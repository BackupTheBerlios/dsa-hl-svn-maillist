<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r3768 - dependencies/opensteer/include/OpenSteer	dependencies/opensteer/plugins dependencies/opensteer/src	modules/common/scripts rl/trunk/engine/ai	rl/trunk/engine/ai/include rl/trunk/engine/ai/src	rl/trunk/engine/rules/include rl/trunk/engine/rules/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3768%20-%20dependencies/opensteer/include/OpenSteer%0A%09dependencies/opensteer/plugins%20dependencies/opensteer/src%0A%09modules/common/scripts%20rl/trunk/engine/ai%0A%09rl/trunk/engine/ai/include%20rl/trunk/engine/ai/src%0A%09rl/trunk/engine/rules/include%20rl/trunk/engine/rules/src&In-Reply-To=%3C200708282121.l7SLLfeH011546%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000838.html">
   <LINK REL="Next"  HREF="000840.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r3768 - dependencies/opensteer/include/OpenSteer	dependencies/opensteer/plugins dependencies/opensteer/src	modules/common/scripts rl/trunk/engine/ai	rl/trunk/engine/ai/include rl/trunk/engine/ai/src	rl/trunk/engine/rules/include rl/trunk/engine/rules/src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3768%20-%20dependencies/opensteer/include/OpenSteer%0A%09dependencies/opensteer/plugins%20dependencies/opensteer/src%0A%09modules/common/scripts%20rl/trunk/engine/ai%0A%09rl/trunk/engine/ai/include%20rl/trunk/engine/ai/src%0A%09rl/trunk/engine/rules/include%20rl/trunk/engine/rules/src&In-Reply-To=%3C200708282121.l7SLLfeH011546%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r3768 - dependencies/opensteer/include/OpenSteer	dependencies/opensteer/plugins dependencies/opensteer/src	modules/common/scripts rl/trunk/engine/ai	rl/trunk/engine/ai/include rl/trunk/engine/ai/src	rl/trunk/engine/rules/include rl/trunk/engine/rules/src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Tue Aug 28 23:21:41 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000838.html">[Dsa-hl-svn] r3767 - modules/common/dsa modules/common/scripts	modules/regressiontest/dsa rl/trunk/engine/rules/include	rl/trunk/engine/rules/src
</A></li>
        <LI>Next message: <A HREF="000840.html">[Dsa-hl-svn] r3769 - in rl/trunk/engine: core script
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#839">[ date ]</a>
              <a href="thread.html#839">[ thread ]</a>
              <a href="subject.html#839">[ subject ]</a>
              <a href="author.html#839">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2007-08-28 23:21:18 +0200 (Tue, 28 Aug 2007)
New Revision: 3768

Added:
   rl/trunk/engine/ai/include/AiMessages.h
Modified:
   dependencies/opensteer/include/OpenSteer/AbstractVehicle.h
   dependencies/opensteer/include/OpenSteer/Camera.h
   dependencies/opensteer/include/OpenSteer/LocalSpace.h
   dependencies/opensteer/include/OpenSteer/SimpleVehicle.h
   dependencies/opensteer/include/OpenSteer/SteerLibrary.h
   dependencies/opensteer/plugins/Boids.cpp
   dependencies/opensteer/plugins/CaptureTheFlag.cpp
   dependencies/opensteer/plugins/LowSpeedTurn.cpp
   dependencies/opensteer/plugins/MapDrive.cpp
   dependencies/opensteer/plugins/MultiplePursuit.cpp
   dependencies/opensteer/plugins/OneTurning.cpp
   dependencies/opensteer/plugins/Pedestrian.cpp
   dependencies/opensteer/plugins/Soccer.cpp
   dependencies/opensteer/src/Camera.cpp
   dependencies/opensteer/src/Draw.cpp
   dependencies/opensteer/src/Obstacle.cpp
   dependencies/opensteer/src/OpenSteerDemo.cpp
   dependencies/opensteer/src/SimpleVehicle.cpp
   modules/common/scripts/npc.rb
   rl/trunk/engine/ai/RlAI2005.vcproj
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/AgentDialogState.cpp
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/rules/include/CreatureController.h
   rl/trunk/engine/rules/src/CreatureController.cpp
Log:
- Adapt OpenSteer to naming conventions
- AgentDialogState moves npc to pc then initiates the dialog

Modified: dependencies/opensteer/include/OpenSteer/AbstractVehicle.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/AbstractVehicle.h	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/include/OpenSteer/AbstractVehicle.h	2007-08-28 21:21:18 UTC (rev 3768)
@@ -57,18 +57,18 @@
         virtual ~AbstractVehicle() { /* Nothing to do. */ }
         
         // mass (defaults to unity so acceleration=force)
-        virtual float mass (void) const = 0;
+        virtual float getMass (void) const = 0;
         virtual float setMass (float) = 0;
 
         // size of bounding sphere, for obstacle avoidance, etc.
-        virtual float radius (void) const = 0;
+        virtual float getRadius (void) const = 0;
         virtual float setRadius (float) = 0;
 
         // velocity of vehicle
-        virtual Vector3 velocity (void) const = 0;
+        virtual Vector3 getVelocity (void) const = 0;
 
         // speed of vehicle  (may be faster than taking magnitude of velocity)
-        virtual float speed (void) const = 0;
+        virtual float getSpeed (void) const = 0;
         virtual float setSpeed (float) = 0;
 
         // groups of (pointers to) abstract vehicles, and iterators over them
@@ -84,11 +84,11 @@
         // XXX of place on the abstract base class, but for now it is expedient
 
         // the maximum steering force this vehicle can apply
-        virtual float maxForce (void) const = 0;
+        virtual float getMaxForce (void) const = 0;
         virtual float setMaxForce (float) = 0;
 
         // the maximum speed this vehicle is allowed to move
-        virtual float maxSpeed (void) const = 0;
+        virtual float getMaxSpeed (void) const = 0;
         virtual float setMaxSpeed (float) = 0;
 
 		// dp - added to support heterogeneous flocks

Modified: dependencies/opensteer/include/OpenSteer/Camera.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Camera.h	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/include/OpenSteer/Camera.h	2007-08-28 21:21:18 UTC (rev 3768)
@@ -113,7 +113,7 @@
         // xxx differently (which is to say, correctly) during mouse adjustment.
         LocalSpace ls;
         const LocalSpace&amp; xxxls (void)
-        {ls.regenerateOrthonormalBasis (target - position(), up()); return ls;}
+        {ls.regenerateOrthonormalBasis (target - getPosition(), getUp()); return ls;}
 
 
         // camera mode selection

Modified: dependencies/opensteer/include/OpenSteer/LocalSpace.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/LocalSpace.h	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/include/OpenSteer/LocalSpace.h	2007-08-28 21:21:18 UTC (rev 3768)
@@ -80,17 +80,17 @@
         
 
         // accessors (get and set) for side, up, forward and position
-        virtual Vector3 side (void) const = 0;
+        virtual Vector3 getSide (void) const = 0;
         virtual Vector3 setSide (Vector3 s) = 0;
-        virtual Vector3 up (void) const = 0;
+        virtual Vector3 getUp (void) const = 0;
         virtual Vector3 setUp (Vector3 u) = 0;
-        virtual Vector3 forward (void) const = 0;
+        virtual Vector3 getForward (void) const = 0;
         virtual Vector3 setForward (Vector3 f) = 0;
-        virtual Vector3 position (void) const = 0;
+        virtual Vector3 getPosition (void) const = 0;
         virtual Vector3 setPosition (Vector3 p) = 0;
 
         // use right-(or left-)handed coordinate space
-        virtual bool rightHanded (void) const = 0;
+        virtual bool isRightHanded(void) const = 0;
 
         // reset transform to identity
         virtual void resetLocalSpace (void) = 0;
@@ -121,7 +121,7 @@
         virtual void regenerateOrthonormalBasis (const Vector3&amp; newForward,
                                                  const Vector3&amp; newUp) = 0;
 
-        // rotate 90 degrees in the direction implied by rightHanded()
+        // rotate 90 degrees in the direction implied by isRightHanded()
         virtual Vector3 localRotateForwardToSide (const Vector3&amp; v) const = 0;
         virtual Vector3 globalRotateForwardToSide (const Vector3&amp; globalForward) const=0;
     };
@@ -149,10 +149,10 @@
     public:
 
         // accessors (get and set) for side, up, forward and position
-        Vector3 side     (void) const {return _side;}
-        Vector3 up       (void) const {return _up;}
-        Vector3 forward  (void) const {return _forward;}
-        Vector3 position (void) const {return _position;}
+        Vector3 getSide     (void) const {return _side;}
+        Vector3 getUp       (void) const {return _up;}
+        Vector3 getForward  (void) const {return _forward;}
+        Vector3 getPosition (void) const {return _position;}
         Vector3 setSide     (Vector3 s) {return _side = s;}
         Vector3 setUp       (Vector3 u) {return _up = u;}
         Vector3 setForward  (Vector3 f) {return _forward = f;}
@@ -168,7 +168,7 @@
         // LocalSpace use a left- or right-handed coordinate system?  This can be
         // overloaded in derived types (e.g. vehicles) to change handedness.
 
-        bool rightHanded (void) const {return true;}
+        bool isRightHanded(void) const {return true;}
 
 
         // ------------------------------------------------------------------------
@@ -192,7 +192,7 @@
                          const Vector3&amp; Position)
             : _side(), _up( Up ), _forward( Forward ), _position( Position )
         {
-            setUnitSideFromForwardAndUp ();
+            setUnitSideFromForwardAndUp();
         }
 
         
@@ -275,7 +275,7 @@
         void setUnitSideFromForwardAndUp (void)
         {
             // derive new unit side basis vector from forward and up
-            if (rightHanded())
+            if (isRightHanded())
                 _side = _forward.crossProduct(_up);
             else
                 _side = _up.crossProduct(_forward);
@@ -293,12 +293,12 @@
             _forward = newUnitForward;
 
             // derive new side basis vector from NEW forward and OLD up
-            setUnitSideFromForwardAndUp ();
+            setUnitSideFromForwardAndUp();
 
             // derive new Up basis vector from new Side and new Forward
             // (should have unit length since Side and Forward are
             // perpendicular and unit length)
-            if (rightHanded())
+            if (isRightHanded())
                 _up = _side.crossProduct(_forward);
             else
                 _up = _forward.crossProduct(_side);
@@ -330,7 +330,7 @@
 
         Vector3 localRotateForwardToSide (const Vector3&amp; v) const
         {
-            return Vector3 (rightHanded () ? -v.z : +v.z,
+            return Vector3 (isRightHanded() ? -v.z : +v.z,
                          v.y,
                          v.x);
         }

Modified: dependencies/opensteer/include/OpenSteer/SimpleVehicle.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/SimpleVehicle.h	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/include/OpenSteer/SimpleVehicle.h	2007-08-28 21:21:18 UTC (rev 3768)
@@ -117,7 +117,7 @@
             setMaxSpeed (1.0f);   // velocity is clipped to this magnitude
 
             // reset bookkeeping to do running averages of these quanities
-            resetSmoothedPosition ();
+            resetSmoothedPosition();
             resetSmoothedCurvature ();
             resetSmoothedAcceleration ();
         }
@@ -127,22 +127,22 @@
         float setMass (float m) {return _mass = m;}
 
         // get velocity of vehicle
-        Vector3 velocity (void) const {return forward() * _speed;}
+        Vector3 velocity (void) const {return getForward() * _speed;}
 
         // get/set speed of vehicle  (may be faster than taking mag of velocity)
-        float speed (void) const {return _speed;}
+        float getSpeed (void) const {return _speed;}
         float setSpeed (float s) {return _speed = s;}
 
         // size of bounding sphere, for obstacle avoidance, etc.
-        float radius (void) const {return _radius;}
+        float getRadius (void) const {return _radius;}
         float setRadius (float m) {return _radius = m;}
 
         // get/set maxForce
-        float maxForce (void) const {return _maxForce;}
+        float getMaxForce (void) const {return _maxForce;}
         float setMaxForce (float mf) {return _maxForce = mf;}
 
         // get/set maxSpeed
-        float maxSpeed (void) const {return _maxSpeed;}
+        float getMaxSpeed (void) const {return _maxSpeed;}
         float setMaxSpeed (float ms) {return _maxSpeed = ms;}
 
 
@@ -215,7 +215,7 @@
         {
             setUp (Vector3::UNIT_Y);
             setForward (RandomUnitVectorOnXZPlane ());
-            setSide (localRotateForwardToSide (forward()));
+            setSide (localRotateForwardToSide (getForward()));
         }
 
     private:

Modified: dependencies/opensteer/include/OpenSteer/SteerLibrary.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/SteerLibrary.h	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/include/OpenSteer/SteerLibrary.h	2007-08-28 21:21:18 UTC (rev 3768)
@@ -64,15 +64,15 @@
     class SteerLibraryMixin : public Super
     {
     public:
-        using Super::velocity;
-        using Super::maxSpeed;
-        using Super::speed;
-        using Super::radius;
-        using Super::maxForce;
-        using Super::forward;
-        using Super::position;
-        using Super::side;
-        using Super::up;
+        using Super::getVelocity;
+        using Super::getMaxSpeed;
+        using Super::getSpeed;
+        using Super::getRadius;
+        using Super::getMaxForce;
+        using Super::getForward;
+        using Super::getPosition;
+        using Super::getSide;
+        using Super::getUp;
         using Super::predictFuturePosition;
         
     public:
@@ -257,19 +257,19 @@
 
         bool isAhead (const Vector3&amp; target, float cosThreshold) const
         {
-            const Vector3 targetDirection = (target - position ()).normalisedCopy();
-            return forward().dotProduct(targetDirection) &gt; cosThreshold;
+            const Vector3 targetDirection = (target - getPosition()).normalisedCopy();
+            return getForward().dotProduct(targetDirection) &gt; cosThreshold;
         };
         bool isAside (const Vector3&amp; target, float cosThreshold) const
         {
-            const Vector3 targetDirection = (target - position ()).normalisedCopy();
-            const float dp = forward().dotProduct(targetDirection);
+            const Vector3 targetDirection = (target - getPosition()).normalisedCopy();
+            const float dp = getForward().dotProduct(targetDirection);
             return (dp &lt; cosThreshold) &amp;&amp; (dp &gt; -cosThreshold);
         };
         bool isBehind (const Vector3&amp; target, float cosThreshold) const
         {
-            const Vector3 targetDirection = (target - position()).normalisedCopy();
-            return forward().dotProduct(targetDirection) &lt; cosThreshold;
+            const Vector3 targetDirection = (target - getPosition()).normalisedCopy();
+            return getForward().dotProduct(targetDirection) &lt; cosThreshold;
         };
 
 
@@ -326,7 +326,7 @@
     WanderUp   = scalarRandomWalk (WanderUp,   speed, -1, +1);
 
     // return a pure lateral steering vector: (+/-Side) + (+/-Up)
-    return (side() * WanderSide) + (up() * WanderUp);
+    return (getSide() * WanderSide) + (getUp() * WanderUp);
 }
 
 
@@ -339,8 +339,8 @@
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerForSeek (const Vector3&amp; target)
 {
-    const Vector3 desiredVelocity = target - position();
-    return desiredVelocity - velocity();
+    const Vector3 desiredVelocity = target - getPosition();
+    return desiredVelocity - getVelocity();
 }
 
 
@@ -353,8 +353,8 @@
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerForFlee (const Vector3&amp; target)
 {
-    const Vector3 desiredVelocity = position() - target;
-    return desiredVelocity - velocity();
+    const Vector3 desiredVelocity = getPosition() - target;
+    return desiredVelocity - getVelocity();
 }
 
 
@@ -368,9 +368,9 @@
 xxxsteerForFlee (const Vector3&amp; target)
 {
 //  const Vector3 offset = position - target;
-    const Vector3 offset = position() - target;
-    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, maxSpeed()); //xxxnew
-    return desiredVelocity - velocity();
+    const Vector3 offset = getPosition() - target;
+    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, getMaxSpeed()); //xxxnew
+    return desiredVelocity - getVelocity();
 }
 
 
@@ -380,9 +380,9 @@
 xxxsteerForSeek (const Vector3&amp; target)
 {
 //  const Vector3 offset = target - position;
-    const Vector3 offset = target - position();
-    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, maxSpeed()); //xxxnew
-    return desiredVelocity - velocity();
+    const Vector3 offset = target - getPosition();
+    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, getMaxSpeed()); //xxxnew
+    return desiredVelocity - getVelocity();
 }
 
 
@@ -430,14 +430,14 @@
                    Pathway&amp; path)
 {
     // our goal will be offset from our path distance by this amount
-    const float pathDistanceOffset = direction * predictionTime * speed();
+    const float pathDistanceOffset = direction * predictionTime * getSpeed();
 
     // predict our future position
     const Vector3 futurePosition = predictFuturePosition (predictionTime);
 
     // measure distance along path of our current and predicted positions
     const float nowPathDistance =
-        path.mapPointToPathDistance (position ());
+        path.mapPointToPathDistance (getPosition());
     const float futurePathDistance =
         path.mapPointToPathDistance (futurePosition);
 
@@ -511,7 +511,7 @@
 
     // XXX more annotation modularity problems (assumes spherical obstacle)
     if (avoidance != Vector3::ZERO)
-        annotateAvoidObstacle (minTimeToCollision * speed());
+        annotateAvoidObstacle (minTimeToCollision * getSpeed());
 
     return avoidance;
 }
@@ -531,7 +531,7 @@
 
     // XXX more annotation modularity problems (assumes spherical obstacle)
     if (avoidance != Vector3::ZERO)
-        annotateAvoidObstacle (minTimeToCollision * speed());
+        annotateAvoidObstacle (minTimeToCollision * getSpeed());
 
     return avoidance;
 }
@@ -576,7 +576,7 @@
         if (&amp;other != this)
         {	
             // avoid when future positions are this close (or less)
-            const float collisionDangerThreshold = radius() * 2;
+            const float collisionDangerThreshold = getRadius() * 2;
 
             // predicted time until nearest approach of &quot;this&quot; and &quot;other&quot;
             const float time = predictNearestApproachTime (other);
@@ -605,15 +605,15 @@
     if (threat != NULL)
     {
         // parallel: +1, perpendicular: 0, anti-parallel: -1
-        float parallelness = forward().dotProduct(threat-&gt;forward());
+        float parallelness = getForward().dotProduct(threat-&gt;getForward());
         float angle = 0.707f;
 
         if (parallelness &lt; -angle)
         {
             // anti-parallel &quot;head on&quot; paths:
             // steer away from future threat position
-            Vector3 offset = xxxThreatPositionAtNearestApproach - position();
-            float sideDot = offset.dotProduct(side());
+            Vector3 offset = xxxThreatPositionAtNearestApproach - getPosition();
+            float sideDot = offset.dotProduct(getSide());
             steer = (sideDot &gt; 0) ? -1.0f : 1.0f;
         }
         else
@@ -621,17 +621,17 @@
             if (parallelness &gt; angle)
             {
                 // parallel paths: steer away from threat
-                Vector3 offset = threat-&gt;position() - position();
-                float sideDot = offset.dotProduct(side());
+                Vector3 offset = threat-&gt;getPosition() - getPosition();
+                float sideDot = offset.dotProduct(getSide());
                 steer = (sideDot &gt; 0) ? -1.0f : 1.0f;
             }
             else
             {
                 // perpendicular paths: steer behind threat
                 // (only the slower of the two does this)
-                if (threat-&gt;speed() &lt;= speed())
+                if (threat-&gt;getSpeed() &lt;= getSpeed())
                 {
-                    float sideDot = side().dotProduct(threat-&gt;velocity());
+                    float sideDot = getSide().dotProduct(threat-&gt;getVelocity());
                     steer = (sideDot &gt; 0) ? -1.0f : 1.0f;
                 }
             }
@@ -643,7 +643,7 @@
                                xxxThreatPositionAtNearestApproach);
     }
 
-    return side() * steer;
+    return getSide() * steer;
 }
 
 
@@ -660,8 +660,8 @@
 {
     // imagine we are at the origin with no velocity,
     // compute the relative velocity of the other vehicle
-    const Vector3 myVelocity = velocity();
-    const Vector3 otherVelocity = otherVehicle.velocity();
+    const Vector3 myVelocity = getVelocity();
+    const Vector3 otherVelocity = otherVehicle.getVelocity();
     const Vector3 relVelocity = otherVelocity - myVelocity;
     const float relSpeed = relVelocity.length();
 
@@ -679,7 +679,7 @@
 
     // find distance from its path to origin (compute offset from
     // other to us, find length of projection onto path)
-    const Vector3 relPosition = position() - otherVehicle.position();
+    const Vector3 relPosition = getPosition() - otherVehicle.getPosition();
     const float projection = relTangent.dotProduct(relPosition);
 
     return projection / relSpeed;
@@ -697,11 +697,11 @@
 computeNearestApproachPositions (AbstractVehicle&amp; otherVehicle,
                                  float time)
 {
-    const Vector3    myTravel =       forward () *       speed () * time;
-    const Vector3 otherTravel = otherVehicle.forward () * otherVehicle.speed () * time;
+    const Vector3    myTravel =       getForward() *       getSpeed() * time;
+    const Vector3 otherTravel = otherVehicle.getForward() * otherVehicle.getSpeed () * time;
 
-    const Vector3    myFinal =       position () +    myTravel;
-    const Vector3 otherFinal = otherVehicle.position () + otherTravel;
+    const Vector3    myFinal =       getPosition() +    myTravel;
+    const Vector3 otherFinal = otherVehicle.getPosition() + otherTravel;
 
     // xxx for annotation
     ourPositionAtNearestApproach = myFinal;
@@ -732,15 +732,15 @@
         AbstractVehicle&amp; other = **i;
         if (&amp;other != this)
         {
-            const float sumOfRadii = radius() + other.radius();
+            const float sumOfRadii = getRadius() + other.getRadius();
             const float minCenterToCenter = minSeparationDistance + sumOfRadii;
-            const Vector3 offset = other.position() - position();
+            const Vector3 offset = other.getPosition() - getPosition();
             const float currentDistance = offset.length();
 
             if (currentDistance &lt; minCenterToCenter)
             {
                 annotateAvoidCloseNeighbor (other, minSeparationDistance);
-                return Vec3Utils::perpendicularComponent(-offset, forward());
+                return Vec3Utils::perpendicularComponent(-offset, getForward());
             }
         }
     }
@@ -768,7 +768,7 @@
     }
     else
     {
-        const Vector3 offset = otherVehicle.position() - position();
+        const Vector3 offset = otherVehicle.getPosition() - getPosition();
         const float distanceSquared = offset.squaredLength();
 
         // definitely in neighborhood if inside minDistance sphere
@@ -787,7 +787,7 @@
             {
                 // otherwise, test angular offset from forward axis
                 const Vector3 unitOffset = offset / sqrt (distanceSquared);
-                const float forwardness = forward().dotProduct(unitOffset);
+                const float forwardness = getForward().dotProduct(unitOffset);
                 return forwardness &gt; cosMaxAngle;
             }
         }
@@ -814,12 +814,12 @@
     AVIterator flockEndIter = flock.end();
     for (AVIterator otherVehicle = flock.begin(); otherVehicle != flockEndIter; ++otherVehicle )
     {
-        if (inBoidNeighborhood (**otherVehicle, radius()*3, maxDistance, cosMaxAngle))
+        if (inBoidNeighborhood (**otherVehicle, getRadius()*3, maxDistance, cosMaxAngle))
         {
             // add in steering contribution
             // (opposite of the offset direction, divided once by distance
             // to normalize, divided another time to get 1/d falloff)
-            const Vector3 offset = (**otherVehicle).position() - position();
+            const Vector3 offset = (**otherVehicle).getPosition() - getPosition();
             const float distanceSquared = offset.dotProduct(offset);
             steering += (offset / -distanceSquared);
 
@@ -862,10 +862,10 @@
     // for each of the other vehicles...
     for (AVIterator otherVehicle = flock.begin(); otherVehicle != flock.end(); otherVehicle++)
     {
-        if (inBoidNeighborhood (**otherVehicle, radius()*3, maxDistance, cosMaxAngle))
+        if (inBoidNeighborhood (**otherVehicle, getRadius()*3, maxDistance, cosMaxAngle))
         {
             // accumulate sum of neighbor's heading
-            steering += (**otherVehicle).forward();
+            steering += (**otherVehicle).getForward();
 
             // count neighbors
             neighbors++;
@@ -874,7 +874,7 @@
 
     // divide by neighbors, subtract off current heading to get error-
     // correcting direction, then normalize to pure direction
-    if (neighbors &gt; 0) steering = ((steering / (float)neighbors) - forward()).normalisedCopy();
+    if (neighbors &gt; 0) steering = ((steering / (float)neighbors) - getForward()).normalisedCopy();
 
     return steering;
 }
@@ -899,10 +899,10 @@
     // for each of the other vehicles...
     for (AVIterator otherVehicle = flock.begin(); otherVehicle != flock.end(); otherVehicle++)
     {
-        if (inBoidNeighborhood (**otherVehicle, radius()*3, maxDistance, cosMaxAngle))
+        if (inBoidNeighborhood (**otherVehicle, getRadius()*3, maxDistance, cosMaxAngle))
         {
             // accumulate sum of neighbor's positions
-            steering += (**otherVehicle).position();
+            steering += (**otherVehicle).getPosition();
 
             // count neighbors
             neighbors++;
@@ -911,7 +911,7 @@
 
     // divide by neighbors, subtract off current position to get error-
     // correcting direction, then normalize to pure direction
-    if (neighbors &gt; 0) steering = ((steering / (float)neighbors) - position()).normalisedCopy();
+    if (neighbors &gt; 0) steering = ((steering / (float)neighbors) - getPosition()).normalisedCopy();
 
     return steering;
 }
@@ -937,19 +937,19 @@
                  const float maxPredictionTime)
 {
     // offset from this to quarry, that distance, unit vector toward quarry
-    const Vector3 offset = quarry.position() - position();
+    const Vector3 offset = quarry.getPosition() - getPosition();
     const float distance = offset.length ();
     const Vector3 unitOffset = offset / distance;
 
     // how parallel are the paths of &quot;this&quot; and the quarry
     // (1 means parallel, 0 is pependicular, -1 is anti-parallel)
-    const float parallelness = forward().dotProduct(quarry.forward());
+    const float parallelness = getForward().dotProduct(quarry.getForward());
 
     // how &quot;forward&quot; is the direction to the quarry
     // (1 means dead ahead, 0 is directly to the side, -1 is straight back)
-    const float forwardness = forward().dotProduct(unitOffset);
+    const float forwardness = getForward().dotProduct(unitOffset);
 
-    const float directTravelTime = distance / speed ();
+    const float directTravelTime = distance / getSpeed();
     const int f = intervalComparison (forwardness,  -0.707f, 0.707f);
     const int p = intervalComparison (parallelness, -0.707f, 0.707f);
 
@@ -1024,7 +1024,7 @@
     const Vector3 target = quarry.predictFuturePosition (etl);
 
     // annotation
-/*    annotationLine (position(),
+/*    annotationLine (getPosition(),
                     target,
                     gaudyPursuitAnnotation ? color : gGray40);
 */
@@ -1042,17 +1042,17 @@
                  const float maxPredictionTime)
 {
     // offset from this to menace, that distance, unit vector toward menace
-    const Vector3 offset = menace.position() - position();
+    const Vector3 offset = menace.getPosition() - getPosition();
     const float distance = offset.length ();
 
-    const float roughTime = distance / menace.speed();
+    const float roughTime = distance / menace.getSpeed();
     const float predictionTime = ((roughTime &gt; maxPredictionTime) ?
                                   maxPredictionTime :
                                   roughTime);
 
-    const Vector3 target = menace.predictFuturePosition (predictionTime);
+    const Vector3 target = menace.predictFuturePosition(predictionTime);
 
-    return steerForFlee (target);
+    return steerForFlee(target);
 }
 
 
@@ -1066,9 +1066,9 @@
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerForTargetSpeed (const float targetSpeed)
 {
-    const float mf = maxForce ();
-    const float speedError = targetSpeed - speed ();
-    return forward () * clip (speedError, -mf, +mf);
+    const float mf = getMaxForce();
+    const float speedError = targetSpeed - getSpeed();
+    return getForward() * clip (speedError, -mf, +mf);
 }
 
 

Modified: dependencies/opensteer/plugins/Boids.cpp
===================================================================
--- dependencies/opensteer/plugins/Boids.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/plugins/Boids.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -113,7 +113,7 @@
             setMaxSpeed (9);
 
             // initial slow speed
-            setSpeed (maxSpeed() * 0.3f);
+            setSpeed (getMaxSpeed() * 0.3f);
 
             // randomize initial orientation
             regenerateOrthonormalBasisUF (RandomUnitVector ());
@@ -122,7 +122,7 @@
             setPosition (RandomVectorInUnitRadiusSphere () * 20);
 
             // notify proximity database that our position has changed
-            proximityToken-&gt;updateForNewPosition (position());
+            proximityToken-&gt;updateForNewPosition (getPosition());
         }
 
 
@@ -146,7 +146,7 @@
             sphericalWrapAround ();
 
             // notify proximity database that our position has changed
-            proximityToken-&gt;updateForNewPosition (position());
+            proximityToken-&gt;updateForNewPosition (getPosition());
         }
 
 
@@ -176,7 +176,7 @@
 
             // find all flockmates within maxRadius using proximity database
             neighbors.clear();
-            proximityToken-&gt;findNeighbors (position(), maxRadius, neighbors);
+            proximityToken-&gt;findNeighbors (getPosition(), maxRadius, neighbors);
 
     #ifndef NO_LQ_BIN_STATS
             // maintain stats on max/min/ave neighbors per boids
@@ -216,10 +216,10 @@
         void sphericalWrapAround (void)
         {
             // when outside the sphere
-            if (position().length() &gt; worldRadius)
+            if (getPosition().length() &gt; worldRadius)
             {
                 // wrap around (teleport)
-                setPosition (position().sphericalWrapAround (Vector3::ZERO,
+                setPosition (getPosition().sphericalWrapAround (Vector3::ZERO,
                                                              worldRadius));
                 if (this == OpenSteerDemo::selectedVehicle)
                 {
@@ -252,7 +252,7 @@
         {
 
             // XXX this is special case code, these should be derived from arguments //
-            const Vector3 surfaceNormal = position().normalisedCopy();                       //
+            const Vector3 surfaceNormal = getPosition().normalisedCopy();                       //
             const Vector3 surfacePoint = surfaceNormal * 40.0f;                         //
             // XXX this is special case code, these should be derived from arguments //
 
@@ -266,7 +266,7 @@
             setPosition (newPos);
             setUp (newUp);
             setForward (newFor);
-            setUnitSideFromForwardAndUp ();
+            setUnitSideFromForwardAndgetUp();
         }
     // ---------------------------------------------- xxxcwr111704_terrain_following
 
@@ -298,12 +298,12 @@
         // xxx CaptureTheFlag.cpp
         void annotateAvoidObstacle (const float minDistanceToCollision)
         {
-            const Vector3 boxSide = side() * radius();
-            const Vector3 boxFront = forward() * minDistanceToCollision;
-            const Vector3 FR = position() + boxFront - boxSide;
-            const Vector3 FL = position() + boxFront + boxSide;
-            const Vector3 BR = position()            - boxSide;
-            const Vector3 BL = position()            + boxSide;
+            const Vector3 boxSide = getSide() * radius();
+            const Vector3 boxFront = getForward() * minDistanceToCollision;
+            const Vector3 FR = getPosition() + boxFront - boxSide;
+            const Vector3 FL = getPosition() + boxFront + boxSide;
+            const Vector3 BR = getPosition()            - boxSide;
+            const Vector3 BL = getPosition()            + boxSide;
             const Color white (1,1,1);
             annotationLine (FR, FL, white);
             annotationLine (FL, BL, white);
@@ -727,7 +727,7 @@
                             ((*o == &amp;insideBigSphere) ?
                              Color (0.2f, 0.2f, 0.4f) :
                              Color (0.1f, 0.1f, 0.2f)),
-                            OpenSteerDemo::camera.position ());
+                            OpenSteerDemo::camera.getPosition());
             }
         }
 
@@ -754,10 +754,10 @@
             const float w = box.width / 2;
             const float h = box.height / 2;
             const float d = box.depth / 2;
-            const Vector3 p = box.position ();
-            const Vector3 s = box.side ();
-            const Vector3 u = box.up ();
-            const Vector3 f = box.forward ();
+            const Vector3 p = box.getPosition();
+            const Vector3 s = box.getSide();
+            const Vector3 u = box.getUp();
+            const Vector3 f = box.getForward();
 
             const Vector3 v1 = box.globalizePosition (Vector3 ( w,  h,  d));
             const Vector3 v2 = box.globalizePosition (Vector3 (-w,  h,  d));

Modified: dependencies/opensteer/plugins/CaptureTheFlag.cpp
===================================================================
--- dependencies/opensteer/plugins/CaptureTheFlag.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/plugins/CaptureTheFlag.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -265,7 +265,7 @@
         setPosition (gHomeBaseCenter + randomOnRing);
 
         // are we are too close to an obstacle?
-        if (minDistanceToObstacle (position()) &lt; radius()*5)
+        if (minDistanceToObstacle (getPosition()) &lt; radius()*5)
         {
             // if so, retry the randomization (this recursive call may not return
             // if there is too little free space)
@@ -286,11 +286,11 @@
     {
         // determine upper bound for pursuit prediction time
         const float seekerToGoalDist = Vector3::distance (gHomeBaseCenter,
-                                                       gSeeker-&gt;position());
+                                                       gSeeker-&gt;getPosition());
         const float adjustedDistance = seekerToGoalDist - radius()-gHomeBaseRadius;
         const float seekerToGoalTime = ((adjustedDistance &lt; 0 ) ?
                                         0 :
-                                        (adjustedDistance/gSeeker-&gt;speed()));
+                                        (adjustedDistance/gSeeker-&gt;getSpeed()));
         const float maxPredictionTime = seekerToGoalTime * 0.9f;
 
         // determine steering (pursuit, obstacle avoidance, or braking)
@@ -317,12 +317,12 @@
 
         // annotation
         annotationVelocityAcceleration ();
-        recordTrailVertex (currentTime, position());
+        recordTrailVertex (currentTime, getPosition());
 
 
         // detect and record interceptions (&quot;tags&quot;) of seeker
-        const float seekerToMeDist = Vector3::distance (position(), 
-                                                     gSeeker-&gt;position());
+        const float seekerToMeDist = Vector3::distance (getPosition(), 
+                                                     gSeeker-&gt;getPosition());
         const float sumOfRadii = radius() + gSeeker-&gt;radius();
         if (seekerToMeDist &lt; sumOfRadii)
         {
@@ -333,7 +333,7 @@
             {
                 const Color color (0.8f, 0.5f, 0.5f);
                 annotationXZDisk (sumOfRadii,
-                            (position() + gSeeker-&gt;position()) / 2,
+                            (getPosition() + gSeeker-&gt;getPosition()) / 2,
                             color,
                             20);
             }
@@ -350,7 +350,7 @@
         const float sideThreshold = radius() * 8.0f;
         const float behindThreshold = radius() * 2.0f;
 
-        const Vector3 goalOffset = gHomeBaseCenter - position();
+        const Vector3 goalOffset = gHomeBaseCenter - getPosition();
         const float goalDistance = goalOffset.length ();
         const Vector3 goalDirection = goalOffset / goalDistance;
 
@@ -364,17 +364,17 @@
         {
             // short name for this enemy
             const CtfEnemy&amp; e = *ctfEnemies[i];
-            const float eDistance = Vector3::distance (position(), e.position());
-            const float timeEstimate = 0.3f * eDistance / e.speed(); //xxx
+            const float eDistance = Vector3::distance (getPosition(), e.getPosition());
+            const float timeEstimate = 0.3f * eDistance / e.getSpeed(); //xxx
             const Vector3 eFuture = e.predictFuturePosition (timeEstimate);
-            const Vector3 eOffset = eFuture - position();
+            const Vector3 eOffset = eFuture - getPosition();
             const float alongCorridor = goalDirection.dotProduct(eOffset);
             const bool inCorridor = ((alongCorridor &gt; -behindThreshold) &amp;&amp; 
                                      (alongCorridor &lt; goalDistance));
-            const float eForwardDistance = forward().dotProduct(eOffset);
+            const float eForwardDistance = getForward().dotProduct(eOffset);
 
             // xxx temp move this up before the conditionals
-            annotationXZCircle (e.radius(), eFuture, clearPathColor, 20); //xxx
+            annotationXZCircle (e.getRadius(), eFuture, clearPathColor, 20); //xxx
 
             // consider as potential blocker if within the corridor
             if (inCorridor)
@@ -384,7 +384,7 @@
                 if (acrossCorridor &lt; sideThreshold)
                 {
                     // not a blocker if behind us and we are perp to corridor
-                    const float eFront = eForwardDistance + e.radius ();
+                    const float eFront = eForwardDistance + e.getRadius();
 
                     //annotationLine (position, forward*eFront, gGreen); // xxx
                     //annotationLine (e.position, forward*eFront, gGreen); // xxx
@@ -403,7 +403,7 @@
                     if (! safeToTurnTowardsGoal)
                     {
                         // this enemy blocks the path to the goal, so return false
-                        annotationLine (position(), e.position(), clearPathColor);
+                        annotationLine (getPosition(), e.getPosition(), clearPathColor);
                         // return false;
                         xxxReturn = false;
                     }
@@ -427,9 +427,9 @@
                                          const float behindThreshold,
                                          const Vector3&amp; goalDirection)
     {
-        const Vector3 behindSide = side() * sideThreshold;
-        const Vector3 behindBack = forward() * -behindThreshold;
-        const Vector3 pbb = position() + behindBack;
+        const Vector3 behindSide = getSide() * sideThreshold;
+        const Vector3 behindBack = getForward() * -behindThreshold;
+        const Vector3 pbb = getPosition() + behindBack;
         const Vector3 gun = localRotateForwardToSide (goalDirection);
         const Vector3 gn = gun * sideThreshold;
         const Vector3 hbc = gHomeBaseCenter;
@@ -448,12 +448,12 @@
 
     void CtfBase::annotateAvoidObstacle (const float minDistanceToCollision)
     {
-        const Vector3 boxSide = side() * radius();
-        const Vector3 boxFront = forward() * minDistanceToCollision;
-        const Vector3 FR = position() + boxFront - boxSide;
-        const Vector3 FL = position() + boxFront + boxSide;
-        const Vector3 BR = position()            - boxSide;
-        const Vector3 BL = position()            + boxSide;
+        const Vector3 boxSide = getSide() * radius();
+        const Vector3 boxFront = getForward() * minDistanceToCollision;
+        const Vector3 FR = getPosition() + boxFront - boxSide;
+        const Vector3 FL = getPosition() + boxFront + boxSide;
+        const Vector3 BR = getPosition()            - boxSide;
+        const Vector3 BL = getPosition()            + boxSide;
         const Color white (1,1,1);
         annotationLine (FR, FL, white);
         annotationLine (FL, BL, white);
@@ -468,16 +468,16 @@
     Vector3 CtfSeeker::steerToEvadeAllDefenders (void)
     {
         Vector3 evade (0, 0, 0);
-        const float goalDistance = Vector3::distance (gHomeBaseCenter, position());
+        const float goalDistance = Vector3::distance (gHomeBaseCenter, getPosition());
 
         // sum up weighted evasion
         for (int i = 0; i &lt; ctfEnemyCount; i++)
         {
             const CtfEnemy&amp; e = *ctfEnemies[i];
-            const Vector3 eOffset = e.position() - position();
+            const Vector3 eOffset = e.getPosition() - getPosition();
             const float eDistance = eOffset.length();
 
-            const float eForwardDistance = forward().dotProduct(eOffset);
+            const float eForwardDistance = getForward().dotProduct(eOffset);
             const float behindThreshold = radius() * 2;
             const bool behind = eForwardDistance &lt; behindThreshold;
             if ((!behind) || (eDistance &lt; 5))
@@ -485,14 +485,14 @@
                 if (eDistance &lt; (goalDistance * 1.2)) //xxx
                 {
                     // const float timeEstimate = 0.5f * eDistance / e.speed;//xxx
-                    const float timeEstimate = 0.15f * eDistance / e.speed();//xxx
+                    const float timeEstimate = 0.15f * eDistance / e.getSpeed();//xxx
                     const Vector3 future =
                         e.predictFuturePosition (timeEstimate);
 
-                    annotationXZCircle (e.radius(), future, evadeColor, 20); // xxx
+                    annotationXZCircle (e.getRadius(), future, evadeColor, 20); // xxx
 
-                    const Vector3 offset = future - position();
-                    const Vector3 lateral = offset.perpendicularComponent (forward());
+                    const Vector3 offset = future - getPosition();
+                    const Vector3 lateral = offset.perpendicularComponent (getForward());
                     const float d = lateral.length();
                     const float weight = -1000 / (d * d);
                     evade += (lateral / d) * weight;
@@ -510,20 +510,20 @@
         for (int i = 0; i &lt; ctfEnemyCount; i++)
         {
             const CtfEnemy&amp; e = *ctfEnemies[i];
-            const Vector3 eOffset = e.position() - position();
+            const Vector3 eOffset = e.getPosition() - getPosition();
             const float eDistance = eOffset.length();
 
             // xxx maybe this should take into account e's heading? xxx
-            const float timeEstimate = 0.5f * eDistance / e.speed(); //xxx
+            const float timeEstimate = 0.5f * eDistance / e.getSpeed(); //xxx
             const Vector3 eFuture = e.predictFuturePosition (timeEstimate);
 
             // annotation
-            annotationXZCircle (e.radius(), eFuture, evadeColor, 20);
+            annotationXZCircle (e.getRadius(), eFuture, evadeColor, 20);
 
             // steering to flee from eFuture (enemy's future position)
             const Vector3 flee = xxxsteerForFlee (eFuture);
 
-            const float eForwardDistance = forward().dotProduct(eOffset);
+            const float eForwardDistance = getForward().dotProduct(eOffset);
             const float behindThreshold = radius() * -2;
 
             const float distanceWeight = 4 / eDistance;
@@ -567,9 +567,9 @@
                 // we have a clear path (defender-free corridor), use pure seek
 
                 // xxx experiment 9-16-02
-                Vector3 s = limitMaxDeviationAngle (seek, 0.707f, forward());
+                Vector3 s = limitMaxDeviationAngle (seek, 0.707f, getForward());
 
-                annotationLine (position(), position() + (s * 0.2f), seekColor);
+                annotationLine (getPosition(), getPosition() + (s * 0.2f), seekColor);
                 return s;
             }
             else
@@ -579,10 +579,10 @@
                     // combine seek and (forward facing portion of) evasion
                     const Vector3 evade = steerToEvadeAllDefenders ();
                     const Vector3 steer = 
-                        seek + limitMaxDeviationAngle (evade, 0.5f, forward());
+                        seek + limitMaxDeviationAngle (evade, 0.5f, getForward());
 
                     // annotation: show evasion steering force
-                    annotationLine (position(),position()+(steer*0.2f),evadeColor);
+                    annotationLine (getPosition(),getPosition()+(steer*0.2f),evadeColor);
                     return steer;
                 }
                 else
@@ -590,13 +590,13 @@
                 {
                     const Vector3 evade = XXXsteerToEvadeAllDefenders ();
                     const Vector3 steer = limitMaxDeviationAngle (seek + evade,
-                                                               0.707f, forward());
+                                                               0.707f, getForward());
 
-                    annotationLine (position(),position()+seek, gRed);
-                    annotationLine (position(),position()+evade, gGreen);
+                    annotationLine (getPosition(),getPosition()+seek, gRed);
+                    annotationLine (getPosition(),getPosition()+evade, gGreen);
 
                     // annotation: show evasion steering force
-                    annotationLine (position(),position()+(steer*0.2f),evadeColor);
+                    annotationLine (getPosition(),getPosition()+(steer*0.2f),evadeColor);
                     return steer;
                 }
             }
@@ -614,9 +614,9 @@
         if (clearPath)
         {
             evading = false;
-            const float goalDistance = Vector3::distance (gHomeBaseCenter,position());
+            const float goalDistance = Vector3::distance (gHomeBaseCenter,getPosition());
             const bool headingTowardGoal = isAhead (gHomeBaseCenter, 0.98f);
-            const bool isNear = (goalDistance/speed()) &lt; gAvoidancePredictTimeMax;
+            const bool isNear = (goalDistance/getSpeed()) &lt; gAvoidancePredictTimeMax;
             const bool useMax = headingTowardGoal &amp;&amp; !isNear;
             gAvoidancePredictTime =
                 (useMax ? gAvoidancePredictTimeMax : gAvoidancePredictTimeMin);
@@ -637,7 +637,7 @@
         // if we reach the goal before being tagged, switch to atGoal state
         if (state == running)
         {
-            const float baseDistance = Vector3::distance (position(),gHomeBaseCenter);
+            const float baseDistance = Vector3::distance (getPosition(),gHomeBaseCenter);
             if (baseDistance &lt; (radius() + gHomeBaseRadius)) state = atGoal;
         }
 
@@ -684,11 +684,11 @@
         }
 
         // annote seeker with its state as text
-        const Vector3 textOrigin = position() + Vector3 (0, 0.25, 0);
+        const Vector3 textOrigin = getPosition() + Vector3 (0, 0.25, 0);
         std::ostringstream annote;
         annote &lt;&lt; seekerStateString &lt;&lt; std::endl;
         annote &lt;&lt; std::setprecision(2) &lt;&lt; std::setiosflags(std::ios::fixed)
-               &lt;&lt; speed() &lt;&lt; std::ends;
+               &lt;&lt; getSpeed() &lt;&lt; std::ends;
         draw2dTextAt3dLocation (annote, textOrigin, gWhite, drawGetWindowWidth(), drawGetWindowHeight());
 
         // display status in the upper left corner of the window
@@ -725,7 +725,7 @@
 
         // annotation
         annotationVelocityAcceleration ();
-        recordTrailVertex (currentTime, position());
+        recordTrailVertex (currentTime, getPosition());
     }
 
 
@@ -878,13 +878,13 @@
             OpenSteerDemo::updateCamera (currentTime, elapsedTime, selected);
 
             // draw &quot;ground plane&quot; centered between base and selected vehicle
-            const Vector3 goalOffset = gHomeBaseCenter-OpenSteerDemo::camera.position();
+            const Vector3 goalOffset = gHomeBaseCenter-OpenSteerDemo::camera.getPosition();
             const Vector3 goalDirection = goalOffset.normalisedCopy();
-            const Vector3 cameraForward = OpenSteerDemo::camera.xxxls().forward();
+            const Vector3 cameraForward = OpenSteerDemo::camera.xxxls().getForward();
             const float goalDot = cameraForward.dotProduct(goalDirection);
             const float blend = remapIntervalClip (goalDot, 1, 0, 0.5, 0);
             const Vector3 gridCenter = interpolate (blend,
-                                                 selected.position(),
+                                                 selected.getPosition(),
                                                  gHomeBaseCenter);
             OpenSteerDemo::gridUtility (gridCenter);
 

Modified: dependencies/opensteer/plugins/LowSpeedTurn.cpp
===================================================================
--- dependencies/opensteer/plugins/LowSpeedTurn.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/plugins/LowSpeedTurn.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -102,7 +102,7 @@
 
             // annotation
             annotationVelocityAcceleration ();
-            recordTrailVertex (currentTime, position());
+            recordTrailVertex (currentTime, getPosition());
         }
 
         // reset starting positions
@@ -188,7 +188,7 @@
             OpenSteerDemo::updateCamera (currentTime, elapsedTime, selected);
 
             // draw &quot;ground plane&quot;
-            OpenSteerDemo::gridUtility (selected.position());
+            OpenSteerDemo::gridUtility (selected.getPosition());
           
             // update, draw and annotate each agent
             for (iterator i = all.begin(); i != all.end(); i++)
@@ -200,11 +200,11 @@
                 // display speed near agent's screen position
                 const Color textColor (0.8f, 0.8f, 1.0f);
                 const Vector3 textOffset (0, 0.25f, 0);
-                const Vector3 textPosition = agent.position() + textOffset;
+                const Vector3 textPosition = agent.getPosition() + textOffset;
                 std::ostringstream annote;
                 annote &lt;&lt; std::setprecision (2)
                        &lt;&lt; std::setiosflags (std::ios::fixed)
-                       &lt;&lt; agent.speed()
+                       &lt;&lt; agent.getSpeed()
                        &lt;&lt; std::ends;
                 draw2dTextAt3dLocation (annote, textPosition, textColor, drawGetWindowWidth(), drawGetWindowHeight());
             }

Modified: dependencies/opensteer/plugins/MapDrive.cpp
===================================================================
--- dependencies/opensteer/plugins/MapDrive.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/plugins/MapDrive.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -919,8 +919,8 @@
                     {
                         const Vector3 wander = steerForWander (elapsedTime);
                         const Vector3 flat = wander.setYtoZero ();
-                        const Vector3 weighted = flat.truncateLength (maxForce()) * 6;
-                        const Vector3 a = position() + Vector3 (0, 0.2f, 0);
+                        const Vector3 weighted = flat.truncateLength (getMaxForce()) * 6;
+                        const Vector3 a = getPosition() + Vector3 (0, 0.2f, 0);
                         annotationLine (a, a + (weighted * 0.3f), gWhite);
                         steering += weighted;
                     }
@@ -934,7 +934,7 @@
                         if (pf != Vector3::ZERO)
                         {
                             // steer to remain on path
-                            if (pf.dotProduct(forward()) &lt; 0)
+                            if (pf.dotProduct(getForward()) &lt; 0)
                                 steering = pf;
                             else
                                 steering = pf + steering;
@@ -943,17 +943,17 @@
                         {
                             // path aligment: when neither obstacle avoidance nor
                             // path following is required, align with path segment
-                            const Vector3 pathHeading = mapPointAndDirectionToTangent( *path, position(), pathFollowDirection ); // path-&gt;tangentAt (position (), pathFollowDirection);
+                            const Vector3 pathHeading = mapPointAndDirectionToTangent( *path, getPosition(), pathFollowDirection ); // path-&gt;tangentAt (getPosition(), pathFollowDirection);
                             {
-                                const Vector3 b = (position () +
-                                                (up () * 0.2f) +
-                                                (forward () * halfLength * 1.4f));
+                                const Vector3 b = (getPosition() +
+                                                (getUp() * 0.2f) +
+                                                (getForward() * halfLength * 1.4f));
                                 const float l = 2;
-                                annotationLine (b, b + (forward ()  * l), gCyan);
+                                annotationLine (b, b + (getForward()  * l), gCyan);
                                 annotationLine (b, b + (pathHeading * l), gCyan);
                             }
                             steering += (steerTowardHeading(pathHeading) *
-                                         ( isNearWaypoint( *path, position() ) /* path-&gt;nearWaypoint (position () ) */ ?
+                                         ( isNearWaypoint( *path, getPosition() ) /* path-&gt;nearWaypoint (getPosition() ) */ ?
                                           0.5f : 0.1f));
                         }
                     }
@@ -981,13 +981,13 @@
                 const bool circles = weAreGoingInCircles ();
                 if (circles &amp;&amp; !stuck) stuckCycleCount++;
                 if (circles) stuck = true;
-                annotationCircleOrDisk (0.5, up(), smoothedPosition (),
+                annotationCircleOrDisk (0.5, getUp(), smoothedgetPosition(),
                                         gWhite, 12, circles, false);
             }
 
             // annotation
             perFrameAnnotation ();
-            recordTrailVertex (currentTime, position());
+            recordTrailVertex (currentTime, getPosition());
         }
 
 
@@ -997,8 +997,8 @@
     //  //
     //  Vector3 reduceTurningAtLowSpeeds (const Vector3&amp; rawSteering)
     //  {
-    //      const Vector3 thrust = rawSteering.parallelComponent (forward ());
-    //      const Vector3 lateral = rawSteering.perpendicularComponent (forward ());
+    //      const Vector3 thrust = rawSteering.parallelComponent (getForward());
+    //      const Vector3 lateral = rawSteering.perpendicularComponent (getForward());
     //      // const float adjust = relativeSpeed ();
     //      // const float adjust = square (relativeSpeed ());
     //      const float adjust = square (square (relativeSpeed ()));
@@ -1010,7 +1010,7 @@
         {
             const float minRadius = sqrtXXX(square(halfWidth)+square(halfLength));
             const float safetyMargin = (curvedSteering ?
-                                        interpolate (relativeSpeed(), 0.0f, 1.5f) :
+                                        interpolate (relativegetSpeed(), 0.0f, 1.5f) :
                                         0.0f);
             setRadius (minRadius + safetyMargin);
         }
@@ -1061,15 +1061,15 @@
             if (demoSelect != 2) return Vector3::ZERO;
 
             // are we heading roughly parallel to the current path segment?
-            const Vector3 p = position ();
+            const Vector3 p = getPosition();
             const Vector3 pathHeading = mapPointAndDirectionToTangent( *path, p, pathFollowDirection ); // path-&gt;tangentAt (p, pathFollowDirection);
-            if (pathHeading.dotProduct(forward ()) &lt; 0.8f)
+            if (pathHeading.dotProduct(getForward()) &lt; 0.8f)
             {
                 // if not, the &quot;hint&quot; is to turn to align with path heading
-                const Vector3 s = side () * halfWidth;
+                const Vector3 s = getSide() * halfWidth;
                 const float f = halfLength * 2;
-                annotationLine (p + s, p + s + (forward () * f), gBlack);
-                annotationLine (p - s, p - s + (forward () * f), gBlack);
+                annotationLine (p + s, p + s + (getForward() * f), gBlack);
+                annotationLine (p - s, p - s + (getForward() * f), gBlack);
                 annotationLine (p, p + (pathHeading * 5), gMagenta);
                 return pathHeading;
             }
@@ -1077,7 +1077,7 @@
             {
                 // when there is a valid nearest obstacle position
                 const Vector3 obstacle = qqqLastNearestObstacle;
-                const Vector3 o = obstacle + (up () * 0.1f);
+                const Vector3 o = obstacle + (getUp() * 0.1f);
                 if (obstacle != Vector3::ZERO)
                 {
                     // get offset, distance from obstacle to its image on path
@@ -1106,13 +1106,13 @@
                             {
                                 const Vector3 q = p + (offset.normalisedCopy() * 5);
                                 annotationLine (p, q, gMagenta);
-                                annotationCircleOrDisk (0.4f, up(), o, gWhite,
+                                annotationCircleOrDisk (0.4f, getUp(), o, gWhite,
                                                         12, false, false);
                                 return offset;
                             }
                         }
                     }
-                    annotationCircleOrDisk (0.4f, up(), o, gBlack, 12,false,false);
+                    annotationCircleOrDisk (0.4f, getUp(), o, gBlack, 12,false,false);
                 }
             }
             // otherwise, no hint
@@ -1141,10 +1141,10 @@
         {
             const float spacing = map.minSpacing() / 2;
             const float maxSide = radius();
-            const float maxForward = minTimeToCollision * speed();
+            const float maxForward = minTimeToCollision * getSpeed();
             const int maxSamples = (int) (maxForward / spacing);
-            const Vector3 step = forward () * spacing;
-            const Vector3 fOffset = position ();
+            const Vector3 step = getForward() * spacing;
+            const Vector3 fOffset = getPosition();
             Vector3 sOffset;
             float s = spacing / 2;
 
@@ -1159,21 +1159,21 @@
 
             const bool hintGiven = steerHint != Vector3::ZERO;
             if (hintGiven &amp;&amp; !dtZero) hintGivenCount++;
-            if (hintGiven) annotationCircleOrDisk (halfWidth * 0.9f, up(),
-                                                   position () + (up () * 0.2f),
+            if (hintGiven) annotationCircleOrDisk (halfWidth * 0.9f, getUp(),
+                                                   getPosition() + (getUp() * 0.2f),
                                                    gWhite, 12, false, false);
 
             // QQQ temporary global QQQoaJustScraping
             QQQoaJustScraping = true;
 
             const float signedRadius = 1 / nonZeroCurvatureQQQ ();
-            const Vector3 localCenterOfCurvature = side () * signedRadius;
-            const Vector3 center = position () + localCenterOfCurvature;
+            const Vector3 localCenterOfCurvature = getSide() * signedRadius;
+            const Vector3 center = getPosition() + localCenterOfCurvature;
             const float sign = signedRadius &lt; 0 ? 1.0f : -1.0f;
             const float arcRadius = signedRadius * -sign;
             const float twoPi = 2 * OPENSTEER_M_PI;
             const float circumference = twoPi * arcRadius;
-            const float rawLength = speed() * minTimeToCollision * sign;
+            const float rawLength = getSpeed() * minTimeToCollision * sign;
             const float fracLimit = 1.0f / 6.0f;
             const float distLimit = circumference * fracLimit;
             const float arcLength = arcLengthLimit (rawLength, distLimit);
@@ -1182,10 +1182,10 @@
             // XXX temp annotation to show limit on arc angle
             if (curvedSteering)
             {
-                if ((speed() * minTimeToCollision) &gt; (circumference * fracLimit))
+                if ((getSpeed() * minTimeToCollision) &gt; (circumference * fracLimit))
                 {
                     const float q = twoPi * fracLimit;
-                    const Vector3 fooz = position () - center;
+                    const Vector3 fooz = getPosition() - center;
                     const Vector3 booz = fooz.rotateAboutGlobalY (sign * q);
                     annotationLine (center, center + fooz, gRed);
                     annotationLine (center, center + booz, gRed);
@@ -1199,7 +1199,7 @@
             // keep track of nearest obstacle on left and right sides
             while (s &lt; maxSide)
             {
-                sOffset = side() * s;
+                sOffset = getSide() * s;
                 s += spacing;
                 const Vector3 lOffset = fOffset + sOffset;
                 const Vector3 rOffset = fOffset - sOffset;
@@ -1265,7 +1265,7 @@
                 const int wingScans = 4;
                 // see duplicated code at: QQQ draw sensing &quot;wings&quot;
                 // QQQ should be a parameter of this method
-                const Vector3 wingWidth = side() * wingSlope () * maxForward;
+                const Vector3 wingWidth = getSide() * wingSlope () * maxForward;
 
                 const Color beforeColor (0.75f, 0.9f, 0.0f);  // for annotation
                 const Color afterColor  (0.9f,  0.5f, 0.0f);  // for annotation
@@ -1274,7 +1274,7 @@
                 {
                     const float fraction = (float)i / (float)wingScans;
                     const Vector3 endside = sOffset + (wingWidth * fraction);
-                    const Vector3 corridorFront = forward() * maxForward;
+                    const Vector3 corridorFront = getForward() * maxForward;
 
                     // &quot;loop&quot; from -1 to 1
                     for (int j = -1; j &lt; 2; j+=2)
@@ -1358,7 +1358,7 @@
                 if (obstacleFreeWL || obstacleFreeWR || relativeSpeed () &lt; 0.7f)
                     return Vector3::ZERO;
                 else
-                    return -forward ();
+                    return -getForward();
             }
 
             // if the nearest obstacle is way out there, take hint if any
@@ -1368,7 +1368,7 @@
             {
                 annotationNoteOAClauseName (&quot;nearest obstacle is way out there&quot;);
                 annotationHintWasTaken ();
-                if (steerHint.dotProduct(side())&gt;0) return side();else return -side();
+                if (steerHint.dotProduct(getSide())&gt;0) return getSide();else return -getSide();
             }
 
             // QQQ experiment 3-9-04
@@ -1378,21 +1378,21 @@
             //
             // are we turning more sharply than the minimum turning radius?
             // (code from adjustSteeringForMinimumTurningRadius)
-            const float maxCurvature = 1 / (minimumTurningRadius () * 1.2f);
+            const float maxCurvature = 1 / (minimumTurninggetRadius() * 1.2f);
             if (absXXX (curvature ()) &gt; maxCurvature)
             {
                 annotationNoteOAClauseName (&quot;min turn radius&quot;);
-                annotationCircleOrDisk (minimumTurningRadius () * 1.2f, up(),
+                annotationCircleOrDisk (minimumTurninggetRadius() * 1.2f, getUp(),
                                         center, gBlue * 0.8f, 40, false, false);
-                return side () * sign;
+                return getSide() * sign;
             }
 
             // if either side is obstacle-free, turn in that direction
             if (obstacleFreeL || obstacleFreeR)
                 annotationNoteOAClauseName (&quot;obstacle-free side&quot;);
 
-            if (obstacleFreeL) return side();
-            if (obstacleFreeR) return -side();
+            if (obstacleFreeL) return getSide();
+            if (obstacleFreeR) return -getSide();
 
             // if wings are clear, turn away from nearest obstacle straight ahead
             if (obstacleFreeW)
@@ -1404,12 +1404,12 @@
                 if (same &amp;&amp; hintGiven)
                 {
                     annotationHintWasTaken ();
-                    if (steerHint.dotProduct(side())&gt;0) return side();else return -side();
+                    if (steerHint.dotProduct(getSide())&gt;0) return getSide();else return -getSide();
                 }
                 else
                 {
                     // otherwise steer toward the less cluttered side
-                    if (nearestL &gt; nearestR) return side(); else return -side();
+                    if (nearestL &gt; nearestR) return getSide(); else return -getSide();
                 }
             }
 
@@ -1420,13 +1420,13 @@
             {
                 annotationNoteOAClauseName (&quot;equallyClear&quot;);
                 annotationHintWasTaken ();
-                if (steerHint.dotProduct(side()) &gt; 0) return side(); else return -side();
+                if (steerHint.dotProduct(getSide()) &gt; 0) return getSide(); else return -getSide();
             }
 
             // turn towards the side whose &quot;wing&quot; region is less cluttered
             // (the wing whose nearest obstacle is furthest away)
             annotationNoteOAClauseName (&quot;wing less cluttered&quot;);
-            if (nearestWL &gt; nearestWR) return side(); else return -side();
+            if (nearestWL &gt; nearestWR) return getSide(); else return -getSide();
         }
 
 
@@ -1480,9 +1480,9 @@
             if (!dtZero) hintTakenCount++;
 
             const float r = halfWidth * 0.9f;
-            const Vector3 ff = forward () * r;
-            const Vector3 ss = side () * r;
-            const Vector3 pp = position () + (up () * 0.2f);
+            const Vector3 ff = getForward() * r;
+            const Vector3 ss = getSide() * r;
+            const Vector3 pp = getPosition() + (getUp() * 0.2f);
             annotationLine (pp + ff + ss, pp - ff + ss, gWhite);
             annotationLine (pp - ff - ss, pp - ff + ss, gWhite);
             annotationLine (pp - ff - ss, pp + ff - ss, gWhite);
@@ -1591,12 +1591,12 @@
             const float predictTime = curvedSteering ? .75f : 1.3f; // seconds
             const float maxForward =
                 speed () * combinedLookAheadTime (predictTime, minDistance);
-            const Vector3 step = forward () * spacing;
+            const Vector3 step = getForward() * spacing;
             float s = curvedSteering ? (spacing / 4) : (spacing / 2);
 
             const float signedRadius = 1 / nonZeroCurvatureQQQ ();
-            const Vector3 localCenterOfCurvature = side () * signedRadius;
-            const Vector3 center = position () + localCenterOfCurvature;
+            const Vector3 localCenterOfCurvature = getSide() * signedRadius;
+            const Vector3 center = getPosition() + localCenterOfCurvature;
             const float sign = signedRadius &lt; 0 ? 1.0f : -1.0f;
             const float arcRadius = signedRadius * -sign;
             const float twoPi = 2 * OPENSTEER_M_PI;
@@ -1607,9 +1607,9 @@
             // scan region ahead of vehicle
             while (s &lt; maxSide)
             {
-                const Vector3 sOffset = side() * s;
-                const Vector3 lOffset = position () + sOffset;
-                const Vector3 rOffset = position () - sOffset;
+                const Vector3 sOffset = getSide() * s;
+                const Vector3 lOffset = getPosition() + sOffset;
+                const Vector3 rOffset = getPosition() - sOffset;
                 const float bevel = 0.3f;
                 const float fraction = s / maxSide;
                 const float scanDist = (halfLength +
@@ -1675,30 +1675,30 @@
                 // QQQ and now, worse, I rearranged it to try the &quot;limit arc
                 // QQQ angle&quot; trick
                 const float signedRadius = 1 / nonZeroCurvatureQQQ ();
-                const Vector3 localCenterOfCurvature = side () * signedRadius;
-                const Vector3 center = position () + localCenterOfCurvature;
+                const Vector3 localCenterOfCurvature = getSide() * signedRadius;
+                const Vector3 center = getPosition() + localCenterOfCurvature;
                 const float sign = signedRadius &lt; 0 ? 1.0f : -1.0f;
                 const float arcRadius = signedRadius * -sign;
                 const float twoPi = 2 * OPENSTEER_M_PI;
                 const float circumference = twoPi * arcRadius;
-                const float rawLength = speed() * predictionTime * sign;
+                const float rawLength = getSpeed() * predictionTime * sign;
                 const float arcLength = arcLengthLimit (rawLength,
                                                         circumference * 0.25f);
                 const float arcAngle = twoPi * arcLength / circumference;
 
-                const Vector3 spoke = position () - center;
+                const Vector3 spoke = getPosition() - center;
                 const Vector3 newSpoke = spoke.rotateAboutGlobalY (arcAngle);
                 const Vector3 prediction = newSpoke + center;
 
                 // QQQ unify with annotatePathFollowing
                 const Color futurePositionColor (0.5f, 0.5f, 0.6f);
-                annotationXZArc (position (), center, arcLength, 20, 
+                annotationXZArc (getPosition(), center, arcLength, 20, 
                                  futurePositionColor);
                 return prediction;
             }
             else
             {
-                return position() + (velocity() * predictionTime);
+                return getPosition() + (velocity() * predictionTime);
             }
         }
 
@@ -1748,18 +1748,18 @@
                                       GCRoute&amp; path)
         {
             // our goal will be offset from our path distance by this amount
-            const float pathDistanceOffset = direction * predictionTime * speed();
+            const float pathDistanceOffset = direction * predictionTime * getSpeed();
 
             // predict our future position
             const Vector3 futurePosition = predictFuturePosition (predictionTime);
 
             // measure distance along path of our current and predicted positions
             const float nowPathDistance =
-                path.mapPointToPathDistance (position ());
+                path.mapPointToPathDistance (getPosition());
 
             // are we facing in the correction direction?
-            const Vector3 pathHeading = mapPointToTangent( path, position() ) * static_cast&lt; float &gt;( direction );// path.tangentAt(position()) * (float)direction;
-            const bool correctDirection = pathHeading.dotProduct(forward ()) &gt; 0;
+            const Vector3 pathHeading = mapPointToTangent( path, getPosition() ) * static_cast&lt; float &gt;( direction );// path.tangentAt(getPosition()) * (float)direction;
+            const bool correctDirection = pathHeading.dotProduct(getForward()) &gt; 0;
 
             // find the point on the path nearest the predicted future position
             // XXX need to improve calling sequence, maybe change to return a
@@ -1770,11 +1770,11 @@
 
             // determine if we are currently inside the path tube
             float nowOutside;
-            const Vector3 nowOnPath = mapPointToPointOnCenterLineAndOutside( path, position(), nowOutside );  // path.mapPointToPath (position (), nowOutside);
+            const Vector3 nowOnPath = mapPointToPointOnCenterLineAndOutside( path, getPosition(), nowOutside );  // path.mapPointToPath (getPosition(), nowOutside);
 
             // no steering is required if our present and future positions are
             // inside the path tube and we are facing in the correct direction
-            const float m = -radius ();
+            const float m = -getRadius();
             const bool whollyInside = (futureOutside &lt; m) &amp;&amp; (nowOutside &lt; m);
             if (whollyInside &amp;&amp; correctDirection)
             {
@@ -1795,7 +1795,7 @@
                 // if we are on one segment and target is on the next segment and
                 // the dot of the tangents of the two segments is negative --
                 // increase the target offset to compensate the fold back
-                const int ip =  static_cast&lt; int &gt;( mapPointToSegmentIndex( path, position() ) ); // path.indexOfNearestSegment (position ());
+                const int ip =  static_cast&lt; int &gt;( mapPointToSegmentIndex( path, getPosition() ) ); // path.indexOfNearestSegment (getPosition());
                 const int it =  static_cast&lt; int &gt;( mapPointToSegmentIndex( path, target ) ); // path.indexOfNearestSegment (target);
                 // Because polyline paths have a constant tangent along a segment
                 // just set the distance along the segment to @c 0.0f.
@@ -1818,14 +1818,14 @@
                 if (nowOutside &gt; 0) return steerForSeek (nowOnPath);
 
                 // steering to seek target on path
-                const Vector3 seek = steerForSeek (target).truncateLength(maxForce());
+                const Vector3 seek = steerForSeek (target).truncateLength(getMaxForce());
 
                 // return that seek steering -- except when we are heading off
                 // the path (currently on path and future position is off path)
                 // in which case we put on the brakes.
                 if ((nowOutside &lt; 0) &amp;&amp; (futureOutside &gt; 0))
-                    return (seek.perpendicularComponent (forward ()) -
-                            (forward () * maxForce ()));
+                    return (seek.perpendicularComponent (getForward()) -
+                            (getForward() * maxForce ()));
                 else
                     return seek;
             }
@@ -1848,15 +1848,15 @@
             float futureOutside;
             const Vector3 onPath =  mapPointToPointOnCenterLineAndOutside( path, futurePosition, futureOutside ); // path.mapPointToPath (futurePosition,futureOutside);
             const Vector3 pathHeading =  mapPointAndDirectionToTangent( path, onPath, direction ); // path.tangentAt (onPath, direction);
-            const Vector3 rawBraking = forward () * maxForce () * -1;
+            const Vector3 rawBraking = getForward() * maxForce () * -1;
             const Vector3 braking = ((futureOutside &lt; 0) ? Vector3::ZERO : rawBraking);
             //qqq experimental wrong-way-fixer
             float nowOutside;
             Vector3 nowTangent;
-            const Vector3 p = position ();
+            const Vector3 p = getPosition();
             const Vector3 nowOnPath = path.mapPointToPath (p, nowTangent, nowOutside);
             nowTangent *= (float)direction;
-            const float alignedness = nowTangent.dotProduct(forward ());
+            const float alignedness = nowTangent.dotProduct(getForward());
 
             // facing the wrong way?
             if (alignedness &lt; 0)
@@ -1867,20 +1867,20 @@
                 if (alignedness &lt; -0.707f)
                 {
                     const Vector3 towardCenter = nowOnPath - p;
-                    const Vector3 turn = (towardCenter.dotProduct(side ()) &gt; 0 ?
-                                       side () * maxForce () :
-                                       side () * maxForce () * -1);
+                    const Vector3 turn = (towardCenter.dotProduct(getSide()) &gt; 0 ?
+                                       getSide() * maxForce () :
+                                       getSide() * maxForce () * -1);
                     return (turn + rawBraking);
                 }
                 else
                 {
                     return (steerTowardHeading(pathHeading).
-                            perpendicularComponent(forward()) + braking);
+                            perpendicularComponent(getForward()) + braking);
                 }
             }
 
             // is the predicted future position(+radius+margin) inside the path?
-            if (futureOutside &lt; -(radius () + 1.0f)) //QQQ
+            if (futureOutside &lt; -(getRadius() + 1.0f)) //QQQ
             {
                 // then no steering is required
                 return Vector3::ZERO;
@@ -1890,13 +1890,13 @@
                 // otherwise determine corrective steering (including braking)
                 annotationLine (futurePosition, futurePosition+pathHeading, gRed);
                 annotatePathFollowing (futurePosition, onPath,
-                                       position(), futureOutside);
+                                       getPosition(), futureOutside);
 
                 // two cases, if entering a turn (a waypoint between path segments)
                 if ( /* path.nearWaypoint (onPath) */ isNearWaypoint( path, onPath )  &amp;&amp; (futureOutside &gt; 0))
                 {
                     // steer to align with next path segment
-                    annotationCircleOrDisk (0.5f, up(), futurePosition,
+                    annotationCircleOrDisk (0.5f, getUp(), futurePosition,
                                             gRed, 8, false, false);
                     return steerTowardHeading (pathHeading) + braking;
                 }
@@ -1907,7 +1907,7 @@
                     const Vector3 pathSide = localRotateForwardToSide (pathHeading);
                     const Vector3 towardFP = futurePosition - onPath;
                     const float whichSide = (pathSide.dotProduct(towardFP)&lt;0)?1.0f :-1.0f;
-                    return (side () * maxForce () * whichSide) + braking;
+                    return (getSide() * maxForce () * whichSide) + braking;
                 }
             }
         }
@@ -1915,20 +1915,20 @@
 
         void perFrameAnnotation (void)
         {
-            const Vector3 p = position();
+            const Vector3 p = getPosition();
 
             // draw the circular collision boundary
-            annotationCircleOrDisk (radius(), up(), p, gBlack, 32, false, false);
+            annotationCircleOrDisk (radius(), getUp(), p, gBlack, 32, false, false);
 
             // draw forward sensing corridor and wings ( for non-curved case)
             if (!curvedSteering)
             {
-                const float corLength = speed() * lookAheadTimeOA ();
+                const float corLength = getSpeed() * lookAheadTimeOA ();
                 if (corLength &gt; halfLength)
                 {
-                    const Vector3 corFront = forward() * corLength;
+                    const Vector3 corFront = getForward() * corLength;
                     const Vector3 corBack = Vector3::ZERO; // (was bbFront)
-                    const Vector3 corSide  = side() * radius();
+                    const Vector3 corSide  = getSide() * radius();
                     const Vector3 c1 = p + corSide + corBack;
                     const Vector3 c2 = p + corSide + corFront;
                     const Vector3 c3 = p - corSide + corFront;
@@ -1939,7 +1939,7 @@
                     annotationLine (c3, c4, color);
 
                     // draw sensing &quot;wings&quot;
-                    const Vector3 wingWidth = side () * wingSlope () * corLength;
+                    const Vector3 wingWidth = getSide() * wingSlope () * corLength;
                     const Vector3 wingTipL = c2 + wingWidth;
                     const Vector3 wingTipR = c3 - wingWidth;
                     const Color wingColor (gOrange);
@@ -1951,7 +1951,7 @@
             }
 
             // annotate steering acceleration
-            const Vector3 above = position () + Vector3 (0, 0.2f, 0);
+            const Vector3 above = getPosition() + Vector3 (0, 0.2f, 0);
             const Vector3 accel = smoothedAcceleration () * 5 / maxForce ();
             const Color aColor (0.4f, 0.4f, 0.8f);
             annotationLine (above, above + accel, aColor);
@@ -1967,9 +1967,9 @@
             if (collisionDetected)   bodyColor = gRed;
 
             // draw vehicle's bounding box on gound plane (its &quot;shadow&quot;)
-            const Vector3 p = position();
-            const Vector3 bbSide = side() * halfWidth;
-            const Vector3 bbFront = forward() * halfLength;
+            const Vector3 p = getPosition();
+            const Vector3 bbSide = getSide() * halfWidth;
+            const Vector3 bbFront = getForward() * halfLength;
             const Vector3 bbHeight (0, 0.1f, 0);
             drawQuadrangle (p - bbFront + bbSide + bbHeight,
                             p + bbFront + bbSide + bbHeight,
@@ -1996,16 +1996,16 @@
 
             // draw line from our position to our predicted future position
             if (!curvedSteering)
-                annotationLine (position(), future, futurePositionColor);
+                annotationLine (getPosition(), future, futurePositionColor);
 
             // draw line from our position to our steering target on the path
-            annotationLine (position(), target, toTargetColor);
+            annotationLine (getPosition(), target, toTargetColor);
 
             // draw a two-toned line between the future test point and its
             // projection onto the path, the change from dark to light color
             // indicates the boundary of the tube.
 
-            const float o = outside + radius () + (curvedSteering ? 1.0f : 0.0f);
+            const float o = outside + getRadius() + (curvedSteering ? 1.0f : 0.0f);
             const Vector3 boundaryOffset = ((onPath - future).normalisedCopy() * o);
 
             const Vector3 onPathBoundary = future + boundaryOffset;
@@ -2147,8 +2147,8 @@
             if (demoSelect == 2)
             {
                 // for path following, do wrap-around (teleport) and make new map
-                const float px = position ().x;
-                const float fx = forward ().x;
+                const float px = getPosition().x;
+                const float fx = getForward().x;
                 const float ws = worldSize * 0.51f; // slightly past edge
                 if (((fx &gt; 0) &amp;&amp; (px &gt; ws)) || ((fx &lt; 0) &amp;&amp; (px &lt; -ws)))
                 {
@@ -2157,21 +2157,21 @@
                     lapsFinished++;
 
                     const Vector3 camOffsetBefore =
-                        OpenSteerDemo::camera.position() - position ();
+                        OpenSteerDemo::camera.getPosition() - getPosition();
 
                     // set position on other side of the map (set new X coordinate)
                     setPosition ((((px &lt; 0) ? 1 : -1) *
                                   ((worldSize * 0.5f) +
-                                   (speed() * lookAheadTimePF ()))),
-                                 position ().y,
-                                 position ().z);
+                                   (getSpeed() * lookAheadTimePF ()))),
+                                 getPosition().y,
+                                 getPosition().z);
 
                     // reset bookeeping to detect stuck cycles
                     resetStuckCycleDetection ();
 
                     // new camera position and aimpoint to compensate for teleport
-                    OpenSteerDemo::camera.target = position ();
-                    OpenSteerDemo::camera.setPosition (position () + camOffsetBefore);
+                    OpenSteerDemo::camera.target = getPosition();
+                    OpenSteerDemo::camera.setPosition (getPosition() + camOffsetBefore);
 
                     // make camera jump immediately to new position
                     OpenSteerDemo::camera.doNotSmoothNextMove ();
@@ -2186,7 +2186,7 @@
             {
                 // for the non-path-following demos:
                 // reset simulation if the vehicle drives through the fence
-                if (position().length() &gt; worldDiag) reset();
+                if (getPosition().length() &gt; worldDiag) reset();
             }
             return false;
         }
@@ -2206,7 +2206,7 @@
 
         void resetStuckCycleDetection (void)
         {
-            resetSmoothedPosition (position () + (forward () * -80)); // qqq
+            resetSmoothedPosition (getPosition() + (getForward() * -80)); // qqq
         }
 
 
@@ -2214,7 +2214,7 @@
         // (say for example we were going around a circle with radius &gt; 10)
         bool weAreGoingInCircles (void)
         {
-            const Vector3 offset = smoothedPosition () - position ();
+            const Vector3 offset = smoothedgetPosition() - getPosition();
             return offset.length () &lt; 10;
         }
 
@@ -2223,7 +2223,7 @@
         {
             const float minTime = (baseLookAheadTime *
                                    (curvedSteering ?
-                                    interpolate (relativeSpeed(), 0.4f, 0.7f) :
+                                    interpolate (relativegetSpeed(), 0.4f, 0.7f) :
                                     0.66f));
             return combinedLookAheadTime (minTime, 3);
         }
@@ -2251,12 +2251,12 @@
         {
             if (demoSelect == 2)
             {
-                const Vector3 bbSide = side () * halfWidth;
-                const Vector3 bbFront = forward () * halfLength;
-                return ( /* path-&gt;isInsidePath (position () - bbFront + bbSide) */ isInsidePathway( *path, position () - bbFront + bbSide ) &amp;&amp;
-                         /* path-&gt;isInsidePath (position () + bbFront + bbSide) */ isInsidePathway( *path, position () + bbFront + bbSide ) &amp;&amp;
-                         /* path-&gt;isInsidePath (position () + bbFront - bbSide) */ isInsidePathway( *path, position () + bbFront - bbSide ) &amp;&amp;
-                         /* path-&gt;isInsidePath (position () - bbFront - bbSide) */ isInsidePathway( *path, position () - bbFront - bbSide ) );
+                const Vector3 bbSide = getSide() * halfWidth;
+                const Vector3 bbFront = getForward() * halfLength;
+                return ( /* path-&gt;isInsidePath (getPosition() - bbFront + bbSide) */ isInsidePathway( *path, getPosition() - bbFront + bbSide ) &amp;&amp;
+                         /* path-&gt;isInsidePath (getPosition() + bbFront + bbSide) */ isInsidePathway( *path, getPosition() + bbFront + bbSide ) &amp;&amp;
+                         /* path-&gt;isInsidePath (getPosition() + bbFront - bbSide) */ isInsidePathway( *path, getPosition() + bbFront - bbSide ) &amp;&amp;
+                         /* path-&gt;isInsidePath (getPosition() - bbFront - bbSide) */ isInsidePathway( *path, getPosition() - bbFront - bbSide ) );
             }
             return true;
         }
@@ -2270,7 +2270,7 @@
             {
                 // annotation
                 const Vector3 u (0, 0.5, 0);
-                const Vector3 p = position ();
+                const Vector3 p = getPosition();
                 annotationLine (p + u, p + u + absolute, gRed);
                 annotationLine (p + u, p + u + curved, gYellow);
                 annotationLine (p + u*2, p + u*2 + currentSteering, gGreen);
@@ -2283,9 +2283,9 @@
         //
         // Given a location in this vehicle's linear local space, convert it into
         // the curved space defined by the vehicle's current path curvature.  For
-        // example, forward() gets mapped on a point 1 unit along the circle
+        // example, getForward() gets mapped on a point 1 unit along the circle
         // centered on the current center of curvature and passing through the
-        // vehicle's position().
+        // vehicle's getPosition().
         //
         Vector3 convertLinearToCurvedSpaceGlobal (const Vector3&amp; linear)
         {
@@ -2293,10 +2293,10 @@
 
             // ---------- this block imported from steerToAvoidObstaclesOnMap
             const float signedRadius = 1 / (nonZeroCurvatureQQQ() /*QQQ*/ * 1);
-            const Vector3 localCenterOfCurvature = side () * signedRadius;
-            const Vector3 center = position () + localCenterOfCurvature;
+            const Vector3 localCenterOfCurvature = getSide() * signedRadius;
+            const Vector3 center = getPosition() + localCenterOfCurvature;
             const float sign = signedRadius &lt; 0 ? 1.0f : -1.0f;
-            const float arcLength = trimmedLinear.dotProduct(forward ());
+            const float arcLength = trimmedLinear.dotProduct(getForward());
             //
             const float arcRadius = signedRadius * -sign;
             const float twoPi = 2 * OPENSTEER_M_PI;
@@ -2306,7 +2306,7 @@
 
             // ---------- this block imported from scanObstacleMap
             // vector from center of curvature to position of vehicle
-            const Vector3 initialSpoke = position () - center;
+            const Vector3 initialSpoke = getPosition() - center;
             // rotate by signed arc angle
             const Vector3 spoke = initialSpoke.rotateAboutGlobalY (arcAngle * sign);
             // ---------- this block imported from scanObstacleMap
@@ -2316,23 +2316,23 @@
             const float radiusChangeFactor = (dRadius + arcRadius) / arcRadius;
             const Vector3 resultLocation = center + (spoke * radiusChangeFactor);
             {
-                const Vector3 center = position () + localCenterOfCurvature;
-                annotationXZArc (position (), center, speed () * sign * -3,
+                const Vector3 center = getPosition() + localCenterOfCurvature;
+                annotationXZArc (getPosition(), center, speed () * sign * -3,
                                  20, gWhite);
             }
             // return the vector from vehicle position to the coimputed location
             // of the curved image of the original linear offset
-            return resultLocation - position ();
+            return resultLocation - getPosition();
         }
 
 
         // approximate value for the Polaris Ranger 6x6: 16 feet, 5 meters
-        float minimumTurningRadius () const {return 5.0f;}
+        float minimumTurninggetRadius() const {return 5.0f;}
 
 
         Vector3 adjustSteeringForMinimumTurningRadius (const Vector3&amp; steering)
         {
-            const float maxCurvature = 1 / (minimumTurningRadius () * 1.1f);
+            const float maxCurvature = 1 / (minimumTurninggetRadius() * 1.1f);
 
             // are we turning more sharply than the minimum turning radius?
             if (absXXX (curvature ()) &gt; maxCurvature)
@@ -2343,14 +2343,14 @@
                 // minimum turing radius
                 const float signedRadius = 1 / nonZeroCurvatureQQQ ();
                 const float sign = signedRadius &lt; 0 ? 1.0f : -1.0f;
-                const Vector3 thrust = steering.parallelComponent (forward ());
+                const Vector3 thrust = steering.parallelComponent (getForward());
                 const Vector3 trimmed = thrust.truncateLength (maxForce ());
-                const Vector3 widenOut = side () * maxForce () * sign;
+                const Vector3 widenOut = getSide() * maxForce () * sign;
                 {
                     // annotation
-                    const Vector3 localCenterOfCurvature = side () * signedRadius;
-                    const Vector3 center = position () + localCenterOfCurvature;
-                    annotationCircleOrDisk (minimumTurningRadius (), up(),
+                    const Vector3 localCenterOfCurvature = getSide() * signedRadius;
+                    const Vector3 center = getPosition() + localCenterOfCurvature;
+                    annotationCircleOrDisk (minimumTurninggetRadius(), getUp(),
                                             center, gBlue, 40, false, false);
                 }
                 return trimmed + widenOut;
@@ -2390,7 +2390,7 @@
             {
                 // compute an ad hoc &quot;relative curvature&quot;
                 const float absC = absXXX (curvature ());
-                const float maxC = 1 / minimumTurningRadius ();
+                const float maxC = 1 / minimumTurninggetRadius();
                 const float relativeCurvature = sqrtXXX (clip (absC/maxC, 0, 1));
 
                 // map from full throttle when straight to 10% at max curvature
@@ -2404,9 +2404,9 @@
                 else
                 {
                     // heading (unit tangent) of the path segment of interest
-                    const Vector3 pathHeading =  mapPointAndDirectionToTangent( *path, position(), pathFollowDirection ); // path-&gt;tangentAt (position (), pathFollowDirection);
+                    const Vector3 pathHeading =  mapPointAndDirectionToTangent( *path, getPosition(), pathFollowDirection ); // path-&gt;tangentAt (getPosition(), pathFollowDirection);
                     // measure how parallel we are to the path
-                    const float parallelness = pathHeading.dotProduct(forward ());
+                    const float parallelness = pathHeading.dotProduct(getForward());
 
                     // determine relative speed for this heading
                     const float mw = 0.2f;
@@ -2427,7 +2427,7 @@
         //
         Vector3 steerTowardHeading (const Vector3&amp; desiredGlobalHeading)
         {
-            const Vector3 headingError = desiredGlobalHeading - forward ();
+            const Vector3 headingError = desiredGlobalHeading - getForward();
             return headingError.normalisedCopy() * maxForce ();
         }
 

Modified: dependencies/opensteer/plugins/MultiplePursuit.cpp
===================================================================
--- dependencies/opensteer/plugins/MultiplePursuit.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/plugins/MultiplePursuit.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -98,11 +98,11 @@
         void update (const float currentTime, const float elapsedTime)
         {
             const Vector3 wander2d = steerForWander (elapsedTime).setYtoZero ();
-            const Vector3 steer = forward() + (wander2d * 3);
+            const Vector3 steer = getForward() + (wander2d * 3);
             applySteeringForce (steer, elapsedTime);
 
             // for annotation
-            recordTrailVertex (currentTime, position());
+            recordTrailVertex (currentTime, getPosition());
         }
 
     };
@@ -127,7 +127,7 @@
         void update (const float currentTime, const float elapsedTime)
         {
             // when pursuer touches quarry (&quot;wanderer&quot;), reset its position
-            const float d = Vector3::distance (position(), wanderer-&gt;position());
+            const float d = Vector3::distance (getPosition(), wanderer-&gt;getPosition());
             const float r = radius() + wanderer-&gt;radius();
             if (d &lt; r) reset ();
 
@@ -135,7 +135,7 @@
             applySteeringForce (steerForPursuit (*wanderer, maxTime), elapsedTime);
 
             // for annotation
-            recordTrailVertex (currentTime, position());
+            recordTrailVertex (currentTime, getPosition());
         }
 
         // reset position
@@ -147,7 +147,7 @@
             const float outer = 30;
             const float radius = frandom2 (inner, outer);
             const Vector3 randomOnRing = RandomUnitVectorOnXZPlane () * radius;
-            setPosition (wanderer-&gt;position() + randomOnRing);
+            setPosition (wanderer-&gt;getPosition() + randomOnRing);
 
             // randomize 2D heading
             randomizeHeadingOnXZPlane ();
@@ -215,7 +215,7 @@
             OpenSteerDemo::updateCamera (currentTime, elapsedTime, selected);
 
             // draw &quot;ground plane&quot;
-            OpenSteerDemo::gridUtility (selected.position());
+            OpenSteerDemo::gridUtility (selected.getPosition());
 
             // draw each vehicles
             for (iterator i = allMP.begin(); i != pEnd; i++) (**i).draw ();

Modified: dependencies/opensteer/plugins/OneTurning.cpp
===================================================================
--- dependencies/opensteer/plugins/OneTurning.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/plugins/OneTurning.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -72,7 +72,7 @@
         {
             applySteeringForce (Vector3 (-2, 0, -3), elapsedTime);
             annotationVelocityAcceleration ();
-            recordTrailVertex (currentTime, position());
+            recordTrailVertex (currentTime, getPosition());
         }
 
         // draw this character/vehicle into the scene
@@ -127,15 +127,15 @@
             // textual annotation (following the test vehicle's screen position)
             std::ostringstream annote;
             annote &lt;&lt; std::setprecision (2) &lt;&lt; std::setiosflags (std::ios::fixed);
-            annote &lt;&lt; &quot;      speed: &quot; &lt;&lt; gOneTurning-&gt;speed() &lt;&lt; std::ends;
-            draw2dTextAt3dLocation (annote, gOneTurning-&gt;position(), gRed, drawGetWindowWidth(), drawGetWindowHeight());
+            annote &lt;&lt; &quot;      speed: &quot; &lt;&lt; gOneTurning-&gt;getSpeed() &lt;&lt; std::ends;
+            draw2dTextAt3dLocation (annote, gOneTurning-&gt;getPosition(), gRed, drawGetWindowWidth(), drawGetWindowHeight());
             draw2dTextAt3dLocation (*&quot;start&quot;, Vector3::ZERO, gGreen, drawGetWindowWidth(), drawGetWindowHeight());
 
             // update camera, tracking test vehicle
             OpenSteerDemo::updateCamera (currentTime, elapsedTime, *gOneTurning);
 
             // draw &quot;ground plane&quot;
-            OpenSteerDemo::gridUtility (gOneTurning-&gt;position());
+            OpenSteerDemo::gridUtility (gOneTurning-&gt;getPosition());
         }
 
         void close (void)

Modified: dependencies/opensteer/plugins/Pedestrian.cpp
===================================================================
--- dependencies/opensteer/plugins/Pedestrian.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/plugins/Pedestrian.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -143,7 +143,7 @@
             setTrailParameters (3, 60);
 
             // notify proximity database that our position has changed
-            proximityToken-&gt;updateForNewPosition (position());
+            proximityToken-&gt;updateForNewPosition (getPosition());
         }
 
         // per frame simulation update
@@ -159,12 +159,12 @@
                 const Color darkRed (0.7f, 0, 0);
                 float const pathRadius = path-&gt;radius();
                 
-                if (Vector3::distance (position(), gEndpoint0) &lt; pathRadius )
+                if (Vector3::distance (getPosition(), gEndpoint0) &lt; pathRadius )
                 {
                     pathDirection = +1;
                     annotationXZCircle (pathRadius, gEndpoint0, darkRed, 20);
                 }
-                if (Vector3::distance (position(), gEndpoint1) &lt; pathRadius )
+                if (Vector3::distance (getPosition(), gEndpoint1) &lt; pathRadius )
                 {
                     pathDirection = -1;
                     annotationXZCircle (pathRadius, gEndpoint1, darkRed, 20);
@@ -173,10 +173,10 @@
 
             // annotation
             annotationVelocityAcceleration (5, 0);
-            recordTrailVertex (currentTime, position());
+            recordTrailVertex (currentTime, getPosition());
 
             // notify proximity database that our position has changed
-            proximityToken-&gt;updateForNewPosition (position());
+            proximityToken-&gt;updateForNewPosition (getPosition());
         }
 
         // compute combined steering force: move forward, avoid obstacles
@@ -184,7 +184,7 @@
         Vector3 determineCombinedSteering (const float elapsedTime)
         {
             // move forward
-            Vector3 steeringForce = forward();
+            Vector3 steeringForce = getForward();
 
             // probability that a lower priority behavior will be given a
             // chance to &quot;drive&quot; even if a higher priority behavior might
@@ -219,9 +219,9 @@
                 // find all neighbors within maxRadius using proximity database
                 // (radius is largest distance between vehicles traveling head-on
                 // where a collision is possible within caLeadTime seconds.)
-                const float maxRadius = caLeadTime * maxSpeed() * 2;
+                const float maxRadius = caLeadTime * getMaxSpeed() * 2;
                 neighbors.clear();
-                proximityToken-&gt;findNeighbors (position(), maxRadius, neighbors);
+                proximityToken-&gt;findNeighbors (getPosition(), maxRadius, neighbors);
 
                 if (leakThrough &lt; frandom01())
                     collisionAvoidance =
@@ -275,10 +275,10 @@
             const Color yellowOrange (1.0f, 0.75f, 0.0f);
 
             // draw line from our position to our predicted future position
-            annotationLine (position(), future, yellow);
+            annotationLine (getPosition(), future, yellow);
 
             // draw line from our position to our steering target on the path
-            annotationLine (position(), target, yellowOrange);
+            annotationLine (getPosition(), target, yellowOrange);
 
             // draw a two-toned line between the future test point and its
             // projection onto the path, the change from dark to light color
@@ -295,12 +295,12 @@
                                          const float /*additionalDistance*/)
         {
             // draw the word &quot;Ouch!&quot; above colliding vehicles
-            const float headOn = forward().dotProduct(other.forward()) &lt; 0;
+            const float headOn = getForward().dotProduct(other.getForward()) &lt; 0;
             const Color green (0.4f, 0.8f, 0.1f);
             const Color red (1, 0.1f, 0);
             const Color color = headOn ? red : green;
             const char* string = headOn ? &quot;OUCH!&quot; : &quot;pardon me&quot;;
-            const Vector3 location = position() + Vector3 (0, 0.5f, 0);
+            const Vector3 location = getPosition() + Vector3 (0, 0.5f, 0);
             if (OpenSteer::annotationIsOn())
                 draw2dTextAt3dLocation (*string, location, color, drawGetWindowWidth(), drawGetWindowHeight());
         }
@@ -314,8 +314,8 @@
         {
             const Color green (0.15f, 0.6f, 0.0f);
 
-            annotationLine (position(), ourFuture, green);
-            annotationLine (threat.position(), threatFuture, green);
+            annotationLine (getPosition(), ourFuture, green);
+            annotationLine (threat.getPosition(), threatFuture, green);
             annotationLine (ourFuture, threatFuture, gRed);
             annotationXZCircle (radius(), ourFuture,    green, 12);
             annotationXZCircle (radius(), threatFuture, green, 12);
@@ -326,12 +326,12 @@
         // xxx CaptureTheFlag.cpp
         void annotateAvoidObstacle (const float minDistanceToCollision)
         {
-            const Vector3 boxSide = side() * radius();
-            const Vector3 boxFront = forward() * minDistanceToCollision;
-            const Vector3 FR = position() + boxFront - boxSide;
-            const Vector3 FL = position() + boxFront + boxSide;
-            const Vector3 BR = position()            - boxSide;
-            const Vector3 BL = position()            + boxSide;
+            const Vector3 boxSide = getSide() * radius();
+            const Vector3 boxFront = getForward() * minDistanceToCollision;
+            const Vector3 FR = getPosition() + boxFront - boxSide;
+            const Vector3 FL = getPosition() + boxFront + boxSide;
+            const Vector3 BR = getPosition()            - boxSide;
+            const Vector3 BL = getPosition()            + boxSide;
             const Color white (1,1,1);
             annotationLine (FR, FL, white);
             annotationLine (FL, BL, white);
@@ -517,7 +517,7 @@
             OpenSteerDemo::updateCamera (currentTime, elapsedTime, selected);
 
             // draw &quot;ground plane&quot;
-            if (OpenSteerDemo::selectedVehicle) gridCenter = selected.position();
+            if (OpenSteerDemo::selectedVehicle) gridCenter = selected.getPosition();
             OpenSteerDemo::gridUtility (gridCenter);
 
             // draw and annotate each Pedestrian
@@ -537,15 +537,15 @@
             {
                 const Color color (0.8f, 0.8f, 1.0f);
                 const Vector3 textOffset (0, 0.25f, 0);
-                const Vector3 textPosition = selected.position() + textOffset;
-                const Vector3 camPosition = OpenSteerDemo::camera.position();
-                const float camDistance = Vector3::distance (selected.position(),
+                const Vector3 textPosition = selected.getPosition() + textOffset;
+                const Vector3 camPosition = OpenSteerDemo::camera.getPosition();
+                const float camDistance = Vector3::distance (selected.getPosition(),
                                                           camPosition);
                 const char* spacer = &quot;      &quot;;
                 std::ostringstream annote;
                 annote &lt;&lt; std::setprecision (2);
                 annote &lt;&lt; std::setiosflags (std::ios::fixed);
-                annote &lt;&lt; spacer &lt;&lt; &quot;1: speed: &quot; &lt;&lt; selected.speed() &lt;&lt; std::endl;
+                annote &lt;&lt; spacer &lt;&lt; &quot;1: speed: &quot; &lt;&lt; selected.getSpeed() &lt;&lt; std::endl;
                 annote &lt;&lt; std::setprecision (1);
                 annote &lt;&lt; spacer &lt;&lt; &quot;2: cam dist: &quot; &lt;&lt; camDistance &lt;&lt; std::endl;
                 annote &lt;&lt; spacer &lt;&lt; &quot;3: no third thing&quot; &lt;&lt; std::ends;
@@ -586,9 +586,9 @@
                 {
                     AbstractVehicle* vehicle = *i;
                     const float nearDistance = 6;
-                    const Vector3&amp; vp = vehicle-&gt;position();
-                    const Vector3&amp; np = nearMouse.position();
-                    if ((Vector3::distance (vp, selected.position()) &lt; nearDistance)
+                    const Vector3&amp; vp = vehicle-&gt;getPosition();
+                    const Vector3&amp; np = nearMouse.getPosition();
+                    if ((Vector3::distance (vp, selected.getPosition()) &lt; nearDistance)
                         ||
                         (&amp;nearMouse &amp;&amp; (Vector3::distance (vp, np) &lt; nearDistance)))
                     {
@@ -598,7 +598,7 @@
                            &lt;&lt; std::ends;
                         const Color textColor (0.8f, 1, 0.8f);
                         const Vector3 textOffset (0, 0.25f, 0);
-                        const Vector3 textPos = vehicle-&gt;position() + textOffset;
+                        const Vector3 textPos = vehicle-&gt;getPosition() + textOffset;
                         draw2dTextAt3dLocation (sn, textPos, textColor, drawGetWindowWidth(), drawGetWindowHeight());
                     }
                 }
@@ -621,8 +621,8 @@
     // ------------------------------------ xxxcwr11-1-04 fixing steerToAvoid
             {
                 float w = gObstacle3.width * 0.5f;
-                Vector3 p = gObstacle3.position ();
-                Vector3 s = gObstacle3.side ();
+                Vector3 p = gObstacle3.getPosition();
+                Vector3 s = gObstacle3.getSide();
                 drawLine (p + (s * w), p + (s * -w), gWhite);
 
                 Vector3 v1 = gObstacle3.globalizePosition (Vector3 (w, w, 0));

Modified: dependencies/opensteer/plugins/Soccer.cpp
===================================================================
--- dependencies/opensteer/plugins/Soccer.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/plugins/Soccer.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -112,19 +112,19 @@
             applyBrakingForce(1.5f, elapsedTime);
             applySteeringForce(velocity(), elapsedTime);
             // are we now outside the field?
-            if(!m_bbox-&gt;InsideX(position()))
+            if(!m_bbox-&gt;InsideX(getPosition()))
             {
                 Vector3 d = velocity();
                 regenerateOrthonormalBasis(Vector3(-d.x, d.y, d.z));
                 applySteeringForce(velocity(), elapsedTime);
             }
-            if(!m_bbox-&gt;InsideZ(position()))
+            if(!m_bbox-&gt;InsideZ(getPosition()))
             {
                 Vector3 d = velocity();
                 regenerateOrthonormalBasis(Vector3(d.x, d.y, -d.z));
                 applySteeringForce(velocity(), elapsedTime);
             }
-        recordTrailVertex (currentTime, position());
+        recordTrailVertex (currentTime, getPosition());
         }
 
         void kick(Vector3 dir, const float elapsedTime){
@@ -168,7 +168,7 @@
                 else
                     setPosition(Vector3(-playerPosition[m_MyID].x, playerPosition[m_MyID].y, playerPosition[m_MyID].z));
                 }
-            m_home = position();
+            m_home = getPosition();
             clearTrailHistory ();    // prevent long streaks due to teleportation 
             setTrailParameters (10, 60);
         }
@@ -179,10 +179,10 @@
         {
             // if I hit the ball, kick it.
 
-            const float distToBall = Vector3::distance (position(), m_Ball-&gt;position());
+            const float distToBall = Vector3::distance (getPosition(), m_Ball-&gt;getPosition());
             const float sumOfRadii = radius() + m_Ball-&gt;radius();
             if (distToBall &lt; sumOfRadii)
-                m_Ball-&gt;kick((m_Ball-&gt;position()-position())*50, elapsedTime);
+                m_Ball-&gt;kick((m_Ball-&gt;getPosition()-getPosition())*50, elapsedTime);
 
 
             // otherwise consider avoiding collisions with others
@@ -191,24 +191,24 @@
                 applySteeringForce (collisionAvoidance, elapsedTime);
             else
                 {
-                float distHomeToBall = Vector3::distance (m_home, m_Ball-&gt;position());
+                float distHomeToBall = Vector3::distance (m_home, m_Ball-&gt;getPosition());
                 if( distHomeToBall &lt; 12.0f)
                     {
                     // go for ball if I'm on the 'right' side of the ball
-                        if( b_ImTeamA ? position().x &gt; m_Ball-&gt;position().x : position().x &lt; m_Ball-&gt;position().x)
+                        if( b_ImTeamA ? getPosition().x &gt; m_Ball-&gt;getPosition().x : getPosition().x &lt; m_Ball-&gt;getPosition().x)
                         {
-                        Vector3 seekTarget = xxxsteerForSeek(m_Ball-&gt;position());
+                        Vector3 seekTarget = xxxsteerForSeek(m_Ball-&gt;getPosition());
                         applySteeringForce (seekTarget, elapsedTime);
                         }
                     else
                         {
                         if( distHomeToBall &lt; 12.0f)
                             {
-                            float Z = m_Ball-&gt;position().z - position().z &gt; 0 ? -1.0f : 1.0f;
-                            Vector3 behindBall = m_Ball-&gt;position() + (b_ImTeamA ? Vector3(2.0f,0.0f,Z) : Vector3(-2.0f,0.0f,Z));
+                            float Z = m_Ball-&gt;getPosition().z - getPosition().z &gt; 0 ? -1.0f : 1.0f;
+                            Vector3 behindBall = m_Ball-&gt;getPosition() + (b_ImTeamA ? Vector3(2.0f,0.0f,Z) : Vector3(-2.0f,0.0f,Z));
                             Vector3 behindBallForce = xxxsteerForSeek(behindBall);
-                            annotationLine (position(), behindBall , Color(0.0f,1.0f,0.0f));
-                            Vector3 evadeTarget = xxxsteerForFlee(m_Ball-&gt;position());
+                            annotationLine (getPosition(), behindBall , Color(0.0f,1.0f,0.0f));
+                            Vector3 evadeTarget = xxxsteerForFlee(m_Ball-&gt;getPosition());
                             applySteeringForce (behindBallForce*10.0f + evadeTarget, elapsedTime);
                             }
                         }
@@ -301,12 +301,12 @@
                 TeamB[i]-&gt;update (currentTime, elapsedTime);
             m_Ball-&gt;update(currentTime, elapsedTime);
 
-            if(m_TeamAGoal-&gt;InsideX(m_Ball-&gt;position()) &amp;&amp; m_TeamAGoal-&gt;InsideZ(m_Ball-&gt;position()))
+            if(m_TeamAGoal-&gt;InsideX(m_Ball-&gt;getPosition()) &amp;&amp; m_TeamAGoal-&gt;InsideZ(m_Ball-&gt;getPosition()))
             {
                 m_Ball-&gt;reset();	// Ball in blue teams goal, red scores
                 m_redScore++;
             }
-            if(m_TeamBGoal-&gt;InsideX(m_Ball-&gt;position()) &amp;&amp; m_TeamBGoal-&gt;InsideZ(m_Ball-&gt;position()))
+            if(m_TeamBGoal-&gt;InsideX(m_Ball-&gt;getPosition()) &amp;&amp; m_TeamBGoal-&gt;InsideZ(m_Ball-&gt;getPosition()))
             {
                 m_Ball-&gt;reset();	// Ball in red teams goal, blue scores
                     m_blueScore++;
@@ -342,8 +342,8 @@
             {
                 std::ostringstream annote;
                 annote &lt;&lt; std::setprecision (2) &lt;&lt; std::setiosflags (std::ios::fixed);
-                annote &lt;&lt; &quot;      speed: &quot; &lt;&lt; TeamA[i]-&gt;speed() &lt;&lt; &quot;ID:&quot; &lt;&lt; i &lt;&lt; std::ends;
-                draw2dTextAt3dLocation (annote, TeamA[i]-&gt;position(), gRed, drawGetWindowWidth(), drawGetWindowHeight());
+                annote &lt;&lt; &quot;      speed: &quot; &lt;&lt; TeamA[i]-&gt;getSpeed() &lt;&lt; &quot;ID:&quot; &lt;&lt; i &lt;&lt; std::ends;
+                draw2dTextAt3dLocation (annote, TeamA[i]-&gt;getPosition(), gRed, drawGetWindowWidth(), drawGetWindowHeight());
                 draw2dTextAt3dLocation (*&quot;start&quot;, Vector3::ZERO, gGreen, drawGetWindowWidth(), drawGetWindowHeight());
             }
             // update camera, tracking test vehicle

Modified: dependencies/opensteer/src/Camera.cpp
===================================================================
--- dependencies/opensteer/src/Camera.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/src/Camera.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -120,9 +120,9 @@
     const bool noVehicle = vehicleToTrack == NULL;
     
     // new position/target/up, set in switch below, defaults to current
-    Vector3 newPosition = position();
+    Vector3 newPosition = getPosition();
     Vector3 newTarget = target;
-    Vector3 newUp = up();
+    Vector3 newUp = getUp();
 
 
     // prediction time to compensate for lag caused by smoothing moves
@@ -149,7 +149,7 @@
 
     case cmStraightDown:
         if (noVehicle) break;
-        newUp = v.forward();
+        newUp = v.getForward();
         newTarget = v.predictFuturePosition (predictionTime);
         newPosition = newTarget;
         newPosition.y += lookdownDistance;
@@ -157,7 +157,7 @@
 
     case cmFixedLocalOffset:
         if (noVehicle) break;
-        newUp = v.up();
+        newUp = v.getUp();
         newTarget = v.predictFuturePosition (predictionTime);
         newPosition = v.globalizePosition (fixedLocalOffset);
         break;
@@ -165,13 +165,13 @@
     case cmOffsetPOV:
         {
             if (noVehicle) break;
-            newUp = v.up();
+            newUp = v.getUp();
             const Vector3 futurePosition = v.predictFuturePosition (antiLagTime);
             const Vector3 globalOffset = v.globalizeDirection (povOffset);
             newPosition = futurePosition + globalOffset;
             // XXX hack to improve smoothing between modes (no effect on aim)
             const float L = 10;
-            newTarget = newPosition + (v.forward() * L);
+            newTarget = newPosition + (v.getForward() * L);
             break;
         }
     default:
@@ -182,7 +182,7 @@
     smoothCameraMove (newPosition, newTarget, newUp, elapsedTime);
 
     // set camera in draw module
-    drawCameraLookAt (position(), target, up());
+    drawCameraLookAt (getPosition(), target, getUp());
 }
 
 
@@ -204,8 +204,8 @@
     {
         const float smoothRate = elapsedTime * smoothMoveSpeed;
 
-        Vector3 tempPosition = position();
-        Vector3 tempUp = up();
+        Vector3 tempPosition = getPosition();
+        Vector3 tempUp = getUp();
         blendIntoAccumulator (smoothRate, newPosition, tempPosition);
         blendIntoAccumulator (smoothRate, newTarget,   target);
         blendIntoAccumulator (smoothRate, newUp,       tempUp);
@@ -215,10 +215,10 @@
         // xxx not sure if these are needed, seems like a good idea
         // xxx (also if either up or oldUP are zero, use the other?)
         // xxx (even better: force up to be perp to target-position axis))
-        if (up() == Vector3::ZERO)
+        if (getUp() == Vector3::ZERO)
             setUp (Vector3::UNIT_Y);
         else
-            setUp (up().normalisedCopy());
+            setUp (getUp().normalisedCopy());
     }
     else
     {
@@ -247,9 +247,9 @@
     const bool constrainUp = (fixedDistVOffset != 0);
 
     // vector offset from target to current camera position
-    const Vector3 adjustedPosition (position().x,
-                                 (constrainUp) ? target.y : position().y,
-                                 position().z);
+    const Vector3 adjustedPosition (getPosition().x,
+                                 (constrainUp) ? target.y : getPosition().y,
+                                 getPosition().z);
     const Vector3 offset = adjustedPosition - target;
 
     // current distance between them
@@ -258,7 +258,7 @@
     // move camera only when geometry is well-defined (avoid degenerate case)
     if (distance == 0)
     {
-        return position();
+        return getPosition();
     }
     else
     {
@@ -343,7 +343,7 @@
             // XXX this is the oddball case, adjusting &quot;position&quot; instead
             // XXX of mode parameters, hence no smoothing during adjustment
             // XXX Plus the fixedDistVOffset feature complicates things
-            const Vector3 offset = position() - target;
+            const Vector3 offset = getPosition() - target;
             const Vector3 adjusted = mouseAdjustPolar (adjustment, offset);
             // XXX --------------------------------------------------
 //             position = target + adjusted;
@@ -360,7 +360,7 @@
             setPosition (target + adjusted);
             fixedDistDistance = adjusted.length();
 //          fixedDistVOffset = position.y - target.y;
-            fixedDistVOffset = position().y - target.y;
+            fixedDistVOffset = getPosition().y - target.y;
             // XXX --------------------------------------------------
             break;
         }
@@ -412,8 +412,8 @@
     // sphere.
     const float oldLength = result.length ();
     const float rate = polar ? oldLength : 1;
-    result += xxxls().side() * (adjustment.x * rate);
-    result += xxxls().up()   * (adjustment.y * rate);
+    result += xxxls().getSide() * (adjustment.x * rate);
+    result += xxxls().getUp()   * (adjustment.y * rate);
     if (polar)
     {
         const float newLength = result.length ();
@@ -424,7 +424,7 @@
     if (polar)
         result *= (1 + adjustment.z);
     else
-        result += xxxls().forward() * adjustment.z;
+        result += xxxls().getForward() * adjustment.z;
 
     return result;
 }

Modified: dependencies/opensteer/src/Draw.cpp
===================================================================
--- dependencies/opensteer/src/Draw.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/src/Draw.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -381,7 +381,7 @@
         ls.setUp (unitAxis);
         ls.setForward (unitPerp);
         ls.setPosition (center);
-        ls.setUnitSideFromForwardAndUp ();
+        ls.setUnitSideFromForwardAndgetUp();
     }
         
     // make disks visible (not culled) from both sides 
@@ -398,7 +398,7 @@
     glBegin (filled ? GL_TRIANGLE_FAN : GL_LINE_LOOP);
 
     // for the filled case, first emit the center point
-    if (filled) iglVertexVec3 (in3d ? ls.position() : center);
+    if (filled) iglVertexVec3 (in3d ? ls.getPosition() : center);
 
     // rotate p around the circle in &quot;segments&quot; steps
     float sin=0, cos=0;
@@ -518,14 +518,14 @@
     const float y = sqrtXXX (1 - (x * x));
 
     // radius and position of vehicle
-    const float r = vehicle.radius();
-    const Vector3&amp; p = vehicle.position();
+    const float r = vehicle.getRadius();
+    const Vector3&amp; p = vehicle.getPosition();
 
     // shape of triangular body
     const Vector3 u = r * 0.05f * Vector3 (0, 1, 0); // slightly up
-    const Vector3 f = r * vehicle.forward();
-    const Vector3 s = r * vehicle.side() * x;
-    const Vector3 b = r * vehicle.forward() * -y;
+    const Vector3 f = r * vehicle.getForward();
+    const Vector3 s = r * vehicle.getSide() * x;
+    const Vector3 b = r * vehicle.getForward() * -y;
 
     // draw double-sided triangle (that is: no (back) face culling)
     beginDoubleSidedDrawing ();
@@ -553,14 +553,14 @@
     const float y = sqrtXXX (1 - (x * x));
 
     // radius and position of vehicle
-    const float r = vehicle.radius();
-    const Vector3&amp; p = vehicle.position();
+    const float r = vehicle.getRadius();
+    const Vector3&amp; p = vehicle.getPosition();
 
     // body shape parameters
-    const Vector3 f = r * vehicle.forward();
-    const Vector3 s = r * vehicle.side() * x;
-    const Vector3 u = r * vehicle.up() * x * 0.5f;
-    const Vector3 b = r * vehicle.forward() * -y;
+    const Vector3 f = r * vehicle.getForward();
+    const Vector3 s = r * vehicle.getSide() * x;
+    const Vector3 u = r * vehicle.getUp() * x * 0.5f;
+    const Vector3 b = r * vehicle.getForward() * -y;
 
     // vertex positions
     const Vector3 nose   = p + f;
@@ -600,14 +600,14 @@
     const float y = sqrtXXX (1 - (x * x));
 
     // radius and position of vehicle
-    const float r = vehicle.radius();
-    const Vector3&amp; p = vehicle.position();
+    const float r = vehicle.getRadius();
+    const Vector3&amp; p = vehicle.getPosition();
 
     // body shape parameters
-    const Vector3 f = r * vehicle.forward();
-    const Vector3 s = r * vehicle.side() * x;
-    const Vector3 u = r * vehicle.up() * x * 0.5f;
-    const Vector3 b = r * vehicle.forward() * -y;
+    const Vector3 f = r * vehicle.getForward();
+    const Vector3 s = r * vehicle.getSide() * x;
+    const Vector3 u = r * vehicle.getUp() * x * 0.5f;
+    const Vector3 b = r * vehicle.getForward() * -y;
 
     // vertex positions
     const Vector3 nose   = p + f;

Modified: dependencies/opensteer/src/Obstacle.cpp
===================================================================
--- dependencies/opensteer/src/Obstacle.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/src/Obstacle.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -126,14 +126,14 @@
                       const float minTimeToCollision) const
 {
     // if nearby intersection found, steer away from it, otherwise no steering
-    const float minDistanceToCollision = minTimeToCollision * vehicle.speed();
+    const float minDistanceToCollision = minTimeToCollision * vehicle.getSpeed();
     if (intersect &amp;&amp; (distance &lt; minDistanceToCollision))
     {
         // compute avoidance steering force: take the component of
         // steerHint which is lateral (perpendicular to vehicle's
         // forward direction), set its length to vehicle's maxForce
-        Vector3 lateral = Vec3Utils::perpendicularComponent(steerHint, vehicle.forward ());
-        return lateral.normalisedCopy() * vehicle.maxForce ();
+        Vector3 lateral = Vec3Utils::perpendicularComponent(steerHint, vehicle.getForward());
+        return lateral.normalisedCopy() * vehicle.getMaxForce();
     }
     else
     {
@@ -170,7 +170,7 @@
     lc = vehicle.localizePosition (center);
 
     // compute line-sphere intersection parameters
-    const float r = radius + vehicle.radius();
+    const float r = radius + vehicle.getRadius();
     b = -2 * lc.z;
     c = square (lc.x) + square (lc.y) + square (lc.z) - square (r);
     d = (b * b) - (4 * c);
@@ -203,7 +203,7 @@
          // hollow obstacle (or &quot;both&quot;), pick point that is in front
          ((p &gt; 0) ? p : q));
     pi.surfacePoint =
-        vehicle.position() + (vehicle.forward() * pi.distance);
+        vehicle.getPosition() + (vehicle.getForward() * pi.distance);
     pi.surfaceNormal = (pi.surfacePoint-center).normalisedCopy();
     // hmm, note that this was actually determined already in pi.distance calc
     pi.vehicleOutside = lc.length () &gt; radius;
@@ -237,10 +237,10 @@
     const float w = width; // dimensions
     const float h = height;
     const float d = depth;
-    const Vector3 s = side (); // local space
-    const Vector3 u = up ();
-    const Vector3 f = forward ();
-    const Vector3 p = position ();
+    const Vector3 s = getSide(); // local space
+    const Vector3 u = getUp();
+    const Vector3 f = getForward();
+    const Vector3 p = getPosition();
     const Vector3 hw = s * (0.5f * width); // offsets for face centers
     const Vector3 hh = u * (0.5f * height);
     const Vector3 hd = f * (0.5f * depth);
@@ -271,7 +271,7 @@
     if (pi.intersect)
     {
         pi.obstacle = this;
-        pi.steerHint = ((pi.surfacePoint - position ()).normalisedCopy() *
+        pi.steerHint = ((pi.surfacePoint - getPosition()).normalisedCopy() *
                         (pi.vehicleOutside ? 1.0f : -1.0f));
     }
 }
@@ -291,8 +291,8 @@
     // initialize pathIntersection object to &quot;no intersection found&quot;
     pi.intersect = false;
 
-    const Vector3 lp =  localizePosition (vehicle.position ());
-    const Vector3 ld = localizeDirection (vehicle.forward ());
+    const Vector3 lp =  localizePosition (vehicle.getPosition());
+    const Vector3 ld = localizeDirection (vehicle.getForward());
 
     // no obstacle intersection if path is parallel to XY (side/up) plane
     if (ld.dotProduct(Vector3::NEGATIVE_UNIT_Z) == 0.0f) return;
@@ -311,13 +311,13 @@
     const Vector3 planeIntersection (ix, iy, 0.0f);
 
     // no obstacle intersection if plane intersection is outside 2d shape
-    if (!xyPointInsideShape (planeIntersection, vehicle.radius ())) return;
+    if (!xyPointInsideShape (planeIntersection, vehicle.getRadius())) return;
 
     // otherwise, the vehicle path DOES intersect this rectangle
     const Vector3 localXYradial = planeIntersection.normalisedCopy();
     const Vector3 radial = globalizeDirection (localXYradial);
     const float sideSign = (lp.z &gt; 0.0f) ? +1.0f : -1.0f;
-    const Vector3 opposingNormal = forward () * sideSign;
+    const Vector3 opposingNormal = getForward() * sideSign;
     pi.intersect = true;
     pi.obstacle = this;
     pi.distance = (lp - planeIntersection).length ();

Modified: dependencies/opensteer/src/OpenSteerDemo.cpp
===================================================================
--- dependencies/opensteer/src/OpenSteerDemo.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/src/OpenSteerDemo.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -461,8 +461,8 @@
     for (AVIterator i = vehicles.begin(); i != vehicles.end(); i++)
     {
         // distance from this vehicle's center to the selection line:
-        const float d = distanceFromLine ((**i).position(),
-                                          camera.position(),
+        const float d = distanceFromLine ((**i).getPosition(),
+                                          camera.getPosition(),
                                           direction);
 
         // if this vehicle-to-line distance is the smallest so far,
@@ -541,9 +541,9 @@
     selectedVehicle = &selected;
     if (&amp;selected)
     {
-        const Vector3 behind = selected.forward() * -distance;
-        camera.setPosition (selected.position() + behind);
-        camera.target = selected.position();
+        const Vector3 behind = selected.getForward() * -distance;
+        camera.setPosition (selected.getPosition() + behind);
+        camera.target = selected.getPosition();
     }
 }
 
@@ -563,7 +563,7 @@
     position3dCamera (selected, distance, elevation);
 
     // then adjust for 3d:
-    Vector3 position3d = camera.position();
+    Vector3 position3d = camera.getPosition();
     position3d.y += elevation;
     camera.setPosition (position3d);
 }
@@ -627,7 +627,7 @@
 OpenSteer::OpenSteerDemo::highlightVehicleUtility (const AbstractVehicle&amp; vehicle)
 {
     if (&amp;vehicle != NULL)
-        drawXZDisk (vehicle.radius(), vehicle.position(), gGray60, 20);
+        drawXZDisk (vehicle.getRadius(), vehicle.getPosition(), gGray60, 20);
 }
 
 
@@ -638,8 +638,8 @@
 void 
 OpenSteer::OpenSteerDemo::circleHighlightVehicleUtility (const AbstractVehicle&amp; vehicle)
 {
-    if (&amp;vehicle != NULL) drawXZCircle (vehicle.radius () * 1.1f,
-                                        vehicle.position(),
+    if (&amp;vehicle != NULL) drawXZCircle (vehicle.getRadius() * 1.1f,
+                                        vehicle.getPosition(),
                                         gGray60,
                                         20);
 }
@@ -656,7 +656,7 @@
 {
     if (&amp;v)
     {
-        const float diameter = v.radius() * 2;
+        const float diameter = v.getRadius() * 2;
         const Vector3 size (diameter, diameter, diameter);
         drawBoxOutline (v, size, color);
     }
@@ -676,10 +676,10 @@
 {
     if (&amp;v)
     {
-        const Vector3&amp; cPosition = camera.position();
-        draw3dCircle  (v.radius() * radiusMultiplier,  // adjusted radius
-                       v.position(),                   // center
-                       v.position() - cPosition,       // view axis
+        const Vector3&amp; cPosition = camera.getPosition();
+        draw3dCircle  (v.getRadius() * radiusMultiplier,  // adjusted radius
+                       v.getPosition(),                   // center
+                       v.getPosition() - cPosition,       // view axis
                        color,                          // drawing color
                        20);                            // circle segments
     }

Modified: dependencies/opensteer/src/SimpleVehicle.cpp
===================================================================
--- dependencies/opensteer/src/SimpleVehicle.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ dependencies/opensteer/src/SimpleVehicle.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -110,22 +110,22 @@
 OpenSteer::SimpleVehicle::adjustRawSteeringForce (const Vector3&amp; force,
                                                   const float /* deltaTime */)
 {
-    const float maxAdjustedSpeed = 0.2f * maxSpeed();
+    const float maxAdjustedSpeed = 0.2f * getMaxSpeed();
 
-    if ((speed() &gt; maxAdjustedSpeed) || (force == Vector3::ZERO))
+    if ((getSpeed() &gt; maxAdjustedSpeed) || (force == Vector3::ZERO))
     {
         return force;
     }
     else
     {
-        const float range = speed() / maxAdjustedSpeed;
+        const float range = getSpeed() / maxAdjustedSpeed;
         // const float cosine = interpolate (pow (range, 6), 1.0f, -1.0f);
         // const float cosine = interpolate (pow (range, 10), 1.0f, -1.0f);
         // const float cosine = interpolate (pow (range, 20), 1.0f, -1.0f);
         // const float cosine = interpolate (pow (range, 100), 1.0f, -1.0f);
         // const float cosine = interpolate (pow (range, 50), 1.0f, -1.0f);
         const float cosine = interpolate (pow (range, 20), 1.0f, -1.0f);
-        return limitMaxDeviationAngle (force, cosine, forward());
+        return limitMaxDeviationAngle (force, cosine, getForward());
     }
 }
 
@@ -148,12 +148,12 @@
 void 
 OpenSteer::SimpleVehicle::applyBrakingForce (const float rate, const float deltaTime)
 {
-    const float rawBraking = speed() * rate;
-    const float clipBraking = ((rawBraking &lt; maxForce()) ?
+    const float rawBraking = getSpeed() * rate;
+    const float clipBraking = ((rawBraking &lt; getMaxForce()) ?
                                rawBraking :
-                               maxForce());
+                               getMaxForce());
 
-    setSpeed (speed() - (clipBraking * deltaTime));
+    setSpeed (getSpeed() - (clipBraking * deltaTime));
 }
 
 
@@ -170,7 +170,7 @@
     const Vector3 adjustedForce = adjustRawSteeringForce (force, elapsedTime);
 
     // enforce limit on magnitude of steering force
-    const Vector3 clippedForce = Vec3Utils::truncateLength(adjustedForce, maxForce());
+    const Vector3 clippedForce = Vec3Utils::truncateLength(adjustedForce, getMaxForce());
 
     // compute acceleration and velocity
     Vector3 newAcceleration = (clippedForce / mass());
@@ -190,13 +190,13 @@
     newVelocity += _smoothedAcceleration * elapsedTime;
 
     // enforce speed limit
-    newVelocity = Vec3Utils::truncateLength(newVelocity, maxSpeed());
+    newVelocity = Vec3Utils::truncateLength(newVelocity, getMaxSpeed());
 
     // update Speed
     setSpeed (newVelocity.length());
 
     // Euler integrate (per frame) velocity into position
-    setPosition (position() + (newVelocity * elapsedTime));
+    setPosition (getPosition() + (newVelocity * elapsedTime));
 
     // regenerate local space (by default: align vehicle's forward axis with
     // new velocity, but this behavior may be overridden by derived classes.)
@@ -207,7 +207,7 @@
 
     // running average of recent positions
     blendIntoAccumulator (elapsedTime * 0.06f, // QQQ
-                          position(),
+                          getPosition(),
                           _smoothedPosition);
 }
 
@@ -224,7 +224,7 @@
                                                 const float /* elapsedTime */)
 {
     // adjust orthonormal basis vectors to be aligned with new velocity
-    if (speed() &gt; 0) regenerateOrthonormalBasisUF (newVelocity / speed());
+    if (getSpeed() &gt; 0) regenerateOrthonormalBasisUF (newVelocity / getSpeed());
 }
 
 
@@ -253,17 +253,17 @@
 
     // blend bankUp into vehicle's UP basis vector
     const float smoothRate = elapsedTime * 3;
-    Vector3 tempUp = up();
+    Vector3 tempUp = getUp();
     blendIntoAccumulator (smoothRate, bankUp, tempUp);
     setUp (tempUp.normalisedCopy());
 
-//  annotationLine (position(), position() + (globalUp * 4), gWhite);  // XXX
-//  annotationLine (position(), position() + (bankUp   * 4), gOrange); // XXX
-//  annotationLine (position(), position() + (accelUp  * 4), gRed);    // XXX
-//  annotationLine (position(), position() + (up()    * 1), gYellow); // XXX
+//  annotationLine (getPosition(), getPosition() + (globalUp * 4), gWhite);  // XXX
+//  annotationLine (getPosition(), getPosition() + (bankUp   * 4), gOrange); // XXX
+//  annotationLine (getPosition(), getPosition() + (accelUp  * 4), gRed);    // XXX
+//  annotationLine (getPosition(), getPosition() + (getUp()    * 1), gYellow); // XXX
 
     // adjust orthonormal basis vectors to be aligned with new velocity
-    if (speed() &gt; 0) regenerateOrthonormalBasisUF (newVelocity / speed());
+    if (getSpeed() &gt; 0) regenerateOrthonormalBasisUF (newVelocity / getSpeed());
 }
 
 
@@ -276,16 +276,16 @@
 {
     if (elapsedTime &gt; 0)
     {
-        const Vector3 dP = _lastPosition - position();
-        const Vector3 dF = (_lastForward - forward()) / dP.length();
-        const Vector3 lateral = Vec3Utils::perpendicularComponent(dF, forward());
-        const float sign = (lateral.dotProduct(side()) &lt; 0) ? 1.0f : -1.0f;
+        const Vector3 dP = _lastPosition - getPosition();
+        const Vector3 dF = (_lastForward - getForward()) / dP.length();
+        const Vector3 lateral = Vec3Utils::perpendicularComponent(dF, getForward());
+        const float sign = (lateral.dotProduct(getSide()) &lt; 0) ? 1.0f : -1.0f;
         _curvature = lateral.length() * sign;
         blendIntoAccumulator (elapsedTime * 4.0f,
                               _curvature,
                               _smoothedCurvature);
-        _lastForward = forward();
-        _lastPosition = position();
+        _lastForward = getForward();
+        _lastPosition = getPosition();
     }
 }
 
@@ -299,9 +299,9 @@
                                                           float maxLengthV)
 {
     const float desat = 0.4f;
-    const float aScale = maxLengthA / maxForce();
-    const float vScale = maxLengthV / maxSpeed();
-    const Vector3&amp; p = position();
+    const float aScale = maxLengthA / getMaxForce();
+    const float vScale = maxLengthV / getMaxSpeed();
+    const Vector3&amp; p = getPosition();
     const Color aColor (desat, desat, 1); // bluish
     const Color vColor (    1, desat, 1); // pinkish
 
@@ -323,7 +323,7 @@
 Vector3 
 OpenSteer::SimpleVehicle::predictFuturePosition (const float predictionTime) const
 {
-    return position() + (velocity() * predictionTime);
+    return getPosition() + (velocity() * predictionTime);
 }
 
 

Modified: modules/common/scripts/npc.rb
===================================================================
--- modules/common/scripts/npc.rb	2007-08-27 23:55:37 UTC (rev 3767)
+++ modules/common/scripts/npc.rb	2007-08-28 21:21:18 UTC (rev 3768)
@@ -11,18 +11,12 @@
       bot = $AI.loadBot(object.getName(), object.getDialogfile())
     end
     if ( not bot.nil? )
-	  p &quot;foo1&quot;
       bot.setPlayerCharacter( actor );
-	  p &quot;foo2&quot;
       bot.setNonPlayerCharacter( object );
-	  p &quot;foo3&quot;
-	  p &quot;foo4&quot;
 	  agent = AgentManager::getSingleton().createAgent(object)
 	  agent.pushState(RlScript::AST_DIALOG);
-	  p &quot;foo5&quot;
 	  agent.getCurrentState().setDialogPartner(
 		AgentManager::getSingleton().createAgent(actor))
-	  p &quot;foo6&quot;
     end
   end
 end

Modified: rl/trunk/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/trunk/engine/ai/RlAI2005.vcproj	2007-08-27 23:55:37 UTC (rev 3767)
+++ rl/trunk/engine/ai/RlAI2005.vcproj	2007-08-28 21:21:18 UTC (rev 3768)
@@ -250,7 +250,7 @@
 				AdditionalDependencies=&quot;OgreMain.lib OgreNewt.lib CEGUIBase.lib opensteer.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib MadaBot.lib xerces-c_2.lib&quot;
 				OutputFile=&quot;$(OutDir)/RlAI.dll&quot;
 				LinkIncremental=&quot;1&quot;
-				AdditionalLibraryDirectories=&quot;&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\dialog\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;&quot;..\..\dependencies\aiml\MadaBot\lib\$(ConfigurationName)&quot;;..\..\dependencies\xerces\lib&quot;
+				AdditionalLibraryDirectories=&quot;..\common\lib\Release;..\core\lib\Release;..\rules\lib\Release;..\dialog\lib\Release;..\..\dependencies\ogrenew\lib\;..\..\dependencies\ogrenewt\lib\Release;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\aiml\MadaBot\lib\Release&quot;
 				GenerateDebugInformation=&quot;true&quot;
 				SubSystem=&quot;2&quot;
 				OptimizeReferences=&quot;2&quot;
@@ -513,6 +513,10 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\include\AiMessages.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\include\AimlNodeImplRl.h&quot;
 				&gt;
 			&lt;/File&gt;

Added: rl/trunk/engine/ai/include/AiMessages.h
===================================================================
--- rl/trunk/engine/ai/include/AiMessages.h	2007-08-27 23:55:37 UTC (rev 3767)
+++ rl/trunk/engine/ai/include/AiMessages.h	2007-08-28 21:21:18 UTC (rev 3768)
@@ -0,0 +1,42 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __Rl_AiMessages_H__
+#define __Rl_AiMessages_H__
+
+#include &quot;AiPrerequisites.h&quot;
+#include &quot;MessageType.h&quot;
+
+namespace rl
+{
+    class DialogCharacter;
+
+    enum AiMessageTypeIds
+    {
+        // Controllers //
+        // Mask
+        RLMSG_CONTROLLERS_EVENTS            = 0x02000100,
+        // Events
+        RLMSG_CONTROLLERS_DIALOG_STARTED    = 0x02000101,
+        RLMSG_CONTROLLERS_DIALOG_ENDED      = 0x02000102,
+    };
+
+    /// Message sent when a dialog with the player will be started
+    typedef MessageType&lt;RLMSG_CONTROLLERS_DIALOG_STARTED/*, DialogCharacter* */&gt; 
+        MessageType_DialogStarted;
+}
+
+#endif

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-08-27 23:55:37 UTC (rev 3767)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-08-28 21:21:18 UTC (rev 3768)
@@ -173,7 +173,7 @@
 		/** get mass
 		 * @returns mass of physical object
 		 */
-		float mass() const;
+		float getMass() const;
 		/** does not set mass but is necessary for AbstractVehicle.
 		 * throws an exception on invocation.
 		 * @param m mass
@@ -183,12 +183,12 @@
 		/** retrieve velocity of vehicle
 		 * @returns velocity of the vehicle
 		 */
-		Ogre::Vector3 velocity() const {return mCurrentVelocity;}
+		Ogre::Vector3 getVelocity() const {return mCurrentVelocity;}
 
 		/** retrieves speed of vehicle.
 		 * may be faster than taking mag of velocity
 		 */
-		float speed() const;
+		float getSpeed() const;
 		/** sets speed of vehicle.
 		 * may be faster than taking mag of velocity
 		 * @param s new speed to set
@@ -201,7 +201,7 @@
 		 * TODO: this should be handled by size of NewtonBody
 		 * @returns float the radius
 	    */
-		float radius() const;
+		float getRadius() const;
 		/** sets radius for size of bounding sphere.
 		 * used for obstacle avoidance, etc.
 		 * TODO: this should be handled by size of NewtonBody
@@ -214,7 +214,7 @@
 		 * TODO: this should be handled by height of NewtonBody
 		 * @returns float the height
 	    */
-        float height() const;
+        float getHeight() const;
 		/** height for size of bounding sphere.
 		 * used for obstacle avoidance, etc.
 		 * TODO: this should be handled by height of NewtonBody
@@ -225,7 +225,7 @@
 		/** retrieves maximum force.
 		 * @returns float containing maximum force.
 		 */
-		float maxForce() const; 
+		float getMaxForce() const; 
 		/** sets maximum force.
 		 * TODO: should not be set here, throw excpetion or so
 		 * @returns float containing maximum force set.
@@ -235,7 +235,7 @@
 		/** retrieves maximum speed.
 		 * @returns float containing maximum speed
 		 */
-		float maxSpeed() const;
+		float getMaxSpeed() const;
 		/** retrieves maximum speed.
 		 * TODO: should not be set here, throw excpetion or so
 		 * @returns float containing maximum speed

Modified: rl/trunk/engine/ai/src/AgentDialogState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentDialogState.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ rl/trunk/engine/ai/src/AgentDialogState.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -18,9 +18,11 @@
 #include &quot;AgentDialogState.h&quot;
 
 #include &quot;Agent.h&quot;
+#include &quot;AiMessages.h&quot;
 #include &quot;Creature.h&quot;
 #include &quot;CreatureController.h&quot;
 #include &quot;CreatureControllerManager.h&quot;
+#include &quot;MessagePump.h&quot;
 
 using namespace Ogre;
 
@@ -49,30 +51,28 @@
                 CreatureControllerManager::getSingleton().getCreatureController(
                     mAgent-&gt;getControlledCreature());
 
-        if (mAgent-&gt;getPosition().squaredDistance(mPartner-&gt;getPosition()) &gt; 1.5)
+        if (mAgent-&gt;getPosition().squaredDistance(mPartner-&gt;getPosition()) &gt; 1.5
+            || !mAgent-&gt;isAhead(mPartner, 0.95))
         {		
-            mAgent-&gt;addForce(mAgent-&gt;calcPursuit(mPartner));
+            mAgent-&gt;addForce(mAgent-&gt;calcSeek(mPartner-&gt;getPosition()));
             mAgent-&gt;updateVehicle(0, elapsedTime);
         }
-        //else if (!mAgent-&gt;isAhead(mPartner, 0.95)) 
-        //{		
-        //    mAgent-&gt;addForce(mAgent-&gt;calcPursuit(mPartner));
-        //    mAgent-&gt;updateVehicle(0, elapsedTime);
-        //}
-        ///@todo: Turn if near but not correctly oriented
 		else
         {
 			if (!mTalking)
             {
                 mAgent-&gt;reset();
-                ctrl-&gt;setMovement(CreatureController::MT_NONE, Vector3::ZERO, Vector3::ZERO);
-		        //$IM.pushControlState(CST_DIALOG);
+                ctrl-&gt;setMovement(
+                    CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
 
                 ctrl-&gt;setAnimation(&quot;reden&quot;);
 				mTalking = true;
+
+                MessagePump::getSingleton().sendMessage&lt;MessageType_DialogStarted&gt;();
+                
+                mAgent-&gt;popState();
             }			
         }
 
-
     }
 } // namespace rl

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -96,8 +96,8 @@
     // Dadurch ist ungefaehr der Umriss gesichert!
     // Habe bisher keine elegantere Loesung gefunden
     RaycastType raycastType;
-    Vector3 pos = vehicle.position();
-    Vector3 futPos = vehicle.forward() * vehicle.speed() * 3 + pos;
+    Vector3 pos = vehicle.getPosition();
+    Vector3 futPos = vehicle.getForward() * vehicle.getSpeed() * 3 + pos;
 
 
     if (pos == futPos)
@@ -114,8 +114,8 @@
 
     if( steerVec != NULL )
     {
-        pos = pos + Ogre::Vector3::UNIT_Y*steerVec-&gt;height()/2.0;
-        futPos = futPos + Ogre::Vector3::UNIT_Y*steerVec-&gt;height()/2.0;
+        pos = pos + Ogre::Vector3::UNIT_Y*steerVec-&gt;getHeight()/2.0;
+        futPos = futPos + Ogre::Vector3::UNIT_Y*steerVec-&gt;getHeight()/2.0;
     }
 
 
@@ -137,18 +137,18 @@
         else if( raycastType == RIGHT )
         {
             // so wir ham ne normale und machen uns nen Y
-            if( vehicle.radius() == 0 )
+            if( vehicle.getRadius() == 0 )
                 continue;
-            Vector3 offset = vehicle.side().normalisedCopy() * (vehicle.radius() - 0.1);
+            Vector3 offset = vehicle.getSide().normalisedCopy() * (vehicle.getRadius() - 0.1);
             castPos = pos + offset;
             castFutPos = futPos + offset;
         }
         else if( raycastType == LEFT )
         {
             // wie bei right ...
-            if( vehicle.radius() == 0 )
+            if( vehicle.getRadius() == 0 )
                 continue;
-            Vector3 offset = vehicle.side().normalisedCopy() * (vehicle.radius() - 0.1);
+            Vector3 offset = vehicle.getSide().normalisedCopy() * (vehicle.getRadius() - 0.1);
             castPos = pos - offset;
             castFutPos = futPos - offset;
         }
@@ -156,7 +156,7 @@
         {
             if( steerVec == NULL ) // hier abbrechen
                 break;
-            float height = steerVec-&gt;height();
+            float height = steerVec-&gt;getHeight();
             if( height == 0 )
                 break;
             if( raycastType == TOP )
@@ -209,7 +209,7 @@
         pi.obstacle = this;
         pi.distance = infoNearest.mDistance * (futPos - pos).length();
         pi.surfacePoint =
-        vehicle.position() + (vehicle.forward() * pi.distance);
+        vehicle.getPosition() + (vehicle.getForward() * pi.distance);
 
         // Die normale muss zu uns zeigen! koennte aber auch in die entgegengesetzte Richtung sein!
         pi.surfaceNormal = Vector3(infoNearest.mNormal.x, infoNearest.mNormal.y, infoNearest.mNormal.z);

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * Copyright(C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
@@ -22,6 +22,7 @@
 #include &quot;Agent.h&quot;
 #include &quot;Actor.h&quot;
 #include &quot;Creature.h&quot;
+#include &quot;CreatureController.h&quot;
 #include &quot;CreatureControllerManager.h&quot;
 #include &quot;MeshObject.h&quot;
 #include &quot;CreatureController.h&quot;
@@ -50,25 +51,25 @@
         mCreature);
 }
 
-SteeringVehicle::~SteeringVehicle(void)
+SteeringVehicle::~SteeringVehicle()
 {
 }
 
 void SteeringVehicle::resetLocalSpace()
 {
 	setForward(mForwardVector);
-	setSide(localRotateForwardToSide(forward()));
+	setSide(localRotateForwardToSide(getForward()));
     setUp(Vector3::UNIT_Y);
-	Vector3 pos = mCreature-&gt;getActor()-&gt;getPosition();
+	Vector3 pos = mCreature-&gt;getPosition();
 	setPosition(pos);
-	Vector3 src = mCreature-&gt;getActor()-&gt;getOrientation()*Vector3::NEGATIVE_UNIT_Z;
+	Vector3 src = mCreature-&gt;getOrientation()*Vector3::NEGATIVE_UNIT_Z;
 
-    // regenerate local space (by default: align vehicle's forward axis with
+    // regenerate local space(by default: align vehicle's forward axis with
     // new velocity, but this behavior may be overridden by derived classes.)
-	regenerateOrthonormalBasisUF ( src);
+	regenerateOrthonormalBasisUF(src);
 }
 
-void SteeringVehicle::initialize(void)
+void SteeringVehicle::initialize()
 {
     // reset LocalSpace state
 	resetLocalSpace();
@@ -76,8 +77,8 @@
     // reset SteerLibraryMixin state
 	SimpleVehicle_2::reset();
 
-	setMaxForce (1.0f);   // steering force is clipped to this magnitude
-	setMaxSpeed (1.0f);   // velocity is clipped to this magnitude
+	setMaxForce(1.0f);   // steering force is clipped to this magnitude
+	setMaxSpeed(1.0f);   // velocity is clipped to this magnitude
 }
 
 void SteeringVehicle::addForce(const Ogre::Vector3&amp; force)
@@ -92,23 +93,20 @@
 
 	OgreNewt::Body* body = mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
 
-    Vector3 position;
-	Quaternion orientation;
-	body-&gt;getPositionOrientation(position, orientation);
-	setPosition(position);
+	setPosition(mCreature-&gt;getPosition());
 
     //  Get the velocity vector
 	mCurrentVelocity = body-&gt;getVelocity();
 	//  enforce speed limit
-	//  newVelocity = newVelocity.truncateLength (maxSpeed ());
+	//  newVelocity = newVelocity.truncateLength(maxSpeed());
 	//  update speed
 	setSpeed(mCurrentVelocity.length());
 	Vector3 newVelocity(mCurrentVelocity);
 
-    //  regenerate local space (by default: align vehicle's forward axis with
+    //  regenerate local space(by default: align vehicle's forward axis with
     //  new velocity, but this behavior may be overridden by derived classes.)
     // use future orientation or not??
-    orientation = Quaternion(mController-&gt;getYaw(), Ogre::Vector3::UNIT_Y);
+    Quaternion orientation(mController-&gt;getYaw(), Ogre::Vector3::UNIT_Y);
     Vector3 newUnitForward = orientation*Vector3::NEGATIVE_UNIT_Z;
     regenerateOrthonormalBasisUF(newUnitForward);
 
@@ -162,6 +160,10 @@
 
 
     mController-&gt;setMovement(movement, direction, rotation);
+    LOG_MESSAGE(&quot;mController-&gt;setMovement&quot;,
+        Ogre::StringConverter::toString(movement) + &quot;, &quot;
+        + Ogre::StringConverter::toString(direction) + &quot;, &quot;
+        + Ogre::StringConverter::toString(rotation));
 
 	mCurrentForce = Ogre::Vector3::ZERO;
 }
@@ -223,7 +225,7 @@
 bool SteeringVehicle::needAvoidance(const float minTimeToCollision)
 {
 	Vector3 rVal = calcAvoidNeighbors(minTimeToCollision) + calcAvoidObstacles(minTimeToCollision);
-	if(rVal == Vector3::ZERO)
+	if (rVal == Vector3::ZERO)
 	{
 		return false;
 	}
@@ -239,7 +241,7 @@
 	//{
 	//	if ((*itr) != this)
 	//	{
-	//		group.push_back( (*itr));
+	//		group.push_back((*itr));
 	//	}
 	//}
 	return group;
@@ -253,81 +255,81 @@
 
 Vector3 SteeringVehicle::getPosition()
 {
-	return position();
+	return mCreature-&gt;getPosition();
 }
 
-float SteeringVehicle::mass (void) const 
+float SteeringVehicle::getMass() const 
 {
-    return mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;getMass();
+    return mCreature-&gt;getMass();
 }
 
-float SteeringVehicle::setMass (float m) 
+float SteeringVehicle::setMass(float m) 
 {
 	// don't set mass here TODO: throw exception
 
 	return 1;
 } 
 
-float SteeringVehicle::speed (void) const 
+float SteeringVehicle::getSpeed() const 
 {
 	return mSpeed;
 }
 
-float SteeringVehicle::setSpeed (float s) 
+float SteeringVehicle::setSpeed(float s) 
 {
-	return mSpeed = s;
+	return 1;
 }
 
-float SteeringVehicle::radius (void) const 
+float SteeringVehicle::getRadius() const 
 {
 	// this is only the radius in x axis, but i think, this is the value that should be used here
     Ogre::AxisAlignedBox aab = mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getCollision()-&gt;getAABB();
-    return (aab.getMaximum().x - aab.getMinimum().x)/2;
+    return(aab.getMaximum().x - aab.getMinimum().x)/2;
 }
 
-float SteeringVehicle::setRadius (float m) 
+float SteeringVehicle::setRadius(float m) 
 {
 	// don't set mass here TODO: throw exception
 	return 1;
 }
 
-float SteeringVehicle::height (void) const 
+float SteeringVehicle::getHeight() const 
 {
     Ogre::AxisAlignedBox aab = mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getCollision()-&gt;getAABB();
     return aab.getMaximum().y - aab.getMinimum().y;
 }
 
-float SteeringVehicle::setHeight (float h) 
+float SteeringVehicle::setHeight(float h) 
 {
 	// don't set mass here TODO: throw exception
 	return 1;
 }
 
-const Actor* SteeringVehicle::getActor(void) const  
+const Actor* SteeringVehicle::getActor() const  
 { 
 	return mCreature-&gt;getActor(); 
 }
 
-float SteeringVehicle::maxForce (void) const 
+float SteeringVehicle::getMaxForce() const 
 {
 	return 10000.0f;
 } 
 
-float SteeringVehicle::setMaxForce (float mf) 
+float SteeringVehicle::setMaxForce(float mf) 
 {
 	 // TODO: should not be set here, throw excpetion or so
 	return _maxForce = mf;
 }
 
-float SteeringVehicle::maxSpeed (void) const 
+float SteeringVehicle::getMaxSpeed() const 
 {
-	return 100000; 
+	return mController-&gt;getMaximumSpeed();
 }
 
-float SteeringVehicle::setMaxSpeed (float ms) 
+float SteeringVehicle::setMaxSpeed(float ms) 
 {
 	 // TODO: should not be set here, throw excpetion or so
-	return _maxSpeed = ms;
+	return 1;
 }
 
 const ObstacleGroup&amp; SteeringVehicle::getObstacles() const
@@ -337,28 +339,28 @@
 
 Vector3 SteeringVehicle::predictFuturePosition(const float predictionTime) const
 {
-	//return position() + (velocity() * predictionTime);
-	return velocity() * predictionTime;
+	//return position() +(velocity() * predictionTime);
+	return getVelocity() * predictionTime;
 }
 
 Vector3 SteeringVehicle::adjustRawSteeringForce(const Vector3&amp; force)
 {
-    const float maxAdjustedSpeed = 0.2f * maxSpeed ();
+    const float maxAdjustedSpeed = 0.2f * getMaxSpeed();
 
-    if ((speed () &gt; maxAdjustedSpeed) || (force == Vector3::ZERO))
+    if ((getSpeed() &gt; maxAdjustedSpeed) ||(force == Vector3::ZERO))
     {
         return force;
     }
     else
     {
-        const float range = speed() / maxAdjustedSpeed;
-        // const float cosine = interpolate (pow (range, 6), 1.0f, -1.0f);
-        // const float cosine = interpolate (pow (range, 10), 1.0f, -1.0f);
-        // const float cosine = interpolate (pow (range, 20), 1.0f, -1.0f);
-        // const float cosine = interpolate (pow (range, 100), 1.0f, -1.0f);
-        // const float cosine = interpolate (pow (range, 50), 1.0f, -1.0f);
-        const float cosine = interpolate (pow (range, 20), 1.0f, -1.0f);
-        return limitMaxDeviationAngle (force, cosine, forward());
+        const float range = getSpeed() / maxAdjustedSpeed;
+        // const float cosine = interpolate(pow(range, 6), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 10), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 20), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 100), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 50), 1.0f, -1.0f);
+        const float cosine = interpolate(pow(range, 20), 1.0f, -1.0f);
+        return limitMaxDeviationAngle(force, cosine, getForward());
     }
 }
 
@@ -378,17 +380,17 @@
     LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
     lineSet-&gt;clear();
     
-    if(mDebugSteer != Vector3::ZERO)
+    if (mDebugSteer != Vector3::ZERO)
     {
         lineSet-&gt;addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugSteer.normalisedCopy()*0.5, ColourValue::Black);
         mDebugSteer = Vector3::ZERO;
     }
-    if(mDebugWander != Vector3::ZERO)
+    if (mDebugWander != Vector3::ZERO)
     {
         lineSet-&gt;addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugWander.normalisedCopy()*0.5, ColourValue::Green);
         mDebugWander = Vector3::ZERO;
     }
-    if(mDebugAvoidObstacles != Vector3::ZERO)
+    if (mDebugAvoidObstacles != Vector3::ZERO)
     {
         lineSet-&gt;addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugAvoidObstacles.normalisedCopy()*0.5, ColourValue::Red);
         mDebugAvoidObstacles = Vector3::ZERO;
@@ -399,4 +401,5 @@
 {
     mPrimitive = new LineSetPrimitive();
 }
-}
+
+} // namespace rl

Modified: rl/trunk/engine/rules/include/CreatureController.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureController.h	2007-08-27 23:55:37 UTC (rev 3767)
+++ rl/trunk/engine/rules/include/CreatureController.h	2007-08-28 21:21:18 UTC (rev 3768)
@@ -131,6 +131,7 @@
 
         // some methods used by movements
         int getCurrentGS() const;
+        Ogre::Real getMaximumSpeed() const;
         Ogre::Vector3 getVelocity() const; // in local axes
         Ogre::Vector3 getOmega() const;
         MeshAnimation *setAnimation(const Ogre::String &amp;name, 

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2007-08-27 23:55:37 UTC (rev 3767)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2007-08-28 21:21:18 UTC (rev 3768)
@@ -1218,6 +1218,11 @@
         return max(act_gs,1);
     }
 
+    Ogre::Real CreatureController::getMaximumSpeed() const
+    {
+        return getCurrentGS() * 1.2; // GS = m/KR
+    }
+
     MeshAnimation *CreatureController::setAnimation(const Ogre::String &amp;name, Ogre::Real speed, unsigned int timesToPlay, const Ogre::String &amp;collisionName, Real weight)
     {
         MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(mCreature-&gt;getActor()-&gt;getControlledObject());


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000838.html">[Dsa-hl-svn] r3767 - modules/common/dsa modules/common/scripts	modules/regressiontest/dsa rl/trunk/engine/rules/include	rl/trunk/engine/rules/src
</A></li>
	<LI>Next message: <A HREF="000840.html">[Dsa-hl-svn] r3769 - in rl/trunk/engine: core script
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#839">[ date ]</a>
              <a href="thread.html#839">[ thread ]</a>
              <a href="subject.html#839">[ subject ]</a>
              <a href="author.html#839">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
