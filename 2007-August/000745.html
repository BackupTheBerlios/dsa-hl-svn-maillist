<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r3674 - in rl/trunk/engine: ai ai/include ai/src rules	rules/include rules/src script/swig ui/include ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3674%20-%20in%20rl/trunk/engine%3A%20ai%20ai/include%20ai/src%20rules%0A%09rules/include%20rules/src%20script/swig%20ui/include%20ui/src&In-Reply-To=%3C200708072121.l77LLN54023087%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000744.html">
   <LINK REL="Next"  HREF="000746.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r3674 - in rl/trunk/engine: ai ai/include ai/src rules	rules/include rules/src script/swig ui/include ui/src</H1>
    <B>tanis at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3674%20-%20in%20rl/trunk/engine%3A%20ai%20ai/include%20ai/src%20rules%0A%09rules/include%20rules/src%20script/swig%20ui/include%20ui/src&In-Reply-To=%3C200708072121.l77LLN54023087%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r3674 - in rl/trunk/engine: ai ai/include ai/src rules	rules/include rules/src script/swig ui/include ui/src">tanis at mail.berlios.de
       </A><BR>
    <I>Tue Aug  7 23:21:23 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000744.html">[Dsa-hl-svn] r3673 - in modules/common/materials: model programs
</A></li>
        <LI>Next message: <A HREF="000746.html">[Dsa-hl-svn] r3675 - modules/combattest/dsa
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#745">[ date ]</a>
              <a href="thread.html#745">[ thread ]</a>
              <a href="subject.html#745">[ subject ]</a>
              <a href="author.html#745">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tanis
Date: 2007-08-07 23:20:27 +0200 (Tue, 07 Aug 2007)
New Revision: 3674

Added:
   rl/trunk/engine/ai/include/AgentCombatState.h
   rl/trunk/engine/ai/include/AgentState.h
   rl/trunk/engine/ai/include/AgentSteeringState.h
   rl/trunk/engine/ai/src/AgentCombatState.cpp
   rl/trunk/engine/ai/src/AgentSteeringState.cpp
   rl/trunk/engine/rules/include/Combatant.h
   rl/trunk/engine/rules/src/Combatant.cpp
Removed:
   rl/trunk/engine/ai/include/PlayerVehicle.h
   rl/trunk/engine/ai/src/PlayerVehicle.cpp
Modified:
   rl/trunk/engine/ai/RlAI2005.vcproj
   rl/trunk/engine/ai/include/Agent.h
   rl/trunk/engine/ai/include/AgentManager.h
   rl/trunk/engine/ai/include/Makefile.am
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/Agent.cpp
   rl/trunk/engine/ai/src/AgentManager.cpp
   rl/trunk/engine/ai/src/Makefile.am
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/rules/RlRules2005.vcproj
   rl/trunk/engine/rules/include/Combat.h
   rl/trunk/engine/rules/include/CombatManager.h
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/CreatureController.h
   rl/trunk/engine/rules/include/CreatureControllerManager.h
   rl/trunk/engine/rules/include/Makefile.am
   rl/trunk/engine/rules/src/Combat.cpp
   rl/trunk/engine/rules/src/CombatManager.cpp
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/CreatureController.cpp
   rl/trunk/engine/rules/src/CreatureControllerManager.cpp
   rl/trunk/engine/rules/src/Makefile.am
   rl/trunk/engine/script/swig/RlAi.swig
   rl/trunk/engine/ui/include/CombatControlState.h
   rl/trunk/engine/ui/include/MovementControlState.h
   rl/trunk/engine/ui/src/CombatControlState.cpp
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
Intermediate state of combat development.
Changed the way AI works. OpenSteer is no longer the top agent layer, instead steering is one discrete agent state among others (combat, dialog).
Changed CreatureController-API so that CreatureControllers are created transparently if one is requested. This way higher level layers like AI and UI have better access to controllers.
Every module save combattest should work fine.

Modified: rl/trunk/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/trunk/engine/ai/RlAI2005.vcproj	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/RlAI2005.vcproj	2007-08-07 21:20:27 UTC (rev 3674)
@@ -299,10 +299,18 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\src\AgentCombatState.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\src\AgentManager.cpp&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\src\AgentSteeringState.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\src\AiSubsystem.cpp&quot;
 				&gt;
 			&lt;/File&gt;
@@ -347,10 +355,6 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\src\PlayerVehicle.cpp&quot;
-				&gt;
-			&lt;/File&gt;
-			&lt;File
 				RelativePath=&quot;.\src\stdinc.cpp&quot;
 				&gt;
 				&lt;FileConfiguration
@@ -405,10 +409,22 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\include\AgentCombatState.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\include\AgentManager.h&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\include\AgentState.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\include\AgentSteeringState.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\include\AiPrerequisites.h&quot;
 				&gt;
 			&lt;/File&gt;
@@ -465,10 +481,6 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\include\PlayerVehicle.h&quot;
-				&gt;
-			&lt;/File&gt;
-			&lt;File
 				RelativePath=&quot;.\include\stdinc.h&quot;
 				&gt;
 			&lt;/File&gt;

Modified: rl/trunk/engine/ai/include/Agent.h
===================================================================
--- rl/trunk/engine/ai/include/Agent.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/include/Agent.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -16,16 +16,15 @@
 #ifndef __RlAI_Agent_H__
 #define __RlAI_Agent_H__
 
-#include &quot;FuzzyState.h&quot;
 #include &quot;AgentManager.h&quot;
+#include &quot;AgentState.h&quot;
 
+#include &lt;stack&gt;
+
 namespace rl
 {
-	class SteeringVehicle;
-	class SteeringMachine;
-	class DialogCharacter;
-	class Creature;
 	class Actor;
+	class Creature;
 
 	/** Represents a single entity that has got AI.
 	 * Instantiated objects are normally registered with AgentManager.
@@ -40,11 +39,6 @@
 		 * @param character Creature object
 		 */
 		Agent(Creature* character);
-		/** Constructor by Creature object.
-		 * @param character Creature object
-		 * @param vehicle SteeringVehicle object for the specified creature
-		 */
-		Agent(Creature* character, SteeringVehicle* vehicle);
 
 		/** explicit virtual destructor
 		 */
@@ -55,17 +49,10 @@
 		 * supplied on object creation. Creates a behaviour state machine and
 		 * registers itself as a PhysicsController with PhysicalManager for the
 		 * stored creature object.
+         * Also pushes the SteeringState as the default state onto the state stack.
 		 */
 		void initialize();
 
-		/** Returns the agent type (Player, NPC, etc.).
-		 */
-		AgentManager::AgentType getType();
-		/** Sets the agent type (Player, NPC, etc. ).
-		 * @param type AgentType sets the type to the given one.
-		 */
-		void setType(AgentManager::AgentType type);
-
 		/** Function invoked by AgentManager to let Agents advance their AI.
 		 * Is invoked with time since last invocation. Here the behaviour and
 		 * the vehicle are updated.
@@ -74,50 +61,22 @@
 		/** Adds a steering behaviour to the internal steering machine.
 		 * @param behaviour SteeringBehaviour is initialized and registered to mBehaviour.
 		 */
-		void addSteeringBehaviour(SteeringBehaviour* behaviour);
-		/** Removes all steering behaviours.
-		 */
-        void clearSteeringBehaviours();
 
-		/** Retrieves the stored SteeringVehicle.
-		 */
-		SteeringVehicle* getVehicle();
-
 		/** Retrieves the Creature object controlled by this agent
 		 * @returns Creature object controlled
 		 */
         Creature* getControlledCreature() const;
 
+        AgentState* getCurrentState() const;
+
+        void pushState(AgentStateType);
+        void popState();
+
 	protected:
-		//! stores the type of the agent (Player, NPC, ...)
-		AgentManager::AgentType mType;
-		//! stores the behaviour FuzzyStateMachine for behaviour
-		SteeringMachine* mBehaviour;
-		//! stores the vehicle representation of the creature
-		SteeringVehicle* mVehicle;
+        typedef std::deque&lt;AgentState*&gt; AgentStateStack;
 		//! stores the creature whose AI is simulated
 		Creature* mCreature;
+        std::stack&lt;AgentState*&gt; mAgentStates;
 	};
-
-	inline AgentManager::AgentType Agent::getType()
-	{
-		return mType;
-	}
-
-	inline SteeringVehicle* Agent::getVehicle()
-	{
-		return mVehicle;
-	}
-
-	inline void Agent::setType(AgentManager::AgentType type)
-	{
-		mType = type;
-	}
-
-/*	inline PerceptionPool* Agent::getPerceptionPool()
-	{
-		return mPerceptionPool;
-	}
-*/
 }
 #endif

Added: rl/trunk/engine/ai/include/AgentCombatState.h
===================================================================
--- rl/trunk/engine/ai/include/AgentCombatState.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/include/AgentCombatState.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -0,0 +1,46 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
+ */
+#ifndef __RlAI_AgentCombatState_H__
+#define __RlAI_AgentCombatState_H__
+
+#include &quot;AiPrerequisites.h&quot;
+#include &quot;AgentState.h&quot;
+#include &quot;Combatant.h&quot;
+
+namespace rl
+{
+	/** Represents a discrete state an Agent can be in.
+     * The Agent delegates the decision making to the currently active state, wich can
+     * further deligate decision making.
+	 */
+    class _RlAiExport AgentCombatState : public AgentState, public Combatant
+	{
+	public:
+        /// @param agent the agent this state works upon.
+        AgentCombatState(Agent* agent);
+
+        virtual ~AgentCombatState();
+
+        virtual Ogre::String getTypeName();
+
+		/** Function invoked by Agents to advance the AI.
+		 * Decision making is done here.
+         * @param elapsedTime time since last update call.
+		 */
+		virtual void update(const float elapsedTime);
+	};
+}
+#endif

Modified: rl/trunk/engine/ai/include/AgentManager.h
===================================================================
--- rl/trunk/engine/ai/include/AgentManager.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/include/AgentManager.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -18,6 +18,7 @@
 
 #include &lt;OgreSingleton.h&gt;
 #include &quot;AiPrerequisites.h&quot;
+#include &quot;Combatant.h&quot;
 #include &quot;GameTask.h&quot;
 #include &quot;GameObjectStateListener.h&quot;
 #include &quot;FuzzyState.h&quot;
@@ -47,22 +48,11 @@
 	class _RlAiExport AgentManager
 		: public Ogre::Singleton&lt;AgentManager&gt;,
 		  public GameTask,
-          public GameObjectStateListener
+          public GameObjectStateListener,
+          public CombatantFactory
 		  
 	{
 	public:
-		/** Different types of agents.
-		 * Implemented in order to recognise different types of agents, because
-		 * the AI needs to handle them differently.
-		 */
-		enum AgentType
-		{
-			AGENT_NONE = -1,	//!&lt; when the type is unknown/unset
-			AGENT_PLAYER = 0,	//!&lt; when the agent represents a player
-			AGENT_STD_NPC = 1,	//!&lt; when the agent is a nonplayercharacter
-			AGENT_FLOCKING = 2	//!&lt; hmm, possibly for groups behaviour of NPCs
-		};
-
 		//! defines a std::vector list of Vehicle objects for OpenSteer
 		typedef std::vector&lt;SteeringVehicle*&gt; VehicleList;
 
@@ -76,14 +66,11 @@
 		 * @param type defines the type of the agent \see AgentType
 		 * @param character the associated creature
 		 */
-		Agent* createAgent(AgentType type, Creature* character);
+		Agent* createAgent(Creature* character);
 
         //! Destroys an Agent and all its behaviours. (if any)
         void destroyAgent(Agent*);
 
-		//! ??? purpose ??? needed for opensteer ?
-		VehicleList getNeighbors(Agent* agent);
-
 		/** Interface executed as a GameTask by GameLoop.
 		 * is responsible for advancing the ai logik about the time specified.
 		 * Each registered Agent is executed can advance the specified time.
@@ -107,6 +94,11 @@
 
         /// Set the factory to be used to create behaviours.
         virtual void setBehaviourFactory(BehaviourFactory*);
+
+        // overrides from CombatantFactory
+        virtual Combatant* createCombatant(Creature* creature);
+        virtual void destroyCombatant(Combatant*);
+
 	private:
 
 		/** Used to register an agent internally.
@@ -116,15 +108,13 @@
 		void addAgent(Agent* agent);
 
 		//! defines a std::vector of Agents to ease understanding
-		typedef std::vector&lt;Agent*&gt; AgentList;
+		typedef std::map&lt;Creature*, Agent*&gt; AgentMap;
 
         //! Factory to create behaviours with.
         BehaviourFactory* mBehaviourFactory;
 		
-		//! List of Vehicle objects from the Agents in mAgents (might be needed for opensteer)
-		VehicleList mAllNeighbors;
 		//! List of registered agents (includes mPlayer)
-		AgentList mAgents;
+		AgentMap mAgents;
 		//! Agent representing the player
 		Agent* mPlayer;
 	};

Added: rl/trunk/engine/ai/include/AgentState.h
===================================================================
--- rl/trunk/engine/ai/include/AgentState.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/include/AgentState.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -0,0 +1,51 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
+ */
+#ifndef __RlAI_AgentState_H__
+#define __RlAI_AgentState_H__
+
+#include &quot;AiPrerequisites.h&quot;
+
+namespace rl
+{
+	class Agent;
+
+    typedef enum {AST_STEERING, AST_COMBAT, AST_DIALOG} AgentStateType;
+
+	/** Represents a discrete state an Agent can be in.
+     * The Agent delegates the decision making to the currently active state, wich can
+     * further deligate decision making.
+	 */
+	class _RlAiExport AgentState
+	{
+	public:
+        /// @param agent the agent this state works upon.
+        AgentState(Agent* agent) : mAgent(agent) {}
+
+        virtual ~AgentState() {}
+
+		/** Function invoked by Agents to advance the AI.
+		 * Decision making is done here.
+         * @param elapsedTime time since last update call.
+		 */
+		virtual void update(const float elapsedTime) = 0;
+
+        Agent* getAgent() const { return mAgent; }
+
+	protected:
+		Agent* mAgent;
+	};
+}
+#endif

Added: rl/trunk/engine/ai/include/AgentSteeringState.h
===================================================================
--- rl/trunk/engine/ai/include/AgentSteeringState.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/include/AgentSteeringState.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -0,0 +1,59 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
+ */
+#ifndef __RlAI_SteeringAgentState_H__
+#define __RlAI_SteeringAgentState_H__
+
+#include &quot;AiPrerequisites.h&quot;
+#include &quot;AgentState.h&quot;
+#include &quot;SteeringVehicle.h&quot;
+#include &quot;SteeringMachine.h&quot;
+
+namespace rl
+{
+    /// AgentState that is used when an Agent is idling or walking from A to B.
+    /// This state uses a fuzzy state machine to incorporate one or more behaviours
+    /// for decision making.
+    class _RlAiExport AgentSteeringState : public AgentState
+	{
+	public:
+        /// @param agent the agent this state works upon.
+        AgentSteeringState(Agent* agent);
+
+        virtual ~AgentSteeringState();
+
+		/** Function invoked by Agents to advance the AI.
+		 * Decision making is done here.
+         * @param elapsedTime time since last update call.
+		 */
+		void update(const float elapsedTime);
+
+		void addSteeringBehaviour(SteeringBehaviour* behaviour);
+		/** Removes all steering behaviours.
+		 */
+        void clearSteeringBehaviours();
+
+		/** Retrieves the stored SteeringVehicle.
+		 */
+		SteeringVehicle* getVehicle();
+
+	protected:
+		//! stores the behaviour FuzzyStateMachine for behaviour
+		SteeringMachine* mBehaviour;
+		//! stores the vehicle representation of the creature
+		SteeringVehicle* mVehicle;
+	};
+}
+#endif

Modified: rl/trunk/engine/ai/include/Makefile.am
===================================================================
--- rl/trunk/engine/ai/include/Makefile.am	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/include/Makefile.am	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1,6 +1,9 @@
 noinst_HEADERS =
 	Agent.h \
 	AgentManager.h \
+	AgentCombatState.h \
+	AgentState.h \
+	AgentSteeringState.h \
 	AiPrerequisites.h \
 	AiSubsystem.h \
 	AiWorld.h \

Deleted: rl/trunk/engine/ai/include/PlayerVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/PlayerVehicle.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/include/PlayerVehicle.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1,55 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
- *
- *  You should have received a copy of the Perl Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
- */
-#ifndef __RlAI_PlayerVehicle_H__
-#define __RlAI_PlayerVehicle_H__
-
-#include &quot;SteeringVehicle.h&quot;
-
-namespace rl
-{
-	class Agent;
-	class Creature;
-	/** Represents the player as a vehicle.
-	 */
-	class PlayerVehicle :
-		public SteeringVehicle
-	{
-	public:
-		/** Constructor
-		 * @param Actor gives the Actor representing the Player
-		 */
-		PlayerVehicle(Creature* character);
-		/** explicit destructor
-		 */
-		virtual ~PlayerVehicle(void);
-
-		/** Updates the steering of the vehicle.
-		 * Update is done by fetching position and orientation from the
-		 * attached PhysicalThing object representing the player. Those
-		 * are then used to set the state of the OpenSteer Obstacle
-		 * accordingly.
-		 * @param currentTime const float current time
-		 * @param elapsedTime const float elapsed time since last call
-		 */
-        // same as SteeringVehicle if mMovingCreature is not set
-		//virtual void update(const float currentTime, const float elapsedTime);
-    protected:
-        virtual void createMovingCreature() {}
-        virtual void destroyMovingCreature() {}
-	};
-}
-
-#endif

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -58,9 +58,8 @@
 	public:
 		/** Constructor.
 		 * @param parent Agent owning this vehicle
-		 * @param character Actor controlled by Agent
 		 */
-		SteeringVehicle(Agent* parent, Creature* character);
+		SteeringVehicle(Agent* parent);
 		/** explicit virtual destructor.
 		 */
 		virtual ~SteeringVehicle(void);
@@ -263,9 +262,6 @@
 		 */
 		void initialize();
 
-        virtual void createMovingCreature(); // permit PlayerVehicle to override this functions!
-        virtual void destroyMovingCreature();
-
 		/** retrieves the neighbours of this SteeringVehicle
 		 */
 		OpenSteer::AVGroup getNeighbors() const;
@@ -299,7 +295,7 @@
         //! Creature object steered by this vehicle (and controlled by Agent).
         Creature* mCreature;
 
-        CreatureController* mMovingCreature;
+        CreatureController* mController;
 
         // derived from debugvisualisable
         virtual void doCreatePrimitive();

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
+ * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,11 +13,12 @@
  *  along with this program; if not you can get it here
  *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
  */
-#include &quot;stdinc.h&quot; //precompiled header
+#include &quot;stdinc.h&quot;
 
 #include &quot;Agent.h&quot;
 
 #include &quot;Actor.h&quot;
+#include &quot;AgentSteeringState.h&quot;
 #include &quot;Creature.h&quot;
 #include &quot;DialogCharacter.h&quot;
 #include &quot;Exception.h&quot;
@@ -31,28 +32,15 @@
 namespace rl {
 
 Agent::Agent(Creature* character)
-	: mType(AgentManager::AGENT_NONE),
-      mBehaviour(NULL),
-      mVehicle(NULL),
-	  mCreature(character)
+	: mCreature(character),
+      mAgentStates()
 {
 	initialize();
 	ScriptWrapper::getSingleton().owned(character);
 }
 
-Agent::Agent(Creature* character, SteeringVehicle* vehicle)
-	: mType(AgentManager::AGENT_NONE),
-      mBehaviour(NULL),
-      mVehicle(vehicle),
-	  mCreature(character)
-{
-	initialize();
-}
-
 Agent::~Agent(void)
 {
-    delete mVehicle;
-    delete mBehaviour;
 	if (mCreature != NULL)
 		ScriptWrapper::getSingleton().disowned(mCreature);
 }
@@ -64,47 +52,53 @@
 	{
 		Throw(NullPointerException, &quot;Agent has no creature&quot;);
 	}
+}
 
-    //  if there is no vehicle, create a standard vehicle
-	if(mVehicle == NULL)
-	{
-		mType = AgentManager::AGENT_STD_NPC;
-		mVehicle = new SteeringVehicle(this, mCreature);
-	}
-    LOG_MESSAGE(Logger::AI,
-        &quot;created SteeringVehicle for Agent&quot;);
-
-	mBehaviour = new SteeringMachine(NULL, mVehicle);
-    LOG_MESSAGE(Logger::AI,
-        &quot;created SteeringMachine for Agent&quot;);
+void Agent::update(const float elapsedTime)
+{
 }
 
-void Agent::addSteeringBehaviour(SteeringBehaviour* behaviour)
+Creature* Agent::getControlledCreature() const
 {
-    behaviour-&gt;setParent(mBehaviour);
-    behaviour-&gt;setController(mVehicle);
-    mBehaviour-&gt;addState(behaviour);
-    LOG_MESSAGE(Logger::AI,
-        &quot;added SteeringBehaviour for Agent&quot;);
+    return mCreature;
 }
 
-void Agent::clearSteeringBehaviours()
+void Agent::pushState(AgentStateType stateType)
 {
-    mBehaviour-&gt;clearStates();
-    LOG_MESSAGE(Logger::AI,
-        &quot;Cleared all SteeringBehaviours for Agent&quot;);
+    AgentState* state = NULL;
+    if (stateType == AST_STEERING)
+    {
+        state = new AgentSteeringState(this);
+    }
+    else if (stateType == AST_COMBAT)
+    {
+    }
+    else if (stateType == AST_DIALOG)
+    {
+    }
+    else
+    {
+        Throw(IllegalArgumentException, &quot;Unknown AgentStateType&quot;);
+    }
+
+    mAgentStates.push(state);
 }
 
-void Agent::update(const float elapsedTime)
+void Agent::popState()
 {
-	mBehaviour-&gt;update(elapsedTime);
-    //  currentTime not needed yet, only elapsedTime
-    mVehicle-&gt;update(0.0f, elapsedTime);
+    mAgentStates.pop();
 }
 
-Creature* Agent::getControlledCreature() const
+AgentState* Agent::getCurrentState() const
 {
-    return mCreature;
+    if (mAgentStates.empty())
+    {
+        return NULL;
+    }
+    else
+    {
+        return mAgentStates.top();
+    }
 }
 
 }

Added: rl/trunk/engine/ai/src/AgentCombatState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentCombatState.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/src/AgentCombatState.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -0,0 +1,44 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;Agent.h&quot;
+#include &quot;AgentCombatState.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
+
+namespace rl
+{
+
+    AgentCombatState::AgentCombatState(Agent* agent)
+        : AgentState(agent),
+        Combatant(CreatureControllerManager::getSingleton().getCreatureController(
+            agent-&gt;getControlledCreature()))
+    {
+    }
+
+    AgentCombatState::~AgentCombatState()
+    {
+    }
+
+    Ogre::String AgentCombatState::getTypeName()
+    {
+        return &quot;AgentCombatState&quot;;
+    }
+
+	void AgentCombatState::update(const float elapsedTime)
+    {
+    }
+}

Modified: rl/trunk/engine/ai/src/AgentManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentManager.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/src/AgentManager.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
+ * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,11 +13,12 @@
  *  along with this program; if not you can get it here
  *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
  */
-#include &quot;stdinc.h&quot; //precompiled header
+#include &quot;stdinc.h&quot;
 
 #include &quot;AgentManager.h&quot;
+
 #include &quot;Agent.h&quot;
-#include &quot;PlayerVehicle.h&quot;
+#include &quot;AgentCombatState.h&quot;
 #include &quot;Creature.h&quot;
 #include &quot;GameObjectManager.h&quot;
 
@@ -27,20 +28,15 @@
 
 namespace rl {
 
-struct FindAgentByControlledCreature : public std::binary_function&lt;Agent*, Creature*, bool&gt;
-{
-    bool operator()(Agent* agent, Creature* creature) const
-    {
-        return agent-&gt;getControlledCreature() == creature;
-    }
-};
-
 AgentManager::AgentManager(void)
-    : mBehaviourFactory(NULL), mAllNeighbors(), mAgents(), mPlayer(NULL)
+    : mBehaviourFactory(NULL), mAgents(), mPlayer(NULL)
 {
     // Subscribe as listener to the GameObjectManager, in order to attach Agents to
     // Creatures that are placed into the scene.
     GameObjectManager::getSingleton().registerGameObjectStateListener(this);
+
+    // Register the AgentCombatStateFactory with the CombatManager, so that they can
+    // be created when a creature is taking part the combat.
 }
 
 AgentManager::~AgentManager(void)
@@ -49,66 +45,50 @@
 	removeAllAgents();
 }
 
-Agent* AgentManager::createAgent(AgentType type, Creature* character)
+Agent* AgentManager::createAgent(Creature* character)
 {
-	SteeringVehicle* vehicle = NULL;
-	if(type == AGENT_PLAYER)
-	{
-		vehicle = new PlayerVehicle(character);
-	}
-
-    Agent* agent = new Agent(character, vehicle);
-	agent-&gt;setType(type);
-	if(type == AGENT_PLAYER)
-	{
-		mPlayer = agent;
-	}
-
-
+    Agent* agent = new Agent(character);
 	addAgent(agent);
     return agent;
 }
 
 void AgentManager::destroyAgent(Agent* agent)
 {
-    AgentList::iterator it = std::find(mAgents.begin(), mAgents.end(), agent);
+    AgentMap::iterator it = mAgents.find(agent-&gt;getControlledCreature());
     if (it != mAgents.end())
     {
-        delete *it;
+        delete it-&gt;second;
         mAgents.erase(it);
     }
+    else
+    {
+        LOG_ERROR(Logger::AI, &quot;AgentManager::destroyAgent: agent not found.&quot;);
+    }
 }
 
 void AgentManager::addAgent(Agent* agent)
 {
-	mAgents.push_back(agent);
-    LOG_MESSAGE(Logger::AI,
+    mAgents.insert(std::make_pair(agent-&gt;getControlledCreature(), agent));
+    LOG_MESSAGE(Logger::AI, 
         &quot;created AI Agent&quot;);
-	mAllNeighbors.push_back(agent-&gt;getVehicle());
 }
 
-AgentManager::VehicleList AgentManager::getNeighbors(Agent* agent)
+void AgentManager::run( Ogre::Real elapsedTime ) 
 {
-	return mAllNeighbors;
-}
-
-void AgentManager::run( Ogre::Real elapsedTime )
-{
     //	update agents
-    for(AgentList::iterator itr = mAgents.begin(); itr != mAgents.end(); ++itr)
+    for(AgentMap::iterator it = mAgents.begin(); it != mAgents.end(); ++it)
     {
-	    (*itr)-&gt;update(elapsedTime);
+	    it-&gt;second-&gt;update(elapsedTime);
     }
 }
 
 void AgentManager::removeAllAgents()
 {
-    for(AgentList::iterator itr = mAgents.begin(); itr != mAgents.end(); ++itr)
+    for(AgentMap::iterator it = mAgents.begin(); it != mAgents.end(); ++it)
     {
-        delete (*itr);
+	    delete it-&gt;second;
     }
     mAgents.clear();
-    mAllNeighbors.clear();
     mPlayer = NULL;
 }
 
@@ -129,35 +109,34 @@
     if (oldState == GOS_IN_SCENE &amp;&amp; newState != GOS_IN_SCENE)
     {
         // Remove the Agent and destroy it. Later we should pool them...
-        AgentList::iterator it = std::find_if(mAgents.begin(), mAgents.end(),
-            std::bind2nd(FindAgentByControlledCreature(), creature));
+        AgentMap::iterator it = mAgents.find(creature);
         if (it != mAgents.end())
         {
-            destroyAgent(*it);
+            destroyAgent(it-&gt;second);
         }
     }
     else if (newState == GOS_IN_SCENE)
     {
         // Create an Agent and add the behaviours of the creature to it.
-        Property behaviorProperty = creature-&gt;getProperty(Creature::PROPERTY_BEHAVIOURS);
-        if (behaviorProperty.isArray())
-        {
-            PropertyVector behaviors = behaviorProperty.toArray();
-            if (!behaviors.empty())
-            {
-                Agent* agent = createAgent(AGENT_STD_NPC, creature);
-                for (PropertyVector::const_iterator it = behaviors.begin(),
-                    end = behaviors.end(); it != end; ++it)
-                {
-                    if (it-&gt;isString())
-                    {
-                        SteeringBehaviour* behavior =
-                            mBehaviourFactory-&gt;createBehaviour(it-&gt;toString().c_str());
-                        agent-&gt;addSteeringBehaviour(behavior);
-                    }
-                }
-            }
-        }
+        Property aiProperty = creature-&gt;getProperty(Creature::PROPERTY_AI);
+        //if (behaviorProperty.isArray())
+        //{
+        //    PropertyVector behaviors = aiProperty.toArray();
+        //    if (!behaviors.empty())
+        //    {
+        //        Agent* agent = createAgent(creature);
+        //        for (PropertyVector::const_iterator it = behaviors.begin(),
+        //            end = behaviors.end(); it != end; ++it)
+        //        {
+        //            if (it-&gt;isString())
+        //            {
+        //                SteeringBehaviour* behavior =
+        //                    mBehaviourFactory-&gt;createBehaviour(it-&gt;toString().c_str());
+        //                agent-&gt;addSteeringBehaviour(behavior);
+        //            }
+        //        }
+        //    }
+        //}
     }
 }
 
@@ -166,4 +145,37 @@
     mBehaviourFactory = factory;
 }
 
+Combatant* AgentManager::createCombatant(Creature* creature)
+{
+    Agent* agent = NULL;
+    // Get agent from the creature.
+    AgentMap::iterator it = mAgents.find(creature);
+    if (it == mAgents.end())
+    {
+        // Create agent, since there is none yet.
+        agent = createAgent(creature);
+    }
+    else
+    {
+        agent = it-&gt;second;
+    }
+    // Put the Agent into combat state and return the state.
+    agent-&gt;pushState(AST_COMBAT);
+    Combatant* combatant = dynamic_cast&lt;AgentCombatState*&gt;(agent-&gt;getCurrentState());
+    return combatant;
 }
+
+void AgentManager::destroyCombatant(Combatant* combatant)
+{
+    // Get agent from combatant
+    AgentCombatState* combatState = dynamic_cast&lt;AgentCombatState*&gt;(combatant);
+    if (combatState == NULL)
+    {
+        Throw(IllegalArgumentException,
+            &quot;Given combatant was not created by this Factory.(AgentManager)&quot;);
+    }
+    // Pop state
+    combatState-&gt;getAgent()-&gt;popState();
+}
+
+}

Added: rl/trunk/engine/ai/src/AgentSteeringState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentSteeringState.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/src/AgentSteeringState.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -0,0 +1,75 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;Agent.h&quot;
+#include &quot;AgentSteeringState.h&quot;
+
+using namespace Ogre;
+using namespace OpenSteer;
+
+namespace rl {
+
+    AgentSteeringState::AgentSteeringState(Agent* agent)
+        : AgentState(agent),
+        mBehaviour(NULL),
+        mVehicle(NULL)
+    {
+        mVehicle = new SteeringVehicle(agent);
+
+        LOG_MESSAGE(Logger::AI, 
+            &quot;created SteeringVehicle for Agent&quot;);
+
+        mBehaviour = new SteeringMachine(NULL, mVehicle);
+        LOG_MESSAGE(Logger::AI, 
+            &quot;created SteeringMachine for Agent&quot;);
+    }
+
+    AgentSteeringState::~AgentSteeringState(void)
+    {
+        delete mVehicle;
+        delete mBehaviour;
+    }
+
+    void AgentSteeringState::addSteeringBehaviour(SteeringBehaviour* behaviour)
+    {
+        behaviour-&gt;setParent(mBehaviour);
+        behaviour-&gt;setController(mVehicle);
+        mBehaviour-&gt;addState(behaviour);
+        LOG_MESSAGE(Logger::AI, 
+            &quot;added SteeringBehaviour for Agent&quot;);
+    }
+
+    void AgentSteeringState::clearSteeringBehaviours()
+    {
+        mBehaviour-&gt;clearStates();
+        LOG_MESSAGE(Logger::AI, 
+            &quot;Cleared all SteeringBehaviours for Agent&quot;);
+    }
+
+    void AgentSteeringState::update(const float elapsedTime)
+    {
+        mBehaviour-&gt;update(elapsedTime);
+        //  currentTime not needed yet, only elapsedTime
+        mVehicle-&gt;update(0.0f, elapsedTime);
+    }
+
+    SteeringVehicle* AgentSteeringState::getVehicle()
+    {
+        return mVehicle;
+    }
+
+}

Modified: rl/trunk/engine/ai/src/Makefile.am
===================================================================
--- rl/trunk/engine/ai/src/Makefile.am	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/src/Makefile.am	2007-08-07 21:20:27 UTC (rev 3674)
@@ -5,7 +5,9 @@
 libRlAi_la_LDFLAGS = $(OGRE_LIBS) $(LIBS)
 libRlAi_la_SOURCES = \
 	Agent.cpp \
+	AgentCombatState.cpp \
 	AgentManager.cpp \
+	AgentSteeringState.cpp \
 	AiSubsystem.cpp \
 	AiWorld.cpp \
 	AStarCosts.cpp \

Deleted: rl/trunk/engine/ai/src/PlayerVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/PlayerVehicle.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/src/PlayerVehicle.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1,68 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
- *
- *  You should have received a copy of the Perl Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;PlayerVehicle.h&quot;
-#include &quot;Actor.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;MeshObject.h&quot;
-#include &quot;PhysicalThing.h&quot;
-
-using namespace OpenSteer;
-using namespace Ogre;
-
-namespace rl {
-
-PlayerVehicle::PlayerVehicle(Creature* character)
-	: SteeringVehicle(NULL, character)
-{
-}
-
-PlayerVehicle::~PlayerVehicle(void)
-{
-}
-/*
-void PlayerVehicle::update(const float currentTime, const float elapsedTime)
-{
-	PhysicalThing* pt = mCreature-&gt;getActor()-&gt;getPhysicalThing();
-	OgreNewt::Body* body = NULL;
-	if(pt) pt-&gt;_getBody();
-	if(body)
-	{
-		Vector3 position;
-		Quaternion orientation;
-		body-&gt;getPositionOrientation(position, orientation);
-		setPosition(Vec3(position.x, position.y, position.z));
-
-	//  Get the velocity vector
-		mCurrentVelocity = body-&gt;getVelocity();
-	//  enforce speed limit
-	//  newVelocity = newVelocity.truncateLength (maxSpeed ());
-	//  update speed
-		setSpeed(mCurrentVelocity.length());
-		Vec3 newVelocity(mCurrentVelocity.x, mCurrentVelocity.y, mCurrentVelocity.z);
-
-	//  regenerate local space (by default: align vehicle's forward axis with
-	//  new velocity, but this behavior may be overridden by derived classes.)
-		if (speed() &gt; 0) regenerateOrthonormalBasisUF (newVelocity / speed());
-
-	//  prevent adding a counter force against gravity
-		if (mCurrentVelocity.y &lt; 0.0f) mCurrentVelocity.y = 0.0f;
-	}
-	mCurrentForce = Ogre::Vector3::ZERO;
-}
-*/
-}

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
+ * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -13,14 +13,16 @@
  *  along with this program; if not you can get it here
  *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
  */
-#include &quot;stdinc.h&quot; //precompiled header
+#include &quot;stdinc.h&quot;
 
 #include &quot;SteeringVehicle.h&quot;
+
 #include &quot;AiSubsystem.h&quot;
-#include &quot;AiWorld.h&quot;
+#include &quot;AiWorld.h&quot; 
 #include &quot;Agent.h&quot;
 #include &quot;Actor.h&quot;
 #include &quot;Creature.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
 #include &quot;MeshObject.h&quot;
 #include &quot;CreatureController.h&quot;
 #include &quot;PhysicalThing.h&quot;
@@ -30,44 +32,30 @@
 
 namespace rl {
 
-SteeringVehicle::SteeringVehicle(Agent* parent, Creature* character)
+SteeringVehicle::SteeringVehicle(Agent* parent)
 	: _maxForce(1.0f),
       _maxSpeed(1.0f),
       mSpeed(1.0f),
-	  mCurrentForce(Vector3::ZERO),
+	  mCurrentForce(Vector3::ZERO), 
 	  mCurrentVelocity(Vector3::ZERO),
 	  mForwardVector(Vector3::NEGATIVE_UNIT_Z),
 	  mParent(parent),
-	  mCreature(character),
-      mMovingCreature(NULL),
+	  mCreature(NULL),
+      mController(NULL),
       mDebugSteer(Vector3::ZERO),
       mDebugWander(Vector3::ZERO),
       mDebugAvoidObstacles(Vector3::ZERO)
 {
-	initialize();
+    mCreature = parent-&gt;getControlledCreature();
 
-    createMovingCreature();
+	initialize();
+    mController = CreatureControllerManager::getSingleton().getCreatureController(mCreature);
 }
 
 SteeringVehicle::~SteeringVehicle(void)
 {
-    destroyMovingCreature();
 }
 
-void SteeringVehicle::createMovingCreature()
-{
-    if( mMovingCreature == NULL )
-    {
-        mMovingCreature = new CreatureController(mCreature);
-    }
-}
-
-void SteeringVehicle::destroyMovingCreature()
-{
-    if( mMovingCreature != NULL )
-        delete mMovingCreature;
-}
-
 void SteeringVehicle::resetLocalSpace()
 {
 	setForward(Vec3(mForwardVector.x, mForwardVector.y, mForwardVector.z));
@@ -86,7 +74,7 @@
 {
     // reset LocalSpace state
 	resetLocalSpace();
-
+	
     // reset SteerLibraryMixin state
 	SimpleVehicle_2::reset ();
 
@@ -122,7 +110,7 @@
     //  regenerate local space (by default: align vehicle's forward axis with
     //  new velocity, but this behavior may be overridden by derived classes.)
     // use future orientation or not??
-    orientation = Quaternion(mMovingCreature-&gt;getYaw(), Ogre::Vector3::UNIT_Y);
+    orientation = Quaternion(mController-&gt;getYaw(), Ogre::Vector3::UNIT_Y);
     Vector3 newUnitForward = orientation*Vector3::NEGATIVE_UNIT_Z;
     regenerateOrthonormalBasisUF (Vec3(newUnitForward.x,newUnitForward.y,newUnitForward.z));
 
@@ -131,13 +119,13 @@
 
 
     // only process if mMovingCreature not NULL
-    if( mMovingCreature == NULL )
+    if( mController == NULL )
     {
         mCurrentForce = Vector3::ZERO;
         return;
     }
-
-// calculate the result of the force
+    
+// calculate the result of the force    
     Vector3 result = mCurrentForce;// + mCurrentVelocity;
 
      mDebugSteer = mCurrentForce;
@@ -147,7 +135,7 @@
         mCreature-&gt;modifyAu(20,true);
 
 
-    AbstractMovement *mov_drehen = mMovingCreature-&gt;getMovementFromId(CreatureController::MT_DREHEN);
+    AbstractMovement *mov_drehen = mController-&gt;getMovementFromId(CreatureController::MT_DREHEN);
     Real vel_drehen(0);
     Radian max_drehen = Degree(0);
     if( mov_drehen-&gt;calculateBaseVelocity(vel_drehen) )
@@ -155,7 +143,7 @@
         max_drehen = Degree(vel_drehen * 360 * elapsedTime);
     }
 
-    Ogre::Quaternion future_orientation(mMovingCreature-&gt;getYaw(), Ogre::Vector3::UNIT_Y);
+    Ogre::Quaternion future_orientation(mController-&gt;getYaw(), Ogre::Vector3::UNIT_Y);
     Ogre::Vector3 creatureDirection = future_orientation * Ogre::Vector3::NEGATIVE_UNIT_Z;
     Radian yaw(0);
     creatureDirection.y = result.y = 0;
@@ -175,7 +163,7 @@
     }
 
 
-    mMovingCreature-&gt;setMovement(movement, direction, rotation);
+    mController-&gt;setMovement(movement, direction, rotation);
 
 	mCurrentForce = Ogre::Vector3::ZERO;
 }
@@ -183,7 +171,7 @@
 Vector3 SteeringVehicle::calcWander(const float elapsedTime)
 {
 	Vec3 rVal(mForwardVector.x, mForwardVector.y, mForwardVector.z);
-
+	
     rVal += steerForWander(elapsedTime/12.0f).setYtoZero();
 
     Vector3 steering(rVal.x, rVal.y, rVal.z);
@@ -207,9 +195,17 @@
 
 Vector3 SteeringVehicle::calcPursuit(Agent* agent)
 {
-	Vec3 rVal = steerForPursuit(*(agent-&gt;getVehicle())).setYtoZero();
-    Vector3 steering(rVal.x, rVal.y, rVal.z);
-	return steering;
+    /// @todo Think up an OpenSteer compatible solution if this is none.
+    /// Not all Agents have a SteeringVehicle, so it is not possible to
+    /// to use steerForPursuit like this in all cases.
+	/// Vec3 rVal = steerForPursuit(*(agent-&gt;getVehicle())).setYtoZero();
+    /// So here is my naive solution without regarding
+    /// Just returning a direction vector on the xz-plane
+    /// towards the other agent.
+    Vector3 dir = agent-&gt;getControlledCreature()-&gt;getPosition() -
+        mParent-&gt;getControlledCreature()-&gt;getPosition();
+    dir.y = 0;
+	return dir;
 }
 
 Vector3 SteeringVehicle::calcAvoidObstacles(const float minTimeToCollision)
@@ -226,7 +222,7 @@
 	Vec3 rVal = steerToAvoidNeighbors(minTimeToCollision, getNeighbors()).setYtoZero();
 	return Vector3(rVal.x, rVal.y, rVal.z);
 }
-
+		
 Vector3 SteeringVehicle::calcSteerTargetSpeed(const float targetSpeed)
 {
 	return Vector3();
@@ -234,7 +230,7 @@
 
 bool SteeringVehicle::isAhead(Agent* agent, const float threshold)
 {
-	Vector3 target = agent-&gt;getVehicle()-&gt;getPosition();
+    Vector3 target = agent-&gt;getControlledCreature()-&gt;getPosition();
 	//target.y = position.y;
 	return (SimpleVehicle_2::isAhead(Vec3(target.x, target.y, target.z), threshold));
 }
@@ -252,15 +248,15 @@
 AVGroup SteeringVehicle::getNeighbors() const
 {
 	AVGroup group;
-	AgentManager::VehicleList list = AgentManager::getSingleton().getNeighbors(NULL);
-	AgentManager::VehicleList::const_iterator itr = list.begin();
-	for(; itr != list.end(); ++itr)
-	{
-		if( (*itr) != this )
-		{
-			group.push_back( (*itr) );
-		}
-	}
+	//AgentManager::VehicleList list = AgentManager::getSingleton().getNeighbors(NULL);
+	//AgentManager::VehicleList::const_iterator itr = list.begin();
+	//for(; itr != list.end(); ++itr)
+	//{
+	//	if( (*itr) != this )
+	//	{
+	//		group.push_back( (*itr) );
+	//	}
+	//}
 	return group;
 }
 
@@ -275,75 +271,75 @@
 	return Vector3(position().x, position().y, position().z);
 }
 
-float SteeringVehicle::mass (void) const
+float SteeringVehicle::mass (void) const 
 {
     return mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;getMass();
 }
 
-float SteeringVehicle::setMass (float m)
+float SteeringVehicle::setMass (float m) 
 {
 	// don't set mass here TODO: throw exception
 
 	return 1;
-}
+} 
 
-float SteeringVehicle::speed (void) const
+float SteeringVehicle::speed (void) const 
 {
 	return mSpeed;
 }
 
-float SteeringVehicle::setSpeed (float s)
+float SteeringVehicle::setSpeed (float s) 
 {
 	return mSpeed = s;
 }
 
-float SteeringVehicle::radius (void) const
+float SteeringVehicle::radius (void) const 
 {
 	// this is only the radius in x axis, but i think, this is the value that should be used here
     Ogre::AxisAlignedBox aab = mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getCollision()-&gt;getAABB();
     return (aab.getMaximum().x - aab.getMinimum().x)/2;
 }
 
-float SteeringVehicle::setRadius (float m)
+float SteeringVehicle::setRadius (float m) 
 {
 	// don't set mass here TODO: throw exception
 	return 1;
 }
 
-float SteeringVehicle::height (void) const
+float SteeringVehicle::height (void) const 
 {
     Ogre::AxisAlignedBox aab = mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getCollision()-&gt;getAABB();
     return aab.getMaximum().y - aab.getMinimum().y;
 }
 
-float SteeringVehicle::setHeight (float h)
+float SteeringVehicle::setHeight (float h) 
 {
 	// don't set mass here TODO: throw exception
 	return 1;
 }
 
-const Actor* SteeringVehicle::getActor(void) const
-{
-	return mCreature-&gt;getActor();
+const Actor* SteeringVehicle::getActor(void) const  
+{ 
+	return mCreature-&gt;getActor(); 
 }
 
-float SteeringVehicle::maxForce (void) const
+float SteeringVehicle::maxForce (void) const 
 {
 	return 10000.0f;
-}
+} 
 
-float SteeringVehicle::setMaxForce (float mf)
+float SteeringVehicle::setMaxForce (float mf) 
 {
 	 // TODO: should not be set here, throw excpetion or so
 	return _maxForce = mf;
 }
 
-float SteeringVehicle::maxSpeed (void) const
+float SteeringVehicle::maxSpeed (void) const 
 {
-	return 100000;
+	return 100000; 
 }
 
-float SteeringVehicle::setMaxSpeed (float ms)
+float SteeringVehicle::setMaxSpeed (float ms) 
 {
 	 // TODO: should not be set here, throw excpetion or so
 	return _maxSpeed = ms;
@@ -396,7 +392,7 @@
 
     LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
     lineSet-&gt;clear();
-
+    
     if(mDebugSteer != Vector3::ZERO)
     {
         lineSet-&gt;addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugSteer.normalisedCopy()*0.5, ColourValue::Black);

Modified: rl/trunk/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/trunk/engine/rules/RlRules2005.vcproj	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/RlRules2005.vcproj	2007-08-07 21:20:27 UTC (rev 3674)
@@ -303,6 +303,10 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\src\Combatant.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\src\CombatManager.cpp&quot;
 				&gt;
 			&lt;/File&gt;
@@ -513,6 +517,10 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\include\Combatant.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\include\CombatManager.h&quot;
 				&gt;
 			&lt;/File&gt;

Modified: rl/trunk/engine/rules/include/Combat.h
===================================================================
--- rl/trunk/engine/rules/include/Combat.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/include/Combat.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -23,29 +23,29 @@
 
 namespace rl
 {
-    class Creature;
+    class Combatant;
 
     class _RlRulesExport Combat
     {
     public:
-        typedef std::set&lt;Creature*&gt; CreatureSet;
+        typedef std::set&lt;Combatant*&gt; CombatantSet;
 
-        Combat(Creature* character);
+        Combat(Combatant* character);
         ~Combat();
 
-        void addOpponent(Creature*);
-        void removeOpponent(Creature*);
+        void addOpponent(Combatant*);
+        void removeOpponent(Combatant*);
 
-        void addAlly(Creature*);
-        void removeAlly(Creature*);
+        void addAlly(Combatant*);
+        void removeAlly(Combatant*);
 
-        const CreatureSet&amp; getAllOpponents() const;
-        const CreatureSet&amp; getAllAllies() const;
+        const CombatantSet&amp; getAllOpponents() const;
+        const CombatantSet&amp; getAllAllies() const;
 
     private:
-        Creature* mCharacter;
-        CreatureSet mOpponents;
-        CreatureSet mAllies;
+        Combatant* mCharacter;
+        CombatantSet mOpponents;
+        CombatantSet mAllies;
     };
 }
 

Modified: rl/trunk/engine/rules/include/CombatManager.h
===================================================================
--- rl/trunk/engine/rules/include/CombatManager.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/include/CombatManager.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -21,9 +21,13 @@
 
 #include &lt;OgreSingleton.h&gt;
 
+#include &lt;map&gt;
+
 namespace rl
 {
 	class Combat;
+    class Combatant;
+    class CombatantFactory;
     class Creature;
 	
     class _RlRulesExport CombatManager : public Ogre::Singleton&lt;CombatManager&gt;
@@ -36,12 +40,27 @@
         /// @param character the player character
         /// @param firstOpponent the opponent, that caused the combat.
         /// @throw IllegalStateException if there is already a combat running.
-        Combat* startCombat(Creature* character, Creature* firstOpponent);
+        Combat* startCombat(Combatant* character, Combatant* firstOpponent);
 
         /// Return the combat currently running, NULL if there is none.
         Combat* getCurrentCombat() const;
 
+        /// Returns a Combatant instance for the given Creature with the given name.
+        /// If no name is given, the default Creature-Combatant is chosen, which is
+        /// the default one registered by RlAi.
+        /// Caller is resonsible for calling destroyCombatant in order to
+        /// All undestroyed instances are destroyed when CombatManager is destroyed.
+        /// @param creature Creature to create a Combatant for
+        /// @param combatantType Name of the type to be used.
+        Combatant* createCombatant(Creature* creature, const Ogre::String&amp; combatantType = &quot;default&quot;);
+        void destroyCombatant(Combatant* combatant);
+
+        void registerCombatantFactory(const Ogre::String&amp; name, CombatantFactory* factory);
+        void unregisterCombatantFactory(CombatantFactory* factory);
+
     private:
+        typedef std::map&lt;Ogre::String, CombatantFactory*&gt; CombatantFactoryMap;
+        CombatantFactoryMap mCombatantFactories;
         Combat* mCurrentCombat;
     };
 }

Added: rl/trunk/engine/rules/include/Combatant.h
===================================================================
--- rl/trunk/engine/rules/include/Combatant.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/include/Combatant.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -0,0 +1,51 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __RL_COMBATANT_H__
+#define __RL_COMBATANT_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+namespace rl
+{
+    class Creature;
+    class CreatureController;
+
+    class _RlRulesExport Combatant
+    {
+    public:
+        Combatant(CreatureController* controller);
+        virtual ~Combatant();
+
+        virtual Ogre::String getTypeName() = 0;
+
+        CreatureController* getCreatureController() const;
+
+    protected:
+        CreatureController* mController;
+    };
+
+    class _RlRulesExport CombatantFactory
+    {
+    public:
+        virtual ~CombatantFactory() {}
+
+        virtual Combatant* createCombatant(Creature* creature) = 0;
+        virtual void destroyCombatant(Combatant*) = 0;
+    };
+}
+
+#endif

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/include/Creature.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -107,7 +107,7 @@
             typedef std::map&lt;const CeGuiString, int&gt; TalentMap;
 
             static const Ogre::String CLASS_NAME;
-            static const Ogre::String PROPERTY_BEHAVIOURS;
+            static const Ogre::String PROPERTY_AI;
 			static const Ogre::String PROPERTY_INVENTORY_WINDOW_TYPE;
             static const Ogre::String PROPERTY_CURRENT_LE;
             static const Ogre::String PROPERTY_CURRENT_AE;
@@ -779,7 +779,7 @@
             Inventory* mInventory;
             Ogre::String mInventoryWindowType;
 
-            Property mBehaviours;
+            Property mAiProperties;
 
             Alignment mAlignment;
 

Modified: rl/trunk/engine/rules/include/CreatureController.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureController.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/include/CreatureController.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -61,7 +61,7 @@
         /// Newton contact callback called by the movingCreatureManager
         int userProcess();
 
-        Creature *getCreature() {return mCreature;}
+        Creature* getCreature() {return mCreature;}
 
         /** 
          * the different movements a creature can perform, 

Modified: rl/trunk/engine/rules/include/CreatureControllerManager.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureControllerManager.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/include/CreatureControllerManager.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -30,6 +30,10 @@
 {
     class CreatureController;
 
+    /// This class manages CreatureControllers, which provide an API for moving the creature
+    /// around in the scene.
+    /// CreatureControllers are created on demand and a reference is kept here, so that no more
+    /// than one CreatureController is created per Creature.
     class _RlRulesExport CreatureControllerManager : 
         public GameTask,
         public Ogre::Singleton&lt;CreatureControllerManager&gt;,
@@ -39,45 +43,27 @@
         CreatureControllerManager();
         ~CreatureControllerManager();
 
-        /**
-         * adds a new movingCreature, this function is not intended to be used directly; 
-         * each CreatureController is automatically added. a creature is always added in a
-         * idle state
-         */
-        void add(CreatureController *movingCreature);
+        /// Returns a CreatureController that can be used to control given Creature.
+        /// There is only one controller per Creature at a given time.
+        /// If no such controller exists yet, it is created.
+        CreatureController* getCreatureController(Creature* creature);
 
-        /**
-         * removes a movingCreature, this function is not intended to be used directly, 
-         * destroy the movingCreature instead.
-         */
-        void remove(CreatureController *movingCreature);
+        /// This function detaches a controller attached to the given Creature, if any.
+        void detachController(Creature* creature);
 
         void run(Ogre::Real elapsedTime);
 
-        /**
-         * Sets a movingCreature in an active state, this means that it is updated every
-         * frame. This must be the case, if the creature is moving. If a creature is in an
-         * idle state, it is only updated less often
-         */
-        void setActive(CreatureController* movingCreature);
+        // override from GameTask
+        const Ogre::String&amp; getName() const;
 
-        const Ogre::String &amp; getName() const {return mName;}
-
         // Newton Contact Callback
         int userProcess();
     protected:
-        typedef std::vector&lt;CreatureController*&gt; MovingCreatureVector;
-        MovingCreatureVector mActiveCreatures;
-        MovingCreatureVector mIdleCreatures;
-        MovingCreatureVector mAddToActiveCreatures;
-        Ogre::Real mUpdateIdleTime;
-        Ogre::Real mTimeSinceLastIdleUpdate;
-        Ogre::String mName;
+        typedef std::map&lt;Creature*, CreatureController*&gt; ControllerMap;
+        ControllerMap mControllers;
 
-        typedef std::map&lt;OgreNewt::Body*,CreatureController*&gt; MovingCreatureBodyMap;
-        MovingCreatureBodyMap mMovingCreatureFromBody;
+        typedef std::map&lt;OgreNewt::Body*, CreatureController*&gt; BodyControllerMap;
+        BodyControllerMap mBodyControllers;
     };
 }
-
-
 #endif

Modified: rl/trunk/engine/rules/include/Makefile.am
===================================================================
--- rl/trunk/engine/rules/include/Makefile.am	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/include/Makefile.am	2007-08-07 21:20:27 UTC (rev 3674)
@@ -3,6 +3,7 @@
 	ActionManager.h \
 	Armor.h \
 	Combat.h \
+	Combatant.h \
 	CombatManager.h \
 	Container.h \
 	Creature.h \

Modified: rl/trunk/engine/rules/src/Combat.cpp
===================================================================
--- rl/trunk/engine/rules/src/Combat.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/src/Combat.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
+ * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,13 +13,13 @@
  *  along with this program; if not you can get it here
  *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
  */
-#include &quot;stdinc.h&quot; //precompiled header
+#include &quot;stdinc.h&quot;
 
 #include &quot;Combat.h&quot;
 
 namespace rl
 {
-    Combat::Combat(Creature* character) : mCharacter(character)
+    Combat::Combat(Combatant* character) : mCharacter(character)
     {
     }
 
@@ -27,32 +27,32 @@
     {
     }
 
-    void Combat::addOpponent(Creature* creature)
+    void Combat::addOpponent(Combatant* Combatant)
     {
-        mOpponents.insert(creature);
+        mOpponents.insert(Combatant);
     }
 
-    void Combat::removeOpponent(Creature* creature)
+    void Combat::removeOpponent(Combatant* Combatant)
     {
-        mOpponents.erase(creature);
+        mOpponents.erase(Combatant);
     }
 
-    void Combat::addAlly(Creature* creature)
+    void Combat::addAlly(Combatant* Combatant)
     {
-        mAllies.insert(creature);
+        mAllies.insert(Combatant);
     }
 
-    void Combat::removeAlly(Creature* creature)
+    void Combat::removeAlly(Combatant* Combatant)
     {
-        mAllies.erase(creature);
+        mAllies.erase(Combatant);
     }
 
-    const Combat::CreatureSet&amp; Combat::getAllOpponents() const
+    const Combat::CombatantSet&amp; Combat::getAllOpponents() const
     {
         return mOpponents;
     }
 
-    const Combat::CreatureSet&amp; Combat::getAllAllies() const
+    const Combat::CombatantSet&amp; Combat::getAllAllies() const
     {
         return mAllies;
     }

Modified: rl/trunk/engine/rules/src/CombatManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CombatManager.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/src/CombatManager.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
+* 
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -13,12 +13,12 @@
 *  along with this program; if not you can get it here
 *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
 */
-#include &quot;stdinc.h&quot; //precompiled header
+#include &quot;stdinc.h&quot;
 
-
 #include &quot;CombatManager.h&quot;
 
 #include &quot;Combat.h&quot;
+#include &quot;Combatant.h&quot;
 #include &quot;Exception.h&quot;
 
 using namespace Ogre;
@@ -36,7 +36,7 @@
     {
     }
 
-    Combat* CombatManager::startCombat(Creature* character, Creature* firstOpponent)
+    Combat* CombatManager::startCombat(Combatant* character, Combatant* firstOpponent)
     {
         if (mCurrentCombat != NULL)
         {
@@ -53,4 +53,29 @@
     {
         return mCurrentCombat;
     }
+
+    Combatant* CombatManager::createCombatant(Creature* creature, const String&amp; combatantType)
+    {
+        CombatantFactoryMap::iterator it = mCombatantFactories.find(combatantType);
+        if (it != mCombatantFactories.end())
+        {
+            return it-&gt;second-&gt;createCombatant(creature);
+        }
+        else
+        {
+            Throw(IllegalArgumentException, &quot;No such CombatantType registered: &quot; + combatantType);
+        }
+    }
+
+    void CombatManager::destroyCombatant(Combatant* combatant)
+    {
+    }
+
+    void CombatManager::registerCombatantFactory(const String&amp; name, CombatantFactory* factory)
+    {
+    }
+
+    void CombatManager::unregisterCombatantFactory(CombatantFactory* factory)
+    {
+    }
 }

Added: rl/trunk/engine/rules/src/Combatant.cpp
===================================================================
--- rl/trunk/engine/rules/src/Combatant.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/src/Combatant.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -0,0 +1,34 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;Combatant.h&quot;
+
+namespace rl
+{
+    Combatant::Combatant(CreatureController* controller) : mController(controller)
+    {
+    }
+
+    Combatant::~Combatant()
+    {
+    }
+
+    CreatureController* Combatant::getCreatureController() const
+    {
+        return mController;
+    }
+}

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -40,7 +40,7 @@
 {
     const Ogre::String Creature::CLASS_NAME = &quot;Creature&quot;;
 
-    const Ogre::String Creature::PROPERTY_BEHAVIOURS = &quot;behaviours&quot;;
+    const Ogre::String Creature::PROPERTY_AI = &quot;ai&quot;;
     const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = &quot;inventorywindowtype&quot;;
     const Ogre::String Creature::PROPERTY_CURRENT_LE = &quot;current_le&quot;;
     const Ogre::String Creature::PROPERTY_CURRENT_AE = &quot;current_ae&quot;;
@@ -953,9 +953,9 @@
 
     void Creature::setProperty(const Ogre::String &amp;key, const rl::Property &amp;value)
     {
-        if (key == Creature::PROPERTY_BEHAVIOURS)
+        if (key == Creature::PROPERTY_AI)
         {
-            mBehaviours = value;
+            mAiProperties = value;
         }
         else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
         {
@@ -1033,9 +1033,9 @@
 
     const Property Creature::getProperty(const Ogre::String &amp;key) const
     {
-        if (key == Creature::PROPERTY_BEHAVIOURS)
+        if (key == Creature::PROPERTY_AI)
         {
-            return mBehaviours;
+            return mAiProperties;
         }
         else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
         {
@@ -1112,7 +1112,7 @@
     PropertySet* Creature::getAllProperties() const
     {
         PropertySet* ps = GameObject::getAllProperties();
-        ps-&gt;setProperty(Creature::PROPERTY_BEHAVIOURS, mBehaviours);
+        ps-&gt;setProperty(Creature::PROPERTY_AI, mAiProperties);
         ps-&gt;setProperty(Creature::PROPERTY_INVENTORY_WINDOW_TYPE, Property(mInventoryWindowType));
         ps-&gt;setProperty(Creature::PROPERTY_CURRENT_LE, getProperty(Creature::PROPERTY_CURRENT_LE));
         ps-&gt;setProperty(Creature::PROPERTY_CURRENT_AE, getProperty(Creature::PROPERTY_CURRENT_AE));

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -1141,8 +1141,6 @@
         mStillWeightedAnimationName(&quot;&quot;),
         mLastFloorContact(TimeSourceManager::getSingleton().getTimeSource(TimeSource::REALTIME_INTERRUPTABLE)-&gt;getClock())
     {
-        CreatureControllerManager::getSingleton().add(this);
-
         mOldMaterialId = mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getMaterialGroupID();
         const OgreNewt::MaterialID *material = PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;);
         mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;setMaterialID(material);
@@ -1202,7 +1200,6 @@
         mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
 
         mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;setMaterialID(mOldMaterialId);
-        CreatureControllerManager::getSingleton().remove(this);
     }
 
     CreatureController::MovementType CreatureController::getMovementId() const
@@ -1410,7 +1407,10 @@
 
         if(mMovement != NULL)
         {
-            // i hope this will copy the protected members of the contact callback
+            // @XXX Evil code!
+            // Protected members from type OgreNewt::ContactCallback have to be overridden in order
+            // for the movements to work. This is because these members are used by OgreNewt functions
+            // for processing this contact. Should probably be solved in OgreNewt directly.
             OgreNewt::ContactCallback *movement = mMovement;
             *movement = (OgreNewt::ContactCallback)(*this);
             return movement-&gt;userProcess();
@@ -1437,7 +1437,6 @@
         {
             if( mMovement-&gt;getId() == type )
             {
-                CreatureControllerManager::getSingleton().setActive(this);
                 mDirection = direction;
                 mRotation = rotation;
                 return true;
@@ -1455,12 +1454,11 @@
 
         AbstractMovement *movement = getMovementFromId(type);
 
-
         while(movement != NULL)
         {
             if(movement-&gt;isPossible())
             {
-                CreatureControllerManager::getSingleton().setActive(this); // runs the old movement if idle!
+                // runs the old movement if idle!
                 if(mMovement == NULL)
                 {
                     mLastMovementType = MT_NONE;

Modified: rl/trunk/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -25,22 +25,19 @@
 
 
 using namespace Ogre;
-using namespace std;
 
-
 template&lt;&gt; rl::CreatureControllerManager* Singleton&lt;rl::CreatureControllerManager&gt;::ms_Singleton = 0;
 
 
 namespace rl
 {
     CreatureControllerManager::CreatureControllerManager() :
-            mUpdateIdleTime(1.0f),
-            mTimeSinceLastIdleUpdate(0.0f),
-            mName(&quot;CreatureControllerManager&quot;)
+            mControllers(),
+            mBodyControllers()
     {
         GameLoop::getSingleton().addTask(this, GameLoop::TG_LOGIC);
 
-        PhysicsManager *physicsManager = PhysicsManager::getSingletonPtr();
+        PhysicsManager* physicsManager = PhysicsManager::getSingletonPtr();
         // the material of moving creatures
         const OgreNewt::MaterialID *char_mat = physicsManager-&gt;createMaterialID(&quot;character&quot;);
 
@@ -66,163 +63,88 @@
         GameLoop::getSingleton().removeTask(this);
     }
 
-    void CreatureControllerManager::add(CreatureController *movingCreature)
+    CreatureController* CreatureControllerManager::getCreatureController(Creature* creature)
     {
-        if(movingCreature == NULL)
+        // valid Creature is needed as argument
+        if (creature == NULL)
         {
-            Throw(NullPointerException, &quot;Argument movingCreature darf nicht NULL sein.&quot;);
+            Throw(NullPointerException, &quot;Argument creature darf nicht NULL sein.&quot;);
         }
 
-        MovingCreatureVector::const_iterator iter;
-        for(iter = mIdleCreatures.begin(); iter != mIdleCreatures.end(); iter++)
+        CreatureController* rval = NULL;
+
+        // do we have a controller attached to this creature?
+        ControllerMap::const_iterator it = mControllers.find(creature);
+        if ( it == mControllers.end())
         {
-            if( (*iter) == movingCreature )
-            {
-                Throw(IllegalArgumentException, &quot;CreatureController wird schon vom CreatureControllerManager verwaltet.&quot;);
-            }
+            // No, so create one and put it into the map.
+            rval = new CreatureController(creature);
+            mControllers.insert(std::make_pair(creature, rval));
+            mBodyControllers.insert(std::make_pair(
+                creature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody(), rval));
         }
-        for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter++)
+        else
         {
-            if( (*iter) == movingCreature )
-            {
-                Throw(IllegalArgumentException, &quot;CreatureController wird schon vom CreatureControllerManager verwaltet.&quot;);
-            }
+            rval = it-&gt;second;
         }
 
-        mMovingCreatureFromBody.insert(make_pair(
-            movingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody(),
-            movingCreature));
-        mIdleCreatures.push_back(movingCreature);
+        return rval;
     }
 
 
-    void CreatureControllerManager::remove(CreatureController *movingCreature)
+    void CreatureControllerManager::detachController(Creature* creature)
     {
-        if(movingCreature == NULL)
+        if( creature == NULL)
         {
-            Throw(NullPointerException, &quot;Argument movingCreature darf nicht NULL sein.&quot;);
+            Throw(NullPointerException, &quot;Argument creature darf nicht NULL sein.&quot;);
         }
 
-        MovingCreatureBodyMap::iterator body_iter = mMovingCreatureFromBody.find(
-            movingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody());
-
-        if( body_iter == mMovingCreatureFromBody.end() )
+        mControllers.find(creature);
+        ControllerMap::iterator it = mControllers.find(creature);
+        if (it == mControllers.end())
         {
-            Throw(IllegalArgumentException, &quot;CreatureController wird nicht vom CreatureControllerManager verwaltet.&quot;);
+            delete it-&gt;second;
+            mControllers.erase(it);
         }
 
-        mMovingCreatureFromBody.erase(body_iter);
-
-
-        MovingCreatureVector::iterator iter;
-        for(iter = mIdleCreatures.begin(); iter != mIdleCreatures.end(); iter++)
-        {
-            if( (*iter) == movingCreature )
-            {
-                mIdleCreatures.erase(iter);
-                return;
-            }
-        }
-        for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter++)
-        {
-            if( (*iter) == movingCreature )
-            {
-                mActiveCreatures.erase(iter);
-                return;
-            }
-        }
-        for(iter = mAddToActiveCreatures.begin(); iter != mAddToActiveCreatures.end(); iter++)
-        {
-            if( (*iter) == movingCreature )
-            {
-                mAddToActiveCreatures.erase(iter);
-                return;
-            }
-        }
-
-
-        Throw(IllegalArgumentException, &quot;CreatureController wird nicht vom CreatureControllerManager verwaltet.&quot;);
+        mBodyControllers.erase(creature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody());
     }
 
     void CreatureControllerManager::run(Real elapsedTime)
     {
-        mTimeSinceLastIdleUpdate += elapsedTime;
-
-
-        MovingCreatureVector::iterator iter;
-        for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter ++)
+        for (ControllerMap::iterator it = mControllers.begin(); it != mControllers.end(); ++it)
         {
-            (*iter)-&gt;run(elapsedTime);
+            it-&gt;second-&gt;run(elapsedTime);
         }
-
-        if( mTimeSinceLastIdleUpdate &gt;= mUpdateIdleTime )
-        {
-            for(iter = mIdleCreatures.begin(); iter != mIdleCreatures.end(); iter++)
-            {
-                (*iter)-&gt;run(mTimeSinceLastIdleUpdate);
-            }
-            mTimeSinceLastIdleUpdate = 0.0f;
-        }
     }
 
-
-    void CreatureControllerManager::setActive(CreatureController* movingCreature)
+    int CreatureControllerManager::userProcess()
     {
-        if(movingCreature == NULL)
+        BodyControllerMap::iterator it = mBodyControllers.find(m_body0);
+        if (it == mBodyControllers.end())
         {
-            Throw(NullPointerException, &quot;Argument movingCreature darf nicht NULL sein.&quot;);
-        }
+            it = mBodyControllers.find(m_body1);
 
-        // we cannot simply add the item to the other list, since it needs to be updated first!!
-        // i hope there are no errors, if this update is not at the proposed time in the game loop
-        // since it is not executed with the other runs!!!
-
-        MovingCreatureVector::iterator iter;
-        for(iter = mIdleCreatures.begin(); iter != mIdleCreatures.end(); iter++)
-        {
-            if( *iter == movingCreature )
+            if (it == mBodyControllers.end())
             {
-                movingCreature-&gt;run(mTimeSinceLastIdleUpdate);
-
-                mActiveCreatures.push_back(movingCreature);
-                mIdleCreatures.erase(iter);
-                return;
+                LOG_ERROR(Logger::RULES,
+                    &quot;Der Kollisionsk&#246;rper konnte keiner Creature zugeordner werden.&quot;);
+                return 1;
             }
         }
 
-        for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter++)
-        {
-            if( *iter == movingCreature )
-            {
-                LOG_DEBUG(Logger::RULES, &quot;Die angegebene CreatureController ist schon aktiv.&quot;);
-                return;
-            }
-        }
-
-
-        Throw(IllegalArgumentException, &quot;CreatureController wird nicht vom CreatureControllerManager verwaltet.&quot;);
+        // @XXX Evil code!
+        // Protected members from type OgreNewt::ContactCallback have to be overridden in order
+        // for the controllers to work. This is because these members are used by OgreNewt functions
+        // for processing this contact. Should probably be solved in OgreNewt directly.
+        OgreNewt::ContactCallback* controller = it-&gt;second;
+        *controller = (OgreNewt::ContactCallback)(*this);
+        return controller-&gt;userProcess();
     }
 
-
-    int CreatureControllerManager::userProcess()
+    const Ogre::String&amp; CreatureControllerManager::getName() const
     {
-        MovingCreatureBodyMap::iterator iter;
-        iter = mMovingCreatureFromBody.find(m_body0);
-
-        if( iter == mMovingCreatureFromBody.end() )
-        {
-            iter = mMovingCreatureFromBody.find(m_body1);
-
-            if( iter == mMovingCreatureFromBody.end() )
-            {
-                LOG_ERROR(Logger::RULES, &quot;Der Kollisionsk&#246;rper konnte keiner Creature zugeordner werden.&quot;);
-                return 1;
-            }
-        }
-
-        // i hope this will copy the protected members of the contact callback
-        OgreNewt::ContactCallback *movingCreature = iter-&gt;second;
-        *movingCreature = (OgreNewt::ContactCallback)(*this);
-        return movingCreature-&gt;userProcess();
+        static String name = &quot;CreatureControllerManager&quot;;
+        return name;
     }
-}
+ }

Modified: rl/trunk/engine/rules/src/Makefile.am
===================================================================
--- rl/trunk/engine/rules/src/Makefile.am	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/rules/src/Makefile.am	2007-08-07 21:20:27 UTC (rev 3674)
@@ -7,6 +7,7 @@
 	ActionManager.cpp \
 	Armor.cpp \
 	Combat.cpp \
+	Combatant.cpp \
 	CombatManager.cpp \
 	Container.cpp \
 	Creature.cpp \

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-08-07 21:20:27 UTC (rev 3674)
@@ -29,7 +29,7 @@
 	class SteeringVehicle
 	{
 	public:
-		SteeringVehicle(rl::Agent* agent, rl::Creature* character);
+		SteeringVehicle(rl::Agent* agent);
 		
 		void addForce(const Ogre::Vector3&amp; force);
 
@@ -82,8 +82,7 @@
 	public:
 		Agent(rl::Creature* character);
 		virtual ~Agent();
-		void addSteeringBehaviour(rl::SteeringBehaviour* behaviour);
-		void clearSteeringBehaviours();
+        rl::Creature* getControlledCreature() const;
 	};
 	class AiSubsystem 
 	{
@@ -103,17 +102,9 @@
     
 	class AgentManager
 	{
-	public:
-		enum AgentType
-		{
-			AGENT_NONE = -1,
-			AGENT_PLAYER = 0,
-			AGENT_STD_NPC = 1,
-			AGENT_FLOCKING = 2
-		};
-		
+	public:		
 		static AgentManager&amp; getSingleton(void);
-		rl::Agent* createAgent(rl::AgentManager::AgentType type, rl::Creature* character);
+		rl::Agent* createAgent(rl::Creature* character);
 		
         virtual void setBehaviourFactory(BehaviourFactory* factory);
 	};

Modified: rl/trunk/engine/ui/include/CombatControlState.h
===================================================================
--- rl/trunk/engine/ui/include/CombatControlState.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ui/include/CombatControlState.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -20,6 +20,7 @@
 #include &quot;UiPrerequisites.h&quot;
 
 #include &quot;ControlState.h&quot;
+#include &quot;Combatant.h&quot;
 #include &quot;Selector.h&quot;
 
 #include &lt;OgreRectangle.h&gt;
@@ -31,7 +32,7 @@
     class CombatManager;
     class CombatWindow;
 
-	class _RlUiExport CombatControlState : public ControlState
+	class _RlUiExport CombatControlState : public ControlState, public Combatant
 	{
 	public:
 		/**
@@ -45,6 +46,9 @@
 
 		void run(Ogre::Real elapsedTime);
 
+        // Combatant override
+        virtual Ogre::String getTypeName();
+
     private:
         CombatManager* mCombatManager;
         // Current combat that is controlled.

Modified: rl/trunk/engine/ui/include/MovementControlState.h
===================================================================
--- rl/trunk/engine/ui/include/MovementControlState.h	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ui/include/MovementControlState.h	2007-08-07 21:20:27 UTC (rev 3674)
@@ -85,7 +85,7 @@
 
     protected:
         virtual void doCreatePrimitive();
-        CreatureController *mMovingCreature;
+        CreatureController* mController;
 
     private:
 

Modified: rl/trunk/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatControlState.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ui/src/CombatControlState.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -13,7 +13,7 @@
  *  along with this program; if not you can get it here
  *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
  */
-#include &quot;stdinc.h&quot; //precompiled header
+#include &quot;stdinc.h&quot;
 
 #include &quot;CombatControlState.h&quot;
 
@@ -24,6 +24,8 @@
 #include &quot;CombatWindow.h&quot;
 #include &quot;CoreSubsystem.h&quot;
 #include &quot;Creature.h&quot;
+#include &quot;CreatureController.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
 #include &quot;InputManager.h&quot;
 #include &quot;MeshObject.h&quot;
 #include &quot;Person.h&quot;
@@ -39,6 +41,7 @@
     CombatControlState::CombatControlState(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
         : ControlState(cmdMapper, camera, character, CST_COMBAT),
+          Combatant(CreatureControllerManager::getSingleton().getCreatureController(character)),
           mCombatManager(CombatManager::getSingletonPtr()),
           mCombat(NULL),
           mCombatWindow(NULL),
@@ -97,12 +100,15 @@
             const Selector::GameObjectVector&amp; enemies = mEnemySelector.getAllSelectedObjects();
             if (!enemies.empty())
             {
+                Combatant* firstOpponent = mCombatManager-&gt;createCombatant(
+                    static_cast&lt;Creature*&gt;(enemies[0]));
                 // There are enemies in vicinity, so start a new combat and set it up properly.
-                mCombat = mCombatManager-&gt;startCombat(mCharacter,
-                    static_cast&lt;Creature*&gt;(enemies[0]));
+                mCombat = mCombatManager-&gt;startCombat(this, firstOpponent);
                 for (size_t i = 1; i &lt; enemies.size(); ++i)
                 {
-                    mCombat-&gt;addOpponent(static_cast&lt;Creature*&gt;(enemies[i]));
+                    Combatant* opponent = mCombatManager-&gt;createCombatant(
+                        static_cast&lt;Creature*&gt;(enemies[i]));
+                    mCombat-&gt;addOpponent(opponent);
                 }
             }
             else
@@ -133,12 +139,13 @@
         mHud-&gt;clear();
 
         mHud-&gt;begin(&quot;BaseWhiteNoLighting&quot;, RenderOperation::OT_LINE_STRIP);
-        const Combat::CreatureSet&amp; opponents = mCombat-&gt;getAllOpponents();
-        for (Combat::CreatureSet::const_iterator it = opponents.begin(), end = opponents.end();
+        const Combat::CombatantSet&amp; opponents = mCombat-&gt;getAllOpponents();
+        for (Combat::CombatantSet::const_iterator it = opponents.begin(), end = opponents.end();
             it != end; ++it)
         {
             Ogre::Rectangle rec = getScreenRectFromWorldAABB(
-                (*it)-&gt;getActor()-&gt;_getSceneNode()-&gt;_getWorldAABB());
+                (*it)-&gt;getCreatureController()-&gt;getCreature()-&gt;getActor()
+                    -&gt;_getSceneNode()-&gt;_getWorldAABB());
             mHud-&gt;position(rec.left,  rec.top,    0.0f);
             mHud-&gt;position(rec.left,  rec.bottom, 0.0f);
             mHud-&gt;position(rec.right, rec.top,    0.0f);
@@ -175,4 +182,9 @@
         Ogre::Rectangle rval = {left,top, right, bottom};
         return rval;
     }
+
+    Ogre::String CombatControlState::getTypeName()
+    {
+        return &quot;CombatControlState&quot;;
+    }
 }

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-07 15:56:25 UTC (rev 3673)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2007-08-07 21:20:27 UTC (rev 3674)
@@ -35,6 +35,7 @@
 #include &quot;ConfigurationManager.h&quot;
 #include &quot;CoreSubsystem.h&quot;
 #include &quot;Creature.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
 #include &quot;DebugWindow.h&quot;
 #include &quot;Exception.h&quot;
 #include &quot;InputManager.h&quot;
@@ -70,7 +71,7 @@
     MovementControlState::MovementControlState(CommandMapper* cmdMapper,
         Actor* camera, Person* character)
         : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
-        mMovingCreature(NULL),
+        mController(NULL),
         mCharacterState(),
         mDesiredDistance(2.00),
         mDistanceRange(0.60, 7.00),
@@ -156,11 +157,7 @@
     //------------------------------------------------------------------------
     void MovementControlState::pause()
     {
-        if( mMovingCreature != NULL )
-        {
-            delete mMovingCreature;
-            mMovingCreature = NULL;
-        }
+        mController = NULL;
 
         // actors aren't controlled anymore
         //mCharacterActor-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
@@ -189,8 +186,11 @@
     //------------------------------------------------------------------------
     void MovementControlState::resume()
     {
-        if( mMovingCreature == NULL )
-            mMovingCreature = new CreatureController(mCharacter);
+        if (mController == NULL )
+        {
+            mController =
+                CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
+        }
 
         // We want to check for visibility from char's POV.
         mSelector.setCheckVisibility(true, mCharacter);
@@ -292,12 +292,12 @@
     void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
     {
         InputManager* im = InputManager::getSingletonPtr();
-        if( mMovingCreature != NULL )
+        if( mController != NULL )
         {
             int movement = mCharacterState.mCurrentMovementState;
             Degree rotation(0);
 
-            AbstractMovement *drehen = mMovingCreature-&gt;getMovementFromId(CreatureController::MT_DREHEN);
+            AbstractMovement *drehen = mController-&gt;getMovementFromId(CreatureController::MT_DREHEN);
             Real baseVelocity = 0;
             if( drehen-&gt;calculateBaseVelocity(baseVelocity) )
             {
@@ -345,13 +345,13 @@
                     direction.z = -1;
                 else if( movement &amp; MOVE_BACKWARD)
                     direction.z = 1;
-                mMovingCreature-&gt;setMovement(
+                mController-&gt;setMovement(
                     CreatureController::MT_SCHLEICHEN,
                     direction,
                     Vector3(0, rotation.valueRadians(), 0) );
             }
             else if( movement &amp; MOVE_JUMP &amp;&amp; 
-                mMovingCreature-&gt;getMovementFromId(CreatureController::MT_HOCHSPRUNG)-&gt;isPossible() )
+                mController-&gt;getMovementFromId(CreatureController::MT_HOCHSPRUNG)-&gt;isPossible() )
             {
                 CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
                 Vector3 direction = Vector3::UNIT_Y;
@@ -360,7 +360,7 @@
                     type = CreatureController::MT_WEITSPRUNG;
                     direction += Vector3::NEGATIVE_UNIT_Z;
                 }
-                mMovingCreature-&gt;setMovement(
+                mController-&gt;setMovement(
                     type,
                     direction,
                     Vector3(0, rotation.valueRadians(), 0) );
@@ -382,7 +382,7 @@
                     else
                         type = CreatureController::MT_JOGGEN;
                 }
-                mMovingCreature-&gt;setMovement(
+                mController-&gt;setMovement(
                     type,
                     Vector3(0,0,-1), 
                     Vector3(0, rotation.valueRadians(), 0) );
@@ -392,7 +392,7 @@
                 CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
                 if( !(movement &amp; MOVE_RUN) )
                     type = CreatureController::MT_RUECKWAERTS_JOGGEN;
-                mMovingCreature-&gt;setMovement(
+                mController-&gt;setMovement(
                     type,
                     Vector3(0,0,1), 
                     Vector3(0, rotation.valueRadians(), 0) );
@@ -402,14 +402,14 @@
                 Vector3 direction = Vector3::UNIT_X;
                 if( movement &amp; MOVE_LEFT )
                     direction = Vector3::NEGATIVE_UNIT_X;
-                mMovingCreature-&gt;setMovement(
+                mController-&gt;setMovement(
                     CreatureController::MT_SEITWAERTS_GEHEN,
                     direction, 
                     Vector3(0, rotation.valueRadians(), 0) );
             }
             else
             {
-                mMovingCreature-&gt;setMovement(
+                mController-&gt;setMovement(
                     CreatureController::MT_STEHEN, 
                     Vector3(0,0,0),
                     Vector3(0, rotation.valueRadians(), 0) );
@@ -548,16 +548,14 @@
         mCamBody-&gt;getPositionOrientation(bodpos,egal);
         ss
             &lt;&lt; &quot;scene node : &quot; &lt;&lt; playpos &lt;&lt; std::endl
-            &lt;&lt; &quot;player velocity : &quot; &lt;&lt; -mMovingCreature-&gt;getVelocity().z &lt;&lt; std::endl
-            &lt;&lt; &quot;player orientation : &quot; &lt;&lt; mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getOrientation() &lt;&lt; std::endl
+            &lt;&lt; &quot;player velocity : &quot; &lt;&lt; -mController-&gt;getVelocity().z &lt;&lt; std::endl
+            &lt;&lt; &quot;player orientation : &quot; &lt;&lt; mController-&gt;getCreature()-&gt;getActor()-&gt;getOrientation() &lt;&lt; std::endl
             &lt;&lt; &quot;camera posder : &quot; &lt;&lt; static_cast&lt;Camera*&gt;(
                 mCameraActor-&gt;_getMovableObject())-&gt;getDerivedPosition() &lt;&lt; std::endl
-//                &lt;&lt; &quot;camera pos : &quot; &lt;&lt; static_cast&lt;Camera*&gt;(
-//                    mCameraActor-&gt;_getMovableObject())-&gt;getPosition() &lt;&lt; std::endl
             &lt;&lt; &quot;camera orientation : &quot; &lt;&lt; mCameraActor-&gt;getWorldOrientation() &lt;&lt; std::endl
             &lt;&lt; &quot;camera pos : &quot; &lt;&lt; bodpos &lt;&lt; std::endl
             &lt;&lt; &quot;camera distance : &quot; &lt;&lt; mDesiredDistance &lt;&lt; std::endl
-            &lt;&lt; &quot;is airborne: &quot; &lt;&lt; (mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_AIRBORNE ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
+            &lt;&lt; &quot;is airborne: &quot; &lt;&lt; (mController-&gt;getAbstractLocation() == CreatureController::AL_AIRBORNE ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
 
         LOG_DEBUG(Logger::UI, ss.str());
         DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000744.html">[Dsa-hl-svn] r3673 - in modules/common/materials: model programs
</A></li>
	<LI>Next message: <A HREF="000746.html">[Dsa-hl-svn] r3675 - modules/combattest/dsa
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#745">[ date ]</a>
              <a href="thread.html#745">[ thread ]</a>
              <a href="subject.html#745">[ subject ]</a>
              <a href="author.html#745">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
