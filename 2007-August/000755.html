<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r3684 - dependencies/opensteer/include/OpenSteer	dependencies/opensteer/plugins dependencies/opensteer/src	modules/aitest/scripts rl/trunk/engine/ai/include	rl/trunk/engine/ai/src rl/trunk/engine/script/swig
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3684%20-%20dependencies/opensteer/include/OpenSteer%0A%09dependencies/opensteer/plugins%20dependencies/opensteer/src%0A%09modules/aitest/scripts%20rl/trunk/engine/ai/include%0A%09rl/trunk/engine/ai/src%20rl/trunk/engine/script/swig&In-Reply-To=%3C200708122130.l7CLUqsF005585%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000754.html">
   <LINK REL="Next"  HREF="000756.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r3684 - dependencies/opensteer/include/OpenSteer	dependencies/opensteer/plugins dependencies/opensteer/src	modules/aitest/scripts rl/trunk/engine/ai/include	rl/trunk/engine/ai/src rl/trunk/engine/script/swig</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3684%20-%20dependencies/opensteer/include/OpenSteer%0A%09dependencies/opensteer/plugins%20dependencies/opensteer/src%0A%09modules/aitest/scripts%20rl/trunk/engine/ai/include%0A%09rl/trunk/engine/ai/src%20rl/trunk/engine/script/swig&In-Reply-To=%3C200708122130.l7CLUqsF005585%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r3684 - dependencies/opensteer/include/OpenSteer	dependencies/opensteer/plugins dependencies/opensteer/src	modules/aitest/scripts rl/trunk/engine/ai/include	rl/trunk/engine/ai/src rl/trunk/engine/script/swig">blakharaz at mail.berlios.de
       </A><BR>
    <I>Sun Aug 12 23:30:52 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000754.html">[Dsa-hl-svn] r3683 - in rl/trunk/engine/ui: include src
</A></li>
        <LI>Next message: <A HREF="000756.html">[Dsa-hl-svn] r3685 - in rl/trunk/engine: ai ai/include ai/src	rules/include rules/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#755">[ date ]</a>
              <a href="thread.html#755">[ thread ]</a>
              <a href="subject.html#755">[ subject ]</a>
              <a href="author.html#755">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2007-08-12 23:30:22 +0200 (Sun, 12 Aug 2007)
New Revision: 3684

Modified:
   dependencies/opensteer/include/OpenSteer/AbstractVehicle.h
   dependencies/opensteer/include/OpenSteer/Annotation.h
   dependencies/opensteer/include/OpenSteer/Camera.h
   dependencies/opensteer/include/OpenSteer/Color.h
   dependencies/opensteer/include/OpenSteer/Draw.h
   dependencies/opensteer/include/OpenSteer/LocalSpace.h
   dependencies/opensteer/include/OpenSteer/Obstacle.h
   dependencies/opensteer/include/OpenSteer/OldPathway.h
   dependencies/opensteer/include/OpenSteer/OpenSteerDemo.h
   dependencies/opensteer/include/OpenSteer/Path.h
   dependencies/opensteer/include/OpenSteer/Pathway.h
   dependencies/opensteer/include/OpenSteer/PolylineSegmentedPath.h
   dependencies/opensteer/include/OpenSteer/PolylineSegmentedPathwaySegmentRadii.h
   dependencies/opensteer/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h
   dependencies/opensteer/include/OpenSteer/Proximity.h
   dependencies/opensteer/include/OpenSteer/QueryPathAlike.h
   dependencies/opensteer/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h
   dependencies/opensteer/include/OpenSteer/QueryPathAlikeMappings.h
   dependencies/opensteer/include/OpenSteer/SegmentedPath.h
   dependencies/opensteer/include/OpenSteer/SegmentedPathway.h
   dependencies/opensteer/include/OpenSteer/SimpleVehicle.h
   dependencies/opensteer/include/OpenSteer/SteerLibrary.h
   dependencies/opensteer/include/OpenSteer/Vec3.h
   dependencies/opensteer/include/OpenSteer/Vec3Utilities.h
   dependencies/opensteer/plugins/Boids.cpp
   dependencies/opensteer/plugins/CaptureTheFlag.cpp
   dependencies/opensteer/plugins/LowSpeedTurn.cpp
   dependencies/opensteer/plugins/MapDrive.cpp
   dependencies/opensteer/plugins/MultiplePursuit.cpp
   dependencies/opensteer/plugins/OneTurning.cpp
   dependencies/opensteer/plugins/Pedestrian.cpp
   dependencies/opensteer/plugins/Soccer.cpp
   dependencies/opensteer/src/Camera.cpp
   dependencies/opensteer/src/Color.cpp
   dependencies/opensteer/src/Draw.cpp
   dependencies/opensteer/src/Obstacle.cpp
   dependencies/opensteer/src/OldPathway.cpp
   dependencies/opensteer/src/OpenSteerDemo.cpp
   dependencies/opensteer/src/PolylineSegmentedPath.cpp
   dependencies/opensteer/src/PolylineSegmentedPathwaySingleRadius.cpp
   dependencies/opensteer/src/SimpleVehicle.cpp
   dependencies/opensteer/src/Vec3.cpp
   dependencies/opensteer/src/Vec3Utilities.cpp
   modules/aitest/scripts/NpcTest.rb
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/include/stdinc.h
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/script/swig/RlAi.swig
Log:
Replace OpenSteer's Vec3 by Ogre's Vector3, additional functions are moved to Vec3Utils

Modified: dependencies/opensteer/include/OpenSteer/AbstractVehicle.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/AbstractVehicle.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/AbstractVehicle.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -65,7 +65,7 @@
         virtual float setRadius (float) = 0;
 
         // velocity of vehicle
-        virtual Vec3 velocity (void) const = 0;
+        virtual Vector3 velocity (void) const = 0;
 
         // speed of vehicle  (may be faster than taking magnitude of velocity)
         virtual float speed (void) const = 0;
@@ -77,7 +77,7 @@
 
         // predict position of this vehicle at some time in the future
         // (assumes velocity remains constant)
-        virtual Vec3 predictFuturePosition (const float predictionTime) const = 0;
+        virtual Vector3 predictFuturePosition (const float predictionTime) const = 0;
 
         // ----------------------------------------------------------------------
         // XXX this vehicle-model-specific functionality functionality seems out

Modified: dependencies/opensteer/include/OpenSteer/Annotation.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Annotation.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Annotation.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -85,7 +85,7 @@
         // XXX Annotation would &quot;has-a&quot; one (or more))
 
         // record a position for the current time, called once per update
-        void recordTrailVertex (const float currentTime, const Vec3&amp; position);
+        void recordTrailVertex (const float currentTime, const Vector3&amp; position);
 
         // draw the trail as a dotted line, fading away with age
         void drawTrail (void) {drawTrail (grayColor (0.7f), gWhite);}
@@ -111,13 +111,13 @@
         //       &quot;segments&quot; is the number of line segments used to draw the circle
 
         // draw an opaque colored line segment between two locations in space
-        void annotationLine (const Vec3&amp; startPoint,
-                             const Vec3&amp; endPoint,
+        void annotationLine (const Vector3&amp; startPoint,
+                             const Vector3&amp; endPoint,
                              const Color&amp; color) const;
 
         // draw a circle on the XZ plane
         void annotationXZCircle (const float radius,
-                                 const Vec3&amp; center,
+                                 const Vector3&amp; center,
                                  const Color&amp; color,
                                  const int segments) const
         {
@@ -127,7 +127,7 @@
 
         // draw a disk on the XZ plane
         void annotationXZDisk (const float radius,
-                               const Vec3&amp; center,
+                               const Vector3&amp; center,
                                const Color&amp; color,
                                const int segments) const
         {
@@ -137,8 +137,8 @@
 
         // draw a circle perpendicular to the given axis
         void annotation3dCircle (const float radius,
-                                 const Vec3&amp; center,
-                                 const Vec3&amp; axis,
+                                 const Vector3&amp; center,
+                                 const Vector3&amp; axis,
                                  const Color&amp; color,
                                  const int segments) const
         {
@@ -148,8 +148,8 @@
 
         // draw a disk perpendicular to the given axis
         void annotation3dDisk (const float radius,
-                               const Vec3&amp; center,
-                               const Vec3&amp; axis,
+                               const Vector3&amp; center,
+                               const Vector3&amp; axis,
                                const Color&amp; color,
                                const int segments) const
         {
@@ -162,13 +162,13 @@
         // support for annotation circles
 
         void annotationXZCircleOrDisk (const float radius,
-                                       const Vec3&amp; center,
+                                       const Vector3&amp; center,
                                        const Color&amp; color,
                                        const int segments,
                                        const bool filled) const
         {
             annotationCircleOrDisk (radius,
-                                    Vec3::zero,
+                                    Vector3::ZERO,
                                     center,
                                     color,
                                     segments,
@@ -178,8 +178,8 @@
 
 
         void annotation3dCircleOrDisk (const float radius,
-                                       const Vec3&amp; center,
-                                       const Vec3&amp; axis,
+                                       const Vector3&amp; center,
+                                       const Vector3&amp; axis,
                                        const Color&amp; color,
                                        const int segments,
                                        const bool filled) const
@@ -194,8 +194,8 @@
         }
 
         void annotationCircleOrDisk (const float radius,
-                                     const Vec3&amp; axis,
-                                     const Vec3&amp; center,
+                                     const Vector3&amp; axis,
+                                     const Vector3&amp; center,
                                      const Color&amp; color,
                                      const int segments,
                                      const bool filled,
@@ -211,8 +211,8 @@
         float trailSampleInterval;  // desired interval between taking samples
         float trailLastSampleTime;  // global time when lat sample was taken
         int trailDottedPhase;       // dotted line: draw segment or not
-        Vec3 curPosition;           // last reported position of vehicle
-        Vec3* trailVertices;        // array (ring) of recent points along trail
+        Vector3 curPosition;           // last reported position of vehicle
+        Vector3* trailVertices;        // array (ring) of recent points along trail
         char* trailFlags;           // array (ring) of flag bits for trail points
     };
 
@@ -269,7 +269,7 @@
 
     // prepare trailVertices array: free old one if needed, allocate new one
     delete[] trailVertices;
-    trailVertices = new Vec3[trailVertexCount];
+    trailVertices = new Vector3[trailVertexCount];
 
     // prepare trailFlags array: free old one if needed, allocate new one
     delete[] trailFlags;
@@ -303,7 +303,7 @@
 template&lt;class Super&gt;
 void 
 OpenSteer::AnnotationMixin&lt;Super&gt;::recordTrailVertex (const float currentTime,
-                                                      const Vec3&amp; position)
+                                                      const Vector3&amp; position)
 {
     const float timeSinceLastTrailSample = currentTime - trailLastSampleTime;
     if (timeSinceLastTrailSample &gt; trailSampleInterval)
@@ -382,8 +382,8 @@
 #ifndef NOT_OPENSTEERDEMO  // only when building OpenSteerDemo
 template&lt;class Super&gt;
 void 
-OpenSteer::AnnotationMixin&lt;Super&gt;::annotationLine (const Vec3&amp; startPoint,
-                                                   const Vec3&amp; endPoint,
+OpenSteer::AnnotationMixin&lt;Super&gt;::annotationLine (const Vector3&amp; startPoint,
+                                                   const Vector3&amp; endPoint,
                                                    const Color&amp; color) const
 {
     if (enableAnnotation)
@@ -400,7 +400,7 @@
 }
 #else
 template&lt;class Super&gt; void OpenSteer::AnnotationMixin&lt;Super&gt;::annotationLine
- (const Vec3&amp;, const Vec3&amp;, const Vec3&amp;) const {}
+ (const Vector3&amp;, const Vector3&amp;, const Vector3&amp;) const {}
 #endif // NOT_OPENSTEERDEMO
 
 
@@ -416,8 +416,8 @@
 template&lt;class Super&gt;
 void 
 OpenSteer::AnnotationMixin&lt;Super&gt;::annotationCircleOrDisk (const float radius,
-                                                           const Vec3&amp; axis,
-                                                           const Vec3&amp; center,
+                                                           const Vector3&amp; axis,
+                                                           const Vector3&amp; center,
                                                            const Color&amp; color,
                                                            const int segments,
                                                            const bool filled,
@@ -440,7 +440,7 @@
 #else
 template&lt;class Super&gt;
 void OpenSteer::AnnotationMixin&lt;Super&gt;::annotationCircleOrDisk
-(const float, const Vec3&amp;, const Vec3&amp;, const Vec3&amp;, const int,
+(const float, const Vector3&amp;, const Vector3&amp;, const Vector3&amp;, const int,
  const bool, const bool) const {}
 #endif // NOT_OPENSTEERDEMO
 

Modified: dependencies/opensteer/include/OpenSteer/Camera.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Camera.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Camera.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -65,7 +65,7 @@
         void reset (void);
 
         // &quot;look at&quot; point, center of view
-        Vec3 target;
+        Vector3 target;
 
         // vehicle being tracked
         const AbstractVehicle* vehicleToTrack;
@@ -81,12 +81,12 @@
         {update (currentTime, elapsedTime, false);};
 
         // helper function for &quot;drag behind&quot; mode
-        Vec3 constDistHelper (const float elapsedTime);
+        Vector3 constDistHelper (const float elapsedTime);
 
         // Smoothly move camera ...
-        void smoothCameraMove (const Vec3&amp; newPosition,
-                               const Vec3&amp; newTarget,
-                               const Vec3&amp; newUp,
+        void smoothCameraMove (const Vector3&amp; newPosition,
+                               const Vector3&amp; newTarget,
+                               const Vector3&amp; newUp,
                                const float elapsedTime);
 
         void doNotSmoothNextMove (void) {smoothNextMove = false;};
@@ -96,15 +96,15 @@
 
         // adjust the offset vector of the current camera mode based on a
         // &quot;mouse adjustment vector&quot; from OpenSteerDemo (xxx experiment 10-17-02)
-        void mouseAdjustOffset (const Vec3&amp; adjustment);
-        Vec3 mouseAdjust2 (const bool polar,
-                           const Vec3&amp; adjustment,
-                           const Vec3&amp; offsetToAdjust);
-        Vec3 mouseAdjustPolar (const Vec3&amp; adjustment,
-                               const Vec3&amp; offsetToAdjust)
+        void mouseAdjustOffset (const Vector3&amp; adjustment);
+        Vector3 mouseAdjust2 (const bool polar,
+                           const Vector3&amp; adjustment,
+                           const Vector3&amp; offsetToAdjust);
+        Vector3 mouseAdjustPolar (const Vector3&amp; adjustment,
+                               const Vector3&amp; offsetToAdjust)
         {return mouseAdjust2 (true, adjustment, offsetToAdjust);};
-        Vec3 mouseAdjustOrtho (const Vec3&amp; adjustment,
-                               const Vec3&amp; offsetToAdjust)
+        Vector3 mouseAdjustOrtho (const Vector3&amp; adjustment,
+                               const Vector3&amp; offsetToAdjust)
         {return mouseAdjust2 (false, adjustment, offsetToAdjust);};
 
         // xxx since currently (10-21-02) the camera's Forward and Side basis
@@ -160,9 +160,9 @@
         cameraMode successorMode (const cameraMode cm) const;
 
         // &quot;static&quot; camera mode parameters
-        Vec3 fixedPosition;
-        Vec3 fixedTarget;
-        Vec3 fixedUp;
+        Vector3 fixedPosition;
+        Vector3 fixedTarget;
+        Vector3 fixedUp;
 
         // &quot;constant distance from vehicle&quot; camera mode parameters
         float fixedDistDistance;             // desired distance from it
@@ -172,10 +172,10 @@
         float lookdownDistance;             // fixed vertical offset from it
 
         // &quot;fixed local offset&quot; camera mode parameters
-        Vec3 fixedLocalOffset;
+        Vector3 fixedLocalOffset;
 
         // &quot;offset POV&quot; camera mode parameters
-        Vec3 povOffset;
+        Vector3 povOffset;
     };
 
 } // namespace OpenSteer

Modified: dependencies/opensteer/include/OpenSteer/Color.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Color.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Color.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -39,21 +39,17 @@
 #ifndef OPENSTEER_COLOR_H
 #define OPENSTEER_COLOR_H
 
+#include &quot;OpenSteer/Vec3.h&quot;
 
 
-
 namespace OpenSteer {
     
-    // Forward declaration. Full declaration in Vec3.h
-    class Vec3;
-    
-    
     class Color {
     public:
         Color();
         explicit Color( float greyValue );
         Color( float rValue, float gValue, float bValue, float aValue = 1.0f );
-        explicit Color( Vec3 const&amp; vector );
+        explicit Color( Vector3 const&amp; vector );
         
         float r() const;
         float g() const;
@@ -66,7 +62,7 @@
 		void setA( float value );
         void set( float rValue, float gValue, float bValue, float aValue = 1.0f );
         
-        Vec3 convertToVec3() const;
+        Vector3 convertToVec3() const;
     
 		// this is necessary so that graphics API's such as DirectX
 		// requiring a pointer to colors can do their conversion

Modified: dependencies/opensteer/include/OpenSteer/Draw.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Draw.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Draw.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -85,9 +85,9 @@
     // ----------------------------------------------------------------------------
     // this is a typedef for a triangle draw routine which can be passed in
     // when using rendering API's of the user's choice.
-    typedef void (*drawTriangleRoutine) (const Vec3&amp; a,
-                                         const Vec3&amp; b,
-                                         const Vec3&amp; c,
+    typedef void (*drawTriangleRoutine) (const Vector3&amp; a,
+                                         const Vector3&amp; b,
+                                         const Vector3&amp; c,
                                          const Color&amp; color);
 
     // ------------------------------------------------------------------------
@@ -97,7 +97,7 @@
 
 
     void drawAxes  (const AbstractLocalSpace&amp; localSpace,
-                    const Vec3&amp; size,
+                    const Vector3&amp; size,
                     const Color&amp; color);
 
 
@@ -109,7 +109,7 @@
 
 
     void drawBoxOutline  (const AbstractLocalSpace&amp; localSpace,
-                          const Vec3&amp; size,
+                          const Vector3&amp; size,
                           const Color&amp; color);
 
 
@@ -125,7 +125,7 @@
 
     void drawXZCheckerboardGrid (const float size,
                                  const int subsquares,
-                                 const Vec3&amp; center,
+                                 const Vector3&amp; center,
                                  const Color&amp; color1,
                                  const Color&amp; color2);
 
@@ -141,7 +141,7 @@
 
     void drawXZLineGrid (const float size,
                          const int subsquares,
-                         const Vec3&amp; center,
+                         const Vector3&amp; center,
                          const Color&amp; color);
 
 
@@ -150,28 +150,28 @@
 
 
     void drawCircleOrDisk (const float radius,
-                           const Vec3&amp; axis,
-                           const Vec3&amp; center,
+                           const Vector3&amp; axis,
+                           const Vector3&amp; center,
                            const Color&amp; color,
                            const int segments,
                            const bool filled,
                            const bool in3d);
 
     void drawXZCircleOrDisk (const float radius,
-                             const Vec3&amp; center,
+                             const Vector3&amp; center,
                              const Color&amp; color,
                              const int segments,
                              const bool filled);
 
     void draw3dCircleOrDisk (const float radius,
-                             const Vec3&amp; center,
-                             const Vec3&amp; axis,
+                             const Vector3&amp; center,
+                             const Vector3&amp; axis,
                              const Color&amp; color,
                              const int segments,
                              const bool filled);
 
     inline void drawXZCircle (const float radius,
-                              const Vec3&amp; center,
+                              const Vector3&amp; center,
                               const Color&amp; color,
                               const int segments)
     {
@@ -180,7 +180,7 @@
     }
 
     inline void drawXZDisk (const float radius,
-                            const Vec3&amp; center,
+                            const Vector3&amp; center,
                             const Color&amp; color,
                             const int segments)
     {
@@ -189,8 +189,8 @@
     }
 
     inline void draw3dCircle (const float radius,
-                              const Vec3&amp; center,
-                              const Vec3&amp; axis,
+                              const Vector3&amp; center,
+                              const Vector3&amp; axis,
                               const Color&amp; color,
                               const int segments)
     {
@@ -199,8 +199,8 @@
     }
 
     inline void draw3dDisk (const float radius,
-                            const Vec3&amp; center,
-                            const Vec3&amp; axis,
+                            const Vector3&amp; center,
+                            const Vector3&amp; axis,
                             const Color&amp; color,
                             const int segments)
     {
@@ -213,8 +213,8 @@
     // for a given arc length, in a given number of segments and color.  The
     // sign of arcLength determines the direction in which the arc is drawn.
 
-    void drawXZArc (const Vec3&amp; start,
-                    const Vec3&amp; center,
+    void drawXZArc (const Vector3&amp; start,
+                    const Vector3&amp; center,
                     const float arcLength,
                     const int segments,
                     const Color&amp; color);
@@ -225,21 +225,21 @@
 
 
     // draw a sphere (wireframe or opaque, with front/back/both culling)
-    void drawSphere (const Vec3 center,
+    void drawSphere (const Vector3 center,
                      const float radius,
                      const float maxEdgeLength,
                      const bool filled,
                      const Color&amp; color,
                      const bool drawFrontFacing = true,
                      const bool drawBackFacing = true,
-                     const Vec3&amp; viewpoint = Vec3::zero);
+                     const Vector3&amp; viewpoint = Vector3::ZERO);
 
     // draw a SphereObstacle
     void drawSphereObstacle (const SphereObstacle&amp; so,
                              const float maxEdgeLength,
                              const bool filled,
                              const Color&amp; color,
-                             const Vec3&amp; viewpoint);
+                             const Vector3&amp; viewpoint);
 
 
     // ------------------------------------------------------------------------
@@ -268,42 +268,42 @@
     // for every graphics API
 
     void draw2dTextAt3dLocation (const char&amp; text,
-                                 const Vec3&amp; location,
+                                 const Vector3&amp; location,
                                  const Color&amp; color, float w, float h);
 
     void draw2dTextAt3dLocation (const std::ostringstream&amp; text,
-                                 const Vec3&amp; location,
+                                 const Vector3&amp; location,
                                  const Color&amp; color, float w, float h);
 
     void draw2dTextAt2dLocation (const char&amp; text,
-                                 const Vec3 location,
+                                 const Vector3 location,
                                  const Color&amp; color, float w, float h);
 
     void draw2dTextAt2dLocation (const std::ostringstream&amp; text,
-                                 const Vec3 location,
+                                 const Vector3 location,
                                  const Color&amp; color, float w, float h);
 
     // ------------------------------------------------------------------------
-    // emit an OpenGL vertex based on a Vec3
+    // emit an OpenGL vertex based on a Vector3
 
 
-    void glVertexVec3 (const Vec3&amp; v);
+    void glVertexVec3 (const Vector3&amp; v);
 
 
     // ----------------------------------------------------------------------------
     // draw 3d &quot;graphical annotation&quot; lines, used for debugging
 
 
-    void drawLine (const Vec3&amp; startPoint,
-                   const Vec3&amp; endPoint,
+    void drawLine (const Vector3&amp; startPoint,
+                   const Vector3&amp; endPoint,
                    const Color&amp; color);
 
 
     // ----------------------------------------------------------------------------
     // draw 2d lines in screen space: x and y are the relevant coordinates
     // w and h are the dimensions of the viewport in pixels
-    void draw2dLine (const Vec3&amp; startPoint,
-                    const Vec3&amp; endPoint,
+    void draw2dLine (const Vector3&amp; startPoint,
+                    const Vector3&amp; endPoint,
                     const Color&amp; color,
                     float w, float h);
 
@@ -311,8 +311,8 @@
     // ----------------------------------------------------------------------------
     // draw a line with alpha blending
 
-    void drawLineAlpha (const Vec3&amp; startPoint,
-                        const Vec3&amp; endPoint,
+    void drawLineAlpha (const Vector3&amp; startPoint,
+                        const Vector3&amp; endPoint,
                         const Color&amp; color,
                         const float alpha);
 
@@ -321,13 +321,13 @@
     // deferred drawing of lines, circles and (filled) disks
 
 
-    void deferredDrawLine (const Vec3&amp; startPoint,
-                           const Vec3&amp; endPoint,
+    void deferredDrawLine (const Vector3&amp; startPoint,
+                           const Vector3&amp; endPoint,
                            const Color&amp; color);
 
     void deferredDrawCircleOrDisk (const float radius,
-                                   const Vec3&amp; axis,
-                                   const Vec3&amp; center,
+                                   const Vector3&amp; axis,
+                                   const Vector3&amp; center,
                                    const Color&amp; color,
                                    const int segments,
                                    const bool filled,
@@ -338,23 +338,23 @@
 
 
     // ------------------------------------------------------------------------
-    // Draw a single OpenGL triangle given three Vec3 vertices.
+    // Draw a single OpenGL triangle given three Vector3 vertices.
 
 
-    void drawTriangle (const Vec3&amp; a,
-                       const Vec3&amp; b,
-                       const Vec3&amp; c,
+    void drawTriangle (const Vector3&amp; a,
+                       const Vector3&amp; b,
+                       const Vector3&amp; c,
                        const Color&amp; color);
 
 
     // ------------------------------------------------------------------------
-    // Draw a single OpenGL quadrangle given four Vec3 vertices, and color.
+    // Draw a single OpenGL quadrangle given four Vector3 vertices, and color.
 
 
-    void drawQuadrangle (const Vec3&amp; a,
-                         const Vec3&amp; b,
-                         const Vec3&amp; c,
-                         const Vec3&amp; d,
+    void drawQuadrangle (const Vector3&amp; a,
+                         const Vector3&amp; b,
+                         const Vector3&amp; c,
+                         const Vector3&amp; d,
                          const Color&amp; color);
 
 
@@ -363,8 +363,8 @@
     // whose mid-line connects two given endpoints
 
 
-    void drawXZWideLine (const Vec3&amp; startPoint,
-                         const Vec3&amp; endPoint,
+    void drawXZWideLine (const Vector3&amp; startPoint,
+                         const Vector3&amp; endPoint,
                          const Color&amp; color,
                          float width);
 
@@ -372,9 +372,9 @@
     // ----------------------------------------------------------------------------
 
 
-    void drawCameraLookAt (const Vec3&amp; cameraPosition,
-                           const Vec3&amp; pointToLookAt,
-                           const Vec3&amp; up);
+    void drawCameraLookAt (const Vector3&amp; cameraPosition,
+                           const Vector3&amp; pointToLookAt,
+                           const Vector3&amp; up);
 
 
     // ----------------------------------------------------------------------------
@@ -390,7 +390,7 @@
     // given point on the screen: the ray that would be traced for that pixel
 
 
-    Vec3 directionFromCameraToScreenPosition (int x, int y, int h);
+    Vector3 directionFromCameraToScreenPosition (int x, int y, int h);
 
 
 

Modified: dependencies/opensteer/include/OpenSteer/LocalSpace.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/LocalSpace.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/LocalSpace.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -80,14 +80,14 @@
         
 
         // accessors (get and set) for side, up, forward and position
-        virtual Vec3 side (void) const = 0;
-        virtual Vec3 setSide (Vec3 s) = 0;
-        virtual Vec3 up (void) const = 0;
-        virtual Vec3 setUp (Vec3 u) = 0;
-        virtual Vec3 forward (void) const = 0;
-        virtual Vec3 setForward (Vec3 f) = 0;
-        virtual Vec3 position (void) const = 0;
-        virtual Vec3 setPosition (Vec3 p) = 0;
+        virtual Vector3 side (void) const = 0;
+        virtual Vector3 setSide (Vector3 s) = 0;
+        virtual Vector3 up (void) const = 0;
+        virtual Vector3 setUp (Vector3 u) = 0;
+        virtual Vector3 forward (void) const = 0;
+        virtual Vector3 setForward (Vector3 f) = 0;
+        virtual Vector3 position (void) const = 0;
+        virtual Vector3 setPosition (Vector3 p) = 0;
 
         // use right-(or left-)handed coordinate space
         virtual bool rightHanded (void) const = 0;
@@ -96,34 +96,34 @@
         virtual void resetLocalSpace (void) = 0;
 
         // transform a direction in global space to its equivalent in local space
-        virtual Vec3 localizeDirection (const Vec3&amp; globalDirection) const = 0;
+        virtual Vector3 localizeDirection (const Vector3&amp; globalDirection) const = 0;
 
         // transform a point in global space to its equivalent in local space
-        virtual Vec3 localizePosition (const Vec3&amp; globalPosition) const = 0;
+        virtual Vector3 localizePosition (const Vector3&amp; globalPosition) const = 0;
 
         // transform a point in local space to its equivalent in global space
-        virtual Vec3 globalizePosition (const Vec3&amp; localPosition) const = 0;
+        virtual Vector3 globalizePosition (const Vector3&amp; localPosition) const = 0;
 
         // transform a direction in local space to its equivalent in global space
-        virtual Vec3 globalizeDirection (const Vec3&amp; localDirection) const = 0;
+        virtual Vector3 globalizeDirection (const Vector3&amp; localDirection) const = 0;
 
         // set &quot;side&quot; basis vector to normalized cross product of forward and up
         virtual void setUnitSideFromForwardAndUp (void) = 0;
 
         // regenerate the orthonormal basis vectors given a new forward
         // (which is expected to have unit length)
-        virtual void regenerateOrthonormalBasisUF (const Vec3&amp; newUnitForward) = 0;
+        virtual void regenerateOrthonormalBasisUF (const Vector3&amp; newUnitForward) = 0;
 
         // for when the new forward is NOT of unit length
-        virtual void regenerateOrthonormalBasis (const Vec3&amp; newForward) = 0;
+        virtual void regenerateOrthonormalBasis (const Vector3&amp; newForward) = 0;
 
         // for supplying both a new forward and and new up
-        virtual void regenerateOrthonormalBasis (const Vec3&amp; newForward,
-                                                 const Vec3&amp; newUp) = 0;
+        virtual void regenerateOrthonormalBasis (const Vector3&amp; newForward,
+                                                 const Vector3&amp; newUp) = 0;
 
         // rotate 90 degrees in the direction implied by rightHanded()
-        virtual Vec3 localRotateForwardToSide (const Vec3&amp; v) const = 0;
-        virtual Vec3 globalRotateForwardToSide (const Vec3&amp; globalForward) const=0;
+        virtual Vector3 localRotateForwardToSide (const Vector3&amp; v) const = 0;
+        virtual Vector3 globalRotateForwardToSide (const Vector3&amp; globalForward) const=0;
     };
 
 
@@ -141,26 +141,26 @@
 
     private:
 
-        Vec3 _side;     //    side-pointing unit basis vector
-        Vec3 _up;       //  upward-pointing unit basis vector
-        Vec3 _forward;  // forward-pointing unit basis vector
-        Vec3 _position; // origin of local space
+        Vector3 _side;     //    side-pointing unit basis vector
+        Vector3 _up;       //  upward-pointing unit basis vector
+        Vector3 _forward;  // forward-pointing unit basis vector
+        Vector3 _position; // origin of local space
 
     public:
 
         // accessors (get and set) for side, up, forward and position
-        Vec3 side     (void) const {return _side;};
-        Vec3 up       (void) const {return _up;};
-        Vec3 forward  (void) const {return _forward;};
-        Vec3 position (void) const {return _position;};
-        Vec3 setSide     (Vec3 s) {return _side = s;};
-        Vec3 setUp       (Vec3 u) {return _up = u;};
-        Vec3 setForward  (Vec3 f) {return _forward = f;};
-        Vec3 setPosition (Vec3 p) {return _position = p;};
-        Vec3 setSide     (float x, float y, float z){return _side.set    (x,y,z);};
-        Vec3 setUp       (float x, float y, float z){return _up.set      (x,y,z);};
-        Vec3 setForward  (float x, float y, float z){return _forward.set (x,y,z);};
-        Vec3 setPosition (float x, float y, float z){return _position.set(x,y,z);};
+        Vector3 side     (void) const {return _side;}
+        Vector3 up       (void) const {return _up;}
+        Vector3 forward  (void) const {return _forward;}
+        Vector3 position (void) const {return _position;}
+        Vector3 setSide     (Vector3 s) {return _side = s;}
+        Vector3 setUp       (Vector3 u) {return _up = u;}
+        Vector3 setForward  (Vector3 f) {return _forward = f;}
+        Vector3 setPosition (Vector3 p) {return _position = p;}
+        Vector3 setSide     (float x, float y, float z){return _side = Vector3(x,y,z);}
+        Vector3 setUp       (float x, float y, float z){return _up = Vector3(x,y,z);}
+        Vector3 setForward  (float x, float y, float z){return _forward = Vector3(x,y,z);}
+        Vector3 setPosition (float x, float y, float z){return _position = Vector3(x,y,z);}
 
 
         // ------------------------------------------------------------------------
@@ -180,16 +180,16 @@
             resetLocalSpace ();
         };
 
-        LocalSpaceMixin (const Vec3&amp; Side,
-                         const Vec3&amp; Up,
-                         const Vec3&amp; Forward,
-                         const Vec3&amp; Position)
+        LocalSpaceMixin (const Vector3&amp; Side,
+                         const Vector3&amp; Up,
+                         const Vector3&amp; Forward,
+                         const Vector3&amp; Position)
             : _side( Side ), _up( Up ), _forward( Forward ), _position( Position ) {}
 
 
-        LocalSpaceMixin (const Vec3&amp; Up,
-                         const Vec3&amp; Forward,
-                         const Vec3&amp; Position)
+        LocalSpaceMixin (const Vector3&amp; Up,
+                         const Vector3&amp; Forward,
+                         const Vector3&amp; Position)
             : _side(), _up( Up ), _forward( Forward ), _position( Position )
         {
             setUnitSideFromForwardAndUp ();
@@ -212,10 +212,10 @@
 
         void resetLocalSpace (void)
         {
-            _forward.set (0, 0, 1);
+            _forward = Vector3(0, 0, 1);
             _side = localRotateForwardToSide (_forward);
-            _up.set (0, 1, 0);
-            _position.set (0, 0, 0);
+            _up = Vector3(0, 1, 0);
+            _position = Vector3(0, 0, 0);
         };
 
 
@@ -223,12 +223,12 @@
         // transform a direction in global space to its equivalent in local space
 
 
-        Vec3 localizeDirection (const Vec3&amp; globalDirection) const
+        Vector3 localizeDirection (const Vector3&amp; globalDirection) const
         {
             // dot offset with local basis vectors to obtain local coordiantes
-            return Vec3 (globalDirection.dot (_side),
-                         globalDirection.dot (_up),
-                         globalDirection.dot (_forward));
+            return Vector3 (globalDirection.dotProduct(_side),
+                         globalDirection.dotProduct(_up),
+                         globalDirection.dotProduct(_forward));
         };
 
 
@@ -236,10 +236,10 @@
         // transform a point in global space to its equivalent in local space
 
 
-        Vec3 localizePosition (const Vec3&amp; globalPosition) const
+        Vector3 localizePosition (const Vector3&amp; globalPosition) const
         {
             // global offset from local origin
-            Vec3 globalOffset = globalPosition - _position;
+            Vector3 globalOffset = globalPosition - _position;
 
             // dot offset with local basis vectors to obtain local coordiantes
             return localizeDirection (globalOffset);
@@ -250,7 +250,7 @@
         // transform a point in local space to its equivalent in global space
 
 
-        Vec3 globalizePosition (const Vec3&amp; localPosition) const
+        Vector3 globalizePosition (const Vector3&amp; localPosition) const
         {
             return _position + globalizeDirection (localPosition);
         };
@@ -260,7 +260,7 @@
         // transform a direction in local space to its equivalent in global space
 
 
-        Vec3 globalizeDirection (const Vec3&amp; localDirection) const
+        Vector3 globalizeDirection (const Vector3&amp; localDirection) const
         {
             return ((_side    * localDirection.x) +
                     (_up      * localDirection.y) +
@@ -276,10 +276,10 @@
         {
             // derive new unit side basis vector from forward and up
             if (rightHanded())
-                _side.cross (_forward, _up);
+                _side = _forward.crossProduct(_up);
             else
-                _side.cross (_up, _forward);
-            _side = _side.normalize ();
+                _side = _up.crossProduct(_forward);
+            _side = _side.normalisedCopy();
         }
 
 
@@ -288,7 +288,7 @@
         // (which is expected to have unit length)
 
 
-        void regenerateOrthonormalBasisUF (const Vec3&amp; newUnitForward)
+        void regenerateOrthonormalBasisUF (const Vector3&amp; newUnitForward)
         {
             _forward = newUnitForward;
 
@@ -299,27 +299,27 @@
             // (should have unit length since Side and Forward are
             // perpendicular and unit length)
             if (rightHanded())
-                _up.cross (_side, _forward);
+                _up = _side.crossProduct(_forward);
             else
-                _up.cross (_forward, _side);
+                _up = _forward.crossProduct(_side);
         }
 
 
         // for when the new forward is NOT know to have unit length
 
-        void regenerateOrthonormalBasis (const Vec3&amp; newForward)
+        void regenerateOrthonormalBasis (const Vector3&amp; newForward)
         {
-            regenerateOrthonormalBasisUF (newForward.normalize());
+            regenerateOrthonormalBasisUF (newForward.normalisedCopy());
         }
 
 
         // for supplying both a new forward and and new up
 
-        void regenerateOrthonormalBasis (const Vec3&amp; newForward,
-                                         const Vec3&amp; newUp)
+        void regenerateOrthonormalBasis (const Vector3&amp; newForward,
+                                         const Vector3&amp; newUp)
         {
             _up = newUp;
-            regenerateOrthonormalBasis (newForward.normalize());
+            regenerateOrthonormalBasis (newForward.normalisedCopy());
         }
 
 
@@ -328,19 +328,19 @@
         // &quot;forward&quot; (+Z) direction to the &quot;side&quot; (+/-X) direction
 
 
-        Vec3 localRotateForwardToSide (const Vec3&amp; v) const
+        Vector3 localRotateForwardToSide (const Vector3&amp; v) const
         {
-            return Vec3 (rightHanded () ? -v.z : +v.z,
+            return Vector3 (rightHanded () ? -v.z : +v.z,
                          v.y,
                          v.x);
         }
 
         // not currently used, just added for completeness
 
-        Vec3 globalRotateForwardToSide (const Vec3&amp; globalForward) const
+        Vector3 globalRotateForwardToSide (const Vector3&amp; globalForward) const
         {
-            const Vec3 localForward = localizeDirection (globalForward);
-            const Vec3 localSide = localRotateForwardToSide (localForward);
+            const Vector3 localForward = localizeDirection (globalForward);
+            const Vector3 localSide = localRotateForwardToSide (localForward);
             return globalizeDirection (localSide);
         }
     };

Modified: dependencies/opensteer/include/OpenSteer/Obstacle.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Obstacle.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Obstacle.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -67,7 +67,7 @@
         
         
         // compute steering for a vehicle to avoid this obstacle, if needed
-        virtual Vec3 steerToAvoid (const AbstractVehicle&amp; v,
+        virtual Vector3 steerToAvoid (const AbstractVehicle&amp; v,
                                    const float minTimeToCollision) const = 0;
 
         // PathIntersection object: used internally to analyze and store
@@ -77,14 +77,14 @@
         public:
             bool intersect; // was an intersection found?
             float distance; // how far was intersection point from vehicle?
-            Vec3 surfacePoint; // position of intersection
-            Vec3 surfaceNormal; // unit normal at point of intersection
-            Vec3 steerHint; // where to steer away from intersection
+            Vector3 surfacePoint; // position of intersection
+            Vector3 surfaceNormal; // unit normal at point of intersection
+            Vector3 steerHint; // where to steer away from intersection
             bool vehicleOutside; // is the vehicle outside the obstacle?
             const AbstractObstacle* obstacle; // obstacle the path intersects
 
             // determine steering based on path intersection tests
-            Vec3 steerToAvoidIfNeeded (const AbstractVehicle&amp; vehicle,
+            Vector3 steerToAvoidIfNeeded (const AbstractVehicle&amp; vehicle,
                                        const float minTimeToCollision) const;
 
         };
@@ -101,7 +101,7 @@
         // specialized by derived types to provide graphics for obstacles
         virtual void draw (const bool filled,
                            const Color&amp; color,
-                           const Vec3&amp; viewpoint)
+                           const Vector3&amp; viewpoint)
             const
             = 0 ;
 
@@ -134,13 +134,13 @@
         virtual ~Obstacle() { /* Nothing to do. */ }
         
         // compute steering for a vehicle to avoid this obstacle, if needed 
-        Vec3 steerToAvoid (const AbstractVehicle&amp; v,
+        Vector3 steerToAvoid (const AbstractVehicle&amp; v,
                            const float minTimeToCollision)
             const;
 
         // static method to apply steerToAvoid to nearest obstacle in an
         // ObstacleGroup
-        static Vec3 steerToAvoidObstacles (const AbstractVehicle&amp; vehicle,
+        static Vector3 steerToAvoidObstacles (const AbstractVehicle&amp; vehicle,
                                            const float minTimeToCollision,
                                            const ObstacleGroup&amp; obstacles);
 
@@ -153,7 +153,7 @@
                                                 PathIntersection&amp; next);
 
         // default do-nothing draw function (derived class can overload this)
-        void draw (const bool, const Color&amp;, const Vec3&amp;) const {}
+        void draw (const bool, const Color&amp;, const Vector3&amp;) const {}
 
         seenFromState seenFrom (void) const {return _seenFrom;}
         void setSeenFrom (seenFromState s) {_seenFrom = s;}
@@ -170,11 +170,11 @@
     {
     public:
         float radius;
-        Vec3 center;
+        Vector3 center;
 
         // constructors
-        SphereObstacle (float r, Vec3 c) : radius(r), center (c) {}
-        SphereObstacle (void) : radius(1), center (Vec3::zero) {}
+        SphereObstacle (float r, Vector3 c) : radius(r), center (c) {}
+        SphereObstacle (void) : radius(1), center (Vector3::ZERO) {}
 
         virtual ~SphereObstacle() { /* Nothing to do. */ }
         
@@ -235,10 +235,10 @@
     public:
         // constructors
         PlaneObstacle (void) {}
-        PlaneObstacle (const Vec3&amp; s,
-                       const Vec3&amp; u,
-                       const Vec3&amp; f,
-                       const Vec3&amp; p)
+        PlaneObstacle (const Vector3&amp; s,
+                       const Vector3&amp; u,
+                       const Vector3&amp; f,
+                       const Vector3&amp; p)
         : LocalSpaceObstacle( s, u, f, p )
         {
             /*
@@ -255,7 +255,7 @@
             const;
 
         // determines if a given point on XY plane is inside obstacle shape
-        virtual bool xyPointInsideShape (const Vec3&amp; /*point*/,
+        virtual bool xyPointInsideShape (const Vector3&amp; /*point*/,
                                          float /*radius*/) const
         {
             return true; // always true for PlaneObstacle
@@ -278,8 +278,8 @@
         // constructors
         RectangleObstacle (float w, float h) : width(w), height(h) {}
         RectangleObstacle (void) :  width(1.0f), height(1.0f) {}
-        RectangleObstacle (float w, float h, const Vec3&amp; s,
-                           const Vec3&amp; u, const Vec3&amp; f, const Vec3&amp; p,
+        RectangleObstacle (float w, float h, const Vector3&amp; s,
+                           const Vector3&amp; u, const Vector3&amp; f, const Vector3&amp; p,
                            seenFromState sf) 
             : PlaneObstacle( s, u, f, p ), width(w), height(h)
         {
@@ -295,7 +295,7 @@
         virtual ~RectangleObstacle() { /* Nothing to do. */ }
 
         // determines if a given point on XY plane is inside obstacle shape
-        bool xyPointInsideShape (const Vec3&amp; point, float radius) const;
+        bool xyPointInsideShape (const Vector3&amp; point, float radius) const;
     };
 
 

Modified: dependencies/opensteer/include/OpenSteer/OldPathway.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/OldPathway.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/OldPathway.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -65,28 +65,28 @@
             // this path.  Also returns, via output arguments, the path tangent at
             // P and a measure of how far A is outside the Pathway's &quot;tube&quot;.  Note
             // that a negative distance indicates A is inside the Pathway.
-            virtual Vec3 mapPointToPath (const Vec3&amp; point,
-                Vec3&amp; tangent,
+            virtual Vector3 mapPointToPath (const Vector3&amp; point,
+                Vector3&amp; tangent,
                 float&amp; outside) = 0;
 
             // given a distance along the path, convert it to a point on the path
-            virtual Vec3 mapPathDistanceToPoint (float pathDistance) = 0;
+            virtual Vector3 mapPathDistanceToPoint (float pathDistance) = 0;
 
             // Given an arbitrary point, convert it to a distance along the path.
-            virtual float mapPointToPathDistance (const Vec3&amp; point) = 0;
+            virtual float mapPointToPathDistance (const Vector3&amp; point) = 0;
 
             // is the given point inside the path tube?
-            bool isInsidePath (const Vec3&amp; point)
+            bool isInsidePath (const Vector3&amp; point)
             {
-                float outside; Vec3 tangent;
+                float outside; Vector3 tangent;
                 mapPointToPath (point, tangent, outside);
                 return outside &lt; 0;
             }
 
             // how far outside path tube is the given point?  (negative is inside)
-            float howFarOutsidePath (const Vec3&amp; point)
+            float howFarOutsidePath (const Vector3&amp; point)
             {
-                float outside; Vec3 tangent;
+                float outside; Vector3 tangent;
                 mapPointToPath (point, tangent, outside);
                 return outside;
             }
@@ -106,7 +106,7 @@
         public:
 
             int pointCount;
-            Vec3* points;
+            Vector3* points;
             float radius;
             bool cyclic;
 
@@ -116,13 +116,13 @@
             // construct a PolylinePathway given the number of points (vertices),
             // an array of points, and a path radius.
             PolylinePathway (const int _pointCount,
-                const Vec3 _points[],
+                const Vector3 _points[],
                 const float _radius,
                 const bool _cyclic);
 
             // utility for constructors in derived classes
             void initialize (const int _pointCount,
-                const Vec3 _points[],
+                const Vector3 _points[],
                 const float _radius,
                 const bool _cyclic);
 
@@ -133,27 +133,27 @@
             // move existing points safely
             void movePoints (const int _firstPoint,
                             const int _numPoints,
-                            const Vec3 _points[]);
+                            const Vector3 _points[]);
 
             // Given an arbitrary point (&quot;A&quot;), returns the nearest point (&quot;P&quot;) on
             // this path.  Also returns, via output arguments, the path tangent at
             // P and a measure of how far A is outside the Pathway's &quot;tube&quot;.  Note
             // that a negative distance indicates A is inside the Pathway.
-            Vec3 mapPointToPath (const Vec3&amp; point, Vec3&amp; tangent, float&amp; outside);
+            Vector3 mapPointToPath (const Vector3&amp; point, Vector3&amp; tangent, float&amp; outside);
 
 
             // given an arbitrary point, convert it to a distance along the path
-            float mapPointToPathDistance (const Vec3&amp; point);
+            float mapPointToPathDistance (const Vector3&amp; point);
 
             // given a distance along the path, convert it to a point on the path
-            Vec3 mapPathDistanceToPoint (float pathDistance);
+            Vector3 mapPathDistanceToPoint (float pathDistance);
 
             // utility methods
 
             // compute minimum distance from a point to a line segment
-            float pointToSegmentDistance (const Vec3&amp; point,
-                const Vec3&amp; ep0,
-                const Vec3&amp; ep1);
+            float pointToSegmentDistance (const Vector3&amp; point,
+                const Vector3&amp; ep0,
+                const Vector3&amp; ep1);
 
             // assessor for total path length;
             float getTotalPathLength (void) {return totalPathLength;};
@@ -167,12 +167,12 @@
             // xxx seems like a bad design
             float segmentLength;
             float segmentProjection;
-            Vec3 local;
-            Vec3 chosen;
-            Vec3 segmentNormal;
+            Vector3 local;
+            Vector3 chosen;
+            Vector3 segmentNormal;
 
             float* lengths;
-            Vec3* normals;
+            Vector3* normals;
             float totalPathLength;
         };
 

Modified: dependencies/opensteer/include/OpenSteer/OpenSteerDemo.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/OpenSteerDemo.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/OpenSteerDemo.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -52,13 +52,10 @@
 #include &quot;OpenSteer/PlugIn.h&quot;
 #include &quot;OpenSteer/Camera.h&quot;
 #include &quot;OpenSteer/Utilities.h&quot;
+#include &quot;OpenSteer/Color.h&quot;
 
-
 namespace OpenSteer {
 
-    class Color;
-    class Vec3;
-    
 
     class OpenSteerDemo
     {
@@ -206,7 +203,7 @@
         // some camera-related default constants
         static const float camera2dElevation;
         static const float cameraTargetDistance;
-        static const Vec3 cameraTargetOffset;
+        static const Vector3 cameraTargetOffset;
 
         // ------------------------------------------------ graphics and annotation
 
@@ -214,7 +211,7 @@
         static void initializeGraphics (void);
 
         // ground plane grid-drawing utility used by several plug-ins
-        static void gridUtility (const Vec3&amp; gridTarget);
+        static void gridUtility (const Vector3&amp; gridTarget);
 
         // draws a gray disk on the XZ plane under a given vehicle
         static void highlightVehicleUtility (const AbstractVehicle&amp; vehicle);

Modified: dependencies/opensteer/include/OpenSteer/Path.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Path.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Path.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -31,15 +31,12 @@
 #define OPENSTEER_PATH_H
 
 
+#include &quot;OpenSteer/Vec3.h&quot;
 
 
-
 namespace OpenSteer {
 
-    // Forward declaration.
-    class Vec3;
     
-    
     /**
      * Path in space that might be cyclic.
      *
@@ -66,21 +63,21 @@
          *
          * If @c isValid is @c false the behavior is undefined.
          */
-		virtual Vec3 mapPointToPath (const Vec3&amp; point,
-                                     Vec3&amp; tangent,
+		virtual Vector3 mapPointToPath (const Vector3&amp; point,
+                                     Vector3&amp; tangent,
                                      float&amp; outside) const = 0;
         
 		/**
          * Given a distance along the path, convert it to a point on the path.
          * If @c isValid is @c false the behavior is undefined.
          */
-		virtual Vec3 mapPathDistanceToPoint (float pathDistance) const = 0;
+		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const = 0;
         
 		/**
          * Given an arbitrary point, convert it to a distance along the path.
          * If @c isValid is @c false the behavior is undefined.
          */
-		virtual float mapPointToPathDistance (const Vec3&amp; point) const = 0;
+		virtual float mapPointToPathDistance (const Vector3&amp; point) const = 0;
         
         /**
          * Returns @c true f the path is closed, otherwise @c false.

Modified: dependencies/opensteer/include/OpenSteer/Pathway.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Pathway.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Pathway.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -30,14 +30,11 @@
 #ifndef OPENSTEER_PATHWAY_H
 #define OPENSTEER_PATHWAY_H
 
+#include &quot;OpenSteer/Vec3.h&quot;
+
 namespace OpenSteer {
     
-    // Forward declaration, include Vec3.h if needed.
-    // @todo Include Vec3.h?
-    class Vec3;
     
-    
-    
     /**
      * Pure virtual base class representing an abstract pathway in space.
      * Could be used for example in path following.
@@ -60,21 +57,21 @@
          *
          * If @c isValid is @c false the behavior is undefined.
          */
-		virtual Vec3 mapPointToPath (const Vec3&amp; point,
-                                     Vec3&amp; tangent,
+		virtual Vector3 mapPointToPath (const Vector3&amp; point,
+                                     Vector3&amp; tangent,
                                      float&amp; outside) const = 0;
         
 		/**
          * Given a distance along the path, convert it to a point on the path.
          * If @c isValid is @c false the behavior is undefined.
          */
-		virtual Vec3 mapPathDistanceToPoint (float pathDistance) const = 0;
+		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const = 0;
         
 		/**
          * Given an arbitrary point, convert it to a distance along the path.
          * If @c isValid is @c false the behavior is undefined.
          */
-		virtual float mapPointToPathDistance (const Vec3&amp; point) const = 0;
+		virtual float mapPointToPathDistance (const Vector3&amp; point) const = 0;
         
         /**
          * Returns @c true f the path is closed, otherwise @c false.

Modified: dependencies/opensteer/include/OpenSteer/PolylineSegmentedPath.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/PolylineSegmentedPath.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/PolylineSegmentedPath.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -43,7 +43,7 @@
 // Include OpenSteer::PointToPathAlikeBaseDataExtractionPolicy
 #include &quot;OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h&quot;
 
-// Include OpenSteer::Vec3
+// Include Vector3
 #include &quot;OpenSteer/Vec3.h&quot;
 
 // Include OpenSteer::distance
@@ -81,7 +81,7 @@
          *                    cycle closing segment.
          */
         PolylineSegmentedPath( size_type numOfPoints,
-                               Vec3 const newPoints[],
+                               Vector3 const newPoints[],
                                bool closedCycle );
         
         PolylineSegmentedPath( PolylineSegmentedPath const&amp; other );
@@ -105,7 +105,7 @@
          *                    cycle closing segment.
          */
         void setPath( size_type numOfPoints,
-                      Vec3 const newPoints[],
+                      Vector3 const newPoints[],
                       bool closedCycle );
         
         /**
@@ -127,49 +127,49 @@
          */
         void movePoints( size_type startIndex,
                          size_type numOfPoints,
-                         Vec3 const newPoints[]);
+                         Vector3 const newPoints[]);
         
         
         
         virtual bool isValid() const;
-        virtual Vec3 mapPointToPath (const Vec3&amp; point,
-                                     Vec3&amp; tangent,
+        virtual Vector3 mapPointToPath (const Vector3&amp; point,
+                                     Vector3&amp; tangent,
                                      float&amp; outside) const;
-		virtual Vec3 mapPathDistanceToPoint (float pathDistance) const;
-		virtual float mapPointToPathDistance (const Vec3&amp; point) const;
+		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const;
+		virtual float mapPointToPathDistance (const Vector3&amp; point) const;
         virtual bool isCyclic() const;
         virtual float length() const;
         
         
         virtual size_type pointCount() const;
-        virtual Vec3 point( size_type pointIndex ) const;        
+        virtual Vector3 point( size_type pointIndex ) const;        
         
         
         virtual size_type segmentCount() const;
         virtual float segmentLength( size_type segmentIndex ) const;
-        virtual Vec3 segmentStart( size_type segmentIndex ) const;
-        virtual Vec3 segmentEnd( size_type segmentIndex ) const;
+        virtual Vector3 segmentStart( size_type segmentIndex ) const;
+        virtual Vector3 segmentEnd( size_type segmentIndex ) const;
         virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vec3 const&amp; point ) const;
-        virtual Vec3 mapSegmentDistanceToPoint( size_type segmentIndex, 
+                                                 Vector3 const&amp; point ) const;
+        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
                                                 float segmentDistance ) const;
-        virtual Vec3 mapSegmentDistanceToTangent( size_type segmentIndex, 
+        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
                                                   float segmentDistance ) const;
         
         virtual void mapDistanceToSegmentPointAndTangent( size_type segmentIndex,
                                                           float distance,
-                                                          Vec3&amp; pointOnPath,
-                                                          Vec3&amp; tangent ) const;
+                                                          Vector3&amp; pointOnPath,
+                                                          Vector3&amp; tangent ) const;
         
         virtual void mapPointToSegmentDistanceAndPointAndTangent( size_type segmentIndex,
-                                                                  Vec3 const&amp; point,
+                                                                  Vector3 const&amp; point,
                                                                   float&amp; distance,
-                                                                  Vec3&amp; pointOnPath,
-                                                                  Vec3&amp; tangent ) const;
+                                                                  Vector3&amp; pointOnPath,
+                                                                  Vector3&amp; tangent ) const;
         
     private:
-        std::vector&lt; Vec3 &gt; points_;
-        std::vector&lt; Vec3 &gt; segmentTangents_;
+        std::vector&lt; Vector3 &gt; points_;
+        std::vector&lt; Vector3 &gt; segmentTangents_;
         std::vector&lt; float &gt; segmentLengths_;
         bool closedCycle_;
     }; // class PolylineSegmentedPath
@@ -192,12 +192,12 @@
         
         static void extract( PolylineSegmentedPath const&amp; pathAlike,
                              PolylineSegmentedPath::size_type segmentIndex,
-                             Vec3 const&amp; point, 
+                             Vector3 const&amp; point, 
                              float&amp; segmentDistance, 
                              float&amp;, 
                              float&amp; distancePointToPath, 
-                             Vec3&amp; pointOnPathCenterLine, 
-                             Vec3&amp; tangent ) {
+                             Vector3&amp; pointOnPathCenterLine, 
+                             Vector3&amp; tangent ) {
             pathAlike.mapPointToSegmentDistanceAndPointAndTangent( segmentIndex, point, segmentDistance, pointOnPathCenterLine, tangent );
             distancePointToPath = distance( point, pointOnPathCenterLine );
         }
@@ -213,8 +213,8 @@
         static void extract( PolylineSegmentedPath const&amp; pathAlike,
                              PolylineSegmentedPath::size_type segmentIndex,
                              float segmentDistance, 
-                             Vec3&amp; pointOnPathCenterLine, 
-                             Vec3&amp; tangent, 
+                             Vector3&amp; pointOnPathCenterLine, 
+                             Vector3&amp; tangent, 
                              float&amp;  )  {
             pathAlike.mapDistanceToSegmentPointAndTangent( segmentIndex, segmentDistance, pointOnPathCenterLine, tangent );     
         }

Modified: dependencies/opensteer/include/OpenSteer/PolylineSegmentedPathwaySegmentRadii.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/PolylineSegmentedPathwaySegmentRadii.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/PolylineSegmentedPathwaySegmentRadii.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -48,7 +48,7 @@
 // Include OpenSteer::PointToPathAlikeBaseDataExtractionPolicy
 #include &quot;OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h&quot;
 
-// Include OpenSteer::Vec3
+// Include Vector3
 #include &quot;OpenSteer/Vec3.h&quot;
 
 // Include OpenSteer::distance
@@ -79,7 +79,7 @@
          * last point mustn't be identical, too.
          */
         PolylineSegmentedPathwaySegmentRadii( size_type numOfPoints,
-                                              Vec3 const points[],
+                                              Vector3 const points[],
                                               float const radii[],
                                               bool closedCycle );
         PolylineSegmentedPathwaySegmentRadii( PolylineSegmentedPathwaySegmentRadii const&amp; other );
@@ -111,7 +111,7 @@
          */
         void movePoints( size_type startIndex,
                          size_type numOfPoints,
-                         Vec3 const points[] );
+                         Vector3 const points[] );
         /**
          * Replaces the pathway information completely.
          *
@@ -133,7 +133,7 @@
          *        otherwise.
          */
         void setPathway( size_type numOfPoints,
-                         Vec3 const points[],
+                         Vector3 const points[],
                          float const radii[],
                          bool closedCycle );
         
@@ -162,43 +162,43 @@
         
         
         virtual bool isValid() const;
-        virtual Vec3 mapPointToPath (const Vec3&amp; point,
-                                     Vec3&amp; tangent,
+        virtual Vector3 mapPointToPath (const Vector3&amp; point,
+                                     Vector3&amp; tangent,
                                      float&amp; outside) const;
-		virtual Vec3 mapPathDistanceToPoint (float pathDistance) const;
-		virtual float mapPointToPathDistance (const Vec3&amp; point) const;
+		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const;
+		virtual float mapPointToPathDistance (const Vector3&amp; point) const;
         virtual bool isCyclic() const;
         virtual float length() const;
         
         
         virtual size_type pointCount() const;
-        virtual Vec3 point( size_type pointIndex ) const;  
+        virtual Vector3 point( size_type pointIndex ) const;  
         
         
         virtual size_type segmentCount() const;
         virtual float segmentLength( size_type segmentIndex ) const;
-        virtual Vec3 segmentStart( size_type segmentIndex ) const;
-        virtual Vec3 segmentEnd( size_type segmentIndex ) const;
+        virtual Vector3 segmentStart( size_type segmentIndex ) const;
+        virtual Vector3 segmentEnd( size_type segmentIndex ) const;
         virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vec3 const&amp; point ) const;
-        virtual Vec3 mapSegmentDistanceToPoint( size_type segmentIndex, 
+                                                 Vector3 const&amp; point ) const;
+        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
                                                 float segmentDistance ) const;
         virtual float mapSegmentDistanceToRadius( size_type segmentIndex, 
                                                   float distanceOnSegment ) const;
-        virtual Vec3 mapSegmentDistanceToTangent( size_type segmentIndex, 
+        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
                                                   float segmentDistance ) const;
         
         virtual void mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
                                                                    float segmentDistance,
-                                                                   Vec3&amp; pointOnPath,
-                                                                   Vec3&amp; tangent,
+                                                                   Vector3&amp; pointOnPath,
+                                                                   Vector3&amp; tangent,
                                                                    float&amp; radius ) const;
             
         virtual void mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
-                                                                           Vec3 const&amp; point,
+                                                                           Vector3 const&amp; point,
                                                                            float&amp; distance,
-                                                                           Vec3&amp; pointOnPath,
-                                                                           Vec3&amp; tangent,
+                                                                           Vector3&amp; pointOnPath,
+                                                                           Vector3&amp; tangent,
                                                                            float&amp; radius) const;
 
     private:
@@ -225,12 +225,12 @@
             
         static void extract( PolylineSegmentedPathwaySegmentRadii const&amp; pathAlike,
                              PolylineSegmentedPathwaySegmentRadii::size_type segmentIndex,
-                             Vec3 const&amp; point, 
+                             Vector3 const&amp; point, 
                              float&amp; segmentDistance, 
                              float&amp; radius, 
                              float&amp; distancePointToPath, 
-                             Vec3&amp; pointOnPathCenterLine, 
-                             Vec3&amp; tangent ) {
+                             Vector3&amp; pointOnPathCenterLine, 
+                             Vector3&amp; tangent ) {
             pathAlike.mapPointToSegmentDistanceAndPointAndTangentAndRadius( segmentIndex, point, segmentDistance, pointOnPathCenterLine, tangent, radius );
             distancePointToPath = distance( point, pointOnPathCenterLine ) - radius;
         }
@@ -247,8 +247,8 @@
         static void extract( PolylineSegmentedPathwaySegmentRadii const&amp; pathAlike,
                              PolylineSegmentedPathwaySegmentRadii::size_type segmentIndex,
                              float segmentDistance, 
-                             Vec3&amp; pointOnPathCenterLine, 
-                             Vec3&amp; tangent, 
+                             Vector3&amp; pointOnPathCenterLine, 
+                             Vector3&amp; tangent, 
                              float&amp; radius )  {
             pathAlike.mapDistanceToSegmentPointAndTangentAndRadius( segmentIndex, segmentDistance, pointOnPathCenterLine, tangent, radius );     
         }

Modified: dependencies/opensteer/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -42,7 +42,7 @@
 // Include OpenSteer::PointToPathAlikeBaseDataExtractionPolicy
 #include &quot;OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h&quot;
 
-// Include OpenSteer::Vec3
+// Include Vector3
 #include &quot;OpenSteer/Vec3.h&quot;
 
 // Include OpenSteer::distance
@@ -61,7 +61,7 @@
         PolylineSegmentedPathwaySingleRadius();
         explicit PolylineSegmentedPathwaySingleRadius( float r );
         PolylineSegmentedPathwaySingleRadius( size_type numOfPoints,
-                                              Vec3 const points[],
+                                              Vector3 const points[],
                                               float r,
                                               bool closeCycle );
         PolylineSegmentedPathwaySingleRadius( PolylineSegmentedPathwaySingleRadius const&amp; other );
@@ -92,7 +92,7 @@
          */
         void movePoints( size_type startIndex,
                          size_type numOfPoints,
-                         Vec3 const newPointValues[] );
+                         Vector3 const newPointValues[] );
         /**
          * Replaces the pathway information completely.
          *
@@ -109,7 +109,7 @@
          *        otherwise.
          */
         void setPathway( size_type numOfPoints,
-                         Vec3 const points[],
+                         Vector3 const points[],
                          float r,
                          bool closedCycle );
         
@@ -125,43 +125,43 @@
         
         
         virtual bool isValid() const;
-		virtual Vec3 mapPointToPath (const Vec3&amp; point,
-                                     Vec3&amp; tangent,
+		virtual Vector3 mapPointToPath (const Vector3&amp; point,
+                                     Vector3&amp; tangent,
                                      float&amp; outside) const;
-		virtual Vec3 mapPathDistanceToPoint (float pathDistance) const;
-		virtual float mapPointToPathDistance (const Vec3&amp; point) const;
+		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const;
+		virtual float mapPointToPathDistance (const Vector3&amp; point) const;
         virtual bool isCyclic() const;
         virtual float length() const;
         
         
         virtual size_type pointCount() const;
-        virtual Vec3 point( size_type pointIndex ) const;
+        virtual Vector3 point( size_type pointIndex ) const;
         
         
         virtual size_type segmentCount() const;
         virtual float segmentLength( size_type segmentIndex ) const;
-        virtual Vec3 segmentStart( size_type segmentIndex ) const;
-        virtual Vec3 segmentEnd( size_type segmentIndex ) const;
+        virtual Vector3 segmentStart( size_type segmentIndex ) const;
+        virtual Vector3 segmentEnd( size_type segmentIndex ) const;
         virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vec3 const&amp; point ) const;
-        virtual Vec3 mapSegmentDistanceToPoint( size_type segmentIndex, 
+                                                 Vector3 const&amp; point ) const;
+        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
                                                 float segmentDistance ) const;
         virtual float mapSegmentDistanceToRadius( size_type segmentIndex, 
                                                  float distanceOnSegment ) const;
-        virtual Vec3 mapSegmentDistanceToTangent( size_type segmentIndex, 
+        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
                                                   float segmentDistance ) const;
         
         virtual void mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
                                                                    float segmentDistance,
-                                                                   Vec3&amp; pointOnPath,
-                                                                   Vec3&amp; tangent,
+                                                                   Vector3&amp; pointOnPath,
+                                                                   Vector3&amp; tangent,
                                                                    float&amp; radius ) const;
         
         virtual void mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
-                                                                           Vec3 const&amp; point,
+                                                                           Vector3 const&amp; point,
                                                                            float&amp; distance,
-                                                                           Vec3&amp; pointOnPath,
-                                                                           Vec3&amp; tangent,
+                                                                           Vector3&amp; pointOnPath,
+                                                                           Vector3&amp; tangent,
                                                                            float&amp; radius) const;
          
     private:
@@ -188,12 +188,12 @@
             
         static void extract( PolylineSegmentedPathwaySingleRadius const&amp; pathAlike,
                              PolylineSegmentedPathwaySingleRadius::size_type segmentIndex,
-                             Vec3 const&amp; point, 
+                             Vector3 const&amp; point, 
                              float&amp; segmentDistance, 
                              float&amp; radius, 
                              float&amp; distancePointToPath, 
-                             Vec3&amp; pointOnPathCenterLine, 
-                             Vec3&amp; tangent ) {
+                             Vector3&amp; pointOnPathCenterLine, 
+                             Vector3&amp; tangent ) {
             pathAlike.mapPointToSegmentDistanceAndPointAndTangentAndRadius( segmentIndex, point, segmentDistance, pointOnPathCenterLine, tangent, radius );
             distancePointToPath = distance( point, pointOnPathCenterLine ) - radius;
         }
@@ -210,8 +210,8 @@
         static void extract( PolylineSegmentedPathwaySingleRadius const&amp; pathAlike,
                              PolylineSegmentedPathwaySingleRadius::size_type segmentIndex,
                              float segmentDistance, 
-                             Vec3&amp; pointOnPathCenterLine, 
-                             Vec3&amp; tangent, 
+                             Vector3&amp; pointOnPathCenterLine, 
+                             Vector3&amp; tangent, 
                              float&amp; radius )  {
             pathAlike.mapDistanceToSegmentPointAndTangentAndRadius( segmentIndex, segmentDistance, pointOnPathCenterLine, tangent, radius );     
         }

Modified: dependencies/opensteer/include/OpenSteer/Proximity.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Proximity.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Proximity.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -64,10 +64,10 @@
         virtual ~AbstractTokenForProximityDatabase () {}
 
         // the client object calls this each time its position changes
-        virtual void updateForNewPosition (const Vec3&amp; position) = 0;
+        virtual void updateForNewPosition (const Vector3&amp; position) = 0;
 
         // find all neighbors within the given sphere (as center and radius)
-        virtual void findNeighbors (const Vec3&amp; center,
+        virtual void findNeighbors (const Vector3&amp; center,
                                     const float radius,
                                     std::vector&lt;ContentType&gt;&amp; results) = 0;
 
@@ -155,13 +155,13 @@
             }
 
             // the client object calls this each time its position changes
-            void updateForNewPosition (const Vec3&amp; newPosition)
+            void updateForNewPosition (const Vector3&amp; newPosition)
             {
                 position = newPosition;
             }
 
             // find all neighbors within the given sphere (as center and radius)
-            void findNeighbors (const Vec3&amp; center,
+            void findNeighbors (const Vector3&amp; center,
                                 const float radius,
                                 std::vector&lt;ContentType&gt;&amp; results)
             {
@@ -171,7 +171,7 @@
                      i != bfpd-&gt;group.end();
                      i++)
                 {
-                    const Vec3 offset = center - (**i).position;
+                    const Vector3 offset = center - (**i).position;
                     const float d2 = offset.lengthSquared();
 
                     // push onto result vector when within given radius
@@ -182,7 +182,7 @@
         private:
             BruteForceProximityDatabase* bfpd;
             ContentType object;
-            Vec3 position;
+            Vector3 position;
         };
 
         typedef std::vector&lt;tokenType*&gt; tokenVector;
@@ -216,12 +216,12 @@
     public:
 
         // constructor
-        LQProximityDatabase (const Vec3&amp; center,
-                             const Vec3&amp; dimensions,
-                             const Vec3&amp; divisions)
+        LQProximityDatabase (const Vector3&amp; center,
+                             const Vector3&amp; dimensions,
+                             const Vector3&amp; divisions)
         {
-            const Vec3 halfsize (dimensions * 0.5f);
-            const Vec3 origin (center - halfsize);
+            const Vector3 halfsize (dimensions * 0.5f);
+            const Vector3 origin (center - halfsize);
 
             lq = lqCreateDatabase (origin.x, origin.y, origin.z, 
                                    dimensions.x, dimensions.y, dimensions.z,  
@@ -256,13 +256,13 @@
             }
 
             // the client object calls this each time its position changes
-            void updateForNewPosition (const Vec3&amp; p)
+            void updateForNewPosition (const Vector3&amp; p)
             {
                 lqUpdateForNewLocation (lq, &amp;proxy, p.x, p.y, p.z);
             }
 
             // find all neighbors within the given sphere (as center and radius)
-            void findNeighbors (const Vec3&amp; center,
+            void findNeighbors (const Vector3&amp; center,
                                 const float radius,
                                 std::vector&lt;ContentType&gt;&amp; results)
             {

Modified: dependencies/opensteer/include/OpenSteer/QueryPathAlike.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/QueryPathAlike.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/QueryPathAlike.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -39,7 +39,7 @@
 
 
 
-// Include OpenSteer::Vec3
+// Include Vector3
 #include &quot;OpenSteer/Vec3.h&quot;
 
 // Include OpenSteer::distance
@@ -77,10 +77,10 @@
          * empty member function calls and the associated calculations for its
          * parameters away.
          *
-         * &lt;code&gt; void setPointOnPathCenterLine( Vec3 const&amp; ) &lt;/code&gt;
-         * &lt;code&gt; void setPointOnPathBoundary( Vec3 const&amp; ) &lt;/code&gt;
+         * &lt;code&gt; void setPointOnPathCenterLine( Vector3 const&amp; ) &lt;/code&gt;
+         * &lt;code&gt; void setPointOnPathBoundary( Vector3 const&amp; ) &lt;/code&gt;
          * &lt;code&gt; void setRadius( float ) &lt;/code&gt;
-         * &lt;code&gt; void setTangent( Vec3 const&amp; ) &lt;/code&gt;
+         * &lt;code&gt; void setTangent( Vector3 const&amp; ) &lt;/code&gt;
          * &lt;code&gt; void setSegmentIndex( typename SegmentedPathAlike::size_type ) &lt;/code&gt;
          * &lt;code&gt; void setDistancePointToPath( float ) &lt;/code&gt;
          * &lt;code&gt; void setDistancePointToPathCenterLine( float ) &lt;/code&gt;
@@ -99,7 +99,7 @@
          * @c QueryPathAlikeUtilities.h provides some base classes to inherit
          * from to automatically get some of the functionality described above.
          */
-        static void map( PathAlike const&amp; pathAlike, Vec3 const&amp; queryPoint, Mapping&amp; mapping ) {
+        static void map( PathAlike const&amp; pathAlike, Vector3 const&amp; queryPoint, Mapping&amp; mapping ) {
             float minDistancePointToPath = std::numeric_limits&lt; float &gt;::max();
             mapping.setDistanceOnPathFlag( 0.0f );
             
@@ -110,15 +110,15 @@
                 float segmentDistance = 0.0f;
                 float radius = 0.0f;
                 float distancePointToPath = 0.0f;
-                Vec3 pointOnPathCenterLine( 0.0f, 0.0f, 0.0f );
-                Vec3 tangent( 0.0f, 0.0f, 0.0f );
+                Vector3 pointOnPathCenterLine( 0.0f, 0.0f, 0.0f );
+                Vector3 tangent( 0.0f, 0.0f, 0.0f );
                 
                 BaseDataExtractionPolicy::extract( pathAlike, segmentIndex, queryPoint, segmentDistance, radius, distancePointToPath, pointOnPathCenterLine, tangent );
                 
                 if ( distancePointToPath &lt; minDistancePointToPath ) {
                     minDistancePointToPath = distancePointToPath;
                     mapping.setPointOnPathCenterLine( pointOnPathCenterLine );
-                    mapping.setPointOnPathBoundary( pointOnPathCenterLine + ( ( queryPoint - pointOnPathCenterLine ).normalize() * radius ) );
+                    mapping.setPointOnPathBoundary( pointOnPathCenterLine + ( ( queryPoint - pointOnPathCenterLine ).normalisedCopy() * radius ) );
                     mapping.setRadius( radius );
                     mapping.setTangent( tangent );
                     mapping.setSegmentIndex( segmentIndex );
@@ -141,7 +141,7 @@
      * See @c MapPointToPathAlike::map for further information.
      */
     template&lt; class PathAlike, class Mapping &gt;
-    void mapPointToPathAlike( PathAlike const&amp; pathAlike, Vec3 const&amp; point, Mapping&amp; mapping ) {
+    void mapPointToPathAlike( PathAlike const&amp; pathAlike, Vector3 const&amp; point, Mapping&amp; mapping ) {
         PointToPathAlikeMapping&lt; PathAlike, Mapping &gt;::map( pathAlike, point, mapping );
     }
     
@@ -165,9 +165,9 @@
          * empty member function calls and the associated calculations for its
          * parameters away.
          *
-         * &lt;code&gt; void setPointOnPathCenterLine( Vec3 const&amp; ) &lt;/code&gt;
+         * &lt;code&gt; void setPointOnPathCenterLine( Vector3 const&amp; ) &lt;/code&gt;
          * &lt;code&gt; void setRadius( float ) &lt;/code&gt;
-         * &lt;code&gt; void setTangent( Vec3 const&amp; ) &lt;/code&gt;
+         * &lt;code&gt; void setTangent( Vector3 const&amp; ) &lt;/code&gt;
          * &lt;code&gt; void setSegmentIndex( typename SegmentedPathAlike::size_type ) &lt;/code&gt;
          * &lt;code&gt; void setDistanceOnPath( float ) &lt;/code&gt;
          * &lt;code&gt; void setDistanceOnSegment( float ) &lt;/code&gt;
@@ -194,8 +194,8 @@
             
             // Extract the path related data associated with the segment reached
             // by @c distanceOnPath.
-            Vec3 pointOnPathCenterLine( 0.0f, 0.0f, 0.0f );
-            Vec3 tangent( 0.0f, 0.0f, 0.0f );
+            Vector3 pointOnPathCenterLine( 0.0f, 0.0f, 0.0f );
+            Vector3 tangent( 0.0f, 0.0f, 0.0f );
             float radius = 0.0f;
             BaseDataExtractionPolicy::extract( pathAlike, segmentIndex, remainingDistance, pointOnPathCenterLine, tangent, radius );
             

Modified: dependencies/opensteer/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -43,7 +43,7 @@
      * Specialize it for the path alike to use and provide a static member
      * function with the following signature:
      *
-     * &lt;code&gt;static void extract( PathAlike const&amp; pathAlike, typename PathAlike::size_type segmentIndex, Vec3 const&amp; point, float&amp; segmentDistance, float&amp; radius, float&amp; distancePointToPath, Vec3&amp; pointOnPathCenterLine, Vec3&amp; tangent )&lt;/code&gt;
+     * &lt;code&gt;static void extract( PathAlike const&amp; pathAlike, typename PathAlike::size_type segmentIndex, Vector3 const&amp; point, float&amp; segmentDistance, float&amp; radius, float&amp; distancePointToPath, Vector3&amp; pointOnPathCenterLine, Vector3&amp; tangent )&lt;/code&gt;
      *
      * @attention Be aware of the references that are passed in.
      */
@@ -58,7 +58,7 @@
      * Specialize it for the path alike to use and provide a static member
      * function with the following signature:
      *
-     * &lt;code&gt;static void extract( PathAlike const&amp; pathAlike, typename PathAlike::size_type segmentIndex, float segmentDistance, Vec3&amp; pointOnPathCenterLine, Vec3&amp; tangent, float&amp; radius )&lt;/code&gt;
+     * &lt;code&gt;static void extract( PathAlike const&amp; pathAlike, typename PathAlike::size_type segmentIndex, float segmentDistance, Vector3&amp; pointOnPathCenterLine, Vector3&amp; tangent, float&amp; radius )&lt;/code&gt;
      *
      * @attention Be aware of the references that are passed in.
      */    

Modified: dependencies/opensteer/include/OpenSteer/QueryPathAlikeMappings.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/QueryPathAlikeMappings.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/QueryPathAlikeMappings.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -38,7 +38,7 @@
 // Include OpenSteer::HasNoRadius, OpenSteer::ExtractPathDistance, OpenSteer::DontExtractPathDistance
 #include &quot;OpenSteer/QueryPathAlikeUtilities.h&quot;
 
-// Include OpenSteer::Vec3
+// Include Vector3
 #include &quot;OpenSteer/Vec3.h&quot;
 
 // Include OpenSteer::size_t
@@ -59,14 +59,14 @@
     public:
         PointToPathMapping() : pointOnPathCenterLine( 0.0f, 0.0f, 0.0f ), tangent( 0.0f, 0.0f, 0.0f ), distancePointToPath( 0.0f ) {}
             
-        void setPointOnPathCenterLine( Vec3 const&amp; point ) {
+        void setPointOnPathCenterLine( Vector3 const&amp; point ) {
             pointOnPathCenterLine = point;
         }
-        void setPointOnPathBoundary( Vec3 const&amp; ) {
+        void setPointOnPathBoundary( Vector3 const&amp; ) {
             // pointOnPathBoundary = point;
         }
         void setRadius( float ) {}
-        void setTangent( Vec3 const&amp; t) {
+        void setTangent( Vector3 const&amp; t) {
             tangent = t;
         }
         void setSegmentIndex( size_t ) {}
@@ -77,9 +77,9 @@
         void setDistanceOnPath( float ) {}
         void setDistanceOnSegment( float ) {}
             
-        Vec3 pointOnPathCenterLine;
-        // Vec3 pointOnPathBoundary; 
-        Vec3 tangent;
+        Vector3 pointOnPathCenterLine;
+        // Vector3 pointOnPathBoundary; 
+        Vector3 tangent;
         float distancePointToPath;
             
             
@@ -95,17 +95,17 @@
             
     public:
         
-        void setPointOnPathCenterLine( Vec3 const&amp; vec ){
+        void setPointOnPathCenterLine( Vector3 const&amp; vec ){
             pointOnPathCenterLine = vec;
         }
         void setRadius( float ) {}
-        void setTangent( Vec3 const&amp; ){}
+        void setTangent( Vector3 const&amp; ){}
         void setSegmentIndex( size_t ){}
         void setDistanceOnPath( float ){}
         void setDistanceOnSegment( float ){}
             
             
-        Vec3 pointOnPathCenterLine; 
+        Vector3 pointOnPathCenterLine; 
             
             
     }; // class PathDistanceToPointMapping
@@ -121,10 +121,10 @@
     public:
         PointToPathDistanceMapping() : distanceOnPath( 0.0f ) {}
             
-        void setPointOnPathCenterLine( Vec3 const&amp; ) {}
-        void setPointOnPathBoundary( Vec3 const&amp;  ) {}
+        void setPointOnPathCenterLine( Vector3 const&amp; ) {}
+        void setPointOnPathBoundary( Vector3 const&amp;  ) {}
         void setRadius( float ) {}
-        void setTangent( Vec3 const&amp; ) {}
+        void setTangent( Vector3 const&amp; ) {}
         void setSegmentIndex( size_t ) {}
         void setDistancePointToPath( float  ) {}
         void setDistancePointToPathCenterLine( float ) {}

Modified: dependencies/opensteer/include/OpenSteer/SegmentedPath.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/SegmentedPath.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/SegmentedPath.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -63,7 +63,7 @@
          * If the path is cyclic also the last point that is the duplicated
          * first one is accessible.
          */
-        virtual Vec3 point( size_type pointIndex ) const = 0;
+        virtual Vector3 point( size_type pointIndex ) const = 0;
         
         
         
@@ -80,12 +80,12 @@
         /**
          * Returns the start point of the segment @a segmentIndex.
          */
-        virtual Vec3 segmentStart( size_type segmentIndex ) const = 0;
+        virtual Vector3 segmentStart( size_type segmentIndex ) const = 0;
         
         /**
          * Returns the end point of segment @a segmentIndex.
          */
-        virtual Vec3 segmentEnd( size_type segmentIndex ) const = 0;
+        virtual Vector3 segmentEnd( size_type segmentIndex ) const = 0;
         
         
         /**
@@ -94,7 +94,7 @@
          * this point.
          */
         virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vec3 const&amp; point ) const = 0;
+                                                 Vector3 const&amp; point ) const = 0;
         
         
         /**
@@ -104,7 +104,7 @@
          * If @a segmentDistance is greater or smaller than the segment length
          * is is clamped to @c 0.0f or @c segmentLength().
          */
-        virtual Vec3 mapSegmentDistanceToPoint( size_type segmentIndex, 
+        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
                                                 float segmentDistance ) const = 0;
         
         /**
@@ -115,7 +115,7 @@
          * If @a segmentDistance is greater or smaller than the segment length
          * is is clamped to @c 0.0f or @c segmentLength().
          */
-        virtual Vec3 mapSegmentDistanceToTangent( size_type segmentIndex, 
+        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
                                                   float segmentDistance ) const = 0;
         
         
@@ -125,8 +125,8 @@
          */
         virtual void mapDistanceToSegmentPointAndTangent( size_type segmentIndex,
                                                           float distance,
-                                                          Vec3&amp; pointOnPath,
-                                                          Vec3&amp; tangent ) const = 0;
+                                                          Vector3&amp; pointOnPath,
+                                                          Vector3&amp; tangent ) const = 0;
         
         
         /**
@@ -134,10 +134,10 @@
          * and @c mapSegmentDistanceToTangent.
          */
         virtual void mapPointToSegmentDistanceAndPointAndTangent( size_type segmentIndex,
-                                                                  Vec3 const&amp; point,
+                                                                  Vector3 const&amp; point,
                                                                   float&amp; distance,
-                                                                  Vec3&amp; pointOnPath,
-                                                                  Vec3&amp; tangent ) const = 0;
+                                                                  Vector3&amp; pointOnPath,
+                                                                  Vector3&amp; tangent ) const = 0;
 
     protected:
         /**

Modified: dependencies/opensteer/include/OpenSteer/SegmentedPathway.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/SegmentedPathway.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/SegmentedPathway.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -42,9 +42,6 @@
 
 namespace OpenSteer {
 
-    // Forward declaration
-    class Vec3;
-    
     /**
      * Path defined by path segments.
      *
@@ -71,7 +68,7 @@
          * If the path is cyclic also the last point that is the duplicated
          * first one is accessible.
          */
-        virtual Vec3 point( size_type pointIndex ) const = 0;
+        virtual Vector3 point( size_type pointIndex ) const = 0;
         
         
         /**
@@ -87,12 +84,12 @@
         /**
          * Returns the start point of the segment @a segmentIndex.
          */
-        virtual Vec3 segmentStart( size_type segmentIndex ) const = 0;
+        virtual Vector3 segmentStart( size_type segmentIndex ) const = 0;
         
         /**
          * Returns the end point of segment @a segmentIndex.
          */
-        virtual Vec3 segmentEnd( size_type segmentIndex ) const = 0;
+        virtual Vector3 segmentEnd( size_type segmentIndex ) const = 0;
         
         
         
@@ -102,7 +99,7 @@
          * this point.
          */
         virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vec3 const&amp; point ) const = 0;
+                                                 Vector3 const&amp; point ) const = 0;
         
         
         /**
@@ -112,7 +109,7 @@
          * If @a segmentDistance is greater or smaller than the segment length
          * is is clamped to @c 0.0f or @c segmentLength().
          */
-        virtual Vec3 mapSegmentDistanceToPoint( size_type segmentIndex, 
+        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
                                                 float segmentDistance ) const = 0;
         
         /**
@@ -133,7 +130,7 @@
          * If @a segmentDistance is greater or smaller than the segment length
          * is is clamped to @c 0.0f or @c segmentLength().
          */
-        virtual Vec3 mapSegmentDistanceToTangent( size_type segmentIndex, 
+        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
                                                   float segmentDistance ) const = 0;
         
         /**
@@ -142,8 +139,8 @@
          */
         virtual void mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
                                                                    float segmentDistance,
-                                                                   Vec3&amp; pointOnPath,
-                                                                   Vec3&amp; tangent,
+                                                                   Vector3&amp; pointOnPath,
+                                                                   Vector3&amp; tangent,
                                                                    float&amp; radius ) const = 0;        
         
         /**
@@ -151,10 +148,10 @@
          * @c mapSegmentDistanceToRadius, and @c mapSegmentDistanceToTangent.
          */
         virtual void mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
-                                                                           Vec3 const&amp; point,
+                                                                           Vector3 const&amp; point,
                                                                            float&amp; distance,
-                                                                           Vec3&amp; pointOnPath,
-                                                                           Vec3&amp; tangent,
+                                                                           Vector3&amp; pointOnPath,
+                                                                           Vector3&amp; tangent,
                                                                            float&amp; radius) const = 0;
         
        

Modified: dependencies/opensteer/include/OpenSteer/SimpleVehicle.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/SimpleVehicle.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/SimpleVehicle.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -127,7 +127,7 @@
         float setMass (float m) {return _mass = m;}
 
         // get velocity of vehicle
-        Vec3 velocity (void) const {return forward() * _speed;}
+        Vector3 velocity (void) const {return forward() * _speed;}
 
         // get/set speed of vehicle  (may be faster than taking mag of velocity)
         float speed (void) const {return _speed;}
@@ -148,24 +148,24 @@
 
         // apply a given steering force to our momentum,
         // adjusting our orientation to maintain velocity-alignment.
-        void applySteeringForce (const Vec3&amp; force, const float deltaTime);
+        void applySteeringForce (const Vector3&amp; force, const float deltaTime);
 
         // the default version: keep FORWARD parallel to velocity, change
         // UP as little as possible.
-        virtual void regenerateLocalSpace (const Vec3&amp; newVelocity,
+        virtual void regenerateLocalSpace (const Vector3&amp; newVelocity,
                                            const float elapsedTime);
 
         // alternate version: keep FORWARD parallel to velocity, adjust UP
         // according to a no-basis-in-reality &quot;banking&quot; behavior, something
         // like what birds and airplanes do.  (XXX experimental cwr 6-5-03)
-        void regenerateLocalSpaceForBanking (const Vec3&amp; newVelocity,
+        void regenerateLocalSpaceForBanking (const Vector3&amp; newVelocity,
                                              const float elapsedTime);
 
         // adjust the steering force passed to applySteeringForce.
         // allows a specific vehicle class to redefine this adjustment.
         // default is to disallow backward-facing steering at low speed.
         // xxx experimental 8-20-02
-        virtual Vec3 adjustRawSteeringForce (const Vec3&amp; force,
+        virtual Vector3 adjustRawSteeringForce (const Vector3&amp; force,
                                              const float deltaTime);
 
         // apply a given braking force (for a given dt) to our momentum.
@@ -174,7 +174,7 @@
 
         // predict position of this vehicle at some time in the future
         // (assumes velocity remains constant)
-        Vec3 predictFuturePosition (const float predictionTime) const;
+        Vector3 predictFuturePosition (const float predictionTime) const;
 
         // get instantaneous curvature (since last update)
         float curvature (void) const {return _curvature;}
@@ -183,17 +183,17 @@
         float smoothedCurvature (void) {return _smoothedCurvature;}
         float resetSmoothedCurvature (float value = 0)
         {
-            _lastForward = Vec3::zero;
-            _lastPosition = Vec3::zero;
+            _lastForward = Vector3::ZERO;
+            _lastPosition = Vector3::ZERO;
             return _smoothedCurvature = _curvature = value;
         }
-        Vec3 smoothedAcceleration (void) {return _smoothedAcceleration;}
-        Vec3 resetSmoothedAcceleration (const Vec3&amp; value = Vec3::zero)
+        Vector3 smoothedAcceleration (void) {return _smoothedAcceleration;}
+        Vector3 resetSmoothedAcceleration (const Vector3&amp; value = Vector3::ZERO)
         {
             return _smoothedAcceleration = value;
         }
-        Vec3 smoothedPosition (void) {return _smoothedPosition;}
-        Vec3 resetSmoothedPosition (const Vec3&amp; value = Vec3::zero)
+        Vector3 smoothedPosition (void) {return _smoothedPosition;}
+        Vector3 resetSmoothedPosition (const Vector3&amp; value = Vector3::ZERO)
         {
             return _smoothedPosition = value;
         }
@@ -213,7 +213,7 @@
         // rotate about it by a random angle (pick random forward, derive side).
         void randomizeHeadingOnXZPlane (void)
         {
-            setUp (Vec3::up);
+            setUp (Vector3::UNIT_Y);
             setForward (RandomUnitVectorOnXZPlane ());
             setSide (localRotateForwardToSide (forward()));
         }
@@ -234,11 +234,11 @@
                            // (velocity is clipped to this magnitude)
 
         float _curvature;
-        Vec3 _lastForward;
-        Vec3 _lastPosition;
-        Vec3 _smoothedPosition;
+        Vector3 _lastForward;
+        Vector3 _lastPosition;
+        Vector3 _smoothedPosition;
         float _smoothedCurvature;
-        Vec3 _smoothedAcceleration;
+        Vector3 _smoothedAcceleration;
 
         // measure path curvature (1/turning-radius), maintain smoothed version
         void measurePathCurvature (const float elapsedTime);

Modified: dependencies/opensteer/include/OpenSteer/SteerLibrary.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/SteerLibrary.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/SteerLibrary.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -100,23 +100,23 @@
         // Wander behavior
         float WanderSide;
         float WanderUp;
-        Vec3 steerForWander (float dt);
+        Vector3 steerForWander (float dt);
 
         // Seek behavior
-        Vec3 steerForSeek (const Vec3&amp; target);
+        Vector3 steerForSeek (const Vector3&amp; target);
 
         // Flee behavior
-        Vec3 steerForFlee (const Vec3&amp; target);
+        Vector3 steerForFlee (const Vector3&amp; target);
 
         // xxx proposed, experimental new seek/flee [cwr 9-16-02]
-        Vec3 xxxsteerForFlee (const Vec3&amp; target);
-        Vec3 xxxsteerForSeek (const Vec3&amp; target);
+        Vector3 xxxsteerForFlee (const Vector3&amp; target);
+        Vector3 xxxsteerForSeek (const Vector3&amp; target);
 
         // Path Following behaviors
-        Vec3 steerToFollowPath (const int direction,
+        Vector3 steerToFollowPath (const int direction,
                                 const float predictionTime,
                                 Pathway&amp; path);
-        Vec3 steerToStayOnPath (const float predictionTime, Pathway&amp; path);
+        Vector3 steerToStayOnPath (const float predictionTime, Pathway&amp; path);
 
         // ------------------------------------------------------------------------
         // Obstacle Avoidance behavior
@@ -126,17 +126,17 @@
         // of the obstacle.  Avoidance is required when (1) the obstacle
         // intersects the vehicle's current path, (2) it is in front of the
         // vehicle, and (3) is within minTimeToCollision seconds of travel at the
-        // vehicle's current velocity.  Returns a zero vector value (Vec3::zero)
+        // vehicle's current velocity.  Returns a zero vector value (Vector3::ZERO)
         // when no avoidance is required.
 
 
-        Vec3 steerToAvoidObstacle (const float minTimeToCollision,
+        Vector3 steerToAvoidObstacle (const float minTimeToCollision,
                                    const Obstacle&amp; obstacle);
 
 
         // avoids all obstacles in an ObstacleGroup
 
-        Vec3 steerToAvoidObstacles (const float minTimeToCollision,
+        Vector3 steerToAvoidObstacles (const float minTimeToCollision,
                                     const ObstacleGroup&amp; obstacles);
 
 
@@ -148,7 +148,7 @@
         // force vector, which is zero length if there is no impending collision.
 
 
-        Vec3 steerToAvoidNeighbors (const float minTimeToCollision,
+        Vector3 steerToAvoidNeighbors (const float minTimeToCollision,
                                     const AVGroup&amp; others);
 
 
@@ -164,8 +164,8 @@
 
 
         /// XXX globals only for the sake of graphical annotation
-        Vec3 hisPositionAtNearestApproach;
-        Vec3 ourPositionAtNearestApproach;
+        Vector3 hisPositionAtNearestApproach;
+        Vector3 ourPositionAtNearestApproach;
 
 
         // ------------------------------------------------------------------------
@@ -176,7 +176,7 @@
         // XXX  to steerForSeparation.
 
 
-        Vec3 steerToAvoidCloseNeighbors (const float minSeparationDistance,
+        Vector3 steerToAvoidCloseNeighbors (const float minSeparationDistance,
                                          const AVGroup&amp; others);
 
 
@@ -194,7 +194,7 @@
         // Separation behavior -- determines the direction away from nearby boids
 
 
-        Vec3 steerForSeparation (const float maxDistance,
+        Vector3 steerForSeparation (const float maxDistance,
                                  const float cosMaxAngle,
                                  const AVGroup&amp; flock);
 
@@ -202,7 +202,7 @@
         // ------------------------------------------------------------------------
         // Alignment behavior
 
-        Vec3 steerForAlignment (const float maxDistance,
+        Vector3 steerForAlignment (const float maxDistance,
                                 const float cosMaxAngle,
                                 const AVGroup&amp; flock);
 
@@ -211,7 +211,7 @@
         // Cohesion behavior
 
 
-        Vec3 steerForCohesion (const float maxDistance,
+        Vector3 steerForCohesion (const float maxDistance,
                                const float cosMaxAngle,
                                const AVGroup&amp; flock);
 
@@ -220,9 +220,9 @@
         // pursuit of another vehicle (&amp; version with ceiling on prediction time)
 
 
-        Vec3 steerForPursuit (const AbstractVehicle&amp; quarry);
+        Vector3 steerForPursuit (const AbstractVehicle&amp; quarry);
 
-        Vec3 steerForPursuit (const AbstractVehicle&amp; quarry,
+        Vector3 steerForPursuit (const AbstractVehicle&amp; quarry,
                               const float maxPredictionTime);
 
         // for annotation
@@ -233,7 +233,7 @@
         // evasion of another vehicle
 
 
-        Vec3 steerForEvasion (const AbstractVehicle&amp; menace,
+        Vector3 steerForEvasion (const AbstractVehicle&amp; menace,
                               const float maxPredictionTime);
 
 
@@ -242,7 +242,7 @@
         // force along the forward/backward axis
 
 
-        Vec3 steerForTargetSpeed (const float targetSpeed);
+        Vector3 steerForTargetSpeed (const float targetSpeed);
 
 
         // ----------------------------------------------------------- utilities
@@ -251,25 +251,25 @@
         // XXX (&quot;utility vehicle&quot;?)
 
         // xxx cwr experimental 9-9-02 -- names OK?
-        bool isAhead (const Vec3&amp; target) const {return isAhead (target, 0.707f);};
-        bool isAside (const Vec3&amp; target) const {return isAside (target, 0.707f);};
-        bool isBehind (const Vec3&amp; target) const {return isBehind (target, -0.707f);};
+        bool isAhead (const Vector3&amp; target) const {return isAhead (target, 0.707f);};
+        bool isAside (const Vector3&amp; target) const {return isAside (target, 0.707f);};
+        bool isBehind (const Vector3&amp; target) const {return isBehind (target, -0.707f);};
 
-        bool isAhead (const Vec3&amp; target, float cosThreshold) const
+        bool isAhead (const Vector3&amp; target, float cosThreshold) const
         {
-            const Vec3 targetDirection = (target - position ()).normalize ();
-            return forward().dot(targetDirection) &gt; cosThreshold;
+            const Vector3 targetDirection = (target - position ()).normalisedCopy();
+            return forward().dotProduct(targetDirection) &gt; cosThreshold;
         };
-        bool isAside (const Vec3&amp; target, float cosThreshold) const
+        bool isAside (const Vector3&amp; target, float cosThreshold) const
         {
-            const Vec3 targetDirection = (target - position ()).normalize ();
-            const float dp = forward().dot(targetDirection);
+            const Vector3 targetDirection = (target - position ()).normalisedCopy();
+            const float dp = forward().dotProduct(targetDirection);
             return (dp &lt; cosThreshold) &amp;&amp; (dp &gt; -cosThreshold);
         };
-        bool isBehind (const Vec3&amp; target, float cosThreshold) const
+        bool isBehind (const Vector3&amp; target, float cosThreshold) const
         {
-            const Vec3 targetDirection = (target - position()).normalize ();
-            return forward().dot(targetDirection) &lt; cosThreshold;
+            const Vector3 targetDirection = (target - position()).normalisedCopy();
+            return forward().dotProduct(targetDirection) &lt; cosThreshold;
         };
 
 
@@ -285,9 +285,9 @@
 
         // called when steerToFollowPath decides steering is required
         // (default action is to do nothing, layered classes can overload it)
-        virtual void annotatePathFollowing (const Vec3&amp; /*future*/,
-                                            const Vec3&amp; /*onPath*/,
-                                            const Vec3&amp; /*target*/,
+        virtual void annotatePathFollowing (const Vector3&amp; /*future*/,
+                                            const Vector3&amp; /*onPath*/,
+                                            const Vector3&amp; /*target*/,
                                             const float /*outside*/)
         {
         }
@@ -303,8 +303,8 @@
         // (default action is to do nothing, layered classes can overload it)
         virtual void annotateAvoidNeighbor (const AbstractVehicle&amp; /*threat*/,
                                             const float /*steer*/,
-                                            const Vec3&amp; /*ourFuture*/,
-                                            const Vec3&amp; /*threatFuture*/)
+                                            const Vector3&amp; /*ourFuture*/,
+                                            const Vector3&amp; /*threatFuture*/)
         {
         }
     };
@@ -316,7 +316,7 @@
 
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerForWander (float dt)
 {
@@ -335,11 +335,11 @@
 
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerForSeek (const Vec3&amp; target)
+steerForSeek (const Vector3&amp; target)
 {
-    const Vec3 desiredVelocity = target - position();
+    const Vector3 desiredVelocity = target - position();
     return desiredVelocity - velocity();
 }
 
@@ -349,11 +349,11 @@
 
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerForFlee (const Vec3&amp; target)
+steerForFlee (const Vector3&amp; target)
 {
-    const Vec3 desiredVelocity = position() - target;
+    const Vector3 desiredVelocity = position() - target;
     return desiredVelocity - velocity();
 }
 
@@ -363,25 +363,25 @@
 
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-xxxsteerForFlee (const Vec3&amp; target)
+xxxsteerForFlee (const Vector3&amp; target)
 {
-//  const Vec3 offset = position - target;
-    const Vec3 offset = position() - target;
-    const Vec3 desiredVelocity = offset.truncateLength (maxSpeed ()); //xxxnew
+//  const Vector3 offset = position - target;
+    const Vector3 offset = position() - target;
+    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, maxSpeed()); //xxxnew
     return desiredVelocity - velocity();
 }
 
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-xxxsteerForSeek (const Vec3&amp; target)
+xxxsteerForSeek (const Vector3&amp; target)
 {
-//  const Vec3 offset = target - position;
-    const Vec3 offset = target - position();
-    const Vec3 desiredVelocity = offset.truncateLength (maxSpeed ()); //xxxnew
+//  const Vector3 offset = target - position;
+    const Vector3 offset = target - position();
+    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, maxSpeed()); //xxxnew
     return desiredVelocity - velocity();
 }
 
@@ -391,17 +391,17 @@
 
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerToStayOnPath (const float predictionTime, Pathway&amp; path)
 {
     // predict our future position
-    const Vec3 futurePosition = predictFuturePosition (predictionTime);
+    const Vector3 futurePosition = predictFuturePosition (predictionTime);
 
     // find the point on the path nearest the predicted future position
-    Vec3 tangent;
+    Vector3 tangent;
     float outside;
-    const Vec3 onPath = path.mapPointToPath (futurePosition,
+    const Vector3 onPath = path.mapPointToPath (futurePosition,
                                              tangent,     // output argument
                                              outside);    // output argument
 
@@ -409,7 +409,7 @@
     {
         // our predicted future position was in the path,
         // return zero steering.
-        return Vec3::zero;
+        return Vector3::ZERO;
     }
     else
     {
@@ -423,7 +423,7 @@
 
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerToFollowPath (const int direction,
                    const float predictionTime,
@@ -433,7 +433,7 @@
     const float pathDistanceOffset = direction * predictionTime * speed();
 
     // predict our future position
-    const Vec3 futurePosition = predictFuturePosition (predictionTime);
+    const Vector3 futurePosition = predictFuturePosition (predictionTime);
 
     // measure distance along path of our current and predicted positions
     const float nowPathDistance =
@@ -450,9 +450,9 @@
     // XXX need to improve calling sequence, maybe change to return a
     // XXX special path-defined object which includes two Vec3s and a 
     // XXX bool (onPath,tangent (ignored), withinPath)
-    Vec3 tangent;
+    Vector3 tangent;
     float outside;
-    const Vec3 onPath = path.mapPointToPath (futurePosition,
+    const Vector3 onPath = path.mapPointToPath (futurePosition,
                                              // output arguments:
                                              tangent,
                                              outside);
@@ -462,7 +462,7 @@
     if ((outside &lt; 0) &amp;&amp; rightway)
     {
         // all is well, return zero steering
-        return Vec3::zero;
+        return Vector3::ZERO;
     }
     else
     {
@@ -470,7 +470,7 @@
         // by adding pathDistanceOffset to our current path position
 
         float const targetPathDistance = nowPathDistance + pathDistanceOffset;
-        Vec3 const target = path.mapPathDistanceToPoint (targetPathDistance);
+        Vector3 const target = path.mapPathDistanceToPoint (targetPathDistance);
 
         annotatePathFollowing (futurePosition, onPath, target, outside);
 
@@ -488,7 +488,7 @@
 // obstacle.  Avoidance is required when (1) the obstacle intersects the
 // vehicle's current path, (2) it is in front of the vehicle, and (3) is
 // within minTimeToCollision seconds of travel at the vehicle's current
-// velocity.  Returns a zero vector value (Vec3::zero) when no avoidance is
+// velocity.  Returns a zero vector value (Vector3::ZERO) when no avoidance is
 // required.
 //
 // XXX The current (4-23-03) scheme is to dump all the work on the various
@@ -502,15 +502,15 @@
 // XXX to avoid a non-grouped obstacle)
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerToAvoidObstacle (const float minTimeToCollision,
                       const Obstacle&amp; obstacle)
 {
-    const Vec3 avoidance = obstacle.steerToAvoid (*this, minTimeToCollision);
+    const Vector3 avoidance = obstacle.steerToAvoid (*this, minTimeToCollision);
 
     // XXX more annotation modularity problems (assumes spherical obstacle)
-    if (avoidance != Vec3::zero)
+    if (avoidance != Vector3::ZERO)
         annotateAvoidObstacle (minTimeToCollision * speed());
 
     return avoidance;
@@ -520,17 +520,17 @@
 // this version avoids all of the obstacles in an ObstacleGroup
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerToAvoidObstacles (const float minTimeToCollision,
                        const ObstacleGroup&amp; obstacles)
 {
-    const Vec3 avoidance = Obstacle::steerToAvoidObstacles (*this,
+    const Vector3 avoidance = Obstacle::steerToAvoidObstacles (*this,
                                                             minTimeToCollision,
                                                             obstacles);
 
     // XXX more annotation modularity problems (assumes spherical obstacle)
-    if (avoidance != Vec3::zero)
+    if (avoidance != Vector3::ZERO)
         annotateAvoidObstacle (minTimeToCollision * speed());
 
     return avoidance;
@@ -546,14 +546,14 @@
 
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerToAvoidNeighbors (const float minTimeToCollision,
                        const AVGroup&amp; others)
 {
     // first priority is to prevent immediate interpenetration
-    const Vec3 separation = steerToAvoidCloseNeighbors (0, others);
-    if (separation != Vec3::zero) return separation;
+    const Vector3 separation = steerToAvoidCloseNeighbors (0, others);
+    if (separation != Vector3::ZERO) return separation;
 
     // otherwise, go on to consider potential future collisions
     float steer = 0;
@@ -565,8 +565,8 @@
     float minTime = minTimeToCollision;
 
     // xxx solely for annotation
-    Vec3 xxxThreatPositionAtNearestApproach;
-    Vec3 xxxOurPositionAtNearestApproach;
+    Vector3 xxxThreatPositionAtNearestApproach;
+    Vector3 xxxOurPositionAtNearestApproach;
 
     // for each of the other vehicles, determine which (if any)
     // pose the most immediate threat of collision.
@@ -605,15 +605,15 @@
     if (threat != NULL)
     {
         // parallel: +1, perpendicular: 0, anti-parallel: -1
-        float parallelness = forward().dot(threat-&gt;forward());
+        float parallelness = forward().dotProduct(threat-&gt;forward());
         float angle = 0.707f;
 
         if (parallelness &lt; -angle)
         {
             // anti-parallel &quot;head on&quot; paths:
             // steer away from future threat position
-            Vec3 offset = xxxThreatPositionAtNearestApproach - position();
-            float sideDot = offset.dot(side());
+            Vector3 offset = xxxThreatPositionAtNearestApproach - position();
+            float sideDot = offset.dotProduct(side());
             steer = (sideDot &gt; 0) ? -1.0f : 1.0f;
         }
         else
@@ -621,8 +621,8 @@
             if (parallelness &gt; angle)
             {
                 // parallel paths: steer away from threat
-                Vec3 offset = threat-&gt;position() - position();
-                float sideDot = offset.dot(side());
+                Vector3 offset = threat-&gt;position() - position();
+                float sideDot = offset.dotProduct(side());
                 steer = (sideDot &gt; 0) ? -1.0f : 1.0f;
             }
             else
@@ -631,7 +631,7 @@
                 // (only the slower of the two does this)
                 if (threat-&gt;speed() &lt;= speed())
                 {
-                    float sideDot = side().dot(threat-&gt;velocity());
+                    float sideDot = side().dotProduct(threat-&gt;velocity());
                     steer = (sideDot &gt; 0) ? -1.0f : 1.0f;
                 }
             }
@@ -660,9 +660,9 @@
 {
     // imagine we are at the origin with no velocity,
     // compute the relative velocity of the other vehicle
-    const Vec3 myVelocity = velocity();
-    const Vec3 otherVelocity = otherVehicle.velocity();
-    const Vec3 relVelocity = otherVelocity - myVelocity;
+    const Vector3 myVelocity = velocity();
+    const Vector3 otherVelocity = otherVehicle.velocity();
+    const Vector3 relVelocity = otherVelocity - myVelocity;
     const float relSpeed = relVelocity.length();
 
     // for parallel paths, the vehicles will always be at the same distance,
@@ -675,12 +675,12 @@
     // the nearest approach.
 
     // Take the unit tangent along the other vehicle's path
-    const Vec3 relTangent = relVelocity / relSpeed;
+    const Vector3 relTangent = relVelocity / relSpeed;
 
     // find distance from its path to origin (compute offset from
     // other to us, find length of projection onto path)
-    const Vec3 relPosition = position() - otherVehicle.position();
-    const float projection = relTangent.dot(relPosition);
+    const Vector3 relPosition = position() - otherVehicle.position();
+    const float projection = relTangent.dotProduct(relPosition);
 
     return projection / relSpeed;
 }
@@ -697,17 +697,17 @@
 computeNearestApproachPositions (AbstractVehicle&amp; otherVehicle,
                                  float time)
 {
-    const Vec3    myTravel =       forward () *       speed () * time;
-    const Vec3 otherTravel = otherVehicle.forward () * otherVehicle.speed () * time;
+    const Vector3    myTravel =       forward () *       speed () * time;
+    const Vector3 otherTravel = otherVehicle.forward () * otherVehicle.speed () * time;
 
-    const Vec3    myFinal =       position () +    myTravel;
-    const Vec3 otherFinal = otherVehicle.position () + otherTravel;
+    const Vector3    myFinal =       position () +    myTravel;
+    const Vector3 otherFinal = otherVehicle.position () + otherTravel;
 
     // xxx for annotation
     ourPositionAtNearestApproach = myFinal;
     hisPositionAtNearestApproach = otherFinal;
 
-    return Vec3::distance (myFinal, otherFinal);
+    return myFinal.distance(otherFinal);
 }
 
 
@@ -721,7 +721,7 @@
 
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerToAvoidCloseNeighbors (const float minSeparationDistance,
                             const AVGroup&amp; others)
@@ -734,19 +734,19 @@
         {
             const float sumOfRadii = radius() + other.radius();
             const float minCenterToCenter = minSeparationDistance + sumOfRadii;
-            const Vec3 offset = other.position() - position();
+            const Vector3 offset = other.position() - position();
             const float currentDistance = offset.length();
 
             if (currentDistance &lt; minCenterToCenter)
             {
                 annotateAvoidCloseNeighbor (other, minSeparationDistance);
-                return (-offset).perpendicularComponent (forward());
+                return Vec3Utils::perpendicularComponent(-offset, forward());
             }
         }
     }
 
     // otherwise return zero
-    return Vec3::zero;
+    return Vector3::ZERO;
 }
 
 
@@ -768,8 +768,8 @@
     }
     else
     {
-        const Vec3 offset = otherVehicle.position() - position();
-        const float distanceSquared = offset.lengthSquared ();
+        const Vector3 offset = otherVehicle.position() - position();
+        const float distanceSquared = offset.squaredLength();
 
         // definitely in neighborhood if inside minDistance sphere
         if (distanceSquared &lt; (minDistance * minDistance))
@@ -786,8 +786,8 @@
             else
             {
                 // otherwise, test angular offset from forward axis
-                const Vec3 unitOffset = offset / sqrt (distanceSquared);
-                const float forwardness = forward().dot (unitOffset);
+                const Vector3 unitOffset = offset / sqrt (distanceSquared);
+                const float forwardness = forward().dotProduct(unitOffset);
                 return forwardness &gt; cosMaxAngle;
             }
         }
@@ -800,14 +800,14 @@
 
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerForSeparation (const float maxDistance,
                     const float cosMaxAngle,
                     const AVGroup&amp; flock)
 {
     // steering accumulator and count of neighbors, both initially zero
-    Vec3 steering;
+    Vector3 steering;
     int neighbors = 0;
 
     // for each of the other vehicles...
@@ -819,8 +819,8 @@
             // add in steering contribution
             // (opposite of the offset direction, divided once by distance
             // to normalize, divided another time to get 1/d falloff)
-            const Vec3 offset = (**otherVehicle).position() - position();
-            const float distanceSquared = offset.dot(offset);
+            const Vector3 offset = (**otherVehicle).position() - position();
+            const float distanceSquared = offset.dotProduct(offset);
             steering += (offset / -distanceSquared);
 
             // count neighbors
@@ -835,10 +835,10 @@
     /*
     if (neighbors &gt; 0) {
         steering /= neighbors;
-        steering = steering.normalize();
+        steering = steering.normalisedCopy();
     }
     */
-    steering = steering.normalize();
+    steering = steering.normalisedCopy();
     
     return steering;
 }
@@ -849,14 +849,14 @@
 
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerForAlignment (const float maxDistance,
                    const float cosMaxAngle,
                    const AVGroup&amp; flock)
 {
     // steering accumulator and count of neighbors, both initially zero
-    Vec3 steering;
+    Vector3 steering;
     int neighbors = 0;
 
     // for each of the other vehicles...
@@ -874,7 +874,7 @@
 
     // divide by neighbors, subtract off current heading to get error-
     // correcting direction, then normalize to pure direction
-    if (neighbors &gt; 0) steering = ((steering / (float)neighbors) - forward()).normalize();
+    if (neighbors &gt; 0) steering = ((steering / (float)neighbors) - forward()).normalisedCopy();
 
     return steering;
 }
@@ -886,14 +886,14 @@
 
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerForCohesion (const float maxDistance,
                   const float cosMaxAngle,
                   const AVGroup&amp; flock)
 {
     // steering accumulator and count of neighbors, both initially zero
-    Vec3 steering;
+    Vector3 steering;
     int neighbors = 0;
 
     // for each of the other vehicles...
@@ -911,7 +911,7 @@
 
     // divide by neighbors, subtract off current position to get error-
     // correcting direction, then normalize to pure direction
-    if (neighbors &gt; 0) steering = ((steering / (float)neighbors) - position()).normalize();
+    if (neighbors &gt; 0) steering = ((steering / (float)neighbors) - position()).normalisedCopy();
 
     return steering;
 }
@@ -922,7 +922,7 @@
 
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerForPursuit (const AbstractVehicle&amp; quarry)
 {
@@ -931,23 +931,23 @@
 
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerForPursuit (const AbstractVehicle&amp; quarry,
                  const float maxPredictionTime)
 {
     // offset from this to quarry, that distance, unit vector toward quarry
-    const Vec3 offset = quarry.position() - position();
+    const Vector3 offset = quarry.position() - position();
     const float distance = offset.length ();
-    const Vec3 unitOffset = offset / distance;
+    const Vector3 unitOffset = offset / distance;
 
     // how parallel are the paths of &quot;this&quot; and the quarry
     // (1 means parallel, 0 is pependicular, -1 is anti-parallel)
-    const float parallelness = forward().dot (quarry.forward());
+    const float parallelness = forward().dotProduct(quarry.forward());
 
     // how &quot;forward&quot; is the direction to the quarry
     // (1 means dead ahead, 0 is directly to the side, -1 is straight back)
-    const float forwardness = forward().dot (unitOffset);
+    const float forwardness = forward().dotProduct(unitOffset);
 
     const float directTravelTime = distance / speed ();
     const int f = intervalComparison (forwardness,  -0.707f, 0.707f);
@@ -1021,7 +1021,7 @@
     const float etl = (et &gt; maxPredictionTime) ? maxPredictionTime : et;
 
     // estimated position of quarry at intercept
-    const Vec3 target = quarry.predictFuturePosition (etl);
+    const Vector3 target = quarry.predictFuturePosition (etl);
 
     // annotation
 /*    annotationLine (position(),
@@ -1036,13 +1036,13 @@
 
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerForEvasion (const AbstractVehicle&amp; menace,
                  const float maxPredictionTime)
 {
     // offset from this to menace, that distance, unit vector toward menace
-    const Vec3 offset = menace.position() - position();
+    const Vector3 offset = menace.position() - position();
     const float distance = offset.length ();
 
     const float roughTime = distance / menace.speed();
@@ -1050,7 +1050,7 @@
                                   maxPredictionTime :
                                   roughTime);
 
-    const Vec3 target = menace.predictFuturePosition (predictionTime);
+    const Vector3 target = menace.predictFuturePosition (predictionTime);
 
     return steerForFlee (target);
 }
@@ -1062,7 +1062,7 @@
 
 
 template&lt;class Super&gt;
-OpenSteer::Vec3
+Vector3
 OpenSteer::SteerLibraryMixin&lt;Super&gt;::
 steerForTargetSpeed (const float targetSpeed)
 {

Modified: dependencies/opensteer/include/OpenSteer/Vec3.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Vec3.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Vec3.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -27,15 +27,15 @@
 //
 // ----------------------------------------------------------------------------
 //
-// Vec3: OpenSteer's generic type for 3d vectors
+// Vector3: OpenSteer's generic type for 3d vectors
 //
-// This file defines the class Vec3, which is used throughout OpenSteer to
+// This file defines the class Vector3, which is used throughout OpenSteer to
 // manipulate 3d geometric data.  It includes standard vector operations (like
 // vector addition, subtraction, scale, dot, cross...) and more idiosyncratic
 // utility functions.
 //
 // When integrating OpenSteer into a preexisting 3d application, it may be
-// important to use the 3d vector type of that application.  In that case Vec3
+// important to use the 3d vector type of that application.  In that case Vector3
 // can be changed to inherit from the preexisting application' vector type and
 // to match the interface used by OpenSteer to the interface provided by the
 // preexisting 3d vector type.
@@ -47,117 +47,36 @@
 // ----------------------------------------------------------------------------
 
 
-#ifndef OPENSTEER_VEC3_H
-#define OPENSTEER_VEC3_H
+#ifndef OPENSTEER_Vector3_H
+#define OPENSTEER_Vector3_H
 
 
 #include &quot;OpenSteer/Utilities.h&quot;  // for interpolate, etc.
+#include &lt;OgreVector3.h&gt;
 
+using Ogre::Vector3;
 
 namespace OpenSteer {
 
     // ----------------------------------------------------------------------------
-
-
-    class Vec3
+    class Vec3Utils
     {
     public:
-
-        // ----------------------------------------- generic 3d vector operations
-
-        // three-dimensional Cartesian coordinates
-        float x, y, z;
-
-        // constructors
-        Vec3 (void): x( 0.0f ), y( 0.0f ), z( 0.0f ) {}
-        Vec3 (float X, float Y, float Z) : x( X ), y( Y ), z( Z ) {}
-
-        // vector addition
-        Vec3 operator+ (const Vec3&amp; v) const {return Vec3 (x+v.x, y+v.y, z+v.z);}
-
-        // vector subtraction
-        Vec3 operator- (const Vec3&amp; v) const {return Vec3 (x-v.x, y-v.y, z-v.z);}
-
-        // unary minus
-        Vec3 operator- (void) const {return Vec3 (-x, -y, -z);}
-
-        // vector times scalar product (scale length of vector times argument)
-        Vec3 operator* (const float s) const {return Vec3 (x * s, y * s, z * s);}
-
-        // vector divided by a scalar (divide length of vector by argument)
-        Vec3 operator/ (const float s) const {return Vec3 (x / s, y / s, z / s);}
-
-        // dot product
-        float dot (const Vec3&amp; v) const {return (x * v.x) + (y * v.y) + (z * v.z);}
-
-        // length
-        float length (void) const {return sqrtXXX (lengthSquared ());}
-
-        // length squared
-        float lengthSquared (void) const {return this-&gt;dot (*this);}
-
-        // normalize: returns normalized version (parallel to this, length = 1)
-        Vec3 normalize (void) const
-        {
-            // skip divide if length is zero
-            const float len = length ();
-            return (len&gt;0) ? (*this)/len : (*this);
-        }
-
-        // cross product (modify &quot;*this&quot; to be A x B)
-        // [XXX  side effecting -- deprecate this function?  XXX]
-        void cross(const Vec3&amp; a, const Vec3&amp; b)
-        {
-            *this = Vec3 ((a.y * b.z) - (a.z * b.y),
-                          (a.z * b.x) - (a.x * b.z),
-                          (a.x * b.y) - (a.y * b.x));
-        }
-
-        // assignment
-        Vec3 operator= (const Vec3&amp; v) {x=v.x; y=v.y; z=v.z; return *this;}
-
-        // set XYZ coordinates to given three floats
-        Vec3 set (const float _x, const float _y, const float _z)
-        {x = _x; y = _y; z = _z; return *this;}
-
-        // +=
-        Vec3 operator+= (const Vec3&amp; v) {return *this = (*this + v);}
-
-        // -=
-        Vec3 operator-= (const Vec3&amp; v) {return *this = (*this - v);}
-
-        // *=
-        Vec3 operator*= (const float&amp; s) {return *this = (*this * s);}
-
-        
-        Vec3 operator/=( float d ) { return *this = (*this / d);  }
-        
-        // equality/inequality
-        bool operator== (const Vec3&amp; v) const {return x==v.x &amp;&amp; y==v.y &amp;&amp; z==v.z;}
-        bool operator!= (const Vec3&amp; v) const {return !(*this == v);}
-
-        // @todo Remove - use @c distance from the Vec3Utilitites header instead.
-        // XXX experimental (4-1-03 cwr): is this the right approach?  defining
-        // XXX &quot;Vec3 distance (vec3, Vec3)&quot; collided with STL's distance template.
-        static float distance (const Vec3&amp; a, const Vec3&amp; b){ return(a-b).length();}
-
-        // --------------------------- utility member functions used in OpenSteer
-
         // return component of vector parallel to a unit basis vector
         // (IMPORTANT NOTE: assumes &quot;basis&quot; has unit magnitude (length==1))
 
-        inline Vec3 parallelComponent (const Vec3&amp; unitBasis) const
+        static Vector3 parallelComponent (const Vector3&amp; vector, const Vector3&amp; unitBasis)
         {
-            const float projection = this-&gt;dot (unitBasis);
+            const float projection = vector.dotProduct(unitBasis);
             return unitBasis * projection;
         }
 
         // return component of vector perpendicular to a unit basis vector
         // (IMPORTANT NOTE: assumes &quot;basis&quot; has unit magnitude (length==1))
 
-        inline Vec3 perpendicularComponent (const Vec3&amp; unitBasis) const
+        static Vector3 perpendicularComponent (const Vector3&amp; vector, const Vector3&amp; unitBasis)
         {
-            return (*this) - parallelComponent (unitBasis);
+            return vector - parallelComponent(vector, unitBasis);
         }
 
         // clamps the length of a given vector to maxLength.  If the vector is
@@ -165,33 +84,35 @@
         // the value returned has length of maxLength and is paralle to the
         // original input.
 
-        Vec3 truncateLength (const float maxLength) const
+        static Vector3 truncateLength (const Vector3&amp; vector, const float maxLength)
         {
-            const float maxLengthSquared = maxLength * maxLength;
-            const float vecLengthSquared = this-&gt;lengthSquared ();
-            if (vecLengthSquared &lt;= maxLengthSquared)
-                return *this;
+            const float vecLength = vector.length();
+            if (vecLength &lt;= maxLength)
+                return vector;
             else
-                return (*this) * (maxLength / sqrtXXX (vecLengthSquared));
+                return vector * (maxLength / vecLength);
         }
 
         // forces a 3d position onto the XZ (aka y=0) plane
 
-        Vec3 setYtoZero (void) const {return Vec3 (this-&gt;x, 0, this-&gt;z);}
+        static Vector3 setYtoZero (const Vector3&amp; vector)
+        {
+            return Vector3 (vector.x, 0, vector.z);
+        }
 
         // rotate this vector about the global Y (up) axis by the given angle
 
-        Vec3 rotateAboutGlobalY (float angle) const 
+        static Vector3 rotateAboutGlobalY (const Vector3&amp; vector, float angle)
         {
             const float s = sinXXX (angle);
             const float c = cosXXX (angle);
-            return Vec3 ((this-&gt;x * c) + (this-&gt;z * s),
-                         (this-&gt;y),
-                         (this-&gt;z * c) - (this-&gt;x * s));
+            return Vector3 ((vector.x * c) + (vector.z * s),
+                         (vector.y),
+                         (vector.z * c) - (vector.x * s));
         }
 
         // version for caching sin/cos computation
-        Vec3 rotateAboutGlobalY (float angle, float&amp; sin, float&amp; cos) const 
+        static Vector3 rotateAboutGlobalY (const Vector3&amp; vector, float angle, float&amp; sin, float&amp; cos)
         {
             // is both are zero, they have not be initialized yet
             if (sin==0 &amp;&amp; cos==0)
@@ -199,67 +120,48 @@
                 sin = sinXXX (angle);
                 cos = cosXXX (angle);
             }
-            return Vec3 ((this-&gt;x * cos) + (this-&gt;z * sin),
-                         (this-&gt;y),
-                         (this-&gt;z * cos) - (this-&gt;x * sin));
+            return Vector3 ((vector.x * cos) + (vector.z * sin),
+                         (vector.y),
+                         (vector.z * cos) - (vector.x * sin));
         }
 
         // if this position is outside sphere, push it back in by one diameter
 
-        Vec3 sphericalWrapAround (const Vec3&amp; center, float radius)
+        static Vector3 sphericalWrapAround (const Vector3&amp; vector, const Vector3&amp; center, float radius)
         {
-            const Vec3 offset = *this - center;
+            const Vector3 offset = vector - center;
             const float r = offset.length();
             if (r &gt; radius)
-                return *this + ((offset/r) * radius * -2);
+                return vector + ((offset/r) * radius * -2);
             else
-                return *this;
+                return vector;
         }
-
-        // names for frequently used vector constants
-        static const Vec3 zero;
-        static const Vec3 side;
-        static const Vec3 up;
-        static const Vec3 forward;
     };
 
 
     // ----------------------------------------------------------------------------
-    // scalar times vector product (&quot;float * Vec3&quot;)
+    // scalar times vector product (&quot;float * Vector3&quot;)
 
 
-    inline Vec3 operator* (float s, const Vec3&amp; v) {return v*s;}
+    inline Vector3 operator* (float s, const Vector3&amp; v) {return v*s;}
 
 
 	// return cross product a x b
-	inline Vec3 crossProduct(const Vec3&amp; a, const Vec3&amp; b)
+	inline Vector3 crossProduct(const Vector3&amp; a, const Vector3&amp; b)
 	{
-		Vec3 result((a.y * b.z) - (a.z * b.y),
+		Vector3 result((a.y * b.z) - (a.z * b.y),
 					(a.z * b.x) - (a.x * b.z),
 					(a.x * b.y) - (a.y * b.x));
 		return result;
 	}
 
-
     // ----------------------------------------------------------------------------
-    // default character stream output method
-
-#ifndef NOT_OPENSTEERDEMO  // only when building OpenSteerDemo
-
-    inline std::ostream&amp; operator&lt;&lt; (std::ostream&amp; o, const Vec3&amp; v)
-    {
-        return o &lt;&lt; &quot;(&quot; &lt;&lt; v.x &lt;&lt; &quot;,&quot; &lt;&lt; v.y &lt;&lt; &quot;,&quot; &lt;&lt; v.z &lt;&lt; &quot;)&quot;;
-    }
-
-#endif // NOT_OPENSTEERDEMO
-
-    // ----------------------------------------------------------------------------
     // Returns a position randomly distributed inside a sphere of unit radius
     // centered at the origin.  Orientation will be random and length will range
     // between 0 and 1
 
 
-    Vec3 RandomVectorInUnitRadiusSphere (void);
+    Vector3 RandomVectorInUnitRadiusSphere (void);
 
 
     // ----------------------------------------------------------------------------
@@ -268,7 +170,7 @@
     // random and length will range between 0 and 1
 
 
-    Vec3 randomVectorOnUnitRadiusXZDisk (void);
+    Vector3 randomVectorOnUnitRadiusXZDisk (void);
 
 
     // ----------------------------------------------------------------------------
@@ -277,9 +179,9 @@
     // and length will be 1
 
 
-    inline Vec3 RandomUnitVector (void)
+    inline Vector3 RandomUnitVector (void)
     {
-        return RandomVectorInUnitRadiusSphere().normalize();
+        return RandomVectorInUnitRadiusSphere().normalisedCopy();
     }
 
 
@@ -289,9 +191,9 @@
     // random and length will be 1
 
 
-    inline Vec3 RandomUnitVectorOnXZPlane (void)
+    inline Vector3 RandomUnitVectorOnXZPlane (void)
     {
-        return RandomVectorInUnitRadiusSphere().setYtoZero().normalize();
+        return Vec3Utils::setYtoZero(RandomVectorInUnitRadiusSphere()).normalisedCopy();
     }
 
 
@@ -299,10 +201,10 @@
     // used by limitMaxDeviationAngle / limitMinDeviationAngle below
 
 
-    Vec3 vecLimitDeviationAngleUtility (const bool insideOrOutside,
-                                        const Vec3&amp; source,
+    Vector3 vecLimitDeviationAngleUtility (const bool insideOrOutside,
+                                        const Vector3&amp; source,
                                         const float cosineOfConeAngle,
-                                        const Vec3&amp; basis);
+                                        const Vector3&amp; basis);
 
 
     // ----------------------------------------------------------------------------
@@ -312,9 +214,9 @@
     // defined by the basis and an angle.
 
 
-    inline Vec3 limitMaxDeviationAngle (const Vec3&amp; source,
+    inline Vector3 limitMaxDeviationAngle (const Vector3&amp; source,
                                         const float cosineOfConeAngle,
-                                        const Vec3&amp; basis)
+                                        const Vector3&amp; basis)
     {
         return vecLimitDeviationAngleUtility (true, // force source INSIDE cone
                                               source,
@@ -330,9 +232,9 @@
     // defined by the basis and an angle.
 
 
-    inline Vec3 limitMinDeviationAngle (const Vec3&amp; source,
+    inline Vector3 limitMinDeviationAngle (const Vector3&amp; source,
                                         const float cosineOfConeAngle,
-                                        const Vec3&amp; basis)
+                                        const Vector3&amp; basis)
     {    
         return vecLimitDeviationAngleUtility (false, // force source OUTSIDE cone
                                               source,
@@ -347,12 +249,12 @@
     // the line (&quot;lineUnitTangent&quot;)
 
 
-    inline float distanceFromLine (const Vec3&amp; point,
-                                   const Vec3&amp; lineOrigin,
-                                   const Vec3&amp; lineUnitTangent)
+    inline float distanceFromLine (const Vector3&amp; point,
+                                   const Vector3&amp; lineOrigin,
+                                   const Vector3&amp; lineUnitTangent)
     {
-        const Vec3 offset = point - lineOrigin;
-        const Vec3 perp = offset.perpendicularComponent (lineUnitTangent);
+        const Vector3 offset = point - lineOrigin;
+        const Vector3 perp = Vec3Utils::perpendicularComponent(offset, lineUnitTangent);
         return perp.length();
     }
 
@@ -362,7 +264,7 @@
     // arbitrarily selects one of the infinitude of perpendicular vectors)
 
 
-    Vec3 findPerpendicularIn3d (const Vec3&amp; direction);
+    Vector3 findPerpendicularIn3d (const Vector3&amp; direction);
 
 
     // ----------------------------------------------------------------------------
@@ -379,4 +281,4 @@
     
 
 // ----------------------------------------------------------------------------
-#endif // OPENSTEER_VEC3_H
+#endif // OPENSTEER_Vector3_H

Modified: dependencies/opensteer/include/OpenSteer/Vec3Utilities.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Vec3Utilities.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/include/OpenSteer/Vec3Utilities.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -27,7 +27,7 @@
 //
 // ----------------------------------------------------------------------------
 //
-// Utilities to work with Vec3.
+// Utilities to work with Vector3.
 //
 // 05-12-05 bk:  Created based on code of PolylinePathway.
 //
@@ -37,7 +37,7 @@
 #define OPENSTEER_VEC3UTILITIES_H
 
 
-// Include OpenSteer::Vec3
+// Include Vector3
 #include &quot;OpenSteer/Vec3.h&quot;
 
 // Include OpenSteer::size_t
@@ -54,22 +54,22 @@
      * Returns the nearest point on the segment @a segmentPoint0 to 
      * @a segmentPoint1 from @a point.
      */
-    OpenSteer::Vec3  nearestPointOnSegment( const Vec3&amp; point,
-                                            const Vec3&amp; segmentPoint0,
-                                            const Vec3&amp; segmentPoint1 );
+    Vector3  nearestPointOnSegment( const Vector3&amp; point,
+                                            const Vector3&amp; segmentPoint0,
+                                            const Vector3&amp; segmentPoint1 );
     
     /**
      * Computes minimum distance from @a point to the line segment defined by
      * @a segmentPoint0 and @a segmentPoint1.
      */
-    float pointToSegmentDistance( const Vec3&amp; point,
-                                  const Vec3&amp; segmentPoint0,
-                                  const Vec3&amp; segmentPoint1);
+    float pointToSegmentDistance( const Vector3&amp; point,
+                                  const Vector3&amp; segmentPoint0,
+                                  const Vector3&amp; segmentPoint1);
         
     /**
      * Retuns distance between @a a and @a b.
      */
-    inline float distance (const Vec3&amp; a, const Vec3&amp; b) {
+    inline float distance (const Vector3&amp; a, const Vector3&amp; b) {
         return (a-b).length();
     } 
     
@@ -85,8 +85,8 @@
      */
     inline
     bool
-    equalsRelative( Vec3 const&amp; lhs, 
-                     Vec3 const&amp; rhs, 
+    equalsRelative( Vector3 const&amp; lhs, 
+                     Vector3 const&amp; rhs, 
                      float const&amp; tolerance = std::numeric_limits&lt; float &gt;::epsilon()  ) {
         return equalsRelative( lhs.x, rhs.x, tolerance ) &amp;&amp; equalsRelative( lhs.y, rhs.y ) &amp;&amp; equalsRelative( lhs.z, rhs.z );
     }

Modified: dependencies/opensteer/plugins/Boids.cpp
===================================================================
--- dependencies/opensteer/plugins/Boids.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/plugins/Boids.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -151,12 +151,12 @@
 
 
         // basic flocking
-        Vec3 steerToFlock (void)
+        Vector3 steerToFlock (void)
         {
             // avoid obstacles if needed
             // XXX this should probably be moved elsewhere
-            const Vec3 avoidance = steerToAvoidObstacles (1.0f, obstacles);
-            if (avoidance != Vec3::zero) return avoidance;
+            const Vector3 avoidance = steerToAvoidObstacles (1.0f, obstacles);
+            if (avoidance != Vector3::ZERO) return avoidance;
 
             const float separationRadius =  5.0f;
             const float separationAngle  = -0.707f;
@@ -187,20 +187,20 @@
     #endif // NO_LQ_BIN_STATS
 
             // determine each of the three component behaviors of flocking
-            const Vec3 separation = steerForSeparation (separationRadius,
+            const Vector3 separation = steerForSeparation (separationRadius,
                                                         separationAngle,
                                                         neighbors);
-            const Vec3 alignment  = steerForAlignment  (alignmentRadius,
+            const Vector3 alignment  = steerForAlignment  (alignmentRadius,
                                                         alignmentAngle,
                                                         neighbors);
-            const Vec3 cohesion   = steerForCohesion   (cohesionRadius,
+            const Vector3 cohesion   = steerForCohesion   (cohesionRadius,
                                                         cohesionAngle,
                                                         neighbors);
 
             // apply weights to components (save in variables for annotation)
-            const Vec3 separationW = separation * separationWeight;
-            const Vec3 alignmentW = alignment * alignmentWeight;
-            const Vec3 cohesionW = cohesion * cohesionWeight;
+            const Vector3 separationW = separation * separationWeight;
+            const Vector3 alignmentW = alignment * alignmentWeight;
+            const Vector3 cohesionW = cohesion * cohesionWeight;
 
             // annotation
             // const float s = 0.1;
@@ -219,7 +219,7 @@
             if (position().length() &gt; worldRadius)
             {
                 // wrap around (teleport)
-                setPosition (position().sphericalWrapAround (Vec3::zero,
+                setPosition (position().sphericalWrapAround (Vector3::ZERO,
                                                              worldRadius));
                 if (this == OpenSteerDemo::selectedVehicle)
                 {
@@ -233,7 +233,7 @@
 
     // ---------------------------------------------- xxxcwr111704_terrain_following
         // control orientation for this boid
-        void regenerateLocalSpace (const Vec3&amp; newVelocity,
+        void regenerateLocalSpace (const Vector3&amp; newVelocity,
                                    const float elapsedTime)
         {
             // 3d flight with banking
@@ -247,20 +247,20 @@
         // XXX experiment:
         // XXX   herd with terrain following
         // XXX   special case terrain: a sphere at the origin, radius 40
-        void regenerateLocalSpaceForTerrainFollowing  (const Vec3&amp; newVelocity,
+        void regenerateLocalSpaceForTerrainFollowing  (const Vector3&amp; newVelocity,
                                                        const float /* elapsedTime */)
         {
 
             // XXX this is special case code, these should be derived from arguments //
-            const Vec3 surfaceNormal = position().normalize();                       //
-            const Vec3 surfacePoint = surfaceNormal * 40.0f;                         //
+            const Vector3 surfaceNormal = position().normalisedCopy();                       //
+            const Vector3 surfacePoint = surfaceNormal * 40.0f;                         //
             // XXX this is special case code, these should be derived from arguments //
 
-            const Vec3 newUp = surfaceNormal;
-            const Vec3 newPos = surfacePoint;
-            const Vec3 newVel = newVelocity.perpendicularComponent(newUp);
+            const Vector3 newUp = surfaceNormal;
+            const Vector3 newPos = surfacePoint;
+            const Vector3 newVel = newVelocity.perpendicularComponent(newUp);
             const float newSpeed = newVel.length();
-            const Vec3 newFor = newVel / newSpeed;
+            const Vector3 newFor = newVel / newSpeed;
 
             setSpeed (newSpeed);
             setPosition (newPos);
@@ -298,12 +298,12 @@
         // xxx CaptureTheFlag.cpp
         void annotateAvoidObstacle (const float minDistanceToCollision)
         {
-            const Vec3 boxSide = side() * radius();
-            const Vec3 boxFront = forward() * minDistanceToCollision;
-            const Vec3 FR = position() + boxFront - boxSide;
-            const Vec3 FL = position() + boxFront + boxSide;
-            const Vec3 BR = position()            - boxSide;
-            const Vec3 BL = position()            + boxSide;
+            const Vector3 boxSide = side() * radius();
+            const Vector3 boxFront = forward() * minDistanceToCollision;
+            const Vector3 FR = position() + boxFront - boxSide;
+            const Vector3 FL = position() + boxFront + boxSide;
+            const Vector3 BR = position()            - boxSide;
+            const Vector3 BL = position()            + boxSide;
             const Color white (1,1,1);
             annotationLine (FR, FL, white);
             annotationLine (FL, BL, white);
@@ -356,7 +356,7 @@
             OpenSteerDemo::camera.fixedDistVOffset = 0;
             OpenSteerDemo::camera.lookdownDistance = 20;
             OpenSteerDemo::camera.aimLeadTime = 0.5;
-            OpenSteerDemo::camera.povOffset.set (0, 0.5, -2);
+            OpenSteerDemo::camera.povOffset = Vector3(0, 0.5, -2);
 
             // set up obstacles
             initObstacles ();
@@ -429,7 +429,7 @@
             }
             status &lt;&lt; std::endl;
             const float h = drawGetWindowHeight ();
-            const Vec3 screenLocation (10, h-50, 0);
+            const Vector3 screenLocation (10, h-50, 0);
             draw2dTextAt2dLocation (status, screenLocation, gGray80, drawGetWindowWidth(), drawGetWindowHeight());
 
             drawObstacles ();
@@ -471,11 +471,11 @@
             {
             case 0:
                 {
-                    const Vec3 center;
+                    const Vector3 center;
                     const float div = 10.0f;
-                    const Vec3 divisions (div, div, div);
+                    const Vector3 divisions (div, div, div);
                     const float diameter = Boid::worldRadius * 1.1f * 2;
-                    const Vec3 dimensions (diameter, diameter, diameter);
+                    const Vector3 dimensions (diameter, diameter, diameter);
                     typedef LQProximityDatabase&lt;AbstractVehicle*&gt; LQPDAV;
                     pd = new LQPDAV (center, dimensions, divisions);
                     break;
@@ -600,15 +600,15 @@
         }
 
         class SO : public SphereObstacle
-        {void draw (const bool filled, const Color&amp; color, const Vec3&amp; vp) const
+        {void draw (const bool filled, const Color&amp; color, const Vector3&amp; vp) const
             {drawSphereObstacle (*this, 10.0f, filled, color, vp);}};
 
         class RO : public RectangleObstacle
-        {void draw (const bool, const Color&amp; color, const Vec3&amp;) const
+        {void draw (const bool, const Color&amp; color, const Vector3&amp;) const
             {tempDrawRectangle (*this, color);}};
 
         class BO : public BoxObstacle
-        {void draw (const bool, const Color&amp; color, const Vec3&amp;) const
+        {void draw (const bool, const Color&amp; color, const Vector3&amp;) const
             {tempDrawBox (*this, color);}};
 
         RO bigRectangle;
@@ -637,16 +637,16 @@
             const float p = Boid::worldRadius * 0.5f;
             const float m = -p;
             const float z = 0.0f;
-            outsideSphere1.center.set (p, z, z);
-            outsideSphere2.center.set (m, z, z);
-            outsideSphere3.center.set (z, p, z);
-            outsideSphere4.center.set (z, m, z);
-            outsideSphere5.center.set (z, z, p);
-            outsideSphere6.center.set (z, z, m);
+            outsideSphere1.center = Vector3(p, z, z);
+            outsideSphere2.center = Vector3(m, z, z);
+            outsideSphere3.center = Vector3(z, p, z);
+            outsideSphere4.center = Vector3(z, m, z);
+            outsideSphere5.center = Vector3(z, z, p);
+            outsideSphere6.center = Vector3(z, z, m);
 
-            const Vec3 tiltF = Vec3 (1.0f, 1.0f, 0.0f).normalize ();
-            const Vec3 tiltS (0.0f, 0.0f, 1.0f);
-            const Vec3 tiltU = Vec3 (-1.0f, 1.0f, 0.0f).normalize ();
+            const Vector3 tiltF = Vector3 (1.0f, 1.0f, 0.0f).normalisedCopy();
+            const Vector3 tiltS (0.0f, 0.0f, 1.0f);
+            const Vector3 tiltU = Vector3 (-1.0f, 1.0f, 0.0f).normalisedCopy();
 
             bigRectangle.width = 50.0f;
             bigRectangle.height = 80.0f;
@@ -737,10 +737,10 @@
             float w = rect.width / 2;
             float h = rect.height / 2;
 
-            Vec3 v1 = rect.globalizePosition (Vec3 ( w,  h, 0));
-            Vec3 v2 = rect.globalizePosition (Vec3 (-w,  h, 0));
-            Vec3 v3 = rect.globalizePosition (Vec3 (-w, -h, 0));
-            Vec3 v4 = rect.globalizePosition (Vec3 ( w, -h, 0));
+            Vector3 v1 = rect.globalizePosition (Vector3 ( w,  h, 0));
+            Vector3 v2 = rect.globalizePosition (Vector3 (-w,  h, 0));
+            Vector3 v3 = rect.globalizePosition (Vector3 (-w, -h, 0));
+            Vector3 v4 = rect.globalizePosition (Vector3 ( w, -h, 0));
 
             drawLine (v1, v2, color);
             drawLine (v2, v3, color);
@@ -754,20 +754,20 @@
             const float w = box.width / 2;
             const float h = box.height / 2;
             const float d = box.depth / 2;
-            const Vec3 p = box.position ();
-            const Vec3 s = box.side ();
-            const Vec3 u = box.up ();
-            const Vec3 f = box.forward ();
+            const Vector3 p = box.position ();
+            const Vector3 s = box.side ();
+            const Vector3 u = box.up ();
+            const Vector3 f = box.forward ();
 
-            const Vec3 v1 = box.globalizePosition (Vec3 ( w,  h,  d));
-            const Vec3 v2 = box.globalizePosition (Vec3 (-w,  h,  d));
-            const Vec3 v3 = box.globalizePosition (Vec3 (-w, -h,  d));
-            const Vec3 v4 = box.globalizePosition (Vec3 ( w, -h,  d));
+            const Vector3 v1 = box.globalizePosition (Vector3 ( w,  h,  d));
+            const Vector3 v2 = box.globalizePosition (Vector3 (-w,  h,  d));
+            const Vector3 v3 = box.globalizePosition (Vector3 (-w, -h,  d));
+            const Vector3 v4 = box.globalizePosition (Vector3 ( w, -h,  d));
 
-            const Vec3 v5 = box.globalizePosition (Vec3 ( w,  h, -d));
-            const Vec3 v6 = box.globalizePosition (Vec3 (-w,  h, -d));
-            const Vec3 v7 = box.globalizePosition (Vec3 (-w, -h, -d));
-            const Vec3 v8 = box.globalizePosition (Vec3 ( w, -h, -d));
+            const Vector3 v5 = box.globalizePosition (Vector3 ( w,  h, -d));
+            const Vector3 v6 = box.globalizePosition (Vector3 (-w,  h, -d));
+            const Vector3 v7 = box.globalizePosition (Vector3 (-w, -h, -d));
+            const Vector3 v8 = box.globalizePosition (Vector3 ( w, -h, -d));
 
             drawLine (v1, v2, color);
             drawLine (v2, v3, color);

Modified: dependencies/opensteer/plugins/CaptureTheFlag.cpp
===================================================================
--- dependencies/opensteer/plugins/CaptureTheFlag.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/plugins/CaptureTheFlag.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -106,7 +106,7 @@
         static void initializeObstacles (void);
         static void addOneObstacle (void);
         static void removeOneObstacle (void);
-        float minDistanceToObstacle (const Vec3 point);
+        float minDistanceToObstacle (const Vector3 point);
         static int obstacleCount;
         static const int maxObstacleCount;
         static SOG allObstacles;
@@ -129,15 +129,15 @@
         // is there a clear path to the goal?
         bool clearPathToGoal (void);
 
-        Vec3 steeringForSeeker (void);
+        Vector3 steeringForSeeker (void);
         void updateState (const float currentTime);
         void draw (void);
-        Vec3 steerToEvadeAllDefenders (void);
-        Vec3 XXXsteerToEvadeAllDefenders (void);
+        Vector3 steerToEvadeAllDefenders (void);
+        Vector3 XXXsteerToEvadeAllDefenders (void);
         void adjustObstacleAvoidanceLookAhead (const bool clearPath);
         void clearPathAnnotation (const float threshold,
                                   const float behindcThreshold,
-                                  const Vec3&amp; goalDirection);
+                                  const Vector3&amp; goalDirection);
 
         seekerState state;
         bool evading; // xxx store steer sub-state for anotation
@@ -167,7 +167,7 @@
 
     const int CtfBase::maxObstacleCount = 100;
 
-    const Vec3 gHomeBaseCenter (0, 0, 0);
+    const Vector3 gHomeBaseCenter (0, 0, 0);
     const float gHomeBaseRadius = 1.5;
 
     const float gMinStartRadius = 30;
@@ -228,7 +228,7 @@
     void CtfSeeker::reset (void)
     {
         CtfBase::reset ();
-        bodyColor.set (0.4f, 0.4f, 0.6f); // blueish
+        bodyColor = Color(Vector3(0.4f, 0.4f, 0.6f)); // blueish
         gSeeker = this;
         state = running;
         evading = false;
@@ -238,7 +238,7 @@
     void CtfEnemy::reset (void)
     {
         CtfBase::reset ();
-        bodyColor.set (0.6f, 0.4f, 0.4f); // redish
+        bodyColor = Color(Vector3(0.6f, 0.4f, 0.4f)); // redish
     }
 
 
@@ -261,7 +261,7 @@
         // randomize position on a ring between inner and outer radii
         // centered around the home base
         const float rRadius = frandom2 (gMinStartRadius, gMaxStartRadius);
-        const Vec3 randomOnRing = RandomUnitVectorOnXZPlane () * rRadius;
+        const Vector3 randomOnRing = RandomUnitVectorOnXZPlane () * rRadius;
         setPosition (gHomeBaseCenter + randomOnRing);
 
         // are we are too close to an obstacle?
@@ -285,7 +285,7 @@
     void CtfEnemy::update (const float currentTime, const float elapsedTime)
     {
         // determine upper bound for pursuit prediction time
-        const float seekerToGoalDist = Vec3::distance (gHomeBaseCenter,
+        const float seekerToGoalDist = Vector3::distance (gHomeBaseCenter,
                                                        gSeeker-&gt;position());
         const float adjustedDistance = seekerToGoalDist - radius()-gHomeBaseRadius;
         const float seekerToGoalTime = ((adjustedDistance &lt; 0 ) ?
@@ -294,15 +294,15 @@
         const float maxPredictionTime = seekerToGoalTime * 0.9f;
 
         // determine steering (pursuit, obstacle avoidance, or braking)
-        Vec3 steer (0, 0, 0);
+        Vector3 steer (0, 0, 0);
         if (gSeeker-&gt;state == running)
         {
-            const Vec3 avoidance =
+            const Vector3 avoidance =
                 steerToAvoidObstacles (gAvoidancePredictTimeMin,
                                        (ObstacleGroup&amp;) allObstacles);
 
             // saved for annotation
-            avoiding = (avoidance == Vec3::zero);
+            avoiding = (avoidance == Vector3::ZERO);
 
             if (avoiding)
                 steer = steerForPursuit (*gSeeker, maxPredictionTime);
@@ -321,7 +321,7 @@
 
 
         // detect and record interceptions (&quot;tags&quot;) of seeker
-        const float seekerToMeDist = Vec3::distance (position(), 
+        const float seekerToMeDist = Vector3::distance (position(), 
                                                      gSeeker-&gt;position());
         const float sumOfRadii = radius() + gSeeker-&gt;radius();
         if (seekerToMeDist &lt; sumOfRadii)
@@ -350,9 +350,9 @@
         const float sideThreshold = radius() * 8.0f;
         const float behindThreshold = radius() * 2.0f;
 
-        const Vec3 goalOffset = gHomeBaseCenter - position();
+        const Vector3 goalOffset = gHomeBaseCenter - position();
         const float goalDistance = goalOffset.length ();
-        const Vec3 goalDirection = goalOffset / goalDistance;
+        const Vector3 goalDirection = goalOffset / goalDistance;
 
         const bool goalIsAside = isAside (gHomeBaseCenter, 0.5);
 
@@ -364,14 +364,14 @@
         {
             // short name for this enemy
             const CtfEnemy&amp; e = *ctfEnemies[i];
-            const float eDistance = Vec3::distance (position(), e.position());
+            const float eDistance = Vector3::distance (position(), e.position());
             const float timeEstimate = 0.3f * eDistance / e.speed(); //xxx
-            const Vec3 eFuture = e.predictFuturePosition (timeEstimate);
-            const Vec3 eOffset = eFuture - position();
-            const float alongCorridor = goalDirection.dot (eOffset);
+            const Vector3 eFuture = e.predictFuturePosition (timeEstimate);
+            const Vector3 eOffset = eFuture - position();
+            const float alongCorridor = goalDirection.dotProduct(eOffset);
             const bool inCorridor = ((alongCorridor &gt; -behindThreshold) &amp;&amp; 
                                      (alongCorridor &lt; goalDistance));
-            const float eForwardDistance = forward().dot (eOffset);
+            const float eForwardDistance = forward().dotProduct(eOffset);
 
             // xxx temp move this up before the conditionals
             annotationXZCircle (e.radius(), eFuture, clearPathColor, 20); //xxx
@@ -379,7 +379,7 @@
             // consider as potential blocker if within the corridor
             if (inCorridor)
             {
-                const Vec3 perp = eOffset - (goalDirection * alongCorridor);
+                const Vector3 perp = eOffset - (goalDirection * alongCorridor);
                 const float acrossCorridor = perp.length();
                 if (acrossCorridor &lt; sideThreshold)
                 {
@@ -425,14 +425,14 @@
 
     void CtfSeeker::clearPathAnnotation (const float sideThreshold,
                                          const float behindThreshold,
-                                         const Vec3&amp; goalDirection)
+                                         const Vector3&amp; goalDirection)
     {
-        const Vec3 behindSide = side() * sideThreshold;
-        const Vec3 behindBack = forward() * -behindThreshold;
-        const Vec3 pbb = position() + behindBack;
-        const Vec3 gun = localRotateForwardToSide (goalDirection);
-        const Vec3 gn = gun * sideThreshold;
-        const Vec3 hbc = gHomeBaseCenter;
+        const Vector3 behindSide = side() * sideThreshold;
+        const Vector3 behindBack = forward() * -behindThreshold;
+        const Vector3 pbb = position() + behindBack;
+        const Vector3 gun = localRotateForwardToSide (goalDirection);
+        const Vector3 gn = gun * sideThreshold;
+        const Vector3 hbc = gHomeBaseCenter;
         annotationLine (pbb + gn,         hbc + gn,         clearPathColor);
         annotationLine (pbb - gn,         hbc - gn,         clearPathColor);
         annotationLine (hbc - gn,         hbc + gn,         clearPathColor);
@@ -448,12 +448,12 @@
 
     void CtfBase::annotateAvoidObstacle (const float minDistanceToCollision)
     {
-        const Vec3 boxSide = side() * radius();
-        const Vec3 boxFront = forward() * minDistanceToCollision;
-        const Vec3 FR = position() + boxFront - boxSide;
-        const Vec3 FL = position() + boxFront + boxSide;
-        const Vec3 BR = position()            - boxSide;
-        const Vec3 BL = position()            + boxSide;
+        const Vector3 boxSide = side() * radius();
+        const Vector3 boxFront = forward() * minDistanceToCollision;
+        const Vector3 FR = position() + boxFront - boxSide;
+        const Vector3 FL = position() + boxFront + boxSide;
+        const Vector3 BR = position()            - boxSide;
+        const Vector3 BL = position()            + boxSide;
         const Color white (1,1,1);
         annotationLine (FR, FL, white);
         annotationLine (FL, BL, white);
@@ -465,19 +465,19 @@
     // ----------------------------------------------------------------------------
 
 
-    Vec3 CtfSeeker::steerToEvadeAllDefenders (void)
+    Vector3 CtfSeeker::steerToEvadeAllDefenders (void)
     {
-        Vec3 evade (0, 0, 0);
-        const float goalDistance = Vec3::distance (gHomeBaseCenter, position());
+        Vector3 evade (0, 0, 0);
+        const float goalDistance = Vector3::distance (gHomeBaseCenter, position());
 
         // sum up weighted evasion
         for (int i = 0; i &lt; ctfEnemyCount; i++)
         {
             const CtfEnemy&amp; e = *ctfEnemies[i];
-            const Vec3 eOffset = e.position() - position();
+            const Vector3 eOffset = e.position() - position();
             const float eDistance = eOffset.length();
 
-            const float eForwardDistance = forward().dot (eOffset);
+            const float eForwardDistance = forward().dotProduct(eOffset);
             const float behindThreshold = radius() * 2;
             const bool behind = eForwardDistance &lt; behindThreshold;
             if ((!behind) || (eDistance &lt; 5))
@@ -486,13 +486,13 @@
                 {
                     // const float timeEstimate = 0.5f * eDistance / e.speed;//xxx
                     const float timeEstimate = 0.15f * eDistance / e.speed();//xxx
-                    const Vec3 future =
+                    const Vector3 future =
                         e.predictFuturePosition (timeEstimate);
 
                     annotationXZCircle (e.radius(), future, evadeColor, 20); // xxx
 
-                    const Vec3 offset = future - position();
-                    const Vec3 lateral = offset.perpendicularComponent (forward());
+                    const Vector3 offset = future - position();
+                    const Vector3 lateral = offset.perpendicularComponent (forward());
                     const float d = lateral.length();
                     const float weight = -1000 / (d * d);
                     evade += (lateral / d) * weight;
@@ -503,34 +503,34 @@
     }
 
 
-    Vec3 CtfSeeker::XXXsteerToEvadeAllDefenders (void)
+    Vector3 CtfSeeker::XXXsteerToEvadeAllDefenders (void)
     {
         // sum up weighted evasion
-        Vec3 evade (0, 0, 0);
+        Vector3 evade (0, 0, 0);
         for (int i = 0; i &lt; ctfEnemyCount; i++)
         {
             const CtfEnemy&amp; e = *ctfEnemies[i];
-            const Vec3 eOffset = e.position() - position();
+            const Vector3 eOffset = e.position() - position();
             const float eDistance = eOffset.length();
 
             // xxx maybe this should take into account e's heading? xxx
             const float timeEstimate = 0.5f * eDistance / e.speed(); //xxx
-            const Vec3 eFuture = e.predictFuturePosition (timeEstimate);
+            const Vector3 eFuture = e.predictFuturePosition (timeEstimate);
 
             // annotation
             annotationXZCircle (e.radius(), eFuture, evadeColor, 20);
 
             // steering to flee from eFuture (enemy's future position)
-            const Vec3 flee = xxxsteerForFlee (eFuture);
+            const Vector3 flee = xxxsteerForFlee (eFuture);
 
-            const float eForwardDistance = forward().dot (eOffset);
+            const float eForwardDistance = forward().dotProduct(eOffset);
             const float behindThreshold = radius() * -2;
 
             const float distanceWeight = 4 / eDistance;
             const float forwardWeight = ((eForwardDistance &gt; behindThreshold) ?
                                          1.0f : 0.5f);
 
-            const Vec3 adjustedFlee = flee * distanceWeight * forwardWeight;
+            const Vector3 adjustedFlee = flee * distanceWeight * forwardWeight;
 
             evade += adjustedFlee;
         }
@@ -541,17 +541,17 @@
     // ----------------------------------------------------------------------------
 
 
-    Vec3 CtfSeeker::steeringForSeeker (void)
+    Vector3 CtfSeeker::steeringForSeeker (void)
     {
         // determine if obstacle avodiance is needed
         const bool clearPath = clearPathToGoal ();
         adjustObstacleAvoidanceLookAhead (clearPath);
-        const Vec3 obstacleAvoidance =
+        const Vector3 obstacleAvoidance =
             steerToAvoidObstacles (gAvoidancePredictTime,
                                    (ObstacleGroup&amp;) allObstacles);
 
         // saved for annotation
-        avoiding = (obstacleAvoidance != Vec3::zero);
+        avoiding = (obstacleAvoidance != Vector3::ZERO);
 
         if (avoiding)
         {
@@ -561,13 +561,13 @@
         else
         {
             // otherwise seek home base and perhaps evade defenders
-            const Vec3 seek = xxxsteerForSeek (gHomeBaseCenter);
+            const Vector3 seek = xxxsteerForSeek (gHomeBaseCenter);
             if (clearPath)
             {
                 // we have a clear path (defender-free corridor), use pure seek
 
                 // xxx experiment 9-16-02
-                Vec3 s = limitMaxDeviationAngle (seek, 0.707f, forward());
+                Vector3 s = limitMaxDeviationAngle (seek, 0.707f, forward());
 
                 annotationLine (position(), position() + (s * 0.2f), seekColor);
                 return s;
@@ -577,8 +577,8 @@
                 if (0) // xxx testing new evade code xxx
                 {
                     // combine seek and (forward facing portion of) evasion
-                    const Vec3 evade = steerToEvadeAllDefenders ();
-                    const Vec3 steer = 
+                    const Vector3 evade = steerToEvadeAllDefenders ();
+                    const Vector3 steer = 
                         seek + limitMaxDeviationAngle (evade, 0.5f, forward());
 
                     // annotation: show evasion steering force
@@ -588,8 +588,8 @@
                 else
 
                 {
-                    const Vec3 evade = XXXsteerToEvadeAllDefenders ();
-                    const Vec3 steer = limitMaxDeviationAngle (seek + evade,
+                    const Vector3 evade = XXXsteerToEvadeAllDefenders ();
+                    const Vector3 steer = limitMaxDeviationAngle (seek + evade,
                                                                0.707f, forward());
 
                     annotationLine (position(),position()+seek, gRed);
@@ -614,7 +614,7 @@
         if (clearPath)
         {
             evading = false;
-            const float goalDistance = Vec3::distance (gHomeBaseCenter,position());
+            const float goalDistance = Vector3::distance (gHomeBaseCenter,position());
             const bool headingTowardGoal = isAhead (gHomeBaseCenter, 0.98f);
             const bool isNear = (goalDistance/speed()) &lt; gAvoidancePredictTimeMax;
             const bool useMax = headingTowardGoal &amp;&amp; !isNear;
@@ -637,7 +637,7 @@
         // if we reach the goal before being tagged, switch to atGoal state
         if (state == running)
         {
-            const float baseDistance = Vec3::distance (position(),gHomeBaseCenter);
+            const float baseDistance = Vector3::distance (position(),gHomeBaseCenter);
             if (baseDistance &lt; (radius() + gHomeBaseRadius)) state = atGoal;
         }
 
@@ -684,7 +684,7 @@
         }
 
         // annote seeker with its state as text
-        const Vec3 textOrigin = position() + Vec3 (0, 0.25, 0);
+        const Vector3 textOrigin = position() + Vector3 (0, 0.25, 0);
         std::ostringstream annote;
         annote &lt;&lt; seekerStateString &lt;&lt; std::endl;
         annote &lt;&lt; std::setprecision(2) &lt;&lt; std::setiosflags(std::ios::fixed)
@@ -697,7 +697,7 @@
         status &lt;&lt; obstacleCount &lt;&lt; &quot; obstacles [F1/F2]&quot; &lt;&lt; std::endl;
         status &lt;&lt; resetCount &lt;&lt; &quot; restarts&quot; &lt;&lt; std::ends;
         const float h = drawGetWindowHeight ();
-        const Vec3 screenLocation (10, h-50, 0);
+        const Vector3 screenLocation (10, h-50, 0);
         draw2dTextAt2dLocation (status, screenLocation, gGray80, drawGetWindowWidth(), drawGetWindowHeight());
     }
 
@@ -712,7 +712,7 @@
         updateState (currentTime);
 
         // determine and apply steering/braking forces
-        Vec3 steer (0, 0, 0);
+        Vector3 steer (0, 0, 0);
         if (state == running)
         {
             steer = steeringForSeeker ();
@@ -744,7 +744,7 @@
 
     #define testOneObstacleOverlap(radius, center)               \
     {                                                            \
-        float d = Vec3::distance (c, center);                    \
+        float d = Vector3::distance (c, center);                    \
         float clearance = d - (r + (radius));                    \
         if (minClearance &gt; clearance) minClearance = clearance;  \
     }
@@ -768,7 +768,7 @@
             // pick a random center and radius,
             // loop until no overlap with other obstacles and the home base
             float r;
-            Vec3 c;
+            Vector3 c;
             float minClearance;
             const float requiredClearance = gSeeker-&gt;radius() * 4; // 2 x diameter
             do
@@ -794,10 +794,10 @@
     }
 
 
-    float CtfBase::minDistanceToObstacle (const Vec3 point)
+    float CtfBase::minDistanceToObstacle (const Vector3 point)
     {
         float r = 0;
-        Vec3 c = point;
+        Vector3 c = point;
         float minClearance = FLT_MAX;
         for (SOI so = allObstacles.begin(); so != allObstacles.end(); so++)
         {
@@ -848,8 +848,8 @@
             // initialize camera
             OpenSteerDemo::init2dCamera (*ctfSeeker);
             OpenSteerDemo::camera.mode = Camera::cmFixedDistanceOffset;
-            OpenSteerDemo::camera.fixedTarget.set (15, 0, 0);
-            OpenSteerDemo::camera.fixedPosition.set (80, 60, 0);
+            OpenSteerDemo::camera.fixedTarget = Vector3(15, 0, 0);
+            OpenSteerDemo::camera.fixedPosition = Vector3(80, 60, 0);
 
             CtfBase::initializeObstacles ();
         }
@@ -878,12 +878,12 @@
             OpenSteerDemo::updateCamera (currentTime, elapsedTime, selected);
 
             // draw &quot;ground plane&quot; centered between base and selected vehicle
-            const Vec3 goalOffset = gHomeBaseCenter-OpenSteerDemo::camera.position();
-            const Vec3 goalDirection = goalOffset.normalize ();
-            const Vec3 cameraForward = OpenSteerDemo::camera.xxxls().forward();
-            const float goalDot = cameraForward.dot (goalDirection);
+            const Vector3 goalOffset = gHomeBaseCenter-OpenSteerDemo::camera.position();
+            const Vector3 goalDirection = goalOffset.normalisedCopy();
+            const Vector3 cameraForward = OpenSteerDemo::camera.xxxls().forward();
+            const float goalDot = cameraForward.dotProduct(goalDirection);
             const float blend = remapIntervalClip (goalDot, 1, 0, 0.5, 0);
-            const Vec3 gridCenter = interpolate (blend,
+            const Vector3 gridCenter = interpolate (blend,
                                                  selected.position(),
                                                  gHomeBaseCenter);
             OpenSteerDemo::gridUtility (gridCenter);
@@ -957,7 +957,7 @@
 
         void drawHomeBase (void)
         {
-            const Vec3 up (0, 0.01f, 0);
+            const Vector3 up (0, 0.01f, 0);
             const Color atColor (0.3f, 0.3f, 0.5f);
             const Color noColor = gGray50;
             const bool reached = ctfSeeker-&gt;state == CtfSeeker::atGoal;

Modified: dependencies/opensteer/plugins/LowSpeedTurn.cpp
===================================================================
--- dependencies/opensteer/plugins/LowSpeedTurn.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/plugins/LowSpeedTurn.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -113,7 +113,7 @@
         }
 
         // constant steering force
-        Vec3 steering (void) {return Vec3 (1, 0, -1);}
+        Vector3 steering (void) {return Vector3 (1, 0, -1);}
 
         // for stepping the starting conditions for next vehicle
         static float startX;
@@ -131,8 +131,8 @@
 
     const int lstCount = 5;
     const float lstLookDownDistance = 18;
-    const Vec3 lstViewCenter (7, 0, -2);
-    const Vec3 lstPlusZ (0, 0, 1);
+    const Vector3 lstViewCenter (7, 0, -2);
+    const Vector3 lstPlusZ (0, 0, 1);
 
 
     class LowSpeedTurnPlugIn : public PlugIn
@@ -199,8 +199,8 @@
 
                 // display speed near agent's screen position
                 const Color textColor (0.8f, 0.8f, 1.0f);
-                const Vec3 textOffset (0, 0.25f, 0);
-                const Vec3 textPosition = agent.position() + textOffset;
+                const Vector3 textOffset (0, 0.25f, 0);
+                const Vector3 textPosition = agent.position() + textOffset;
                 std::ostringstream annote;
                 annote &lt;&lt; std::setprecision (2)
                        &lt;&lt; std::setiosflags (std::ios::fixed)

Modified: dependencies/opensteer/plugins/MapDrive.cpp
===================================================================
--- dependencies/opensteer/plugins/MapDrive.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/plugins/MapDrive.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -96,10 +96,10 @@
     public:
         PointToRadiusMapping(): radius( 0.0f ) {}
         
-        void setPointOnPathCenterLine( OpenSteer::Vec3 const&amp; ) {}
-        void setPointOnPathBoundary( OpenSteer::Vec3 const&amp;  ) {}
+        void setPointOnPathCenterLine( Vector3 const&amp; ) {}
+        void setPointOnPathBoundary( Vector3 const&amp;  ) {}
         void setRadius( float r ) { radius = r; }
-        void setTangent( OpenSteer::Vec3 const&amp; ) {}
+        void setTangent( Vector3 const&amp; ) {}
         void setSegmentIndex( OpenSteer::size_t ) {}
         void setDistancePointToPath( float  ) {}
         void setDistancePointToPathCenterLine( float ) {}
@@ -113,19 +113,19 @@
     
     class PointToTangentMapping : public OpenSteer::DontExtractPathDistance {
     public:
-        PointToTangentMapping() : tangent( OpenSteer::Vec3( 0.0f, 0.0f, 0.0f ) ) {}
+        PointToTangentMapping() : tangent( Vector3( 0.0f, 0.0f, 0.0f ) ) {}
         
-        void setPointOnPathCenterLine( OpenSteer::Vec3 const&amp; ) {}
-        void setPointOnPathBoundary( OpenSteer::Vec3 const&amp;  ) {}
+        void setPointOnPathCenterLine( Vector3 const&amp; ) {}
+        void setPointOnPathBoundary( Vector3 const&amp;  ) {}
         void setRadius( float ) {}
-        void setTangent( OpenSteer::Vec3 const&amp; t ) { tangent = t; }
+        void setTangent( Vector3 const&amp; t ) { tangent = t; }
         void setSegmentIndex( OpenSteer::size_t ) {}
         void setDistancePointToPath( float  ) {}
         void setDistancePointToPathCenterLine( float ) {}
         void setDistanceOnPath( float  ) {}
         void setDistanceOnSegment( float ) {}
         
-        OpenSteer::Vec3 tangent;
+        Vector3 tangent;
     };
 
 
@@ -133,19 +133,19 @@
     
     class PointToPointOnCenterLineAndOutsideMapping : public OpenSteer::DontExtractPathDistance {
     public:
-        PointToPointOnCenterLineAndOutsideMapping() : pointOnPathCenterLine( OpenSteer::Vec3( 0.0f, 0.0f, 0.0f ) ), distancePointToPathBoundary( 0.0f ) {}
+        PointToPointOnCenterLineAndOutsideMapping() : pointOnPathCenterLine( Vector3( 0.0f, 0.0f, 0.0f ) ), distancePointToPathBoundary( 0.0f ) {}
         
-        void setPointOnPathCenterLine( OpenSteer::Vec3 const&amp; point) { pointOnPathCenterLine = point; }
-        void setPointOnPathBoundary( OpenSteer::Vec3 const&amp; ) {}
+        void setPointOnPathCenterLine( Vector3 const&amp; point) { pointOnPathCenterLine = point; }
+        void setPointOnPathBoundary( Vector3 const&amp; ) {}
         void setRadius( float ) {}
-        void setTangent( OpenSteer::Vec3 const&amp; ) {}
+        void setTangent( Vector3 const&amp; ) {}
         void setSegmentIndex( OpenSteer::size_t ) {}
         void setDistancePointToPath( float d ) { distancePointToPathBoundary = d; }
         void setDistancePointToPathCenterLine( float ) {}
         void setDistanceOnPath( float  ) {}
         void setDistanceOnSegment( float ) {}    
         
-        OpenSteer::Vec3 pointOnPathCenterLine;
+        Vector3 pointOnPathCenterLine;
         float distancePointToPathBoundary;
     };
 
@@ -156,10 +156,10 @@
     public:
         PointToOutsideMapping() : distancePointToPathBoundary( 0.0f ) {}
         
-        void setPointOnPathCenterLine( OpenSteer::Vec3 const&amp; ) {}
-        void setPointOnPathBoundary( OpenSteer::Vec3 const&amp;  ) {}
+        void setPointOnPathCenterLine( Vector3 const&amp; ) {}
+        void setPointOnPathBoundary( Vector3 const&amp;  ) {}
         void setRadius( float ) {}
-        void setTangent( OpenSteer::Vec3 const&amp; ) {}
+        void setTangent( Vector3 const&amp; ) {}
         void setSegmentIndex( OpenSteer::size_t ) {}
         void setDistancePointToPath( float d ) { distancePointToPathBoundary = d; }
         void setDistancePointToPathCenterLine( float ) {}
@@ -175,10 +175,10 @@
     public:
         PointToSegmentIndexMapping() : segmentIndex( 0 ) {}
         
-        void setPointOnPathCenterLine( OpenSteer::Vec3 const&amp; ) {}
-        void setPointOnPathBoundary( OpenSteer::Vec3 const&amp;  ) {}
+        void setPointOnPathCenterLine( Vector3 const&amp; ) {}
+        void setPointOnPathBoundary( Vector3 const&amp;  ) {}
         void setRadius( float ) {}
-        void setTangent( OpenSteer::Vec3 const&amp; ) {}
+        void setTangent( Vector3 const&amp; ) {}
         void setSegmentIndex( OpenSteer::size_t i ) { segmentIndex = i; }
         void setDistancePointToPath( float  ) {}
         void setDistancePointToPathCenterLine( float ) {}
@@ -191,7 +191,7 @@
     /**
      * Maps @a point to @a pathway and extracts the radius at the mapping point.
      */
-    float mapPointToRadius( OpenSteer::PolylineSegmentedPathwaySegmentRadii const&amp; pathway, OpenSteer::Vec3 const&amp; point ) {
+    float mapPointToRadius( OpenSteer::PolylineSegmentedPathwaySegmentRadii const&amp; pathway, Vector3 const&amp; point ) {
         PointToRadiusMapping mapping;
         OpenSteer::mapPointToPathAlike( pathway, point, mapping );
         return mapping.radius;
@@ -201,7 +201,7 @@
      * Maps @a point to @a pathway and extracts the tangent at the mapping 
      * point.
      */
-    OpenSteer::Vec3 mapPointToTangent( OpenSteer::PolylineSegmentedPathwaySegmentRadii const&amp; pathway, OpenSteer::Vec3 const&amp; point ) {
+    Vector3 mapPointToTangent( OpenSteer::PolylineSegmentedPathwaySegmentRadii const&amp; pathway, Vector3 const&amp; point ) {
         PointToTangentMapping mapping;
         OpenSteer::mapPointToPathAlike( pathway, point, mapping );
         return mapping.tangent;
@@ -214,12 +214,12 @@
      */
     bool isInsidePathSegment( OpenSteer::PolylineSegmentedPathwaySegmentRadii const&amp; pathway,  
                               OpenSteer::PolylineSegmentedPathwaySegmentRadii::size_type segmentIndex, 
-                              OpenSteer::Vec3 const&amp; point ) {
+                              Vector3 const&amp; point ) {
         assert( pathway.isValid() &amp;&amp; &quot;pathway isn't valid.&quot; );
         assert( segmentIndex &lt; pathway.segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
         
         float const segmentDistance = pathway.mapPointToSegmentDistance( segmentIndex, point );
-        OpenSteer::Vec3 const pointOnSegmentCenterLine = pathway.mapSegmentDistanceToPoint( segmentIndex, segmentDistance );
+        Vector3 const pointOnSegmentCenterLine = pathway.mapSegmentDistanceToPoint( segmentIndex, segmentDistance );
         float const segmentRadiusAtPoint = pathway.mapSegmentDistanceToRadius( segmentIndex, segmentDistance );
         
         float const distancePointToPointOnSegmentCenterLine = (point - pointOnSegmentCenterLine).length();
@@ -238,7 +238,7 @@
      * @param direction Follow the path in path direction (@c 1) or in reverse
      *                  direction ( @c -1 ).
      */
-    OpenSteer::Vec3 mapPointAndDirectionToTangent( OpenSteer::PolylineSegmentedPathwaySegmentRadii const&amp; pathway, OpenSteer::Vec3 const&amp; point, int direction ) {
+    Vector3 mapPointAndDirectionToTangent( OpenSteer::PolylineSegmentedPathwaySegmentRadii const&amp; pathway, Vector3 const&amp; point, int direction ) {
         assert( ( ( 1 == direction ) || ( -1 == direction ) ) &amp;&amp; &quot;direction must be 1 or -1.&quot; );
         typedef OpenSteer::PolylineSegmentedPathwaySegmentRadii::size_type size_type;
         
@@ -279,7 +279,7 @@
      *
      * On point on the boundary isn't inside the pathway.
      */
-    bool isNearWaypoint( OpenSteer::PolylineSegmentedPathwaySegmentRadii const&amp; pathway, OpenSteer::Vec3 const&amp; point ) {
+    bool isNearWaypoint( OpenSteer::PolylineSegmentedPathwaySegmentRadii const&amp; pathway, Vector3 const&amp; point ) {
         assert( pathway.isValid() &amp;&amp; &quot;pathway must be valid.&quot; );
         
         typedef OpenSteer::PolylineSegmentedPathwaySegmentRadii::size_type size_type;
@@ -287,8 +287,8 @@
         size_type pointIndex = 0;
         
         // Test first waypoint.
-        OpenSteer::Vec3 pointPathwayPointVector = point - pathway.point( pointIndex );
-        float pointPathwayPointDistance = pointPathwayPointVector.dot( pointPathwayPointVector );
+        Vector3 pointPathwayPointVector = point - pathway.point( pointIndex );
+        float pointPathwayPointDistance = pointPathwayPointVector.dotProduct( pointPathwayPointVector );
         if ( pointPathwayPointDistance &lt; OpenSteer::square( pathway.segmentRadius( pointIndex ) ) ) {
             return true;
         }
@@ -297,7 +297,7 @@
         size_type const maxInnerPointIndex = pathway.pointCount() - 2;
         for ( pointIndex = 1; pointIndex &lt;= maxInnerPointIndex; ++pointIndex ) {
             pointPathwayPointVector = point - pathway.point( pointIndex );
-            pointPathwayPointDistance = pointPathwayPointVector.dot( pointPathwayPointVector );
+            pointPathwayPointDistance = pointPathwayPointVector.dotProduct( pointPathwayPointVector );
             if ( ( pointPathwayPointDistance &lt; OpenSteer::square( pathway.segmentRadius( pointIndex ) ) ) ||
                  ( pointPathwayPointDistance &lt; OpenSteer::square( pathway.segmentRadius( pointIndex - 1) ) ) ) {
                 return true;
@@ -306,7 +306,7 @@
 
         // Test last waypoint.
         pointPathwayPointVector = point - pathway.point( pointIndex );
-        pointPathwayPointDistance = pointPathwayPointVector.dot( pointPathwayPointVector );
+        pointPathwayPointDistance = pointPathwayPointVector.dotProduct( pointPathwayPointVector );
         if ( pointPathwayPointDistance &lt; OpenSteer::square( pathway.segmentRadius( pointIndex - 1 ) ) ) {
             return true;
         }
@@ -331,7 +331,7 @@
      * Maps @a point to @a pathway and returns the mapping point on the pathway 
      * boundary and how far outside @a point is from the mapping point.
      */
-    OpenSteer::Vec3 mapPointToPointOnCenterLineAndOutside( OpenSteer::PolylineSegmentedPathwaySegmentRadii const&amp; pathway, OpenSteer::Vec3 const&amp; point, float&amp; outside ) {
+    Vector3 mapPointToPointOnCenterLineAndOutside( OpenSteer::PolylineSegmentedPathwaySegmentRadii const&amp; pathway, Vector3 const&amp; point, float&amp; outside ) {
         PointToPointOnCenterLineAndOutsideMapping mapping;
         OpenSteer::mapPointToPathAlike( pathway, point, mapping );
         outside = mapping.distancePointToPathBoundary;
@@ -343,7 +343,7 @@
      * Maps @a point to @a pathway and returns how far outside @a point is from 
      * the mapping point on the path boundary.
      */
-    float mapPointToOutside( OpenSteer::PolylineSegmentedPathwaySegmentRadii const&amp; pathway, OpenSteer::Vec3 const&amp; point ) {
+    float mapPointToOutside( OpenSteer::PolylineSegmentedPathwaySegmentRadii const&amp; pathway, Vector3 const&amp; point ) {
         PointToOutsideMapping mapping;
         OpenSteer::mapPointToPathAlike( pathway, point, mapping);
         return mapping.distancePointToPathBoundary;    
@@ -353,13 +353,13 @@
      * Returns @c true if @a point is inside @a pathway, @c false otherwise.
      * A point on the boundary isn't inside the pathway.
      */
-    bool isInsidePathway( OpenSteer::PolylineSegmentedPathwaySegmentRadii const&amp; pathway, OpenSteer::Vec3 const&amp; point ) {
+    bool isInsidePathway( OpenSteer::PolylineSegmentedPathwaySegmentRadii const&amp; pathway, Vector3 const&amp; point ) {
         return 0.0f &gt; mapPointToOutside( pathway, point );
     }
     
 
     OpenSteer::PolylineSegmentedPathwaySegmentRadii::size_type mapPointToSegmentIndex(  OpenSteer::PolylineSegmentedPathwaySegmentRadii const&amp; pathway, 
-                                                                                        OpenSteer::Vec3 const&amp; point ) {
+                                                                                        Vector3 const&amp; point ) {
         PointToSegmentIndexMapping mapping;
         OpenSteer::mapPointToPathAlike( pathway, point, mapping );
         return mapping.segmentIndex;
@@ -381,7 +381,7 @@
     public:
 
         // constructor
-        TerrainMap (const Vec3&amp; c, float x, float z, int r)
+        TerrainMap (const Vector3&amp; c, float x, float z, int r)
             : center(c),
               xSize(x),
               zSize(z),
@@ -418,10 +418,10 @@
 
 
         // get a value based on a position in 3d world space
-        bool getMapValue (const Vec3&amp; point) const
+        bool getMapValue (const Vector3&amp; point) const
         {
-            const Vec3 local = point - center;
-            const Vec3 localXZ = local.setYtoZero();
+            const Vector3 local = point - center;
+            const Vector3 localXZ = local.setYtoZero();
 
             const float hxs = xSize/2;
             const float hzs = zSize/2;
@@ -449,9 +449,9 @@
         {
             const float xs = xSize/(float)resolution;
             const float zs = zSize/(float)resolution;
-            const Vec3 alongRow (xs, 0, 0);
-            const Vec3 nextRow (-xSize, 0, zs);
-            Vec3 g ((xSize - xs) / -2, 0, (zSize - zs) / -2);
+            const Vector3 alongRow (xs, 0, 0);
+            const Vector3 nextRow (-xSize, 0, zs);
+            Vector3 g ((xSize - xs) / -2, 0, (zSize - zs) / -2);
             g += center;
             for (int j = 0; j &lt; resolution; j++)
             {
@@ -460,23 +460,23 @@
                     if (getMapBit (i, j))
                     {
                         // spikes
-                        // const Vec3 spikeTop (0, 5.0f, 0);
+                        // const Vector3 spikeTop (0, 5.0f, 0);
                         // drawLine (g, g+spikeTop, gWhite);
 
                         // squares
                         const float rockHeight = 0;
-                        const Vec3 v1 (+xs/2, rockHeight, +zs/2);
-                        const Vec3 v2 (+xs/2, rockHeight, -zs/2);
-                        const Vec3 v3 (-xs/2, rockHeight, -zs/2);
-                        const Vec3 v4 (-xs/2, rockHeight, +zs/2);
-                        // const Vec3 redRockColor (0.6f, 0.1f, 0.0f);
+                        const Vector3 v1 (+xs/2, rockHeight, +zs/2);
+                        const Vector3 v2 (+xs/2, rockHeight, -zs/2);
+                        const Vector3 v3 (-xs/2, rockHeight, -zs/2);
+                        const Vector3 v4 (-xs/2, rockHeight, +zs/2);
+                        // const Vector3 redRockColor (0.6f, 0.1f, 0.0f);
                         const Color orangeRockColor (0.5f, 0.2f, 0.0f);
                         drawQuadrangle (g+v1, g+v2, g+v3, g+v4, orangeRockColor);
 
                         // pyramids
-                        // const Vec3 top (0, xs/2, 0);
-                        // const Vec3 redRockColor (0.6f, 0.1f, 0.0f);
-                        // const Vec3 orangeRockColor (0.5f, 0.2f, 0.0f);
+                        // const Vector3 top (0, xs/2, 0);
+                        // const Vector3 redRockColor (0.6f, 0.1f, 0.0f);
+                        // const Vector3 orangeRockColor (0.5f, 0.2f, 0.0f);
                         // drawTriangle (g+v1, g+v2, g+top, redRockColor);
                         // drawTriangle (g+v2, g+v3, g+top, orangeRockColor);
                         // drawTriangle (g+v3, g+v4, g+top, redRockColor);
@@ -505,8 +505,8 @@
             {
                 for (float z = zMin; z &lt; zMax; z += spacing)
                 {
-                    const Vec3 sample (x, 0, z);
-                    const Vec3 global = localSpace.globalizePosition (sample);
+                    const Vector3 sample (x, 0, z);
+                    const Vector3 global = localSpace.globalizePosition (sample);
                     if (getMapValue (global)) return true;
                 }
             }
@@ -516,11 +516,11 @@
         // Scans along a ray (directed line segment) on the XZ plane, sampling
         // the map for a &quot;true&quot; cell.  Returns the index of the first sample
         // that gets a &quot;hit&quot;, or zero if no hits found.
-        int scanXZray (const Vec3&amp; origin,
-                       const Vec3&amp; sampleSpacing,
+        int scanXZray (const Vector3&amp; origin,
+                       const Vector3&amp; sampleSpacing,
                        const int sampleCount) const
         {
-            Vec3 samplePoint (origin);
+            Vector3 samplePoint (origin);
 
             for (int i = 1; i &lt;= sampleCount; i++)
             {
@@ -534,10 +534,10 @@
 
         int cellwidth (void) const {return resolution;}  // xxx cwr
         int cellheight (void) const {return resolution;}  // xxx cwr
-        bool isPassable (const Vec3&amp; point) const {return ! getMapValue (point);}
+        bool isPassable (const Vector3&amp; point) const {return ! getMapValue (point);}
 
 
-        Vec3 center;
+        Vector3 center;
         float xSize;
         float zSize;
         int resolution;
@@ -580,7 +580,7 @@
         // array of points, an array of per-segment path radii, and a flag
         // indiating if the path is connected at the end.
         GCRoute (const int _pointCount,
-                 const Vec3 _points[],
+                 const Vector3 _points[],
                  const float _radii[],
                  const bool _cyclic)
         {
@@ -607,9 +607,9 @@
         // P and a measure of how far A is outside the Pathway's &quot;tube&quot;.  Note
         // that a negative distance indicates A is inside the Pathway.
 
-        Vec3 mapPointToPath (const Vec3&amp; point, Vec3&amp; tangent, float&amp; outside)
+        Vector3 mapPointToPath (const Vector3&amp; point, Vector3&amp; tangent, float&amp; outside)
         {
-            Vec3 onPath;
+            Vector3 onPath;
             outside = FLT_MAX;
 
             // loop over all segments, find the one nearest to the given point
@@ -640,15 +640,15 @@
 
         // ignore that &quot;tangent&quot; output argument which is never used
         // XXX eventually move this to Pathway class
-        Vec3 mapPointToPath (const Vec3&amp; point, float&amp; outside)
+        Vector3 mapPointToPath (const Vector3&amp; point, float&amp; outside)
         {
-            Vec3 tangent;
+            Vector3 tangent;
             return mapPointToPath (point, tangent, outside);
         }
 
         // get the index number of the path segment nearest the given point
         // XXX consider moving this to path class
-        int indexOfNearestSegment (const Vec3&amp; point)
+        int indexOfNearestSegment (const Vector3&amp; point)
         {
             int index = 0;
             float minDistance = FLT_MAX;
@@ -672,11 +672,11 @@
         // used to measure the &quot;angle&quot; at a path vertex: how sharp is the turn?
         float dotSegmentUnitTangents (int segmentIndex0, int segmentIndex1)
         {
-            return normals[segmentIndex0].dot (normals[segmentIndex1]);
+            return normals[segmentIndex0].dotProduct(normals[segmentIndex1]);
         }
 
         // return path tangent at given point (its projection on path)
-        Vec3 tangentAt (const Vec3&amp; point)
+        Vector3 tangentAt (const Vector3&amp; point)
         {
             return normals [indexOfNearestSegment (point)];
         }
@@ -685,7 +685,7 @@
         // multiplied by the given pathfollowing direction (+1/-1 =
         // upstream/downstream).  Near path vertices (waypoints) use the
         // tangent of the &quot;next segment&quot; in the given direction
-        Vec3 tangentAt (const Vec3&amp; point, const int pathFollowDirection)
+        Vector3 tangentAt (const Vector3&amp; point, const int pathFollowDirection)
         {
             const int segmentIndex = indexOfNearestSegment (point);
             const int nextIndex = segmentIndex + pathFollowDirection;
@@ -697,7 +697,7 @@
 
         // is the given point &quot;near&quot; a waypoint of this path?  (&quot;near&quot; == closer
         // to the waypoint than the max of radii of two adjacent segments)
-        bool nearWaypoint (const Vec3&amp; point)
+        bool nearWaypoint (const Vector3&amp; point)
         {
             // loop over all waypoints
             for (int i = 1; i &lt; pointCount; i++)
@@ -713,7 +713,7 @@
         // is the given point inside the path tube of the given segment
         // number?  (currently not used. this seemed like a useful utility,
         // but wasn't right for the problem I was trying to solve)
-        bool isInsidePathSegment (const Vec3&amp; point, const int segmentIndex)
+        bool isInsidePathSegment (const Vector3&amp; point, const int segmentIndex)
         {
             const int i = segmentIndex;
 
@@ -817,7 +817,7 @@
             adjustVehicleRadiusForSpeed ();
 
             // not previously avoiding
-            annotateAvoid = Vec3::zero;
+            annotateAvoid = Vector3::ZERO;
 
             // prevent long streaks due to teleportation 
             clearTrailHistory ();
@@ -826,7 +826,7 @@
             stuck = false;
 
             // QQQ need to clean up this hack
-            qqqLastNearestObstacle = Vec3::zero;
+            qqqLastNearestObstacle = Vector3::ZERO;
 
             // master look ahead (prediction) time
             baseLookAheadTime = 3;
@@ -836,15 +836,15 @@
                 lapsStarted++;
                 const float s = worldSize;
                 const float d = (float) pathFollowDirection;
-                setPosition (Vec3 (s * d * 0.6f, 0, s * -0.4f));
-                regenerateOrthonormalBasisUF (Vec3::side * d);
+                setPosition (Vector3 (s * d * 0.6f, 0, s * -0.4f));
+                regenerateOrthonormalBasisUF (Vector3::side * d);
             }
 
             // reset bookeeping to detect stuck cycles
             resetStuckCycleDetection ();
 
             // assume no previous steering
-            currentSteering = Vec3::zero;
+            currentSteering = Vector3::ZERO;
 
             // assume normal running state
             dtZero = false;
@@ -872,7 +872,7 @@
             annoteMaxRelSpeed = annoteMaxRelSpeedCurve = annoteMaxRelSpeedPath = 1;
 
             // determine combined steering
-            Vec3 steering;
+            Vector3 steering;
             const bool offPath = !bodyInsidePath ();
             if (stuck || offPath || detectImminentCollision ())
             {
@@ -887,16 +887,16 @@
 
                 // QQQ trying to prevent &quot;creep&quot; during emergency stops
                 resetSmoothedAcceleration ();
-                currentSteering = Vec3::zero;
+                currentSteering = Vector3::ZERO;
             }
             else
             {
                 // determine steering for obstacle avoidance (save for annotation)
-                const Vec3 avoid = annotateAvoid = 
+                const Vector3 avoid = annotateAvoid = 
                     steerToAvoidObstaclesOnMap (lookAheadTimeOA (),
                                                 *map,
                                                 hintForObstacleAvoidance ());
-                const bool needToAvoid = avoid != Vec3::zero;
+                const bool needToAvoid = avoid != Vector3::ZERO;
 
                 // any obstacles to avoid?
                 if (needToAvoid)
@@ -917,10 +917,10 @@
                     // wander for demo 1
                     if (demoSelect == 1)
                     {
-                        const Vec3 wander = steerForWander (elapsedTime);
-                        const Vec3 flat = wander.setYtoZero ();
-                        const Vec3 weighted = flat.truncateLength (maxForce()) * 6;
-                        const Vec3 a = position() + Vec3 (0, 0.2f, 0);
+                        const Vector3 wander = steerForWander (elapsedTime);
+                        const Vector3 flat = wander.setYtoZero ();
+                        const Vector3 weighted = flat.truncateLength (maxForce()) * 6;
+                        const Vector3 a = position() + Vector3 (0, 0.2f, 0);
                         annotationLine (a, a + (weighted * 0.3f), gWhite);
                         steering += weighted;
                     }
@@ -928,13 +928,13 @@
                     // follow the path in demo 2
                     if (demoSelect == 2)
                     {
-                        const Vec3 pf = steerToFollowPath (pathFollowDirection,
+                        const Vector3 pf = steerToFollowPath (pathFollowDirection,
                                                            lookAheadTimePF (),
                                                            *path);
-                        if (pf != Vec3::zero)
+                        if (pf != Vector3::ZERO)
                         {
                             // steer to remain on path
-                            if (pf.dot (forward()) &lt; 0)
+                            if (pf.dotProduct(forward()) &lt; 0)
                                 steering = pf;
                             else
                                 steering = pf + steering;
@@ -943,9 +943,9 @@
                         {
                             // path aligment: when neither obstacle avoidance nor
                             // path following is required, align with path segment
-                            const Vec3 pathHeading = mapPointAndDirectionToTangent( *path, position(), pathFollowDirection ); // path-&gt;tangentAt (position (), pathFollowDirection);
+                            const Vector3 pathHeading = mapPointAndDirectionToTangent( *path, position(), pathFollowDirection ); // path-&gt;tangentAt (position (), pathFollowDirection);
                             {
-                                const Vec3 b = (position () +
+                                const Vector3 b = (position () +
                                                 (up () * 0.2f) +
                                                 (forward () * halfLength * 1.4f));
                                 const float l = 2;
@@ -995,10 +995,10 @@
     //  //
     //  // reduce lateral steering at low speeds
     //  //
-    //  Vec3 reduceTurningAtLowSpeeds (const Vec3&amp; rawSteering)
+    //  Vector3 reduceTurningAtLowSpeeds (const Vector3&amp; rawSteering)
     //  {
-    //      const Vec3 thrust = rawSteering.parallelComponent (forward ());
-    //      const Vec3 lateral = rawSteering.perpendicularComponent (forward ());
+    //      const Vector3 thrust = rawSteering.parallelComponent (forward ());
+    //      const Vector3 lateral = rawSteering.perpendicularComponent (forward ());
     //      // const float adjust = relativeSpeed ();
     //      // const float adjust = square (relativeSpeed ());
     //      const float adjust = square (square (relativeSpeed ()));
@@ -1055,18 +1055,18 @@
         }
 
 
-        Vec3 hintForObstacleAvoidance (void)
+        Vector3 hintForObstacleAvoidance (void)
         {
             // used only when path following, return zero (&quot;no hint&quot;) otherwise
-            if (demoSelect != 2) return Vec3::zero;
+            if (demoSelect != 2) return Vector3::ZERO;
 
             // are we heading roughly parallel to the current path segment?
-            const Vec3 p = position ();
-            const Vec3 pathHeading = mapPointAndDirectionToTangent( *path, p, pathFollowDirection ); // path-&gt;tangentAt (p, pathFollowDirection);
-            if (pathHeading.dot (forward ()) &lt; 0.8f)
+            const Vector3 p = position ();
+            const Vector3 pathHeading = mapPointAndDirectionToTangent( *path, p, pathFollowDirection ); // path-&gt;tangentAt (p, pathFollowDirection);
+            if (pathHeading.dotProduct(forward ()) &lt; 0.8f)
             {
                 // if not, the &quot;hint&quot; is to turn to align with path heading
-                const Vec3 s = side () * halfWidth;
+                const Vector3 s = side () * halfWidth;
                 const float f = halfLength * 2;
                 annotationLine (p + s, p + s + (forward () * f), gBlack);
                 annotationLine (p - s, p - s + (forward () * f), gBlack);
@@ -1076,14 +1076,14 @@
             else
             {
                 // when there is a valid nearest obstacle position
-                const Vec3 obstacle = qqqLastNearestObstacle;
-                const Vec3 o = obstacle + (up () * 0.1f);
-                if (obstacle != Vec3::zero)
+                const Vector3 obstacle = qqqLastNearestObstacle;
+                const Vector3 o = obstacle + (up () * 0.1f);
+                if (obstacle != Vector3::ZERO)
                 {
                     // get offset, distance from obstacle to its image on path
                     float outside;
-                    const Vec3 onPath = mapPointToPointOnCenterLineAndOutside( *path, obstacle, outside );// path-&gt;mapPointToPath (obstacle, outside);
-                    const Vec3 offset = onPath - obstacle;
+                    const Vector3 onPath = mapPointToPointOnCenterLineAndOutside( *path, obstacle, outside );// path-&gt;mapPointToPath (obstacle, outside);
+                    const Vector3 offset = onPath - obstacle;
                     const float offsetDistance = offset.length();
 
                     // when the obstacle is inside the path tube
@@ -1104,7 +1104,7 @@
                             const bool usableHint = obstacleDistance&gt;farThreshold;
                             if (usableHint)
                             {
-                                const Vec3 q = p + (offset.normalize() * 5);
+                                const Vector3 q = p + (offset.normalisedCopy() * 5);
                                 annotationLine (p, q, gMagenta);
                                 annotationCircleOrDisk (0.4f, up(), o, gWhite,
                                                         12, false, false);
@@ -1116,36 +1116,36 @@
                 }
             }
             // otherwise, no hint
-            return Vec3::zero;
+            return Vector3::ZERO;
         }
 
 
         // like steerToAvoidObstacles, but based on a BinaryTerrainMap indicating
         // the possitions of impassible regions
         //
-        Vec3 steerToAvoidObstaclesOnMap (const float minTimeToCollision,
+        Vector3 steerToAvoidObstaclesOnMap (const float minTimeToCollision,
                                          const TerrainMap&amp; map)
         {
             return steerToAvoidObstaclesOnMap (minTimeToCollision,
                                                map,
-                                               Vec3::zero); // no steer hint
+                                               Vector3::ZERO); // no steer hint
         }
 
 
         // given a map of obstacles (currently a global, binary map) steer so as
         // to avoid collisions within the next minTimeToCollision seconds.
         //
-        Vec3 steerToAvoidObstaclesOnMap (const float minTimeToCollision,
+        Vector3 steerToAvoidObstaclesOnMap (const float minTimeToCollision,
                                          const TerrainMap&amp; map,
-                                         const Vec3&amp; steerHint)
+                                         const Vector3&amp; steerHint)
         {
             const float spacing = map.minSpacing() / 2;
             const float maxSide = radius();
             const float maxForward = minTimeToCollision * speed();
             const int maxSamples = (int) (maxForward / spacing);
-            const Vec3 step = forward () * spacing;
-            const Vec3 fOffset = position ();
-            Vec3 sOffset;
+            const Vector3 step = forward () * spacing;
+            const Vector3 fOffset = position ();
+            Vector3 sOffset;
             float s = spacing / 2;
 
             const int infinity = 9999; // qqq
@@ -1153,11 +1153,11 @@
             int nearestR = infinity;
             int nearestWL = infinity;
             int nearestWR = infinity;
-            Vec3 nearestO;
+            Vector3 nearestO;
             wingDrawFlagL = false;
             wingDrawFlagR = false;
 
-            const bool hintGiven = steerHint != Vec3::zero;
+            const bool hintGiven = steerHint != Vector3::ZERO;
             if (hintGiven &amp;&amp; !dtZero) hintGivenCount++;
             if (hintGiven) annotationCircleOrDisk (halfWidth * 0.9f, up(),
                                                    position () + (up () * 0.2f),
@@ -1167,8 +1167,8 @@
             QQQoaJustScraping = true;
 
             const float signedRadius = 1 / nonZeroCurvatureQQQ ();
-            const Vec3 localCenterOfCurvature = side () * signedRadius;
-            const Vec3 center = position () + localCenterOfCurvature;
+            const Vector3 localCenterOfCurvature = side () * signedRadius;
+            const Vector3 center = position () + localCenterOfCurvature;
             const float sign = signedRadius &lt; 0 ? 1.0f : -1.0f;
             const float arcRadius = signedRadius * -sign;
             const float twoPi = 2 * OPENSTEER_M_PI;
@@ -1185,8 +1185,8 @@
                 if ((speed() * minTimeToCollision) &gt; (circumference * fracLimit))
                 {
                     const float q = twoPi * fracLimit;
-                    const Vec3 fooz = position () - center;
-                    const Vec3 booz = fooz.rotateAboutGlobalY (sign * q);
+                    const Vector3 fooz = position () - center;
+                    const Vector3 booz = fooz.rotateAboutGlobalY (sign * q);
                     annotationLine (center, center + fooz, gRed);
                     annotationLine (center, center + booz, gRed);
                 }
@@ -1201,10 +1201,10 @@
             {
                 sOffset = side() * s;
                 s += spacing;
-                const Vec3 lOffset = fOffset + sOffset;
-                const Vec3 rOffset = fOffset - sOffset;
+                const Vector3 lOffset = fOffset + sOffset;
+                const Vector3 rOffset = fOffset - sOffset;
 
-                Vec3 lObsPos, rObsPos;
+                Vector3 lObsPos, rObsPos;
 
                 const int L = (curvedSteering ? 
                                (int) (scanObstacleMap (lOffset,
@@ -1265,7 +1265,7 @@
                 const int wingScans = 4;
                 // see duplicated code at: QQQ draw sensing &quot;wings&quot;
                 // QQQ should be a parameter of this method
-                const Vec3 wingWidth = side() * wingSlope () * maxForward;
+                const Vector3 wingWidth = side() * wingSlope () * maxForward;
 
                 const Color beforeColor (0.75f, 0.9f, 0.0f);  // for annotation
                 const Color afterColor  (0.9f,  0.5f, 0.0f);  // for annotation
@@ -1273,23 +1273,23 @@
                 for (int i=1; i&lt;=wingScans; i++)
                 {
                     const float fraction = (float)i / (float)wingScans;
-                    const Vec3 endside = sOffset + (wingWidth * fraction);
-                    const Vec3 corridorFront = forward() * maxForward;
+                    const Vector3 endside = sOffset + (wingWidth * fraction);
+                    const Vector3 corridorFront = forward() * maxForward;
 
                     // &quot;loop&quot; from -1 to 1
                     for (int j = -1; j &lt; 2; j+=2)
                     {
                         float k = (float)j; // prevent VC7.1 warning
-                        const Vec3 start = fOffset + (sOffset * k);
-                        const Vec3 end = fOffset + corridorFront + (endside * k);
-                        const Vec3 ray = end - start;
+                        const Vector3 start = fOffset + (sOffset * k);
+                        const Vector3 end = fOffset + corridorFront + (endside * k);
+                        const Vector3 ray = end - start;
                         const float rayLength = ray.length();
-                        const Vec3 step = ray * spacing / rayLength;
+                        const Vector3 step = ray * spacing / rayLength;
                         const int raySamples = (int) (rayLength / spacing);
                         const float endRadius =
                             wingSlope () * maxForward * fraction *
                             (signedRadius &lt; 0 ? 1 : -1) * (j==1?1:-1);
-                        Vec3 ignore;
+                        Vector3 ignore;
                         const int scan = (curvedSteering ?
                                           (int) (scanObstacleMap (start,
                                                                   center,
@@ -1349,14 +1349,14 @@
             // no obstacles found on path, return zero steering
             if (obstacleFreeC)
             {
-                qqqLastNearestObstacle = Vec3::zero;
+                qqqLastNearestObstacle = Vector3::ZERO;
                 annotationNoteOAClauseName (&quot;obstacleFreeC&quot;);
 
                 // qqq  this may be in the wrong place (what would be the right
                 // qqq  place?!) but I'm trying to say &quot;even if the path is
                 // qqq  clear, don't go too fast when driving between obstacles
                 if (obstacleFreeWL || obstacleFreeWR || relativeSpeed () &lt; 0.7f)
-                    return Vec3::zero;
+                    return Vector3::ZERO;
                 else
                     return -forward ();
             }
@@ -1368,7 +1368,7 @@
             {
                 annotationNoteOAClauseName (&quot;nearest obstacle is way out there&quot;);
                 annotationHintWasTaken ();
-                if (steerHint.dot(side())&gt;0) return side();else return -side();
+                if (steerHint.dotProduct(side())&gt;0) return side();else return -side();
             }
 
             // QQQ experiment 3-9-04
@@ -1404,7 +1404,7 @@
                 if (same &amp;&amp; hintGiven)
                 {
                     annotationHintWasTaken ();
-                    if (steerHint.dot(side())&gt;0) return side();else return -side();
+                    if (steerHint.dotProduct(side())&gt;0) return side();else return -side();
                 }
                 else
                 {
@@ -1420,7 +1420,7 @@
             {
                 annotationNoteOAClauseName (&quot;equallyClear&quot;);
                 annotationHintWasTaken ();
-                if (steerHint.dot(side()) &gt; 0) return side(); else return -side();
+                if (steerHint.dotProduct(side()) &gt; 0) return side(); else return -side();
             }
 
             // turn towards the side whose &quot;wing&quot; region is less cluttered
@@ -1434,18 +1434,18 @@
         // QQQ reconsider calling sequence
         // called when steerToAvoidObstaclesOnMap decides steering is required
         // (default action is to do nothing, layered classes can overload it)
-        // virtual void annotateAvoidObstaclesOnMap (const Vec3&amp; scanOrigin,
+        // virtual void annotateAvoidObstaclesOnMap (const Vector3&amp; scanOrigin,
         //                                           int scanIndex,
-        //                                           const Vec3&amp; scanStep)
+        //                                           const Vector3&amp; scanStep)
         // {
         // }
-        void annotateAvoidObstaclesOnMap (const Vec3&amp; scanOrigin,
+        void annotateAvoidObstaclesOnMap (const Vector3&amp; scanOrigin,
                                           int scanIndex,
-                                          const Vec3&amp; scanStep)
+                                          const Vector3&amp; scanStep)
         {
             if (scanIndex &gt; 0)
             {
-                const Vec3 hit = scanOrigin + (scanStep * (float) scanIndex);
+                const Vector3 hit = scanOrigin + (scanStep * (float) scanIndex);
                 annotationLine (scanOrigin, hit, Color (0.7f, 0.3f, 0.3f));
             }
         }
@@ -1480,9 +1480,9 @@
             if (!dtZero) hintTakenCount++;
 
             const float r = halfWidth * 0.9f;
-            const Vec3 ff = forward () * r;
-            const Vec3 ss = side () * r;
-            const Vec3 pp = position () + (up () * 0.2f);
+            const Vector3 ff = forward () * r;
+            const Vector3 ss = side () * r;
+            const Vector3 pp = position () + (up () * 0.2f);
             annotationLine (pp + ff + ss, pp - ff + ss, gWhite);
             annotationLine (pp - ff - ss, pp - ff + ss, gWhite);
             annotationLine (pp - ff - ss, pp + ff - ss, gWhite);
@@ -1505,29 +1505,29 @@
         //        return a &quot;scan results object&quot; with a flag for obstacle found,
         //        plus distant and position if so.
         //
-        float scanObstacleMap (const Vec3&amp; start,
-                               const Vec3&amp; center,
+        float scanObstacleMap (const Vector3&amp; start,
+                               const Vector3&amp; center,
                                const float arcAngle,
                                const int segments,
                                const float endRadiusChange,
                                const Color&amp; beforeColor,
                                const Color&amp; afterColor,
-                               Vec3&amp; returnObstaclePosition)
+                               Vector3&amp; returnObstaclePosition)
         {
             // &quot;spoke&quot; is initially the vector from center to start,
             // which is then rotated step by step around center
-            Vec3 spoke = start - center;
+            Vector3 spoke = start - center;
             // determine the angular step per segment
             const float step = arcAngle / segments;
             // store distance to, and position of first obstacle
             float obstacleDistance = 0;
-            returnObstaclePosition = Vec3::zero;
+            returnObstaclePosition = Vector3::ZERO;
             // for spiral &quot;ramps&quot; of changing radius
             const float startRadius = (endRadiusChange == 0) ? 0 : spoke.length(); 
 
             // traverse each segment along arc
             float sin=0, cos=0;
-            Vec3 oldPoint = start;
+            Vector3 oldPoint = start;
             bool obstacleFound = false;
             for (int i = 0; i &lt; segments; i++)
             {
@@ -1547,7 +1547,7 @@
 
                 // construct new scan point: center point, offset by rotated
                 // spoke (possibly adjusting the radius if endRadiusChange!=0)
-                const Vec3 newPoint = center + (spoke * adjust);
+                const Vector3 newPoint = center + (spoke * adjust);
 
                 // once an obstacle if found &quot;our work here is done&quot; -- continue
                 // to loop only for the sake of annotation (make that optional?)
@@ -1559,7 +1559,7 @@
                 {
                     // no obstacle found on this scan so far,
                     // scan map along current segment (a chord of the arc)
-                    const Vec3 offset = newPoint - oldPoint;
+                    const Vector3 offset = newPoint - oldPoint;
                     const float d2 = offset.length() * 2;
 
                     // when obstacle found: set flag, save distance and position
@@ -1591,25 +1591,25 @@
             const float predictTime = curvedSteering ? .75f : 1.3f; // seconds
             const float maxForward =
                 speed () * combinedLookAheadTime (predictTime, minDistance);
-            const Vec3 step = forward () * spacing;
+            const Vector3 step = forward () * spacing;
             float s = curvedSteering ? (spacing / 4) : (spacing / 2);
 
             const float signedRadius = 1 / nonZeroCurvatureQQQ ();
-            const Vec3 localCenterOfCurvature = side () * signedRadius;
-            const Vec3 center = position () + localCenterOfCurvature;
+            const Vector3 localCenterOfCurvature = side () * signedRadius;
+            const Vector3 center = position () + localCenterOfCurvature;
             const float sign = signedRadius &lt; 0 ? 1.0f : -1.0f;
             const float arcRadius = signedRadius * -sign;
             const float twoPi = 2 * OPENSTEER_M_PI;
             const float circumference = twoPi * arcRadius;
-            const Vec3 qqqLift (0, 0.2f, 0);
-            Vec3 ignore;
+            const Vector3 qqqLift (0, 0.2f, 0);
+            Vector3 ignore;
 
             // scan region ahead of vehicle
             while (s &lt; maxSide)
             {
-                const Vec3 sOffset = side() * s;
-                const Vec3 lOffset = position () + sOffset;
-                const Vec3 rOffset = position () - sOffset;
+                const Vector3 sOffset = side() * s;
+                const Vector3 lOffset = position () + sOffset;
+                const Vector3 rOffset = position () - sOffset;
                 const float bevel = 0.3f;
                 const float fraction = s / maxSide;
                 const float scanDist = (halfLength +
@@ -1647,7 +1647,7 @@
                 // annotation
                 if (! curvedSteering)
                 {
-                    const Vec3 d (step * (float) samples);
+                    const Vector3 d (step * (float) samples);
                     annotationLine (lOffset, lOffset + d, gWhite);
                     annotationLine (rOffset, rOffset + d, gWhite);
                 }
@@ -1665,7 +1665,7 @@
         //
         // this should be const, but easier for now to ignore that
 
-        Vec3 predictFuturePosition (const float predictionTime) const
+        Vector3 predictFuturePosition (const float predictionTime) const
         {
             if (curvedSteering)
             {
@@ -1675,8 +1675,8 @@
                 // QQQ and now, worse, I rearranged it to try the &quot;limit arc
                 // QQQ angle&quot; trick
                 const float signedRadius = 1 / nonZeroCurvatureQQQ ();
-                const Vec3 localCenterOfCurvature = side () * signedRadius;
-                const Vec3 center = position () + localCenterOfCurvature;
+                const Vector3 localCenterOfCurvature = side () * signedRadius;
+                const Vector3 center = position () + localCenterOfCurvature;
                 const float sign = signedRadius &lt; 0 ? 1.0f : -1.0f;
                 const float arcRadius = signedRadius * -sign;
                 const float twoPi = 2 * OPENSTEER_M_PI;
@@ -1686,9 +1686,9 @@
                                                         circumference * 0.25f);
                 const float arcAngle = twoPi * arcLength / circumference;
 
-                const Vec3 spoke = position () - center;
-                const Vec3 newSpoke = spoke.rotateAboutGlobalY (arcAngle);
-                const Vec3 prediction = newSpoke + center;
+                const Vector3 spoke = position () - center;
+                const Vector3 newSpoke = spoke.rotateAboutGlobalY (arcAngle);
+                const Vector3 prediction = newSpoke + center;
 
                 // QQQ unify with annotatePathFollowing
                 const Color futurePositionColor (0.5f, 0.5f, 0.6f);
@@ -1732,7 +1732,7 @@
         //
         // and now its been modified again for curvature-based prediction
         //
-        Vec3 steerToFollowPath (const int direction,
+        Vector3 steerToFollowPath (const int direction,
                                 const float predictionTime,
                                 GCRoute&amp; path)
         {
@@ -1743,7 +1743,7 @@
         }
 
 
-        Vec3 steerToFollowPathLinear (const int direction,
+        Vector3 steerToFollowPathLinear (const int direction,
                                       const float predictionTime,
                                       GCRoute&amp; path)
         {
@@ -1751,26 +1751,26 @@
             const float pathDistanceOffset = direction * predictionTime * speed();
 
             // predict our future position
-            const Vec3 futurePosition = predictFuturePosition (predictionTime);
+            const Vector3 futurePosition = predictFuturePosition (predictionTime);
 
             // measure distance along path of our current and predicted positions
             const float nowPathDistance =
                 path.mapPointToPathDistance (position ());
 
             // are we facing in the correction direction?
-            const Vec3 pathHeading = mapPointToTangent( path, position() ) * static_cast&lt; float &gt;( direction );// path.tangentAt(position()) * (float)direction;
-            const bool correctDirection = pathHeading.dot (forward ()) &gt; 0;
+            const Vector3 pathHeading = mapPointToTangent( path, position() ) * static_cast&lt; float &gt;( direction );// path.tangentAt(position()) * (float)direction;
+            const bool correctDirection = pathHeading.dotProduct(forward ()) &gt; 0;
 
             // find the point on the path nearest the predicted future position
             // XXX need to improve calling sequence, maybe change to return a
             // XXX special path-defined object which includes two Vec3s and a 
             // XXX bool (onPath,tangent (ignored), withinPath)
             float futureOutside;
-            const Vec3 onPath = mapPointToPointOnCenterLineAndOutside( path, futurePosition, futureOutside ); // path.mapPointToPath (futurePosition,futureOutside);
+            const Vector3 onPath = mapPointToPointOnCenterLineAndOutside( path, futurePosition, futureOutside ); // path.mapPointToPath (futurePosition,futureOutside);
 
             // determine if we are currently inside the path tube
             float nowOutside;
-            const Vec3 nowOnPath = mapPointToPointOnCenterLineAndOutside( path, position(), nowOutside );  // path.mapPointToPath (position (), nowOutside);
+            const Vector3 nowOnPath = mapPointToPointOnCenterLineAndOutside( path, position(), nowOutside );  // path.mapPointToPath (position (), nowOutside);
 
             // no steering is required if our present and future positions are
             // inside the path tube and we are facing in the correct direction
@@ -1779,7 +1779,7 @@
             if (whollyInside &amp;&amp; correctDirection)
             {
                 // all is well, return zero steering
-                return Vec3::zero;
+                return Vector3::ZERO;
             }
             else
             {
@@ -1789,7 +1789,7 @@
                 const float targetPathDistance = (nowPathDistance + 
                                                   (pathDistanceOffset *
                                                    (correctDirection ? 1 : 0.1f)));
-                Vec3 target = path.mapPathDistanceToPoint (targetPathDistance);
+                Vector3 target = path.mapPathDistanceToPoint (targetPathDistance);
 
 
                 // if we are on one segment and target is on the next segment and
@@ -1799,12 +1799,12 @@
                 const int it =  static_cast&lt; int &gt;( mapPointToSegmentIndex( path, target ) ); // path.indexOfNearestSegment (target);
                 // Because polyline paths have a constant tangent along a segment
                 // just set the distance along the segment to @c 0.0f.
-                Vec3 const ipTangent = path.mapSegmentDistanceToTangent( ip, 0.0f );
+                Vector3 const ipTangent = path.mapSegmentDistanceToTangent( ip, 0.0f );
                 // Because polyline paths have a constant tangent along a segment
                 // just set the distance along the segment to @c 0.0f.
-                Vec3 const itTangent = path.mapSegmentDistanceToTangent( it, 0.0f );
+                Vector3 const itTangent = path.mapSegmentDistanceToTangent( it, 0.0f );
                 if (((ip + direction) == it) &amp;&amp;
-                    ( /* path.dotSegmentUnitTangents (it, ip) */  itTangent.dot( ipTangent ) &lt; -0.1f ) )
+                    ( /* path.dotSegmentUnitTangents (it, ip) */  itTangent.dotProduct( ipTangent ) &lt; -0.1f ) )
                 {
                     const float newTargetPathDistance =
                         nowPathDistance + (pathDistanceOffset * 2);
@@ -1818,7 +1818,7 @@
                 if (nowOutside &gt; 0) return steerForSeek (nowOnPath);
 
                 // steering to seek target on path
-                const Vec3 seek = steerForSeek (target).truncateLength(maxForce());
+                const Vector3 seek = steerForSeek (target).truncateLength(maxForce());
 
                 // return that seek steering -- except when we are heading off
                 // the path (currently on path and future position is off path)
@@ -1838,25 +1838,25 @@
         // QQQ this does not handle the case when we AND futurePosition
         // QQQ are outside, say when approach the path from far away
         //
-        Vec3 steerToFollowPathCurve (const int direction,
+        Vector3 steerToFollowPathCurve (const int direction,
                                      const float predictionTime,
                                      GCRoute&amp; path)
         {
             // predict our future position (based on current curvature and speed)
-            const Vec3 futurePosition = predictFuturePosition (predictionTime);
+            const Vector3 futurePosition = predictFuturePosition (predictionTime);
             // find the point on the path nearest the predicted future position
             float futureOutside;
-            const Vec3 onPath =  mapPointToPointOnCenterLineAndOutside( path, futurePosition, futureOutside ); // path.mapPointToPath (futurePosition,futureOutside);
-            const Vec3 pathHeading =  mapPointAndDirectionToTangent( path, onPath, direction ); // path.tangentAt (onPath, direction);
-            const Vec3 rawBraking = forward () * maxForce () * -1;
-            const Vec3 braking = ((futureOutside &lt; 0) ? Vec3::zero : rawBraking);
+            const Vector3 onPath =  mapPointToPointOnCenterLineAndOutside( path, futurePosition, futureOutside ); // path.mapPointToPath (futurePosition,futureOutside);
+            const Vector3 pathHeading =  mapPointAndDirectionToTangent( path, onPath, direction ); // path.tangentAt (onPath, direction);
+            const Vector3 rawBraking = forward () * maxForce () * -1;
+            const Vector3 braking = ((futureOutside &lt; 0) ? Vector3::ZERO : rawBraking);
             //qqq experimental wrong-way-fixer
             float nowOutside;
-            Vec3 nowTangent;
-            const Vec3 p = position ();
-            const Vec3 nowOnPath = path.mapPointToPath (p, nowTangent, nowOutside);
+            Vector3 nowTangent;
+            const Vector3 p = position ();
+            const Vector3 nowOnPath = path.mapPointToPath (p, nowTangent, nowOutside);
             nowTangent *= (float)direction;
-            const float alignedness = nowTangent.dot (forward ());
+            const float alignedness = nowTangent.dotProduct(forward ());
 
             // facing the wrong way?
             if (alignedness &lt; 0)
@@ -1866,8 +1866,8 @@
                 // if nearly anti-parallel
                 if (alignedness &lt; -0.707f)
                 {
-                    const Vec3 towardCenter = nowOnPath - p;
-                    const Vec3 turn = (towardCenter.dot (side ()) &gt; 0 ?
+                    const Vector3 towardCenter = nowOnPath - p;
+                    const Vector3 turn = (towardCenter.dotProduct(side ()) &gt; 0 ?
                                        side () * maxForce () :
                                        side () * maxForce () * -1);
                     return (turn + rawBraking);
@@ -1883,7 +1883,7 @@
             if (futureOutside &lt; -(radius () + 1.0f)) //QQQ
             {
                 // then no steering is required
-                return Vec3::zero;
+                return Vector3::ZERO;
             }
             else
             {
@@ -1904,9 +1904,9 @@
                 {
                     // otherwise steer away from the side of the path we
                     // are heading for
-                    const Vec3 pathSide = localRotateForwardToSide (pathHeading);
-                    const Vec3 towardFP = futurePosition - onPath;
-                    const float whichSide = (pathSide.dot(towardFP)&lt;0)?1.0f :-1.0f;
+                    const Vector3 pathSide = localRotateForwardToSide (pathHeading);
+                    const Vector3 towardFP = futurePosition - onPath;
+                    const float whichSide = (pathSide.dotProduct(towardFP)&lt;0)?1.0f :-1.0f;
                     return (side () * maxForce () * whichSide) + braking;
                 }
             }
@@ -1915,7 +1915,7 @@
 
         void perFrameAnnotation (void)
         {
-            const Vec3 p = position();
+            const Vector3 p = position();
 
             // draw the circular collision boundary
             annotationCircleOrDisk (radius(), up(), p, gBlack, 32, false, false);
@@ -1926,22 +1926,22 @@
                 const float corLength = speed() * lookAheadTimeOA ();
                 if (corLength &gt; halfLength)
                 {
-                    const Vec3 corFront = forward() * corLength;
-                    const Vec3 corBack = Vec3::zero; // (was bbFront)
-                    const Vec3 corSide  = side() * radius();
-                    const Vec3 c1 = p + corSide + corBack;
-                    const Vec3 c2 = p + corSide + corFront;
-                    const Vec3 c3 = p - corSide + corFront;
-                    const Vec3 c4 = p - corSide + corBack;
-                    const Color color = ((annotateAvoid!=Vec3::zero)?gRed:gYellow);
+                    const Vector3 corFront = forward() * corLength;
+                    const Vector3 corBack = Vector3::ZERO; // (was bbFront)
+                    const Vector3 corSide  = side() * radius();
+                    const Vector3 c1 = p + corSide + corBack;
+                    const Vector3 c2 = p + corSide + corFront;
+                    const Vector3 c3 = p - corSide + corFront;
+                    const Vector3 c4 = p - corSide + corBack;
+                    const Color color = ((annotateAvoid!=Vector3::ZERO)?gRed:gYellow);
                     annotationLine (c1, c2, color);
                     annotationLine (c2, c3, color);
                     annotationLine (c3, c4, color);
 
                     // draw sensing &quot;wings&quot;
-                    const Vec3 wingWidth = side () * wingSlope () * corLength;
-                    const Vec3 wingTipL = c2 + wingWidth;
-                    const Vec3 wingTipR = c3 - wingWidth;
+                    const Vector3 wingWidth = side () * wingSlope () * corLength;
+                    const Vector3 wingTipL = c2 + wingWidth;
+                    const Vector3 wingTipR = c3 - wingWidth;
                     const Color wingColor (gOrange);
                     if (wingDrawFlagL) annotationLine (c2, wingTipL, wingColor);
                     if (wingDrawFlagL) annotationLine (c1, wingTipL, wingColor);
@@ -1951,8 +1951,8 @@
             }
 
             // annotate steering acceleration
-            const Vec3 above = position () + Vec3 (0, 0.2f, 0);
-            const Vec3 accel = smoothedAcceleration () * 5 / maxForce ();
+            const Vector3 above = position () + Vector3 (0, 0.2f, 0);
+            const Vector3 accel = smoothedAcceleration () * 5 / maxForce ();
             const Color aColor (0.4f, 0.4f, 0.8f);
             annotationLine (above, above + accel, aColor);
         }
@@ -1967,10 +1967,10 @@
             if (collisionDetected)   bodyColor = gRed;
 
             // draw vehicle's bounding box on gound plane (its &quot;shadow&quot;)
-            const Vec3 p = position();
-            const Vec3 bbSide = side() * halfWidth;
-            const Vec3 bbFront = forward() * halfLength;
-            const Vec3 bbHeight (0, 0.1f, 0);
+            const Vector3 p = position();
+            const Vector3 bbSide = side() * halfWidth;
+            const Vector3 bbFront = forward() * halfLength;
+            const Vector3 bbHeight (0, 0.1f, 0);
             drawQuadrangle (p - bbFront + bbSide + bbHeight,
                             p + bbFront + bbSide + bbHeight,
                             p + bbFront - bbSide + bbHeight,
@@ -1984,9 +1984,9 @@
 
 
         // called when steerToFollowPath decides steering is required
-        void annotatePathFollowing (const Vec3&amp; future,
-                                    const Vec3&amp; onPath,
-                                    const Vec3&amp; target,
+        void annotatePathFollowing (const Vector3&amp; future,
+                                    const Vector3&amp; onPath,
+                                    const Vector3&amp; target,
                                     const float outside)
         {
             const Color toTargetColor (gGreen * 0.6f);
@@ -2006,9 +2006,9 @@
             // indicates the boundary of the tube.
 
             const float o = outside + radius () + (curvedSteering ? 1.0f : 0.0f);
-            const Vec3 boundaryOffset = ((onPath - future).normalize() * o);
+            const Vector3 boundaryOffset = ((onPath - future).normalisedCopy() * o);
 
-            const Vec3 onPathBoundary = future + boundaryOffset;
+            const Vector3 onPathBoundary = future + boundaryOffset;
             annotationLine (onPath, onPathBoundary, insidePathColor);
             annotationLine (onPathBoundary, future, outsidePathColor);
         }
@@ -2019,9 +2019,9 @@
     #ifdef OLDTERRAINMAP
             const float xs = map-&gt;xSize/(float)map-&gt;resolution;
             const float zs = map-&gt;zSize/(float)map-&gt;resolution;
-            const Vec3 alongRow (xs, 0, 0);
-            const Vec3 nextRow (-map-&gt;xSize, 0, zs);
-            Vec3 g ((map-&gt;xSize - xs) / -2, 0, (map-&gt;zSize - zs) / -2);
+            const Vector3 alongRow (xs, 0, 0);
+            const Vector3 nextRow (-map-&gt;xSize, 0, zs);
+            Vector3 g ((map-&gt;xSize - xs) / -2, 0, (map-&gt;zSize - zs) / -2);
             g += map-&gt;center;
             for (int j = 0; j &lt; map-&gt;resolution; j++)
             {
@@ -2030,23 +2030,23 @@
                     if (map-&gt;getMapBit (i, j))
                     {
                         // spikes
-                        // const Vec3 spikeTop (0, 5.0f, 0);
+                        // const Vector3 spikeTop (0, 5.0f, 0);
                         // drawLine (g, g+spikeTop, gWhite);
 
                         // squares
                         const float rockHeight = 0;
-                        const Vec3 v1 (+xs/2, rockHeight, +zs/2);
-                        const Vec3 v2 (+xs/2, rockHeight, -zs/2);
-                        const Vec3 v3 (-xs/2, rockHeight, -zs/2);
-                        const Vec3 v4 (-xs/2, rockHeight, +zs/2);
-                        // const Vec3 redRockColor (0.6f, 0.1f, 0.0f);
+                        const Vector3 v1 (+xs/2, rockHeight, +zs/2);
+                        const Vector3 v2 (+xs/2, rockHeight, -zs/2);
+                        const Vector3 v3 (-xs/2, rockHeight, -zs/2);
+                        const Vector3 v4 (-xs/2, rockHeight, +zs/2);
+                        // const Vector3 redRockColor (0.6f, 0.1f, 0.0f);
                         const Color orangeRockColor (0.5f, 0.2f, 0.0f);
                         drawQuadrangle (g+v1, g+v2, g+v3, g+v4, orangeRockColor);
 
                         // pyramids
-                        // const Vec3 top (0, xs/2, 0);
-                        // const Vec3 redRockColor (0.6f, 0.1f, 0.0f);
-                        // const Vec3 orangeRockColor (0.5f, 0.2f, 0.0f);
+                        // const Vector3 top (0, xs/2, 0);
+                        // const Vector3 redRockColor (0.6f, 0.1f, 0.0f);
+                        // const Vector3 orangeRockColor (0.5f, 0.2f, 0.0f);
                         // drawTriangle (g+v1, g+v2, g+top, redRockColor);
                         // drawTriangle (g+v2, g+v3, g+top, orangeRockColor);
                         // drawTriangle (g+v3, g+v4, g+top, redRockColor);
@@ -2065,7 +2065,7 @@
          * (QQQ this should probably be a method of Path (or a
          * closely-related utility function) in which case should pass
          * color in, certainly shouldn't be recomputing it each draw)
-         * @todo Add a &lt;code&gt;Vec3 const* points() const&lt;/code&gt; member function to
+         * @todo Add a &lt;code&gt;Vector3 const* points() const&lt;/code&gt; member function to
          *       SegmentedPath, etc. to allow for faster point access?
          */
         void drawPath (void)
@@ -2074,11 +2074,11 @@
             const Color sandColor (0.8f, 0.7f, 0.5f);
             const Color color = interpolate (0.1f, sandColor, pathColor);
 
-            const Vec3 down (0, -0.1f, 0);
+            const Vector3 down (0, -0.1f, 0);
             for ( OpenSteer::size_t i = 1; i &lt; path-&gt;pointCount(); ++i )
             {
-                const Vec3 endPoint0 = path-&gt;point( i ) + down;
-                const Vec3 endPoint1 = path-&gt;point( i - 1 ) + down;
+                const Vector3 endPoint0 = path-&gt;point( i ) + down;
+                const Vector3 endPoint1 = path-&gt;point( i - 1 ) + down;
 
                 const float legWidth = path-&gt;segmentRadius( i - 1 );
 
@@ -2099,30 +2099,30 @@
             const float o = worldSize * 2;    // outside of the sand
 
             // construction vectors
-            const Vec3 p (0,   0, m);
-            const Vec3 q (0,   0, m-n);
-            const Vec3 r (-m,  0, 0);
-            const Vec3 s (2*n, 0, 0);
-            const Vec3 t (o,   0, 0);
-            const Vec3 u (-o,  0, 0);
-            const Vec3 v (n,   0, 0);
-            const Vec3 w (0, 0, 0);
+            const Vector3 p (0,   0, m);
+            const Vector3 q (0,   0, m-n);
+            const Vector3 r (-m,  0, 0);
+            const Vector3 s (2*n, 0, 0);
+            const Vector3 t (o,   0, 0);
+            const Vector3 u (-o,  0, 0);
+            const Vector3 v (n,   0, 0);
+            const Vector3 w (0, 0, 0);
 
 
             // path vertices
-            const Vec3 a (t-p);
-            const Vec3 b (s+v-p);
-            const Vec3 c (s-q);
-            const Vec3 d (s+q);
-            const Vec3 e (s-v+p);
-            const Vec3 f (p-w);
-            const Vec3 g (r-w);
-            const Vec3 h (-p-w);
-            const Vec3 i (u-p);
+            const Vector3 a (t-p);
+            const Vector3 b (s+v-p);
+            const Vector3 c (s-q);
+            const Vector3 d (s+q);
+            const Vector3 e (s-v+p);
+            const Vector3 f (p-w);
+            const Vector3 g (r-w);
+            const Vector3 h (-p-w);
+            const Vector3 i (u-p);
 
             // return Path object
             const int pathPointCount = 9;
-            const Vec3 pathPoints[pathPointCount] = {a, b, c, d, e, f, g, h, i};
+            const Vector3 pathPoints[pathPointCount] = {a, b, c, d, e, f, g, h, i};
             const float k = 10.0f;
             const float pathRadii[pathPointCount] = {k, k, k, k, k, k, k, k, k};
             return new GCRoute (pathPointCount, pathPoints, pathRadii, false);
@@ -2132,7 +2132,7 @@
         TerrainMap* makeMap (void)
         {
     #ifdef OLDTERRAINMAP
-            return new TerrainMap (Vec3::zero,
+            return new TerrainMap (Vector3::ZERO,
                                    worldSize,
                                    worldSize,
                                    (int)worldSize + 1);
@@ -2156,7 +2156,7 @@
                     lapsStarted++;
                     lapsFinished++;
 
-                    const Vec3 camOffsetBefore =
+                    const Vector3 camOffsetBefore =
                         OpenSteerDemo::camera.position() - position ();
 
                     // set position on other side of the map (set new X coordinate)
@@ -2214,7 +2214,7 @@
         // (say for example we were going around a circle with radius &gt; 10)
         bool weAreGoingInCircles (void)
         {
-            const Vec3 offset = smoothedPosition () - position ();
+            const Vector3 offset = smoothedPosition () - position ();
             return offset.length () &lt; 10;
         }
 
@@ -2251,8 +2251,8 @@
         {
             if (demoSelect == 2)
             {
-                const Vec3 bbSide = side () * halfWidth;
-                const Vec3 bbFront = forward () * halfLength;
+                const Vector3 bbSide = side () * halfWidth;
+                const Vector3 bbFront = forward () * halfLength;
                 return ( /* path-&gt;isInsidePath (position () - bbFront + bbSide) */ isInsidePathway( *path, position () - bbFront + bbSide ) &amp;&amp;
                          /* path-&gt;isInsidePath (position () + bbFront + bbSide) */ isInsidePathway( *path, position () + bbFront + bbSide ) &amp;&amp;
                          /* path-&gt;isInsidePath (position () + bbFront - bbSide) */ isInsidePathway( *path, position () + bbFront - bbSide ) &amp;&amp;
@@ -2262,15 +2262,15 @@
         }
 
 
-        Vec3 convertAbsoluteToIncrementalSteering (const Vec3&amp; absolute,
+        Vector3 convertAbsoluteToIncrementalSteering (const Vector3&amp; absolute,
                                                    const float elapsedTime)
         {
-            const Vec3 curved = convertLinearToCurvedSpaceGlobal (absolute);
+            const Vector3 curved = convertLinearToCurvedSpaceGlobal (absolute);
             blendIntoAccumulator (elapsedTime * 8.0f, curved, currentSteering);
             {
                 // annotation
-                const Vec3 u (0, 0.5, 0);
-                const Vec3 p = position ();
+                const Vector3 u (0, 0.5, 0);
+                const Vector3 p = position ();
                 annotationLine (p + u, p + u + absolute, gRed);
                 annotationLine (p + u, p + u + curved, gYellow);
                 annotationLine (p + u*2, p + u*2 + currentSteering, gGreen);
@@ -2287,16 +2287,16 @@
         // centered on the current center of curvature and passing through the
         // vehicle's position().
         //
-        Vec3 convertLinearToCurvedSpaceGlobal (const Vec3&amp; linear)
+        Vector3 convertLinearToCurvedSpaceGlobal (const Vector3&amp; linear)
         {
-            const Vec3 trimmedLinear = linear.truncateLength (maxForce ());
+            const Vector3 trimmedLinear = linear.truncateLength (maxForce ());
 
             // ---------- this block imported from steerToAvoidObstaclesOnMap
             const float signedRadius = 1 / (nonZeroCurvatureQQQ() /*QQQ*/ * 1);
-            const Vec3 localCenterOfCurvature = side () * signedRadius;
-            const Vec3 center = position () + localCenterOfCurvature;
+            const Vector3 localCenterOfCurvature = side () * signedRadius;
+            const Vector3 center = position () + localCenterOfCurvature;
             const float sign = signedRadius &lt; 0 ? 1.0f : -1.0f;
-            const float arcLength = trimmedLinear.dot (forward ());
+            const float arcLength = trimmedLinear.dotProduct(forward ());
             //
             const float arcRadius = signedRadius * -sign;
             const float twoPi = 2 * OPENSTEER_M_PI;
@@ -2306,17 +2306,17 @@
 
             // ---------- this block imported from scanObstacleMap
             // vector from center of curvature to position of vehicle
-            const Vec3 initialSpoke = position () - center;
+            const Vector3 initialSpoke = position () - center;
             // rotate by signed arc angle
-            const Vec3 spoke = initialSpoke.rotateAboutGlobalY (arcAngle * sign);
+            const Vector3 spoke = initialSpoke.rotateAboutGlobalY (arcAngle * sign);
             // ---------- this block imported from scanObstacleMap
 
-            const Vec3 fromCenter = -localCenterOfCurvature.normalize ();
-            const float dRadius = trimmedLinear.dot (fromCenter);
+            const Vector3 fromCenter = -localCenterOfCurvature.normalisedCopy();
+            const float dRadius = trimmedLinear.dotProduct(fromCenter);
             const float radiusChangeFactor = (dRadius + arcRadius) / arcRadius;
-            const Vec3 resultLocation = center + (spoke * radiusChangeFactor);
+            const Vector3 resultLocation = center + (spoke * radiusChangeFactor);
             {
-                const Vec3 center = position () + localCenterOfCurvature;
+                const Vector3 center = position () + localCenterOfCurvature;
                 annotationXZArc (position (), center, speed () * sign * -3,
                                  20, gWhite);
             }
@@ -2330,7 +2330,7 @@
         float minimumTurningRadius () const {return 5.0f;}
 
 
-        Vec3 adjustSteeringForMinimumTurningRadius (const Vec3&amp; steering)
+        Vector3 adjustSteeringForMinimumTurningRadius (const Vector3&amp; steering)
         {
             const float maxCurvature = 1 / (minimumTurningRadius () * 1.1f);
 
@@ -2343,13 +2343,13 @@
                 // minimum turing radius
                 const float signedRadius = 1 / nonZeroCurvatureQQQ ();
                 const float sign = signedRadius &lt; 0 ? 1.0f : -1.0f;
-                const Vec3 thrust = steering.parallelComponent (forward ());
-                const Vec3 trimmed = thrust.truncateLength (maxForce ());
-                const Vec3 widenOut = side () * maxForce () * sign;
+                const Vector3 thrust = steering.parallelComponent (forward ());
+                const Vector3 trimmed = thrust.truncateLength (maxForce ());
+                const Vector3 widenOut = side () * maxForce () * sign;
                 {
                     // annotation
-                    const Vec3 localCenterOfCurvature = side () * signedRadius;
-                    const Vec3 center = position () + localCenterOfCurvature;
+                    const Vector3 localCenterOfCurvature = side () * signedRadius;
+                    const Vector3 center = position () + localCenterOfCurvature;
                     annotationCircleOrDisk (minimumTurningRadius (), up(),
                                             center, gBlue, 40, false, false);
                 }
@@ -2404,9 +2404,9 @@
                 else
                 {
                     // heading (unit tangent) of the path segment of interest
-                    const Vec3 pathHeading =  mapPointAndDirectionToTangent( *path, position(), pathFollowDirection ); // path-&gt;tangentAt (position (), pathFollowDirection);
+                    const Vector3 pathHeading =  mapPointAndDirectionToTangent( *path, position(), pathFollowDirection ); // path-&gt;tangentAt (position (), pathFollowDirection);
                     // measure how parallel we are to the path
-                    const float parallelness = pathHeading.dot (forward ());
+                    const float parallelness = pathHeading.dotProduct(forward ());
 
                     // determine relative speed for this heading
                     const float mw = 0.2f;
@@ -2425,24 +2425,24 @@
         // xxx library candidate
         // xxx assumes (but does not check or enforce) heading is unit length
         //
-        Vec3 steerTowardHeading (const Vec3&amp; desiredGlobalHeading)
+        Vector3 steerTowardHeading (const Vector3&amp; desiredGlobalHeading)
         {
-            const Vec3 headingError = desiredGlobalHeading - forward ();
-            return headingError.normalize () * maxForce ();
+            const Vector3 headingError = desiredGlobalHeading - forward ();
+            return headingError.normalisedCopy() * maxForce ();
         }
 
 
         // XXX this should eventually be in a library, make it a first
         // XXX class annotation queue, tie in with drawXZArc
-        void annotationXZArc (const Vec3&amp; start,
-                              const Vec3&amp; center,
+        void annotationXZArc (const Vector3&amp; start,
+                              const Vector3&amp; center,
                               const float arcLength,
                               const int segments,
                               const Color&amp; color) const
         {
             // &quot;spoke&quot; is initially the vector from center to start,
             // it is then rotated around its tail
-            Vec3 spoke = start - center;
+            Vector3 spoke = start - center;
 
             // determine the angular step per segment
             const float radius = spoke.length ();
@@ -2455,7 +2455,7 @@
             float sin=0, cos=0;
             for (int i = 0; i &lt; segments; i++)
             {
-                const Vec3 old = spoke + center;
+                const Vector3 old = spoke + center;
 
                 // rotate point to next step around circle
                 spoke = spoke.rotateAboutGlobalY (step, sin, cos);
@@ -2500,7 +2500,7 @@
         bool dtZero;
 
         // state saved for annotation
-        Vec3 annotateAvoid;
+        Vector3 annotateAvoid;
         bool wingDrawFlagL, wingDrawFlagR;
 
         // QQQ first pass at detecting &quot;stuck&quot; state
@@ -2509,7 +2509,7 @@
         int stuckCycleCount;
         int stuckOffPathCount;
 
-        Vec3 qqqLastNearestObstacle;
+        Vector3 qqqLastNearestObstacle;
 
         int lapsStarted;
         int lapsFinished;
@@ -2523,7 +2523,7 @@
 
         // for &quot;curvature-based incremental steering&quot; -- contains the current
         // steering into which new incremental steering is blended
-        Vec3 currentSteering;
+        Vector3 currentSteering;
 
         // use curved prediction and incremental steering:
         bool curvedSteering;
@@ -2595,9 +2595,9 @@
             // &quot;look straight down at vehicle&quot; camera mode parameters
             OpenSteerDemo::camera.lookdownDistance = 50;
             // &quot;static&quot; camera mode parameters
-            OpenSteerDemo::camera.fixedPosition.set (145, 145, 145);
-            OpenSteerDemo::camera.fixedTarget.set (40, 0, 40);
-            OpenSteerDemo::camera.fixedUp = Vec3::up;
+            OpenSteerDemo::camera.fixedPosition = Vector3(145, 145, 145);
+            OpenSteerDemo::camera.fixedTarget = Vector3(40, 0, 40);
+            OpenSteerDemo::camera.fixedUp = Vector3::UNIT_Y;
 
             // reset this plugin
             reset ();
@@ -2629,10 +2629,10 @@
             // draw &quot;ground plane&quot;  (make it 4x map size)
             const float s = MapDriver::worldSize * 2;
             const float u = -0.2f;
-            drawQuadrangle (Vec3 (+s, u, +s),
-                            Vec3 (+s, u, -s),
-                            Vec3 (-s, u, -s),
-                            Vec3 (-s, u, +s),
+            drawQuadrangle (Vector3 (+s, u, +s),
+                            Vector3 (+s, u, -s),
+                            Vector3 (-s, u, -s),
+                            Vector3 (-s, u, +s),
                             Color (0.8f, 0.7f, 0.5f)); // &quot;sand&quot;
 
             // draw map and path
@@ -2644,8 +2644,8 @@
 
             // QQQ mark origin to help spot artifacts
             const float tick = 2;
-            drawLine (Vec3 (tick, 0, 0), Vec3 (-tick, 0, 0), gGreen);
-            drawLine (Vec3 (0, 0, tick), Vec3 (0, 0, -tick), gGreen);
+            drawLine (Vector3 (tick, 0, 0), Vector3 (-tick, 0, 0), gGreen);
+            drawLine (Vector3 (0, 0, tick), Vector3 (0, 0, -tick), gGreen);
 
             // compute conversion factor miles-per-hour to meters-per-second
             const float metersPerMile = 1609.344f;
@@ -2718,7 +2718,7 @@
             qqqRange (&quot;WL &quot;, vehicle-&gt;savedNearestWL, status);
             status &lt;&lt; std::ends;
             const float h = drawGetWindowHeight ();
-            const Vec3 screenLocation (10, h-50, 0);
+            const Vector3 screenLocation (10, h-50, 0);
             const Color color (0.15f, 0.15f, 0.5f);
             draw2dTextAt2dLocation (status, screenLocation, color, drawGetWindowWidth(), drawGetWindowHeight());
 
@@ -2731,21 +2731,21 @@
 
                 // limit tick mark
                 const float l = vehicle-&gt;annoteMaxRelSpeed;
-                draw2dLine (Vec3 (m+(f*l), v-3, 0), Vec3 (m+(f*l),v+3, 0), gBlack, drawGetWindowWidth(), drawGetWindowHeight());
+                draw2dLine (Vector3 (m+(f*l), v-3, 0), Vector3 (m+(f*l),v+3, 0), gBlack, drawGetWindowWidth(), drawGetWindowHeight());
                 // two &quot;inverse speedometers&quot; showing limits due to curvature and
                 // path alignment
                 if (l!=0)
                 {
                     const float c = vehicle-&gt;annoteMaxRelSpeedCurve;
                     const float p = vehicle-&gt;annoteMaxRelSpeedPath;
-                    draw2dLine (Vec3(m+(f*c), v+1, 0), Vec3(w-m, v+1, 0), gRed, drawGetWindowWidth(), drawGetWindowHeight());
-                    draw2dLine (Vec3(m+(f*p), v-2, 0), Vec3(w-m, v-1, 0), gGreen, drawGetWindowWidth(), drawGetWindowHeight());
+                    draw2dLine (Vector3(m+(f*c), v+1, 0), Vector3(w-m, v+1, 0), gRed, drawGetWindowWidth(), drawGetWindowHeight());
+                    draw2dLine (Vector3(m+(f*p), v-2, 0), Vector3(w-m, v-1, 0), gGreen, drawGetWindowWidth(), drawGetWindowHeight());
                 }
                 // speedometer: horizontal line with length proportional to speed
-                draw2dLine (Vec3 (m, v, 0), Vec3 (m + (f * s), v, 0), gWhite, drawGetWindowWidth(), drawGetWindowHeight());
+                draw2dLine (Vector3 (m, v, 0), Vector3 (m + (f * s), v, 0), gWhite, drawGetWindowWidth(), drawGetWindowHeight());
                 // min and max tick marks
-                draw2dLine (Vec3 (m,       v, 0), Vec3 (m,      v-2, 0), gWhite, drawGetWindowWidth(), drawGetWindowHeight());
-                draw2dLine (Vec3 (w-m,     v, 0), Vec3 (w-m,    v-2, 0), gWhite, drawGetWindowWidth(), drawGetWindowHeight());
+                draw2dLine (Vector3 (m,       v, 0), Vector3 (m,      v-2, 0), gWhite, drawGetWindowWidth(), drawGetWindowHeight());
+                draw2dLine (Vector3 (w-m,     v, 0), Vector3 (w-m,    v-2, 0), gWhite, drawGetWindowWidth(), drawGetWindowHeight());
             }
         }
 
@@ -2789,13 +2789,13 @@
                 {
                     const float m = MapDriver::worldSize * 0.4f; // main diamond size
                     const float n = MapDriver::worldSize / 8;    // notch size
-                    const Vec3 q (0,   0, m-n);
-                    const Vec3 s (2*n, 0, 0);
-                    const Vec3 c (s-q);
-                    const Vec3 d (s+q);
+                    const Vector3 q (0,   0, m-n);
+                    const Vector3 s (2*n, 0, 0);
+                    const Vector3 c (s-q);
+                    const Vector3 d (s+q);
                     const int pathPointCount = 2;
                     const float pathRadii[pathPointCount] = {10, 10};
-                    const Vec3 pathPoints[pathPointCount] = {c, d};
+                    const Vector3 pathPoints[pathPointCount] = {c, d};
                     GCRoute r (pathPointCount, pathPoints, pathRadii, false);
                     drawPathFencesOnMap (*vehicle-&gt;map, r);
                     break;
@@ -2984,9 +2984,9 @@
     #ifdef OLDTERRAINMAP
             const float xs = map.xSize / (float)map.resolution;
             const float zs = map.zSize / (float)map.resolution;
-            const Vec3 alongRow (xs, 0, 0);
-            const Vec3 nextRow (-map.xSize, 0, zs);
-            Vec3 g ((map.xSize - xs) / -2, 0, (map.zSize - zs) / -2);
+            const Vector3 alongRow (xs, 0, 0);
+            const Vector3 nextRow (-map.xSize, 0, zs);
+            Vector3 g ((map.xSize - xs) / -2, 0, (map.zSize - zs) / -2);
             for (int j = 0; j &lt; map.resolution; j++)
             {
                 for (int i = 0; i &lt; map.resolution; i++)

Modified: dependencies/opensteer/plugins/MultiplePursuit.cpp
===================================================================
--- dependencies/opensteer/plugins/MultiplePursuit.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/plugins/MultiplePursuit.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -91,14 +91,14 @@
         void reset (void)
         {
             MpBase::reset ();
-            bodyColor.set (0.4f, 0.6f, 0.4f); // greenish
+            bodyColor = Vector3(0.4f, 0.6f, 0.4f); // greenish
         }
 
         // one simulation step
         void update (const float currentTime, const float elapsedTime)
         {
-            const Vec3 wander2d = steerForWander (elapsedTime).setYtoZero ();
-            const Vec3 steer = forward() + (wander2d * 3);
+            const Vector3 wander2d = steerForWander (elapsedTime).setYtoZero ();
+            const Vector3 steer = forward() + (wander2d * 3);
             applySteeringForce (steer, elapsedTime);
 
             // for annotation
@@ -119,7 +119,7 @@
         void reset (void)
         {
             MpBase::reset ();
-            bodyColor.set (0.6f, 0.4f, 0.4f); // redish
+            bodyColor = Vector3(0.6f, 0.4f, 0.4f); // redish
             randomizeStartingPositionAndHeading ();
         }
 
@@ -127,7 +127,7 @@
         void update (const float currentTime, const float elapsedTime)
         {
             // when pursuer touches quarry (&quot;wanderer&quot;), reset its position
-            const float d = Vec3::distance (position(), wanderer-&gt;position());
+            const float d = Vector3::distance (position(), wanderer-&gt;position());
             const float r = radius() + wanderer-&gt;radius();
             if (d &lt; r) reset ();
 
@@ -146,7 +146,7 @@
             const float inner = 20;
             const float outer = 30;
             const float radius = frandom2 (inner, outer);
-            const Vec3 randomOnRing = RandomUnitVectorOnXZPlane () * radius;
+            const Vector3 randomOnRing = RandomUnitVectorOnXZPlane () * radius;
             setPosition (wanderer-&gt;position() + randomOnRing);
 
             // randomize 2D heading

Modified: dependencies/opensteer/plugins/OneTurning.cpp
===================================================================
--- dependencies/opensteer/plugins/OneTurning.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/plugins/OneTurning.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -70,7 +70,7 @@
         // per frame simulation update
         void update (const float currentTime, const float elapsedTime)
         {
-            applySteeringForce (Vec3 (-2, 0, -3), elapsedTime);
+            applySteeringForce (Vector3 (-2, 0, -3), elapsedTime);
             annotationVelocityAcceleration ();
             recordTrailVertex (currentTime, position());
         }
@@ -110,7 +110,7 @@
             OpenSteerDemo::camera.setPosition (10,
                                                OpenSteerDemo::camera2dElevation,
                                                10);
-            OpenSteerDemo::camera.fixedPosition.set (40, 40, 40);
+            OpenSteerDemo::camera.fixedPosition = Vector3(40, 40, 40);
         }
 
         void update (const float currentTime, const float elapsedTime)
@@ -129,7 +129,7 @@
             annote &lt;&lt; std::setprecision (2) &lt;&lt; std::setiosflags (std::ios::fixed);
             annote &lt;&lt; &quot;      speed: &quot; &lt;&lt; gOneTurning-&gt;speed() &lt;&lt; std::ends;
             draw2dTextAt3dLocation (annote, gOneTurning-&gt;position(), gRed, drawGetWindowWidth(), drawGetWindowHeight());
-            draw2dTextAt3dLocation (*&quot;start&quot;, Vec3::zero, gGreen, drawGetWindowWidth(), drawGetWindowHeight());
+            draw2dTextAt3dLocation (*&quot;start&quot;, Vector3::ZERO, gGreen, drawGetWindowWidth(), drawGetWindowHeight());
 
             // update camera, tracking test vehicle
             OpenSteerDemo::updateCamera (currentTime, elapsedTime, *gOneTurning);

Modified: dependencies/opensteer/plugins/Pedestrian.cpp
===================================================================
--- dependencies/opensteer/plugins/Pedestrian.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/plugins/Pedestrian.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -68,8 +68,8 @@
     SphereObstacle gObstacle1;
     SphereObstacle gObstacle2;
     ObstacleGroup gObstacles;
-    Vec3 gEndpoint0;
-    Vec3 gEndpoint1;
+    Vector3 gEndpoint0;
+    Vector3 gEndpoint1;
     bool gUseDirectedPathFollowing = true;
     // ------------------------------------ xxxcwr11-1-04 fixing steerToAvoid
     RectangleObstacle gObstacle3 (7,7);
@@ -130,7 +130,7 @@
             // (random point on path + random horizontal offset)
             const float d = path-&gt;length() * frandom01();
             const float r = path-&gt;radius();
-            const Vec3 randomOffset = randomVectorOnUnitRadiusXZDisk () * r;
+            const Vector3 randomOffset = randomVectorOnUnitRadiusXZDisk () * r;
             setPosition (path-&gt;mapPathDistanceToPoint (d) + randomOffset);
 
             // randomize 2D heading
@@ -159,12 +159,12 @@
                 const Color darkRed (0.7f, 0, 0);
                 float const pathRadius = path-&gt;radius();
                 
-                if (Vec3::distance (position(), gEndpoint0) &lt; pathRadius )
+                if (Vector3::distance (position(), gEndpoint0) &lt; pathRadius )
                 {
                     pathDirection = +1;
                     annotationXZCircle (pathRadius, gEndpoint0, darkRed, 20);
                 }
-                if (Vec3::distance (position(), gEndpoint1) &lt; pathRadius )
+                if (Vector3::distance (position(), gEndpoint1) &lt; pathRadius )
                 {
                     pathDirection = -1;
                     annotationXZCircle (pathRadius, gEndpoint1, darkRed, 20);
@@ -181,10 +181,10 @@
 
         // compute combined steering force: move forward, avoid obstacles
         // or neighbors if needed, otherwise follow the path and wander
-        Vec3 determineCombinedSteering (const float elapsedTime)
+        Vector3 determineCombinedSteering (const float elapsedTime)
         {
             // move forward
-            Vec3 steeringForce = forward();
+            Vector3 steeringForce = forward();
 
             // probability that a lower priority behavior will be given a
             // chance to &quot;drive&quot; even if a higher priority behavior might
@@ -192,7 +192,7 @@
             const float leakThrough = 0.1f;
 
             // determine if obstacle avoidance is required
-            Vec3 obstacleAvoidance;
+            Vector3 obstacleAvoidance;
             if (leakThrough &lt; frandom01())
             {
                 const float oTime = 6; // minTimeToCollision = 6 seconds
@@ -206,14 +206,14 @@
             }
 
             // if obstacle avoidance is needed, do it
-            if (obstacleAvoidance != Vec3::zero)
+            if (obstacleAvoidance != Vector3::ZERO)
             {
                 steeringForce += obstacleAvoidance;
             }
             else
             {
                 // otherwise consider avoiding collisions with others
-                Vec3 collisionAvoidance;
+                Vector3 collisionAvoidance;
                 const float caLeadTime = 3;
 
                 // find all neighbors within maxRadius using proximity database
@@ -228,7 +228,7 @@
                         steerToAvoidNeighbors (caLeadTime, neighbors) * 10;
 
                 // if collision avoidance is needed, do it
-                if (collisionAvoidance != Vec3::zero)
+                if (collisionAvoidance != Vector3::ZERO)
                 {
                     steeringForce += collisionAvoidance;
                 }
@@ -240,7 +240,7 @@
 
                     // do (interactively) selected type of path following
                     const float pfLeadTime = 3;
-                    const Vec3 pathFollow =
+                    const Vector3 pathFollow =
                         (gUseDirectedPathFollowing ?
                          steerToFollowPath (pathDirection, pfLeadTime, *path) :
                          steerToStayOnPath (pfLeadTime, *path));
@@ -264,9 +264,9 @@
 
 
         // called when steerToFollowPath decides steering is required
-        void annotatePathFollowing (const Vec3&amp; future,
-                                    const Vec3&amp; onPath,
-                                    const Vec3&amp; target,
+        void annotatePathFollowing (const Vector3&amp; future,
+                                    const Vector3&amp; onPath,
+                                    const Vector3&amp; target,
                                     const float outside)
         {
             const Color yellow (1, 1, 0);
@@ -283,8 +283,8 @@
             // draw a two-toned line between the future test point and its
             // projection onto the path, the change from dark to light color
             // indicates the boundary of the tube.
-            const Vec3 boundaryOffset = (onPath - future).normalize() * outside;
-            const Vec3 onPathBoundary = future + boundaryOffset;
+            const Vector3 boundaryOffset = (onPath - future).normalisedCopy() * outside;
+            const Vector3 onPathBoundary = future + boundaryOffset;
             annotationLine (onPath, onPathBoundary, darkOrange);
             annotationLine (onPathBoundary, future, lightOrange);
         }
@@ -295,12 +295,12 @@
                                          const float /*additionalDistance*/)
         {
             // draw the word &quot;Ouch!&quot; above colliding vehicles
-            const float headOn = forward().dot(other.forward()) &lt; 0;
+            const float headOn = forward().dotProduct(other.forward()) &lt; 0;
             const Color green (0.4f, 0.8f, 0.1f);
             const Color red (1, 0.1f, 0);
             const Color color = headOn ? red : green;
             const char* string = headOn ? &quot;OUCH!&quot; : &quot;pardon me&quot;;
-            const Vec3 location = position() + Vec3 (0, 0.5f, 0);
+            const Vector3 location = position() + Vector3 (0, 0.5f, 0);
             if (OpenSteer::annotationIsOn())
                 draw2dTextAt3dLocation (*string, location, color, drawGetWindowWidth(), drawGetWindowHeight());
         }
@@ -309,8 +309,8 @@
         // (parameter names commented out to prevent compiler warning from &quot;-W&quot;)
         void annotateAvoidNeighbor (const AbstractVehicle&amp; threat,
                                     const float /*steer*/,
-                                    const Vec3&amp; ourFuture,
-                                    const Vec3&amp; threatFuture)
+                                    const Vector3&amp; ourFuture,
+                                    const Vector3&amp; threatFuture)
         {
             const Color green (0.15f, 0.6f, 0.0f);
 
@@ -326,12 +326,12 @@
         // xxx CaptureTheFlag.cpp
         void annotateAvoidObstacle (const float minDistanceToCollision)
         {
-            const Vec3 boxSide = side() * radius();
-            const Vec3 boxFront = forward() * minDistanceToCollision;
-            const Vec3 FR = position() + boxFront - boxSide;
-            const Vec3 FL = position() + boxFront + boxSide;
-            const Vec3 BR = position()            - boxSide;
-            const Vec3 BL = position()            + boxSide;
+            const Vector3 boxSide = side() * radius();
+            const Vector3 boxFront = forward() * minDistanceToCollision;
+            const Vector3 FR = position() + boxFront - boxSide;
+            const Vector3 FL = position() + boxFront + boxSide;
+            const Vector3 BR = position()            - boxSide;
+            const Vector3 BL = position()            + boxSide;
             const Color white (1,1,1);
             annotationLine (FR, FL, white);
             annotationLine (FL, BL, white);
@@ -405,14 +405,14 @@
             const float gap = 1.2f * size;
             const float out = 2 * size;
             const float h = 0.5;
-            const Vec3 pathPoints[pathPointCount] =
-                {Vec3 (h+gap-out,     0,  h+top-out),  // 0 a
-                 Vec3 (h+gap,         0,  h+top),      // 1 b
-                 Vec3 (h+gap+(top/2), 0,  h+top/2),    // 2 c
-                 Vec3 (h+gap,         0,  h),          // 3 d
-                 Vec3 (h,             0,  h),          // 4 e
-                 Vec3 (h,             0,  h+top),      // 5 f
-                 Vec3 (h+gap,         0,  h+top/2)};   // 6 g
+            const Vector3 pathPoints[pathPointCount] =
+                {Vector3 (h+gap-out,     0,  h+top-out),  // 0 a
+                 Vector3 (h+gap,         0,  h+top),      // 1 b
+                 Vector3 (h+gap+(top/2), 0,  h+top/2),    // 2 c
+                 Vector3 (h+gap,         0,  h),          // 3 d
+                 Vector3 (h,             0,  h),          // 4 e
+                 Vector3 (h,             0,  h+top),      // 5 f
+                 Vector3 (h+gap,         0,  h+top/2)};   // 6 g
 
             gObstacle1.center = interpolate (0.2f, pathPoints[0], pathPoints[1]);
             gObstacle2.center = interpolate (0.5f, pathPoints[2], pathPoints[3]);
@@ -441,9 +441,9 @@
     //         gObstacle3.setPosition (20, 0, h);
 
             // tilted 45 degrees
-            gObstacle3.setForward (Vec3(1,1,0).normalize());
+            gObstacle3.setForward (Vector3(1,1,0).normalisedCopy());
             gObstacle3.setSide (0,0,1);
-            gObstacle3.setUp (Vec3(-1,1,0).normalize());
+            gObstacle3.setUp (Vector3(-1,1,0).normalisedCopy());
             gObstacle3.setPosition (20, 0, h);
 
     //         gObstacle3.setSeenFrom (Obstacle::outside);
@@ -492,8 +492,8 @@
             Pedestrian&amp; firstPedestrian = **crowd.begin();
             OpenSteerDemo::init3dCamera (firstPedestrian);
             OpenSteerDemo::camera.mode = Camera::cmFixedDistanceOffset;
-            OpenSteerDemo::camera.fixedTarget.set (15, 0, 30);
-            OpenSteerDemo::camera.fixedPosition.set (15, 70, -70);
+            OpenSteerDemo::camera.fixedTarget = Vector3(15, 0, 30);
+            OpenSteerDemo::camera.fixedPosition = Vector3(15, 70, -70);
         }
 
         void update (const float currentTime, const float elapsedTime)
@@ -536,10 +536,10 @@
             if (OpenSteerDemo::selectedVehicle &amp;&amp; OpenSteer::annotationIsOn())
             {
                 const Color color (0.8f, 0.8f, 1.0f);
-                const Vec3 textOffset (0, 0.25f, 0);
-                const Vec3 textPosition = selected.position() + textOffset;
-                const Vec3 camPosition = OpenSteerDemo::camera.position();
-                const float camDistance = Vec3::distance (selected.position(),
+                const Vector3 textOffset (0, 0.25f, 0);
+                const Vector3 textPosition = selected.position() + textOffset;
+                const Vector3 camPosition = OpenSteerDemo::camera.position();
+                const float camDistance = Vector3::distance (selected.position(),
                                                           camPosition);
                 const char* spacer = &quot;      &quot;;
                 std::ostringstream annote;
@@ -570,7 +570,7 @@
             if (gWanderSwitch) status &lt;&lt; &quot;yes&quot;; else status &lt;&lt; &quot;no&quot;;
             status &lt;&lt; std::endl;
             const float h = drawGetWindowHeight ();
-            const Vec3 screenLocation (10, h-50, 0);
+            const Vector3 screenLocation (10, h-50, 0);
             draw2dTextAt2dLocation (status, screenLocation, gGray80, drawGetWindowWidth(), drawGetWindowHeight());
         }
 
@@ -586,19 +586,19 @@
                 {
                     AbstractVehicle* vehicle = *i;
                     const float nearDistance = 6;
-                    const Vec3&amp; vp = vehicle-&gt;position();
-                    const Vec3&amp; np = nearMouse.position();
-                    if ((Vec3::distance (vp, selected.position()) &lt; nearDistance)
+                    const Vector3&amp; vp = vehicle-&gt;position();
+                    const Vector3&amp; np = nearMouse.position();
+                    if ((Vector3::distance (vp, selected.position()) &lt; nearDistance)
                         ||
-                        (&amp;nearMouse &amp;&amp; (Vec3::distance (vp, np) &lt; nearDistance)))
+                        (&amp;nearMouse &amp;&amp; (Vector3::distance (vp, np) &lt; nearDistance)))
                     {
                         std::ostringstream sn;
                         sn &lt;&lt; &quot;#&quot;
                            &lt;&lt; ((Pedestrian*)vehicle)-&gt;serialNumber
                            &lt;&lt; std::ends;
                         const Color textColor (0.8f, 1, 0.8f);
-                        const Vec3 textOffset (0, 0.25f, 0);
-                        const Vec3 textPos = vehicle-&gt;position() + textOffset;
+                        const Vector3 textOffset (0, 0.25f, 0);
+                        const Vector3 textPos = vehicle-&gt;position() + textOffset;
                         draw2dTextAt3dLocation (sn, textPos, textColor, drawGetWindowWidth(), drawGetWindowHeight());
                     }
                 }
@@ -621,14 +621,14 @@
     // ------------------------------------ xxxcwr11-1-04 fixing steerToAvoid
             {
                 float w = gObstacle3.width * 0.5f;
-                Vec3 p = gObstacle3.position ();
-                Vec3 s = gObstacle3.side ();
+                Vector3 p = gObstacle3.position ();
+                Vector3 s = gObstacle3.side ();
                 drawLine (p + (s * w), p + (s * -w), gWhite);
 
-                Vec3 v1 = gObstacle3.globalizePosition (Vec3 (w, w, 0));
-                Vec3 v2 = gObstacle3.globalizePosition (Vec3 (-w, w, 0));
-                Vec3 v3 = gObstacle3.globalizePosition (Vec3 (-w, -w, 0));
-                Vec3 v4 = gObstacle3.globalizePosition (Vec3 (w, -w, 0));
+                Vector3 v1 = gObstacle3.globalizePosition (Vector3 (w, w, 0));
+                Vector3 v2 = gObstacle3.globalizePosition (Vector3 (-w, w, 0));
+                Vector3 v3 = gObstacle3.globalizePosition (Vector3 (-w, -w, 0));
+                Vector3 v4 = gObstacle3.globalizePosition (Vector3 (w, -w, 0));
 
                 drawLine (v1, v2, gWhite);
                 drawLine (v2, v3, gWhite);
@@ -726,11 +726,11 @@
             {
             case 0:
                 {
-                    const Vec3 center;
+                    const Vector3 center;
                     const float div = 20.0f;
-                    const Vec3 divisions (div, 1.0f, div);
+                    const Vector3 divisions (div, 1.0f, div);
                     const float diameter = 80.0f; //XXX need better way to get this
-                    const Vec3 dimensions (diameter, diameter, diameter);
+                    const Vector3 dimensions (diameter, diameter, diameter);
                     typedef LQProximityDatabase&lt;AbstractVehicle*&gt; LQPDAV;
                     pd = new LQPDAV (center, dimensions, divisions);
                     break;
@@ -756,7 +756,7 @@
         Pedestrian::groupType crowd;
         typedef Pedestrian::groupType::const_iterator iterator;
 
-        Vec3 gridCenter;
+        Vector3 gridCenter;
 
         // pointer to database used to accelerate proximity queries
         ProximityDatabase* pd;

Modified: dependencies/opensteer/plugins/Soccer.cpp
===================================================================
--- dependencies/opensteer/plugins/Soccer.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/plugins/Soccer.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -52,16 +52,16 @@
     using namespace OpenSteer;
 
 
-    Vec3 playerPosition[9] = {
-        Vec3(4,0,0),
-        Vec3(7,0,-5),
-        Vec3(7,0,5),
-        Vec3(10,0,-3),
-        Vec3(10,0,3),
-        Vec3(15,0, -8),
-        Vec3(15,0,0),
-        Vec3(15,0,8),
-        Vec3(4,0,0)
+    Vector3 playerPosition[9] = {
+        Vector3(4,0,0),
+        Vector3(7,0,-5),
+        Vector3(7,0,5),
+        Vector3(10,0,-3),
+        Vector3(10,0,3),
+        Vector3(15,0, -8),
+        Vector3(15,0,0),
+        Vector3(15,0,8),
+        Vector3(4,0,0)
     };
 
     // ----------------------------------------------------------------------------
@@ -69,14 +69,14 @@
     // a box object for the field and the goals.
     class AABBox{
     public:
-        AABBox(Vec3 &amp;min, Vec3&amp; max): m_min(min), m_max(max){}
-        AABBox(Vec3 min, Vec3 max): m_min(min), m_max(max){}
-        bool	InsideX(const Vec3 p){if(p.x &lt; m_min.x || p.x &gt; m_max.x)	return false;return true;}
-        bool	InsideZ(const Vec3 p){if(p.z &lt; m_min.z || p.z &gt; m_max.z)	return false;return true;}
+        AABBox(Vector3 &amp;min, Vector3&amp; max): m_min(min), m_max(max){}
+        AABBox(Vector3 min, Vector3 max): m_min(min), m_max(max){}
+        bool	InsideX(const Vector3 p){if(p.x &lt; m_min.x || p.x &gt; m_max.x)	return false;return true;}
+        bool	InsideZ(const Vector3 p){if(p.z &lt; m_min.z || p.z &gt; m_max.z)	return false;return true;}
         void	draw(){
-            Vec3 b,c;
-            b = Vec3(m_min.x, 0, m_max.z);
-            c = Vec3(m_max.x, 0, m_min.z);
+            Vector3 b,c;
+            b = Vector3(m_min.x, 0, m_max.z);
+            c = Vector3(m_max.x, 0, m_min.z);
             Color color(1.0f,1.0f,0.0f);
             drawLineAlpha(m_min, b, color, 1.0f);
             drawLineAlpha(b, m_max, color, 1.0f);
@@ -84,8 +84,8 @@
             drawLineAlpha(c,m_min, color, 1.0f);
         }
     private:
-        Vec3 m_min;
-        Vec3 m_max;
+        Vector3 m_min;
+        Vector3 m_max;
     };
 
     // The ball object
@@ -114,20 +114,20 @@
             // are we now outside the field?
             if(!m_bbox-&gt;InsideX(position()))
             {
-                Vec3 d = velocity();
-                regenerateOrthonormalBasis(Vec3(-d.x, d.y, d.z));
+                Vector3 d = velocity();
+                regenerateOrthonormalBasis(Vector3(-d.x, d.y, d.z));
                 applySteeringForce(velocity(), elapsedTime);
             }
             if(!m_bbox-&gt;InsideZ(position()))
             {
-                Vec3 d = velocity();
-                regenerateOrthonormalBasis(Vec3(d.x, d.y, -d.z));
+                Vector3 d = velocity();
+                regenerateOrthonormalBasis(Vector3(d.x, d.y, -d.z));
                 applySteeringForce(velocity(), elapsedTime);
             }
         recordTrailVertex (currentTime, position());
         }
 
-        void kick(Vec3 dir, const float elapsedTime){
+        void kick(Vector3 dir, const float elapsedTime){
             OPENSTEER_UNUSED_PARAMETER(elapsedTime);
             
             setSpeed(dir.length());
@@ -166,7 +166,7 @@
                 if(b_ImTeamA)
                     setPosition(playerPosition[m_MyID]);
                 else
-                    setPosition(Vec3(-playerPosition[m_MyID].x, playerPosition[m_MyID].y, playerPosition[m_MyID].z));
+                    setPosition(Vector3(-playerPosition[m_MyID].x, playerPosition[m_MyID].y, playerPosition[m_MyID].z));
                 }
             m_home = position();
             clearTrailHistory ();    // prevent long streaks due to teleportation 
@@ -179,25 +179,25 @@
         {
             // if I hit the ball, kick it.
 
-            const float distToBall = Vec3::distance (position(), m_Ball-&gt;position());
+            const float distToBall = Vector3::distance (position(), m_Ball-&gt;position());
             const float sumOfRadii = radius() + m_Ball-&gt;radius();
             if (distToBall &lt; sumOfRadii)
                 m_Ball-&gt;kick((m_Ball-&gt;position()-position())*50, elapsedTime);
 
 
             // otherwise consider avoiding collisions with others
-            Vec3 collisionAvoidance = steerToAvoidNeighbors(1, (AVGroup&amp;)m_AllPlayers);
-            if(collisionAvoidance != Vec3::zero)
+            Vector3 collisionAvoidance = steerToAvoidNeighbors(1, (AVGroup&amp;)m_AllPlayers);
+            if(collisionAvoidance != Vector3::ZERO)
                 applySteeringForce (collisionAvoidance, elapsedTime);
             else
                 {
-                float distHomeToBall = Vec3::distance (m_home, m_Ball-&gt;position());
+                float distHomeToBall = Vector3::distance (m_home, m_Ball-&gt;position());
                 if( distHomeToBall &lt; 12.0f)
                     {
                     // go for ball if I'm on the 'right' side of the ball
                         if( b_ImTeamA ? position().x &gt; m_Ball-&gt;position().x : position().x &lt; m_Ball-&gt;position().x)
                         {
-                        Vec3 seekTarget = xxxsteerForSeek(m_Ball-&gt;position());
+                        Vector3 seekTarget = xxxsteerForSeek(m_Ball-&gt;position());
                         applySteeringForce (seekTarget, elapsedTime);
                         }
                     else
@@ -205,18 +205,18 @@
                         if( distHomeToBall &lt; 12.0f)
                             {
                             float Z = m_Ball-&gt;position().z - position().z &gt; 0 ? -1.0f : 1.0f;
-                            Vec3 behindBall = m_Ball-&gt;position() + (b_ImTeamA ? Vec3(2.0f,0.0f,Z) : Vec3(-2.0f,0.0f,Z));
-                            Vec3 behindBallForce = xxxsteerForSeek(behindBall);
+                            Vector3 behindBall = m_Ball-&gt;position() + (b_ImTeamA ? Vector3(2.0f,0.0f,Z) : Vector3(-2.0f,0.0f,Z));
+                            Vector3 behindBallForce = xxxsteerForSeek(behindBall);
                             annotationLine (position(), behindBall , Color(0.0f,1.0f,0.0f));
-                            Vec3 evadeTarget = xxxsteerForFlee(m_Ball-&gt;position());
+                            Vector3 evadeTarget = xxxsteerForFlee(m_Ball-&gt;position());
                             applySteeringForce (behindBallForce*10.0f + evadeTarget, elapsedTime);
                             }
                         }
                     }
                 else	// Go home
                     {
-                    Vec3 seekTarget = xxxsteerForSeek(m_home);
-                    Vec3 seekHome = xxxsteerForSeek(m_home);
+                    Vector3 seekTarget = xxxsteerForSeek(m_home);
+                    Vector3 seekHome = xxxsteerForSeek(m_home);
                     applySteeringForce (seekTarget+seekHome, elapsedTime);
                     }
 
@@ -235,7 +235,7 @@
         Ball*	m_Ball;
         bool	b_ImTeamA;
         int		m_MyID;
-        Vec3		m_home;
+        Vector3		m_home;
     };
 
 
@@ -258,11 +258,11 @@
         void open (void)
         {
             // Make a field
-            m_bbox = new AABBox(Vec3(-20,0,-10), Vec3(20,0,10));
+            m_bbox = new AABBox(Vector3(-20,0,-10), Vector3(20,0,10));
             // Red goal
-            m_TeamAGoal = new AABBox(Vec3(-21,0,-7), Vec3(-19,0,7));
+            m_TeamAGoal = new AABBox(Vector3(-21,0,-7), Vector3(-19,0,7));
             // Blue Goal
-            m_TeamBGoal = new AABBox(Vec3(19,0,-7), Vec3(21,0,7));
+            m_TeamBGoal = new AABBox(Vector3(19,0,-7), Vector3(21,0,7));
             // Make a ball
             m_Ball = new Ball(m_bbox);
             // Build team A
@@ -286,7 +286,7 @@
             // initialize camera
             OpenSteerDemo::init2dCamera (*m_Ball);
             OpenSteerDemo::camera.setPosition (10, OpenSteerDemo::camera2dElevation, 10);
-            OpenSteerDemo::camera.fixedPosition.set (40, 40, 40);
+            OpenSteerDemo::camera.fixedPosition = Vector3(40, 40, 40);
             OpenSteerDemo::camera.mode = Camera::cmFixed;
             m_redScore = 0;
             m_blueScore = 0;
@@ -328,12 +328,12 @@
             {
                 std::ostringstream annote;
                 annote &lt;&lt; &quot;Red: &quot;&lt;&lt; m_redScore;
-                draw2dTextAt3dLocation (annote, Vec3(23,0,0), Color(1.0f,0.7f,0.7f), drawGetWindowWidth(), drawGetWindowHeight());
+                draw2dTextAt3dLocation (annote, Vector3(23,0,0), Color(1.0f,0.7f,0.7f), drawGetWindowWidth(), drawGetWindowHeight());
             }
             {
                 std::ostringstream annote;
                 annote &lt;&lt; &quot;Blue: &quot;&lt;&lt; m_blueScore;
-                draw2dTextAt3dLocation (annote, Vec3(-23,0,0), Color(0.7f,0.7f,1.0f), drawGetWindowWidth(), drawGetWindowHeight());
+                draw2dTextAt3dLocation (annote, Vector3(-23,0,0), Color(0.7f,0.7f,1.0f), drawGetWindowWidth(), drawGetWindowHeight());
             }
 
             // textual annotation (following the test vehicle's screen position)
@@ -344,13 +344,13 @@
                 annote &lt;&lt; std::setprecision (2) &lt;&lt; std::setiosflags (std::ios::fixed);
                 annote &lt;&lt; &quot;      speed: &quot; &lt;&lt; TeamA[i]-&gt;speed() &lt;&lt; &quot;ID:&quot; &lt;&lt; i &lt;&lt; std::ends;
                 draw2dTextAt3dLocation (annote, TeamA[i]-&gt;position(), gRed, drawGetWindowWidth(), drawGetWindowHeight());
-                draw2dTextAt3dLocation (*&quot;start&quot;, Vec3::zero, gGreen, drawGetWindowWidth(), drawGetWindowHeight());
+                draw2dTextAt3dLocation (*&quot;start&quot;, Vector3::ZERO, gGreen, drawGetWindowWidth(), drawGetWindowHeight());
             }
             // update camera, tracking test vehicle
             OpenSteerDemo::updateCamera (currentTime, elapsedTime, *OpenSteerDemo::selectedVehicle);
 
             // draw &quot;ground plane&quot;
-            OpenSteerDemo::gridUtility (Vec3(0,0,0));
+            OpenSteerDemo::gridUtility (Vector3(0,0,0));
         }
 
         void close (void)

Modified: dependencies/opensteer/src/Camera.cpp
===================================================================
--- dependencies/opensteer/src/Camera.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/Camera.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -65,7 +65,7 @@
     resetLocalSpace ();
 
     // &quot;look at&quot; point, center of view
-    target = Vec3::zero;
+    target = Vector3::ZERO;
 
     // vehicle being tracked
     vehicleToTrack = NULL;
@@ -90,15 +90,15 @@
     lookdownDistance = 30;
 
     // &quot;static&quot; camera mode parameters
-    fixedPosition.set (75, 75, 75);
-    fixedTarget = Vec3::zero;
-    fixedUp = Vec3::up;
+    fixedPosition = Vector3(75, 75, 75);
+    fixedTarget = Vector3::ZERO;
+    fixedUp = Vector3::UNIT_Y;
 
     // &quot;fixed local offset&quot; camera mode parameters
-    fixedLocalOffset.set (5, 5, -5);
+    fixedLocalOffset = Vector3(5, 5, -5);
 
     // &quot;offset POV&quot; camera mode parameters
-    povOffset.set (0, 1, -3);
+    povOffset = Vector3(0, 1, -3);
 }
 
 
@@ -120,9 +120,9 @@
     const bool noVehicle = vehicleToTrack == NULL;
     
     // new position/target/up, set in switch below, defaults to current
-    Vec3 newPosition = position();
-    Vec3 newTarget = target;
-    Vec3 newUp = up();
+    Vector3 newPosition = position();
+    Vector3 newTarget = target;
+    Vector3 newUp = up();
 
 
     // prediction time to compensate for lag caused by smoothing moves
@@ -142,7 +142,7 @@
 
     case cmFixedDistanceOffset:
         if (noVehicle) break;
-        newUp = Vec3::up; // xxx maybe this should be v.up ?
+        newUp = Vector3::UNIT_Y; // xxx maybe this should be v.up ?
         newTarget = v.predictFuturePosition (predictionTime);
         newPosition = constDistHelper (elapsedTime);
         break;
@@ -166,8 +166,8 @@
         {
             if (noVehicle) break;
             newUp = v.up();
-            const Vec3 futurePosition = v.predictFuturePosition (antiLagTime);
-            const Vec3 globalOffset = v.globalizeDirection (povOffset);
+            const Vector3 futurePosition = v.predictFuturePosition (antiLagTime);
+            const Vector3 globalOffset = v.globalizeDirection (povOffset);
             newPosition = futurePosition + globalOffset;
             // XXX hack to improve smoothing between modes (no effect on aim)
             const float L = 10;
@@ -195,17 +195,17 @@
 
 
 void 
-OpenSteer::Camera::smoothCameraMove (const Vec3&amp; newPosition,
-                                     const Vec3&amp; newTarget,
-                                     const Vec3&amp; newUp,
+OpenSteer::Camera::smoothCameraMove (const Vector3&amp; newPosition,
+                                     const Vector3&amp; newTarget,
+                                     const Vector3&amp; newUp,
                                      const float elapsedTime)
 {
     if (smoothNextMove)
     {
         const float smoothRate = elapsedTime * smoothMoveSpeed;
 
-        Vec3 tempPosition = position();
-        Vec3 tempUp = up();
+        Vector3 tempPosition = position();
+        Vector3 tempUp = up();
         blendIntoAccumulator (smoothRate, newPosition, tempPosition);
         blendIntoAccumulator (smoothRate, newTarget,   target);
         blendIntoAccumulator (smoothRate, newUp,       tempUp);
@@ -215,10 +215,10 @@
         // xxx not sure if these are needed, seems like a good idea
         // xxx (also if either up or oldUP are zero, use the other?)
         // xxx (even better: force up to be perp to target-position axis))
-        if (up() == Vec3::zero)
-            setUp (Vec3::up);
+        if (up() == Vector3::ZERO)
+            setUp (Vector3::UNIT_Y);
         else
-            setUp (up().normalize ());
+            setUp (up().normalisedCopy());
     }
     else
     {
@@ -238,7 +238,7 @@
 // parameter names commented out to prevent compiler warning from &quot;-W&quot;
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::Camera::constDistHelper (const float /*elapsedTime*/)
 {
     // is the &quot;global up&quot;/&quot;vertical&quot; offset constraint enabled?  (it forces
@@ -247,10 +247,10 @@
     const bool constrainUp = (fixedDistVOffset != 0);
 
     // vector offset from target to current camera position
-    const Vec3 adjustedPosition (position().x,
+    const Vector3 adjustedPosition (position().x,
                                  (constrainUp) ? target.y : position().y,
                                  position().z);
-    const Vec3 offset = adjustedPosition - target;
+    const Vector3 offset = adjustedPosition - target;
 
     // current distance between them
     const float distance = offset.length();
@@ -263,15 +263,15 @@
     else
     {
         // unit vector along original offset
-        const Vec3 unitOffset = offset / distance;
+        const Vector3 unitOffset = offset / distance;
 
         // new offset of length XXX
         const float xxxDistance = sqrtXXX (square (fixedDistDistance) -
                                            square (fixedDistVOffset));
-        const Vec3 newOffset = unitOffset * xxxDistance;
+        const Vector3 newOffset = unitOffset * xxxDistance;
 
         // return new camera position: adjust distance to target
-        return target + newOffset + Vec3 (0, fixedDistVOffset, 0);
+        return target + newOffset + Vector3 (0, fixedDistVOffset, 0);
     }
 }
 
@@ -324,7 +324,7 @@
 
 
 void 
-OpenSteer::Camera::mouseAdjustOffset (const Vec3&amp; adjustment)
+OpenSteer::Camera::mouseAdjustOffset (const Vector3&amp; adjustment)
 {
     // vehicle being tracked (just a reference with a more concise name)
     const AbstractVehicle&amp; v = *vehicleToTrack;
@@ -333,8 +333,8 @@
     {
     case cmFixed:
         {
-            const Vec3 offset = fixedPosition - fixedTarget;
-            const Vec3 adjusted = mouseAdjustPolar (adjustment, offset);
+            const Vector3 offset = fixedPosition - fixedTarget;
+            const Vector3 adjusted = mouseAdjustPolar (adjustment, offset);
             fixedPosition = fixedTarget + adjusted;
             break;
         }
@@ -343,15 +343,15 @@
             // XXX this is the oddball case, adjusting &quot;position&quot; instead
             // XXX of mode parameters, hence no smoothing during adjustment
             // XXX Plus the fixedDistVOffset feature complicates things
-            const Vec3 offset = position() - target;
-            const Vec3 adjusted = mouseAdjustPolar (adjustment, offset);
+            const Vector3 offset = position() - target;
+            const Vector3 adjusted = mouseAdjustPolar (adjustment, offset);
             // XXX --------------------------------------------------
 //             position = target + adjusted;
 //             fixedDistDistance = adjusted.length();
 //             fixedDistVOffset = position.y - target.y;
             // XXX --------------------------------------------------
 //             const float s = smoothMoveSpeed * (1.0f/40f);
-//             const Vec3 newPosition = target + adjusted;
+//             const Vector3 newPosition = target + adjusted;
 //             position = interpolate (s, position, newPosition);
 //             fixedDistDistance = interpolate (s, fixedDistDistance, adjusted.length());
 //             fixedDistVOffset = interpolate (s, fixedDistVOffset, position.y - target.y);
@@ -366,15 +366,15 @@
         }
     case cmStraightDown:
         {
-            const Vec3 offset (0, 0, lookdownDistance);
-            const Vec3 adjusted = mouseAdjustPolar (adjustment, offset);
+            const Vector3 offset (0, 0, lookdownDistance);
+            const Vector3 adjusted = mouseAdjustPolar (adjustment, offset);
             lookdownDistance = adjusted.z;
             break;
         }
     case cmFixedLocalOffset:
         {
-            const Vec3 offset = v.globalizeDirection (fixedLocalOffset);
-            const Vec3 adjusted = mouseAdjustPolar (adjustment, offset);
+            const Vector3 offset = v.globalizeDirection (fixedLocalOffset);
+            const Vector3 adjusted = mouseAdjustPolar (adjustment, offset);
             fixedLocalOffset = v.localizeDirection (adjusted);
             break;
         }
@@ -383,8 +383,8 @@
             // XXX this might work better as a translation control, it is
             // XXX non-obvious using a polar adjustment when the view
             // XXX center is not at the camera aim target
-            const Vec3 offset = v.globalizeDirection (povOffset);
-            const Vec3 adjusted = mouseAdjustOrtho (adjustment, offset);
+            const Vector3 offset = v.globalizeDirection (povOffset);
+            const Vector3 adjusted = mouseAdjustOrtho (adjustment, offset);
             povOffset = v.localizeDirection (adjusted);
             break;
         }
@@ -397,13 +397,13 @@
 // ----------------------------------------------------------------------------
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::Camera::mouseAdjust2 (const bool polar,
-                                 const Vec3&amp; adjustment,
-                                 const Vec3&amp; offsetToAdjust)
+                                 const Vector3&amp; adjustment,
+                                 const Vector3&amp; offsetToAdjust)
 {
     // value to be returned
-    Vec3 result = offsetToAdjust;
+    Vector3 result = offsetToAdjust;
 
     // using the camera's side/up axes (essentially: screen space) move the
     // offset vector sideways according to adjustment.x and vertically

Modified: dependencies/opensteer/src/Color.cpp
===================================================================
--- dependencies/opensteer/src/Color.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/Color.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -29,7 +29,7 @@
 
 #include &quot;OpenSteer/Color.h&quot;
 
-// Include OpenSteer::Vec3
+// Include Vector3
 #include &quot;OpenSteer/Vec3.h&quot;
 
 // Include assert
@@ -57,7 +57,7 @@
 }
 
 
-OpenSteer::Color::Color( Vec3 const&amp; vector )
+OpenSteer::Color::Color( Vector3 const&amp; vector )
     : r_( vector.x ), g_( vector.y ), b_( vector.z ), a_ (1.0f)
 {
     
@@ -130,10 +130,10 @@
 }
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::Color::convertToVec3() const
 {
-    return Vec3( r_, g_, b_ );
+    return Vector3( r_, g_, b_ );
 }
 
 

Modified: dependencies/opensteer/src/Draw.cpp
===================================================================
--- dependencies/opensteer/src/Draw.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/Draw.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -88,9 +88,9 @@
 
 namespace {
     // ------------------------------------------------------------------------
-    // emit an OpenGL vertex based on a Vec3
+    // emit an OpenGL vertex based on a Vector3
     
-    inline void iglVertexVec3 (const OpenSteer::Vec3&amp; v)
+    inline void iglVertexVec3 (const Vector3&amp; v)
     {
         glVertex3f (v.x, v.y, v.z);
     }
@@ -129,8 +129,8 @@
     // ----------------------------------------------------------------------------
     // draw 3d &quot;graphical annotation&quot; lines, used for debugging
     
-    inline void iDrawLine (const OpenSteer::Vec3&amp; startPoint,
-                           const OpenSteer::Vec3&amp; endPoint,
+    inline void iDrawLine (const Vector3&amp; startPoint,
+                           const Vector3&amp; endPoint,
                            const OpenSteer::Color&amp; color)
     {
         OpenSteer::warnIfInUpdatePhase (&quot;iDrawLine&quot;);
@@ -142,11 +142,11 @@
     }
 
     // ----------------------------------------------------------------------------
-    // Draw a single OpenGL triangle given three Vec3 vertices.
+    // Draw a single OpenGL triangle given three Vector3 vertices.
     
-    inline void iDrawTriangle (const OpenSteer::Vec3&amp; a,
-                               const OpenSteer::Vec3&amp; b,
-                               const OpenSteer::Vec3&amp; c,
+    inline void iDrawTriangle (const Vector3&amp; a,
+                               const Vector3&amp; b,
+                               const Vector3&amp; c,
                                const OpenSteer::Color&amp; color)
     {
         OpenSteer::warnIfInUpdatePhase (&quot;iDrawTriangle&quot;);
@@ -162,12 +162,12 @@
 
 
     // ------------------------------------------------------------------------
-    // Draw a single OpenGL quadrangle given four Vec3 vertices, and color.
+    // Draw a single OpenGL quadrangle given four Vector3 vertices, and color.
     
-    inline void iDrawQuadrangle (const OpenSteer::Vec3&amp; a,
-                                 const OpenSteer::Vec3&amp; b,
-                                 const OpenSteer::Vec3&amp; c,
-                                 const OpenSteer::Vec3&amp; d,
+    inline void iDrawQuadrangle (const Vector3&amp; a,
+                                 const Vector3&amp; b,
+                                 const Vector3&amp; c,
+                                 const Vector3&amp; d,
                                  const OpenSteer::Color&amp; color)
     {
         OpenSteer::warnIfInUpdatePhase (&quot;iDrawQuadrangle&quot;);
@@ -238,7 +238,7 @@
 
 
 void 
-OpenSteer::glVertexVec3 (const Vec3&amp; v)
+OpenSteer::glVertexVec3 (const Vector3&amp; v)
 {
     iglVertexVec3 (v);
 }
@@ -265,8 +265,8 @@
 
 
 void 
-OpenSteer::drawLine (const Vec3&amp; startPoint,
-                     const Vec3&amp; endPoint,
+OpenSteer::drawLine (const Vector3&amp; startPoint,
+                     const Vector3&amp; endPoint,
                      const Color&amp; color)
 {
     iDrawLine (startPoint, endPoint, color);
@@ -282,8 +282,8 @@
 
 
 void 
-OpenSteer::drawLineAlpha (const Vec3&amp; startPoint,
-                          const Vec3&amp; endPoint,
+OpenSteer::drawLineAlpha (const Vector3&amp; startPoint,
+                          const Vector3&amp; endPoint,
                           const Color&amp; color,
                           const float alpha)
 {
@@ -300,9 +300,9 @@
 
 
 void 
-OpenSteer::drawTriangle (const Vec3&amp; a,
-                         const Vec3&amp; b,
-                         const Vec3&amp; c,
+OpenSteer::drawTriangle (const Vector3&amp; a,
+                         const Vector3&amp; b,
+                         const Vector3&amp; c,
                          const Color&amp; color)
 {
     iDrawTriangle (a, b, c, color);
@@ -314,10 +314,10 @@
     
     
 void 
-OpenSteer::drawQuadrangle (const Vec3&amp; a,
-                           const Vec3&amp; b,
-                           const Vec3&amp; c,
-                           const Vec3&amp; d,
+OpenSteer::drawQuadrangle (const Vector3&amp; a,
+                           const Vector3&amp; b,
+                           const Vector3&amp; c,
+                           const Vector3&amp; d,
                            const Color&amp; color)
 {
     iDrawQuadrangle (a, b, c, d, color);
@@ -330,22 +330,22 @@
 
 
 void 
-OpenSteer::drawXZWideLine (const Vec3&amp; startPoint,
-                           const Vec3&amp; endPoint,
+OpenSteer::drawXZWideLine (const Vector3&amp; startPoint,
+                           const Vector3&amp; endPoint,
                            const Color&amp; color,
                            float width)
 {
     warnIfInUpdatePhase (&quot;drawXZWideLine&quot;);
 
-    const Vec3 offset = endPoint - startPoint;
-    const Vec3 along = offset.normalize();
-    const Vec3 perp = gGlobalSpace.localRotateForwardToSide (along);
-    const Vec3 radius = perp * width / 2;
+    const Vector3 offset = endPoint - startPoint;
+    const Vector3 along = offset.normalisedCopy();
+    const Vector3 perp = gGlobalSpace.localRotateForwardToSide (along);
+    const Vector3 radius = perp * width / 2;
 
-    const Vec3 a = startPoint + radius;
-    const Vec3 b = endPoint + radius;
-    const Vec3 c = endPoint - radius;
-    const Vec3 d = startPoint - radius;
+    const Vector3 a = startPoint + radius;
+    const Vector3 b = endPoint + radius;
+    const Vector3 c = endPoint - radius;
+    const Vector3 d = startPoint - radius;
 
     iDrawQuadrangle (a, b, c, d, color);
 }
@@ -364,8 +364,8 @@
 
 void 
 OpenSteer::drawCircleOrDisk (const float radius,
-                             const Vec3&amp; axis,
-                             const Vec3&amp; center,
+                             const Vector3&amp; axis,
+                             const Vector3&amp; center,
                              const Color&amp; color,
                              const int segments,
                              const bool filled,
@@ -376,8 +376,8 @@
     {
         // define a local space with &quot;axis&quot; as the Y/up direction
         // (XXX should this be a method on  LocalSpace?)
-        const Vec3 unitAxis = axis.normalize ();
-        const Vec3 unitPerp = findPerpendicularIn3d (axis).normalize ();
+        const Vector3 unitAxis = axis.normalisedCopy();
+        const Vector3 unitPerp = findPerpendicularIn3d (axis).normalisedCopy();
         ls.setUp (unitAxis);
         ls.setForward (unitPerp);
         ls.setPosition (center);
@@ -388,7 +388,7 @@
     if (filled) beginDoubleSidedDrawing ();
 
     // point to be rotated about the (local) Y axis, angular step size
-    Vec3 pointOnCircle (radius, 0, 0);
+    Vector3 pointOnCircle (radius, 0, 0);
     const float step = (2 * OPENSTEER_M_PI) / segments;
 
     // set drawing color
@@ -409,7 +409,7 @@
         // of the local space), or in 2d (offset from the center)
         iglVertexVec3 (in3d ?
                            ls.globalizePosition (pointOnCircle) :
-                           (Vec3) (pointOnCircle + center));
+                           (Vector3) (pointOnCircle + center));
 
         // rotate point one more step around circle
         pointOnCircle = pointOnCircle.rotateAboutGlobalY (step, sin, cos);
@@ -426,8 +426,8 @@
 
 void 
 OpenSteer::draw3dCircleOrDisk (const float radius,
-                               const Vec3&amp; center,
-                               const Vec3&amp; axis,
+                               const Vector3&amp; center,
+                               const Vector3&amp; axis,
                                const Color&amp; color,
                                const int segments,
                                const bool filled)
@@ -443,13 +443,13 @@
 
 void 
 OpenSteer::drawXZCircleOrDisk (const float radius,
-                               const Vec3&amp; center,
+                               const Vector3&amp; center,
                                const Color&amp; color,
                                const int segments,
                                const bool filled)
 {
     // draw a circle-or-disk on the XZ plane
-    drawCircleOrDisk (radius, Vec3::zero, center, color, segments, filled, false);
+    drawCircleOrDisk (radius, Vector3::ZERO, center, color, segments, filled, false);
 }
 
 
@@ -464,8 +464,8 @@
 
 
 void 
-OpenSteer::drawXZArc (const Vec3&amp; start,
-                      const Vec3&amp; center,
+OpenSteer::drawXZArc (const Vector3&amp; start,
+                      const Vector3&amp; center,
                       const float arcLength,
                       const int segments,
                       const Color&amp; color)
@@ -474,7 +474,7 @@
 
     // &quot;spoke&quot; is initially the vector from center to start,
     // it is then rotated around its tail
-    Vec3 spoke = start - center;
+    Vector3 spoke = start - center;
 
     // determine the angular step per segment
     const float radius = spoke.length ();
@@ -519,13 +519,13 @@
 
     // radius and position of vehicle
     const float r = vehicle.radius();
-    const Vec3&amp; p = vehicle.position();
+    const Vector3&amp; p = vehicle.position();
 
     // shape of triangular body
-    const Vec3 u = r * 0.05f * Vec3 (0, 1, 0); // slightly up
-    const Vec3 f = r * vehicle.forward();
-    const Vec3 s = r * vehicle.side() * x;
-    const Vec3 b = r * vehicle.forward() * -y;
+    const Vector3 u = r * 0.05f * Vector3 (0, 1, 0); // slightly up
+    const Vector3 f = r * vehicle.forward();
+    const Vector3 s = r * vehicle.side() * x;
+    const Vector3 b = r * vehicle.forward() * -y;
 
     // draw double-sided triangle (that is: no (back) face culling)
     beginDoubleSidedDrawing ();
@@ -554,20 +554,20 @@
 
     // radius and position of vehicle
     const float r = vehicle.radius();
-    const Vec3&amp; p = vehicle.position();
+    const Vector3&amp; p = vehicle.position();
 
     // body shape parameters
-    const Vec3 f = r * vehicle.forward();
-    const Vec3 s = r * vehicle.side() * x;
-    const Vec3 u = r * vehicle.up() * x * 0.5f;
-    const Vec3 b = r * vehicle.forward() * -y;
+    const Vector3 f = r * vehicle.forward();
+    const Vector3 s = r * vehicle.side() * x;
+    const Vector3 u = r * vehicle.up() * x * 0.5f;
+    const Vector3 b = r * vehicle.forward() * -y;
 
     // vertex positions
-    const Vec3 nose   = p + f;
-    const Vec3 side1  = p + b - s;
-    const Vec3 side2  = p + b + s;
-    const Vec3 top    = p + b + u;
-    const Vec3 bottom = p + b - u;
+    const Vector3 nose   = p + f;
+    const Vector3 side1  = p + b - s;
+    const Vector3 side2  = p + b + s;
+    const Vector3 top    = p + b + u;
+    const Vector3 bottom = p + b - u;
 
     // colors
     const float j = +0.05f;
@@ -601,20 +601,20 @@
 
     // radius and position of vehicle
     const float r = vehicle.radius();
-    const Vec3&amp; p = vehicle.position();
+    const Vector3&amp; p = vehicle.position();
 
     // body shape parameters
-    const Vec3 f = r * vehicle.forward();
-    const Vec3 s = r * vehicle.side() * x;
-    const Vec3 u = r * vehicle.up() * x * 0.5f;
-    const Vec3 b = r * vehicle.forward() * -y;
+    const Vector3 f = r * vehicle.forward();
+    const Vector3 s = r * vehicle.side() * x;
+    const Vector3 u = r * vehicle.up() * x * 0.5f;
+    const Vector3 b = r * vehicle.forward() * -y;
 
     // vertex positions
-    const Vec3 nose   = p + f;
-    const Vec3 side1  = p + b - s;
-    const Vec3 side2  = p + b + s;
-    const Vec3 top    = p + b + u;
-    const Vec3 bottom = p + b - u;
+    const Vector3 nose   = p + f;
+    const Vector3 side1  = p + b - s;
+    const Vector3 side2  = p + b + s;
+    const Vector3 top    = p + b + u;
+    const Vector3 bottom = p + b - u;
 
     // colors
     const float j = +0.05f;
@@ -651,7 +651,7 @@
 void 
 OpenSteer::drawXZCheckerboardGrid (const float size,
                                    const int subsquares,
-                                   const Vec3&amp; center,
+                                   const Vector3&amp; center,
                                    const Color&amp; color1,
                                    const Color&amp; color2)
 {
@@ -662,19 +662,19 @@
     {
         bool flag1 = false;
         float p = -half;
-        Vec3 corner;
+        Vector3 corner;
         for (int i = 0; i &lt; subsquares; i++)
         {
             bool flag2 = flag1;
             float q = -half;
             for (int j = 0; j &lt; subsquares; j++)
             {
-                corner.set (p, 0, q);
+                corner = Vector3(p, 0, q);
                 corner += center;
                 iDrawQuadrangle (corner,
-                                 corner + Vec3 (spacing, 0,       0),
-                                 corner + Vec3 (spacing, 0, spacing),
-                                 corner + Vec3 (0,       0, spacing),
+                                 corner + Vector3 (spacing, 0,       0),
+                                 corner + Vector3 (spacing, 0, spacing),
+                                 corner + Vector3 (0,       0, spacing),
                                  flag2 ? color1 : color2);
                 flag2 = !flag2;
                 q += spacing;
@@ -699,7 +699,7 @@
 void 
 OpenSteer::drawXZLineGrid (const float size,
                            const int subsquares,
-                           const Vec3&amp; center,
+                           const Vector3&amp; center,
                            const Color&amp; color)
 {
     warnIfInUpdatePhase (&quot;drawXZLineGrid&quot;);
@@ -715,10 +715,10 @@
     float q = -half;
     for (int i = 0; i &lt; (subsquares + 1); i++)
     {
-        const Vec3 x1 (q, 0, +half); // along X parallel to Z
-        const Vec3 x2 (q, 0, -half);
-        const Vec3 z1 (+half, 0, q); // along Z parallel to X
-        const Vec3 z2 (-half, 0, q);
+        const Vector3 x1 (q, 0, +half); // along X parallel to Z
+        const Vector3 x2 (q, 0, -half);
+        const Vector3 z1 (+half, 0, q); // along Z parallel to X
+        const Vector3 z2 (-half, 0, q);
 
         iglVertexVec3 (x1 + center);
         iglVertexVec3 (x2 + center);
@@ -739,12 +739,12 @@
 
 void 
 OpenSteer::drawAxes  (const AbstractLocalSpace&amp; ls,
-                      const Vec3&amp; size,
+                      const Vector3&amp; size,
                       const Color&amp; color)
 {
-    const Vec3 x (size.x / 2, 0, 0);
-    const Vec3 y (0, size.y / 2, 0);
-    const Vec3 z (0, 0, size.z / 2);
+    const Vector3 x (size.x / 2, 0, 0);
+    const Vector3 y (0, size.y / 2, 0);
+    const Vector3 z (0, 0, size.z / 2);
  
     iDrawLine (ls.globalizePosition (x), ls.globalizePosition (x * -1), color);
     iDrawLine (ls.globalizePosition (y), ls.globalizePosition (y * -1), color);
@@ -763,30 +763,30 @@
 
 void 
 OpenSteer::drawBoxOutline  (const AbstractLocalSpace&amp; localSpace,
-                            const Vec3&amp; size,
+                            const Vector3&amp; size,
                             const Color&amp; color)
 {
-    const Vec3 s = size / 2.0f;  // half of main diagonal
+    const Vector3 s = size / 2.0f;  // half of main diagonal
 
-    const Vec3 a (+s.x, +s.y, +s.z);
-    const Vec3 b (+s.x, -s.y, +s.z);
-    const Vec3 c (-s.x, -s.y, +s.z);
-    const Vec3 d (-s.x, +s.y, +s.z);
+    const Vector3 a (+s.x, +s.y, +s.z);
+    const Vector3 b (+s.x, -s.y, +s.z);
+    const Vector3 c (-s.x, -s.y, +s.z);
+    const Vector3 d (-s.x, +s.y, +s.z);
 
-    const Vec3 e (+s.x, +s.y, -s.z);
-    const Vec3 f (+s.x, -s.y, -s.z);
-    const Vec3 g (-s.x, -s.y, -s.z);
-    const Vec3 h (-s.x, +s.y, -s.z);
+    const Vector3 e (+s.x, +s.y, -s.z);
+    const Vector3 f (+s.x, -s.y, -s.z);
+    const Vector3 g (-s.x, -s.y, -s.z);
+    const Vector3 h (-s.x, +s.y, -s.z);
 
-    const Vec3 A = localSpace.globalizePosition (a);
-    const Vec3 B = localSpace.globalizePosition (b);
-    const Vec3 C = localSpace.globalizePosition (c);
-    const Vec3 D = localSpace.globalizePosition (d);
+    const Vector3 A = localSpace.globalizePosition (a);
+    const Vector3 B = localSpace.globalizePosition (b);
+    const Vector3 C = localSpace.globalizePosition (c);
+    const Vector3 D = localSpace.globalizePosition (d);
 
-    const Vec3 E = localSpace.globalizePosition (e);
-    const Vec3 F = localSpace.globalizePosition (f);
-    const Vec3 G = localSpace.globalizePosition (g);
-    const Vec3 H = localSpace.globalizePosition (h);
+    const Vector3 E = localSpace.globalizePosition (e);
+    const Vector3 F = localSpace.globalizePosition (f);
+    const Vector3 G = localSpace.globalizePosition (g);
+    const Vector3 H = localSpace.globalizePosition (h);
 
     iDrawLine (A, B, color);
     iDrawLine (B, C, color);
@@ -810,13 +810,13 @@
 // ------------------------------------------------------------------------
 // this comes up often enough to warrant its own warning function
 
-    inline void drawCameraLookAtCheck (const OpenSteer::Vec3&amp; cameraPosition,
-                                       const OpenSteer::Vec3&amp; pointToLookAt,
-                                       const OpenSteer::Vec3&amp; up)
+    inline void drawCameraLookAtCheck (const Vector3&amp; cameraPosition,
+                                       const Vector3&amp; pointToLookAt,
+                                       const Vector3&amp; up)
     {
-        const OpenSteer::Vec3 view = pointToLookAt - cameraPosition;
-        const OpenSteer::Vec3 perp = view.perpendicularComponent (up);
-        if (perp == OpenSteer::Vec3::zero)
+        const Vector3 view = pointToLookAt - cameraPosition;
+        const Vector3 perp = view.perpendicularComponent (up);
+        if (perp == Vector3::ZERO)
             std::cerr &lt;&lt; &quot;OpenSteer - LookAt: degenerate camera&quot;;
     }
 
@@ -832,9 +832,9 @@
 
 
 void 
-OpenSteer::drawCameraLookAt (const Vec3&amp; cameraPosition,
-                             const Vec3&amp; pointToLookAt,
-                             const Vec3&amp; up)
+OpenSteer::drawCameraLookAt (const Vector3&amp; cameraPosition,
+                             const Vector3&amp; pointToLookAt,
+                             const Vector3&amp; up)
 {
     // check for valid &quot;look at&quot; parameters
     drawCameraLookAtCheck (cameraPosition, pointToLookAt, up);
@@ -849,8 +849,8 @@
 
 
 void 
-OpenSteer::draw2dLine (const Vec3&amp; startPoint,
-                       const Vec3&amp; endPoint,
+OpenSteer::draw2dLine (const Vector3&amp; startPoint,
+                       const Vector3&amp; endPoint,
                        const Color&amp; color, 
                        float w, float h)
 {
@@ -872,16 +872,16 @@
     const int a = 10;
     const int b = 30;
 
-    draw2dLine (Vec3 (w+a, h,   0), Vec3 (w+b, h,   0), gWhite, w, h);
-    draw2dLine (Vec3 (w,   h+a, 0), Vec3 (w,   h+b, 0), gWhite, w, h);
-    draw2dLine (Vec3 (w-a, h,   0), Vec3 (w-b, h,   0), gWhite, w, h);
-    draw2dLine (Vec3 (w,   h-a, 0), Vec3 (w,   h-b, 0), gWhite, w, h);
+    draw2dLine (Vector3 (w+a, h,   0), Vector3 (w+b, h,   0), gWhite, w, h);
+    draw2dLine (Vector3 (w,   h+a, 0), Vector3 (w,   h+b, 0), gWhite, w, h);
+    draw2dLine (Vector3 (w-a, h,   0), Vector3 (w-b, h,   0), gWhite, w, h);
+    draw2dLine (Vector3 (w,   h-a, 0), Vector3 (w,   h-b, 0), gWhite, w, h);
 
     glLineWidth (3);
-    draw2dLine (Vec3 (w+a, h,   0), Vec3 (w+b, h,   0), gBlack, w, h);
-    draw2dLine (Vec3 (w,   h+a, 0), Vec3 (w,   h+b, 0), gBlack, w, h);
-    draw2dLine (Vec3 (w-a, h,   0), Vec3 (w-b, h,   0), gBlack, w, h);
-    draw2dLine (Vec3 (w,   h-a, 0), Vec3 (w,   h-b, 0), gBlack, w, h);
+    draw2dLine (Vector3 (w+a, h,   0), Vector3 (w+b, h,   0), gBlack, w, h);
+    draw2dLine (Vector3 (w,   h+a, 0), Vector3 (w,   h+b, 0), gBlack, w, h);
+    draw2dLine (Vector3 (w-a, h,   0), Vector3 (w-b, h,   0), gBlack, w, h);
+    draw2dLine (Vector3 (w,   h-a, 0), Vector3 (w,   h-b, 0), gBlack, w, h);
     glLineWidth (1);
 }
 
@@ -893,9 +893,9 @@
 
 //     // xxx --------------------------------------------------
 //     {
-//         const Vec3 p = gSelectedVehicle-&gt;position;
-//         const Vec3 f = gSelectedVehicle-&gt;forward;
-//         const Vec3 s = gSelectedVehicle-&gt;side * 0.25f;
+//         const Vector3 p = gSelectedVehicle-&gt;position;
+//         const Vector3 f = gSelectedVehicle-&gt;forward;
+//         const Vector3 s = gSelectedVehicle-&gt;side * 0.25f;
 //         for (float i = 0; i &lt;= 5; i++)
 //         {
 //             drawLine (p + (f * +i) + s, p + (f * +i) - s, gGray60);
@@ -921,7 +921,7 @@
 // given point on the screen: the ray that would be traced for that pixel
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::directionFromCameraToScreenPosition (int x, int y, int h)
 {
     // Get window height, viewport, modelview and projection matrices
@@ -938,8 +938,8 @@
 
     // &quot;direction&quot; is the normalized difference between these far and near
     // unprojected points.  Its parallel to the &quot;eye-mouse&quot; selection line.
-    const Vec3 diffNearFar (un1x-un0x, un1y-un0y, un1z-un0z);
-    const Vec3 direction = diffNearFar.normalize ();
+    const Vector3 diffNearFar (un1x-un0x, un1y-un0y, un1z-un0z);
+    const Vector3 direction = diffNearFar.normalisedCopy();
     return direction;
 }
 
@@ -957,8 +957,8 @@
     {
     public:
 
-        static void addToBuffer (const OpenSteer::Vec3&amp; s,
-                                 const OpenSteer::Vec3&amp; e,
+        static void addToBuffer (const Vector3&amp; s,
+                                 const Vector3&amp; e,
                                  const OpenSteer::Color&amp; c)
         {
             DeferredLine dl;
@@ -988,8 +988,8 @@
 
     private:
 
-        OpenSteer::Vec3 startPoint;
-        OpenSteer::Vec3 endPoint;
+        Vector3 startPoint;
+        Vector3 endPoint;
         OpenSteer::Color color;
 
         static DeferredLines lines;
@@ -1003,8 +1003,8 @@
 
 
 void 
-OpenSteer::deferredDrawLine (const Vec3&amp; startPoint,
-                             const Vec3&amp; endPoint,
+OpenSteer::deferredDrawLine (const Vector3&amp; startPoint,
+                             const Vector3&amp; endPoint,
                              const Color&amp; color)
 {
     DeferredLine::addToBuffer (startPoint, endPoint, color);
@@ -1033,8 +1033,8 @@
     public:
 
         static void addToBuffer (const float radius,
-                                 const OpenSteer::Vec3&amp; axis,
-                                 const OpenSteer::Vec3&amp; center,
+                                 const Vector3&amp; axis,
+                                 const Vector3&amp; center,
                                  const OpenSteer::Color&amp; color,
                                  const int segments,
                                  const bool filled,
@@ -1072,8 +1072,8 @@
     private:
 
         float radius;
-        OpenSteer::Vec3 axis;
-        OpenSteer::Vec3 center;
+        Vector3 axis;
+        Vector3 center;
         OpenSteer::Color color;
         int segments;
         bool filled;
@@ -1091,8 +1091,8 @@
 
 void 
 OpenSteer::deferredDrawCircleOrDisk (const float radius,
-                                     const Vec3&amp; axis,
-                                     const Vec3&amp; center,
+                                     const Vector3&amp; axis,
+                                     const Vector3&amp; center,
                                      const Color&amp; color,
                                      const int segments,
                                      const bool filled,
@@ -1147,7 +1147,7 @@
 //         const int fontHeight = 15; // for GLUT_BITMAP_9_BY_15
 //         const int x = w - (fontWidth * s.pcount());
 //         const int y = h - (fontHeight + 5);
-//         const Vec3 screenLocation (x, y, 0);
+//         const Vector3 screenLocation (x, y, 0);
 //         draw2dTextAt2dLocation (s, screenLocation, gWhite);
 //     }
 
@@ -1155,8 +1155,8 @@
 
 // // void draw2dTextAt3dLocation (const char* s,
 // void draw2dTextAt3dLocation (const char* const s,
-//                              const Vec3 location,
-//                              const Vec3 color)
+//                              const Vector3 location,
+//                              const Vector3 color)
 // {
 //     // set text color and raster position
 //     glColor3f (color.r(), color.g(), color.b());
@@ -1186,8 +1186,8 @@
 
 // // void draw2dTextAt2dLocation (char* s,
 // void draw2dTextAt2dLocation (const char* const s,
-//                              const Vec3 location,
-//                              const Vec3 color)
+//                              const Vector3 location,
+//                              const Vector3 color)
 // {
 //     // store OpenGL matrix mode
 //     int savedMatrixMode;
@@ -1269,8 +1269,8 @@
 
 
 // void draw2dTextAt3dLocation (const char* const s,
-//                              const Vec3 location,
-//                              const Vec3 color)
+//                              const Vector3 location,
+//                              const Vector3 color)
 // {
 //     // set text color and raster position
 //     glColor3f (color.r(), color.g(), color.b());
@@ -1299,8 +1299,8 @@
 
 
 // void draw2dTextAt2dLocation (const char* const s,
-//                              const Vec3 location,
-//                              const Vec3 color)
+//                              const Vector3 location,
+//                              const Vector3 color)
 // {
 // //     // store OpenGL matrix mode
 // //     int savedMatrixMode;
@@ -1385,8 +1385,8 @@
 
 
 // void draw2dTextAt3dLocation (const char* const s,
-//                              const Vec3 location,
-//                              const Vec3 color)
+//                              const Vector3 location,
+//                              const Vector3 color)
 // {
 //     // set text color and raster position
 //     glColor3f (color.r(), color.g(), color.b());
@@ -1423,8 +1423,8 @@
 
 
 // void draw2dTextAt2dLocation (const char* const s,
-//                              const Vec3 location,
-//                              const Vec3 color)
+//                              const Vector3 location,
+//                              const Vector3 color)
 // {
 //     begin2dDrawing ();
 
@@ -1442,8 +1442,8 @@
 
 
 // void draw2dTextAt3dLocation (const char* const s,
-//                              const Vec3 location,
-//                              const Vec3 color)
+//                              const Vector3 location,
+//                              const Vector3 color)
 // {
 //     // set text color and raster position
 //     glColor3f (color.r(), color.g(), color.b());
@@ -1483,8 +1483,8 @@
 
 
 // void draw2dTextAt2dLocation (const char* const s,
-//                              const Vec3 location,
-//                              const Vec3 color)
+//                              const Vector3 location,
+//                              const Vector3 color)
 // {
 //     const GLint originalMatrixMode = begin2dDrawing ();
 
@@ -1498,7 +1498,7 @@
 
 void 
 OpenSteer::draw2dTextAt3dLocation (const char&amp; text,
-                                   const Vec3&amp; location,
+                                   const Vector3&amp; location,
                                    const Color&amp; color, float w, float h)
 {
     // XXX NOTE: &quot;it would be nice if&quot; this had a 2d screenspace offset for
@@ -1547,7 +1547,7 @@
 
 void 
 OpenSteer::draw2dTextAt3dLocation (const std::ostringstream&amp; text,
-                                   const Vec3&amp; location,
+                                   const Vector3&amp; location,
                                    const Color&amp; color, float w, float h)
 {
     draw2dTextAt3dLocation (*text.str().c_str(), location, color, w, h);
@@ -1556,7 +1556,7 @@
 
 void 
 OpenSteer::draw2dTextAt2dLocation (const char&amp; text,
-                                   const Vec3 location,
+                                   const Vector3 location,
                                    const Color&amp; color, float w, float h)
 {
     const GLint originalMatrixMode = begin2dDrawing (w, h);
@@ -1571,7 +1571,7 @@
 
 void 
 OpenSteer::draw2dTextAt2dLocation (const std::ostringstream&amp; text,
-                                   const Vec3 location,
+                                   const Vector3 location,
                                    const Color&amp; color, float w, float h)
 {
     draw2dTextAt2dLocation (*text.str().c_str(), location, color, w, h);
@@ -1596,37 +1596,37 @@
     class DrawSphereHelper
     {
     public:
-        Vec3 center;
+        Vector3 center;
         float radius;
         float maxEdgeLength;
         bool filled;
         Color color;
         bool drawFrontFacing;
         bool drawBackFacing;
-        Vec3 viewpoint;
+        Vector3 viewpoint;
 
         // default constructor (at origin, radius=1, white, wireframe, nocull)
         DrawSphereHelper ()
-            : center (Vec3::zero),
+            : center (Vector3::ZERO),
               radius (1.0f),
               maxEdgeLength (1.0f),
               filled (false),
               color (gWhite),
               drawFrontFacing (true),
               drawBackFacing (true),
-              viewpoint (Vec3::zero)
+              viewpoint (Vector3::ZERO)
         {}
 
 
         // &quot;kitchen sink&quot; constructor (allows specifying everything)
-        DrawSphereHelper (const Vec3 _center,
+        DrawSphereHelper (const Vector3 _center,
                           const float _radius,
                           const float _maxEdgeLength,
                           const bool _filled,
                           const Color&amp; _color,
                           const bool _drawFrontFacing,
                           const bool _drawBackFacing,
-                          const Vec3&amp; _viewpoint)
+                          const Vector3&amp; _viewpoint)
             : center (_center),
               radius (_radius),
               maxEdgeLength (_maxEdgeLength),
@@ -1652,18 +1652,18 @@
             const float b = (radius / ratio) / (2.0f * phi);
 
             // define the icosahedron's 12 vertices:
-            const Vec3 v1  = center + Vec3 ( 0,  b, -a);
-            const Vec3 v2  = center + Vec3 ( b,  a,  0);
-            const Vec3 v3  = center + Vec3 (-b,  a,  0);
-            const Vec3 v4  = center + Vec3 ( 0,  b,  a);
-            const Vec3 v5  = center + Vec3 ( 0, -b,  a);
-            const Vec3 v6  = center + Vec3 (-a,  0,  b);
-            const Vec3 v7  = center + Vec3 ( 0, -b, -a);
-            const Vec3 v8  = center + Vec3 ( a,  0, -b);
-            const Vec3 v9  = center + Vec3 ( a,  0,  b);
-            const Vec3 v10 = center + Vec3 (-a,  0, -b);
-            const Vec3 v11 = center + Vec3 ( b, -a,  0);
-            const Vec3 v12 = center + Vec3 (-b, -a,  0);
+            const Vector3 v1  = center + Vector3 ( 0,  b, -a);
+            const Vector3 v2  = center + Vector3 ( b,  a,  0);
+            const Vector3 v3  = center + Vector3 (-b,  a,  0);
+            const Vector3 v4  = center + Vector3 ( 0,  b,  a);
+            const Vector3 v5  = center + Vector3 ( 0, -b,  a);
+            const Vector3 v6  = center + Vector3 (-a,  0,  b);
+            const Vector3 v7  = center + Vector3 ( 0, -b, -a);
+            const Vector3 v8  = center + Vector3 ( a,  0, -b);
+            const Vector3 v9  = center + Vector3 ( a,  0,  b);
+            const Vector3 v10 = center + Vector3 (-a,  0, -b);
+            const Vector3 v11 = center + Vector3 ( b, -a,  0);
+            const Vector3 v12 = center + Vector3 (-b, -a,  0);
 
             // draw the icosahedron's 20 triangular faces:
             drawMeshedTriangleOnSphere (v1, v2, v3);
@@ -1690,10 +1690,10 @@
 
 
         // given two points, take midpoint and project onto this sphere
-        inline Vec3 midpointOnSphere (const Vec3&amp; a, const Vec3&amp; b) const
+        inline Vector3 midpointOnSphere (const Vector3&amp; a, const Vector3&amp; b) const
         {
-            const Vec3 midpoint = (a + b) * 0.5f;
-            const Vec3 unitRadial = (midpoint - center).normalize ();
+            const Vector3 midpoint = (a + b) * 0.5f;
+            const Vector3 unitRadial = (midpoint - center).normalisedCopy();
             return center + (unitRadial * radius);
         }
 
@@ -1701,9 +1701,9 @@
         // given three points on the surface of this sphere, if the triangle
         // is &quot;small enough&quot; draw it, otherwise subdivide it into four smaller
         // triangles and recursively draw each of them.
-        void drawMeshedTriangleOnSphere (const Vec3&amp; a, 
-                                         const Vec3&amp; b,
-                                         const Vec3&amp; c) const
+        void drawMeshedTriangleOnSphere (const Vector3&amp; a, 
+                                         const Vector3&amp; b,
+                                         const Vector3&amp; c) const
         {
             // if all edges are short enough
             if ((((a - b).length ()) &lt; maxEdgeLength) &amp;&amp;
@@ -1716,9 +1716,9 @@
             else // otherwise subdivide and recurse
             {
                 // find edge midpoints
-                const Vec3 ab = midpointOnSphere (a, b);
-                const Vec3 bc = midpointOnSphere (b, c);
-                const Vec3 ca = midpointOnSphere (c, a);
+                const Vector3 ab = midpointOnSphere (a, b);
+                const Vector3 bc = midpointOnSphere (b, c);
+                const Vector3 ca = midpointOnSphere (c, a);
 
                 // recurse on four sub-triangles
                 drawMeshedTriangleOnSphere ( a, ab, ca);
@@ -1730,16 +1730,16 @@
 
 
         // draw one mesh element for drawMeshedTriangleOnSphere
-        void drawTriangleOnSphere (const Vec3&amp; a, 
-                                   const Vec3&amp; b,
-                                   const Vec3&amp; c) const
+        void drawTriangleOnSphere (const Vector3&amp; a, 
+                                   const Vector3&amp; b,
+                                   const Vector3&amp; c) const
         {
             // draw triangle, subject to the camera orientation criteria
             // (according to drawBackFacing and drawFrontFacing)
-            const Vec3 triCenter = (a + b + c) / 3.0f;
-            const Vec3 triNormal = triCenter - center; // not unit length
-            const Vec3 view = triCenter - viewpoint;
-            const float dot = view.dot (triNormal); // project normal on view
+            const Vector3 triCenter = (a + b + c) / 3.0f;
+            const Vector3 triNormal = triCenter - center; // not unit length
+            const Vector3 view = triCenter - viewpoint;
+            const float dot = view.dotProduct(triNormal); // project normal on view
             const bool seen = ((dot&gt;0.0f) ? drawBackFacing : drawFrontFacing);
             if (seen)
             {
@@ -1756,7 +1756,7 @@
                     // draw triangle edges (use trick to avoid drawing each
                     // edge twice (for each adjacent triangle) unless we are
                     // culling and this tri is near the sphere's silhouette)
-                    const float unitDot = view.dot (triNormal.normalize ());
+                    const float unitDot = view.dotProduct(triNormal.normalisedCopy());
                     const float t = 0.05f; // near threshold
                     const bool nearSilhouette = (unitDot&lt;t) || (unitDot&gt;-t);
                     if (nearSilhouette &amp;&amp; !(drawBackFacing&amp;&amp;drawFrontFacing))
@@ -1779,8 +1779,8 @@
         // Draws line from A to B but not from B to A: assumes each edge
         // will be drawn in both directions, picks just one direction for
         // drawing according to an arbitary but reproducable criterion.
-        void drawMeshedTriangleLine (const Vec3&amp; a, 
-                                     const Vec3&amp; b,
+        void drawMeshedTriangleLine (const Vector3&amp; a, 
+                                     const Vector3&amp; b,
                                      const Color&amp; color) const
         {
             if (a.x != b.x)
@@ -1804,14 +1804,14 @@
 
 
     // draw a sphere (wireframe or opaque, with front/back/both culling)
-    void drawSphere (const Vec3 center,
+    void drawSphere (const Vector3 center,
                      const float radius,
                      const float maxEdgeLength,
                      const bool filled,
                      const Color&amp; color,
                      const bool drawFrontFacing,
                      const bool drawBackFacing,
-                     const Vec3&amp; viewpoint)
+                     const Vector3&amp; viewpoint)
     {
         const DrawSphereHelper s (center, radius, maxEdgeLength, filled, color,
                                   drawFrontFacing, drawBackFacing, viewpoint);
@@ -1824,7 +1824,7 @@
                              const float maxEdgeLength,
                              const bool filled,
                              const Color&amp; color,
-                             const Vec3&amp; viewpoint)
+                             const Vector3&amp; viewpoint)
     {
         bool front, back;
         switch (so.seenFrom ())

Modified: dependencies/opensteer/src/Obstacle.cpp
===================================================================
--- dependencies/opensteer/src/Obstacle.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/Obstacle.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -44,7 +44,7 @@
 // compute steering for a vehicle to avoid this obstacle, if needed 
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::Obstacle::steerToAvoid (const AbstractVehicle&amp; vehicle,
                                    const float minTimeToCollision) const
 {
@@ -62,7 +62,7 @@
 // static method to apply steerToAvoid to nearest obstacle in an ObstacleGroup
 
 
-OpenSteer::Vec3
+Vector3
 OpenSteer::Obstacle::
 steerToAvoidObstacles (const AbstractVehicle&amp; vehicle,
                        const float minTimeToCollision,
@@ -120,7 +120,7 @@
 // determine steering once path intersections have been found
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::Obstacle::PathIntersection::
 steerToAvoidIfNeeded (const AbstractVehicle&amp; vehicle,
                       const float minTimeToCollision) const
@@ -132,12 +132,12 @@
         // compute avoidance steering force: take the component of
         // steerHint which is lateral (perpendicular to vehicle's
         // forward direction), set its length to vehicle's maxForce
-        Vec3 lateral = steerHint.perpendicularComponent (vehicle.forward ());
-        return lateral.normalize () * vehicle.maxForce ();
+        Vector3 lateral = Vec3Utils::perpendicularComponent(steerHint, vehicle.forward ());
+        return lateral.normalisedCopy() * vehicle.maxForce ();
     }
     else
     {
-        return Vec3::zero;
+        return Vector3::ZERO;
     }
 }
 
@@ -161,7 +161,7 @@
     // simplifies some of the calculations.
 
     float b, c, d, p, q, s;
-    Vec3 lc;
+    Vector3 lc;
 
     // initialize pathIntersection object to &quot;no intersection found&quot;
     pi.intersect = false;
@@ -204,7 +204,7 @@
          ((p &gt; 0) ? p : q));
     pi.surfacePoint =
         vehicle.position() + (vehicle.forward() * pi.distance);
-    pi.surfaceNormal = (pi.surfacePoint-center).normalize();
+    pi.surfaceNormal = (pi.surfacePoint-center).normalisedCopy();
     // hmm, note that this was actually determined already in pi.distance calc
     pi.vehicleOutside = lc.length () &gt; radius;
     switch (seenFrom ())
@@ -237,13 +237,13 @@
     const float w = width; // dimensions
     const float h = height;
     const float d = depth;
-    const Vec3 s = side (); // local space
-    const Vec3 u = up ();
-    const Vec3 f = forward ();
-    const Vec3 p = position ();
-    const Vec3 hw = s * (0.5f * width); // offsets for face centers
-    const Vec3 hh = u * (0.5f * height);
-    const Vec3 hd = f * (0.5f * depth);
+    const Vector3 s = side (); // local space
+    const Vector3 u = up ();
+    const Vector3 f = forward ();
+    const Vector3 p = position ();
+    const Vector3 hw = s * (0.5f * width); // offsets for face centers
+    const Vector3 hh = u * (0.5f * height);
+    const Vector3 hd = f * (0.5f * depth);
     const seenFromState sf = seenFrom ();
 
     // the box's six rectangular faces
@@ -271,7 +271,7 @@
     if (pi.intersect)
     {
         pi.obstacle = this;
-        pi.steerHint = ((pi.surfacePoint - position ()).normalize () *
+        pi.steerHint = ((pi.surfacePoint - position ()).normalisedCopy() *
                         (pi.vehicleOutside ? 1.0f : -1.0f));
     }
 }
@@ -291,11 +291,11 @@
     // initialize pathIntersection object to &quot;no intersection found&quot;
     pi.intersect = false;
 
-    const Vec3 lp =  localizePosition (vehicle.position ());
-    const Vec3 ld = localizeDirection (vehicle.forward ());
+    const Vector3 lp =  localizePosition (vehicle.position ());
+    const Vector3 ld = localizeDirection (vehicle.forward ());
 
     // no obstacle intersection if path is parallel to XY (side/up) plane
-    if (ld.dot (Vec3::forward) == 0.0f) return;
+    if (ld.dotProduct(Vector3::NEGATIVE_UNIT_Z) == 0.0f) return;
 
     // no obstacle intersection if vehicle is heading away from the XY plane
     if ((lp.z &gt; 0.0f) &amp;&amp; (ld.z &gt; 0.0f)) return;
@@ -308,16 +308,16 @@
     // find intersection of path with rectangle's plane (XY plane)
     const float ix = lp.x - (ld.x * lp.z / ld.z);
     const float iy = lp.y - (ld.y * lp.z / ld.z);
-    const Vec3 planeIntersection (ix, iy, 0.0f);
+    const Vector3 planeIntersection (ix, iy, 0.0f);
 
     // no obstacle intersection if plane intersection is outside 2d shape
     if (!xyPointInsideShape (planeIntersection, vehicle.radius ())) return;
 
     // otherwise, the vehicle path DOES intersect this rectangle
-    const Vec3 localXYradial = planeIntersection.normalize ();
-    const Vec3 radial = globalizeDirection (localXYradial);
+    const Vector3 localXYradial = planeIntersection.normalisedCopy();
+    const Vector3 radial = globalizeDirection (localXYradial);
     const float sideSign = (lp.z &gt; 0.0f) ? +1.0f : -1.0f;
-    const Vec3 opposingNormal = forward () * sideSign;
+    const Vector3 opposingNormal = forward () * sideSign;
     pi.intersect = true;
     pi.obstacle = this;
     pi.distance = (lp - planeIntersection).length ();
@@ -336,7 +336,7 @@
 bool 
 OpenSteer::
 RectangleObstacle::
-xyPointInsideShape (const Vec3&amp; point, float radius) const
+xyPointInsideShape (const Vector3&amp; point, float radius) const
 {
     const float w = radius + (width * 0.5f);
     const float h = radius + (height * 0.5f);

Modified: dependencies/opensteer/src/OldPathway.cpp
===================================================================
--- dependencies/opensteer/src/OldPathway.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/OldPathway.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -47,7 +47,7 @@
 
 
 OpenSteer::Old::PolylinePathway::PolylinePathway (const int _pointCount,
-                                                  const Vec3 _points[],
+                                                  const Vector3 _points[],
                                                   const float _radius,
                                                   const bool _cyclic)
 {
@@ -61,7 +61,7 @@
 
 void 
 OpenSteer::Old::PolylinePathway::initialize (const int _pointCount,
-                                             const Vec3 _points[],
+                                             const Vector3 _points[],
                                              const float _radius,
                                              const bool _cyclic)
 {
@@ -71,8 +71,8 @@
     pointCount = _pointCount;
     if (cyclic) pointCount++;
     lengths = new float    [pointCount];
-    points  = new Vec3 [pointCount];
-    normals = new Vec3 [pointCount];
+    points  = new Vector3 [pointCount];
+    normals = new Vector3 [pointCount];
 
     // loop over all points
     for (int i = 0; i &lt; pointCount; i++)
@@ -117,7 +117,7 @@
 void 
 OpenSteer::Old::PolylinePathway::movePoints (const int _firstPoint,
                                              const int _numPoints,
-                                             const Vec3 _points[])
+                                             const Vector3 _points[])
 {
     // loop over all points
     for (int i = _firstPoint; i &lt; _firstPoint + _numPoints; i++)
@@ -141,14 +141,14 @@
 // that a negative distance indicates A is inside the Pathway.
 
 
-OpenSteer::Vec3 
-OpenSteer::Old::PolylinePathway::mapPointToPath (const Vec3&amp; point,
-                                                 Vec3&amp; tangent,
+Vector3 
+OpenSteer::Old::PolylinePathway::mapPointToPath (const Vector3&amp; point,
+                                                 Vector3&amp; tangent,
                                                  float&amp; outside)
 {
     float d;
     float minDistance = FLT_MAX;
-    Vec3 onPath;
+    Vector3 onPath;
 
     // loop over all segments, find the one nearest to the given point
     for (int i = 1; i &lt; pointCount; i++)
@@ -165,7 +165,7 @@
     }
 
     // measure how far original point is outside the Pathway's &quot;tube&quot;
-    outside = Vec3::distance (onPath, point) - radius;
+    outside = onPath.distance(point) - radius;
 
     // return point on path
     return onPath;
@@ -177,7 +177,7 @@
 
 
 float 
-OpenSteer::Old::PolylinePathway::mapPointToPathDistance (const Vec3&amp; point)
+OpenSteer::Old::PolylinePathway::mapPointToPathDistance (const Vector3&amp; point)
 {
     float d;
     float minDistance = FLT_MAX;
@@ -206,7 +206,7 @@
 // given a distance along the path, convert it to a point on the path
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::Old::PolylinePathway::mapPathDistanceToPoint (float pathDistance)
 {
     // clip or wrap given path distance according to cyclic flag
@@ -224,7 +224,7 @@
     // step through segments, subtracting off segment lengths until
     // locating the segment that contains the original pathDistance.
     // Interpolate along that segment to find 3d point value to return.
-    Vec3 result;
+    Vector3 result;
     for (int i = 1; i &lt; pointCount; i++)
     {
         segmentLength = lengths[i];
@@ -251,15 +251,15 @@
 
 
 float 
-OpenSteer::Old::PolylinePathway::pointToSegmentDistance (const Vec3&amp; point,
-                                                         const Vec3&amp; ep0,
-                                                         const Vec3&amp; ep1)
+OpenSteer::Old::PolylinePathway::pointToSegmentDistance (const Vector3&amp; point,
+                                                         const Vector3&amp; ep0,
+                                                         const Vector3&amp; ep1)
 {
     // convert the test point to be &quot;local&quot; to ep0
     local = point - ep0;
 
     // find the projection of &quot;local&quot; onto &quot;segmentNormal&quot;
-    segmentProjection = segmentNormal.dot (local);
+    segmentProjection = segmentNormal.dotProduct(local);
 
     // handle boundary cases: when projection is not on segment, the
     // nearest point is one of the endpoints of the segment
@@ -267,19 +267,19 @@
     {
         chosen = ep0;
         segmentProjection = 0;
-        return Vec3::distance (point, ep0);
+        return point.distance(ep0);
     }
     if (segmentProjection &gt; segmentLength)
     {
         chosen = ep1;
         segmentProjection = segmentLength;
-        return Vec3::distance (point, ep1);
+        return point.distance(ep1);
     }
 
     // otherwise nearest point is projection point on segment
     chosen = segmentNormal * segmentProjection;
     chosen +=  ep0;
-    return Vec3::distance (point, chosen);
+    return point.distance(chosen);
 }
 
 

Modified: dependencies/opensteer/src/OpenSteerDemo.cpp
===================================================================
--- dependencies/opensteer/src/OpenSteerDemo.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/OpenSteerDemo.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -451,7 +451,7 @@
 OpenSteer::OpenSteerDemo::findVehicleNearestScreenPosition (int x, int y)
 {
     // find the direction from the camera position to the given pixel
-    const Vec3 direction = directionFromCameraToScreenPosition (x, y, glutGet (GLUT_WINDOW_HEIGHT));
+    const Vector3 direction = directionFromCameraToScreenPosition (x, y, glutGet (GLUT_WINDOW_HEIGHT));
 
     // iterate over all vehicles to find the one whose center is nearest the
     // &quot;eye-mouse&quot; selection line
@@ -541,7 +541,7 @@
     selectedVehicle = &selected;
     if (&amp;selected)
     {
-        const Vec3 behind = selected.forward() * -distance;
+        const Vector3 behind = selected.forward() * -distance;
         camera.setPosition (selected.position() + behind);
         camera.target = selected.position();
     }
@@ -563,7 +563,7 @@
     position3dCamera (selected, distance, elevation);
 
     // then adjust for 3d:
-    Vec3 position3d = camera.position();
+    Vector3 position3d = camera.position();
     position3d.y += elevation;
     camera.setPosition (position3d);
 }
@@ -589,7 +589,7 @@
 
 const float OpenSteer::OpenSteerDemo::camera2dElevation = 8;
 const float OpenSteer::OpenSteerDemo::cameraTargetDistance = 13;
-const OpenSteer::Vec3 OpenSteer::OpenSteerDemo::cameraTargetOffset (0, OpenSteer::OpenSteerDemo::camera2dElevation, 
+const Vector3 OpenSteer::OpenSteerDemo::cameraTargetOffset (0, OpenSteer::OpenSteerDemo::camera2dElevation, 
                                                                     0);
 
 
@@ -598,12 +598,12 @@
 
 
 void 
-OpenSteer::OpenSteerDemo::gridUtility (const Vec3&amp; gridTarget)
+OpenSteer::OpenSteerDemo::gridUtility (const Vector3&amp; gridTarget)
 {
     // round off target to the nearest multiple of 2 (because the
     // checkboard grid with a pitch of 1 tiles with a period of 2)
     // then lower the grid a bit to put it under 2d annotation lines
-    const Vec3 gridCenter ((round (gridTarget.x * 0.5f) * 2),
+    const Vector3 gridCenter ((round (gridTarget.x * 0.5f) * 2),
                            (round (gridTarget.y * 0.5f) * 2) - .05f,
                            (round (gridTarget.z * 0.5f) * 2));
 
@@ -657,7 +657,7 @@
     if (&amp;v)
     {
         const float diameter = v.radius() * 2;
-        const Vec3 size (diameter, diameter, diameter);
+        const Vector3 size (diameter, diameter, diameter);
         drawBoxOutline (v, size, color);
     }
 }
@@ -676,7 +676,7 @@
 {
     if (&amp;v)
     {
-        const Vec3&amp; cPosition = camera.position();
+        const Vector3&amp; cPosition = camera.position();
         draw3dCircle  (v.radius() * radiusMultiplier,  // adjusted radius
                        v.position(),                   // center
                        v.position() - cPosition,       // view axis
@@ -988,7 +988,7 @@
             gMouseAdjustingCameraLastX = x;
             gMouseAdjustingCameraLastY = y;
 
-            OpenSteer::Vec3 cameraAdjustment;
+            Vector3 cameraAdjustment;
 
             // set XY values according to mouse motion on screen space
             if (gMouseAdjustingCameraAngle)
@@ -1041,7 +1041,7 @@
     drawDisplayPlugInName (void)
     {
         const float h = glutGet (GLUT_WINDOW_HEIGHT);
-        const OpenSteer::Vec3 screenLocation (10, h-20, 0);
+        const Vector3 screenLocation (10, h-20, 0);
         draw2dTextAt2dLocation (*OpenSteer::OpenSteerDemo::nameOfSelectedPlugIn (),
                                 screenLocation,
                                 OpenSteer::gWhite, OpenSteer::drawGetWindowWidth(), OpenSteer::drawGetWindowHeight());
@@ -1057,7 +1057,7 @@
     {
         std::ostringstream message;
         message &lt;&lt; &quot;Camera: &quot; &lt;&lt; OpenSteer::OpenSteerDemo::camera.modeName () &lt;&lt; std::ends;
-        const OpenSteer::Vec3 screenLocation (10, 10, 0);
+        const Vector3 screenLocation (10, 10, 0);
         OpenSteer::draw2dTextAt2dLocation (message, screenLocation, OpenSteer::gWhite, OpenSteer::drawGetWindowWidth(), OpenSteer::drawGetWindowHeight());
     }
 
@@ -1124,7 +1124,7 @@
             // keep track of font metrics and start of next line
             const int lh = 16; // xxx line height
             const int cw = 9; // xxx character width
-            OpenSteer::Vec3 screenLocation (10, 10, 0);
+            Vector3 screenLocation (10, 10, 0);
 
             // target and recent average frame rates
             const int targetFPS = OpenSteer::OpenSteerDemo::clock.getFixedFrameRate ();
@@ -1155,7 +1155,7 @@
                     clockStr &lt;&lt; &quot;fixed frame rate (target: &quot; &lt;&lt; targetFPS;
                     clockStr &lt;&lt; &quot; actual: &quot; &lt;&lt; OpenSteer::round(smoothedFPS) &lt;&lt; &quot;, &quot;;
 
-                    OpenSteer::Vec3 sp;
+                    Vector3 sp;
                     sp = screenLocation;
                     sp.x += cw * (int) clockStr.tellp ();
 

Modified: dependencies/opensteer/src/PolylineSegmentedPath.cpp
===================================================================
--- dependencies/opensteer/src/PolylineSegmentedPath.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/PolylineSegmentedPath.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -38,7 +38,7 @@
 
 
 
-// Include OpenSteer::Vec3
+// Include Vector3
 #include &quot;OpenSteer/Vec3.h&quot;
 
 // Include OpenSteer::mapPointToPathway, OpenSteer::mapDistanceToPointOnPathCenterLine
@@ -58,7 +58,7 @@
 namespace {
     
     typedef OpenSteer::SegmentedPath::size_type size_type;
-    typedef std::vector&lt; OpenSteer::Vec3 &gt; Vec3Container;
+    typedef std::vector&lt; Vector3 &gt; Vec3Container;
     typedef std::vector&lt; float &gt; FloatContainer;
     
     /**
@@ -79,7 +79,7 @@
                 &quot;segmentIndex out of range.&quot; );
         assert( segmentTangents.size() == segmentLengths.size() &amp;&amp; &quot;segmentTangents and segmentLengths must have the same size.&quot; );
         
-        OpenSteer::Vec3 tangent = points[ segmentIndex + 1 ] - points[ segmentIndex ];
+        Vector3 tangent = points[ segmentIndex + 1 ] - points[ segmentIndex ];
         float const length = tangent.length();
         assert( ! OpenSteer::isZero( length ) &amp;&amp; 
                 &quot;Segments must have lengths greater than 0.&quot; );
@@ -200,7 +200,7 @@
 
 
 OpenSteer::PolylineSegmentedPath::PolylineSegmentedPath( size_type numOfPoints,
-                                                         Vec3 const newPoints[],
+                                                         Vector3 const newPoints[],
                                                          bool closedCycle )
     : points_( 0 ), segmentTangents_( 0 ), segmentLengths_( 0 ), closedCycle_( closedCycle )
 {
@@ -247,7 +247,7 @@
 
 void 
 OpenSteer::PolylineSegmentedPath::setPath( size_type numOfPoints,
-                                           Vec3 const newPoints[],
+                                           Vector3 const newPoints[],
                                            bool closedCycle )
 {
     assert( 1 &lt; numOfPoints &amp;&amp; &quot;Path must have at least two distinct points.&quot; );
@@ -289,7 +289,7 @@
 void 
 OpenSteer::PolylineSegmentedPath::movePoints( size_type startIndex,
                                               size_type numOfPoints,
-                                              Vec3 const newPoints[] )
+                                              Vector3 const newPoints[] )
 {
     assert( ( startIndex &lt; ( pointCount() - ( isCyclic() ? 1 : 0 ) ) ) &amp;&amp; 
             &quot;startIndex must be inside index range.&quot; );
@@ -329,9 +329,9 @@
 
 
 
-OpenSteer::Vec3 
-OpenSteer::PolylineSegmentedPath::mapPointToPath (const Vec3&amp; point,
-                                                  Vec3&amp; tangent,
+Vector3 
+OpenSteer::PolylineSegmentedPath::mapPointToPath (const Vector3&amp; point,
+                                                  Vector3&amp; tangent,
                                                   float&amp; outside) const
 {
     PointToPathMapping mapping;
@@ -342,7 +342,7 @@
 }
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPath::mapPathDistanceToPoint (float pathDistance) const
 {
     PathDistanceToPointMapping mapping;
@@ -352,7 +352,7 @@
 
 
 float 
-OpenSteer::PolylineSegmentedPath::mapPointToPathDistance (const Vec3&amp; point) const
+OpenSteer::PolylineSegmentedPath::mapPointToPathDistance (const Vector3&amp; point) const
 {
     PointToPathDistanceMapping mapping;
     mapPointToPathAlike( *this, point, mapping );
@@ -382,7 +382,7 @@
 
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPath::point( size_type pointIndex ) const
 {
     assert( pointIndex &lt; pointCount() &amp;&amp; &quot;pointIndex out of range.&quot; );
@@ -407,7 +407,7 @@
 }
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPath::segmentStart( size_type segmentIndex ) const
 {
     assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
@@ -416,7 +416,7 @@
 }
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPath::segmentEnd( size_type segmentIndex ) const
 {
     assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
@@ -428,18 +428,18 @@
 
 float 
 OpenSteer::PolylineSegmentedPath::mapPointToSegmentDistance( size_type segmentIndex, 
-                                                             Vec3 const&amp; point ) const
+                                                             Vector3 const&amp; point ) const
 {
     assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex is out of range.&quot; );
     
-    Vec3 const segmentStartToPoint( point - points_[ segmentIndex ] );
-    float const distance = segmentStartToPoint.dot( segmentTangents_[ segmentIndex ] );
+    Vector3 const segmentStartToPoint( point - points_[ segmentIndex ] );
+    float const distance = segmentStartToPoint.dotProduct( segmentTangents_[ segmentIndex ] );
     
     return clamp( distance, 0.0f, segmentLengths_[ segmentIndex ] );
 }
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPath::mapSegmentDistanceToPoint( size_type segmentIndex, 
                                                              float segmentDistance ) const
 {
@@ -459,7 +459,7 @@
 }
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPath::mapSegmentDistanceToTangent( size_type segmentIndex, 
                                                                float ) const
 {
@@ -471,8 +471,8 @@
 void 
 OpenSteer::PolylineSegmentedPath::mapDistanceToSegmentPointAndTangent( size_type segmentIndex,
                                                                        float segmentDistance,
-                                                                       Vec3&amp; pointOnPath,
-                                                                       Vec3&amp; tangent ) const
+                                                                       Vector3&amp; pointOnPath,
+                                                                       Vector3&amp; tangent ) const
 {
     assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex is out of range.&quot; );
     
@@ -494,17 +494,17 @@
 
 void 
 OpenSteer::PolylineSegmentedPath::mapPointToSegmentDistanceAndPointAndTangent( size_type segmentIndex,
-                                                                               Vec3 const&amp; point,
+                                                                               Vector3 const&amp; point,
                                                                                float&amp; distance,
-                                                                               Vec3&amp; pointOnPath,
-                                                                               Vec3&amp; tangent ) const
+                                                                               Vector3&amp; pointOnPath,
+                                                                               Vector3&amp; tangent ) const
 {
     assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex is out of range.&quot; );
     
-    Vec3 const segmentStartPoint = points_[ segmentIndex ];
-    Vec3 const segmentStartToPoint( point - segmentStartPoint );
+    Vector3 const segmentStartPoint = points_[ segmentIndex ];
+    Vector3 const segmentStartToPoint( point - segmentStartPoint );
     tangent = segmentTangents_[ segmentIndex ];
-    distance = segmentStartToPoint.dot( tangent );
+    distance = segmentStartToPoint.dotProduct( tangent );
     distance =  clamp( distance, 0.0f, segmentLengths_[ segmentIndex ] );
     pointOnPath = tangent * distance + segmentStartPoint;
 }

Modified: dependencies/opensteer/src/PolylineSegmentedPathwaySingleRadius.cpp
===================================================================
--- dependencies/opensteer/src/PolylineSegmentedPathwaySingleRadius.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/PolylineSegmentedPathwaySingleRadius.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -62,7 +62,7 @@
 
 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius( size_type numOfPoints,
-                                                                                       Vec3 const points[],
+                                                                                       Vector3 const points[],
                                                                                        float r,
                                                                                        bool closeCycle )
     : path_( numOfPoints, points, closeCycle ), radius_( r )
@@ -110,7 +110,7 @@
 void 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::movePoints( size_type startIndex,
                                                              size_type numOfPoints,
-                                                             Vec3 const newPointValues[] )
+                                                             Vector3 const newPointValues[] )
 {
     path_.movePoints( startIndex, numOfPoints, newPointValues );
 }
@@ -120,7 +120,7 @@
 
 void 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::setPathway( size_type numOfPoints,
-                                                             Vec3 const points[],
+                                                             Vector3 const points[],
                                                              float r,
                                                              bool closedCycle )
 {
@@ -155,9 +155,9 @@
 
 
 
-OpenSteer::Vec3 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToPath (const Vec3&amp; point,
-                                                                 Vec3&amp; tangent,
+Vector3 
+OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToPath (const Vector3&amp; point,
+                                                                 Vector3&amp; tangent,
                                                                  float&amp; outside) const
 {
     PointToPathMapping mapping;
@@ -169,7 +169,7 @@
 
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPathDistanceToPoint (float pathDistance) const
 {
     PathDistanceToPointMapping mapping;
@@ -180,7 +180,7 @@
 
 
 float 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToPathDistance (const Vec3&amp; point) const
+OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToPathDistance (const Vector3&amp; point) const
 {
     PointToPathDistanceMapping mapping;
     mapPointToPathAlike( *this, point, mapping );
@@ -213,7 +213,7 @@
 
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::point( size_type pointIndex ) const
 {
     return path_.point( pointIndex );
@@ -238,7 +238,7 @@
 
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::segmentStart( size_type segmentIndex ) const
 {
     return path_.segmentStart( segmentIndex );
@@ -246,7 +246,7 @@
 
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::segmentEnd( size_type segmentIndex ) const
 {
     return path_.segmentEnd( segmentIndex );
@@ -256,14 +256,14 @@
 
 float 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToSegmentDistance( size_type segmentIndex, 
-                                                                            Vec3 const&amp; point ) const
+                                                                            Vector3 const&amp; point ) const
 {
     return path_.mapPointToSegmentDistance( segmentIndex, point );
 }
 
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::mapSegmentDistanceToPoint( size_type segmentIndex, 
                                                                             float segmentDistance ) const
 {
@@ -283,7 +283,7 @@
 
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::mapSegmentDistanceToTangent( size_type segmentIndex, 
                                                                               float segmentDistance ) const
 {
@@ -294,8 +294,8 @@
 void 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
                                                                                                float distance,
-                                                                                               Vec3&amp; pointOnPath,
-                                                                                               Vec3&amp; tangent,
+                                                                                               Vector3&amp; pointOnPath,
+                                                                                               Vector3&amp; tangent,
                                                                                                float&amp; radius ) const
 {
     path_.mapDistanceToSegmentPointAndTangent( segmentIndex, distance, pointOnPath, tangent );
@@ -307,10 +307,10 @@
 
 void 
 OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
-                                                                                              Vec3 const&amp; point,
+                                                                                              Vector3 const&amp; point,
                                                                                               float&amp; distance,
-                                                                                              Vec3&amp; pointOnPath,
-                                                                                              Vec3&amp; tangent,
+                                                                                              Vector3&amp; pointOnPath,
+                                                                                              Vector3&amp; tangent,
                                                                                               float&amp; radius) const
 {
     path_.mapPointToSegmentDistanceAndPointAndTangent( segmentIndex, point, distance, pointOnPath, tangent );

Modified: dependencies/opensteer/src/SimpleVehicle.cpp
===================================================================
--- dependencies/opensteer/src/SimpleVehicle.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/SimpleVehicle.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -78,7 +78,7 @@
 OpenSteer::SimpleVehicle::SimpleVehicle (void)
 {
     // set inital state
-    reset ();
+    reset();
 
     // maintain unique serial numbers
     serialNumber = serialNumberCounter++;
@@ -106,13 +106,13 @@
 // parameter names commented out to prevent compiler warning from &quot;-W&quot;
 
 
-OpenSteer::Vec3 
-OpenSteer::SimpleVehicle::adjustRawSteeringForce (const Vec3&amp; force,
+Vector3 
+OpenSteer::SimpleVehicle::adjustRawSteeringForce (const Vector3&amp; force,
                                                   const float /* deltaTime */)
 {
-    const float maxAdjustedSpeed = 0.2f * maxSpeed ();
+    const float maxAdjustedSpeed = 0.2f * maxSpeed();
 
-    if ((speed () &gt; maxAdjustedSpeed) || (force == Vec3::zero))
+    if ((speed() &gt; maxAdjustedSpeed) || (force == Vector3::ZERO))
     {
         return force;
     }
@@ -148,12 +148,12 @@
 void 
 OpenSteer::SimpleVehicle::applyBrakingForce (const float rate, const float deltaTime)
 {
-    const float rawBraking = speed () * rate;
-    const float clipBraking = ((rawBraking &lt; maxForce ()) ?
+    const float rawBraking = speed() * rate;
+    const float clipBraking = ((rawBraking &lt; maxForce()) ?
                                rawBraking :
-                               maxForce ());
+                               maxForce());
 
-    setSpeed (speed () - (clipBraking * deltaTime));
+    setSpeed (speed() - (clipBraking * deltaTime));
 }
 
 
@@ -163,18 +163,18 @@
 
 
 void 
-OpenSteer::SimpleVehicle::applySteeringForce (const Vec3&amp; force,
+OpenSteer::SimpleVehicle::applySteeringForce (const Vector3&amp; force,
                                               const float elapsedTime)
 {
 
-    const Vec3 adjustedForce = adjustRawSteeringForce (force, elapsedTime);
+    const Vector3 adjustedForce = adjustRawSteeringForce (force, elapsedTime);
 
     // enforce limit on magnitude of steering force
-    const Vec3 clippedForce = adjustedForce.truncateLength (maxForce ());
+    const Vector3 clippedForce = Vec3Utils::truncateLength(adjustedForce, maxForce());
 
     // compute acceleration and velocity
-    Vec3 newAcceleration = (clippedForce / mass());
-    Vec3 newVelocity = velocity();
+    Vector3 newAcceleration = (clippedForce / mass());
+    Vector3 newVelocity = velocity();
 
     // damp out abrupt changes and oscillations in steering acceleration
     // (rate is proportional to time step, then clipped into useful range)
@@ -190,7 +190,7 @@
     newVelocity += _smoothedAcceleration * elapsedTime;
 
     // enforce speed limit
-    newVelocity = newVelocity.truncateLength (maxSpeed ());
+    newVelocity = Vec3Utils::truncateLength(newVelocity, maxSpeed());
 
     // update Speed
     setSpeed (newVelocity.length());
@@ -207,7 +207,7 @@
 
     // running average of recent positions
     blendIntoAccumulator (elapsedTime * 0.06f, // QQQ
-                          position (),
+                          position(),
                           _smoothedPosition);
 }
 
@@ -220,7 +220,7 @@
 
 
 void 
-OpenSteer::SimpleVehicle::regenerateLocalSpace (const Vec3&amp; newVelocity,
+OpenSteer::SimpleVehicle::regenerateLocalSpace (const Vector3&amp; newVelocity,
                                                 const float /* elapsedTime */)
 {
     // adjust orthonormal basis vectors to be aligned with new velocity
@@ -237,30 +237,30 @@
 
 
 void 
-OpenSteer::SimpleVehicle::regenerateLocalSpaceForBanking (const Vec3&amp; newVelocity,
+OpenSteer::SimpleVehicle::regenerateLocalSpaceForBanking (const Vector3&amp; newVelocity,
                                                           const float elapsedTime)
 {
     // the length of this global-upward-pointing vector controls the vehicle's
     // tendency to right itself as it is rolled over from turning acceleration
-    const Vec3 globalUp (0, 0.2f, 0);
+    const Vector3 globalUp (0, 0.2f, 0);
 
     // acceleration points toward the center of local path curvature, the
     // length determines how much the vehicle will roll while turning
-    const Vec3 accelUp = _smoothedAcceleration * 0.05f;
+    const Vector3 accelUp = _smoothedAcceleration * 0.05f;
 
     // combined banking, sum of UP due to turning and global UP
-    const Vec3 bankUp = accelUp + globalUp;
+    const Vector3 bankUp = accelUp + globalUp;
 
     // blend bankUp into vehicle's UP basis vector
     const float smoothRate = elapsedTime * 3;
-    Vec3 tempUp = up();
+    Vector3 tempUp = up();
     blendIntoAccumulator (smoothRate, bankUp, tempUp);
-    setUp (tempUp.normalize());
+    setUp (tempUp.normalisedCopy());
 
 //  annotationLine (position(), position() + (globalUp * 4), gWhite);  // XXX
 //  annotationLine (position(), position() + (bankUp   * 4), gOrange); // XXX
 //  annotationLine (position(), position() + (accelUp  * 4), gRed);    // XXX
-//  annotationLine (position(), position() + (up ()    * 1), gYellow); // XXX
+//  annotationLine (position(), position() + (up()    * 1), gYellow); // XXX
 
     // adjust orthonormal basis vectors to be aligned with new velocity
     if (speed() &gt; 0) regenerateOrthonormalBasisUF (newVelocity / speed());
@@ -276,16 +276,16 @@
 {
     if (elapsedTime &gt; 0)
     {
-        const Vec3 dP = _lastPosition - position ();
-        const Vec3 dF = (_lastForward - forward ()) / dP.length ();
-        const Vec3 lateral = dF.perpendicularComponent (forward ());
-        const float sign = (lateral.dot (side ()) &lt; 0) ? 1.0f : -1.0f;
+        const Vector3 dP = _lastPosition - position();
+        const Vector3 dF = (_lastForward - forward()) / dP.length();
+        const Vector3 lateral = Vec3Utils::perpendicularComponent(dF, forward());
+        const float sign = (lateral.dotProduct(side()) &lt; 0) ? 1.0f : -1.0f;
         _curvature = lateral.length() * sign;
         blendIntoAccumulator (elapsedTime * 4.0f,
                               _curvature,
                               _smoothedCurvature);
-        _lastForward = forward ();
-        _lastPosition = position ();
+        _lastForward = forward();
+        _lastPosition = position();
     }
 }
 
@@ -299,13 +299,13 @@
                                                           float maxLengthV)
 {
     const float desat = 0.4f;
-    const float aScale = maxLengthA / maxForce ();
-    const float vScale = maxLengthV / maxSpeed ();
-    const Vec3&amp; p = position();
+    const float aScale = maxLengthA / maxForce();
+    const float vScale = maxLengthV / maxSpeed();
+    const Vector3&amp; p = position();
     const Color aColor (desat, desat, 1); // bluish
     const Color vColor (    1, desat, 1); // pinkish
 
-    annotationLine (p, p + (velocity ()           * vScale), vColor);
+    annotationLine (p, p + (velocity()           * vScale), vColor);
     annotationLine (p, p + (_smoothedAcceleration * aScale), aColor);
 }
 
@@ -320,7 +320,7 @@
 // XXX move to a vehicle utility mixin?
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::SimpleVehicle::predictFuturePosition (const float predictionTime) const
 {
     return position() + (velocity() * predictionTime);

Modified: dependencies/opensteer/src/Vec3.cpp
===================================================================
--- dependencies/opensteer/src/Vec3.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/Vec3.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -28,15 +28,15 @@
 // ----------------------------------------------------------------------------
 //
 //
-// Vec3: OpenSteer's generic type for 3d vectors
+// Vector3: OpenSteer's generic type for 3d vectors
 //
-// This file defines the class Vec3, which is used throughout OpenSteer to
+// This file defines the class Vector3, which is used throughout OpenSteer to
 // manipulate 3d geometric data.  It includes standard vector operations (like
 // vector addition, subtraction, scale, dot, cross...) and more idiosyncratic
 // utility functions.
 //
 // When integrating OpenSteer into a preexisting 3d application, it may be
-// important to use the 3d vector type of that application.  In that case Vec3
+// important to use the 3d vector type of that application.  In that case Vector3
 // can be changed to inherit from the preexisting application' vector type and
 // to match the interface used by OpenSteer to the interface provided by the
 // preexisting 3d vector type.
@@ -52,37 +52,16 @@
 #include &quot;OpenSteer/Vec3.h&quot;
 
 
-// ----------------------------------------------------------------------------
-// names for frequently used vector constants
-
-
-const OpenSteer::Vec3 OpenSteer::Vec3::zero    (0, 0, 0);
-const OpenSteer::Vec3 OpenSteer::Vec3::up      (0, 1, 0);
-const OpenSteer::Vec3 OpenSteer::Vec3::forward (0, 0, 1);
-
-// XXX  This should be unified with LocalSpace::rightHanded, but I don't want
-// XXX  Vec3 to be based on LocalSpace which is based on Vec3.  Perhaps there
-// XXX  should be a tiny chirality.h header to define a const?  That could
-// XXX  then be included by both Vec3.h and LocalSpace.h
-
-const OpenSteer::Vec3 OpenSteer::Vec3::side    (-1, 0, 0);
-
-// ----------------------------------------------------------------------------
-// Returns a position randomly distributed inside a sphere of unit radius
-// centered at the origin.  Orientation will be random and length will range
-// between 0 and 1
-
-
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::RandomVectorInUnitRadiusSphere (void)
 {
-    Vec3 v;
+    Vector3 v;
 
     do
     {
-        v.set ((frandom01()*2) - 1,
-               (frandom01()*2) - 1,
-               (frandom01()*2) - 1);
+        v.x = (frandom01()*2) - 1;
+        v.y = (frandom01()*2) - 1;
+        v.z = (frandom01()*2) - 1;
     }
     while (v.length() &gt;= 1);
 
@@ -96,16 +75,16 @@
 // random and length will range between 0 and 1
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::randomVectorOnUnitRadiusXZDisk (void)
 {
-    Vec3 v;
+    Vector3 v;
 
     do
     {
-        v.set ((frandom01()*2) - 1,
-               0,
-               (frandom01()*2) - 1);
+        v.x = (frandom01()*2) - 1;
+        v.y = 0;
+        v.z = (frandom01()*2) - 1;
     }
     while (v.length() &gt;= 1);
 
@@ -121,19 +100,19 @@
 // cone.  Called by vecLimitMaxDeviationAngle and vecLimitMinDeviationAngle.
 
 
-OpenSteer::Vec3 
+Vector3 
 OpenSteer::vecLimitDeviationAngleUtility (const bool insideOrOutside,
-                                          const Vec3&amp; source,
+                                          const Vector3&amp; source,
                                           const float cosineOfConeAngle,
-                                          const Vec3&amp; basis)
+                                          const Vector3&amp; basis)
 {
     // immediately return zero length input vectors
     float sourceLength = source.length();
     if (sourceLength == 0) return source;
 
     // measure the angular diviation of &quot;source&quot; from &quot;basis&quot;
-    const Vec3 direction = source / sourceLength;
-    float cosineOfSourceAngle = direction.dot (basis);
+    const Vector3 direction = source / sourceLength;
+    float cosineOfSourceAngle = direction.dotProduct(basis);
 
     // Simply return &quot;source&quot; if it already meets the angle criteria.
     // (note: we hope this top &quot;if&quot; gets compiled out since the flag
@@ -150,18 +129,18 @@
     }
 
     // find the portion of &quot;source&quot; that is perpendicular to &quot;basis&quot;
-    const Vec3 perp = source.perpendicularComponent (basis);
+    const Vector3 perp = Vec3Utils::perpendicularComponent(source, basis);
 
     // normalize that perpendicular
-    const Vec3 unitPerp = perp.normalize ();
+    const Vector3 unitPerp = perp.normalisedCopy();
 
     // construct a new vector whose length equals the source vector,
     // and lies on the intersection of a plane (formed the source and
     // basis vectors) and a cone (whose axis is &quot;basis&quot; and whose
     // angle corresponds to cosineOfConeAngle)
     float perpDist = sqrtXXX (1 - (cosineOfConeAngle * cosineOfConeAngle));
-    const Vec3 c0 = basis * cosineOfConeAngle;
-    const Vec3 c1 = unitPerp * perpDist;
+    const Vector3 c0 = basis * cosineOfConeAngle;
+    const Vector3 c1 = unitPerp * perpDist;
     return (c0 + c1) * sourceLength;
 }
 
@@ -173,22 +152,22 @@
 // remain within 20% of input length).
 
 
-OpenSteer::Vec3 
-OpenSteer::findPerpendicularIn3d (const Vec3&amp; direction)
+Vector3 
+OpenSteer::findPerpendicularIn3d (const Vector3&amp; direction)
 {
     // to be filled in:
-    Vec3 quasiPerp;  // a direction which is &quot;almost perpendicular&quot;
-    Vec3 result;     // the computed perpendicular to be returned
+    Vector3 quasiPerp;  // a direction which is &quot;almost perpendicular&quot;
+    Vector3 result;     // the computed perpendicular to be returned
 
     // three mutually perpendicular basis vectors
-    const Vec3 i (1, 0, 0);
-    const Vec3 j (0, 1, 0);
-    const Vec3 k (0, 0, 1);
+    const Vector3 i (1, 0, 0);
+    const Vector3 j (0, 1, 0);
+    const Vector3 k (0, 0, 1);
 
     // measure the projection of &quot;direction&quot; onto each of the axes
-    const float id = i.dot (direction);
-    const float jd = j.dot (direction);
-    const float kd = k.dot (direction);
+    const float id = i.dotProduct(direction);
+    const float jd = j.dotProduct(direction);
+    const float kd = k.dotProduct(direction);
 
     // set quasiPerp to the basis which is least parallel to &quot;direction&quot;
     if ((id &lt;= jd) &amp;&amp; (id &lt;= kd))
@@ -205,7 +184,7 @@
 
     // return the cross product (direction x quasiPerp)
     // which is guaranteed to be perpendicular to both of them
-    result.cross (direction, quasiPerp);
+    result = crossProduct(direction, quasiPerp);
     return result;
 }
 

Modified: dependencies/opensteer/src/Vec3Utilities.cpp
===================================================================
--- dependencies/opensteer/src/Vec3Utilities.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ dependencies/opensteer/src/Vec3Utilities.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -38,10 +38,10 @@
 
 /**
  * @todo Is this useful?
-std::pair&lt; Vec3, Vec3 &gt;
-OpenSteer::convertPointAndSegmentToVectors( const Vec3&amp; point,
-                                 const Vec3&amp; segmentPoint0,
-                                 const Vec3&amp; segmentPoint1 )
+std::pair&lt; Vector3, Vector3 &gt;
+OpenSteer::convertPointAndSegmentToVectors( const Vector3&amp; point,
+                                 const Vector3&amp; segmentPoint0,
+                                 const Vector3&amp; segmentPoint1 )
 {
     
     
@@ -50,26 +50,26 @@
 }
 */
 
-OpenSteer::Vec3
-OpenSteer::nearestPointOnSegment( const Vec3&amp; point,
-                                  const Vec3&amp; segmentPoint0,
-                                  const Vec3&amp; segmentPoint1 )
+Vector3
+OpenSteer::nearestPointOnSegment( const Vector3&amp; point,
+                                  const Vector3&amp; segmentPoint0,
+                                  const Vector3&amp; segmentPoint1 )
 {
     // convert the test point to be &quot;local&quot; to ep0
-    Vec3 const local( point - segmentPoint0 );
+    Vector3 const local( point - segmentPoint0 );
     
     // find the projection of &quot;local&quot; onto &quot;segmentNormal&quot;
-    Vec3 const segment( segmentPoint1 - segmentPoint0 );
+    Vector3 const segment( segmentPoint1 - segmentPoint0 );
     float const segmentLength( segment.length() );
     
     assert( 0 != segmentLength &amp;&amp; &quot;Segment mustn't be of length zero.&quot; );
     
-    Vec3 const segmentNormalized( segment / segmentLength ); 
-    float segmentProjection = segmentNormalized.dot (local);
+    Vector3 const segmentNormalized( segment / segmentLength ); 
+    float segmentProjection = segmentNormalized.dotProduct(local);
     
     segmentProjection = clamp( segmentProjection, 0.0f, segmentLength );
     
-    Vec3 result( segmentNormalized * segmentProjection );
+    Vector3 result( segmentNormalized * segmentProjection );
     result +=  segmentPoint0;
     return result;    
     
@@ -78,9 +78,9 @@
 
 
 float 
-OpenSteer::pointToSegmentDistance ( const Vec3&amp; point,
-                                    const Vec3&amp; segmentPoint0,
-                                    const Vec3&amp; segmentPoint1)
+OpenSteer::pointToSegmentDistance ( const Vector3&amp; point,
+                                    const Vector3&amp; segmentPoint0,
+                                    const Vector3&amp; segmentPoint1)
 {
     return distance( point, nearestPointOnSegment( point, segmentPoint0, segmentPoint1 ) );
 }

Modified: modules/aitest/scripts/NpcTest.rb
===================================================================
--- modules/aitest/scripts/NpcTest.rb	2007-08-12 20:51:30 UTC (rev 3683)
+++ modules/aitest/scripts/NpcTest.rb	2007-08-12 21:30:22 UTC (rev 3684)
@@ -12,9 +12,9 @@
                                            min_base, max_base, &quot;alpha_blue&quot;)
         base.placeIntoScene(center);
 
-        npc1proxy = $GOM.createGameObject(&quot;TestPerson&quot;);
-        npc1 = npc1proxy;
+        npc1 = $GOM.createGameObject(&quot;TestPerson&quot;);
         npc1.setPosition(rel_pos([0.0, height, 0.0]));
+		
 
         npc1.placeIntoScene();
     end

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -1,5 +1,5 @@
 /* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * Copyright(C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
  * 
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
@@ -52,14 +52,14 @@
 	 *
 	 * Maybe this should be used as interface instead of AbstractVehicle
 	 */
-        class _RlAiExport SteeringVehicle : public SimpleVehicle_2,
+    class _RlAiExport SteeringVehicle : public SimpleVehicle_2,
                                             public DebugVisualisable
 	{
 	public:
 		/** Constructor.
 		 * @param parent Agent owning this vehicle
 		 */
-		SteeringVehicle(Agent* parent);
+		SteeringVehicle(Creature* creature);
 		/** explicit virtual destructor.
 		 */
 		virtual ~SteeringVehicle(void);
@@ -72,8 +72,8 @@
 
 		/**
 		 * Random walking behaviour
-		 * The steering value is purely tangential (has no Forward component) 
-		 * and uses the x-axis only at the moment (2D wandering)
+		 * The steering value is purely tangential(has no Forward component) 
+		 * and uses the x-axis only at the moment(2D wandering)
 		 * @param  elapsedTime The time step value allows wander rate to be consistent when frame times vary
 		 * @return a steering force for wandering behavior. 
 		 */
@@ -164,95 +164,95 @@
 		virtual void update(const float currentTime, const float elapsedTime);
 		/**
 		 * predict position of this vehicle at some time in the future
-		 * (assumes velocity remains constant)
+		 *(assumes velocity remains constant)
 		 */
-		OpenSteer::Vec3 predictFuturePosition (const float predictionTime) const;
+		Ogre::Vector3 predictFuturePosition(const float predictionTime) const;
 
 		void resetLocalSpace();
 
 		/** get mass
 		 * @returns mass of physical object
 		 */
-		float mass (void) const;
+		float mass() const;
 		/** does not set mass but is necessary for AbstractVehicle.
 		 * throws an exception on invocation.
 		 * @param m mass
 		 */
-		float setMass (float m);
+		float setMass(float m);
 
 		/** retrieve velocity of vehicle
 		 * @returns velocity of the vehicle
 		 */
-		OpenSteer::Vec3 velocity (void) const {return OpenSteer::Vec3(mCurrentVelocity.x, mCurrentVelocity.y, mCurrentVelocity.z);}
+		Ogre::Vector3 velocity() const {return mCurrentVelocity;}
 
 		/** retrieves speed of vehicle.
 		 * may be faster than taking mag of velocity
 		 */
-		float speed (void) const;
+		float speed() const;
 		/** sets speed of vehicle.
 		 * may be faster than taking mag of velocity
 		 * @param s new speed to set
 		 * @returns float new speed set.
 		 */
-		float setSpeed (float s);
+		float setSpeed(float s);
 
 		/** radius for size of bounding sphere.
 		 * used for obstacle avoidance, etc.
 		 * TODO: this should be handled by size of NewtonBody
 		 * @returns float the radius
 	    */
-		float radius (void) const;
+		float radius() const;
 		/** sets radius for size of bounding sphere.
 		 * used for obstacle avoidance, etc.
 		 * TODO: this should be handled by size of NewtonBody
 		 * @returns float the radius
 	    */
-		float setRadius (float m);
+		float setRadius(float m);
 
 		/** height for size of bounding sphere.
 		 * used for obstacle avoidance, etc.
 		 * TODO: this should be handled by height of NewtonBody
 		 * @returns float the height
 	    */
-        float height (void) const;
+        float height() const;
 		/** height for size of bounding sphere.
 		 * used for obstacle avoidance, etc.
 		 * TODO: this should be handled by height of NewtonBody
 		 * @returns float the height
 	    */
-        float setHeight (float h);
+        float setHeight(float h);
 
 		/** retrieves maximum force.
 		 * @returns float containing maximum force.
 		 */
-		float maxForce (void) const; 
+		float maxForce() const; 
 		/** sets maximum force.
 		 * TODO: should not be set here, throw excpetion or so
 		 * @returns float containing maximum force set.
 		 */
-		float setMaxForce (float mf);
+		float setMaxForce(float mf);
 
 		/** retrieves maximum speed.
 		 * @returns float containing maximum speed
 		 */
-		float maxSpeed (void) const;
+		float maxSpeed() const;
 		/** retrieves maximum speed.
 		 * TODO: should not be set here, throw excpetion or so
 		 * @returns float containing maximum speed
 		 */
-		float setMaxSpeed (float ms);
+		float setMaxSpeed(float ms);
 
 		/**
 		 * adjust the steering force passed to applySteeringForce.
          * allows a specific vehicle class to redefine this adjustment.
          * default is to disallow backward-facing steering at low speed.
 		 */
-		virtual OpenSteer::Vec3 adjustRawSteeringForce (const OpenSteer::Vec3&amp; force);
+		virtual Ogre::Vector3 adjustRawSteeringForce(const Ogre::Vector3&amp; force);
 
 		/** retrieve the controlled Actor
 		 * @returns Actor that is controlled by the SteeringVehicle
 		 */
-        const Actor* getActor(void) const;
+        const Actor* getActor() const;
 
         // derived from debugvisualisable
         virtual DebugVisualisableFlag getFlag() const;
@@ -290,9 +290,7 @@
 		//! the yaw angle in radians
 		//Ogre::Radian mYaw;
 
-		//! Agent using this vehicle
-		Agent* mParent;
-        //! Creature object steered by this vehicle (and controlled by Agent).
+        //! Creature object steered by this vehicle(and controlled by Agent).
         Creature* mCreature;
 
         CreatureController* mController;

Modified: rl/trunk/engine/ai/include/stdinc.h
===================================================================
--- rl/trunk/engine/ai/include/stdinc.h	2007-08-12 20:51:30 UTC (rev 3683)
+++ rl/trunk/engine/ai/include/stdinc.h	2007-08-12 21:30:22 UTC (rev 3684)
@@ -40,6 +40,7 @@
 #include &lt;list&gt;
 #include &lt;map&gt;
 #include &lt;set&gt;
+#include &lt;stack&gt;
 
 #include &lt;iostream&gt;
 #include &lt;sstream&gt;

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -39,13 +39,13 @@
 //  for easier access
 /*	BoxObstacle* o = new BoxObstacle(25,50,25);
 	o-&gt;setSeenFrom(AbstractObstacle::inside);
-	o-&gt;setPosition(Vec3(-40.0f,-10.0f, 0.0f));
+	o-&gt;setPosition(Vector3(-40.0f,-10.0f, 0.0f));
 	o-&gt;setForward(0,0,-1);
 	addObstacle(o);
 
 	o = new BoxObstacle(2,50,2);
 	o-&gt;setSeenFrom(AbstractObstacle::outside);
-	o-&gt;setPosition(Vec3(-31.5f,-10.0f, -3.5f));
+	o-&gt;setPosition(Vector3(-31.5f,-10.0f, -3.5f));
 	o-&gt;setForward(0,0,-1);
 	addObstacle(o); */
 
@@ -96,16 +96,13 @@
     // Dadurch ist ungefaehr der Umriss gesichert!
     // Habe bisher keine elegantere Loesung gefunden
     RaycastType raycastType;
-    Vec3 _pos = vehicle.position();
-    Vec3 _futPos = vehicle.forward() * vehicle.speed() * 3 + _pos;
+    Vector3 pos = vehicle.position();
+    Vector3 futPos = vehicle.forward() * vehicle.speed() * 3 + pos;
 
 
-    if( _pos == _futPos )
+    if (pos == futPos)
         return;
 
-    Ogre::Vector3 pos (_pos.x, _pos.y, _pos.z);
-    Ogre::Vector3 futPos (_futPos.x, _futPos.y, _futPos.z);
-
     // zur Hilfe bei der Berechnung
     Ogre::Vector3 velocityNorm(futPos - pos);
     velocityNorm.normalise(); // normalisierte geschwindigkeit (Richtung!)
@@ -142,18 +139,18 @@
             // so wir ham ne normale und machen uns nen Y
             if( vehicle.radius() == 0 )
                 continue;
-            Vec3 offset = vehicle.side().normalize() * (vehicle.radius() - 0.1);
-            castPos = pos + Vector3(offset.x, offset.y, offset.z);
-            castFutPos = futPos + Vector3(offset.x, offset.y, offset.z);
+            Vector3 offset = vehicle.side().normalisedCopy() * (vehicle.radius() - 0.1);
+            castPos = pos + offset;
+            castFutPos = futPos + offset;
         }
         else if( raycastType == LEFT )
         {
             // wie bei right ...
             if( vehicle.radius() == 0 )
                 continue;
-            Vec3 offset = vehicle.side().normalize() * (vehicle.radius() - 0.1);
-            castPos = pos - Vector3(offset.x, offset.y, offset.z);
-            castFutPos = futPos - Vector3(offset.x, offset.y, offset.z);
+            Vector3 offset = vehicle.side().normalisedCopy() * (vehicle.radius() - 0.1);
+            castPos = pos - offset;
+            castFutPos = futPos - offset;
         }
         else
         {
@@ -215,8 +212,8 @@
         vehicle.position() + (vehicle.forward() * pi.distance);
 
         // Die normale muss zu uns zeigen! koennte aber auch in die entgegengesetzte Richtung sein!
-        pi.surfaceNormal = Vec3(infoNearest.mNormal.x, infoNearest.mNormal.y, infoNearest.mNormal.z);
-/*        pi.surfaceNormal.normalize();
+        pi.surfaceNormal = Vector3(infoNearest.mNormal.x, infoNearest.mNormal.y, infoNearest.mNormal.z);
+/*        pi.surfaceNormal.normalisedCopy();
         // jedenfalls gilt dafuer, dass der abstand zwischen surfacePoint+surfaceNormal und _pos minimal sein muss
         if( ((pi.surfacePoint + pi.surfaceNormal) - _pos).length() &gt;
             ((pi.surfacePoint - pi.surfaceNormal) - _pos).length() )

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-08-12 20:51:30 UTC (rev 3683)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-08-12 21:30:22 UTC (rev 3684)
@@ -32,24 +32,22 @@
 
 namespace rl {
 
-SteeringVehicle::SteeringVehicle(Agent* parent)
+SteeringVehicle::SteeringVehicle(Creature* creature)
 	: _maxForce(1.0f),
       _maxSpeed(1.0f),
       mSpeed(1.0f),
 	  mCurrentForce(Vector3::ZERO), 
 	  mCurrentVelocity(Vector3::ZERO),
 	  mForwardVector(Vector3::NEGATIVE_UNIT_Z),
-	  mParent(parent),
-	  mCreature(NULL),
+	  mCreature(creature),
       mController(NULL),
       mDebugSteer(Vector3::ZERO),
       mDebugWander(Vector3::ZERO),
       mDebugAvoidObstacles(Vector3::ZERO)
 {
-    mCreature = parent-&gt;getControlledCreature();
-
 	initialize();
-    mController = CreatureControllerManager::getSingleton().getCreatureController(mCreature);
+    mController = CreatureControllerManager::getSingleton().getCreatureController(
+        mCreature);
 }
 
 SteeringVehicle::~SteeringVehicle(void)
@@ -58,16 +56,16 @@
 
 void SteeringVehicle::resetLocalSpace()
 {
-	setForward(Vec3(mForwardVector.x, mForwardVector.y, mForwardVector.z));
+	setForward(mForwardVector);
 	setSide(localRotateForwardToSide(forward()));
-	setUp(OpenSteer::Vec3(0, 1, 0));
+    setUp(Vector3::UNIT_Y);
 	Vector3 pos = mCreature-&gt;getActor()-&gt;getPosition();
-	setPosition(Vec3(pos.x, pos.y, pos.z));
+	setPosition(pos);
 	Vector3 src = mCreature-&gt;getActor()-&gt;getOrientation()*Vector3::NEGATIVE_UNIT_Z;
 
     // regenerate local space (by default: align vehicle's forward axis with
     // new velocity, but this behavior may be overridden by derived classes.)
-	regenerateOrthonormalBasisUF ( Vec3(src.x, src.y, src.z) );
+	regenerateOrthonormalBasisUF ( src );
 }
 
 void SteeringVehicle::initialize(void)
@@ -76,7 +74,7 @@
 	resetLocalSpace();
 	
     // reset SteerLibraryMixin state
-	SimpleVehicle_2::reset ();
+	SimpleVehicle_2::reset();
 
 	setMaxForce (1.0f);   // steering force is clipped to this magnitude
 	setMaxSpeed (1.0f);   // velocity is clipped to this magnitude
@@ -97,7 +95,7 @@
     Vector3 position;
 	Quaternion orientation;
 	body-&gt;getPositionOrientation(position, orientation);
-	setPosition(Vec3(position.x, position.y, position.z));
+	setPosition(position);
 
     //  Get the velocity vector
 	mCurrentVelocity = body-&gt;getVelocity();
@@ -105,14 +103,14 @@
 	//  newVelocity = newVelocity.truncateLength (maxSpeed ());
 	//  update speed
 	setSpeed(mCurrentVelocity.length());
-	Vec3 newVelocity(mCurrentVelocity.x, mCurrentVelocity.y, mCurrentVelocity.z);
+	Vector3 newVelocity(mCurrentVelocity);
 
     //  regenerate local space (by default: align vehicle's forward axis with
     //  new velocity, but this behavior may be overridden by derived classes.)
     // use future orientation or not??
     orientation = Quaternion(mController-&gt;getYaw(), Ogre::Vector3::UNIT_Y);
     Vector3 newUnitForward = orientation*Vector3::NEGATIVE_UNIT_Z;
-    regenerateOrthonormalBasisUF (Vec3(newUnitForward.x,newUnitForward.y,newUnitForward.z));
+    regenerateOrthonormalBasisUF(newUnitForward);
 
     // end of inserting from playervehicle
 
@@ -170,26 +168,23 @@
 
 Vector3 SteeringVehicle::calcWander(const float elapsedTime)
 {
-	Vec3 rVal(mForwardVector.x, mForwardVector.y, mForwardVector.z);
+	Vector3 steering = mForwardVector;
 	
-    rVal += steerForWander(elapsedTime/12.0f).setYtoZero();
+    steering += Vec3Utils::setYtoZero(steerForWander(elapsedTime/12.0f));
 
-    Vector3 steering(rVal.x, rVal.y, rVal.z);
     mDebugWander = steering;
 	return steering;
 }
 
 Vector3 SteeringVehicle::calcSeek(const Vector3&amp; target)
 {
-	Vec3 rVal = steerForSeek(Vec3(target.x, target.y, target.z)).setYtoZero();
-    Vector3 steering(rVal.x, rVal.y, rVal.z);
+	Vector3 steering = Vec3Utils::setYtoZero(steerForSeek(target));
 	return steering;
 }
 
 Vector3 SteeringVehicle::calcFlee(const Vector3&amp; target)
 {
-	Vec3 rVal = steerForFlee(Vec3(target.x, target.y, target.z)).setYtoZero();
-    Vector3 steering(rVal.x, rVal.y, rVal.z);
+	Vector3 steering = Vec3Utils::setYtoZero(steerForFlee(target));
 	return steering;
 }
 
@@ -203,7 +198,7 @@
     /// Just returning a direction vector on the xz-plane
     /// towards the other agent.
     Vector3 dir = agent-&gt;getControlledCreature()-&gt;getPosition() -
-        mParent-&gt;getControlledCreature()-&gt;getPosition();
+        mCreature-&gt;getPosition();
     dir.y = 0;
 	return dir;
 }
@@ -211,16 +206,15 @@
 Vector3 SteeringVehicle::calcAvoidObstacles(const float minTimeToCollision)
 {
     ObstacleGroup obstacles = getObstacles();
-	Vec3 rVal = steerToAvoidObstacles(minTimeToCollision, obstacles).setYtoZero();
-    Vector3 steering(rVal.x, rVal.y, rVal.z);
+    Vector3 steering = Vec3Utils::setYtoZero(steerToAvoidObstacles(minTimeToCollision, obstacles));
     mDebugAvoidObstacles = steering;
 	return steering;
 }
 
 Vector3 SteeringVehicle::calcAvoidNeighbors(const float minTimeToCollision)
 {
-	Vec3 rVal = steerToAvoidNeighbors(minTimeToCollision, getNeighbors()).setYtoZero();
-	return Vector3(rVal.x, rVal.y, rVal.z);
+	Vector3 steering = Vec3Utils::setYtoZero(steerToAvoidNeighbors(minTimeToCollision, getNeighbors()));
+	return steering;
 }
 		
 Vector3 SteeringVehicle::calcSteerTargetSpeed(const float targetSpeed)
@@ -232,7 +226,7 @@
 {
     Vector3 target = agent-&gt;getControlledCreature()-&gt;getPosition();
 	//target.y = position.y;
-	return (SimpleVehicle_2::isAhead(Vec3(target.x, target.y, target.z), threshold));
+	return SimpleVehicle_2::isAhead(target, threshold);
 }
 
 bool SteeringVehicle::needAvoidance(const float minTimeToCollision)
@@ -268,7 +262,7 @@
 
 Vector3 SteeringVehicle::getPosition()
 {
-	return Vector3(position().x, position().y, position().z);
+	return position();
 }
 
 float SteeringVehicle::mass (void) const 
@@ -350,17 +344,17 @@
 	return AiSubsystem::getSingleton().getWorld()-&gt;getSteeringObstacles();
 }
 
-Vec3 SteeringVehicle::predictFuturePosition(const float predictionTime) const
+Vector3 SteeringVehicle::predictFuturePosition(const float predictionTime) const
 {
 	//return position() + (velocity() * predictionTime);
 	return velocity() * predictionTime;
 }
 
-Vec3 SteeringVehicle::adjustRawSteeringForce(const Vec3&amp; force)
+Vector3 SteeringVehicle::adjustRawSteeringForce(const Vector3&amp; force)
 {
     const float maxAdjustedSpeed = 0.2f * maxSpeed ();
 
-    if ((speed () &gt; maxAdjustedSpeed) || (force == Vec3::zero))
+    if ((speed () &gt; maxAdjustedSpeed) || (force == Vector3::ZERO))
     {
         return force;
     }

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-08-12 20:51:30 UTC (rev 3683)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-08-12 21:30:22 UTC (rev 3684)
@@ -29,30 +29,18 @@
 	class SteeringVehicle
 	{
 	public:
-		SteeringVehicle(rl::Agent* agent);
-		
+        SteeringVehicle(rl::Creature* creature);
 		void addForce(const Ogre::Vector3&amp; force);
-
 		Ogre::Vector3 calcWander(const float elapsedTime);
-
 		Ogre::Vector3 calcSeek(const Ogre::Vector3&amp; target);
-
 		Ogre::Vector3 calcFlee(const Ogre::Vector3&amp; target);
-		
 		Ogre::Vector3 calcPursuit(rl::Agent* agent);
-
 		Ogre::Vector3 calcAvoidObstacles(const float minTimeToCollision);
-
 		Ogre::Vector3 calcAvoidNeighbors(const float minTimeToCollision);
-		
 		Ogre::Vector3 calcSteerTargetSpeed(const float targetSpeed);
-		
 		float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2);
-		
 		Ogre::Vector3 getPosition();
-		
 		bool isAhead(rl::Agent* agent, const float threshold);
-		
 		bool needAvoidance(const float minTimeToCollision);
 	};
 	


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000754.html">[Dsa-hl-svn] r3683 - in rl/trunk/engine/ui: include src
</A></li>
	<LI>Next message: <A HREF="000756.html">[Dsa-hl-svn] r3685 - in rl/trunk/engine: ai ai/include ai/src	rules/include rules/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#755">[ date ]</a>
              <a href="thread.html#755">[ thread ]</a>
              <a href="subject.html#755">[ subject ]</a>
              <a href="author.html#755">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
