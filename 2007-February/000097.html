<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r3026 - in rl/trunk: . engine/ai/src	engine/common/include engine/common/src engine/core	engine/core/include engine/core/include/nulldriver	engine/core/src engine/core/src/nulldriver engine/startup/src	engine/ui/include engine/ui/src plugins/fmod4driver/include	plugins/fmod4driver/src plugins/openaldriver/include	plugins/openaldriver/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-February/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3026%20-%20in%20rl/trunk%3A%20.%20engine/ai/src%0A%09engine/common/include%20engine/common/src%20engine/core%0A%09engine/core/include%20engine/core/include/nulldriver%0A%09engine/core/src%20engine/core/src/nulldriver%20engine/startup/src%0A%09engine/ui/include%20engine/ui/src%20plugins/fmod4driver/include%0A%09plugins/fmod4driver/src%20plugins/openaldriver/include%0A%09plugins/openaldriver/src&In-Reply-To=%3C200702071930.l17JUJk2026075%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000096.html">
   <LINK REL="Next"  HREF="000098.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r3026 - in rl/trunk: . engine/ai/src	engine/common/include engine/common/src engine/core	engine/core/include engine/core/include/nulldriver	engine/core/src engine/core/src/nulldriver engine/startup/src	engine/ui/include engine/ui/src plugins/fmod4driver/include	plugins/fmod4driver/src plugins/openaldriver/include	plugins/openaldriver/src</H1>
    <B>chrber at BerliOS</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3026%20-%20in%20rl/trunk%3A%20.%20engine/ai/src%0A%09engine/common/include%20engine/common/src%20engine/core%0A%09engine/core/include%20engine/core/include/nulldriver%0A%09engine/core/src%20engine/core/src/nulldriver%20engine/startup/src%0A%09engine/ui/include%20engine/ui/src%20plugins/fmod4driver/include%0A%09plugins/fmod4driver/src%20plugins/openaldriver/include%0A%09plugins/openaldriver/src&In-Reply-To=%3C200702071930.l17JUJk2026075%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r3026 - in rl/trunk: . engine/ai/src	engine/common/include engine/common/src engine/core	engine/core/include engine/core/include/nulldriver	engine/core/src engine/core/src/nulldriver engine/startup/src	engine/ui/include engine/ui/src plugins/fmod4driver/include	plugins/fmod4driver/src plugins/openaldriver/include	plugins/openaldriver/src">chrber at mail.berlios.de
       </A><BR>
    <I>Wed Feb  7 20:30:19 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000096.html">[Dsa-hl-svn] r3025 - rl/trunk/engine/core/include
</A></li>
        <LI>Next message: <A HREF="000098.html">[Dsa-hl-svn] r3027 - modules/common/gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#97">[ date ]</a>
              <a href="thread.html#97">[ thread ]</a>
              <a href="subject.html#97">[ subject ]</a>
              <a href="author.html#97">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: chrber
Date: 2007-02-07 20:30:10 +0100 (Wed, 07 Feb 2007)
New Revision: 3026

Modified:
   rl/trunk/configure.in
   rl/trunk/engine/ai/src/AiSubsystem.cpp
   rl/trunk/engine/common/include/ConfigFile.h
   rl/trunk/engine/common/include/RastullahPrerequisites.h
   rl/trunk/engine/common/src/ConfigFile.cpp
   rl/trunk/engine/core/Makefile.am
   rl/trunk/engine/core/include/ConfigurationManager.h
   rl/trunk/engine/core/include/CoreSubsystem.h
   rl/trunk/engine/core/include/SoundDriver.h
   rl/trunk/engine/core/include/SoundManager.h
   rl/trunk/engine/core/include/nulldriver/NullDriver.h
   rl/trunk/engine/core/src/ConfigurationManager.cpp
   rl/trunk/engine/core/src/ContentModule.cpp
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/core/src/DotSceneLoader.cpp
   rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp
   rl/trunk/engine/core/src/Makefile.am
   rl/trunk/engine/core/src/SoundDriver.cpp
   rl/trunk/engine/core/src/SoundManager.cpp
   rl/trunk/engine/core/src/nulldriver/NullDriver.cpp
   rl/trunk/engine/startup/src/RastullahMain.cpp
   rl/trunk/engine/ui/include/CommandMapper.h
   rl/trunk/engine/ui/include/InputManager.h
   rl/trunk/engine/ui/src/CommandMapper.cpp
   rl/trunk/engine/ui/src/DebugWindow.cpp
   rl/trunk/engine/ui/src/DialogCharacterController.cpp
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
   rl/trunk/engine/ui/src/UiSubsystem.cpp
   rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h
   rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp
   rl/trunk/plugins/openaldriver/include/OpenALDriver.h
   rl/trunk/plugins/openaldriver/src/OpenALDriver.cpp
   rl/trunk/rastullah.conf.in
Log:
Implemented Step 2 of ConfigurationManager rewrite:
 - Rastullah works without a default configuration file, using compiled fallback values
 - Restructered a whole bunch of classes, so that this works (bugs?!)


Modified: rl/trunk/configure.in
===================================================================
--- rl/trunk/configure.in	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/configure.in	2007-02-07 19:30:10 UTC (rev 3026)
@@ -108,7 +108,7 @@
 
 # Ogre
 PKG_CHECK_MODULES(OGRE, OGRE &gt;= 1.3.0)
-AC_ARG_WITH(ogre-plugins,[  --with-ogre-plugins=path        Set location of Ogre plugins],[ OGRE_PLUGINDIR=&quot;$withval&quot;], [OGRE_PLUGINDIR=/usr/local/lib/OGRE])
+AC_ARG_WITH(ogre-plugins,[  --with-ogre-plugins=path        Set location of Ogre plugins],[ OGRE_PLUGINDIR=&quot;$withval&quot;], [OGRE_PLUGINDIR=`pkg-config OGRE --variable=plugindir`])
 AC_SUBST(OGRE_PLUGINDIR)
 
 # CEGUI
@@ -193,10 +193,11 @@
 	prefix=${ac_default_prefix}
 fi
 dnl Must double eval here, to replace ${datadir} and after that ${prefix}
-eval RL_MODULE_DIR=&quot;${datadir}&quot;
-eval RL_MODULE_DIR=&quot;${RL_MODULE_DIR}/rastullah&quot;
-AC_SUBST(RL_MODULE_DIR)
+eval RL_MODULEDIR=&quot;${datadir}&quot;
+eval RL_MODULEDIR=&quot;${RL_MODULEDIR}/rastullah&quot;
+AC_SUBST(RL_MODULEDIR)
 
+
 dnl Create the makefiles
 AC_CONFIG_FILES([Makefile \
 		docs/Makefile docs/src/Makefile \
@@ -215,14 +216,14 @@
 		plugins/Makefile \
 		plugins/fmod4driver/Makefile plugins/fmod4driver/include/Makefile plugins/fmod4driver/src/Makefile \
 		plugins/openaldriver/Makefile plugins/openaldriver/include/Makefile plugins/openaldriver/src/Makefile \
-		rastullah.conf  \
 		tools/Makefile \
+		rastullah.conf
     ])
 
 AC_OUTPUT
 
-eval GAME_DIR=&quot;${bindir}&quot;
-eval GAME_DIR=&quot;${GAME_DIR}&quot;
+eval RL_GAMEDIR=&quot;${bindir}&quot;
+eval RL_GAMEDIR=&quot;${RL_GAMEDIR}&quot;
 
 dnl Show a summary about important directories
 echo
@@ -239,8 +240,8 @@
 echo &quot;       OpenAL plugin:                      ${enable_openal-no}&quot;
 echo
 echo &quot; Directory settings:&quot;
-echo &quot;       rastullah binary will be placed in: ${GAME_DIR}&quot;
-echo &quot;       Module directory:                   ${RL_MODULE_DIR}&quot;
+echo &quot;       rastullah binary will be placed in: ${RL_GAMEDIR}&quot;
+echo &quot;       Module directory:                   ${RL_MODULEDIR}&quot;
 echo
 echo &quot; Configuration files:&quot;
 echo &quot;       installation of global config file: ${enable_global_config-no}&quot;

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Perl Artistic License.
  *
@@ -30,36 +30,36 @@
 
 AiSubsystem&amp; AiSubsystem::getSingleton(void)
 {
-	return Singleton&lt;AiSubsystem&gt;::getSingleton();
+    return Singleton&lt;AiSubsystem&gt;::getSingleton();
 }
 
 AiSubsystem* AiSubsystem::getSingletonPtr(void)
 {
-	return Singleton&lt;AiSubsystem&gt;::getSingletonPtr();
+    return Singleton&lt;AiSubsystem&gt;::getSingletonPtr();
 }
 
 AiSubsystem::AiSubsystem(void)
-	: mAgentManager(NULL), 
-	  mWorld(NULL)
+    : mAgentManager(NULL),
+      mWorld(NULL)
 {
-	LOG_MESSAGE(Logger::AI, &quot;Init Start&quot;);
-	initialize();
-	LOG_MESSAGE(Logger::AI, &quot;Init Ende&quot;);
+    LOG_MESSAGE(Logger::AI, &quot;Init Start&quot;);
+    initialize();
+    LOG_MESSAGE(Logger::AI, &quot;Init Ende&quot;);
 }
 
 AiSubsystem::~AiSubsystem(void)
 {
     CoreSubsystem::getSingletonPtr()-&gt;getWorld()-&gt;removeSceneChangeListener(this);
     AgentManager::getSingleton().removeAllAgents();
-	mWorld-&gt;removeAllObstacles();
-	delete mAgentManager;
-	delete mWorld;
+    mWorld-&gt;removeAllObstacles();
+    delete mAgentManager;
+    delete mWorld;
 }
 
 void AiSubsystem::initialize()
 {
-	mAgentManager = new AgentManager();
-	mWorld = new AiWorld();
+    mAgentManager = new AgentManager();
+    mWorld = new AiWorld();
 
     CoreSubsystem::getSingletonPtr()-&gt;getWorld()-&gt;addSceneChangeListener(this);
     GameLoop::getSingleton().addTask(AgentManager::getSingletonPtr(), GameLoop::TG_LOGIC);
@@ -67,8 +67,8 @@
 
 void AiSubsystem::onBeforeClearScene()
 {
-	AgentManager::getSingleton().removeAllAgents();
-	mWorld-&gt;removeAllObstacles();
+    AgentManager::getSingleton().removeAllAgents();
+    mWorld-&gt;removeAllObstacles();
 }
 
 
@@ -82,20 +82,20 @@
 
     // &#228;u&#223;ere grenzen einf&#252;gen
     //PhysicsManager
-/*    
+/*
 //  create an obstacle as bounding box of the walkarea for npcs
 //  this should be accessable through scripting, the Obstacles should have names
 //  for easier access
-	BoxObstacle* o = new BoxObstacle(25,50,25);
-	o-&gt;setSeenFrom(AbstractObstacle::inside);
-	o-&gt;setPosition(Vec3(-40.0f,-10.0f, 0.0f));
-	o-&gt;setForward(0,0,-1);
-	addObstacle(o);
+    BoxObstacle* o = new BoxObstacle(25,50,25);
+    o-&gt;setSeenFrom(AbstractObstacle::inside);
+    o-&gt;setPosition(Vec3(-40.0f,-10.0f, 0.0f));
+    o-&gt;setForward(0,0,-1);
+    addObstacle(o);
 
-	o = new BoxObstacle(2,50,2);
-	o-&gt;setSeenFrom(AbstractObstacle::outside);
-	o-&gt;setPosition(Vec3(-31.5f,-10.0f, -3.5f));
-	o-&gt;setForward(0,0,-1);
-	addObstacle(o);
+    o = new BoxObstacle(2,50,2);
+    o-&gt;setSeenFrom(AbstractObstacle::outside);
+    o-&gt;setPosition(Vec3(-31.5f,-10.0f, -3.5f));
+    o-&gt;setForward(0,0,-1);
+    addObstacle(o);
 */
-}
\ No newline at end of file
+}

Modified: rl/trunk/engine/common/include/ConfigFile.h
===================================================================
--- rl/trunk/engine/common/include/ConfigFile.h	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/common/include/ConfigFile.h	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,7 +13,7 @@
  *  along with this program; if not you can get it here
  *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
  */
- 
+
 #ifndef CONFIGFILE_H_
 #define CONFIGFILE_H_
 
@@ -22,12 +22,12 @@
 #include &lt;OgreDataStream.h&gt;
 #include &lt;OgreStringConverter.h&gt;
 
-namespace Ogre 
+namespace Ogre
 {
     template&lt;class T&gt; class SharedPtr;
     class DataStream;
     typedef class SharedPtr&lt;DataStream&gt; DataStreamPtr;
-    
+
 }
 
 namespace rl
@@ -36,7 +36,7 @@
 class _RlCommonExport ConfigFile : public Ogre::ConfigFile
 {
 public:
-	ConfigFile();
+    ConfigFile();
     /// save to a filename (not using resource group locations)
     void save(const Ogre::String&amp; filename, const Ogre::String&amp; separators = &quot;\t:=&quot;, bool trimWhitespace = true);
     /// save to a filename (using resource group locations)
@@ -50,144 +50,151 @@
 
 
     /**
-	 * Setzt die Einstellung mit Namen und Abschnitt
+     * Setzt die Einstellung mit Namen und Abschnitt
      * @param name Der Name der Einstellung
-	 * @param value Der Wert der Einstellung
+     * @param value Der Wert der Einstellung
      * @param section Der Name des Abschnitts
-	 * @author JoSch
-	 * @date 05-10-2006
+     * @author JoSch
+     * @date 05-10-2006
     */
-	template &lt;class T&gt;
-	void setValue(const T &amp;value, const Ogre::String &amp;name,
-		const Ogre::String &amp;section = Ogre::StringUtil::BLANK)
-	{
-		if (mSettings[section] == 0)
-		{
-			// Neue Sektion anlegen
-			mSettings[section] = new SettingsMultiMap();
-		}
-		Ogre::String _value = Ogre::StringConverter::toString(value);
-		mSettings[section]-&gt;insert( std::multimap&lt;Ogre::String, Ogre::String&gt;::value_type(name, _value));
-	}
+    template &lt;class T&gt;
+    void setValue(const T &amp;value, const Ogre::String &amp;name,
+        const Ogre::String &amp;section = Ogre::StringUtil::BLANK)
+    {
+        if (mSettings[section] == 0)
+        {
+            // Neue Sektion anlegen
+            mSettings[section] = new SettingsMultiMap();
+        }
+        Ogre::String _value = Ogre::StringConverter::toString(value);
+        mSettings[section]-&gt;insert( std::multimap&lt;Ogre::String, Ogre::String&gt;::value_type(name, _value));
+    }
 
-	/**
-	 * Setzt die Einstellung mit Namen und Abschnitt
+    /**
+     * Setzt die Einstellung mit Namen und Abschnitt
      * @param name Der Name der Einstellung
-	 * @param value Der Wert der Einstellung
+     * @param value Der Wert der Einstellung
      * @param section Der Name des Abschnitts
-	 * @author JoSch
-	 * @date 05-10-2006
+     * @author JoSch
+     * @date 05-10-2006
     */
-	void setValues(const Ogre::StringVector values, const Ogre::String &amp;name,
-		const Ogre::String &amp;section = Ogre::StringUtil::BLANK)
-	{
-		if (mSettings[section] == 0)
-		{
-			// Neue Sektion anlegen
-			mSettings[section] = new SettingsMultiMap();
-		}
-		for (Ogre::StringVector::const_iterator it = values.begin();
-			it != values.end(); it++)
-		{
-			mSettings[section]-&gt;insert( std::multimap&lt;Ogre::String, Ogre::String&gt;::value_type(name, *it));
-		}
-	}
+    void setValues(const Ogre::StringVector values, const Ogre::String &amp;name,
+        const Ogre::String &amp;section = Ogre::StringUtil::BLANK)
+    {
+        if (mSettings[section] == 0)
+        {
+            // Neue Sektion anlegen
+            mSettings[section] = new SettingsMultiMap();
+        }
+        for (Ogre::StringVector::const_iterator it = values.begin();
+            it != values.end(); it++)
+        {
+            mSettings[section]-&gt;insert( std::multimap&lt;Ogre::String, Ogre::String&gt;::value_type(name, *it));
+        }
+    }
 
-	/**
-	 * Holt eine Einstellung mit Namen und Abschnitt
-	 * @param name Der Name der Einstellung
-	 * @param section Der Name des Abschnitts
-	 * @param _default Ein Standardwert, falls die Einstellung nicht
-	 * gespeichert wurde
-	 * @author JoSch
-	 * @date 05-10-2006
-	 */
-	int getValue(const int _default, const Ogre::String &amp;name, 
-		const Ogre::String &amp;section = Ogre::StringUtil::BLANK);
+    /**
+     * Holt eine Einstellung mit Namen und Abschnitt
+     * @param name Der Name der Einstellung
+     * @param section Der Name des Abschnitts
+     * @param _default Ein Standardwert, falls die Einstellung nicht
+     * gespeichert wurde
+     * @author JoSch
+     * @date 05-10-2006
+     */
+    int getValue(const int _default, const Ogre::String &amp;name,
+        const Ogre::String &amp;section = Ogre::StringUtil::BLANK);
 
-	/**
-	 * Holt eine Einstellung mit Namen und Abschnitt
-	 * @param name Der Name der Einstellung
-	 * @param section Der Name des Abschnitts
-	 * @param __default Ein Standardwert, falls die Einstellung nicht
-	 * gespeichert wurde
-	 * @author JoSch
-	 * @date 05-10-2006
-	 */
-	Ogre::String getValue(const Ogre::String &amp;_default, const Ogre::String &amp;name, 
-		const Ogre::String &amp;section = Ogre::StringUtil::BLANK);
+    /**
+     * Holt eine Einstellung mit Namen und Abschnitt
+     * @param name Der Name der Einstellung
+     * @param section Der Name des Abschnitts
+     * @param __default Ein Standardwert, falls die Einstellung nicht
+     * gespeichert wurde
+     * @author JoSch
+     * @date 05-10-2006
+     */
+    Ogre::String getValue(const Ogre::String &amp;_default, const Ogre::String &amp;name,
+        const Ogre::String &amp;section = Ogre::StringUtil::BLANK);
 
-	/**
-	 * Holt alle Einstellungen mit selbem Namen und Abschnitt
-	 * @param name Der Name der Einstellung
-	 * @param section Der Name des Abschnitts
-	 * @author JoSch
-	 * @date 05-10-2006
-	 */
-	Ogre::StringVector getValues(const Ogre::String &amp;name, 
-		const Ogre::String &amp;section = Ogre::StringUtil::BLANK);
+    /**
+     * Holt alle Einstellungen mit selbem Namen und Abschnitt
+     * @param name Der Name der Einstellung
+     * @param section Der Name des Abschnitts
+     * @author JoSch
+     * @date 05-10-2006
+     */
+    Ogre::StringVector getValues(const Ogre::String &amp;name,
+        const Ogre::String &amp;section = Ogre::StringUtil::BLANK);
 
 
-	/**
-	 * Holt eine Einstellung mit Namen und Abschnitt
-	 * @param name Der Name der Einstellung
-	 * @param section Der Name des Abschnitts
-	 * @param __default Ein Standardwert, falls die Einstellung nicht
-	 * gespeichert wurde
-	 * @author JoSch
-	 * @date 05-10-2006
-	 */
-	Ogre::Real getValue(const Ogre::Real &amp;_default, const Ogre::String &amp;name, 
-		const Ogre::String &amp;section = Ogre::StringUtil::BLANK);
+    /**
+     * Holt eine Einstellung mit Namen und Abschnitt
+     * @param name Der Name der Einstellung
+     * @param section Der Name des Abschnitts
+     * @param __default Ein Standardwert, falls die Einstellung nicht
+     * gespeichert wurde
+     * @author JoSch
+     * @date 05-10-2006
+     */
+    Ogre::Real getValue(const Ogre::Real &amp;_default, const Ogre::String &amp;name,
+        const Ogre::String &amp;section = Ogre::StringUtil::BLANK);
 
-	/**
-	 * Holt eine Einstellung mit Namen und Abschnitt
-	 * @param name Der Name der Einstellung
-	 * @param section Der Name des Abschnitts
-	 * @param __default Ein Standardwert, falls die Einstellung nicht
-	 * gespeichert wurde
-	 * @author JoSch
-	 * @date 05-10-2006
-	 */
-	bool getValue(const bool _default, const Ogre::String &amp;name, 
-		const Ogre::String &amp;section = Ogre::StringUtil::BLANK);
+    /**
+     * Holt eine Einstellung mit Namen und Abschnitt
+     * @param name Der Name der Einstellung
+     * @param section Der Name des Abschnitts
+     * @param __default Ein Standardwert, falls die Einstellung nicht
+     * gespeichert wurde
+     * @author JoSch
+     * @date 05-10-2006
+     */
+    bool getValue(const bool _default, const Ogre::String &amp;name,
+        const Ogre::String &amp;section = Ogre::StringUtil::BLANK);
 
-	/**
-	 * Holt eine Einstellung mit Namen und Abschnitt
-	 * @param name Der Name der Einstellung
-	 * @param section Der Name des Abschnitts
-	 * @param __default Ein Standardwert, falls die Einstellung nicht
-	 * gespeichert wurde
-	 * @author JoSch
-	 * @date 05-10-2006
-	 */
-	long int getValue(const long int _default, const Ogre::String &amp;name, 
-		const Ogre::String &amp;section = Ogre::StringUtil::BLANK);
+    /**
+     * Holt eine Einstellung mit Namen und Abschnitt
+     * @param name Der Name der Einstellung
+     * @param section Der Name des Abschnitts
+     * @param __default Ein Standardwert, falls die Einstellung nicht
+     * gespeichert wurde
+     * @author JoSch
+     * @date 05-10-2006
+     */
+    long int getValue(const long int _default, const Ogre::String &amp;name,
+        const Ogre::String &amp;section = Ogre::StringUtil::BLANK);
 
-	/**
-	 * Holt eine Einstellung mit Namen und Abschnitt
-	 * @param name Der Name der Einstellung
-	 * @param section Der Name des Abschnitts
-	 * @param __default Ein Standardwert, falls die Einstellung nicht
-	 * gespeichert wurde
-	 * @author JoSch
-	 * @date 05-10-2006
-	 */
-	unsigned int getValue(const unsigned int _default, const Ogre::String &amp;name, 
-		const Ogre::String &amp;section = Ogre::StringUtil::BLANK);
+    /**
+     * Holt eine Einstellung mit Namen und Abschnitt
+     * @param name Der Name der Einstellung
+     * @param section Der Name des Abschnitts
+     * @param __default Ein Standardwert, falls die Einstellung nicht
+     * gespeichert wurde
+     * @author JoSch
+     * @date 05-10-2006
+     */
+    unsigned int getValue(const unsigned int _default, const Ogre::String &amp;name,
+        const Ogre::String &amp;section = Ogre::StringUtil::BLANK);
 
-	/**
-	 * Holt eine Einstellung mit Namen und Abschnitt
-	 * @param name Der Name der Einstellung
-	 * @param section Der Name des Abschnitts
-	 * @param __default Ein Standardwert, falls die Einstellung nicht
-	 * gespeichert wurde
-	 * @author JoSch
-	 * @date 05-10-2006
-	 */
-	unsigned long int getValue(const unsigned long int _default, const Ogre::String &amp;name, 
-		const Ogre::String &amp;section = Ogre::StringUtil::BLANK);
+    /**
+     * Holt eine Einstellung mit Namen und Abschnitt
+     * @param name Der Name der Einstellung
+     * @param section Der Name des Abschnitts
+     * @param __default Ein Standardwert, falls die Einstellung nicht
+     * gespeichert wurde
+     * @author JoSch
+     * @date 05-10-2006
+     */
+    unsigned long int getValue(const unsigned long int _default, const Ogre::String &amp;name,
+        const Ogre::String &amp;section = Ogre::StringUtil::BLANK);
 
+        /**
+         * Adds a section to the config file and adds a list of key-value pairs
+         *
+         * @param section The name of the section, where the key-value pairs are written to
+         * @param settings The list of key-value pairs
+         */
+        void addSection(const Ogre::String&amp; section, const Ogre::NameValuePairList&amp; settings);
 };
 
 template&lt;&gt; inline
@@ -199,7 +206,7 @@
         // Neue Sektion anlegen
         mSettings[section] = new SettingsMultiMap();
     }
-    mSettings[section]-&gt;insert( std::multimap&lt;Ogre::String, Ogre::String&gt;::value_type(name, value));   
+    mSettings[section]-&gt;insert( std::multimap&lt;Ogre::String, Ogre::String&gt;::value_type(name, value));
 }
 
 }

Modified: rl/trunk/engine/common/include/RastullahPrerequisites.h
===================================================================
--- rl/trunk/engine/common/include/RastullahPrerequisites.h	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/common/include/RastullahPrerequisites.h	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -17,29 +17,9 @@
 #ifndef __RastullahPrerequisites_H__
 #define __RastullahPrerequisites_H__
 
-#ifdef HAVE_CONFIG_H
-#   undef PACKAGE_NAME
-#   undef PACKAGE
-#   undef PACKAGE_BUGREPORT
-#   undef PACKAGE_STRING
-#   undef PACKAGE_TARNAME
-#   undef PACKAGE_VERSION
-#endif
-
 #define OGRE_MEMORY_STRESS_TEST 1
 #include &lt;Ogre.h&gt;
 
-#ifdef HAVE_CONFIG_H
-#   undef PACKAGE_NAME
-#   undef PACKAGE
-#   undef PACKAGE_BUGREPORT
-#   undef PACKAGE_STRING
-#   undef PACKAGE_TARNAME
-#   undef PACKAGE_VERSION
-#   include &quot;config.h&quot; 
-#endif
-
-
 #if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
 #   define _snprintf snprintf
 template&lt;class T1, class T2&gt;
@@ -56,11 +36,11 @@
 
 #if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt; 1300)   // MS Visual Studio 2005
 // signed / unsigned auf 1x
-#	pragma warning(once : 4018) 
+#    pragma warning(once : 4018)
 // Sichere Versionen der Stringfunktionen benutzen
-#	if !defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)
-#		define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
-#	endif
+#    if !defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)
+#        define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
+#    endif
 #endif
 
 #endif

Modified: rl/trunk/engine/common/src/ConfigFile.cpp
===================================================================
--- rl/trunk/engine/common/src/ConfigFile.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/common/src/ConfigFile.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -13,7 +13,7 @@
  *  along with this program; if not you can get it here
  *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
  */
- 
+
 #include &quot;ConfigFile.h&quot;
 #include &quot;Exception.h&quot;
 
@@ -37,13 +37,13 @@
     saveDirect(filename, separators, trimWhitespace);
 }
 //-----------------------------------------------------------------------
-void ConfigFile::save(const String&amp; filename, const String&amp; resourceGroup, 
+void ConfigFile::save(const String&amp; filename, const String&amp; resourceGroup,
     const String&amp; separators, bool trimWhitespace)
 {
     saveToResourceSystem(filename, resourceGroup, separators, trimWhitespace);
 }
 //-----------------------------------------------------------------------
-void ConfigFile::saveDirect(const String&amp; filename, const String&amp; separators, 
+void ConfigFile::saveDirect(const String&amp; filename, const String&amp; separators,
     bool trimWhitespace)
 {
     /* Open the configuration file */
@@ -58,7 +58,7 @@
 
 }
 //-----------------------------------------------------------------------
-void ConfigFile::saveToResourceSystem(const String&amp; filename, 
+void ConfigFile::saveToResourceSystem(const String&amp; filename,
     const String&amp; resourceGroup, const String&amp; separators, bool trimWhitespace)
 {
     ///@todo ResourceGroup zum Dateiname erstellen.
@@ -72,109 +72,119 @@
     save(fp, separators, trimWhitespace);
 }
 //-----------------------------------------------------------------------
-void ConfigFile::save(ofstream&amp; stream, const String&amp; separators, 
+void ConfigFile::save(ofstream&amp; stream, const String&amp; separators,
     bool trimWhitespace)
 {
-	SettingsBySection::const_iterator section;
-	for(section = mSettings.begin(); section != mSettings.end(); section++)
-	{
-		if (section-&gt;first != StringUtil::BLANK)
-		{
-			stream &lt;&lt; &quot;[&quot; &lt;&lt; section-&gt;first &lt;&lt; &quot;]&quot; &lt;&lt; endl;
-		} else {
-			/// Keine Sektion
-		}
-		SettingsMultiMap::const_iterator setting;
-		SettingsMultiMap *settings = section-&gt;second;
-		for(setting = settings-&gt;begin(); setting != settings-&gt;end(); setting++)
-		{
-			stream &lt;&lt; setting-&gt;first &lt;&lt; &quot;=&quot; &lt;&lt; setting-&gt;second &lt;&lt; endl;
-		}
-	}
+    SettingsBySection::const_iterator section;
+    for(section = mSettings.begin(); section != mSettings.end(); section++)
+    {
+        if (section-&gt;first != StringUtil::BLANK)
+        {
+            stream &lt;&lt; &quot;[&quot; &lt;&lt; section-&gt;first &lt;&lt; &quot;]&quot; &lt;&lt; endl;
+        } else {
+            /// Keine Sektion
+        }
+        SettingsMultiMap::const_iterator setting;
+        SettingsMultiMap *settings = section-&gt;second;
+        for(setting = settings-&gt;begin(); setting != settings-&gt;end(); setting++)
+        {
+            stream &lt;&lt; setting-&gt;first &lt;&lt; &quot;=&quot; &lt;&lt; setting-&gt;second &lt;&lt; endl;
+        }
+
+        // Insert a linebreak
+        stream &lt;&lt; endl;
+    }
 }
 
-int ConfigFile::getValue(const int _default, const Ogre::String &amp;name, 
-		const Ogre::String &amp;section)
+int ConfigFile::getValue(const int _default, const Ogre::String &amp;name,
+        const Ogre::String &amp;section)
 {
-	Ogre::String v = getSetting(name, section);
-	if (v == Ogre::StringUtil::BLANK)
-	{
-		return _default;
-	} else {
-		return Ogre::StringConverter::parseInt(v);
-	}
+    Ogre::String v = getSetting(name, section);
+    if (v == Ogre::StringUtil::BLANK)
+    {
+        return _default;
+    } else {
+        return Ogre::StringConverter::parseInt(v);
+    }
 }
 
-String ConfigFile::getValue(const String &amp;_default, const Ogre::String &amp;name, 
-		const Ogre::String &amp;section)
+String ConfigFile::getValue(const String &amp;_default, const Ogre::String &amp;name,
+        const Ogre::String &amp;section)
 {
-	return getSetting(name, section);
+    return getSetting(name, section);
 }
 
-StringVector ConfigFile::getValues(const Ogre::String &amp;name, 
-		const Ogre::String &amp;section)
+StringVector ConfigFile::getValues(const Ogre::String &amp;name,
+        const Ogre::String &amp;section)
 {
-	return getMultiSetting(name, section);
+    return getMultiSetting(name, section);
 }
 
-Real ConfigFile::getValue(const Real &amp;_default, const Ogre::String &amp;name, 
-		const Ogre::String &amp;section)
+Real ConfigFile::getValue(const Real &amp;_default, const Ogre::String &amp;name,
+        const Ogre::String &amp;section)
 {
-	Ogre::String v = getSetting(name, section);
-	if (v == Ogre::StringUtil::BLANK)
-	{
-		return _default;
-	} else {
-		return Ogre::StringConverter::parseReal(v);
-	}
+    Ogre::String v = getSetting(name, section);
+    if (v == Ogre::StringUtil::BLANK)
+    {
+        return _default;
+    } else {
+        return Ogre::StringConverter::parseReal(v);
+    }
 }
 
-bool ConfigFile::getValue(const bool _default, const Ogre::String &amp;name, 
-		const Ogre::String &amp;section)
+bool ConfigFile::getValue(const bool _default, const Ogre::String &amp;name,
+        const Ogre::String &amp;section)
 {
-	Ogre::String v = getSetting(name, section);
-	if (v == Ogre::StringUtil::BLANK)
-	{
-		return _default;
-	} else {
-		return Ogre::StringConverter::parseBool(v);
-	}
+    Ogre::String v = getSetting(name, section);
+    if (v == Ogre::StringUtil::BLANK)
+    {
+        return _default;
+    } else {
+        return Ogre::StringConverter::parseBool(v);
+    }
 }
 
-long int ConfigFile::getValue(const long int _default, const Ogre::String &amp;name, 
-		const Ogre::String &amp;section)
+long int ConfigFile::getValue(const long int _default, const Ogre::String &amp;name,
+        const Ogre::String &amp;section)
 {
-	Ogre::String v = getSetting(name, section);
-	if (v == Ogre::StringUtil::BLANK)
-	{
-		return _default;
-	} else {
-		return Ogre::StringConverter::parseLong(v);
-	}
+    Ogre::String v = getSetting(name, section);
+    if (v == Ogre::StringUtil::BLANK)
+    {
+        return _default;
+    } else {
+        return Ogre::StringConverter::parseLong(v);
+    }
 }
 
-unsigned int ConfigFile::getValue(const unsigned int _default, const Ogre::String &amp;name, 
-		const Ogre::String &amp;section)
+unsigned int ConfigFile::getValue(const unsigned int _default, const Ogre::String &amp;name,
+        const Ogre::String &amp;section)
 {
-	Ogre::String v = getSetting(name, section);
-	if (v == Ogre::StringUtil::BLANK)
-	{
-		return _default;
-	} else {
-		return Ogre::StringConverter::parseUnsignedInt(v);
-	}
+    Ogre::String v = getSetting(name, section);
+    if (v == Ogre::StringUtil::BLANK)
+    {
+        return _default;
+    } else {
+        return Ogre::StringConverter::parseUnsignedInt(v);
+    }
 }
 
-unsigned long int ConfigFile::getValue(const unsigned long int _default, const Ogre::String &amp;name, 
-		const Ogre::String &amp;section)
+unsigned long int ConfigFile::getValue(const unsigned long int _default, const Ogre::String &amp;name,
+        const Ogre::String &amp;section)
 {
-	Ogre::String v = getSetting(name, section);
-	if (v == Ogre::StringUtil::BLANK)
-	{
-		return _default;
-	} else {
-		return Ogre::StringConverter::parseUnsignedLong(v);
-	}
+    Ogre::String v = getSetting(name, section);
+    if (v == Ogre::StringUtil::BLANK)
+    {
+        return _default;
+    } else {
+        return Ogre::StringConverter::parseUnsignedLong(v);
+    }
 }
 
+    void ConfigFile::addSection(const Ogre::String&amp; section, const Ogre::NameValuePairList&amp; settings)
+    {
+        // Create new section
+        mSettings[section] = new SettingsMultiMap();
+        // Insert values from the settings map
+        mSettings[section]-&gt;insert(settings.begin(), settings.end());
+    }
 }

Modified: rl/trunk/engine/core/Makefile.am
===================================================================
--- rl/trunk/engine/core/Makefile.am	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/core/Makefile.am	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,2 +1 @@
 SUBDIRS = include src
-

Modified: rl/trunk/engine/core/include/ConfigurationManager.h
===================================================================
--- rl/trunk/engine/core/include/ConfigurationManager.h	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/core/include/ConfigurationManager.h	2007-02-07 19:30:10 UTC (rev 3026)
@@ -14,16 +14,17 @@
  *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
  */
 
-#ifndef __RL_CONFIGURATIONMANAGER_H__
-#define __RL_CONFIGURATIONMANAGER_H__
-
-#include &quot;CorePrerequisites.h&quot;
 /**
  * \file ConfigurationManager.h
  * Definiert die abstrakte Basisklasse f&#195;&#188;r das Konfigurationsmanagement.
  */
 
-#include &lt;OgreConfigFile.h&gt;
+#ifndef __RL_CONFIGURATIONMANAGER_H__
+#define __RL_CONFIGURATIONMANAGER_H__
+
+#include &quot;CorePrerequisites.h&quot;
+#include &quot;ConfigFile.h&quot;
+
 #include &lt;OgreSingleton.h&gt;
 #include &lt;boost/filesystem/operations.hpp&gt;
 #include &lt;boost/filesystem/exception.hpp&gt;
@@ -32,197 +33,276 @@
 
 namespace rl
 {
-	class _RlCoreExport ConfigurationManager : protected Ogre::Singleton&lt;ConfigurationManager&gt;
-	{
-		public:
-			/**
-			 * Constructs a new ConfigurationManager object.
-			 *
-			 * Sets the name for the Ogre and Rastullah logfiles
-			 * and the Rastullah configuration file. The path
-			 * where configuration files might be reside is also set.
-			 */
-            ConfigurationManager();
+    class _RlCoreExport ConfigurationManager : protected Ogre::Singleton&lt;ConfigurationManager&gt;
+    {
+        public:
+            /// Sections where settings can be queried from
+            enum ConfigurationSection
+            {
+                CS_GENERAL = 1,
+                CS_GRAPHICS,
+                CS_SOUND,
+                CS_INPUT
+            };
 
-			~ConfigurationManager();
+            ~ConfigurationManager();
 
-			/**
-			 * Returns a pointer to the single instance of the
-			 * ConfigurationManager.
-			 *
-			 * The ConfigurationManager object is created, if it does not
-			 * exist.
-			 * @return Pointer to ConfigurationManager object
-			 */
-			static ConfigurationManager* getSingletonPtr();
+            /**
+             * Returns a pointer to the single instance of the
+             * ConfigurationManager.
+             *
+             * The ConfigurationManager object is created, if it does not
+             * exist.
+             *
+             * @return Pointer to ConfigurationManager object
+             */
+            static ConfigurationManager* getSingletonPtr();
 
-			/**
-			 * Returns a reference to the single instance of the
-			 * ConfigurationManager.
-			 *
-			 * The ConfigurationManager object is created, if it does not
-			 * exist.
-			 * @return Reference to ConfigurationManager object
-			 */
-			static ConfigurationManager&amp; getSingleton();
+            /**
+             * Returns a reference to the single instance of the
+             * ConfigurationManager.
+             *
+             * The ConfigurationManager object is created, if it does not
+             * exist.
+             *
+             * @return Reference to ConfigurationManager object
+             */
+            static ConfigurationManager&amp; getSingleton();
 
-			/**
-			 * Returns the filename for the log written by Ogre
-			 *
-			 * @return filename of Ogre's logfile
-			 */
-			Ogre::String getOgreLogFile() const;
+            /**
+             * Returns the filename for the log written by Ogre
+             *
+             * @return filename of Ogre's logfile
+             */
+            Ogre::String getOgreLogFile() const;
 
-			/**
-			 * Returns the filename for the log written by Rastullah
-			 *
-			 * @return filename of Rastullah's logfile
-			 */
-			Ogre::String getRastullahLogFile() const;
+            /**
+             * Returns the filename for the log written by Rastullah
+             *
+             * @return filename of Rastullah's logfile
+             */
+            Ogre::String getRastullahLogFile() const;
 
-			/**
-			 * Returns the filename for the log written by CEGUI
-			 *
-			 * @return filename of CEGUI's logfile
-			 */
-			Ogre::String getCeguiLogFile() const;
+            /**
+             * Returns the filename for the log written by CEGUI
+             *
+             * @return filename of CEGUI's logfile
+             */
+            Ogre::String getCeguiLogFile() const;
 
-			/**
-			 * Returns the filename of the configuration file for the modules
-			 *
-			 * @return filename of module's configuration file
-			 */
-			Ogre::String getModulesCfgFile() const;
+            /**
+             * Returns the filename of the configuration file for the modules
+             *
+             * @return filename of module's configuration file
+             */
+            Ogre::String getModulesCfgFile() const;
 
-			/**
-			 * Returns the filename of the configuration file for the OS
-			 * specific plugins
-			 *
-			 * @return filename of the plugin's configuration file
-			 */
-			Ogre::String getPluginCfgFile() const;
+            /**
+             * Returns the filename of the configuration file for the OS
+             * specific plugins
+             *
+             * @return filename of the plugin's configuration file
+             */
+            Ogre::String getPluginCfgFile() const;
 
-			/**
-			 * Returns a list of paths, were Rastullah configuration files
-			 * reside
-			 *
-			 * The list is seperated via the : character and has to be
-			 * processed, before usage
-			 *
-			 * @return colon seperated path of Rastullah configuration
-			 *         directories
-			 */
-			Ogre::String getRastullahCfgPath() const;
+            /**
+             * Returns a list of paths, were Rastullah configuration files
+             * reside
+             *
+             * The list is seperated via the : character and has to be
+             * processed, before usage
+             *
+             * @return colon seperated path of Rastullah configuration
+             *         directories
+             */
+            Ogre::String getRastullahCfgPath() const;
 
-			/**
-			 * Returns the root of the Rastullah modules directory
-			 *
-			 * @return directory where Rastullah modules reside
-			 */
-			Ogre::String getModulesRootDirectory() const;
+            /**
+             * Returns the root of the Rastullah modules directory
+             *
+             * @return directory where Rastullah modules reside
+             */
+            Ogre::String getModulesRootDirectory() const;
 
-			/**
-			 * Returns the directory where Rastullah stores all its log files
-			 *
-			 * @return directoy where Rastullah logfiles are stored
-			 */
-			Ogre::String getRastullahLogDirectory() const;
+            /**
+             * Returns the directory where Rastullah stores all its log files
+             *
+             * @return directoy where Rastullah logfiles are stored
+             */
+            Ogre::String getRastullahLogDirectory() const;
 
-			/**
-			 * Returns the filename of the current keymap file used by
-			 * Rastullah
-			 *
-			 * @return filename of keymap file
-			 */
-			Ogre::String getKeymap() const;
+            /**
+             * Returns the directory where OGRE stores its plugins
+             *
+             * @return directory where OGRE plugins are stored
+             */
+            Ogre::String getOgrePluginDirectory() const;
 
-			/**
-			 * @todo Remove, after other subsystems were changed to
-			 *       new ConfigurationManager style
-			 */
-			Ogre::String getPluginCfgPath() const;
-			Ogre::String getRastullahLogPath() const;
-			Ogre::String getModulesCfgPath() const;
-			Ogre::String getConfigModulePath() const;
-            Ogre::String getRastullahSystemCfgPath() const;
-			Ogre::String getSoundCfgPath() const;
-			Ogre::String getInputConfigPath() const;
+            /**
+             * Adds a key-value pair to the list specified by section
+             *
+             * If the key already exists in the list, its value will be updated
+             *
+             * @param section The section where the key-value pair will be inserted
+             * @param key The key of the key-value pair
+             * @param value The value of the key-value pair
+             */
+            void addSetting(ConfigurationSection section, Ogre::String key, Ogre::String value);
 
-			Ogre::String getStringSetting(const Ogre::String&amp; name, const Ogre::String&amp; _default = Ogre::StringUtil::BLANK) const;
-			Ogre::Real getRealSetting(const Ogre::String&amp; name, Ogre::Real _default = 0.0f) const;
-			int getIntSetting(const Ogre::String&amp; name, int _default = 0) const;
-			bool getBoolSetting(const Ogre::String&amp; name, bool _default = false) const;
+            /**
+             * Returns the string value for a specific key in a specific section
+             *
+             * @param section The sections key-value list, which is searched
+             * @param key The key, for which a value will be returned
+             * @return string value for the specific key in the specific section
+             */
+            Ogre::String getStringSetting(ConfigurationSection section, Ogre::String key);
 
-            Logger::LogLevel getLogLevel() const;
+            /**
+             * Returns the int value for a specific key in a specific section
+             *
+             * @param section The sections key-value list, which is searched
+             * @param key The key, for which a value will be returned
+             * @return int value for the specific key in the specific section
+             */
+            int getIntSetting(ConfigurationSection section, Ogre::String key);
 
-			Ogre::String getEngineVersionString() const;
-			Ogre::String getEngineVersionName() const;
-			long         getEngineBuildNumber() const;
-			const rl::CeGuiString&amp;  getAboutText() const;
+            /**
+             * Returns the boolean value for a specific key in a specific section
+             *
+             * @param section The sections key-value list, which is searched
+             * @param key The key, for which a value will be returned
+             * @return boolean value for the specific key in the specific section
+             */
+            bool getBoolSetting(ConfigurationSection section, Ogre::String key);
 
-			bool shouldUseStaticGeometry() const;
-			Ogre::String getTextureUnitScheme() const;
+            /**
+             * Returns the real value for a specific key in a specific section
+             *
+             * @param section The sections key-value list, which is searched
+             * @param key The key, for which a value will be returned
+             * @return real value for the specific key in the specific section
+             */
+            Ogre::Real getRealSetting(ConfigurationSection section, Ogre::String key);
 
-			/**
-			 * Loads configuration files from the configuration directories
-			 *
-			 * Loads up to four configuration files (systemwide, user, current
-			 * directory, module) and sets certain settings for the game
-			 */
-            void loadConfig();
+            /**
+             * Returns a pointer to the graphical settings for the OGRE renderer
+             *
+             * @return key-value list of graphic settings
+             */
+            Ogre::NameValuePairList getGraphicSettings() const;
 
-		protected:
-			Ogre::String mRastullahCfgFile;
-			Ogre::String mOgreLogFile;
-			Ogre::String mRastullahLogFile;
-			Ogre::String mCeguiLogFile;
-			Ogre::String mSoundCfgFile;
-			Ogre::String mModulesCfgFile;
-			Ogre::String mPluginCfgFile;
+            /**
+             * Returns a pointer to the sound settings for the Rl::SoundManager
+             *
+             * @return key-value list of sound settings
+             */
+            Ogre::NameValuePairList getSoundSettings() const;
 
-			Ogre::String mModulesRootDirectory;
-			Ogre::String mRastullahLogDirectory;
-			Ogre::String mModulesCfgDirectory;
-			Ogre::String mRastullahCfgPath;
+            /**
+             * Returns the filename of the current keymap file used by
+             * Rastullah
+             *
+             * @return filename of keymap file
+             */
+            Ogre::String getKeymap() const;
 
-			/**
-			 * @todo Remove, after other subsystems were changed to
-			 *       new ConfigurationManager style
-			 */
-			Ogre::String mPluginCfgPath;
-			Ogre::String mModulesCfgPath;
-			Ogre::String mConfigModuleDirectory;
-            Ogre::String mRastullahSystemCfgPath;
-			Ogre::String mSoundCfgPath;
-			Ogre::String mRastullahOgreCfgPath;
+            /**
+             * Returns the input settings for the CommandMapper
+             *
+             * @return key-value list of input settings
+             */
+            Ogre::NameValuePairList getInputSettings() const;
 
+            /**
+             * Returns the log level specifying how verbose the created
+             * logfiles are
+             *
+             * @return verbosity level of logfiles
+             */
+            Logger::LogLevel getLogLevel();
+
+            Ogre::String getEngineVersionString() const;
+            Ogre::String getEngineVersionName() const;
+            long         getEngineBuildNumber() const;
+
+            /**
+             * Returns the text displayed in the &quot;About Application&quot; window
+             *
+             * @return text displayed in &quot;About Application&quot; window
+             */
+            const rl::CeGuiString&amp; getAboutText() const;
+
+            /**
+             * Loads configuration files from the configuration directories
+             *
+             * Loads up to four configuration files (systemwide, user, current
+             * directory, module) and sets certain settings for the game
+             */
+            void loadConfig();
+
+            /**
+             * Saves a configuration file in OS specific directory
+             */
+            void saveConfig();
+
         private:
-			/**
-			 * Sets the path where configuration files may reside
-			 * based on the operating system.
-			 */
-			void setRastullahCfgPath();
+            /**
+             * Constructs a new ConfigurationManager object.
+             *
+             * Sets the name for the Ogre, Rastullah and CEGUI logfiles
+             * and the Rastullah configuration file. The path
+             * where configuration files might be reside is also set.
+             */
+            ConfigurationManager();
 
-			/**
-			 * Adds the specified path to the Rastullah configuration path
-			 * variable.
-			 *
-			 * All values are seperated via a colon.
-			 *
-			 * @param cfg_dir Directory where a configuration file may reside
-			 */
-			void addToCfgPath(const std::string&amp; cfg_dir);
+            /**
+             * Sets the path where configuration files may reside
+             * based on the operating system.
+             */
+            void setRastullahCfgPath();
 
-			/**
-			 * Check if a specified file exists.
-			 *
-			 * @param filename File being checked for existence
-			 * @return true if file exists, false otherwise
-			 */
-			bool checkForFile(const std::string&amp; filename);
+            /**
+             * Adds the specified path to the Rastullah configuration path
+             * variable.
+             *
+             * All values are seperated via a colon.
+             *
+             * @param cfg_dir Directory where a configuration file may reside
+             */
+            void addToCfgPath(const std::string&amp; cfg_dir);
 
-            Ogre::ConfigFile* mSystemConfig;
-	};
+            /**
+             * Check if a specified file exists.
+             *
+             * @param filename File being checked for existence
+             * @return true if file exists, false otherwise
+             */
+            bool checkForFile(const std::string&amp; filename);
+
+            /**
+             * Searches for a specific key in a specific section
+             *
+             * @param section The sections key-value list, which is searched
+             * @param key The key, for which a value will be returned
+             * @return value if key exits, otherwise NULL
+             */
+            Ogre::String findSetting(ConfigurationSection section, Ogre::String key) const;
+
+            Ogre::String mRastullahCfgFile;           //!&lt; Filename of the Rastullah configuration file
+            Ogre::String mOgreLogFile;                //!&lt; Filename of the logfile written by OGRE
+            Ogre::String mRastullahLogFile;           //!&lt; Filename of the logfile written by Rastullah
+            Ogre::String mCeguiLogFile;               //!&lt; Filename of the logfile written by CEGUI
+            Ogre::String mModulesCfgFile;             //!&lt; Filename of the Module configuration file
+            Ogre::String mModulesRootDirectory;       //!&lt; Directory where Rastullah's modules reside
+            Ogre::String mRastullahLogDirectory;      //!&lt; Directory where all logfiles are stored
+            Ogre::String mRastullahCfgPath;           //!&lt; List of directories containing Rastullah configuration files
+            Ogre::String mOgrePluginDirectory;        //!&lt; Directory where OGRE stores its plugins
+            Ogre::NameValuePairList mGeneralSettings; //!&lt; General settings for Rastullah
+            Ogre::NameValuePairList mGraphicSettings; //!&lt; Graphic settings for the OGRE Renderer
+            Ogre::NameValuePairList mSoundSettings;   //!&lt; Sound settings for the Rastullah soundsystem
+            Ogre::NameValuePairList mInputSettings;   //!&lt; Input settings for the Rastullah inputsystem
+    };
 }
 
 #endif

Modified: rl/trunk/engine/core/include/CoreSubsystem.h
===================================================================
--- rl/trunk/engine/core/include/CoreSubsystem.h	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/core/include/CoreSubsystem.h	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -50,69 +50,77 @@
 
 typedef _RlCoreExport std::map&lt;Ogre::String, ContentModule*&gt; ModuleMap;
 
-/** CoreSubsystem. 
-	@remarks		
+/** CoreSubsystem.
+    @remarks
         It follows the Singleton Pattern,
-		and initialises the game context.
+        and initialises the game context.
 */
 class _RlCoreExport CoreSubsystem : public Ogre::Singleton&lt;CoreSubsystem&gt;, public virtual EventSource
 {
 public:
-	/** Default Constructor */
-	CoreSubsystem();
+    /** Default Constructor */
+    CoreSubsystem();
     /** Default Deconstructor */
-	virtual ~CoreSubsystem();
+    virtual ~CoreSubsystem();
 
-	/** Starts the Game */
-	void startCore();
-	
-	/** Returns the Singleton */
-	//static CoreSubsystem &amp; getSingleton();
-	//static CoreSubsystem * getSingletonPtr();
+    /** Starts the Game */
+    void startCore();
 
-	World* getWorld();
-	void loadMap(const Ogre::String type, const Ogre::String filename,
-	    const Ogre::String module, const Ogre::String startupScript = &quot;&quot;);
+    /** Returns the Singleton */
+    //static CoreSubsystem &amp; getSingleton();
+    //static CoreSubsystem * getSingletonPtr();
 
-	RubyInterpreter* getRubyInterpreter();
+    World* getWorld();
+    void loadMap(const Ogre::String type, const Ogre::String filename,
+        const Ogre::String module, const Ogre::String startupScript = &quot;&quot;);
 
-	ContentModule* getActiveAdventureModule() const;
-	ContentModule* getModule(const Ogre::String&amp; moduleId) const;
-	const ModuleMap&amp; getAllModules() const;
-	void startAdventureModule(ContentModule* module);
-	void setDefaultActiveModule(const Ogre::String&amp; moduleId); 
-	const Ogre::String&amp; getDefaultActiveModule() const; 
-	void registerModule(ContentModule* module);
+    RubyInterpreter* getRubyInterpreter();
 
-	void setDeveloperMode(bool developerMode);
-	bool getDeveloperMode() const;
+    ContentModule* getActiveAdventureModule() const;
+    ContentModule* getModule(const Ogre::String&amp; moduleId) const;
+    const ModuleMap&amp; getAllModules() const;
+    void startAdventureModule(ContentModule* module);
+    void setDefaultActiveModule(const Ogre::String&amp; moduleId);
+    const Ogre::String&amp; getDefaultActiveModule() const;
+    void registerModule(ContentModule* module);
 
-	
-	/** Saves a timestamped jpg Screenshot
-		@param sName The filename (extended with the timestamp)
-	*/
-	void makeScreenshot(const Ogre::String&amp; sName);
+    void setDeveloperMode(bool developerMode);
+    bool getDeveloperMode() const;
 
-	void addCoreEventListener(CoreEventListener* listener);
-	void removeCoreEventListener(CoreEventListener* listener);
 
-	void setScheme(const Ogre::String&amp; schemeName);
+    /** Saves a timestamped jpg Screenshot
+        @param sName The filename (extended with the timestamp)
+    */
+    void makeScreenshot(const Ogre::String&amp; sName);
 
-	bool isInitialized() const;
+    void addCoreEventListener(CoreEventListener* listener);
+    void removeCoreEventListener(CoreEventListener* listener);
 
+    void setScheme(const Ogre::String&amp; schemeName);
+
+    bool isInitialized() const;
+
+    /**
+     * Retrieves a pointer to the current render window.
+     *
+     * @return pointer to render window
+     */
+    Ogre::RenderWindow* getRenderWindow();
+
 private:
-	World* mWorld;
-	RubyInterpreter* mRubyInterpreter;
-	ModuleMap mModules;
-	ContentModule* mActiveAdventureModule;
-	Ogre::String mDefaultActiveModule;
+    World* mWorld;
+    RubyInterpreter* mRubyInterpreter;
+    ModuleMap mModules;
+    ContentModule* mActiveAdventureModule;
+    Ogre::String mDefaultActiveModule;
+    Ogre::RenderWindow* mRenderWindow;            //!&lt; Render window for OGRE
 
-	RL_LONGLONG mClockStartTime;
+    RL_LONGLONG mClockStartTime;
 
-	bool mDeveloperMode;
-	bool mInitialized;
-	EventCaster&lt;CoreEvent&gt; mCoreEventCaster;
-	std::vector&lt;Ogre::Technique*&gt; mDefaultTechniques;
+    bool mDeveloperMode;
+    bool mInitialized;
+    EventCaster&lt;CoreEvent&gt; mCoreEventCaster;
+    std::vector&lt;Ogre::Technique*&gt; mDefaultTechniques;
 
     // The singletons of this subsystem
     Ogre::Root* mOgreRoot;
@@ -124,29 +132,26 @@
     ActorManager* mActorManager;
     GameEventManager* mGameEventManager;
     ConfigurationManager* mConfigurationManager;
-	SoundManager* mSoundManager;
+    SoundManager* mSoundManager;
     DebugVisualsManager* mDebugVisualsManager;
     JobScheduler* mJobScheduler;
 
     /** Runs the setup methods  */
-	bool initializeCoreSubsystem();
+    bool initializeCoreSubsystem();
 
-	/** Loads all needed ressources */
-	void initializeResources();
+    /** Loads all needed ressources */
+    void initializeResources();
 
-	void loadPlugins();
+    void loadPlugins();
     void unloadPlugins();
 
-	/**
-	 * Sammelt alle Default-Techniques, um sie sp&#228;ter bei jedem aktivierten Scheme 
-	 * benutzen zu k&#246;nnen
-	 */
-	void updateDefaultScheme();
+    /**
+     * Sammelt alle Default-Techniques, um sie sp&#228;ter bei jedem aktivierten Scheme
+     * benutzen zu k&#246;nnen
+     */
+    void updateDefaultScheme();
 
     void loadModule(ContentModule* module);
-
-	/** Opens a configuration dialog */
-	bool setupConfiguration();
 };
 
 }

Modified: rl/trunk/engine/core/include/SoundDriver.h
===================================================================
--- rl/trunk/engine/core/include/SoundDriver.h	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/core/include/SoundDriver.h	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -22,83 +22,88 @@
 
 namespace rl
 {
-    class ConfigFile;
     class ListenerMovable;
 
-/**
- * Diese Klasse dient zur Definition einer Schnittstelle
- * zu den m&#239;&#191;&#189;glichen Soundbibliotheken. Sie geben Preis, ob
- * ein Treiber vorhanden ist oder nicht. Der Nulltreiber
- * existiert dabei immer.
- */
-class _RlCoreExport SoundDriver
-{
-public:
-    /// Der Konstruktor
-	SoundDriver(Ogre::ResourceManager* soundResourceManager);
-    /// Der Destruktor
-	virtual ~SoundDriver();
-    /// Zeigt an, ob der Treiber funktionsf&#239;&#191;&#189;hig ist.
-    virtual bool isDriverAvailable() = 0;
-    
-    /** Initialize driver
-     *  @return &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; otherwise
-     */ 
-    virtual bool initialize() = 0;
-    
-    /// Beende den Treiber
-    virtual void shutdown() = 0;
-    /// Der Name des Treibers
-    virtual Ogre::String getName() const = 0;
-    /// Update-Aufgaben erledigen
-    virtual void update() = 0;
-    /// Einen Sound-Stream mit Resource erzeugen
-    virtual Sound *createStream(const SoundResourcePtr &amp;res) = 0;
-    /// Einen Sound-Sample mit Resource erzeugen
-    virtual Sound *createSample(const SoundResourcePtr &amp;res) = 0;
-    /// Einen Soundlistener erzeugen
-    virtual ListenerMovable *createListener(const Ogre::String &amp;name) = 0;
-    
+    /**
+     * Diese Klasse dient zur Definition einer Schnittstelle
+     * zu den m&#239;&#191;&#189;glichen Soundbibliotheken. Sie geben Preis, ob
+     * ein Treiber vorhanden ist oder nicht. Der Nulltreiber
+     * existiert dabei immer.
+     */
+    class _RlCoreExport SoundDriver
+    {
+    public:
+        /// Der Konstruktor
+        SoundDriver(Ogre::ResourceManager* soundResourceManager);
+        /// Der Destruktor
+        virtual ~SoundDriver();
+        /// Zeigt an, ob der Treiber funktionsf&#239;&#191;&#189;hig ist.
+        virtual bool isDriverAvailable() = 0;
 
-	/// Setzt den Faktor f, mit der die Lautst&#239;&#191;&#189;rke nach der Formel 1/(f*Entfernung) abnimmt
-	virtual void setRolloffFactor(const Ogre::Real&amp; f) = 0;
-	virtual const Ogre::Real getRolloffFactor() = 0;
-    /// Die Standardlautst&#239;&#191;&#189;rke f&#239;&#191;&#189;r Musik einstellen
-    void setDefaultMusicVolume(const Ogre::Real&amp; vol);
-    /// Die Standardlautst&#239;&#191;&#189;rke f&#239;&#191;&#189;r Musik zur&#239;&#191;&#189;ckgeben.
-	const Ogre::Real getDefaultMusicVolume() const;
-    /// Die Standardlautst&#239;&#191;&#189;rke f&#239;&#191;&#189;r Musik einstellen
-    void setDefaultSoundVolume(const Ogre::Real&amp; vol);
-    /// Die Standardlautst&#239;&#191;&#189;rke f&#239;&#191;&#189;r Musik zur&#239;&#191;&#189;ckgeben.
-    const Ogre::Real getDefaultSoundVolume() const;
-    /// Die Lautst&#239;&#191;&#189;rke aller Sounds
-    virtual void setMasterVolume(const Ogre::Real&amp; vol);
-    /// Die Standardlautst&#239;&#191;&#189;rke f&#239;&#191;&#189;r Musik zur&#239;&#191;&#189;ckgeben.
-    const Ogre::Real getMasterVolume() const;
-    /// Einen Sound aus den Listen entfernen
-    void remove(Sound *sound);
-    
-    /// Die Einstellungen in Datei schreiben
-    virtual void saveConf(rl::ConfigFile &amp;conf) const;
-    /// Die Einstellungen laden
-    virtual void loadConf(rl::ConfigFile &amp;conf);
-    
-    
-protected:
-    /// Liste der Musikst&#239;&#191;&#189;cke
-    SoundSet mMusicSet;
-    /// Liste der Sounds
-    SoundSet mSoundSet;
-    /// Standardeinstellung f&#239;&#191;&#189;r Musik
-    Ogre::Real mDefaultMusicVolume;
-    /// Standardeinstellung f&#239;&#191;&#189;r Sounds
-    Ogre::Real mDefaultSoundVolume;
+        /** Initialize driver
+         *  @return &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; otherwise
+         */
+        virtual bool initialize() = 0;
 
-	Ogre::Real mMasterVolume;
+        /// Beende den Treiber
+        virtual void shutdown() = 0;
+        /// Der Name des Treibers
+        virtual Ogre::String getName() const = 0;
+        /// Update-Aufgaben erledigen
+        virtual void update() = 0;
+        /// Einen Sound-Stream mit Resource erzeugen
+        virtual Sound *createStream(const SoundResourcePtr &amp;res) = 0;
+        /// Einen Sound-Sample mit Resource erzeugen
+        virtual Sound *createSample(const SoundResourcePtr &amp;res) = 0;
+        /// Einen Soundlistener erzeugen
+        virtual ListenerMovable *createListener(const Ogre::String &amp;name) = 0;
 
-	static Ogre::ResourceManager* sSoundResourceManager;
-};
 
+        /// Setzt den Faktor f, mit der die Lautst&#239;&#191;&#189;rke nach der Formel 1/(f*Entfernung) abnimmt
+        virtual void setRolloffFactor(const Ogre::Real&amp; f) = 0;
+        virtual const Ogre::Real getRolloffFactor() = 0;
+        /// Die Standardlautst&#239;&#191;&#189;rke f&#239;&#191;&#189;r Musik einstellen
+        void setDefaultMusicVolume(const Ogre::Real&amp; vol);
+        /// Die Standardlautst&#239;&#191;&#189;rke f&#239;&#191;&#189;r Musik zur&#239;&#191;&#189;ckgeben.
+        const Ogre::Real getDefaultMusicVolume() const;
+        /// Die Standardlautst&#239;&#191;&#189;rke f&#239;&#191;&#189;r Musik einstellen
+        void setDefaultSoundVolume(const Ogre::Real&amp; vol);
+        /// Die Standardlautst&#239;&#191;&#189;rke f&#239;&#191;&#189;r Musik zur&#239;&#191;&#189;ckgeben.
+        const Ogre::Real getDefaultSoundVolume() const;
+        /// Die Lautst&#239;&#191;&#189;rke aller Sounds
+        virtual void setMasterVolume(const Ogre::Real&amp; vol);
+        /// Die Standardlautst&#239;&#191;&#189;rke f&#239;&#191;&#189;r Musik zur&#239;&#191;&#189;ckgeben.
+        const Ogre::Real getMasterVolume() const;
+        /// Einen Sound aus den Listen entfernen
+        void remove(Sound *sound);
+
+        /**
+         * Returns the current sound driver settings as a key-value list
+         *
+         * @return key-value list of sound options
+         */
+        virtual Ogre::NameValuePairList getSettings() const;
+
+        /**
+         * Sets certain options for the sound driver, like volume settings for
+         * sound effects and music.
+         *
+         * @param settings key-value list of settings
+         */
+        virtual void applySettings(const Ogre::NameValuePairList&amp; settings);
+
+    protected:
+        /// Liste der Musikst&#239;&#191;&#189;cke
+        SoundSet mMusicSet;
+        /// Liste der Sounds
+        SoundSet mSoundSet;
+        Ogre::Real mDefaultMusicVolume;  ///!&lt; Music volume
+        Ogre::Real mDefaultSoundVolume;  ///!&lt; Sound effect volume
+        Ogre::Real mMasterVolume;        ///!&lt; Master volume
+
+        static Ogre::ResourceManager* sSoundResourceManager;
+    };
+
 }
 
 #endif /*SOUNDDRIVER_H_*/

Modified: rl/trunk/engine/core/include/SoundManager.h
===================================================================
--- rl/trunk/engine/core/include/SoundManager.h	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/core/include/SoundManager.h	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,18 +1,18 @@
 /* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
 
 #ifndef SOUNDMANAGER_H
 #define SOUNDMANAGER_H
@@ -47,10 +47,10 @@
  * @date 04-26-2004
  * @version 2.0
  * @date 06-29-2005
- */ 
-class _RlCoreExport SoundManager : public Ogre::ResourceManager,
-        public Ogre::Singleton&lt;SoundManager&gt;, public GameTask 
-{
+ */
+    class _RlCoreExport SoundManager : public Ogre::ResourceManager,
+            public Ogre::Singleton&lt;SoundManager&gt;, public GameTask
+    {
     public:
         /// Gibt das Singleton zurueck.
         static SoundManager&amp; getSingleton();
@@ -59,63 +59,61 @@
         /// Eine Resource erzeugen
         /// Konstruktor
         SoundManager();
-		virtual ~SoundManager();
+        virtual ~SoundManager();
 
-	    /// Den aktiven Listener zur&#252;ckgeben.
-		ListenerObject* getListener() const;
+        /// Den aktiven Listener zur&#252;ckgeben.
+        ListenerObject* getListener() const;
         /// Creates the listener actor.
-		Actor* createListenerActor();
+        Actor* createListenerActor();
         /// Returns the listener actor, if it exists. Else returns NULL.
-		Actor* getListenerActor();
-		void _clearListenerActor();		
+        Actor* getListenerActor();
+        void _clearListenerActor();
 
-		/// Hole den Treiber mit dem Namen
-		SoundDriver* getDriverByName(const Ogre::String &amp;name);
+        /// Hole den Treiber mit dem Namen
+        SoundDriver* getDriverByName(const Ogre::String &amp;name);
 
-		/// Hole die Soundkonfiguration
-		void loadConf(const Ogre::String &amp;filename);
-		/// Schreibe die Soundkonfiguration
-		void saveConf(const Ogre::String &amp;filename) const;
+        /**
+         * Sets the active sound driver and forwards all other settings
+         * to the driver's setSettings function.
+         *
+         * @param settings key-value list of settings
+         */
+        void applySettings(const Ogre::NameValuePairList&amp; settings);
 
-		/// 3D-Sound aktualisieren.
-		void update();
-		/// Liste der Soundtreiber.
-		const DriverList&amp; getSoundDriverList() const;
-		/// Den aktiven Treiber zur&#252;ckgeben.
-		SoundDriver* getActiveDriver() const;
-		/// Den aktiven Treiber setzen.
-		void setActiveDriver(SoundDriver *driver);
+        /// Schreibe die Soundkonfiguration
+        Ogre::NameValuePairList getSettings() const;
 
-		void registerDriver(SoundDriver* driver);
-		void unregisterDriver(SoundDriver* driver);
+        /// 3D-Sound aktualisieren.
+        void update();
+        /// Den aktiven Treiber zur&#252;ckgeben.
+        SoundDriver* getActiveDriver() const;
+        /// Den aktiven Treiber setzen.
+        void setActiveDriver(SoundDriver *driver);
+
+        void registerDriver(SoundDriver* driver);
+        void unregisterDriver(SoundDriver* driver);
+
         void unloadAllDrivers();
 
         virtual void run( Ogre::Real elapsedTime );
 
         virtual const Ogre::String&amp; getName() const;
 
-	protected:
-		virtual Ogre::Resource* createImpl(const Ogre::String&amp; name, Ogre::ResourceHandle handle, 
-			const Ogre::String&amp; group, bool isManual, Ogre::ManualResourceLoader* loader, 
-			const Ogre::NameValuePairList* createParams);
+    protected:
+        virtual Ogre::Resource* createImpl(const Ogre::String&amp; name, Ogre::ResourceHandle handle,
+            const Ogre::String&amp; group, bool isManual, Ogre::ManualResourceLoader* loader,
+            const Ogre::NameValuePairList* createParams);
 
-	private:
-		/// Ein MutEx, um das Hinzuf&#252;gen der Sounds zu synchronisieren.
-		boost::mutex mResListMutex;
-		/// Welche Dateiendung soll verwendet werden.
-		virtual StringList getExtension();
+    private:
+        /// Ein MutEx, um das Hinzuf&#252;gen der Sounds zu synchronisieren.
+        boost::mutex mResListMutex;
+        /// Welche Dateiendung soll verwendet werden.
+        virtual StringList getExtension();
 
-
-	    /// die Liste der bekannten und funktionierenden Treiber
-		DriverList mDriverList;  
-		/// Der aktuell bentutzte Soundtreiber
-		SoundDriver *mActiveDriver;
-		/// Der aktive Soundlistener
-		ListenerObject *mActiveListener;
-		Actor* mListenerActor;
-
-		Ogre::StringVector mDrivers;
-};
-
+        DriverList mDriverList;          //!&lt; List of currently loaded drivers
+        SoundDriver* mActiveDriver;      //!&lt; Currently used sound driver
+        ListenerObject* mActiveListener; //!&lt; Currently used sound listener
+        Actor* mListenerActor;
+    };
 }
 #endif

Modified: rl/trunk/engine/core/include/nulldriver/NullDriver.h
===================================================================
--- rl/trunk/engine/core/include/nulldriver/NullDriver.h	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/core/include/nulldriver/NullDriver.h	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -28,12 +28,12 @@
 class _RlCoreExport NullDriver : public rl::SoundDriver
 {
 public:
-	/// Der Treibername
+    /// Der Treibername
     static Ogre::String NAME;
     /// Der Konstruktor
-	NullDriver(Ogre::ResourceManager* soundResourceManager);
+    NullDriver(Ogre::ResourceManager* soundResourceManager);
     /// Der Destruktor
-	~NullDriver();
+    ~NullDriver();
     /// Ist der Treiber angeschaltet?
     bool isDriverAvailable();
     /// Initialisiere den Treiber.
@@ -50,15 +50,9 @@
     virtual Sound *createSample(const SoundResourcePtr &amp;res);
     /// Einen Soundlistener erzeugen
     virtual ListenerMovable *createListener(const Ogre::String &amp;name);
-
-    /// Die Einstellungen in Datei schreiben
-    virtual void saveConf(rl::ConfigFile &amp;conf) const;
-    /// Die Einstellungen laden
-    virtual void loadConf(rl::ConfigFile &amp;conf);
-
-	/// Setzt den Faktor f, mit der die Lautst&#239;&#191;&#189;rke nach der Formel 1/(f*Entfernung) abnimmt
-	virtual void setRolloffFactor(const Ogre::Real&amp;);
-	virtual const Ogre::Real getRolloffFactor();
+    /// Setzt den Faktor f, mit der die Lautst&#239;&#191;&#189;rke nach der Formel 1/(f*Entfernung) abnimmt
+    virtual void setRolloffFactor(const Ogre::Real&amp;);
+    virtual const Ogre::Real getRolloffFactor();
 };
 
 }

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -15,391 +15,500 @@
  */
 
 #include &quot;ConfigurationManager.h&quot;
-
-#include &lt;OgreRenderSystem.h&gt;
-#include &lt;OgreResourceGroupManager.h&gt;
-
 #include &quot;CoreSubsystem.h&quot;
 
-using namespace Ogre;
+template&lt;&gt; rl::ConfigurationManager* Ogre::Singleton&lt;rl::ConfigurationManager&gt;::ms_Singleton = 0;
 
-template&lt;&gt; rl::ConfigurationManager* Singleton&lt;rl::ConfigurationManager&gt;::ms_Singleton = 0;
-
 namespace rl
 {
-	ConfigurationManager* ConfigurationManager::getSingletonPtr()
-	{
-		if (ms_Singleton == NULL)
-		{
-			ms_Singleton = new ConfigurationManager();
-		}
+    ConfigurationManager* ConfigurationManager::getSingletonPtr()
+    {
+        if (ms_Singleton == NULL)
+        {
+            ms_Singleton = new ConfigurationManager();
+        }
 
-		return ms_Singleton;
-	}
+        return ms_Singleton;
+    }
 
-	ConfigurationManager&amp; ConfigurationManager::getSingleton()
-	{
-		if (ms_Singleton == NULL)
-		{
-			ms_Singleton = new ConfigurationManager();
-		}
+    ConfigurationManager&amp; ConfigurationManager::getSingleton()
+    {
+        if (ms_Singleton == NULL)
+        {
+            ms_Singleton = new ConfigurationManager();
+        }
 
-		return *ms_Singleton;
-	}
+        return *ms_Singleton;
+    }
 
-    ConfigurationManager::ConfigurationManager() :
-        mSystemConfig(NULL)
+    ConfigurationManager::ConfigurationManager()
     {
-    	mRastullahCfgFile = &quot;rastullah.conf&quot;;
-    	mOgreLogFile = &quot;ogre.log&quot;;
-    	mCeguiLogFile = &quot;cegui.log&quot;;
+        // Filenames for log and configuration files
+        mRastullahCfgFile = &quot;rastullah.conf&quot;;
+        mOgreLogFile = &quot;ogre.log&quot;;
+        mCeguiLogFile = &quot;cegui.log&quot;;
         mRastullahLogFile = &quot;rastullah.log&quot;;
-		mModulesCfgFile = &quot;modules.cfg&quot;;
+        mModulesCfgFile = &quot;modules.cfg&quot;;
 
-    	setRastullahCfgPath();
-    }
+        // Setup general default values
+        mGeneralSettings.insert(make_pair(&quot;Log Level&quot;, &quot;2&quot;));
+        mGeneralSettings.insert(make_pair(&quot;Subtitle Speed&quot;, &quot;0.0&quot;));
 
-	ConfigurationManager::~ConfigurationManager()
-	{
-        delete mSystemConfig;
-	}
+        // Setup sound default values
+        mSoundSettings.insert(make_pair(&quot;DefaultMusicVolume&quot;, &quot;0.4&quot;));
+        mSoundSettings.insert(make_pair(&quot;DefaultSoundVolume&quot;, &quot;0.9&quot;));
+        mSoundSettings.insert(make_pair(&quot;MasterVolume&quot;, &quot;1&quot;));
 
-	Ogre::String ConfigurationManager::getOgreLogFile() const
-	{
-		return mRastullahLogDirectory + &quot;/&quot; + mOgreLogFile;
-	}
+        // Setup graphic default values
+#       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+        mGraphicSettings.insert(make_pair(&quot;Render System&quot;, &quot;Direct3D9 Rendering Subsystem&quot;));
+#       else
+        mGraphicSettings.insert(make_pair(&quot;Render System&quot;,&quot;OpenGL Rendering Subsystem&quot;));
+        mGraphicSettings.insert(make_pair(&quot;RTT Preferred Mode&quot;, &quot;FBO&quot;));
+#       endif
+        mGraphicSettings.insert(make_pair(&quot;Fullscreen&quot;, &quot;no&quot;));
+        mGraphicSettings.insert(make_pair(&quot;FSAA&quot;, &quot;0&quot;));
+        mGraphicSettings.insert(make_pair(&quot;Video Mode&quot;, &quot;800 x 600&quot;));
+        mGraphicSettings.insert(make_pair(&quot;Use Static Geometry&quot;, &quot;auto&quot;));
+        mGraphicSettings.insert(make_pair(&quot;Max Anisotropy&quot;, &quot;1&quot;));
 
-	Ogre::String ConfigurationManager::getRastullahLogFile() const
-	{
-		return mRastullahLogDirectory + &quot;/&quot; + mRastullahLogFile;
-	}
+        // Setup input default values
+        mInputSettings.insert(make_pair(&quot;Mouse Sensitivity&quot;, &quot;4&quot;));
+        mInputSettings.insert(make_pair(&quot;Mouse Invert&quot;, &quot;no&quot;));
 
-	Ogre::String ConfigurationManager::getCeguiLogFile() const
-	{
-		return mRastullahLogDirectory + &quot;/&quot; + mCeguiLogFile;
-	}
+        setRastullahCfgPath();
+    }
 
-	Ogre::String ConfigurationManager::getModulesCfgFile() const
-	{
-		return mModulesCfgDirectory  + &quot;/&quot; + mModulesCfgFile;
-	}
+    ConfigurationManager::~ConfigurationManager()
+    {
+    }
 
-	Ogre::String ConfigurationManager::getModulesRootDirectory() const
-	{
-		return mModulesRootDirectory;
-	}
+    Ogre::String ConfigurationManager::getOgreLogFile() const
+    {
+        return mRastullahLogDirectory + &quot;/&quot; + mOgreLogFile;
+    }
 
-	Ogre::String ConfigurationManager::getRastullahLogDirectory() const
-	{
-		return mRastullahLogDirectory;
-	}
+    Ogre::String ConfigurationManager::getRastullahLogFile() const
+    {
+        return mRastullahLogDirectory + &quot;/&quot; + mRastullahLogFile;
+    }
 
-	/**
-	 * @todo Remove, after other subsystems were changed to
-	 *       new ConfigurationManager style
-	 */
-	Ogre::String ConfigurationManager::getRastullahCfgPath() const
-	{
-		return mRastullahOgreCfgPath;
-	}
+    Ogre::String ConfigurationManager::getCeguiLogFile() const
+    {
+        return mRastullahLogDirectory + &quot;/&quot; + mCeguiLogFile;
+    }
 
-	Ogre::String ConfigurationManager::getPluginCfgFile() const
-	{
-		return mPluginCfgFile;
-	}
+    Ogre::String ConfigurationManager::getModulesCfgFile() const
+    {
+        return mModulesRootDirectory  + &quot;/&quot; + mModulesCfgFile;
+    }
 
-	Ogre::String ConfigurationManager::getPluginCfgPath() const
-	{
-		return mPluginCfgPath;
-	}
+    Ogre::String ConfigurationManager::getModulesRootDirectory() const
+    {
+        return mModulesRootDirectory;
+    }
 
-	Ogre::String ConfigurationManager::getModulesCfgPath() const
-	{
-		return mModulesCfgPath;
-	}
+    Ogre::String ConfigurationManager::getRastullahLogDirectory() const
+    {
+        return mRastullahLogDirectory;
+    }
 
-    Ogre::String ConfigurationManager::getRastullahSystemCfgPath() const
+    Ogre::String ConfigurationManager::getOgrePluginDirectory() const
     {
-        return mRastullahSystemCfgPath;
+        return mOgrePluginDirectory;
     }
 
-    Ogre::String ConfigurationManager::getSoundCfgPath() const
+    Ogre::NameValuePairList ConfigurationManager::getGraphicSettings() const
     {
-        return mSoundCfgPath;
+        return mGraphicSettings;
     }
-    /// end remove
 
-    void ConfigurationManager::loadConfig()
+    Ogre::NameValuePairList ConfigurationManager::getSoundSettings() const
     {
-        if(mSystemConfig == NULL)
-        {
-        	// On Linux, we create the .rastullah directory
-#           if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-			fs::path rastullahCfgDirectory(string(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah&quot;, fs::portable_posix_name);
+        return mSoundSettings;
+    }
 
-			if (!fs::exists(rastullahCfgDirectory))
-			{
-				fs::create_directory(rastullahCfgDirectory);
-			}
+    Ogre::NameValuePairList ConfigurationManager::getInputSettings() const
+    {
+        return mInputSettings;
+    }
 
-			mRastullahOgreCfgPath = string(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/rastullah_ogre.cfg&quot;;
-#           else
-			mRastullahOgreCfgPath = &quot;./modules/config/rastullah_ogre.cfg&quot;;
-#           endif
+    void ConfigurationManager::loadConfig()
+    {
+        // On Linux, we create the .rastullah directory
+#       if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
+        fs::path rastullahCfgDirectory(string(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah&quot;, fs::portable_posix_name);
 
-            mSystemConfig = new Ogre::ConfigFile();
-            std::vector&lt;String&gt; cfg_paths;
+        if (!fs::exists(rastullahCfgDirectory))
+        {
+            fs::create_directory(rastullahCfgDirectory);
+        }
+#       endif
 
-			if (mRastullahCfgPath.find(&quot;:&quot;) == std::string::npos)
-			{
-				cfg_paths.push_back(mRastullahCfgPath);
-			}
-			else
-			{
-				// Split the path at the ':' character
-				cfg_paths = StringUtil::split(mRastullahCfgPath, &quot;:&quot;);
-			}
+        // First check, if we have found any directory
+        if (!mRastullahCfgPath.empty())
+        {
+            ConfigFile* configfile = new ConfigFile();
+            std::vector&lt;Ogre::String&gt; cfg_paths;
 
-			for (unsigned int i = 0; i &lt; cfg_paths.size(); i++)
-			{
-				try
-				{
-					std::cout &lt;&lt; &quot;Loading Configuration File &quot; &lt;&lt; cfg_paths[i] &lt;&lt; std::endl;
-					mSystemConfig-&gt;load(cfg_paths[i] + mRastullahCfgFile, &quot;=&quot;, true);
-				}
-				catch (Ogre::Exception)
-				{
-					LOG_ERROR2(Logger::CORE,
-						&quot;Konnte Rastullah-Konfiguration in '&quot; + cfg_paths[i] +
-						&quot;' nicht laden! Defaulteinstellungen werden benutzt.&quot;,&quot;Configuration&quot;);
-				}
+            if (mRastullahCfgPath.find(&quot;:&quot;) == std::string::npos)
+            {
+                cfg_paths.push_back(mRastullahCfgPath);
+            }
+            else
+            {
+                // Split the path at the ':' character
+                cfg_paths = Ogre::StringUtil::split(mRastullahCfgPath, &quot;:&quot;);
+            }
 
-				// Set log and modules directory and plugin cfg file name
-				mRastullahLogDirectory = mSystemConfig-&gt;getSetting(&quot;LogDirectory&quot;, &quot;Rastullah&quot;);
+            for (unsigned int i = 0; i &lt; cfg_paths.size(); i++)
+            {
+                try
+                {
+                    std::cout &lt;&lt; &quot;Loading Configuration File &quot; &lt;&lt; cfg_paths[i] &lt;&lt; mRastullahCfgFile &lt;&lt; std::endl;
+                    configfile-&gt;load(cfg_paths[i] + mRastullahCfgFile, &quot;=&quot;, true);
+                }
+                catch (Ogre::Exception)
+                {
+                    LOG_ERROR2(Logger::CORE,
+                         &quot;Konnte Rastullah-Konfiguration in '&quot; + cfg_paths[i] +
+                         &quot;' nicht laden! Defaulteinstellungen werden benutzt.&quot;,&quot;Configuration&quot;);
+                }
 
-				if (mRastullahLogDirectory.empty())
-				{
-#                   if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-					mRastullahLogDirectory = string(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/logs&quot;;
-#                   else
-					mRastullahLogDirectory = &quot;./logs&quot;;
-#                   endif
-				}
+                // Set log, modules and OGRE plugin directory
+                mRastullahLogDirectory = configfile-&gt;getSetting(&quot;LogDirectory&quot;, &quot;Paths&quot;);
+                mModulesRootDirectory = configfile-&gt;getSetting(&quot;ModulesDirectory&quot;, &quot;Paths&quot;);
+                mOgrePluginDirectory = configfile-&gt;getSetting(&quot;OgrePluginDirectory&quot;, &quot;Paths&quot;);
 
-				mModulesRootDirectory = mSystemConfig-&gt;getSetting(&quot;ModulesDirectory&quot;, &quot;Rastullah&quot;);
-				mPluginCfgFile = mSystemConfig-&gt;getSetting(&quot;PluginCfg&quot;, &quot;Rastullah&quot;);
-			}
-        }
+                // Get general settings
+                try
+                {
+                    for (ConfigFile::SettingsIterator it = configfile-&gt;getSettingsIterator(&quot;General&quot;); it.hasMoreElements(); it.moveNext())
+                    {
+                        addSetting(CS_GENERAL, it.peekNextKey(), it.peekNextValue());
+                    }
+                }
+                catch (Ogre::Exception&amp; oe)
+                {
+                    // Log it as information
+                    LOG_WARNING(Logger::CORE, &quot;Configuration File &quot; + cfg_paths[i] + mRastullahCfgFile + &quot; does not contain a section 'General'. Defaults will be used.&quot;);
+                }
 
-		/**
-		 * @todo Remove, after other subsystems were changed to
-		 *       new ConfigurationManager style
-		 */
-		mModulesCfgDirectory = mModulesRootDirectory + &quot;/modules/config&quot;;
-		mRastullahCfgPath = &quot;./rastullah_ogre.cfg&quot;;
-		mRastullahSystemCfgPath = mModulesCfgDirectory + &quot;/rastullah_system.cfg&quot;;
-		mSoundCfgPath = mModulesCfgDirectory + &quot;/sound.cfg&quot;;
-		mPluginCfgPath = mModulesCfgDirectory + &quot;/&quot; + mPluginCfgFile;
+                // Get video settings
+                try
+                {
+                    for (ConfigFile::SettingsIterator it = configfile-&gt;getSettingsIterator(&quot;Video&quot;); it.hasMoreElements(); it.moveNext())
+                    {
+                        addSetting(CS_GRAPHICS, it.peekNextKey(), it.peekNextValue());
+                    }
+                }
+                catch (Ogre::Exception&amp; oe)
+                {
+                    // Log it as information
+                    LOG_WARNING(Logger::CORE, &quot;Configuration File &quot; + cfg_paths[i] + mRastullahCfgFile + &quot; does not contain a section 'Video'. Defaults will be used.&quot;);
+                }
 
-		mModulesCfgPath = mModulesRootDirectory + &quot;/modules/modules.cfg&quot;;
-    }
+                // Get sound settings
+                try
+                {
+                    for (ConfigFile::SettingsIterator it = configfile-&gt;getSettingsIterator(&quot;Sound&quot;); it.hasMoreElements(); it.moveNext())
+                    {
+                        addSetting(CS_SOUND, it.peekNextKey(), it.peekNextValue());
+                    }
+                }
+                catch (Ogre::Exception&amp; oe)
+                {
+                    // Log it as information
+                    LOG_WARNING(Logger::CORE, &quot;Configuration File &quot; + cfg_paths[i] + mRastullahCfgFile + &quot; does not contain a section 'Video'. Defaults will be used.&quot;);
+                }
 
-    bool ConfigurationManager::shouldUseStaticGeometry() const
-    {
-        Ogre::String mode = mSystemConfig-&gt;getSetting( &quot;use_static_geometry&quot; );
+                // Get input settings
+                try
+                {
+                    for (ConfigFile::SettingsIterator it = configfile-&gt;getSettingsIterator(&quot;Input&quot;); it.hasMoreElements(); it.moveNext())
+                    {
+                        addSetting(CS_INPUT, it.peekNextKey(), it.peekNextValue());
+                    }
+                }
+                catch (Ogre::Exception&amp; oe)
+                {
+                    // Log it as information
+                    LOG_WARNING(Logger::CORE, &quot;Configuration File &quot; + cfg_paths[i] + mRastullahCfgFile + &quot; does not contain a section 'Input'. Defaults will be used.&quot;);
+                }
+            }
 
-        if( mode == Ogre::StringUtil::BLANK )
-            mode = &quot;auto&quot;;
+            delete configfile;
+        }
 
-        if( mode.compare(&quot;yes&quot;) == 0 )
+        if (mRastullahLogDirectory.empty())
         {
-            return true;
+#           if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
+            mRastullahLogDirectory = string(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/logs&quot;;
+#           else
+            mRastullahLogDirectory = &quot;./logs&quot;;
+#           endif
         }
-        else if( mode.compare(&quot;no&quot;) == 0 )
+
+        if (mModulesRootDirectory.empty())
         {
-            return false;
+#           if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
+                mModulesRootDirectory = RL_MODULEDIR;
+#           else
+                mModulesRootDirectory = &quot;./&quot;;
+#           endif
         }
-        else
+
+        if (mOgrePluginDirectory.empty())
         {
-            // &#220;berpr&#252;fen ob der Renderer VertexBuffer unterst&#252;tzt
-            return Ogre::Root::getSingleton().getRenderSystem()
-                -&gt;getCapabilities()-&gt;hasCapability( Ogre::RSC_VBO );
+#           if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
+            mOgrePluginDirectory = OGRE_PLUGINDIR;
+#           else
+            mOgrePluginDirectory = &quot;&quot;;
+#           endif
         }
+    }
 
+    void ConfigurationManager::saveConfig()
+    {
+        ConfigFile* cfgfile = new ConfigFile();
+
+        // Create the path list
+        Ogre::NameValuePairList* PathSettings = new Ogre::NameValuePairList();
+        PathSettings-&gt;insert(make_pair(&quot;ModulesDirectory&quot;, mModulesRootDirectory));
+        PathSettings-&gt;insert(make_pair(&quot;OgrePluginDirectory&quot;, mOgrePluginDirectory));
+        PathSettings-&gt;insert(make_pair(&quot;LogDirectory&quot;, mRastullahLogDirectory));
+
+        // Add General settings
+        cfgfile-&gt;addSection(&quot;General&quot;, mGeneralSettings);
+        // Add Path settings
+        cfgfile-&gt;addSection(&quot;Path&quot;, *PathSettings);
+        // Add Video settings
+        cfgfile-&gt;addSection(&quot;Video&quot;, mGraphicSettings);
+        // Add Sound settings
+        cfgfile-&gt;addSection(&quot;Sound&quot;, mSoundSettings);
+        // Add Input settings
+        cfgfile-&gt;addSection(&quot;Input&quot;, mInputSettings);
+
+#       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+        cfgfile-&gt;save(&quot;./config&quot;);
+#       else
+        cfgfile-&gt;save(Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/&quot; + mRastullahCfgFile);
+#       endif
+
+        // Clean up
+        delete PathSettings;
+        delete cfgfile;
     }
 
-	Ogre::String ConfigurationManager::getTextureUnitScheme() const
-	{
-		int numTu = Ogre::Root::getSingleton().getRenderSystem()
-			-&gt;getCapabilities()-&gt;getNumTextureUnits();
+    Logger::LogLevel ConfigurationManager::getLogLevel()
+    {
+        return static_cast&lt;Logger::LogLevel&gt;(getIntSetting(ConfigurationManager::CS_GENERAL, &quot;Log Level&quot;));
+    }
 
-		Ogre::String scheme;
+    Ogre::String ConfigurationManager::getEngineVersionString() const
+    {
+        static Ogre::String version = &quot;0.2.0&quot;;
+        return version;
+    }
 
-		if (numTu &gt;= 6)
-			scheme = &quot;tu6&quot;;
-		else if (numTu &gt;= 2)
-			scheme = &quot;tu2&quot;;
-		else
-			scheme = &quot;tu1&quot;;
+    Ogre::String ConfigurationManager::getEngineVersionName() const
+    {
+        static Ogre::String version = &quot;Internal Build&quot;;
+        return version;
+    }
 
-		LOG_MESSAGE(Logger::CORE,
-			&quot;Found &quot;+Ogre::StringConverter::toString(numTu) + &quot; Texture Units, using &quot;+
-			&quot;alphablending scheme &quot;+scheme);
-		return scheme;
-	}
+    Ogre::String ConfigurationManager::getStringSetting(ConfigurationSection section, Ogre::String key)
+    {
+        // Get the value we are looking for
+        return findSetting(section, key);
+    }
 
-	Logger::LogLevel ConfigurationManager::getLogLevel() const
-	{
-		int loglevel = Ogre::StringConverter::parseInt(mSystemConfig-&gt;getSetting(&quot;log_level&quot;));
-		return static_cast&lt;Logger::LogLevel&gt;(loglevel);
-	}
+    int ConfigurationManager::getIntSetting(ConfigurationSection section, Ogre::String key)
+    {
+        // Get the value we are looking for
+        return Ogre::StringConverter::parseInt(findSetting(section, key));
+    }
 
-	Ogre::String ConfigurationManager::getEngineVersionString() const
-	{
-		static Ogre::String version = &quot;0.2.0&quot;;
-		return version;
-	}
+    bool ConfigurationManager::getBoolSetting(ConfigurationSection section, Ogre::String key)
+    {
+        // Get the value we are looking for
+        return Ogre::StringConverter::parseBool(findSetting(section, key));
+    }
 
-	Ogre::String ConfigurationManager::getEngineVersionName() const
-	{
-		static Ogre::String version = &quot;Internal Build&quot;;
-		return version;
-	}
+    Ogre::Real ConfigurationManager::getRealSetting(ConfigurationSection section, Ogre::String key)
+    {
+        // Get the value we are looking for
+        return Ogre::StringConverter::parseReal(findSetting(section, key));
+    }
 
-	static const Ogre::String sMonths[] =
-			{&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;,
-             &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;};
+    Ogre::String ConfigurationManager::findSetting(ConfigurationSection section, Ogre::String key) const
+    {
+        Ogre::NameValuePairList::const_iterator it;
+        const Ogre::NameValuePairList* searchList;
 
-	/// __DATE__ sieht ca. so aus : Nov 08 2005
-	long parseDate(char* date)
-	{
-		Ogre::String dateStr = Ogre::String(date);
-		Ogre::String monthStr = dateStr.substr(0,3);
-		int day = Ogre::StringConverter::parseInt( dateStr.substr(4,2) );
-		int year = Ogre::StringConverter::parseInt( dateStr.substr(7,4) );
-		int month = 0;
+        // Search for the key in the specified section
+        switch (section)
+        {
+            case CS_GENERAL:
+                searchList = &mGeneralSettings;
+            break;
+            case CS_GRAPHICS:
+                searchList = &mGraphicSettings;
+            break;
+            case CS_SOUND:
+                searchList = &mSoundSettings;
+            break;
+            case CS_INPUT:
+                searchList = &mInputSettings;
+            break;
+            default:
 
-		while( month &lt; 12 &amp;&amp; monthStr.compare(sMonths[month]) != 0 )
-			month++;
+            break;
+        }
 
-		return /* Jahr */		  year * 100000 +
-			   /* Monat */	 (month+1) * 1000 +
-			   /* Tag */		   day * 10 +
-			   /* Sub-Version */	 0;
-	}
+        it = searchList-&gt;find(key);
 
-	long ConfigurationManager::getEngineBuildNumber() const
-	{
-		static long buildNumber = parseDate(__DATE__);
-		return buildNumber;
-	}
+        if (it == searchList-&gt;end())
+        {
+            return Ogre::String(&quot;&quot;);
+        }
+        else
+        {
+            return it-&gt;second;
+        }
+    }
 
+    void ConfigurationManager::addSetting(ConfigurationSection section, Ogre::String key, Ogre::String value)
+    {
+        Ogre::NameValuePairList::iterator it;
+        Ogre::NameValuePairList* addList;
 
-	const CeGuiString&amp; ConfigurationManager::getAboutText() const
-	{
-		static CeGuiString aboutText =
-			&quot;Rastullahs Lockenpracht\n\nCopyright 2003-2006 Team Pantheon\n\nBenutzte Bibliotheken: Ogre, fmod, Newton, boost, ...&quot;;
-		return aboutText;
-	}
+        // Get the section, where the key is inserted
+        switch (section)
+        {
+            case CS_GENERAL:
+                addList = &mGeneralSettings;
+            break;
+            case CS_GRAPHICS:
+                addList = &mGraphicSettings;
+            break;
+            case CS_SOUND:
+                addList = &mSoundSettings;
+            break;
+            case CS_INPUT:
+                addList = &mInputSettings;
+            break;
+            default:
 
-	String ConfigurationManager::getStringSetting(const String&amp; name, const String&amp; defaultv) const
-	{
-		String rval = mSystemConfig-&gt;getSetting(name);
-		if (rval == StringUtil::BLANK) rval = defaultv;
-		return rval;
-	}
+            break;
+        }
 
-	Real ConfigurationManager::getRealSetting(const String&amp; name, Real defaultv) const
-	{
-		String val = getStringSetting(name);
-		if (val == StringUtil::BLANK) return defaultv;
-		else return StringConverter::parseReal(val);
-	}
+        // Find out, if key exist
+        it = addList-&gt;find(key);
 
-	int ConfigurationManager::getIntSetting(const String&amp; name, int defaultv) const
-	{
-		String val = getStringSetting(name);
-		if (val == StringUtil::BLANK) return defaultv;
-		else return StringConverter::parseInt(val);
-	}
+        if (it == addList-&gt;end())
+        {
+            // Key does not exist, insert
+            addList-&gt;insert(make_pair(key, value));
+        }
+        else
+        {
+            // Key does exist, update
+            it-&gt;second = value;
+        }
+    }
 
-	bool ConfigurationManager::getBoolSetting(const String&amp; name, bool defaultv) const
-	{
-		String val = getStringSetting(name);
-		if (val == StringUtil::BLANK) return defaultv;
-		else return StringConverter::parseBool(val);
-	}
+    static const Ogre::String sMonths[] =
+            {&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;,
+             &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;};
 
-	String ConfigurationManager::getInputConfigPath() const
-	{
-		return mModulesCfgDirectory + &quot;/rastullah_input.cfg&quot;;
-	}
+    /// __DATE__ sieht ca. so aus : Nov 08 2005
+    long parseDate(char* date)
+    {
+        Ogre::String dateStr = Ogre::String(date);
+        Ogre::String monthStr = dateStr.substr(0,3);
+        int day = Ogre::StringConverter::parseInt( dateStr.substr(4,2) );
+        int year = Ogre::StringConverter::parseInt( dateStr.substr(7,4) );
+        int month = 0;
 
-	String ConfigurationManager::getKeymap() const
-	{
-		return mModulesCfgDirectory + &quot;/keymap-german.xml&quot;;
-	}
+        while( month &lt; 12 &amp;&amp; monthStr.compare(sMonths[month]) != 0 )
+            month++;
 
-    String ConfigurationManager::getConfigModulePath() const
-    {
-        return mConfigModuleDirectory;
+        return /* Jahr */          year * 100000 +
+               /* Monat */     (month+1) * 1000 +
+               /* Tag */           day * 10 +
+               /* Sub-Version */     0;
     }
 
-    void ConfigurationManager::setRastullahCfgPath()
+    long ConfigurationManager::getEngineBuildNumber() const
     {
-    	string path = &quot;./&quot;;
+        static long buildNumber = parseDate(__DATE__);
+        return buildNumber;
+    }
 
-    	// First try: Current directory
-    	if (checkForFile(path + mRastullahCfgFile))
-    	{
-			addToCfgPath(path);
-    	}
 
-#		if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-		// Check system wide /etc/rastullah directory
-		path = &quot;/etc/rastullah/&quot;;
+    const CeGuiString&amp; ConfigurationManager::getAboutText() const
+    {
+        static CeGuiString aboutText =
+            &quot;Rastullahs Lockenpracht\n\nCopyright 2003-2006 Team Pantheon\n\nBenutzte Bibliotheken: Ogre, fmod, Newton, boost, ...&quot;;
+        return aboutText;
+    }
 
-    	if (checkForFile(path + mRastullahCfgFile))
-    	{
-			addToCfgPath(path);
-    	}
+    Ogre::String ConfigurationManager::getKeymap() const
+    {
+        return Ogre::String(&quot;config/keymap-german.xml&quot;);
+    }
 
-		// Check home .rastullah directory
-    	path = string(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/&quot;;
+    void ConfigurationManager::setRastullahCfgPath()
+    {
+        // First try: Current directory
+        addToCfgPath(&quot;./&quot;);
 
-    	if (checkForFile(path + mRastullahCfgFile))
-    	{
-			addToCfgPath(path);
-    	}
-#		else
-        addToCfgPath(&quot;./modules/config/&quot;);
+#       if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
+        // Check system wide /etc/rastullah directory
+        addToCfgPath(&quot;/etc/rastullah/&quot;);
+        // Check home .rastullah directory
+        addToCfgPath(Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/&quot;);
+#       else
+        addToCfgPath(&quot;./config/&quot;);
 #       endif
     }
 
-	void ConfigurationManager::addToCfgPath(const std::string&amp; path)
-	{
-		if (mRastullahCfgPath.size() &gt; 0)
-		{
-			mRastullahCfgPath += &quot;:&quot; + path;
-		}
-		else
-		{
-			mRastullahCfgPath = path;
-		}
-	}
+    void ConfigurationManager::addToCfgPath(const std::string&amp; path)
+    {
+        std::cout &lt;&lt; &quot;Checking for &quot; &lt;&lt; mRastullahCfgFile &lt;&lt; &quot; in &quot; &lt;&lt; path &lt;&lt; std::endl;
 
-	bool ConfigurationManager::checkForFile(const std::string&amp; filename)
-	{
-		try {
-			if (fs::exists(filename))
-			{
-				return true;
-			}
-		}
-		catch (fs::filesystem_error&amp; fe) {
-			return false;
-		}
+        if (checkForFile(path + mRastullahCfgFile))
+        {
+            if (mRastullahCfgPath.size() &gt; 0)
+            {
+                mRastullahCfgPath += &quot;:&quot; + path;
+            }
+            else
+            {
+                mRastullahCfgPath = path;
+            }
 
-		return false;
-	}
+            std::cout &lt;&lt; &quot;Adding path &quot; &lt;&lt; path &lt;&lt; &quot; to Rastullah configuration path.&quot; &lt;&lt; std::endl;
+        }
+    }
+
+    bool ConfigurationManager::checkForFile(const std::string&amp; filename)
+    {
+        try {
+#           if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+            if (fs::exists(filename))
+#           else
+            if (fs::exists(fs::path(filename, fs::portable_posix_name)))
+#           endif
+            {
+                return true;
+            }
+        }
+        catch (fs::filesystem_error&amp; fe) {
+            return false;
+        }
+
+        return false;
+    }
 }

Modified: rl/trunk/engine/core/src/ContentModule.cpp
===================================================================
--- rl/trunk/engine/core/src/ContentModule.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/core/src/ContentModule.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -28,81 +28,81 @@
 
 namespace rl
 {
-	ContentModule::ContentModule(const String&amp; id, const CeGuiString&amp; name, bool common, long minimumEngineVersion)
-	:	mId(id),
-		mName(name),
-		mCommon(common),
-		mMinimumEngineVersion(minimumEngineVersion),
+    ContentModule::ContentModule(const String&amp; id, const CeGuiString&amp; name, bool common, long minimumEngineVersion)
+    :    mId(id),
+        mName(name),
+        mCommon(common),
+        mMinimumEngineVersion(minimumEngineVersion),
         mLoaded(false)
-	{
-	}
+    {
+    }
 
-	ContentModule::~ContentModule()
-	{
-	}
+    ContentModule::~ContentModule()
+    {
+    }
 
-	const String ContentModule::getInitFile(const String&amp; moduleId)
-	{
-		return getDirectory(moduleId) + &quot;/scripts/moduleconfig.rb&quot;;
-	}
+    const String ContentModule::getInitFile(const String&amp; moduleId)
+    {
+        return getDirectory(moduleId) + &quot;/scripts/moduleconfig.rb&quot;;
+    }
 
-	const String ContentModule::getDirectory(const String&amp; moduleId)
-	{
-		return ConfigurationManager::getSingleton().
-        		getModulesRootDirectory() + &quot;/modules/&quot; + moduleId;
-	}
+    const String ContentModule::getDirectory(const String&amp; moduleId)
+    {
+        return ConfigurationManager::getSingleton().
+                getModulesRootDirectory() + &quot;/&quot; + moduleId;
+    }
 
-	const String ContentModule::getDirectory() const
-	{
-		return ContentModule::getDirectory(mId);
-	}
+    const String ContentModule::getDirectory() const
+    {
+        return ContentModule::getDirectory(mId);
+    }
 
-	const CeGuiString&amp; ContentModule::getName() const
-	{
-		return mName;
-	}
+    const CeGuiString&amp; ContentModule::getName() const
+    {
+        return mName;
+    }
 
-	const String&amp; ContentModule::getId() const
-	{
-		return mId;
-	}
+    const String&amp; ContentModule::getId() const
+    {
+        return mId;
+    }
 
-	long ContentModule::getMinimumEngineVersion() const
-	{
-		return mMinimumEngineVersion;
-	}
+    long ContentModule::getMinimumEngineVersion() const
+    {
+        return mMinimumEngineVersion;
+    }
 
-	bool ContentModule::isCommon() const
-	{
-		return mCommon;
-	}
+    bool ContentModule::isCommon() const
+    {
+        return mCommon;
+    }
 
     void ContentModule::initializeTextures() const
     {
-		String resourceGroup = getId();
+        String resourceGroup = getId();
 
-		StringVector texLocations = getTextureLocations();
-		for(StringVector::iterator iter = texLocations.begin();
-			iter != texLocations.end();
-			iter++)
-		{
-			String location = *iter;
-			if (location.find(&quot;.zip&quot;) != String::npos)
-			{
+        StringVector texLocations = getTextureLocations();
+        for(StringVector::iterator iter = texLocations.begin();
+            iter != texLocations.end();
+            iter++)
+        {
+            String location = *iter;
+            if (location.find(&quot;.zip&quot;) != String::npos)
+            {
                 ResourceGroupManager::getSingleton().addResourceLocation(
-                	getDirectory() + &quot;/materials/&quot; + location, &quot;Zip&quot;, resourceGroup);
-			}
-			else
-			{
+                    getDirectory() + &quot;/materials/&quot; + location, &quot;Zip&quot;, resourceGroup);
+            }
+            else
+            {
                 ResourceGroupManager::getSingleton().addResourceLocation(
-                	getDirectory() + &quot;/materials/&quot; + location, &quot;FileSystem&quot;, resourceGroup);
-			}
-		}
+                    getDirectory() + &quot;/materials/&quot; + location, &quot;FileSystem&quot;, resourceGroup);
+            }
+        }
 
-		addSearchPath(getDirectory()+&quot;/materials&quot;, resourceGroup);
+        addSearchPath(getDirectory()+&quot;/materials&quot;, resourceGroup);
     }
 
-	void ContentModule::initialize()
+    void ContentModule::initialize()
     {
         String moduleDir = getDirectory();
 
@@ -112,28 +112,28 @@
         addSearchPath(moduleDir + &quot;/dsa&quot;, resourceGroup);
         addSearchPath(moduleDir + &quot;/maps&quot;, resourceGroup);
         addSearchPath(moduleDir + &quot;/models&quot;, resourceGroup);
-   		StringVector modelLoc = getModelLocations();
-		for (StringVector::iterator it = modelLoc.begin(); it != modelLoc.end(); ++it)
-		{
-			addSearchPath(moduleDir + &quot;/models/&quot;+*it, resourceGroup);
-		}
+           StringVector modelLoc = getModelLocations();
+        for (StringVector::iterator it = modelLoc.begin(); it != modelLoc.end(); ++it)
+        {
+            addSearchPath(moduleDir + &quot;/models/&quot;+*it, resourceGroup);
+        }
 
-		addSearchPath(moduleDir + &quot;/sound&quot;, resourceGroup); //@todo ueber Verzeichnisnamen nachdenken
-		StringVector soundLoc = getSoundLocations();
-		for (StringVector::iterator it = soundLoc.begin(); it != soundLoc.end(); ++it)
-		{
-			addSearchPath(moduleDir + &quot;/sound/&quot;+*it, resourceGroup);
-		}
+        addSearchPath(moduleDir + &quot;/sound&quot;, resourceGroup); //@todo ueber Verzeichnisnamen nachdenken
+        StringVector soundLoc = getSoundLocations();
+        for (StringVector::iterator it = soundLoc.begin(); it != soundLoc.end(); ++it)
+        {
+            addSearchPath(moduleDir + &quot;/sound/&quot;+*it, resourceGroup);
+        }
 
-		addSearchPath(moduleDir + &quot;/gui&quot;, resourceGroup);
+        addSearchPath(moduleDir + &quot;/gui&quot;, resourceGroup);
         addSearchPath(moduleDir + &quot;/gui/fonts&quot;, resourceGroup);
         addSearchPath(moduleDir + &quot;/gui/imagesets&quot;, resourceGroup);
         addSearchPath(moduleDir + &quot;/gui/schemes&quot;, resourceGroup);
         addSearchPath(moduleDir + &quot;/gui/windows&quot;, resourceGroup);
         addSearchPath(moduleDir + &quot;/gui/windows/buttons&quot;, resourceGroup);
-        addSearchPath(moduleDir + &quot;/dialogs&quot;, resourceGroup);     
+        addSearchPath(moduleDir + &quot;/dialogs&quot;, resourceGroup);
 
-		RubyInterpreter* interpreter = CoreSubsystem::getSingleton().getRubyInterpreter();
+        RubyInterpreter* interpreter = CoreSubsystem::getSingleton().getRubyInterpreter();
         if (interpreter != NULL)
         {
             interpreter-&gt;addSearchPath(moduleDir + &quot;/scripts&quot;);
@@ -143,20 +143,20 @@
         mLoaded = true;
     }
 
-	void ContentModule::addSearchPath(const Ogre::String&amp; path, const Ogre::String&amp; resourceGroup) const
+    void ContentModule::addSearchPath(const Ogre::String&amp; path, const Ogre::String&amp; resourceGroup) const
     {
-        try 
+        try
         {
-            ResourceGroupManager::getSingleton().addResourceLocation(path, 
+            ResourceGroupManager::getSingleton().addResourceLocation(path,
                 &quot;FileSystem&quot;, resourceGroup);
-        } 
-        catch(...) 
+        }
+        catch(...)
         {
-			// and forget
-		}
+            // and forget
+        }
     }
 
-	void ContentModule::precreateMeshes() const
+    void ContentModule::precreateMeshes() const
     {
         StringVectorPtr meshes = ResourceGroupManager::getSingleton()
             .findResourceNames(getId(), &quot;*.mesh&quot;);
@@ -172,7 +172,7 @@
         }
     }
 
-	void ContentModule::unload()
+    void ContentModule::unload()
     {
         //TODO: unloadModule
         mLoaded = false;

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -58,7 +58,7 @@
         mDefaultActiveModule(&quot;&quot;),
         mClockStartTime(),
         mDeveloperMode(false),
-		mInitialized(false),
+        mInitialized(false),
         mCoreEventCaster(),
         mDefaultTechniques(),
         mOgreRoot(NULL),
@@ -70,16 +70,17 @@
         mActorManager(NULL),
         mGameEventManager(NULL),
         mConfigurationManager(NULL),
-		mSoundManager(NULL),
+        mSoundManager(NULL),
         mDebugVisualsManager(NULL),
-        mJobScheduler(NULL)
+        mJobScheduler(NULL),
+        mRenderWindow(NULL)
     {
         initializeCoreSubsystem();
     }
 
     CoreSubsystem::~CoreSubsystem()
     {
-		mCoreEventCaster.removeEventListeners();
+        mCoreEventCaster.removeEventListeners();
 
         delete mWorld;
         delete mGameLoop;
@@ -92,34 +93,34 @@
         delete mXmlResourceManager;
         delete mScriptWrapper;
         delete mConfigurationManager;
-		delete mSoundManager;
+        delete mSoundManager;
         delete mOgreRoot;
         delete mRubyInterpreter;
-	}
+    }
 
     void CoreSubsystem::startCore()
     {
         loadPlugins();
 
-		mInitialized = true;
+        mInitialized = true;
 
-		if (mDefaultActiveModule == &quot;&quot;)
-		{
-			mDefaultActiveModule = &quot;intro&quot;; ///@fixme replace by last active
-		}
+        if (mDefaultActiveModule == &quot;&quot;)
+        {
+            mDefaultActiveModule = &quot;intro&quot;; ///@fixme replace by last active
+        }
 
 
-		ContentModule* mod = getModule(mDefaultActiveModule);
-		if (mod == NULL)
-		{
-			Throw(rl::RuntimeException, &quot;Module &quot;+mDefaultActiveModule+&quot; not found&quot;);
-		}
-		else
-		{
-			startAdventureModule(mod);
-		}
+        ContentModule* mod = getModule(mDefaultActiveModule);
+        if (mod == NULL)
+        {
+            Throw(rl::RuntimeException, &quot;Module &quot;+mDefaultActiveModule+&quot; not found&quot;);
+        }
+        else
+        {
+            startAdventureModule(mod);
+        }
 
-		mGameLoop-&gt;loop();
+        mGameLoop-&gt;loop();
 
         mWorld-&gt;clearScene();
         unloadPlugins();
@@ -127,95 +128,113 @@
         //mRubyInterpreter-&gt;finalizeInterpreter();
     }
 
-    bool CoreSubsystem::setupConfiguration()
+    void CoreSubsystem::setDeveloperMode(bool developerMode)
     {
-        if(Root::getSingleton().restoreConfig()
-            || Root::getSingleton().showConfigDialog())
-        {
-            std::stringstream name;
-            name &lt;&lt; &quot;Rastullahs Lockenpracht - &quot;;
-            name &lt;&lt; ConfigurationManager::getSingleton().getEngineVersionString() &lt;&lt; &quot; &quot;;
-            name &lt;&lt; ConfigurationManager::getSingleton().getEngineVersionName() &lt;&lt; &quot; [&quot;;
-            name &lt;&lt; ConfigurationManager::getSingleton().getEngineBuildNumber() &lt;&lt; &quot;]&quot;;
+        mDeveloperMode = developerMode;
+    }
 
-            Root::getSingleton().initialise(true, name.str() );
-            return true;
-        }
-        else
-        {
-            return false;
-        }
+    bool CoreSubsystem::getDeveloperMode() const
+    {
+        return mDeveloperMode;
     }
 
-	void CoreSubsystem::setDeveloperMode(bool developerMode)
-	{
-		mDeveloperMode = developerMode;
-	}
+    bool CoreSubsystem::isInitialized() const
+    {
+        return mInitialized;
+    }
 
-	bool CoreSubsystem::getDeveloperMode() const
-	{
-		return mDeveloperMode;
-	}
+    Ogre::RenderWindow* CoreSubsystem::getRenderWindow()
+    {
+        return mRenderWindow;
+    }
 
-	bool CoreSubsystem::isInitialized() const
-	{
-		return mInitialized;
-	}
-
     bool CoreSubsystem::initializeCoreSubsystem()
     {
         mConfigurationManager = ConfigurationManager::getSingletonPtr();
-        mOgreRoot = new Root(
-        	mConfigurationManager-&gt;getPluginCfgPath(),
-        	mConfigurationManager-&gt;getRastullahCfgPath(),
-        	mConfigurationManager-&gt;getOgreLogFile()
-        );
+        // By not specifying the first two parameters, OGRE will not try
+        // to load plugins.cfg and ogre.cfg
+        mOgreRoot = new Root(&quot;&quot;, &quot;&quot;, ConfigurationManager::getSingleton().getOgreLogFile());
 
+        // Load Ogre plugins
+        String PluginDir = ConfigurationManager::getSingleton().getOgrePluginDirectory();
+#       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+        mOgreRoot-&gt;loadPlugin(PluginDir + &quot;/RenderSystem_Direct3D9&quot;);
+#       endif
+        mOgreRoot-&gt;loadPlugin(PluginDir + &quot;/RenderSystem_GL&quot;);
+        mOgreRoot-&gt;loadPlugin(PluginDir + &quot;/Plugin_ParticleFX&quot;);
+        mOgreRoot-&gt;loadPlugin(PluginDir + &quot;/Plugin_OctreeSceneManager&quot;);
+
+        // Find out, what Renderer plugins are available
+        RenderSystemList* rsl = mOgreRoot-&gt;getAvailableRenderers();
+        RenderSystemList::iterator it;
+
+        for (it = rsl-&gt;begin(); it &lt; rsl-&gt;end(); it++)
+        {
+            if ((*it)-&gt;getName() == ConfigurationManager::getSingleton().getStringSetting(ConfigurationManager::CS_GRAPHICS, &quot;Render System&quot;))
+            {
+                // Select and initialise the render system
+                mOgreRoot-&gt;setRenderSystem(*it);
+                mOgreRoot-&gt;initialise(false, &quot;&quot;);
+            }
+        }
+
         //Root::getSingleton().setFrameSmoothingPeriod(0.5f);
 
         // Muss vor dem Laden der Ressourcen geschehen,
         // weil es sonst sofort angewandt wird.
         MeshManager::getSingleton().setBoundsPaddingFactor(0.0);
 
-		// EDIT:
-		LOG_MESSAGE(Logger::CORE,&quot;init&quot;);
+        // EDIT:
+        LOG_MESSAGE(Logger::CORE,&quot;init&quot;);
 
-        bool carryOn = setupConfiguration();
+        std::stringstream name;
+        name &lt;&lt; &quot;Rastullahs Lockenpracht - &quot;;
+        name &lt;&lt; ConfigurationManager::getSingleton().getEngineVersionString() &lt;&lt; &quot; &quot;;
+        name &lt;&lt; ConfigurationManager::getSingleton().getEngineVersionName() &lt;&lt; &quot; [&quot;;
+        name &lt;&lt; ConfigurationManager::getSingleton().getEngineBuildNumber() &lt;&lt; &quot;]&quot;;
 
-        if (!carryOn)
+        // Get width and height of the RenderWindow from the &quot;Video Mode&quot; setting
+        Ogre::String VideoMode = ConfigurationManager::getSingleton().getStringSetting(ConfigurationManager::CS_GRAPHICS, &quot;Video Mode&quot;);
+        int temp = VideoMode.find(&quot;x&quot;);
+        int width = Ogre::StringConverter::parseInt(VideoMode.substr(0, temp));
+        int height = Ogre::StringConverter::parseInt(VideoMode.substr(temp + 1, VideoMode.size()));
+
+        mRenderWindow = mOgreRoot-&gt;createRenderWindow(name.str(), width, height, ConfigurationManager::getSingleton().getBoolSetting(ConfigurationManager::CS_GRAPHICS, &quot;Fullscreen&quot;), &amp;ConfigurationManager::getSingleton().getGraphicSettings());
+
+        if (!mRenderWindow)
             return false;
 
-		mGameLoop = new GameLoop();
+        mGameLoop = new GameLoop();
         LOG_MESSAGE(Logger::CORE,&quot;GameLoopmanager erzeugt&quot;);
 
-		mScriptWrapper = new ScriptWrapper();
-		LOG_MESSAGE(Logger::CORE,&quot;Skriptwrapper erzeugt&quot;);
+        mScriptWrapper = new ScriptWrapper();
+        LOG_MESSAGE(Logger::CORE,&quot;Skriptwrapper erzeugt&quot;);
         // TODO: muss l&#246;schbar werden.
-		mRubyInterpreter = new RubyInterpreter();
-		LOG_MESSAGE(Logger::CORE,&quot;RubyInterpreter erzeugt&quot;);
-		mRubyInterpreter-&gt;initializeInterpreter();
-		LOG_MESSAGE(Logger::CORE,&quot;RubyInterpreter initialisiert&quot;);
+        mRubyInterpreter = new RubyInterpreter();
+        LOG_MESSAGE(Logger::CORE,&quot;RubyInterpreter erzeugt&quot;);
+        mRubyInterpreter-&gt;initializeInterpreter();
+        LOG_MESSAGE(Logger::CORE,&quot;RubyInterpreter initialisiert&quot;);
 
         mActorManager = new ActorManager();
-		LOG_MESSAGE(Logger::CORE,&quot;Aktormanager erzeugt&quot;);
+        LOG_MESSAGE(Logger::CORE,&quot;Aktormanager erzeugt&quot;);
 
-		mSoundManager = new SoundManager();
-		LOG_MESSAGE(Logger::CORE,&quot;SoundManager erzeugt&quot;);
+        mSoundManager = new SoundManager();
+        LOG_MESSAGE(Logger::CORE,&quot;SoundManager erzeugt&quot;);
 
-		initializeResources();
+        initializeResources();
 
         // Set default mipmap level (NB some APIs ignore this)
         //TODO: In Config-Datei verlagern
         TextureManager::getSingleton().setDefaultNumMipmaps(5);
         MaterialManager::getSingleton().setDefaultTextureFiltering(TFO_TRILINEAR);
         MaterialManager::getSingleton().setDefaultAnisotropy(
-            ConfigurationManager::getSingleton().getIntSetting(&quot;max_anisotropy&quot;,1));
+            ConfigurationManager::getSingleton().getIntSetting(ConfigurationManager::CS_GRAPHICS, &quot;Max Anisotropy&quot;));
 
 
         mWorld = new DotSceneOctreeWorld();
-		mActorManager-&gt;setWorld(mWorld);
+        mActorManager-&gt;setWorld(mWorld);
 
-		mPhysicsManager = new PhysicsManager();
+        mPhysicsManager = new PhysicsManager();
         GameLoop::getSingleton().addTask(mPhysicsManager, GameLoop::TG_PHYSICS);
 
         mAnimationManager = new AnimationManager();
@@ -230,32 +249,24 @@
         mJobScheduler = new JobScheduler();
         GameLoop::getSingleton().addTask(mJobScheduler, GameLoop::TG_GRAPHICS);
 
-		return true;
+        return true;
     }
 
     void CoreSubsystem::initializeResources()
     {
         mXmlResourceManager = new XmlResourceManager();
 
-		// Fuer Configs die keinem Typ zugeordnet sind,
+        // Fuer Configs die keinem Typ zugeordnet sind,
         // und die per kompletten Verezeichnis erfragt werden
-		ResourceGroupManager::getSingleton().addResourceLocation(
-			ConfigurationManager::getSingleton().
-				getModulesRootDirectory(),
-            &quot;FileSystem&quot;,
-			ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
-
         ResourceGroupManager::getSingleton().addResourceLocation(
-			ConfigurationManager::getSingleton().
-                getConfigModulePath(),
+            ConfigurationManager::getSingleton().
+                getModulesRootDirectory(),
             &quot;FileSystem&quot;,
-			ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
+            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
 
-        mConfigurationManager-&gt;loadConfig();
-
         // Laden mittels eines Configfiles
         ConfigFile cf;
-        cf.load(mConfigurationManager-&gt;getModulesCfgPath());
+        cf.load(mConfigurationManager-&gt;getModulesCfgFile());
 
         // Durchgehen der einzelnen Settings
         ConfigFile::SettingsIterator i = cf.getSettingsIterator();
@@ -265,101 +276,114 @@
             key = i.peekNextKey();
             value = i.getNext();
 
-			if (key.compare(&quot;module&quot;) == 0)
+            if (key.compare(&quot;module&quot;) == 0)
             {
-				mRubyInterpreter-&gt;executeFile(ContentModule::getInitFile(value));
+                mRubyInterpreter-&gt;executeFile(ContentModule::getInitFile(value));
 
-				ContentModule* module = getModule(value);
+                ContentModule* module = getModule(value);
 
-				if (module == NULL)
-				{
-					Throw(
-						rl::RuntimeException,
-						ContentModule::getInitFile(value) + &quot; did not register module '&quot;+value+&quot;'&quot;);
-				}
-				//else
-				//{
-				//	if (module-&gt;isCommon())
-				//	{
-				//		module-&gt;initializeTextures();
-				//		module-&gt;initialize();
-				//	}
-				//}
+                if (module == NULL)
+                {
+                    Throw(
+                        rl::RuntimeException,
+                        ContentModule::getInitFile(value) + &quot; did not register module '&quot;+value+&quot;'&quot;);
+                }
+                //else
+                //{
+                //    if (module-&gt;isCommon())
+                //    {
+                //        module-&gt;initializeTextures();
+                //        module-&gt;initialize();
+                //    }
+                //}
             }
         }
     }
 
-	ContentModule* CoreSubsystem::getModule(const String&amp; moduleId) const
-	{
-		ModuleMap::const_iterator moduleIt = mModules.find(moduleId);
+    ContentModule* CoreSubsystem::getModule(const String&amp; moduleId) const
+    {
+        ModuleMap::const_iterator moduleIt = mModules.find(moduleId);
 
-		if (moduleIt != mModules.end())
-		{
-			return (*moduleIt).second;
-		}
-		else
-		{
-			return NULL;
-		}
-	}
+        if (moduleIt != mModules.end())
+        {
+            return (*moduleIt).second;
+        }
+        else
+        {
+            return NULL;
+        }
+    }
 
-	void CoreSubsystem::registerModule(ContentModule* module)
-	{
-		mModules[module-&gt;getId()] = module;
-	}
+    void CoreSubsystem::registerModule(ContentModule* module)
+    {
+        mModules[module-&gt;getId()] = module;
+    }
 
-	void CoreSubsystem::updateDefaultScheme()
-	{
-		String tuScheme = mConfigurationManager-&gt;getTextureUnitScheme();
+    void CoreSubsystem::updateDefaultScheme()
+    {
+        int numTu = mOgreRoot-&gt;getRenderSystem()-&gt;getCapabilities()-&gt;getNumTextureUnits();
 
-		for (ResourceManager::ResourceMapIterator itMat =
-			MaterialManager::getSingleton().getResourceIterator();
-			itMat.hasMoreElements();)
-		{
-			MaterialPtr mat = itMat.getNext();
-			for (Material::TechniqueIterator itTech =
-				mat-&gt;getTechniqueIterator();
-				itTech.hasMoreElements();)
-			{
-				Technique* tech = itTech.getNext();
-				if (tech-&gt;getSchemeName() == tuScheme)
-				{
-					tech-&gt;setSchemeName(MaterialManager::DEFAULT_SCHEME_NAME);
-					mDefaultTechniques.push_back(tech);
-				}
-				else if (tech-&gt;getSchemeName() == MaterialManager::DEFAULT_SCHEME_NAME)
-				{
-					mDefaultTechniques.push_back(tech);
-				}
-			}
-		}
-	}
+        Ogre::String tuScheme;
 
-	void CoreSubsystem::setScheme(const Ogre::String&amp; schemeName)
-	{
-		if (schemeName != MaterialManager::getSingleton().getActiveScheme())
-		{
-			/*for (std::vector&lt;Technique*&gt;::iterator iter = mDefaultTechniques.begin();
-				iter != mDefaultTechniques.end(); ++iter)
-			{
-				Technique* cur = *iter;
-				cur-&gt;setSchemeName(schemeName);
-			}*/
+        if (numTu &gt;= 6)
+            tuScheme = &quot;tu6&quot;;
+        else if (numTu &gt;= 2)
+            tuScheme = &quot;tu2&quot;;
+        else
+            tuScheme = &quot;tu1&quot;;
 
-			MaterialManager::getSingleton().setActiveScheme(schemeName);
-		}
-	}
+        LOG_MESSAGE(Logger::CORE,
+            &quot;Found &quot; + Ogre::StringConverter::toString(numTu) + &quot; Texture Units, using &quot;+
+            &quot;alphablending scheme &quot; + tuScheme);
 
+        for (ResourceManager::ResourceMapIterator itMat =
+            MaterialManager::getSingleton().getResourceIterator();
+            itMat.hasMoreElements();)
+        {
+            MaterialPtr mat = itMat.getNext();
+            for (Material::TechniqueIterator itTech =
+                mat-&gt;getTechniqueIterator();
+                itTech.hasMoreElements();)
+            {
+                Technique* tech = itTech.getNext();
+                if (tech-&gt;getSchemeName() == tuScheme)
+                {
+                    tech-&gt;setSchemeName(MaterialManager::DEFAULT_SCHEME_NAME);
+                    mDefaultTechniques.push_back(tech);
+                }
+                else if (tech-&gt;getSchemeName() == MaterialManager::DEFAULT_SCHEME_NAME)
+                {
+                    mDefaultTechniques.push_back(tech);
+                }
+            }
+        }
+    }
+
+    void CoreSubsystem::setScheme(const Ogre::String&amp; schemeName)
+    {
+        if (schemeName != MaterialManager::getSingleton().getActiveScheme())
+        {
+            /*for (std::vector&lt;Technique*&gt;::iterator iter = mDefaultTechniques.begin();
+                iter != mDefaultTechniques.end(); ++iter)
+            {
+                Technique* cur = *iter;
+                cur-&gt;setSchemeName(schemeName);
+            }*/
+
+            MaterialManager::getSingleton().setActiveScheme(schemeName);
+        }
+    }
+
     void CoreSubsystem::startAdventureModule(ContentModule* module)
     {
         if (mActiveAdventureModule != NULL)
-		{
-	        mActiveAdventureModule-&gt;unload();
-		}
+        {
+            mActiveAdventureModule-&gt;unload();
+        }
 
         //mCoreEventCaster.dispatchEvent(new DataLoadedEvent(0.0));
 
-		updateDefaultScheme();
+        updateDefaultScheme();
         loadModule(module);
         mActiveAdventureModule = module;
 
@@ -372,16 +396,16 @@
     {
         if (module-&gt;getMinimumEngineVersion()
             &gt; ConfigurationManager::getSingleton().getEngineBuildNumber())
-		{
-			Throw(
-				rl::RuntimeException,
-				&quot;Module &quot;
-				+ Ogre::String(module-&gt;getName().c_str())
-				+ &quot; needs engine &gt;=&quot;
-				+ StringConverter::toString(module-&gt;getMinimumEngineVersion())
-				+ &quot; but engine is &quot;
-				+ StringConverter::toString(ConfigurationManager::getSingleton().getEngineBuildNumber()));
-		}
+        {
+            Throw(
+                rl::RuntimeException,
+                &quot;Module &quot;
+                + Ogre::String(module-&gt;getName().c_str())
+                + &quot; needs engine &gt;=&quot;
+                + StringConverter::toString(module-&gt;getMinimumEngineVersion())
+                + &quot; but engine is &quot;
+                + StringConverter::toString(ConfigurationManager::getSingleton().getEngineBuildNumber()));
+        }
 
         StringVector deps = module-&gt;getDependencies();
         for (StringVector::const_iterator depsIt = deps.begin(); depsIt != deps.end(); depsIt++)
@@ -390,9 +414,9 @@
             ModuleMap::iterator modIt = mModules.find(depName);
             if (modIt == mModules.end())
             {
-			    Throw(
-				    rl::RuntimeException,
-				    &quot;Depedency Module &quot; + depName
+                Throw(
+                    rl::RuntimeException,
+                    &quot;Depedency Module &quot; + depName
                     + &quot; needed by &quot; + Ogre::String(module-&gt;getName().c_str())
                     + &quot; not found.&quot;);
             }
@@ -411,7 +435,7 @@
         module-&gt;initializeTextures();
         module-&gt;initialize();
 
-		ResourceGroupManager::getSingleton().initialiseResourceGroup(module-&gt;getId());
+        ResourceGroupManager::getSingleton().initialiseResourceGroup(module-&gt;getId());
         module-&gt;precreateMeshes();
 
         if (module-&gt;isCommon())
@@ -424,15 +448,15 @@
             &quot;Module &quot; + module-&gt;getName() + &quot; initialized.&quot;);
     }
 
-	void CoreSubsystem::setDefaultActiveModule(const Ogre::String&amp; module)
-	{
-		mDefaultActiveModule = module;
-	}
+    void CoreSubsystem::setDefaultActiveModule(const Ogre::String&amp; module)
+    {
+        mDefaultActiveModule = module;
+    }
 
-	const Ogre::String&amp; CoreSubsystem::getDefaultActiveModule() const
-	{
-		return mDefaultActiveModule;
-	}
+    const Ogre::String&amp; CoreSubsystem::getDefaultActiveModule() const
+    {
+        return mDefaultActiveModule;
+    }
 
     World* CoreSubsystem::getWorld()
     {
@@ -447,8 +471,7 @@
 
     void CoreSubsystem::makeScreenshot( const String&amp; sName )
     {
-        Ogre::Root::getSingleton().getAutoCreatedWindow()-&gt;
-            writeContentsToTimestampedFile(sName, &quot;.jpg&quot;);
+        mRenderWindow-&gt;writeContentsToTimestampedFile(sName, &quot;.jpg&quot;);
     }
 
     ContentModule* CoreSubsystem::getActiveAdventureModule() const
@@ -456,13 +479,13 @@
         return mActiveAdventureModule;
     }
 
-	const ModuleMap&amp; CoreSubsystem::getAllModules() const
-	{
-		return mModules;
-	}
+    const ModuleMap&amp; CoreSubsystem::getAllModules() const
+    {
+        return mModules;
+    }
 
     void CoreSubsystem::loadMap(const String type, const String filename,
-    	const String module, const String startupScript)
+        const String module, const String startupScript)
     {
         mWorld-&gt;loadScene(filename, module);
         if (startupScript.length() &gt; 0) mRubyInterpreter-&gt;executeFile(startupScript);
@@ -470,24 +493,23 @@
 
     void CoreSubsystem::loadPlugins()
     {
-		mSoundManager-&gt;loadConf(rl::ConfigurationManager::getSingleton().getSoundCfgPath());
-		LOG_MESSAGE(Logger::CORE, &quot;Soundkonfiguration geladen&quot;);
+        mSoundManager-&gt;applySettings(rl::ConfigurationManager::getSingleton().getSoundSettings());
+        LOG_MESSAGE(Logger::CORE, &quot;Soundeinstellungen geladen&quot;);
     }
 
     void CoreSubsystem::unloadPlugins()
     {
-        mSoundManager-&gt;saveConf(rl::ConfigurationManager::getSingleton().getSoundCfgPath());
-		LOG_MESSAGE(Logger::CORE, &quot;Soundkonfiguration gespeichert.&quot;);
         mSoundManager-&gt;unloadAllDrivers();
+        LOG_MESSAGE(Logger::CORE, &quot;Soundtreiber entladen&quot;);
     }
 
-	void CoreSubsystem::addCoreEventListener(rl::CoreEventListener *listener)
-	{
-		mCoreEventCaster.addEventListener(listener);
-	}
+    void CoreSubsystem::addCoreEventListener(rl::CoreEventListener *listener)
+    {
+        mCoreEventCaster.addEventListener(listener);
+    }
 
-	void CoreSubsystem::removeCoreEventListener(CoreEventListener* listener)
+    void CoreSubsystem::removeCoreEventListener(CoreEventListener* listener)
     {
-		mCoreEventCaster.removeEventListener(listener);
+        mCoreEventCaster.removeEventListener(listener);
     }
 }

Modified: rl/trunk/engine/core/src/DotSceneLoader.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneLoader.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/core/src/DotSceneLoader.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -47,112 +47,129 @@
 using namespace Ogre;
 
 namespace rl {
-	using XERCES_CPP_NAMESPACE::DOMDocument;
+    using XERCES_CPP_NAMESPACE::DOMDocument;
 
     DotSceneLoader::DotSceneLoader(const string&amp; filename, const string&amp; resourceGroup)
         : mSceneName(filename),
           mResourceGroup(resourceGroup),
-		  mStaticNodes(),
-		  mRenderingDistance(ActorManager::getSingleton().getDefaultActorRenderingDistance()),
-		  mStaticgeomRenderingDistances(),
-		  mStaticgeomBatchSizes(),
+          mStaticNodes(),
+          mRenderingDistance(ActorManager::getSingleton().getDefaultActorRenderingDistance()),
+          mStaticgeomRenderingDistances(),
+          mStaticgeomBatchSizes(),
           mRessource(NULL),
           mParser(NULL),
           mErrorCount(0)
-	{
+    {
         srand(static_cast&lt;unsigned int&gt;(time(NULL)));
-	}
+    }
 
-	DotSceneLoader::~DotSceneLoader()
-	{      
+    DotSceneLoader::~DotSceneLoader()
+    {
         if (mRessource-&gt;isLoaded())
         {
             XmlResourceManager::getSingleton().unload(mSceneName);
             XmlResourceManager::getSingleton().remove(mRessource-&gt;getHandle());
         }
-	}
+    }
 
-	void DotSceneLoader::initializeScene(SceneManager* sceneManager)
-	{
-		XMLPlatformUtils::Initialize();
-		XmlHelper::initializeTranscoder();
+    void DotSceneLoader::initializeScene(SceneManager* sceneManager)
+    {
+        XMLPlatformUtils::Initialize();
+        XmlHelper::initializeTranscoder();
 
-		LOG_MESSAGE(Logger::CORE, &quot;Loading Scene from &quot; + mSceneName);
-        DOMDocument* doc = openSceneFile();            
+        LOG_MESSAGE(Logger::CORE, &quot;Loading Scene from &quot; + mSceneName);
+        DOMDocument* doc = openSceneFile();
 
-		// Durch alle Unterelemente iterieren
-		DOMNode* child = doc-&gt;getDocumentElement()-&gt;getFirstChild();
+        // Durch alle Unterelemente iterieren
+        DOMNode* child = doc-&gt;getDocumentElement()-&gt;getFirstChild();
 
-		while(child != NULL)
-		{
-			// Ein Node
+        while(child != NULL)
+        {
+            // Ein Node
             if (XMLString::compareIString(child-&gt;getNodeName(), AutoXMLCh(&quot;userData&quot;).data()) == 0 )
-			{
-				processSceneUserData(static_cast&lt;DOMElement*&gt;(child));
-			}
-			child = child-&gt;getNextSibling();
-		} 
+            {
+                processSceneUserData(static_cast&lt;DOMElement*&gt;(child));
+            }
+            child = child-&gt;getNextSibling();
+        }
 
-		LOG_DEBUG(Logger::CORE, &quot; Beginne parsen der Unterelemente&quot;);
-		DOMElement* nodes = XmlHelper::getChildNamed(doc-&gt;getDocumentElement(), &quot;nodes&quot;);
+        LOG_DEBUG(Logger::CORE, &quot; Beginne parsen der Unterelemente&quot;);
+        DOMElement* nodes = XmlHelper::getChildNamed(doc-&gt;getDocumentElement(), &quot;nodes&quot;);
 
-		// Eine .scene wird in einem SceneNode mit dem Namen der .scene befestigt
-		mSceneNode = sceneManager-&gt;getRootSceneNode()-&gt;createChildSceneNode(mSceneName);
-		processNodes(nodes, sceneManager, mSceneNode);
+        // Eine .scene wird in einem SceneNode mit dem Namen der .scene befestigt
+        mSceneNode = sceneManager-&gt;getRootSceneNode()-&gt;createChildSceneNode(mSceneName);
+        processNodes(nodes, sceneManager, mSceneNode);
 
+        // Find out, if static geometry should be used
+        Ogre::String temp = ConfigurationManager::getSingleton().getStringSetting(ConfigurationManager::CS_GRAPHICS, &quot;Use Static Geometry&quot;);
+        bool useStaticGeometry;
 
-        if (ConfigurationManager::getSingleton().shouldUseStaticGeometry())
-        {    
-			for(std::map&lt;int,Ogre::SceneNode*&gt;::iterator it = mStaticNodes.begin();
-				it != mStaticNodes.end();) 
-			{
-				Ogre::SceneNode* staticNode = it-&gt;second;
-				string staticName = Ogre::StringConverter::toString(it-&gt;first);
-				Ogre::Real renderDist = mRenderingDistance;
-				Ogre::Real batchSize = 25.0;
+        if (temp == &quot;yes&quot;)
+        {
+            useStaticGeometry = true;
+        }
+        else if (temp == &quot;no&quot;)
+        {
+            useStaticGeometry = false;
+        }
+        else
+        {
+            // Check, if Renderer supports vertex buffer
+            useStaticGeometry = Ogre::Root::getSingleton().getRenderSystem()-&gt;getCapabilities()-&gt;hasCapability(Ogre::RSC_VBO);
+        }
 
-				if (mStaticgeomRenderingDistances.find(it-&gt;first) != mStaticgeomRenderingDistances.end())
-					renderDist = mStaticgeomRenderingDistances[it-&gt;first];
-				if (mStaticgeomBatchSizes.find(it-&gt;first) != mStaticgeomBatchSizes.end())
-					batchSize = mStaticgeomBatchSizes[it-&gt;first];
+        if (useStaticGeometry)
+        {
+            for(std::map&lt;int,Ogre::SceneNode*&gt;::iterator it = mStaticNodes.begin();
+                it != mStaticNodes.end();)
+            {
+                Ogre::SceneNode* staticNode = it-&gt;second;
+                string staticName = Ogre::StringConverter::toString(it-&gt;first);
+                Ogre::Real renderDist = mRenderingDistance;
+                Ogre::Real batchSize = 25.0;
 
-				StaticGeometry* staticGeom = sceneManager-&gt;createStaticGeometry(mSceneName + staticName );
-				
-				staticGeom-&gt;setRenderingDistance(renderDist);
-				staticGeom-&gt;addSceneNode(staticNode);
-				staticGeom-&gt;setRegionDimensions(batchSize * Vector3::UNIT_SCALE);
-				// Statische Geometrie bauen
-				staticGeom-&gt;build();
-				// Nicht mehr den Original-Knoten rendern, da dieser noch erhalten ist.			
-				staticNode-&gt;setVisible(false);
-				staticNode-&gt;removeAndDestroyAllChildren();
-				sceneManager-&gt;destroySceneNode(staticNode-&gt;getName());				
-				staticNode = NULL;
-				LOG_DEBUG(Logger::CORE, &quot; Statische Geometrie &quot;+staticName+&quot; erstellt&quot;);
-				++it;
-			}
+                if (mStaticgeomRenderingDistances.find(it-&gt;first) != mStaticgeomRenderingDistances.end())
+                    renderDist = mStaticgeomRenderingDistances[it-&gt;first];
+                if (mStaticgeomBatchSizes.find(it-&gt;first) != mStaticgeomBatchSizes.end())
+                    batchSize = mStaticgeomBatchSizes[it-&gt;first];
+
+                StaticGeometry* staticGeom = sceneManager-&gt;createStaticGeometry(mSceneName + staticName );
+
+                staticGeom-&gt;setRenderingDistance(renderDist);
+                staticGeom-&gt;addSceneNode(staticNode);
+                staticGeom-&gt;setRegionDimensions(batchSize * Vector3::UNIT_SCALE);
+                // Statische Geometrie bauen
+                staticGeom-&gt;build();
+                // Nicht mehr den Original-Knoten rendern, da dieser noch erhalten ist.
+                staticNode-&gt;setVisible(false);
+                staticNode-&gt;removeAndDestroyAllChildren();
+                sceneManager-&gt;destroySceneNode(staticNode-&gt;getName());
+                staticNode = NULL;
+                LOG_DEBUG(Logger::CORE, &quot; Statische Geometrie &quot;+staticName+&quot; erstellt&quot;);
+                ++it;
+            }
         }
         else
             LOG_DEBUG(Logger::CORE, &quot; Keine statischen Geometrien erstellt&quot;);
-        
+
         delete mParser;
-		XMLPlatformUtils::Terminate();		
-		LOG_DEBUG(Logger::CORE, &quot;Szenenbeschreibung aus &quot; + mSceneName +&quot; fertig geparst&quot;);
-	}
+        XMLPlatformUtils::Terminate();
+        LOG_DEBUG(Logger::CORE, &quot;Szenenbeschreibung aus &quot; + mSceneName +&quot; fertig geparst&quot;);
+    }
 
-	DOMDocument* DotSceneLoader::openSceneFile()
-	{
-		mParser = new XercesDOMParser();
+    DOMDocument* DotSceneLoader::openSceneFile()
+    {
+        mParser = new XercesDOMParser();
         mParser-&gt;setValidationScheme(XercesDOMParser::Val_Auto);
         mParser-&gt;setDoNamespaces(true);
         mParser-&gt;setErrorHandler(this);
-		
+
         try
         {
-		    mRessource = 
-			    XmlResourceManager::getSingleton().create(
-			    mSceneName, 
-		   	    mResourceGroup);
+            mRessource =
+                XmlResourceManager::getSingleton().create(
+                mSceneName,
+                   mResourceGroup);
         }
         catch(Ogre::Exception)
         {
@@ -171,36 +188,36 @@
         if (mErrorCount &gt; 0)
             Throw(RuntimeException, &quot;File '&quot;+mSceneName+&quot;' could not be parsed.&quot;);
 
-		DOMDocument* doc = mParser-&gt;getDocument();     
+        DOMDocument* doc = mParser-&gt;getDocument();
 
         return doc;
-	}
+    }
 
-	// Iteriert durch die einzelnen Nodes
-	void DotSceneLoader::processNodes(DOMElement* rootNodesXml, SceneManager* sceneManager, 
-		Ogre::SceneNode* parentNode)
-	{
-		if (rootNodesXml == NULL)
-			return;
-		if (parentNode == NULL)
-			Throw(NullPointerException, &quot;parentNode darf nicht null sein&quot;);
-	
+    // Iteriert durch die einzelnen Nodes
+    void DotSceneLoader::processNodes(DOMElement* rootNodesXml, SceneManager* sceneManager,
+        Ogre::SceneNode* parentNode)
+    {
+        if (rootNodesXml == NULL)
+            return;
+        if (parentNode == NULL)
+            Throw(NullPointerException, &quot;parentNode darf nicht null sein&quot;);
 
-		// Durch alle Unterelemente iterieren
-		DOMNode* child = rootNodesXml-&gt;getFirstChild();
 
-		while(child != NULL)
-		{
-			// Ein Node
+        // Durch alle Unterelemente iterieren
+        DOMNode* child = rootNodesXml-&gt;getFirstChild();
+
+        while(child != NULL)
+        {
+            // Ein Node
             if (XMLString::compareIString(child-&gt;getNodeName(), AutoXMLCh(&quot;node&quot;).data()) == 0 )
-			{
-				processNode(static_cast&lt;DOMElement*&gt;(child), sceneManager, parentNode, NULL);
-			}
-			child = child-&gt;getNextSibling();
-		} 
-	}
+            {
+                processNode(static_cast&lt;DOMElement*&gt;(child), sceneManager, parentNode, NULL);
+            }
+            child = child-&gt;getNextSibling();
+        }
+    }
 
-	// Befasst sich mit einem Node
+    // Befasst sich mit einem Node
     void DotSceneLoader::processNode(DOMElement* rootNodeXml, SceneManager* sceneManager, Ogre::SceneNode* parentNode, NodeUserData* parentUserData)
     {
         if (rootNodeXml == NULL)
@@ -208,7 +225,7 @@
         if (parentNode == NULL)
             Throw(NullPointerException, &quot;parentNode darf nicht null sein&quot;);
 
-        string nodeName = XmlHelper::getAttributeValueAsStdString(rootNodeXml, 
+        string nodeName = XmlHelper::getAttributeValueAsStdString(rootNodeXml,
                         &quot;name&quot;);
 
         Ogre::SceneNode* newNode;
@@ -224,17 +241,17 @@
             {
                 // Name schon vergeben
                 newNode = parentNode-&gt;createChildSceneNode();
-                LOG_DEBUG(Logger::CORE, 
+                LOG_DEBUG(Logger::CORE,
                     &quot; NodeName '&quot;+nodeName+&quot;' war schon vergeben! Es wurde der Name '&quot;+newNode-&gt;getName()+&quot;' benutzt.&quot;);
             }
         }
         else
         {
             newNode = parentNode-&gt;createChildSceneNode();
-        }	
+        }
 
-        LOG_DEBUG(Logger::CORE, 
-                    &quot; Node '&quot;+newNode-&gt;getName()+&quot;' als Unterknoten von '&quot;+parentNode-&gt;getName()+&quot;' erstellt.&quot;);		
+        LOG_DEBUG(Logger::CORE,
+                    &quot; Node '&quot;+newNode-&gt;getName()+&quot;' als Unterknoten von '&quot;+parentNode-&gt;getName()+&quot;' erstellt.&quot;);
 
 
         NodeUserData userData;
@@ -260,25 +277,25 @@
 
         mCollisions.clear();
         DOMNode* child = rootNodeXml-&gt;getFirstChild();
-        DOMNode *childScale = NULL, *childPosition = NULL, 
+        DOMNode *childScale = NULL, *childPosition = NULL,
         *childRotation = NULL;
         // Durch alle Unterelemente iterieren und gefundenes speichern
         while(child != NULL)
         {
             // Ein selbstdefinierter Bereich
-            if (XMLString::compareIString(child-&gt;getNodeName(), 
+            if (XMLString::compareIString(child-&gt;getNodeName(),
                 AutoXMLCh(&quot;userData&quot;).data()) == 0)
             {
                 // UserData direkt auslesen
                 processNodeUserData(static_cast&lt;DOMElement*&gt;(child) , &amp;userData);
             }
-            else if (XMLString::compareIString(child-&gt;getNodeName(), 
+            else if (XMLString::compareIString(child-&gt;getNodeName(),
                      AutoXMLCh(&quot;position&quot;).data()) == 0)
                 childPosition = child;//rootNodeXml-&gt;removeChild(child);
-            else if (XMLString::compareIString(child-&gt;getNodeName(), 
+            else if (XMLString::compareIString(child-&gt;getNodeName(),
                      AutoXMLCh(&quot;rotation&quot;).data()) == 0)
                 childRotation = child;//rootNodeXml-&gt;removeChild(child);
-            else if (XMLString::compareIString(child-&gt;getNodeName(), 
+            else if (XMLString::compareIString(child-&gt;getNodeName(),
                      AutoXMLCh(&quot;scale&quot;).data()) == 0)
                 childScale = child;//rootNodeXml-&gt;removeChild(child);
 
@@ -297,7 +314,7 @@
             // Existiert noch nicht
             if (mStaticNodes.find(userData.staticgeom_group) == mStaticNodes.end())
             {
-                mStaticNodes[userData.staticgeom_group] = 
+                mStaticNodes[userData.staticgeom_group] =
                 sceneManager-&gt;getRootSceneNode()-&gt;createChildSceneNode(
                 mSceneName+&quot;_static_&quot;+Ogre::StringConverter::toString(userData.staticgeom_group));
             }
@@ -339,13 +356,13 @@
         while(child != NULL)
         {
             // geschachteltes weiteres Node
-            if (XMLString::compareIString(child-&gt;getNodeName(), 
+            if (XMLString::compareIString(child-&gt;getNodeName(),
                 AutoXMLCh(&quot;node&quot;).data()) == 0)
                 processNode(static_cast&lt;DOMElement*&gt;(child), sceneManager, newNode, &amp;userData);
             // Eine Entity
-            else if (XMLString::compareIString(child-&gt;getNodeName(), 
+            else if (XMLString::compareIString(child-&gt;getNodeName(),
                      AutoXMLCh(&quot;entity&quot;).data()) == 0)
-                processEntity(static_cast&lt;DOMElement*&gt;(child), 
+                processEntity(static_cast&lt;DOMElement*&gt;(child),
                                 sceneManager,
                                 newNode,
                                 userData.renderingdistance,
@@ -365,11 +382,11 @@
         while(child != NULL)
         {
             // Ein selbstdefinierter Bereich
-            if (XMLString::compareIString(child-&gt;getNodeName(), 
+            if (XMLString::compareIString(child-&gt;getNodeName(),
                 AutoXMLCh(&quot;property&quot;).data()) == 0)
             {
                 DOMElement* propertyXml = static_cast&lt;DOMElement*&gt;(child);
-                
+
                 PropertyEntry entry = propertyReader-&gt;processProperty(propertyXml);
 
                 try
@@ -391,19 +408,19 @@
                 }
                 catch(...)
                 {
-                    LOG_DEBUG(Logger::CORE, 
+                    LOG_DEBUG(Logger::CORE,
                         &quot; &gt; Parse Error beim &#220;bernehmen der Property '&quot;+entry.first+&quot;'!&quot;);
                 }
 
             }
             // Manuell definiertes LOD
-            else if (XMLString::compareIString(child-&gt;getNodeName(), 
+            else if (XMLString::compareIString(child-&gt;getNodeName(),
                 AutoXMLCh(&quot;manualLOD&quot;).data()) == 0)
             {
                 DOMElement* lodXml = static_cast&lt;DOMElement*&gt;(child);
-                string meshName = XmlHelper::getAttributeValueAsStdString(lodXml, 
+                string meshName = XmlHelper::getAttributeValueAsStdString(lodXml,
                     &quot;mesh&quot;);
-				
+
                 try
                 {
                     Ogre::MeshPtr mesh = Ogre::MeshManager::getSingleton().getByName(meshName);
@@ -416,8 +433,8 @@
 
                     // Durch alle Unterelemente iterieren, um die LODs zu finden
                     while(lodchild != NULL)
-                    {						
-                        if (XMLString::compareIString(lodchild-&gt;getNodeName(), 
+                    {
+                        if (XMLString::compareIString(lodchild-&gt;getNodeName(),
                             AutoXMLCh(&quot;LOD&quot;).data()) == 0)
                         {
                             loddist = 0.0;
@@ -426,15 +443,15 @@
                             try
                             {
                                 lodXml = static_cast&lt;DOMElement*&gt;(lodchild);
-                                loddist = XmlHelper::getAttributeValueAsReal(lodXml, 
+                                loddist = XmlHelper::getAttributeValueAsReal(lodXml,
                                     &quot;distance&quot;);
-                                lodmeshName = XmlHelper::getAttributeValueAsStdString(lodXml, 
+                                lodmeshName = XmlHelper::getAttributeValueAsStdString(lodXml,
                                     &quot;mesh&quot;);
 
                                 if (lodmeshName.length() &gt; 0 &amp;&amp; loddist &gt; 0)
                                 {
                                     mesh-&gt;createManualLodLevel(loddist, lodmeshName);
-                                    LOG_DEBUG(Logger::CORE, 
+                                    LOG_DEBUG(Logger::CORE,
                                         &quot; LOD f&#252;r bei '&quot;+Ogre::StringConverter::toString(loddist)+
                                         &quot;' als '&quot;+lodmeshName+&quot;' gesetzt!&quot;);
                                 }
@@ -444,10 +461,10 @@
 
                         lodchild = lodchild-&gt;getNextSibling();
                     }
-				}
+                }
                 catch(...)
                 {
-                    LOG_MESSAGE(Logger::CORE, 
+                    LOG_MESSAGE(Logger::CORE,
                         &quot; &gt; Parse Error beim Setzen der LOD f&#252;r '&quot;+meshName+&quot;'!&quot;);
                 }
             }
@@ -455,9 +472,9 @@
         }
 
         delete propertyReader;
-	}
+    }
 
-    void DotSceneLoader::processNodeUserData(XERCES_CPP_NAMESPACE::DOMElement* rootUserDataXml, 
+    void DotSceneLoader::processNodeUserData(XERCES_CPP_NAMESPACE::DOMElement* rootUserDataXml,
         NodeUserData* userData)
     {
         DOMNode* child = rootUserDataXml-&gt;getFirstChild();
@@ -468,7 +485,7 @@
         while(child != NULL)
         {
             // Ein selbstdefinierter Bereich
-            if (XMLString::compareIString(child-&gt;getNodeName(), 
+            if (XMLString::compareIString(child-&gt;getNodeName(),
                 AutoXMLCh(&quot;property&quot;).data()) == 0)
             {
                 DOMElement* propertyXml = static_cast&lt;DOMElement*&gt;(child);
@@ -487,12 +504,12 @@
                 }
                 catch(...)
                 {
-                    LOG_MESSAGE(Logger::CORE, 
+                    LOG_MESSAGE(Logger::CORE,
                         &quot; &gt; Parse Error beim &#220;bernehmen der Property '&quot;+entry.first+&quot;'!&quot;);
                 }
 
             }
-            else if (XMLString::compareIString(child-&gt;getNodeName(), 
+            else if (XMLString::compareIString(child-&gt;getNodeName(),
                         AutoXMLCh(&quot;collisions&quot;).data()) == 0)
                     processCollisions(static_cast&lt;DOMElement*&gt; (child));
 
@@ -539,17 +556,17 @@
             {
                 if (childChild-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
                 {
-                    if (XMLString::compareIString(childChild-&gt;getNodeName(), 
+                    if (XMLString::compareIString(childChild-&gt;getNodeName(),
                         AutoXMLCh(&quot;scale&quot;).data()) == 0)
                         scale = processScale(static_cast&lt;DOMElement*&gt;(childChild));
-                    else if (XMLString::compareIString(childChild-&gt;getNodeName(), 
+                    else if (XMLString::compareIString(childChild-&gt;getNodeName(),
                              AutoXMLCh(&quot;offset&quot;).data()) == 0)
                         offset = processPosition(static_cast&lt;DOMElement*&gt;(childChild));
-                    else if (XMLString::compareIString(childChild-&gt;getNodeName(), 
+                    else if (XMLString::compareIString(childChild-&gt;getNodeName(),
                              AutoXMLCh(&quot;rotation&quot;).data()) == 0)
                         rotation = processRotation(static_cast&lt;DOMElement*&gt;(childChild));
 
-                    else if (XMLString::compareIString(childChild-&gt;getNodeName(), 
+                    else if (XMLString::compareIString(childChild-&gt;getNodeName(),
                              AutoXMLCh(&quot;vertices&quot;).data()) == 0)
                     {
                         DOMNode *childChildChild = static_cast&lt;DOMElement*&gt;(childChild)-&gt;getFirstChild();
@@ -557,7 +574,7 @@
                         {
                             if (childChild-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
                             {
-                                if (XMLString::compareIString(childChildChild-&gt;getNodeName(), 
+                                if (XMLString::compareIString(childChildChild-&gt;getNodeName(),
                                     AutoXMLCh(&quot;vertex&quot;).data()) == 0)
                                 {
                                     bool error = false;
@@ -606,7 +623,7 @@
                     size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
                     vertcount &lt; 4)
                 {
-                    LOG_MESSAGE(Logger::CORE, 
+                    LOG_MESSAGE(Logger::CORE,
                         &quot; physical_body 'convexhull' in &lt;collisions&gt; konnte nicht erstellt werden; der K&#246;rper ist zu klein!&quot;);
 
                     // Minimale Gr&#246;&#223;e verwenden
@@ -616,10 +633,10 @@
                         size.y = PhysicsManager::NEWTON_GRID_WIDTH;
                     if (size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH)
                         size.z = PhysicsManager::NEWTON_GRID_WIDTH;
-                        
+
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
                                      thisWorld, size, rotation, offset));
-                    
+
                     LOG_MESSAGE(Logger::CORE, &quot; stattdessen physical_body 'box' erstellt. &quot;);
                 }
                 else
@@ -746,7 +763,7 @@
 */
                 else
                 {
-                    LOG_MESSAGE(Logger::CORE, 
+                    LOG_MESSAGE(Logger::CORE,
                         &quot; &gt; Parse Error beim Erstellen einer Collision; ung&#252;ltiger typ: '&quot;+typeAsString+&quot;' !&quot;);
                     collision.setNull();
                     //return OgreNewt::CollisionPtr(NULL);
@@ -763,11 +780,11 @@
         }
     }
 
-	// Eine Entity
-	void DotSceneLoader::processEntity(DOMElement* rootEntityXml,
-		SceneManager* sceneManager, Ogre::SceneNode* parentNode, 
-		Ogre::Real renderingDistance, const std::string &amp;physical_body)
-	{
+    // Eine Entity
+    void DotSceneLoader::processEntity(DOMElement* rootEntityXml,
+        SceneManager* sceneManager, Ogre::SceneNode* parentNode,
+        Ogre::Real renderingDistance, const std::string &amp;physical_body)
+    {
         string entName = XmlHelper::getAttributeValueAsStdString(
             rootEntityXml, &quot;name&quot;);
         string meshName = XmlHelper::getAttributeValueAsStdString(
@@ -823,8 +840,8 @@
             Ogre::Vector3 size = (aab.getMaximum() - aab.getMinimum()) * parentNode-&gt;getScale();
             bool forceBox = false;
 
-            if ((size.x &lt; PhysicsManager::NEWTON_GRID_WIDTH || 
-                 size.y &lt; PhysicsManager::NEWTON_GRID_WIDTH || 
+            if ((size.x &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
+                 size.y &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
                  size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH) &amp;&amp;
                  physical_body.compare(&quot;convexhull&quot;) == 0)
             {
@@ -844,7 +861,7 @@
 
             // Pr&#252;fen, ob schon ein identischer Proxy erstellt wurde um diesen erneut zu verwenden
             AlreadyUsedCollision &amp;aucol (mAutoCreatedCollisions[meshName]);
-            if (aucol.Type.compare(physical_body) == 0  &amp;&amp; 
+            if (aucol.Type.compare(physical_body) == 0  &amp;&amp;
                 aucol.Scale == parentNode-&gt;getScale() &amp;&amp;
                 (!forceBox)) // sicherheitshalber
             {
@@ -932,7 +949,7 @@
 
         // Zur Physik des Levels hinzuf&#252;gen
         if (mCollisions.size() &gt; 0)
-        {                
+        {
             PhysicsManager::getSingleton().addLevelGeometry(newEnt, mCollisions);
             LOG_DEBUG(Logger::CORE, &quot; Entity '&quot;+entName+&quot;' in levelGeometry geladen&quot;);
         }
@@ -943,12 +960,12 @@
         {
             mCollisions.pop_back();
         }
-        
+
         // Renderingdistanz berechnen
         if (renderingDistance == mRenderingDistance)
         {
-            Ogre::Real diameter 
-                = (newEnt-&gt;getBoundingBox().getMaximum() - newEnt-&gt;getBoundingBox().getMinimum()).length();  
+            Ogre::Real diameter
+                = (newEnt-&gt;getBoundingBox().getMaximum() - newEnt-&gt;getBoundingBox().getMinimum()).length();
 
             // Gerade mal 10cm&#178; =&gt; 10m
             if (diameter &lt;= 0.5)
@@ -971,9 +988,9 @@
             newEnt-&gt;setRenderingDistance(renderingDistance);
         }
         else
-		    newEnt-&gt;setRenderingDistance(renderingDistance);
+            newEnt-&gt;setRenderingDistance(renderingDistance);
         newEnt-&gt;setCastShadows(false);
-	}
+    }
 
     string DotSceneLoader::getRandomName(const string&amp; baseName)
     {
@@ -983,132 +1000,132 @@
         return rval.str();
     }
 
-	Ogre::Vector3 DotSceneLoader::processPosition(DOMElement* rootPositionXml)
-	{
-		LOG_DEBUG(Logger::CORE, &quot; Position gefunden&quot;);
+    Ogre::Vector3 DotSceneLoader::processPosition(DOMElement* rootPositionXml)
+    {
+        LOG_DEBUG(Logger::CORE, &quot; Position gefunden&quot;);
 
-		try
-		{
-			if (XmlHelper::hasAttribute(rootPositionXml, &quot;x&quot;) &amp;&amp; 
-				XmlHelper::hasAttribute(rootPositionXml, &quot;y&quot;) &amp;&amp; 
-				XmlHelper::hasAttribute(rootPositionXml, &quot;z&quot;))
-			{
-				return Ogre::Vector3(
-					XmlHelper::getAttributeValueAsReal(rootPositionXml, &quot;x&quot;),
-					XmlHelper::getAttributeValueAsReal(rootPositionXml, &quot;y&quot;),
-					XmlHelper::getAttributeValueAsReal(rootPositionXml, &quot;z&quot;));
-			}
-		}
-		catch(...) { }
-         
-		LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim &#220;bernehmen der Position! &quot;);
+        try
+        {
+            if (XmlHelper::hasAttribute(rootPositionXml, &quot;x&quot;) &amp;&amp;
+                XmlHelper::hasAttribute(rootPositionXml, &quot;y&quot;) &amp;&amp;
+                XmlHelper::hasAttribute(rootPositionXml, &quot;z&quot;))
+            {
+                return Ogre::Vector3(
+                    XmlHelper::getAttributeValueAsReal(rootPositionXml, &quot;x&quot;),
+                    XmlHelper::getAttributeValueAsReal(rootPositionXml, &quot;y&quot;),
+                    XmlHelper::getAttributeValueAsReal(rootPositionXml, &quot;z&quot;));
+            }
+        }
+        catch(...) { }
 
-		return Ogre::Vector3::ZERO;
-	}
+        LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim &#220;bernehmen der Position! &quot;);
 
+        return Ogre::Vector3::ZERO;
+    }
 
-	Ogre::Vector3 DotSceneLoader::processScale(DOMElement* rootScaleXml)
-	{
-		LOG_DEBUG(Logger::CORE, &quot; Skalierung gefunden&quot;);
 
-		try
-		{
-			if (XmlHelper::hasAttribute(rootScaleXml, &quot;x&quot;) &amp;&amp; 
-				XmlHelper::hasAttribute(rootScaleXml, &quot;y&quot;) &amp;&amp; 
-				XmlHelper::hasAttribute(rootScaleXml, &quot;z&quot;))
-			{
-				return Ogre::Vector3(
-					XmlHelper::getAttributeValueAsReal(rootScaleXml, &quot;x&quot;),
-					XmlHelper::getAttributeValueAsReal(rootScaleXml, &quot;y&quot;),
-					XmlHelper::getAttributeValueAsReal(rootScaleXml, &quot;z&quot;));
-			}
-		}
+    Ogre::Vector3 DotSceneLoader::processScale(DOMElement* rootScaleXml)
+    {
+        LOG_DEBUG(Logger::CORE, &quot; Skalierung gefunden&quot;);
+
+        try
+        {
+            if (XmlHelper::hasAttribute(rootScaleXml, &quot;x&quot;) &amp;&amp;
+                XmlHelper::hasAttribute(rootScaleXml, &quot;y&quot;) &amp;&amp;
+                XmlHelper::hasAttribute(rootScaleXml, &quot;z&quot;))
+            {
+                return Ogre::Vector3(
+                    XmlHelper::getAttributeValueAsReal(rootScaleXml, &quot;x&quot;),
+                    XmlHelper::getAttributeValueAsReal(rootScaleXml, &quot;y&quot;),
+                    XmlHelper::getAttributeValueAsReal(rootScaleXml, &quot;z&quot;));
+            }
+        }
         catch(...) { }
 
-		LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim &#220;bernehmen der Skalierung! &quot;);
+        LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim &#220;bernehmen der Skalierung! &quot;);
 
-		return Ogre::Vector3::UNIT_SCALE;
-	}
+        return Ogre::Vector3::UNIT_SCALE;
+    }
 
-	Ogre::Vector3 DotSceneLoader::processVector(DOMElement* rootScaleXml, bool &amp;error)
-	{
-		LOG_DEBUG(Logger::CORE, &quot; Vector gefunden&quot;);
+    Ogre::Vector3 DotSceneLoader::processVector(DOMElement* rootScaleXml, bool &amp;error)
+    {
+        LOG_DEBUG(Logger::CORE, &quot; Vector gefunden&quot;);
 
-		try
-		{
-			if (XmlHelper::hasAttribute(rootScaleXml, &quot;x&quot;) &amp;&amp; 
-				XmlHelper::hasAttribute(rootScaleXml, &quot;y&quot;) &amp;&amp; 
-				XmlHelper::hasAttribute(rootScaleXml, &quot;z&quot;))
-			{
-				error = false;
-				return Ogre::Vector3(
-					XmlHelper::getAttributeValueAsReal(rootScaleXml, &quot;x&quot;),
-					XmlHelper::getAttributeValueAsReal(rootScaleXml, &quot;y&quot;),
-					XmlHelper::getAttributeValueAsReal(rootScaleXml, &quot;z&quot;));
-			}
-		}
+        try
+        {
+            if (XmlHelper::hasAttribute(rootScaleXml, &quot;x&quot;) &amp;&amp;
+                XmlHelper::hasAttribute(rootScaleXml, &quot;y&quot;) &amp;&amp;
+                XmlHelper::hasAttribute(rootScaleXml, &quot;z&quot;))
+            {
+                error = false;
+                return Ogre::Vector3(
+                    XmlHelper::getAttributeValueAsReal(rootScaleXml, &quot;x&quot;),
+                    XmlHelper::getAttributeValueAsReal(rootScaleXml, &quot;y&quot;),
+                    XmlHelper::getAttributeValueAsReal(rootScaleXml, &quot;z&quot;));
+            }
+        }
         catch(...) { }
 
-		LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim Lesen eines Vectors! &quot;);
-		error = true;
+        LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim Lesen eines Vectors! &quot;);
+        error = true;
 
-		return Ogre::Vector3::UNIT_SCALE;
-	}
+        return Ogre::Vector3::UNIT_SCALE;
+    }
 
-	/// @TODO Sollten drei M&#246;glichkeiten sein...
-	Ogre::Quaternion DotSceneLoader::processRotation(DOMElement* rootQuatXml)
-	{
-		LOG_DEBUG(Logger::CORE, &quot; Rotation gefunden&quot;);
+    /// @TODO Sollten drei M&#246;glichkeiten sein...
+    Ogre::Quaternion DotSceneLoader::processRotation(DOMElement* rootQuatXml)
+    {
+        LOG_DEBUG(Logger::CORE, &quot; Rotation gefunden&quot;);
 
-		try
-		{
-			// Durch w,x,y,z definiert
-			if (XmlHelper::hasAttribute(rootQuatXml, &quot;qw&quot;) &amp;&amp; 
-				XmlHelper::hasAttribute(rootQuatXml, &quot;qx&quot;) &amp;&amp; 
-				XmlHelper::hasAttribute(rootQuatXml, &quot;qy&quot;) &amp;&amp; 
-				XmlHelper::hasAttribute(rootQuatXml, &quot;qz&quot;))
-			{
+        try
+        {
+            // Durch w,x,y,z definiert
+            if (XmlHelper::hasAttribute(rootQuatXml, &quot;qw&quot;) &amp;&amp;
+                XmlHelper::hasAttribute(rootQuatXml, &quot;qx&quot;) &amp;&amp;
+                XmlHelper::hasAttribute(rootQuatXml, &quot;qy&quot;) &amp;&amp;
+                XmlHelper::hasAttribute(rootQuatXml, &quot;qz&quot;))
+            {
 
-				return Ogre::Quaternion(
-					XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;qw&quot;),
-					XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;qx&quot;),
-					XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;qy&quot;),
-					XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;qz&quot;));
-			}
+                return Ogre::Quaternion(
+                    XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;qw&quot;),
+                    XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;qx&quot;),
+                    XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;qy&quot;),
+                    XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;qz&quot;));
+            }
 
-			// Durch axisX,axisY,axisZ,angle definiert
-			if (XmlHelper::hasAttribute(rootQuatXml, &quot;angle&quot;) &amp;&amp;
-				XmlHelper::hasAttribute(rootQuatXml, &quot;axisX&quot;) &amp;&amp; 
-				XmlHelper::hasAttribute(rootQuatXml, &quot;axisY&quot;) &amp;&amp; 
-				XmlHelper::hasAttribute(rootQuatXml, &quot;axisZ&quot;))
-			{
-				return Ogre::Quaternion(
-					Ogre::Degree(XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;angle&quot;)),
-					Ogre::Vector3(
-					XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;axisX&quot;),
-					XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;axisY&quot;),
-					XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;axisZ&quot;)));
-			}
+            // Durch axisX,axisY,axisZ,angle definiert
+            if (XmlHelper::hasAttribute(rootQuatXml, &quot;angle&quot;) &amp;&amp;
+                XmlHelper::hasAttribute(rootQuatXml, &quot;axisX&quot;) &amp;&amp;
+                XmlHelper::hasAttribute(rootQuatXml, &quot;axisY&quot;) &amp;&amp;
+                XmlHelper::hasAttribute(rootQuatXml, &quot;axisZ&quot;))
+            {
+                return Ogre::Quaternion(
+                    Ogre::Degree(XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;angle&quot;)),
+                    Ogre::Vector3(
+                    XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;axisX&quot;),
+                    XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;axisY&quot;),
+                    XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;axisZ&quot;)));
+            }
 
-			// Durch angleX,angleY,angleZ definiert
-			if (XmlHelper::hasAttribute(rootQuatXml, &quot;angleX&quot;) &amp;&amp; 
-				XmlHelper::hasAttribute(rootQuatXml, &quot;angleY&quot;) &amp;&amp; 
-				XmlHelper::hasAttribute(rootQuatXml, &quot;angleZ&quot;) )
-			{
-				Ogre::Matrix3 mat;
-				mat.FromEulerAnglesXYZ(
-					Degree(XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;angleX&quot;)),
-					Degree(XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;angleY&quot;)),
-					Degree(XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;angleZ&quot;)));
-				return Quaternion(mat);
-			}
-		}
-		catch(...) {}
+            // Durch angleX,angleY,angleZ definiert
+            if (XmlHelper::hasAttribute(rootQuatXml, &quot;angleX&quot;) &amp;&amp;
+                XmlHelper::hasAttribute(rootQuatXml, &quot;angleY&quot;) &amp;&amp;
+                XmlHelper::hasAttribute(rootQuatXml, &quot;angleZ&quot;) )
+            {
+                Ogre::Matrix3 mat;
+                mat.FromEulerAnglesXYZ(
+                    Degree(XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;angleX&quot;)),
+                    Degree(XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;angleY&quot;)),
+                    Degree(XmlHelper::getAttributeValueAsReal(rootQuatXml, &quot;angleZ&quot;)));
+                return Quaternion(mat);
+            }
+        }
+        catch(...) {}
 
         LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim &#220;bernehmen der Rotation! &quot;);
 
-		return Ogre::Quaternion::IDENTITY;
-	}
+        return Ogre::Quaternion::IDENTITY;
+    }
 
 
     void DotSceneLoader::warning(const XERCES_CPP_NAMESPACE::SAXParseException&amp; exc)
@@ -1133,14 +1150,14 @@
         const XERCES_CPP_NAMESPACE::SAXParseException&amp; exc) const
     {
         std::stringstream strs;
-        strs &lt;&lt; &quot;A&quot; &lt;&lt; type &lt;&lt; &quot; occured while parsing &quot; &lt;&lt; mSceneName 
+        strs &lt;&lt; &quot;A&quot; &lt;&lt; type &lt;&lt; &quot; occured while parsing &quot; &lt;&lt; mSceneName
              &lt;&lt; &quot; at line &quot; &lt;&lt; exc.getLineNumber() &lt;&lt; &quot; column &quot; &lt;&lt;  exc.getColumnNumber();
 
         if (exc.getSystemId() != NULL)
             strs &lt;&lt; &quot; with system &quot; &lt;&lt; XmlHelper::transcodeToStdString(exc.getSystemId());
         if (exc.getPublicId() != NULL)
             strs &lt;&lt; &quot; with public &quot; &lt;&lt; XmlHelper::transcodeToStdString(exc.getPublicId());
-    
+
         return strs.str();
     }
 }

Modified: rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -23,6 +23,7 @@
 #include &lt;OgreRoot.h&gt;
 #include &lt;OgreException.h&gt;
 
+#include &quot;CoreSubsystem.h&quot;
 #include &quot;ActorManager.h&quot;
 #include &quot;Actor.h&quot;
 #include &quot;PhysicsManager.h&quot;
@@ -58,19 +59,18 @@
             mCamera-&gt;setAutoAspectRatio(true);
 
             actor-&gt;placeIntoScene();
-            setActiveActor( actor );            
+            setActiveActor( actor );
         }
 
         // Ein Viewport, das komplette Fenster
-        Viewport* newVp = Ogre::Root::getSingletonPtr()-&gt;
-            getAutoCreatedWindow()-&gt;addViewport(mCamera, 1);
+        Viewport* newVp = CoreSubsystem::getSingleton().getRenderWindow()-&gt;addViewport(mCamera, 1);
 
         // Schwarzer Hintergrund
         newVp-&gt;setBackgroundColour(ColourValue(0,0,0));
     }
 
     void DotSceneOctreeWorld::loadScene(const String&amp; levelName, const String&amp; module)
-    {   
+    {
         // Alte Szene l&#246;schen
         clearScene();
 
@@ -86,7 +86,7 @@
             /// TODO - In den Sky-Sonnenpart verschieben
             mSceneMgr-&gt;setAmbientLight(ColourValue(0.55, 0.55, 0.55));
             mSceneFile = levelName;
-            
+
             DotSceneLoader* dot = NULL;
             try
             {
@@ -96,7 +96,7 @@
             }
             catch( ... )
             {
-                LOG_CRITICAL(Logger::CORE, 
+                LOG_CRITICAL(Logger::CORE,
                     &quot;Laden der Szenenbeschreibung aus '&quot; + mSceneFile + &quot;' ist fehlgeschlagen.&quot; );
                 delete dot;
             }
@@ -113,7 +113,7 @@
         fireBeforeClearScene();
 
         // This is necessary to destroy cameras too.
-        Ogre::Root::getSingleton().getAutoCreatedWindow()-&gt;removeAllViewports();
+        CoreSubsystem::getSingleton().getRenderWindow()-&gt;removeAllViewports();
         ActorManager::getSingleton().destroyAllActors();
         mSceneMgr-&gt;clearScene();
         PhysicsManager::getSingleton().clearLevelGeometry();

Modified: rl/trunk/engine/core/src/Makefile.am
===================================================================
--- rl/trunk/engine/core/src/Makefile.am	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/core/src/Makefile.am	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,3 +1,6 @@
+# Default values, if configuration file is missing (hard coded)
+AM_CPPFLAGS = -DRL_MODULEDIR=\&quot;$(RL_MODULEDIR)\&quot; -DOGRE_PLUGINDIR=\&quot;$(OGRE_PLUGINDIR)\&quot;
+
 INCLUDES = $(RUBY_CFLAGS) $(OGRE_CFLAGS) $(CEGUI_CFLAGS) $(STLPORT_CFLAGS) -I../include -I../../common/include -I../include/nulldriver
 
 lib_LTLIBRARIES = libRlCore.la

Modified: rl/trunk/engine/core/src/SoundDriver.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundDriver.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/core/src/SoundDriver.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -29,9 +29,9 @@
     mSoundSet(),
     mDefaultMusicVolume(40),
     mDefaultSoundVolume(100),
-	mMasterVolume(100)	
+    mMasterVolume(100)
 {
-	sSoundResourceManager = soundResourceManager;
+    sSoundResourceManager = soundResourceManager;
 }
 
 SoundDriver::~SoundDriver()
@@ -89,30 +89,53 @@
     mSoundSet.erase(sound);
 }
 
-/*
- * Die Konfiguration in Datei schreiben.
- * @author JoSch
- * @date 05-07-2006
- * @param conf Die Konfigurationdatei zum Schreiben.
- */
-void SoundDriver::saveConf(ConfigFile &amp;conf) const
-{
-	conf.setValue(getMasterVolume(), &quot;MasterVolume&quot;, &quot;General&quot;);
-	conf.setValue(getDefaultMusicVolume(), &quot;DefaultMusicVolume&quot;, &quot;General&quot;);
-	conf.setValue(getDefaultSoundVolume(), &quot;DefaultSoundVolume&quot;, &quot;General&quot;);
-}
+    Ogre::NameValuePairList SoundDriver::getSettings() const
+    {
+        Ogre::NameValuePairList SoundSettings;
 
-/*
- * Die Konfiguration lesen
- * @author JoSch
- * @date 05-07-2006
- * @param conf Die Konfigurationdatei, aus der gelesen werden soll
- */
-void SoundDriver::loadConf(ConfigFile &amp;conf)
-{
-	setMasterVolume(conf.getValue(Real(1.0), &quot;MasterVolume&quot;, &quot;General&quot;));
-	setDefaultMusicVolume(conf.getValue(Real(0.30), &quot;DefaultMusicVolume&quot;, &quot;General&quot;));
-	setDefaultSoundVolume(conf.getValue(Real(1.0), &quot;DefaultSoundVolume&quot;, &quot;General&quot;));
-}
+        // Append the settings to the list
+        SoundSettings.insert(make_pair(&quot;MasterVolume&quot;, Ogre::StringConverter::toString(mMasterVolume)));
+        SoundSettings.insert(make_pair(&quot;DefaultMusicVolume&quot;, Ogre::StringConverter::toString(mDefaultMusicVolume)));
+        SoundSettings.insert(make_pair(&quot;DefaultSoundVolume&quot;, Ogre::StringConverter::toString(mDefaultSoundVolume)));
 
+        return SoundSettings;
+    }
+
+    void SoundDriver::applySettings(const Ogre::NameValuePairList&amp; settings)
+    {
+        Ogre::NameValuePairList::const_iterator it;
+
+        // Set the Master volume
+        if ((it = settings.find(&quot;MasterVolume&quot;)) == settings.end())
+        {
+            // Set a sane default value
+            setMasterVolume(Real(1.0));
+        }
+        else
+        {
+            setMasterVolume(Ogre::StringConverter::parseReal(it-&gt;second));
+        }
+
+        // Set the Default Music Volume
+        if ((it = settings.find(&quot;DefaultMusicVolume&quot;)) == settings.end())
+        {
+            // Set a sane default value
+            setDefaultMusicVolume(Real(0.3));
+        }
+        else
+        {
+            setDefaultMusicVolume(Ogre::StringConverter::parseReal(it-&gt;second));
+        }
+
+        // Set the Default Sound Volume
+        if ((it = settings.find(&quot;DefaultSoundVolume&quot;)) == settings.end())
+        {
+            // Set a sane default value
+            setDefaultSoundVolume(Real(1.0));
+        }
+        else
+        {
+            setDefaultSoundVolume(Ogre::StringConverter::parseReal(it-&gt;second));
+        }
+    }
 }

Modified: rl/trunk/engine/core/src/SoundManager.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundManager.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/core/src/SoundManager.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -37,58 +37,56 @@
  * @date 04-26-2004
  */
 template&lt;&gt; rl::SoundManager* Singleton&lt;rl::SoundManager&gt;::ms_Singleton = 0;
- 
+
 namespace rl {
 
-/**
- * @return Eine Referenz auf das Singleton-Objekt.
- * @author JoSch
- * @date 04-26-2004
- */
-SoundManager&amp; SoundManager::getSingleton()
-{
-    return Singleton&lt;SoundManager&gt;::getSingleton();
-}
+    /**
+     * @return Eine Referenz auf das Singleton-Objekt.
+     * @author JoSch
+     * @date 04-26-2004
+     */
+    SoundManager&amp; SoundManager::getSingleton()
+    {
+        return Singleton&lt;SoundManager&gt;::getSingleton();
+    }
 
-/**
- * @return Ein Zeiger auf das Singleton-Objekt.
- * @author JoSch
- * @date 04-26-2004
- */
-SoundManager* SoundManager::getSingletonPtr()
-{
-    return Singleton&lt;SoundManager&gt;::getSingletonPtr();
-}
+    /**
+     * @return Ein Zeiger auf das Singleton-Objekt.
+     * @author JoSch
+     * @date 04-26-2004
+     */
+    SoundManager* SoundManager::getSingletonPtr()
+    {
+        return Singleton&lt;SoundManager&gt;::getSingletonPtr();
+    }
 
-/**
- * Standardkonstruktor
- * @author JoSch
- * @date 01-27-2005
- */
-SoundManager::SoundManager() 
-: ResourceManager(),
-  mDriverList(),
-  mActiveDriver(NULL),
-  mListenerActor(NULL),
-  mActiveListener(NULL)
-{
-	LOG_MESSAGE(Logger::CORE, &quot;Erzeuge Soundmanager...&quot;);
-	SoundDriver *driver = NULL;
-    mDriverList.clear();
-	NullDriver* nullDriver = new NullDriver(this);
-    registerDriver(nullDriver);
-    setActiveDriver(nullDriver);
+    /**
+     * Standardkonstruktor
+     * @author JoSch
+     * @date 01-27-2005
+     */
+    SoundManager::SoundManager()
+    : ResourceManager(),
+      mDriverList(),
+      mActiveDriver(NULL),
+      mListenerActor(NULL),
+      mActiveListener(NULL)
+    {
+        LOG_MESSAGE(Logger::CORE, &quot;Erzeuge Soundmanager...&quot;);
+        NullDriver* nullDriver = new NullDriver(this);
+        registerDriver(nullDriver);
+        setActiveDriver(nullDriver);
 
-    mResourceType = &quot;Sound&quot;;
-    ResourceGroupManager::getSingleton()._registerResourceManager(mResourceType, this);
+        mResourceType = &quot;Sound&quot;;
+        ResourceGroupManager::getSingleton()._registerResourceManager(mResourceType, this);
 
-}
+    }
 
-SoundManager::~SoundManager()
-{
-    ResourceGroupManager::getSingleton()._unregisterResourceManager(mResourceType);
-    unloadAllDrivers();    
-}
+    SoundManager::~SoundManager()
+    {
+        ResourceGroupManager::getSingleton()._unregisterResourceManager(mResourceType);
+        unloadAllDrivers();
+    }
 
 /**
  * Gibt die Suchmuster fuer die Extension zurueck.
@@ -101,7 +99,7 @@
     StringList result;
     result.push_back(&quot;*.ogg&quot;);
     result.push_back(&quot;*.wav&quot;);
-    
+
     return result;
 }
 
@@ -112,77 +110,67 @@
 * @date 06-18-2004
 */
 Resource* SoundManager::createImpl(
-	const String&amp; resName, 
-	ResourceHandle handle,
-	const String&amp; group,
-	bool isManual, 
-	ManualResourceLoader* loader, 
-	const NameValuePairList* loadParams)
+    const String&amp; resName,
+    ResourceHandle handle,
+    const String&amp; group,
+    bool isManual,
+    ManualResourceLoader* loader,
+    const NameValuePairList* loadParams)
 {
-	SoundResource *newSound = NULL;
-	newSound = new SoundResource(this, resName, handle, group, isManual, loader);
-	return newSound;
+    SoundResource *newSound = NULL;
+    newSound = new SoundResource(this, resName, handle, group, isManual, loader);
+    return newSound;
 }
 
 /**
- * @return Die Liste der funktionierenden Treiber.
- * @author JoSch
- * @date 12-23-2005
- */
-const DriverList&amp; SoundManager::getSoundDriverList() const
-{
-    return mDriverList;
-}
-
-/**
  * @param Der neue Treiber.
  * @author JoSch
  * @date 12-23-2005
  */
 void SoundManager::setActiveDriver(SoundDriver *driver)
 {
-	if (driver == NULL)
-	{
-		driver = getDriverByName(NullDriver::NAME);
-	}
+    if (driver == NULL)
+    {
+        driver = getDriverByName(NullDriver::NAME);
+    }
 
-	if (mActiveDriver == driver)
-	{
-	    LOG_DEBUG(Logger::CORE,
-			&quot;No need to change Sound Driver, &quot;
-			+ mActiveDriver-&gt;getName()
-			+ &quot; is already active.&quot;);
-	    return;
-	}
-	
-	LOG_MESSAGE(Logger::CORE,
-		&quot;Changing Sound Driver to &quot;
+    if (mActiveDriver == driver)
+    {
+        LOG_DEBUG(Logger::CORE,
+            &quot;No need to change Sound Driver, &quot;
+            + mActiveDriver-&gt;getName()
+            + &quot; is already active.&quot;);
+        return;
+    }
+
+    LOG_MESSAGE(Logger::CORE,
+        &quot;Changing Sound Driver to &quot;
          + driver-&gt;getName());
 
-	if (driver-&gt;initialize())
+    if (driver-&gt;initialize())
     {
-    	if (mActiveDriver != NULL)
-    	{
-	    	mActiveDriver-&gt;shutdown();
-	    	delete mActiveDriver;
-	    	mActiveDriver = NULL;
-    	}
-		mActiveDriver = driver;
+        if (mActiveDriver != NULL)
+        {
+            mActiveDriver-&gt;shutdown();
+            delete mActiveDriver;
+            mActiveDriver = NULL;
+        }
+        mActiveDriver = driver;
     }
     else
     {
-    	LOG_ERROR(
-    		Logger::CORE, 
-    		&quot;Sound driver &quot;
-    		+ driver-&gt;getName()
-    		+ &quot; had an error while initializing, keeping old driver.&quot;);
+        LOG_ERROR(
+            Logger::CORE,
+            &quot;Sound driver &quot;
+            + driver-&gt;getName()
+            + &quot; had an error while initializing, keeping old driver.&quot;);
     }
 }
 
 void SoundManager::_clearListenerActor()
 {
-	mActiveListener = NULL;
-	mListenerActor = NULL;
+    mActiveListener = NULL;
+    mListenerActor = NULL;
 }
 
 
@@ -208,18 +196,18 @@
 
 Actor* SoundManager::createListenerActor()
 {
-	if (mListenerActor == NULL)
-	{
-		if (mActiveListener != NULL)
-		{
-			mActiveListener-&gt;getListener()-&gt;setActive(false);
-		}
+    if (mListenerActor == NULL)
+    {
+        if (mActiveListener != NULL)
+        {
+            mActiveListener-&gt;getListener()-&gt;setActive(false);
+        }
 
-		mListenerActor = ActorManager::getSingleton().createListenerActor(&quot;SoundListenerObject&quot;);
-		mActiveListener = static_cast&lt;ListenerObject*&gt;(mListenerActor-&gt;getControlledObject());
-		mActiveListener-&gt;getListener()-&gt;setActive(true);
-	    return mListenerActor;
-	}
+        mListenerActor = ActorManager::getSingleton().createListenerActor(&quot;SoundListenerObject&quot;);
+        mActiveListener = static_cast&lt;ListenerObject*&gt;(mListenerActor-&gt;getControlledObject());
+        mActiveListener-&gt;getListener()-&gt;setActive(true);
+        return mListenerActor;
+    }
     else
     {
         Throw(IllegalStateException, &quot;ListenerActor already created.&quot;);
@@ -231,7 +219,7 @@
     return mListenerActor;
 }
 
-/** 
+/**
  * Hole einen Treiber durch Angabe seines Namens
  * @param name Der name des gesuchten Treibers.
  * @return Der gesuchte Treiber
@@ -240,118 +228,112 @@
  */
 SoundDriver *SoundManager::getDriverByName(const String &amp;name)
 {
-	DriverList::const_iterator it;
-	for(it = mDriverList.begin(); it != mDriverList.end(); it++)
-	{
-		if ((*it)-&gt;getName() == name)
-		{
-			return *it;
-		}
-	}
-	return 0;
+    DriverList::const_iterator it;
+    for(it = mDriverList.begin(); it != mDriverList.end(); it++)
+    {
+        if ((*it)-&gt;getName() == name)
+        {
+            return *it;
+        }
+    }
+    return 0;
 }
 
-void SoundManager::registerDriver(rl::SoundDriver *driver)
-{
-	mDriverList.push_back(driver);
-}
+    void SoundManager::registerDriver(rl::SoundDriver *driver)
+    {
+        mDriverList.push_back(driver);
+    }
 
-void SoundManager::unregisterDriver(rl::SoundDriver *driver)
-{
-	mDriverList.remove(driver);
-}
+    void SoundManager::unregisterDriver(rl::SoundDriver *driver)
+    {
+        mDriverList.remove(driver);
+    }
 
-/**
- * Hole die Soundkonfiguration
- * 
- * @author JoSch
- * @date 05-08-2006
- */
-void SoundManager::loadConf(const Ogre::String &amp;filename)
-{
-	ConfigFile conf;
-	conf.load(filename);
-	
-	mDrivers = conf.getValues(&quot;Driver&quot;, &quot;Drivers&quot;);
-	for (StringVector::const_iterator it = mDrivers.begin(); 
-		it != mDrivers.end(); it++)
-	{
-        try {
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-		    Ogre::Root::getSingleton().loadPlugin(*it);
-#else
-            Ogre::Root::getSingleton().loadPlugin(&quot;lib&quot;+*it);
-#endif
+    void SoundManager::applySettings(const Ogre::NameValuePairList&amp; settings)
+    {
+        // Get the sound driver
+        Ogre::NameValuePairList::const_iterator it = settings.find(&quot;Driver&quot;);
+        Ogre::String drivername;
+
+        if (it == settings.end())
+        {
+            drivername = &quot;RlFmod4Driver&quot;;
         }
+        else
+        {
+            drivername = it-&gt;second;
+        }
+
+        try
+        {
+            #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+            Ogre::Root::getSingleton().loadPlugin(drivername);
+            #else
+            Ogre::Root::getSingleton().loadPlugin(&quot;lib&quot; + drivername);
+            #endif
+        }
         catch(Ogre::Exception &amp;e)
         {
             LOG_MESSAGE(Logger::CORE,
                 CeGuiString(&quot;Soundtreiber kann nicht geladen werden: &quot;)
-                    + *it + &quot;\n&quot;
+                    + drivername + &quot;\n&quot;
                     + e.getFullDescription());
         }
         catch(...)
         {
             LOG_MESSAGE(Logger::CORE,
-                CeGuiString(&quot;Soundtreiber kann nicht geladen werden: &quot;)
-                    + *it);
+                 CeGuiString(&quot;Soundtreiber kann nicht geladen werden: &quot;)
+                    + drivername);
         }
-            
-	}
 
-	String drivername = conf.getValue(NullDriver::NAME, &quot;ActiveDriver&quot;, &quot;General&quot;);
-	SoundDriver *driver = getDriverByName(drivername);
-    if (driver == NULL)
-    {
-        driver = getDriverByName(NullDriver::NAME);
-    }
-	RlAssert(driver != NULL, &quot;Beim Laden des Treibers ist ein Fehler aufgetreten&quot;);
-	setActiveDriver(driver);
-	getActiveDriver()-&gt;loadConf(conf);
-}
+        SoundDriver *driver = getDriverByName(drivername);
 
-/**
- * Schreibe die Soundkonfiguration
- * @author JoSch
- * @date 05-08-2006
- * @param filename Der Dateiname der Konfiguration
- */
-void SoundManager::saveConf(const Ogre::String &amp;filename) const
-{
-	RlAssert(getActiveDriver() != NULL, &quot;Kein aktiver Soundtreiber&quot;);
-	ConfigFile conf;
-	conf.setValues(mDrivers, &quot;Driver&quot;, &quot;Drivers&quot;);
-	conf.setValue(String(getActiveDriver()-&gt;getName().c_str()), &quot;ActiveDriver&quot;, &quot;General&quot;);
-	getActiveDriver()-&gt;saveConf(conf);
-	conf.save(filename);
-}
+        if (driver == NULL)
+        {
+            driver = getDriverByName(NullDriver::NAME);
+        }
 
+        RlAssert(driver != NULL, &quot;Beim Laden des Treibers ist ein Fehler aufgetreten&quot;);
+        setActiveDriver(driver);
+        getActiveDriver()-&gt;applySettings(settings);
+    }
+
 void SoundManager::unloadAllDrivers()
 {
-   	if (mActiveDriver != NULL)
+       if (mActiveDriver != NULL)
     {
         mActiveDriver-&gt;shutdown();
         mActiveDriver = NULL;
     }
 
-	for(StringVector::iterator it = mDrivers.begin();
-		it != mDrivers.end(); it++)
-	{
-		Ogre::String driverPlugin = *it;
+    /**
+     * @ToDo: This is a hack to avoid the problem with the Null driver.
+     *        Don't know yet, why this happens.
+     */
+    DriverList::iterator it = mDriverList.begin();
+    it++;
+    /** Hack End **/
+    for(/*DriverList::iterator it = mDriverList.begin()*/; it != mDriverList.end(); it++)
+    {
+#       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+        Ogre::String driverPlugin = (*it)-&gt;getName();
+#       else
+        Ogre::String driverPlugin = &quot;lib&quot; + (*it)-&gt;getName();
+#       endif
 
-		LOG_MESSAGE(Logger::CORE,
-			&quot;Unloading sound driver DLL &quot;
-			+ driverPlugin);
+        LOG_MESSAGE(Logger::CORE,
+            &quot;Unloading sound driver DLL &quot;
+            + driverPlugin);
 
-		Ogre::Root::getSingleton().unloadPlugin(driverPlugin);
+        Ogre::Root::getSingleton().unloadPlugin(driverPlugin);
 
-		LOG_MESSAGE(Logger::CORE,
-			&quot;Sound driver DLL &quot;
-			+ driverPlugin
-			+ &quot; successfully unloaded.&quot;);
-	}
+        LOG_MESSAGE(Logger::CORE,
+            &quot;Sound driver DLL &quot;
+            + driverPlugin
+            + &quot; successfully unloaded.&quot;);
+    }
 
-	mDriverList.clear();
+    mDriverList.clear();
 }
 
 /**

Modified: rl/trunk/engine/core/src/nulldriver/NullDriver.cpp
===================================================================
--- rl/trunk/engine/core/src/nulldriver/NullDriver.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/core/src/nulldriver/NullDriver.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -22,7 +22,7 @@
 {
 Ogre::String NullDriver::NAME = &quot;NullDriver&quot;;
 
-/** 
+/**
  * Konstruktor
  * @author JoSch
  * @date 12-23-2005
@@ -32,7 +32,7 @@
 {
 }
 
-/** 
+/**
  * Destruktor
  * @author JoSch
  * @date 12-23-2005
@@ -41,7 +41,7 @@
 {
 }
 
-/** 
+/**
  * Zeigt an, ob der Treiber funktionsf&#239;&#191;&#189;hig ist.
  * @return Immer TRUE.
  * @author JoSch
@@ -52,17 +52,17 @@
     return true;
 }
 
-/** 
+/**
  * Starte den Nulltreiber und mache alle Initialisierung.
  * @author JoSch
  * @date 12-23-2005
  */
 bool NullDriver::initialize()
 {
-	return true;
+    return true;
 }
 
-/** 
+/**
  * Beeende den Nulltreiber und gib alle Resourcen frei.
  * @author JoSch
  * @date 12-23-2005
@@ -71,7 +71,7 @@
 {
 }
 
-/** 
+/**
  * Gibt den Anzeigename des Treiber zur&#239;&#191;&#189;ck.
  * @return Anzeigename
  * @author JoSch
@@ -89,9 +89,9 @@
  */
  void NullDriver::update()
  {
- 	// Erstmal nichts zu tun.
+     // Erstmal nichts zu tun.
  }
- 
+
  /**
   * Einen Sound-Stream mit Resource erzeugen
   * @return Der erzeugte Stream
@@ -101,8 +101,8 @@
   */
 Sound *NullDriver::createStream(const SoundResourcePtr &amp;res)
 {
- 	Sound *sound = new NullSound(res);
- 	return sound;
+     Sound *sound = new NullSound(res);
+     return sound;
 }
 
 /**
@@ -114,8 +114,8 @@
  */
 Sound *NullDriver::createSample(const SoundResourcePtr &amp;res)
 {
- 	Sound *sound = new NullSound(res);
- 	return sound;
+     Sound *sound = new NullSound(res);
+     return sound;
 }
 
 /**
@@ -131,38 +131,13 @@
     return listener;
 }
 
-
-/*
- * Die Konfiguration in Datei schreiben.
- * @author JoSch
- * @date 05-07-2006
- * @param conf Die Konfigurationdatei zum Schreiben.
- */
-void NullDriver::saveConf(ConfigFile &amp;conf) const
-{
-	SoundDriver::saveConf(conf);
-    // DO NOTHING
-}
-
-/*
- * Die Konfiguration lesen
- * @author JoSch
- * @date 05-07-2006
- * @param conf Die Konfigurationdatei, aus der gelesen werden soll
- */
-void NullDriver::loadConf(ConfigFile &amp;conf)
-{
-	SoundDriver::loadConf(conf);
-    // DO NOTHING
-}
-
 void NullDriver::setRolloffFactor(const Ogre::Real&amp;)
 {
 }
 
 const Ogre::Real NullDriver::getRolloffFactor()
 {
-	return 1.0;
+    return 1.0;
 }
 
 }

Modified: rl/trunk/engine/startup/src/RastullahMain.cpp
===================================================================
--- rl/trunk/engine/startup/src/RastullahMain.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/startup/src/RastullahMain.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -14,7 +14,7 @@
 *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
 */
 
-#include &lt;xercesc/util/XMemory.hpp&gt;	// Muss vor Ogre stehen (zumindest fuer VS)
+#include &lt;xercesc/util/XMemory.hpp&gt;    // Muss vor Ogre stehen (zumindest fuer VS)
 
 #include &lt;OgreLogManager.h&gt;
 #include &lt;stdexcept&gt;
@@ -34,184 +34,185 @@
 #include &lt;CEGUIExceptions.h&gt;
 
 #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-	#define WIN32_LEAN_AND_MEAN
-	#include &lt;windows.h&gt;
+    #define WIN32_LEAN_AND_MEAN
+    #include &lt;windows.h&gt;
     #include &lt;shellapi.h&gt;
 #endif
 
 void startupRl(bool developerMode, Ogre::String module)
 {
-	rl::CoreSubsystem* core = NULL;
-	rl::RulesSubsystem* rules = NULL;
-	rl::DialogSubsystem* dialog = NULL;
-	rl::AiSubsystem* ai = NULL;
-	rl::UiSubsystem* ui =  NULL;
-	rl::ScriptSubsystem* script =  NULL;
-	rl::Logger* logger = NULL;
+    rl::CoreSubsystem* core = NULL;
+    rl::RulesSubsystem* rules = NULL;
+    rl::DialogSubsystem* dialog = NULL;
+    rl::AiSubsystem* ai = NULL;
+    rl::UiSubsystem* ui =  NULL;
+    rl::ScriptSubsystem* script =  NULL;
+    rl::Logger* logger = NULL;
 
 #ifndef _DEBUG
-	try {
+    try {
 #endif // #ifndef _DEBUG
         rl::ConfigurationManager::getSingleton().loadConfig();
 
-		logger = new rl::Logger(
-			rl::ConfigurationManager::getSingleton().getRastullahLogDirectory(),
-			rl::ConfigurationManager::getSingleton().getOgreLogFile(),
-			rl::ConfigurationManager::getSingleton().getRastullahLogFile());
+        logger = new rl::Logger(
+            rl::ConfigurationManager::getSingleton().getRastullahLogDirectory(),
+            rl::ConfigurationManager::getSingleton().getOgreLogFile(),
+            rl::ConfigurationManager::getSingleton().getRastullahLogFile());
         // @todo in ConfigDatei auslagern/ oder auch Parameter
 
-		rl::Logger::getSingleton().setLogDetail(
-			rl::ConfigurationManager::getSingleton().getLogLevel());
+        rl::Logger::getSingleton().setLogDetail(
+            rl::ConfigurationManager::getSingleton().getLogLevel());
 
-		core = new rl::CoreSubsystem();
-		core-&gt;setDeveloperMode(developerMode);
+        core = new rl::CoreSubsystem();
+        core-&gt;setDeveloperMode(developerMode);
         LOG_MESSAGE_SHORT(&quot;CoreSubsystem gestartet&quot;);
 
-		rules = new rl::RulesSubsystem();
-		LOG_MESSAGE_SHORT(&quot;RulesSubsystem gestartet&quot;);
+        rules = new rl::RulesSubsystem();
+        LOG_MESSAGE_SHORT(&quot;RulesSubsystem gestartet&quot;);
 
-		dialog = new rl::DialogSubsystem();
-		LOG_MESSAGE_SHORT(&quot;DialogSubsystem gestartet&quot;);
+        dialog = new rl::DialogSubsystem();
+        LOG_MESSAGE_SHORT(&quot;DialogSubsystem gestartet&quot;);
 
-		ai = new rl::AiSubsystem();
-		LOG_MESSAGE_SHORT(&quot;AiSubsystem gestartet&quot;);
+        ai = new rl::AiSubsystem();
+        LOG_MESSAGE_SHORT(&quot;AiSubsystem gestartet&quot;);
 
-		ui = new rl::UiSubsystem();
-		LOG_MESSAGE_SHORT(&quot;UiSubsystem gestartet&quot;);
+        ui = new rl::UiSubsystem();
+        LOG_MESSAGE_SHORT(&quot;UiSubsystem gestartet&quot;);
 
-		script = new rl::ScriptSubsystem();
-		LOG_MESSAGE_SHORT(&quot;ScriptSubsystem gestartet&quot;);
+        script = new rl::ScriptSubsystem();
+        LOG_MESSAGE_SHORT(&quot;ScriptSubsystem gestartet&quot;);
 
 
-		LOG_MESSAGE_SHORT(&quot;Starte...&quot;);
-		if (module != &quot;&quot;)
-			core-&gt;setDefaultActiveModule(module);
+        LOG_MESSAGE_SHORT(&quot;Starte...&quot;);
+        if (module != &quot;&quot;)
+            core-&gt;setDefaultActiveModule(module);
 
-		core-&gt;startCore();
+        core-&gt;startCore();
 
 
 #ifndef _DEBUG
-	}
-	catch(Ogre::Exception&amp; oe) {
-		rl::showError(oe.getFullDescription());
-	}
-	catch(rl::Exception&amp; re) {
-		rl::showError(re.toString());
-	}
-	catch(CEGUI::Exception&amp; ce) {
-		rl::showError(ce.getMessage().c_str());
-	}
-	catch(fs::filesystem_error&amp; fe) {
-		rl::showError(fe.what());
-	}
-	catch(std::runtime_error&amp; rte) {
-		rl::showError(rte.what());
-	}
-	catch(std::exception&amp; exp) {
-		rl::showError( exp.what() );
-	}
-	catch(std::string&amp; err) {
-		rl::showError( err );
-	}
-	catch(...) {
-		rl::showError( &quot;Unknown exception occured&quot; );
-	}
+    }
+    catch(Ogre::Exception&amp; oe) {
+        rl::showError(oe.getFullDescription());
+    }
+    catch(rl::Exception&amp; re) {
+        rl::showError(re.toString());
+    }
+    catch(CEGUI::Exception&amp; ce) {
+        rl::showError(ce.getMessage().c_str());
+    }
+    catch(fs::filesystem_error&amp; fe) {
+        rl::showError(fe.what());
+    }
+    catch(std::runtime_error&amp; rte) {
+        rl::showError(rte.what());
+    }
+    catch(std::exception&amp; exp) {
+        rl::showError( exp.what() );
+    }
+    catch(std::string&amp; err) {
+        rl::showError( err );
+    }
+    catch(...) {
+        rl::showError( &quot;Unknown exception occured&quot; );
+    }
 
 
-	try
+    try
     {
 #endif // #ifndef _DEBUG
-        LOG_MESSAGE_SHORT(&quot;Soundkonfiguration gespeichert&quot;);
+        // Save the configuration to disk
+        rl::ConfigurationManager::getSingleton().saveConfig();
+        LOG_MESSAGE_SHORT(&quot;Configuration file saved&quot;);
 
-		delete script;
-		delete ui;
-		delete ai;
-		delete dialog;
-		delete rules;
-		delete core;
-
+        delete script;
+        delete ui;
+        delete ai;
+        delete dialog;
+        delete rules;
+        delete core;
         delete logger;
 #ifndef _DEBUG
-	}
-	catch(Ogre::Exception&amp; oe) {
-		rl::showError(oe.getFullDescription());
-	}
-	catch(rl::Exception&amp; re) {
-		rl::showError(re.toString());
-	}
-	catch(std::runtime_error&amp; rte) {
-		rl::showError(rte.what());
-	}
-	catch(std::exception&amp; exp) {
-		rl::showError( exp.what() );
-	}
-	catch(std::string&amp; err) {
-		rl::showError( err );
-	}
-	catch(...) {
-		rl::showError( &quot;Unknown exception occured&quot; );
-	}
+    }
+    catch(Ogre::Exception&amp; oe) {
+        rl::showError(oe.getFullDescription());
+    }
+    catch(rl::Exception&amp; re) {
+        rl::showError(re.toString());
+    }
+    catch(std::runtime_error&amp; rte) {
+        rl::showError(rte.what());
+    }
+    catch(std::exception&amp; exp) {
+        rl::showError( exp.what() );
+    }
+    catch(std::string&amp; err) {
+        rl::showError( err );
+    }
+    catch(...) {
+        rl::showError( &quot;Unknown exception occured&quot; );
+    }
 #endif //#ifndef _DEBUG
 
 }
 
 void analyzeParameters(int argc, char** argv, bool&amp; developerMode, Ogre::String&amp; startModule)
 {
-	developerMode = false;
-	startModule = &quot;&quot;;
+    developerMode = false;
+    startModule = &quot;&quot;;
 
-	for (int argIdx = 0; argIdx &lt; argc; argIdx++)
-	{
-		if (strncmp(argv[argIdx], &quot;--dev&quot;, 5) == 0)
-			developerMode = true;
-		else if (strncmp(argv[argIdx], &quot;--module&quot;, 8) == 0
-				&amp;&amp; argc &gt; argIdx + 1) // N&#195;&#164;chster Parameter existiert
-			startModule = argv[argIdx + 1];
-	}
+    for (int argIdx = 0; argIdx &lt; argc; argIdx++)
+    {
+        if (strncmp(argv[argIdx], &quot;--dev&quot;, 5) == 0)
+            developerMode = true;
+        else if (strncmp(argv[argIdx], &quot;--module&quot;, 8) == 0
+                &amp;&amp; argc &gt; argIdx + 1) // N&#195;&#164;chster Parameter existiert
+            startModule = argv[argIdx + 1];
+    }
 }
 
 #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
 
 INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
 {
-	int argc;
-	LPWSTR* argList = CommandLineToArgvW(GetCommandLineW(), &amp;argc);
-	char** argv = new char*[argc];
-	for (int argIdx = 0; argIdx &lt; argc; argIdx++)
-	{
-		int len = wcslen(argList[argIdx])+1;
-		argv[argIdx] = new char[len];
-		wcstombs(argv[argIdx], argList[argIdx], len);
-		argv[argIdx][len-1] = '\0';
-	}
+    int argc;
+    LPWSTR* argList = CommandLineToArgvW(GetCommandLineW(), &amp;argc);
+    char** argv = new char*[argc];
+    for (int argIdx = 0; argIdx &lt; argc; argIdx++)
+    {
+        int len = wcslen(argList[argIdx])+1;
+        argv[argIdx] = new char[len];
+        wcstombs(argv[argIdx], argList[argIdx], len);
+        argv[argIdx][len-1] = '\0';
+    }
 
-	bool developer;
-	Ogre::String module;
-	analyzeParameters(argc, argv, developer, module);
+    bool developer;
+    Ogre::String module;
+    analyzeParameters(argc, argv, developer, module);
 
-	for (int argIdx = 0; argIdx &lt; argc; argIdx++)
-	{
-		delete[] argv[argIdx];
-	}
-	delete[] argv;
-	LocalFree(argList);
+    for (int argIdx = 0; argIdx &lt; argc; argIdx++)
+    {
+        delete[] argv[argIdx];
+    }
+    delete[] argv;
+    LocalFree(argList);
 
     startupRl(developer, module);
 
-	return 0;
+    return 0;
 }
 
 #else // if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
 
 int main(int argc, char **argv)
 {
-	bool developer;
-	Ogre::String module;
+    bool developer;
+    Ogre::String module;
 
-	analyzeParameters(argc, argv, developer, module);
+    analyzeParameters(argc, argv, developer, module);
     startupRl(developer, module);
 
-	return 0;
+    return 0;
 }
 
 #endif

Modified: rl/trunk/engine/ui/include/CommandMapper.h
===================================================================
--- rl/trunk/engine/ui/include/CommandMapper.h	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/ui/include/CommandMapper.h	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -23,79 +23,78 @@
 
 namespace rl {
 
-	enum MovementState
-	{
-		MOVE_NONE = 0,
-		MOVE_LEFT = 1&lt;&lt;0,
-		MOVE_RIGHT = 1&lt;&lt;1,
-		MOVE_FORWARD = 1&lt;&lt;2,
-		MOVE_BACKWARD = 1&lt;&lt;3,
-		TURN_LEFT = 1&lt;&lt;4,
-		TURN_RIGHT = 1&lt;&lt;5,
-		MOVE_RUN = 1&lt;&lt;6,
-		MOVE_SNEAK = 1&lt;&lt;7,
-		MOVE_JUMP = 1&lt;&lt;8,
-		MOVE_RUN_LOCK = 1&lt;&lt;9
-	};
+    enum MovementState
+    {
+        MOVE_NONE = 0,
+        MOVE_LEFT = 1&lt;&lt;0,
+        MOVE_RIGHT = 1&lt;&lt;1,
+        MOVE_FORWARD = 1&lt;&lt;2,
+        MOVE_BACKWARD = 1&lt;&lt;3,
+        TURN_LEFT = 1&lt;&lt;4,
+        TURN_RIGHT = 1&lt;&lt;5,
+        MOVE_RUN = 1&lt;&lt;6,
+        MOVE_SNEAK = 1&lt;&lt;7,
+        MOVE_JUMP = 1&lt;&lt;8,
+        MOVE_RUN_LOCK = 1&lt;&lt;9
+    };
 
-	enum MapType
-	{
-		CMDMAP_KEYMAP_IN_COMBAT,
-		CMDMAP_KEYMAP_OFF_COMBAT,
-		CMDMAP_KEYMAP_MOVEMENT,
+    enum MapType
+    {
+        CMDMAP_KEYMAP_IN_COMBAT,
+        CMDMAP_KEYMAP_OFF_COMBAT,
+        CMDMAP_KEYMAP_MOVEMENT,
         CMDMAP_KEYMAP_GLOBAL,
-		CMDMAP_MOUSEMAP_IN_COMBAT,
-		CMDMAP_MOUSEMAP_OFF_COMBAT
-	};
+        CMDMAP_MOUSEMAP_IN_COMBAT,
+        CMDMAP_MOUSEMAP_OFF_COMBAT
+    };
 
-	const int CMDMAP_NO_MAPPING = -9999999;
+    const int CMDMAP_NO_MAPPING = -9999999;
 
-	class _RlUiExport CommandMapper
-	{
-	public:
+    class _RlUiExport CommandMapper
+    {
+    public:
 
-		CommandMapper();
-		~CommandMapper();
+        CommandMapper();
+        ~CommandMapper();
 
-		void loadCommandMap(const Ogre::String&amp; mapfile);
-		void saveCommandMap(const Ogre::String&amp; mapfile) const;
+        void buildCommandMapping(const Ogre::NameValuePairList&amp; keylist);
 
-		void setMapping(MapType map, int code, const CeGuiString&amp; actionName);
+        void setMapping(MapType map, int code, const CeGuiString&amp; actionName);
 
-		int getMapping(MapType map, const CeGuiString&amp; actionName);
+        int getMapping(MapType map, const CeGuiString&amp; actionName);
 
-		std::map&lt;CeGuiString, MovementState&gt; getMovements();
+        std::map&lt;CeGuiString, MovementState&gt; getMovements();
 
-		static int encodeKey(int scancode, int syskeys);
-		static void decodeKey(int combinedKeyCode, int* scancode, int* syskeys);
+        static int encodeKey(int scancode, int syskeys);
+        static void decodeKey(int combinedKeyCode, int* scancode, int* syskeys);
 
-		const MovementState getMovement(int keycode) const;
+        const MovementState getMovement(int keycode) const;
 
-		// Finde die der Taste oder dem Mausbutton zugeordneten Aktion in der 
-		// angegebenen CommandMap
-		const CeGuiString&amp; getAction(int keyCodeOrMouseButton, MapType mapType);
+        // Finde die der Taste oder dem Mausbutton zugeordneten Aktion in der
+        // angegebenen CommandMap
+        const CeGuiString&amp; getAction(int keyCodeOrMouseButton, MapType mapType);
 
-	private:
+    private:
 
-		// KeyCode -&gt; Name
-		typedef std::map&lt;int, CeGuiString &gt; KeyAndMouseCommandMap;
-		typedef std::map&lt;int, MovementState&gt; MovementCommandMap;
+        // KeyCode -&gt; Name
+        typedef std::map&lt;int, CeGuiString &gt; KeyAndMouseCommandMap;
+        typedef std::map&lt;int, MovementState&gt; MovementCommandMap;
 
-		MovementCommandMap mMovementCommands;
-		KeyAndMouseCommandMap mKeyCommandsInCombat;
-		KeyAndMouseCommandMap mKeyCommandsOffCombat;
+        MovementCommandMap mMovementCommands;
+        KeyAndMouseCommandMap mKeyCommandsInCombat;
+        KeyAndMouseCommandMap mKeyCommandsOffCombat;
         KeyAndMouseCommandMap mKeyCommandsGlobal;
-		KeyAndMouseCommandMap mMouseCommandsInCombat;
-		KeyAndMouseCommandMap mMouseCommandsOffCombat;
+        KeyAndMouseCommandMap mMouseCommandsInCombat;
+        KeyAndMouseCommandMap mMouseCommandsOffCombat;
 
-		std::map&lt;CeGuiString, MovementState&gt; mMovement;
+        std::map&lt;CeGuiString, MovementState&gt; mMovement;
 
-		KeyAndMouseCommandMap* getCommandMap(MapType mapType);
-		int getKeyCode(const Ogre::String&amp; keyDescription);
-		int getMouseButtonCode(int buttonNum);
-		int getMouseButtonCode(const Ogre::String&amp; buttonDescription);
-		MovementState getMovement(const Ogre::String&amp; movementDescription);
-	};
+        KeyAndMouseCommandMap* getCommandMap(MapType mapType);
+        int getKeyCode(const Ogre::String&amp; keyDescription);
+        int getMouseButtonCode(int buttonNum);
+        int getMouseButtonCode(const Ogre::String&amp; buttonDescription);
+        MovementState getMovement(const Ogre::String&amp; movementDescription);
+    };
 
 }
 

Modified: rl/trunk/engine/ui/include/InputManager.h
===================================================================
--- rl/trunk/engine/ui/include/InputManager.h	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/ui/include/InputManager.h	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -33,24 +33,24 @@
 #include &lt;OgreMemoryMacros.h&gt;
 
 namespace CEGUI {
-	enum MouseButton;
+    enum MouseButton;
 }
 
 namespace rl {
 
-	class CeGuiWindow;
-	class GameObject;
-	class CharacterController;
+    class CeGuiWindow;
+    class GameObject;
+    class CharacterController;
     class CommandMapper;
 
     class _RlUiExport InputManager
-        :	public Ogre::Singleton&lt;InputManager&gt;, 
+        :    public Ogre::Singleton&lt;InputManager&gt;,
             public GameTask,
-            public OIS::KeyListener, 
+            public OIS::KeyListener,
             public OIS::MouseListener
     {
     public:
-		InputManager(Ogre::RenderWindow* window);
+        InputManager(Ogre::RenderWindow* window);
         ~InputManager();
 
         static InputManager &amp; getSingleton(void);
@@ -71,15 +71,15 @@
         virtual bool mousePressed(const OIS::MouseEvent &amp; arg, OIS::MouseButtonID id);
         virtual bool mouseReleased(const OIS::MouseEvent &amp; arg, OIS::MouseButtonID id);
         virtual bool mouseMoved(const OIS::MouseEvent &amp;arg);
-		virtual bool keyPressed(const OIS::KeyEvent &amp;arg);
-		virtual bool keyReleased(const OIS::KeyEvent &amp;arg);
+        virtual bool keyPressed(const OIS::KeyEvent &amp;arg);
+        virtual bool keyReleased(const OIS::KeyEvent &amp;arg);
 
         CeGuiString getKeyName(int scancode, int syskeys);
         CeGuiString getKeyName(int combinedKeyCode);
         int getScanCode(const CeGuiString&amp; name);
         int getSystemCode(const CeGuiString&amp; name);
         void loadKeyMapping(const Ogre::String&amp; filename);
-        void loadCommandMapping(const Ogre::String&amp; filename);
+        void buildCommandMapping(const Ogre::NameValuePairList&amp; keylist);
         typedef std::map&lt;int, CEGUI::utf8&gt; KeyCharMap;
         typedef std::map&lt;int, CeGuiString&gt; KeyNameMap;
 
@@ -98,7 +98,7 @@
         int getModifierCode() const;
         const CEGUI::utf8&amp; getKeyChar(int keycode, int modifiers) const;
 
-		Ogre::Vector3 mSavedMouseState;
+        Ogre::Vector3 mSavedMouseState;
 
         OIS::Mouse* mMouse;
         OIS::Keyboard* mKeyboard;

Modified: rl/trunk/engine/ui/src/CommandMapper.cpp
===================================================================
--- rl/trunk/engine/ui/src/CommandMapper.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/ui/src/CommandMapper.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -28,95 +28,95 @@
 
 namespace rl {
 
-	CommandMapper::CommandMapper()
-	    : mMovementCommands(),
-		  mKeyCommandsInCombat(),
-		  mKeyCommandsOffCombat(),
+    CommandMapper::CommandMapper()
+        : mMovementCommands(),
+          mKeyCommandsInCombat(),
+          mKeyCommandsOffCombat(),
           mKeyCommandsGlobal(),
-		  mMouseCommandsInCombat(),
-		  mMouseCommandsOffCombat()
-	{
-	}
+          mMouseCommandsInCombat(),
+          mMouseCommandsOffCombat()
+    {
+    }
 
-	CommandMapper::~CommandMapper()
-	{
-	}
+    CommandMapper::~CommandMapper()
+    {
+    }
 
-	const CeGuiString&amp; CommandMapper::getAction(int keyCodeOrMouseButton, MapType mapType)
-	{
-		KeyAndMouseCommandMap* commandMap = getCommandMap(mapType);
+    const CeGuiString&amp; CommandMapper::getAction(int keyCodeOrMouseButton, MapType mapType)
+    {
+        KeyAndMouseCommandMap* commandMap = getCommandMap(mapType);
 
-		KeyAndMouseCommandMap::const_iterator command = commandMap-&gt;find(keyCodeOrMouseButton);
+        KeyAndMouseCommandMap::const_iterator command = commandMap-&gt;find(keyCodeOrMouseButton);
 
-		if (command != commandMap-&gt;end())
-		{
-			return (*command).second;
-		}
+        if (command != commandMap-&gt;end())
+        {
+            return (*command).second;
+        }
 
-		static CeGuiString NO_ACTION = &quot;&quot;;
-		return NO_ACTION;
-	}
+        static CeGuiString NO_ACTION = &quot;&quot;;
+        return NO_ACTION;
+    }
 
 
-	void CommandMapper::setMapping(
-			MapType mapType,
-			int code,
-			const CeGuiString&amp; actionName)
-	{
-		getCommandMap(mapType)-&gt;insert(make_pair(code, actionName));
-	}
+    void CommandMapper::setMapping(
+            MapType mapType,
+            int code,
+            const CeGuiString&amp; actionName)
+    {
+        getCommandMap(mapType)-&gt;insert(make_pair(code, actionName));
+    }
 
-	CommandMapper::KeyAndMouseCommandMap* CommandMapper::getCommandMap(MapType mapType)
-	{
-		KeyAndMouseCommandMap* commandMap;
+    CommandMapper::KeyAndMouseCommandMap* CommandMapper::getCommandMap(MapType mapType)
+    {
+        KeyAndMouseCommandMap* commandMap;
 
-		if (mapType == CMDMAP_KEYMAP_OFF_COMBAT)
-			commandMap = &mKeyCommandsOffCombat;
-		else if (mapType == CMDMAP_KEYMAP_IN_COMBAT)
-			commandMap = &mKeyCommandsInCombat;
-		else if (mapType == CMDMAP_KEYMAP_GLOBAL)
-			commandMap = &mKeyCommandsGlobal;
-		else if (mapType == CMDMAP_MOUSEMAP_OFF_COMBAT)
-			commandMap = &mMouseCommandsOffCombat;
-		else if (mapType == CMDMAP_MOUSEMAP_IN_COMBAT)
-			commandMap = &mMouseCommandsInCombat;
-		else
-			Throw(RuntimeException, &quot;Unknown command map&quot;);
+        if (mapType == CMDMAP_KEYMAP_OFF_COMBAT)
+            commandMap = &mKeyCommandsOffCombat;
+        else if (mapType == CMDMAP_KEYMAP_IN_COMBAT)
+            commandMap = &mKeyCommandsInCombat;
+        else if (mapType == CMDMAP_KEYMAP_GLOBAL)
+            commandMap = &mKeyCommandsGlobal;
+        else if (mapType == CMDMAP_MOUSEMAP_OFF_COMBAT)
+            commandMap = &mMouseCommandsOffCombat;
+        else if (mapType == CMDMAP_MOUSEMAP_IN_COMBAT)
+            commandMap = &mMouseCommandsInCombat;
+        else
+            Throw(RuntimeException, &quot;Unknown command map&quot;);
 
-		return commandMap;
-	}
+        return commandMap;
+    }
 
-	int CommandMapper::getMapping(
-			MapType mapType,
-			const CeGuiString&amp; actionName)
-	{
-		if (mapType == CMDMAP_KEYMAP_MOVEMENT)
-		{
-			return 0;
-		}
+    int CommandMapper::getMapping(
+            MapType mapType,
+            const CeGuiString&amp; actionName)
+    {
+        if (mapType == CMDMAP_KEYMAP_MOVEMENT)
+        {
+            return 0;
+        }
 
-		KeyAndMouseCommandMap* commandMap = getCommandMap(mapType);
+        KeyAndMouseCommandMap* commandMap = getCommandMap(mapType);
 
-		for (KeyAndMouseCommandMap::iterator command = commandMap-&gt;begin();
-				command != commandMap-&gt;end(); command++)
-		{
-			CeGuiString name = (*command).second;
-			if (name.compare(actionName) == 0)
-				return (*command).first;
-		}
+        for (KeyAndMouseCommandMap::iterator command = commandMap-&gt;begin();
+                command != commandMap-&gt;end(); command++)
+        {
+            CeGuiString name = (*command).second;
+            if (name.compare(actionName) == 0)
+                return (*command).first;
+        }
 
-		return CMDMAP_NO_MAPPING;
-	}
+        return CMDMAP_NO_MAPPING;
+    }
 
-	int CommandMapper::encodeKey(int scancode, int syskeys)
-	{
+    int CommandMapper::encodeKey(int scancode, int syskeys)
+    {
         return scancode | syskeys &lt;&lt; 16;
-	}
+    }
 
-	void CommandMapper::decodeKey(int combinedKeyCode, int* scancode, int* syskeys)
-	{
-		int syskeysTmp = combinedKeyCode &gt;&gt; 16;
-		int scancodeTmp = combinedKeyCode &amp; ~(syskeysTmp &lt;&lt; 16);
+    void CommandMapper::decodeKey(int combinedKeyCode, int* scancode, int* syskeys)
+    {
+        int syskeysTmp = combinedKeyCode &gt;&gt; 16;
+        int scancodeTmp = combinedKeyCode &amp; ~(syskeysTmp &lt;&lt; 16);
 
         if (syskeys != NULL)
         {
@@ -124,182 +124,195 @@
         }
         if (scancode != NULL)
         {
-		    *scancode = scancodeTmp;
+            *scancode = scancodeTmp;
         }
-	}
+    }
 
-	const MovementState CommandMapper::getMovement(int keycode) const
-	{
-		MovementCommandMap::const_iterator mvcmd = mMovementCommands.find(keycode);
+    const MovementState CommandMapper::getMovement(int keycode) const
+    {
+        MovementCommandMap::const_iterator mvcmd = mMovementCommands.find(keycode);
 
-		if (mvcmd == mMovementCommands.end())
-		{
-			return MOVE_NONE;
-		}
-		else
-		{
-			return (*mvcmd).second;
-		}
-	}
+        if (mvcmd == mMovementCommands.end())
+        {
+            return MOVE_NONE;
+        }
+        else
+        {
+            return (*mvcmd).second;
+        }
+    }
 
-	void CommandMapper::loadCommandMap(const Ogre::String&amp; mapfile)
-	{
-		ConfigFile* cfg = new ConfigFile();
-		cfg-&gt;load(mapfile);
+    void CommandMapper::buildCommandMapping(const Ogre::NameValuePairList&amp; keylist)
+    {
+        /** @Todo: Replace this with something not static */
+        mMovementCommands[InputManager::getSingleton().getScanCode(&quot;Q&quot;)] = getMovement(&quot;turn_left&quot;);
+        mMovementCommands[InputManager::getSingleton().getScanCode(&quot;E&quot;)] = getMovement(&quot;turn_right&quot;);
+        mMovementCommands[InputManager::getSingleton().getScanCode(&quot;W&quot;)] = getMovement(&quot;forward&quot;);
+        mMovementCommands[InputManager::getSingleton().getScanCode(&quot;S&quot;)] = getMovement(&quot;backward&quot;);
+        mMovementCommands[InputManager::getSingleton().getScanCode(&quot;A&quot;)] = getMovement(&quot;left&quot;);
+        mMovementCommands[InputManager::getSingleton().getScanCode(&quot;D&quot;)] = getMovement(&quot;right&quot;);
+        mMovementCommands[InputManager::getSingleton().getScanCode(&quot;Leertaste&quot;)] = getMovement(&quot;jump&quot;);
 
-		for (ConfigFile::SettingsIterator it = cfg-&gt;getSettingsIterator(&quot;Movement&quot;);
-			it.hasMoreElements();)
-		{
-			String key = it.peekNextKey();
-			String setting = it.getNext();
+        mKeyCommandsGlobal[getKeyCode(&quot;Ctrl+X&quot;)] = CeGuiString(&quot;quitgame&quot;);
+        mKeyCommandsGlobal[getKeyCode(&quot;F10&quot;)] = CeGuiString(&quot;toggleingameglobalmenu&quot;);
+        mKeyCommandsGlobal[getKeyCode(&quot;I&quot;)] = CeGuiString(&quot;toggleinventorywindow&quot;);
+        mKeyCommandsGlobal[getKeyCode(&quot;J&quot;)] = CeGuiString(&quot;showjournalwindow&quot;);
+        mKeyCommandsGlobal[getKeyCode(&quot;C&quot;)] = CeGuiString(&quot;showcharactersheet&quot;);
+        mKeyCommandsGlobal[getKeyCode(&quot;O&quot;)] = CeGuiString(&quot;togglecharacterstatewindow&quot;);
 
-			mMovementCommands[InputManager::getSingleton().getScanCode(key)] = getMovement(setting);
-			LOG_MESSAGE(Logger::UI,
-				Ogre::String(&quot;Key &quot;) + key	+ &quot; (&quot;
-				+ StringConverter::toString(InputManager::getSingleton().getScanCode(key))
-				+ &quot;) is assigned to movement &quot;	+ setting+&quot; (&quot;
-				+ StringConverter::toString(getMovement(setting))+&quot;)&quot;);
-		}
+        /*
+        for (ConfigFile::SettingsIterator it = cfgfile-&gt;getSettingsIterator(&quot;Movement&quot;);
+            it.hasMoreElements();)
+        {
+            String key = it.peekNextKey();
+            String setting = it.getNext();
 
-        for (ConfigFile::SettingsIterator it = cfg-&gt;getSettingsIterator(&quot;Global keys&quot;);
-			it.hasMoreElements();)
-		{
-			String key = it.peekNextKey();
-			String setting = it.getNext();
+            mMovementCommands[InputManager::getSingleton().getScanCode(key)] = getMovement(setting);
+            LOG_MESSAGE(Logger::UI,
+                Ogre::String(&quot;Key &quot;) + key    + &quot; (&quot;
+                + StringConverter::toString(InputManager::getSingleton().getScanCode(key))
+                + &quot;) is assigned to movement &quot;    + setting+&quot; (&quot;
+                + StringConverter::toString(getMovement(setting))+&quot;)&quot;);
+        }
 
-			mKeyCommandsGlobal[getKeyCode(key)] = CeGuiString(setting);
-			LOG_MESSAGE(Logger::UI,
-				Ogre::String(&quot;Key &quot;) + key	+ &quot; (&quot; + StringConverter::toString(getKeyCode(key))
-				+ &quot;) is assigned to command &quot; + setting+&quot; globally&quot;);
-		}
+        for (ConfigFile::SettingsIterator it = cfgfile-&gt;getSettingsIterator(&quot;Global keys&quot;);
+            it.hasMoreElements();)
+        {
+            String key = it.peekNextKey();
+            String setting = it.getNext();
 
-		for (ConfigFile::SettingsIterator it = cfg-&gt;getSettingsIterator(&quot;Keys off combat&quot;);
-			it.hasMoreElements();)
-		{
-			String key = it.peekNextKey();
-			String setting = it.getNext();
+            mKeyCommandsGlobal[getKeyCode(key)] = CeGuiString(setting);
+            LOG_MESSAGE(Logger::UI,
+                Ogre::String(&quot;Key &quot;) + key    + &quot; (&quot; + StringConverter::toString(getKeyCode(key))
+                + &quot;) is assigned to command &quot; + setting+&quot; globally&quot;);
+        }
 
-			mKeyCommandsOffCombat[getKeyCode(key)] = CeGuiString(setting);
-			LOG_MESSAGE(Logger::UI,
-				Ogre::String(&quot;Key &quot;) + key	+ &quot; (&quot; + StringConverter::toString(getKeyCode(key))
-				+ &quot;) is assigned to command &quot; + setting+&quot; while not in combat&quot;);
-		}
+        for (ConfigFile::SettingsIterator it = cfgfile-&gt;getSettingsIterator(&quot;Keys off combat&quot;);
+            it.hasMoreElements();)
+        {
+            String key = it.peekNextKey();
+            String setting = it.getNext();
 
-		for (ConfigFile::SettingsIterator it = cfg-&gt;getSettingsIterator(&quot;Keys in combat&quot;);
-			it.hasMoreElements();)
-		{
-			String key = it.peekNextKey();
-			String setting = it.getNext();
+            mKeyCommandsOffCombat[getKeyCode(key)] = CeGuiString(setting);
+            LOG_MESSAGE(Logger::UI,
+                Ogre::String(&quot;Key &quot;) + key    + &quot; (&quot; + StringConverter::toString(getKeyCode(key))
+                + &quot;) is assigned to command &quot; + setting+&quot; while not in combat&quot;);
+        }
 
-			mKeyCommandsInCombat[getKeyCode(key)] = CeGuiString(setting);
-			LOG_MESSAGE(Logger::UI,
-				Ogre::String(&quot;Key &quot;) + key	+ &quot; (&quot; + StringConverter::toString(getKeyCode(key))
-				+ &quot;) is assigned to command &quot; + setting+&quot; while in combat&quot;);
-		}
+        for (ConfigFile::SettingsIterator it = cfgfile-&gt;getSettingsIterator(&quot;Keys in combat&quot;);
+            it.hasMoreElements();)
+        {
+            String key = it.peekNextKey();
+            String setting = it.getNext();
 
-		for (ConfigFile::SettingsIterator it = cfg-&gt;getSettingsIterator(&quot;Mouse off combat&quot;);
-			it.hasMoreElements();)
-		{
-			String key = it.peekNextKey();
-			String setting = it.getNext();
+            mKeyCommandsInCombat[getKeyCode(key)] = CeGuiString(setting);
+            LOG_MESSAGE(Logger::UI,
+                Ogre::String(&quot;Key &quot;) + key    + &quot; (&quot; + StringConverter::toString(getKeyCode(key))
+                + &quot;) is assigned to command &quot; + setting+&quot; while in combat&quot;);
+        }
 
-			mMouseCommandsOffCombat[getMouseButtonCode(key)] = CeGuiString(setting);
-			LOG_MESSAGE(Logger::UI,
-				Ogre::String(&quot;Mouse Button &quot;) + key	+ &quot; (&quot; + StringConverter::toString(getMouseButtonCode(key))
-				+ &quot;) is assigned to command &quot; + setting+&quot; while not in combat&quot;);
-		}
+        for (ConfigFile::SettingsIterator it = cfgfile-&gt;getSettingsIterator(&quot;Mouse off combat&quot;);
+            it.hasMoreElements();)
+        {
+            String key = it.peekNextKey();
+            String setting = it.getNext();
 
-		for (ConfigFile::SettingsIterator it = cfg-&gt;getSettingsIterator(&quot;Mouse in combat&quot;);
-			it.hasMoreElements();)
-		{
-			String key = it.peekNextKey();
-			String setting = it.getNext();
+            mMouseCommandsOffCombat[getMouseButtonCode(key)] = CeGuiString(setting);
+            LOG_MESSAGE(Logger::UI,
+                Ogre::String(&quot;Mouse Button &quot;) + key    + &quot; (&quot; + StringConverter::toString(getMouseButtonCode(key))
+                + &quot;) is assigned to command &quot; + setting+&quot; while not in combat&quot;);
+        }
 
-			mMouseCommandsInCombat[getMouseButtonCode(key)] = CeGuiString(setting);
-			LOG_MESSAGE(Logger::UI,
-				Ogre::String(&quot;Mouse Button &quot;) + key	+ &quot; (&quot; + StringConverter::toString(getMouseButtonCode(key))
-				+ &quot;) is assigned to command &quot; + setting+&quot; while in combat&quot;);
-		}
+        for (ConfigFile::SettingsIterator it = cfgfile-&gt;getSettingsIterator(&quot;Mouse in combat&quot;);
+            it.hasMoreElements();)
+        {
+            String key = it.peekNextKey();
+            String setting = it.getNext();
 
-		delete cfg;
-	}
+            mMouseCommandsInCombat[getMouseButtonCode(key)] = CeGuiString(setting);
+            LOG_MESSAGE(Logger::UI,
+                Ogre::String(&quot;Mouse Button &quot;) + key    + &quot; (&quot; + StringConverter::toString(getMouseButtonCode(key))
+                + &quot;) is assigned to command &quot; + setting+&quot; while in combat&quot;);
+        }
+        */
+    }
 
-	int CommandMapper::getKeyCode(const Ogre::String &amp;keyDescription)
-	{
-		StringVector parts = StringUtil::split(keyDescription, &quot;+&quot;);
+    int CommandMapper::getKeyCode(const Ogre::String &amp;keyDescription)
+    {
+        StringVector parts = StringUtil::split(keyDescription, &quot;+&quot;);
 
-		int modifiers = 0;
-		for(size_t i = 0; i&lt;parts.size()-1; i++)
-		{
-			modifiers |= InputManager::getSingleton().getSystemCode(parts[i]);
-		}
+        int modifiers = 0;
+        for(size_t i = 0; i&lt;parts.size()-1; i++)
+        {
+            modifiers |= InputManager::getSingleton().getSystemCode(parts[i]);
+        }
 
-		return encodeKey(InputManager::getSingleton().getScanCode(parts[parts.size()-1]), modifiers);
-	}
+        return encodeKey(InputManager::getSingleton().getScanCode(parts[parts.size()-1]), modifiers);
+    }
 
-	int CommandMapper::getMouseButtonCode(int buttonNum)
-	{
-		return buttonNum;
-	}
+    int CommandMapper::getMouseButtonCode(int buttonNum)
+    {
+        return buttonNum;
+    }
 
-	int CommandMapper::getMouseButtonCode(const Ogre::String &amp;buttonDescription)
-	{
-		StringVector parts = StringUtil::split(buttonDescription, &quot;+&quot;);
+    int CommandMapper::getMouseButtonCode(const Ogre::String &amp;buttonDescription)
+    {
+        StringVector parts = StringUtil::split(buttonDescription, &quot;+&quot;);
 
-		int modifiers = 0;
-		for(size_t i = 0; i&lt;parts.size()-1; i++)
-		{
-			modifiers |= InputManager::getSingleton().getSystemCode(parts[i]);
-		}
+        int modifiers = 0;
+        for(size_t i = 0; i&lt;parts.size()-1; i++)
+        {
+            modifiers |= InputManager::getSingleton().getSystemCode(parts[i]);
+        }
 
-		int buttonNum = StringConverter::parseInt(parts[parts.size()-1].substr(6));
-		return encodeKey(getMouseButtonCode(buttonNum), modifiers);
-	}
+        int buttonNum = StringConverter::parseInt(parts[parts.size()-1].substr(6));
+        return encodeKey(getMouseButtonCode(buttonNum), modifiers);
+    }
 
-	MovementState CommandMapper::getMovement(const Ogre::String &amp;movementDescription)
-	{
-		if (movementDescription == &quot;left&quot;)
-		{
-			return MOVE_LEFT;
-		}
-		else if (movementDescription == &quot;right&quot;)
-		{
-			return MOVE_RIGHT;
-		}
-		else if (movementDescription == &quot;forward&quot;)
-		{
-			return MOVE_FORWARD;
-		}
-		else if (movementDescription == &quot;backward&quot;)
-		{
-			return MOVE_BACKWARD;
-		}
-		else if (movementDescription == &quot;turn_left&quot;)
-		{
-			return TURN_LEFT;
-		}
-		else if (movementDescription == &quot;turn_right&quot;)
-		{
-			return TURN_RIGHT;
-		}
-		else if (movementDescription == &quot;run&quot;)
-		{
-			return MOVE_RUN;
-		}
-		else if (movementDescription == &quot;sneak&quot;)
-		{
-			return MOVE_SNEAK;
-		}
-		else if (movementDescription == &quot;jump&quot;)
-		{
-			return MOVE_JUMP;
-		}
-		else if (movementDescription == &quot;run_lock&quot;)
-		{
-			return MOVE_RUN_LOCK;
-		}
+    MovementState CommandMapper::getMovement(const Ogre::String &amp;movementDescription)
+    {
+        if (movementDescription == &quot;left&quot;)
+        {
+            return MOVE_LEFT;
+        }
+        else if (movementDescription == &quot;right&quot;)
+        {
+            return MOVE_RIGHT;
+        }
+        else if (movementDescription == &quot;forward&quot;)
+        {
+            return MOVE_FORWARD;
+        }
+        else if (movementDescription == &quot;backward&quot;)
+        {
+            return MOVE_BACKWARD;
+        }
+        else if (movementDescription == &quot;turn_left&quot;)
+        {
+            return TURN_LEFT;
+        }
+        else if (movementDescription == &quot;turn_right&quot;)
+        {
+            return TURN_RIGHT;
+        }
+        else if (movementDescription == &quot;run&quot;)
+        {
+            return MOVE_RUN;
+        }
+        else if (movementDescription == &quot;sneak&quot;)
+        {
+            return MOVE_SNEAK;
+        }
+        else if (movementDescription == &quot;jump&quot;)
+        {
+            return MOVE_JUMP;
+        }
+        else if (movementDescription == &quot;run_lock&quot;)
+        {
+            return MOVE_RUN_LOCK;
+        }
 
-		return MOVE_NONE;
-	}
+        return MOVE_NONE;
+    }
 }
 

Modified: rl/trunk/engine/ui/src/DebugWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DebugWindow.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/ui/src/DebugWindow.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -33,38 +33,38 @@
 
 template&lt;&gt; rl::DebugWindow* Ogre::Singleton&lt;rl::DebugWindow&gt;::ms_Singleton = 0;
 
-namespace rl 
+namespace rl
 {
   DebugWindow&amp; DebugWindow::getSingleton(void)
     {
         return Ogre::Singleton&lt;DebugWindow&gt;::getSingleton();
     }
-	DebugWindow* DebugWindow::getSingletonPtr(void)
+    DebugWindow* DebugWindow::getSingletonPtr(void)
     {
         return Ogre::Singleton&lt;DebugWindow&gt;::getSingletonPtr();
     }
 
-	DebugWindow::DebugWindow() : CeGuiWindow(&quot;debugwindow.xml&quot;, WND_SHOW),
+    DebugWindow::DebugWindow() : CeGuiWindow(&quot;debugwindow.xml&quot;, WND_SHOW),
           mMessageText(),
           mPageCaption(),
           mPageText(),
           mPageTexts(),
           mCurrentPage(StringUtil::BLANK),
           mDebugPageName(&quot;General Informations&quot;)
-	{
-		mPageCaption = getWindow(&quot;DebugWindow/PageCaption&quot;);
-		mPageCaption-&gt;moveToFront();
+    {
+        mPageCaption = getWindow(&quot;DebugWindow/PageCaption&quot;);
+        mPageCaption-&gt;moveToFront();
 
-		mPageText = getMultiLineEditbox(&quot;DebugWindow/PageText&quot;);
+        mPageText = getMultiLineEditbox(&quot;DebugWindow/PageText&quot;);
 
-		mMessageText = getWindow(&quot;DebugWindow/MessageText&quot;);
-		mMessageText-&gt;moveToFront();
+        mMessageText = getWindow(&quot;DebugWindow/MessageText&quot;);
+        mMessageText-&gt;moveToFront();
 
-		bindCloseToCloseButton();
+        bindCloseToCloseButton();
         registerPage(&quot;General Informations&quot;);
-	}
+    }
 
-	DebugWindow::~DebugWindow()
+    DebugWindow::~DebugWindow()
     {
         unregisterPage(&quot;General Informations&quot;);
     }
@@ -123,7 +123,7 @@
             updatePageText();
         }
     }
-    
+
     void DebugWindow::setMessageText(const Ogre::String&amp; text)
     {
         CeGuiString o(text.c_str());
@@ -132,7 +132,7 @@
 
     void DebugWindow::showNextPage()
     {
-        PageTextMap::iterator it = mPageTexts.find(mCurrentPage);        
+        PageTextMap::iterator it = mPageTexts.find(mCurrentPage);
         if (it != mPageTexts.end())
         {
             ++it;
@@ -149,10 +149,10 @@
         }
     }
 
-	void DebugWindow::run(Ogre::Real elapsedTime)
-	{
-		updateFps();
-	}
+    void DebugWindow::run(Ogre::Real elapsedTime)
+    {
+        updateFps();
+    }
 
     void DebugWindow::updatePageText()
     {
@@ -162,62 +162,62 @@
         mPageText-&gt;setText(text);
     }
 
-	void DebugWindow::updateFps()
-	{
-		const RenderTarget::FrameStats&amp; stats = Root::getSingleton().getAutoCreatedWindow()-&gt;getStatistics();
+    void DebugWindow::updateFps()
+    {
+        const RenderTarget::FrameStats&amp; stats = CoreSubsystem::getSingleton().getRenderWindow()-&gt;getStatistics();
 
-		Ogre::String textSt = &quot;Current FPS: &quot; + 
-			StringConverter::toString(stats.lastFPS)+
-			&quot;\nBest/worst/avg FPS: &quot; + 
-			StringConverter::toString(stats.bestFPS) + &quot;/&quot; + 
-			StringConverter::toString(stats.worstFPS) + &quot;/&quot; + 
-			StringConverter::toString(stats.avgFPS)+
-			&quot;\nBest/worst Frame times: &quot; + 
-			StringConverter::toString(stats.bestFPS) + &quot;/&quot; + 
-			StringConverter::toString(stats.worstFPS)+
-			&quot;\nTriangle Count: &quot; + 
-			StringConverter::toString(stats.triangleCount);
+        Ogre::String textSt = &quot;Current FPS: &quot; +
+            StringConverter::toString(stats.lastFPS)+
+            &quot;\nBest/worst/avg FPS: &quot; +
+            StringConverter::toString(stats.bestFPS) + &quot;/&quot; +
+            StringConverter::toString(stats.worstFPS) + &quot;/&quot; +
+            StringConverter::toString(stats.avgFPS)+
+            &quot;\nBest/worst Frame times: &quot; +
+            StringConverter::toString(stats.bestFPS) + &quot;/&quot; +
+            StringConverter::toString(stats.worstFPS)+
+            &quot;\nTriangle Count: &quot; +
+            StringConverter::toString(stats.triangleCount);
 
-		if (UiSubsystem::getSingleton().getActiveCharacter() != NULL &amp;&amp; 
-			UiSubsystem::getSingleton().getActiveCharacter()-&gt;getActor() != NULL)
-		{
+        if (UiSubsystem::getSingleton().getActiveCharacter() != NULL &amp;&amp;
+            UiSubsystem::getSingleton().getActiveCharacter()-&gt;getActor() != NULL)
+        {
             ActorControlledObject* charObj = UiSubsystem::getSingletonPtr()-&gt;
-				getActiveCharacter()-&gt;getActor()-&gt;getControlledObject();
+                getActiveCharacter()-&gt;getActor()-&gt;getControlledObject();
 
             if( charObj != NULL )
             {
-			    Ogre::Vector3 pos = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;getWorldPosition();
+                Ogre::Vector3 pos = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;getWorldPosition();
 
-			    textSt += &quot;\nPlayer Position [ &quot;
-				    + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;
-				    + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+&quot;, &quot;
-				    + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+&quot; ]&quot;;
+                textSt += &quot;\nPlayer Position [ &quot;
+                    + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;
+                    + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+&quot;, &quot;
+                    + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+&quot; ]&quot;;
             }
-		}
+        }
 
         Actor* camActor = ActorManager::getSingleton().getActor(&quot;DefaultCamera&quot;);
-		if( camActor != 0 &amp;&amp; camActor-&gt;_getSceneNode() != NULL )
-		{
-			Ogre::Camera* cam = dynamic_cast&lt;CameraObject*&gt;(camActor-&gt;getControlledObject())-&gt;getCamera();
+        if( camActor != 0 &amp;&amp; camActor-&gt;_getSceneNode() != NULL )
+        {
+            Ogre::Camera* cam = dynamic_cast&lt;CameraObject*&gt;(camActor-&gt;getControlledObject())-&gt;getCamera();
             Ogre::Vector3 pos = cam-&gt;getDerivedPosition();
 
-			textSt += &quot;\nCamera Position [ &quot;
-				+ StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;
-				+ StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+&quot;, &quot;
-				+ StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+&quot; ]&quot;;
-		}
+            textSt += &quot;\nCamera Position [ &quot;
+                + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;
+                + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+&quot;, &quot;
+                + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+&quot; ]&quot;;
+        }
 
         setPageText(mDebugPageName, textSt);
-	}
+    }
 
-	void DebugWindow::setVisible(bool visible, bool destroyAfterHide)
-	{
-		CeGuiWindow::setVisible(visible, destroyAfterHide);
-		if (visible)
+    void DebugWindow::setVisible(bool visible, bool destroyAfterHide)
+    {
+        CeGuiWindow::setVisible(visible, destroyAfterHide);
+        if (visible)
             GameLoop::getSingleton().addTask(this, GameLoop::TG_GRAPHICS);
-		else
-			GameLoop::getSingleton().removeTask(this);
-	}
+        else
+            GameLoop::getSingleton().removeTask(this);
+    }
 
     const Ogre::String&amp; DebugWindow::getName() const
     {

Modified: rl/trunk/engine/ui/src/DialogCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogCharacterController.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/ui/src/DialogCharacterController.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,7 +1,7 @@
 /*
 * This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Perl Artistic License.
 *
@@ -43,126 +43,126 @@
 
 namespace rl {
 
-	DialogCharacterController::DialogCharacterController(Actor* camera, Actor* character)
-		: CharacterController(camera, character),
-		mTargetCameraPosition(Vector3::ZERO),
+    DialogCharacterController::DialogCharacterController(Actor* camera, Actor* character)
+        : CharacterController(camera, character),
+        mTargetCameraPosition(Vector3::ZERO),
         mTargetCameraDirection(Vector3::UNIT_Z),
-		mCurrFadeTextTime(0),
+        mCurrFadeTextTime(0),
         mTotalFadeTextTime(0),
         mText(),
         mDialogMode(DM_FRONT),
         mTextShown(false),
-		mDialogWindow(NULL),
-		mSubtitleWindow(NULL),
-		mSoundObject(NULL),
-		mTalkAnimation(NULL),
+        mDialogWindow(NULL),
+        mSubtitleWindow(NULL),
+        mSoundObject(NULL),
+        mTalkAnimation(NULL),
         mSubtitleSpeed(1.0f)
-	{
-		mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
-		mCharacterActor-&gt;getPhysicalThing()-&gt;freeze();		
-		Camera* ogreCam = static_cast&lt;Camera*&gt;(mCameraActor-&gt;_getMovableObject());
-		ogreCam-&gt;setFixedYawAxis(true);
-		ogreCam-&gt;setPosition(Vector3::ZERO);	
-		ogreCam-&gt;setOrientation(Quaternion::IDENTITY);
-		mCameraActor-&gt;_getSceneNode()-&gt;setFixedYawAxis(true);
+    {
+        mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
+        mCharacterActor-&gt;getPhysicalThing()-&gt;freeze();
+        Camera* ogreCam = static_cast&lt;Camera*&gt;(mCameraActor-&gt;_getMovableObject());
+        ogreCam-&gt;setFixedYawAxis(true);
+        ogreCam-&gt;setPosition(Vector3::ZERO);
+        ogreCam-&gt;setOrientation(Quaternion::IDENTITY);
+        mCameraActor-&gt;_getSceneNode()-&gt;setFixedYawAxis(true);
 
-        mSubtitleSpeed = ConfigurationManager::getSingleton().getRealSetting( &quot;subtitle_speed&quot;, 1.0 );
-	}
+        mSubtitleSpeed = ConfigurationManager::getSingleton().getRealSetting(ConfigurationManager::CS_GENERAL, &quot;Subtitle Speed&quot;);
+    }
 
-	DialogCharacterController::~DialogCharacterController()
-	{
-		mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
-		mCharacterActor-&gt;getPhysicalThing()-&gt;unfreeze();
-		if (mDialogWindow != NULL)
-		{
+    DialogCharacterController::~DialogCharacterController()
+    {
+        mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
+        mCharacterActor-&gt;getPhysicalThing()-&gt;unfreeze();
+        if (mDialogWindow != NULL)
+        {
             mDialogWindow-&gt;setVisible(false, true);
-			mDialogWindow = NULL;
-		}
-		if (mSubtitleWindow != NULL)
-		{
+            mDialogWindow = NULL;
+        }
+        if (mSubtitleWindow != NULL)
+        {
             mSubtitleWindow-&gt;setVisible(false, true);
-			mSubtitleWindow = NULL;
-		}
-		delete mSoundObject;
-	}
+            mSubtitleWindow = NULL;
+        }
+        delete mSoundObject;
+    }
 
-	CharacterController::ControllerType DialogCharacterController::getType() const
-	{
-		return CTRL_DIALOG;
-	}
+    CharacterController::ControllerType DialogCharacterController::getType() const
+    {
+        return CTRL_DIALOG;
+    }
 
-	void DialogCharacterController::setDialogPartner(Actor* partner)
-	{
-		mDialogPartner = partner;
-		resetCamera();
-	}
+    void DialogCharacterController::setDialogPartner(Actor* partner)
+    {
+        mDialogPartner = partner;
+        resetCamera();
+    }
 
-	void DialogCharacterController::run(Real elapsedTime)
-	{
-		if( elapsedTime &lt;= 0.0 )
-			return;
+    void DialogCharacterController::run(Real elapsedTime)
+    {
+        if( elapsedTime &lt;= 0.0 )
+            return;
 
-		// Aktuellen Abstand zur gew&#252;nschten Position berechnen
-		Vector3 posDistance = (mTargetCameraPosition - mCameraActor-&gt;_getSceneNode()-&gt;getPosition());
-		// Ist eine Anpassung n&#246;tig?
-		if( posDistance != Vector3::ZERO )
-		{
-			// Die Kameraanpassgeschwindigkeit
-			Real speed = 1/elapsedTime;
-			mCameraActor-&gt;setPosition(mTargetCameraPosition);					
-		}
+        // Aktuellen Abstand zur gew&#252;nschten Position berechnen
+        Vector3 posDistance = (mTargetCameraPosition - mCameraActor-&gt;_getSceneNode()-&gt;getPosition());
+        // Ist eine Anpassung n&#246;tig?
+        if( posDistance != Vector3::ZERO )
+        {
+            // Die Kameraanpassgeschwindigkeit
+            Real speed = 1/elapsedTime;
+            mCameraActor-&gt;setPosition(mTargetCameraPosition);
+        }
 
         mCameraActor-&gt;setOrientation( Quaternion::IDENTITY );
         mCameraActor-&gt;_getSceneNode()-&gt;setDirection( mTargetCameraDirection );
         mCameraActor-&gt;_getSceneNode()-&gt;_update( true, false );
 
-		// Textanzeigedauer
-		if (mCurrFadeTextTime &gt;= 0)
-		{
-			mCurrFadeTextTime -= elapsedTime;
-		}
+        // Textanzeigedauer
+        if (mCurrFadeTextTime &gt;= 0)
+        {
+            mCurrFadeTextTime -= elapsedTime;
+        }
 
-		if (mTextShown &amp;&amp; mCurrFadeTextTime &lt;= 0)
-		{
-			mCurrFadeTextTime = 0;
+        if (mTextShown &amp;&amp; mCurrFadeTextTime &lt;= 0)
+        {
+            mCurrFadeTextTime = 0;
             mTotalFadeTextTime = 0;
-			mTextShown = false;
-   			if (mSoundObject)
+            mTextShown = false;
+               if (mSoundObject)
             {
                 mSoundObject-&gt;stop();
             }
-			mSubtitleWindow-&gt;setVisible(false);
-			mDialogWindow-&gt;textFinished();
-		}
+            mSubtitleWindow-&gt;setVisible(false);
+            mDialogWindow-&gt;textFinished();
+        }
 
-        LOG_DEBUG(Logger::UI, 
-				StringConverter::toString(mSubtitleWindow-&gt;getWindow()-&gt;getEffectiveAlpha())
-				+ &quot;: &quot;
-				+ mSubtitleWindow-&gt;getText()
-				+ CeGuiString(mSubtitleWindow-&gt;getWindow()-&gt;isVisible() ? &quot;vis&quot; : &quot;unvis&quot;)
-				+ &quot;, Time: &quot;
-				+ StringConverter::toString(mCurrFadeTextTime));
-	}
+        LOG_DEBUG(Logger::UI,
+                StringConverter::toString(mSubtitleWindow-&gt;getWindow()-&gt;getEffectiveAlpha())
+                + &quot;: &quot;
+                + mSubtitleWindow-&gt;getText()
+                + CeGuiString(mSubtitleWindow-&gt;getWindow()-&gt;isVisible() ? &quot;vis&quot; : &quot;unvis&quot;)
+                + &quot;, Time: &quot;
+                + StringConverter::toString(mCurrFadeTextTime));
+    }
 
-	void DialogCharacterController::setDialogWindow(DialogWindow* dialog)
-	{
-		mDialogWindow = dialog;
-	}
+    void DialogCharacterController::setDialogWindow(DialogWindow* dialog)
+    {
+        mDialogWindow = dialog;
+    }
 
-	void DialogCharacterController::setSubtitleWindow(SubtitleWindow* subtitles)
-	{
-		mSubtitleWindow = subtitles;
-	}
+    void DialogCharacterController::setSubtitleWindow(SubtitleWindow* subtitles)
+    {
+        mSubtitleWindow = subtitles;
+    }
 
-	void DialogCharacterController::toggleViewMode()
-	{
-		/// @todo Krasser Gesichtszoom? Halbtotale... usw?
-	}
+    void DialogCharacterController::toggleViewMode()
+    {
+        /// @todo Krasser Gesichtszoom? Halbtotale... usw?
+    }
 
-	void DialogCharacterController::resetCamera()
-	{
-		recalculateCamera( mDialogPartner, mCharacterActor );
-	}
+    void DialogCharacterController::resetCamera()
+    {
+        recalculateCamera( mDialogPartner, mCharacterActor );
+    }
 
     void DialogCharacterController::recalculateCamera( Actor* speaker, Actor* listener )
     {
@@ -173,55 +173,55 @@
         {
             MeshObject* mo = dynamic_cast&lt;MeshObject*&gt;(speaker-&gt;getControlledObject());
             Ogre::AxisAlignedBox aab = mo-&gt;getDefaultSize();
-            Vector3 offset( 
-                aab.getCenter().x, 
-                aab.getMaximum().y*0.933, 
+            Vector3 offset(
+                aab.getCenter().x,
+                aab.getMaximum().y*0.933,
                 aab.getCenter().z );
             charEyes += speaker-&gt;getWorldOrientation()*offset;
-        }        
+        }
 
-        Vector3 partEyes = listener-&gt;getWorldPosition();        
+        Vector3 partEyes = listener-&gt;getWorldPosition();
         // Modify by MeshBounds
         if( listener-&gt;getControlledObject()-&gt;isMeshObject() )
         {
             MeshObject* mo = dynamic_cast&lt;MeshObject*&gt;(listener-&gt;getControlledObject());
             Ogre::AxisAlignedBox aab = mo-&gt;getDefaultSize();
-            Vector3 offset( 
-                aab.getCenter().x, 
-                aab.getMaximum().y*0.933, 
+            Vector3 offset(
+                aab.getCenter().x,
+                aab.getMaximum().y*0.933,
                 aab.getCenter().z );
             partEyes += listener-&gt;getWorldOrientation()*offset;
         }
 
-		Vector3 globalCameraPosition = ( charEyes + partEyes ) / 2.0f;
+        Vector3 globalCameraPosition = ( charEyes + partEyes ) / 2.0f;
 
-		// Weltkoordinaten in lokale umwandeln
-		mTargetCameraPosition = 
-			-1*(mCameraActor-&gt;_getSceneNode()-&gt;getParentSceneNode()-&gt;getWorldOrientation().Inverse()*
-			(mCameraActor-&gt;_getSceneNode()-&gt;getParentSceneNode()-&gt;getWorldPosition() - globalCameraPosition));
+        // Weltkoordinaten in lokale umwandeln
+        mTargetCameraPosition =
+            -1*(mCameraActor-&gt;_getSceneNode()-&gt;getParentSceneNode()-&gt;getWorldOrientation().Inverse()*
+            (mCameraActor-&gt;_getSceneNode()-&gt;getParentSceneNode()-&gt;getWorldPosition() - globalCameraPosition));
 
 
         mTargetCameraDirection = ( partEyes - mTargetCameraPosition ).normalisedCopy();
     }
 
-	float DialogCharacterController::getShowTextLength(const CeGuiString&amp; text) const
-	{
-		return 0.019f * text.length() + // Zeit f&#252;rs Text lesen
-			   0.25f;                   // Fade in
-	}
+    float DialogCharacterController::getShowTextLength(const CeGuiString&amp; text) const
+    {
+        return 0.019f * text.length() + // Zeit f&#252;rs Text lesen
+               0.25f;                   // Fade in
+    }
 
-	void DialogCharacterController::response(
-		Actor* actor, const CeGuiString&amp; text, const Ogre::String&amp; soundFile)
-	{
+    void DialogCharacterController::response(
+        Actor* actor, const CeGuiString&amp; text, const Ogre::String&amp; soundFile)
+    {
         if( actor == mDialogPartner )
-		    recalculateCamera( mCharacterActor, mDialogPartner );
+            recalculateCamera( mCharacterActor, mDialogPartner );
         else
             recalculateCamera( mDialogPartner, mCharacterActor );
 
         // Ungef&#228;hre Lesedauer bestimmen
         float fadeTime = getShowTextLength(text);
-		if (soundFile.length() == 0)
-		{
+        if (soundFile.length() == 0)
+        {
             float speed = mSubtitleSpeed;
 
             if( mSubtitleSpeed == 0.0 )
@@ -229,64 +229,64 @@
 
             mCurrFadeTextTime = fadeTime*speed;
             mTotalFadeTextTime = fadeTime*speed;
-		}
-		else
-		{
+        }
+        else
+        {
             if( mSoundObject != NULL )
                 mSoundObject-&gt;getMovableObject()-&gt;getParentSceneNode()-&gt;detachObject(
                     mSoundObject-&gt;getMovableObject() );
 
-			delete mSoundObject;
-			mSoundObject = 
-				new SoundObject(
-					SoundManager::getSingleton().getActiveDriver()-&gt;
-						createSample(
-							SoundManager::getSingleton().getByName(soundFile)),
-					soundFile);
+            delete mSoundObject;
+            mSoundObject =
+                new SoundObject(
+                    SoundManager::getSingleton().getActiveDriver()-&gt;
+                        createSample(
+                            SoundManager::getSingleton().getByName(soundFile)),
+                    soundFile);
 
-			// An Sprecher h&#228;ngen
+            // An Sprecher h&#228;ngen
             actor-&gt;_getSceneNode()-&gt;attachObject( mSoundObject-&gt;getMovableObject() );
             actor-&gt;_getSceneNode()-&gt;_update( true, false );
             mSoundObject-&gt;_setActor( actor );
-			mSoundObject-&gt;set3d(true);
-			mSoundObject-&gt;play();
+            mSoundObject-&gt;set3d(true);
+            mSoundObject-&gt;play();
             mSoundObject-&gt;_update();
 
 
             mCurrFadeTextTime = std::max(fadeTime*mSubtitleSpeed,mSoundObject-&gt;getLength());
             mTotalFadeTextTime = mCurrFadeTextTime;
-		}
+        }
 
-		MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(actor-&gt;getControlledObject());
-		if (mesh != NULL)
-		{
-			if (mesh-&gt;hasAnimation(&quot;reden&quot;))
-			{
-				mesh-&gt;stopAllAnimations();
-				mTalkAnimation = mesh-&gt;startAnimation(&quot;reden&quot;);
-			}
-		}
+        MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(actor-&gt;getControlledObject());
+        if (mesh != NULL)
+        {
+            if (mesh-&gt;hasAnimation(&quot;reden&quot;))
+            {
+                mesh-&gt;stopAllAnimations();
+                mTalkAnimation = mesh-&gt;startAnimation(&quot;reden&quot;);
+            }
+        }
 
-        LOG_DEBUG(Logger::UI, 
-			&quot;Response: &quot;
-				+ actor-&gt;getName()
-				+ &quot; File: '&quot;
-				+ soundFile 
-				+ &quot;', Text: '&quot; + text + &quot;', Time: &quot;
-				+ StringConverter::toString(mCurrFadeTextTime));
+        LOG_DEBUG(Logger::UI,
+            &quot;Response: &quot;
+                + actor-&gt;getName()
+                + &quot; File: '&quot;
+                + soundFile
+                + &quot;', Text: '&quot; + text + &quot;', Time: &quot;
+                + StringConverter::toString(mCurrFadeTextTime));
 
 
-		mTextShown = true;
+        mTextShown = true;
 
-		if (mSubtitleWindow != NULL &amp;&amp; !text.empty())
-		{
-			mSubtitleWindow-&gt;show(text);
-		}
-	}
+        if (mSubtitleWindow != NULL &amp;&amp; !text.empty())
+        {
+            mSubtitleWindow-&gt;show(text);
+        }
+    }
 
     bool DialogCharacterController::injectMouseUp(int mouseButtonMask)
     {
-        
+
         if( mTextShown &amp;&amp; (mCurrFadeTextTime+0.25)&lt;mTotalFadeTextTime )
         {
             mCurrFadeTextTime = -1;

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Perl Artistic License.
 *
@@ -55,29 +55,29 @@
 
     String MovementCharacterController::msDebugWindowPageName = &quot;MovementCharacterController&quot;;
 
-	MovementCharacterController::CharacterState::CharacterState()
-		: mIsAirBorne(false),
+    MovementCharacterController::CharacterState::CharacterState()
+        : mIsAirBorne(false),
         mHasFloorContact(false),
-		mStartJump(false),
-		mJumpTimer(0.0),
-		mDesiredVel(Vector3::ZERO),
-		mCurrentMovementState(MOVE_NONE),
-		mLastMovementState(MOVE_NONE),
+        mStartJump(false),
+        mJumpTimer(0.0),
+        mDesiredVel(Vector3::ZERO),
+        mCurrentMovementState(MOVE_NONE),
+        mLastMovementState(MOVE_NONE),
         mPose(Stand)
-	{
+    {
 
-	}
+    }
 
-	MovementCharacterController::MovementCharacterController(Actor* camera, Creature* character)
-		: CharacterController(camera, character-&gt;getActor()),
-		mCharacterState(),
-		mCharacter(character),
-		mDesiredDistance(2.00),
-		mDistanceRange(0.60, 7.00),
-		mYaw(0),
+    MovementCharacterController::MovementCharacterController(Actor* camera, Creature* character)
+        : CharacterController(camera, character-&gt;getActor()),
+        mCharacterState(),
+        mCharacter(character),
+        mDesiredDistance(2.00),
+        mDistanceRange(0.60, 7.00),
+        mYaw(0),
         mCamYaw(0),
-		mPitch(20),
-		mPitchRange(Degree(-75), Degree(85)),
+        mPitch(20),
+        mPitchRange(Degree(-75), Degree(85)),
         mLinearSpringK(400.0f),
         mLinearDampingK(Math::NEG_INFINITY),
         mCamMoveAwayVelocity(4.0f),
@@ -85,29 +85,26 @@
         mCamMoveAwayRange(8.0f),
         mRotLinearSpringK(600.0f),
         mRotLinearDampingK(Math::NEG_INFINITY),
-		mLookAtOffset(),
-		mRotationSpeed(Degree(120.0f)),
+        mLookAtOffset(),
+        mRotationSpeed(Degree(120.0f)),
         mMouseSensitivity(4.0f),
-		mSpeedModifier(1.0f),
-		mViewMode(VM_THIRD_PERSON),
-//		mMaxDelay(1.0/20.0),
-		mObstractedFrameCount(0),
-		mObstractedTime(0.0f),
-		mCameraJammedFrameCount(0),
-		mCameraJammedTime(0.0f),
-		mRaycast(new PhysicsMaterialRaycast()),
-		mGravitation(),
+        mSpeedModifier(1.0f),
+        mViewMode(VM_THIRD_PERSON),
+//        mMaxDelay(1.0/20.0),
+        mObstractedFrameCount(0),
+        mObstractedTime(0.0f),
+        mCameraJammedFrameCount(0),
+        mCameraJammedTime(0.0f),
+        mRaycast(new PhysicsMaterialRaycast()),
+        mGravitation(),
         mSelector(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager())
-	{
+    {
         DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
 
 
-		mGravitation = PhysicsManager::getSingleton().getGravity();
-		mMouseSensitivity
-			= ConfigurationManager::getSingleton().getIntSetting(&quot;mouse_sensitivity&quot;, 4);
-        int temp = 
-            ConfigurationManager::getSingleton().getIntSetting(&quot;mouse_invert&quot;, 0);
-        mInvertedMouse = temp != 0;
+        mGravitation = PhysicsManager::getSingleton().getGravity();
+        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting(ConfigurationManager::CS_INPUT, &quot;Mouse Sensitivity&quot;);
+        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting(ConfigurationManager::CS_INPUT, &quot;Mouse Invert&quot;);
 
         // The relationCoefficient determines the relation between spring accel in target direction
         // and damping in velocity direction. 1.0 means equilibrium is reached in optimal time
@@ -118,46 +115,46 @@
         mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
         mRotLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mRotLinearSpringK);
 
-		// Offset for the look at point,
-		// so the cam does look at the characters head instead of the feet.
-		MeshObject* charMesh = dynamic_cast&lt;MeshObject*&gt;(
-			mCharacterActor-&gt;getControlledObject());
+        // Offset for the look at point,
+        // so the cam does look at the characters head instead of the feet.
+        MeshObject* charMesh = dynamic_cast&lt;MeshObject*&gt;(
+            mCharacterActor-&gt;getControlledObject());
         AxisAlignedBox aabb = charMesh-&gt;getDefaultSize();
 
         // wird sp&#228;ter neu berechnet in calculateOptimalCameraPosition
         mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
 
-		// The actor should be controlled manually,
-		// so let the PM prepare it accordingly
-		PhysicsManager::getSingleton().setPhysicsController(
-			mCharacterActor-&gt;getPhysicalThing(), this);
-		PhysicsManager::getSingleton().setPhysicsController(
-			mCameraActor-&gt;getPhysicalThing(), this);
+        // The actor should be controlled manually,
+        // so let the PM prepare it accordingly
+        PhysicsManager::getSingleton().setPhysicsController(
+            mCharacterActor-&gt;getPhysicalThing(), this);
+        PhysicsManager::getSingleton().setPhysicsController(
+            mCameraActor-&gt;getPhysicalThing(), this);
         // We also handle char&lt;-&gt;level, char&lt;-&gt;default collision from now on
         PhysicsManager::getSingleton().setCharLevelContactCallback(this);
         PhysicsManager::getSingleton().setCharDefaultContactCallback(this);
-		// Fit Collision proxy to idle anim
+        // Fit Collision proxy to idle anim
         mCharacterActor-&gt;getPhysicalThing()-&gt;fitToPose(&quot;idle&quot;);
 
         MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
-		mesh-&gt;stopAllAnimations();
-		mesh-&gt;startAnimation(&quot;idle&quot;);
+        mesh-&gt;stopAllAnimations();
+        mesh-&gt;startAnimation(&quot;idle&quot;);
 
-		setViewMode(VM_THIRD_PERSON);
+        setViewMode(VM_THIRD_PERSON);
 
         // We want to check for visibility from char's POV.
         mSelector.setCheckVisibility(true, mCharacterActor);
-	}
+    }
 
-	//------------------------------------------------------------------------
-	MovementCharacterController::~MovementCharacterController()
-	{
+    //------------------------------------------------------------------------
+    MovementCharacterController::~MovementCharacterController()
+    {
         delete mRaycast;
-		// actors aren't controlled anymore
-		PhysicsManager::getSingleton().setPhysicsController(
-			mCharacterActor-&gt;getPhysicalThing(), NULL);
-		PhysicsManager::getSingleton().setPhysicsController(
-			mCameraActor-&gt;getPhysicalThing(), NULL);
+        // actors aren't controlled anymore
+        PhysicsManager::getSingleton().setPhysicsController(
+            mCharacterActor-&gt;getPhysicalThing(), NULL);
+        PhysicsManager::getSingleton().setPhysicsController(
+            mCameraActor-&gt;getPhysicalThing(), NULL);
         // Char&lt;-&gt;Level collision back to default
         PhysicsManager::getSingleton().setCharLevelContactCallback(NULL);
         // Char&lt;-&gt;Default collision back to default
@@ -180,17 +177,17 @@
         {
             mCharacterActor-&gt;_getSceneNode()-&gt;removeChild(mSceneNode);
         }
-	}
+    }
 
-	//------------------------------------------------------------------------
-	CharacterController::ControllerType MovementCharacterController::getType() const
-	{
-		return CTRL_MOVEMENT;
-	}
+    //------------------------------------------------------------------------
+    CharacterController::ControllerType MovementCharacterController::getType() const
+    {
+        return CTRL_MOVEMENT;
+    }
 
-	//------------------------------------------------------------------------
-	void MovementCharacterController::run(Real elapsedTime)
-	{
+    //------------------------------------------------------------------------
+    void MovementCharacterController::run(Real elapsedTime)
+    {
         int movement = mCharacterState.mCurrentMovementState;
         updateAnimationState(movement);
         updateCharacterState(movement, elapsedTime);
@@ -213,11 +210,11 @@
         // Do we need to reset the Camera?
         Vector3 charPos = mCharacterActor-&gt;getWorldPosition();
         Quaternion charOri = mCharacterActor-&gt;getWorldOrientation();
-		//mCharBody-&gt;getPositionOrientation(charPos, charOri);
+        //mCharBody-&gt;getPositionOrientation(charPos, charOri);
 
-		Vector3 camPos;
-		Quaternion camOri;
-		mCamBody-&gt;getPositionOrientation(camPos, camOri);
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody-&gt;getPositionOrientation(camPos, camOri);
 
         float maxdistance;
         if (mViewMode == VM_FIRST_PERSON)
@@ -225,32 +222,32 @@
         else
             maxdistance = 1.3f * mDesiredDistance + 1.4f;
 
-		// if we have more than 250ms and at least five frames with camera distance higher
-		// than desired distance, reset camera
-		if ((camPos - (charPos + charOri*mLookAtOffset)).length() &gt; maxdistance)
-		{
-			mCameraJammedTime += elapsedTime;
-			++mCameraJammedFrameCount;
-		}
-		else
-		{
-			mCameraJammedTime = 0.0f;
-			mCameraJammedFrameCount = 0;
-		}
+        // if we have more than 250ms and at least five frames with camera distance higher
+        // than desired distance, reset camera
+        if ((camPos - (charPos + charOri*mLookAtOffset)).length() &gt; maxdistance)
+        {
+            mCameraJammedTime += elapsedTime;
+            ++mCameraJammedFrameCount;
+        }
+        else
+        {
+            mCameraJammedTime = 0.0f;
+            mCameraJammedFrameCount = 0;
+        }
 
-		if (mCameraJammedTime &gt; 0.250f &amp;&amp; mCameraJammedFrameCount &gt; 5)
-		{
-			mCameraJammedFrameCount = 0;
-			resetCamera();
-		}
-			
+        if (mCameraJammedTime &gt; 0.250f &amp;&amp; mCameraJammedFrameCount &gt; 5)
+        {
+            mCameraJammedFrameCount = 0;
+            resetCamera();
+        }
+
         mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
     }
 
-	//------------------------------------------------------------------------
-	void MovementCharacterController::updateCharacterState(int movement, Ogre::Real elapsedTime)
-	{
-		InputManager* im = InputManager::getSingletonPtr();
+    //------------------------------------------------------------------------
+    void MovementCharacterController::updateCharacterState(int movement, Ogre::Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
         Real gs = mCharacter-&gt;getWert(Creature::WERT_GS);
         Real auPerSecond = 0.0; // Standard - Ausdauer-verbrauch/Regeneration pro Sekunde
         bool canRun = mCharacter-&gt;getAu() &gt; 6.0f;
@@ -400,22 +397,22 @@
 
 
 
-		mDesiredDistance -= im-&gt;getMouseRelativeZ() * 0.002;
-		if (mDesiredDistance &lt; mDistanceRange.first)
-		{
-			mDesiredDistance = mDistanceRange.first;
-		}
-		if (mDesiredDistance &gt; mDistanceRange.second)
-		{
-			mDesiredDistance = mDistanceRange.second;
-		}
+        mDesiredDistance -= im-&gt;getMouseRelativeZ() * 0.002;
+        if (mDesiredDistance &lt; mDistanceRange.first)
+        {
+            mDesiredDistance = mDistanceRange.first;
+        }
+        if (mDesiredDistance &gt; mDistanceRange.second)
+        {
+            mDesiredDistance = mDistanceRange.second;
+        }
 
         if (mInvertedMouse)
-		    mPitch -= 0.5 * mMouseSensitivity * Degree(im-&gt;getMouseRelativeY() / 10);
+            mPitch -= 0.5 * mMouseSensitivity * Degree(im-&gt;getMouseRelativeY() / 10);
         else
             mPitch += 0.5 * mMouseSensitivity * Degree(im-&gt;getMouseRelativeY() / 10);
-		if (mPitch &lt; mPitchRange.first) mPitch = mPitchRange.first;
-		if (mPitch &gt; mPitchRange.second) mPitch = mPitchRange.second;
+        if (mPitch &lt; mPitchRange.first) mPitch = mPitchRange.first;
+        if (mPitch &gt; mPitchRange.second) mPitch = mPitchRange.second;
 
 
         if( !im-&gt;isCeguiActive() &amp;&amp; mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
@@ -425,45 +422,45 @@
                 mYaw -= mMouseSensitivity / 6.0 * rotationSpeed * Degree(im-&gt;getMouseRelativeX() / 15);
 
                 while (mYaw.valueDegrees() &gt; 360.0f) mYaw -= Degree(360.0f);
-		        while (mYaw.valueDegrees() &lt; -360.0f) mYaw += Degree(360.0f);
+                while (mYaw.valueDegrees() &lt; -360.0f) mYaw += Degree(360.0f);
             }
         }
     }
 
-	//------------------------------------------------------------------------
-	void MovementCharacterController::updateCameraLookAt(Ogre::Real elapsedTime)
-	{
+    //------------------------------------------------------------------------
+    void MovementCharacterController::updateCameraLookAt(Ogre::Real elapsedTime)
+    {
         InputManager* im = InputManager::getSingletonPtr();
-        
 
+
         if( !im-&gt;isCeguiActive() &amp;&amp; mViewMode == VM_FREE_CAMERA )
         {
             mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im-&gt;getMouseRelativeX() / 15);
 
-		    while (mCamYaw.valueDegrees() &gt; 360.0f) mCamYaw -= Degree(360.0f);
-		    while (mCamYaw.valueDegrees() &lt; -360.0f) mCamYaw += Degree(360.0f);
+            while (mCamYaw.valueDegrees() &gt; 360.0f) mCamYaw -= Degree(360.0f);
+            while (mCamYaw.valueDegrees() &lt; -360.0f) mCamYaw += Degree(360.0f);
         }
 
-		SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
+        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
 
-		Vector3 charPos;
-		Quaternion charOri;
-		//mCharBody-&gt;getPositionOrientation(charPos, charOri);
+        Vector3 charPos;
+        Quaternion charOri;
+        //mCharBody-&gt;getPositionOrientation(charPos, charOri);
         charPos = mCharacterActor-&gt;getWorldPosition();
         charOri = mCharacterActor-&gt;getWorldOrientation();
 
-		if( mViewMode == VM_FIRST_PERSON)
-		{
-			Quaternion camOri;
+        if( mViewMode == VM_FIRST_PERSON)
+        {
+            Quaternion camOri;
             camOri.FromAngleAxis(mPitch, Vector3::NEGATIVE_UNIT_X);
-			cameraNode-&gt;lookAt(
-				charPos
-				+ charOri * mLookAtOffset
-				+ charOri * camOri * (-Vector3::UNIT_Z), 
-				Node::TS_WORLD);
-		}
-		else if( mViewMode == VM_THIRD_PERSON )
-		{
+            cameraNode-&gt;lookAt(
+                charPos
+                + charOri * mLookAtOffset
+                + charOri * camOri * (-Vector3::UNIT_Z),
+                Node::TS_WORLD);
+        }
+        else if( mViewMode == VM_THIRD_PERSON )
+        {
             // Kamera-Gr&#246;&#223;e beziehen
             CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
                 mCameraActor-&gt;getControlledObject());
@@ -472,15 +469,15 @@
             Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
 
             cameraNode-&gt;lookAt(
-				charPos	+ mLookAtOffset
-                + charOri * (-Vector3::UNIT_Z*radius), 
-				Node::TS_WORLD);
+                charPos    + mLookAtOffset
+                + charOri * (-Vector3::UNIT_Z*radius),
+                Node::TS_WORLD);
 
-		}
+        }
         else if( mViewMode == VM_FREE_CAMERA )
         {
             cameraNode-&gt;lookAt(
-				charPos	+ mLookAtOffset,
+                charPos    + mLookAtOffset,
                 Node::TS_WORLD);
         }
 
@@ -495,7 +492,7 @@
             Quaternion camOri;
             mCamBody-&gt;getPositionOrientation(camPos, camOri);
             Vector3 camPoint, charPoint, normal;
-            int collisionPoints = 
+            int collisionPoints =
                 OgreNewt::CollisionTools::CollisionClosestPoint(
                     PhysicsManager::getSingleton()._getNewtonWorld(),
                     mCamBody-&gt;getCollision(), camOri, camPos,
@@ -516,17 +513,17 @@
     // adopted from the chararcter demo in the newton sdk
     // copyright 2000-2004
     // By Julio Jerez
-	int MovementCharacterController::userProcess()
-	{
+    int MovementCharacterController::userProcess()
+    {
         if ((m_body0 == mCamBody &amp;&amp; m_body1 == mCharBody)
             || (m_body0 == mCharBody &amp;&amp; m_body1 == mCamBody))
         {
             // No collision between char and camera
             return 0;
         }
-		else if (m_body0 == mCamBody || m_body1 == mCamBody)
-		{
-			// this is camera collision
+        else if (m_body0 == mCamBody || m_body1 == mCamBody)
+        {
+            // this is camera collision
 
             if( mViewMode == VM_FIRST_PERSON )
                 return 0;
@@ -535,17 +532,17 @@
             setContactElasticity(0.0f);
 
             return 1;
-		}
-		else if (m_body0 == mCharBody || m_body1 == mCharBody)
-		{
-			// this is character collision
-			Vector3 point;
-			Vector3 normal;
-			getContactPositionAndNormal(point, normal);
+        }
+        else if (m_body0 == mCharBody || m_body1 == mCharBody)
+        {
+            // this is character collision
+            Vector3 point;
+            Vector3 normal;
+            getContactPositionAndNormal(point, normal);
 
-			// determine if this contact is with the floor.
-			// Meaning the contact normal has an angle to UNIT_Y of 20&#176; or less.
-			Degree angle = Math::ACos(normal.dotProduct(Vector3::UNIT_Y));
+            // determine if this contact is with the floor.
+            // Meaning the contact normal has an angle to UNIT_Y of 20&#176; or less.
+            Degree angle = Math::ACos(normal.dotProduct(Vector3::UNIT_Y));
 
             Vector3 charPos;
             Quaternion charOri;
@@ -562,88 +559,88 @@
 
             if ( isFloorCollision )
             {
-				mCharacterState.mHasFloorContact = true;
+                mCharacterState.mHasFloorContact = true;
             }
             else
             {
 
-				Vector3 velocity = mCharBody-&gt;getVelocity();
+                Vector3 velocity = mCharBody-&gt;getVelocity();
 
-				// calculate char velocity perpendicular to the contact normal
-				Vector3 tangentVel = velocity - normal * (normal.dotProduct(velocity));
+                // calculate char velocity perpendicular to the contact normal
+                Vector3 tangentVel = velocity - normal * (normal.dotProduct(velocity));
 
-				// align the tangent at the contact point with the
-				// tangent velocity vector of the char
-				rotateTangentDirections(tangentVel);
-			}
+                // align the tangent at the contact point with the
+                // tangent velocity vector of the char
+                rotateTangentDirections(tangentVel);
+            }
 
 
             // beinflusst die Sprungh&#246;he!
             // der erste Sprung bleibt normal, jeder weitere Sprung ist ungef&#228;hr um
-            // die angegebene Zahl h&#246;her (eher 2*die angegebene Zahl oder so, 
+            // die angegebene Zahl h&#246;her (eher 2*die angegebene Zahl oder so,
             // vermutlich wieder framedauer abh&#228;ngig!)
-			setContactElasticity(0.3f); // was 0.3f 
-			setContactSoftness(0.01f);
+            setContactElasticity(0.3f); // was 0.3f
+            setContactSoftness(0.01f);
 
-			setContactFrictionState(1, 0);
-			setContactFrictionState(1, 1);
-		}
+            setContactFrictionState(1, 0);
+            setContactFrictionState(1, 1);
+        }
 
-		// return one to tell Newton we want to accept this contact
-		return 1;
-	}
+        // return one to tell Newton we want to accept this contact
+        return 1;
+    }
 
     //------------------------------------------------------------------------
     // adopted from the chararcter demo in the newton sdk
     // copyright 2000-2004
     // By Julio Jerez
-	void MovementCharacterController::OnApplyForceAndTorque(PhysicalThing* thing)
-	{
-		OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
-		OgreNewt::Body* body = thing-&gt;_getBody();
+    void MovementCharacterController::OnApplyForceAndTorque(PhysicalThing* thing)
+    {
+        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
+        OgreNewt::Body* body = thing-&gt;_getBody();
 
-		// Get the current world timestep
-		Real timestep = world-&gt;getTimeStep();
+        // Get the current world timestep
+        Real timestep = world-&gt;getTimeStep();
 
-		if (body == mCamBody)
-		{
-			calculateCamera(timestep);
-		}
-		else
-		{
-		    mCharacterState.mJumpTimer += timestep;
+        if (body == mCamBody)
+        {
+            calculateCamera(timestep);
+        }
+        else
+        {
+            mCharacterState.mJumpTimer += timestep;
             static Real timeSinceLastFloorContact(0.0f); // damit kleine Bodenunebenheiten nicht gleich zum &quot;Sprung f&#252;hren&quot;
             if( !mCharacterState.mHasFloorContact )
                 timeSinceLastFloorContact += timestep;
             else
                 timeSinceLastFloorContact = 0.0f;
-            
-            
-            
-            
+
+
+
+
             // apply character force
-			Vector3 position;
-			Quaternion orientation;
-			body-&gt;getPositionOrientation(position, orientation);
+            Vector3 position;
+            Quaternion orientation;
+            body-&gt;getPositionOrientation(position, orientation);
 
-			// get the charater mass
-			Real mass;
-			Vector3 inertia;
-			body-&gt;getMassMatrix(mass, inertia);
+            // get the charater mass
+            Real mass;
+            Vector3 inertia;
+            body-&gt;getMassMatrix(mass, inertia);
 
-			// apply gravity
+            // apply gravity
             Vector3 force = Vector3::ZERO;
-			force = mass * mGravitation;
+            force = mass * mGravitation;
 
-			// Get the velocity vector
-			Vector3 currentVel = body-&gt;getVelocity();
+            // Get the velocity vector
+            Vector3 currentVel = body-&gt;getVelocity();
 
-			// Gravity is applied above, so not needed here
-			// prevent adding a counter force against gravity
-			//if (currentVel.y &lt; 0.0f || mCharacterState.mJumpTimer &lt; 2.0f) 
-			currentVel.y = 0.0f;
+            // Gravity is applied above, so not needed here
+            // prevent adding a counter force against gravity
+            //if (currentVel.y &lt; 0.0f || mCharacterState.mJumpTimer &lt; 2.0f)
+            currentVel.y = 0.0f;
 
-            if( (mCharacterState.mHasFloorContact &amp;&amp; mCharacterState.mJumpTimer &gt; 0.1f) || 
+            if( (mCharacterState.mHasFloorContact &amp;&amp; mCharacterState.mJumpTimer &gt; 0.1f) ||
                 ( timeSinceLastFloorContact &lt; 0.2f &amp;&amp; !mCharacterState.mIsAirBorne ) )
                 mCharacterState.mIsAirBorne = false;
             else
@@ -652,10 +649,10 @@
 
             if( !mCharacterState.mIsAirBorne )
             {
-			    // apply the jump
-			    if ( mCharacterState.mStartJump )
-			    {
-				    mCharacterState.mJumpTimer = 0.0f;
+                // apply the jump
+                if ( mCharacterState.mStartJump )
+                {
+                    mCharacterState.mJumpTimer = 0.0f;
                     mCharacterState.mIsAirBorne = true;
                     Real height = 0.75f; // beim zweiten gehts seltsamerweise was h&#246;her /doppelsprung physik?)
                     Real gravity = 9.81f;
@@ -663,32 +660,32 @@
                     force += Vector3(0,
                         jumpForce,
                         0);
-			    }
+                }
 
                 Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep(); // so ist die Beschleunigung unabh&#228;ngig von der framerate!
                 force += mass*(orientation*mCharacterState.mDesiredVel - currentVel) / delay;
             }
             mCharacterState.mStartJump = false;
 
-			body-&gt;setForce(force);
-			// Assume we are air borne.
-			// Might be set to true in the collision callback
-			mCharacterState.mHasFloorContact = false;
+            body-&gt;setForce(force);
+            // Assume we are air borne.
+            // Might be set to true in the collision callback
+            mCharacterState.mHasFloorContact = false;
 
 
 
 
 
 
-		    // Calculate angular velocity
-		    // We first need the yaw rotation from actual yaw to desired yaw
-		    Vector3 src = orientation*Vector3::NEGATIVE_UNIT_Z;
-		    src.y = 0;
-		    Vector3 dst = Quaternion(mYaw, Vector3::UNIT_Y)*Vector3::UNIT_Z;
-		    dst.y = 0;
-		    Radian yaw = src.getRotationTo(dst).getYaw();
+            // Calculate angular velocity
+            // We first need the yaw rotation from actual yaw to desired yaw
+            Vector3 src = orientation*Vector3::NEGATIVE_UNIT_Z;
+            src.y = 0;
+            Vector3 dst = Quaternion(mYaw, Vector3::UNIT_Y)*Vector3::UNIT_Z;
+            dst.y = 0;
+            Radian yaw = src.getRotationTo(dst).getYaw();
 
-            
+
             // was soll dieser komische Fehler?
             // wenn yaw 0 sein sollte, wird er manchmal zu -90 grad, find ich nich nett
             if( (yaw.valueDegrees() - (-90)) &lt; 0.5 )
@@ -696,28 +693,28 @@
                     yaw = Degree(0);
 
 
-		    // Calculate omega in order to go this rotation in mMaxDelay seconds.
+            // Calculate omega in order to go this rotation in mMaxDelay seconds.
             // Real newOmega = yaw.valueRadians() / mMaxDelay;
             Vector3 diff = Vector3(0, yaw.valueRadians(), 0);
             Vector3 omega = mCharBody-&gt;getOmega();
             omega.x = omega.z = 0;
             // sollte nicht direkt gesetzt werden!
             Vector3 springAcc = -mRotLinearSpringK*diff - mRotLinearDampingK * omega;
-		    //body-&gt;setOmega(Vector3(0, newOmega, 0)); // omega sollte nicht direkt gesetzt werden
+            //body-&gt;setOmega(Vector3(0, newOmega, 0)); // omega sollte nicht direkt gesetzt werden
             body-&gt;setTorque( mass * springAcc );
         }
 
 
 
         SceneNode* node = mCharacterActor-&gt;_getSceneNode();
-		std::ostringstream ss;
+        std::ostringstream ss;
         Vector3 bodpos, playpos = node-&gt;getPosition();
         Quaternion egal;
         mCamBody-&gt;getPositionOrientation(bodpos,egal);
         static Real maxHeight(0);
         if( playpos.y &gt; maxHeight )
             maxHeight = playpos.y;
-        ss 
+        ss
             &lt;&lt; &quot;scene node : &quot; &lt;&lt; playpos &lt;&lt; endl
 //            &lt;&lt; &quot;player max Height : &quot; &lt;&lt; maxHeight &lt;&lt; endl
             &lt;&lt; &quot;camera posder : &quot; &lt;&lt; static_cast&lt;Camera*&gt;(
@@ -736,17 +733,17 @@
     }
 
     //------------------------------------------------------------------------
-	void MovementCharacterController::calculateCamera(const Ogre::Real&amp; timestep)
-	{
-		Vector3 charPos;
-		Quaternion charOri;
-		//mCharBody-&gt;getPositionOrientation(charPos, charOri);
+    void MovementCharacterController::calculateCamera(const Ogre::Real&amp; timestep)
+    {
+        Vector3 charPos;
+        Quaternion charOri;
+        //mCharBody-&gt;getPositionOrientation(charPos, charOri);
         charPos = mCharacterActor-&gt;getWorldPosition();
         charOri = mCharacterActor-&gt;getWorldOrientation();
 
-		Vector3 camPos;
-		Quaternion camOri;
-		mCamBody-&gt;getPositionOrientation(camPos, camOri);
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody-&gt;getPositionOrientation(camPos, camOri);
         SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
 
 /*
@@ -760,12 +757,12 @@
         static std::vector&lt;Ogre::Vector3&gt; camOptPositionsBuffer(20);
         static size_t camOptPositionsBufferIdx = -1;
         camOptPositionsBufferIdx = (camOptPositionsBufferIdx + 1) % camOptPositionsBuffer.size();
-*/        
+*/
         Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
         charPos = charPos + charOri * mLookAtOffset;
 //        camOptPositionsBuffer[camOptPositionsBufferIdx] = optimalCamPos;
-        
 
+
         // Ringbuffer mit Positionen des Characters
         static std::vector&lt;Ogre::Vector3&gt; charPositionsBuffer(20);
         static size_t charPositionsBufferIdx = -1;
@@ -789,14 +786,14 @@
 
 
 
-		if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA )
-		{
+        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA )
+        {
 
             // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
             // so zur optimalen kommen
             const OgreNewt::MaterialID* materialId =
                 mCharBody-&gt;getMaterialGroupID();
-//			    PhysicsManager::getSingleton()._getLevelMaterialID();
+//                PhysicsManager::getSingleton()._getLevelMaterialID();
             OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
 
             Vector3 normToOptCamPos = (optimalCamPos - charPos);
@@ -805,16 +802,16 @@
 
 
             RaycastInfo infoCastOptPos = mRaycast-&gt;execute(
-                world, 
-                materialId, 
+                world,
+                materialId,
                 camPos + camRadius * normToOptCamPos, // Gr&#246;&#223;e der Kamera einbeziehen
                 optimalCamPos + camRadius * normToOptCamPos,
                 true); // Gr&#246;&#223;e der Kamera einbeziehen
 
             RaycastInfo infoCastChar = mRaycast-&gt;execute(
-                world, 
-                materialId, 
-                camPos, 
+                world,
+                materialId,
+                camPos,
                 charPos,
                 true);
 
@@ -850,7 +847,7 @@
                     while( delta &gt; 0.05 ) // genauigkeit des gefundenen Punktes
                     {
                         infoCastNewPos = mRaycast-&gt;execute(
-                            world, 
+                            world,
                             materialId,
                             camPos + camRadius * normToOptCamPos, // Gr&#246;&#223;e der Kamera!
                             temp,
@@ -875,7 +872,7 @@
             }
 
 
-            static bool isPathfinding (false); 
+            static bool isPathfinding (false);
             static unsigned int lastReachableBufPos;
             // gibt an, ob schon gebufferte Daten f&#252;r den
             // neuen Weg existieren und dort weitergemacht werden kann,
@@ -902,7 +899,7 @@
                     while ( delta &lt; buffSize )
                     {
                         RaycastInfo info = mRaycast-&gt;execute(
-                            world, 
+                            world,
                             materialId,
                             camPos,
                             charPositionsBuffer[ (charPositionsBufferIdx - delta) % buffSize ] ,
@@ -935,7 +932,7 @@
                     while ( delta &gt; 0 ) // delta = 0 braucht nicht &#252;berpr&#252;ft zu werden, wurde oben schon ausgeschlossen!
                     {
                         RaycastInfo info = mRaycast-&gt;execute(
-                            world, 
+                            world,
                             materialId,
                             camPos,
                             charPositionsBuffer[ (charPositionsBufferIdx - delta) % buffSize ],
@@ -966,8 +963,8 @@
             Vector3 springAcc = -mLinearSpringK*diff - mLinearDampingK * cameraVelocity;
 
             // get the camera mass
-			Real mass;
-			Vector3 inertia;
+            Real mass;
+            Vector3 inertia;
             mCamBody-&gt;getMassMatrix(mass, inertia);
 
             //mCamBody-&gt;setPositionOrientation(newCamPos, camOri);
@@ -977,7 +974,7 @@
         {
             mCamBody-&gt;setPositionOrientation(optimalCamPos, camOri);
         }
-	}
+    }
 
     //------------------------------------------------------------------------
     Ogre::Vector3 MovementCharacterController::calculateOptimalCameraPosition(bool SlowlyMoveBackward, const Real &amp;timestep)
@@ -995,23 +992,23 @@
             charPos = charPos + charOri * mLookAtOffset;
             if(mViewMode == VM_THIRD_PERSON)
             {
-	            targetCamPos = 
-		            charPos 
-		            + charOri * Vector3(
-						            0, 
-						            Math::Sin(mPitch) * mDesiredDistance,
-						            Math::Cos(mPitch) * mDesiredDistance);
+                targetCamPos =
+                    charPos
+                    + charOri * Vector3(
+                                    0,
+                                    Math::Sin(mPitch) * mDesiredDistance,
+                                    Math::Cos(mPitch) * mDesiredDistance);
             }
             else
             {
                 Quaternion camOri;
                 camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-	            targetCamPos = 
-		            charPos 
-		            + charOri * camOri * Vector3(
-						                        0, 
-						                        Math::Sin(mPitch) * mDesiredDistance,
-						                        Math::Cos(mPitch) * mDesiredDistance);
+                targetCamPos =
+                    charPos
+                    + charOri * camOri * Vector3(
+                                                0,
+                                                Math::Sin(mPitch) * mDesiredDistance,
+                                                Math::Cos(mPitch) * mDesiredDistance);
             }
 
 
@@ -1033,9 +1030,9 @@
             Vector3 radiusOffset = charOri * Vector3(0, sinPitchRad, cosPitchRad);
 
             startRay[0] = charPos;
-            endRay[0] = targetCamPos; // hier ist nun leider was doppelt, 
+            endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
                                       // dadurch kann aber sichergestellt
-                                      // werden, dass kein Objekt direkt 
+                                      // werden, dass kein Objekt direkt
                                       // hinter dem Helden &#252;bersehen wird
             startRay[1] = charPos + radiusOffset;
             endRay[1] = targetCamPos + radiusOffset;
@@ -1052,9 +1049,9 @@
 
             const OgreNewt::MaterialID* materialId =
                 mCharBody-&gt;getMaterialGroupID();
-//			    PhysicsManager::getSingleton()._getLevelMaterialID();
+//                PhysicsManager::getSingleton()._getLevelMaterialID();
             OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-            
+
             Vector3 diff = targetCamPos - charPos;
             bool CollisionFound = false;
             for( int i = 0; i &lt; 6; i++ )
@@ -1065,7 +1062,7 @@
                     startRay[i],
                     endRay[i],
                     true);
-            
+
                 if( info.mBody )
                 {
                     CollisionFound = true;
@@ -1097,7 +1094,7 @@
             Quaternion camOri;
             mCamBody-&gt;getPositionOrientation(camPos, camOri);
 
-            if( SlowlyMoveBackward &amp;&amp; 
+            if( SlowlyMoveBackward &amp;&amp;
                 desiredDistance &gt; lastDistance )
             {
 
@@ -1105,18 +1102,18 @@
                 Real newDistance;
                 Vector3 actDiff = camPos - charPos;
                 actDiff.normalise();
-                
-                if( TimeOfLastCollision &gt; mCamMoveAwayStartTime || 
+
+                if( TimeOfLastCollision &gt; mCamMoveAwayStartTime ||
                     diff.directionEquals(actDiff, mCamMoveAwayRange*timestep) )
                     newDistance = lastDistance + mCamMoveAwayVelocity*timestep;
                 else
                     newDistance = lastDistance;
-                
+
                 if( newDistance &gt; desiredDistance )
                     newDistance = desiredDistance;
-                
+
                 diff = diff*newDistance;
-                
+
                 lastDistance = newDistance;
             }
             else
@@ -1132,14 +1129,14 @@
             //mCharBody-&gt;getPositionOrientation(charPos, charOri);
             charPos = mCharacterActor-&gt;getWorldPosition();
             charOri = mCharacterActor-&gt;getWorldOrientation();
-            // determine the optimal target position of the camera            
-	        targetCamPos = 
-		        charPos 
-		        + charOri * mLookAtOffset 
-		        + charOri * Vector3(
-						        0, 
-						        Math::Sin(mPitch) * mDesiredDistance,
-						        Math::Cos(mPitch) * mDesiredDistance);
+            // determine the optimal target position of the camera
+            targetCamPos =
+                charPos
+                + charOri * mLookAtOffset
+                + charOri * Vector3(
+                                0,
+                                Math::Sin(mPitch) * mDesiredDistance,
+                                Math::Cos(mPitch) * mDesiredDistance);
         }
 
 
@@ -1147,8 +1144,8 @@
     }
 
     //------------------------------------------------------------------------
-	void MovementCharacterController::updateSelection()
-	{
+    void MovementCharacterController::updateSelection()
+    {
         InputManager* im = InputManager::getSingletonPtr();
         if( im-&gt;isCeguiActive() )
             return;
@@ -1169,7 +1166,7 @@
 
         if (newGo != NULL &amp;&amp; newGo != oldGo)
         {
-            newGo-&gt;setHighlighted(true);            
+            newGo-&gt;setHighlighted(true);
         }
 
         // Optionen anzeigen
@@ -1181,13 +1178,13 @@
         {
             mSelector.getSelectedObject()-&gt;doDefaultAction(mCharacter, NULL);
         }
-	}
+    }
 
     //------------------------------------------------------------------------
-	void MovementCharacterController::updateAnimationState(int &amp;movement)
-	{
-		MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
-		PhysicalThing* pt = mCharacterActor-&gt;getPhysicalThing();
+    void MovementCharacterController::updateAnimationState(int &amp;movement)
+    {
+        MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
+        PhysicalThing* pt = mCharacterActor-&gt;getPhysicalThing();
         static std::string lastAnimation(&quot;&quot;);
         std::string newAnimation(&quot;&quot;);
         Real animSpeed = 1;
@@ -1195,8 +1192,8 @@
         static bool jumpNextFrame(false);
         unsigned int animTimesToPlay = 0;
         Real gs = mCharacter-&gt;getWert(Creature::WERT_GS);
-		static String lastCollisionPose = &quot;&quot;;
-		String collisionPose = &quot;idle&quot;;
+        static String lastCollisionPose = &quot;&quot;;
+        String collisionPose = &quot;idle&quot;;
 
         // the different factors used to calculate the animation-speed from the character-speed
         const Real factor_hocke_gehen = 0.7;
@@ -1239,7 +1236,7 @@
             if (meshAnim-&gt;getTimePlayed() &gt;= meshAnim-&gt;getLength())
             {
                 newAnimation = &quot;hocke_idle&quot;;
-				collisionPose = &quot;hocke_idle&quot;;
+                collisionPose = &quot;hocke_idle&quot;;
                 mCharacterState.mPose = CharacterState::Crouch;
             }
             // kamera-offset interpolieren grrr
@@ -1252,13 +1249,13 @@
             if (vel &gt; 0.1 &amp;&amp; movement &amp; MOVE_FORWARD)
             {
                 newAnimation = &quot;hocke_gehen&quot;;
-				collisionPose = &quot;hocke_idle&quot;;
+                collisionPose = &quot;hocke_idle&quot;;
                 animSpeed = charVelocity.length() * factor_hocke_gehen;
             }
             else
             {
                 newAnimation = &quot;hocke_idle&quot;;
-				collisionPose = &quot;hocke_idle&quot;;
+                collisionPose = &quot;hocke_idle&quot;;
             }
         }
         else if (mCharacterState.mPose == CharacterState::Crouch)
@@ -1288,7 +1285,7 @@
                 MeshAnimation *meshAnim = mesh-&gt;getAnimation(&quot;rennen_absprung&quot;);
                 if (meshAnim-&gt;getTimePlayed() &gt;= meshAnim-&gt;getLength())
                 {
-					///\todo Animation &quot;rennen_sprung&quot; has length of 0.0f. Substitute for Idle, till this is resolved.
+                    ///\todo Animation &quot;rennen_sprung&quot; has length of 0.0f. Substitute for Idle, till this is resolved.
                     //newAnimation = &quot;rennen_sprung&quot;;
                     newAnimation = &quot;idle&quot;;
 
@@ -1303,7 +1300,7 @@
                 MeshAnimation *meshAnim = mesh-&gt;getAnimation(&quot;idle_absprung&quot;);
                 if (meshAnim-&gt;getTimePlayed() &gt;= meshAnim-&gt;getLength())
                 {
-					///\todo Animation &quot;idle_sprung&quot; has length of 0.0f. Substitute for Idle, till this is resolved.
+                    ///\todo Animation &quot;idle_sprung&quot; has length of 0.0f. Substitute for Idle, till this is resolved.
                     //newAnimation = &quot;idle_sprung&quot;;
                     newAnimation = &quot;idle&quot;;
 
@@ -1409,7 +1406,7 @@
                     animSpeed = factor_rennen_absprung * vel;
                     mCharacterState.mPose = CharacterState::StartJump;
                 }
-                else 
+                else
                 {
                     if ( vel &gt; 0.1 )
                     {
@@ -1435,16 +1432,16 @@
 
         if (newAnimation != &quot;&quot;)
         {
-			// nur schneller nicht langsamer ausf&#252;hren!
+            // nur schneller nicht langsamer ausf&#252;hren!
             if (animSpeed &lt; 1) animSpeed = 1;
-                
+
             if (lastAnimation != newAnimation)
             {
-				if (collisionPose != lastCollisionPose)
-				{
-					pt-&gt;fitToPose(collisionPose);
-					lastCollisionPose = collisionPose;
-				}
+                if (collisionPose != lastCollisionPose)
+                {
+                    pt-&gt;fitToPose(collisionPose);
+                    lastCollisionPose = collisionPose;
+                }
                 mesh-&gt;stopAllAnimations();
                 mesh-&gt;startAnimation(newAnimation, animSpeed, animTimesToPlay);
                 lastAnimation = newAnimation;
@@ -1463,53 +1460,53 @@
     }
 
     //------------------------------------------------------------------------
-	void MovementCharacterController::setViewMode(ViewMode mode)
-	{
-		mViewMode = mode;
+    void MovementCharacterController::setViewMode(ViewMode mode)
+    {
+        mViewMode = mode;
 
-		MeshObject* charMesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
-		AxisAlignedBox aabb = charMesh-&gt;getDefaultSize();
-		if (mode == VM_FIRST_PERSON)
-		{
+        MeshObject* charMesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
+        AxisAlignedBox aabb = charMesh-&gt;getDefaultSize();
+        if (mode == VM_FIRST_PERSON)
+        {
             mLookAtOffset = Vector3(
-                    0, 
+                    0,
                     (aabb.getMaximum().y - aabb.getMinimum().y) * 0.90f,
                     (aabb.getMaximum().z - aabb.getMinimum().z) * (-0.3f) );
-			mDistanceRange.first = 0.0;
-			mDistanceRange.second = 0.0;
-			mDesiredDistance = 0.0;
-			mPitchRange.first = Degree(-85);
-			mPitchRange.second = Degree(85);
+            mDistanceRange.first = 0.0;
+            mDistanceRange.second = 0.0;
+            mDesiredDistance = 0.0;
+            mPitchRange.first = Degree(-85);
+            mPitchRange.second = Degree(85);
             mPitch = 0;
-			LOG_MESSAGE(Logger::UI, &quot;Switch to 1st person view&quot;);
-			resetCamera();
-		}
-		else if(mode == VM_THIRD_PERSON)
-		{
+            LOG_MESSAGE(Logger::UI, &quot;Switch to 1st person view&quot;);
+            resetCamera();
+        }
+        else if(mode == VM_THIRD_PERSON)
+        {
             mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.90f, 0);
-			mDistanceRange.first = 0.60;
-			mDistanceRange.second = 7.00;
-			mDesiredDistance = 2.0;
-			mPitchRange.first = Degree(-75);
-			mPitchRange.second = Degree(85);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.0;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
             mPitch = Degree(30);
-			LOG_MESSAGE(Logger::UI, &quot;Switch to 3rd person view&quot;);			
-			resetCamera();
-		}
+            LOG_MESSAGE(Logger::UI, &quot;Switch to 3rd person view&quot;);
+            resetCamera();
+        }
         else // mode == VM_FREE_CAMERA
         {
-			mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
-			mDistanceRange.first = 0.60;
-			mDistanceRange.second = 7.00;
-			mDesiredDistance = 2.0;
-			mPitchRange.first = Degree(-75);
-			mPitchRange.second = Degree(85);
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.0;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
             mPitch = Degree(30);
             mCamYaw = mYaw;
-			LOG_MESSAGE(Logger::UI, &quot;Switch to free camera view&quot;);			
-			resetCamera();
+            LOG_MESSAGE(Logger::UI, &quot;Switch to free camera view&quot;);
+            resetCamera();
         }
-	}
+    }
 
     //------------------------------------------------------------------------
     void MovementCharacterController::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
@@ -1546,81 +1543,81 @@
     }
 
     //------------------------------------------------------------------------
-	MovementCharacterController::ViewMode MovementCharacterController::getViewMode()
-	{
-		return mViewMode;
-	}
+    MovementCharacterController::ViewMode MovementCharacterController::getViewMode()
+    {
+        return mViewMode;
+    }
 
     //------------------------------------------------------------------------
-	void MovementCharacterController::toggleViewMode()
-	{
-		if (getViewMode() == VM_THIRD_PERSON)
+    void MovementCharacterController::toggleViewMode()
+    {
+        if (getViewMode() == VM_THIRD_PERSON)
             setViewMode(VM_FIRST_PERSON);
         else if(getViewMode() == VM_FIRST_PERSON)
             setViewMode(VM_FREE_CAMERA);
         else
-            setViewMode(VM_THIRD_PERSON);         
-	}
+            setViewMode(VM_THIRD_PERSON);
+    }
 
     //------------------------------------------------------------------------
-	void MovementCharacterController::resetCamera()
-	{
+    void MovementCharacterController::resetCamera()
+    {
         Vector3 camPos;
-		Quaternion camOri;
-		mCamBody-&gt;getPositionOrientation(camPos, camOri);
+        Quaternion camOri;
+        mCamBody-&gt;getPositionOrientation(camPos, camOri);
         mCamBody-&gt;setPositionOrientation(calculateOptimalCameraPosition(false, 0.0f), camOri);
         if(mViewMode == VM_FIRST_PERSON)
             mCharacterActor-&gt;setVisible(false);
         else
             mCharacterActor-&gt;setVisible(true);
-	}
+    }
 
     //------------------------------------------------------------------------
-	bool MovementCharacterController::injectKeyDown(int keycode)
-	{
+    bool MovementCharacterController::injectKeyDown(int keycode)
+    {
         int scancode;
         mCommandMapper-&gt;decodeKey(keycode, &amp;scancode, NULL);
-		int movement = mCommandMapper-&gt;getMovement(scancode);
+        int movement = mCommandMapper-&gt;getMovement(scancode);
 
         if (movement &amp; MOVE_RUN_LOCK) // dieses einrasten lassen
         {
             mCharacterState.mCurrentMovementState ^= MOVE_RUN_LOCK;
             movement &amp;= ~MOVE_RUN_LOCK;
         }
-		if (movement != MOVE_NONE)
-		{
-			mCharacterState.mCurrentMovementState |= movement;
-			return true;
-		}
-		return false;
-	}
+        if (movement != MOVE_NONE)
+        {
+            mCharacterState.mCurrentMovementState |= movement;
+            return true;
+        }
+        return false;
+    }
 
     //------------------------------------------------------------------------
-	bool MovementCharacterController::injectKeyUp(int keycode)
-	{
+    bool MovementCharacterController::injectKeyUp(int keycode)
+    {
         int scancode;
         mCommandMapper-&gt;decodeKey(keycode, &amp;scancode, NULL);
-		int movement = mCommandMapper-&gt;getMovement(scancode);
+        int movement = mCommandMapper-&gt;getMovement(scancode);
 
-		if (movement != MOVE_NONE)
-		{
-			mCharacterState.mCurrentMovementState &amp;= (~movement | MOVE_RUN_LOCK);
-			return true;
-		}
+        if (movement != MOVE_NONE)
+        {
+            mCharacterState.mCurrentMovementState &amp;= (~movement | MOVE_RUN_LOCK);
+            return true;
+        }
         else
         {
             return startAction(mCommandMapper-&gt;getAction(keycode, CMDMAP_KEYMAP_OFF_COMBAT), mCharacter);
         }
-			
-		return false;
-	}
 
+        return false;
+    }
+
     //------------------------------------------------------------------------
-	bool MovementCharacterController::injectMouseDown(int mouseButtonMask)
-	{
+    bool MovementCharacterController::injectMouseDown(int mouseButtonMask)
+    {
       //  if (!im-&gt;isCeguiActive())
       //  {
-		    //updateSelection();
+            //updateSelection();
       //      if (im-&gt;isMouseButtonDown(1) &amp;&amp; mSelector.getSelectedObject() != NULL)
       //      {
       //          WindowFactory::getSingleton().showActionChoice(mSelector.getSelectedObject());
@@ -1630,22 +1627,22 @@
       //          mSelector.getSelectedObject()-&gt;doDefaultAction(mCharacter, NULL);
       //      }
       //  }
-	  return false;
-	}
+      return false;
+    }
 
     //------------------------------------------------------------------------
-	bool MovementCharacterController::injectMouseUp(int mouseButtonMask)
-	{
+    bool MovementCharacterController::injectMouseUp(int mouseButtonMask)
+    {
         if (!InputManager::getSingleton().isCeguiActive())
         {
-		    return startAction(mCommandMapper-&gt;getAction(mouseButtonMask,
-                CMDMAP_MOUSEMAP_OFF_COMBAT), mCharacter);		
+            return startAction(mCommandMapper-&gt;getAction(mouseButtonMask,
+                CMDMAP_MOUSEMAP_OFF_COMBAT), mCharacter);
         }
         else
         {
             return false;
         }
-	}
+    }
 
     //------------------------------------------------------------------------
     DebugVisualisableFlag MovementCharacterController::getFlag() const

Modified: rl/trunk/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ui/src/UiSubsystem.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/engine/ui/src/UiSubsystem.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -50,111 +50,110 @@
 template&lt;&gt; rl::UiSubsystem* Singleton&lt;rl::UiSubsystem&gt;::ms_Singleton = 0;
 
 namespace rl {
-	const char* UiSubsystem::CEGUI_ROOT = &quot;RootWindow&quot;;
+    const char* UiSubsystem::CEGUI_ROOT = &quot;RootWindow&quot;;
 
-	UiSubsystem&amp; UiSubsystem::getSingleton(void)
-	{
-		return Singleton&lt;UiSubsystem&gt;::getSingleton();
-	}
+    UiSubsystem&amp; UiSubsystem::getSingleton(void)
+    {
+        return Singleton&lt;UiSubsystem&gt;::getSingleton();
+    }
 
-	UiSubsystem* UiSubsystem::getSingletonPtr(void)
-	{
-		return Singleton&lt;UiSubsystem&gt;::getSingletonPtr();
-	}
+    UiSubsystem* UiSubsystem::getSingletonPtr(void)
+    {
+        return Singleton&lt;UiSubsystem&gt;::getSingletonPtr();
+    }
 
-	UiSubsystem::UiSubsystem() :
+    UiSubsystem::UiSubsystem() :
         mCharacterController(NULL),
-		mCharacterControllerType(CharacterController::CTRL_NONE),
+        mCharacterControllerType(CharacterController::CTRL_NONE),
         mHero(NULL),
         mCharacter(NULL),
-		mInputManager(NULL),
-		mWindowFactory(NULL),
-		mWindowManager(NULL),
+        mInputManager(NULL),
+        mWindowFactory(NULL),
+        mWindowManager(NULL),
         mGuiRenderer(NULL),
         mGuiResourceProvider(NULL),
         mGuiSystem(NULL)
-	{
+    {
         CoreSubsystem::getSingletonPtr()-&gt;getWorld()-&gt;addSceneChangeListener(this);
-		mWindowFactory = new WindowFactory();
-	}
+        mWindowFactory = new WindowFactory();
+    }
 
     UiSubsystem::~UiSubsystem()
     {
         CoreSubsystem::getSingletonPtr()-&gt;getWorld()-&gt;removeSceneChangeListener(this);
 
-		delete mWindowFactory;
-		delete mWindowManager;
+        delete mWindowFactory;
+        delete mWindowManager;
 
         GameLoop::getSingleton().removeTask(mCharacterController);
-		delete mCharacterController;
+        delete mCharacterController;
 
-		delete mInputManager;
+        delete mInputManager;
 
         delete mGuiSystem;
         delete mGuiResourceProvider;
         delete mGuiRenderer;
-	}
+    }
 
     void UiSubsystem::initializeSubsystem()
     {
-		using namespace CEGUI;
+        using namespace CEGUI;
 
         LOG_MESSAGE2(Logger::UI,
             &quot;Initialisiere UI&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);
         World* world = CoreSubsystem::getSingleton().getWorld();
         SceneManager* sceneMgr = world-&gt;getSceneManager();
 
-		Ogre::RenderWindow* window = Ogre::Root::getSingleton().getAutoCreatedWindow();
-		LOG_MESSAGE2(Logger::UI,
+        LOG_MESSAGE2(Logger::UI,
             &quot;Initializing CEGUI Renderer.&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);
-		mGuiRenderer = new OgreCEGUIRenderer(window,
+        mGuiRenderer = new OgreCEGUIRenderer(CoreSubsystem::getSingleton().getRenderWindow(),
             Ogre::RENDER_QUEUE_OVERLAY, false, 3000, sceneMgr);
 
-		LOG_MESSAGE2(Logger::UI,
+        LOG_MESSAGE2(Logger::UI,
             &quot;Initializing CEGUI System.&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);
         mGuiResourceProvider = new OgreCEGUIResourceProvider();
         CEGUI::System::setDefaultXMLParserName(&quot;XercesParser&quot;);
-		mGuiSystem = new System(mGuiRenderer, mGuiResourceProvider,
+        mGuiSystem = new System(mGuiRenderer, mGuiResourceProvider,
             NULL, NULL, (utf8*)&quot;cegui.config&quot;, ConfigurationManager::getSingleton().getCeguiLogFile());
-		CEGUI::Logger::getSingleton().setLoggingLevel(
+        CEGUI::Logger::getSingleton().setLoggingLevel(
             rl::Logger::getSingleton().getCeGuiLogDetail());
-		LOG_MESSAGE2(Logger::UI,
+        LOG_MESSAGE2(Logger::UI,
             &quot;CEGUI System initialized.&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);
 
-		// load scheme and set up defaults
-		///@todo Hier sollte was Lookunabh&#228;ngiges rein!!! FIXME TODO BUG!
-		System::getSingleton().setDefaultMouseCursor((utf8*)&quot;RastullahLook-Images&quot;,
+        // load scheme and set up defaults
+        ///@todo Hier sollte was Lookunabh&#228;ngiges rein!!! FIXME TODO BUG!
+        System::getSingleton().setDefaultMouseCursor((utf8*)&quot;RastullahLook-Images&quot;,
             (utf8*)&quot;MouseArrow&quot;);
-		LOG_MESSAGE2(Logger::UI, &quot;Mouse arrow loaded.&quot;,
+        LOG_MESSAGE2(Logger::UI, &quot;Mouse arrow loaded.&quot;,
             &quot;UiSubsystem::initializeUiSubsystem&quot;);
-		Window* sheet = CEGUI::WindowManager::getSingleton().createWindow((utf8*)&quot;DefaultGUISheet&quot;,
+        Window* sheet = CEGUI::WindowManager::getSingleton().createWindow((utf8*)&quot;DefaultGUISheet&quot;,
             (utf8*)CEGUI_ROOT);
-		LOG_MESSAGE2(Logger::UI, &quot;CEGUI Root Window created.&quot;,
+        LOG_MESSAGE2(Logger::UI, &quot;CEGUI Root Window created.&quot;,
             &quot;UiSubsystem::initializeUiSubsystem&quot;);
-		sheet-&gt;setSize(
+        sheet-&gt;setSize(
             CeGuiHelper::asAbsolute(CEGUI::Vector2(
-                Ogre::Root::getSingleton().getAutoCreatedWindow()-&gt;getWidth(),
-				Ogre::Root::getSingleton().getAutoCreatedWindow()-&gt;getHeight())));
-		sheet-&gt;setPosition(CeGuiHelper::asAbsolute(CEGUI::Point(0, 0)));
-		System::getSingleton().setGUISheet(sheet);
+                CoreSubsystem::getSingleton().getRenderWindow()-&gt;getWidth(),
+                CoreSubsystem::getSingleton().getRenderWindow()-&gt;getHeight())));
+        sheet-&gt;setPosition(CeGuiHelper::asAbsolute(CEGUI::Point(0, 0)));
+        System::getSingleton().setGUISheet(sheet);
         sheet-&gt;setZOrderingEnabled(true);
         sheet-&gt;moveToBack();
-		System::getSingleton().setDefaultTooltip(&quot;RastullahLook/Tooltip&quot;);
+        System::getSingleton().setDefaultTooltip(&quot;RastullahLook/Tooltip&quot;);
         LOG_MESSAGE2(Logger::UI, &quot;CEGUI initialized.&quot;,
             &quot;UiSubsystem::initializeUiSubsystem&quot;);
 
-		mWindowManager = new WindowManager();
+        mWindowManager = new WindowManager();
 
-		//Initializing InputManager
-        mInputManager = new InputManager(Ogre::Root::getSingleton().getAutoCreatedWindow());
-		LOG_MESSAGE2(Logger::UI, &quot;InputManager started.&quot;,
+        //Initializing InputManager
+        mInputManager = new InputManager(CoreSubsystem::getSingleton().getRenderWindow());
+        LOG_MESSAGE2(Logger::UI, &quot;InputManager started.&quot;,
             &quot;UiSubsystem::initializeUiSubsystem&quot;);
 
-		mInputManager-&gt;loadKeyMapping(ConfigurationManager::getSingleton().getKeymap());
-		LOG_MESSAGE2(Logger::UI, &quot;Keymap geladen&quot;,
+        mInputManager-&gt;loadKeyMapping(ConfigurationManager::getSingleton().getKeymap());
+        LOG_MESSAGE2(Logger::UI, &quot;Keymap geladen&quot;,
             &quot;UiSubsystem::initializeUiSubsystem&quot;);
-        mInputManager-&gt;loadCommandMapping(ConfigurationManager::getSingleton().getInputConfigPath());
-		LOG_MESSAGE2(Logger::UI, &quot;UI-Manager loaded.&quot;,
+        mInputManager-&gt;buildCommandMapping(ConfigurationManager::getSingleton().getInputSettings());
+        LOG_MESSAGE2(Logger::UI, &quot;UI-Manager loaded.&quot;,
             &quot;UiSubsystem::initializeUiSubsystem&quot;);
 
         mWindowFactory-&gt;initialize();
@@ -166,18 +165,18 @@
     }
 
 
-	CEGUI::OgreCEGUIRenderer* UiSubsystem::getGUIRenderer()
-	{
-		return mGuiRenderer;
-	}
+    CEGUI::OgreCEGUIRenderer* UiSubsystem::getGUIRenderer()
+    {
+        return mGuiRenderer;
+    }
 
-	Person* UiSubsystem::getActiveCharacter() const
-	{
-		return mCharacter;
-	}
+    Person* UiSubsystem::getActiveCharacter() const
+    {
+        return mCharacter;
+    }
 
-	void UiSubsystem::setActiveCharacter(Person* person)
-	{
+    void UiSubsystem::setActiveCharacter(Person* person)
+    {
         // Ensure we have a sound listener
         if (SoundManager::getSingleton().getListenerActor() == NULL)
         {
@@ -187,58 +186,58 @@
         // Nur wenn es sich ver&#228;ndert hat
         if( person != mCharacter )
         {
-			if( mCharacter != NULL )
-			{
-				ScriptWrapper::getSingleton().disowned( mCharacter );
-				mCharacter-&gt;getActor()-&gt;detach(SoundManager::getSingleton().getListenerActor());
-			}
+            if( mCharacter != NULL )
+            {
+                ScriptWrapper::getSingleton().disowned( mCharacter );
+                mCharacter-&gt;getActor()-&gt;detach(SoundManager::getSingleton().getListenerActor());
+            }
 
             World* world = CoreSubsystem::getSingletonPtr()-&gt;getWorld();
 
-			if (person == NULL)
-			{
-				mCharacter = NULL;
+            if (person == NULL)
+            {
+                mCharacter = NULL;
                 world-&gt;setActiveActor( ActorManager::getSingleton().getActor(&quot;DefaultCamera&quot;) );
-			}
-			else
-			{
-				ScriptWrapper::getSingleton().owned( person );
-				mCharacter = person;
+            }
+            else
+            {
+                ScriptWrapper::getSingleton().owned( person );
+                mCharacter = person;
 
-				world-&gt;setActiveActor(person-&gt;getActor());
-				mWindowFactory-&gt;setActiveCharacter(person);
+                world-&gt;setActiveActor(person-&gt;getActor());
+                mWindowFactory-&gt;setActiveCharacter(person);
 
-				mCharacter-&gt;getActor()-&gt;attach(SoundManager::getSingleton().getListenerActor());
-				LOG_MESSAGE(Logger::UI, &quot;SoundListener attached.&quot;);
+                mCharacter-&gt;getActor()-&gt;attach(SoundManager::getSingleton().getListenerActor());
+                LOG_MESSAGE(Logger::UI, &quot;SoundListener attached.&quot;);
 
-				setCharacterController(CharacterController::CTRL_MOVEMENT);
-			}
+                setCharacterController(CharacterController::CTRL_MOVEMENT);
+            }
         }
-	}
+    }
 
-	void UiSubsystem::requestCharacterControllerSwitch(CharacterController::ControllerType type)
-	{
-		mCharacterControllerType = type;
-	}
+    void UiSubsystem::requestCharacterControllerSwitch(CharacterController::ControllerType type)
+    {
+        mCharacterControllerType = type;
+    }
 
-	void UiSubsystem::setCharacterController(CharacterController::ControllerType type)
-	{
-		if (mCharacterController != NULL)
-		{
-			if (mCharacterController-&gt;getType() == type)
-				return;
+    void UiSubsystem::setCharacterController(CharacterController::ControllerType type)
+    {
+        if (mCharacterController != NULL)
+        {
+            if (mCharacterController-&gt;getType() == type)
+                return;
 
-			GameLoop::getSingleton().removeTask(mCharacterController);
-			delete mCharacterController;
+            GameLoop::getSingleton().removeTask(mCharacterController);
+            delete mCharacterController;
             mCharacterController = NULL;
-			LOG_MESSAGE(Logger::UI,
+            LOG_MESSAGE(Logger::UI,
                 &quot;Old CharacterController deleted.&quot;);
-		}
+        }
 
-   		if( type == CharacterController::CTRL_NONE )
+           if( type == CharacterController::CTRL_NONE )
         {
-			mCharacterController = NULL;
-			return;
+            mCharacterController = NULL;
+            return;
         }
 
         Actor* camera = ActorManager::getSingleton().getActor(&quot;DefaultCamera&quot;);
@@ -248,71 +247,71 @@
             return;
         }
 
-		if (type == CharacterController::CTRL_MOVEMENT)
+        if (type == CharacterController::CTRL_MOVEMENT)
         {
-			mCharacterController = new MovementCharacterController(camera, mCharacter);
-			if (!PhysicsManager::getSingleton().isEnabled())
-			{
-				PhysicsManager::getSingleton().setEnabled(true);
-			}
+            mCharacterController = new MovementCharacterController(camera, mCharacter);
+            if (!PhysicsManager::getSingleton().isEnabled())
+            {
+                PhysicsManager::getSingleton().setEnabled(true);
+            }
         }
-		else if (type == CharacterController::CTRL_FREEFLIGHT)
+        else if (type == CharacterController::CTRL_FREEFLIGHT)
         {
-			mCharacterController = new FreeFlightCharacterController(camera,
+            mCharacterController = new FreeFlightCharacterController(camera,
                 CoreSubsystem::getSingleton().getWorld()-&gt;getActiveActor());
         }
-		else if (type == CharacterController::CTRL_DIALOG)
+        else if (type == CharacterController::CTRL_DIALOG)
         {
-			mCharacterController = new DialogCharacterController(camera,
+            mCharacterController = new DialogCharacterController(camera,
                 CoreSubsystem::getSingleton().getWorld()-&gt;getActiveActor());
         }
-		else if (type == CharacterController::CTRL_VANITY_MODE)
+        else if (type == CharacterController::CTRL_VANITY_MODE)
         {
-			mCharacterController = new VanityModeCharacterController(camera,
+            mCharacterController = new VanityModeCharacterController(camera,
                 CoreSubsystem::getSingleton().getWorld()-&gt;getActiveActor());
         }
-		else if (type == CharacterController::CTRL_CUTSCENE)
+        else if (type == CharacterController::CTRL_CUTSCENE)
         {
-			mCharacterController = new CutsceneCharacterController(camera);
+            mCharacterController = new CutsceneCharacterController(camera);
         }
         else
         {
-			Throw(IllegalArgumentException, &quot;Unknown CharacterControllerType.&quot;);
-		}
-		mCharacterControllerType = type;
+            Throw(IllegalArgumentException, &quot;Unknown CharacterControllerType.&quot;);
+        }
+        mCharacterControllerType = type;
 
-		mInputManager-&gt;setCharacterController(mCharacterController);
+        mInputManager-&gt;setCharacterController(mCharacterController);
 
-	    LOG_MESSAGE(Logger::UI, &quot;CharacterController created.&quot;);
+        LOG_MESSAGE(Logger::UI, &quot;CharacterController created.&quot;);
         GameLoop::getSingleton().addTask(mCharacterController, GameLoop::TG_INPUT);
         LOG_MESSAGE(Logger::UI, &quot;CharacterController task added.&quot;);
-	}
+    }
 
-	void UiSubsystem::run(Ogre::Real timeElapsed)
-	{
-		setCharacterController(mCharacterControllerType);
-	}
+    void UiSubsystem::run(Ogre::Real timeElapsed)
+    {
+        setCharacterController(mCharacterControllerType);
+    }
 
     CharacterController* UiSubsystem::getCharacterController() const
     {
         return mCharacterController;
     }
 
-	CharacterController::ControllerType UiSubsystem::getCharacterControllerType() const
-	{
-		if (mCharacterController == NULL)
-			return CharacterController::CTRL_NONE;
+    CharacterController::ControllerType UiSubsystem::getCharacterControllerType() const
+    {
+        if (mCharacterController == NULL)
+            return CharacterController::CTRL_NONE;
 
-		return mCharacterController-&gt;getType();
-	}
+        return mCharacterController-&gt;getType();
+    }
 
     void UiSubsystem::onBeforeClearScene()
     {
-		if (mCharacterController != NULL)
-		{
+        if (mCharacterController != NULL)
+        {
             setCharacterController(CharacterController::CTRL_NONE);
-			setActiveCharacter(NULL);
-		}
+            setActiveCharacter(NULL);
+        }
     }
 
     const Ogre::String&amp; UiSubsystem::getName() const

Modified: rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h
===================================================================
--- rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -31,104 +31,113 @@
 namespace rl
 {
 
-typedef map&lt;Ogre::String, StringList&gt; DriverMap;
+    typedef map&lt;Ogre::String, StringList&gt; DriverMap;
 
-#define CHECK_FMOD4_ERRORS(fmod4_errorcode)\
-{\
-    if (fmod4_errorcode != FMOD_OK)\
+    #define CHECK_FMOD4_ERRORS(fmod4_errorcode)\
     {\
-        Throw(rl::RuntimeException,\
-            &quot;FMOD error #&quot;\
-            + StringConverter::toString(fmod4_errorcode)\
-            + &quot; &quot;\
-            + FMOD_ErrorString(fmod4_errorcode));\
-    }\
-}
+        if (fmod4_errorcode != FMOD_OK)\
+        {\
+            Throw(rl::RuntimeException,\
+                &quot;FMOD error #&quot;\
+                + StringConverter::toString(fmod4_errorcode)\
+                + &quot; &quot;\
+                + FMOD_ErrorString(fmod4_errorcode));\
+        }\
+    }
 
+    /** Diese Klasse ist der Treiber, der OpenAL zur
+     * Ausgabe benutzt.
+     */
+    class _RlFmod4DriverExport Fmod4Driver : public rl::SoundDriver
+    {
+    public:
+        /// Der Treibername
+        static Ogre::String NAME;
+        /// Der Konstruktor
+        Fmod4Driver(Ogre::ResourceManager* soundResourceManager);
+        /// Der Destruktor
+        virtual ~Fmod4Driver();
+        /// Ist der Treiber angeschaltet?
+        virtual bool isDriverAvailable();
+        /// Initialisiere den Treiber.
+        virtual bool initialize();
+        /// Deinitialisiere den Treiber.
+        virtual void shutdown();
+        /// Der Name des Treibers
+        virtual Ogre::String getName() const;
+        /// Update-Aufgaben erledigen
+        virtual void update();
+        /// Einen Sound-Stream mit Resource erzeugen
+        virtual Sound *createStream(const SoundResourcePtr &amp;res);
+        /// Einen Sound-Sample mit Resource erzeugen
+        virtual Sound *createSample(const SoundResourcePtr &amp;res);
+        /// Einen Soundlistener erzeugen
+        virtual ListenerMovable *createListener(const Ogre::String &amp;name);
 
-/** Diese Klasse ist der Treiber, der OpenAL zur
- * Ausgabe benutzt.
- */
-class _RlFmod4DriverExport Fmod4Driver : public rl::SoundDriver
-{
-public:
-	/// Der Treibername
-    static Ogre::String NAME;
-    /// Der Konstruktor
-	Fmod4Driver(Ogre::ResourceManager* soundResourceManager);
-    /// Der Destruktor
-	virtual ~Fmod4Driver();
-    /// Ist der Treiber angeschaltet?
-    virtual bool isDriverAvailable();
-    /// Initialisiere den Treiber.
-    virtual bool initialize();
-    /// Deinitialisiere den Treiber.
-    virtual void shutdown();
-    /// Der Name des Treibers
-    virtual Ogre::String getName() const;
-    /// Update-Aufgaben erledigen
-    virtual void update();
-    /// Einen Sound-Stream mit Resource erzeugen
-    virtual Sound *createStream(const SoundResourcePtr &amp;res);
-    /// Einen Sound-Sample mit Resource erzeugen
-    virtual Sound *createSample(const SoundResourcePtr &amp;res);
-    /// Einen Soundlistener erzeugen
-    virtual ListenerMovable *createListener(const Ogre::String &amp;name);
+        virtual void setMasterVolume(const Ogre::Real&amp; vol);
 
-    virtual void setMasterVolume(const Ogre::Real&amp; vol);
+        /**
+         * Returns the current sound driver settings as a key-value list
+         *
+         * @return key-value list of sound options
+         */
+        virtual Ogre::NameValuePairList getSettings() const;
 
-    /// Die Einstellungen in Datei schreiben
-    virtual void saveConf(rl::ConfigFile &amp;conf) const;
-    /// Die Einstellungen laden
-    virtual void loadConf(rl::ConfigFile &amp;conf);
+        /**
+         * Sets certain options for the sound driver, like volume settings for
+         * sound effects and music.
+         *
+         * @param settings key-value list of settings
+         */
+        virtual void applySettings(const Ogre::NameValuePairList&amp; settings);
 
-    /// Setzt den Faktor f, mit der die Lautst&#239;&#191;&#189;rke nach der Formel 1/(f*Entfernung) abnimmt
-	virtual void setRolloffFactor(const Ogre::Real&amp;);
-	virtual const Ogre::Real getRolloffFactor();
+        /// Setzt den Faktor f, mit der die Lautst&#239;&#191;&#189;rke nach der Formel 1/(f*Entfernung) abnimmt
+        virtual void setRolloffFactor(const Ogre::Real&amp;);
+        virtual const Ogre::Real getRolloffFactor();
 
-	/// Datensammlung zurueckgeben
-	const DriverMap&amp; getDriverData() const;
+        /// Datensammlung zurueckgeben
+        const DriverMap&amp; getDriverData() const;
 
-    FMOD::System* _getFmodSystem();
+        FMOD::System* _getFmodSystem();
 
-private:
-    /// Informationen &#239;&#191;&#189;ber den Treiber ausgeben
-    virtual void printData() const;
-    void printDriverInfo(int driver) const;
+    private:
+        /// Informationen &#239;&#191;&#189;ber den Treiber ausgeben
+        virtual void printData() const;
+        void printDriverInfo(int driver) const;
 
-    // Wir merken uns die Konfiguration von Fmod4
-	DriverMap mDriverData;
-    FMOD::System* mFmod4System;
-    FMOD::ChannelGroup* mMasterChannelGroup;
+        // Wir merken uns die Konfiguration von Fmod4
+        DriverMap mDriverData;
+        FMOD::System* mFmod4System;
+        FMOD::ChannelGroup* mMasterChannelGroup;
 
-    static FMOD_RESULT F_CALLBACK open(
-        const char *  name, 
-        int  unicode, 
-        unsigned int *  filesize, 
-        void **  handle, 
-        void **  userdata
-    );
+        static FMOD_RESULT F_CALLBACK open(
+            const char *  name,
+            int  unicode,
+            unsigned int *  filesize,
+            void **  handle,
+            void **  userdata
+        );
 
-    static FMOD_RESULT F_CALLBACK close(
-        void *  handle, 
-        void *  userdata
-    );
+        static FMOD_RESULT F_CALLBACK close(
+            void *  handle,
+            void *  userdata
+        );
 
-    static FMOD_RESULT F_CALLBACK read(
-        void *  handle, 
-        void *  buffer, 
-        unsigned int  sizebytes, 
-        unsigned int *  bytesread, 
-        void *  userdata
-    );
+        static FMOD_RESULT F_CALLBACK read(
+            void *  handle,
+            void *  buffer,
+            unsigned int  sizebytes,
+            unsigned int *  bytesread,
+            void *  userdata
+        );
 
-    static FMOD_RESULT F_CALLBACK seek(
-        void *  handle, 
-        unsigned int  pos, 
-        void *  userdata
-    );
+        static FMOD_RESULT F_CALLBACK seek(
+            void *  handle,
+            unsigned int  pos,
+            void *  userdata
+        );
 
-};
+    };
 
 }
 

Modified: rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -24,339 +24,337 @@
 
 namespace rl
 {
-String Fmod4Driver::NAME = &quot;FMOD4&quot;;
+    String Fmod4Driver::NAME = &quot;RlFmod4Driver&quot;;
 
-Fmod4Driver::Fmod4Driver(Ogre::ResourceManager *soundResourceManager)
-    : SoundDriver(soundResourceManager),
-    mMasterChannelGroup(NULL)
-{    
-}
+    Fmod4Driver::Fmod4Driver(Ogre::ResourceManager *soundResourceManager)
+        : SoundDriver(soundResourceManager),
+        mMasterChannelGroup(NULL)
+    {
+    }
 
-Fmod4Driver::~Fmod4Driver()
-{
-}
+    Fmod4Driver::~Fmod4Driver()
+    {
+    }
 
-String Fmod4Driver::getName() const
-{
-    return NAME;
-}
+    String Fmod4Driver::getName() const
+    {
+        return NAME;
+    }
 
-bool Fmod4Driver::initialize()
-{
-    static int MAX_VIRTUAL_CHANNELS = 100;
+    bool Fmod4Driver::initialize()
+    {
+        static int MAX_VIRTUAL_CHANNELS = 100;
 
-    CHECK_FMOD4_ERRORS(FMOD::System_Create(&amp;mFmod4System));
-    
-    mFmod4System-&gt;setFileSystem(
-        Fmod4Driver::open,
-        Fmod4Driver::close,
-        Fmod4Driver::read,
-        Fmod4Driver::seek,
-        -1);
+        CHECK_FMOD4_ERRORS(FMOD::System_Create(&amp;mFmod4System));
 
-    printData();
+        mFmod4System-&gt;setFileSystem(
+            Fmod4Driver::open,
+            Fmod4Driver::close,
+            Fmod4Driver::read,
+            Fmod4Driver::seek,
+            -1);
 
-    mFmod4System-&gt;setDriver(-1);
-    //CHECK_FMOD4_ERRORS(mFmod4System-&gt;setOutput(FMOD_OUTPUTTYPE_ESD));
-    
-    FMOD_RESULT result = mFmod4System-&gt;init(MAX_VIRTUAL_CHANNELS, FMOD_INIT_NORMAL, NULL); //Alternative: ,Output)
-    if (result != FMOD_OK)
-    {
-        LOG_ERROR(Logger::CORE,
-            &quot;FMOD error #&quot;
-            + StringConverter::toString(result)
-            + &quot; &quot;
-            + FMOD_ErrorString(result));
-            
-        return false;
-    }
-    
-    mFmod4System-&gt;getMasterChannelGroup(&amp;mMasterChannelGroup);
-    return true;
-}
+        printData();
 
-void Fmod4Driver::shutdown()
-{
-    CHECK_FMOD4_ERRORS(mFmod4System-&gt;close());
-    CHECK_FMOD4_ERRORS(mFmod4System-&gt;release());
-}
+        mFmod4System-&gt;setDriver(-1);
+        //CHECK_FMOD4_ERRORS(mFmod4System-&gt;setOutput(FMOD_OUTPUTTYPE_ESD));
 
-bool Fmod4Driver::isDriverAvailable()
-{
-    FMOD::System* system;
-    FMOD_RESULT result = FMOD::System_Create(&amp;system);
-    if (result != FMOD_OK)
-    {
-        return false;
-    }
+        FMOD_RESULT result = mFmod4System-&gt;init(MAX_VIRTUAL_CHANNELS, FMOD_INIT_NORMAL, NULL); //Alternative: ,Output)
+        if (result != FMOD_OK)
+        {
+            LOG_ERROR(Logger::CORE,
+                &quot;FMOD error #&quot;
+                + StringConverter::toString(result)
+                + &quot; &quot;
+                + FMOD_ErrorString(result));
 
-    system-&gt;release();
-    return true;
-}
+            return false;
+        }
 
-void Fmod4Driver::update()
-{
-    mFmod4System-&gt;update();
-}
+        mFmod4System-&gt;getMasterChannelGroup(&amp;mMasterChannelGroup);
+        return true;
+    }
 
-/**
-  * Einen Sound-Stream mit Resource erzeugen
-  * @return Der erzeugte Stream
-  * @author JoSch
-  * @date 03-06-2006
-  */
-Sound *Fmod4Driver::createStream(const SoundResourcePtr &amp;res)
-{
- 	Sound *sound = new Fmod4Sound(this, res, Fmod4Sound::STREAM);
- 	return sound;
-}
+    void Fmod4Driver::shutdown()
+    {
+        CHECK_FMOD4_ERRORS(mFmod4System-&gt;close());
+        CHECK_FMOD4_ERRORS(mFmod4System-&gt;release());
+    }
 
-/**
- * Einen Sound-Sample mit Resource erzeugen
- * @return Das erzeugte Sample
- * @author JoSch
- * @date 03-06-2006
- */
-Sound *Fmod4Driver::createSample(const SoundResourcePtr &amp;res)
-{
-    Sound *sound = new Fmod4Sound(this, res, Fmod4Sound::SAMPLE);
- 	return sound;
-}
+    bool Fmod4Driver::isDriverAvailable()
+    {
+        FMOD::System* system;
+        FMOD_RESULT result = FMOD::System_Create(&amp;system);
+        if (result != FMOD_OK)
+        {
+            return false;
+        }
 
-ListenerMovable *Fmod4Driver::createListener(const Ogre::String &amp;name)
-{
-    return new Fmod4Listener(name, mFmod4System);
-}
+        system-&gt;release();
+        return true;
+    }
 
-FMOD::System* Fmod4Driver::_getFmodSystem()
-{
-    return mFmod4System;
-}
+    void Fmod4Driver::update()
+    {
+        mFmod4System-&gt;update();
+    }
 
-void Fmod4Driver::loadConf(rl::ConfigFile &amp;conf)
-{
-    SoundDriver::loadConf(conf);
-    mMasterChannelGroup-&gt;setVolume(mMasterVolume);
-}
+    /**
+      * Einen Sound-Stream mit Resource erzeugen
+      * @return Der erzeugte Stream
+      * @author JoSch
+      * @date 03-06-2006
+      */
+    Sound *Fmod4Driver::createStream(const SoundResourcePtr &amp;res)
+    {
+         Sound *sound = new Fmod4Sound(this, res, Fmod4Sound::STREAM);
+         return sound;
+    }
 
-void Fmod4Driver::saveConf(rl::ConfigFile &amp;conf) const
-{
-    SoundDriver::saveConf(conf);
-}
+    /**
+     * Einen Sound-Sample mit Resource erzeugen
+     * @return Das erzeugte Sample
+     * @author JoSch
+     * @date 03-06-2006
+     */
+    Sound *Fmod4Driver::createSample(const SoundResourcePtr &amp;res)
+    {
+        Sound *sound = new Fmod4Sound(this, res, Fmod4Sound::SAMPLE);
+         return sound;
+    }
 
-void Fmod4Driver::printData() const
-{
-    int numDrivers;
-    mFmod4System-&gt;getNumDrivers(&amp;numDrivers);
+    ListenerMovable *Fmod4Driver::createListener(const Ogre::String &amp;name)
+    {
+        return new Fmod4Listener(name, mFmod4System);
+    }
 
-    for (int i = 0; i &lt; numDrivers; i++)
+    FMOD::System* Fmod4Driver::_getFmodSystem()
     {
-        printDriverInfo(i);
+        return mFmod4System;
     }
 
-    int numPlugins;
-    mFmod4System-&gt;getNumPlugins(FMOD_PLUGINTYPE_CODEC, &amp;numPlugins);
-    for (int i = 0; i &lt; numDrivers; i++)
+    void Fmod4Driver::applySettings(const Ogre::NameValuePairList&amp; settings)
     {
-        char pluginName[128];
-        unsigned int version;
+        SoundDriver::applySettings(settings);
+        mMasterChannelGroup-&gt;setVolume(mMasterVolume);
+    }
 
-        mFmod4System-&gt;getPluginInfo(
-            FMOD_PLUGINTYPE_CODEC,
-            i,
-            pluginName,
-            127,
-            &amp;version);
-        LOG_MESSAGE(Logger::MULTIMEDIA, 
-            String(&quot;Fmod4Driver Plugin '&quot;)
-            + pluginName
-            + &quot;' Version &quot;
-            + StringConverter::toString(version));
+    Ogre::NameValuePairList Fmod4Driver::getSettings() const
+    {
+        return SoundDriver::getSettings();
     }
-}
 
-void Fmod4Driver::printDriverInfo(int driver) const
-{
-    int curdriver;
-    mFmod4System-&gt;getDriver(&amp;curdriver);
+    void Fmod4Driver::printData() const
+    {
+        int numDrivers;
+        mFmod4System-&gt;getNumDrivers(&amp;numDrivers);
 
-    char name[128];
-    mFmod4System-&gt;getDriverName(driver, name, 127);
+        for (int i = 0; i &lt; numDrivers; i++)
+        {
+            printDriverInfo(i);
+        }
 
-    FMOD_CAPS caps;
-    int minfreq, maxfreq;
-    FMOD_SPEAKERMODE speakermode;
-    mFmod4System-&gt;getDriverCaps(driver, &amp;caps, &amp;minfreq, &amp;maxfreq, &amp;speakermode);
+        int numPlugins;
+        mFmod4System-&gt;getNumPlugins(FMOD_PLUGINTYPE_CODEC, &amp;numPlugins);
+        for (int i = 0; i &lt; numDrivers; i++)
+        {
+            char pluginName[128];
+            unsigned int version;
 
-    LOG_MESSAGE(Logger::MULTIMEDIA, 
-        String(&quot;Fmod4Driver '&quot;)
-        + name 
-        + &quot;'&quot;
-        + (driver == curdriver ? &quot;(cur)&quot; : &quot;&quot;)
-        + &quot;: \n&quot;
-        + &quot;Freq &quot; + StringConverter::toString(minfreq)
-        + &quot; - &quot; + StringConverter::toString(maxfreq));
+            mFmod4System-&gt;getPluginInfo(
+                FMOD_PLUGINTYPE_CODEC,
+                i,
+                pluginName,
+                127,
+                &amp;version);
+            LOG_MESSAGE(Logger::MULTIMEDIA,
+                String(&quot;Fmod4Driver Plugin '&quot;)
+                + pluginName
+                + &quot;' Version &quot;
+                + StringConverter::toString(version));
+        }
+    }
 
-    int hard2d, hard3d, hardtotal;
-    mFmod4System-&gt;getHardwareChannels(&amp;hard2d, &amp;hard3d, &amp;hardtotal);
-    LOG_MESSAGE(Logger::MULTIMEDIA, 
-        String(&quot;Fmod4Driver '&quot;)
-        + name + &quot;' Hardware Channels: &quot;
-        + &quot;2D #&quot; + StringConverter::toString(hard2d)
-        + &quot;, 3D #&quot; + StringConverter::toString(hard3d)
-        + &quot;, Total #&quot; + StringConverter::toString(hardtotal));
+    void Fmod4Driver::printDriverInfo(int driver) const
+    {
+        int curdriver;
+        mFmod4System-&gt;getDriver(&amp;curdriver);
 
-    int softchannels;
-    mFmod4System-&gt;getSoftwareChannels(&amp;softchannels);
-    LOG_MESSAGE(Logger::MULTIMEDIA, 
-        String(&quot;Fmod4Driver '&quot;)
-        + name + &quot;' Software Channels: &quot;
-        + &quot;#&quot; + StringConverter::toString(softchannels));
+        char name[128];
+        mFmod4System-&gt;getDriverName(driver, name, 127);
 
-    FMOD_OUTPUTTYPE output;
-    mFmod4System-&gt;getOutput(&amp;output);
-    String outputName;
+        FMOD_CAPS caps;
+        int minfreq, maxfreq;
+        FMOD_SPEAKERMODE speakermode;
+        mFmod4System-&gt;getDriverCaps(driver, &amp;caps, &amp;minfreq, &amp;maxfreq, &amp;speakermode);
 
-    if(output == FMOD_OUTPUTTYPE_AUTODETECT)
-		outputName = &quot;Autodetect&quot;;
-    else if(output == FMOD_OUTPUTTYPE_UNKNOWN)
-		outputName = &quot;Unknown&quot;;
-    else if(output == FMOD_OUTPUTTYPE_NOSOUND)
-		outputName = &quot;No Sound&quot;;
-    else if(output == FMOD_OUTPUTTYPE_WAVWRITER)
-		outputName = &quot;Wave Writer&quot;;
-    else if(output == FMOD_OUTPUTTYPE_NOSOUND_NRT)
-		outputName = &quot;No Sound non realtime&quot;;
-    else if(output == FMOD_OUTPUTTYPE_WAVWRITER_NRT)
-		outputName = &quot;Wave Writer non realtime&quot;;
-    else if(output == FMOD_OUTPUTTYPE_DSOUND)
-		outputName = &quot;DirectSound&quot;;
-    else if(output == FMOD_OUTPUTTYPE_WINMM)
-		outputName = &quot;Windows Multimedia&quot;;
-    else if(output == FMOD_OUTPUTTYPE_ASIO)
-		outputName = &quot;Low Latency ASIO driver&quot;;
-    else if(output == FMOD_OUTPUTTYPE_OSS)
-		outputName = &quot;Open Sound System (OSS)&quot;;
-    else if(output == FMOD_OUTPUTTYPE_ALSA)
-		outputName = &quot;Advanced Linux Sound Architecture (ALSA)&quot;;
-    else if(output == FMOD_OUTPUTTYPE_ESD)
-		outputName = &quot;Enlightment Sound Daemon (ESD)&quot;;
-    else if(output == FMOD_OUTPUTTYPE_SOUNDMANAGER)
-		outputName = &quot;Macintosh SoundManager&quot;;
-    else if(output == FMOD_OUTPUTTYPE_COREAUDIO)
-		outputName = &quot;Macintosh CoreAudio&quot;;
+        LOG_MESSAGE(Logger::MULTIMEDIA,
+            String(&quot;Fmod4Driver '&quot;)
+            + name
+            + &quot;'&quot;
+            + (driver == curdriver ? &quot;(cur)&quot; : &quot;&quot;)
+            + &quot;: \n&quot;
+            + &quot;Freq &quot; + StringConverter::toString(minfreq)
+            + &quot; - &quot; + StringConverter::toString(maxfreq));
 
-    LOG_MESSAGE(Logger::MULTIMEDIA, 
-        String(&quot;Fmod4Driver '&quot;)
-        + name + &quot;' Output: &quot; + outputName);   
-}
+        int hard2d, hard3d, hardtotal;
+        mFmod4System-&gt;getHardwareChannels(&amp;hard2d, &amp;hard3d, &amp;hardtotal);
+        LOG_MESSAGE(Logger::MULTIMEDIA,
+            String(&quot;Fmod4Driver '&quot;)
+            + name + &quot;' Hardware Channels: &quot;
+            + &quot;2D #&quot; + StringConverter::toString(hard2d)
+            + &quot;, 3D #&quot; + StringConverter::toString(hard3d)
+            + &quot;, Total #&quot; + StringConverter::toString(hardtotal));
 
-FMOD_RESULT F_CALLBACK Fmod4Driver::open(
-    const char *  name, 
-    int  unicode, 
-    unsigned int *  filesize, 
-    void **  handle, 
-    void **  userdata)
-{
-    SoundResourcePtr* res = new SoundResourcePtr(sSoundResourceManager-&gt;getByName(name));
-    LOG_DEBUG(Logger::MULTIMEDIA, 
-		&quot;Opened stream &quot; + (*res)-&gt;getName());
-    (*res)-&gt;load();
-    *filesize = (*res)-&gt;getSize();
-    *handle = res;
-    return FMOD_OK;
-}
+        int softchannels;
+        mFmod4System-&gt;getSoftwareChannels(&amp;softchannels);
+        LOG_MESSAGE(Logger::MULTIMEDIA,
+            String(&quot;Fmod4Driver '&quot;)
+            + name + &quot;' Software Channels: &quot;
+            + &quot;#&quot; + StringConverter::toString(softchannels));
 
-FMOD_RESULT F_CALLBACK Fmod4Driver::close(
-    void *  handle, 
-    void *  userdata)
-{
-   	SoundResourcePtr *res = static_cast&lt;SoundResourcePtr*&gt;(handle);
-    LOG_DEBUG(Logger::MULTIMEDIA, 
-		&quot;Closing stream &quot; + (*res)-&gt;getName());
-    (*res)-&gt;unload();
-    delete res;
-    return FMOD_OK;
-}
+        FMOD_OUTPUTTYPE output;
+        mFmod4System-&gt;getOutput(&amp;output);
+        String outputName;
 
-FMOD_RESULT F_CALLBACK Fmod4Driver::read(
-    void *  handle, 
-    void *  buffer, 
-    unsigned int  sizebytes, 
-    unsigned int *  bytesread, 
-    void *  userdata)
-{
-    if (handle == NULL)
+        if(output == FMOD_OUTPUTTYPE_AUTODETECT)
+            outputName = &quot;Autodetect&quot;;
+        else if(output == FMOD_OUTPUTTYPE_UNKNOWN)
+            outputName = &quot;Unknown&quot;;
+        else if(output == FMOD_OUTPUTTYPE_NOSOUND)
+            outputName = &quot;No Sound&quot;;
+        else if(output == FMOD_OUTPUTTYPE_WAVWRITER)
+            outputName = &quot;Wave Writer&quot;;
+        else if(output == FMOD_OUTPUTTYPE_NOSOUND_NRT)
+            outputName = &quot;No Sound non realtime&quot;;
+        else if(output == FMOD_OUTPUTTYPE_WAVWRITER_NRT)
+            outputName = &quot;Wave Writer non realtime&quot;;
+        else if(output == FMOD_OUTPUTTYPE_DSOUND)
+            outputName = &quot;DirectSound&quot;;
+        else if(output == FMOD_OUTPUTTYPE_WINMM)
+            outputName = &quot;Windows Multimedia&quot;;
+        else if(output == FMOD_OUTPUTTYPE_ASIO)
+            outputName = &quot;Low Latency ASIO driver&quot;;
+        else if(output == FMOD_OUTPUTTYPE_OSS)
+            outputName = &quot;Open Sound System (OSS)&quot;;
+        else if(output == FMOD_OUTPUTTYPE_ALSA)
+            outputName = &quot;Advanced Linux Sound Architecture (ALSA)&quot;;
+        else if(output == FMOD_OUTPUTTYPE_ESD)
+            outputName = &quot;Enlightment Sound Daemon (ESD)&quot;;
+        else if(output == FMOD_OUTPUTTYPE_SOUNDMANAGER)
+            outputName = &quot;Macintosh SoundManager&quot;;
+        else if(output == FMOD_OUTPUTTYPE_COREAUDIO)
+            outputName = &quot;Macintosh CoreAudio&quot;;
+
+        LOG_MESSAGE(Logger::MULTIMEDIA,
+            String(&quot;Fmod4Driver '&quot;)
+            + name + &quot;' Output: &quot; + outputName);
+    }
+
+    FMOD_RESULT F_CALLBACK Fmod4Driver::open(
+        const char *  name,
+        int  unicode,
+        unsigned int *  filesize,
+        void **  handle,
+        void **  userdata)
     {
-        return FMOD_ERR_INVALID_PARAM;
+        SoundResourcePtr* res = new SoundResourcePtr(sSoundResourceManager-&gt;getByName(name));
+        LOG_DEBUG(Logger::MULTIMEDIA,
+            &quot;Opened stream &quot; + (*res)-&gt;getName());
+        (*res)-&gt;load();
+        *filesize = (*res)-&gt;getSize();
+        *handle = res;
+        return FMOD_OK;
     }
 
-	SoundResourcePtr *sound = static_cast&lt;SoundResourcePtr*&gt;(handle);
-	if (!sound-&gt;isNull())
-	{
-        if (!(*sound)-&gt;isLoaded())
+    FMOD_RESULT F_CALLBACK Fmod4Driver::close(
+        void *  handle,
+        void *  userdata)
+    {
+           SoundResourcePtr *res = static_cast&lt;SoundResourcePtr*&gt;(handle);
+        LOG_DEBUG(Logger::MULTIMEDIA,
+            &quot;Closing stream &quot; + (*res)-&gt;getName());
+        (*res)-&gt;unload();
+        delete res;
+        return FMOD_OK;
+    }
+
+    FMOD_RESULT F_CALLBACK Fmod4Driver::read(
+        void *  handle,
+        void *  buffer,
+        unsigned int  sizebytes,
+        unsigned int *  bytesread,
+        void *  userdata)
+    {
+        if (handle == NULL)
         {
-            (*sound)-&gt;load();
+            return FMOD_ERR_INVALID_PARAM;
         }
 
-		DataStreamPtr ds = (*sound)-&gt;getDataStream();
-    	if (!ds.isNull())
-    	{
-            *bytesread = ds-&gt;read(buffer, sizebytes);
-            if (*bytesread &lt; sizebytes)
+        SoundResourcePtr *sound = static_cast&lt;SoundResourcePtr*&gt;(handle);
+        if (!sound-&gt;isNull())
+        {
+            if (!(*sound)-&gt;isLoaded())
             {
-                return FMOD_ERR_FILE_EOF;
+                (*sound)-&gt;load();
             }
-            return FMOD_OK;
-    	}
-    }
 
-    return FMOD_ERR_FILE_EOF;
-}
+            DataStreamPtr ds = (*sound)-&gt;getDataStream();
+            if (!ds.isNull())
+            {
+                *bytesread = ds-&gt;read(buffer, sizebytes);
+                if (*bytesread &lt; sizebytes)
+                {
+                    return FMOD_ERR_FILE_EOF;
+                }
+                return FMOD_OK;
+            }
+        }
 
-FMOD_RESULT F_CALLBACK Fmod4Driver::seek(
-    void *  handle, 
-    unsigned int  pos, 
-    void *  userdata)
-{
-    if (handle == NULL)
+        return FMOD_ERR_FILE_EOF;
+    }
+
+    FMOD_RESULT F_CALLBACK Fmod4Driver::seek(
+        void *  handle,
+        unsigned int  pos,
+        void *  userdata)
     {
+        if (handle == NULL)
+        {
+            return FMOD_ERR_INVALID_PARAM;
+        }
+
+        SoundResourcePtr *sound = static_cast&lt;SoundResourcePtr*&gt;(handle);
+        if (!sound-&gt;isNull())
+        {
+            DataStreamPtr ds = (*sound)-&gt;getDataStream();
+            if (!ds.isNull())
+            {
+                ds-&gt;seek(pos);
+                return FMOD_OK;
+            }
+        }
         return FMOD_ERR_INVALID_PARAM;
     }
 
-    SoundResourcePtr *sound = static_cast&lt;SoundResourcePtr*&gt;(handle);
-	if (!sound-&gt;isNull())
-	{
-		DataStreamPtr ds = (*sound)-&gt;getDataStream();
-    	if (!ds.isNull())
-    	{
-        	ds-&gt;seek(pos);
-        	return FMOD_OK;
-    	}
+    void Fmod4Driver::setMasterVolume(const Ogre::Real&amp; vol)
+    {
+        SoundDriver::setMasterVolume(vol);
+        /**@todo: Lautst&#239;&#191;&#189;rke setzen, geht m&#239;&#191;&#189;glicherweise nur &#239;&#191;&#189;ber channelgroups*/
     }
-    return FMOD_ERR_INVALID_PARAM;
-}
 
-void Fmod4Driver::setMasterVolume(const Ogre::Real&amp; vol)
-{
-    SoundDriver::setMasterVolume(vol);
-    /**@todo: Lautst&#239;&#191;&#189;rke setzen, geht m&#239;&#191;&#189;glicherweise nur &#239;&#191;&#189;ber channelgroups*/
-}
+    /// Setzt den Faktor f, mit der die Lautst&#239;&#191;&#189;rke nach der Formel 1/(f*Entfernung) abnimmt
+    void Fmod4Driver::setRolloffFactor(const Ogre::Real&amp; factor)
+    {
+        float dopplerScale;
+        mFmod4System-&gt;get3DSettings(&amp;dopplerScale, NULL, NULL);
+        mFmod4System-&gt;set3DSettings(dopplerScale, 1.0, factor);
+    }
 
-/// Setzt den Faktor f, mit der die Lautst&#239;&#191;&#189;rke nach der Formel 1/(f*Entfernung) abnimmt
-void Fmod4Driver::setRolloffFactor(const Ogre::Real&amp; factor)
-{
-    float dopplerScale;
-    mFmod4System-&gt;get3DSettings(&amp;dopplerScale, NULL, NULL);
-    mFmod4System-&gt;set3DSettings(dopplerScale, 1.0, factor);
+    const Ogre::Real Fmod4Driver::getRolloffFactor()
+    {
+        float factor;
+        mFmod4System-&gt;get3DSettings(NULL, NULL, &amp;factor);
+        return factor;
+    }
 }
-
-const Ogre::Real Fmod4Driver::getRolloffFactor()
-{
-    float factor;
-    mFmod4System-&gt;get3DSettings(NULL, NULL, &amp;factor);
-    return factor;
-}
-
-
-}

Modified: rl/trunk/plugins/openaldriver/include/OpenALDriver.h
===================================================================
--- rl/trunk/plugins/openaldriver/include/OpenALDriver.h	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/plugins/openaldriver/include/OpenALDriver.h	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -22,49 +22,43 @@
 namespace rl
 {
 
-/** Diese Klasse ist der Treiber, der OpenAL zur
- * Ausgabe benutzt.
- */
-class _RlOpenALDriverExport OpenALDriver : public rl::SoundDriver
-{
-public:
-	/// Der Treibername
-    static Ogre::String NAME;
-    /// Der Konstruktor
-	OpenALDriver(Ogre::ResourceManager* soundResourceManager);
-    /// Der Destruktor
-	virtual ~OpenALDriver();
-    /// Ist der Treiber angeschaltet?
-    virtual bool isDriverAvailable();
-    /// Initialisiere den Treiber.
-    virtual bool initialize();
-    /// Deinitialisiere den Treiber.
-    virtual void shutdown();
-    /// Der Name des Treibers
-    virtual Ogre::String getName() const;
-    /// Update-Aufgaben erledigen
-    virtual void update();
-    /// Einen Sound-Stream mit Resource erzeugen
-    virtual Sound *createStream(const SoundResourcePtr &amp;res);
-    /// Einen Sound-Sample mit Resource erzeugen
-    virtual Sound *createSample(const SoundResourcePtr &amp;res);
-    /// Einen Soundlistener erzeugen
-    virtual ListenerMovable *createListener(const Ogre::String &amp;name);
+    /** Diese Klasse ist der Treiber, der OpenAL zur
+     * Ausgabe benutzt.
+     */
+    class _RlOpenALDriverExport OpenALDriver : public rl::SoundDriver
+    {
+    public:
+        /// Der Treibername
+        static Ogre::String NAME;
+        /// Der Konstruktor
+        OpenALDriver(Ogre::ResourceManager* soundResourceManager);
+        /// Der Destruktor
+        virtual ~OpenALDriver();
+        /// Ist der Treiber angeschaltet?
+        virtual bool isDriverAvailable();
+        /// Initialisiere den Treiber.
+        virtual bool initialize();
+        /// Deinitialisiere den Treiber.
+        virtual void shutdown();
+        /// Der Name des Treibers
+        virtual Ogre::String getName() const;
+        /// Update-Aufgaben erledigen
+        virtual void update();
+        /// Einen Sound-Stream mit Resource erzeugen
+        virtual Sound *createStream(const SoundResourcePtr &amp;res);
+        /// Einen Sound-Sample mit Resource erzeugen
+        virtual Sound *createSample(const SoundResourcePtr &amp;res);
+        /// Einen Soundlistener erzeugen
+        virtual ListenerMovable *createListener(const Ogre::String &amp;name);
 
-    /// Die Einstellungen in Datei schreiben
-    virtual void saveConf(rl::ConfigFile &amp;conf) const;
-    /// Die Einstellungen laden
-    virtual void loadConf(rl::ConfigFile &amp;conf);
+        /// Setzt den Faktor f, mit der die Lautst&#228;rke nach der Formel 1/(f*Entfernung) abnimmt
+        virtual void setRolloffFactor(const Ogre::Real&amp; f);
+        virtual const Ogre::Real getRolloffFactor();
 
-    /// Setzt den Faktor f, mit der die Lautst&#228;rke nach der Formel 1/(f*Entfernung) abnimmt
-	virtual void setRolloffFactor(const Ogre::Real&amp; f);
-	virtual const Ogre::Real getRolloffFactor();
-    
-private:
-    /// Informationen &#252;ber den Treiber ausgeben
-    virtual void printData() const;
-};
-
+    private:
+        /// Informationen &#252;ber den Treiber ausgeben
+        virtual void printData() const;
+    };
 }
 
 #endif /*OALDRIVER_H_*/

Modified: rl/trunk/plugins/openaldriver/src/OpenALDriver.cpp
===================================================================
--- rl/trunk/plugins/openaldriver/src/OpenALDriver.cpp	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/plugins/openaldriver/src/OpenALDriver.cpp	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -17,201 +17,176 @@
 
 #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
     // OpenAL 1.1 unter Windows
-//	extern &quot;C&quot; {
-//		#include &quot;al.h&quot;
-//		#include &quot;alc.h&quot;
-//	}
+//    extern &quot;C&quot; {
+//        #include &quot;al.h&quot;
+//        #include &quot;alc.h&quot;
+//    }
 //#else
 //    // OpenAL 1.0 unter Linux
-//	extern &quot;C&quot; {
-//		#include &quot;AL/al.h&quot;
-//		#include &quot;AL/alc.h&quot;
-//	}
+//    extern &quot;C&quot; {
+//        #include &quot;AL/al.h&quot;
+//        #include &quot;AL/alc.h&quot;
+//    }
 #endif
 
 #include &quot;OpenALSoundSample.h&quot;
 #include &quot;OpenALSoundStream.h&quot;
 #include &quot;OpenALListener.h&quot;
 
-Ogre::String rl::OpenALDriver::NAME = &quot;OpenAL&quot;;
-
 namespace rl
 {
+    Ogre::String rl::OpenALDriver::NAME = &quot;RlOpenALDriver&quot;;
 
-/** 
- * Konstruktor
- * @author JoSch
- * @date 12-23-2005
- */
-OpenALDriver::OpenALDriver(Ogre::ResourceManager* soundResourceManager)
-: SoundDriver(soundResourceManager)
-{
-}
+    /**
+     * Konstruktor
+     * @author JoSch
+     * @date 12-23-2005
+     */
+    OpenALDriver::OpenALDriver(Ogre::ResourceManager* soundResourceManager)
+    : SoundDriver(soundResourceManager)
+    {
+    }
 
-/** 
- * Destruktor
- * @author JoSch
- * @date 12-23-2005
- */
-OpenALDriver::~OpenALDriver()
-{
-}
+    /**
+     * Destruktor
+     * @author JoSch
+     * @date 12-23-2005
+     */
+    OpenALDriver::~OpenALDriver()
+    {
+    }
 
-/** 
- * Zeigt an, ob der Treiber funktionsf&#228;hig ist.
- * @return Immer TRUE.
- * @author JoSch
- * @date 12-23-2005
- */
-bool OpenALDriver::isDriverAvailable()
-{
-    //try {
-    //    // Clear error code
-    //    alGetError();
-    //    ALCdevice *device = alcOpenDevice(0);
-    //    
-    //    if (device == 0)
-    //    {
-    //        return false;
-    //    }
-    //    
-    //    //Create context(s)
-    //    ALCcontext *context = alcCreateContext(device, 0);
-    //    //Set active context
-    //    alcMakeContextCurrent(context);
-    //    // Get Error Code
-    //    ALenum success = alGetError();
-    //    //Disable context
-    //    alcMakeContextCurrent(0);
-    //    //Release context(s)
-    //    alcDestroyContext(context);
-    //    //Close device
-    //    alcCloseDevice(device);
-    //    
-    //    return (success == AL_NO_ERROR);
-    //} catch (...)
-    //{
-        return false;
-    //}
-}
+    /**
+     * Zeigt an, ob der Treiber funktionsf&#228;hig ist.
+     * @return Immer TRUE.
+     * @author JoSch
+     * @date 12-23-2005
+     */
+    bool OpenALDriver::isDriverAvailable()
+    {
+        //try {
+        //    // Clear error code
+        //    alGetError();
+        //    ALCdevice *device = alcOpenDevice(0);
+        //
+        //    if (device == 0)
+        //    {
+        //        return false;
+        //    }
+        //
+        //    //Create context(s)
+        //    ALCcontext *context = alcCreateContext(device, 0);
+        //    //Set active context
+        //    alcMakeContextCurrent(context);
+        //    // Get Error Code
+        //    ALenum success = alGetError();
+        //    //Disable context
+        //    alcMakeContextCurrent(0);
+        //    //Release context(s)
+        //    alcDestroyContext(context);
+        //    //Close device
+        //    alcCloseDevice(device);
+        //
+        //    return (success == AL_NO_ERROR);
+        //} catch (...)
+        //{
+            return false;
+        //}
+    }
 
-/** 
- * Starte den Treiber und mache alle Initialisierung.
- * @author JoSch
- * @date 12-23-2005
- */
-bool OpenALDriver::initialize()
-{
-    return true;
-}
+    /**
+     * Starte den Treiber und mache alle Initialisierung.
+     * @author JoSch
+     * @date 12-23-2005
+     */
+    bool OpenALDriver::initialize()
+    {
+        return true;
+    }
 
-/** 
- * Beeende den Treiber und gib alle Resourcen frei.
- * @author JoSch
- * @date 12-23-2005
- */
-void OpenALDriver::shutdown()
-{
-}
+    /**
+     * Beeende den Treiber und gib alle Resourcen frei.
+     * @author JoSch
+     * @date 12-23-2005
+     */
+    void OpenALDriver::shutdown()
+    {
+    }
 
-/** 
- * Gibt den Anzeigename des Treiber zur&#252;ck.
- * @return Anzeigename
- * @author JoSch
- * @date 12-23-2005
- */
-Ogre::String OpenALDriver::getName() const
-{
-    return NAME;
-}
+    /**
+     * Gibt den Anzeigename des Treiber zur&#252;ck.
+     * @return Anzeigename
+     * @author JoSch
+     * @date 12-23-2005
+     */
+    Ogre::String OpenALDriver::getName() const
+    {
+        return NAME;
+    }
 
-/**
- * Update-Aufgaben erledigen
- * @author JoSch
- * @date 03-06-2006
- */
- void OpenALDriver::update()
- {
- 	// Erstmal nichts zu tun.
- }
- 
- /**
-  * Einen Sound-Stream mit Resource erzeugen
-  * @return Der erzeugte Stream
-  * @author JoSch
-  * @date 03-06-2006
-  */
-Sound *OpenALDriver::createStream(const SoundResourcePtr &amp;res)
-{
- 	Sound *sound = new OpenALSoundStream(this, res);
- 	return sound;
-}
+    /**
+     * Update-Aufgaben erledigen
+     * @author JoSch
+     * @date 03-06-2006
+     */
+     void OpenALDriver::update()
+     {
+         // Erstmal nichts zu tun.
+     }
 
-/**
- * Einen Sound-Sample mit Resource erzeugen
- * @return Das erzeugte Sample
- * @author JoSch
- * @date 03-06-2006
- */
-Sound *OpenALDriver::createSample(const SoundResourcePtr &amp;res)
-{
- 	Sound *sound = new OpenALSoundSample(this, res);
- 	return sound;
-}
+     /**
+      * Einen Sound-Stream mit Resource erzeugen
+      * @return Der erzeugte Stream
+      * @author JoSch
+      * @date 03-06-2006
+      */
+    Sound *OpenALDriver::createStream(const SoundResourcePtr &amp;res)
+    {
+         Sound *sound = new OpenALSoundStream(this, res);
+         return sound;
+    }
 
-/**
- * Einen Soundlistener erzeugen
- * @return Der erzeugte Listener
- * @param name Der Name des Channels.
- * @author JoSch
- * @date 04-04-2006
- */
-ListenerMovable *OpenALDriver::createListener(const Ogre::String &amp;name)
-{
-    ListenerMovable *listener = new OpenALListener(name);
-    return listener;
-}
+    /**
+     * Einen Sound-Sample mit Resource erzeugen
+     * @return Das erzeugte Sample
+     * @author JoSch
+     * @date 03-06-2006
+     */
+    Sound *OpenALDriver::createSample(const SoundResourcePtr &amp;res)
+    {
+         Sound *sound = new OpenALSoundSample(this, res);
+         return sound;
+    }
 
-/**
- * Ausdruck einiger Werte des Soundsystems.
- * @author JoSch
- * @date 01-20-2006
- */
-void OpenALDriver::printData() const
-{
-}
+    /**
+     * Einen Soundlistener erzeugen
+     * @return Der erzeugte Listener
+     * @param name Der Name des Channels.
+     * @author JoSch
+     * @date 04-04-2006
+     */
+    ListenerMovable *OpenALDriver::createListener(const Ogre::String &amp;name)
+    {
+        ListenerMovable *listener = new OpenALListener(name);
+        return listener;
+    }
 
-/*
- * Die Konfiguration in Datei schreiben.
- * @author JoSch
- * @date 05-07-2006
- * @param conf Die Konfigurationdatei zum Schreiben.
- */
-void OpenALDriver::saveConf(ConfigFile &amp;conf) const
-{
-	SoundDriver::saveConf(conf);
-    // DO NOTHING
-}
+    /**
+     * Ausdruck einiger Werte des Soundsystems.
+     * @author JoSch
+     * @date 01-20-2006
+     */
+    void OpenALDriver::printData() const
+    {
+    }
 
-/*
- * Die Konfiguration lesen
- * @author JoSch
- * @date 05-07-2006
- * @param conf Die Konfigurationdatei, aus der gelesen werden soll
- */
-void OpenALDriver::loadConf(ConfigFile &amp;conf)
-{
-	SoundDriver::loadConf(conf);
-    // DO NOTHING
-}
+    void OpenALDriver::setRolloffFactor(const Ogre::Real&amp; f)
+    {
+    }
 
-void OpenALDriver::setRolloffFactor(const Ogre::Real&amp; f)
-{
-}
+    const Ogre::Real OpenALDriver::getRolloffFactor()
+    {
+        return 1.0;
+    }
 
-const Ogre::Real OpenALDriver::getRolloffFactor()
-{
-    return 1.0;
 }
-
-}

Modified: rl/trunk/rastullah.conf.in
===================================================================
--- rl/trunk/rastullah.conf.in	2007-02-06 18:57:23 UTC (rev 3025)
+++ rl/trunk/rastullah.conf.in	2007-02-07 19:30:10 UTC (rev 3026)
@@ -1,3 +1,3 @@
-[Rastullah]
-ModulesDirectory=@RL_MODULE_DIR@
-PluginCfg=plugins-linux.cfg
+[Paths]
+ModulesDirectory=@RL_MODULEDIR@
+OgrePluginDirectory=@OGRE_PLUGINDIR@


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000096.html">[Dsa-hl-svn] r3025 - rl/trunk/engine/core/include
</A></li>
	<LI>Next message: <A HREF="000098.html">[Dsa-hl-svn] r3027 - modules/common/gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#97">[ date ]</a>
              <a href="thread.html#97">[ thread ]</a>
              <a href="subject.html#97">[ subject ]</a>
              <a href="author.html#97">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
