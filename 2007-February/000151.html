<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r3080 - in rl/trunk: docs/src engine/script	engine/script/swig
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-February/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3080%20-%20in%20rl/trunk%3A%20docs/src%20engine/script%0A%09engine/script/swig&In-Reply-To=%3C200702271104.l1RB4ktC002299%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000150.html">
   <LINK REL="Next"  HREF="000152.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r3080 - in rl/trunk: docs/src engine/script	engine/script/swig</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3080%20-%20in%20rl/trunk%3A%20docs/src%20engine/script%0A%09engine/script/swig&In-Reply-To=%3C200702271104.l1RB4ktC002299%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r3080 - in rl/trunk: docs/src engine/script	engine/script/swig">blakharaz at mail.berlios.de
       </A><BR>
    <I>Tue Feb 27 12:04:46 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000150.html">[Dsa-hl-svn] r3079 - rl/trunk/engine/ui/src
</A></li>
        <LI>Next message: <A HREF="000152.html">[Dsa-hl-svn] r3081 - rl/trunk/docs/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#151">[ date ]</a>
              <a href="thread.html#151">[ thread ]</a>
              <a href="subject.html#151">[ subject ]</a>
              <a href="author.html#151">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2007-02-27 12:04:17 +0100 (Tue, 27 Feb 2007)
New Revision: 3080

Added:
   rl/trunk/docs/src/ruby_html.cfg
   rl/trunk/engine/script/swig/RlAi.head.swig
   rl/trunk/engine/script/swig/RlAi.swig
   rl/trunk/engine/script/swig/RlCommon.head.swig
   rl/trunk/engine/script/swig/RlCommon.swig
   rl/trunk/engine/script/swig/RlCore.head.swig
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/engine/script/swig/RlDialog.head.swig
   rl/trunk/engine/script/swig/RlDialog.swig
   rl/trunk/engine/script/swig/RlRules.head.swig
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/script/swig/RlScript.head.swig
   rl/trunk/engine/script/swig/RlScript.swig
   rl/trunk/engine/script/swig/RlUi.head.swig
   rl/trunk/engine/script/swig/RlUi.swig
   rl/trunk/engine/script/swig/TypeOgreColourValue.swig
   rl/trunk/engine/script/swig/TypeOgreQuaternion.swig
   rl/trunk/engine/script/swig/TypeOgreRadian.swig
   rl/trunk/engine/script/swig/TypeOgreReal.swig
   rl/trunk/engine/script/swig/TypeOgreString.swig
   rl/trunk/engine/script/swig/TypeOgreStringVector.swig
   rl/trunk/engine/script/swig/TypeOgreVector3.swig
   rl/trunk/engine/script/swig/TypeRlCeGuiString.swig
   rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.swig
   rl/trunk/engine/script/swig/TypeRlProperty.swig
   rl/trunk/engine/script/swig/TypeRlTripelInt.swig
   rl/trunk/engine/script/swig/TypeStdPairIntInt.swig
Removed:
   rl/trunk/engine/script/swig/RlAi.head.inc
   rl/trunk/engine/script/swig/RlAi.inc
   rl/trunk/engine/script/swig/RlCommon.head.inc
   rl/trunk/engine/script/swig/RlCommon.inc
   rl/trunk/engine/script/swig/RlCore.head.inc
   rl/trunk/engine/script/swig/RlCore.inc
   rl/trunk/engine/script/swig/RlDialog.head.inc
   rl/trunk/engine/script/swig/RlDialog.inc
   rl/trunk/engine/script/swig/RlRules.head.inc
   rl/trunk/engine/script/swig/RlRules.inc
   rl/trunk/engine/script/swig/RlScript.head.inc
   rl/trunk/engine/script/swig/RlScript.inc
   rl/trunk/engine/script/swig/RlUi.head.inc
   rl/trunk/engine/script/swig/RlUi.inc
   rl/trunk/engine/script/swig/TypeOgreColourValue.inc
   rl/trunk/engine/script/swig/TypeOgreQuaternion.inc
   rl/trunk/engine/script/swig/TypeOgreRadian.inc
   rl/trunk/engine/script/swig/TypeOgreReal.inc
   rl/trunk/engine/script/swig/TypeOgreString.inc
   rl/trunk/engine/script/swig/TypeOgreStringVector.inc
   rl/trunk/engine/script/swig/TypeOgreVector3.inc
   rl/trunk/engine/script/swig/TypeRlCeGuiString.inc
   rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.inc
   rl/trunk/engine/script/swig/TypeRlProperty.inc
   rl/trunk/engine/script/swig/TypeRlTripelInt.inc
   rl/trunk/engine/script/swig/TypeStdPairIntInt.inc
Modified:
   rl/trunk/engine/script/RlScript2005.vcproj
   rl/trunk/engine/script/swig/Makefile.am
Log:
Doxygen documentation of RL's ruby interface
* renamed all .inc to .swig since .inc is PHP for doxygen, .swig is 
parsed as C++ since it is unknown
* added doxyfile for generating documentation from all .swig files

Now just add the missing doxygen comments ;)


Added: rl/trunk/docs/src/ruby_html.cfg
===================================================================
--- rl/trunk/docs/src/ruby_html.cfg	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/docs/src/ruby_html.cfg	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,222 @@
+# Doxyfile 1.4.3
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+PROJECT_NAME           = &quot;Rastullahs Lockenpracht&quot;
+PROJECT_NUMBER         = 
+OUTPUT_DIRECTORY       = ../ruby-api
+CREATE_SUBDIRS         = NO
+OUTPUT_LANGUAGE        = 
+USE_WINDOWS_ENCODING   = NO
+BRIEF_MEMBER_DESC      = YES
+REPEAT_BRIEF           = YES
+ABBREVIATE_BRIEF       = 
+ALWAYS_DETAILED_SEC    = NO
+INLINE_INHERITED_MEMB  = NO
+FULL_PATH_NAMES        = NO
+STRIP_FROM_PATH        = 
+STRIP_FROM_INC_PATH    = 
+SHORT_NAMES            = NO
+JAVADOC_AUTOBRIEF      = YES
+MULTILINE_CPP_IS_BRIEF = NO
+DETAILS_AT_TOP         = YES
+INHERIT_DOCS           = YES
+DISTRIBUTE_GROUP_DOC   = NO
+SEPARATE_MEMBER_PAGES  = NO
+TAB_SIZE               = 4
+ALIASES                = 
+OPTIMIZE_OUTPUT_FOR_C  = NO
+OPTIMIZE_OUTPUT_JAVA   = NO
+SUBGROUPING            = YES
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+EXTRACT_ALL            = YES
+EXTRACT_PRIVATE        = YES
+EXTRACT_STATIC         = YES
+EXTRACT_LOCAL_CLASSES  = YES
+EXTRACT_LOCAL_METHODS  = NO
+HIDE_UNDOC_MEMBERS     = NO
+HIDE_UNDOC_CLASSES     = NO
+HIDE_FRIEND_COMPOUNDS  = NO
+HIDE_IN_BODY_DOCS      = NO
+INTERNAL_DOCS          = NO
+CASE_SENSE_NAMES       = YES
+HIDE_SCOPE_NAMES       = NO
+SHOW_INCLUDE_FILES     = YES
+INLINE_INFO            = YES
+SORT_MEMBER_DOCS       = YES
+SORT_BRIEF_DOCS        = YES
+SORT_BY_SCOPE_NAME     = NO
+GENERATE_TODOLIST      = YES
+GENERATE_TESTLIST      = YES
+GENERATE_BUGLIST       = YES
+GENERATE_DEPRECATEDLIST= YES
+ENABLED_SECTIONS       = 
+MAX_INITIALIZER_LINES  = 30
+SHOW_USED_FILES        = NO
+SHOW_DIRECTORIES       = YES
+FILE_VERSION_FILTER    = 
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+QUIET                  = NO
+WARNINGS               = YES
+WARN_IF_UNDOCUMENTED   = YES
+WARN_IF_DOC_ERROR      = YES
+WARN_NO_PARAMDOC       = NO
+WARN_FORMAT            = &quot;$file:$line: $text&quot;
+WARN_LOGFILE           = doxygen_warnings.log
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+INPUT                  = ../../engine/script
+FILE_PATTERNS          = Rl*.swig
+RECURSIVE              = YES
+EXCLUDE                = 
+EXCLUDE_SYMLINKS       = NO
+EXCLUDE_PATTERNS       = 
+EXAMPLE_PATH           = 
+EXAMPLE_PATTERNS       = 
+EXAMPLE_RECURSIVE      = NO
+IMAGE_PATH             = 
+INPUT_FILTER           = 
+FILTER_PATTERNS        = 
+FILTER_SOURCE_FILES    = NO
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+SOURCE_BROWSER         = NO
+INLINE_SOURCES         = NO
+STRIP_CODE_COMMENTS    = YES
+REFERENCED_BY_RELATION = NO
+REFERENCES_RELATION    = NO
+USE_HTAGS              = NO
+VERBATIM_HEADERS       = NO
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+ALPHABETICAL_INDEX     = YES
+COLS_IN_ALPHA_INDEX    = 3
+IGNORE_PREFIX          = 
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+GENERATE_HTML          = YES
+HTML_OUTPUT            = html
+HTML_FILE_EXTENSION    = .html
+HTML_HEADER            = 
+HTML_FOOTER            =
+HTML_STYLESHEET        =
+HTML_ALIGN_MEMBERS     = YES
+GENERATE_HTMLHELP      = NO
+CHM_FILE               = 
+HHC_LOCATION           = 
+GENERATE_CHI           = NO
+BINARY_TOC             = NO
+TOC_EXPAND             = NO
+DISABLE_INDEX          = NO
+ENUM_VALUES_PER_LINE   = 4
+GENERATE_TREEVIEW      = NO
+TREEVIEW_WIDTH         = 250
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+GENERATE_LATEX         = NO
+LATEX_OUTPUT           = latex
+LATEX_CMD_NAME         = latex
+MAKEINDEX_CMD_NAME     = makeindex
+COMPACT_LATEX          = NO
+PAPER_TYPE             = a4wide
+EXTRA_PACKAGES         = 
+LATEX_HEADER           = 
+PDF_HYPERLINKS         = NO
+USE_PDFLATEX           = NO
+LATEX_BATCHMODE        = NO
+LATEX_HIDE_INDICES     = NO
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+GENERATE_RTF           = NO
+RTF_OUTPUT             = rtf
+COMPACT_RTF            = NO
+RTF_HYPERLINKS         = NO
+RTF_STYLESHEET_FILE    = 
+RTF_EXTENSIONS_FILE    = 
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+GENERATE_MAN           = NO
+MAN_OUTPUT             = man
+MAN_EXTENSION          = .3
+MAN_LINKS              = NO
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+GENERATE_XML           = NO
+XML_OUTPUT             = xml
+XML_SCHEMA             = 
+XML_DTD                = 
+XML_PROGRAMLISTING     = YES
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+GENERATE_AUTOGEN_DEF   = NO
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+GENERATE_PERLMOD       = NO
+PERLMOD_LATEX          = NO
+PERLMOD_PRETTY         = YES
+PERLMOD_MAKEVAR_PREFIX = 
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+ENABLE_PREPROCESSING   = YES
+MACRO_EXPANSION        = NO
+EXPAND_ONLY_PREDEF     = NO
+SEARCH_INCLUDES        = YES
+INCLUDE_PATH           = 
+INCLUDE_FILE_PATTERNS  = 
+PREDEFINED             = 
+EXPAND_AS_DEFINED      = 
+SKIP_FUNCTION_MACROS   = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+TAGFILES               = 
+GENERATE_TAGFILE       = 
+ALLEXTERNALS           = NO
+EXTERNAL_GROUPS        = YES
+PERL_PATH              = perl
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+CLASS_DIAGRAMS         = YES
+HIDE_UNDOC_RELATIONS   = YES
+HAVE_DOT               = NO
+CLASS_GRAPH            = YES
+COLLABORATION_GRAPH    = YES
+GROUP_GRAPHS           = YES
+UML_LOOK               = NO
+TEMPLATE_RELATIONS     = NO
+INCLUDE_GRAPH          = YES
+INCLUDED_BY_GRAPH      = YES
+CALL_GRAPH             = NO
+GRAPHICAL_HIERARCHY    = YES
+DIRECTORY_GRAPH        = YES
+DOT_IMAGE_FORMAT       = png
+DOT_PATH               = 
+DOTFILE_DIRS           = 
+MAX_DOT_GRAPH_WIDTH    = 800
+MAX_DOT_GRAPH_HEIGHT   = 600
+MAX_DOT_GRAPH_DEPTH    = 0
+DOT_TRANSPARENT        = NO
+DOT_MULTI_TARGETS      = NO
+GENERATE_LEGEND        = YES
+DOT_CLEANUP            = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+SEARCHENGINE           = NO


Property changes on: rl/trunk/docs/src/ruby_html.cfg
___________________________________________________________________
Name: svn:executable
   + *

Modified: rl/trunk/engine/script/RlScript2005.vcproj
===================================================================
--- rl/trunk/engine/script/RlScript2005.vcproj	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/RlScript2005.vcproj	2007-02-27 11:04:17 UTC (rev 3080)
@@ -317,7 +317,7 @@
 						Name=&quot;VCCustomBuildTool&quot;
 						Description=&quot;[SWIG] RubyWrapper erzeugen.&quot;
 						CommandLine=&quot;cd &quot;$(InputDir)&quot;&amp;#x0D;&amp;#x0A;&quot;$(ProjectDir)..\..\dependencies\swig\swig.exe&quot; -o &quot;$(InputDir)$(InputName)_wrap.cxx&quot; -c++ -ruby -minherit -v -Wall  &quot;$(InputPath)&quot;&amp;#x0D;&amp;#x0A;&quot;
-						AdditionalDependencies=&quot;&quot;$(InputDir)TypeMaps.i&quot;;&quot;$(InputDir)RlCore.inc&quot;;&quot;$(InputDir)RlDialog.inc&quot;;&quot;$(InputDir)RlCommon.inc&quot;;&quot;$(InputDir)RlRules.inc&quot;;&quot;$(InputDir)RlScript.inc&quot;;&quot;$(InputDir)RlSound.inc&quot;;&quot;$(InputDir)RlUi.inc&quot;;&quot;$(InputDir)RlAi.inc&quot;&quot;
+						AdditionalDependencies=&quot;&quot;$(InputDir)TypeMaps.i&quot;;&quot;$(InputDir)RlCore.swig&quot;;&quot;$(InputDir)RlDialog.swig&quot;;&quot;$(InputDir)RlCommon.swig&quot;;&quot;$(InputDir)RlRules.swig&quot;;&quot;$(InputDir)RlScript.swig&quot;;&quot;$(InputDir)RlSound.swig&quot;;&quot;$(InputDir)RlUi.swig&quot;;&quot;$(InputDir)RlAi.swig&quot;&quot;
 						Outputs=&quot;&quot;$(InputDir)$(InputName)_wrap.cxx&quot;&quot;
 					/&gt;
 				&lt;/FileConfiguration&gt;
@@ -328,7 +328,7 @@
 						Name=&quot;VCCustomBuildTool&quot;
 						Description=&quot;[SWIG] RubyWrapper erzeugen.&quot;
 						CommandLine=&quot;cd &quot;$(InputDir)&quot;&amp;#x0D;&amp;#x0A;&quot;$(ProjectDir)..\..\dependencies\swig\swig.exe&quot; -o &quot;$(InputDir)$(InputName)_wrap.cxx&quot; -c++ -ruby -minherit -v -Wall  &quot;$(InputPath)&quot;&amp;#x0D;&amp;#x0A;&quot;
-						AdditionalDependencies=&quot;&quot;$(InputDir)TypeMaps.i&quot;;&quot;$(InputDir)RlCore.inc&quot;;&quot;$(InputDir)RlDialog.inc&quot;;&quot;$(InputDir)RlCommon.inc&quot;;&quot;$(InputDir)RlRules.inc&quot;;&quot;$(InputDir)RlScript.inc&quot;;&quot;$(InputDir)RlSound.inc&quot;;&quot;$(InputDir)RlUi.inc&quot;;&quot;$(InputDir)RlAi.inc&quot;&quot;
+						AdditionalDependencies=&quot;&quot;$(InputDir)TypeMaps.i&quot;;&quot;$(InputDir)RlCore.swig&quot;;&quot;$(InputDir)RlDialog.swig&quot;;&quot;$(InputDir)RlCommon.swig&quot;;&quot;$(InputDir)RlRules.swig&quot;;&quot;$(InputDir)RlScript.swig&quot;;&quot;$(InputDir)RlSound.swig&quot;;&quot;$(InputDir)RlUi.swig&quot;;&quot;$(InputDir)RlAi.swig&quot;&quot;
 						Outputs=&quot;&quot;$(InputDir)$(InputName)_wrap.cxx&quot;&quot;
 					/&gt;
 				&lt;/FileConfiguration&gt;
@@ -339,7 +339,7 @@
 						Name=&quot;VCCustomBuildTool&quot;
 						Description=&quot;[SWIG] RubyWrapper erzeugen.&quot;
 						CommandLine=&quot;cd &quot;$(InputDir)&quot;&amp;#x0D;&amp;#x0A;&quot;$(ProjectDir)..\..\dependencies\swig\swig.exe&quot; -o &quot;$(InputDir)$(InputName)_wrap.cxx&quot; -c++ -ruby -minherit -v -Wall  &quot;$(InputPath)&quot;&amp;#x0D;&amp;#x0A;&quot;
-						AdditionalDependencies=&quot;&quot;$(InputDir)TypeMaps.i&quot;;&quot;$(InputDir)RlCore.inc&quot;;&quot;$(InputDir)RlDialog.inc&quot;;&quot;$(InputDir)RlCommon.inc&quot;;&quot;$(InputDir)RlRules.inc&quot;;&quot;$(InputDir)RlScript.inc&quot;;&quot;$(InputDir)RlSound.inc&quot;;&quot;$(InputDir)RlUi.inc&quot;;&quot;$(InputDir)RlAi.inc&quot;&quot;
+						AdditionalDependencies=&quot;&quot;$(InputDir)TypeMaps.i&quot;;&quot;$(InputDir)RlCore.swig&quot;;&quot;$(InputDir)RlDialog.swig&quot;;&quot;$(InputDir)RlCommon.swig&quot;;&quot;$(InputDir)RlRules.swig&quot;;&quot;$(InputDir)RlScript.swig&quot;;&quot;$(InputDir)RlSound.swig&quot;;&quot;$(InputDir)RlUi.swig&quot;;&quot;$(InputDir)RlAi.swig&quot;&quot;
 						Outputs=&quot;&quot;$(InputDir)$(InputName)_wrap.cxx&quot;&quot;
 					/&gt;
 				&lt;/FileConfiguration&gt;
@@ -360,31 +360,31 @@
 				Name=&quot;include&quot;
 				&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\RlAi.head.inc&quot;
+					RelativePath=&quot;.\swig\RlAi.head.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\RlCommon.head.inc&quot;
+					RelativePath=&quot;.\swig\RlCommon.head.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\RlCore.head.inc&quot;
+					RelativePath=&quot;.\swig\RlCore.head.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\RlDialog.head.inc&quot;
+					RelativePath=&quot;.\swig\RlDialog.head.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\RlRules.head.inc&quot;
+					RelativePath=&quot;.\swig\RlRules.head.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\RlScript.head.inc&quot;
+					RelativePath=&quot;.\swig\RlScript.head.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\RlUi.head.inc&quot;
+					RelativePath=&quot;.\swig\RlUi.head.swig&quot;
 					&gt;
 				&lt;/File&gt;
 			&lt;/Filter&gt;
@@ -392,31 +392,31 @@
 				Name=&quot;src&quot;
 				&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\RlAi.inc&quot;
+					RelativePath=&quot;.\swig\RlAi.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\RlCommon.inc&quot;
+					RelativePath=&quot;.\swig\RlCommon.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\RlCore.inc&quot;
+					RelativePath=&quot;.\swig\RlCore.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\RlDialog.inc&quot;
+					RelativePath=&quot;.\swig\RlDialog.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\RlRules.inc&quot;
+					RelativePath=&quot;.\swig\RlRules.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\RlScript.inc&quot;
+					RelativePath=&quot;.\swig\RlScript.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\RlUi.inc&quot;
+					RelativePath=&quot;.\swig\RlUi.swig&quot;
 					&gt;
 				&lt;/File&gt;
 			&lt;/Filter&gt;
@@ -424,51 +424,51 @@
 				Name=&quot;types&quot;
 				&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\TypeOgreColourValue.inc&quot;
+					RelativePath=&quot;.\swig\TypeOgreColourValue.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\TypeOgreQuaternion.inc&quot;
+					RelativePath=&quot;.\swig\TypeOgreQuaternion.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\TypeOgreRadian.inc&quot;
+					RelativePath=&quot;.\swig\TypeOgreRadian.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\TypeOgreReal.inc&quot;
+					RelativePath=&quot;.\swig\TypeOgreReal.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\TypeOgreString.inc&quot;
+					RelativePath=&quot;.\swig\TypeOgreString.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\TypeOgreStringVector.inc&quot;
+					RelativePath=&quot;.\swig\TypeOgreStringVector.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\TypeOgreVector3.inc&quot;
+					RelativePath=&quot;.\swig\TypeOgreVector3.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\TypeRlCeGuiString.inc&quot;
+					RelativePath=&quot;.\swig\TypeRlCeGuiString.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\TypeRlCeGuiStringVector.inc&quot;
+					RelativePath=&quot;.\swig\TypeRlCeGuiStringVector.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\TypeRlProperty.inc&quot;
+					RelativePath=&quot;.\swig\TypeRlProperty.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\TypeRlTripelInt.inc&quot;
+					RelativePath=&quot;.\swig\TypeRlTripelInt.swig&quot;
 					&gt;
 				&lt;/File&gt;
 				&lt;File
-					RelativePath=&quot;.\swig\TypeStdPairIntInt.inc&quot;
+					RelativePath=&quot;.\swig\TypeStdPairIntInt.swig&quot;
 					&gt;
 				&lt;/File&gt;
 			&lt;/Filter&gt;

Modified: rl/trunk/engine/script/swig/Makefile.am
===================================================================
--- rl/trunk/engine/script/swig/Makefile.am	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/Makefile.am	2007-02-27 11:04:17 UTC (rev 3080)
@@ -2,10 +2,10 @@
 
 all: RlExports.cxx
 
-RlExports.cxx: RlCore.head.inc RlCore.inc RlRules.head.inc \
- RlRules.inc RlUi.head.inc RlUi.inc RlAi.head.inc RlAi.inc \
- RlScript.head.inc RlScript.inc RlCommon.head.inc RlCommon.inc \
- RlDialog.head.inc RlDialog.inc RlExports.i TypeMaps.i
+RlExports.cxx: RlCore.head.swig RlCore.swig RlRules.head.swig \
+ RlRules.swig RlUi.head.swig RlUi.swig RlAi.head.swig RlAi.swig \
+ RlScript.head.swig RlScript.swig RlCommon.head.swig RlCommon.swig \
+ RlDialog.head.swig RlDialog.swig RlExports.i TypeMaps.i
  
 .i.cxx:
-	$(SWIG) $(SWIG_RUBY_OPT) -o $@ $&lt;
\ No newline at end of file
+	$(SWIG) $(SWIG_RUBY_OPT) -o $@ $&lt;

Deleted: rl/trunk/engine/script/swig/RlAi.head.inc
===================================================================
--- rl/trunk/engine/script/swig/RlAi.head.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlAi.head.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,27 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-%{
-//----------- Includes - Ai -----------
-#include &quot;FixRubyHeaders.h&quot;
-#include &quot;AiPrerequisites.h&quot;
-#include &quot;SteeringMachine.h&quot;
-#include &quot;SteeringVehicle.h&quot;
-#include &quot;AiSubsystem.h&quot;
-#include &quot;AgentManager.h&quot;
-#include &quot;Agent.h&quot;
-#include &quot;PhysicalObstacle.h&quot;
-%}
\ No newline at end of file

Added: rl/trunk/engine/script/swig/RlAi.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.head.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlAi.head.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,27 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+%{
+//----------- Includes - Ai -----------
+#include &quot;FixRubyHeaders.h&quot;
+#include &quot;AiPrerequisites.h&quot;
+#include &quot;SteeringMachine.h&quot;
+#include &quot;SteeringVehicle.h&quot;
+#include &quot;AiSubsystem.h&quot;
+#include &quot;AgentManager.h&quot;
+#include &quot;Agent.h&quot;
+#include &quot;PhysicalObstacle.h&quot;
+%}
\ No newline at end of file


Property changes on: rl/trunk/engine/script/swig/RlAi.head.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/RlAi.inc
===================================================================
--- rl/trunk/engine/script/swig/RlAi.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlAi.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,117 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-namespace rl 
-{
-	class SteeringVehicle
-	{
-	public:
-		SteeringVehicle(rl::Agent* agent, rl::Actor* character);
-		
-		void addForce(const Ogre::Vector3&amp; force);
-
-		Ogre::Vector3 calcWander(const float elapsedTime);
-
-		Ogre::Vector3 calcSeek(const Ogre::Vector3&amp; target);
-
-		Ogre::Vector3 calcFlee(const Ogre::Vector3&amp; target);
-		
-		Ogre::Vector3 calcPursuit(rl::Agent* agent);
-
-		Ogre::Vector3 calcAvoidObstacles(const float minTimeToCollision);
-
-		Ogre::Vector3 calcAvoidNeighbors(const float minTimeToCollision);
-		
-		Ogre::Vector3 calcSteerTargetSpeed(const float targetSpeed);
-		
-		bool isDialogActive();
-		
-		float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2);
-		
-		Ogre::Vector3 getPosition();
-		
-		bool isAhead(rl::Agent* agent, const float threshold);
-		
-		bool needAvoidance(const float minTimeToCollision);
-		
-		void setAnimation(rl::CeGuiString&amp; name);
-	};
-	
-	%feature(&quot;director&quot;) SteeringBehaviour;
-	class SteeringBehaviour
-	{
-	public:
-		SteeringBehaviour();
-		virtual ~SteeringBehaviour();
-		virtual rl::CeGuiString getType()=0;
-		virtual void init()=0;
-		virtual void activate()=0;
-		virtual void deactivate()=0;
-		virtual void update(const float elapsedTime)=0;
-
-		virtual float calculateActivation()=0;
-		
-		float getActivationLevel();
-		void setActivationLevel(float activationLevel);
-
-		rl::SteeringBehaviour* getParent();
-		rl::SteeringVehicle* getController();
-	};
-	
-	class Agent
-	{
-	public:
-		Agent(rl::Creature* character);
-		virtual ~Agent();
-		void addSteeringBehaviour(rl::SteeringBehaviour* behaviour);
-		void clearSteeringBehaviours();
-		bool isDialogActive();
-	};
-	class AiSubsystem 
-	{
-	public:
-		static AiSubsystem&amp; getSingleton(void);
-	};
-	
-	class AgentManager
-	{
-	public:
-		enum AgentType
-		{
-			AGENT_NONE = -1,
-			AGENT_PLAYER = 0,
-			AGENT_STD_NPC = 1,
-			AGENT_FLOCKING = 2
-		};
-		
-		static AgentManager&amp; getSingleton(void);
-		rl::Agent* createAgent(rl::AgentManager::AgentType type, rl::Creature* character);
-		rl::Agent* createAgent(rl::DialogCharacter* character);
-	};
-	
-    class PhysicalObstacle {
-        
-        public:
-            PhysicalObstacle(rl::PhysicalThing *thing);
-            virtual ~PhysicalObstacle();
-            
-            OpenSteer::Obstacle *getObstacle() const;
-            
-            rl::PhysicalThing *getPhysicalThing() const;
-            void setPhysicalThing(rl::PhysicalThing *thing);
-    };
-	
-}

Added: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,117 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+namespace rl 
+{
+	class SteeringVehicle
+	{
+	public:
+		SteeringVehicle(rl::Agent* agent, rl::Actor* character);
+		
+		void addForce(const Ogre::Vector3&amp; force);
+
+		Ogre::Vector3 calcWander(const float elapsedTime);
+
+		Ogre::Vector3 calcSeek(const Ogre::Vector3&amp; target);
+
+		Ogre::Vector3 calcFlee(const Ogre::Vector3&amp; target);
+		
+		Ogre::Vector3 calcPursuit(rl::Agent* agent);
+
+		Ogre::Vector3 calcAvoidObstacles(const float minTimeToCollision);
+
+		Ogre::Vector3 calcAvoidNeighbors(const float minTimeToCollision);
+		
+		Ogre::Vector3 calcSteerTargetSpeed(const float targetSpeed);
+		
+		bool isDialogActive();
+		
+		float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2);
+		
+		Ogre::Vector3 getPosition();
+		
+		bool isAhead(rl::Agent* agent, const float threshold);
+		
+		bool needAvoidance(const float minTimeToCollision);
+		
+		void setAnimation(rl::CeGuiString&amp; name);
+	};
+	
+	%feature(&quot;director&quot;) SteeringBehaviour;
+	class SteeringBehaviour
+	{
+	public:
+		SteeringBehaviour();
+		virtual ~SteeringBehaviour();
+		virtual rl::CeGuiString getType()=0;
+		virtual void init()=0;
+		virtual void activate()=0;
+		virtual void deactivate()=0;
+		virtual void update(const float elapsedTime)=0;
+
+		virtual float calculateActivation()=0;
+		
+		float getActivationLevel();
+		void setActivationLevel(float activationLevel);
+
+		rl::SteeringBehaviour* getParent();
+		rl::SteeringVehicle* getController();
+	};
+	
+	class Agent
+	{
+	public:
+		Agent(rl::Creature* character);
+		virtual ~Agent();
+		void addSteeringBehaviour(rl::SteeringBehaviour* behaviour);
+		void clearSteeringBehaviours();
+		bool isDialogActive();
+	};
+	class AiSubsystem 
+	{
+	public:
+		static AiSubsystem&amp; getSingleton(void);
+	};
+	
+	class AgentManager
+	{
+	public:
+		enum AgentType
+		{
+			AGENT_NONE = -1,
+			AGENT_PLAYER = 0,
+			AGENT_STD_NPC = 1,
+			AGENT_FLOCKING = 2
+		};
+		
+		static AgentManager&amp; getSingleton(void);
+		rl::Agent* createAgent(rl::AgentManager::AgentType type, rl::Creature* character);
+		rl::Agent* createAgent(rl::DialogCharacter* character);
+	};
+	
+    class PhysicalObstacle {
+        
+        public:
+            PhysicalObstacle(rl::PhysicalThing *thing);
+            virtual ~PhysicalObstacle();
+            
+            OpenSteer::Obstacle *getObstacle() const;
+            
+            rl::PhysicalThing *getPhysicalThing() const;
+            void setPhysicalThing(rl::PhysicalThing *thing);
+    };
+	
+}


Property changes on: rl/trunk/engine/script/swig/RlAi.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/RlCommon.head.inc
===================================================================
--- rl/trunk/engine/script/swig/RlCommon.head.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlCommon.head.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,32 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-%{
-//----------- Includes - Common -----------
-#include &quot;FixRubyHeaders.h&quot;
-#include &quot;CommonPrerequisites.h&quot;
-#include &quot;GameTask.h&quot;
-#include &lt;set&gt;
-#include &quot;EventListener.h&quot;
-#include &quot;EventObject.h&quot;
-#include &quot;EventCaster.h&quot;
-#include &quot;PlaylistObject.h&quot;
-#include &quot;Playlist.h&quot;
-#include &quot;PlaylistEvent.h&quot;
-#include &quot;Property.h&quot;
-#include &quot;SimplePlaylist.h&quot;
-#include &quot;LinkedPlaylist.h&quot;
-%}

Added: rl/trunk/engine/script/swig/RlCommon.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCommon.head.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlCommon.head.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,32 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+%{
+//----------- Includes - Common -----------
+#include &quot;FixRubyHeaders.h&quot;
+#include &quot;CommonPrerequisites.h&quot;
+#include &quot;GameTask.h&quot;
+#include &lt;set&gt;
+#include &quot;EventListener.h&quot;
+#include &quot;EventObject.h&quot;
+#include &quot;EventCaster.h&quot;
+#include &quot;PlaylistObject.h&quot;
+#include &quot;Playlist.h&quot;
+#include &quot;PlaylistEvent.h&quot;
+#include &quot;Property.h&quot;
+#include &quot;SimplePlaylist.h&quot;
+#include &quot;LinkedPlaylist.h&quot;
+%}


Property changes on: rl/trunk/engine/script/swig/RlCommon.head.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/RlCommon.inc
===================================================================
--- rl/trunk/engine/script/swig/RlCommon.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlCommon.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,175 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Perl Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Perl Artistic License for more details.
- *
- *  You should have received a copy of the Perl Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
- */
-
-namespace Ogre {
-
-template&lt;class T&gt; class SharedPtr {
- public:
-    SharedPtr();
-    SharedPtr(T* rep);
-    SharedPtr(const SharedPtr&amp; r);
-    virtual ~SharedPtr(); 
-    T* get() const;
-};
-
-}
-
-namespace rl {
-
-class GameTask
-{
-    public:
-        GameTask();
-        virtual ~GameTask( ) {};
-        bool isPaused() const;
-        void setPaused( bool isPaused );
-		virtual void run(float) = 0;
-};
-
-
-template &lt;typename Event&gt; class EventListener {
-public:
-    /// Der Konstruktor.
-	EventListener();
-    /// Der Destruktor.
-	virtual ~EventListener();
-    /* Hier wird das Objekt benachrichtigt.
-	 *
-	 * @return bool consumed Wurde der Event aufgebracht (defunct)
-	 */
-    virtual bool eventRaised(Event *anEvent) = 0;
-};
-
-template &lt;typename Event&gt; class EventCaster {
-public:
-    typedef rl::EventListener&lt;Event&gt; ListenerToEvent;
-    typedef std::set&lt;rl::ListenerToEvent*&gt; EventSet;
-    typedef typename EventSet::iterator EventSetIterator;
-
-    /// Der Konstruktor
-	EventCaster();
-    /// Der Destruktor
-    virtual ~EventCaster();
-    /// Fuege einen EventListener hinzu.
-    void addEventListener(rl::EventListener&lt;Event&gt; *newListener);
-    /// Loesche einen EventListener.
-    void removeEventListener(rl::EventListener&lt;Event&gt; *aListener);
-    /// Loescht alle EventListener.
-    void removeEventListeners();
-    /// Gibt es diesen Listener bereits?
-    bool containsListener(rl::EventListener&lt;Event&gt; *aListener) const;
-    /// Sind Listener vorhanden?
-    bool hasEventListeners() const;
-    /// Ein Ereignis verteilen.
-    void dispatchEvent(Event *anEvent);
-    /// EventSet
-    EventSet getEventSet() const;
-
-};
-
-class EventObject {
-public:
-    /// Der Konstruktor.
-	EventObject(rl::EventSource *source);
-	/// Der Konstruktor.
-	EventObject(rl::EventSource *source, const unsigned int reason );
-    /// Der Destruktor.
-	virtual ~EventObject();
-   
-   /// Die Ereignisquelle zurueckgeben
-   rl::EventSource *getSource() const;
-   /// Die ID des Grundes f&#252;r den Event.
-   const unsigned int getReason() const;
-   /// Die ID setzen
-   void setReason(const unsigned int reason);
-};
-
-%template(EventObjectEventCaster) EventCaster&lt;rl::EventObject&gt;;
-class PlaylistObject : public rl::EventCaster&lt;rl::EventObject&gt;
-{
-public:
-	/// Konstruktor
-	PlaylistObject();
-	/// Destruktor
-	~PlaylistObject();
-	/// Objekt laden, einrichten etc.
-	virtual void load() = 0;
-	/// Objekt entladen, abbauen etc.
-	virtual void unload() = 0;
-	/// Objektaktion starten
-	virtual void start() = 0;
-	/// Objectaktion stoppen
-	virtual void stop() = 0;
-	/// Objektaktion pausieren
-	virtual void pause() = 0;
-};
-
-class PlaylistEvent : public rl::EventObject
-{
-};
-
-%template(EventObjectEventListener) EventListener&lt;rl::PlaylistEvent&gt;;
-class Playlist : public rl::EventListener&lt;rl::PlaylistEvent&gt;
-{
-public:
-	Playlist();
-	virtual ~Playlist();
-    virtual void start() = 0;
-    virtual void stop() = 0;
-};
-
-class SimplePlaylist : public rl::Playlist
-{
-public:
-	SimplePlaylist();
-	virtual ~SimplePlaylist();
-    virtual void add(rl::PlaylistObject *object);
-    virtual void remove(rl::PlaylistObject *object);
-    virtual void start();
-    virtual void stop();
-    void setLooping(bool looping);
-    bool isLooping() const;
-    virtual bool eventRaised(rl::PlaylistEvent *eventRaised);
-};
-
-class rl::LinkItem;
-typedef std::list&lt;rl::LinkItem*&gt; LinkedList;
-class LinkItem {
-public:
-	LinkItem(rl::PlaylistObject *item);
-	virtual ~LinkItem();
-	rl::PlaylistObject* getItem() const;
-	void start();
-	void stop();
-	void add(rl::PlaylistObject *child);
-	void remove(rl::PlaylistObject *child);
-};
-
-
-class LinkedPlaylist : public rl::Playlist
-{
-public:
-	LinkedPlaylist();
-	virtual ~LinkedPlaylist();
-    void add(rl::PlaylistObject *object, LinkItem *parent);
-	void remove(rl::PlaylistObject *object, LinkItem *parent);
-    virtual void stop();
-	virtual void start();
-	LinkItem* getList() const;
-};
-
-}
-

Added: rl/trunk/engine/script/swig/RlCommon.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCommon.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlCommon.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,175 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
+ */
+
+namespace Ogre {
+
+template&lt;class T&gt; class SharedPtr {
+ public:
+    SharedPtr();
+    SharedPtr(T* rep);
+    SharedPtr(const SharedPtr&amp; r);
+    virtual ~SharedPtr(); 
+    T* get() const;
+};
+
+}
+
+namespace rl {
+
+class GameTask
+{
+    public:
+        GameTask();
+        virtual ~GameTask( ) {};
+        bool isPaused() const;
+        void setPaused( bool isPaused );
+		virtual void run(float) = 0;
+};
+
+
+template &lt;typename Event&gt; class EventListener {
+public:
+    /// Der Konstruktor.
+	EventListener();
+    /// Der Destruktor.
+	virtual ~EventListener();
+    /* Hier wird das Objekt benachrichtigt.
+	 *
+	 * @return bool consumed Wurde der Event aufgebracht (defunct)
+	 */
+    virtual bool eventRaised(Event *anEvent) = 0;
+};
+
+template &lt;typename Event&gt; class EventCaster {
+public:
+    typedef rl::EventListener&lt;Event&gt; ListenerToEvent;
+    typedef std::set&lt;rl::ListenerToEvent*&gt; EventSet;
+    typedef typename EventSet::iterator EventSetIterator;
+
+    /// Der Konstruktor
+	EventCaster();
+    /// Der Destruktor
+    virtual ~EventCaster();
+    /// Fuege einen EventListener hinzu.
+    void addEventListener(rl::EventListener&lt;Event&gt; *newListener);
+    /// Loesche einen EventListener.
+    void removeEventListener(rl::EventListener&lt;Event&gt; *aListener);
+    /// Loescht alle EventListener.
+    void removeEventListeners();
+    /// Gibt es diesen Listener bereits?
+    bool containsListener(rl::EventListener&lt;Event&gt; *aListener) const;
+    /// Sind Listener vorhanden?
+    bool hasEventListeners() const;
+    /// Ein Ereignis verteilen.
+    void dispatchEvent(Event *anEvent);
+    /// EventSet
+    EventSet getEventSet() const;
+
+};
+
+class EventObject {
+public:
+    /// Der Konstruktor.
+	EventObject(rl::EventSource *source);
+	/// Der Konstruktor.
+	EventObject(rl::EventSource *source, const unsigned int reason );
+    /// Der Destruktor.
+	virtual ~EventObject();
+   
+   /// Die Ereignisquelle zurueckgeben
+   rl::EventSource *getSource() const;
+   /// Die ID des Grundes f&#252;r den Event.
+   const unsigned int getReason() const;
+   /// Die ID setzen
+   void setReason(const unsigned int reason);
+};
+
+%template(EventObjectEventCaster) EventCaster&lt;rl::EventObject&gt;;
+class PlaylistObject : public rl::EventCaster&lt;rl::EventObject&gt;
+{
+public:
+	/// Konstruktor
+	PlaylistObject();
+	/// Destruktor
+	~PlaylistObject();
+	/// Objekt laden, einrichten etc.
+	virtual void load() = 0;
+	/// Objekt entladen, abbauen etc.
+	virtual void unload() = 0;
+	/// Objektaktion starten
+	virtual void start() = 0;
+	/// Objectaktion stoppen
+	virtual void stop() = 0;
+	/// Objektaktion pausieren
+	virtual void pause() = 0;
+};
+
+class PlaylistEvent : public rl::EventObject
+{
+};
+
+%template(EventObjectEventListener) EventListener&lt;rl::PlaylistEvent&gt;;
+class Playlist : public rl::EventListener&lt;rl::PlaylistEvent&gt;
+{
+public:
+	Playlist();
+	virtual ~Playlist();
+    virtual void start() = 0;
+    virtual void stop() = 0;
+};
+
+class SimplePlaylist : public rl::Playlist
+{
+public:
+	SimplePlaylist();
+	virtual ~SimplePlaylist();
+    virtual void add(rl::PlaylistObject *object);
+    virtual void remove(rl::PlaylistObject *object);
+    virtual void start();
+    virtual void stop();
+    void setLooping(bool looping);
+    bool isLooping() const;
+    virtual bool eventRaised(rl::PlaylistEvent *eventRaised);
+};
+
+class rl::LinkItem;
+typedef std::list&lt;rl::LinkItem*&gt; LinkedList;
+class LinkItem {
+public:
+	LinkItem(rl::PlaylistObject *item);
+	virtual ~LinkItem();
+	rl::PlaylistObject* getItem() const;
+	void start();
+	void stop();
+	void add(rl::PlaylistObject *child);
+	void remove(rl::PlaylistObject *child);
+};
+
+
+class LinkedPlaylist : public rl::Playlist
+{
+public:
+	LinkedPlaylist();
+	virtual ~LinkedPlaylist();
+    void add(rl::PlaylistObject *object, LinkItem *parent);
+	void remove(rl::PlaylistObject *object, LinkItem *parent);
+    virtual void stop();
+	virtual void start();
+	LinkItem* getList() const;
+};
+
+}
+


Property changes on: rl/trunk/engine/script/swig/RlCommon.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/RlCore.head.inc
===================================================================
--- rl/trunk/engine/script/swig/RlCore.head.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlCore.head.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,61 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-%{
-//----------- Includes - Core -----------
-#include &quot;FixRubyHeaders.h&quot;
-#include &quot;CorePrerequisites.h&quot;
-#include &quot;ActorManager.h&quot;
-#include &quot;Actor.h&quot;
-#include &quot;MeshObject.h&quot;
-#include &quot;SoundObject.h&quot;
-#include &quot;SoundManager.h&quot;
-#include &quot;ListenerObject.h&quot;
-#include &quot;ListenerMovable.h&quot;
-#include &quot;CameraObject.h&quot;
-#include &quot;LightObject.h&quot;
-#include &quot;ParticleSystemObject.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;PhysicalThing.h&quot;
-#include &quot;PhysicsManager.h&quot;
-#include &quot;PhysicsContactListener.h&quot;
-#include &quot;DebugVisualsManager.h&quot;
-#include &quot;GameEventManager.h&quot;
-#include &quot;GameAreaEventSource.h&quot;
-#include &quot;GameAreaListener.h&quot;
-#include &quot;GameAreaEvent.h&quot;
-#include &quot;GameAreaTypes.h&quot;
-#include &quot;AnimationManager.h&quot;
-#include &quot;AnimationListener.h&quot;
-#include &quot;BaseAnimation.h&quot;
-#include &quot;MeshAnimation.h&quot;
-#include &quot;FadeAnimation.h&quot;
-#include &quot;TrackAnimation.h&quot;
-#include &quot;GameLoop.h&quot;
-#include &quot;World.h&quot;
-#include &quot;ContentModule.h&quot;
-#include &quot;ListenerObject.h&quot;
-#include &quot;Sound.h&quot;
-#include &quot;SoundEvents.h&quot;
-#include &quot;JobScheduler.h&quot;
-#include &quot;Job.h&quot;
-#include &quot;JobListener.h&quot;
-#include &quot;PlaySoundJob.h&quot;
-#include &quot;PlayAnimationJob.h&quot;
-#undef message
-#undef send
-%}
-

Added: rl/trunk/engine/script/swig/RlCore.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.head.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlCore.head.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,61 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+%{
+//----------- Includes - Core -----------
+#include &quot;FixRubyHeaders.h&quot;
+#include &quot;CorePrerequisites.h&quot;
+#include &quot;ActorManager.h&quot;
+#include &quot;Actor.h&quot;
+#include &quot;MeshObject.h&quot;
+#include &quot;SoundObject.h&quot;
+#include &quot;SoundManager.h&quot;
+#include &quot;ListenerObject.h&quot;
+#include &quot;ListenerMovable.h&quot;
+#include &quot;CameraObject.h&quot;
+#include &quot;LightObject.h&quot;
+#include &quot;ParticleSystemObject.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;PhysicalThing.h&quot;
+#include &quot;PhysicsManager.h&quot;
+#include &quot;PhysicsContactListener.h&quot;
+#include &quot;DebugVisualsManager.h&quot;
+#include &quot;GameEventManager.h&quot;
+#include &quot;GameAreaEventSource.h&quot;
+#include &quot;GameAreaListener.h&quot;
+#include &quot;GameAreaEvent.h&quot;
+#include &quot;GameAreaTypes.h&quot;
+#include &quot;AnimationManager.h&quot;
+#include &quot;AnimationListener.h&quot;
+#include &quot;BaseAnimation.h&quot;
+#include &quot;MeshAnimation.h&quot;
+#include &quot;FadeAnimation.h&quot;
+#include &quot;TrackAnimation.h&quot;
+#include &quot;GameLoop.h&quot;
+#include &quot;World.h&quot;
+#include &quot;ContentModule.h&quot;
+#include &quot;ListenerObject.h&quot;
+#include &quot;Sound.h&quot;
+#include &quot;SoundEvents.h&quot;
+#include &quot;JobScheduler.h&quot;
+#include &quot;Job.h&quot;
+#include &quot;JobListener.h&quot;
+#include &quot;PlaySoundJob.h&quot;
+#include &quot;PlayAnimationJob.h&quot;
+#undef message
+#undef send
+%}
+


Property changes on: rl/trunk/engine/script/swig/RlCore.head.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/RlCore.inc
===================================================================
--- rl/trunk/engine/script/swig/RlCore.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlCore.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,759 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-namespace rl {
-%{
-static swig_type_info *GameAreaType_dynamic_cast(void **ptr) {
-    rl::GameAreaType **ppGameAreaType = reinterpret_cast&lt;rl::GameAreaType **&gt;(ptr);
-    
-    rl::GameSphereAreaType *pGameSphereAreaType = dynamic_cast&lt;rl::GameSphereAreaType*&gt;(*ppGameAreaType);
-    if(pGameSphereAreaType){
-      *ptr=reinterpret_cast&lt;void*&gt;(pGameSphereAreaType);
-      return SWIGTYPE_p_rl__GameSphereAreaType;
-    }    
-    
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__GameAreaType, GameAreaType_dynamic_cast);
-
-
-
-%{
-static swig_type_info *BaseAnimation_dynamic_cast(void **ptr) {
-    rl::BaseAnimation **ppBaseAnimation = reinterpret_cast&lt;rl::BaseAnimation **&gt;(ptr);
-    
-    rl::FadeAnimation *pFadeAnimation = dynamic_cast&lt;rl::FadeAnimation*&gt;(*ppBaseAnimation);
-    if(pFadeAnimation){
-      *ptr=reinterpret_cast&lt;void*&gt;(pFadeAnimation);
-      return SWIGTYPE_p_rl__FadeAnimation;
-    }    
-    rl::MeshAnimation *pMeshAnimation = dynamic_cast&lt;rl::MeshAnimation*&gt;(*ppBaseAnimation);
-    if(pMeshAnimation){
-      *ptr=reinterpret_cast&lt;void*&gt;(pMeshAnimation);
-      return SWIGTYPE_p_rl__MeshAnimation;
-    }    
-    rl::TrackAnimation *pTrackAnimation = dynamic_cast&lt;rl::TrackAnimation*&gt;(*ppBaseAnimation);
-    if(pTrackAnimation){
-      *ptr=reinterpret_cast&lt;void*&gt;(pTrackAnimation);
-      return SWIGTYPE_p_rl__TrackAnimation;
-    }  
-    
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__BaseAnimation, BaseAnimation_dynamic_cast);
-
-
-%{
-static swig_type_info *ActorControlledObject_dynamic_cast(void **ptr)
-{
-    rl::ActorControlledObject **ppActorControlledObject =
-        reinterpret_cast&lt;rl::ActorControlledObject**&gt;(ptr);
-
-    rl::MeshObject *pMeshObject=dynamic_cast&lt;rl::MeshObject*&gt;(*ppActorControlledObject);
-    if (pMeshObject) {
-        *ptr=reinterpret_cast&lt;void*&gt;(pMeshObject);
-        return SWIGTYPE_p_rl__MeshObject;
-    }
-    rl::CameraObject *pCameraObject=dynamic_cast&lt;rl::CameraObject*&gt;(*ppActorControlledObject);
-    if (pCameraObject) {
-        *ptr=reinterpret_cast&lt;void*&gt;(pCameraObject);
-        return SWIGTYPE_p_rl__CameraObject;
-    }
-    rl::LightObject *pLightObject=dynamic_cast&lt;rl::LightObject*&gt;(*ppActorControlledObject);
-    if (pLightObject) {
-        *ptr=reinterpret_cast&lt;void*&gt;(pLightObject);
-        return SWIGTYPE_p_rl__LightObject;
-    }
-    rl::ParticleSystemObject *pParticleSystemObject=dynamic_cast&lt;rl::ParticleSystemObject*&gt;(*ppActorControlledObject);
-    if (pParticleSystemObject) {
-        *ptr=reinterpret_cast&lt;void*&gt;(pParticleSystemObject);
-        return SWIGTYPE_p_rl__ParticleSystemObject;
-    }
-    rl::SoundObject *pSoundObject=dynamic_cast&lt;rl::SoundObject*&gt;(*ppActorControlledObject);
-    if (pSoundObject) {
-        *ptr=reinterpret_cast&lt;void*&gt;(pSoundObject);
-        return SWIGTYPE_p_rl__SoundObject;
-    }
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__ActorControlledObject, ActorControlledObject_dynamic_cast);
-
-
-class ActorManager {
-private:
-	ActorManager();
-public:
-	static ActorManager&amp; getSingleton(void);
-
-	rl::Actor* createParticleSystemActor(const Ogre::String&amp; name, const Ogre::String&amp; soundfile);
-    rl::Actor* createSoundStreamActor(const Ogre::String&amp; name, const Ogre::String&amp; soundfile);
-    rl::Actor* createSoundSampleActor(const Ogre::String&amp; name, const Ogre::String&amp; soundfile);
-    rl::Actor* createEmptyActor(const Ogre::String&amp; name);
-    rl::Actor* createLightActor(const Ogre::String&amp; name, rl::LightObject::LightTypes type );
-	rl::Actor* createMeshActor(const Ogre::String&amp; name, const Ogre::String&amp; meshname,
-		    rl::PhysicsManager::GeometryType geom = rl::PhysicsManager::GT_NONE,
-		    Ogre::Real density=1.0);
-	rl::Actor* createBoxPrimitiveActor(const Ogre::String&amp; name,
-            const Ogre::Vector3&amp; minCorner, const Ogre::Vector3&amp; maxCorner,
-            const Ogre::String&amp; materialName = &quot;&quot;, Ogre::Real mass = 0.0);
-		    
-	//void createDebugActors();
-	    
-	rl::Actor* getActor(const Ogre::String&amp; name);
-	void destroyActor(rl::Actor* actor);
-    void destroyAllActors();
-};
-
-class World {
-public:	
-	enum FogMode { FOG_NONE, FOG_EXP, FOG_EXP2, FOG_LINEAR  };
-
-	void loadScene(const Ogre::String&amp; levelName, const Ogre::String&amp; resourceGroup ) = 0;
-
-    virtual void setSkyBox (bool enable, const Ogre::String&amp; materialName, Ogre::Real distance=2500, bool drawFirst=true );
-    virtual void setSkyDome (bool enable, const Ogre::String&amp; materialName, Ogre::Real curvature=10, Ogre::Real tiling=8, Ogre::Real distance=4000, bool drawFirst=true );
-    virtual void setFog ( FogMode mode=FOG_NONE, const Ogre::ColourValue &amp;colour=Ogre::ColourValue::White, Ogre::Real expDensity=0.001, Ogre::Real linearStart=0.0, Ogre::Real linearEnd=1.0);
-    virtual FogMode getFogMode (void) const;
-    virtual const Ogre::ColourValue &amp; getFogColour (void) const;
-    virtual Ogre::Real getFogStart (void) const;
-    virtual Ogre::Real getFogEnd (void) const;	
-    virtual void setAmbientLight(Ogre::Real r, Ogre::Real g, Ogre::Real b);
-    virtual Ogre::Vector3 getStartPoint() const;
-    virtual void setCastShadows(bool);
-
-    void setShowBoundingBoxes( bool dis );
-};
-
-/// Alles was mit AreaKrams zu tun hat
-%apply SWIGTYPE *DYNAMIC { GameAreaType * };
-
-%feature(&quot;director&quot;) GameAreaListener; 
-class GameAreaListener
-{
-public:
-	virtual ~GameAreaListener();
-    virtual void areaLeft(rl::GameAreaEvent *anEvent) const = 0;
-    virtual void areaEntered(rl::GameAreaEvent *anEvent) const = 0;
-};
-
-class GameAreaType
-{
-private:
-	GameAreaType();
-public:
-	unsigned long getQueryMask() const;
-    void setQueryMask( unsigned long mask );
-    void addQueryFlag( unsigned long flag  );
-    void removeQueryFlag( unsigned long flag );
-    const Ogre::Vector3&amp; getQueryPosition() const;
-};
-
-class GameSphereAreaType : public GameAreaType
-{
-private:
-	GameSphereAreaType( Ogre::Vector3, Ogre::Real, unsigned long mask = 0xFFFFFFFF );
-public:
-};
-
-class GameAreaEventSource
-{
-private: 
-	GameAreaEventSource( rl::GameAreaType* areaType, rl::Actor* act );
-public:   
-    void addAreaListener( rl::GameAreaListener*  list );
-    void removeAreaListener( rl::GameAreaListener* list );
-    bool hasListeners( ) const;
-
-    rl::GameAreaType* getGameAreaType() const;
-    // const ActorMap&amp; getInsideAreaList() const;
-    rl::Actor* getActor() const;
-};
-
-class GameAreaEvent
-{
-private:
-	GameAreaEvent( rl::GameAreaEventSource* src, const unsigned int reason );
-public:
-    rl::Actor* getProvokingActor() const;
-    rl::GameAreaEventSource* getSource() const;
-};
-
-class GameEventManager
-{
-private:
-    GameEventManager( );
-public:
-    void addSphereAreaListener( rl::Actor* actor, Ogre::Real radius, 
-		rl::GameAreaListener* list, unsigned long queryMask = 0xFFFFFFFF );
-    void removeAreaListener( rl::GameAreaListener* list );
-    void removeAllAreas( rl::Actor* actor );
-
-    static rl::GameEventManager &amp; getSingleton(void);
-};
-
-/// Alles was mit Animationen zu tun hat
-%apply SWIGTYPE *DYNAMIC { BaseAnimation * };
-
-%feature(&quot;director&quot;) AnimationListener; 
-class AnimationListener
-{
-public:
-	virtual ~AnimationListener();
-
-	virtual void animationFinished(rl::AnimationEvent *anEvent) const = 0;
-	virtual void animationPaused(rl::AnimationEvent *anEvent) const = 0;
-	virtual void animationUnpaused(rl::AnimationEvent *anEvent) const = 0;
-};
-
-%feature(&quot;director&quot;) AnimationFrameListener; 
-class AnimationFrameListener
-{
-public:
-	virtual ~AnimationFrameListener();
-
-	virtual void animationFrameReached( rl::AnimationFrameEvent *anEvent ) const = 0;
-};
-
-class AnimationEvent
-{
-public:
-	rl::BaseAnimation* getAnimation() const;
-private:
-	AnimationEvent( rl::BaseAnimation* anim,  const unsigned int reason );
-};
-
-class AnimationFrameEvent
-{
-public:
-	rl::BaseAnimation* getAnimation() const;
-	Ogre::Real getFrameNumber() const;
-private:
-	AnimationFrameEvent( rl::BaseAnimation* anim,  const unsigned int reason, Ogre::Real frameNumber );
-};
-
-
-class BaseAnimation {
-public:
-	bool isPaused() const;
-    void setPaused( bool isPaused );
-
-	bool isIgnoringGlobalSpeed() const;
-	void setIgnoringGlobalSpeed( bool isIgnoringGlobalSpeed );
-
-	Ogre::Real getSpeed() const;
-	void setSpeed( Ogre::Real speed );
-	void reverseAnimation();
-
-	void setTimesToPlay(unsigned int timesToPlay);
-	unsigned int getTimesPlayed() const;
-	void resetTimesPlayed();
-	unsigned int getTimesToPlay() const;
-	unsigned int getTimesToPlayLeft() const;
-	Ogre::Real getTimePlayed() const;
-
-	Ogre::Real getDelay(void) const;
-    void setDelay(Ogre::Real delay);
-    
-    void addAnimationListener( rl::AnimationListener *listener);
-	void removeAnimationListener( rl::AnimationListener *listener);
-	
-	void addAnimationFrameListener( rl::AnimationFrameListener *listener, 
-									float frameNumber );
-	void removeAnimationFrameListener( rl::AnimationFrameListener *listener );
-	void removeAnimationFrameListener( rl::AnimationFrameListener *listener, Ogre::Real frameNumber );
-private:
-	BaseAnimation(  );
-};
-
-class FadeAnimation : public BaseAnimation {
-private:
-	FadeAnimation(  ); 
-public:
-	bool isDeleteOnFinish() const;
-	void setDeleteOnFinish( bool deleteOnFinish );
-};
-
-class MeshAnimation : public BaseAnimation {
-public:
-    rl::MeshObject* getMeshObject( );
-    
-	Ogre::Real getWeight(void) const;
-    void setWeight(Ogre::Real weight);
-private:
-	MeshAnimation(  ); 
-};
-
-class TrackAnimation : public BaseAnimation {
-public:
-	void addKeyFrame( Ogre::Real timePos );
-    void setKeyFrameTranslation( Ogre::Real timePos, Ogre::Real xPos, Ogre::Real yPos, Ogre::Real zPos );
-    void setKeyFrameRotation( Ogre::Real timePos, Ogre::Real xRotAxis, Ogre::Real yRotAxis, Ogre::Real zRotAxis, Ogre::Real angleUnits );
-    void setKeyFrameRotationQuaternion( Ogre::Real timePos, Ogre::Real w, Ogre::Real x, Ogre::Real y, Ogre::Real z );
-    void setKeyFrameScale( Ogre::Real timePos, Ogre::Real xScale, Ogre::Real yScale, Ogre::Real zScale );
-
-	void setInterpolationMode( rl::AnimationManager::InterpolationMode im );
-	rl::AnimationManager::InterpolationMode getInterpolationMode() const;
-
-	void setRotationInterpolationMode( rl::AnimationManager::RotationInterpolationMode im );
-	rl::AnimationManager::RotationInterpolationMode getRotationInterpolationMode() const;
-
-	void setUseShortestRotationPath ( bool useShortestPath );
-	bool getUseShortestRotationPath () const;
-private:
-	TrackAnimation(  ); 
-};
-
-class AnimationManager {
-private:
-	AnimationManager();
-public:
-	static AnimationManager&amp; getSingleton(void);
-	
-	enum InterpolationMode { IM_LINEAR, IM_SPLINE };
-	enum RotationInterpolationMode { RIM_LINEAR, RIM_SPHERICAL };
-	
-	rl::TrackAnimation* createTrackAnimation(rl::Actor* actor, const Ogre::String&amp; name, Ogre::Real length );
-	void removeAnimation( rl::MeshAnimation* anim );
-    void removeAnimation( rl::TrackAnimation* anim );
-    void removeAnimation( rl::FadeAnimation* anim );
-	void removeTrackAnimation( rl::Actor* act, const Ogre::String&amp; name );
-	void removeAllTrackAnimations( rl::Actor* act );
-	
-	void setGlobalAnimationSpeed( Ogre::Real speed );
-	Ogre::Real getGlobalAnimationSpeed( ) const;
-
-    rl::FadeAnimation* fadeAnimation( rl::MeshAnimation* from, rl::MeshAnimation* to, Ogre::Real time );
-    rl::FadeAnimation* fadeAnimation( rl::MeshAnimation* fromLoop, rl::MeshAnimation* blendAnim, 
-        rl::MeshAnimation* toLoop, Ogre::Real loopDuration = 0.0);
-	
-	void setDefaultInterpolationMode( rl::AnimationManager::InterpolationMode im );
-	rl::AnimationManager::InterpolationMode getDefaultInterpolationMode() const;
-
-	void setDefaultRotationInterpolationMode( rl::AnimationManager::RotationInterpolationMode rim );
-	rl::AnimationManager::RotationInterpolationMode getDefaultRotationInterpolationMode() const;
-};
-
-%apply SWIGTYPE *DYNAMIC { ActorControlledObject * };
-class ActorControlledObject {
-private:
-    ActorControlledObject();
-public:
-    rl::Actor* getActor();
-};
-
-class PhysicalObject : public ActorControlledObject
-{
-};
-
-class MeshObject : public PhysicalObject
-{
-private:
-    MeshObject(const Ogre::String&amp; name, const Ogre::String&amp; meshname);
-public:
-    
-    /// Groesse der Boundingbox
-    Ogre::AxisAlignedBox getDefaultSize() const;
-        
-	rl::BaseAnimation* getAnimation(const Ogre::String&amp; animName);
-	rl::BaseAnimation* replaceAnimation(const Ogre::String&amp; oldAnimName, 
-	    const Ogre::String&amp; newAnimName, float speed=1.0, unsigned int timesToPlay=0);
-	rl::BaseAnimation* startAnimation(const Ogre::String&amp; animName, 
-		float speed=1.0, unsigned int timesToPlay=0);
-    void stopAnimation(const Ogre::String&amp;);
-    void stopAllAnimations();
-    
-    void setCastShadows (bool enabled);
-    bool getCastShadows (void) const;    
-};
-
-class LightObject : public ActorControlledObject
-{
-private:
-    LightObject(const Ogre::String&amp; name, rl::LightObject::LightTypes type);
-public:
-	enum LightTypes { LT_POINT, LT_DIRECTIONAL, LT_SPOTLIGHT };
-
-    void setAttenuation(float range, float constant,
-        float linear, float quadric);
-    void setDiffuseColour(float red, float green, float blue);
-    void setDirection(float x, float y, float z);
-    void setSpecularColour(float red, float green, float blue);
-    void setSpotlightRange(float innerangle, float outerangle,
-        float falloff);
-    void setCastShadows( bool cast );
-};
-
-
-class SoundObject : public ActorControlledObject
-{
-public:
-	void play( );
-
-	void load();
-	void unload();
-	bool is3d() const;
-	void set3d( bool is3d );
-
-    /// Gibt zur&#252;ck ob der Sound geloopt werden soll 
-    bool isLooping() const;
-    /// Setzt ob der Sound geloopt werden soll 
-    void setLooping( bool looping );
-    /// Pausiert den Sound.
-    void pause(bool pausing);
-    /// Ist der Sound pausiert?
-    bool isPaused();
-    /// Stoppt den Sound.
-    void stop();
-	/// Setzt die Lautstaerke (1.0 = volle Lautst&#228;rke)
-	void setVolume(float volume = 1.0);
-	
-	rl::Sound* getSound();
-};
-
-class ParticleSystemObject : public ActorControlledObject
-{
-public:
-     void setActive(bool active);
-private:
-	 ParticleSystemObject(const Ogre::String&amp; name, const Ogre::String&amp; partSys );
-};
-
-class CameraObject : public PhysicalObject
-{
-private:
-    CameraObject(const Ogre::String&amp; name);
-public:
-};
-
-class Actor {
-private:
-	Actor(const Ogre::String&amp; name);
-public:	
-	static const Ogre::String DEFAULT_SLOT_NAME;
-
-    enum QueryGroupFlags
-    {
-        QGF_NONE = 0,
-        QGF_DEFAULT = 1,
-        QGF_PLAYER = 2,
-        QGF_ALL = 0xFFFFFFFF
-    };
-
-	const const Ogre::String&amp; getName() const;
-	const Ogre::Vector3&amp; getPosition(void);
-	const Ogre::Quaternion&amp; getOrientation(void);
-	const Ogre::Vector3&amp; getWorldPosition(void);
-	const Ogre::Quaternion&amp; getWorldOrientation(void);
-
-    void setPosition(Ogre::Real x, Ogre::Real y, Ogre::Real z);
-    void setPosition( const Ogre::Vector3&amp; );
-    void setOrientation( const Ogre::Quaternion&amp; );
-    
-    rl::ActorControlledObject* getControlledObject();
-    Ogre::UserDefinedObject* getGameObject() const;
-    rl::PhysicalThing* getPhysicalThing() const;
-
-    void setScale( Ogre::Real sx, Ogre::Real sy, Ogre::Real sz );
-    void placeIntoScene(
-            const Ogre::Vector3&amp; position = Ogre::Vector3::ZERO,
-            const Ogre::Quaternion&amp; orientation = Ogre::Quaternion::IDENTITY,
-            const Ogre::String&amp; physicsBone = &quot;&quot;);  
-    void placeIntoScene(
-        Ogre::Real px, Ogre::Real py, Ogre::Real pz,
-        Ogre::Real ow, Ogre::Real ox, Ogre::Real oy, Ogre::Real oz, 
-        const Ogre::String&amp; physicsBone = &quot;&quot;);
-    void removeFromScene();
-           
-    void attach( 
-            Actor* actor,
-            const Ogre::String&amp; childSlot = &quot;SLOT_DEFAULT&quot;,
-            const Ogre::Vector3&amp; offsetPosition=Ogre::Vector3::ZERO,
-            const Ogre::Quaternion&amp; offsetOrientation=Ogre::Quaternion::IDENTITY
-            );
-   	void attachAxisRot( 
-            rl::Actor* actor,
-            const Ogre::String&amp; childSlot = &quot;SLOT_DEFAULT&quot;,            
-            const Ogre::Vector3&amp; offsetPosition=Ogre::Vector3::ZERO,
-            const Ogre::Vector3&amp; offsetAxis=Ogre::Vector3::UNIT_X,
-            const Ogre::Radian&amp; offsetRotation=Ogre::Radian(0) );
-    void attachToSlot( 
-            Actor* actor,
-            const Ogre::String&amp; slot,
-            const Ogre::String&amp; childSlot = &quot;SLOT_DEFAULT&quot;,
-            const Ogre::Vector3&amp; offsetPosition=Ogre::Vector3::ZERO,
-			const Ogre::Quaternion&amp; offsetOrientation=Ogre::Quaternion::IDENTITY
-			);
-    void attachToSlotAxisRot( 
-            rl::Actor* actor,
-            const Ogre::String&amp; slot,
-            const Ogre::String&amp; childSlot = &quot;SLOT_DEFAULT&quot;,            
-			const Ogre::Vector3&amp; offsetPosition=Ogre::Vector3::ZERO,
-            const Ogre::Vector3&amp; offsetAxis=Ogre::Vector3::UNIT_X,
-            const Ogre::Radian&amp; offsetRotation=Ogre::Radian(0) );
-                    
-    void detach(rl::Actor* actor);
-    
-    rl::Actor* getChildByName(const Ogre::String&amp; name ) const;
-    
-    void setVisible( bool vis, bool cascade = true );
-	bool isVisible() const;
-       
-	void roll(Ogre::Real angleunits);
-	void pitch(Ogre::Real angleunits);
-	void yaw(Ogre::Real angleunits);
-	
-	unsigned long getQueryMask() const;
-    void setQueryMask( unsigned long mask = 0xFFFFFFFF );
-    void addQueryFlag( unsigned long flag  );
-    void removeQueryFlag( unsigned long flag );
-    void setListenerOf (Ogre::SceneNode *node);
-    Ogre::Bone *_getBone() const;
-    Ogre::SceneNode* _getSceneNode() const;
-    
-};
-
-%feature(&quot;director&quot;) PhysicsContactListener; 
-class PhysicsContactListener
-{
-public:
-    PhysicsContactListener();
-    virtual ~PhysicsContactListener();
-    
-    virtual void contactOccured(rl::Actor* actor1, rl::Actor* actor2) = 0;
-};
-
-class PhysicalThing
-{
-public:
-    PhysicalThing(
-			rl::PhysicsManager::GeometryType geomType,
-			rl::PhysicalObject* po, 
-			Ogre::Real mass, 
-			bool hullModifier = false);
-
-    void setPosition(Ogre::Real x, Ogre::Real y, Ogre::Real z);
-    void setOrientation(Ogre::Real w, Ogre::Real x, Ogre::Real y, Ogre::Real z);
-    
-    void setVelocity(const Ogre::Vector3&amp; vel);
-
-    // Sets the vector, that will always point up.
-    void setUpConstraint(const Ogre::Vector3&amp; upVector = Ogre::Vector3::UNIT_Y);
-    Ogre::Vector3 getUpConstraint() const;
-    void clearUpConstraint();
-
-    rl::Actor* getActor() const;
-
-    void addForce(const Ogre::Vector3&amp; force);
-
-    void freeze();
-    void unfreeze();
-        
-    void setGravityOverride(bool override,
-        Ogre::Real x = 0.0f, Ogre::Real y = 0.0f, Ogre::Real z = 0.0f);
-        
-    Ogre::Real getMass() const;
-    void setMass(Ogre::Real mass);
-    
-    void updateCollisionHull();
-
-    void setContactListener(rl::PhysicsContactListener* listener);
-    rl::PhysicsContactListener* getContactListener() const;
-
-    void fitToPose(const Ogre::String&amp; name);
-
-};
-
-class PhysicsManager
-{
-public:
-
-    enum GeometryType {
-        GT_NONE = -1,
-        GT_BOX = 0,
-        GT_SPHERE = 1,
-        GT_CAPSULE = 2,
-        GT_MESH = 3,
-        GT_ELLIPSOID = 4,
-        GT_CONVEXHULL = 5
-    };
-    
-    PhysicsManager();
-	static PhysicsManager&amp; getSingleton(void);
-    
-    rl::PhysicalThing* createPhysicalThing(rl::PhysicsManager::GeometryType geomType, rl::PhysicalObject* po,
-		Ogre::Real mass);
-
-    void removeAndDestroyPhysicalThing(PhysicalThing* thing);
-
-    // Global Settings
-    void setGravity(Ogre::Real x, Ogre::Real y, Ogre::Real z);
-    Ogre::Vector3 getGravity() const;
-
-    bool isEnabled() const;
-    void setEnabled(bool enabled);
-	
-	void toggleDebugMode();
-    bool isDebugMode() const;
-};
-
-class DebugVisualsManager
-{
-public:
-    DebugVisualsManager();
-    static DebugVisualsManager&amp; getSingleton(void);
-
-    void show(unsigned long flags);
-    void hide(unsigned long flags);
-    void showAll();
-    void hideAll();
-    void toggleAll();
-};
-    
-%feature(&quot;director&quot;) ContentModule; 
-class ContentModule
-{
-public:
-	ContentModule(
-		const Ogre::String&amp; id, 
-		const rl::CeGuiString&amp; name, 
-		bool common, 
-		long minimumEngineVersion);
-		
-	virtual ~ContentModule();
-		
-	virtual const Ogre::StringVector&amp; getDependencies() const = 0;
-	virtual const Ogre::StringVector&amp; getTextureLocations() const = 0;
-	virtual const Ogre::StringVector&amp; getSoundLocations() const = 0;
-	virtual const Ogre::StringVector&amp; getModelLocations() const = 0;
-
-	virtual void start() = 0;
-};
-
-class CoreSubsystem {
-private:
-	CoreSubsystem();
-public:
-    static CoreSubsystem&amp; getSingleton(void);
-    
-    void loadMap(const Ogre::String&amp; type, const Ogre::String&amp; filename,
-		const Ogre::String&amp; resourceGroup, const Ogre::String&amp; startupScript = &quot;&quot;);
-	void registerModule(ContentModule* module);
-    World* getWorld();
-    unsigned long getClock();
-    void makeScreenshot(const Ogre::String&amp; sName);
-    bool isInitialized() const;
-    void setScheme(const Ogre::String&amp; schemeName);
-};
-
-class Sound 
-{
-private:
-	Sound(const SoundResourcePtr&amp; res);
-public:
-	virtual ~Sound();
-    
-    /// Name zur&#252;ckgeben
-    const Ogre::String&amp; getName() const;
-
-    /// Gibt die eingestellte Position der Soundquelle zurueck
-    const Ogre::Vector3 getPosition() const;
-    /// Setzt die Position der Soundquelle.
-    void setPosition(const Ogre::Vector3&amp; direction);
-    /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck
-    const Ogre::Real getVolume() const; 
-    /// Setzt die relative Lautstaerke der Soundquelle.
-    void setVolume(const Ogre::Real gain);
-    /// Gibt die Richtung der Soundquelle zurueck.
-    const Ogre::Quaternion getDirection() const;
-    /// Gibt die Geschwindigkeit der Soundquelle zurueck.
-    const Ogre::Vector3 getVelocity() const;
-    /// Setzt die Richtung der Soundquelle.
-    void setDirection(const Ogre::Quaternion&amp;);
-    /// Setzt die Geschwindigkeit der Soundquelle.
-    void setVelocity(const Ogre::Vector3&amp;);
-    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
-	void setRolloffStartDistance(const Ogre::Real dist);
-	const Ogre::Real getRolloffStartDistance() const;
-	/// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
-	void setRolloffEndDistance(const Ogre::Real dist);
-	const Ogre::Real getRolloffEndDistance() const;
-
-    /// Spielt den Sound ab.
-    void play() ;
-    /// Pausiert den Sound.
-    void pause(bool pausing) ;
-    /// Ist der Sound pausiert?
-    bool isPaused() ;
-    /// Stoppt den Sound.
-    void stop() ;
-    /// Laeuft der Sound noch
-    const bool isPlaying() const ;
-
-    /// Gibt zur&#252;ck ob der Sound geloopt werden soll 
-    bool isLooping() const;
-    /// Setzt ob der Sound geloopt werden soll 
-    void setLooping( bool looping );
-    
-    // Sind wir gueltig
-    bool isValid() const;
-};
-
-// define as empty at this time. Must not yet be used from within ruby.
-class Job
-{
-private:
-	Job();
-};
-
-class PlaySound2dJob : public rl::Job
-{
-public:
-
-    PlaySound2dJob(const Ogre::String&amp; sound, Ogre::Real volume=1.0f);
-    virtual ~PlaySound2dJob();
-};
-
-class PlaySound3dJob : public rl::Job
-{
-public:
-
-    PlaySound3dJob(const Ogre::String&amp; sound, const Ogre::Vector3&amp; pos, Ogre::Real volume=1.0f);
-    virtual ~PlaySound3dJob();
-};
-
-class PlayAnimationJob : public Job
-{
-public:
-
-    PlayAnimationJob(Actor* actor, const Ogre::String&amp; anim, bool doLoop=false,
-		bool replaceAllAnims=true);
-    virtual ~PlayAnimationJob();
-};
-
-class JobScheduler
-{
-public:
-    typedef enum {JP_LOW = 10, JP_NORMAL = 20, JP_HIGH = 30} JobPriority;
-	static JobScheduler&amp; getSingleton(void);
-    unsigned long addJob(rl::Job* job,
-		rl::JobScheduler::JobPriority priority = JobScheduler::JP_NORMAL,
-		Ogre::Real delay=0.0f);
-};
-
-}

Added: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlCore.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,759 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+namespace rl {
+%{
+static swig_type_info *GameAreaType_dynamic_cast(void **ptr) {
+    rl::GameAreaType **ppGameAreaType = reinterpret_cast&lt;rl::GameAreaType **&gt;(ptr);
+    
+    rl::GameSphereAreaType *pGameSphereAreaType = dynamic_cast&lt;rl::GameSphereAreaType*&gt;(*ppGameAreaType);
+    if(pGameSphereAreaType){
+      *ptr=reinterpret_cast&lt;void*&gt;(pGameSphereAreaType);
+      return SWIGTYPE_p_rl__GameSphereAreaType;
+    }    
+    
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__GameAreaType, GameAreaType_dynamic_cast);
+
+
+
+%{
+static swig_type_info *BaseAnimation_dynamic_cast(void **ptr) {
+    rl::BaseAnimation **ppBaseAnimation = reinterpret_cast&lt;rl::BaseAnimation **&gt;(ptr);
+    
+    rl::FadeAnimation *pFadeAnimation = dynamic_cast&lt;rl::FadeAnimation*&gt;(*ppBaseAnimation);
+    if(pFadeAnimation){
+      *ptr=reinterpret_cast&lt;void*&gt;(pFadeAnimation);
+      return SWIGTYPE_p_rl__FadeAnimation;
+    }    
+    rl::MeshAnimation *pMeshAnimation = dynamic_cast&lt;rl::MeshAnimation*&gt;(*ppBaseAnimation);
+    if(pMeshAnimation){
+      *ptr=reinterpret_cast&lt;void*&gt;(pMeshAnimation);
+      return SWIGTYPE_p_rl__MeshAnimation;
+    }    
+    rl::TrackAnimation *pTrackAnimation = dynamic_cast&lt;rl::TrackAnimation*&gt;(*ppBaseAnimation);
+    if(pTrackAnimation){
+      *ptr=reinterpret_cast&lt;void*&gt;(pTrackAnimation);
+      return SWIGTYPE_p_rl__TrackAnimation;
+    }  
+    
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__BaseAnimation, BaseAnimation_dynamic_cast);
+
+
+%{
+static swig_type_info *ActorControlledObject_dynamic_cast(void **ptr)
+{
+    rl::ActorControlledObject **ppActorControlledObject =
+        reinterpret_cast&lt;rl::ActorControlledObject**&gt;(ptr);
+
+    rl::MeshObject *pMeshObject=dynamic_cast&lt;rl::MeshObject*&gt;(*ppActorControlledObject);
+    if (pMeshObject) {
+        *ptr=reinterpret_cast&lt;void*&gt;(pMeshObject);
+        return SWIGTYPE_p_rl__MeshObject;
+    }
+    rl::CameraObject *pCameraObject=dynamic_cast&lt;rl::CameraObject*&gt;(*ppActorControlledObject);
+    if (pCameraObject) {
+        *ptr=reinterpret_cast&lt;void*&gt;(pCameraObject);
+        return SWIGTYPE_p_rl__CameraObject;
+    }
+    rl::LightObject *pLightObject=dynamic_cast&lt;rl::LightObject*&gt;(*ppActorControlledObject);
+    if (pLightObject) {
+        *ptr=reinterpret_cast&lt;void*&gt;(pLightObject);
+        return SWIGTYPE_p_rl__LightObject;
+    }
+    rl::ParticleSystemObject *pParticleSystemObject=dynamic_cast&lt;rl::ParticleSystemObject*&gt;(*ppActorControlledObject);
+    if (pParticleSystemObject) {
+        *ptr=reinterpret_cast&lt;void*&gt;(pParticleSystemObject);
+        return SWIGTYPE_p_rl__ParticleSystemObject;
+    }
+    rl::SoundObject *pSoundObject=dynamic_cast&lt;rl::SoundObject*&gt;(*ppActorControlledObject);
+    if (pSoundObject) {
+        *ptr=reinterpret_cast&lt;void*&gt;(pSoundObject);
+        return SWIGTYPE_p_rl__SoundObject;
+    }
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__ActorControlledObject, ActorControlledObject_dynamic_cast);
+
+
+class ActorManager {
+private:
+	ActorManager();
+public:
+	static ActorManager&amp; getSingleton(void);
+
+	rl::Actor* createParticleSystemActor(const Ogre::String&amp; name, const Ogre::String&amp; soundfile);
+    rl::Actor* createSoundStreamActor(const Ogre::String&amp; name, const Ogre::String&amp; soundfile);
+    rl::Actor* createSoundSampleActor(const Ogre::String&amp; name, const Ogre::String&amp; soundfile);
+    rl::Actor* createEmptyActor(const Ogre::String&amp; name);
+    rl::Actor* createLightActor(const Ogre::String&amp; name, rl::LightObject::LightTypes type );
+	rl::Actor* createMeshActor(const Ogre::String&amp; name, const Ogre::String&amp; meshname,
+		    rl::PhysicsManager::GeometryType geom = rl::PhysicsManager::GT_NONE,
+		    Ogre::Real density=1.0);
+	rl::Actor* createBoxPrimitiveActor(const Ogre::String&amp; name,
+            const Ogre::Vector3&amp; minCorner, const Ogre::Vector3&amp; maxCorner,
+            const Ogre::String&amp; materialName = &quot;&quot;, Ogre::Real mass = 0.0);
+		    
+	//void createDebugActors();
+	    
+	rl::Actor* getActor(const Ogre::String&amp; name);
+	void destroyActor(rl::Actor* actor);
+    void destroyAllActors();
+};
+
+class World {
+public:	
+	enum FogMode { FOG_NONE, FOG_EXP, FOG_EXP2, FOG_LINEAR  };
+
+	void loadScene(const Ogre::String&amp; levelName, const Ogre::String&amp; resourceGroup ) = 0;
+
+    virtual void setSkyBox (bool enable, const Ogre::String&amp; materialName, Ogre::Real distance=2500, bool drawFirst=true );
+    virtual void setSkyDome (bool enable, const Ogre::String&amp; materialName, Ogre::Real curvature=10, Ogre::Real tiling=8, Ogre::Real distance=4000, bool drawFirst=true );
+    virtual void setFog ( FogMode mode=FOG_NONE, const Ogre::ColourValue &amp;colour=Ogre::ColourValue::White, Ogre::Real expDensity=0.001, Ogre::Real linearStart=0.0, Ogre::Real linearEnd=1.0);
+    virtual FogMode getFogMode (void) const;
+    virtual const Ogre::ColourValue &amp; getFogColour (void) const;
+    virtual Ogre::Real getFogStart (void) const;
+    virtual Ogre::Real getFogEnd (void) const;	
+    virtual void setAmbientLight(Ogre::Real r, Ogre::Real g, Ogre::Real b);
+    virtual Ogre::Vector3 getStartPoint() const;
+    virtual void setCastShadows(bool);
+
+    void setShowBoundingBoxes( bool dis );
+};
+
+/// Alles was mit AreaKrams zu tun hat
+%apply SWIGTYPE *DYNAMIC { GameAreaType * };
+
+%feature(&quot;director&quot;) GameAreaListener; 
+class GameAreaListener
+{
+public:
+	virtual ~GameAreaListener();
+    virtual void areaLeft(rl::GameAreaEvent *anEvent) const = 0;
+    virtual void areaEntered(rl::GameAreaEvent *anEvent) const = 0;
+};
+
+class GameAreaType
+{
+private:
+	GameAreaType();
+public:
+	unsigned long getQueryMask() const;
+    void setQueryMask( unsigned long mask );
+    void addQueryFlag( unsigned long flag  );
+    void removeQueryFlag( unsigned long flag );
+    const Ogre::Vector3&amp; getQueryPosition() const;
+};
+
+class GameSphereAreaType : public GameAreaType
+{
+private:
+	GameSphereAreaType( Ogre::Vector3, Ogre::Real, unsigned long mask = 0xFFFFFFFF );
+public:
+};
+
+class GameAreaEventSource
+{
+private: 
+	GameAreaEventSource( rl::GameAreaType* areaType, rl::Actor* act );
+public:   
+    void addAreaListener( rl::GameAreaListener*  list );
+    void removeAreaListener( rl::GameAreaListener* list );
+    bool hasListeners( ) const;
+
+    rl::GameAreaType* getGameAreaType() const;
+    // const ActorMap&amp; getInsideAreaList() const;
+    rl::Actor* getActor() const;
+};
+
+class GameAreaEvent
+{
+private:
+	GameAreaEvent( rl::GameAreaEventSource* src, const unsigned int reason );
+public:
+    rl::Actor* getProvokingActor() const;
+    rl::GameAreaEventSource* getSource() const;
+};
+
+class GameEventManager
+{
+private:
+    GameEventManager( );
+public:
+    void addSphereAreaListener( rl::Actor* actor, Ogre::Real radius, 
+		rl::GameAreaListener* list, unsigned long queryMask = 0xFFFFFFFF );
+    void removeAreaListener( rl::GameAreaListener* list );
+    void removeAllAreas( rl::Actor* actor );
+
+    static rl::GameEventManager &amp; getSingleton(void);
+};
+
+/// Alles was mit Animationen zu tun hat
+%apply SWIGTYPE *DYNAMIC { BaseAnimation * };
+
+%feature(&quot;director&quot;) AnimationListener; 
+class AnimationListener
+{
+public:
+	virtual ~AnimationListener();
+
+	virtual void animationFinished(rl::AnimationEvent *anEvent) const = 0;
+	virtual void animationPaused(rl::AnimationEvent *anEvent) const = 0;
+	virtual void animationUnpaused(rl::AnimationEvent *anEvent) const = 0;
+};
+
+%feature(&quot;director&quot;) AnimationFrameListener; 
+class AnimationFrameListener
+{
+public:
+	virtual ~AnimationFrameListener();
+
+	virtual void animationFrameReached( rl::AnimationFrameEvent *anEvent ) const = 0;
+};
+
+class AnimationEvent
+{
+public:
+	rl::BaseAnimation* getAnimation() const;
+private:
+	AnimationEvent( rl::BaseAnimation* anim,  const unsigned int reason );
+};
+
+class AnimationFrameEvent
+{
+public:
+	rl::BaseAnimation* getAnimation() const;
+	Ogre::Real getFrameNumber() const;
+private:
+	AnimationFrameEvent( rl::BaseAnimation* anim,  const unsigned int reason, Ogre::Real frameNumber );
+};
+
+
+class BaseAnimation {
+public:
+	bool isPaused() const;
+    void setPaused( bool isPaused );
+
+	bool isIgnoringGlobalSpeed() const;
+	void setIgnoringGlobalSpeed( bool isIgnoringGlobalSpeed );
+
+	Ogre::Real getSpeed() const;
+	void setSpeed( Ogre::Real speed );
+	void reverseAnimation();
+
+	void setTimesToPlay(unsigned int timesToPlay);
+	unsigned int getTimesPlayed() const;
+	void resetTimesPlayed();
+	unsigned int getTimesToPlay() const;
+	unsigned int getTimesToPlayLeft() const;
+	Ogre::Real getTimePlayed() const;
+
+	Ogre::Real getDelay(void) const;
+    void setDelay(Ogre::Real delay);
+    
+    void addAnimationListener( rl::AnimationListener *listener);
+	void removeAnimationListener( rl::AnimationListener *listener);
+	
+	void addAnimationFrameListener( rl::AnimationFrameListener *listener, 
+									float frameNumber );
+	void removeAnimationFrameListener( rl::AnimationFrameListener *listener );
+	void removeAnimationFrameListener( rl::AnimationFrameListener *listener, Ogre::Real frameNumber );
+private:
+	BaseAnimation(  );
+};
+
+class FadeAnimation : public BaseAnimation {
+private:
+	FadeAnimation(  ); 
+public:
+	bool isDeleteOnFinish() const;
+	void setDeleteOnFinish( bool deleteOnFinish );
+};
+
+class MeshAnimation : public BaseAnimation {
+public:
+    rl::MeshObject* getMeshObject( );
+    
+	Ogre::Real getWeight(void) const;
+    void setWeight(Ogre::Real weight);
+private:
+	MeshAnimation(  ); 
+};
+
+class TrackAnimation : public BaseAnimation {
+public:
+	void addKeyFrame( Ogre::Real timePos );
+    void setKeyFrameTranslation( Ogre::Real timePos, Ogre::Real xPos, Ogre::Real yPos, Ogre::Real zPos );
+    void setKeyFrameRotation( Ogre::Real timePos, Ogre::Real xRotAxis, Ogre::Real yRotAxis, Ogre::Real zRotAxis, Ogre::Real angleUnits );
+    void setKeyFrameRotationQuaternion( Ogre::Real timePos, Ogre::Real w, Ogre::Real x, Ogre::Real y, Ogre::Real z );
+    void setKeyFrameScale( Ogre::Real timePos, Ogre::Real xScale, Ogre::Real yScale, Ogre::Real zScale );
+
+	void setInterpolationMode( rl::AnimationManager::InterpolationMode im );
+	rl::AnimationManager::InterpolationMode getInterpolationMode() const;
+
+	void setRotationInterpolationMode( rl::AnimationManager::RotationInterpolationMode im );
+	rl::AnimationManager::RotationInterpolationMode getRotationInterpolationMode() const;
+
+	void setUseShortestRotationPath ( bool useShortestPath );
+	bool getUseShortestRotationPath () const;
+private:
+	TrackAnimation(  ); 
+};
+
+class AnimationManager {
+private:
+	AnimationManager();
+public:
+	static AnimationManager&amp; getSingleton(void);
+	
+	enum InterpolationMode { IM_LINEAR, IM_SPLINE };
+	enum RotationInterpolationMode { RIM_LINEAR, RIM_SPHERICAL };
+	
+	rl::TrackAnimation* createTrackAnimation(rl::Actor* actor, const Ogre::String&amp; name, Ogre::Real length );
+	void removeAnimation( rl::MeshAnimation* anim );
+    void removeAnimation( rl::TrackAnimation* anim );
+    void removeAnimation( rl::FadeAnimation* anim );
+	void removeTrackAnimation( rl::Actor* act, const Ogre::String&amp; name );
+	void removeAllTrackAnimations( rl::Actor* act );
+	
+	void setGlobalAnimationSpeed( Ogre::Real speed );
+	Ogre::Real getGlobalAnimationSpeed( ) const;
+
+    rl::FadeAnimation* fadeAnimation( rl::MeshAnimation* from, rl::MeshAnimation* to, Ogre::Real time );
+    rl::FadeAnimation* fadeAnimation( rl::MeshAnimation* fromLoop, rl::MeshAnimation* blendAnim, 
+        rl::MeshAnimation* toLoop, Ogre::Real loopDuration = 0.0);
+	
+	void setDefaultInterpolationMode( rl::AnimationManager::InterpolationMode im );
+	rl::AnimationManager::InterpolationMode getDefaultInterpolationMode() const;
+
+	void setDefaultRotationInterpolationMode( rl::AnimationManager::RotationInterpolationMode rim );
+	rl::AnimationManager::RotationInterpolationMode getDefaultRotationInterpolationMode() const;
+};
+
+%apply SWIGTYPE *DYNAMIC { ActorControlledObject * };
+class ActorControlledObject {
+private:
+    ActorControlledObject();
+public:
+    rl::Actor* getActor();
+};
+
+class PhysicalObject : public ActorControlledObject
+{
+};
+
+class MeshObject : public PhysicalObject
+{
+private:
+    MeshObject(const Ogre::String&amp; name, const Ogre::String&amp; meshname);
+public:
+    
+    /// Groesse der Boundingbox
+    Ogre::AxisAlignedBox getDefaultSize() const;
+        
+	rl::BaseAnimation* getAnimation(const Ogre::String&amp; animName);
+	rl::BaseAnimation* replaceAnimation(const Ogre::String&amp; oldAnimName, 
+	    const Ogre::String&amp; newAnimName, float speed=1.0, unsigned int timesToPlay=0);
+	rl::BaseAnimation* startAnimation(const Ogre::String&amp; animName, 
+		float speed=1.0, unsigned int timesToPlay=0);
+    void stopAnimation(const Ogre::String&amp;);
+    void stopAllAnimations();
+    
+    void setCastShadows (bool enabled);
+    bool getCastShadows (void) const;    
+};
+
+class LightObject : public ActorControlledObject
+{
+private:
+    LightObject(const Ogre::String&amp; name, rl::LightObject::LightTypes type);
+public:
+	enum LightTypes { LT_POINT, LT_DIRECTIONAL, LT_SPOTLIGHT };
+
+    void setAttenuation(float range, float constant,
+        float linear, float quadric);
+    void setDiffuseColour(float red, float green, float blue);
+    void setDirection(float x, float y, float z);
+    void setSpecularColour(float red, float green, float blue);
+    void setSpotlightRange(float innerangle, float outerangle,
+        float falloff);
+    void setCastShadows( bool cast );
+};
+
+
+class SoundObject : public ActorControlledObject
+{
+public:
+	void play( );
+
+	void load();
+	void unload();
+	bool is3d() const;
+	void set3d( bool is3d );
+
+    /// Gibt zur&#252;ck ob der Sound geloopt werden soll 
+    bool isLooping() const;
+    /// Setzt ob der Sound geloopt werden soll 
+    void setLooping( bool looping );
+    /// Pausiert den Sound.
+    void pause(bool pausing);
+    /// Ist der Sound pausiert?
+    bool isPaused();
+    /// Stoppt den Sound.
+    void stop();
+	/// Setzt die Lautstaerke (1.0 = volle Lautst&#228;rke)
+	void setVolume(float volume = 1.0);
+	
+	rl::Sound* getSound();
+};
+
+class ParticleSystemObject : public ActorControlledObject
+{
+public:
+     void setActive(bool active);
+private:
+	 ParticleSystemObject(const Ogre::String&amp; name, const Ogre::String&amp; partSys );
+};
+
+class CameraObject : public PhysicalObject
+{
+private:
+    CameraObject(const Ogre::String&amp; name);
+public:
+};
+
+class Actor {
+private:
+	Actor(const Ogre::String&amp; name);
+public:	
+	static const Ogre::String DEFAULT_SLOT_NAME;
+
+    enum QueryGroupFlags
+    {
+        QGF_NONE = 0,
+        QGF_DEFAULT = 1,
+        QGF_PLAYER = 2,
+        QGF_ALL = 0xFFFFFFFF
+    };
+
+	const const Ogre::String&amp; getName() const;
+	const Ogre::Vector3&amp; getPosition(void);
+	const Ogre::Quaternion&amp; getOrientation(void);
+	const Ogre::Vector3&amp; getWorldPosition(void);
+	const Ogre::Quaternion&amp; getWorldOrientation(void);
+
+    void setPosition(Ogre::Real x, Ogre::Real y, Ogre::Real z);
+    void setPosition( const Ogre::Vector3&amp; );
+    void setOrientation( const Ogre::Quaternion&amp; );
+    
+    rl::ActorControlledObject* getControlledObject();
+    Ogre::UserDefinedObject* getGameObject() const;
+    rl::PhysicalThing* getPhysicalThing() const;
+
+    void setScale( Ogre::Real sx, Ogre::Real sy, Ogre::Real sz );
+    void placeIntoScene(
+            const Ogre::Vector3&amp; position = Ogre::Vector3::ZERO,
+            const Ogre::Quaternion&amp; orientation = Ogre::Quaternion::IDENTITY,
+            const Ogre::String&amp; physicsBone = &quot;&quot;);  
+    void placeIntoScene(
+        Ogre::Real px, Ogre::Real py, Ogre::Real pz,
+        Ogre::Real ow, Ogre::Real ox, Ogre::Real oy, Ogre::Real oz, 
+        const Ogre::String&amp; physicsBone = &quot;&quot;);
+    void removeFromScene();
+           
+    void attach( 
+            Actor* actor,
+            const Ogre::String&amp; childSlot = &quot;SLOT_DEFAULT&quot;,
+            const Ogre::Vector3&amp; offsetPosition=Ogre::Vector3::ZERO,
+            const Ogre::Quaternion&amp; offsetOrientation=Ogre::Quaternion::IDENTITY
+            );
+   	void attachAxisRot( 
+            rl::Actor* actor,
+            const Ogre::String&amp; childSlot = &quot;SLOT_DEFAULT&quot;,            
+            const Ogre::Vector3&amp; offsetPosition=Ogre::Vector3::ZERO,
+            const Ogre::Vector3&amp; offsetAxis=Ogre::Vector3::UNIT_X,
+            const Ogre::Radian&amp; offsetRotation=Ogre::Radian(0) );
+    void attachToSlot( 
+            Actor* actor,
+            const Ogre::String&amp; slot,
+            const Ogre::String&amp; childSlot = &quot;SLOT_DEFAULT&quot;,
+            const Ogre::Vector3&amp; offsetPosition=Ogre::Vector3::ZERO,
+			const Ogre::Quaternion&amp; offsetOrientation=Ogre::Quaternion::IDENTITY
+			);
+    void attachToSlotAxisRot( 
+            rl::Actor* actor,
+            const Ogre::String&amp; slot,
+            const Ogre::String&amp; childSlot = &quot;SLOT_DEFAULT&quot;,            
+			const Ogre::Vector3&amp; offsetPosition=Ogre::Vector3::ZERO,
+            const Ogre::Vector3&amp; offsetAxis=Ogre::Vector3::UNIT_X,
+            const Ogre::Radian&amp; offsetRotation=Ogre::Radian(0) );
+                    
+    void detach(rl::Actor* actor);
+    
+    rl::Actor* getChildByName(const Ogre::String&amp; name ) const;
+    
+    void setVisible( bool vis, bool cascade = true );
+	bool isVisible() const;
+       
+	void roll(Ogre::Real angleunits);
+	void pitch(Ogre::Real angleunits);
+	void yaw(Ogre::Real angleunits);
+	
+	unsigned long getQueryMask() const;
+    void setQueryMask( unsigned long mask = 0xFFFFFFFF );
+    void addQueryFlag( unsigned long flag  );
+    void removeQueryFlag( unsigned long flag );
+    void setListenerOf (Ogre::SceneNode *node);
+    Ogre::Bone *_getBone() const;
+    Ogre::SceneNode* _getSceneNode() const;
+    
+};
+
+%feature(&quot;director&quot;) PhysicsContactListener; 
+class PhysicsContactListener
+{
+public:
+    PhysicsContactListener();
+    virtual ~PhysicsContactListener();
+    
+    virtual void contactOccured(rl::Actor* actor1, rl::Actor* actor2) = 0;
+};
+
+class PhysicalThing
+{
+public:
+    PhysicalThing(
+			rl::PhysicsManager::GeometryType geomType,
+			rl::PhysicalObject* po, 
+			Ogre::Real mass, 
+			bool hullModifier = false);
+
+    void setPosition(Ogre::Real x, Ogre::Real y, Ogre::Real z);
+    void setOrientation(Ogre::Real w, Ogre::Real x, Ogre::Real y, Ogre::Real z);
+    
+    void setVelocity(const Ogre::Vector3&amp; vel);
+
+    // Sets the vector, that will always point up.
+    void setUpConstraint(const Ogre::Vector3&amp; upVector = Ogre::Vector3::UNIT_Y);
+    Ogre::Vector3 getUpConstraint() const;
+    void clearUpConstraint();
+
+    rl::Actor* getActor() const;
+
+    void addForce(const Ogre::Vector3&amp; force);
+
+    void freeze();
+    void unfreeze();
+        
+    void setGravityOverride(bool override,
+        Ogre::Real x = 0.0f, Ogre::Real y = 0.0f, Ogre::Real z = 0.0f);
+        
+    Ogre::Real getMass() const;
+    void setMass(Ogre::Real mass);
+    
+    void updateCollisionHull();
+
+    void setContactListener(rl::PhysicsContactListener* listener);
+    rl::PhysicsContactListener* getContactListener() const;
+
+    void fitToPose(const Ogre::String&amp; name);
+
+};
+
+class PhysicsManager
+{
+public:
+
+    enum GeometryType {
+        GT_NONE = -1,
+        GT_BOX = 0,
+        GT_SPHERE = 1,
+        GT_CAPSULE = 2,
+        GT_MESH = 3,
+        GT_ELLIPSOID = 4,
+        GT_CONVEXHULL = 5
+    };
+    
+    PhysicsManager();
+	static PhysicsManager&amp; getSingleton(void);
+    
+    rl::PhysicalThing* createPhysicalThing(rl::PhysicsManager::GeometryType geomType, rl::PhysicalObject* po,
+		Ogre::Real mass);
+
+    void removeAndDestroyPhysicalThing(PhysicalThing* thing);
+
+    // Global Settings
+    void setGravity(Ogre::Real x, Ogre::Real y, Ogre::Real z);
+    Ogre::Vector3 getGravity() const;
+
+    bool isEnabled() const;
+    void setEnabled(bool enabled);
+	
+	void toggleDebugMode();
+    bool isDebugMode() const;
+};
+
+class DebugVisualsManager
+{
+public:
+    DebugVisualsManager();
+    static DebugVisualsManager&amp; getSingleton(void);
+
+    void show(unsigned long flags);
+    void hide(unsigned long flags);
+    void showAll();
+    void hideAll();
+    void toggleAll();
+};
+    
+%feature(&quot;director&quot;) ContentModule; 
+class ContentModule
+{
+public:
+	ContentModule(
+		const Ogre::String&amp; id, 
+		const rl::CeGuiString&amp; name, 
+		bool common, 
+		long minimumEngineVersion);
+		
+	virtual ~ContentModule();
+		
+	virtual const Ogre::StringVector&amp; getDependencies() const = 0;
+	virtual const Ogre::StringVector&amp; getTextureLocations() const = 0;
+	virtual const Ogre::StringVector&amp; getSoundLocations() const = 0;
+	virtual const Ogre::StringVector&amp; getModelLocations() const = 0;
+
+	virtual void start() = 0;
+};
+
+class CoreSubsystem {
+private:
+	CoreSubsystem();
+public:
+    static CoreSubsystem&amp; getSingleton(void);
+    
+    void loadMap(const Ogre::String&amp; type, const Ogre::String&amp; filename,
+		const Ogre::String&amp; resourceGroup, const Ogre::String&amp; startupScript = &quot;&quot;);
+	void registerModule(ContentModule* module);
+    World* getWorld();
+    unsigned long getClock();
+    void makeScreenshot(const Ogre::String&amp; sName);
+    bool isInitialized() const;
+    void setScheme(const Ogre::String&amp; schemeName);
+};
+
+class Sound 
+{
+private:
+	Sound(const SoundResourcePtr&amp; res);
+public:
+	virtual ~Sound();
+    
+    /// Name zur&#252;ckgeben
+    const Ogre::String&amp; getName() const;
+
+    /// Gibt die eingestellte Position der Soundquelle zurueck
+    const Ogre::Vector3 getPosition() const;
+    /// Setzt die Position der Soundquelle.
+    void setPosition(const Ogre::Vector3&amp; direction);
+    /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck
+    const Ogre::Real getVolume() const; 
+    /// Setzt die relative Lautstaerke der Soundquelle.
+    void setVolume(const Ogre::Real gain);
+    /// Gibt die Richtung der Soundquelle zurueck.
+    const Ogre::Quaternion getDirection() const;
+    /// Gibt die Geschwindigkeit der Soundquelle zurueck.
+    const Ogre::Vector3 getVelocity() const;
+    /// Setzt die Richtung der Soundquelle.
+    void setDirection(const Ogre::Quaternion&amp;);
+    /// Setzt die Geschwindigkeit der Soundquelle.
+    void setVelocity(const Ogre::Vector3&amp;);
+    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
+	void setRolloffStartDistance(const Ogre::Real dist);
+	const Ogre::Real getRolloffStartDistance() const;
+	/// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
+	void setRolloffEndDistance(const Ogre::Real dist);
+	const Ogre::Real getRolloffEndDistance() const;
+
+    /// Spielt den Sound ab.
+    void play() ;
+    /// Pausiert den Sound.
+    void pause(bool pausing) ;
+    /// Ist der Sound pausiert?
+    bool isPaused() ;
+    /// Stoppt den Sound.
+    void stop() ;
+    /// Laeuft der Sound noch
+    const bool isPlaying() const ;
+
+    /// Gibt zur&#252;ck ob der Sound geloopt werden soll 
+    bool isLooping() const;
+    /// Setzt ob der Sound geloopt werden soll 
+    void setLooping( bool looping );
+    
+    // Sind wir gueltig
+    bool isValid() const;
+};
+
+// define as empty at this time. Must not yet be used from within ruby.
+class Job
+{
+private:
+	Job();
+};
+
+class PlaySound2dJob : public rl::Job
+{
+public:
+
+    PlaySound2dJob(const Ogre::String&amp; sound, Ogre::Real volume=1.0f);
+    virtual ~PlaySound2dJob();
+};
+
+class PlaySound3dJob : public rl::Job
+{
+public:
+
+    PlaySound3dJob(const Ogre::String&amp; sound, const Ogre::Vector3&amp; pos, Ogre::Real volume=1.0f);
+    virtual ~PlaySound3dJob();
+};
+
+class PlayAnimationJob : public Job
+{
+public:
+
+    PlayAnimationJob(Actor* actor, const Ogre::String&amp; anim, bool doLoop=false,
+		bool replaceAllAnims=true);
+    virtual ~PlayAnimationJob();
+};
+
+class JobScheduler
+{
+public:
+    typedef enum {JP_LOW = 10, JP_NORMAL = 20, JP_HIGH = 30} JobPriority;
+	static JobScheduler&amp; getSingleton(void);
+    unsigned long addJob(rl::Job* job,
+		rl::JobScheduler::JobPriority priority = JobScheduler::JP_NORMAL,
+		Ogre::Real delay=0.0f);
+};
+
+}


Property changes on: rl/trunk/engine/script/swig/RlCore.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/RlDialog.head.inc
===================================================================
--- rl/trunk/engine/script/swig/RlDialog.head.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlDialog.head.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,23 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-%{
-//----------- Includes - Dialog -----------
-#include &quot;FixRubyHeaders.h&quot;
-#include &quot;DialogPrerequisites.h&quot;
-#include &quot;DialogSubsystem.h&quot;
-#include &quot;DialogCharacter.h&quot;
-%}
\ No newline at end of file

Added: rl/trunk/engine/script/swig/RlDialog.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlDialog.head.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlDialog.head.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,23 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+%{
+//----------- Includes - Dialog -----------
+#include &quot;FixRubyHeaders.h&quot;
+#include &quot;DialogPrerequisites.h&quot;
+#include &quot;DialogSubsystem.h&quot;
+#include &quot;DialogCharacter.h&quot;
+%}
\ No newline at end of file


Property changes on: rl/trunk/engine/script/swig/RlDialog.head.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/RlDialog.inc
===================================================================
--- rl/trunk/engine/script/swig/RlDialog.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlDialog.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,51 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-namespace rl 
-{
-	%feature(&quot;director&quot;) DialogCharacter;
-	class DialogCharacter
-	{
-	public:
-		DialogCharacter();
-		virtual ~DialogCharacter();
-
-		const rl::CeGuiString getName() const;
-		rl::Creature* getDialogCharacter() const;
-		void setDialogCharacter(rl::Creature* dialogCharacter);
-		rl::Creature* getDialogPartner() const;
-		void setDialogPartner(rl::Creature* dialogPartner);
-		
-		rl::Creature* getNonPlayerCharacter()const;
-		void setNonPlayerCharacter(rl::Creature* npc);
-		
-		rl::Creature* getPlayerCharacter()const;
-		void setPlayerCharacter(rl::Creature* pc);
-		
-		virtual int calcOptionValue(const rl::CeGuiString&amp; optionName)=0;	
-		virtual int calcResponseValue(const rl::CeGuiString&amp; responseName)=0;
-		virtual int calcSelectionValue(const rl::CeGuiString&amp; selectionName)=0;
-	};
-
-	class DialogSubsystem 
-	{
-	public:
-		static DialogSubsystem&amp; getSingleton(void);
-		rl::DialogCharacter* getBot(const rl::CeGuiString&amp; botName);
-		rl::DialogCharacter* loadBot(const rl::CeGuiString&amp; fileName, const rl::CeGuiString&amp; botName = &quot;&quot;);
-		void setCurrentDialogCharacter(rl::DialogCharacter* bot);
-	};
-}

Added: rl/trunk/engine/script/swig/RlDialog.swig
===================================================================
--- rl/trunk/engine/script/swig/RlDialog.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlDialog.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,51 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+namespace rl 
+{
+	%feature(&quot;director&quot;) DialogCharacter;
+	class DialogCharacter
+	{
+	public:
+		DialogCharacter();
+		virtual ~DialogCharacter();
+
+		const rl::CeGuiString getName() const;
+		rl::Creature* getDialogCharacter() const;
+		void setDialogCharacter(rl::Creature* dialogCharacter);
+		rl::Creature* getDialogPartner() const;
+		void setDialogPartner(rl::Creature* dialogPartner);
+		
+		rl::Creature* getNonPlayerCharacter()const;
+		void setNonPlayerCharacter(rl::Creature* npc);
+		
+		rl::Creature* getPlayerCharacter()const;
+		void setPlayerCharacter(rl::Creature* pc);
+		
+		virtual int calcOptionValue(const rl::CeGuiString&amp; optionName)=0;	
+		virtual int calcResponseValue(const rl::CeGuiString&amp; responseName)=0;
+		virtual int calcSelectionValue(const rl::CeGuiString&amp; selectionName)=0;
+	};
+
+	class DialogSubsystem 
+	{
+	public:
+		static DialogSubsystem&amp; getSingleton(void);
+		rl::DialogCharacter* getBot(const rl::CeGuiString&amp; botName);
+		rl::DialogCharacter* loadBot(const rl::CeGuiString&amp; fileName, const rl::CeGuiString&amp; botName = &quot;&quot;);
+		void setCurrentDialogCharacter(rl::DialogCharacter* bot);
+	};
+}


Property changes on: rl/trunk/engine/script/swig/RlDialog.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/RlRules.head.inc
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlRules.head.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,55 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-%{
-//----------- Includes - Rules -----------
-#include &quot;FixRubyHeaders.h&quot;
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &quot;Action.h&quot;
-#include &quot;ActionManager.h&quot;
-#include &quot;Armor.h&quot;
-#include &quot;CompositeEffect.h&quot;
-#include &quot;Container.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;Date.h&quot;
-#include &quot;DsaManager.h&quot;
-#include &quot;Effect.h&quot;
-#include &quot;EigenschaftenStateSet.h&quot;
-#include &quot;GameObject.h&quot;
-#include &quot;GameObjectManager.h&quot;
-#include &quot;GameObjectProxy.h&quot;
-#include &quot;Inventory.h&quot;
-#include &quot;Item.h&quot;
-#include &quot;ObjectStateChangeEventSource.h&quot;
-#include &quot;ObjectStateChangeEvent.h&quot;
-#include &quot;ObjectStateChangeListener.h&quot;
-#include &quot;Person.h&quot;
-#include &quot;Quest.h&quot;
-#include &quot;QuestBook.h&quot;
-#include &quot;QuestEvent.h&quot;
-#include &quot;QuestListener.h&quot;
-#include &quot;RulesSubsystem.h&quot;
-#include &quot;SonderfertigkeitenStateSet.h&quot;
-#include &quot;StateSet.h&quot;
-#include &quot;Talent.h&quot;
-#include &quot;TalentStateSet.h&quot;
-#include &quot;TimerEventSource.h&quot;
-#include &quot;TimerEvent.h&quot;
-#include &quot;TimerListener.h&quot;
-#include &quot;Tripel.h&quot;
-#include &quot;Weapon.h&quot;
-%}

Added: rl/trunk/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlRules.head.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,55 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+%{
+//----------- Includes - Rules -----------
+#include &quot;FixRubyHeaders.h&quot;
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &quot;Action.h&quot;
+#include &quot;ActionManager.h&quot;
+#include &quot;Armor.h&quot;
+#include &quot;CompositeEffect.h&quot;
+#include &quot;Container.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;Date.h&quot;
+#include &quot;DsaManager.h&quot;
+#include &quot;Effect.h&quot;
+#include &quot;EigenschaftenStateSet.h&quot;
+#include &quot;GameObject.h&quot;
+#include &quot;GameObjectManager.h&quot;
+#include &quot;GameObjectProxy.h&quot;
+#include &quot;Inventory.h&quot;
+#include &quot;Item.h&quot;
+#include &quot;ObjectStateChangeEventSource.h&quot;
+#include &quot;ObjectStateChangeEvent.h&quot;
+#include &quot;ObjectStateChangeListener.h&quot;
+#include &quot;Person.h&quot;
+#include &quot;Quest.h&quot;
+#include &quot;QuestBook.h&quot;
+#include &quot;QuestEvent.h&quot;
+#include &quot;QuestListener.h&quot;
+#include &quot;RulesSubsystem.h&quot;
+#include &quot;SonderfertigkeitenStateSet.h&quot;
+#include &quot;StateSet.h&quot;
+#include &quot;Talent.h&quot;
+#include &quot;TalentStateSet.h&quot;
+#include &quot;TimerEventSource.h&quot;
+#include &quot;TimerEvent.h&quot;
+#include &quot;TimerListener.h&quot;
+#include &quot;Tripel.h&quot;
+#include &quot;Weapon.h&quot;
+%}


Property changes on: rl/trunk/engine/script/swig/RlRules.head.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/RlRules.inc
===================================================================
--- rl/trunk/engine/script/swig/RlRules.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlRules.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,783 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-namespace rl {
-
-	// Before first use of GameObject or subclasses!
-	%apply SWIGTYPE *DYNAMIC { rl::GameObject * };
-					
-   template&lt;typename T&gt;
-   class Tripel {
-   public:
-      T first;
-      T second;
-      T third;
-
-      Tripel();      
-      Tripel(const T&amp; t1, const T&amp; t2, const T&amp; t3);
-      Tripel(const Tripel&amp; rhs);
-
-      //Tripel&amp; operator=(const Tripel&amp; rhs);
-      bool operator==(const Tripel&amp; rhs);
-      bool operator&lt;(const Tripel&amp; rhs);     
-   };
-	
-		class Date {
-    public:
-        static const RL_LONGLONG ONE_SECOND = 1000ULL;
-        static const RL_LONGLONG ONE_MINUTE = 60000ULL;
-        static const RL_LONGLONG ONE_HOUR = 3600000ULL;
-        static const RL_LONGLONG ONE_DAY = 86400000ULL;
-        static const RL_LONGLONG ONE_WEEK = 604800000ULL;
-        static const RL_LONGLONG ONE_MONTH = 2592000000ULL;
-        static const RL_LONGLONG ONE_YEAR = 31536000000ULL;
-        static const RL_LONGLONG ONE_KAMPFRUNDE = 2 * ONE_SECOND;
-        static const RL_LONGLONG ONE_SPIELRUNDE = 5 * ONE_MINUTE;
-
-        Date();
-        Date(RL_LONGLONG timestamp);
-        Date(const Date&amp; rhs);
-      
-        bool operator==(const Date&amp; rhs);
-        bool operator&lt;(const Date&amp; rhs);
-        bool operator&lt;=(const Date&amp; rhs);
-        bool operator&gt;=(const Date&amp; rhs);
-        bool operator&gt;(const Date&amp; rhs);
-
-        Date operator+(const RL_LONGLONG&amp; rhs);
-        Date operator-(const RL_LONGLONG&amp; rhs);
-        RL_LONGLONG operator-(const Date&amp; rhs);
-      
-        RL_LONGLONG getTimestamp();
-
-        int getTimeFraction();
-        int getYear();
-        int getMonth();
-        rl::CeGuiString getMonthName();
-        int getDayOfYear();
-        int getDayOfMonth();
-        int getDayOfWeek();
-        rl::CeGuiString getDayOfWeekName();
-        int getHour();
-        int getMinute();
-        int getSecond();
-        int getMilliSecond();
-      
-        rl::CeGuiString toString();
-    };
-   
-    Date operator+(const RL_LONGLONG&amp;, const Date&amp;);
-    Date operator-(const RL_LONGLONG&amp;, const Date&amp;);
-
-	class RulesSubsystem 
-    {
-		public:
- 			static rl::RulesSubsystem&amp; getSingleton();
- 			rl::QuestBook* getQuestBook();
- 			void resetQuestBook();
-    };
-  
-    class DsaManager {
-    public:
-        RL_LONGLONG getTimestamp();
-        Date getCurrentDate();
-		void setTimestamp(const RL_LONGLONG time);
-		void setCurrentDate(const Date&amp; date);
-		
-        int rollD20();
-        Tripel&lt;int&gt; roll3D20();
-        int rollD6();
-        int roll(int d6, int d20);
-      
-	    static DsaManager&amp; getSingleton();
-	    rl::Talent* getTalent(const rl::CeGuiString name) const;
-	    rl::Person* getPerson(const int id) const;
-    };
-    
-    class GameObjectProxy
-    {
-    private:
-        GameObjectProxy(const Ogre::String&amp; classid, unsigned int id);
-        
-    public:       
-        rl::GameObject* getGameObject();
-
-        unsigned int getId() const;
-        const Ogre::String&amp; getClassId() const;
-        
-        void load();
-        void unload();
-    };
-    
-    %feature(&quot;director&quot;) GameObjectFactory; 
-    class GameObjectFactory
-    {
-    public:
-        virtual rl::GameObject* createRubyGameObject(const Ogre::String&amp; classname, unsigned int id) = 0;
-        GameObjectFactory();
-        virtual ~GameObjectFactory();
-    };
-
-    class GameObjectManager
-    {
-    public:
-        static rl::GameObjectManager&amp; getSingleton();
-        rl::GameObjectProxy&amp; createGameObjectProxy(const Ogre::String&amp; classId, unsigned int id = 0);
-        rl::GameObjectProxy* getGameObjectProxy(unsigned int id) const;
-        void setGameObjectFactory(rl::GameObjectFactory* gof);
-
-    private:
-        GameObjectManager();
-    };
-
-
-	%feature(&quot;director&quot;) QuestListener; 
-	class QuestListener
-	{
-	public:
-		virtual ~QuestListener();
-		
-		virtual void questStateChanged(rl::QuestEvent* anEvent) = 0;
-		virtual void questPartsDoneChanged(rl::QuestEvent* anEvent) = 0;
-		virtual void questKnownChanged(rl::QuestEvent* anEvent) = 0;
-		virtual void questSubquestAdded(rl::QuestEvent* anEvent) = 0;
-		virtual void journalEntryAdded(rl::JournalEvent* anEvent) = 0;
-	};
-
-    class JournalEntry
-    {
-    public:
-        JournalEntry(const rl::CeGuiString caption, const rl::CeGuiString text);
-        virtual ~JournalEntry();
-
-        rl::CeGuiString getCaption() const;
-
-        rl::CeGuiString getText() const;
-    };
-    
-	class Quest
-	{
-	public:
-		enum State
-		{
-			OPEN = 0,
-			ASSIGNED,
-			FAILED,
-			SUCCEEDED,
-			COMPLETED
-		};
-
-		Quest(const rl::CeGuiString id, const rl::CeGuiString name, const rl::CeGuiString description);
-		virtual ~Quest();
-
-		const rl::CeGuiString getId();
-		const rl::CeGuiString getName();
-		const rl::CeGuiString getDescription();
-		int getPartsToDo();
-		void setPartsToDo(int partsToDo);
-		int getPartsDone();
-		void setPartsDone(int partsDone);
-		void increasePartsDone(int parts = 1);
-		void decreasePartsDone(int parts = 1);
-
-		rl::Quest::State getState();
-		void setState(rl::Quest::State state);
-		bool isKnown();
-		void setKnown(bool known);
-
-		// QuestVector getSubquests();
-		void addSubquest(rl::Quest* quest); 
-	};   
-	
-	class QuestEvent
-	{
-	public:
-		rl::Quest* getQuest();
-	private:
-		QuestEvent( rl::QuestBook* src, int reason );
-	};
-	
-	class QuestBook
-	{
-	public:
-		rl::Quest* getQuest(const rl::CeGuiString id);
-		void addQuest(rl::Quest* quest);
-		
-		void addJournalEntry(rl::JournalEntry* entry);
-		void addJournalEntry(rl::CeGuiString caption, rl::CeGuiString text);
-		
-		void addQuestListener(rl::QuestListener* listener);
-		void removeQuestListener(rl::QuestListener* listener);
-	};
-	
-    class Talent
-    {
-    public:
-        Talent(const rl::CeGuiString name,
-               const rl::CeGuiString description,
-               const Tripel&lt;rl::CeGuiString&gt;&amp; eigenschaften,
-               int ebe,
-			   int gruppe,
-			   const rl::CeGuiString art);
-
-        bool operator==(const Talent&amp; rhs) const;
-        bool operator&lt;(const Talent&amp; rhs) const;
-        rl::CeGuiString getName() const;
-        rl::CeGuiString getDescription() const;
-		int getEbe() const;
-
-        /// Berechnet effektive Behinderung bei gegebener Behinderung;
-        int calculateEbe(int be) const;
-        Tripel&lt;rl::CeGuiString&gt; getEigenschaften() const;
-    };
-
-    class ActionGroup
-	{
-	public:
-		ActionGroup(rl::CeGuiString name, ActionGroup* parent = NULL);
-		~ActionGroup();
-	
-		const rl::CeGuiString getName() const;
-	};
-	
-	%feature(&quot;director&quot;) Action;   
-    class Action
-    {
-    public:
-    	static const int ACT_NORMAL = 1&lt;&lt;0;
-		static const int ACT_INVIS_DESC = 1&lt;&lt;1;
-		static const int ACT_DISABLED = 1&lt;&lt;2;
-		static const int ACT_NEEDS_TALENT = 1&lt;&lt;8;
-
-		static const int TC_NO_TARGET = 0;
-		static const int TC_GAMEOBJECT = 1;
-		static const int TC_CREATURE = 2;
-		static const int TC_ITEM = 3;
-		static const int TC_POINT = 4;
-		static const int TC_RADIUS = 5;
-		static const int TC_POINT_AND_RADIUS = 6;
-    
-        Action(const rl::CeGuiString name, const rl::CeGuiString description);
-        virtual ~Action();
-
-        virtual const rl::CeGuiString getName() const;
-        //virtual const rl::CeGuiString getClassName() const;
-        virtual const rl::CeGuiString getDescription() const;
-        virtual int getTargetClass() const;
-        virtual void doAction(rl::GameObject *object, rl::Creature *actor,
-            rl::GameObject *target);
-        virtual bool canDo(rl::GameObject* object, rl::Creature* actor) const;
-            
-        void setGroup(rl::ActionGroup* group);
-		rl::ActionGroup* getGroup() const;
-    };
-    
-	%feature(&quot;director&quot;) ObjectStateChangeListener; 	 
-	class ObjectStateChangeListener 	 
-	{ 	 
-	public: 	 
-		virtual ~ObjectStateChangeListener(); 	 
-		  	 
-		virtual void objectStateChanged(rl::ObjectStateChangeEvent *anEvent) = 0; 	 
-	};
-		 	 
-		  	 
-	class ObjectStateChangeEventSource 	 
-	{ 	 
-	public: 	 
-		ObjectStateChangeEventSource( ); 	 
-		  	 
-		void addObjectStateChangeListener( rl::ObjectStateChangeListener*  list ); 	 
-		void removeObjectStateChangeListener( rl::ObjectStateChangeListener* list ); 	 
-		bool hasListeners( ) const; 	 
-		rl::GameObject* getObject() const;
-		void fireObjectStateChangeEvent(); 	 
-	}; 	 
-		  	 
-	class ObjectStateChangeEvent 	 
-	{ 	 
-	public: 	 
-		ObjectStateChangeEvent( rl::ObjectStateChangeEventSource* src ); 	 
-		rl::GameObject* getProvokingObject() const; 	 
-		rl::ObjectStateChangeEventSource* getSource() const; 	 
-	};
-		    
-	enum GameObjectState
-    {
-        GOS_UNDEFINED = 0,
-        GOS_UNLOADED,
-        GOS_LOADED,
-        GOS_IN_POSSESSION,
-        GOS_IN_SCENE,
-        GOS_HELD,
-        GOS_READY
-    };
-    
-    %feature(&quot;director&quot;) GameObject;
-    class GameObject: public ObjectStateChangeEventSource
-    {
-    public:
-        GameObject(unsigned int id);
-        virtual ~GameObject();
-
-        virtual unsigned int getId();
-
-        virtual const rl::CeGuiString getName() const;
-        virtual void setName(rl::CeGuiString name);
-
-        const rl::CeGuiString getDescription() const;
-        virtual void setDescription(rl::CeGuiString description);   
-        
-        void setActor(rl::Actor* actor);
-		rl::Actor* getActor();
-
-        void addAction(rl::Action *action, int option = ACT_NORMAL);
-        void addActionInGroup(Action* action, ActionGroup* group, int option = ACT_NORMAL);
-        void removeAction(rl::Action *action);
-
-        const std::vector&lt;Action*&gt; getValidActions(rl::Creature *actor) const;        
-        void setPosition(const Ogre::Vector3&amp; position);
-        void setOrientation(const Ogre::Quaternion&amp; orientation);
-	    const Ogre::Quaternion&amp; getOrientation() const;
-        const Ogre::Vector3&amp; getPosition() const;
-        
-        void setMeshfile(rl::CeGuiString meshfile);
-        
-        virtual Action* getDefaultAction(rl::Creature* actor) const;
-        
-        void doAction(
-			const rl::CeGuiString actionName, 
-			rl::Creature* actor,
-            rl::GameObject* target);
-        void doAction(
-			const rl::CeGuiString actionName);
-        void doAction(rl::Action* action, rl::Creature* actor,
-            rl::GameObject* target);
-            
-        void doDefaultAction(rl::Creature* actor, rl::GameObject* target);
-            
-		static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
-		
-		bool isHighlightingEnabled();
-        void setHighlightingEnabled( bool highlightenabled );
-        
-        virtual const rl::Property getProperty(const Ogre::String&amp; key) const;
-        virtual void setProperty(const Ogre::String&amp; key, const rl::Property&amp; value);
-        
-        void placeIntoScene();
-        void removeFromScene();
-        
-        rl::GameObjectState getState() const;
-        virtual void setState(rl::GameObjectState state);
-    };
-    
-    %feature(&quot;director&quot;) Item;
-    class Item : public rl::GameObject {
-    public:
-        enum ItemType{
-			ITEMTYPE_WEAPON     = 1 &lt;&lt; 0,
-			ITEMTYPE_SHIELD     = 1 &lt;&lt; 1,
-			ITEMTYPE_RING       = 1 &lt;&lt; 2,
-			ITEMTYPE_GLOVES     = 1 &lt;&lt; 3,
-			ITEMTYPE_BRACELET   = 1 &lt;&lt; 4,
-			ITEMTYPE_ARMOR      = 1 &lt;&lt; 5,
-			ITEMTYPE_CAPE       = 1 &lt;&lt; 6,
-			ITEMTYPE_BRACERS    = 1 &lt;&lt; 7,
-			ITEMTYPE_BACKPACK   = 1 &lt;&lt; 8,
-			ITEMTYPE_BELT       = 1 &lt;&lt; 9,
-			ITEMTYPE_NECKLACE   = 1 &lt;&lt; 10,
-			ITEMTYPE_HELMET     = 1 &lt;&lt; 11,
-			ITEMTYPE_TROUSERS   = 1 &lt;&lt; 12,
-			ITEMTYPE_SHINBONE   = 1 &lt;&lt; 13,
-			ITEMTYPE_BOOTS      = 1 &lt;&lt; 14,
-			ITEMTYPE_OTHER      = 1 &lt;&lt; 15,
-            ITEMTYPE_ALL_ITEMS  = ~(0)
-		};
-    
-        Item(unsigned int id);
-        virtual ~Item();
-        
-        void setItemType(rl::Item::ItemType itemType);
-        rl::Item::ItemType getItemType() const;
-        virtual void setState(rl::GameObjectState state);
-
-        virtual const rl::Property getProperty(const Ogre::String&amp; key) const;
-        virtual void setProperty(const Ogre::String&amp; key, const rl::Property&amp; value);
-    };
-    
-    %feature(&quot;director&quot;) Weapon;
-    class Weapon : public rl::Item 
-    {
-    public:
-		enum Distanzklasse { DK_H=0, DK_N, DK_S, DK_P };
-
-        Weapon(unsigned int id);
-        virtual ~Weapon();
-                
-		void setTp(int d6, int d20, int mod);
-		const Tripel&lt;int&gt;&amp; getTp() const;
-		void setTpKk(int base, int step);
-		const pair&lt;int, int&gt;&amp; getTpKk() const;
-		void setBf(int newBf);
-		int getBf();
-		void setIni(int newIni);
-		int getIni();
-		void setWm(pair&lt;int, int&gt;&amp; newWm);
-		const pair&lt;int,int&gt;&amp; getWm() const;
-		void setDk(Weapon::Distanzklasse newDk);
-		Weapon::Distanzklasse getDk();
-		void setKampftechnik(const rl::CeGuiString newKampftechnik);
-		const rl::CeGuiString getKampftechnik() const;
-
-        virtual const rl::Property getProperty(const Ogre::String&amp; key) const;
-        virtual void setProperty(const Ogre::String&amp; key, const rl::Property&amp; value);
-    };
-    
-    %feature(&quot;director&quot;) Armor;
-    class Armor : public Item
-    {
-    public:
-        Armor(unsigned int id);
-        virtual ~Armor();
-
-        virtual const rl::Property getProperty(const Ogre::String&amp; key) const;
-        virtual void setProperty(const Ogre::String&amp; key, const rl::Property&amp; value);
-    };
-    
-    %feature(&quot;director&quot;) Container;
-    class Container : public Item
-    {
-    public:
-        Container(unsigned int id);
-        virtual ~Container();
-
-        Ogre::Real getCapacity() const;
-        void setCapacity(Ogre::Real capacity);
-        void setVolume(unsigned int x, unsigned int y);
-        Ogre::Real getContentWeight() const;
-        void addItem(rl::Item* item);
-        void removeItem(rl::Item* item);
-        rl::ItemSet getItems() const;
-        int getItemCount() const;
-        rl::Item* getItemAt(unsigned int x, unsigned int y);
-
-        virtual const rl::Property getProperty(const Ogre::String&amp; key) const;
-        virtual void setProperty(const Ogre::String&amp; key, const rl::Property&amp; value);
-	};
-	
-	class StateSet
-	{
-	public:
-		StateSet();
-		virtual ~StateSet();
-
-		virtual int getValue(bool getUnmodfiedValue = false) const;
-		virtual int getOriginalValue() const;
-		virtual void setOriginalValue(int newValue);
-		virtual int getModifier() const;
-		virtual void setModifier(int newModifier);
-		virtual void modifyModifier(int modifier);
-		virtual int getProbenModifier() const;
-		virtual void setProbenModifier(int newProbenModifier);
-		virtual void modifyProbenModifier(int modifier);
-		virtual int getMultiplier() const;
-		virtual void setMultiplier(int newMultiplier);
-	};
-
-	class EigenschaftenStateSet : public StateSet
-	{
-	public:
-		EigenschaftenStateSet();
-		~EigenschaftenStateSet();
-
-		int getStartValue();
-		void setStartValue( int newStartValue );
-		int getPermanentModifier();
-		void setPermanentModifier( int newPermanentModifier );
-		int getModifierWithoutRecalculation();
-		void setModifierWithoutRecalculation( int newModifierWithoutRecalculation );
-
-		int getValue( bool getUnmodifiedValue = false );
-		int getValueForBasiswertCalculation();
-	};
-	
-	class SonderfertigkeitenStateSet : public StateSet
-	{
-	public:
-		SonderfertigkeitenStateSet();
-		~SonderfertigkeitenStateSet();
-
-		void setModifier( int newModifier );
-		int getLehrmeisterZeiteinheiten();
-		void setLehrmeisterZeiteinheiten( int newLehrmeisterZeiteinheiten );
-	};
-	
-	class TalentStateSet : public StateSet
-	{
-	public:
-		TalentStateSet();
-		~TalentStateSet();
-
-		bool getSe();
-		void setSe(bool newSe);
-		int getLehrmeisterZeiteinheiten();
-		void setLehrmeisterZeiteinheiten( int newLehrmeisterZeiteinheiten );
-		int getSelbststudiumZeiteinheiten();
-		void setSelbststudiumZeiteinheiten( int newSelbststudiumZeiteinheiten );
-	};
-	
-	%feature(&quot;director&quot;) Effect;
-	class Effect
-	{
-	public:
-        enum Quantifier
-        {
-            QUANTIFIER_MULTIPLE,
-            QUANTIFIER_UNIQUE,
-            QUANTIFIER_UNIQUE_BUT_PROLONGABLE,
-            QUANTIFIER_UNIQUE_BUT_CUMULATIVE
-        };
-
-        enum EffectTag
-        {
-            EFFECTTAG_NONE,
-            EFFECTTAG_KRANKHEIT
-        };
-
-		Effect(int stufe = 1);
-		virtual ~Effect();
-
-        const rl::CeGuiString getName() const;
-        void setName(rl::CeGuiString name);
-        const rl::CeGuiString getDescription() const;
-        void setDescription(rl::CeGuiString description);
-		rl::Creature* getOwner() const;
-		void setOwner(rl::Creature* owner);
-		virtual int getDuration();
-		virtual void setDuration(int newDuration);
-		Quantifier getQuantifier();
-		void setQuantifier(Quantifier quantifier);
-		virtual void addTag(EffectTag tagId);
-		virtual void removeTag(EffectTag tagId);
-		virtual bool queryTag(EffectTag tagId);
-		virtual const int getStufe();
-		virtual void increaseStufe();
-		virtual void decreaseStufe();
-		virtual void enable();
-		virtual void disable();
-		virtual void check() = 0;
-
-	protected:
-		virtual void apply() = 0;
-		virtual void remove() = 0;
-		virtual RL_LONGLONG getTimePassed();
-	};
-	
-	class Inventory 
-	{
-    private:
-        Inventory(rl::Creature* owner);
-	public:
-	    void addSlot(const rl::CeGuiString&amp; name, const Ogre::String&amp; bone, int itemMask);
-	    rl::Item* getItem(const rl::CeGuiString&amp; slotName);
-        void hold(rl::Item* item, const rl::CeGuiString&amp; slot);
-	};
-
-    %feature(&quot;director&quot;) Creature;
-    class Creature : public GameObject {
-    public:
-
-        enum Wert
-        {
-            WERT_MOD_AE = 1, // Astralenergie
-            WERT_MOD_LE, // Lebensenergie
-            WERT_MOD_AT, // Attacke
-            WERT_MOD_PA, // Parade
-            WERT_MOD_FK, // Fernkampf
-            WERT_MOD_AU, // Ausdauer
-            WERT_MOD_MR, // Magieresistenz
-            WERT_MOD_INI, // Initiative
-            WERT_MOD_REGENERATION_LE, // Naechtliche Regeneration. modifier modifiziert den W6, ProbenModifier modifiziert die KO-Probe.
-            WERT_MOD_REGENERATION_AE, // Astrale Regeneration. modifier modifiziert den W6, ProbenModifier modifiziert die IN-Probe.
-            WERT_MOD_ERSCHOEPFUNGSSCHWELLE, // Die Modifkitoren von KO bezueglich der Erschoepfungsschwelle.
-            WERT_MOD_ALL_EIGENSCHAFTSPROBEN, // Modifiziert alle Proben, die mit 1W20 gewuerfelt werden.
-            WERT_MOD_ALL_TALENTPROBEN, // Modifiziert alle Proben, die mit 3W20 gewuerfelt werden.
-            WERT_GS, // Geschwindigkeit
-            WERT_SOZIALSTATUS, // Sozialstatus
-            WERT_BE // Behinderung
-        };
-
-        Creature(unsigned int id);
-        virtual ~Creature();
-
-        virtual int getLe();
-        virtual void modifyLe(int mod, bool ignoreMax);
-        virtual void modifyAe(int mod);
-        virtual void modifyAu(int mod);
-        void setWert(Wert wertId, int value);
-        virtual StateSet* getWertStateSet(Wert wertId);
-        
-        virtual int getEigenschaft(const rl::CeGuiString eigenschaftName);
-        virtual void setEigenschaft(const rl::CeGuiString eigenschaftName, int value);
-        virtual void modifyEigenschaft(const rl::CeGuiString eigenschaftName, int mod);
-		virtual EigenschaftenStateSet* getEigenschaftenStateSet(const rl::CeGuiString eigenschaftName);
-		
-        void addTalent(const rl::CeGuiString talentName, int value=0);
-        virtual int getTalent(const rl::CeGuiString talentName);
-        virtual void setTalent(const rl::CeGuiString talentName, int value);
-        virtual void modifyTalent(const rl::CeGuiString talentName, int mod);
-		virtual void addSe(const rl::CeGuiString talentName);
-		virtual TalentStateSet* getTalentStateSet(const rl::CeGuiString talentName);
-		
-		void addVorteil(const rl::CeGuiString vorteilName, int value = 0);
-		void addNachteil(const rl::CeGuiString nachteilName, int value = 0);		
-		
-        void addKampftechnik(const rl::CeGuiString kampftechnikName, std::pair&lt;int,int&gt; value = make_pair(0,0));
-        
-		virtual SonderfertigkeitenStateSet* getSonderfertigkeitenStateSet(const rl::CeGuiString sfName);
-
-        virtual int doTalentprobe(const rl::CeGuiString talentName, int modifier);
-        virtual int doEigenschaftsprobe(const rl::CeGuiString eigenschaftName, int modifier);
-        
-        rl::Inventory* getInventory();
-        
-		void addEffect(Effect* effect);
-		void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
-        static const int LEDAMAGE_NORMAL = 0;
-        static const int LEDAMAGE_FIRE = 1;
-        static const int LEDAMAGE_WATER = 2;
-        static const int LEDAMAGE_DEMONIC = 4;
-        void damageAu(int aup, int damageType = AUDAMAGE_NORMAL);
-        static const int AUDAMAGE_NORMAL = 0;
-        static const int AUDAMAGE_HEAT = 1;
-        static const int AUDAMAGE_COLD = 2;
-        static const int AUDAMAGE_CHOKE = 4;
-        static const int AUDAMAGE_DROWN = 8;
-
-        virtual const rl::Property getProperty(const Ogre::String&amp; key) const;
-        virtual void setProperty(const Ogre::String&amp; key, const rl::Property&amp; value);
-   };
-   
-   %feature(&quot;director&quot;) Person;
-   class Person : public Creature
-   {
-   public:
-	    Person(unsigned int id);
-
-        virtual const rl::Property getProperty(const Ogre::String&amp; key) const;
-        virtual void setProperty(const Ogre::String&amp; key, const rl::Property&amp; value);
-	};
-		
-	%feature(&quot;director&quot;) CompositeEffect;	
-	class CompositeEffect : public Effect
-	{
-	public:
-		CompositeEffect();
-		virtual ~CompositeEffect();
-
-		void addEffect(Effect* effect);
-		virtual void check();
-	protected:
-		void apply();
-		void remove();
-	};
-
-	%feature(&quot;director&quot;) ActionMananger;
-    class ActionManager
-    {
-    public:
-        void registerAction(rl::Action* action);
-        void unregisterAction(const rl::CeGuiString actionName);
-		rl::Action* getAction(const rl::CeGuiString actionName) const;
-
-		void registerInGameGlobalAction(rl::Action* action, rl::ActionGroup* group);
-	
-        static rl::ActionManager&amp; getSingleton();
-	};
-	
-	%feature(&quot;director&quot;) TimerListener;
-	class TimerListener
-	{
-	public:
-		virtual ~TimerLister();
-	  
-  		virtual void timerFired(rl::TimerEvent* anEvent) = 0;
-	};
-	
-	class TimerEventSource
-	{
-	public:
-		static const RL_LONGLONG NO_REPEAT;
-
-		TimerEventSource( const RL_LONGLONG gameTime, const RL_LONGLONG interval = rl::TimerEventSource::NO_REPEAT );
-		TimerEventSource( const rl::Date dsaTime, const rl::Date interval = rl::TimerEventSource::NO_REPEAT );
-	
-		void addTimerListener( rl::TimerListener* ist );
-        void removeTimerListener( rl::TimerListener* ist );
-	};
-	
-	class TimerEvent
-	{
-	public:
-		TimerEvent( rl::TimerEventSource* src );
-	
-		Ogre::Real getTime();
-		rl::Date getGameTime();
-
-		rl::TimerEventSource* getSource() const;
-	};
-} // Namespace
-
-%{
-static swig_type_info *GameObject_dynamic_cast(void **ptr)
-{
-    rl::GameObject **ppGameObject = reinterpret_cast&lt;rl::GameObject**&gt;(ptr);
-
-    rl::Person *pPerson=dynamic_cast&lt;rl::Person*&gt;(*ppGameObject);
-    if (pPerson) {
-        *ptr=reinterpret_cast&lt;void*&gt;(pPerson);
-        return SWIGTYPE_p_rl__Person;
-    }
-    rl::Creature *pCreature=dynamic_cast&lt;rl::Creature*&gt;(*ppGameObject);
-    if (pCreature) {
-        *ptr=reinterpret_cast&lt;void*&gt;(pCreature);
-        return SWIGTYPE_p_rl__Creature;
-    }
-    rl::Weapon *pWeapon=dynamic_cast&lt;rl::Weapon*&gt;(*ppGameObject);
-    if (pWeapon) {
-        *ptr=reinterpret_cast&lt;void*&gt;(pWeapon);
-        return SWIGTYPE_p_rl__Weapon;
-    }
-    rl::Armor *pArmor=dynamic_cast&lt;rl::Armor*&gt;(*ppGameObject);
-    if (pArmor) {
-        *ptr=reinterpret_cast&lt;void*&gt;(pArmor);
-        return SWIGTYPE_p_rl__Armor;
-    }
-    rl::Container *pContainer=dynamic_cast&lt;rl::Container*&gt;(*ppGameObject);
-    if (pContainer) {
-        *ptr=reinterpret_cast&lt;void*&gt;(pContainer);
-        return SWIGTYPE_p_rl__Container;
-    }
-    rl::Item *pItem=dynamic_cast&lt;rl::Item*&gt;(*ppGameObject);
-    if (pItem) {
-        *ptr=reinterpret_cast&lt;void*&gt;(pItem);
-        return SWIGTYPE_p_rl__Item;
-    }
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__GameObject, GameObject_dynamic_cast);
-

Added: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,783 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+namespace rl {
+
+	// Before first use of GameObject or subclasses!
+	%apply SWIGTYPE *DYNAMIC { rl::GameObject * };
+					
+   template&lt;typename T&gt;
+   class Tripel {
+   public:
+      T first;
+      T second;
+      T third;
+
+      Tripel();      
+      Tripel(const T&amp; t1, const T&amp; t2, const T&amp; t3);
+      Tripel(const Tripel&amp; rhs);
+
+      //Tripel&amp; operator=(const Tripel&amp; rhs);
+      bool operator==(const Tripel&amp; rhs);
+      bool operator&lt;(const Tripel&amp; rhs);     
+   };
+	
+		class Date {
+    public:
+        static const RL_LONGLONG ONE_SECOND = 1000ULL;
+        static const RL_LONGLONG ONE_MINUTE = 60000ULL;
+        static const RL_LONGLONG ONE_HOUR = 3600000ULL;
+        static const RL_LONGLONG ONE_DAY = 86400000ULL;
+        static const RL_LONGLONG ONE_WEEK = 604800000ULL;
+        static const RL_LONGLONG ONE_MONTH = 2592000000ULL;
+        static const RL_LONGLONG ONE_YEAR = 31536000000ULL;
+        static const RL_LONGLONG ONE_KAMPFRUNDE = 2 * ONE_SECOND;
+        static const RL_LONGLONG ONE_SPIELRUNDE = 5 * ONE_MINUTE;
+
+        Date();
+        Date(RL_LONGLONG timestamp);
+        Date(const Date&amp; rhs);
+      
+        bool operator==(const Date&amp; rhs);
+        bool operator&lt;(const Date&amp; rhs);
+        bool operator&lt;=(const Date&amp; rhs);
+        bool operator&gt;=(const Date&amp; rhs);
+        bool operator&gt;(const Date&amp; rhs);
+
+        Date operator+(const RL_LONGLONG&amp; rhs);
+        Date operator-(const RL_LONGLONG&amp; rhs);
+        RL_LONGLONG operator-(const Date&amp; rhs);
+      
+        RL_LONGLONG getTimestamp();
+
+        int getTimeFraction();
+        int getYear();
+        int getMonth();
+        rl::CeGuiString getMonthName();
+        int getDayOfYear();
+        int getDayOfMonth();
+        int getDayOfWeek();
+        rl::CeGuiString getDayOfWeekName();
+        int getHour();
+        int getMinute();
+        int getSecond();
+        int getMilliSecond();
+      
+        rl::CeGuiString toString();
+    };
+   
+    Date operator+(const RL_LONGLONG&amp;, const Date&amp;);
+    Date operator-(const RL_LONGLONG&amp;, const Date&amp;);
+
+	class RulesSubsystem 
+    {
+		public:
+ 			static rl::RulesSubsystem&amp; getSingleton();
+ 			rl::QuestBook* getQuestBook();
+ 			void resetQuestBook();
+    };
+  
+    class DsaManager {
+    public:
+        RL_LONGLONG getTimestamp();
+        Date getCurrentDate();
+		void setTimestamp(const RL_LONGLONG time);
+		void setCurrentDate(const Date&amp; date);
+		
+        int rollD20();
+        Tripel&lt;int&gt; roll3D20();
+        int rollD6();
+        int roll(int d6, int d20);
+      
+	    static DsaManager&amp; getSingleton();
+	    rl::Talent* getTalent(const rl::CeGuiString name) const;
+	    rl::Person* getPerson(const int id) const;
+    };
+    
+    class GameObjectProxy
+    {
+    private:
+        GameObjectProxy(const Ogre::String&amp; classid, unsigned int id);
+        
+    public:       
+        rl::GameObject* getGameObject();
+
+        unsigned int getId() const;
+        const Ogre::String&amp; getClassId() const;
+        
+        void load();
+        void unload();
+    };
+    
+    %feature(&quot;director&quot;) GameObjectFactory; 
+    class GameObjectFactory
+    {
+    public:
+        virtual rl::GameObject* createRubyGameObject(const Ogre::String&amp; classname, unsigned int id) = 0;
+        GameObjectFactory();
+        virtual ~GameObjectFactory();
+    };
+
+    class GameObjectManager
+    {
+    public:
+        static rl::GameObjectManager&amp; getSingleton();
+        rl::GameObjectProxy&amp; createGameObjectProxy(const Ogre::String&amp; classId, unsigned int id = 0);
+        rl::GameObjectProxy* getGameObjectProxy(unsigned int id) const;
+        void setGameObjectFactory(rl::GameObjectFactory* gof);
+
+    private:
+        GameObjectManager();
+    };
+
+
+	%feature(&quot;director&quot;) QuestListener; 
+	class QuestListener
+	{
+	public:
+		virtual ~QuestListener();
+		
+		virtual void questStateChanged(rl::QuestEvent* anEvent) = 0;
+		virtual void questPartsDoneChanged(rl::QuestEvent* anEvent) = 0;
+		virtual void questKnownChanged(rl::QuestEvent* anEvent) = 0;
+		virtual void questSubquestAdded(rl::QuestEvent* anEvent) = 0;
+		virtual void journalEntryAdded(rl::JournalEvent* anEvent) = 0;
+	};
+
+    class JournalEntry
+    {
+    public:
+        JournalEntry(const rl::CeGuiString caption, const rl::CeGuiString text);
+        virtual ~JournalEntry();
+
+        rl::CeGuiString getCaption() const;
+
+        rl::CeGuiString getText() const;
+    };
+    
+	class Quest
+	{
+	public:
+		enum State
+		{
+			OPEN = 0,
+			ASSIGNED,
+			FAILED,
+			SUCCEEDED,
+			COMPLETED
+		};
+
+		Quest(const rl::CeGuiString id, const rl::CeGuiString name, const rl::CeGuiString description);
+		virtual ~Quest();
+
+		const rl::CeGuiString getId();
+		const rl::CeGuiString getName();
+		const rl::CeGuiString getDescription();
+		int getPartsToDo();
+		void setPartsToDo(int partsToDo);
+		int getPartsDone();
+		void setPartsDone(int partsDone);
+		void increasePartsDone(int parts = 1);
+		void decreasePartsDone(int parts = 1);
+
+		rl::Quest::State getState();
+		void setState(rl::Quest::State state);
+		bool isKnown();
+		void setKnown(bool known);
+
+		// QuestVector getSubquests();
+		void addSubquest(rl::Quest* quest); 
+	};   
+	
+	class QuestEvent
+	{
+	public:
+		rl::Quest* getQuest();
+	private:
+		QuestEvent( rl::QuestBook* src, int reason );
+	};
+	
+	class QuestBook
+	{
+	public:
+		rl::Quest* getQuest(const rl::CeGuiString id);
+		void addQuest(rl::Quest* quest);
+		
+		void addJournalEntry(rl::JournalEntry* entry);
+		void addJournalEntry(rl::CeGuiString caption, rl::CeGuiString text);
+		
+		void addQuestListener(rl::QuestListener* listener);
+		void removeQuestListener(rl::QuestListener* listener);
+	};
+	
+    class Talent
+    {
+    public:
+        Talent(const rl::CeGuiString name,
+               const rl::CeGuiString description,
+               const Tripel&lt;rl::CeGuiString&gt;&amp; eigenschaften,
+               int ebe,
+			   int gruppe,
+			   const rl::CeGuiString art);
+
+        bool operator==(const Talent&amp; rhs) const;
+        bool operator&lt;(const Talent&amp; rhs) const;
+        rl::CeGuiString getName() const;
+        rl::CeGuiString getDescription() const;
+		int getEbe() const;
+
+        /// Berechnet effektive Behinderung bei gegebener Behinderung;
+        int calculateEbe(int be) const;
+        Tripel&lt;rl::CeGuiString&gt; getEigenschaften() const;
+    };
+
+    class ActionGroup
+	{
+	public:
+		ActionGroup(rl::CeGuiString name, ActionGroup* parent = NULL);
+		~ActionGroup();
+	
+		const rl::CeGuiString getName() const;
+	};
+	
+	%feature(&quot;director&quot;) Action;   
+    class Action
+    {
+    public:
+    	static const int ACT_NORMAL = 1&lt;&lt;0;
+		static const int ACT_INVIS_DESC = 1&lt;&lt;1;
+		static const int ACT_DISABLED = 1&lt;&lt;2;
+		static const int ACT_NEEDS_TALENT = 1&lt;&lt;8;
+
+		static const int TC_NO_TARGET = 0;
+		static const int TC_GAMEOBJECT = 1;
+		static const int TC_CREATURE = 2;
+		static const int TC_ITEM = 3;
+		static const int TC_POINT = 4;
+		static const int TC_RADIUS = 5;
+		static const int TC_POINT_AND_RADIUS = 6;
+    
+        Action(const rl::CeGuiString name, const rl::CeGuiString description);
+        virtual ~Action();
+
+        virtual const rl::CeGuiString getName() const;
+        //virtual const rl::CeGuiString getClassName() const;
+        virtual const rl::CeGuiString getDescription() const;
+        virtual int getTargetClass() const;
+        virtual void doAction(rl::GameObject *object, rl::Creature *actor,
+            rl::GameObject *target);
+        virtual bool canDo(rl::GameObject* object, rl::Creature* actor) const;
+            
+        void setGroup(rl::ActionGroup* group);
+		rl::ActionGroup* getGroup() const;
+    };
+    
+	%feature(&quot;director&quot;) ObjectStateChangeListener; 	 
+	class ObjectStateChangeListener 	 
+	{ 	 
+	public: 	 
+		virtual ~ObjectStateChangeListener(); 	 
+		  	 
+		virtual void objectStateChanged(rl::ObjectStateChangeEvent *anEvent) = 0; 	 
+	};
+		 	 
+		  	 
+	class ObjectStateChangeEventSource 	 
+	{ 	 
+	public: 	 
+		ObjectStateChangeEventSource( ); 	 
+		  	 
+		void addObjectStateChangeListener( rl::ObjectStateChangeListener*  list ); 	 
+		void removeObjectStateChangeListener( rl::ObjectStateChangeListener* list ); 	 
+		bool hasListeners( ) const; 	 
+		rl::GameObject* getObject() const;
+		void fireObjectStateChangeEvent(); 	 
+	}; 	 
+		  	 
+	class ObjectStateChangeEvent 	 
+	{ 	 
+	public: 	 
+		ObjectStateChangeEvent( rl::ObjectStateChangeEventSource* src ); 	 
+		rl::GameObject* getProvokingObject() const; 	 
+		rl::ObjectStateChangeEventSource* getSource() const; 	 
+	};
+		    
+	enum GameObjectState
+    {
+        GOS_UNDEFINED = 0,
+        GOS_UNLOADED,
+        GOS_LOADED,
+        GOS_IN_POSSESSION,
+        GOS_IN_SCENE,
+        GOS_HELD,
+        GOS_READY
+    };
+    
+    %feature(&quot;director&quot;) GameObject;
+    class GameObject: public ObjectStateChangeEventSource
+    {
+    public:
+        GameObject(unsigned int id);
+        virtual ~GameObject();
+
+        virtual unsigned int getId();
+
+        virtual const rl::CeGuiString getName() const;
+        virtual void setName(rl::CeGuiString name);
+
+        const rl::CeGuiString getDescription() const;
+        virtual void setDescription(rl::CeGuiString description);   
+        
+        void setActor(rl::Actor* actor);
+		rl::Actor* getActor();
+
+        void addAction(rl::Action *action, int option = ACT_NORMAL);
+        void addActionInGroup(Action* action, ActionGroup* group, int option = ACT_NORMAL);
+        void removeAction(rl::Action *action);
+
+        const std::vector&lt;Action*&gt; getValidActions(rl::Creature *actor) const;        
+        void setPosition(const Ogre::Vector3&amp; position);
+        void setOrientation(const Ogre::Quaternion&amp; orientation);
+	    const Ogre::Quaternion&amp; getOrientation() const;
+        const Ogre::Vector3&amp; getPosition() const;
+        
+        void setMeshfile(rl::CeGuiString meshfile);
+        
+        virtual Action* getDefaultAction(rl::Creature* actor) const;
+        
+        void doAction(
+			const rl::CeGuiString actionName, 
+			rl::Creature* actor,
+            rl::GameObject* target);
+        void doAction(
+			const rl::CeGuiString actionName);
+        void doAction(rl::Action* action, rl::Creature* actor,
+            rl::GameObject* target);
+            
+        void doDefaultAction(rl::Creature* actor, rl::GameObject* target);
+            
+		static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
+		
+		bool isHighlightingEnabled();
+        void setHighlightingEnabled( bool highlightenabled );
+        
+        virtual const rl::Property getProperty(const Ogre::String&amp; key) const;
+        virtual void setProperty(const Ogre::String&amp; key, const rl::Property&amp; value);
+        
+        void placeIntoScene();
+        void removeFromScene();
+        
+        rl::GameObjectState getState() const;
+        virtual void setState(rl::GameObjectState state);
+    };
+    
+    %feature(&quot;director&quot;) Item;
+    class Item : public rl::GameObject {
+    public:
+        enum ItemType{
+			ITEMTYPE_WEAPON     = 1 &lt;&lt; 0,
+			ITEMTYPE_SHIELD     = 1 &lt;&lt; 1,
+			ITEMTYPE_RING       = 1 &lt;&lt; 2,
+			ITEMTYPE_GLOVES     = 1 &lt;&lt; 3,
+			ITEMTYPE_BRACELET   = 1 &lt;&lt; 4,
+			ITEMTYPE_ARMOR      = 1 &lt;&lt; 5,
+			ITEMTYPE_CAPE       = 1 &lt;&lt; 6,
+			ITEMTYPE_BRACERS    = 1 &lt;&lt; 7,
+			ITEMTYPE_BACKPACK   = 1 &lt;&lt; 8,
+			ITEMTYPE_BELT       = 1 &lt;&lt; 9,
+			ITEMTYPE_NECKLACE   = 1 &lt;&lt; 10,
+			ITEMTYPE_HELMET     = 1 &lt;&lt; 11,
+			ITEMTYPE_TROUSERS   = 1 &lt;&lt; 12,
+			ITEMTYPE_SHINBONE   = 1 &lt;&lt; 13,
+			ITEMTYPE_BOOTS      = 1 &lt;&lt; 14,
+			ITEMTYPE_OTHER      = 1 &lt;&lt; 15,
+            ITEMTYPE_ALL_ITEMS  = ~(0)
+		};
+    
+        Item(unsigned int id);
+        virtual ~Item();
+        
+        void setItemType(rl::Item::ItemType itemType);
+        rl::Item::ItemType getItemType() const;
+        virtual void setState(rl::GameObjectState state);
+
+        virtual const rl::Property getProperty(const Ogre::String&amp; key) const;
+        virtual void setProperty(const Ogre::String&amp; key, const rl::Property&amp; value);
+    };
+    
+    %feature(&quot;director&quot;) Weapon;
+    class Weapon : public rl::Item 
+    {
+    public:
+		enum Distanzklasse { DK_H=0, DK_N, DK_S, DK_P };
+
+        Weapon(unsigned int id);
+        virtual ~Weapon();
+                
+		void setTp(int d6, int d20, int mod);
+		const Tripel&lt;int&gt;&amp; getTp() const;
+		void setTpKk(int base, int step);
+		const pair&lt;int, int&gt;&amp; getTpKk() const;
+		void setBf(int newBf);
+		int getBf();
+		void setIni(int newIni);
+		int getIni();
+		void setWm(pair&lt;int, int&gt;&amp; newWm);
+		const pair&lt;int,int&gt;&amp; getWm() const;
+		void setDk(Weapon::Distanzklasse newDk);
+		Weapon::Distanzklasse getDk();
+		void setKampftechnik(const rl::CeGuiString newKampftechnik);
+		const rl::CeGuiString getKampftechnik() const;
+
+        virtual const rl::Property getProperty(const Ogre::String&amp; key) const;
+        virtual void setProperty(const Ogre::String&amp; key, const rl::Property&amp; value);
+    };
+    
+    %feature(&quot;director&quot;) Armor;
+    class Armor : public Item
+    {
+    public:
+        Armor(unsigned int id);
+        virtual ~Armor();
+
+        virtual const rl::Property getProperty(const Ogre::String&amp; key) const;
+        virtual void setProperty(const Ogre::String&amp; key, const rl::Property&amp; value);
+    };
+    
+    %feature(&quot;director&quot;) Container;
+    class Container : public Item
+    {
+    public:
+        Container(unsigned int id);
+        virtual ~Container();
+
+        Ogre::Real getCapacity() const;
+        void setCapacity(Ogre::Real capacity);
+        void setVolume(unsigned int x, unsigned int y);
+        Ogre::Real getContentWeight() const;
+        void addItem(rl::Item* item);
+        void removeItem(rl::Item* item);
+        rl::ItemSet getItems() const;
+        int getItemCount() const;
+        rl::Item* getItemAt(unsigned int x, unsigned int y);
+
+        virtual const rl::Property getProperty(const Ogre::String&amp; key) const;
+        virtual void setProperty(const Ogre::String&amp; key, const rl::Property&amp; value);
+	};
+	
+	class StateSet
+	{
+	public:
+		StateSet();
+		virtual ~StateSet();
+
+		virtual int getValue(bool getUnmodfiedValue = false) const;
+		virtual int getOriginalValue() const;
+		virtual void setOriginalValue(int newValue);
+		virtual int getModifier() const;
+		virtual void setModifier(int newModifier);
+		virtual void modifyModifier(int modifier);
+		virtual int getProbenModifier() const;
+		virtual void setProbenModifier(int newProbenModifier);
+		virtual void modifyProbenModifier(int modifier);
+		virtual int getMultiplier() const;
+		virtual void setMultiplier(int newMultiplier);
+	};
+
+	class EigenschaftenStateSet : public StateSet
+	{
+	public:
+		EigenschaftenStateSet();
+		~EigenschaftenStateSet();
+
+		int getStartValue();
+		void setStartValue( int newStartValue );
+		int getPermanentModifier();
+		void setPermanentModifier( int newPermanentModifier );
+		int getModifierWithoutRecalculation();
+		void setModifierWithoutRecalculation( int newModifierWithoutRecalculation );
+
+		int getValue( bool getUnmodifiedValue = false );
+		int getValueForBasiswertCalculation();
+	};
+	
+	class SonderfertigkeitenStateSet : public StateSet
+	{
+	public:
+		SonderfertigkeitenStateSet();
+		~SonderfertigkeitenStateSet();
+
+		void setModifier( int newModifier );
+		int getLehrmeisterZeiteinheiten();
+		void setLehrmeisterZeiteinheiten( int newLehrmeisterZeiteinheiten );
+	};
+	
+	class TalentStateSet : public StateSet
+	{
+	public:
+		TalentStateSet();
+		~TalentStateSet();
+
+		bool getSe();
+		void setSe(bool newSe);
+		int getLehrmeisterZeiteinheiten();
+		void setLehrmeisterZeiteinheiten( int newLehrmeisterZeiteinheiten );
+		int getSelbststudiumZeiteinheiten();
+		void setSelbststudiumZeiteinheiten( int newSelbststudiumZeiteinheiten );
+	};
+	
+	%feature(&quot;director&quot;) Effect;
+	class Effect
+	{
+	public:
+        enum Quantifier
+        {
+            QUANTIFIER_MULTIPLE,
+            QUANTIFIER_UNIQUE,
+            QUANTIFIER_UNIQUE_BUT_PROLONGABLE,
+            QUANTIFIER_UNIQUE_BUT_CUMULATIVE
+        };
+
+        enum EffectTag
+        {
+            EFFECTTAG_NONE,
+            EFFECTTAG_KRANKHEIT
+        };
+
+		Effect(int stufe = 1);
+		virtual ~Effect();
+
+        const rl::CeGuiString getName() const;
+        void setName(rl::CeGuiString name);
+        const rl::CeGuiString getDescription() const;
+        void setDescription(rl::CeGuiString description);
+		rl::Creature* getOwner() const;
+		void setOwner(rl::Creature* owner);
+		virtual int getDuration();
+		virtual void setDuration(int newDuration);
+		Quantifier getQuantifier();
+		void setQuantifier(Quantifier quantifier);
+		virtual void addTag(EffectTag tagId);
+		virtual void removeTag(EffectTag tagId);
+		virtual bool queryTag(EffectTag tagId);
+		virtual const int getStufe();
+		virtual void increaseStufe();
+		virtual void decreaseStufe();
+		virtual void enable();
+		virtual void disable();
+		virtual void check() = 0;
+
+	protected:
+		virtual void apply() = 0;
+		virtual void remove() = 0;
+		virtual RL_LONGLONG getTimePassed();
+	};
+	
+	class Inventory 
+	{
+    private:
+        Inventory(rl::Creature* owner);
+	public:
+	    void addSlot(const rl::CeGuiString&amp; name, const Ogre::String&amp; bone, int itemMask);
+	    rl::Item* getItem(const rl::CeGuiString&amp; slotName);
+        void hold(rl::Item* item, const rl::CeGuiString&amp; slot);
+	};
+
+    %feature(&quot;director&quot;) Creature;
+    class Creature : public GameObject {
+    public:
+
+        enum Wert
+        {
+            WERT_MOD_AE = 1, // Astralenergie
+            WERT_MOD_LE, // Lebensenergie
+            WERT_MOD_AT, // Attacke
+            WERT_MOD_PA, // Parade
+            WERT_MOD_FK, // Fernkampf
+            WERT_MOD_AU, // Ausdauer
+            WERT_MOD_MR, // Magieresistenz
+            WERT_MOD_INI, // Initiative
+            WERT_MOD_REGENERATION_LE, // Naechtliche Regeneration. modifier modifiziert den W6, ProbenModifier modifiziert die KO-Probe.
+            WERT_MOD_REGENERATION_AE, // Astrale Regeneration. modifier modifiziert den W6, ProbenModifier modifiziert die IN-Probe.
+            WERT_MOD_ERSCHOEPFUNGSSCHWELLE, // Die Modifkitoren von KO bezueglich der Erschoepfungsschwelle.
+            WERT_MOD_ALL_EIGENSCHAFTSPROBEN, // Modifiziert alle Proben, die mit 1W20 gewuerfelt werden.
+            WERT_MOD_ALL_TALENTPROBEN, // Modifiziert alle Proben, die mit 3W20 gewuerfelt werden.
+            WERT_GS, // Geschwindigkeit
+            WERT_SOZIALSTATUS, // Sozialstatus
+            WERT_BE // Behinderung
+        };
+
+        Creature(unsigned int id);
+        virtual ~Creature();
+
+        virtual int getLe();
+        virtual void modifyLe(int mod, bool ignoreMax);
+        virtual void modifyAe(int mod);
+        virtual void modifyAu(int mod);
+        void setWert(Wert wertId, int value);
+        virtual StateSet* getWertStateSet(Wert wertId);
+        
+        virtual int getEigenschaft(const rl::CeGuiString eigenschaftName);
+        virtual void setEigenschaft(const rl::CeGuiString eigenschaftName, int value);
+        virtual void modifyEigenschaft(const rl::CeGuiString eigenschaftName, int mod);
+		virtual EigenschaftenStateSet* getEigenschaftenStateSet(const rl::CeGuiString eigenschaftName);
+		
+        void addTalent(const rl::CeGuiString talentName, int value=0);
+        virtual int getTalent(const rl::CeGuiString talentName);
+        virtual void setTalent(const rl::CeGuiString talentName, int value);
+        virtual void modifyTalent(const rl::CeGuiString talentName, int mod);
+		virtual void addSe(const rl::CeGuiString talentName);
+		virtual TalentStateSet* getTalentStateSet(const rl::CeGuiString talentName);
+		
+		void addVorteil(const rl::CeGuiString vorteilName, int value = 0);
+		void addNachteil(const rl::CeGuiString nachteilName, int value = 0);		
+		
+        void addKampftechnik(const rl::CeGuiString kampftechnikName, std::pair&lt;int,int&gt; value = make_pair(0,0));
+        
+		virtual SonderfertigkeitenStateSet* getSonderfertigkeitenStateSet(const rl::CeGuiString sfName);
+
+        virtual int doTalentprobe(const rl::CeGuiString talentName, int modifier);
+        virtual int doEigenschaftsprobe(const rl::CeGuiString eigenschaftName, int modifier);
+        
+        rl::Inventory* getInventory();
+        
+		void addEffect(Effect* effect);
+		void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
+        static const int LEDAMAGE_NORMAL = 0;
+        static const int LEDAMAGE_FIRE = 1;
+        static const int LEDAMAGE_WATER = 2;
+        static const int LEDAMAGE_DEMONIC = 4;
+        void damageAu(int aup, int damageType = AUDAMAGE_NORMAL);
+        static const int AUDAMAGE_NORMAL = 0;
+        static const int AUDAMAGE_HEAT = 1;
+        static const int AUDAMAGE_COLD = 2;
+        static const int AUDAMAGE_CHOKE = 4;
+        static const int AUDAMAGE_DROWN = 8;
+
+        virtual const rl::Property getProperty(const Ogre::String&amp; key) const;
+        virtual void setProperty(const Ogre::String&amp; key, const rl::Property&amp; value);
+   };
+   
+   %feature(&quot;director&quot;) Person;
+   class Person : public Creature
+   {
+   public:
+	    Person(unsigned int id);
+
+        virtual const rl::Property getProperty(const Ogre::String&amp; key) const;
+        virtual void setProperty(const Ogre::String&amp; key, const rl::Property&amp; value);
+	};
+		
+	%feature(&quot;director&quot;) CompositeEffect;	
+	class CompositeEffect : public Effect
+	{
+	public:
+		CompositeEffect();
+		virtual ~CompositeEffect();
+
+		void addEffect(Effect* effect);
+		virtual void check();
+	protected:
+		void apply();
+		void remove();
+	};
+
+	%feature(&quot;director&quot;) ActionMananger;
+    class ActionManager
+    {
+    public:
+        void registerAction(rl::Action* action);
+        void unregisterAction(const rl::CeGuiString actionName);
+		rl::Action* getAction(const rl::CeGuiString actionName) const;
+
+		void registerInGameGlobalAction(rl::Action* action, rl::ActionGroup* group);
+	
+        static rl::ActionManager&amp; getSingleton();
+	};
+	
+	%feature(&quot;director&quot;) TimerListener;
+	class TimerListener
+	{
+	public:
+		virtual ~TimerLister();
+	  
+  		virtual void timerFired(rl::TimerEvent* anEvent) = 0;
+	};
+	
+	class TimerEventSource
+	{
+	public:
+		static const RL_LONGLONG NO_REPEAT;
+
+		TimerEventSource( const RL_LONGLONG gameTime, const RL_LONGLONG interval = rl::TimerEventSource::NO_REPEAT );
+		TimerEventSource( const rl::Date dsaTime, const rl::Date interval = rl::TimerEventSource::NO_REPEAT );
+	
+		void addTimerListener( rl::TimerListener* ist );
+        void removeTimerListener( rl::TimerListener* ist );
+	};
+	
+	class TimerEvent
+	{
+	public:
+		TimerEvent( rl::TimerEventSource* src );
+	
+		Ogre::Real getTime();
+		rl::Date getGameTime();
+
+		rl::TimerEventSource* getSource() const;
+	};
+} // Namespace
+
+%{
+static swig_type_info *GameObject_dynamic_cast(void **ptr)
+{
+    rl::GameObject **ppGameObject = reinterpret_cast&lt;rl::GameObject**&gt;(ptr);
+
+    rl::Person *pPerson=dynamic_cast&lt;rl::Person*&gt;(*ppGameObject);
+    if (pPerson) {
+        *ptr=reinterpret_cast&lt;void*&gt;(pPerson);
+        return SWIGTYPE_p_rl__Person;
+    }
+    rl::Creature *pCreature=dynamic_cast&lt;rl::Creature*&gt;(*ppGameObject);
+    if (pCreature) {
+        *ptr=reinterpret_cast&lt;void*&gt;(pCreature);
+        return SWIGTYPE_p_rl__Creature;
+    }
+    rl::Weapon *pWeapon=dynamic_cast&lt;rl::Weapon*&gt;(*ppGameObject);
+    if (pWeapon) {
+        *ptr=reinterpret_cast&lt;void*&gt;(pWeapon);
+        return SWIGTYPE_p_rl__Weapon;
+    }
+    rl::Armor *pArmor=dynamic_cast&lt;rl::Armor*&gt;(*ppGameObject);
+    if (pArmor) {
+        *ptr=reinterpret_cast&lt;void*&gt;(pArmor);
+        return SWIGTYPE_p_rl__Armor;
+    }
+    rl::Container *pContainer=dynamic_cast&lt;rl::Container*&gt;(*ppGameObject);
+    if (pContainer) {
+        *ptr=reinterpret_cast&lt;void*&gt;(pContainer);
+        return SWIGTYPE_p_rl__Container;
+    }
+    rl::Item *pItem=dynamic_cast&lt;rl::Item*&gt;(*ppGameObject);
+    if (pItem) {
+        *ptr=reinterpret_cast&lt;void*&gt;(pItem);
+        return SWIGTYPE_p_rl__Item;
+    }
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__GameObject, GameObject_dynamic_cast);
+


Property changes on: rl/trunk/engine/script/swig/RlRules.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/RlScript.head.inc
===================================================================
--- rl/trunk/engine/script/swig/RlScript.head.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlScript.head.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,20 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-%{
-//----------- Includes - Script -----------
-#include &quot;ScriptSubsystem.h&quot;
-%}
\ No newline at end of file

Added: rl/trunk/engine/script/swig/RlScript.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlScript.head.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlScript.head.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,20 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+%{
+//----------- Includes - Script -----------
+#include &quot;ScriptSubsystem.h&quot;
+%}
\ No newline at end of file


Property changes on: rl/trunk/engine/script/swig/RlScript.head.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/RlScript.inc
===================================================================
--- rl/trunk/engine/script/swig/RlScript.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlScript.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,25 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-namespace rl {
-	class ScriptSubsystem
-	{
-	public:
-		static rl::ScriptSubsystem&amp; getSingleton();
-
-		void log(const rl::CeGuiString&amp; message);
-	};
-}
\ No newline at end of file

Added: rl/trunk/engine/script/swig/RlScript.swig
===================================================================
--- rl/trunk/engine/script/swig/RlScript.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlScript.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,25 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+namespace rl {
+	class ScriptSubsystem
+	{
+	public:
+		static rl::ScriptSubsystem&amp; getSingleton();
+
+		void log(const rl::CeGuiString&amp; message);
+	};
+}
\ No newline at end of file


Property changes on: rl/trunk/engine/script/swig/RlScript.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/RlUi.head.inc
===================================================================
--- rl/trunk/engine/script/swig/RlUi.head.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlUi.head.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,29 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-%{
-//----------- Includes - UI -----------
-#include &quot;FixRubyHeaders.h&quot;
-
-#include &quot;CharacterController.h&quot;
-#include &quot;CommandMapper.h&quot;
-#include &quot;CutsceneCharacterController.h&quot;
-#include &quot;GameLoggerWindow.h&quot;
-#include &quot;UiPrerequisites.h&quot;
-#include &quot;UiSubsystem.h&quot;
-#include &quot;WindowFactory.h&quot;
-#include &quot;WindowManager.h&quot;
-%}
\ No newline at end of file

Added: rl/trunk/engine/script/swig/RlUi.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.head.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlUi.head.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,29 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+%{
+//----------- Includes - UI -----------
+#include &quot;FixRubyHeaders.h&quot;
+
+#include &quot;CharacterController.h&quot;
+#include &quot;CommandMapper.h&quot;
+#include &quot;CutsceneCharacterController.h&quot;
+#include &quot;GameLoggerWindow.h&quot;
+#include &quot;UiPrerequisites.h&quot;
+#include &quot;UiSubsystem.h&quot;
+#include &quot;WindowFactory.h&quot;
+#include &quot;WindowManager.h&quot;
+%}
\ No newline at end of file


Property changes on: rl/trunk/engine/script/swig/RlUi.head.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/RlUi.inc
===================================================================
--- rl/trunk/engine/script/swig/RlUi.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlUi.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,158 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-namespace rl {
-
-%apply SWIGTYPE *DYNAMIC { rl::CharacterController * };
-
-%feature(&quot;director&quot;) CharacterController;
-class CharacterController
-{
-private:
-	CharacterController(rl::Actor* camera, rl::Actor* character);
-public:
-	enum ControllerType 
-	{
-		CTRL_NONE = 1,
-		CTRL_FREEFLIGHT,
-		CTRL_MOVEMENT,
-		CTRL_DIALOG,
-		CTRL_CUTSCENE,
-        CTRL_VANITY_MODE,
-		CTRL_COMBAT,
-	};
-	
-	rl::CharacterController::ControllerType getType();
-
-     /**
-       *  @throw NullPointerException if camera or character is NULL.
-       *  @throw InvalidArgumentException if character is not placed in the scene.
-       */
-    void toggleViewMode();
-    void resetCamera();
-        
-};
-
-class CutsceneCharacterController : public CharacterController
-{
-private:
-   	CutsceneCharacterController(rl::Actor* camera);
-
-public:
-	virtual ~CutsceneCharacterController();
-
-	ControllerType getType() const;
-
-	void toggleViewMode();
-    void resetCamera();
-
-    void setCameraPosition(const Ogre::Vector3&amp; pos);
-    void setCameraOrientation(const Ogre::Quaternion&amp; orient);
-    void lookAt(const Ogre::Vector3&amp; point);
-};
-
-class UiSubsystem 
-{
-public:
-    static UiSubsystem&amp; getSingleton(void);
-	void initializeSubsystem();
-	    
-	rl::Person* getActiveCharacter();
-	void setActiveCharacter(rl::Person* chara);
-
-	rl::CharacterController* getCharacterController() const;
-	rl::CharacterController::ControllerType getCharacterControllerType() const;
-	void setCharacterController(rl::CharacterController::ControllerType type);
-	void linkKeyToRubyCommand(const rl::CeGuiString &amp;key, const rl::CeGuiString &amp;command);
-};
-
-class GameLoggerWindow
-{
-public:
-	void logDialogEvent(const rl::CeGuiString&amp; speaker, const rl::CeGuiString&amp; text);
-	void logFightEvent(const rl::CeGuiString&amp; text);
-	void logCharacterEvent(const rl::CeGuiString&amp; text);
-	void logMiscEvent(const rl::CeGuiString&amp; text);
-};
-
-class WindowFactory
-{
-public:
-	enum PopupType
-	{
-		ICON_ERROR = 1,
-		ICON_QUEST
-	};
-
-	static rl::WindowFactory&amp; getSingleton();
-
-	void update();
-
-	void showAboutWindow();
-	void showActionChoice(rl::GameObject* obj);
-	void showCharacterActionChoice();
-	void showCharacterSheet();
-	void showCharacterSheet(rl::Person* chara);
-	void showContainerContent(rl::Container* container);
-	void showDescriptionWindow(rl::GameObject* obj);
-	void showDialog(rl::DialogCharacter* bot);
-	void showExitConfirmation();
-	void showJournalWindow();
-	void showLogfiles();
-	void showMainMenu();
-	void showMessageWindow(const rl::CeGuiString&amp; message);
-    void showPlaylist();
-	void showPopupMessage(int popupTypes);
-    void showSoundConfig();
-
-	void toggleConsole();
-	void toggleDebugWindow();
-	void toggleGameLogWindow();
-	void toggleCharacterStateWindow();
-	void toggleInGameGlobalMenu();
-	void toggleInventoryWindow();	
-
-	void checkForErrors();
-	rl::GameLoggerWindow* getGameLogger();
-	
-    void showNextDebugWindowPage();
-};
-
-class WindowManager
-{
-public:
-	static rl::WindowManager&amp; getSingleton();
-	void closeTopWindow();
-};
-
-} //namespace rl
-
-%{
-static swig_type_info *CharacterController_dynamic_cast(void **ptr)
-{
-    rl::CharacterController **ppCharacterController = 
-        reinterpret_cast&lt;rl::CharacterController**&gt;(ptr);
-
-    rl::CutsceneCharacterController *pCutSceneCC = 
-        dynamic_cast&lt;rl::CutsceneCharacterController*&gt;(*ppCharacterController);
-    if (pCutSceneCC != NULL) {
-        *ptr=reinterpret_cast&lt;void*&gt;(pCutSceneCC);
-        return SWIGTYPE_p_rl__CutsceneCharacterController;
-    }
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__CharacterController, CharacterController_dynamic_cast);

Added: rl/trunk/engine/script/swig/RlUi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/RlUi.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,158 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+namespace rl {
+
+%apply SWIGTYPE *DYNAMIC { rl::CharacterController * };
+
+%feature(&quot;director&quot;) CharacterController;
+class CharacterController
+{
+private:
+	CharacterController(rl::Actor* camera, rl::Actor* character);
+public:
+	enum ControllerType 
+	{
+		CTRL_NONE = 1,
+		CTRL_FREEFLIGHT,
+		CTRL_MOVEMENT,
+		CTRL_DIALOG,
+		CTRL_CUTSCENE,
+        CTRL_VANITY_MODE,
+		CTRL_COMBAT,
+	};
+	
+	rl::CharacterController::ControllerType getType();
+
+     /**
+       *  @throw NullPointerException if camera or character is NULL.
+       *  @throw InvalidArgumentException if character is not placed in the scene.
+       */
+    void toggleViewMode();
+    void resetCamera();
+        
+};
+
+class CutsceneCharacterController : public CharacterController
+{
+private:
+   	CutsceneCharacterController(rl::Actor* camera);
+
+public:
+	virtual ~CutsceneCharacterController();
+
+	ControllerType getType() const;
+
+	void toggleViewMode();
+    void resetCamera();
+
+    void setCameraPosition(const Ogre::Vector3&amp; pos);
+    void setCameraOrientation(const Ogre::Quaternion&amp; orient);
+    void lookAt(const Ogre::Vector3&amp; point);
+};
+
+class UiSubsystem 
+{
+public:
+    static UiSubsystem&amp; getSingleton(void);
+	void initializeSubsystem();
+	    
+	rl::Person* getActiveCharacter();
+	void setActiveCharacter(rl::Person* chara);
+
+	rl::CharacterController* getCharacterController() const;
+	rl::CharacterController::ControllerType getCharacterControllerType() const;
+	void setCharacterController(rl::CharacterController::ControllerType type);
+	void linkKeyToRubyCommand(const rl::CeGuiString &amp;key, const rl::CeGuiString &amp;command);
+};
+
+class GameLoggerWindow
+{
+public:
+	void logDialogEvent(const rl::CeGuiString&amp; speaker, const rl::CeGuiString&amp; text);
+	void logFightEvent(const rl::CeGuiString&amp; text);
+	void logCharacterEvent(const rl::CeGuiString&amp; text);
+	void logMiscEvent(const rl::CeGuiString&amp; text);
+};
+
+class WindowFactory
+{
+public:
+	enum PopupType
+	{
+		ICON_ERROR = 1,
+		ICON_QUEST
+	};
+
+	static rl::WindowFactory&amp; getSingleton();
+
+	void update();
+
+	void showAboutWindow();
+	void showActionChoice(rl::GameObject* obj);
+	void showCharacterActionChoice();
+	void showCharacterSheet();
+	void showCharacterSheet(rl::Person* chara);
+	void showContainerContent(rl::Container* container);
+	void showDescriptionWindow(rl::GameObject* obj);
+	void showDialog(rl::DialogCharacter* bot);
+	void showExitConfirmation();
+	void showJournalWindow();
+	void showLogfiles();
+	void showMainMenu();
+	void showMessageWindow(const rl::CeGuiString&amp; message);
+    void showPlaylist();
+	void showPopupMessage(int popupTypes);
+    void showSoundConfig();
+
+	void toggleConsole();
+	void toggleDebugWindow();
+	void toggleGameLogWindow();
+	void toggleCharacterStateWindow();
+	void toggleInGameGlobalMenu();
+	void toggleInventoryWindow();	
+
+	void checkForErrors();
+	rl::GameLoggerWindow* getGameLogger();
+	
+    void showNextDebugWindowPage();
+};
+
+class WindowManager
+{
+public:
+	static rl::WindowManager&amp; getSingleton();
+	void closeTopWindow();
+};
+
+} //namespace rl
+
+%{
+static swig_type_info *CharacterController_dynamic_cast(void **ptr)
+{
+    rl::CharacterController **ppCharacterController = 
+        reinterpret_cast&lt;rl::CharacterController**&gt;(ptr);
+
+    rl::CutsceneCharacterController *pCutSceneCC = 
+        dynamic_cast&lt;rl::CutsceneCharacterController*&gt;(*ppCharacterController);
+    if (pCutSceneCC != NULL) {
+        *ptr=reinterpret_cast&lt;void*&gt;(pCutSceneCC);
+        return SWIGTYPE_p_rl__CutsceneCharacterController;
+    }
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__CharacterController, CharacterController_dynamic_cast);


Property changes on: rl/trunk/engine/script/swig/RlUi.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/TypeOgreColourValue.inc
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreColourValue.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeOgreColourValue.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,102 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-/* Typemaps fuer ColourValue.
- * Ein ColourValue wird einfach auf ein dreielementiges Array abgebildet.
- * 
- */
-
-%typecheck(SWIG_TYPECHECK_DOUBLE_ARRAY) Ogre::ColourValue, const Ogre::ColourValue, Ogre::ColourValue*, Ogre::ColourValue&amp;,
-   const Ogre::ColourValue*, const Ogre::ColourValue&amp;
-{
-   $1 = TYPE($input) == T_ARRAY &amp;&amp; RARRAY($input)-&gt;len == 4 ? 1 : 0;
-}
- 
-%typemap(in) Ogre::ColourValue, const Ogre::ColourValue
-{
-   Ogre::ColourValue vec(0.0, 0.0, 0.0);
-   int length = RARRAY($input)-&gt;len;
-   VALUE* it = RARRAY($input)-&gt;ptr;
-   if (length &gt; 0) {
-      Check_Type(*it, T_FLOAT);
-      vec.r = RFLOAT(*it)-&gt;value;
-      it++;
-   }
-   if (length &gt; 1) {
-      Check_Type(*it, T_FLOAT);
-      vec.g = RFLOAT(*it)-&gt;value;
-      it++;
-   }
-   if (length &gt; 2) {
-      Check_Type(*it, T_FLOAT);
-      vec.b = RFLOAT(*it)-&gt;value;
-   }
-   if (length &gt; 3) {
-      Check_Type(*it, T_FLOAT);
-      vec.a = RFLOAT(*it)-&gt;value;
-   }
-   $1 = vec;
-}
-
-%typemap(in) Ogre::ColourValue*, Ogre::ColourValue&amp;,
-   const Ogre::ColourValue*, const Ogre::ColourValue&amp;
-{
-   Ogre::ColourValue* vec = new Ogre::ColourValue(0.0, 0.0, 0.0);
-   int length = RARRAY($input)-&gt;len;
-   VALUE* it = RARRAY($input)-&gt;ptr;
-   if (length &gt; 0) {
-      vec-&gt;r = NUM2DBL(*it);
-      it++;
-   }
-   if (length &gt; 1) {
-      vec-&gt;g = NUM2DBL(*it);
-      it++;
-   }
-   if (length &gt; 2) {
-      vec-&gt;b = NUM2DBL(*it);
-      it++;
-   }
-   if (length &gt; 3) {
-      vec-&gt;a = NUM2DBL(*it);
-   }
-   $1 = vec;
-}
-%typemap(freearg) Ogre::ColourValue*, Ogre::ColourValue&amp;,
-   const Ogre::ColourValue*, const Ogre::ColourValue&amp;  
-&quot;   delete $1;&quot;
-
-%typemap(out) Ogre::ColourValue, const Ogre::ColourValue {
-   VALUE array = rb_ary_new();
-   rb_ary_push(array, rb_float_new($1.r));
-   rb_ary_push(array, rb_float_new($1.g));
-   rb_ary_push(array, rb_float_new($1.b));
-   rb_ary_push(array, rb_float_new($1.a));
-   $result = array;
-}
-
-%typemap(out) Ogre::ColourValue*, const Ogre::ColourValue*, const Ogre::ColourValue&amp;, Ogre::Vector&amp; {
-   VALUE array = rb_ary_new();
-   rb_ary_push(array, rb_float_new($1-&gt;r));
-   rb_ary_push(array, rb_float_new($1-&gt;g));
-   rb_ary_push(array, rb_float_new($1-&gt;b));
-   rb_ary_push(array, rb_float_new($1-&gt;a));
-   $result = array;
-} 
-
-%typemap(freearg) Ogre::ColourValue*, Ogre::ColourValue&amp;,
-   const Ogre::ColourValue*, const Ogre::ColourValue&amp;  
-&quot;   delete $1;&quot;
-

Added: rl/trunk/engine/script/swig/TypeOgreColourValue.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreColourValue.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeOgreColourValue.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,102 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+/* Typemaps fuer ColourValue.
+ * Ein ColourValue wird einfach auf ein dreielementiges Array abgebildet.
+ * 
+ */
+
+%typecheck(SWIG_TYPECHECK_DOUBLE_ARRAY) Ogre::ColourValue, const Ogre::ColourValue, Ogre::ColourValue*, Ogre::ColourValue&amp;,
+   const Ogre::ColourValue*, const Ogre::ColourValue&amp;
+{
+   $1 = TYPE($input) == T_ARRAY &amp;&amp; RARRAY($input)-&gt;len == 4 ? 1 : 0;
+}
+ 
+%typemap(in) Ogre::ColourValue, const Ogre::ColourValue
+{
+   Ogre::ColourValue vec(0.0, 0.0, 0.0);
+   int length = RARRAY($input)-&gt;len;
+   VALUE* it = RARRAY($input)-&gt;ptr;
+   if (length &gt; 0) {
+      Check_Type(*it, T_FLOAT);
+      vec.r = RFLOAT(*it)-&gt;value;
+      it++;
+   }
+   if (length &gt; 1) {
+      Check_Type(*it, T_FLOAT);
+      vec.g = RFLOAT(*it)-&gt;value;
+      it++;
+   }
+   if (length &gt; 2) {
+      Check_Type(*it, T_FLOAT);
+      vec.b = RFLOAT(*it)-&gt;value;
+   }
+   if (length &gt; 3) {
+      Check_Type(*it, T_FLOAT);
+      vec.a = RFLOAT(*it)-&gt;value;
+   }
+   $1 = vec;
+}
+
+%typemap(in) Ogre::ColourValue*, Ogre::ColourValue&amp;,
+   const Ogre::ColourValue*, const Ogre::ColourValue&amp;
+{
+   Ogre::ColourValue* vec = new Ogre::ColourValue(0.0, 0.0, 0.0);
+   int length = RARRAY($input)-&gt;len;
+   VALUE* it = RARRAY($input)-&gt;ptr;
+   if (length &gt; 0) {
+      vec-&gt;r = NUM2DBL(*it);
+      it++;
+   }
+   if (length &gt; 1) {
+      vec-&gt;g = NUM2DBL(*it);
+      it++;
+   }
+   if (length &gt; 2) {
+      vec-&gt;b = NUM2DBL(*it);
+      it++;
+   }
+   if (length &gt; 3) {
+      vec-&gt;a = NUM2DBL(*it);
+   }
+   $1 = vec;
+}
+%typemap(freearg) Ogre::ColourValue*, Ogre::ColourValue&amp;,
+   const Ogre::ColourValue*, const Ogre::ColourValue&amp;  
+&quot;   delete $1;&quot;
+
+%typemap(out) Ogre::ColourValue, const Ogre::ColourValue {
+   VALUE array = rb_ary_new();
+   rb_ary_push(array, rb_float_new($1.r));
+   rb_ary_push(array, rb_float_new($1.g));
+   rb_ary_push(array, rb_float_new($1.b));
+   rb_ary_push(array, rb_float_new($1.a));
+   $result = array;
+}
+
+%typemap(out) Ogre::ColourValue*, const Ogre::ColourValue*, const Ogre::ColourValue&amp;, Ogre::Vector&amp; {
+   VALUE array = rb_ary_new();
+   rb_ary_push(array, rb_float_new($1-&gt;r));
+   rb_ary_push(array, rb_float_new($1-&gt;g));
+   rb_ary_push(array, rb_float_new($1-&gt;b));
+   rb_ary_push(array, rb_float_new($1-&gt;a));
+   $result = array;
+} 
+
+%typemap(freearg) Ogre::ColourValue*, Ogre::ColourValue&amp;,
+   const Ogre::ColourValue*, const Ogre::ColourValue&amp;  
+&quot;   delete $1;&quot;
+


Property changes on: rl/trunk/engine/script/swig/TypeOgreColourValue.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/TypeOgreQuaternion.inc
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreQuaternion.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeOgreQuaternion.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,191 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-/* Typemaps fuer Quaternion.
- * Ein Quaternion wird auf ein Array aus einem 3-elementigen Array 
- * f&#252;r die Rotationsachse und einem Wert f&#252;r den Winkel abgebildet
- * 
- */
-
-%typemap(typecheck) Ogre::Quaternion, const Ogre::Quaternion&amp; {
-		if (TYPE($input) == T_ARRAY)
-		{
-			int length = RARRAY($input)-&gt;len;
-			if (length == 2)
-			{
-				VALUE entry0 = rb_ary_entry($input, 0);
-				VALUE entry1 = rb_ary_entry($input, 1);
-				if ((TYPE(entry1) == T_FLOAT || TYPE(entry1) == T_FIXNUM)
-					&amp;&amp; TYPE(entry0) == T_ARRAY 
-					&amp;&amp; RARRAY(entry0)-&gt;len == 3)
-				{
-					$1 = 1;
-				}
-				else
-				{
-					$1 = 0;
-				}
-			}
-			else if (length == 3 || length == 4)
-			{
-				$1 = 1;
-				
-				for (int i = 0; i &lt; length; i++)
-				{
-					if (TYPE(rb_ary_entry($input, i)) != T_FLOAT 
-					    &amp;&amp; TYPE(rb_ary_entry($input, i)) != T_FIXNUM)
-					{
-						$1 = 0;
-						break;
-					}
-				}
-			}
-			else
-			{
-				$1 = 0;
-			}
-		}
-		else
-		{
-			$1 = 0;
-		}
-}
-
-%typemap(in) Ogre::Quaternion, const Ogre::Quaternion
-{
-   Ogre::Quaternion quat;
-   
-   if (RARRAY($input)-&gt;len == 2)
-   {
-	   VALUE axisVal = rb_ary_entry($input, 0);
-	   Ogre::Vector3 axis(
-				NUM2DBL(rb_ary_entry(axisVal, 0)), 
-				NUM2DBL(rb_ary_entry(axisVal, 1)),
-				NUM2DBL(rb_ary_entry(axisVal, 2)));
-
-	   double angle = NUM2DBL(rb_ary_entry($input, 1));
-	      
-	   quat.FromAngleAxis(Ogre::Degree(angle), axis);
-   }
-   else if (RARRAY($input)-&gt;len == 3)
-   {
-	   Quaternion rotX, rotY, rotZ;
-        rotX.FromAngleAxis(
-			Ogre::Degree(NUM2DBL(rb_ary_entry($input, 0))), 
-			Ogre::Vector3::UNIT_X);
-        rotY.FromAngleAxis(
-			Ogre::Degree(NUM2DBL(rb_ary_entry($input, 1))), 
-			Ogre::Vector3::UNIT_Y);
-        rotZ.FromAngleAxis(
-			Ogre::Degree(NUM2DBL(rb_ary_entry($input, 2))), 
-			Ogre::Vector3::UNIT_Z);
-	   
-	   quat = rotX * rotY * rotZ;
-	   quat.normalise();
-   }
-   else if (RARRAY($input)-&gt;len == 4)
-   {
-	   quat.w = NUM2DBL(rb_ary_entry($input, 0));
-	   quat.x = NUM2DBL(rb_ary_entry($input, 1));
-	   quat.y = NUM2DBL(rb_ary_entry($input, 2));
-	   quat.z = NUM2DBL(rb_ary_entry($input, 3));
-   }
-   $1 = quat;
-}
-
-%typemap(in) Ogre::Quaternion*, Ogre::Quaternion&amp;,
-   const Ogre::Quaternion*, const Ogre::Quaternion&amp;
-{
-   Ogre::Quaternion* quat = new Ogre::Quaternion();
-   if (RARRAY($input)-&gt;len == 2)
-   {
-	   VALUE axisVal = rb_ary_entry($input, 0);
-	   Ogre::Vector3 axis(
-				NUM2DBL(rb_ary_entry(axisVal, 0)), 
-				NUM2DBL(rb_ary_entry(axisVal, 1)),
-				NUM2DBL(rb_ary_entry(axisVal, 2)));
-
-	   double angle = NUM2DBL(rb_ary_entry($input, 1));
-	      
-	   quat-&gt;FromAngleAxis(Ogre::Degree(angle), axis);
-   }
-   else if (RARRAY($input)-&gt;len == 3)
-   {
-	   Quaternion rotX, rotY, rotZ;
-        rotX.FromAngleAxis(
-			Ogre::Degree(NUM2DBL(rb_ary_entry($input, 0))), 
-			Ogre::Vector3::UNIT_X);
-        rotY.FromAngleAxis(
-			Ogre::Degree(NUM2DBL(rb_ary_entry($input, 1))), 
-			Ogre::Vector3::UNIT_Y);
-        rotZ.FromAngleAxis(
-			Ogre::Degree(NUM2DBL(rb_ary_entry($input, 2))), 
-			Ogre::Vector3::UNIT_Z);
-	   
-	   *quat = rotX * rotY * rotZ;
-	   quat-&gt;normalise();
-   }
-   else if (RARRAY($input)-&gt;len == 4)
-   {
-	   quat-&gt;w = NUM2DBL(rb_ary_entry($input, 0));
-	   quat-&gt;x = NUM2DBL(rb_ary_entry($input, 1));
-	   quat-&gt;y = NUM2DBL(rb_ary_entry($input, 2));
-	   quat-&gt;z = NUM2DBL(rb_ary_entry($input, 3));
-   }   
-   $1 = quat;
-}
-%typemap(freearg)  Ogre::Quaternion*, Ogre::Quaternion&amp;,
-   const Ogre::Quaternion*, const Ogre::Quaternion&amp; 
-&quot;   delete $1;&quot;
-
-
-
-
-%typemap(out) Ogre::Quaternion, const Ogre::Quaternion {
-   Degree angle;
-   Vector3 axis;
-   
-   $1.ToAngleAxis(angle, axis);
-   
-   VALUE arrAxis = rb_ary_new();
-   rb_ary_push(arrAxis, rb_float_new(axis.x));
-   rb_ary_push(arrAxis, rb_float_new(axis.y));
-   rb_ary_push(arrAxis, rb_float_new(axis.z));
-   VALUE rval = rb_ary_new();
-   rb_ary_push(rval, arrAxis);
-   rb_ary_push(rval, rb_float_new(angle.valueDegrees()));
-   
-   $result = rval;
-}
-
-%typemap(out) Ogre::Quaternion*, const Ogre::Quaternion*, const Ogre::Quaternion&amp;, Ogre::Quaternion&amp; {
-   Degree angle;
-   Vector3 axis;
-   
-   $1-&gt;ToAngleAxis(angle, axis);
-   
-   VALUE arrAxis = rb_ary_new();
-   rb_ary_push(arrAxis, rb_float_new(axis.x));
-   rb_ary_push(arrAxis, rb_float_new(axis.y));
-   rb_ary_push(arrAxis, rb_float_new(axis.z));
-   VALUE rval = rb_ary_new();
-   rb_ary_push(rval, arrAxis);
-   rb_ary_push(rval, rb_float_new(angle.valueDegrees()));
-   
-   $result = rval;
-} 
-
-

Added: rl/trunk/engine/script/swig/TypeOgreQuaternion.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreQuaternion.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeOgreQuaternion.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,191 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+/* Typemaps fuer Quaternion.
+ * Ein Quaternion wird auf ein Array aus einem 3-elementigen Array 
+ * f&#252;r die Rotationsachse und einem Wert f&#252;r den Winkel abgebildet
+ * 
+ */
+
+%typemap(typecheck) Ogre::Quaternion, const Ogre::Quaternion&amp; {
+		if (TYPE($input) == T_ARRAY)
+		{
+			int length = RARRAY($input)-&gt;len;
+			if (length == 2)
+			{
+				VALUE entry0 = rb_ary_entry($input, 0);
+				VALUE entry1 = rb_ary_entry($input, 1);
+				if ((TYPE(entry1) == T_FLOAT || TYPE(entry1) == T_FIXNUM)
+					&amp;&amp; TYPE(entry0) == T_ARRAY 
+					&amp;&amp; RARRAY(entry0)-&gt;len == 3)
+				{
+					$1 = 1;
+				}
+				else
+				{
+					$1 = 0;
+				}
+			}
+			else if (length == 3 || length == 4)
+			{
+				$1 = 1;
+				
+				for (int i = 0; i &lt; length; i++)
+				{
+					if (TYPE(rb_ary_entry($input, i)) != T_FLOAT 
+					    &amp;&amp; TYPE(rb_ary_entry($input, i)) != T_FIXNUM)
+					{
+						$1 = 0;
+						break;
+					}
+				}
+			}
+			else
+			{
+				$1 = 0;
+			}
+		}
+		else
+		{
+			$1 = 0;
+		}
+}
+
+%typemap(in) Ogre::Quaternion, const Ogre::Quaternion
+{
+   Ogre::Quaternion quat;
+   
+   if (RARRAY($input)-&gt;len == 2)
+   {
+	   VALUE axisVal = rb_ary_entry($input, 0);
+	   Ogre::Vector3 axis(
+				NUM2DBL(rb_ary_entry(axisVal, 0)), 
+				NUM2DBL(rb_ary_entry(axisVal, 1)),
+				NUM2DBL(rb_ary_entry(axisVal, 2)));
+
+	   double angle = NUM2DBL(rb_ary_entry($input, 1));
+	      
+	   quat.FromAngleAxis(Ogre::Degree(angle), axis);
+   }
+   else if (RARRAY($input)-&gt;len == 3)
+   {
+	   Quaternion rotX, rotY, rotZ;
+        rotX.FromAngleAxis(
+			Ogre::Degree(NUM2DBL(rb_ary_entry($input, 0))), 
+			Ogre::Vector3::UNIT_X);
+        rotY.FromAngleAxis(
+			Ogre::Degree(NUM2DBL(rb_ary_entry($input, 1))), 
+			Ogre::Vector3::UNIT_Y);
+        rotZ.FromAngleAxis(
+			Ogre::Degree(NUM2DBL(rb_ary_entry($input, 2))), 
+			Ogre::Vector3::UNIT_Z);
+	   
+	   quat = rotX * rotY * rotZ;
+	   quat.normalise();
+   }
+   else if (RARRAY($input)-&gt;len == 4)
+   {
+	   quat.w = NUM2DBL(rb_ary_entry($input, 0));
+	   quat.x = NUM2DBL(rb_ary_entry($input, 1));
+	   quat.y = NUM2DBL(rb_ary_entry($input, 2));
+	   quat.z = NUM2DBL(rb_ary_entry($input, 3));
+   }
+   $1 = quat;
+}
+
+%typemap(in) Ogre::Quaternion*, Ogre::Quaternion&amp;,
+   const Ogre::Quaternion*, const Ogre::Quaternion&amp;
+{
+   Ogre::Quaternion* quat = new Ogre::Quaternion();
+   if (RARRAY($input)-&gt;len == 2)
+   {
+	   VALUE axisVal = rb_ary_entry($input, 0);
+	   Ogre::Vector3 axis(
+				NUM2DBL(rb_ary_entry(axisVal, 0)), 
+				NUM2DBL(rb_ary_entry(axisVal, 1)),
+				NUM2DBL(rb_ary_entry(axisVal, 2)));
+
+	   double angle = NUM2DBL(rb_ary_entry($input, 1));
+	      
+	   quat-&gt;FromAngleAxis(Ogre::Degree(angle), axis);
+   }
+   else if (RARRAY($input)-&gt;len == 3)
+   {
+	   Quaternion rotX, rotY, rotZ;
+        rotX.FromAngleAxis(
+			Ogre::Degree(NUM2DBL(rb_ary_entry($input, 0))), 
+			Ogre::Vector3::UNIT_X);
+        rotY.FromAngleAxis(
+			Ogre::Degree(NUM2DBL(rb_ary_entry($input, 1))), 
+			Ogre::Vector3::UNIT_Y);
+        rotZ.FromAngleAxis(
+			Ogre::Degree(NUM2DBL(rb_ary_entry($input, 2))), 
+			Ogre::Vector3::UNIT_Z);
+	   
+	   *quat = rotX * rotY * rotZ;
+	   quat-&gt;normalise();
+   }
+   else if (RARRAY($input)-&gt;len == 4)
+   {
+	   quat-&gt;w = NUM2DBL(rb_ary_entry($input, 0));
+	   quat-&gt;x = NUM2DBL(rb_ary_entry($input, 1));
+	   quat-&gt;y = NUM2DBL(rb_ary_entry($input, 2));
+	   quat-&gt;z = NUM2DBL(rb_ary_entry($input, 3));
+   }   
+   $1 = quat;
+}
+%typemap(freearg)  Ogre::Quaternion*, Ogre::Quaternion&amp;,
+   const Ogre::Quaternion*, const Ogre::Quaternion&amp; 
+&quot;   delete $1;&quot;
+
+
+
+
+%typemap(out) Ogre::Quaternion, const Ogre::Quaternion {
+   Degree angle;
+   Vector3 axis;
+   
+   $1.ToAngleAxis(angle, axis);
+   
+   VALUE arrAxis = rb_ary_new();
+   rb_ary_push(arrAxis, rb_float_new(axis.x));
+   rb_ary_push(arrAxis, rb_float_new(axis.y));
+   rb_ary_push(arrAxis, rb_float_new(axis.z));
+   VALUE rval = rb_ary_new();
+   rb_ary_push(rval, arrAxis);
+   rb_ary_push(rval, rb_float_new(angle.valueDegrees()));
+   
+   $result = rval;
+}
+
+%typemap(out) Ogre::Quaternion*, const Ogre::Quaternion*, const Ogre::Quaternion&amp;, Ogre::Quaternion&amp; {
+   Degree angle;
+   Vector3 axis;
+   
+   $1-&gt;ToAngleAxis(angle, axis);
+   
+   VALUE arrAxis = rb_ary_new();
+   rb_ary_push(arrAxis, rb_float_new(axis.x));
+   rb_ary_push(arrAxis, rb_float_new(axis.y));
+   rb_ary_push(arrAxis, rb_float_new(axis.z));
+   VALUE rval = rb_ary_new();
+   rb_ary_push(rval, arrAxis);
+   rb_ary_push(rval, rb_float_new(angle.valueDegrees()));
+   
+   $result = rval;
+} 
+
+


Property changes on: rl/trunk/engine/script/swig/TypeOgreQuaternion.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/TypeOgreRadian.inc
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreRadian.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeOgreRadian.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,49 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-/* Radian / Degree all Ruby Values are interpreted as DEGREE! */
-%typemap(typecheck) Ogre::Radian, const Ogre::Radian&amp; = double;
-
-%typemap(in) Ogre::Radian, const Ogre::Radian, Ogre::Radian&amp;, const Ogre::Radian&amp; {
-    if (TYPE($input) == T_FLOAT) {
-		$1 = Ogre::Degree(RFLOAT($input)-&gt;value);
-    } else if (TYPE($input) == T_FIXNUM) {
-		$1 = Ogre::Degree(FIX2INT($input));
-    } else {
-        throw Swig::DirectorTypeMismatchException(&quot;float or fixnum expected&quot;);
-    }
-}
-%typemap(in) Ogre::Radian*, const Ogre::Radian*, Ogre::Radian&amp;, const Ogre::Radian&amp; {
-    if (TYPE($input) == T_FLOAT) {
-		$1 = new Ogre::Radian(Ogre::Degree(RFLOAT($input)-&gt;value));
-    } else if (TYPE($input) == T_FIXNUM) {
-		$1 = new Ogre::Radian(Ogre::Degree(FIX2INT($input)));
-    } else {
-        throw Swig::DirectorTypeMismatchException(&quot;float or fixnum expected&quot;);
-    }
-}
-
-%typemap(freearg) Ogre::Radian*, const Ogre::Radian*, Ogre::Radian&amp;, const Ogre::Radian&amp; 
-&quot;   delete $1;&quot;
-
-%typemap(out) Ogre::Radian, const Ogre::Radian {
-     $result = rb_float_new($1.valueDegrees());
-}
-%typemap(out) Ogre::Radian&amp;, const Ogre::Radian&amp; {
-     $result = rb_float_new($1-&gt;valueDegrees());
-}
-
-

Added: rl/trunk/engine/script/swig/TypeOgreRadian.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreRadian.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeOgreRadian.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,49 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+/* Radian / Degree all Ruby Values are interpreted as DEGREE! */
+%typemap(typecheck) Ogre::Radian, const Ogre::Radian&amp; = double;
+
+%typemap(in) Ogre::Radian, const Ogre::Radian, Ogre::Radian&amp;, const Ogre::Radian&amp; {
+    if (TYPE($input) == T_FLOAT) {
+		$1 = Ogre::Degree(RFLOAT($input)-&gt;value);
+    } else if (TYPE($input) == T_FIXNUM) {
+		$1 = Ogre::Degree(FIX2INT($input));
+    } else {
+        throw Swig::DirectorTypeMismatchException(&quot;float or fixnum expected&quot;);
+    }
+}
+%typemap(in) Ogre::Radian*, const Ogre::Radian*, Ogre::Radian&amp;, const Ogre::Radian&amp; {
+    if (TYPE($input) == T_FLOAT) {
+		$1 = new Ogre::Radian(Ogre::Degree(RFLOAT($input)-&gt;value));
+    } else if (TYPE($input) == T_FIXNUM) {
+		$1 = new Ogre::Radian(Ogre::Degree(FIX2INT($input)));
+    } else {
+        throw Swig::DirectorTypeMismatchException(&quot;float or fixnum expected&quot;);
+    }
+}
+
+%typemap(freearg) Ogre::Radian*, const Ogre::Radian*, Ogre::Radian&amp;, const Ogre::Radian&amp; 
+&quot;   delete $1;&quot;
+
+%typemap(out) Ogre::Radian, const Ogre::Radian {
+     $result = rb_float_new($1.valueDegrees());
+}
+%typemap(out) Ogre::Radian&amp;, const Ogre::Radian&amp; {
+     $result = rb_float_new($1-&gt;valueDegrees());
+}
+
+


Property changes on: rl/trunk/engine/script/swig/TypeOgreRadian.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/TypeOgreReal.inc
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreReal.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeOgreReal.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,37 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-/* Wrapping Real to ruby and back 
- for Real, const Real, Real&amp;, Real*, const Real*, const Real&amp;
-*/
-%typemap(typecheck) Ogre::Real, const Ogre::Real&amp; = double;
-    
-%typemap(in) Ogre::Real, const Ogre::Real 
-&quot;   $1 = NUM2DBL($input);&quot;
-
-%typemap(out) Ogre::Real, const Ogre::Real
-&quot;   $result = rb_float_new($1);&quot;
-
-%typemap(in) Ogre::Real*, Ogre::Real&amp;, const Ogre::Real*, const Ogre::Real&amp;
-&quot;   $1 = NUM2DBL($input);&quot;
-
-%typemap(out) Ogre::Real*, Ogre::Real&amp;,  const Ogre::Real*, const Ogre::Real&amp;
-&quot;   $result = rb_float_new(*$1);&quot;
-
-%typemap(freearg) Ogre::Real*, Ogre::Real&amp;,  const Ogre::Real*, const Ogre::Real&amp;
-&quot;   delete $1;&quot;
-
-

Added: rl/trunk/engine/script/swig/TypeOgreReal.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreReal.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeOgreReal.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,37 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+/* Wrapping Real to ruby and back 
+ for Real, const Real, Real&amp;, Real*, const Real*, const Real&amp;
+*/
+%typemap(typecheck) Ogre::Real, const Ogre::Real&amp; = double;
+    
+%typemap(in) Ogre::Real, const Ogre::Real 
+&quot;   $1 = NUM2DBL($input);&quot;
+
+%typemap(out) Ogre::Real, const Ogre::Real
+&quot;   $result = rb_float_new($1);&quot;
+
+%typemap(in) Ogre::Real*, Ogre::Real&amp;, const Ogre::Real*, const Ogre::Real&amp;
+&quot;   $1 = NUM2DBL($input);&quot;
+
+%typemap(out) Ogre::Real*, Ogre::Real&amp;,  const Ogre::Real*, const Ogre::Real&amp;
+&quot;   $result = rb_float_new(*$1);&quot;
+
+%typemap(freearg) Ogre::Real*, Ogre::Real&amp;,  const Ogre::Real*, const Ogre::Real&amp;
+&quot;   delete $1;&quot;
+
+


Property changes on: rl/trunk/engine/script/swig/TypeOgreReal.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/TypeOgreString.inc
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreString.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeOgreString.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,52 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-/* Wrapping Strings to ruby and back 
- for String, const String, String&amp;, String*, const String*, const String&amp;
-*/
-%typemap(typecheck) Ogre::String, const Ogre::String &amp; = char *;
-
-%typemap(in) Ogre::String, const Ogre::String
-&quot;
-    Check_Type($input, T_STRING);
-    $1 = Ogre::String(StringValuePtr($input));
-&quot;
-%typemap(out) Ogre::String, const Ogre::String
-&quot;
-     $result = rb_str_buf_new2($1.c_str());
-&quot;
-%typemap(in) Ogre::String*, Ogre::String&amp;, const Ogre::String*, const Ogre::String&amp;
-&quot;
-    Check_Type($input, T_STRING);
-    $1 = new Ogre::String(StringValuePtr($input));
-&quot;
-%typemap(freearg) Ogre::String*, Ogre::String&amp;, const Ogre::String*, const Ogre::String&amp;
-&quot;   delete $1;&quot;
-
-%typemap(out) Ogre::String*, Ogre::String&amp;, const Ogre::String*, const Ogre::String&amp;
-&quot;    $result = rb_str_buf_new2($1-&gt;c_str());&quot;
-
-%typemap(varout) Ogre::String, const Ogre::String
-&quot;    $result = rb_str_buf_new2($1.c_str());&quot;
-
-%typemap(directorin) Ogre::String*, const Ogre::String*
-&quot;    $input = rb_str_buf_new2($1-&gt;c_str());&quot;
-
-%typemap(directorin) Ogre::String, Ogre::String&amp;, const Ogre::String, const Ogre::String&amp;
-&quot;    $input = rb_str_buf_new2($1.c_str());&quot;
-
-%typemap(directorout) Ogre::String*, Ogre::String&amp;, const Ogre::String*, const Ogre::String&amp;
-&quot;    $result = new Ogre::String(StringValuePtr($1));&quot;

Added: rl/trunk/engine/script/swig/TypeOgreString.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreString.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeOgreString.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,52 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+/* Wrapping Strings to ruby and back 
+ for String, const String, String&amp;, String*, const String*, const String&amp;
+*/
+%typemap(typecheck) Ogre::String, const Ogre::String &amp; = char *;
+
+%typemap(in) Ogre::String, const Ogre::String
+&quot;
+    Check_Type($input, T_STRING);
+    $1 = Ogre::String(StringValuePtr($input));
+&quot;
+%typemap(out) Ogre::String, const Ogre::String
+&quot;
+     $result = rb_str_buf_new2($1.c_str());
+&quot;
+%typemap(in) Ogre::String*, Ogre::String&amp;, const Ogre::String*, const Ogre::String&amp;
+&quot;
+    Check_Type($input, T_STRING);
+    $1 = new Ogre::String(StringValuePtr($input));
+&quot;
+%typemap(freearg) Ogre::String*, Ogre::String&amp;, const Ogre::String*, const Ogre::String&amp;
+&quot;   delete $1;&quot;
+
+%typemap(out) Ogre::String*, Ogre::String&amp;, const Ogre::String*, const Ogre::String&amp;
+&quot;    $result = rb_str_buf_new2($1-&gt;c_str());&quot;
+
+%typemap(varout) Ogre::String, const Ogre::String
+&quot;    $result = rb_str_buf_new2($1.c_str());&quot;
+
+%typemap(directorin) Ogre::String*, const Ogre::String*
+&quot;    $input = rb_str_buf_new2($1-&gt;c_str());&quot;
+
+%typemap(directorin) Ogre::String, Ogre::String&amp;, const Ogre::String, const Ogre::String&amp;
+&quot;    $input = rb_str_buf_new2($1.c_str());&quot;
+
+%typemap(directorout) Ogre::String*, Ogre::String&amp;, const Ogre::String*, const Ogre::String&amp;
+&quot;    $result = new Ogre::String(StringValuePtr($1));&quot;


Property changes on: rl/trunk/engine/script/swig/TypeOgreString.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/TypeOgreStringVector.inc
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreStringVector.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeOgreStringVector.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,56 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-%typemap(freearg) Ogre::StringVector &amp;, const Ogre::StringVector &amp; {
-  delete $1;
-}
-
-%typemap(directorin) Ogre::StringVector &amp;, const Ogre::StringVector &amp; {
-  VALUE arr = rb_ary_new2($1-&gt;size()); 
-  StringVector::iterator i = $1-&gt;begin(), iend = $1-&gt;end();
-  for ( ; i!=iend; i++ )
-    rb_ary_push(arr, rb_str_new2(&amp;(*i)));
-  $result = arr;
-}
-%typemap(directorin) Ogre::StringVector, const Ogre::StringVector {
-  VALUE arr = rb_ary_new2($1.size()); 
-  StringVector::iterator i = $1.begin(), iend = $1.end();
-  for ( ; i!=iend; i++ )
-    rb_ary_push(arr, rb_str_new2(*i));
-  $result = arr;
-}
-
-%typemap(directorout) Ogre::StringVector , const Ogre::StringVector {
-  Check_Type($input, T_ARRAY);
-  Ogre::StringVector vec;
-  int len = RARRAY($input)-&gt;len;
-  for (int i=0; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
-    vec.push_back(Ogre::String(StringValuePtr(inst)));
-  }
-  $result = vec;
-}
-
-%typemap(directorout) Ogre::StringVector *, const Ogre::StringVector* , Ogre::StringVector &amp;, const Ogre::StringVector&amp; {
-  Check_Type($input, T_ARRAY);
-  Ogre::StringVector *vec = new Ogre::StringVector;
-  int len = RARRAY($input)-&gt;len;
-  for (int i=0; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
-    vec-&gt;push_back(Ogre::String(StringValuePtr(inst)));
-  }
-  $result = vec;
-}

Added: rl/trunk/engine/script/swig/TypeOgreStringVector.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreStringVector.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeOgreStringVector.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,56 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+%typemap(freearg) Ogre::StringVector &amp;, const Ogre::StringVector &amp; {
+  delete $1;
+}
+
+%typemap(directorin) Ogre::StringVector &amp;, const Ogre::StringVector &amp; {
+  VALUE arr = rb_ary_new2($1-&gt;size()); 
+  StringVector::iterator i = $1-&gt;begin(), iend = $1-&gt;end();
+  for ( ; i!=iend; i++ )
+    rb_ary_push(arr, rb_str_new2(&amp;(*i)));
+  $result = arr;
+}
+%typemap(directorin) Ogre::StringVector, const Ogre::StringVector {
+  VALUE arr = rb_ary_new2($1.size()); 
+  StringVector::iterator i = $1.begin(), iend = $1.end();
+  for ( ; i!=iend; i++ )
+    rb_ary_push(arr, rb_str_new2(*i));
+  $result = arr;
+}
+
+%typemap(directorout) Ogre::StringVector , const Ogre::StringVector {
+  Check_Type($input, T_ARRAY);
+  Ogre::StringVector vec;
+  int len = RARRAY($input)-&gt;len;
+  for (int i=0; i!=len; i++) {
+    VALUE inst = rb_ary_entry($input, i);
+    vec.push_back(Ogre::String(StringValuePtr(inst)));
+  }
+  $result = vec;
+}
+
+%typemap(directorout) Ogre::StringVector *, const Ogre::StringVector* , Ogre::StringVector &amp;, const Ogre::StringVector&amp; {
+  Check_Type($input, T_ARRAY);
+  Ogre::StringVector *vec = new Ogre::StringVector;
+  int len = RARRAY($input)-&gt;len;
+  for (int i=0; i!=len; i++) {
+    VALUE inst = rb_ary_entry($input, i);
+    vec-&gt;push_back(Ogre::String(StringValuePtr(inst)));
+  }
+  $result = vec;
+}


Property changes on: rl/trunk/engine/script/swig/TypeOgreStringVector.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/TypeOgreVector3.inc
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreVector3.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeOgreVector3.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,87 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-/* Typemaps fuer Vector3.
- * Ein Vector3 wird einfach auf ein dreielementiges Array abgebildet.
- * 
- */
-
-%typecheck(SWIG_TYPECHECK_DOUBLE_ARRAY) Ogre::Vector3, const Ogre::Vector3, Ogre::Vector3*, Ogre::Vector3&amp;,
-   const Ogre::Vector3*, const Ogre::Vector3&amp;
-{
-   $1 = TYPE($input) == T_ARRAY &amp;&amp; RARRAY($input)-&gt;len == 3 ? 1 : 0;
-}
- 
-%typemap(in) Ogre::Vector3, const Ogre::Vector3
-{
-   Ogre::Vector3 vec(0.0, 0.0, 0.0);
-   int length = RARRAY($input)-&gt;len;
-   VALUE* it = RARRAY($input)-&gt;ptr;
-   if (length &gt; 0) {
-      vec.x = NUM2DBL(*it);
-      it++;
-   }
-   if (length &gt; 1) {
-      vec.y = NUM2DBL(*it);
-      it++;
-   }
-   if (length &gt; 2) {
-      vec.z = NUM2DBL(*it);
-   }
-   $1 = vec;
-}
-
-%typemap(in) Ogre::Vector3*, Ogre::Vector3&amp;,
-   const Ogre::Vector3*, const Ogre::Vector3&amp;
-{
-   Ogre::Vector3* vec = new Ogre::Vector3(0.0, 0.0, 0.0);
-   int length = RARRAY($input)-&gt;len;
-   VALUE* it = RARRAY($input)-&gt;ptr;
-   if (length &gt; 0) {
-      vec-&gt;x = NUM2DBL(*it);
-      it++;
-   }
-   if (length &gt; 1) {
-      vec-&gt;y = NUM2DBL(*it);
-      it++;
-   }
-   if (length &gt; 2) {
-      vec-&gt;z = NUM2DBL(*it);
-   }
-   $1 = vec;
-}
-%typemap(freearg) Ogre::Vector3*, Ogre::Vector3&amp;,
-   const Ogre::Vector3*, const Ogre::Vector3&amp; {
-   delete $1;
-}
-
-%typemap(out) Ogre::Vector3, const Ogre::Vector3 {
-   VALUE rval = rb_ary_new();
-   rb_ary_push(rval, rb_float_new($1.x));
-   rb_ary_push(rval, rb_float_new($1.y));
-   rb_ary_push(rval, rb_float_new($1.z));
-   $result = rval;
-}
-
-%typemap(out) Ogre::Vector3*, const Ogre::Vector3*, const Ogre::Vector3&amp;, Ogre::Vector&amp; {
-   VALUE rval = rb_ary_new();
-   rb_ary_push(rval, rb_float_new($1-&gt;x));
-   rb_ary_push(rval, rb_float_new($1-&gt;y));
-   rb_ary_push(rval, rb_float_new($1-&gt;z));
-   $result = rval;
-} 
-
-

Added: rl/trunk/engine/script/swig/TypeOgreVector3.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreVector3.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeOgreVector3.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,87 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+/* Typemaps fuer Vector3.
+ * Ein Vector3 wird einfach auf ein dreielementiges Array abgebildet.
+ * 
+ */
+
+%typecheck(SWIG_TYPECHECK_DOUBLE_ARRAY) Ogre::Vector3, const Ogre::Vector3, Ogre::Vector3*, Ogre::Vector3&amp;,
+   const Ogre::Vector3*, const Ogre::Vector3&amp;
+{
+   $1 = TYPE($input) == T_ARRAY &amp;&amp; RARRAY($input)-&gt;len == 3 ? 1 : 0;
+}
+ 
+%typemap(in) Ogre::Vector3, const Ogre::Vector3
+{
+   Ogre::Vector3 vec(0.0, 0.0, 0.0);
+   int length = RARRAY($input)-&gt;len;
+   VALUE* it = RARRAY($input)-&gt;ptr;
+   if (length &gt; 0) {
+      vec.x = NUM2DBL(*it);
+      it++;
+   }
+   if (length &gt; 1) {
+      vec.y = NUM2DBL(*it);
+      it++;
+   }
+   if (length &gt; 2) {
+      vec.z = NUM2DBL(*it);
+   }
+   $1 = vec;
+}
+
+%typemap(in) Ogre::Vector3*, Ogre::Vector3&amp;,
+   const Ogre::Vector3*, const Ogre::Vector3&amp;
+{
+   Ogre::Vector3* vec = new Ogre::Vector3(0.0, 0.0, 0.0);
+   int length = RARRAY($input)-&gt;len;
+   VALUE* it = RARRAY($input)-&gt;ptr;
+   if (length &gt; 0) {
+      vec-&gt;x = NUM2DBL(*it);
+      it++;
+   }
+   if (length &gt; 1) {
+      vec-&gt;y = NUM2DBL(*it);
+      it++;
+   }
+   if (length &gt; 2) {
+      vec-&gt;z = NUM2DBL(*it);
+   }
+   $1 = vec;
+}
+%typemap(freearg) Ogre::Vector3*, Ogre::Vector3&amp;,
+   const Ogre::Vector3*, const Ogre::Vector3&amp; {
+   delete $1;
+}
+
+%typemap(out) Ogre::Vector3, const Ogre::Vector3 {
+   VALUE rval = rb_ary_new();
+   rb_ary_push(rval, rb_float_new($1.x));
+   rb_ary_push(rval, rb_float_new($1.y));
+   rb_ary_push(rval, rb_float_new($1.z));
+   $result = rval;
+}
+
+%typemap(out) Ogre::Vector3*, const Ogre::Vector3*, const Ogre::Vector3&amp;, Ogre::Vector&amp; {
+   VALUE rval = rb_ary_new();
+   rb_ary_push(rval, rb_float_new($1-&gt;x));
+   rb_ary_push(rval, rb_float_new($1-&gt;y));
+   rb_ary_push(rval, rb_float_new($1-&gt;z));
+   $result = rval;
+} 
+
+


Property changes on: rl/trunk/engine/script/swig/TypeOgreVector3.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/TypeRlCeGuiString.inc
===================================================================
--- rl/trunk/engine/script/swig/TypeRlCeGuiString.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeRlCeGuiString.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,58 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-/* Wrapping rl::CeGuiStrings to ruby and back 
- for CeGuiString
-*/
-%typemap(typecheck) rl::CeGuiString, const rl::CeGuiString, rl::CeGuiString*, rl::CeGuiString&amp;, const rl::CeGuiString*, const rl::CeGuiString&amp; = char *;
-
-%typemap(in) rl::CeGuiString, const rl::CeGuiString 
-	&quot;Check_Type($input, T_STRING);
-    $1 = rl::CeGuiString(
-		reinterpret_cast&lt;CEGUI::utf8*&gt;(StringValuePtr($input)));&quot;
-
-%typemap(out) rl::CeGuiString, const rl::CeGuiString 
-     &quot;$result = rb_str_buf_new2($1.c_str());&quot;
-
-
-%typemap(in) rl::CeGuiString*, rl::CeGuiString&amp;, const rl::CeGuiString*, const rl::CeGuiString&amp; 
-    &quot;Check_Type($input, T_STRING);
-    $1 = new rl::CeGuiString(
-		reinterpret_cast&lt;CEGUI::utf8*&gt;(StringValuePtr($input)));&quot;
-%typemap(freearg) rl::CeGuiString*, rl::CeGuiString&amp;, const rl::CeGuiString*, const rl::CeGuiString&amp;  {
-   delete $1;
-}
-%typemap(out) rl::CeGuiString*, rl::CeGuiString&amp;,  const rl::CeGuiString*, const rl::CeGuiString&amp; 
-     &quot;$result = rb_str_buf_new2($1-&gt;c_str());&quot;
-
-%typemap(varout) rl::CeGuiString, const rl::CeGuiString 
-     &quot;$result = rb_str_buf_new2($1.c_str());&quot;
-
-%typemap(directorin) rl::CeGuiString, const rl::CeGuiString &amp;, rl::CeGuiString &amp; 
-	&quot;$input = rb_str_buf_new2($1.c_str());&quot;
-
-%typemap(directorin) rl::CeGuiString *, const rl::CeGuiString * 
-	&quot;$input = rb_str_buf_new2($1-&gt;c_str());&quot;
-
-%typemap(directorout) rl::CeGuiString, const rl::CeGuiString 
-    &quot;$result = rl::CeGuiString(
-		reinterpret_cast&lt;CEGUI::utf8*&gt;(StringValuePtr($input)));&quot;
-
-%typemap(directorout) const rl::CeGuiString &amp;, rl::CeGuiString&amp;  
-    &quot;$result = new rl::CeGuiString();
-     $result-&gt;append( 
-		reinterpret_cast&lt;CEGUI::utf8*&gt;(StringValuePtr($input)) );&quot;
-

Added: rl/trunk/engine/script/swig/TypeRlCeGuiString.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlCeGuiString.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeRlCeGuiString.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,58 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+/* Wrapping rl::CeGuiStrings to ruby and back 
+ for CeGuiString
+*/
+%typemap(typecheck) rl::CeGuiString, const rl::CeGuiString, rl::CeGuiString*, rl::CeGuiString&amp;, const rl::CeGuiString*, const rl::CeGuiString&amp; = char *;
+
+%typemap(in) rl::CeGuiString, const rl::CeGuiString 
+	&quot;Check_Type($input, T_STRING);
+    $1 = rl::CeGuiString(
+		reinterpret_cast&lt;CEGUI::utf8*&gt;(StringValuePtr($input)));&quot;
+
+%typemap(out) rl::CeGuiString, const rl::CeGuiString 
+     &quot;$result = rb_str_buf_new2($1.c_str());&quot;
+
+
+%typemap(in) rl::CeGuiString*, rl::CeGuiString&amp;, const rl::CeGuiString*, const rl::CeGuiString&amp; 
+    &quot;Check_Type($input, T_STRING);
+    $1 = new rl::CeGuiString(
+		reinterpret_cast&lt;CEGUI::utf8*&gt;(StringValuePtr($input)));&quot;
+%typemap(freearg) rl::CeGuiString*, rl::CeGuiString&amp;, const rl::CeGuiString*, const rl::CeGuiString&amp;  {
+   delete $1;
+}
+%typemap(out) rl::CeGuiString*, rl::CeGuiString&amp;,  const rl::CeGuiString*, const rl::CeGuiString&amp; 
+     &quot;$result = rb_str_buf_new2($1-&gt;c_str());&quot;
+
+%typemap(varout) rl::CeGuiString, const rl::CeGuiString 
+     &quot;$result = rb_str_buf_new2($1.c_str());&quot;
+
+%typemap(directorin) rl::CeGuiString, const rl::CeGuiString &amp;, rl::CeGuiString &amp; 
+	&quot;$input = rb_str_buf_new2($1.c_str());&quot;
+
+%typemap(directorin) rl::CeGuiString *, const rl::CeGuiString * 
+	&quot;$input = rb_str_buf_new2($1-&gt;c_str());&quot;
+
+%typemap(directorout) rl::CeGuiString, const rl::CeGuiString 
+    &quot;$result = rl::CeGuiString(
+		reinterpret_cast&lt;CEGUI::utf8*&gt;(StringValuePtr($input)));&quot;
+
+%typemap(directorout) const rl::CeGuiString &amp;, rl::CeGuiString&amp;  
+    &quot;$result = new rl::CeGuiString();
+     $result-&gt;append( 
+		reinterpret_cast&lt;CEGUI::utf8*&gt;(StringValuePtr($input)) );&quot;
+


Property changes on: rl/trunk/engine/script/swig/TypeRlCeGuiString.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.inc
===================================================================
--- rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,57 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-%typemap(freearg) rl::CeGuiStringVector &amp;, const rl::CeGuiStringVector &amp; 
-&quot;  delete $1;&quot;
-
-
-%typemap(directorin) rl::CeGuiStringVector &amp;, const rl::CeGuiStringVector &amp; {
-  VALUE arr = rb_ary_new2($1-&gt;size()); 
-  CeGuiStringVector::iterator i = $1-&gt;begin(), iend = $1-&gt;end();
-  for ( ; i!=iend; i++ )
-    rb_ary_push(arr, rb_str_new2(&amp;(*i)));
-  $result = arr;
-}
-
-%typemap(directorin) rl::CeGuiStringVector, const rl::CeGuiStringVector {
-  VALUE arr = rb_ary_new2($1.size()); 
-  CeGuiStringVector::iterator i = $1.begin(), iend = $1.end();
-  for ( ; i!=iend; i++ )
-    rb_ary_push(arr, rb_str_new2(*i));
-  $result = arr;
-}
-
-%typemap(directorout) rl::CeGuiStringVector , const rl::CeGuiStringVector {
-  Check_Type($input, T_ARRAY);
-  rl::CeGuiStringVector vec;
-  int len = RARRAY($input)-&gt;len;
-  for (int i=0; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
-    vec.push_back(rl::CeGuiString(StringValuePtr(inst)));
-  }
-  $result = vec;
-}
-
-%typemap(directorout) rl::CeGuiStringVector &amp;, const rl::CeGuiStringVector&amp; {
-  Check_Type($input, T_ARRAY);
-  rl::CeGuiStringVector *vec = new rl::CeGuiStringVector;
-  int len = RARRAY($input)-&gt;len;
-  for (int i=0; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
-    vec-&gt;push_back(rl::CeGuiString(StringValuePtr(inst)));
-  }
-  $result = vec;
-}

Added: rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,57 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+%typemap(freearg) rl::CeGuiStringVector &amp;, const rl::CeGuiStringVector &amp; 
+&quot;  delete $1;&quot;
+
+
+%typemap(directorin) rl::CeGuiStringVector &amp;, const rl::CeGuiStringVector &amp; {
+  VALUE arr = rb_ary_new2($1-&gt;size()); 
+  CeGuiStringVector::iterator i = $1-&gt;begin(), iend = $1-&gt;end();
+  for ( ; i!=iend; i++ )
+    rb_ary_push(arr, rb_str_new2(&amp;(*i)));
+  $result = arr;
+}
+
+%typemap(directorin) rl::CeGuiStringVector, const rl::CeGuiStringVector {
+  VALUE arr = rb_ary_new2($1.size()); 
+  CeGuiStringVector::iterator i = $1.begin(), iend = $1.end();
+  for ( ; i!=iend; i++ )
+    rb_ary_push(arr, rb_str_new2(*i));
+  $result = arr;
+}
+
+%typemap(directorout) rl::CeGuiStringVector , const rl::CeGuiStringVector {
+  Check_Type($input, T_ARRAY);
+  rl::CeGuiStringVector vec;
+  int len = RARRAY($input)-&gt;len;
+  for (int i=0; i!=len; i++) {
+    VALUE inst = rb_ary_entry($input, i);
+    vec.push_back(rl::CeGuiString(StringValuePtr(inst)));
+  }
+  $result = vec;
+}
+
+%typemap(directorout) rl::CeGuiStringVector &amp;, const rl::CeGuiStringVector&amp; {
+  Check_Type($input, T_ARRAY);
+  rl::CeGuiStringVector *vec = new rl::CeGuiStringVector;
+  int len = RARRAY($input)-&gt;len;
+  for (int i=0; i!=len; i++) {
+    VALUE inst = rb_ary_entry($input, i);
+    vec-&gt;push_back(rl::CeGuiString(StringValuePtr(inst)));
+  }
+  $result = vec;
+}


Property changes on: rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/TypeRlProperty.inc
===================================================================
--- rl/trunk/engine/script/swig/TypeRlProperty.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeRlProperty.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,204 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-%{
-namespace rl {
-
-Property convertValueToProperty(VALUE input)
-{
-	Property rval;
-	if (TYPE(input) == T_FLOAT)
-    {
-	    rval.setValue(Ogre::Real(NUM2DBL(input)));
-    }
-    else if (TYPE(input) == T_FIXNUM)
-    {
-        rval.setValue(FIX2INT(input));
-    }
-    else if (TYPE(input) == T_FIXNUM)
-    {
-        rval.setValue(FIX2INT(input));
-    }
-    else if (TYPE(input) == T_TRUE)
-    {
-        rval.setValue(true);
-    }
-    else if (TYPE(input) == T_FALSE)
-    {
-        rval.setValue(false);
-    }
-    else if (TYPE(input) == T_STRING) 
-    {
-        rval.setValue(rl::CeGuiString(StringValuePtr(input)));
-    }
-    else if (TYPE(input) == T_ARRAY)
-    {
-		int length = RARRAY(input)-&gt;len;
-		if (length &gt; 0)
-		{
-			VALUE firstVal = rb_ary_entry(input, 0);
-			if (length == 3 
-				&amp;&amp; (TYPE(firstVal) == T_FLOAT || TYPE(firstVal) == T_FIXNUM))
-			{
-				Ogre::Vector3 vec;
-				vec.x = NUM2DBL(rb_ary_entry(input, 0));
-				vec.y = NUM2DBL(rb_ary_entry(input, 1));
-				vec.z = NUM2DBL(rb_ary_entry(input, 2));
-				rval.setValue(vec);
-			}
-			else if (length == 4 
-				&amp;&amp; (TYPE(firstVal) == T_FLOAT || TYPE(firstVal) == T_FIXNUM))
-			{
-				Ogre::Quaternion quat;
-				quat.w = NUM2DBL(rb_ary_entry(input, 0));
-				quat.x = NUM2DBL(rb_ary_entry(input, 1));
-				quat.y = NUM2DBL(rb_ary_entry(input, 2));
-				quat.z = NUM2DBL(rb_ary_entry(input, 3));
-				rval.setValue(quat);
-			}
-			else // Array of Properties
-			{
-				std::vector&lt;Property&gt; vec;
-				for (int idx = 0; idx &lt; length; idx++)
-				{
-					vec.push_back(rl::convertValueToProperty(rb_ary_entry(input, 0)));
-				}
-				rval.setValue(vec);
-			}
-        }
-    }
-    
-    return rval;
-}
-
-VALUE convertPropertyToValue(Property input)
-{
-	if (input.isString())
-    {
-        return rb_str_buf_new2(input.toString().c_str());
-    }
-    else if (input.isInt())
-    {
-        return rb_int_new(input.toInt());
-    }
-    else if (input.isReal())
-    {
-	    return rb_float_new(input.toReal());
-    }
-    else if (input.isBool())
-    {
-        bool boolValue = input.toBool();
-        if (boolValue)
-        {
-            return Qtrue;
-        }
-        else
-        {
-            return Qfalse;
-        }
-    }
-    else if (input.isVector3())
-    {
-        Ogre::Vector3 vec = input.toVector3();
-        VALUE rval = rb_ary_new();
-        rb_ary_push(rval, rb_float_new(vec.x));
-        rb_ary_push(rval, rb_float_new(vec.y));
-        rb_ary_push(rval, rb_float_new(vec.z));
-        return rval;
-    }
-    else if (input.isQuaternion())
-    {
-        Ogre::Quaternion vec = input.toQuaternion();
-        VALUE rval = rb_ary_new();
-        rb_ary_push(rval, rb_float_new(vec.w));
-        rb_ary_push(rval, rb_float_new(vec.x));
-        rb_ary_push(rval, rb_float_new(vec.y));
-        rb_ary_push(rval, rb_float_new(vec.z));
-        return rval;
-    }
-    else if (input.isArray())
-    {
-		std::vector&lt;Property&gt; vec = input.toArray();
-		VALUE rval = rb_ary_new();
-		for (std::vector&lt;Property&gt;::const_iterator it = vec.begin();
-			it != vec.end(); it++)
-		{
-			rb_ary_push(rval, rl::convertPropertyToValue(*it));
-		}
-		return rval;
-    }
-
-    return Qnil;
-}
-
-}
-%}
-
-
-%typemap(typecheck) rl::Property, const rl::Property, rl::Property&amp;, const rl::Property&amp;, rl::Property*, const rl::Property* 
-{
-    if (TYPE($input) == T_FLOAT 
-        || TYPE($input) == T_FIXNUM 
-	    || TYPE($input) == T_STRING
-	    || TYPE($input) == T_TRUE 
-	    || TYPE($input) == T_FALSE
-	    || TYPE($input == T_ARRAY) 
-    {
-        return 1;
-    }
-    
-    return 0;
-}
-
-%typemap(in) rl::Property, const rl::Property
-&quot;   
-	$1 = rl::convertValueToProperty($input);
-&quot;
-
-%typemap(in) rl::Property&amp;, const rl::Property&amp;, rl::Property*, const rl::Property*
-&quot;   
-	$1 = new rl::Property(rl::convertValueToProperty($input));
-&quot;
-
-
-%typemap(out) rl::Property, const rl::Property
-&quot;   
-	$result = rl::convertPropertyToValue($1);
-&quot;
-
-
-%typemap(freearg) rl::Property*, rl::Property&amp;, const rl::Property*, const rl::Property&amp;
-&quot;   delete $1;&quot;
-
-%typemap(directorout) rl::Property, const rl::Property, rl::Property&amp;, const rl::Property&amp;
-&quot;   
-	$result = rl::convertValueToProperty($1);
-&quot;
-
-%typemap(directorout) rl::Property*, const rl::Property*
-&quot;   
-	$result = new rl::Property(rl::convertValueToProperty($1));
-&quot;
-
-%typemap(directorin) rl::Property, const rl::Property, rl::Property&amp;, const rl::Property&amp;
-&quot;   
-	$input = rl::convertPropertyToValue($1);
-&quot;
-
-%typemap(directorin) rl::Property*, const rl::Property*
-&quot;   	
-	$input = rl::convertPropertyToValue(*$1);
-&quot;
\ No newline at end of file

Added: rl/trunk/engine/script/swig/TypeRlProperty.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlProperty.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeRlProperty.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,204 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+%{
+namespace rl {
+
+Property convertValueToProperty(VALUE input)
+{
+	Property rval;
+	if (TYPE(input) == T_FLOAT)
+    {
+	    rval.setValue(Ogre::Real(NUM2DBL(input)));
+    }
+    else if (TYPE(input) == T_FIXNUM)
+    {
+        rval.setValue(FIX2INT(input));
+    }
+    else if (TYPE(input) == T_FIXNUM)
+    {
+        rval.setValue(FIX2INT(input));
+    }
+    else if (TYPE(input) == T_TRUE)
+    {
+        rval.setValue(true);
+    }
+    else if (TYPE(input) == T_FALSE)
+    {
+        rval.setValue(false);
+    }
+    else if (TYPE(input) == T_STRING) 
+    {
+        rval.setValue(rl::CeGuiString(StringValuePtr(input)));
+    }
+    else if (TYPE(input) == T_ARRAY)
+    {
+		int length = RARRAY(input)-&gt;len;
+		if (length &gt; 0)
+		{
+			VALUE firstVal = rb_ary_entry(input, 0);
+			if (length == 3 
+				&amp;&amp; (TYPE(firstVal) == T_FLOAT || TYPE(firstVal) == T_FIXNUM))
+			{
+				Ogre::Vector3 vec;
+				vec.x = NUM2DBL(rb_ary_entry(input, 0));
+				vec.y = NUM2DBL(rb_ary_entry(input, 1));
+				vec.z = NUM2DBL(rb_ary_entry(input, 2));
+				rval.setValue(vec);
+			}
+			else if (length == 4 
+				&amp;&amp; (TYPE(firstVal) == T_FLOAT || TYPE(firstVal) == T_FIXNUM))
+			{
+				Ogre::Quaternion quat;
+				quat.w = NUM2DBL(rb_ary_entry(input, 0));
+				quat.x = NUM2DBL(rb_ary_entry(input, 1));
+				quat.y = NUM2DBL(rb_ary_entry(input, 2));
+				quat.z = NUM2DBL(rb_ary_entry(input, 3));
+				rval.setValue(quat);
+			}
+			else // Array of Properties
+			{
+				std::vector&lt;Property&gt; vec;
+				for (int idx = 0; idx &lt; length; idx++)
+				{
+					vec.push_back(rl::convertValueToProperty(rb_ary_entry(input, 0)));
+				}
+				rval.setValue(vec);
+			}
+        }
+    }
+    
+    return rval;
+}
+
+VALUE convertPropertyToValue(Property input)
+{
+	if (input.isString())
+    {
+        return rb_str_buf_new2(input.toString().c_str());
+    }
+    else if (input.isInt())
+    {
+        return rb_int_new(input.toInt());
+    }
+    else if (input.isReal())
+    {
+	    return rb_float_new(input.toReal());
+    }
+    else if (input.isBool())
+    {
+        bool boolValue = input.toBool();
+        if (boolValue)
+        {
+            return Qtrue;
+        }
+        else
+        {
+            return Qfalse;
+        }
+    }
+    else if (input.isVector3())
+    {
+        Ogre::Vector3 vec = input.toVector3();
+        VALUE rval = rb_ary_new();
+        rb_ary_push(rval, rb_float_new(vec.x));
+        rb_ary_push(rval, rb_float_new(vec.y));
+        rb_ary_push(rval, rb_float_new(vec.z));
+        return rval;
+    }
+    else if (input.isQuaternion())
+    {
+        Ogre::Quaternion vec = input.toQuaternion();
+        VALUE rval = rb_ary_new();
+        rb_ary_push(rval, rb_float_new(vec.w));
+        rb_ary_push(rval, rb_float_new(vec.x));
+        rb_ary_push(rval, rb_float_new(vec.y));
+        rb_ary_push(rval, rb_float_new(vec.z));
+        return rval;
+    }
+    else if (input.isArray())
+    {
+		std::vector&lt;Property&gt; vec = input.toArray();
+		VALUE rval = rb_ary_new();
+		for (std::vector&lt;Property&gt;::const_iterator it = vec.begin();
+			it != vec.end(); it++)
+		{
+			rb_ary_push(rval, rl::convertPropertyToValue(*it));
+		}
+		return rval;
+    }
+
+    return Qnil;
+}
+
+}
+%}
+
+
+%typemap(typecheck) rl::Property, const rl::Property, rl::Property&amp;, const rl::Property&amp;, rl::Property*, const rl::Property* 
+{
+    if (TYPE($input) == T_FLOAT 
+        || TYPE($input) == T_FIXNUM 
+	    || TYPE($input) == T_STRING
+	    || TYPE($input) == T_TRUE 
+	    || TYPE($input) == T_FALSE
+	    || TYPE($input == T_ARRAY) 
+    {
+        return 1;
+    }
+    
+    return 0;
+}
+
+%typemap(in) rl::Property, const rl::Property
+&quot;   
+	$1 = rl::convertValueToProperty($input);
+&quot;
+
+%typemap(in) rl::Property&amp;, const rl::Property&amp;, rl::Property*, const rl::Property*
+&quot;   
+	$1 = new rl::Property(rl::convertValueToProperty($input));
+&quot;
+
+
+%typemap(out) rl::Property, const rl::Property
+&quot;   
+	$result = rl::convertPropertyToValue($1);
+&quot;
+
+
+%typemap(freearg) rl::Property*, rl::Property&amp;, const rl::Property*, const rl::Property&amp;
+&quot;   delete $1;&quot;
+
+%typemap(directorout) rl::Property, const rl::Property, rl::Property&amp;, const rl::Property&amp;
+&quot;   
+	$result = rl::convertValueToProperty($1);
+&quot;
+
+%typemap(directorout) rl::Property*, const rl::Property*
+&quot;   
+	$result = new rl::Property(rl::convertValueToProperty($1));
+&quot;
+
+%typemap(directorin) rl::Property, const rl::Property, rl::Property&amp;, const rl::Property&amp;
+&quot;   
+	$input = rl::convertPropertyToValue($1);
+&quot;
+
+%typemap(directorin) rl::Property*, const rl::Property*
+&quot;   	
+	$input = rl::convertPropertyToValue(*$1);
+&quot;
\ No newline at end of file


Property changes on: rl/trunk/engine/script/swig/TypeRlProperty.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/TypeRlTripelInt.inc
===================================================================
--- rl/trunk/engine/script/swig/TypeRlTripelInt.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeRlTripelInt.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,80 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-/* IN Typemaps fuer Tripel&lt;int&gt;.
- * Ein Tripel wird einfach auf ein dreielementiges Array abgebildet.
- * 
- * Eine Laengenueberpruefung findet nicht statt.
- * Nil wird zu 0. Indizes &gt;= 3 werden ignoriert.
- * TODO eben das aendern
- */
-%typemap(in) Tripel&lt;int&gt;
-{
-   Check_Type($input, T_ARRAY);
-   Tripel&lt;int&gt; tripel(0, 0, 0);
-   int length = RARRAY($input)-&gt;len;
-   VALUE* it = RARRAY($input)-&gt;ptr;
-   if (length &gt; 0) {
-      tripel.first = FIX2INT(*it);
-      it++;
-   }
-   if (length &gt; 1) {
-      tripel.second = FIX2INT(*it);
-      it++;
-   }
-   if (length &gt; 2) {
-      tripel.third = FIX2INT(*it);
-   }
-   $1 = tripel;
-}
-
-%typemap(in) Tripel&lt;int&gt;*, Tripel&lt;int&gt;&amp;,
-   const Tripel&lt;int&gt;*, const Tripel&lt;int&gt;&amp;
-{
-   Check_Type($input, T_ARRAY);
-   Tripel&lt;int&gt;* tripel = new Tripel&lt;int&gt;(0, 0, 0);
-   int length = RARRAY($input)-&gt;len;
-   VALUE* it = RARRAY($input)-&gt;ptr;
-   if (length &gt; 0) {
-      tripel-&gt;first = FIX2INT(*it);
-      it++;
-   }
-   if (length &gt; 1) {
-      tripel-&gt;second = FIX2INT(*it);
-      it++;
-   }
-   if (length &gt; 2) {
-      tripel-&gt;third = FIX2INT(*it);
-   }
-   $1 = tripel;
-}
-
-%typemap(freearg) Tripel&lt;int&gt;*, Tripel&lt;int&gt;&amp;, 
-const Tripel&lt;int&gt;*, const Tripel&lt;int&gt;&amp;
-&quot;   delete $1;&quot;
-
-/* OUT Typemaps fuer Tripel&lt;int&gt;.
- * Ein Tripel wird einfach auf ein dreielementiges Array abgebildet.
- * 
- */
-%typemap(out) Tripel&lt;int&gt; {
-   VALUE array = rb_ary_new();
-   rb_ary_push(array, INT2FIX($1.first));
-   rb_ary_push(array, INT2FIX($1.second));
-   rb_ary_push(array, INT2FIX($1.third));
-   $result = array;
-}
-

Added: rl/trunk/engine/script/swig/TypeRlTripelInt.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlTripelInt.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeRlTripelInt.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,80 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+/* IN Typemaps fuer Tripel&lt;int&gt;.
+ * Ein Tripel wird einfach auf ein dreielementiges Array abgebildet.
+ * 
+ * Eine Laengenueberpruefung findet nicht statt.
+ * Nil wird zu 0. Indizes &gt;= 3 werden ignoriert.
+ * TODO eben das aendern
+ */
+%typemap(in) Tripel&lt;int&gt;
+{
+   Check_Type($input, T_ARRAY);
+   Tripel&lt;int&gt; tripel(0, 0, 0);
+   int length = RARRAY($input)-&gt;len;
+   VALUE* it = RARRAY($input)-&gt;ptr;
+   if (length &gt; 0) {
+      tripel.first = FIX2INT(*it);
+      it++;
+   }
+   if (length &gt; 1) {
+      tripel.second = FIX2INT(*it);
+      it++;
+   }
+   if (length &gt; 2) {
+      tripel.third = FIX2INT(*it);
+   }
+   $1 = tripel;
+}
+
+%typemap(in) Tripel&lt;int&gt;*, Tripel&lt;int&gt;&amp;,
+   const Tripel&lt;int&gt;*, const Tripel&lt;int&gt;&amp;
+{
+   Check_Type($input, T_ARRAY);
+   Tripel&lt;int&gt;* tripel = new Tripel&lt;int&gt;(0, 0, 0);
+   int length = RARRAY($input)-&gt;len;
+   VALUE* it = RARRAY($input)-&gt;ptr;
+   if (length &gt; 0) {
+      tripel-&gt;first = FIX2INT(*it);
+      it++;
+   }
+   if (length &gt; 1) {
+      tripel-&gt;second = FIX2INT(*it);
+      it++;
+   }
+   if (length &gt; 2) {
+      tripel-&gt;third = FIX2INT(*it);
+   }
+   $1 = tripel;
+}
+
+%typemap(freearg) Tripel&lt;int&gt;*, Tripel&lt;int&gt;&amp;, 
+const Tripel&lt;int&gt;*, const Tripel&lt;int&gt;&amp;
+&quot;   delete $1;&quot;
+
+/* OUT Typemaps fuer Tripel&lt;int&gt;.
+ * Ein Tripel wird einfach auf ein dreielementiges Array abgebildet.
+ * 
+ */
+%typemap(out) Tripel&lt;int&gt; {
+   VALUE array = rb_ary_new();
+   rb_ary_push(array, INT2FIX($1.first));
+   rb_ary_push(array, INT2FIX($1.second));
+   rb_ary_push(array, INT2FIX($1.third));
+   $result = array;
+}
+


Property changes on: rl/trunk/engine/script/swig/TypeRlTripelInt.swig
___________________________________________________________________
Name: svn:executable
   + *

Deleted: rl/trunk/engine/script/swig/TypeStdPairIntInt.inc
===================================================================
--- rl/trunk/engine/script/swig/TypeStdPairIntInt.inc	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeStdPairIntInt.inc	2007-02-27 11:04:17 UTC (rev 3080)
@@ -1,63 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-%typecheck(SWIG_TYPECHECK_INT32_ARRAY) 
-	std::pair&lt;int,int&gt;*, std::pair&lt;int,int&gt;&amp;, 
-	const std::pair&lt;int,int&gt;*, const std::pair&lt;int,int&gt;&amp;, 
-	std::pair&lt;int,int&gt;, const std::pair&lt;int,int&gt;
-{
-   $1 = TYPE($input) == T_ARRAY &amp;&amp; RARRAY($input)-&gt;len == 2 ? 1 : 0;
-}
-
-
-%typemap(in) std::pair&lt;int,int&gt;*, std::pair&lt;int,int&gt;&amp;,
-   const std::pair&lt;int,int&gt;*, const std::pair&lt;int,int&gt;&amp;
-{
-	std::pair&lt;int, int&gt;* val = new std::pair&lt;int, int&gt;();
-	val-&gt;first = NUM2INT(rb_ary_entry($input, 0)), 
-	val-&gt;second = NUM2INT(rb_ary_entry($input, 1));
-	
-	$1 = val;
-}
-%typemap(freearg) std::pair&lt;int,int&gt;*, std::pair&lt;int,int&gt;&amp;, 
-const std::pair&lt;int,int&gt;*, const std::pair&lt;int,int&gt;&amp;  {
-   delete $1;
-}
-
-%typemap(in) std::pair&lt;int,int&gt;, const std::pair&lt;int,int&gt;
-{
-	$1.first = NUM2INT(rb_ary_entry($input, 0)), 
-	$1.second = NUM2INT(rb_ary_entry($input, 1));
-}
-
-%typemap(out) std::pair&lt;int,int&gt;, const std::pair&lt;int,int&gt;
-{
-	VALUE array = rb_ary_new();
-	rb_ary_push(array, rb_int_new($1.first));
-	rb_ary_push(array, rb_int_new($1.second));
-	$result = array;
-}
-
-%typemap(out) std::pair&lt;int,int&gt;*, std::pair&lt;int,int&gt;&amp;,
-   const std::pair&lt;int,int&gt;*, const std::pair&lt;int,int&gt;&amp;
-{
-	VALUE array = rb_ary_new();
-	rb_ary_push(array, rb_int_new($1-&gt;first));
-	rb_ary_push(array, rb_int_new($1-&gt;second));
-	$result = array;
-}
-
-

Added: rl/trunk/engine/script/swig/TypeStdPairIntInt.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeStdPairIntInt.swig	2007-02-27 09:57:11 UTC (rev 3079)
+++ rl/trunk/engine/script/swig/TypeStdPairIntInt.swig	2007-02-27 11:04:17 UTC (rev 3080)
@@ -0,0 +1,63 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+%typecheck(SWIG_TYPECHECK_INT32_ARRAY) 
+	std::pair&lt;int,int&gt;*, std::pair&lt;int,int&gt;&amp;, 
+	const std::pair&lt;int,int&gt;*, const std::pair&lt;int,int&gt;&amp;, 
+	std::pair&lt;int,int&gt;, const std::pair&lt;int,int&gt;
+{
+   $1 = TYPE($input) == T_ARRAY &amp;&amp; RARRAY($input)-&gt;len == 2 ? 1 : 0;
+}
+
+
+%typemap(in) std::pair&lt;int,int&gt;*, std::pair&lt;int,int&gt;&amp;,
+   const std::pair&lt;int,int&gt;*, const std::pair&lt;int,int&gt;&amp;
+{
+	std::pair&lt;int, int&gt;* val = new std::pair&lt;int, int&gt;();
+	val-&gt;first = NUM2INT(rb_ary_entry($input, 0)), 
+	val-&gt;second = NUM2INT(rb_ary_entry($input, 1));
+	
+	$1 = val;
+}
+%typemap(freearg) std::pair&lt;int,int&gt;*, std::pair&lt;int,int&gt;&amp;, 
+const std::pair&lt;int,int&gt;*, const std::pair&lt;int,int&gt;&amp;  {
+   delete $1;
+}
+
+%typemap(in) std::pair&lt;int,int&gt;, const std::pair&lt;int,int&gt;
+{
+	$1.first = NUM2INT(rb_ary_entry($input, 0)), 
+	$1.second = NUM2INT(rb_ary_entry($input, 1));
+}
+
+%typemap(out) std::pair&lt;int,int&gt;, const std::pair&lt;int,int&gt;
+{
+	VALUE array = rb_ary_new();
+	rb_ary_push(array, rb_int_new($1.first));
+	rb_ary_push(array, rb_int_new($1.second));
+	$result = array;
+}
+
+%typemap(out) std::pair&lt;int,int&gt;*, std::pair&lt;int,int&gt;&amp;,
+   const std::pair&lt;int,int&gt;*, const std::pair&lt;int,int&gt;&amp;
+{
+	VALUE array = rb_ary_new();
+	rb_ary_push(array, rb_int_new($1-&gt;first));
+	rb_ary_push(array, rb_int_new($1-&gt;second));
+	$result = array;
+}
+
+


Property changes on: rl/trunk/engine/script/swig/TypeStdPairIntInt.swig
___________________________________________________________________
Name: svn:executable
   + *


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000150.html">[Dsa-hl-svn] r3079 - rl/trunk/engine/ui/src
</A></li>
	<LI>Next message: <A HREF="000152.html">[Dsa-hl-svn] r3081 - rl/trunk/docs/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#151">[ date ]</a>
              <a href="thread.html#151">[ thread ]</a>
              <a href="subject.html#151">[ subject ]</a>
              <a href="author.html#151">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
