<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r3015 - in rl/trunk/engine: core core/include core/src	rules/include rules/src script/swig ui ui/include ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-February/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3015%20-%20in%20rl/trunk/engine%3A%20core%20core/include%20core/src%0A%09rules/include%20rules/src%20script/swig%20ui%20ui/include%20ui/src&In-Reply-To=%3C200702012313.l11NDIcs018528%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000087.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r3015 - in rl/trunk/engine: core core/include core/src	rules/include rules/src script/swig ui ui/include ui/src</H1>
    <B>tanis at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3015%20-%20in%20rl/trunk/engine%3A%20core%20core/include%20core/src%0A%09rules/include%20rules/src%20script/swig%20ui%20ui/include%20ui/src&In-Reply-To=%3C200702012313.l11NDIcs018528%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r3015 - in rl/trunk/engine: core core/include core/src	rules/include rules/src script/swig ui ui/include ui/src">tanis at mail.berlios.de
       </A><BR>
    <I>Fri Feb  2 00:13:18 CET 2007</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000087.html">[Dsa-hl-svn] r3016 - in rl/trunk: engine/common/include	engine/common/src engine/core/include	engine/core/include/nulldriver engine/core/src	engine/core/src/nulldriver engine/rules/include	engine/rules/src engine/script/include engine/script/src	engine/script/swig engine/startup/src engine/ui/include	engine/ui/src engine/uicomponents/include	engine/uicomponents/src plugins/fmod4driver/include	plugins/fmod4driver/src plugins/openaldriver/include	plugins/openaldriver/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#86">[ date ]</a>
              <a href="thread.html#86">[ thread ]</a>
              <a href="subject.html#86">[ subject ]</a>
              <a href="author.html#86">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tanis
Date: 2007-02-02 00:12:57 +0100 (Fri, 02 Feb 2007)
New Revision: 3015

Added:
   rl/trunk/engine/core/include/Job.h
   rl/trunk/engine/core/include/JobListener.h
   rl/trunk/engine/core/include/JobScheduler.h
   rl/trunk/engine/core/src/Job.cpp
   rl/trunk/engine/core/src/JobScheduler.cpp
   rl/trunk/engine/ui/include/WindowFadeJob.h
   rl/trunk/engine/ui/src/WindowFadeJob.cpp
Removed:
   rl/trunk/engine/ui/include/WindowUpdater.h
   rl/trunk/engine/ui/src/WindowUpdater.cpp
Modified:
   rl/trunk/engine/core/RlCore2005.vcproj
   rl/trunk/engine/core/include/CoreSubsystem.h
   rl/trunk/engine/core/include/GameLoop.h
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/core/src/GameLoop.cpp
   rl/trunk/engine/rules/include/DsaManager.h
   rl/trunk/engine/rules/src/Date.cpp
   rl/trunk/engine/rules/src/DsaManager.cpp
   rl/trunk/engine/rules/src/TimerEventSource.cpp
   rl/trunk/engine/rules/src/TimerManager.cpp
   rl/trunk/engine/script/swig/RlCore.inc
   rl/trunk/engine/ui/RlUI2005.vcproj
   rl/trunk/engine/ui/include/CeGuiWindow.h
   rl/trunk/engine/ui/include/WindowManager.h
   rl/trunk/engine/ui/src/CeGuiWindow.cpp
   rl/trunk/engine/ui/src/DialogCharacterController.cpp
   rl/trunk/engine/ui/src/InfoPopup.cpp
   rl/trunk/engine/ui/src/WindowManager.cpp
Log:
Started work on job scheduling. Still plenty to do, but it already works. Window fading is the first job to use the new base. Old window faders and WindowUpdateTask removed.

There are three definite time sources now.
* Frame-time is given by GameLoop to each GameTask and on this way by the JobScheduler to each Job.
* Real-time is given by GameLoop::getClock.
* Game-time is given by DsaManager::getTimestamp.


Modified: rl/trunk/engine/core/RlCore2005.vcproj
===================================================================
--- rl/trunk/engine/core/RlCore2005.vcproj	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/core/RlCore2005.vcproj	2007-02-01 23:12:57 UTC (rev 3015)
@@ -441,6 +441,18 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\include\Job.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\include\JobListener.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\include\JobScheduler.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\include\LightObject.h&quot;
 				&gt;
 			&lt;/File&gt;
@@ -658,6 +670,14 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\src\Job.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\src\JobScheduler.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\src\LightObject.cpp&quot;
 				&gt;
 			&lt;/File&gt;

Modified: rl/trunk/engine/core/include/CoreSubsystem.h
===================================================================
--- rl/trunk/engine/core/include/CoreSubsystem.h	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/core/include/CoreSubsystem.h	2007-02-01 23:12:57 UTC (rev 3015)
@@ -21,6 +21,7 @@
 #include &lt;OgreSingleton.h&gt;
 #include &lt;OgreString.h&gt;
 #include &lt;OgreRoot.h&gt;
+#include &lt;OgreTimer.h&gt;
 #include &lt;map&gt;
 
 #include &quot;EventSource.h&quot;
@@ -45,6 +46,7 @@
 class ConfigurationManager;
 class SoundManager;
 class DebugVisualsManager;
+class JobScheduler;
 
 typedef _RlCoreExport std::map&lt;Ogre::String, ContentModule*&gt; ModuleMap;
 
@@ -91,17 +93,6 @@
 	*/
 	void makeScreenshot(const Ogre::String&amp; sName);
 
-    /** Gibt die abgelaufene Spielzeit zur&#252;ck*/
-	RL_LONGLONG getClock();
-
-	/** 
-	*   Setzt die abgelaufene Spielzeit wieder auf Null, die DSA-Zeit wird 
-	*   aus der Basiszeit + abgelaufener Spielzeit berechnet
-	*
-	* @see DsaManager
-	*/
-	void resetClock();
-
 	void addCoreEventListener(CoreEventListener* listener);
 	void removeCoreEventListener(CoreEventListener* listener);
 
@@ -128,13 +119,14 @@
     ScriptWrapper* mScriptWrapper;
     XmlResourceManager* mXmlResourceManager;
     PhysicsManager* mPhysicsManager;
-    GameLoop* mGameLoopManager;
+    GameLoop* mGameLoop;
     AnimationManager* mAnimationManager;
     ActorManager* mActorManager;
     GameEventManager* mGameEventManager;
     ConfigurationManager* mConfigurationManager;
 	SoundManager* mSoundManager;
     DebugVisualsManager* mDebugVisualsManager;
+    JobScheduler* mJobScheduler;
 
     /** Runs the setup methods  */
 	bool initializeCoreSubsystem();
@@ -155,8 +147,6 @@
 
 	/** Opens a configuration dialog */
 	bool setupConfiguration();
-
-	RL_LONGLONG getCurrentTime();
 };
 
 }

Modified: rl/trunk/engine/core/include/GameLoop.h
===================================================================
--- rl/trunk/engine/core/include/GameLoop.h	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/core/include/GameLoop.h	2007-02-01 23:12:57 UTC (rev 3015)
@@ -43,7 +43,7 @@
                   TG_SOUND     ///&lt; Tasks that update sound
                  } TaskGroup;
 
-	GameLoop();
+    GameLoop();
 	virtual ~GameLoop();
 
     /// Adds a task to the game loop. It will not be executed immediately,
@@ -54,13 +54,16 @@
     /// @sa GameLoop::TaskGroup
     void addTask(GameTask* newTask, TaskGroup group);
 
-    /// Removes a task to the game loop.
+    /// Removes a task from the game loop.
     /// The removal is delayed till before the next frame is rendered.
 	void removeTask(GameTask* oldTask);
 
 	/// Request the game to quit. The current task loop will finish though.
 	void quitGame();
 
+    /// Returns time since game started in Milliseconds.
+    unsigned long getClock();
+
     /// Main loop of RL.
     void loop();
       
@@ -75,6 +78,10 @@
     GroupTaskList mAddedTasks;
     GameTaskList mRemovedTasks;
 
+    Ogre::Timer* mTimer;
+    /// Time as sampled after the last frame.
+    unsigned long mGameTime;
+
     std::deque&lt;unsigned long&gt; mLastTimes;
     /// In milliseconds, because Ogre's timer works this way.
     unsigned long mSmoothPeriod;
@@ -84,7 +91,7 @@
 
     /// Averages frame rate over mSmoothPeriod milliseconds.
     /// Steadies Controls and Physics a bit.
-    unsigned long smoothTime(unsigned long time);
+    unsigned long smoothFrameTime(unsigned long time);
 
     /// Processes queued additions and removals of tasks.
     void updateTaskList();

Added: rl/trunk/engine/core/include/Job.h
===================================================================
--- rl/trunk/engine/core/include/Job.h	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/core/include/Job.h	2007-02-01 23:12:57 UTC (rev 3015)
@@ -0,0 +1,74 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2005 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __RL_JOB_H__
+#define __RL_JOB_H__
+
+#include &quot;CorePrerequisites.h&quot;
+
+namespace rl
+{
+    /** A Job is an independent executional entity, that encapsules a singe specific task
+     *  of a some finite duration.
+     *  If you want some task to be executed every frame over the length of the game,
+     *  use GameTask instead.&lt;br&gt;
+     *  A Job is registered with the JobScheduler using JobScheduler#addJob.
+     *  The JobScheduler calles Job#execute till the Job has finished, or the JobScheduler
+     *  decides to discard the Job, if allowed.
+     */
+    class _RlCoreExport Job
+    {
+    public:
+        /**
+         * Constructor.
+         *
+         *  @param isDiscardable Set this true, if the Job's goal can be reached in a single
+         *         step. For instance if a Job is supposed to slowly close a window by fading
+         *         its alpha to 0, then it is discardable, and Job#discard will just finish
+         *         the process by closing the window.
+         *
+         *  @param destroyWhenDone Set this to true, when the JobScheduler shall delete the
+         *         Job, after execution is finished. This should usually be the case, but
+         *         sometimes it is sensible to pool a number of Jobs for reuse.
+         */
+        Job(bool isDiscardable, bool destroyWhenDone);
+        virtual ~Job();
+
+        /**
+         * This is the function in which the job is supposed to do whatever it is supposed to do.
+         * This function is called by the JobScheduler at most once per frame. The frequency depends
+         * on the Job's priority given with JobScheduler#addJob.
+         * @param time the frame-time time, since the last call of this function.
+         */
+        virtual bool execute(Ogre::Real time) = 0;
+
+        /// Returns whether the job can be removed from the queue by the scheduler,
+        virtual bool isDiscardable();
+
+        /// Finish whatever the Job is doing. It won't get a chance to continue.
+        /// Overloaded functions must *not* call this implementation.
+        virtual void discard();
+
+        /// Returns true, if the Job shall be deleted, if the Job is finished. Returns false else.
+        virtual bool destroyWhenDone();
+
+    protected:
+        bool mIsDiscardable;
+        bool mDestroyWhenDone;
+    };
+}
+
+#endif

Added: rl/trunk/engine/core/include/JobListener.h
===================================================================
--- rl/trunk/engine/core/include/JobListener.h	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/core/include/JobListener.h	2007-02-01 23:12:57 UTC (rev 3015)
@@ -0,0 +1,45 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2005 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __RL_JOB_LISTENER_H__
+#define __RL_JOB_LISTENER_H__
+
+#include &quot;CorePrerequisites.h&quot;
+
+namespace rl
+{
+    /**
+     * A Listener for the state of a Job's lifecycle in the JobScheduler.
+     * It can be registered with the JobScheduler, when a Job is added to it.
+     */
+    class _RlCoreExport JobListener
+    {
+    public:
+        JobListener() {}
+        virtual ~JobListener() {}
+
+        /// Called, when a Job is started for the first time.
+        virtual void jobStarted(unsigned long ticket) {}
+        /// Called, when a Job finishes itself regularly.
+        virtual void jobFinished(unsigned long ticket) {}
+        /// Called, when a Job is discarded by the JobScheduler.
+        virtual void jobDiscarded(unsigned long ticket) {}
+        /// Called, when a Job has been removed using JobScheduler#remove.
+        virtual void jobRemoved(unsigned long ticket) {}
+    };
+}
+
+#endif

Added: rl/trunk/engine/core/include/JobScheduler.h
===================================================================
--- rl/trunk/engine/core/include/JobScheduler.h	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/core/include/JobScheduler.h	2007-02-01 23:12:57 UTC (rev 3015)
@@ -0,0 +1,127 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2005 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __RL_JOB_SCHEDULER_H__
+#define __RL_JOB_SCHEDULER_H__
+
+#include &quot;CorePrerequisites.h&quot;
+#include &quot;GameTask.h&quot;
+
+#include &lt;deque&gt;
+#include &lt;functional&gt;
+
+namespace rl
+{
+    class Job;
+    class JobListener;
+
+    /**
+     *  Scheduler for fire-and-forget Jobs in RL.
+     *  Jobs are independent executional entities, that encapsule a singe specific task
+     *  of a some finite duration.
+     *  The JobScheduler executes a certain amount of jobs each frame. The number of jobs per frame
+     *  depends on the time that can be spent for those jobs. Only a gross estimation is done.
+     *  A priority value determines how often a Job is executed.
+     *  Whether a Job can run this frame, depends on the number of tokens, the Job accumulated.
+     *  If this number is over a dynamic threshold,
+     *  it is executed and the tokens are removed from it. If a Job doesn't run this frame, tokens
+     *  are added to it. The number of tokens depends on its priority. The higher the priority, the
+     *  more tokens added.
+     */
+    class _RlCoreExport JobScheduler
+        : public GameTask,
+          public Ogre::Singleton&lt;JobScheduler&gt;
+    {
+    public:
+        typedef enum {JP_LOW = 10, JP_NORMAL = 20, JP_HIGH = 30} JobPriority;
+
+        JobScheduler();
+        virtual ~JobScheduler();
+
+        // Singleton Stuff
+        static JobScheduler&amp; getSingleton(void);
+        static JobScheduler* getSingletonPtr(void);
+
+        /**
+         * Adds a Job to the scheduler.
+         * @param job The job to be added.
+         * @param priority The priority, with which the job is added. The higher, the more often
+         *        it will be called. But it will never be called more than once per frame. No job
+         *        will starve to death.
+         * @param delay The delay in seconds, till the Job job is called for the first time.
+         *        A value of 0.0f will call the job in the next frame.
+         * @param maxRuntime The maximum runtime a job is allowed to run. If it is reached, and
+         *        the Job is not yet finished, it will be discarded by calling Job#discard. If
+         *        the Job is non-discardable, it will just be removed from the queue.
+         * @param listener The JobListener that gets noticed, when the state of the Job changes.
+         *
+         * @return The ticket used to identify the Job. This ticket is used to identify a Job in the
+         *         JobListener. It can be used by the listener to identify the Job, even if it
+         *         doesn't exist anymore. When the Job itself is removed from the queue, the ticket
+         *         looses its validity to the JobScheduler itself though.
+         */
+        unsigned long addJob(Job* job, JobPriority priority=JP_NORMAL, Ogre::Real delay=0.0f,
+            Ogre::Real maxRuntime=Ogre::Math::POS_INFINITY, JobListener* listener=NULL);
+
+        /**
+         * Removes a Job from the queue.
+         * This removal is valid in the next frame.
+         * If the Job has not yet been executed this frame, it may still be executed a single time.
+         * If the ticket is not valid anymore, there won't be an exception, but this event is logged
+         * as a warning.
+         * @param ticket the ticket of the Job to be removed.
+         */
+        void removeJob(unsigned long ticket);
+
+        virtual void run(Ogre::Real time);
+
+        virtual const Ogre::String&amp; getName() const;
+
+    private:
+        /// A JobEntry encapsules a Job for the Scheduler, it contains the Job itself and
+        /// various administrional data.
+        struct JobEntry
+        {
+            Job* job;                     ///&lt; The Job to be executed.
+            JobListener* listener;        ///&lt; attached JobListener or NULL else.
+            unsigned long ticket;         ///&lt; ticket to identify the Job.
+            JobPriority priority;         ///&lt; priority it runs with.
+            unsigned short tokens;        ///&lt; number of accumulated tokens.
+            unsigned long start;          ///&lt; when to execute the Job for the first time.
+            unsigned long end;            ///&lt; when to discard the Job, if not then finished.
+            Ogre::Real timeSinceLastCall; ///&lt; frame time, since the last call of Job#execute.
+            bool called;                  ///&lt; false, if the Job has not been called yet.
+        };
+
+        /// Functor for finding a Job in a JobQueue by its ticket.
+        struct FindJobEntryByTicket : public std::binary_function&lt;JobEntry, unsigned short, bool&gt;
+        {
+            bool operator()(const JobEntry&amp; jobEntry, unsigned short ticket) const
+            {
+                return jobEntry.ticket == ticket;
+            }
+        };
+
+        typedef std::deque&lt;JobEntry&gt; JobQueue;
+
+        JobQueue mJobQueue;
+        JobQueue mRemovedJobs;
+        unsigned short mTokenThreshold;
+        unsigned long mTicketCounter;
+    };
+}
+
+#endif

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2007-02-01 23:12:57 UTC (rev 3015)
@@ -39,6 +39,7 @@
 #include &quot;ScriptWrapper.h&quot;
 #include &quot;SoundManager.h&quot;
 #include &quot;DebugVisualsManager.h&quot;
+#include &quot;JobScheduler.h&quot;
 
 #include &lt;ctime&gt;
 
@@ -64,17 +65,16 @@
         mScriptWrapper(NULL),
         mXmlResourceManager(NULL),
         mPhysicsManager(NULL),
-        mGameLoopManager(NULL),
+        mGameLoop(NULL),
         mAnimationManager(NULL),
         mActorManager(NULL),
         mGameEventManager(NULL),
         mConfigurationManager(NULL),
 		mSoundManager(NULL),
-        mDebugVisualsManager(NULL)
+        mDebugVisualsManager(NULL),
+        mJobScheduler(NULL)
     {
-        resetClock();
         initializeCoreSubsystem();
-        resetClock();
     }
 
     CoreSubsystem::~CoreSubsystem()
@@ -82,10 +82,11 @@
 		mCoreEventCaster.removeEventListeners();
 
         delete mWorld;
+        delete mGameLoop;
+        delete mJobScheduler;
         delete mActorManager;
         delete mGameEventManager;
         delete mAnimationManager;
-        delete mGameLoopManager;
         delete mDebugVisualsManager;
         delete mPhysicsManager;
         delete mXmlResourceManager;
@@ -118,7 +119,7 @@
 			startAdventureModule(mod);
 		}
 
-		mGameLoopManager-&gt;loop();
+		mGameLoop-&gt;loop();
 
         mWorld-&gt;clearScene();
         unloadPlugins();
@@ -184,7 +185,7 @@
         if (!carryOn)
             return false;
 
-		mGameLoopManager = new GameLoop();
+		mGameLoop = new GameLoop();
         LOG_MESSAGE(Logger::CORE,&quot;GameLoopmanager erzeugt&quot;);
 
 		mScriptWrapper = new ScriptWrapper();
@@ -226,6 +227,9 @@
         mDebugVisualsManager = new DebugVisualsManager();
         GameLoop::getSingleton().addTask(mDebugVisualsManager, GameLoop::TG_GRAPHICS);
 
+        mJobScheduler = new JobScheduler();
+        GameLoop::getSingleton().addTask(mJobScheduler, GameLoop::TG_GRAPHICS);
+
 		return true;
     }
 
@@ -477,23 +481,6 @@
         mSoundManager-&gt;unloadAllDrivers();
     }
 
-    void CoreSubsystem::resetClock()
-    {
-        mClockStartTime = getCurrentTime();
-    }
-
-    RL_LONGLONG CoreSubsystem::getClock()
-    {
-        return getCurrentTime() - mClockStartTime;
-    }
-
-    RL_LONGLONG CoreSubsystem::getCurrentTime()
-    {
-        std::time_t t = std::time(NULL);
-        std::tm* ts = std::localtime(&amp;t);
-        return static_cast&lt;RL_LONGLONG&gt;((ts-&gt;tm_hour * 3600 + ts-&gt;tm_min * 60 + ts-&gt;tm_sec) * 1000);
-    }
-
 	void CoreSubsystem::addCoreEventListener(rl::CoreEventListener *listener)
 	{
 		mCoreEventCaster.addEventListener(listener);

Modified: rl/trunk/engine/core/src/GameLoop.cpp
===================================================================
--- rl/trunk/engine/core/src/GameLoop.cpp	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/core/src/GameLoop.cpp	2007-02-01 23:12:57 UTC (rev 3015)
@@ -43,6 +43,8 @@
         : mTaskLists(),
           mAddedTasks(),
           mRemovedTasks(),
+          mTimer(NULL),
+          mGameTime(0),
           mLastTimes(),
           mSmoothPeriod(500),
           mMaxFrameTime(0.250f),
@@ -54,6 +56,8 @@
         mTaskLists.push_back(new GameTaskList);
         mTaskLists.push_back(new GameTaskList);
         mTaskLists.push_back(new GameTaskList);
+
+        mTimer = new Timer();
     }
 
     GameLoop::~GameLoop()
@@ -63,11 +67,12 @@
             delete mTaskLists[i];
         }
         mTaskLists.clear();
+        delete mTimer;
     }
 
     void GameLoop::addTask(GameTask* task, TaskGroup group)
     {
-        RlAssert(task != NULL, &quot;Added task should be not null&quot;);
+        RlAssert1(task != NULL);
         mAddedTasks.push_back(std::make_pair(group, task));
     }
 
@@ -83,17 +88,16 @@
 
     void GameLoop::loop()
     {
-        Timer* timer = Root::getSingleton().getTimer();
         // A sensible start value
-        unsigned long timeSinceLastLoop = timer-&gt;getMilliseconds() - 50;
+        mGameTime = mTimer-&gt;getMilliseconds() - 50;
 
         // Loop until game exit is requested.
         while (!mQuitRequested)
         {
             // Calculate frame time. This time is smoothed and capped.
-            unsigned long elapsedTime = timer-&gt;getMilliseconds();
-            Real frameTime = 0.001f * (Real) smoothTime(elapsedTime - timeSinceLastLoop);
-            timeSinceLastLoop = elapsedTime;
+            unsigned long elapsedTime = mTimer-&gt;getMilliseconds();
+            Real frameTime = 0.001f * (Real) smoothFrameTime(elapsedTime - mGameTime);
+            mGameTime = elapsedTime;
             if (frameTime &gt; mMaxFrameTime) frameTime = mMaxFrameTime;
 
 			// Let Ogre handle Windows/XServer events.
@@ -108,7 +112,6 @@
                 GameTaskList* tasks = mTaskLists[i];
                 for (GameTaskList::iterator it = tasks-&gt;begin(); it != tasks-&gt;end(); ++it)
                 {
-                    RlAssert(*it != NULL, &quot;This task should not be NULL&quot;);
                     if (!(*it)-&gt;isPaused())
                     {
                         (*it)-&gt;run(frameTime);
@@ -142,7 +145,6 @@
         // Add new ones.
         for (GroupTaskList::iterator it = mAddedTasks.begin(); it != mAddedTasks.end(); ++it)
         {
-            RlAssert((*it).second, &quot;New task should not be null&quot;);
             mTaskLists[(*it).first]-&gt;push_back((*it).second);
         }
         mAddedTasks.clear();
@@ -150,7 +152,7 @@
 
     // Idea taken from Ogre, but implementation by us.
     // smooths time step over the period mSmoothPeriod.
-    unsigned long GameLoop::smoothTime(unsigned long time)
+    unsigned long GameLoop::smoothFrameTime(unsigned long time)
     {
         // First add time for this frame
         mLastTimes.push_back(time);
@@ -171,4 +173,9 @@
         return std::accumulate(mLastTimes.begin(), mLastTimes.end(), 0)
             / std::max(mLastTimes.size(), (size_t)1);
     }
+
+    unsigned long GameLoop::getClock()
+    {
+        return mGameTime;
+    }
 }

Added: rl/trunk/engine/core/src/Job.cpp
===================================================================
--- rl/trunk/engine/core/src/Job.cpp	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/core/src/Job.cpp	2007-02-01 23:12:57 UTC (rev 3015)
@@ -0,0 +1,46 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2005 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#include &quot;Job.h&quot;
+#include &quot;Exception.h&quot;
+
+namespace rl
+{
+    Job::Job(bool isDiscardable, bool destroyWhenDone)
+        : mIsDiscardable(isDiscardable), mDestroyWhenDone(destroyWhenDone)
+    {
+
+    }
+
+    Job::~Job()
+    {
+    }
+
+    bool Job::isDiscardable()
+    {
+        return mIsDiscardable;
+    }
+
+    bool Job::destroyWhenDone()
+    {
+        return mDestroyWhenDone;
+    }
+
+    void Job::discard()
+    {
+        RlFail(&quot;Discarded non discardable Job.&quot;);
+    }
+}

Added: rl/trunk/engine/core/src/JobScheduler.cpp
===================================================================
--- rl/trunk/engine/core/src/JobScheduler.cpp	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/core/src/JobScheduler.cpp	2007-02-01 23:12:57 UTC (rev 3015)
@@ -0,0 +1,169 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2005 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#include &quot;JobScheduler.h&quot;
+#include &quot;Job.h&quot;
+#include &quot;JobListener.h&quot;
+#include &quot;GameLoop.h&quot;
+
+using namespace Ogre;
+
+template&lt;&gt; rl::JobScheduler* Singleton&lt;rl::JobScheduler&gt;::ms_Singleton = 0;
+
+namespace rl
+{
+    JobScheduler&amp; JobScheduler::getSingleton(void)
+    {
+        return Singleton&lt;JobScheduler&gt;::getSingleton();
+    }
+
+    JobScheduler* JobScheduler::getSingletonPtr(void)
+    {
+        return Singleton&lt;JobScheduler&gt;::getSingletonPtr();
+    }
+
+    JobScheduler::JobScheduler()
+        : mJobQueue(), mRemovedJobs(), mTokenThreshold(JP_NORMAL), mTicketCounter(0)
+    {
+    }
+
+    JobScheduler::~JobScheduler()
+    {
+    }
+
+    unsigned long JobScheduler::addJob(Job* job, JobPriority priority, Real delay, Real maxRuntime,
+        JobListener* listener)
+    {
+        unsigned long ticket = ++mTicketCounter;
+        unsigned long clock = GameLoop::getSingleton().getClock();
+        unsigned long start = clock + delay*1000;
+        unsigned long end = maxRuntime &gt;= Math::POS_INFINITY ?
+            0xffffffff : static_cast&lt;unsigned long&gt;(start + maxRuntime*1000);
+        JobEntry entry = {job, listener, ticket, priority, priority, start, end, 0.0f, false};
+        mJobQueue.push_back(entry);
+        return ticket;
+    }
+
+    void JobScheduler::run(Ogre::Real time)
+    {
+        ///@todo use different buckets for jobs not yet started, instead of
+        ///      iterating over those each time.
+
+        ///@todo dynamically determine token threshold. Maybe make it work load depending.
+
+        unsigned long clock = GameLoop::getSingleton().getClock();
+
+        // Queue for finished jobs
+        JobQueue notDone;
+
+        for (JobQueue::iterator it = mJobQueue.begin(), end = mJobQueue.end(); it != end; ++it)
+        {
+            JobEntry entry = *it;
+
+            if (entry.start &lt;= clock &amp;&amp; clock &lt; entry.end)
+            {
+                // Is the token threshold reached? 
+                if (entry.tokens &gt;= mTokenThreshold)
+                {
+                    // Yes, pay run fee and execute.
+                    entry.tokens = 0;
+                    bool runAgain = !entry.job-&gt;execute(entry.timeSinceLastCall + time);
+
+                    if (!entry.called)
+                    {
+                        // Notify listener, the job started for the first time
+                        if (entry.listener != NULL)
+                        {
+                            entry.listener-&gt;jobStarted(entry.ticket);
+                        }
+                        entry.called = true;
+                    }
+
+                    if (runAgain)
+                    {
+                        // Job is not done, reset token count and requeue.
+                        entry.tokens = entry.priority;
+                        entry.timeSinceLastCall = 0.0f;
+                        notDone.push_back(entry);
+                    }
+                    else
+                    {
+                        // Notify listener, the job finished regularly.
+                        if (entry.listener != NULL)
+                        {
+                            entry.listener-&gt;jobFinished(entry.ticket);
+                        }
+
+                        // If we are supposed to delete the Job, do so now.
+                        if (entry.job-&gt;destroyWhenDone())
+                        {
+                            delete entry.job;
+                        }
+                    }
+                }
+                else
+                {
+                    // No, increase token count
+                    entry.tokens += entry.priority;
+                    entry.timeSinceLastCall += time;
+                    notDone.push_back(entry);
+                }
+            }
+            else if (!(clock &lt; entry.end))
+            {
+                // Start time not yet reached. Queue again.
+                notDone.push_back(entry);
+            }
+            else
+            {
+                // Job reached its end time and didn't want to finish itself, so we do it.
+                if (entry.job-&gt;isDiscardable())
+                {
+                    entry.job-&gt;discard();
+                    if (entry.listener != NULL)
+                    {
+                        entry.listener-&gt;jobDiscarded(entry.ticket);
+                    }
+                }
+            }
+        }
+
+        // Copy requeued jobs for next run.
+        mJobQueue = notDone;
+    }
+
+    void JobScheduler::removeJob(unsigned long ticket)
+    {
+        JobQueue::iterator it = std::find_if(mJobQueue.begin(), mJobQueue.end(),
+            std::bind2nd(FindJobEntryByTicket(), ticket));
+        if (it != mJobQueue.end())
+        {
+            mRemovedJobs.push_back(*it);
+            if (it-&gt;listener != NULL) it-&gt;listener-&gt;jobRemoved(ticket);
+        }
+        else
+        {
+            ///@todo Log missing job for the ticket.
+        }
+    }
+
+    const String&amp; JobScheduler::getName() const
+    {
+        static String NAME = &quot;JobScheduler&quot;;
+
+        return NAME;
+    }
+}

Modified: rl/trunk/engine/rules/include/DsaManager.h
===================================================================
--- rl/trunk/engine/rules/include/DsaManager.h	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/rules/include/DsaManager.h	2007-02-01 23:12:57 UTC (rev 3015)
@@ -51,7 +51,6 @@
 			RULE_DISTANZKLASSEN
 		};
 
-
         static DsaManager&amp; getSingleton(void);
         static DsaManager* getSingletonPtr(void);
 
@@ -61,34 +60,32 @@
         ~DsaManager();
 
         /** Liefert die aktuelle Spielzeit */
-        RL_LONGLONG getTimestamp();
-		Date getCurrentDate();
+        RL_LONGLONG getTimestamp() const;
+		Date getCurrentDate() const;
 
-		/** Setzt die aktuelle Spielzeit, die Spieluhr in Core wird dabei zur&#252;ckgesetzt */
+		/// Setzt die aktuelle Spielzeit
 		void setTimestamp(const RL_LONGLONG time);
 		void setCurrentDate(const Date&amp; date);
 
+        Ogre::Real getTimeScale() const;
+        void setTimeScale(Ogre::Real scale);
 
         /** liefert eine Zufallszahl zwischen 1 und 20.*/
-        int rollD20();
+        int rollD20() const;
 
         /** liefert ein Tripel von Zufallszahlen zwischen 1 und 20.*/
-        Tripel&lt;int&gt; roll3D20();
+        Tripel&lt;int&gt; roll3D20() const;
 
         /** liefert eine Zufallszahl zwischen 1 und 6.*/
-        int rollD6();
+        int rollD6() const;
 
-		int roll(int d6, int d20);
+		int roll(int d6, int d20) const;
 
         Talent* getTalent(const CeGuiString talentName) const;
-		//Talent* getTalent(const CeGuiString name) const;
         Kampftechnik* getKampftechnik(const CeGuiString kampftechnikName) const;
         Eigenschaft* getEigenschaft(const CeGuiString eigenschaftName) const;
 		Person* getPerson(int id) const;        
-		
-		//int getEigenschaftIdFromString(const CeGuiString str) const;
-		//int getEigenschaftIdFromLongString(const CeGuiString str) const;
-		
+				
 		int getSteigerKosten(int column, int from, int to) const;
 		int getSteigerKosten(int column, int from) const;
 		bool isDkDistance(const Weapon::Distanzklasse&amp; dk, const Ogre::Real&amp; distance) const;
@@ -99,7 +96,9 @@
 		void _addKampftechnik(Kampftechnik* kampftechnik);
 
     private:
-		RL_LONGLONG mBaseTime;
+		mutable RL_LONGLONG mLastGameTime;
+        mutable unsigned long mLastClock;
+        Ogre::Real mTimeScale;
 
         typedef std::map&lt;CeGuiString, Talent*&gt; TalentMap;
 		typedef std::map&lt;int, Person*&gt; PersonMap;

Modified: rl/trunk/engine/rules/src/Date.cpp
===================================================================
--- rl/trunk/engine/rules/src/Date.cpp	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/rules/src/Date.cpp	2007-02-01 23:12:57 UTC (rev 3015)
@@ -62,14 +62,7 @@
     const unsigned RL_LONGLONG Date::ONE_DAY = 86400000UL;
     const unsigned RL_LONGLONG Date::ONE_WEEK = 604800000UL;
     const unsigned RL_LONGLONG Date::ONE_MONTH = 2592000000UL;
-
-#if (_MSC_VER &gt;= 1200) &amp;&amp; (_MSC_VER &lt; 1300)
-    // VC6 kennt kein ULL-Suffix 
-    const unsigned RL_LONGLONG Date::ONE_YEAR = 31536000000UL;
-#else
-    // Und GCC will unbedingt ULL
     const unsigned RL_LONGLONG Date::ONE_YEAR = 31536000000ULL;
-#endif
     const unsigned RL_LONGLONG Date::ONE_KAMPFRUNDE = 3 * Date::ONE_SECOND;
     const unsigned RL_LONGLONG Date::ONE_SPIELRUNDE = 5 * Date::ONE_MINUTE;
 

Modified: rl/trunk/engine/rules/src/DsaManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/DsaManager.cpp	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/rules/src/DsaManager.cpp	2007-02-01 23:12:57 UTC (rev 3015)
@@ -22,16 +22,17 @@
 #include &quot;Person.h&quot;
 #include &quot;RulesSubsystem.h&quot;
 #include &quot;Date.h&quot;
-//#include &quot;XdimlLoader.h&quot;
 #include &quot;DsaDataLoader.h&quot;
 
 #include &quot;Exception.h&quot;
-#include &quot;CoreSubsystem.h&quot;
+#include &quot;GameLoop.h&quot;
 
-template &lt;&gt;
-	rl::DsaManager* Ogre::Singleton&lt;rl::DsaManager&gt; ::ms_Singleton = 0;
+#include &lt;cstdlib&gt;
 
+template &lt;&gt; rl::DsaManager* Ogre::Singleton&lt;rl::DsaManager&gt; ::ms_Singleton = 0;
+
 using namespace std;
+using namespace Ogre;
 using CEGUI::utf8;
 
 namespace rl
@@ -47,7 +48,9 @@
     }
 
     DsaManager::DsaManager()
-        : mBaseTime(0),
+        : mLastGameTime(0),
+        mLastClock(0),
+        mTimeScale(24.0f), // 5 min == 2 hours, 1 hour == 1 day
         mEigenschaften(),
         mTalente(),
         mKampftechniken(),
@@ -136,20 +139,23 @@
 		return false;
 	}
 
-    RL_LONGLONG DsaManager::getTimestamp()
+    RL_LONGLONG DsaManager::getTimestamp() const
     {
-		return mBaseTime + CoreSubsystem::getSingleton().getClock();
+        unsigned long currentClock = GameLoop::getSingleton().getClock();
+        mLastGameTime += mTimeScale * (currentClock - mLastClock);
+        mLastClock = currentClock;
+		return mLastGameTime;
     }
 
-	Date DsaManager::getCurrentDate()
+	Date DsaManager::getCurrentDate() const
 	{
 		return Date(getTimestamp());
 	}
 
 	void DsaManager::setTimestamp(const RL_LONGLONG time)
 	{
-		mBaseTime = time;
-		CoreSubsystem::getSingleton().resetClock();
+		mLastGameTime = time;
+        mLastClock = GameLoop::getSingleton().getClock();
 	}
 
 	void DsaManager::setCurrentDate(const Date&amp; date)
@@ -157,24 +163,37 @@
 		setTimestamp(date.getTimestamp());
 	}
 
-    int DsaManager::rollD20()
+    Real DsaManager::getTimeScale() const
     {
-        double d = rand();
+        return mTimeScale;
+    }
+
+    void DsaManager::setTimeScale(Real scale)
+    {
+        // First refresh time with old scale.
+        getTimestamp();
+        // Then set new scale.
+        mTimeScale = scale;
+    }
+
+    int DsaManager::rollD20() const
+    {
+        double d = std::rand();
         return static_cast&lt;int&gt;(d * 20.0 / RAND_MAX) + 1;
     }
 
-    Tripel&lt;int&gt; DsaManager::roll3D20()
+    Tripel&lt;int&gt; DsaManager::roll3D20() const
     {
         return Tripel&lt;int&gt;(rollD20(), rollD20(), rollD20());
     }
 
-    int DsaManager::rollD6()
+    int DsaManager::rollD6() const
     {
-        double d = rand();
+        double d = std::rand();
         return static_cast&lt;int&gt;(d * 6.0 / RAND_MAX) + 1;
     }
 
-	int DsaManager::roll(int d6, int d20)
+	int DsaManager::roll(int d6, int d20) const
 	{
 		int sum = 0;
 

Modified: rl/trunk/engine/rules/src/TimerEventSource.cpp
===================================================================
--- rl/trunk/engine/rules/src/TimerEventSource.cpp	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/rules/src/TimerEventSource.cpp	2007-02-01 23:12:57 UTC (rev 3015)
@@ -21,7 +21,7 @@
 #include &quot;TimerListener.h&quot;
 #include &quot;GameObject.h&quot;
 #include &quot;DsaManager.h&quot;
-#include &quot;CoreSubsystem.h&quot;
+#include &quot;GameLoop.h&quot;
 #include &quot;ScriptWrapper.h&quot;
 
 using Ogre::Real;
@@ -87,7 +87,7 @@
 		}
 		else if (mType == TIMER_GAME_TIME)
 		{
-			RL_LONGLONG time = CoreSubsystem::getSingleton().getClock();
+			RL_LONGLONG time = GameLoop::getSingleton().getClock();
 			evt-&gt;setTime(time);
 			mGameTimeLastCall = time;
 		}

Modified: rl/trunk/engine/rules/src/TimerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/TimerManager.cpp	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/rules/src/TimerManager.cpp	2007-02-01 23:12:57 UTC (rev 3015)
@@ -62,7 +62,7 @@
 	void TimerManager::run(Ogre::Real elapsedTime)
 	{
 		RL_LONGLONG nowDsa = DsaManager::getSingleton().getTimestamp();
-		RL_LONGLONG now = CoreSubsystem::getSingleton().getClock();
+		RL_LONGLONG now = GameLoop::getSingleton().getClock();
 
 		for (std::set&lt;TimerEventSource*&gt;::iterator timerIter = mTimers.begin(); 
 			timerIter != mTimers.end();)
@@ -106,6 +106,4 @@
 
         return NAME;
     }
-
-
 }

Modified: rl/trunk/engine/script/swig/RlCore.inc
===================================================================
--- rl/trunk/engine/script/swig/RlCore.inc	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/script/swig/RlCore.inc	2007-02-01 23:12:57 UTC (rev 3015)
@@ -656,7 +656,6 @@
 	void registerModule(ContentModule* module);
     World* getWorld();
     void makeScreenshot(const Ogre::String&amp; sName);
-    RL_LONGLONG getClock();
     bool isInitialized() const;
     void setScheme(const Ogre::String&amp; schemeName);
 };

Modified: rl/trunk/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/trunk/engine/ui/RlUI2005.vcproj	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/ui/RlUI2005.vcproj	2007-02-01 23:12:57 UTC (rev 3015)
@@ -390,11 +390,11 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\include\WindowManager.h&quot;
+				RelativePath=&quot;.\include\WindowFadeJob.h&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\include\WindowUpdater.h&quot;
+				RelativePath=&quot;.\include\WindowManager.h&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;Filter
@@ -551,11 +551,11 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\src\WindowManager.cpp&quot;
+				RelativePath=&quot;.\src\WindowFadeJob.cpp&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\src\WindowUpdater.cpp&quot;
+				RelativePath=&quot;.\src\WindowManager.cpp&quot;
 				&gt;
 			&lt;/File&gt;
 			&lt;Filter

Modified: rl/trunk/engine/ui/include/CeGuiWindow.h
===================================================================
--- rl/trunk/engine/ui/include/CeGuiWindow.h	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/ui/include/CeGuiWindow.h	2007-02-01 23:12:57 UTC (rev 3015)
@@ -67,17 +67,12 @@
 
 		bool isModal();
 		bool isClosingOnEscape();
-		bool isFading();
-		void setFading(bool fading);
 
 		const CeGuiString&amp; getName() const;
 		const Ogre::Real&amp; getNormalAlpha() const;
 
-		virtual void windowHid();		
+		virtual void windowHid();
 
-		void _setUpdateTask(WindowUpdateTask* updateTask);
-		WindowUpdateTask* _getUpdateTask();
-
 	protected:
 		CeGuiWindow(
 			const CeGuiString&amp; xmlfile, 
@@ -96,7 +91,7 @@
 		static CEGUI::Window* loadWindow(const CeGuiString&amp; xmlfile, CeGuiString&amp; prefix);
 
 		CEGUI::Window* mWindow;
-		bool mVisible; 
+		bool mVisible;
 
 	private:
 		
@@ -105,8 +100,6 @@
 		CeGuiString mName;
 		bool mModal;
 		bool mCloseOnEscape;
-		bool mFading;
-		WindowUpdateTask* mUpdateTask;
 		Ogre::Real mNormalAlpha;
 
 		static int sNumCeGuiWindows;

Added: rl/trunk/engine/ui/include/WindowFadeJob.h
===================================================================
--- rl/trunk/engine/ui/include/WindowFadeJob.h	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/ui/include/WindowFadeJob.h	2007-02-01 23:12:57 UTC (rev 3015)
@@ -0,0 +1,49 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2005 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __RL_WINDOW_UPDATE_JOB_H__
+#define __RL_WINDOW_UPDATE_JOB_H__
+
+#include &quot;UiPrerequisites.h&quot;
+#include &lt;OgreSingleton.h&gt;
+
+#include &quot;Job.h&quot;
+
+namespace rl {
+
+    class CeGuiWindow;
+
+    class WindowFadeJob : public Job
+    {
+    public:
+        typedef enum {FADE_IN, FADE_OUT, FADE_OUT_AND_DESTROY} Mode;
+
+        WindowFadeJob(CeGuiWindow* window, Mode mode,
+            Ogre::Real targetAlpha, Ogre::Real changeRate = 4.0f);
+
+        virtual bool execute(Ogre::Real time);
+        virtual void discard();
+
+    protected:
+        CeGuiWindow* mWindow;
+        Mode mMode;
+        Ogre::Real mChangeRate;
+        Ogre::Real mCurrentAlpha;
+        Ogre::Real mTargetAlpha;
+    };
+}
+
+#endif

Modified: rl/trunk/engine/ui/include/WindowManager.h
===================================================================
--- rl/trunk/engine/ui/include/WindowManager.h	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/ui/include/WindowManager.h	2007-02-01 23:12:57 UTC (rev 3015)
@@ -44,24 +44,13 @@
 		static WindowManager* getSingletonPtr();
 
 		void registerWindow(CeGuiWindow* window);
-		bool destroyWindow(CeGuiWindow* window);
-		void _doDestroyWindow(CeGuiWindow* window);
+		void destroyWindow(CeGuiWindow* window);
 		void closeTopWindow();
 		bool handleMovedToFront(CeGuiWindow* window);
 		bool handleMovedToBack(CeGuiWindow* window);
 
-		void _fadeIn(CeGuiWindow* window, float targetAlpha = 1.0);
-		void _fadeOut(CeGuiWindow* window, bool destroy);
-		void _fadeInOut(
-			CeGuiWindow* window, 
-			Ogre::Real timeFade, 
-			Ogre::Real timeHold, 
-			bool destroy = false);
-		void _moveOutLeft(CeGuiWindow* window, Ogre::Real time, bool destroy);
-
 	private:
 		std::list&lt;CeGuiWindow*&gt; mWindowList;
-		WindowUpdater* mWindowUpdater;
 	};
 }
 

Deleted: rl/trunk/engine/ui/include/WindowUpdater.h
===================================================================
--- rl/trunk/engine/ui/include/WindowUpdater.h	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/ui/include/WindowUpdater.h	2007-02-01 23:12:57 UTC (rev 3015)
@@ -1,143 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2005 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __WindowUpdater_H__
-#define __WindowUpdater_H__
-
-#include &quot;UiPrerequisites.h&quot;
-#include &lt;OgreSingleton.h&gt;
-
-#include &quot;GameTask.h&quot;
-
-namespace rl {
-
-	class CeGuiWindow;
-
-	class WindowUpdateTask {
-	public:
-		enum WindowUpdateAction
-		{
-			WND_SHOW = 1,
-			WND_HIDE,
-			WND_DESTROY
-		};
-		
-		virtual void run(Ogre::Real elapsedTime) = 0;
-
-		const CEGUI::Point&amp; getCurrentPosition() const;
-		const Ogre::Real&amp; getCurrentAlpha() const;
-		const Ogre::Real&amp; getTimeLeft() const;
-		CeGuiWindow* getWindow();
-		WindowUpdateAction getAction() const;
-
-		virtual bool isFinished() const = 0;
-		
-		void setAction(WindowUpdateAction action);
-		virtual void setTargetAlpha(const Ogre::Real&amp; alpha);
-	
-	protected:
-		WindowUpdateTask(CeGuiWindow* window, WindowUpdateAction action);
-
-		CeGuiWindow* mWindow;
-		CEGUI::Point mCurrentPoint;
-		Ogre::Real mCurrentAlpha;
-
-	private:
-		WindowUpdateAction mAction;
-	};
-
-	class WindowMoveTask : public WindowUpdateTask
-	{
-	public:
-		WindowMoveTask(CeGuiWindow* window, Ogre::Real time, WindowUpdateAction action,
-			int targetX, int targetY);
-
-		void run(Ogre::Real elapsedTime);
-		bool isFinished() const;
-
-	private:
-		Ogre::Real mTime; 
-		CEGUI::Point mTargetPoint;
-		CEGUI::Point mRatePoint;
-	};
-
-	class WindowFadeTask : public WindowUpdateTask
-	{
-	public:
-		WindowFadeTask(CeGuiWindow* window, WindowUpdateAction action, 
-			Ogre::Real targetAlpha);
-
-		void run(Ogre::Real elapsedTime);
-		void setTargetAlpha(const Ogre::Real&amp; alpha);
-		bool isFinished() const;
-
-	private:
-		static const float DEFAULT_RATE;
-
-		Ogre::Real mTargetAlpha;
-		Ogre::Real mRate;
-	};
-
-	class WindowFadeInOutTask : public WindowUpdateTask
-	{
-	public:
-		WindowFadeInOutTask(CeGuiWindow* window, Ogre::Real timeFade, Ogre::Real timeHold, 
-			WindowUpdateAction action);
-
-		void run(Ogre::Real elapsedTime);
-		bool isFinished() const;
-
-	private:
-		Ogre::Real mTime; 
-		Ogre::Real mTimeFade;
-		Ogre::Real mTimeHold;
-		Ogre::Real mRateAlpha;
-	};
-
-	class WindowUpdater : public GameTask
-	{
-	public:
-		void run(Ogre::Real elapsedTime);
-
-		void fadeIn(
-			CeGuiWindow* window, 
-			float targetAlpha = 1.0);
-
-		void fadeOut(
-			CeGuiWindow* window, 
-			bool destroy);
-
-		void fadeInOut(
-			CeGuiWindow* window, 
-			Ogre::Real timeFade, 
-			Ogre::Real timeHold, 
-			bool destroy = false);
-
-		void moveOutLeft(
-			CeGuiWindow* window, 
-			Ogre::Real time, 
-			bool destroy);
-
-        virtual const Ogre::String&amp; getName() const;
-
-	private:
-		std::set&lt;WindowUpdateTask*&gt; mTasks;
-	};
-
-
-}
-
-#endif

Modified: rl/trunk/engine/ui/src/CeGuiWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CeGuiWindow.cpp	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/ui/src/CeGuiWindow.cpp	2007-02-01 23:12:57 UTC (rev 3015)
@@ -23,7 +23,8 @@
 #include &quot;CeGuiHelper.h&quot;
 #include &quot;InputManager.h&quot;
 #include &quot;WindowManager.h&quot;
-#include &quot;WindowUpdater.h&quot;
+#include &quot;WindowFadeJob.h&quot;
+#include &quot;JobScheduler.h&quot;
 
 using namespace std;
 using namespace CEGUI;
@@ -38,8 +39,7 @@
 	: mVisible(false),
 		mModal(modal),
 		mWindowType(type),
-		mCloseOnEscape(closeOnEscape),
-		mUpdateTask(NULL)
+		mCloseOnEscape(closeOnEscape)
 	{
         LOG_MESSAGE(Logger::UI, 
 		    &quot;Lade Fenster '&quot; + Ogre::String(xmlfile.c_str()) + &quot;'&quot;);
@@ -111,22 +111,23 @@
 
 	void CeGuiWindow::setVisible(bool visible, bool destroy)
 	{
-		static float FADE_TIME = 0.2f;
-
 		if(mVisible != visible)
 		{
 			if (visible)
 			{
 				InputManager::getSingleton().registerCeGuiWindow(this);
-				WindowManager::getSingleton()._fadeIn(this, mNormalAlpha);
-				mVisible = true;
+                JobScheduler::getSingleton().addJob(
+                    new WindowFadeJob(this, WindowFadeJob::FADE_IN, mNormalAlpha));
 			}
 			else
 			{
 				InputManager::getSingleton().unregisterCeGuiWindow(this);
-				WindowManager::getSingleton()._fadeOut(this, destroy);
-				mVisible = false;
+                JobScheduler::getSingleton().addJob(
+                    new WindowFadeJob(this,
+                    destroy ? WindowFadeJob::FADE_OUT_AND_DESTROY : WindowFadeJob::FADE_OUT,
+                    0.0f));
 			}
+            mVisible = visible;
 		}
 	}
 
@@ -145,16 +146,6 @@
 		return mCloseOnEscape;
 	}
 
-	bool CeGuiWindow::isFading()
-	{
-		return mFading;
-	}
-
-	void CeGuiWindow::setFading(bool fading)
-	{
-		mFading = fading;
-	}
-
 	CeGuiWindow::WindowType CeGuiWindow::getWindowType()
 	{
 		return mWindowType;
@@ -297,16 +288,6 @@
 		return mNamePrefix;
 	}
 
-	void CeGuiWindow::_setUpdateTask(WindowUpdateTask* task)
-	{
-		mUpdateTask = task;
-	}
-
-	WindowUpdateTask* CeGuiWindow::_getUpdateTask()
-	{
-		return mUpdateTask;
-	}
-
 	void CeGuiWindow::windowHid()
 	{
 	}

Modified: rl/trunk/engine/ui/src/DialogCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogCharacterController.cpp	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/ui/src/DialogCharacterController.cpp	2007-02-01 23:12:57 UTC (rev 3015)
@@ -75,12 +75,12 @@
 		mCharacterActor-&gt;getPhysicalThing()-&gt;unfreeze();
 		if (mDialogWindow != NULL)
 		{
-			WindowManager::getSingleton().destroyWindow(mDialogWindow);
+            mDialogWindow-&gt;setVisible(false, true);
 			mDialogWindow = NULL;
 		}
 		if (mSubtitleWindow != NULL)
 		{
-			WindowManager::getSingleton().destroyWindow(mSubtitleWindow);
+            mSubtitleWindow-&gt;setVisible(false, true);
 			mSubtitleWindow = NULL;
 		}
 		delete mSoundObject;

Modified: rl/trunk/engine/ui/src/InfoPopup.cpp
===================================================================
--- rl/trunk/engine/ui/src/InfoPopup.cpp	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/ui/src/InfoPopup.cpp	2007-02-01 23:12:57 UTC (rev 3015)
@@ -78,10 +78,12 @@
 
 	void InfoPopup::setVisible(bool visible, bool destroyAfterHide)
 	{
-		if (visible &amp;&amp; !isVisible())
-		{
-			WindowManager::getSingleton()._fadeInOut(this, 0.25f, 2.0f);
-		}
+        CeGuiWindow::setVisible(visible, destroyAfterHide);
+        ///@todo implement the following, when timed jobs are possible.
+		//if (visible &amp;&amp; !isVisible())
+		//{
+		//	WindowManager::getSingleton()._fadeInOut(this, 0.25f, 2.0f);
+		//}
 	}
 
 	void InfoPopup::questStateChanged(QuestEvent* anEvent)

Added: rl/trunk/engine/ui/src/WindowFadeJob.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFadeJob.cpp	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/ui/src/WindowFadeJob.cpp	2007-02-01 23:12:57 UTC (rev 3015)
@@ -0,0 +1,66 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2005 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#include &quot;WindowFadeJob.h&quot;
+
+#include &quot;CeGuiWindow.h&quot;
+#include &quot;CeGuiHelper.h&quot;
+#include &quot;WindowManager.h&quot;
+
+using namespace CEGUI;
+using namespace Ogre;
+
+namespace rl
+{
+    WindowFadeJob::WindowFadeJob(CeGuiWindow* window, Mode mode, Real targetAlpha, Real changeRate)
+        : Job(true, true),
+        mWindow(window),
+        mMode(mode),
+        mChangeRate(changeRate),
+        mCurrentAlpha(mode == FADE_IN ? 0.0f : 1.0f),
+        mTargetAlpha(mode == FADE_IN ? targetAlpha : 0.0f)
+    {
+        // Ensure visibility. This is independant of whether we're fading in or out.
+        mWindow-&gt;getWindow()-&gt;setVisible(true);
+        mWindow-&gt;getWindow()-&gt;setAlpha(mCurrentAlpha);
+    }
+
+    bool WindowFadeJob::execute(Real time)
+    {
+        mCurrentAlpha += time * mChangeRate * Math::Sign(mTargetAlpha - mCurrentAlpha);
+
+        // Are we done now?
+        if ((mMode == FADE_IN &amp;&amp; mCurrentAlpha &gt;= mTargetAlpha) ||
+            (mMode != FADE_IN &amp;&amp; mCurrentAlpha &lt;= mTargetAlpha))
+        {
+            discard();
+            return true;
+        }
+        mWindow-&gt;getWindow()-&gt;setAlpha(mCurrentAlpha);
+
+        return false;
+    }
+
+    void WindowFadeJob::discard()
+    {
+        mWindow-&gt;getWindow()-&gt;setAlpha(mTargetAlpha);
+        mWindow-&gt;getWindow()-&gt;setVisible(mMode == FADE_IN ? true : false);
+        if (mMode == FADE_OUT_AND_DESTROY)
+        {
+            WindowManager::getSingleton().destroyWindow(mWindow);
+        }
+    }
+}

Modified: rl/trunk/engine/ui/src/WindowManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowManager.cpp	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/ui/src/WindowManager.cpp	2007-02-01 23:12:57 UTC (rev 3015)
@@ -21,7 +21,6 @@
 #include &quot;Exception.h&quot;
 #include &quot;GameLoop.h&quot;
 #include &quot;UiSubsystem.h&quot;
-#include &quot;WindowUpdater.h&quot;
 
 template&lt;&gt; rl::WindowManager* Ogre::Singleton&lt;rl::WindowManager&gt;::ms_Singleton = 0;
 
@@ -31,15 +30,10 @@
 
 	WindowManager::WindowManager()
 	{
-		mWindowUpdater = new WindowUpdater();
-        GameLoop::getSingleton().addTask(mWindowUpdater, GameLoop::TG_GRAPHICS);
-		//mWindowUpdater-&gt;setPaused(true);
 	}
 
 	WindowManager::~WindowManager()
 	{
-		GameLoop::getSingleton().removeTask(mWindowUpdater);
-		delete mWindowUpdater;
 	}
 	
 	void WindowManager::registerWindow(CeGuiWindow* window)
@@ -47,20 +41,14 @@
 		mWindowList.push_back(window);
 	}
 
-	bool WindowManager::destroyWindow(CeGuiWindow* window)
+	void WindowManager::destroyWindow(CeGuiWindow* window)
 	{
-		mWindowUpdater-&gt;fadeOut(window, true);
-		return true;
-	}
-
-	void WindowManager::_doDestroyWindow(CeGuiWindow* window)
-	{
 		mWindowList.remove(window);
 		window-&gt;getWindow()-&gt;hide();
 		CeGuiWindow::getRoot()-&gt;removeChildWindow(window-&gt;getWindow());
 		CEGUI::WindowManager::getSingleton().destroyWindow(window-&gt;getWindow());
 
-		//FIXME: memory leak, aber destroyWindow macht sonst Probleme (heap corruption)
+		///@todo memory leak, aber destroyWindow macht sonst Probleme (heap corruption)
 		//delete window;		
 	}
 
@@ -100,25 +88,4 @@
 	{
 		return Ogre::Singleton&lt;WindowManager&gt;::getSingletonPtr();
 	}
-
-	void WindowManager::_fadeIn(CeGuiWindow* window, float targetAlpha)
-	{
-		mWindowUpdater-&gt;fadeIn(window, targetAlpha);
-	}
-
-	void WindowManager::_fadeOut(CeGuiWindow* window, bool destroy)
-	{
-		mWindowUpdater-&gt;fadeOut(window, destroy);
-	}
-
-	void WindowManager::_fadeInOut(CeGuiWindow* window, Ogre::Real timeFade, 
-		Ogre::Real timeHold, bool destroy)
-	{
-		mWindowUpdater-&gt;fadeInOut(window, timeFade, timeHold, destroy);
-	}
-
-	void WindowManager::_moveOutLeft(CeGuiWindow* window, Ogre::Real time, bool destroy)
-	{
-		mWindowUpdater-&gt;moveOutLeft(window, time, destroy);
-	}
 }

Deleted: rl/trunk/engine/ui/src/WindowUpdater.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowUpdater.cpp	2007-01-30 20:08:03 UTC (rev 3014)
+++ rl/trunk/engine/ui/src/WindowUpdater.cpp	2007-02-01 23:12:57 UTC (rev 3015)
@@ -1,330 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2005 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#include &quot;CeGuiWindow.h&quot;
-#include &quot;CeGuiHelper.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;WindowManager.h&quot;
-#include &quot;WindowUpdater.h&quot;
-
-using namespace CEGUI;
-
-const float rl::WindowFadeTask::DEFAULT_RATE = 1.0f / 0.25f; // fade time 250ms
-
-namespace rl {
-
-	WindowUpdateTask::WindowUpdateTask(
-		CeGuiWindow* window, 
-		WindowUpdateTask::WindowUpdateAction action)
-	:	mWindow(window),
-		mAction(action)
-	{
-        mCurrentPoint = mWindow-&gt;getWindow()-&gt;getPixelRect().getPosition();
-		mCurrentAlpha = mWindow-&gt;getWindow()-&gt;getAlpha();
-	}
-
-	WindowMoveTask::WindowMoveTask(		
-		CeGuiWindow* window, Ogre::Real time, 
-		WindowUpdateTask::WindowUpdateAction action, 
-		int targetX, int targetY)
-	:	WindowUpdateTask(window, action),
-		mTargetPoint(targetX, targetY)
-	{
-		CEGUI::Point delta = mTargetPoint - mWindow-&gt;getWindow()-&gt;getPixelRect().getPosition();
-		mRatePoint = CEGUI::Point(delta.d_x / mTime, delta.d_y / mTime);
-	}
-
-	void WindowMoveTask::run(Ogre::Real elapsedTime)
-	{
-		mTime -= elapsedTime;
-
-		if (mTime &gt; 0)
-		{
-			mCurrentPoint += CEGUI::Point(mRatePoint.d_x * elapsedTime, mRatePoint.d_y * elapsedTime);
-		}
-		else if (mTime &lt;= 0)
-		{
-			mTime = 0;
-			mCurrentPoint = mTargetPoint;
-			mWindow-&gt;setFading(false);
-		}
-	}
-
-	bool WindowMoveTask::isFinished() const
-	{
-		return mTime &lt;= 0;
-	}
-
-	WindowFadeTask::WindowFadeTask(CeGuiWindow* window,
-		WindowUpdateAction action, Ogre::Real targetAlpha)
-	:	WindowUpdateTask(window, action),
-		mTargetAlpha(targetAlpha),
-		mRate(DEFAULT_RATE)
-	{
-	}
-
-	void WindowFadeTask::run(Ogre::Real elapsedTime)
-	{
-		if (getAction() == WND_SHOW)
-		{
-			if (mCurrentAlpha &lt; mTargetAlpha)
-			{
-				mCurrentAlpha += mRate * elapsedTime;
-			}
-
-			if (mCurrentAlpha &gt;= mTargetAlpha)
-			{
-				mCurrentAlpha = mTargetAlpha;
-				mWindow-&gt;setFading(false);
-			}
-		}
-		else if (getAction() == WND_HIDE || getAction() == WND_DESTROY)
-		{
-			if (mCurrentAlpha &gt; mTargetAlpha)
-			{
-				mCurrentAlpha -= mRate * elapsedTime;
-			}
-			
-			if (mCurrentAlpha &lt;= mTargetAlpha)
-			{
-				mCurrentAlpha = mTargetAlpha;
-				mWindow-&gt;setFading(false);
-			}
-		}
-
-		LOG_DEBUG(Logger::UI, 
-			mWindow-&gt;getName()
-			+ &quot; Curr: &quot;
-			+ Ogre::StringConverter::toString(mCurrentAlpha)
-			+ &quot; Target: &quot;
-			+ Ogre::StringConverter::toString(mTargetAlpha));
-
-	}
-
-	bool WindowFadeTask::isFinished() const
-	{
-		return mCurrentAlpha == mTargetAlpha;
-	}
-
-	const CEGUI::Point&amp; WindowUpdateTask::getCurrentPosition() const
-	{
-		return mCurrentPoint;
-	}
-
-	const Ogre::Real&amp; WindowUpdateTask::getCurrentAlpha() const
-	{
-		return mCurrentAlpha;
-	}
-
-	WindowUpdateTask::WindowUpdateAction WindowUpdateTask::getAction() const
-	{
-		return mAction;
-	}
-
-	void WindowUpdateTask::setAction(WindowUpdateTask::WindowUpdateAction action)
-	{
-		mAction = action;
-	}
-
-	CeGuiWindow* WindowUpdateTask::getWindow()
-	{
-		return mWindow;
-	}
-
-   
-	void WindowUpdateTask::setTargetAlpha(const Ogre::Real&amp; alpha)
-	{
-	}
-
-	void WindowFadeTask::setTargetAlpha(const Ogre::Real&amp; alpha)
-	{
-		mTargetAlpha = alpha;
-	}
-
-	WindowFadeInOutTask::WindowFadeInOutTask(
-		CeGuiWindow* window, Ogre::Real timeFade, Ogre::Real timeHold, 
-		WindowUpdateAction action)
-	:	WindowUpdateTask(window, action),
-		mTimeFade(timeFade),
-		mTimeHold(timeHold),
-		mTime(2*timeFade + timeHold)
-	{
-		mRateAlpha = window-&gt;getNormalAlpha() / mTimeFade;
-	}
-
-	void WindowFadeInOutTask::run(Ogre::Real elapsedTime)
-	{
-		mTime -= elapsedTime;
-
-		if (mTime &gt; mTimeFade + mTimeHold)
-		{
-			mCurrentAlpha += mRateAlpha * elapsedTime;
-		}
-		else if (mTime &gt; mTimeHold)
-		{
-			mCurrentAlpha = mWindow-&gt;getNormalAlpha();
-		}
-		else if (mTime &gt; 0)
-		{
-			mCurrentAlpha -= mRateAlpha * elapsedTime;
-		}
-		else if (mTime &lt;= 0)
-		{
-			mTime = 0;
-			mCurrentAlpha = 0.0;
-			mWindow-&gt;setFading(false);
-		}
-	}
-
-	bool WindowFadeInOutTask::isFinished() const
-	{
-		return mTime &lt;= 0;
-	}
-
-	void WindowUpdater::run(Ogre::Real elapsedTime)
-	{
-		if (mTasks.empty())
-			return;
-
-		vector&lt;CeGuiWindow*&gt; deleteWindows;
-
-		for (std::set&lt;WindowUpdateTask*&gt;::iterator it = mTasks.begin(); it != mTasks.end();)
-		{
-			WindowUpdateTask* task = *it;
-			task-&gt;run(elapsedTime);
-			CeGuiWindow* wnd = task-&gt;getWindow();
-            wnd-&gt;getWindow()-&gt;setPosition(
-                CeGuiHelper::asAbsolute(task-&gt;getCurrentPosition()));
-			wnd-&gt;getWindow()-&gt;setAlpha(task-&gt;getCurrentAlpha());
-			if (task-&gt;isFinished())
-			{
-				mTasks.erase(it++);
-				switch (task-&gt;getAction())
-				{
-				case WindowUpdateTask::WND_DESTROY:
-					WindowManager::getSingleton()._doDestroyWindow(wnd);
-					break;
-				case WindowUpdateTask::WND_HIDE:
-					wnd-&gt;windowHid();
-					wnd-&gt;getWindow()-&gt;hide();
-					wnd-&gt;getWindow()-&gt;setAlpha(wnd-&gt;getNormalAlpha());
-					break;
-				}
-				wnd-&gt;_setUpdateTask(NULL);
-				delete task;
-			}
-			else
-			{
-				++it;
-			}
-		}
-	}
-
-	void WindowUpdater::fadeIn(CeGuiWindow* window, Ogre::Real targetAlpha)
-	{
-		if (window == NULL)
-			Throw(NullPointerException, &quot;window  argument is NULL&quot;);
-
-		if (window-&gt;_getUpdateTask() == NULL)
-		{
-			WindowUpdateTask* task = new WindowFadeTask(
-					window, 
-					WindowUpdateTask::WND_SHOW, 
-					targetAlpha);
-			mTasks.insert(task);
-			window-&gt;_setUpdateTask(task);
-		}
-		else
-		{
-			WindowUpdateTask* task  = window-&gt;_getUpdateTask();
-			task-&gt;setTargetAlpha(targetAlpha);
-			task-&gt;setAction(WindowUpdateTask::WND_SHOW);			
-		}
-
-		window-&gt;getWindow()-&gt;setVisible(true);
-		window-&gt;getWindow()-&gt;setAlpha(0.0);
-		window-&gt;setFading(true);
-	}
-
-	void WindowUpdater::fadeOut(CeGuiWindow* window, bool destroy)
-	{
-		if (window == NULL)
-			Throw(NullPointerException, &quot;window  argument is NULL&quot;);
-
-		if (window-&gt;_getUpdateTask() == NULL)
-		{
-			WindowUpdateTask* task = new WindowFadeTask(
-					window, 
-					destroy 
-						? WindowUpdateTask::WND_DESTROY 
-						: WindowUpdateTask::WND_HIDE, 
-					0.0);
-			mTasks.insert(task);
-			window-&gt;_setUpdateTask(task);
-		}
-		else
-		{
-			WindowUpdateTask* task  = window-&gt;_getUpdateTask();
-			task-&gt;setTargetAlpha(0.0);
-			task-&gt;setAction(
-				destroy ? WindowUpdateTask::WND_DESTROY 
-						: WindowUpdateTask::WND_HIDE);
-		}
-		window-&gt;setFading(true);
-	}
-
-	void WindowUpdater::fadeInOut(rl::CeGuiWindow *window, Ogre::Real timeFade, 
-		Ogre::Real timeHold, bool destroy)
-	{
-		if (window == NULL)
-			Throw(NullPointerException, &quot;window  argument is NULL&quot;);
-
-		WindowUpdateTask* task = new WindowFadeInOutTask(
-				window, 
-				timeFade, timeHold, 
-				destroy ? WindowUpdateTask::WND_DESTROY : WindowUpdateTask::WND_HIDE);
-		mTasks.insert(task);
-		window-&gt;setFading(true);
-		window-&gt;_setUpdateTask(task);
-	}
-
-	void WindowUpdater::moveOutLeft(CeGuiWindow* window, Ogre::Real time, bool destroy)
-	{
-		if (window == NULL)
-			Throw(NullPointerException, &quot;window  argument is NULL&quot;);
-
-		CEGUI::Window* wnd = window-&gt;getWindow();
-		WindowUpdateTask* task = new WindowMoveTask(
-				window, 
-				time,
-				destroy ? WindowUpdateTask::WND_DESTROY : WindowUpdateTask::WND_HIDE, 
-                -wnd-&gt;getPixelSize().d_width, 
-                wnd-&gt;getPixelRect().getPosition().d_y);
-		mTasks.insert(task);
-		window-&gt;setFading(true);
-		window-&gt;_setUpdateTask(task);
-	}
-
-     const Ogre::String&amp; WindowUpdater::getName() const
-    {
-        static Ogre::String NAME = &quot;WindowUpdater&quot;;
-
-        return NAME;
-    }
-
-
-}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000087.html">[Dsa-hl-svn] r3016 - in rl/trunk: engine/common/include	engine/common/src engine/core/include	engine/core/include/nulldriver engine/core/src	engine/core/src/nulldriver engine/rules/include	engine/rules/src engine/script/include engine/script/src	engine/script/swig engine/startup/src engine/ui/include	engine/ui/src engine/uicomponents/include	engine/uicomponents/src plugins/fmod4driver/include	plugins/fmod4driver/src plugins/openaldriver/include	plugins/openaldriver/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#86">[ date ]</a>
              <a href="thread.html#86">[ thread ]</a>
              <a href="subject.html#86">[ subject ]</a>
              <a href="author.html#86">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
