<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r3086 - in dependencies/OgreNewt: . include/OgreNewt	src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-February/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3086%20-%20in%20dependencies/OgreNewt%3A%20.%20include/OgreNewt%0A%09src&In-Reply-To=%3C200702280328.l1S3SDlj017227%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000156.html">
   <LINK REL="Next"  HREF="000158.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r3086 - in dependencies/OgreNewt: . include/OgreNewt	src</H1>
    <B>natoka at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3086%20-%20in%20dependencies/OgreNewt%3A%20.%20include/OgreNewt%0A%09src&In-Reply-To=%3C200702280328.l1S3SDlj017227%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r3086 - in dependencies/OgreNewt: . include/OgreNewt	src">natoka at mail.berlios.de
       </A><BR>
    <I>Wed Feb 28 04:28:13 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000156.html">[Dsa-hl-svn] r3085 - in rl/trunk/engine: core/include core/src	ui/src
</A></li>
        <LI>Next message: <A HREF="000158.html">[Dsa-hl-svn] r3087 - rl/trunk/engine/core/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#157">[ date ]</a>
              <a href="thread.html#157">[ thread ]</a>
              <a href="subject.html#157">[ subject ]</a>
              <a href="author.html#157">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: natoka
Date: 2007-02-28 04:27:47 +0100 (Wed, 28 Feb 2007)
New Revision: 3086

Added:
   dependencies/OgreNewt/DifferencesToOgreCVS.txt
Modified:
   dependencies/OgreNewt/include/OgreNewt/OgreNewt.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_BasicJoints.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_Body.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_BodyIterator.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_CollisionPrimitives.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_ContactCallback.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_Debugger.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_Joint.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_MaterialID.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_MaterialPair.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_Prerequisites.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_RayCast.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_Tools.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_TreeCollisionSerializer.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_Vehicle.h
   dependencies/OgreNewt/include/OgreNewt/OgreNewt_World.h
   dependencies/OgreNewt/src/OgreNewt_BasicJoints.cpp
   dependencies/OgreNewt/src/OgreNewt_Body.cpp
   dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp
   dependencies/OgreNewt/src/OgreNewt_Debugger.cpp
   dependencies/OgreNewt/src/OgreNewt_MaterialID.cpp
   dependencies/OgreNewt/src/OgreNewt_MaterialPair.cpp
   dependencies/OgreNewt/src/OgreNewt_RayCast.cpp
   dependencies/OgreNewt/src/OgreNewt_Tools.cpp
   dependencies/OgreNewt/src/OgreNewt_TreeCollisionSerializer.cpp
   dependencies/OgreNewt/src/OgreNewt_World.cpp
Log:
backportbackported OgreNewt cvs

documented differences between cvs and svn (most, but most likely not all)

Added: dependencies/OgreNewt/DifferencesToOgreCVS.txt
===================================================================
--- dependencies/OgreNewt/DifferencesToOgreCVS.txt	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/DifferencesToOgreCVS.txt	2007-02-28 03:27:47 UTC (rev 3086)
@@ -0,0 +1,194 @@
+This file partionally documents the differences between this svn repository and
+the Ogre addons cvs repository. Some pieces might be outdated, because they 
+have been merged, other pieces might not be mentioned. Therefore this is 
+essentially an overview and by no means complete.
+
+if you don't understand some parts, feel free to contact me
+
+So enjoy reading it,
+Natoka
+
+P.s. most of the #include Prerequisites have been removed in favour of a
+better approach (which means less files to parse for the compiler).
+
+OgreNewt.h:
+	comment changes
+	rl - #include Framelisterner ...
+
+OgreNewt_BasicJoints.h:
+	rl:
+	currently: missing a _OgreNewtExport for CustomRigidJoint
+	cvs: no include of prerequisites
+OgreNewt_BasicJoints.cpp:
+	rl:
+	cvs:
+	#include &lt;Newton.h&gt;
+	m_Accel bug (not initialized)
+
+OgreNewt_Body.h:
+	rl:
+	#include Prerequisites
+	fastdelegates
+	uses CollisionPtr
+	getOgreNode returns an Ogre::SceneNode
+						[fixed] natoka
+		returns an Ogre::Node now ...
+	getOffset()
+	setOffset()
+	getOrientation()
+	setOrientation()
+
+	cvs:
+	boost::function
+	getOgreNode returns an Ogre::Node (this is more generic)
+	autoactiveCallback();
+		auto activate / deactivate callback
+						[takeover] natoka
+						(uses fastdelegates in rl)
+OgreNewt_Body.cpp:
+	rl:
+
+	Callbacks have a if (m_callback != callback) m_callback = callback
+		reason - unknown ...
+	modified setPositionOrientation (to utilize offset/orientationbias)
+
+	cvs:
+	look above
+
+OgreNewt_BodyIterator.h:
+	rl:
+	cvs:
+	newline at end of file
+
+OgreNewt_Collision.h:
+	rl:
+	typedef of CollisionPtr
+	utilization of CollisionPtr to pass Collision objects
+OgreNewt_Collision.cpp:
+	rl:
+	uses CollisionPtr
+
+OgreNewt_CollisionPrimitives.h:
+	rl:
+	#include Prerequisites
+	indentation difference
+	ConvexHull constructor utilizes Ogre::Entity
+	
+	uses CollisionPtr
+	non virtual ~treecollision	[fixed] natoka
+	missing TreecollisionSceneParser [fixed] natoka
+	added better comments
+
+	cvs:
+	ConvexHull constructor utilizes Ogre::SceneNode
+	virtual ~treecollision
+OgreNewt_CollisionPrimitives.cpp:
+	rl:
+	
+	cvs:
+	start()			[takeover] (should be inlined)
+	addVertex()		[takeover] (should be inlined)
+	finalize()		[takeover] (should be inlined)
+	unsigned int in loops	[takeover] natoka
+	TreecollisionSceneParser[takeover] natoka
+
+OgreNewt_ContactCallback.h:
+	rl:
+	#include Prerequisites
+
+	cvs:
+	material and contact get functions for newton mat &amp; contanct
+
+OgreNewt_Debugger.h:
+	rl:
+	destructor defined with code
+
+	cvs:
+	additional	deinit();
+OgreNewt_Debugger.h:
+	rl:
+
+	cvs:
+	indent				[takeover] natoka
+	destructor			[takeover] natoka
+	additional	deinit();	[takeover] natoka
+	uses detachAllObjects		[takeover] natoka
+		in showLines() and
+		hideLines()
+
+OgreNewt_Joint.h:
+	rl:
+	#include Prerequisites
+
+OgreNewt_MaterialID.h:
+	rl:
+	#include Prerequisites
+OgreNewt_MaterialID.cpp:
+	rl:
+	missing newline			[fixed] natoka
+
+OgreNewt_MaterialPair.h:
+	rl:
+	#include Prerequisites
+OgreNewt_MaterialPair.cpp:
+	newline at end
+
+OgreNewt_Prerequisites.h:
+	rl:
+	include &lt;stddef.h&gt;
+
+OgreNewt_RayCast.h:
+	rl:
+	BasicRaycastInfo() constructor in the header [fixed] natoka
+	BasicRaycastInfo() operator &lt; in the header  [!!!!!]
+	virtual ~BasicRaycast()
+
+	cvs:
+	indent, newlines (empty)		[takeover] natoka
+	userPrefilteredCallback()		[takeover] natoka
+		user callback pre-filter function
+	newtonRaycastPrefilter()		[takeover] natoka
+	nonvirtual ~BasicRaycast()
+
+OgreNewt_Tools.h:
+	rl:
+	uses 'using namespace Ogre' 	(args)	[fixed]	natoka
+	utilizes CollisionPtr
+	CalcSphereHollor() renamed to CalcSphereHollow()	[fixed] natoka
+
+	cvs:
+OgreNewt_Tools.cpp:
+	rl:
+	CollisionPointDistance()
+		doesn't missuse globalpt parameter
+
+	cvs:
+	uses 'using namespace Ogre' within source (cleaner) [takeover] natoka
+	CollisionPointDistance()
+		globalpt parameter misused for calculation
+
+
+OgreNewt_TreeCollisionSerializer.h
+	rl:
+	#include Prerequisites
+OgreNewt_TreeCollisionSerializer.cpp
+	rl:
+	uses 'using namespae Ogre'
+
+	cvs:
+	explicitly uses Ogre:: everywere 	[takeover] natoka
+
+
+OgreNewt_Vehicle.h:
+	rl:
+	#include Prerequisites
+
+OgreNewt_World.h:
+	rl:
+	uses fastdelegates
+
+	cvs:
+	uses boost::function
+OgreNewt_World.cpp:
+	newline at file end
+	

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt.h	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt.h	2007-02-28 03:27:47 UTC (rev 3086)
@@ -8,11 +8,11 @@
 
 	main header file.
 
-	current version:  0.06
+	current version:  0.10
 
-		Newton version: 1.5
+		Newton version: 1.53
 
-		Ogre version: Dagon branch
+		Ogre version: Eihort (1.4.x)
 
 */
 
@@ -38,8 +38,9 @@
 #include &quot;OgreNewt_BodyIterator.h&quot;
 #include &quot;OgreNewt_Debugger.h&quot;
 
-/*! \mainpage OgreNewt Library version 0.07
 
+/*! \mainpage OgreNewt Library version 0.10
+
 	\section into_sec Introduction
 
 	OgreNewt is an OOP wrapper for integrating the Newton Dynamics Physics SDK with OGRE.
@@ -47,12 +48,21 @@
 	\section new New in this Version
 
 	New in this version!
+		- OgreNewt and it's demos are now fully compatible with Ogre 1.4.x (Eihort).
 		- moved callback system to much more OOP-friendly &quot;fastdelegate&quot; system.  callbacks can now be instance-specific member functions!
+		- Addition of script files for compiling under linux (Scons)
+		- slight modification to the ContactCallback class to allow access to Newton structures from the outside.
+
+	previous changes...
+		- some cosmetic changes to make the wrapper compile more easily under Linux and other non-windows platforms.
+		- updated to work with the release version of Ogre dagon (1.2)
+		- updated to work with version 1.53 of Newton
+		- raycast now has an optional pre-filter to ignore specific bodies from the raycast.
+		- various other clean-up!
+		- moved callback system to much more OOP-friendly &quot;boost::function&quot; system.  callbacks can now be instance-specific member functions!
 		- several other small fixes to project files, etc.
 		- automatic convex hull generation system added to supplementary ragdoll class (see demo08).
 		- documentation updated.
-
-	previous changes...
 		- updated to Newton version 1.5
 		- added this documentation!
 		- added buoyancy functionality.
@@ -82,11 +92,11 @@
 	- c:/programming/Ogre/ogrenew						&lt;- ogre installation
 	- c:/programming/Ogre/ogreaddons/OgreNewt			&lt;- OgreNewt main directory.
 	- c:/programming/NewtonSDK							&lt;- Newton SDK.
-	- c:/programming/tinyxml							&lt;- tinyxml library (for ragdoll demo only)
+	- c:/programming/tinyxml							&lt;- tinyxml library (needed for ragdoll demo only)
 
 	\section compiling Compiling
 
-	OgreNewt compiles be default to a static library for linking to your project.  However you can also compile OgreNewt into a dynamic DLL on the 
+	OgreNewt compiles by default to a static library for linking to your project.  However you can also compile OgreNewt into a dynamic DLL on the 
 	Windows platform by using the Debug_DLL and Release_DLL solution build configurations in the MSVC solutions.
 
 	note that if you compile OgreNewt as a dynamic DLL and the default debugger, you will need to manually link to the Line3D.obj file by
@@ -105,3 +115,4 @@
 */
 
 #endif
+

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_BasicJoints.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_BasicJoints.h	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_BasicJoints.h	2007-02-28 03:27:47 UTC (rev 3086)
@@ -1,557 +1,556 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_BASICJOINTS
-#define _INCLUDE_OGRENEWT_BASICJOINTS
-
-#include &quot;OgreNewt_Prerequisites.h&quot;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_World.h&quot;
-#include &quot;OgreNewt_Body.h&quot;
-#include &quot;OgreNewt_Joint.h&quot;
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-
-
-//! Namespace for ready-made joints
-namespace BasicJoints
-{
-
-//! Ball and Socket joint.
-/*!
-	simple ball and socket joint, with limits.
-*/
-class _OgreNewtExport BallAndSocket : public Joint
-{
- 
-public:
-
-	//! constructor
-	/*!
-		\param world pointer to the OgreNewt::World
-		\param child pointer to the child rigid body.
-		\param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
-		\param pos position of the joint in global space
-	*/
-	BallAndSocket( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos );
-	
-	//! destructor.
-	~BallAndSocket();					
-
-	//! retrieve the current joint angle
-	Ogre::Vector3 getJointAngle() const;
-
-	//! retrieve the current joint omega
-	Ogre::Vector3 getJointOmega() const;
-
-	//! retrieve the current joint force.
-	/*!
-		This can be used to find the &quot;stress&quot; on the joint.  you can do special effects like break the joint if the force exceedes some value, etc.
-	*/
-	Ogre::Vector3 getJointForce() const;
-
-	//! set limits for the joints rotation
-	/*!
-		\param pin pin direction in global space
-		\param maxCone max angle for &quot;swing&quot; (in radians)
-		\param maxTwist max angle for &quot;twist&quot;  (in radians)
-	*/
-	void setLimits( const Ogre::Vector3&amp; pin, Ogre::Radian maxCone, Ogre::Radian maxTwist ) const { NewtonBallSetConeLimits( m_joint, &amp;pin.x, (float)maxCone.valueRadians(), (float)maxTwist.valueRadians() ); }
-
-
-};
-
-
-//! hinge joint.
-/*!
-	simple hinge joint.  implement motors/limits through a callback.
-*/
-class _OgreNewtExport Hinge : public Joint
-{
- 
-public:
-
-	//! custom hinge callback function.
-	/*!
-		 use the setCallback() function to assign your custom function to the joint.
-	 */
-	typedef void(*HingeCallback)( Hinge* me );
-
-	//! constructor
-	/*!
-		\param world pointer to the OgreNewt::World
-		\param child pointer to the child rigid body.
-		\param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
-		\param pin direction of the joint pin in global space
-	*/
-	Hinge( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin );
-
-	//! destructor
-	~Hinge();	
-
-	//! retrieve the angle around the pin.
-	Ogre::Radian getJointAngle() const { return Ogre::Radian(NewtonHingeGetJointAngle( m_joint )); }
-
-	//! retrieve the rotational velocity around the pin.
-	Ogre::Real getJointOmega() const { return (Ogre::Real)NewtonHingeGetJointOmega( m_joint ); }
-
-	//! get the force on the joint.
-	Ogre::Vector3 getJointForce() const;
-
-	//! set a custom callback for controlling this joint.
-	/*!
-		Joint callbacks allow you to make complex joint behavior such as limits or motors.  just make a custom static function that
-		accepts a pointer to a OgreNewt::BasicJoints::Hinge as the single parameter.  this function will be called automatically every
-		time you upate the World.
-	*/
-	void setCallback( HingeCallback callback ) { m_callback = callback; }
-
-
-	////////// CALLBACK COMMANDS ///////////
-	// the following commands are only valid from inside a hinge callback function
-
-	//! set acceleration around the joint pin
-	/*!
-		This command is only valid when used inside a custom Hinge callback.
-	*/
-	void setCallbackAccel( Ogre::Real accel );
-
-	//! set minimum joint friction.
-	/*!
-		This command is only valid when used inside a custom Hinge callback.
-	*/
-	void setCallbackFrictionMin( Ogre::Real min );
-
-	//! set maximum joint friction
-	/*!
-		This command is only valid when used inside a custom Hinge callback.
-	*/
-	void setCallbackFrictionMax( Ogre::Real max );
-
-	//! get the current physics timestep.
-	/*!
-		This command is only valid when used inside a custom Hinge callback.
-	*/
-	Ogre::Real getCallbackTimestep() const;
-
-	//! calculate the acceleration neccesary to stop the joint at the specified angle.
-	/*!
-		For implementing joint limits.
-		This command is only valid when used inside a custom Hinge callback.
-	*/
-	Ogre::Real calculateStopAlpha( Ogre::Radian angle ) const;
-
-protected:
-
-	//! newton callback, used internally.
-	static unsigned _CDECL newtonCallback( const NewtonJoint* hinge, NewtonHingeSliderUpdateDesc* desc );
-
-	HingeCallback m_callback;
-	NewtonHingeSliderUpdateDesc* m_desc;
-
-	unsigned m_retval;
-
-
-};
-
-
-//! slider joint.
-/*!
-	simple slider joint.  implement motors/limits through a callback.
-*/
-class _OgreNewtExport Slider : public Joint
-{
- 
-public:
-
-	//! custom slider callback function.
-	/*!
-		 use the setCallback() function to assign your custom function to the joint.
-	 */
-	typedef void(*SliderCallback)( Slider* me );
-
-	//! constructor
-	/*!
-		\param world pointer to the OgreNewt::World
-		\param child pointer to the child rigid body.
-		\param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
-		\param pin direction of the joint pin in global space
-	*/
-	Slider( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin );
-
-	//! destructor.
-	~Slider();
-
-	//! get position of child along the pin
-	Ogre::Real getJointPosit() const { return (Ogre::Real)NewtonSliderGetJointPosit( m_joint ); }
-
-	//! get rotational velocity along the pin
-	Ogre::Real getJointVeloc() const { return (Ogre::Real)NewtonSliderGetJointVeloc( m_joint ); }
-
-	//! get force on the joint.
-	Ogre::Vector3 getJointForce() const;
-
-	//! set a custom callback for controlling this joint.
-	/*!
-		Joint callbacks allow you to make complex joint behavior such as limits or motors.  just make a custom static function that
-		accepts a pointer to a OgreNewt::BasicJoints::Slider as the single parameter.  this function will be called automatically every
-		time you upate the World.
-	*/
-	void setCallback( SliderCallback callback ) { m_callback = callback; }
-
-	////////// CALLBACK COMMANDS ///////////
-	// the following commands are only valid from inside a hinge callback function
-
-	//! set the acceleration along the pin.
-	/*!
-		This command is only valid when used inside a custom Slider callback.
-	*/
-	void setCallbackAccel( Ogre::Real accel );
-
-	//! set minimum friction for the joint
-	/*!
-		This command is only valid when used inside a custom Slider callback.
-	*/
-	void setCallbackFrictionMin( Ogre::Real min );
-
-	//! set maximum friction for the joint.
-	/*!
-		This command is only valid when used inside a custom Slider callback.
-	*/
-	void setCallbackFrictionMax( Ogre::Real max );
-
-	//! get current physics timestep.
-	/*!
-		This command is only valid when used inside a custom Slider callback.
-	*/
-	Ogre::Real getCallbackTimestep() const;
-
-	//! calculate the acceleration neccesary to stop the joint at the specified distance.
-	/*!
-		For implementing joint limits.
-		This command is only valid when used inside a custom Slider callback.
-	*/
-	Ogre::Real calculateStopAccel( Ogre::Real dist ) const;
-
-protected:
-
-	//! newton callback.  used internally.
-	static unsigned _CDECL newtonCallback( const NewtonJoint* slider, NewtonHingeSliderUpdateDesc* desc );
-
-	SliderCallback m_callback;
-	NewtonHingeSliderUpdateDesc* m_desc;
-
-	unsigned m_retval;
-
-};
-
-
-
-//!	this class represents a Universal joint.
-/*!
-	simple universal joint.  implement motors/limits through a callback.
-*/
-class _OgreNewtExport Universal : public Joint
-{
- 
-public:
-	
-	//! custom universal callback function.
-	/*!
-		 use the setCallback() function to assign your custom function to the joint.
-	 */
-	typedef void(*UniversalCallback)( Universal* me );
-
-	//! constructor
-	/*!
-		\param world pointer to the OgreNewt::World
-		\param child pointer to the child rigid body.
-		\param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
-		\param pos position of the joint in global space
-		\param pin0 direction of the first axis of rotation in global space
-		\param pin1 direction of the second axis of rotation in global space
-	*/
-	Universal( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin0, const Ogre::Vector3&amp; pin1 );
-
-	//! destructor
-	~Universal();
-
-	//! get the angle around pin0.
-	Ogre::Radian getJointAngle0() const { return Ogre::Radian(NewtonUniversalGetJointAngle0( m_joint )); }
-
-	//! get the angle around pin1.
-	Ogre::Radian getJointAngle1() const { return Ogre::Radian(NewtonUniversalGetJointAngle1( m_joint )); }
-
-	//! get the rotational velocity around pin0.
-	Ogre::Real getJointOmega0() const { return (Ogre::Real)NewtonUniversalGetJointOmega0( m_joint ); }
-
-	//! get the rotational velocity around pin1.
-	Ogre::Real getJointOmega1() const { return (Ogre::Real)NewtonUniversalGetJointOmega1( m_joint ); }
-
-	//! get the force on the joint.
-	Ogre::Vector3 getJointForce() const;
-
-	//! set a custom callback for controlling this joint.
-	/*!
-		Joint callbacks allow you to make complex joint behavior such as limits or motors.  just make a custom static function that
-		accepts a pointer to a OgreNewt::BasicJoints::Universal as the single parameter.  this function will be called automatically every
-		time you upate the World.
-	*/
-	void setCallback( UniversalCallback callback ) { m_callback = callback; }
-
-	////////// CALLBACK COMMANDS ///////////
-	// the following commands are only valid from inside a hinge callback function
-
-	//! set the acceleration around a particular pin.
-	/*
-		this function can only be called from within a custom callback.
-		\param accel desired acceleration
-		\param axis which pin to use (0 or 1)
-	*/
-	void setCallbackAccel( Ogre::Real accel, unsigned axis );
-
-	//! set the minimum friction around a particular pin
-	/*
-		this function can only be called from within a custom callback.
-		\param min minimum friction
-		\param axis which pin to use (0 or 1)
-	*/
-	void setCallbackFrictionMin( Ogre::Real min, unsigned axis );
-
-	//! set the maximum friction around a particular pin.
-	/*
-		this function can only be called from within a custom callback.
-		\param max maximum friction
-		\param axis which pin to use (0 or 1)
-	*/
-	void setCallbackFrictionMax( Ogre::Real max, unsigned axis );
-
-	//! get the current phsics timestep.
-	/*
-		this function can only be called from within a custom callback.
-	*/
-	Ogre::Real getCallbackTimestep() const;
-
-	//! calculate the acceleration neccesary to stop the joint at the specified angle on pin 0.
-	/*!
-		For implementing joint limits.
-		This command is only valid when used inside a custom  callback.
-	*/
-	Ogre::Real calculateStopAlpha0( Ogre::Real angle ) const;
-
-	//! calculate the acceleration neccesary to stop the joint at the specified angle on pin 1.
-	/*!
-		For implementing joint limits.
-		This command is only valid when used inside a custom  callback.
-	*/
-	Ogre::Real calculateStopAlpha1( Ogre::Real angle ) const;
-
-protected:
-	
-	//! newton callback.  used internally.
-	static unsigned _CDECL newtonCallback( const NewtonJoint* universal, NewtonHingeSliderUpdateDesc* desc );
-
-	UniversalCallback m_callback;
-	NewtonHingeSliderUpdateDesc* m_desc;
-
-	unsigned m_retval;
-
-
-
-};
-
-
-
-//! UpVector joint.
-/*!
-	simple upvector joint.  upvectors remove all rotation except for a single pin.  useful for character controllers, etc.
-*/
-class _OgreNewtExport UpVector : public Joint
-{
- 
-public:
-	//! constructor
-	/*
-		\param world pointer to the OgreNewt::World.
-		\param body pointer to the body to apply the upvector to.
-		\param pin direction of the upvector in global space.
-	*/
-	UpVector( const World* world, const Body* body, const Ogre::Vector3&amp; pin );
-
-	//! destructor
-	~UpVector();
-
-	//! set the pin direction.
-	/*
-		by calling this function in realtime, you can effectively &quot;animate&quot; the pin.
-	*/
-	void setPin( const Ogre::Vector3&amp; pin ) const { NewtonUpVectorSetPin( m_joint, &amp;pin.x ); }
-
-	//! get the current pin direction.
-	Ogre::Vector3 getPin() const;
-
-
-};
-
-
-}	// end NAMESPACE BasicJoints
-
-
-//! namespace for pre-built custom joints
-namespace PrebuiltCustomJoints
-{
-
-	//! Custom2DJoint class
-	/*!
-		This class represents a joint that limits movement to a plane, and rotation only around the normal of that
-		plane.  This can be used to create simple 2D simulations.  it also supports limits and acceleration for spinning.
-		This joint has been used in a few projects, but is not 100% fully-tested.
-	*/
-	class _OgreNewtExport Custom2DJoint : public OgreNewt::CustomJoint
-	{
-	public:
-		//! constructor
-		Custom2DJoint( const OgreNewt::Body* body, const Ogre::Vector3&amp; pin );
-
-		//! destructor
-		~Custom2DJoint() {}
-
-		//! overloaded function that applies the actual constraint.
-		void submitConstraint();
-
-		//! get the current angle of the joint.
-		Ogre::Radian getAngle() const { return mAngle; }
-
-		//! set rotational limits for the joint.
-		void setLimits( Ogre::Degree min, Ogre::Degree max ) { mMin = min, mMax = max; }
-		
-		//! sets whether to enable limits or not for the joint.
-		void setLimitsOn( bool onoff ) { mLimitsOn = onoff; }
-
-		//! returns whether limits are turned on or off for the joint.
-		bool getLimitsOn() const { return mLimitsOn; }
-
-		//! adds rotational acceleration to the joint (like a motor)
-		void addAccel( Ogre::Real accel ) { mAccel = accel; }
-
-		//! resets the joint angle to 0.  this simply sets the internal variable to zero.
-		//! you might want to call this for example after resetting a body.
-		void resetAngle() { mAngle = Ogre::Radian(0.0f); }
-
-		//! get the pin.
-		Ogre::Vector3 getPin() { return mPin; }
-
-	private:
-		Ogre::Vector3 mPin;
-		Ogre::Quaternion mLocalOrient0, mLocalOrient1;
-		Ogre::Vector3 mLocalPos0, mLocalPos1;
-
-		Ogre::Radian mAngle;
-
-		Ogre::Radian mMin;
-		Ogre::Radian mMax;
-
-		bool mLimitsOn;
-
-		Ogre::Real mAccel;
-	};
-
-	//! CustomFixedJoint
-	/*!
-		This joint implements a fully fixed joint, which removes all DOF, creating a completely fixed connection between bodies.
-		This is probably the most expensive kind of joint, and should only be used when really needed.
-	*/
-	class CustomRigidJoint : public OgreNewt::CustomJoint
-	{
-	public:
-		CustomRigidJoint( OgreNewt::Body* child, OgreNewt::Body* parent, Ogre::Vector3 dir, Ogre::Vector3 pos);
-		~CustomRigidJoint();
-
-		void submitConstraint();
-
-	private:
-		Ogre::Vector3 mLocalPos0;
-		Ogre::Vector3 mLocalPos1;
-
-		Ogre::Quaternion mLocalOrient0;
-		Ogre::Quaternion mLocalOrient1;
-	};
-
-
-	//! CutomPulleyJoint
-	/*!
-		This joint implements a pulley system.  note that this joint only works with 2 bodies attached!
-	*/
-	class _OgreNewtExport CustomPulleyJoint : public OgreNewt::CustomJoint
-	{
-	public:
-		//! constructor
-		/*!
-			\param gearRatio float value representing the ratio of movement between parent and child.
-			\param parent pointer to OgreNewt::Body to be the parent body.
-			\param child pointer to the OgreNewt::Body to be the child body.
-			\param parentPin direction vector for movement of parent.
-			\param childPin direction vector for movement of child.
-		*/
-		CustomPulleyJoint( Ogre::Real gearRatio, const Body* parent, const Body* child, const Ogre::Vector3&amp; parentPin, const Ogre::Vector3&amp; childPin );
-		~CustomPulleyJoint() {}
-
-		//! overloaded function to submit the constraint.
-		void submitConstraint();
-
-	private:
-		Ogre::Real			mGearRatio;
-
-		Ogre::Vector3		mLocalPos0, mLocalPos1;
-		Ogre::Quaternion	mLocalOrient0, mLocalOrient1;
-	};
-
-
-	//! CustomGearJoint
-	/*!
-		This class works like 2 gears that mesh, retaining a specific ration between the rotational velocity of the bodies.
-		The gears don't have to rotate around the same axis, that is why 2 pins are supplied.
-	*/
-	class _OgreNewtExport CustomGearJoint : public OgreNewt::CustomJoint
-	{
-	public:
-		/*!
-			\param gearRatio float value representing the ratio of movement between parent and child.
-			\param parent pointer to OgreNewt::Body to be the parent body.
-			\param child pointer to the OgreNewt::Body to be the child body.
-			\param parentPin pin around which the parent's rotation should be tracked.
-			\param childPin pin around which the child's rotation should be tracked.
-		*/
-		CustomGearJoint( Ogre::Real gearRatio, const Body* parent, const Body* child, const Ogre::Vector3&amp; parentPin, const Ogre::Vector3&amp; childPin );
-		~CustomGearJoint() {}
-
-		//! overloaded function to submit the constraint.
-		void submitConstraint();
-
-	private:
-		Ogre::Real			mGearRatio;
-
-		Ogre::Vector3		mLocalPos0, mLocalPos1;
-		Ogre::Quaternion	mLocalOrient0, mLocalOrient1;
-	};
-
-
-
-
-}	// end NAMESPACE PrebuiltCustomJoints
-
-
-}	// end NAMESPACE OgreNewt
-
-#endif
-// _INCLUDE_OGRENEWT_BASICJOINTS
-
+/* 
+	OgreNewt Library
+
+	Ogre implementation of Newton Game Dynamics SDK
+
+	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+
+		by Walaber
+
+*/
+#ifndef _INCLUDE_OGRENEWT_BASICJOINTS
+#define _INCLUDE_OGRENEWT_BASICJOINTS
+
+#include &lt;Newton.h&gt;
+#include &quot;OgreNewt_World.h&quot;
+#include &quot;OgreNewt_Body.h&quot;
+#include &quot;OgreNewt_Joint.h&quot;
+
+// OgreNewt namespace.  all functions and classes use this namespace.
+namespace OgreNewt
+{
+
+
+//! Namespace for ready-made joints
+namespace BasicJoints
+{
+
+//! Ball and Socket joint.
+/*!
+	simple ball and socket joint, with limits.
+*/
+class _OgreNewtExport BallAndSocket : public Joint
+{
+ 
+public:
+
+	//! constructor
+	/*!
+		\param world pointer to the OgreNewt::World
+		\param child pointer to the child rigid body.
+		\param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
+		\param pos position of the joint in global space
+	*/
+	BallAndSocket( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos );
+	
+	//! destructor.
+	~BallAndSocket();					
+
+	//! retrieve the current joint angle
+	Ogre::Vector3 getJointAngle() const;
+
+	//! retrieve the current joint omega
+	Ogre::Vector3 getJointOmega() const;
+
+	//! retrieve the current joint force.
+	/*!
+		This can be used to find the &quot;stress&quot; on the joint.  you can do special effects like break the joint if the force exceedes some value, etc.
+	*/
+	Ogre::Vector3 getJointForce() const;
+
+	//! set limits for the joints rotation
+	/*!
+		\param pin pin direction in global space
+		\param maxCone max angle for &quot;swing&quot; (in radians)
+		\param maxTwist max angle for &quot;twist&quot;  (in radians)
+	*/
+	void setLimits( const Ogre::Vector3&amp; pin, Ogre::Radian maxCone, Ogre::Radian maxTwist ) const { NewtonBallSetConeLimits( m_joint, &amp;pin.x, (float)maxCone.valueRadians(), (float)maxTwist.valueRadians() ); }
+
+
+};
+
+
+//! hinge joint.
+/*!
+	simple hinge joint.  implement motors/limits through a callback.
+*/
+class _OgreNewtExport Hinge : public Joint
+{
+ 
+public:
+
+	//! custom hinge callback function.
+	/*!
+		 use the setCallback() function to assign your custom function to the joint.
+	 */
+	typedef void(*HingeCallback)( Hinge* me );
+
+	//! constructor
+	/*!
+		\param world pointer to the OgreNewt::World
+		\param child pointer to the child rigid body.
+		\param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
+		\param pin direction of the joint pin in global space
+	*/
+	Hinge( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin );
+
+	//! destructor
+	~Hinge();	
+
+	//! retrieve the angle around the pin.
+	Ogre::Radian getJointAngle() const { return Ogre::Radian(NewtonHingeGetJointAngle( m_joint )); }
+
+	//! retrieve the rotational velocity around the pin.
+	Ogre::Real getJointOmega() const { return (Ogre::Real)NewtonHingeGetJointOmega( m_joint ); }
+
+	//! get the force on the joint.
+	Ogre::Vector3 getJointForce() const;
+
+	//! set a custom callback for controlling this joint.
+	/*!
+		Joint callbacks allow you to make complex joint behavior such as limits or motors.  just make a custom static function that
+		accepts a pointer to a OgreNewt::BasicJoints::Hinge as the single parameter.  this function will be called automatically every
+		time you upate the World.
+	*/
+	void setCallback( HingeCallback callback ) { m_callback = callback; }
+
+
+	////////// CALLBACK COMMANDS ///////////
+	// the following commands are only valid from inside a hinge callback function
+
+	//! set acceleration around the joint pin
+	/*!
+		This command is only valid when used inside a custom Hinge callback.
+	*/
+	void setCallbackAccel( Ogre::Real accel );
+
+	//! set minimum joint friction.
+	/*!
+		This command is only valid when used inside a custom Hinge callback.
+	*/
+	void setCallbackFrictionMin( Ogre::Real min );
+
+	//! set maximum joint friction
+	/*!
+		This command is only valid when used inside a custom Hinge callback.
+	*/
+	void setCallbackFrictionMax( Ogre::Real max );
+
+	//! get the current physics timestep.
+	/*!
+		This command is only valid when used inside a custom Hinge callback.
+	*/
+	Ogre::Real getCallbackTimestep() const;
+
+	//! calculate the acceleration neccesary to stop the joint at the specified angle.
+	/*!
+		For implementing joint limits.
+		This command is only valid when used inside a custom Hinge callback.
+	*/
+	Ogre::Real calculateStopAlpha( Ogre::Radian angle ) const;
+
+protected:
+
+	//! newton callback, used internally.
+	static unsigned _CDECL newtonCallback( const NewtonJoint* hinge, NewtonHingeSliderUpdateDesc* desc );
+
+	HingeCallback m_callback;
+	NewtonHingeSliderUpdateDesc* m_desc;
+
+	unsigned m_retval;
+
+
+};
+
+
+//! slider joint.
+/*!
+	simple slider joint.  implement motors/limits through a callback.
+*/
+class _OgreNewtExport Slider : public Joint
+{
+ 
+public:
+
+	//! custom slider callback function.
+	/*!
+		 use the setCallback() function to assign your custom function to the joint.
+	 */
+	typedef void(*SliderCallback)( Slider* me );
+
+	//! constructor
+	/*!
+		\param world pointer to the OgreNewt::World
+		\param child pointer to the child rigid body.
+		\param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
+		\param pin direction of the joint pin in global space
+	*/
+	Slider( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin );
+
+	//! destructor.
+	~Slider();
+
+	//! get position of child along the pin
+	Ogre::Real getJointPosit() const { return (Ogre::Real)NewtonSliderGetJointPosit( m_joint ); }
+
+	//! get rotational velocity along the pin
+	Ogre::Real getJointVeloc() const { return (Ogre::Real)NewtonSliderGetJointVeloc( m_joint ); }
+
+	//! get force on the joint.
+	Ogre::Vector3 getJointForce() const;
+
+	//! set a custom callback for controlling this joint.
+	/*!
+		Joint callbacks allow you to make complex joint behavior such as limits or motors.  just make a custom static function that
+		accepts a pointer to a OgreNewt::BasicJoints::Slider as the single parameter.  this function will be called automatically every
+		time you upate the World.
+	*/
+	void setCallback( SliderCallback callback ) { m_callback = callback; }
+
+	////////// CALLBACK COMMANDS ///////////
+	// the following commands are only valid from inside a hinge callback function
+
+	//! set the acceleration along the pin.
+	/*!
+		This command is only valid when used inside a custom Slider callback.
+	*/
+	void setCallbackAccel( Ogre::Real accel );
+
+	//! set minimum friction for the joint
+	/*!
+		This command is only valid when used inside a custom Slider callback.
+	*/
+	void setCallbackFrictionMin( Ogre::Real min );
+
+	//! set maximum friction for the joint.
+	/*!
+		This command is only valid when used inside a custom Slider callback.
+	*/
+	void setCallbackFrictionMax( Ogre::Real max );
+
+	//! get current physics timestep.
+	/*!
+		This command is only valid when used inside a custom Slider callback.
+	*/
+	Ogre::Real getCallbackTimestep() const;
+
+	//! calculate the acceleration neccesary to stop the joint at the specified distance.
+	/*!
+		For implementing joint limits.
+		This command is only valid when used inside a custom Slider callback.
+	*/
+	Ogre::Real calculateStopAccel( Ogre::Real dist ) const;
+
+protected:
+
+	//! newton callback.  used internally.
+	static unsigned _CDECL newtonCallback( const NewtonJoint* slider, NewtonHingeSliderUpdateDesc* desc );
+
+	SliderCallback m_callback;
+	NewtonHingeSliderUpdateDesc* m_desc;
+
+	unsigned m_retval;
+
+};
+
+
+
+//!	this class represents a Universal joint.
+/*!
+	simple universal joint.  implement motors/limits through a callback.
+*/
+class _OgreNewtExport Universal : public Joint
+{
+ 
+public:
+	
+	//! custom universal callback function.
+	/*!
+		 use the setCallback() function to assign your custom function to the joint.
+	 */
+	typedef void(*UniversalCallback)( Universal* me );
+
+	//! constructor
+	/*!
+		\param world pointer to the OgreNewt::World
+		\param child pointer to the child rigid body.
+		\param parent pointer to the parent rigid body. pass NULL to make the world itself the parent (aka a rigid joint)
+		\param pos position of the joint in global space
+		\param pin0 direction of the first axis of rotation in global space
+		\param pin1 direction of the second axis of rotation in global space
+	*/
+	Universal( const World* world, const OgreNewt::Body* child, const OgreNewt::Body* parent, const Ogre::Vector3&amp; pos, const Ogre::Vector3&amp; pin0, const Ogre::Vector3&amp; pin1 );
+
+	//! destructor
+	~Universal();
+
+	//! get the angle around pin0.
+	Ogre::Radian getJointAngle0() const { return Ogre::Radian(NewtonUniversalGetJointAngle0( m_joint )); }
+
+	//! get the angle around pin1.
+	Ogre::Radian getJointAngle1() const { return Ogre::Radian(NewtonUniversalGetJointAngle1( m_joint )); }
+
+	//! get the rotational velocity around pin0.
+	Ogre::Real getJointOmega0() const { return (Ogre::Real)NewtonUniversalGetJointOmega0( m_joint ); }
+
+	//! get the rotational velocity around pin1.
+	Ogre::Real getJointOmega1() const { return (Ogre::Real)NewtonUniversalGetJointOmega1( m_joint ); }
+
+	//! get the force on the joint.
+	Ogre::Vector3 getJointForce() const;
+
+	//! set a custom callback for controlling this joint.
+	/*!
+		Joint callbacks allow you to make complex joint behavior such as limits or motors.  just make a custom static function that
+		accepts a pointer to a OgreNewt::BasicJoints::Universal as the single parameter.  this function will be called automatically every
+		time you upate the World.
+	*/
+	void setCallback( UniversalCallback callback ) { m_callback = callback; }
+
+	////////// CALLBACK COMMANDS ///////////
+	// the following commands are only valid from inside a hinge callback function
+
+	//! set the acceleration around a particular pin.
+	/*
+		this function can only be called from within a custom callback.
+		\param accel desired acceleration
+		\param axis which pin to use (0 or 1)
+	*/
+	void setCallbackAccel( Ogre::Real accel, unsigned axis );
+
+	//! set the minimum friction around a particular pin
+	/*
+		this function can only be called from within a custom callback.
+		\param min minimum friction
+		\param axis which pin to use (0 or 1)
+	*/
+	void setCallbackFrictionMin( Ogre::Real min, unsigned axis );
+
+	//! set the maximum friction around a particular pin.
+	/*
+		this function can only be called from within a custom callback.
+		\param max maximum friction
+		\param axis which pin to use (0 or 1)
+	*/
+	void setCallbackFrictionMax( Ogre::Real max, unsigned axis );
+
+	//! get the current phsics timestep.
+	/*
+		this function can only be called from within a custom callback.
+	*/
+	Ogre::Real getCallbackTimestep() const;
+
+	//! calculate the acceleration neccesary to stop the joint at the specified angle on pin 0.
+	/*!
+		For implementing joint limits.
+		This command is only valid when used inside a custom  callback.
+	*/
+	Ogre::Real calculateStopAlpha0( Ogre::Real angle ) const;
+
+	//! calculate the acceleration neccesary to stop the joint at the specified angle on pin 1.
+	/*!
+		For implementing joint limits.
+		This command is only valid when used inside a custom  callback.
+	*/
+	Ogre::Real calculateStopAlpha1( Ogre::Real angle ) const;
+
+protected:
+	
+	//! newton callback.  used internally.
+	static unsigned _CDECL newtonCallback( const NewtonJoint* universal, NewtonHingeSliderUpdateDesc* desc );
+
+	UniversalCallback m_callback;
+	NewtonHingeSliderUpdateDesc* m_desc;
+
+	unsigned m_retval;
+
+
+
+};
+
+
+
+//! UpVector joint.
+/*!
+	simple upvector joint.  upvectors remove all rotation except for a single pin.  useful for character controllers, etc.
+*/
+class _OgreNewtExport UpVector : public Joint
+{
+ 
+public:
+	//! constructor
+	/*
+		\param world pointer to the OgreNewt::World.
+		\param body pointer to the body to apply the upvector to.
+		\param pin direction of the upvector in global space.
+	*/
+	UpVector( const World* world, const Body* body, const Ogre::Vector3&amp; pin );
+
+	//! destructor
+	~UpVector();
+
+	//! set the pin direction.
+	/*
+		by calling this function in realtime, you can effectively &quot;animate&quot; the pin.
+	*/
+	void setPin( const Ogre::Vector3&amp; pin ) const { NewtonUpVectorSetPin( m_joint, &amp;pin.x ); }
+
+	//! get the current pin direction.
+	Ogre::Vector3 getPin() const;
+
+
+};
+
+
+}	// end NAMESPACE BasicJoints
+
+
+//! namespace for pre-built custom joints
+namespace PrebuiltCustomJoints
+{
+
+	//! Custom2DJoint class
+	/*!
+		This class represents a joint that limits movement to a plane, and rotation only around the normal of that
+		plane.  This can be used to create simple 2D simulations.  it also supports limits and acceleration for spinning.
+		This joint has been used in a few projects, but is not 100% fully-tested.
+	*/
+	class _OgreNewtExport Custom2DJoint : public OgreNewt::CustomJoint
+	{
+	public:
+		//! constructor
+		Custom2DJoint( const OgreNewt::Body* body, const Ogre::Vector3&amp; pin );
+
+		//! destructor
+		~Custom2DJoint() {}
+
+		//! overloaded function that applies the actual constraint.
+		void submitConstraint();
+
+		//! get the current angle of the joint.
+		Ogre::Radian getAngle() const { return mAngle; }
+
+		//! set rotational limits for the joint.
+		void setLimits( Ogre::Degree min, Ogre::Degree max ) { mMin = min, mMax = max; }
+		
+		//! sets whether to enable limits or not for the joint.
+		void setLimitsOn( bool onoff ) { mLimitsOn = onoff; }
+
+		//! returns whether limits are turned on or off for the joint.
+		bool getLimitsOn() const { return mLimitsOn; }
+
+		//! adds rotational acceleration to the joint (like a motor)
+		void addAccel( Ogre::Real accel ) { mAccel = accel; }
+
+		//! resets the joint angle to 0.  this simply sets the internal variable to zero.
+		//! you might want to call this for example after resetting a body.
+		void resetAngle() { mAngle = Ogre::Radian(0.0f); }
+
+		//! get the pin.
+		Ogre::Vector3 getPin() { return mPin; }
+
+	private:
+		Ogre::Vector3 mPin;
+		Ogre::Quaternion mLocalOrient0, mLocalOrient1;
+		Ogre::Vector3 mLocalPos0, mLocalPos1;
+
+		Ogre::Radian mAngle;
+
+		Ogre::Radian mMin;
+		Ogre::Radian mMax;
+
+		bool mLimitsOn;
+
+		Ogre::Real mAccel;
+	};
+
+	//! CustomFixedJoint
+	/*!
+		This joint implements a fully fixed joint, which removes all DOF, creating a completely fixed connection between bodies.
+		This is probably the most expensive kind of joint, and should only be used when really needed.
+	*/
+	class _OgreNewtExport CustomRigidJoint : public OgreNewt::CustomJoint
+	{
+	public:
+		CustomRigidJoint( OgreNewt::Body* child, OgreNewt::Body* parent, Ogre::Vector3 dir, Ogre::Vector3 pos);
+		~CustomRigidJoint();
+
+		void submitConstraint();
+
+	private:
+		Ogre::Vector3 mLocalPos0;
+		Ogre::Vector3 mLocalPos1;
+
+		Ogre::Quaternion mLocalOrient0;
+		Ogre::Quaternion mLocalOrient1;
+	};
+
+
+	//! CutomPulleyJoint
+	/*!
+		This joint implements a pulley system.  note that this joint only works with 2 bodies attached!
+	*/
+	class _OgreNewtExport CustomPulleyJoint : public OgreNewt::CustomJoint
+	{
+	public:
+		//! constructor
+		/*!
+			\param gearRatio float value representing the ratio of movement between parent and child.
+			\param parent pointer to OgreNewt::Body to be the parent body.
+			\param child pointer to the OgreNewt::Body to be the child body.
+			\param parentPin direction vector for movement of parent.
+			\param childPin direction vector for movement of child.
+		*/
+		CustomPulleyJoint( Ogre::Real gearRatio, const Body* parent, const Body* child, const Ogre::Vector3&amp; parentPin, const Ogre::Vector3&amp; childPin );
+		~CustomPulleyJoint() {}
+
+		//! overloaded function to submit the constraint.
+		void submitConstraint();
+
+	private:
+		Ogre::Real			mGearRatio;
+
+		Ogre::Vector3		mLocalPos0, mLocalPos1;
+		Ogre::Quaternion	mLocalOrient0, mLocalOrient1;
+	};
+
+
+	//! CustomGearJoint
+	/*!
+		This class works like 2 gears that mesh, retaining a specific ration between the rotational velocity of the bodies.
+		The gears don't have to rotate around the same axis, that is why 2 pins are supplied.
+	*/
+	class _OgreNewtExport CustomGearJoint : public OgreNewt::CustomJoint
+	{
+	public:
+		/*!
+			\param gearRatio float value representing the ratio of movement between parent and child.
+			\param parent pointer to OgreNewt::Body to be the parent body.
+			\param child pointer to the OgreNewt::Body to be the child body.
+			\param parentPin pin around which the parent's rotation should be tracked.
+			\param childPin pin around which the child's rotation should be tracked.
+		*/
+		CustomGearJoint( Ogre::Real gearRatio, const Body* parent, const Body* child, const Ogre::Vector3&amp; parentPin, const Ogre::Vector3&amp; childPin );
+		~CustomGearJoint() {}
+
+		//! overloaded function to submit the constraint.
+		void submitConstraint();
+
+	private:
+		Ogre::Real			mGearRatio;
+
+		Ogre::Vector3		mLocalPos0, mLocalPos1;
+		Ogre::Quaternion	mLocalOrient0, mLocalOrient1;
+	};
+
+
+
+
+}	// end NAMESPACE PrebuiltCustomJoints
+
+
+}	// end NAMESPACE OgreNewt
+
+#endif
+// _INCLUDE_OGRENEWT_BASICJOINTS
+

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_Body.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_Body.h	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_Body.h	2007-02-28 03:27:47 UTC (rev 3086)
@@ -17,7 +17,6 @@
 #define _INCLUDE_OGRENEWT_BODY
 
 
-#include &quot;OgreNewt_Prerequisites.h&quot;
 #include &lt;Ogre.h&gt;
 #include &lt;Newton.h&gt;
 #include &quot;OgreNewt_World.h&quot;
@@ -75,6 +74,13 @@
 	typedef fastdelegate::FastDelegate5&lt; int, OgreNewt::Body*, const Ogre::Quaternion&amp;, const Ogre::Vector3&amp;, Ogre::Plane&amp;, bool &gt; buoyancyPlaneCallback;
 
 
+	//! auto activate / deactivate callback
+    /*!
+		This function is called whenever Newton automatically activates or deactivates an object.  the unsigned int passed is to
+		inform you if the object is about to &quot;fall asleep&quot;, or &quot;wake up&quot;.
+	*/
+	typedef fastdelegate::FastDelegate2&lt;OgreNewt::Body*, unsigned int&gt; autoactiveCallback;
+
 	//! constructor.
 	/*!
 		creates a Rigid Body in an OgreNewt::World, based on a specific collision shape.
@@ -103,11 +109,11 @@
 	*/
 	NewtonBody* getNewtonBody() const { return m_body; }
 
-	//! get a pointer to the attached SceneNode.
+	//! get a pointer to the attached Node.
 	/*!
-		if you have &quot;attached&quot; this body to an Ogre::SceneNode, this retrieves the node.
+		if you have &quot;attached&quot; this body to an Ogre::Node, this retrieves the node.
 	*/
-	Ogre::SceneNode* getOgreNode() const { return m_node; }
+	Ogre::Node* getOgreNode() const { return m_node; }
 
 	//! get a pointer to the OgreNewt::World this body belongs to.
 	const OgreNewt::World* getWorld() const { return m_world; }
@@ -122,16 +128,11 @@
 	//! get the type set for this body.
 	int getType() const { return m_type; }
 
-	//! attach this body to an Ogre::SceneNode*
+	//! attach this body to an Ogre::Node*
 	/*!
-		This is an easy way to connect a Rigid Body with an Ogre::SceneNode.
-		This automatically sets up a standard Transform callback when you call this.
-		After calling this, the Ogre::SceneNode will have its position orientation updated
-		to that of the Rigid Body each time you call World::update(),
-		and the body has moved during the update.
+		This is an easy way to connect a Rigid Body with an Ogre::Node.  this automatically sets up a standard Transform callback when you call this.  after calling this, the Ogre::Node will have its position orientation updated to that of the Rigid Body each time you call World::update(), and the body has moved during the update.
 	*/
-	void attachToNode(Ogre::SceneNode* node, const Ogre::Vector3&amp; offset = Ogre::Vector3::ZERO,
-		const Ogre::Quaternion&amp; orientationBias = Ogre::Quaternion::IDENTITY);
+	void attachToNode( Ogre::Node* node );
 
 	//! set a standard gravity callback for this body to use.
 	/*!
@@ -156,13 +157,22 @@
 
 	//! set a custom transform callback.
 	/*
-		sets a custom transform callback for the rigid body. see the docs on setCustomForceAndTorqueCallback for a description of how to use this funciton.
+		sets a custom transform callback for the rigid body. see the docs on setCustomForceAndTorqueCallback for a description of how to use this function.
 	*/
 	void setCustomTransformCallback( TransformCallback callback );
 
 	//! remove any transform callbacks.
 	void removeTransformCallback() { m_transformcallback = NULL; }
 
+	//! set a custom autoactivate callback for this body to use.
+    /*
+		This will be called whenever Newton automatically activates or deactivates an object.
+    */
+	void setAutoactiveCallback ( autoactiveCallback callback );
+
+    //! remove any autoactivate callbacks.
+    void removeAutoactiveCallback() { NewtonBodySetAutoactiveCallback( m_body, NULL );   m_autoactivecallback = NULL; }
+
 	//! position and orient the body arbitrarily.
 	/*!
 		generally in a physics engine you shouldn't directly set the location/rotation of a Body, because this defies physics laws.  this command exists to set up bodies initially.
@@ -375,11 +385,7 @@
 	*/
 	void addLocalForce( const Ogre::Vector3&amp; force, const Ogre::Vector3&amp; pos );
 
-    Ogre::Vector3 getOffset() const;
-    void setOffset(const Ogre::Vector3&amp; offset);
 
-	Ogre::Quaternion getOrientationBias() const;
-	void setOrientationBias(const Ogre::Quaternion&amp; orientationbias);
 
  protected:
 
@@ -392,13 +398,12 @@
 	void*				m_userdata;
 	
 	int					m_type;
-	Ogre::SceneNode*	m_node;
-	Ogre::Vector3       m_offset;
-	Ogre::Quaternion    m_orientationBias;
+	Ogre::Node*			m_node;
 
 	ForceCallback			m_forcecallback;
 	TransformCallback		m_transformcallback;
 	buoyancyPlaneCallback	m_buoyancycallback;
+	autoactiveCallback		m_autoactivecallback;
 
 private:
 
@@ -409,6 +414,8 @@
 
 	static int _CDECL newtonBuoyancyCallback( const int collisionID, void* context, const float* globalSpaceMatrix, float* globalSpacePlane );
 
+	static void _CDECL newtonAutoactiveCallback(const NewtonBody* body, unsigned state);
+
 	// standard gravity force callback.
 	static void standardForceCallback( Body* me );
 

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_BodyIterator.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_BodyIterator.h	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_BodyIterator.h	2007-02-28 03:27:47 UTC (rev 3086)
@@ -93,3 +93,4 @@
 }	// end NAMESPACE OgreNewt
 
 #endif	// _INCLUDE_OGRENEWT_BODYITERATOR
+

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_CollisionPrimitives.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_CollisionPrimitives.h	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_CollisionPrimitives.h	2007-02-28 03:27:47 UTC (rev 3086)
@@ -11,7 +11,6 @@
 #ifndef _INCLUDE_OGRENEWT_COLLISIONPRIMITIVES
 #define _INCLUDE_OGRENEWT_COLLISIONPRIMITIVES
 
-#include &lt;OgreNewt_Prerequisites.h&gt;
 #include &lt;Newton.h&gt;
 #include &quot;OgreNewt_World.h&quot;
 #include &quot;OgreNewt_Collision.h&quot;
@@ -20,6 +19,7 @@
 // OgreNewt namespace.  all functions and classes use this namespace.
 namespace OgreNewt
 {
+
 	//! set of basic collision shapes
 	namespace CollisionPrimitives
 	{
@@ -170,8 +170,7 @@
 		public:
 			//! constructor
 			/*!
-				Overloaded constructor.  pass a SceneNode*, 
-                and it will use the vertex data from the first attached object.
+				Overloaded constructor.  pass an Ogre::Entity*, and it will use its vertex data.
 				\param world pointer to the OgreNewt::World
 				\param entity pointer to an Ogre::Entity, if this is attached to an node, then
 				              the node's scale is applied
@@ -215,21 +214,24 @@
 		class _OgreNewtExport TreeCollision : public OgreNewt::Collision
 		{
 		public:
-      //! constructor
-      /*!
-        Create a 'blank' tree collision object to be used with
-        TreeCollisionSerializer::importTreeCollision
-        \param world pointer to the OgreNewt::World
-      */
-      TreeCollision( const World* world);
+			//! constructor
+			/*!
+				Create a 'blank' tree collision object.
+				Can be used for manual TreeCollision creation,
+				or to be used with
+			       	TreeCollisionSerializer::importTreeCollision
+				\param world pointer to the OgreNewt::World
+			*/
+			TreeCollision( const World* world);
 
 			//! constructor
 			/*!
 				Create a tree collision object.
 				\param world pointer to the OgreNewt::World
-				\param entity pointer to an entity, if it is attached to a scenenode, then
-                              the node's scale is applied.
-                \param useTempBuffer determines whether to use the temporary blend buffer instead
+				\param entity pointer to an entity, if it is
+			       		      attached to a scenenode, then
+					      the node's scale is applied.
+				\param useTempBuffer determines whether to use the temporary blend buffer instead
                                      of the mesh's vertex data. This is useful when you want
                                      to create a collision from an intermediate animation state.
 				\param optimize bool whether you want to optimize the collision or not.
@@ -267,13 +269,66 @@
                 Ogre::IndexData* indexData, bool optimize);
 
 			//! destructor
-			~TreeCollision() {}
+			virtual ~TreeCollision() {}
 
-      friend void TreeCollisionSerializer::exportTreeCollision(const TreeCollision* collision, const Ogre::String&amp; filename);
-      friend void TreeCollisionSerializer::importTreeCollision(Ogre::DataStreamPtr&amp; stream, TreeCollision* pDest);
+			//! start a tree collision creation
+			void start();
+
+			//! add a poly to the tree collision
+			/*!
+				Add a single poly to the tree collision.
+				\param polys pointer to an array of 3 Vector3D objects representing the global position of each poly.
+				\param ID and identifier to assign to this poly, that can be retrieved later upon collision detection.
+			*/
+			void addPoly( Ogre::Vector3* polys, unsigned int ID );
+
+			//! finish the tree collision
+			void finish( bool optimize = true );
+
+
+			friend void TreeCollisionSerializer::exportTreeCollision(const TreeCollision* collision, const Ogre::String&amp; filename);
+			friend void TreeCollisionSerializer::importTreeCollision(Ogre::DataStreamPtr&amp; stream, TreeCollision* pDest);
 		};
 
 		////////////////////////////////////////////////////////
+		//! TreeCollision created by parsing a tree of SceneNodes, adding collision data of all meshes.
+		/*!
+			Users can inherit this class, and inherit the &quot;getID&quot; function to perform their own filtering on the
+			IDs to pass to Newton.  IDs are useful during collision callbacks to determine which part of the world
+			is being hit.
+
+			By default, the ID is set to an incrementing integer.
+		*/
+		class _OgreNewtExport TreeCollisionSceneParser : public TreeCollision
+		{
+		public:
+			TreeCollisionSceneParser( OgreNewt::World* world );
+
+			~TreeCollisionSceneParser() {}
+
+			//! parse the scene.
+			void parseScene( Ogre::SceneNode* startNode, bool optimize = false );
+
+		protected:
+
+			//! this is a user-inherited function that lets you filter which Entities will be added to the treeCollision.
+			/*!
+				return true to add this entity, return false to ignore it.
+			*/
+			virtual bool entityFilter( const Ogre::SceneNode* currentNode, const Ogre::Entity* currentEntity ) { return true; }
+
+			//! user inherit-able function, allows customization of the ID to be assigned to this group of polygons.
+			virtual unsigned int getID( const Ogre::SceneNode* currentNode, const Ogre::Entity* currentEntity, unsigned int currentSubMesh ) { return count++; }
+
+		private:
+			//! recursive function to parse a single scene node.
+			void _parseNode( Ogre::SceneNode* node, const Ogre::Quaternion&amp; curOrient, const Ogre::Vector3&amp; curPos );
+
+
+			static int count;
+		};
+
+		////////////////////////////////////////////////////////
 		//	COMPOUND COLLISION!
 
 		//! create a compound from several collision pieces.
@@ -320,17 +375,23 @@
 			~Pyramid() {}
 		};
 
-		//! Wraps another collision to let the user modify the hull via a world space scale matrix
+		//! Wraps a collision in order to make it scaleable.
+		/*!
+			It lets the user to modify the hull via a world space scale
+			matrix without changing the initial collision
+		*/
 		class _OgreNewtExport HullModifier: public OgreNewt::Collision
 		{
 		public:
-			HullModifier( World* world, CollisionPtr wrappedCollision );	// constructor
+			//! constructor
+			HullModifier( World* world, CollisionPtr wrappedCollision );
+			//! destructor
 			~HullModifier() {};
 
-			//! scale matrix in world space
+			//! Sets the scale matrix in world space (of Ogre)
 			void setMatrix(const Ogre::Matrix4&amp; matrix);
 
-			//! scale matrix in world space
+			//! scale matrix in world space (of Ogre)
 			Ogre::Matrix4 getMatrix() const;
 		};	
 
@@ -339,3 +400,4 @@
 }// end namespace OgreNewt
 
 #endif	// _INCLUDE_OGRENEWT_COLLISIONPRIMITIVES
+

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_ContactCallback.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_ContactCallback.h	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_ContactCallback.h	2007-02-28 03:27:47 UTC (rev 3086)
@@ -1,148 +1,153 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_CONTACTCALLBACK
-#define _INCLUDE_OGRENEWT_CONTACTCALLBACK
-
-#include &lt;OgreNewt_Prerequisites.h&gt;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_Body.h&quot;
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-
-
-//! custom contact behavior
-/*!
-	this class is for creating custom behavior between material GroupIDs.
-	this class must be inherited, and the user functions created, and then
-	added to a MaterialPair class.
-*/
-class _OgreNewtExport ContactCallback
-{
-public:
-
-	//! constructor
-	ContactCallback();
-
-	//! destructor
-	virtual ~ContactCallback();
-
-	// basic contact control commands...
-
-	//! disable the current contact.
-	void disableContact() const { NewtonMaterialDisableContact( m_material ); }
-
-	//! get the current physics timestep
-	Ogre::Real getCurrentTimestep() const { return (Ogre::Real)NewtonMaterialGetCurrentTimestep( m_material ); }
-
-	//! get the face ID of a TreeCollision object
-	unsigned getContactFaceAttribute() const { return NewtonMaterialGetContactFaceAttribute( m_material ); }
-
-	//! get the Collision ID of a body currently colliding
-	unsigned getBodyCollisionID( OgreNewt::Body* body ) const { return NewtonMaterialGetBodyCollisionID( m_material, body-&gt;getNewtonBody() ); }
-
-	//! speed of the collision
-	Ogre::Real getContactNormalSpeed() const { return (Ogre::Real)NewtonMaterialGetContactNormalSpeed( m_material, m_contact ); }
-
-	//! force of the collision
-	/*!
-		only valid for objects in a stable state (sitting on top of each other, etc)
-	*/
-	Ogre::Vector3 getContactForce() const;
-
-	//! get positoin and normal of the collision
-	void getContactPositionAndNormal( Ogre::Vector3&amp; pos, Ogre::Vector3&amp; norm ) const;
-
-	//! get the tangent vectors of the collision
-	void getContactTangentDirections( Ogre::Vector3&amp; dir0, Ogre::Vector3&amp; dir1 ) const;
-
-	//! get tangent speed of the collision
-	Ogre::Real getContactTangentSpeed( int index ) const { return (Ogre::Real)NewtonMaterialGetContactTangentSpeed( m_material, m_contact, index ); }
-
-	//! set softness of the current contact
-	void setContactSoftness( Ogre::Real softness ) const { NewtonMaterialSetContactSoftness( m_material, (float)softness ); }
-
-	//! set elasticity of the current contact
-	void setContactElasticity( Ogre::Real elasticity ) const { NewtonMaterialSetContactElasticity( m_material, (float)elasticity ); }
-
-	//! set friction state of current contact
-	void setContactFrictionState( int state, int index ) const { NewtonMaterialSetContactFrictionState( m_material, state, index ); }
-
-	//! set static friction for current contact
-	void setContactStaticFrictionCoef( Ogre::Real coef, int index ) const { NewtonMaterialSetContactStaticFrictionCoef( m_material, (float)coef, index ); }
-
-	//! set kinetic friction for current contact
-	void setContactKineticFrictionCoef( Ogre::Real coef, int index ) const { NewtonMaterialSetContactKineticFrictionCoef( m_material, (float)coef, index ); }
-
-	//! set tangent acceleration for contact
-	void setContactTangentAcceleration( Ogre::Real accel, int index ) const { NewtonMaterialSetContactTangentAcceleration( m_material, (float)accel, index ); }
-
-	//! align tangent vectors with a user supplied direction
-	void rotateTangentDirections( const Ogre::Vector3&amp; dir ) const { NewtonMaterialContactRotateTangentDirections( m_material, &amp;dir.x ); }
-
-	//! manually set the normal for the collision.
-	void setContactNormalDirection( const Ogre::Vector3&amp; dir ) const { NewtonMaterialSetContactNormalDirection( m_material, &amp;dir.x ); }
-
-	//! manually set the acceleration along the collision normal.
-	void setContactNormalAcceleration( Ogre::Real accel ) const { NewtonMaterialSetContactNormalAcceleration( m_material, accel ); }
-
-
-
-	// user-defined callback function.
-	
-	//! user defined Begin function
-	/*!
-		this function is called when 2 bodies AABB overlap.  they have not yet collided, but *may* do so this loop.
-		at this point, m_body0 and m_body1 are defined, but the contact isn't yet valid, so none of the member functions
-		can be called yet.  they must be called from the userProcess() function.
-		return 0 to ignore the collision, 1 to allow it.
-	*/
-	virtual int userBegin() { return 1; }
-
-	//! user-defined Process function
-	/*!
-		user process function.  is called for each contact between the 2 bodies.  all member functions are valid from
-		within this function, and will affect the current contact.  return 0 to ignore the collision, 1 to allow it.
-	 */
-	virtual int userProcess() { return 1; }
-
-	//! user-defined End function
-	/*!
-		called after all contacts between the 2 bodies have been processed. no member functions should be called from within this
-		function either, as all contacts have been processed at this point.
-	*/
-	virtual void userEnd() {  }
-
-
-	//! internal function.
-	static int _CDECL contactBegin( const NewtonMaterial* material, const NewtonBody* body0, const NewtonBody* body1 );
-	//! internal function.
-	static int _CDECL contactProcess( const NewtonMaterial* material, const NewtonContact* contact );
-	//! internal function.
-	static void _CDECL contactEnd( const NewtonMaterial* material );
-
-
-protected:
-
-	NewtonMaterial* m_material;
-	NewtonContact* m_contact;
-
-	OgreNewt::Body* m_body0;
-	OgreNewt::Body* m_body1;
-};
-
-
-}	// end NAMESPACE OgreNewt
-
-#endif
-// _INCLUDE_OGRENEWT_CONTACTCALLBACK
-
+/* 
+	OgreNewt Library
+
+	Ogre implementation of Newton Game Dynamics SDK
+
+	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+
+		by Walaber
+
+*/
+#ifndef _INCLUDE_OGRENEWT_CONTACTCALLBACK
+#define _INCLUDE_OGRENEWT_CONTACTCALLBACK
+
+#include &lt;Newton.h&gt;
+#include &quot;OgreNewt_Body.h&quot;
+
+// OgreNewt namespace.  all functions and classes use this namespace.
+namespace OgreNewt
+{
+
+
+//! custom contact behavior
+/*!
+	this class is for creating custom behavior between material GroupIDs.
+	this class must be inherited, and the user functions created, and then
+	added to a MaterialPair class.
+*/
+class _OgreNewtExport ContactCallback
+{
+public:
+
+	//! constructor
+	ContactCallback();
+
+	//! destructor
+	virtual ~ContactCallback();
+
+	// basic contact control commands...
+
+	//! disable the current contact.
+	void disableContact() const { NewtonMaterialDisableContact( m_material ); }
+
+	//! get the current physics timestep
+	Ogre::Real getCurrentTimestep() const { return (Ogre::Real)NewtonMaterialGetCurrentTimestep( m_material ); }
+
+	//! get the face ID of a TreeCollision object
+	unsigned getContactFaceAttribute() const { return NewtonMaterialGetContactFaceAttribute( m_material ); }
+
+	//! get the Collision ID of a body currently colliding
+	unsigned getBodyCollisionID( OgreNewt::Body* body ) const { return NewtonMaterialGetBodyCollisionID( m_material, body-&gt;getNewtonBody() ); }
+
+	//! speed of the collision
+	Ogre::Real getContactNormalSpeed() const { return (Ogre::Real)NewtonMaterialGetContactNormalSpeed( m_material, m_contact ); }
+
+	//! force of the collision
+	/*!
+		only valid for objects in a stable state (sitting on top of each other, etc)
+	*/
+	Ogre::Vector3 getContactForce() const;
+
+	//! get positoin and normal of the collision
+	void getContactPositionAndNormal( Ogre::Vector3&amp; pos, Ogre::Vector3&amp; norm ) const;
+
+	//! get the tangent vectors of the collision
+	void getContactTangentDirections( Ogre::Vector3&amp; dir0, Ogre::Vector3&amp; dir1 ) const;
+
+	//! get tangent speed of the collision
+	Ogre::Real getContactTangentSpeed( int index ) const { return (Ogre::Real)NewtonMaterialGetContactTangentSpeed( m_material, m_contact, index ); }
+
+	//! set softness of the current contact
+	void setContactSoftness( Ogre::Real softness ) const { NewtonMaterialSetContactSoftness( m_material, (float)softness ); }
+
+	//! set elasticity of the current contact
+	void setContactElasticity( Ogre::Real elasticity ) const { NewtonMaterialSetContactElasticity( m_material, (float)elasticity ); }
+
+	//! set friction state of current contact
+	void setContactFrictionState( int state, int index ) const { NewtonMaterialSetContactFrictionState( m_material, state, index ); }
+
+	//! set static friction for current contact
+	void setContactStaticFrictionCoef( Ogre::Real coef, int index ) const { NewtonMaterialSetContactStaticFrictionCoef( m_material, (float)coef, index ); }
+
+	//! set kinetic friction for current contact
+	void setContactKineticFrictionCoef( Ogre::Real coef, int index ) const { NewtonMaterialSetContactKineticFrictionCoef( m_material, (float)coef, index ); }
+
+	//! set tangent acceleration for contact
+	void setContactTangentAcceleration( Ogre::Real accel, int index ) const { NewtonMaterialSetContactTangentAcceleration( m_material, (float)accel, index ); }
+
+	//! align tangent vectors with a user supplied direction
+	void rotateTangentDirections( const Ogre::Vector3&amp; dir ) const { NewtonMaterialContactRotateTangentDirections( m_material, &amp;dir.x ); }
+
+	//! manually set the normal for the collision.
+	void setContactNormalDirection( const Ogre::Vector3&amp; dir ) const { NewtonMaterialSetContactNormalDirection( m_material, &amp;dir.x ); }
+
+	//! manually set the acceleration along the collision normal.
+	void setContactNormalAcceleration( Ogre::Real accel ) const { NewtonMaterialSetContactNormalAcceleration( m_material, accel ); }
+
+
+
+	// user-defined callback function.
+	
+	//! user defined Begin function
+	/*!
+		this function is called when 2 bodies AABB overlap.  they have not yet collided, but *may* do so this loop.
+		at this point, m_body0 and m_body1 are defined, but the contact isn't yet valid, so none of the member functions
+		can be called yet.  they must be called from the userProcess() function.
+		return 0 to ignore the collision, 1 to allow it.
+	*/
+	virtual int userBegin() { return 1; }
+
+	//! user-defined Process function
+	/*!
+		user process function.  is called for each contact between the 2 bodies.  all member functions are valid from
+		within this function, and will affect the current contact.  return 0 to ignore the collision, 1 to allow it.
+	 */
+	virtual int userProcess() { return 1; }
+
+	//! user-defined End function
+	/*!
+		called after all contacts between the 2 bodies have been processed. no member functions should be called from within this
+		function either, as all contacts have been processed at this point.
+	*/
+	virtual void userEnd() {  }
+
+	//! get the NewtonMaterial from this callback.
+	NewtonMaterial* _getNewtonMaterial() { return m_material; }
+
+	//! get the NewtonContact from this callback.
+	NewtonContact* _getNewtonContact() { return m_contact; }
+
+
+	//! internal function.
+	static int _CDECL contactBegin( const NewtonMaterial* material, const NewtonBody* body0, const NewtonBody* body1 );
+	//! internal function.
+	static int _CDECL contactProcess( const NewtonMaterial* material, const NewtonContact* contact );
+	//! internal function.
+	static void _CDECL contactEnd( const NewtonMaterial* material );
+
+
+protected:
+
+	NewtonMaterial* m_material;
+	NewtonContact* m_contact;
+
+	OgreNewt::Body* m_body0;
+	OgreNewt::Body* m_body1;
+};
+
+
+}	// end NAMESPACE OgreNewt
+
+#endif
+// _INCLUDE_OGRENEWT_CONTACTCALLBACK
+

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_Debugger.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_Debugger.h	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_Debugger.h	2007-02-28 03:27:47 UTC (rev 3086)
@@ -33,7 +33,7 @@
 	{
 	
 	public:
-		~Debugger() {}
+		~Debugger();
 
 		//! get the singleton reference
 		static Debugger&amp; getSingleton();
@@ -44,6 +44,9 @@
 		*/
 		void init( Ogre::SceneManager* smgr );
 
+		//! de-init the debugger (cleantup)
+		void deInit();
+
 		//! show the newton world
 		/*!
 			Draws the Newton world as 3D lines.
@@ -69,3 +72,4 @@
 
 
 #endif	// _INCLUDE_OGRENEWT_DEBUGGER
+

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_Joint.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_Joint.h	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_Joint.h	2007-02-28 03:27:47 UTC (rev 3086)
@@ -1,173 +1,172 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_JOINT
-#define _INCLUDE_OGRENEWT_JOINT
-
-#include &quot;OgreNewt_Prerequisites.h&quot;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_World.h&quot;
-#include &quot;OgreNewt_Body.h&quot;
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-
-//! base class for all joints.
-/*!
-	this class is inherited by all other specific joint types.
-*/
-class _OgreNewtExport Joint
-{
-public:
-
-	//! constructor
-	Joint();
-
-	//! destructor
-	virtual ~Joint();
-
-	//! returns collision state
-	/*!
-		The collision state determines whether collision should be calculated between the parent and child bodies of the joint.
-		\return integer value. 1 = collision on, 0 = collision off.
-	*/
-	int getCollisionState() const { return NewtonJointGetCollisionState( m_joint ); }
-
-	//! sets the collision state
-	/*!
-		The collision state determines whether collision should be calculated between the parent and child bodies of the joint.
-		\param state integer value. 1 = collision on, 0 = collision off.
-	*/		
-	void setCollisionState( int state ) const { NewtonJointSetCollisionState( m_joint, state ); }
-
-
-	//! get joint stiffness
-	/*!
-		Joint stiffness adjusts how much &quot;play&quot; the joint can have.  high stiffness = very small play, but more likely to become unstable.
-		\return float representing joint stiffness in range [0,1]
-	*/
-	Ogre::Real getStiffness() const { return (Ogre::Real)NewtonJointGetStiffness( m_joint ); }
-
-	//! set joint stiffness
-	/*!
-		Joint stiffness adjusts how much &quot;play&quot; the joint can have.  high stiffness = very small play, but more likely to become unstable.
-		\param stiffness float representing joint stiffness in range [0,1]
-	*/
-	void setStiffness( Ogre::Real stiffness ) const { NewtonJointSetStiffness( m_joint, stiffness ); }
-
-
-	//! set user data for this joint
-	/*!
-		user data can be used to connect this class to other user classes through the use of this general pointer.
-	*/
-	void setUserData( void* ptr ) { m_userdata = ptr; }
-
-	//! get user data for this joint
-	/*!
-		user data can be used to connect this class to other user classes through the use of this general pointer.
-	*/
-	void* getUserData() const { return m_userdata; }
-
-		
-protected:
-
-	NewtonJoint* m_joint;
-	const OgreNewt::World* m_world;
-
-	void* m_userdata;
-
-	static void _CDECL destructor( const NewtonJoint* me );
-
-};
-
-
-
-
-
-
-//! CustomJoint 
-/*!
-	this class represents a basic class for creating user-defined joints.  this class must be inherited to create discreet joints.
-*/
-class _OgreNewtExport CustomJoint : public Joint
-{
- 
-public:
-
-	//! constructor
-	CustomJoint( unsigned int maxDOF, const Body* body0, const Body* body1 );
-
-	//! destructor
-	virtual ~CustomJoint();
-
-	//! must be over-written for a functioning joint.
-	virtual void submitConstraint() = 0;
-
-
-	//! find the local orientation and position of the joint with regards to the 2 bodies in the joint.
-	void pinAndDirToLocal( const Ogre::Vector3&amp; pinpt, const Ogre::Vector3&amp; pindir, Ogre::Quaternion&amp; localOrient0, Ogre::Vector3&amp; localPos0, Ogre::Quaternion&amp; localOrient1, Ogre::Vector3&amp; localPos1 ) const;
-
-	//! find the global orientation and position of the joint with regards to the a body in the joint.
-	void localToGlobal( const Ogre::Quaternion&amp; localOrient, const Ogre::Vector3&amp; localPos, Ogre::Quaternion&amp; globalOrient, Ogre::Vector3&amp; globalPos, int bodyIndex = 0 ) const;
-
-	//! add a linear row to the constraint.
-	void addLinearRow( const Ogre::Vector3&amp; pt0, const Ogre::Vector3&amp; pt1, const Ogre::Vector3&amp; dir ) const;
-
-	//! add an angular row to the constraint.
-	void addAngularRow( Ogre::Radian relativeAngleError, const Ogre::Vector3&amp; dir ) const;
-
-	//! set the general jacobian rows directly.
-	void addGeneralRow( const Ogre::Vector3&amp; linear0, const Ogre::Vector3&amp; angular0, const Ogre::Vector3&amp; linear1, const Ogre::Vector3&amp; angular1 ) const;
-
-	//! set row minimum friction
-	void setRowMinimumFriction( Ogre::Real friction ) const;
-
-	//! set row maximum friction
-	void setRowMaximumFriction( Ogre::Real friction ) const;
-
-	//! set row acceleration
-	void setRowAcceleration( Ogre::Real accel ) const;
-
-	//! set row stiffness
-	void setRowStiffness( Ogre::Real stiffness ) const;
-
-	//! apply a spring to this row, allowing for joints with spring behaviour in 1 or more DoF's
-	/*!
-		\param springK float spring constant.
-		\param springD float natural rest state distance of the spring.
-	*/		
-	void setRowSpringDamper( Ogre::Real springK, Ogre::Real springD ) const;
-
-	//! retrieve the force acting on the current row.
-	Ogre::Real getRowForce( int row ) const { return NewtonUserJointGetRowForce( m_joint, row ); }
-
-	//! pin vector to arbitrary quaternion utility function.
-	Ogre::Quaternion grammSchmidt( const Ogre::Vector3&amp; pin ) const;
-
-protected:
-
-	unsigned int m_maxDOF;
-
-	const OgreNewt::Body* m_body0;
-	const OgreNewt::Body* m_body1;
-
-	//! newton callback.  used internally.
-	static void _CDECL newtonSubmitConstraint( const NewtonJoint* me );
-
-};
-
-
-
-}	// end NAMESPACE OgreNewt
-
-#endif
-// _INCLUDE_OGRENEWT_JOINT
-
+/* 
+	OgreNewt Library
+
+	Ogre implementation of Newton Game Dynamics SDK
+
+	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+
+		by Walaber
+
+*/
+#ifndef _INCLUDE_OGRENEWT_JOINT
+#define _INCLUDE_OGRENEWT_JOINT
+
+#include &lt;Newton.h&gt;
+#include &quot;OgreNewt_World.h&quot;
+#include &quot;OgreNewt_Body.h&quot;
+
+// OgreNewt namespace.  all functions and classes use this namespace.
+namespace OgreNewt
+{
+
+//! base class for all joints.
+/*!
+	this class is inherited by all other specific joint types.
+*/
+class _OgreNewtExport Joint
+{
+public:
+
+	//! constructor
+	Joint();
+
+	//! destructor
+	virtual ~Joint();
+
+	//! returns collision state
+	/*!
+		The collision state determines whether collision should be calculated between the parent and child bodies of the joint.
+		\return integer value. 1 = collision on, 0 = collision off.
+	*/
+	int getCollisionState() const { return NewtonJointGetCollisionState( m_joint ); }
+
+	//! sets the collision state
+	/*!
+		The collision state determines whether collision should be calculated between the parent and child bodies of the joint.
+		\param state integer value. 1 = collision on, 0 = collision off.
+	*/		
+	void setCollisionState( int state ) const { NewtonJointSetCollisionState( m_joint, state ); }
+
+
+	//! get joint stiffness
+	/*!
+		Joint stiffness adjusts how much &quot;play&quot; the joint can have.  high stiffness = very small play, but more likely to become unstable.
+		\return float representing joint stiffness in range [0,1]
+	*/
+	Ogre::Real getStiffness() const { return (Ogre::Real)NewtonJointGetStiffness( m_joint ); }
+
+	//! set joint stiffness
+	/*!
+		Joint stiffness adjusts how much &quot;play&quot; the joint can have.  high stiffness = very small play, but more likely to become unstable.
+		\param stiffness float representing joint stiffness in range [0,1]
+	*/
+	void setStiffness( Ogre::Real stiffness ) const { NewtonJointSetStiffness( m_joint, stiffness ); }
+
+
+	//! set user data for this joint
+	/*!
+		user data can be used to connect this class to other user classes through the use of this general pointer.
+	*/
+	void setUserData( void* ptr ) { m_userdata = ptr; }
+
+	//! get user data for this joint
+	/*!
+		user data can be used to connect this class to other user classes through the use of this general pointer.
+	*/
+	void* getUserData() const { return m_userdata; }
+
+		
+protected:
+
+	NewtonJoint* m_joint;
+	const OgreNewt::World* m_world;
+
+	void* m_userdata;
+
+	static void _CDECL destructor( const NewtonJoint* me );
+
+};
+
+
+
+
+
+
+//! CustomJoint 
+/*!
+	this class represents a basic class for creating user-defined joints.  this class must be inherited to create discreet joints.
+*/
+class _OgreNewtExport CustomJoint : public Joint
+{
+ 
+public:
+
+	//! constructor
+	CustomJoint( unsigned int maxDOF, const Body* body0, const Body* body1 );
+
+	//! destructor
+	virtual ~CustomJoint();
+
+	//! must be over-written for a functioning joint.
+	virtual void submitConstraint() = 0;
+
+
+	//! find the local orientation and position of the joint with regards to the 2 bodies in the joint.
+	void pinAndDirToLocal( const Ogre::Vector3&amp; pinpt, const Ogre::Vector3&amp; pindir, Ogre::Quaternion&amp; localOrient0, Ogre::Vector3&amp; localPos0, Ogre::Quaternion&amp; localOrient1, Ogre::Vector3&amp; localPos1 ) const;
+
+	//! find the global orientation and position of the joint with regards to the a body in the joint.
+	void localToGlobal( const Ogre::Quaternion&amp; localOrient, const Ogre::Vector3&amp; localPos, Ogre::Quaternion&amp; globalOrient, Ogre::Vector3&amp; globalPos, int bodyIndex = 0 ) const;
+
+	//! add a linear row to the constraint.
+	void addLinearRow( const Ogre::Vector3&amp; pt0, const Ogre::Vector3&amp; pt1, const Ogre::Vector3&amp; dir ) const;
+
+	//! add an angular row to the constraint.
+	void addAngularRow( Ogre::Radian relativeAngleError, const Ogre::Vector3&amp; dir ) const;
+
+	//! set the general jacobian rows directly.
+	void addGeneralRow( const Ogre::Vector3&amp; linear0, const Ogre::Vector3&amp; angular0, const Ogre::Vector3&amp; linear1, const Ogre::Vector3&amp; angular1 ) const;
+
+	//! set row minimum friction
+	void setRowMinimumFriction( Ogre::Real friction ) const;
+
+	//! set row maximum friction
+	void setRowMaximumFriction( Ogre::Real friction ) const;
+
+	//! set row acceleration
+	void setRowAcceleration( Ogre::Real accel ) const;
+
+	//! set row stiffness
+	void setRowStiffness( Ogre::Real stiffness ) const;
+
+	//! apply a spring to this row, allowing for joints with spring behaviour in 1 or more DoF's
+	/*!
+		\param springK float spring constant.
+		\param springD float natural rest state distance of the spring.
+	*/		
+	void setRowSpringDamper( Ogre::Real springK, Ogre::Real springD ) const;
+
+	//! retrieve the force acting on the current row.
+	Ogre::Real getRowForce( int row ) const { return NewtonUserJointGetRowForce( m_joint, row ); }
+
+	//! pin vector to arbitrary quaternion utility function.
+	Ogre::Quaternion grammSchmidt( const Ogre::Vector3&amp; pin ) const;
+
+protected:
+
+	unsigned int m_maxDOF;
+
+	const OgreNewt::Body* m_body0;
+	const OgreNewt::Body* m_body1;
+
+	//! newton callback.  used internally.
+	static void _CDECL newtonSubmitConstraint( const NewtonJoint* me );
+
+};
+
+
+
+}	// end NAMESPACE OgreNewt
+
+#endif
+// _INCLUDE_OGRENEWT_JOINT
+

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_MaterialID.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_MaterialID.h	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_MaterialID.h	2007-02-28 03:27:47 UTC (rev 3086)
@@ -1,59 +1,58 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_MATERIALID
-#define _INCLUDE_OGRENEWT_MATERIALID
-
-#include &quot;OgreNewt_Prerequisites.h&quot;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_World.h&quot;
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-
-	class World;
-
-//! represents a material
-class _OgreNewtExport MaterialID
-{
-public:
-
-	//! constructor
-	/*!
-		\param world pointer to the OgreNewt;;World
-	*/
-	MaterialID( const World* world );
-
-	/*!
-		Overloaded constructor, sets the internal ID manually.  should not be used by the end-user.
-	*/
-	MaterialID( const World* world, int ID );
-
-	//! destructor
-	~MaterialID();
-
-	//! get Newton-assigned material ID.
-	int getID() const { return id; }
-
-protected:
-
-	int id;
-	const OgreNewt::World* m_world;
-
-};
-
-
-
-}	// end NAMESPACE OgreNewt
-
-#endif
-// _INCLUDE_OGRENEWT_MATERIALID
-
+/* 
+	OgreNewt Library
+
+	Ogre implementation of Newton Game Dynamics SDK
+
+	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+
+		by Walaber
+
+*/
+#ifndef _INCLUDE_OGRENEWT_MATERIALID
+#define _INCLUDE_OGRENEWT_MATERIALID
+
+#include &lt;Newton.h&gt;
+#include &quot;OgreNewt_World.h&quot;
+
+// OgreNewt namespace.  all functions and classes use this namespace.
+namespace OgreNewt
+{
+
+	class World;
+
+//! represents a material
+class _OgreNewtExport MaterialID
+{
+public:
+
+	//! constructor
+	/*!
+		\param world pointer to the OgreNewt;;World
+	*/
+	MaterialID( const World* world );
+
+	/*!
+		Overloaded constructor, sets the internal ID manually.  should not be used by the end-user.
+	*/
+	MaterialID( const World* world, int ID );
+
+	//! destructor
+	~MaterialID();
+
+	//! get Newton-assigned material ID.
+	int getID() const { return id; }
+
+protected:
+
+	int id;
+	const OgreNewt::World* m_world;
+
+};
+
+
+
+}	// end NAMESPACE OgreNewt
+
+#endif
+// _INCLUDE_OGRENEWT_MATERIALID
+

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_MaterialPair.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_MaterialPair.h	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_MaterialPair.h	2007-02-28 03:27:47 UTC (rev 3086)
@@ -1,91 +1,90 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_MATERIALPAIR
-#define _INCLUDE_OGRENEWT_MATERIALPAIR
-
-#include &quot;OgreNewt_Prerequisites.h&quot;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_World.h&quot;
-#include &quot;OgreNewt_ContactCallback.h&quot;
-#include &quot;OgreNewt_MaterialID.h&quot;
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-
-
-//! define interaction between materials
-/*!
-	this class represents a pair of Newton MaterialGroupIDs, which is 
-	used to define interaction bewteen materials.
-*/
-class _OgreNewtExport MaterialPair
-{
-public:
-
-	//! constructor
-	/*!
-		creates an object representing a pair of materials, and defining how they will interact.
-		\param world pointer to the OgreNewt::World
-		\param mat1 pointer to first materialID
-		\param mat2 pointer to second materialID
-	*/
-	MaterialPair( const World* world, const MaterialID* mat1, const MaterialID* mat2 );
-
-	//! destructor
-	~MaterialPair();
-
-
-	// set the default behavior for this material pair.
-
-	//! set default softness for the material pair.
-	void setDefaultSoftness( Ogre::Real softness ) const { NewtonMaterialSetDefaultSoftness( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), (float)softness ); }
-
-	//! set default elasticity for the material pair.
-	void setDefaultElasticity( Ogre::Real elasticity ) const { NewtonMaterialSetDefaultElasticity( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), (float)elasticity ); }
-
-	//! set default collision for the material pair.
-	void setDefaultCollidable( int state ) const { NewtonMaterialSetDefaultCollidable( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), state ); }
-
-	//! set default friction for the material pair.
-	void setDefaultFriction( Ogre::Real stat, Ogre::Real kinetic ) const { NewtonMaterialSetDefaultFriction( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), (float)stat, (float)kinetic ); }
-
-	//! set continuos collision on/off for this material pair
-	/*!
-		continuous collision mode is an advanced system used to prevent &quot;tunelling&quot;, or objects passing through one an other when traveling at high velocities.  
-		there is a performance hit involved, so this sould only be used when it is deemed necessary.
-	*/
-	void setContinuousCollisionMode( int state ) const { NewtonMaterialSetContinuousCollisionMode( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), state ); }
-
-
-	//! assign a custom collision callback.
-	/*!
-		ContactCallbacks allow for custom interaction between bodies of specific materials.
-		\param callback pointer to a user-created ContactCallback object
-	*/
-	void setContactCallback( OgreNewt::ContactCallback* callback );
-
-
-
-protected:
-
-	const MaterialID*	id0;
-	const MaterialID*	id1;
-	const World*		m_world;
-
-};
-
-
-}	// end NAMESPACE OgreNewt
-
-#endif
-// _INCLUDE_OGRENEWT_MATERIALPAIR
-
+/* 
+	OgreNewt Library
+
+	Ogre implementation of Newton Game Dynamics SDK
+
+	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+
+		by Walaber
+
+*/
+#ifndef _INCLUDE_OGRENEWT_MATERIALPAIR
+#define _INCLUDE_OGRENEWT_MATERIALPAIR
+
+#include &lt;Newton.h&gt;
+#include &quot;OgreNewt_World.h&quot;
+#include &quot;OgreNewt_ContactCallback.h&quot;
+#include &quot;OgreNewt_MaterialID.h&quot;
+
+// OgreNewt namespace.  all functions and classes use this namespace.
+namespace OgreNewt
+{
+
+
+//! define interaction between materials
+/*!
+	this class represents a pair of Newton MaterialGroupIDs, which is 
+	used to define interaction bewteen materials.
+*/
+class _OgreNewtExport MaterialPair
+{
+public:
+
+	//! constructor
+	/*!
+		creates an object representing a pair of materials, and defining how they will interact.
+		\param world pointer to the OgreNewt::World
+		\param mat1 pointer to first materialID
+		\param mat2 pointer to second materialID
+	*/
+	MaterialPair( const World* world, const MaterialID* mat1, const MaterialID* mat2 );
+
+	//! destructor
+	~MaterialPair();
+
+
+	// set the default behavior for this material pair.
+
+	//! set default softness for the material pair.
+	void setDefaultSoftness( Ogre::Real softness ) const { NewtonMaterialSetDefaultSoftness( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), (float)softness ); }
+
+	//! set default elasticity for the material pair.
+	void setDefaultElasticity( Ogre::Real elasticity ) const { NewtonMaterialSetDefaultElasticity( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), (float)elasticity ); }
+
+	//! set default collision for the material pair.
+	void setDefaultCollidable( int state ) const { NewtonMaterialSetDefaultCollidable( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), state ); }
+
+	//! set default friction for the material pair.
+	void setDefaultFriction( Ogre::Real stat, Ogre::Real kinetic ) const { NewtonMaterialSetDefaultFriction( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), (float)stat, (float)kinetic ); }
+
+	//! set continuos collision on/off for this material pair
+	/*!
+		continuous collision mode is an advanced system used to prevent &quot;tunelling&quot;, or objects passing through one an other when traveling at high velocities.  
+		there is a performance hit involved, so this sould only be used when it is deemed necessary.
+	*/
+	void setContinuousCollisionMode( int state ) const { NewtonMaterialSetContinuousCollisionMode( m_world-&gt;getNewtonWorld(), id0-&gt;getID(), id1-&gt;getID(), state ); }
+
+
+	//! assign a custom collision callback.
+	/*!
+		ContactCallbacks allow for custom interaction between bodies of specific materials.
+		\param callback pointer to a user-created ContactCallback object
+	*/
+	void setContactCallback( OgreNewt::ContactCallback* callback );
+
+
+
+protected:
+
+	const MaterialID*	id0;
+	const MaterialID*	id1;
+	const World*		m_world;
+
+};
+
+
+}	// end NAMESPACE OgreNewt
+
+#endif
+// _INCLUDE_OGRENEWT_MATERIALPAIR
+

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_Prerequisites.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_Prerequisites.h	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_Prerequisites.h	2007-02-28 03:27:47 UTC (rev 3086)
@@ -25,9 +25,9 @@
 #       define _OgreNewtExport
 #   endif
 #else // Linux / Mac OSX etc
-#   include &lt;stddef.h&gt;
 #   define _OgreNewtExport
 #   define _CDECL
 #endif
 
 #endif 
+

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_RayCast.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_RayCast.h	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_RayCast.h	2007-02-28 03:27:47 UTC (rev 3086)
@@ -1,21 +1,28 @@
 /* 
 	OgreNewt Library
+
 	Ogre implementation of Newton Game Dynamics SDK
+
 	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+
 		by Walaber
+
 */
 
 #ifndef _INCLUDE_OGRENEWT_RAYCAST
 #define _INCLUDE_OGRENEWT_RAYCAST
 
+
 #include &lt;Ogre.h&gt;
 #include &lt;Newton.h&gt;
 #include &quot;OgreNewt_World.h&quot;
 #include &quot;OgreNewt_Body.h&quot;
 
+
 // OgreNewt namespace.  all functions and classes use this namespace.
 namespace OgreNewt
 {
+
 //! general raycast
 /*!
 	General class representing a raycast query in the Newton world.  this class should be inherited to create specific raycast behavior.
@@ -39,6 +46,13 @@
 	*/
 	void go( const OgreNewt::World* world, const Ogre::Vector3&amp; startpt, const Ogre::Vector3&amp; endpt );
 
+	//! user callback pre-filter function.
+	/*!
+		This function is an optional pre-filter to completely ignore specific bodies during the raycast.
+		return false from this function to ignore this body, return true (default) to accept it.
+	*/
+	virtual bool userPreFilterCallback( OgreNewt::Body* body ) { return true; }
+
 	//! user callback filter function
 	/*! user callback function.  
 		This function must be implemented by the user.
@@ -49,12 +63,19 @@
 	*/
 	virtual bool userCallback( OgreNewt::Body* body, Ogre::Real distance, const Ogre::Vector3&amp; normal, int collisionID ) = 0;
 
+
 private:
 
 	//! callback used for running the raycast itself... used internally
 	static float _CDECL newtonRaycastFilter(const NewtonBody* body, const float* hitNormal, int collisionID, void* userData, float intersetParam);
+
+	//! callback used for running the raycast prefilder... used internally
+	static unsigned _CDECL newtonRaycastPreFilter( const NewtonBody* body, const NewtonCollision* collision, void* userData );
 };
 
+
+
+
 //! Basic implementation of the raycast
 /*!
 	This class is provided for general raycast use.  it returns information about all bodies hit by the ray.
@@ -66,14 +87,13 @@
 	class _OgreNewtExport BasicRaycastInfo
 	{
 	public:
-		Ogre::Real		mDistance;	  //!&lt; dist from point1 of the raycast, in range [0,1].
-		OgreNewt::Body*	mBody;	      //!&lt; pointer to body intersected with
-		int				mCollisionID; //!&lt; collision ID of the primitive hit by the ray
-		Ogre::Vector3	mNormal;	  //!&lt; normal of intersection.
+		Ogre::Real					mDistance;	//!&lt; dist from point1 of the raycast, in range [0,1].
+		OgreNewt::Body*				mBody;	//!&lt; pointer to body intersected with
+		int							mCollisionID;		//!&lt; collision ID of the primitive hit by the ray (for compound collision bodies)
+		Ogre::Vector3				mNormal;	//!&lt; normal of intersection.
 
-        BasicRaycastInfo()
-            : mDistance(-1.0f), mBody(NULL), mCollisionID(0), mNormal(Ogre::Vector3::ZERO) {}
-
+		BasicRaycastInfo();
+		~BasicRaycastInfo();
         bool operator&lt;(const BasicRaycastInfo&amp; rhs) const
         {
             return mDistance &lt; rhs.mDistance;
@@ -105,19 +125,29 @@
 	int getHitCount() const;
 
 	//! retrieve the raycast info for a specific hit.
-	BasicRaycastInfo getInfoAt( int hitnum ) const;
+	BasicRaycastInfo getInfoAt( unsigned int hitnum ) const;
 
 	//! get the closest body hit by the ray.
 	BasicRaycastInfo getFirstHit() const;
 
+
 private:
 
+
 	// container for results.
 	typedef std::vector&lt;BasicRaycastInfo&gt; RaycastInfoList;
 
 	RaycastInfoList mRayList;
+
 };
 
+
+
 }	// end NAMESPACE OgreNewt
+	
 
+
+
+
 #endif	// _INCLUDE_OGRENEWT_RAYCAST
+

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_Tools.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_Tools.h	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_Tools.h	2007-02-28 03:27:47 UTC (rev 3086)
@@ -16,7 +16,6 @@
 #include &lt;Newton.h&gt;
 #include &quot;OgreNewt_World.h&quot;
 #include &quot;OgreNewt_Collision.h&quot;
-using namespace Ogre;
 
 namespace OgreNewt
 {
@@ -30,7 +29,7 @@
 			\param quat returned quaternion
 			\param pos returned position vector
 		*/
-		_OgreNewtExport void MatrixToQuatPos( const float* matrix, Quaternion&amp; quat, Vector3 &amp;pos );
+		_OgreNewtExport void MatrixToQuatPos( const float* matrix, Ogre::Quaternion&amp; quat, Ogre::Vector3 &amp;pos );
 	
 
 		//! Take a Quaternion and Position Matrix and create a Newton-happy float matrix!
@@ -39,7 +38,7 @@
 			\param pos input position vector
 			\param matrix returned matrix (float[16])
 		*/
-		_OgreNewtExport void QuatPosToMatrix( const Quaternion&amp; quat, const Vector3 &amp;pos, float* matrix );
+		_OgreNewtExport void QuatPosToMatrix( const Ogre::Quaternion&amp; quat, const Ogre::Vector3 &amp;pos, float* matrix );
 
 		//! Take a Newton matrix and make it into an Ogre::Matrix4.
 		/*!
@@ -180,7 +179,7 @@
 		_OgreNewtExport Ogre::Vector3 CalcSphereSolid( Ogre::Real mass, Ogre::Real radius );
 
 		//! calculate moment of inertia for a hollow sphere
-		_OgreNewtExport Ogre::Vector3 CalcSphereHollor(Ogre::Real mass, Ogre::Real radius );
+		_OgreNewtExport Ogre::Vector3 CalcSphereHollow(Ogre::Real mass, Ogre::Real radius );
 		
 		//! calculate moment of inertia for a solid box
 		_OgreNewtExport Ogre::Vector3 CalcBoxSolid(Ogre::Real mass, const Ogre::Vector3&amp; size );
@@ -193,3 +192,4 @@
 }	// end NAMESPACE OgreNewt
 
 #endif
+

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_TreeCollisionSerializer.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_TreeCollisionSerializer.h	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_TreeCollisionSerializer.h	2007-02-28 03:27:47 UTC (rev 3086)
@@ -1,70 +1,69 @@
-/* 
-OgreNewt Library
-
-Ogre implementation of Newton Game Dynamics SDK
-
-OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_TREECOLLISIONSERIALIZER
-#define _INCLUDE_OGRENEWT_TREECOLLISIONSERIALIZER
-
-#include &quot;OgreNewt_Prerequisites.h&quot;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_World.h&quot;
-#include &quot;OgreSerializer.h&quot;
-#include &quot;OgreString.h&quot;
-
-// OgreNewt namespace.  all functions and classes use this namespace.
-namespace OgreNewt
-{
-  namespace CollisionPrimitives
-  {
-    class TreeCollision;
-  }
-
-  /*!
-  This class can be used to (de)serialize a TreeCollision. Pre-building a TreeCollision and serializing from a tool,
-  then deserializing it at runtime may be more efficient than building the TreeCollision on the fly, especially for complex objects.
-  */
-  class _OgreNewtExport TreeCollisionSerializer : public Ogre::Serializer
-  {
-  public:
-
-    //! constructor
-    TreeCollisionSerializer();
-
-    //! destructor
-    virtual ~TreeCollisionSerializer();
-
-    /*!
-    Serialize the TreeCollision to a file with the given name.
-    */
-    void exportTreeCollision(const CollisionPrimitives::TreeCollision* collision, const Ogre::String&amp; filename);
-
-    /*!
-    Deserialize the TreeCollision from a DataStream.
-    */
-    void importTreeCollision(Ogre::DataStreamPtr&amp; stream, CollisionPrimitives::TreeCollision* pDest);
-
-    /*!
-    Callback function for Newton. It should never be called directly, but will be called by Newton to save the TreeCollision to a stream.
-    (Newton calls this function several times for each serialization, once for each chunk of its file format apparently)
-    */
-    static void _CDECL _newtonSerializeCallback(void* serializeHandle, const void* buffer, size_t size);
-
-    /*!
-    Callback function for Newton. It should never be called directly, but will be called by Newton to load the TreeCollision from a stream.
-    (Newton calls this function several times for each deserialization, once for each chunk of its file format apparently)
-    */
-    static void _CDECL _newtonDeserializeCallback(void* deserializeHandle, void* buffer, size_t size);
-  };
-
-
-}	// end NAMESPACE OgreNewt
-
-#endif
-// _INCLUDE_OGRENEWT_TREECOLLISIONSERIALIZER
-
+/* 
+OgreNewt Library
+
+Ogre implementation of Newton Game Dynamics SDK
+
+OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+
+by Walaber
+
+*/
+#ifndef _INCLUDE_OGRENEWT_TREECOLLISIONSERIALIZER
+#define _INCLUDE_OGRENEWT_TREECOLLISIONSERIALIZER
+
+#include &lt;Newton.h&gt;
+#include &quot;OgreNewt_World.h&quot;
+#include &quot;OgreSerializer.h&quot;
+#include &quot;OgreString.h&quot;
+
+// OgreNewt namespace.  all functions and classes use this namespace.
+namespace OgreNewt
+{
+  namespace CollisionPrimitives
+  {
+    class TreeCollision;
+  }
+
+  /*!
+  This class can be used to (de)serialize a TreeCollision. Pre-building a TreeCollision and serializing from a tool,
+  then deserializing it at runtime may be more efficient than building the TreeCollision on the fly, especially for complex objects.
+  */
+  class _OgreNewtExport TreeCollisionSerializer : public Ogre::Serializer
+  {
+  public:
+
+    //! constructor
+    TreeCollisionSerializer();
+
+    //! destructor
+    virtual ~TreeCollisionSerializer();
+
+    /*!
+    Serialize the TreeCollision to a file with the given name.
+    */
+    void exportTreeCollision(const CollisionPrimitives::TreeCollision* collision, const Ogre::String&amp; filename);
+
+    /*!
+    Deserialize the TreeCollision from a DataStream.
+    */
+    void importTreeCollision(Ogre::DataStreamPtr&amp; stream, CollisionPrimitives::TreeCollision* pDest);
+
+    /*!
+    Callback function for Newton. It should never be called directly, but will be called by Newton to save the TreeCollision to a stream.
+    (Newton calls this function several times for each serialization, once for each chunk of its file format apparently)
+    */
+    static void _CDECL _newtonSerializeCallback(void* serializeHandle, const void* buffer, size_t size);
+
+    /*!
+    Callback function for Newton. It should never be called directly, but will be called by Newton to load the TreeCollision from a stream.
+    (Newton calls this function several times for each deserialization, once for each chunk of its file format apparently)
+    */
+    static void _CDECL _newtonDeserializeCallback(void* deserializeHandle, void* buffer, size_t size);
+  };
+
+
+}	// end NAMESPACE OgreNewt
+
+#endif
+// _INCLUDE_OGRENEWT_TREECOLLISIONSERIALIZER
+

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_Vehicle.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_Vehicle.h	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_Vehicle.h	2007-02-28 03:27:47 UTC (rev 3086)
@@ -1,217 +1,217 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-#ifndef _INCLUDE_OGRENEWT_VEHICLE
-#define _INCLUDE_OGRENEWT_VEHICLE
-
-#include &quot;OgreNewt_Prerequisites.h&quot;
-#include &lt;Newton.h&gt;
-#include &quot;OgreNewt_Body.h&quot;
-#include &quot;OgreNewt_Joint.h&quot;
-#include &quot;OgreNewt_World.h&quot;
-
-namespace OgreNewt
-{
-
-//! Represents a wheeled vehicle
-/*!
-	this class represents a basic vehicle, meant to be inherited by the user, with functionality added.
-*/
-	class _OgreNewtExport Vehicle
-	{
-	public:
-
-		//! basic vehicle tire.
-		/*!
-			secondary class: Tire.  this represents a basic tire.  you add tires by simply creating new tire objects, they are attached to the vehicle object you pass to the constructor.
-		*/
-		class _OgreNewtExport Tire
-		{
-		public:
-			//! overloaded constructor.
-			/*
-				this is the all-important constructor.
-				\param vehicle the parent vehicle to which you want to add this tire.
-				\param localorient local orientation of the tire (in the space of the chassis rigid body)
-				\param localpos local orientation of the tire (in the space of the chassis rigid body)
-				\param pin direction of the pin (axle) in the space of the tire
-				\param mass mass of the tire
-				\param width width of the tire
-				\param radius radis of the tire
-				\param susShock spring damper coefficient
-				\param susSpring spring strength
-				\param susLength spring length
-				\param colID collision ID used to determine collision in material callbacks.
-			*/
-			Tire( OgreNewt::Vehicle* vehicle, Ogre::Quaternion localorient, Ogre::Vector3 localpos, Ogre::Vector3 pin,
-				Ogre::Real mass, Ogre::Real width, Ogre::Real radius, Ogre::Real susShock, Ogre::Real susSpring, Ogre::Real susLength, int colID = 0);
-
-			//! destructor.
-			virtual ~Tire();
-
-			//! attach a scenenode to the tire!
-			void attachToNode( Ogre::SceneNode* node ) { m_node = node; }
-
-			//! update the position of the tire.  this must be called to update the attached scene node to the position of the tire!
-			void updateNode();
-
-			//! get the Newton ID for this tire.
-			const void* getNewtonID() const { return m_tireid; }
-
-			//! get the parent vehicle.
-			OgreNewt::Vehicle* getVehicle() const { return m_vehicle; }
-
-			//! get Ogre::SceneNode.
-			Ogre::SceneNode* getOgreNode() const { return m_node; }
-
-			//////////////////////////////////////////////////////////////////////
-			// Newton functions
-			
-			//! is the tire airborne?
-			int isAirBorne() const { return NewtonVehicleTireIsAirBorne( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
-
-			//! has the tire lost side grip?
-			int lostSideGrip() const { return NewtonVehicleTireLostSideGrip( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
-
-			//! has the tire lost traction?
-			int lostTraction() const { return NewtonVehicleTireLostTraction( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
-
-			//! get the rotational velocity of the tire
-			Ogre::Real getOmega() const { return (Ogre::Real)NewtonVehicleGetTireOmega( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
-
-			//! get the load on the tire (along the suspension normal )
-			Ogre::Real getNormalLoad() const { return (Ogre::Real)NewtonVehicleGetTireNormalLoad( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
-
-			//! get the current steering angle for this tire
-			Ogre::Radian getSteeringAngle() const { return Ogre::Radian( NewtonVehicleGetTireSteerAngle( m_vehicle-&gt;getNewtonVehicle(), m_tireid ) ); }
-
-			//! get the lateral speed of the tire (sideways)
-			Ogre::Real getLateralSpeed() const { return NewtonVehicleGetTireLateralSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
-
-			//! get the longitudinal speed of the tire (forward/backward)
-			Ogre::Real getLongitudinalSpeed() const { return NewtonVehicleGetTireLongitudinalSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
-
-			//! get the location and orientation of the tire (in global space).
-			void getPositionOrientation( Ogre::Quaternion&amp; orient, Ogre::Vector3&amp; pos );
-
-			//! set the torque for this tire.  this must be called in the tire callback!
-			void setTorque( Ogre::Real torque ) const { NewtonVehicleSetTireTorque( m_vehicle-&gt;getNewtonVehicle(), m_tireid, torque ); }
-
-			//! set the steering angle for the tire.  this must be called in the tire callback.
-			void setSteeringAngle( Ogre::Radian angle ) const { NewtonVehicleSetTireSteerAngle( m_vehicle-&gt;getNewtonVehicle(), m_tireid, angle.valueRadians() ); }
-
-			//! calculate the max brake acceleration to stop the tires.
-			Ogre::Real calculateMaxBrakeAcceleration() const { return (Ogre::Real)NewtonVehicleTireCalculateMaxBrakeAcceleration( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
-
-			//! set the brake acceleration
-			void setBrakeAcceleration( Ogre::Real accel, Ogre::Real limit ) const { NewtonVehicleTireSetBrakeAcceleration( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)accel, (float)limit ); }
-
-			//! max side slip speed
-			void setMaxSideSlipSpeed( Ogre::Real speed ) const { NewtonVehicleSetTireMaxSideSleepSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)speed ); }
-
-			//! set side slip coefficient
-			void setSideSlipCoefficient( Ogre::Real coefficient ) const { NewtonVehicleSetTireSideSleepCoeficient( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)coefficient ); }
-
-			//! max longitudinal slip speed
-			void setMaxLongitudinalSlipSpeed( Ogre::Real speed ) const { NewtonVehicleSetTireMaxLongitudinalSlideSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)speed ); }
-
-			//! set longitudinal slip coefficient
-			void setLongitudinalSlipCoefficient( Ogre::Real coefficient ) const { NewtonVehicleSetTireLongitudinalSlideCoeficient( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)coefficient ); }
-
-
-
-
-		protected:
-			OgreNewt::Vehicle* m_vehicle;
-			void* m_tireid;
-
-			Ogre::SceneNode* m_node;
-
-		};
-
-
-		//! constructor
-		Vehicle() { m_vehicle = NULL; }
-
-		//! destructor
-		virtual ~Vehicle();
-
-		//! initialize the vehicle
-		/*!
-			this function should be called to initialize the vehicle, assigning it's main chassis rigid body.  the function
-			also calls the virtual function &quot;setup&quot; which the user should implement to add tires to the vehicle.
-			\param chassis pointer to the OgreNewt::Body to use as the chassis.
-			\param updir unit vector signifying which direction is &quot;up&quot; in your world.  used for suspension.
-		*/
-		void init( OgreNewt::Body* chassis, const Ogre::Vector3&amp; updir );
-
-		//! destroy the vehicle, including chassis Body.
-		void destroy();	
-
-		//! setup the tires.
-		/*!
-			this is a virtual function that must be implemented by the user.  you should add and balance all tires in this function.
-		*/
-		virtual void setup() = 0;
-
-		//! user callback for controlling the vehicle
-		/*!
-			callback called each frame.  inside this callback you can add torque and steering to the tires to control the vehicle.
-		*/
-		virtual void userCallback() {}
-
-		//! get the chassis body.
-		OgreNewt::Body* getChassisBody() const { return m_chassis; }
-
-		//! get the NewtonJoint for the vehicle.
-		NewtonJoint* getNewtonVehicle()  const { return m_vehicle; }
-
-		//////////////////////////////////////////////////////////////
-		// Newton Vehicle functions.
-
-		//! reset the vehicle (stop all tires)
-		void reset() const { NewtonVehicleReset( m_vehicle ); }
-
-		//! get a pointer to the first tire
-		/*!
-			This can be used with the getNextTire function to iterate through all tires in the vehicle.  see examples for more info.
-			should only be called from inside the userCallback() function.
-		*/
-		const OgreNewt::Vehicle::Tire* getFirstTire() const;
-
-		//! get a pointer to the next tire in the vehicle.
-		/*!
-			This can be used with the getFirstTire function to iterate through all tires in the vehicle.  see examples for more info.
-			should only be called from inside the userCallback() function.
-		*/
-		const OgreNewt::Vehicle::Tire* getNextTire( OgreNewt::Vehicle::Tire* current_tire ) const;
-
-
-	protected:
-
-		OgreNewt::Body* m_chassis;
-
-	private:
-		//! callback for newton... it calls the userCallback() function for you.
-		static void _CDECL newtonCallback( const NewtonJoint* me );
-
-		static void _CDECL newtonDestructor( const NewtonJoint* me );
-
-		NewtonJoint* m_vehicle;
-		
-
-	};
-
-
-
-}	// end NAMESPACE OgreNewt
-
-
-#endif	// _INCLUDE_OGRENEWT_VEHICLE
+/* 
+	OgreNewt Library
+
+	Ogre implementation of Newton Game Dynamics SDK
+
+	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+
+		by Walaber
+
+*/
+#ifndef _INCLUDE_OGRENEWT_VEHICLE
+#define _INCLUDE_OGRENEWT_VEHICLE
+
+#include &lt;Newton.h&gt;
+#include &quot;OgreNewt_Body.h&quot;
+#include &quot;OgreNewt_Joint.h&quot;
+#include &quot;OgreNewt_World.h&quot;
+
+namespace OgreNewt
+{
+
+//! Represents a wheeled vehicle
+/*!
+	this class represents a basic vehicle, meant to be inherited by the user, with functionality added.
+*/
+	class _OgreNewtExport Vehicle
+	{
+	public:
+
+		//! basic vehicle tire.
+		/*!
+			secondary class: Tire.  this represents a basic tire.  you add tires by simply creating new tire objects, they are attached to the vehicle object you pass to the constructor.
+		*/
+		class _OgreNewtExport Tire
+		{
+		public:
+			//! overloaded constructor.
+			/*
+				this is the all-important constructor.
+				\param vehicle the parent vehicle to which you want to add this tire.
+				\param localorient local orientation of the tire (in the space of the chassis rigid body)
+				\param localpos local orientation of the tire (in the space of the chassis rigid body)
+				\param pin direction of the pin (axle) in the space of the tire
+				\param mass mass of the tire
+				\param width width of the tire
+				\param radius radis of the tire
+				\param susShock spring damper coefficient
+				\param susSpring spring strength
+				\param susLength spring length
+				\param colID collision ID used to determine collision in material callbacks.
+			*/
+			Tire( OgreNewt::Vehicle* vehicle, Ogre::Quaternion localorient, Ogre::Vector3 localpos, Ogre::Vector3 pin,
+				Ogre::Real mass, Ogre::Real width, Ogre::Real radius, Ogre::Real susShock, Ogre::Real susSpring, Ogre::Real susLength, int colID = 0);
+
+			//! destructor.
+			virtual ~Tire();
+
+			//! attach a scenenode to the tire!
+			void attachToNode( Ogre::SceneNode* node ) { m_node = node; }
+
+			//! update the position of the tire.  this must be called to update the attached scene node to the position of the tire!
+			void updateNode();
+
+			//! get the Newton ID for this tire.
+			const void* getNewtonID() const { return m_tireid; }
+
+			//! get the parent vehicle.
+			OgreNewt::Vehicle* getVehicle() const { return m_vehicle; }
+
+			//! get Ogre::SceneNode.
+			Ogre::SceneNode* getOgreNode() const { return m_node; }
+
+			//////////////////////////////////////////////////////////////////////
+			// Newton functions
+			
+			//! is the tire airborne?
+			int isAirBorne() const { return NewtonVehicleTireIsAirBorne( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
+
+			//! has the tire lost side grip?
+			int lostSideGrip() const { return NewtonVehicleTireLostSideGrip( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
+
+			//! has the tire lost traction?
+			int lostTraction() const { return NewtonVehicleTireLostTraction( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
+
+			//! get the rotational velocity of the tire
+			Ogre::Real getOmega() const { return (Ogre::Real)NewtonVehicleGetTireOmega( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
+
+			//! get the load on the tire (along the suspension normal )
+			Ogre::Real getNormalLoad() const { return (Ogre::Real)NewtonVehicleGetTireNormalLoad( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
+
+			//! get the current steering angle for this tire
+			Ogre::Radian getSteeringAngle() const { return Ogre::Radian( NewtonVehicleGetTireSteerAngle( m_vehicle-&gt;getNewtonVehicle(), m_tireid ) ); }
+
+			//! get the lateral speed of the tire (sideways)
+			Ogre::Real getLateralSpeed() const { return NewtonVehicleGetTireLateralSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
+
+			//! get the longitudinal speed of the tire (forward/backward)
+			Ogre::Real getLongitudinalSpeed() const { return NewtonVehicleGetTireLongitudinalSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
+
+			//! get the location and orientation of the tire (in global space).
+			void getPositionOrientation( Ogre::Quaternion&amp; orient, Ogre::Vector3&amp; pos );
+
+			//! set the torque for this tire.  this must be called in the tire callback!
+			void setTorque( Ogre::Real torque ) const { NewtonVehicleSetTireTorque( m_vehicle-&gt;getNewtonVehicle(), m_tireid, torque ); }
+
+			//! set the steering angle for the tire.  this must be called in the tire callback.
+			void setSteeringAngle( Ogre::Radian angle ) const { NewtonVehicleSetTireSteerAngle( m_vehicle-&gt;getNewtonVehicle(), m_tireid, angle.valueRadians() ); }
+
+			//! calculate the max brake acceleration to stop the tires.
+			Ogre::Real calculateMaxBrakeAcceleration() const { return (Ogre::Real)NewtonVehicleTireCalculateMaxBrakeAcceleration( m_vehicle-&gt;getNewtonVehicle(), m_tireid ); }
+
+			//! set the brake acceleration
+			void setBrakeAcceleration( Ogre::Real accel, Ogre::Real limit ) const { NewtonVehicleTireSetBrakeAcceleration( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)accel, (float)limit ); }
+
+			//! max side slip speed
+			void setMaxSideSlipSpeed( Ogre::Real speed ) const { NewtonVehicleSetTireMaxSideSleepSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)speed ); }
+
+			//! set side slip coefficient
+			void setSideSlipCoefficient( Ogre::Real coefficient ) const { NewtonVehicleSetTireSideSleepCoeficient( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)coefficient ); }
+
+			//! max longitudinal slip speed
+			void setMaxLongitudinalSlipSpeed( Ogre::Real speed ) const { NewtonVehicleSetTireMaxLongitudinalSlideSpeed( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)speed ); }
+
+			//! set longitudinal slip coefficient
+			void setLongitudinalSlipCoefficient( Ogre::Real coefficient ) const { NewtonVehicleSetTireLongitudinalSlideCoeficient( m_vehicle-&gt;getNewtonVehicle(), m_tireid, (float)coefficient ); }
+
+
+
+
+		protected:
+			OgreNewt::Vehicle* m_vehicle;
+			void* m_tireid;
+
+			Ogre::SceneNode* m_node;
+
+		};
+
+
+		//! constructor
+		Vehicle() { m_vehicle = NULL; }
+
+		//! destructor
+		virtual ~Vehicle();
+
+		//! initialize the vehicle
+		/*!
+			this function should be called to initialize the vehicle, assigning it's main chassis rigid body.  the function
+			also calls the virtual function &quot;setup&quot; which the user should implement to add tires to the vehicle.
+			\param chassis pointer to the OgreNewt::Body to use as the chassis.
+			\param updir unit vector signifying which direction is &quot;up&quot; in your world.  used for suspension.
+		*/
+		void init( OgreNewt::Body* chassis, const Ogre::Vector3&amp; updir );
+
+		//! destroy the vehicle, including chassis Body.
+		void destroy();	
+
+		//! setup the tires.
+		/*!
+			this is a virtual function that must be implemented by the user.  you should add and balance all tires in this function.
+		*/
+		virtual void setup() = 0;
+
+		//! user callback for controlling the vehicle
+		/*!
+			callback called each frame.  inside this callback you can add torque and steering to the tires to control the vehicle.
+		*/
+		virtual void userCallback() {}
+
+		//! get the chassis body.
+		OgreNewt::Body* getChassisBody() const { return m_chassis; }
+
+		//! get the NewtonJoint for the vehicle.
+		NewtonJoint* getNewtonVehicle()  const { return m_vehicle; }
+
+		//////////////////////////////////////////////////////////////
+		// Newton Vehicle functions.
+
+		//! reset the vehicle (stop all tires)
+		void reset() const { NewtonVehicleReset( m_vehicle ); }
+
+		//! get a pointer to the first tire
+		/*!
+			This can be used with the getNextTire function to iterate through all tires in the vehicle.  see examples for more info.
+			should only be called from inside the userCallback() function.
+		*/
+		const OgreNewt::Vehicle::Tire* getFirstTire() const;
+
+		//! get a pointer to the next tire in the vehicle.
+		/*!
+			This can be used with the getFirstTire function to iterate through all tires in the vehicle.  see examples for more info.
+			should only be called from inside the userCallback() function.
+		*/
+		const OgreNewt::Vehicle::Tire* getNextTire( OgreNewt::Vehicle::Tire* current_tire ) const;
+
+
+	protected:
+
+		OgreNewt::Body* m_chassis;
+
+	private:
+		//! callback for newton... it calls the userCallback() function for you.
+		static void _CDECL newtonCallback( const NewtonJoint* me );
+
+		static void _CDECL newtonDestructor( const NewtonJoint* me );
+
+		NewtonJoint* m_vehicle;
+		
+
+	};
+
+
+
+}	// end NAMESPACE OgreNewt
+
+
+#endif	// _INCLUDE_OGRENEWT_VEHICLE
+

Modified: dependencies/OgreNewt/include/OgreNewt/OgreNewt_World.h
===================================================================
--- dependencies/OgreNewt/include/OgreNewt/OgreNewt_World.h	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/include/OgreNewt/OgreNewt_World.h	2007-02-28 03:27:47 UTC (rev 3086)
@@ -10,9 +10,9 @@
 #ifndef _INCLUDE_OGRENEWT_WORLD
 #define _INCLUDE_OGRENEWT_WORLD
 
-#include &quot;OgreNewt_Prerequisites.h&quot;
 #include &lt;Newton.h&gt;
 #include &lt;Ogre.h&gt;
+#include &quot;OgreNewt_Prerequisites.h&quot;
 #include &quot;OgreNewt_MaterialID.h&quot;
 #include &quot;FastDelegate.h&quot;
 

Modified: dependencies/OgreNewt/src/OgreNewt_BasicJoints.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_BasicJoints.cpp	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/src/OgreNewt_BasicJoints.cpp	2007-02-28 03:27:47 UTC (rev 3086)
@@ -1,3 +1,4 @@
+#include &lt;Newton.h&gt;
 #include &lt;OgreNewt_BasicJoints.h&gt;
 #include &lt;OgreNewt_World.h&gt;
 #include &lt;OgreNewt_Body.h&gt;
@@ -441,6 +442,7 @@
 	// initialize variables
 	mMin = mMax = Ogre::Degree(0);
 	mLimitsOn = false;
+	mAccel = 0.0f;
 
 }
 

Modified: dependencies/OgreNewt/src/OgreNewt_Body.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Body.cpp	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/src/OgreNewt_Body.cpp	2007-02-28 03:27:47 UTC (rev 3086)
@@ -16,9 +16,6 @@
 	
 	m_userdata = NULL;
 
-	m_offset = Vector3::ZERO;
-	m_orientationBias = Quaternion::IDENTITY;
-
 	m_forcecallback = NULL;
 	m_transformcallback = NULL;
 	m_buoyancycallback = NULL;
@@ -83,6 +80,14 @@
 		me-&gt;m_forcecallback( me );
 }
 
+void _CDECL Body::newtonAutoactiveCallback(const NewtonBody* body, unsigned state)
+{
+	OgreNewt::Body* me = (OgreNewt::Body*)NewtonBodyGetUserData( body );
+
+	if (me-&gt;m_autoactivecallback)
+		me-&gt;m_autoactivecallback( me, state );
+}
+
 void Body::standardForceCallback( OgreNewt::Body* me )
 {
 	//apply a simple gravity force.
@@ -100,8 +105,8 @@
 
 void Body::standardTransformCallback( OgreNewt::Body* me, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos )
 {
-	me-&gt;m_node-&gt;setOrientation( me-&gt;m_orientationBias * orient);
-	me-&gt;m_node-&gt;setPosition( pos - orient*me-&gt;m_offset);
+	me-&gt;m_node-&gt;setOrientation( orient );
+	me-&gt;m_node-&gt;setPosition( pos );
 }
 
 
@@ -135,12 +140,9 @@
 
 
 // attachToNode
-void Body::attachToNode(Ogre::SceneNode* node, const Vector3&amp; offset,
-						const Quaternion&amp; orientationBias)
+void Body::attachToNode( Ogre::Node* node )
 {
 	m_node = node;
-	m_offset = offset;
-	m_orientationBias = orientationBias;
 	if (m_body)
 	{
 		setCustomTransformCallback( &amp;Body::standardTransformCallback );
@@ -158,8 +160,8 @@
 
 		if (m_node)
 		{
-			m_node-&gt;setOrientation(m_orientationBias * orient);
-			m_node-&gt;setPosition(pos - orient*m_offset);
+			m_node-&gt;setOrientation( orient );
+			m_node-&gt;setPosition( pos );
 		}
 	}
 }
@@ -175,8 +177,8 @@
 {
 	if (m_body)
     {
-        Vector3 center = Vector3::ZERO;
-        Vector3 inertia = Vector3::ZERO;
+		Ogre::Vector3 center = Ogre::Vector3::ZERO;
+        Ogre::Vector3 inertia = Ogre::Vector3::ZERO;
         NewtonConvexCollisionCalculateInertialMatrix(m_collision-&gt;getNewtonCollision(),
             &amp;inertia.x, &amp;center.x);
         NewtonBodySetMassMatrix(m_body, (float)mass,
@@ -222,10 +224,26 @@
 
 }
 
+// set callback for auto activate / deactivate
+void Body::setAutoactiveCallback ( autoactiveCallback callback ) 
+{
+	if (!m_autoactivecallback)
+	{
+		m_autoactivecallback = callback; 
+		NewtonBodySetAutoactiveCallback( m_body, newtonAutoactiveCallback );
+	}
+	else
+	{
+//		if (m_autoactivecallback != callback) // no need for this, setting it is quick and will not be called often, plus it keeps me from needing to include another file. :)
+			m_autoactivecallback = callback;
+	}
+}
+
 //set collision
 void Body::setCollision(CollisionPtr col)
 {
 	NewtonBodySetCollision( m_body, col-&gt;getNewtonCollision() );
+
 	m_collision = col;
 }
 
@@ -332,26 +350,7 @@
 	addGlobalForce( globalforce, globalpoint );
 }
 
-Ogre::Vector3 Body::getOffset() const
-{
-    return m_offset;
-}
 
-void Body::setOffset(const Ogre::Vector3&amp; offset)
-{
-    m_offset = offset;
-}
-
-Ogre::Quaternion Body::getOrientationBias() const
-{
-	return m_orientationBias;
-}
-
-void Body::setOrientationBias(const Ogre::Quaternion&amp; orientationbias)
-{
-	m_orientationBias = orientationbias;
-}
-
 // --------------------------------------------------------------------------------------
 
 

Modified: dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp	2007-02-28 03:27:47 UTC (rev 3086)
@@ -90,14 +90,14 @@
 		// OgreNewt::CollisionPrimitives::ConvexHull
 		ConvexHull::ConvexHull( const World* world, Ogre::Entity* entity, bool useTempBuffers, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
 		{
-			Ogre::Vector3 scale = Vector3::UNIT_SCALE;
+			Ogre::Vector3 scale = Ogre::Vector3::UNIT_SCALE;
 
 
 			// get the mesh!
 			Ogre::MeshPtr mesh = entity-&gt;getMesh();
 
 			// get scale, if attached to node
-			Node * node = entity-&gt;getParentNode();
+			Ogre::Node * node = entity-&gt;getParentNode();
 			if (node) scale = node-&gt;getScale();
 
 			//find number of submeshes
@@ -199,7 +199,9 @@
 
 					//unlock buffer
 					v_sptr-&gt;unlock();
-				}		
+				}
+
+		
 			}
 
 			float matrix[16];
@@ -210,8 +212,10 @@
 			m_col = NewtonCreateConvexHull( m_world-&gt;getNewtonWorld(), (int)total_verts, (float*)&amp;vertices[0].x, sizeof(Ogre::Vector3), &amp;matrix[0] );
 
 			delete []vertices;
+
 		}
 
+
 		// OgreNewt::CollisionPrimitives::ConvexHull
 		ConvexHull::ConvexHull( const World* world, const Ogre::Vector3* verts, int vertcount, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos ) : ConvexCollision( world )
 		{
@@ -223,22 +227,24 @@
 
 		}
 
+
+
+
 		TreeCollision::TreeCollision( const World* world) : Collision(world)
 		{
 		}
 
 		TreeCollision::TreeCollision( const World* world, Ogre::Entity* entity, bool optimize, bool useTempBuffers ) : Collision( world )
 		{
-			Ogre::Vector3 scale = Vector3::UNIT_SCALE;
+			Ogre::Vector3 scale = Ogre::Vector3::UNIT_SCALE;
 
-			m_col = NewtonCreateTreeCollision( m_world-&gt;getNewtonWorld(), NULL );
-			NewtonTreeCollisionBeginBuild( m_col );
+			start();
 
 			//now get the mesh!
 			Ogre::MeshPtr mesh = entity-&gt;getMesh();
 
 			//get scale
-			Node* node = entity-&gt;getParentNode();
+			Ogre::Node* node = entity-&gt;getParentNode();
 			if (node) scale = node-&gt;getScale();
 
 			//find number of sub-meshes
@@ -339,7 +345,7 @@
 						}
 					}
 
-					NewtonTreeCollisionAddFace( m_col, 3, (float*)&amp;poly_verts[0].x, sizeof(Ogre::Vector3), cs );
+					addPoly( poly_verts, cs );
 					i_offset += 3;
 				}
 
@@ -349,15 +355,14 @@
 
 			}
 			//done!
-			NewtonTreeCollisionEndBuild( m_col, optimize );
+			finish( optimize );
 		}
 
 
 		TreeCollision::TreeCollision(const OgreNewt::World *world, int numVertices, int numIndices, const float *vertices, const int *indices, bool optimize) : OgreNewt::Collision( world )
 		{
-			m_col = NewtonCreateTreeCollision( world-&gt;getNewtonWorld(), NULL );
-			NewtonTreeCollisionBeginBuild( m_col );
-
+			start();
+ 
 			int numPolys = numIndices / 3;
 
 			Ogre::Vector3 *vecVertices = new Ogre::Vector3[numVertices];
@@ -377,31 +382,30 @@
 				poly_verts[1] = vecVertices[indices[1 + poly * 3]];
 				poly_verts[2] = vecVertices[indices[2 + poly * 3]];
 
-				NewtonTreeCollisionAddFace( m_col, 3, (float*)&amp;poly_verts[0].x, sizeof(Ogre::Vector3), NULL );
+				addPoly( poly_verts, 0 );
 			}
 
 			delete [] vecVertices;
 
-			NewtonTreeCollisionEndBuild( m_col, true ); 
+		     finish( optimize );
 		}
 
 
 		TreeCollision::TreeCollision( const World* world, int numVertices, Ogre::Vector3* vertices, Ogre::IndexData* indexData, bool optimize) : Collision( world )
 		{
-			m_col = NewtonCreateTreeCollision( world-&gt;getNewtonWorld(), NULL );
-			NewtonTreeCollisionBeginBuild( m_col );
+			start();
 
-			int numPolys = indexData-&gt;indexCount / 3;
+			unsigned int numPolys = indexData-&gt;indexCount / 3;
 			Ogre::HardwareIndexBufferSharedPtr hwIndexBuffer=indexData-&gt;indexBuffer;
 			size_t indexSize=hwIndexBuffer-&gt;getIndexSize();
-			void* indices=hwIndexBuffer-&gt;lock(HardwareBuffer::HBL_READ_ONLY);
+			void* indices=hwIndexBuffer-&gt;lock(Ogre::HardwareBuffer::HBL_READ_ONLY);
 
 			assert((indexSize==2) || (indexSize==4));
 
 			if (indexSize==2)
 			{
 				unsigned short* curIndex=(unsigned short*)indices;
-				for ( int poly = 0; poly &lt; numPolys; poly++ )
+				for ( unsigned int poly = 0; poly &lt; numPolys; poly++ )
 				{
 					Ogre::Vector3 poly_verts[3];
 
@@ -410,13 +414,13 @@
 					poly_verts[2] = vertices[*curIndex]; curIndex++;
 					poly_verts[1] = vertices[*curIndex]; curIndex++;
 
-					NewtonTreeCollisionAddFace( m_col, 3, (float*)&amp;poly_verts[0].x, sizeof(Ogre::Vector3), NULL );
+					addPoly( poly_verts, 0 );
 				}
 			}
 			else
 			{
 				unsigned int* curIndex=(unsigned int*)indices;
-				for ( int poly = 0; poly &lt; numPolys; poly++ )
+				for ( unsigned int poly = 0; poly &lt; numPolys; poly++ )
 				{
 					Ogre::Vector3 poly_verts[3];
 
@@ -424,25 +428,205 @@
 					poly_verts[2] = vertices[*curIndex]; curIndex++;
 					poly_verts[1] = vertices[*curIndex]; curIndex++;
 
-					NewtonTreeCollisionAddFace( m_col, 3, (float*)&amp;poly_verts[0].x, sizeof(Ogre::Vector3), NULL );
+					addPoly( poly_verts, 0 );
 				}
 			}
-
+      
 			hwIndexBuffer-&gt;unlock();
-			NewtonTreeCollisionEndBuild( m_col, optimize );
+			finish( optimize );
 		} 
 
 
+		void TreeCollision::start()
+		{
+			m_col = NewtonCreateTreeCollision( m_world-&gt;getNewtonWorld(), NULL );
+			NewtonTreeCollisionBeginBuild( m_col );
+		}
+
+		void TreeCollision::addPoly( Ogre::Vector3* polys, unsigned int ID )
+		{
+			NewtonTreeCollisionAddFace( m_col, 3, (float*)&amp;polys[0].x, sizeof(Ogre::Vector3), ID );
+		}
+
+		void TreeCollision::finish( bool optimize)
+		{
+			NewtonTreeCollisionEndBuild( m_col, optimize );
+		}
+
+
+		int TreeCollisionSceneParser::count = 0;
+		
+		
+		TreeCollisionSceneParser::TreeCollisionSceneParser( OgreNewt::World* world ) : TreeCollision( world )
+		{
+		}
+		
+		void TreeCollisionSceneParser::parseScene( Ogre::SceneNode *startNode, bool optimize)
+		{
+			count = 0;
+
+			start();
+
+			// parse the individual nodes.
+			Ogre::Quaternion rootOrient = Ogre::Quaternion::IDENTITY;
+			Ogre::Vector3 rootPos = Ogre::Vector3::ZERO;
+
+			_parseNode( startNode, rootOrient, rootPos );
+
+			finish( optimize );
+		}
+
+		void TreeCollisionSceneParser::_parseNode(Ogre::SceneNode *node, const Ogre::Quaternion &amp;curOrient, const Ogre::Vector3 &amp;curPos)
+		{
+			// parse this scene node.
+			// do children first.
+			Ogre::Quaternion thisOrient = curOrient * node-&gt;getOrientation();
+			Ogre::Vector3 thisPos = curPos + (curOrient * node-&gt;getPosition() * node-&gt;getScale());
+			Ogre::Vector3 thisScale = node-&gt;getScale();
+
+			Ogre::SceneNode::ChildNodeIterator child_it = node-&gt;getChildIterator();
+
+			while (child_it.hasMoreElements())
+			{
+				_parseNode( (Ogre::SceneNode*)child_it.getNext(), thisOrient, thisPos );
+			}
+
+
+			// now add the polys from this node.
+			//now get the mesh!
+			unsigned int num_obj = node-&gt;numAttachedObjects();
+			for (unsigned int co=0; co&lt;num_obj; co++)
+			{
+				Ogre::MovableObject* obj = node-&gt;getAttachedObject(co);
+				if (obj-&gt;getMovableType() != &quot;Entity&quot;)
+					continue;
+			
+				Ogre::Entity* ent = (Ogre::Entity*)obj;
+
+				if (!entityFilter(node, ent))
+					continue;
+
+				Ogre::MeshPtr mesh = ent-&gt;getMesh();
+
+				//find number of sub-meshes
+				unsigned short sub = mesh-&gt;getNumSubMeshes();
+
+				for (unsigned short cs=0;cs&lt;sub;cs++)
+				{
+					Ogre::SubMesh* sub_mesh = mesh-&gt;getSubMesh(cs);
+
+					//vertex data!
+					Ogre::VertexData* v_data;
+
+					if (sub_mesh-&gt;useSharedVertices)
+					{	
+						v_data = mesh-&gt;sharedVertexData;
+					}
+					else
+					{
+						v_data = sub_mesh-&gt;vertexData;
+					}
+		
+					//let's find more information about the Vertices...
+					Ogre::VertexDeclaration* v_decl = v_data-&gt;vertexDeclaration;
+					const Ogre::VertexElement* p_elem = v_decl-&gt;findElementBySemantic( Ogre::VES_POSITION );
+		
+					// get pointer!
+					Ogre::HardwareVertexBufferSharedPtr v_sptr = v_data-&gt;vertexBufferBinding-&gt;getBuffer( p_elem-&gt;getSource() );
+					unsigned char* v_ptr = static_cast&lt;unsigned char*&gt;(v_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
+		
+					//now find more about the index!!
+					Ogre::IndexData* i_data = sub_mesh-&gt;indexData;
+					size_t index_count = i_data-&gt;indexCount;
+					size_t poly_count = index_count / 3;
+		
+					// get pointer!
+					Ogre::HardwareIndexBufferSharedPtr i_sptr = i_data-&gt;indexBuffer;
+		
+					// 16 or 32 bit indices?
+					bool uses32bit = ( i_sptr-&gt;getType() == Ogre::HardwareIndexBuffer::IT_32BIT );
+					unsigned long* i_Longptr;
+					unsigned short* i_Shortptr;
+		
+					if ( uses32bit)
+					{
+						i_Longptr = static_cast&lt;unsigned long*&gt;(i_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
+					}
+					else
+					{
+						i_Shortptr = static_cast&lt;unsigned short*&gt;(i_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
+					}
+
+					//now loop through the indices, getting polygon info!
+					int i_offset = 0;
+
+					for (size_t i=0; i&lt;poly_count; i++)
+					{
+						Ogre::Vector3 poly_verts[3];
+						unsigned char* v_offset;
+						float* v_Posptr;
+						int idx;
+
+						if (uses32bit)
+						{
+							for (int j=0;j&lt;3;j++)
+							{
+								idx = i_Longptr[i_offset+j];		// index to first vertex!
+								v_offset = v_ptr + (idx * v_sptr-&gt;getVertexSize());
+								p_elem-&gt;baseVertexPointerToElement( v_offset, &amp;v_Posptr );
+								//now get vertex position from v_Posptr!
+								poly_verts[j].x = *v_Posptr; v_Posptr++;
+								poly_verts[j].y = *v_Posptr; v_Posptr++;
+								poly_verts[j].z = *v_Posptr; v_Posptr++;
+	
+								poly_verts[j] = thisPos + (thisOrient * (poly_verts[j] * thisScale));
+							}
+						}
+						else
+						{
+							for (int j=0;j&lt;3;j++)
+							{
+								idx = i_Shortptr[i_offset+j];		// index to first vertex!
+								v_offset = v_ptr + (idx * v_sptr-&gt;getVertexSize());
+								p_elem-&gt;baseVertexPointerToElement( v_offset, &amp;v_Posptr );
+								//now get vertex position from v_Posptr!
+
+								// switch poly winding.
+								poly_verts[j].x = *v_Posptr; v_Posptr++;
+								poly_verts[j].y = *v_Posptr; v_Posptr++;
+								poly_verts[j].z = *v_Posptr; v_Posptr++;
+							
+								poly_verts[j] = thisPos + (thisOrient * (poly_verts[j] * thisScale));
+							}
+						}
+					
+						addPoly( poly_verts, getID(node, ent, cs) );
+						i_offset += 3;
+					}
+
+					//unlock the buffers!
+					v_sptr-&gt;unlock();
+					i_sptr-&gt;unlock();
+
+				}
+			}
+
+		}
+
+
+
+
+
 		// OgreNewt::CollisionPrimitives::CompoundCollision
 		CompoundCollision::CompoundCollision( const World* world, std::vector&lt;CollisionPtr&gt; col_array ) : Collision( world )
 		{
 			//get the number of elements.
-			int num = col_array.size();
+			unsigned int num = col_array.size();
 
 			// create simple array.
 			NewtonCollision** array = new NewtonCollision*[num];
 
-			for (int i=0;i&lt;num;i++)
+			for (unsigned int i=0;i&lt;num;i++)
 			{
 				array[i] = (NewtonCollision*)col_array[i]-&gt;getNewtonCollision();
 			}

Modified: dependencies/OgreNewt/src/OgreNewt_Debugger.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Debugger.cpp	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/src/OgreNewt_Debugger.cpp	2007-02-28 03:27:47 UTC (rev 3086)
@@ -12,6 +12,12 @@
 	m_debugnode = NULL;
 }
 
+Debugger::~Debugger()
+{
+	// natoka: I don't know but this creates an Access violation in deInit 
+	// at line 39
+	//Debugger::getSingleton().deInit();
+}
 
 Debugger&amp; Debugger::getSingleton()
 {
@@ -21,29 +27,45 @@
 		
 void Debugger::init( Ogre::SceneManager* smgr )
 {
-    m_debugnode = smgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(&quot;__OgreNewt__Debugger__&quot;);
-    m_debuglines = new Ogre::ManualObject(&quot;__OgreNewt__Debugger__&quot;);
-    m_debugnode-&gt;attachObject(m_debuglines); 
+	m_debugnode = smgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(&quot;__OgreNewt__Debugger__&quot;);
+	m_debuglines = NULL;
+	m_debuglines = new Ogre::ManualObject(&quot;__OgreNewt__Debugger__&quot;);
 }
 
+void Debugger::deInit()
+{
+	if (m_debugnode)
+	{
+		m_debugnode-&gt;detachAllObjects();
+		if (m_debuglines) { delete m_debuglines; m_debuglines = NULL; }
+		m_debugnode-&gt;getParentSceneNode()-&gt;removeAndDestroyChild( m_debugnode-&gt;getName() );
+		m_debugnode = NULL;
+	}
+}
 
+
 void Debugger::showLines( OgreNewt::World* world )
 {
+	m_debugnode-&gt;detachAllObjects();
 	m_debuglines-&gt;clear();
 	m_debuglines-&gt;begin(&quot;BaseWhiteNoLighting&quot;, Ogre::RenderOperation::OT_LINE_LIST );
 
-	// make the new lines.
+    // make the new lines.
     NewtonWorldForEachBodyDo(world-&gt;getNewtonWorld(), newtonPerBody);
 
-    m_debuglines-&gt;end();	
+    m_debuglines-&gt;end();
+	m_debugnode-&gt;attachObject(m_debuglines); 
+	
 }
 
 void Debugger::hideLines()
 {
 	// erase any existing lines!
+	m_debugnode-&gt;detachAllObjects();
 	m_debuglines-&gt;clear(); 
 }
 
+
 void _CDECL Debugger::newtonPerBody( const NewtonBody* body )
 {
 	NewtonBodyForEachPolygonDo( body, newtonPerPoly );
@@ -59,10 +81,15 @@
 	for (i=0;i&lt;vertexCount;i++)
 	{
 		p1 = Ogre::Vector3( faceVertec[(i*3) + 0], faceVertec[(i*3) + 1], faceVertec[(i*3) + 2] );
+
 		Debugger::getSingleton().m_debuglines-&gt;position( p0 );
 		Debugger::getSingleton().m_debuglines-&gt;position( p1 );
+
 		p0 = p1;
 	}
 }
 
+
+
+
 }	// end namespace OgreNewt

Modified: dependencies/OgreNewt/src/OgreNewt_MaterialID.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_MaterialID.cpp	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/src/OgreNewt_MaterialID.cpp	2007-02-28 03:27:47 UTC (rev 3086)
@@ -25,3 +25,4 @@
 
 
 }
+

Modified: dependencies/OgreNewt/src/OgreNewt_MaterialPair.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_MaterialPair.cpp	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/src/OgreNewt_MaterialPair.cpp	2007-02-28 03:27:47 UTC (rev 3086)
@@ -30,3 +30,4 @@
 
 
 }
+

Modified: dependencies/OgreNewt/src/OgreNewt_RayCast.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_RayCast.cpp	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/src/OgreNewt_RayCast.cpp	2007-02-28 03:27:47 UTC (rev 3086)
@@ -2,97 +2,125 @@
 
 namespace OgreNewt
 {
-    Raycast::Raycast()	{}
-    Raycast::~Raycast()	{}
 
-    void Raycast::go(const OgreNewt::World* world, const Ogre::Vector3&amp; startpt,
-        const Ogre::Vector3&amp; endpt )
-    {
-        // perform the raycast!
-        NewtonWorldRayCast( world-&gt;getNewtonWorld(), (float*)&amp;startpt,
-            (float*)&amp;endpt, OgreNewt::Raycast::newtonRaycastFilter, this, NULL);
-    }
 
-    float _CDECL Raycast::newtonRaycastFilter(const NewtonBody* body,
-        const float* hitNormal, int collisionID, void* userData, float intersectParam)
-    {
-        // get our object!
-        Raycast* me = (Raycast*)userData;
+	Raycast::Raycast()	{}
+	Raycast::~Raycast()	{}
 
-        Body* bod = (Body*)NewtonBodyGetUserData( body );
-        Ogre::Vector3 normal = Ogre::Vector3( hitNormal[0], hitNormal[1], hitNormal[2] );
 
-        if (me-&gt;userCallback( bod, intersectParam, normal, collisionID ))
-        {
-            return intersectParam;
-        }
-        else
-        {
-            return 1.1;
-        }
-    }
+	void Raycast::go(const OgreNewt::World* world, const Ogre::Vector3&amp; startpt, const Ogre::Vector3&amp; endpt )
+	{
+		// perform the raycast!
+		NewtonWorldRayCast( world-&gt;getNewtonWorld(), (float*)&amp;startpt, (float*)&amp;endpt, OgreNewt::Raycast::newtonRaycastFilter, this, OgreNewt::Raycast::newtonRaycastPreFilter );
+	}
 
-    BasicRaycast::BasicRaycast(const OgreNewt::World* world,
-        const Ogre::Vector3&amp; startpt, const Ogre::Vector3&amp; endpt, bool sorted ) : Raycast() 
-    {
-        go(world, startpt, endpt);
-        if (sorted)
-        {
-            std::sort(mRayList.begin(), mRayList.end());
-        }
-    }
+	float _CDECL Raycast::newtonRaycastFilter(const NewtonBody* body, const float* hitNormal, int collisionID, void* userData, float intersectParam)
+	{
+		// get our object!
+		Raycast* me = (Raycast*)userData;
 
-    BasicRaycast::~BasicRaycast()	{}
+		Body* bod = (Body*)NewtonBodyGetUserData( body );
+		Ogre::Vector3 normal = Ogre::Vector3( hitNormal[0], hitNormal[1], hitNormal[2] );
 
-    int BasicRaycast::getHitCount() const { return (int)mRayList.size(); }
+		if (me-&gt;userCallback( bod, intersectParam, normal, collisionID ))
+			return intersectParam;
+		else
+			return 1.1;
 
-    BasicRaycast::BasicRaycastInfo BasicRaycast::getFirstHit() const
-    {
-        //return the closest hit...
-        BasicRaycast::BasicRaycastInfo ret;
+	}
 
-        Ogre::Real dist = 10000.0;
+	unsigned _CDECL Raycast::newtonRaycastPreFilter(const NewtonBody *body, const NewtonCollision *collision, void* userData)
+	{
+		// get our object!
+		Raycast* me = (Raycast*)userData;
 
-        RaycastInfoList::const_iterator it;
-        for (it = mRayList.begin(); it != mRayList.end(); it++)
-        {
-            if (it-&gt;mDistance &lt; dist)
-            {
-                dist = it-&gt;mDistance;
-                ret = (*it);
-            }
-        }
+		Body* bod = (Body*)NewtonBodyGetUserData( body );
 
-        return ret;
-    }
+		if (me-&gt;userPreFilterCallback( bod ))
+			return 1;
+		else
+			return 0;
+	}
 
-    BasicRaycast::BasicRaycastInfo BasicRaycast::getInfoAt( int hitnum ) const
-    {
-        BasicRaycast::BasicRaycastInfo ret;
 
-        if ((hitnum &lt; 0) || (hitnum &gt; mRayList.size()))
-        {
-            return ret;
-        }
 
-        ret = mRayList.at(hitnum);
+	//--------------------------------
+	BasicRaycast::BasicRaycastInfo::BasicRaycastInfo()
+	{
+		mBody = NULL;
+		mDistance = -1.0;
+		mNormal = Ogre::Vector3::ZERO;
+	}
 
-        return ret;
-    }
+	BasicRaycast::BasicRaycastInfo::~BasicRaycastInfo() {}
 
-    bool BasicRaycast::userCallback(OgreNewt::Body* body, Ogre::Real distance,
-        const Ogre::Vector3&amp; normal, int collisionID)
-    {
-        // create a new infor object.
-        BasicRaycast::BasicRaycastInfo newinfo;
 
-        newinfo.mBody = body;
-        newinfo.mDistance = distance;
-        newinfo.mNormal = normal;
-        newinfo.mCollisionID = collisionID;
+	BasicRaycast::BasicRaycast(const OgreNewt::World* world, const Ogre::Vector3&amp; startpt,
+		const Ogre::Vector3&amp; endpt, bool sorted ) : Raycast() 
+	{
+		go( world, startpt, endpt );
+		if (sorted)
+		{
+			std::sort(mRayList.begin(), mRayList.end());
+		}
+	}
 
-        mRayList.push_back(newinfo);
+	BasicRaycast::~BasicRaycast()	{}
 
-        return false;
-    }
+
+	int BasicRaycast::getHitCount() const { return (int)mRayList.size(); }
+
+
+	BasicRaycast::BasicRaycastInfo BasicRaycast::getFirstHit() const
+	{
+		//return the closest hit...
+		BasicRaycast::BasicRaycastInfo ret;
+
+		Ogre::Real dist = 10000.0;
+
+		RaycastInfoList::const_iterator it;
+		for (it = mRayList.begin(); it != mRayList.end(); it++)
+		{
+			if (it-&gt;mDistance &lt; dist)
+			{
+				dist = it-&gt;mDistance;
+				ret = (*it);
+			}
+		}
+
+
+		return ret;
+	}
+
+
+	BasicRaycast::BasicRaycastInfo BasicRaycast::getInfoAt( unsigned int hitnum ) const
+	{
+		BasicRaycast::BasicRaycastInfo ret;
+
+		if ((hitnum &lt; 0) || (hitnum &gt; mRayList.size()))
+			return ret;
+
+		ret = mRayList.at(hitnum);
+
+		return ret;
+	}
+
+	bool BasicRaycast::userCallback( OgreNewt::Body* body, Ogre::Real distance, const Ogre::Vector3&amp; normal, int collisionID )
+	{
+		// create a new infor object.
+		BasicRaycast::BasicRaycastInfo newinfo;
+
+		newinfo.mBody = body;
+		newinfo.mDistance = distance;
+		newinfo.mNormal = normal;
+		newinfo.mCollisionID = collisionID;
+
+		mRayList.push_back( newinfo );
+
+		return false;
+	}
+
+
+
 }	// end NAMESPACE OgreNewt
+

Modified: dependencies/OgreNewt/src/OgreNewt_Tools.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Tools.cpp	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/src/OgreNewt_Tools.cpp	2007-02-28 03:27:47 UTC (rev 3086)
@@ -11,6 +11,7 @@
 	{
 		// this takes a matrix returned by Newton, and creates a Quaternion
 		// and position Vector3, which is more meaningful for Ogre.
+		using namespace Ogre;
 		quat = Quaternion( Matrix3(	matrix[0], matrix[4], matrix[8],
 						matrix[1], matrix[5], matrix[9],
 						matrix[2], matrix[6], matrix[10] ) );
@@ -23,6 +24,7 @@
 	{
 		// this takes a Quaternion and a Vector3 and creates a float array
 		// which is more meaningful to Newton.
+		using namespace Ogre;
 		Matrix3 rot;
 		Vector3 xcol, ycol, zcol;
 		
@@ -243,3 +245,4 @@
 
 
 }
+

Modified: dependencies/OgreNewt/src/OgreNewt_TreeCollisionSerializer.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_TreeCollisionSerializer.cpp	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/src/OgreNewt_TreeCollisionSerializer.cpp	2007-02-28 03:27:47 UTC (rev 3086)
@@ -2,7 +2,7 @@
 #include &lt;OgreNewt_CollisionPrimitives.h&gt;
 
 #include &quot;Ogre.h&quot;
-using namespace Ogre;
+
 namespace OgreNewt
 {
   TreeCollisionSerializer::TreeCollisionSerializer()
@@ -20,8 +20,7 @@
     mpfFile=fopen(filename.c_str(),&quot;wb&quot;);
     if (!mpfFile)
     {
-      OGRE_EXCEPT(Exception::ERR_INVALIDPARAMS, &quot;Unable to open file &quot; + filename + &quot; for writing&quot;,
-		  &quot;TreeCollisionSerializer::exportTreeCollision&quot;);
+      OGRE_EXCEPT(Ogre::Exception::ERR_INVALIDPARAMS, &quot;Unable to open file &quot; + filename + &quot; for writing&quot;,&quot;TreeCollisionSerializer::exportTreeCollision&quot;);
     }
     NewtonTreeCollisionSerialize(collision-&gt;m_col,&amp;TreeCollisionSerializer::_newtonSerializeCallback,this);
   }

Modified: dependencies/OgreNewt/src/OgreNewt_World.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_World.cpp	2007-02-28 03:00:28 UTC (rev 3085)
+++ dependencies/OgreNewt/src/OgreNewt_World.cpp	2007-02-28 03:27:47 UTC (rev 3086)
@@ -97,3 +97,4 @@
 
 
 }
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000156.html">[Dsa-hl-svn] r3085 - in rl/trunk/engine: core/include core/src	ui/src
</A></li>
	<LI>Next message: <A HREF="000158.html">[Dsa-hl-svn] r3087 - rl/trunk/engine/core/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#157">[ date ]</a>
              <a href="thread.html#157">[ thread ]</a>
              <a href="subject.html#157">[ subject ]</a>
              <a href="author.html#157">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
