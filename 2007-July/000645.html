<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r3574 - rl/trunk/engine/ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3574%20-%20rl/trunk/engine/ui/src&In-Reply-To=%3C200707022009.l62K9Rsf008457%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000644.html">
   <LINK REL="Next"  HREF="000646.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r3574 - rl/trunk/engine/ui/src</H1>
    <B>tanis at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3574%20-%20rl/trunk/engine/ui/src&In-Reply-To=%3C200707022009.l62K9Rsf008457%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r3574 - rl/trunk/engine/ui/src">tanis at mail.berlios.de
       </A><BR>
    <I>Mon Jul  2 22:09:27 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000644.html">[Dsa-hl-svn] r3573 - rl/trunk/engine/ui/src
</A></li>
        <LI>Next message: <A HREF="000646.html">[Dsa-hl-svn] r3575 - rl/trunk/engine/ui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#645">[ date ]</a>
              <a href="thread.html#645">[ thread ]</a>
              <a href="subject.html#645">[ subject ]</a>
              <a href="author.html#645">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tanis
Date: 2007-07-02 22:09:19 +0200 (Mon, 02 Jul 2007)
New Revision: 3574

Added:
   rl/trunk/engine/ui/src/MovementControlState.cpp
Removed:
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
Renamed remotely

Deleted: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-07-02 20:08:00 UTC (rev 3573)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-07-02 20:09:19 UTC (rev 3574)
@@ -1,1255 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Perl Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Perl Artistic License for more details.
-*
-*  You should have received a copy of the Perl Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
-*/
-
-#include &quot;MovementControlState.h&quot;
-
-#include &lt;OgreSceneManager.h&gt;
-#include &lt;OgreAxisAlignedBox.h&gt;
-#include &lt;OgreStringConverter.h&gt;
-#include &lt;OgreMath.h&gt;
-#include &lt;OgreEntity.h&gt;
-#include &lt;OgreCamera.h&gt;
-#include &lt;OgreSceneNode.h&gt;
-#include &lt;OgreSceneQuery.h&gt;
-#include &lt;utility&gt;
-
-#include &quot;Actor.h&quot;
-#include &quot;ActorManager.h&quot;
-#include &quot;CameraObject.h&quot;
-#include &quot;CommandMapper.h&quot;
-#include &quot;ConfigurationManager.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;DebugWindow.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;InputManager.h&quot;
-#include &quot;Logger.h&quot;
-#include &quot;MeshObject.h&quot;
-#include &quot;MeshAnimation.h&quot;
-#include &quot;MovementControlState.h&quot;
-#include &quot;Person.h&quot;
-#include &quot;PhysicsManager.h&quot;
-#include &quot;PhysicsMaterialRaycast.h&quot;
-#include &quot;PhysicalThing.h&quot;
-#include &quot;World.h&quot;
-#include &quot;LineSetPrimitive.h&quot;
-#include &quot;WindowFactory.h&quot;
-#include &quot;AnimationManager.h&quot;
-#include &quot;UiSubsystem.h&quot;
-
-#include &lt;numeric&gt;
-
-using namespace Ogre;
-
-namespace rl {
-
-    String MovementControlState::msDebugWindowPageName = &quot;MovementControlState&quot;;
-
-    MovementControlState::CharacterState::CharacterState()
-        :
-        mCurrentMovementState(MOVE_NONE),
-        mLastMovementState(MOVE_NONE)
-    {
-    }
-
-    MovementControlState::MovementControlState(CommandMapper* cmdMapper,
-        Actor* camera, Person* character)
-        : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
-        mMovingCreature(NULL),
-        mCharacterState(),
-        mDesiredDistance(2.00),
-        mDistanceRange(0.60, 7.00),
-        mCamYaw(0),
-        mCamVirtualYaw(0),
-        mPitch(20),
-        mRoll(0),
-        mPitchRange(Degree(-75), Degree(85)),
-        mLinearSpringK(400.0f),
-        mLinearDampingK(Math::NEG_INFINITY),
-        mCamMoveAwayVelocity(4.0f),
-        mCamMoveAwayStartTime(0.25f),
-        mCamMoveAwayRange(8.0f),
-        mLookAtOffset(),
-        mRotationSpeed(Degree(120.0f)),
-        mMouseSensitivity(4.0f),
-        mViewMode(VM_THIRD_PERSON),
-        mObstractedFrameCount(0),
-        mObstractedTime(0.0f),
-        mCameraJammedFrameCount(0),
-        mCameraJammedTime(0.0f),
-        mRaycast(new PhysicsMaterialRaycast()),
-        mSelector(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager()),
-        mCombatSelector(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager(),
-            QUERYFLAG_CREATURE)
-    {
-        DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
-
-
-        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting(&quot;Input&quot;, &quot;Mouse Sensitivity&quot;);
-        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting(&quot;Input&quot;, &quot;Mouse Invert&quot;);
-
-        // The relationCoefficient determines the relation between spring accel in target direction
-        // and damping in velocity direction. 1.0 means equilibrium is reached in optimal time
-        // smaller 1.0 means spring accel is stronger and thus cam shoots over the target, resulting
-        // in a damped ozillation before reaching equilibrium.
-        // Values greater than 1.0 mean damping is stronger and thus camera takes a detour.
-        Real relationCoefficient = 1.0f;
-        mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
-
-        // Offset for the look at point,
-        // so the cam does look at the characters head instead of the feet.
-        MeshObject* charMesh = dynamic_cast&lt;MeshObject*&gt;(
-            mCharacterActor-&gt;getControlledObject());
-        AxisAlignedBox aabb = charMesh-&gt;getDefaultSize();
-
-        // this will be recalculated in calculateOptimalCameraPosition
-        mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
-
-        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
-        filter-&gt;setAlignmentMask(Creature::ALIGNMENT_ENEMY);
-        mCombatSelector.setFilter(filter);
-
-        mSelector.setFilter(new InSceneSelectionFilter());
-    }
-
-    //------------------------------------------------------------------------
-    MovementControlState::~MovementControlState()
-    {
-        delete mCombatSelector.getFilter();
-        delete mRaycast;
-
-        if (DebugWindow::getSingletonPtr())
-        {
-            DebugWindow::getSingletonPtr()-&gt;unregisterPage(msDebugWindowPageName);
-        }
-
-        // Remove debug scene node from character node, if debugview was used.
-        if (mSceneNode != NULL &amp;&amp; mSceneNode-&gt;getParent() != NULL)
-        {
-            mCharacterActor-&gt;_getSceneNode()-&gt;removeChild(mSceneNode);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::pause()
-    {
-        if( mMovingCreature != NULL )
-        {
-            delete mMovingCreature;
-            mMovingCreature = NULL;
-        }
-
-        // actors aren't controlled anymore
-        //mCharacterActor-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
-        mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
-        // cam&lt;-&gt;Level collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;));
-        // cam&lt;-&gt;Default collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
-
-
-        // Unhighlight selected object, if any.
-        GameObject* go = mSelector.getFirstSelectedObject();
-        if (go != NULL &amp;&amp; go-&gt;isHighlighted())
-        {
-            go-&gt;setHighlighted(false);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::resume()
-    {
-        if( mMovingCreature == NULL )
-            mMovingCreature = new MovingCreature(mCharacter);
-
-        // We want to check for visibility from char's POV.
-        mSelector.setCheckVisibility(true, mCharacter);
-        mSelector.track(mCharacter);
-        mSelector.setRadius(3.0);
-
-        // Same for combat selector
-        mCombatSelector.setCheckVisibility(true, mCharacter);
-        mCombatSelector.track(mCharacter);
-        mCombatSelector.setRadius(10.0);
-
-
-        // control camera
-        mCameraActor-&gt;getPhysicalThing()-&gt;setMaterialID(
-            PhysicsManager::getSingleton().createMaterialID(&quot;camera&quot;));
-        mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(this);
-
-        // We also handle cam&lt;-&gt;level, cam&lt;-&gt;default cam&lt;-&gt;char collision from now on
-        PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;))-&gt;setContactCallback(this);
-        PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;))-&gt;setContactCallback(this);
-        PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;))-&gt;setContactCallback(this);
-
-        setViewMode(VM_THIRD_PERSON);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::run(Real elapsedTime)
-    {
-        if (isCeguiActive()) return;
-
-        InputManager* im = InputManager::getSingletonPtr();
-
-        updateCharacter(elapsedTime);
-        updateCameraLookAt(elapsedTime);
-        updateSelection();
-
-
-
-        // camera pitch
-        if (mInvertedMouse)
-            mPitch -= 0.5 * mMouseSensitivity * Degree(im-&gt;getMouseRelativeY() / 10);
-        else
-            mPitch += 0.5 * mMouseSensitivity * Degree(im-&gt;getMouseRelativeY() / 10);
-        if (mPitch &lt; mPitchRange.first) mPitch = mPitchRange.first;
-        if (mPitch &gt; mPitchRange.second) mPitch = mPitchRange.second;
-
-
-
-
-        // Do we need to reset the Camera?
-        Vector3 charPos = mCharacterActor-&gt;getWorldPosition();
-        Quaternion charOri = mCharacterActor-&gt;getWorldOrientation();
-        //mCharBody-&gt;getPositionOrientation(charPos, charOri);
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody-&gt;getPositionOrientation(camPos, camOri);
-
-        float maxdistance;
-        if (mViewMode == VM_FIRST_PERSON)
-            maxdistance = 0.25;
-        else
-            maxdistance = 1.3f * mDesiredDistance + 1.4f;
-
-        // if we have more than 250ms and at least five frames with camera distance higher
-        // than desired distance, reset camera
-        if ((camPos - (charPos + charOri*mLookAtOffset)).length() &gt; maxdistance)
-        {
-            mCameraJammedTime += elapsedTime;
-            ++mCameraJammedFrameCount;
-        }
-        else
-        {
-            mCameraJammedTime = 0.0f;
-            mCameraJammedFrameCount = 0;
-        }
-
-        if (mCameraJammedTime &gt; 0.250f &amp;&amp; mCameraJammedFrameCount &gt; 5)
-        {
-            mCameraJammedFrameCount = 0;
-            resetCamera();
-        }
-
-        mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
-
-        if (isEnemyNear())
-        {
-            InputManager::getSingleton().pushControlState(CST_COMBAT);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-        if( mMovingCreature != NULL )
-        {
-            int movement = mCharacterState.mCurrentMovementState;
-            Degree rotation(0);
-
-            AbstractMovement *drehen = mMovingCreature-&gt;getMovementFromId(MovingCreature::MT_DREHEN);
-            Real baseVelocity = 0;
-            if( drehen-&gt;calculateBaseVelocity(baseVelocity) )
-            {
-                Degree baseVel(baseVelocity*360);
-                if (movement &amp; TURN_LEFT)
-                    rotation = elapsedTime * baseVel;
-                if (movement &amp; TURN_RIGHT)
-                    rotation = -elapsedTime * baseVel;
-
-                // mouse
-                if( !isCeguiActive() &amp;&amp; mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
-                {
-                    if( !(movement &amp; TURN_LEFT || movement &amp; TURN_RIGHT) )
-                    {
-                        rotation = -mMouseSensitivity/3.0f * Degree(im-&gt;getMouseRelativeX())/200.0 * baseVel;
-                    }
-                }
-
-
-                // virtual yaw
-                Degree newVirtualYaw(0);
-                if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) ||
-                    ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) )
-                {
-                    newVirtualYaw = Degree(45);
-                }
-                if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) ||
-                    ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) )
-                {
-                    newVirtualYaw = Degree(-45);
-                }
-                if( mCamVirtualYaw != newVirtualYaw )
-                {
-                    rotation += mCamVirtualYaw - newVirtualYaw;
-                    mCamVirtualYaw = newVirtualYaw;
-                }
-            }
-
-
-
-            if( movement &amp; MOVE_SNEAK )
-            {
-                Vector3 direction(Vector3::ZERO);
-                if (movement &amp; MOVE_FORWARD)
-                    direction.z = -1;
-                else if( movement &amp; MOVE_BACKWARD)
-                    direction.z = 1;
-                mMovingCreature-&gt;setMovement(
-                    MovingCreature::MT_SCHLEICHEN,
-                    direction,
-                    Vector3(0, rotation.valueRadians(), 0) );
-            }
-            else if( movement &amp; MOVE_JUMP &amp;&amp; 
-                mMovingCreature-&gt;getMovementFromId(MovingCreature::MT_HOCHSPRUNG)-&gt;isPossible() )
-            {
-                MovingCreature::MovementType type = MovingCreature::MT_HOCHSPRUNG;
-                Vector3 direction = Vector3::UNIT_Y;
-                if( movement &amp; MOVE_FORWARD )
-                {
-                    type = MovingCreature::MT_WEITSPRUNG;
-                    direction += Vector3::NEGATIVE_UNIT_Z;
-                }
-                mMovingCreature-&gt;setMovement(
-                    type,
-                    direction,
-                    Vector3(0, rotation.valueRadians(), 0) );
-            }
-            else if( movement &amp; MOVE_FORWARD )
-            {
-                MovingCreature::MovementType type = MovingCreature::MT_GEHEN;
-                if( movement &amp; MOVE_RUN_LOCK )
-                {
-                    if( movement &amp; MOVE_RUN )
-                        type = MovingCreature::MT_RENNEN;
-                    else
-                        type = MovingCreature::MT_LAUFEN;
-                }
-                else
-                {
-                    if( movement &amp; MOVE_RUN )
-                        type = MovingCreature::MT_GEHEN;
-                    else
-                        type = MovingCreature::MT_JOGGEN;
-                }
-                mMovingCreature-&gt;setMovement(
-                    type,
-                    Vector3(0,0,-1), 
-                    Vector3(0, rotation.valueRadians(), 0) );
-            }
-            else if (movement &amp; MOVE_BACKWARD )
-            {
-                MovingCreature::MovementType type = MovingCreature::MT_RUECKWAERTS_GEHEN;
-                if( !(movement &amp; MOVE_RUN) )
-                    type = MovingCreature::MT_RUECKWAERTS_JOGGEN;
-                mMovingCreature-&gt;setMovement(
-                    type,
-                    Vector3(0,0,1), 
-                    Vector3(0, rotation.valueRadians(), 0) );
-            }
-            else if (movement &amp; MOVE_LEFT || movement &amp; MOVE_RIGHT)
-            {
-                Vector3 direction = Vector3::UNIT_X;
-                if( movement &amp; MOVE_LEFT )
-                    direction = Vector3::NEGATIVE_UNIT_X;
-                mMovingCreature-&gt;setMovement(
-                    MovingCreature::MT_SEITWAERTS_GEHEN,
-                    direction, 
-                    Vector3(0, rotation.valueRadians(), 0) );
-            }
-            else
-            {
-                mMovingCreature-&gt;setMovement(
-                    MovingCreature::MT_STEHEN, 
-                    Vector3(0,0,0),
-                    Vector3(0, rotation.valueRadians(), 0) );
-            }
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    void MovementControlState::updateCameraLookAt(Ogre::Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        // camera position (distance)
-        mDesiredDistance -= im-&gt;getMouseRelativeZ() * 0.002;
-        if (mDesiredDistance &lt; mDistanceRange.first)
-        {
-            mDesiredDistance = mDistanceRange.first;
-        }
-        if (mDesiredDistance &gt; mDistanceRange.second)
-        {
-            mDesiredDistance = mDistanceRange.second;
-        }
-
-        if( !isCeguiActive() &amp;&amp; mViewMode == VM_FREE_CAMERA )
-        {
-            mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im-&gt;getMouseRelativeX() / 15);
-
-            while (mCamYaw.valueDegrees() &gt; 360.0f) mCamYaw -= Degree(360.0f);
-            while (mCamYaw.valueDegrees() &lt; -360.0f) mCamYaw += Degree(360.0f);
-        }
-
-        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
-
-        Vector3 charPos;
-        charPos = mCharacter-&gt;getActor()-&gt;getWorldPosition();
-        Quaternion charOri = mCharacter-&gt;getActor()-&gt;getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-        if( mViewMode == VM_FIRST_PERSON)
-        {
-            Quaternion camOri;
-            camOri.FromAngleAxis(mPitch, Vector3::NEGATIVE_UNIT_X);
-            cameraNode-&gt;lookAt(
-                charPos
-                + charOri * virtualCamOri * mLookAtOffset
-                + charOri * camOri * virtualCamOri * (-Vector3::UNIT_Z),
-                Node::TS_WORLD);
-        }
-        else if( mViewMode == VM_THIRD_PERSON )
-        {
-            // Kamera-Gr&#65533;e beziehen
-            CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
-                mCameraActor-&gt;getControlledObject());
-            AxisAlignedBox aabb = ogreCam-&gt;getDefaultSize();
-            // Radius berechnen
-            Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
-
-            cameraNode-&gt;lookAt(
-                charPos
-                + charOri * virtualCamOri *  mLookAtOffset
-                + charOri * virtualCamOri * (-Vector3::UNIT_Z*radius),
-                Node::TS_WORLD);
-
-        }
-        else if( mViewMode == VM_FREE_CAMERA )
-        {
-            cameraNode-&gt;lookAt(
-                charPos + charOri * virtualCamOri * mLookAtOffset,
-                Node::TS_WORLD);
-        }
-
-
-        // Character ausblenden, wenn Kamera zu nah.
-        if( mViewMode != VM_FIRST_PERSON )
-        {
-            // here the real charOri of the object is needed
-            Vector3 charPos;
-            Quaternion charOri;
-            mCharBody-&gt;getPositionOrientation(charPos, charOri);
-            Vector3 camPos;
-            Quaternion camOri;
-            mCamBody-&gt;getPositionOrientation(camPos, camOri);
-            Vector3 camPoint, charPoint, normal;
-            int collisionPoints =
-                OgreNewt::CollisionTools::CollisionClosestPoint(
-                    PhysicsManager::getSingleton()._getNewtonWorld(),
-                    mCamBody-&gt;getCollision(), camOri, camPos,
-                    mCharBody-&gt;getCollision(), charOri, charPos,
-                    camPoint, charPoint, normal
-                    );
-            if( collisionPoints == 0 )
-                mCharacterActor-&gt;setVisible(false);
-            else
-            {
-                // eigentlich muss hier transparent gemacht werden!
-                mCharacterActor-&gt;setVisible(true);
-            }
-        }
-    }
-
-    // -------------------------------------------------------------
-    // character collision moved to MovingCreature(Manager)
-    int MovementControlState::userProcess()
-    {
-        // only camera collision
-        return 0;
-    
-        if( mViewMode == VM_FIRST_PERSON )
-            return 0;
-
-        setContactSoftness(1.0f);
-        setContactElasticity(0.0f);
-
-        return 1;
-    }
-
-    //------------------------------------------------------------------------
-    // character callback moved to MovingCreature
-    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing)
-    {
-        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
-        Real timestep = world-&gt;getTimeStep();
-
-        calculateCamera(timestep);
-
-
-
-
-        ///@todo move to MovingCreature?
-        SceneNode* node = mCharacterActor-&gt;_getSceneNode();
-        std::ostringstream ss;
-        Vector3 bodpos, playpos = node-&gt;getPosition();
-        Quaternion egal;
-        mCamBody-&gt;getPositionOrientation(bodpos,egal);
-        static Real maxHeight(0);
-        if( playpos.y &gt; maxHeight )
-            maxHeight = playpos.y;
-        ss
-            &lt;&lt; &quot;scene node : &quot; &lt;&lt; playpos &lt;&lt; std::endl
-            &lt;&lt; &quot;player max Height : &quot; &lt;&lt; maxHeight &lt;&lt; std::endl
-            &lt;&lt; &quot;camera posder : &quot; &lt;&lt; static_cast&lt;Camera*&gt;(
-                mCameraActor-&gt;_getMovableObject())-&gt;getDerivedPosition() &lt;&lt; std::endl
-                &lt;&lt; &quot;camera pos : &quot; &lt;&lt; static_cast&lt;Camera*&gt;(
-                    mCameraActor-&gt;_getMovableObject())-&gt;getPosition() &lt;&lt; std::endl
-            &lt;&lt; &quot;camera actor orientation : &quot; &lt;&lt; mCameraActor-&gt;getWorldOrientation() &lt;&lt; std::endl
-            &lt;&lt; &quot;camera actor : &quot; &lt;&lt; mCameraActor-&gt;getWorldPosition() &lt;&lt; std::endl
-            &lt;&lt; &quot;camera body pos : &quot; &lt;&lt; bodpos &lt;&lt; std::endl
-            &lt;&lt; &quot;camera distance : &quot; &lt;&lt; mDesiredDistance &lt;&lt; std::endl
-            &lt;&lt; &quot;is airborne: &quot; &lt;&lt; (mMovingCreature-&gt;getAbstractLocation() == MovingCreature::AL_AIRBORNE ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
-
-        LOG_DEBUG(Logger::UI, ss.str());
-        DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::calculateCamera(const Ogre::Real&amp; timestep)
-    {
-        Vector3 charPos = mCharacter-&gt;getActor()-&gt;getWorldPosition();
-        Quaternion charOri = mCharacter-&gt;getActor()-&gt;getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody-&gt;getPositionOrientation(camPos, camOri);
-        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
-
-/*
-        // Ringbuffer mit Positionen der Kamera
-        static std::vector&lt;Ogre::Vector3&gt; camPositionsBuffer(20);
-        static size_t camPositionsBufferIdx = -1;
-        camPositionsBufferIdx = (camPositionsBufferIdx + 1) % camPositionsBuffer.size();
-        camPositionsBuffer[camPositionsBufferIdx] = camPos;
-
-        // Ringbuffer mit optimalen Positionen der Kamera
-        static std::vector&lt;Ogre::Vector3&gt; camOptPositionsBuffer(20);
-        static size_t camOptPositionsBufferIdx = -1;
-        camOptPositionsBufferIdx = (camOptPositionsBufferIdx + 1) % camOptPositionsBuffer.size();
-*/
-        Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
-        charPos = charPos + charOri * virtualCamOri * mLookAtOffset;
-//        camOptPositionsBuffer[camOptPositionsBufferIdx] = optimalCamPos;
-
-
-        // Ringbuffer mit Positionen des Characters
-        static std::vector&lt;Ogre::Vector3&gt; charPositionsBuffer(20);
-        static size_t charPositionsBufferIdx = -1;
-        charPositionsBufferIdx = (charPositionsBufferIdx + 1) % charPositionsBuffer.size();
-        charPositionsBuffer[charPositionsBufferIdx] = charPos;
-
-
-        static Real characterOccludedTime = 0;
-        static unsigned int characterOccludedFrameCount = 0;
-
-
-
-        // Kamera-Gr&#65533;e beziehen
-        CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
-            mCameraActor-&gt;getControlledObject());
-        AxisAlignedBox camAabb = ogreCam-&gt;getDefaultSize();
-        // Radius berechnen
-        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
-
-
-
-
-
-        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA )
-        {
-
-            // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
-            // so zur optimalen kommen
-            const OgreNewt::MaterialID *charMaterialId = mCharBody-&gt;getMaterialGroupID();
-            const OgreNewt::MaterialID *camMaterialId = mCamBody-&gt;getMaterialGroupID();
-            PhysicsMaterialRaycast::MaterialVector materialVector;
-            materialVector.push_back(charMaterialId);
-            materialVector.push_back(camMaterialId);
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
-            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-
-            Vector3 normToOptCamPos = (optimalCamPos - charPos);
-            normToOptCamPos.normalise();
-
-
-
-            RaycastInfo infoCastOptPos = mRaycast-&gt;execute(
-                world,
-                &amp;materialVector,
-                camPos + camRadius * normToOptCamPos, // Gr&#65533;e der Kamera einbeziehen
-                optimalCamPos + camRadius * normToOptCamPos,
-                true); // Gr&#65533;e der Kamera einbeziehen
-
-            RaycastInfo infoCastChar = mRaycast-&gt;execute(
-                world,
-                &amp;materialVector,
-                camPos,
-                charPos,
-                true);
-
-            Real maxdistance = Math::Pow(1.5f * mDesiredDistance + 1.4f, 2);
-            if( infoCastChar.mBody || (camPos - charPos).squaredLength() &gt; maxdistance)
-            {
-                characterOccludedTime += timestep;
-                characterOccludedFrameCount++;
-
-                // falls zu lange, Kamera resetten:
-                if( characterOccludedTime &gt; 0.500f &amp;&amp; characterOccludedFrameCount &gt; 10 )
-                {
-                    resetCamera();
-                    return;
-                }
-
-            }
-            else
-                characterOccludedTime = 0;
-
-            if( infoCastOptPos.mBody )
-            {
-                if( !infoCastChar.mBody ) // Character noch im Blickfeld
-                {
-                    // andere Position ermitteln, die ziwschen optimaler und Character liegt
-                    // und erreichbar ist
-                    Real lenToOptCamPos = (optimalCamPos - charPos).length();
-
-                    RaycastInfo infoCastNewPos;
-                    Real delta = lenToOptCamPos/2.0f;
-                    Vector3 temp = charPos + delta * normToOptCamPos;
-                    // Ann&#65533;erung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
-                    while( delta &gt; 0.05 ) // genauigkeit des gefundenen Punktes
-                    {
-                        infoCastNewPos = mRaycast-&gt;execute(
-                            world,
-                            &amp;materialVector,
-                            camPos + camRadius * normToOptCamPos, // Gr&#65533;e der Kamera!
-                            temp,
-                            true);
-                        delta = delta/2.0f;
-                        if( infoCastNewPos.mBody ) // Hindernis gefunden, n&#65533;er an Char ran
-                        {
-                            temp = temp - delta * normToOptCamPos;
-                        }
-                        else // kein Hindernis gefunden, weiter von Char weg
-                        {
-                            temp = temp + delta * normToOptCamPos;
-                        }
-                    }
-
-                    // Jetzt k&#65533;nen wir sicher sein, dass diese Stelle erreichbar ist:
-                    temp = temp - 0.05 * normToOptCamPos;
-                    // Gr&#65533;e der Kamera einbeziehen
-                    optimalCamPos = temp - camRadius * normToOptCamPos;
-                    // so ab hier kann ganz normal weiter gerechnet werden!
-                }
-            }
-
-
-            static bool isPathfinding (false);
-            static unsigned int lastReachableBufPos;
-            // gibt an, ob schon gebufferte Daten fr den
-            // neuen Weg existieren und dort weitergemacht werden kann,
-            // oder ob neu nach einem Weg gesucht werden muss!
-            if( infoCastChar.mBody &amp;&amp; infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
-            {
-                // anderen Weg finden
-                // hier werden erstmal nur alte Player-Positionen betrachtet
-                // es wird davon ausgegangen, dass diese &quot;nah&quot; genug aneinanderliegen
-                // und durch &quot;Geraden&quot; miteinander verbunden werden k&#65533;nen
-                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
-                // und weich (keine scharfen Kurven) erscheinen
-
-                size_t buffSize = charPositionsBuffer.size();
-
-                if( !isPathfinding )
-                {
-                    LOG_DEBUG(Logger::UI, &quot; Pathfinding der Kamera sollte jetzt anfangen!&quot;);
-
-
-                    // letzte Character - Position suchen, die erreichbar ist...
-                    // Ist vermutlicherweise ja die letzte, davor war ja noch alles ok!
-                    unsigned int delta = 1;
-                    while ( delta &lt; buffSize )
-                    {
-                        RaycastInfo info = mRaycast-&gt;execute(
-                            world,
-                            &amp;materialVector,
-                            camPos,
-                            charPositionsBuffer[ (charPositionsBufferIdx - delta) % buffSize ],
-                            true);
-
-                        if( !info.mBody )
-                            break;
-                        delta++;
-                    }
-                    if( delta &gt;= buffSize )
-                    {
-                        // is wohl irgendwas schiefgegangen!
-                        LOG_MESSAGE(Logger::UI, &quot; Der Ringbuffer mit den Player-Positionen scheint zu klein zu sein; Pathfinding der Kamera fehlgeschlagen! &quot;);
-                        isPathfinding = false;
-                        resetCamera();
-                        return;
-                    }
-                    lastReachableBufPos = delta;
-
-                    // auf zu der ermittelten Position!
-                    optimalCamPos = charPositionsBuffer[ (charPositionsBufferIdx - lastReachableBufPos) % buffSize ];
-                }
-                else
-                {
-                    LOG_DEBUG(Logger::UI, &quot; Pathfinding der Kamera sollte weitergefhrt werden!&quot;);
-
-
-                    // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
-                    unsigned int delta = lastReachableBufPos; // das ist die von der letzten Frame!
-                    while ( delta &gt; 0 ) // delta = 0 braucht nicht berprft zu werden, wurde oben schon ausgeschlossen!
-                    {
-                        RaycastInfo info = mRaycast-&gt;execute(
-                            world,
-                            &amp;materialVector,
-                            camPos,
-                            charPositionsBuffer[ (charPositionsBufferIdx - delta) % buffSize ],
-                            true);
-
-                        if( info.mBody )
-                            break;
-                        delta--;
-                    }
-                    lastReachableBufPos = delta + 1;
-
-                    // auf zu der ermittelten Position!
-                    optimalCamPos = charPositionsBuffer[ (charPositionsBufferIdx - lastReachableBufPos) % buffSize ];
-                }
-                isPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
-            }
-            else
-            {
-                isPathfinding = false;
-            }
-
-            Vector3 diff = camPos - optimalCamPos;
-
-            Vector3 cameraVelocity;
-            cameraVelocity = mCamBody-&gt;getVelocity();
-            // spring velocity
-            Vector3 springAcc = -mLinearSpringK*diff - mLinearDampingK * cameraVelocity;
-
-            // get the camera mass
-            Real mass;
-            Vector3 inertia;
-            mCamBody-&gt;getMassMatrix(mass, inertia);
-
-            //mCamBody-&gt;setPositionOrientation(newCamPos, camOri);
-            mCamBody-&gt;setForce(springAcc * mass);
-        }
-        else if( mViewMode == VM_FIRST_PERSON )
-        {
-            mCamBody-&gt;setPositionOrientation(optimalCamPos, camOri);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    Ogre::Vector3 MovementControlState::calculateOptimalCameraPosition(bool SlowlyMoveBackward, const Real &amp;timestep)
-    {
-        Vector3 targetCamPos;
-
-        Vector3 charPos = mCharacter-&gt;getActor()-&gt;getWorldPosition();
-        Quaternion charOri = mCharacter-&gt;getActor()-&gt;getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-
-        if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA )
-        {
-            charPos = charPos + charOri * mLookAtOffset;
-            if(mViewMode == VM_THIRD_PERSON)
-            {
-                targetCamPos =
-                    charPos
-                    + charOri * virtualCamOri * Vector3(
-                                    0,
-                                    Math::Sin(mPitch) * mDesiredDistance,
-                                    Math::Cos(mPitch) * mDesiredDistance);
-            }
-            else
-            {
-                Quaternion camOri;
-                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-                targetCamPos =
-                    charPos
-                    + charOri * camOri * virtualCamOri * Vector3(
-                                                0,
-                                                Math::Sin(mPitch) * mDesiredDistance,
-                                                Math::Cos(mPitch) * mDesiredDistance);
-            }
-
-
-            // Kamera-Gr&#65533;e beziehen
-            CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
-                mCameraActor-&gt;getControlledObject());
-            AxisAlignedBox aabb = ogreCam-&gt;getDefaultSize();
-            // Radius berechnen
-            Real radius = (aabb.getMaximum().z - aabb.getMinimum().z) / 2.0f;
-            radius *= 1.1f; // bissle was dazu tun schadet nich, da ja nur wenige raycasts gemacht werden
-            // unds eigentlich ne kugel ist!
-
-
-
-            Vector3 startRay[6], endRay[6];
-
-            Real sinPitchRad = Math::Sin(mPitch) * radius;
-            Real cosPitchRad = Math::Cos(mPitch) * radius;
-            Vector3 radiusOffset = charOri * Vector3(0, sinPitchRad, cosPitchRad);
-
-            startRay[0] = charPos;
-            endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
-                                      // dadurch kann aber sichergestellt
-                                      // werden, dass kein Objekt direkt
-                                      // hinter dem Helden bersehen wird
-            startRay[1] = charPos + radiusOffset;
-            endRay[1] = targetCamPos + radiusOffset;
-            radiusOffset = charOri * Vector3(radius, sinPitchRad, cosPitchRad);
-            startRay[2] = charPos + radiusOffset;
-            endRay[2] = targetCamPos + radiusOffset;
-            startRay[3] = charPos - radiusOffset;
-            endRay[3] = targetCamPos - radiusOffset;
-            radiusOffset = charOri * Vector3(0, radius-cosPitchRad, -sinPitchRad);
-            startRay[4] = charPos + radiusOffset;
-            endRay[4] = targetCamPos + radiusOffset;
-            startRay[5] = charPos - radiusOffset;
-            endRay[5] = targetCamPos - radiusOffset;
-
-            const OgreNewt::MaterialID* materialId =
-                mCharBody-&gt;getMaterialGroupID();
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
-            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-
-            Vector3 diff = targetCamPos - charPos;
-            bool CollisionFound = false;
-            for( int i = 0; i &lt; 6; i++ )
-            {
-                RaycastInfo info = mRaycast-&gt;execute(
-                    world,
-                    materialId,
-                    startRay[i],
-                    endRay[i],
-                    true);
-
-                if( info.mBody &amp;&amp; info.mBody != mCamBody )
-                {
-                    CollisionFound = true;
-                    Vector3 newdiff = (info.mDistance) * (endRay[i] - startRay[i]);
-                    if( newdiff.squaredLength() &lt; diff.squaredLength() )
-                        diff = newdiff;
-                    if( i == 0 ) // beim ersten schon nahes hindernis gefunden?
-                    {
-                        if( diff.squaredLength() &lt; radius*radius )
-                        {
-                            diff -= charOri * Vector3(0, sinPitchRad, cosPitchRad);
-                            break;
-                        }
-                    }
-                }
-            }
-
-            // Langsames Entfernen vom Char:
-            static Real lastDistance(0.0f);
-            static Real TimeOfLastCollision(0.0f);
-            if( CollisionFound )
-                TimeOfLastCollision = 0.0f;
-            else
-                TimeOfLastCollision += timestep;
-
-
-            Real desiredDistance = diff.length();
-            Vector3 camPos;
-            Quaternion camOri;
-            mCamBody-&gt;getPositionOrientation(camPos, camOri);
-
-            if( SlowlyMoveBackward &amp;&amp;
-                desiredDistance &gt; lastDistance )
-            {
-
-                diff.normalise();
-                Real newDistance;
-                Vector3 actDiff = camPos - charPos;
-                actDiff.normalise();
-
-                if( TimeOfLastCollision &gt; mCamMoveAwayStartTime ||
-                    diff.directionEquals(actDiff, mCamMoveAwayRange*timestep) )
-                    newDistance = lastDistance + mCamMoveAwayVelocity*timestep;
-                else
-                    newDistance = lastDistance;
-
-                if( newDistance &gt; desiredDistance )
-                    newDistance = desiredDistance;
-
-                diff = diff*newDistance;
-
-                lastDistance = newDistance;
-            }
-            else
-                lastDistance = desiredDistance;
-
-
-            targetCamPos = charPos + diff;
-        }
-        else  // FIRST_PERSON
-        {
-            // determine the optimal target position of the camera
-            targetCamPos =
-                charPos
-                + charOri * virtualCamOri * mLookAtOffset
-                + charOri * virtualCamOri * Vector3(
-                                0,
-                                Math::Sin(mPitch) * mDesiredDistance,
-                                Math::Cos(mPitch) * mDesiredDistance);
-        }
-
-
-        return targetCamPos;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::isEnemyNear()
-    {
-        mCombatSelector.updateSelection();
-
-        const Selector::GameObjectVector&amp; gov = mCombatSelector.getAllSelectedObjects();
-        for (size_t i = 0, end = gov.size(); i &lt; end; ++i)
-        {
-            Creature* creature = dynamic_cast&lt;Creature*&gt;(gov.at(i));
-            if (creature &amp;&amp; creature-&gt;getAlignment() == Creature::ALIGNMENT_ENEMY)
-            {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updateSelection()
-    {
-        if (isCeguiActive()) return;
-
-        InputManager* im = InputManager::getSingletonPtr();
-
-        GameObject* oldGo = mSelector.getFirstSelectedObject();
-
-        mSelector.updateSelection();
-
-        GameObject* newGo = mSelector.getFirstSelectedObject();
-
-        if (oldGo != NULL &amp;&amp; oldGo != newGo)
-        {
-            oldGo-&gt;setHighlighted(false);
-        }
-
-        if (newGo != NULL &amp;&amp; newGo != oldGo)
-        {
-            newGo-&gt;setHighlighted(true);
-        }
-
-        // Optionen anzeigen
-        if (im-&gt;isMouseButtonDown(OIS::MB_Right) &amp;&amp; newGo != NULL)
-        {
-            WindowFactory::getSingleton().showActionChoice(newGo);
-        }
-        else if (im-&gt;isMouseButtonDown(OIS::MB_Left) &amp;&amp; newGo != NULL)
-        {
-            newGo-&gt;doDefaultAction(mCharacter, NULL);
-        }
-    }
-
-
-    void MovementControlState::setViewMode(ViewMode mode)
-    {
-        mViewMode = mode;
-
-        MeshObject* charMesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
-        AxisAlignedBox aabb;
-        try
-        {
-            aabb = charMesh-&gt;getPoseSize(&quot;Idle&quot;);
-        }
-        catch(...)
-        {
-            aabb = charMesh-&gt;getDefaultSize();
-        }
-        if (mode == VM_FIRST_PERSON)
-        {
-            mLookAtOffset = Vector3(
-                    0,
-                    (aabb.getMaximum().y - aabb.getMinimum().y) * 0.90f,
-                    (aabb.getMaximum().z - aabb.getMinimum().z) * (-0.3f) );
-            mDistanceRange.first = 0.0;
-            mDistanceRange.second = 0.0;
-            mDesiredDistance = 0.0;
-            mPitchRange.first = Degree(-85);
-            mPitchRange.second = Degree(85);
-            mPitch = 0;
-            LOG_MESSAGE(Logger::UI, &quot;Switch to 1st person view&quot;);
-            resetCamera();
-        }
-        else if(mode == VM_THIRD_PERSON)
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.90f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.0;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            LOG_MESSAGE(Logger::UI, &quot;Switch to 3rd person view&quot;);
-            resetCamera();
-        }
-        else // mode == VM_FREE_CAMERA
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.0;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            mCamYaw = mCharacter-&gt;getActor()-&gt;getWorldOrientation().getYaw();
-            LOG_MESSAGE(Logger::UI, &quot;Switch to free camera view&quot;);
-            resetCamera();
-        }
-    }
-
-    //------------------------------------------------------------------------
-/*
-    // not used at the moment!
-    void MovementControlState::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
-    {
-        AxisAlignedBox aab;
-        Vector3 size[2];
-        Vector3 interpolatedSize;
-
-
-        // Die Gr&#65533;e der beiden Animationen abfragen
-        MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
-        aab = mesh-&gt;getPoseSize(actAnim);
-        size[0] = aab.getMaximum() - aab.getMinimum();
-
-        aab = mesh-&gt;getPoseSize(newAnim);
-        size[1] = aab.getMaximum() - aab.getMinimum();
-
-        // interpolierte Gr&#65533;e (linear) berechnen
-        interpolatedSize = size[0] + factor*(size[1] - size[0]);
-
-        // LookAtOffset berechnen!
-        switch(mViewMode)
-        {
-        case VM_FIRST_PERSON:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, interpolatedSize.z * (-0.3f) );
-            break;
-        case VM_THIRD_PERSON:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, 0);
-            break;
-        case VM_FREE_CAMERA:
-        default:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.80f, 0);
-        }
-    }
-*/
-
-    //------------------------------------------------------------------------
-    MovementControlState::ViewMode MovementControlState::getViewMode()
-    {
-        return mViewMode;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::toggleViewMode()
-    {
-        if (getViewMode() == VM_THIRD_PERSON)
-            setViewMode(VM_FIRST_PERSON);
-        else if(getViewMode() == VM_FIRST_PERSON)
-            setViewMode(VM_FREE_CAMERA);
-        else
-            setViewMode(VM_THIRD_PERSON);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::resetCamera()
-    {
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody-&gt;getPositionOrientation(camPos, camOri);
-        mCamBody-&gt;setPositionOrientation(calculateOptimalCameraPosition(false, 0.0f), camOri);
-        if(mViewMode == VM_FIRST_PERSON)
-            mCharacterActor-&gt;setVisible(false);
-        else
-            mCharacterActor-&gt;setVisible(true);
-        
-        LOG_MESSAGE(Logger::UI, &quot;Camera resetted.&quot;);
-        ///@todo remove this
-        mCharacter-&gt;modifyAu(100);
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::keyPressed(const OIS::KeyEvent&amp; evt)
-    {
-        if (ControlState::keyPressed(evt)) return true;
-
-        int movement = mCommandMapper-&gt;getMovement(evt.key);
-
-        if (movement &amp; MOVE_RUN_LOCK) // dieses einrasten lassen
-        {
-            mCharacterState.mCurrentMovementState ^= MOVE_RUN_LOCK;
-            movement &amp;= ~MOVE_RUN_LOCK;
-        }
-        if (movement != MOVE_NONE)
-        {
-            mCharacterState.mCurrentMovementState |= movement;
-            return true;
-        }
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::keyReleased(const OIS::KeyEvent&amp; evt)
-    {
-        // CEGUI is handled by base class, so hand it down if necessary.
-        if (sendKeyToCeGui(evt))
-        {
-            return ControlState::keyReleased(evt);
-        }
-
-        int movement = mCommandMapper-&gt;getMovement(evt.key);
-
-        if (movement != MOVE_NONE)
-        {
-            mCharacterState.mCurrentMovementState &amp;= (~movement | MOVE_RUN_LOCK);
-            return true;
-        }
-        else
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int keycode = CommandMapper::encodeKey(evt.key, im-&gt;getModifierCode());
-            CeGuiString command = mCommandMapper-&gt;getControlStateAction(keycode, CST_MOVEMENT);
-            if (command == &quot;freeflight_mode&quot;)
-            {
-                InputManager::getSingleton().pushControlState(CST_FREEFLIGHT);
-                return true;
-            }
-            else if (command == &quot;reset_camera&quot;)
-            {
-                resetCamera();
-                return true;
-            }
-            else if (command == &quot;toggle_view_mode&quot;)
-            {
-                toggleViewMode();
-                return true;
-            }
-            else
-            {
-                // Nothing we handle here, see if base class can make something of this input.
-                return ControlState::keyReleased(evt);
-            }
-        }
-
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::mouseReleased(const OIS::MouseEvent&amp; evt,
-        OIS::MouseButtonID id)
-    {
-        if (!isCeguiActive())
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int mouseButtonMask = CommandMapper::encodeKey(id, im-&gt;getModifierCode());
-            return startAction(mCommandMapper-&gt;getControlStateAction(mouseButtonMask,
-                CST_MOVEMENT), mCharacter);
-        }
-        else
-        {
-            return ControlState::mouseReleased(evt, id);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    DebugVisualisableFlag MovementControlState::getFlag() const
-    {
-        return DVF_CONTROL;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updatePrimitive()
-    {
-        if (mSceneNode-&gt;getParent() == NULL)
-        {
-            mCharacterActor-&gt;_getSceneNode()-&gt;addChild(mSceneNode);
-        }
-
-        LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
-        lineSet-&gt;clear();
-        lineSet-&gt;addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::doCreatePrimitive()
-    {
-        mPrimitive = new LineSetPrimitive();
-    }
-}

Copied: rl/trunk/engine/ui/src/MovementControlState.cpp (from rev 3573, rl/trunk/engine/ui/src/MovementCharacterController.cpp)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000644.html">[Dsa-hl-svn] r3573 - rl/trunk/engine/ui/src
</A></li>
	<LI>Next message: <A HREF="000646.html">[Dsa-hl-svn] r3575 - rl/trunk/engine/ui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#645">[ date ]</a>
              <a href="thread.html#645">[ thread ]</a>
              <a href="subject.html#645">[ subject ]</a>
              <a href="author.html#645">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
