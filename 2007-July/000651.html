<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r3580 - in rl/trunk/engine: ai/include ai/src rules	rules/include rules/src script/swig ui/include ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-July/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3580%20-%20in%20rl/trunk/engine%3A%20ai/include%20ai/src%20rules%0A%09rules/include%20rules/src%20script/swig%20ui/include%20ui/src&In-Reply-To=%3C200707022122.l62LMKon013510%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000650.html">
   <LINK REL="Next"  HREF="000652.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r3580 - in rl/trunk/engine: ai/include ai/src rules	rules/include rules/src script/swig ui/include ui/src</H1>
    <B>tanis at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3580%20-%20in%20rl/trunk/engine%3A%20ai/include%20ai/src%20rules%0A%09rules/include%20rules/src%20script/swig%20ui/include%20ui/src&In-Reply-To=%3C200707022122.l62LMKon013510%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r3580 - in rl/trunk/engine: ai/include ai/src rules	rules/include rules/src script/swig ui/include ui/src">tanis at mail.berlios.de
       </A><BR>
    <I>Mon Jul  2 23:22:20 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000650.html">[Dsa-hl-svn] r3579 - rl/trunk/engine/rules/src
</A></li>
        <LI>Next message: <A HREF="000652.html">[Dsa-hl-svn] r3581 - in modules: combattest/scripts/maps	regressiontest/scripts regressiontest/scripts/maps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#651">[ date ]</a>
              <a href="thread.html#651">[ thread ]</a>
              <a href="subject.html#651">[ subject ]</a>
              <a href="author.html#651">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tanis
Date: 2007-07-02 23:21:48 +0200 (Mon, 02 Jul 2007)
New Revision: 3580

Modified:
   rl/trunk/engine/ai/include/CreatureWalkPathJob.h
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/rules/RlRules2005.vcproj
   rl/trunk/engine/rules/include/CreatureController.h
   rl/trunk/engine/rules/include/CreatureControllerManager.h
   rl/trunk/engine/rules/include/RulesSubsystem.h
   rl/trunk/engine/rules/src/CreatureController.cpp
   rl/trunk/engine/rules/src/CreatureControllerManager.cpp
   rl/trunk/engine/rules/src/RulesSubsystem.cpp
   rl/trunk/engine/script/swig/RlAi.swig
   rl/trunk/engine/script/swig/RlRules.head.swig
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/script/swig/RlUi.swig
   rl/trunk/engine/ui/include/MovementControlState.h
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
Finished renaming-aria. SVN Update should be save again.

Modified: rl/trunk/engine/ai/include/CreatureWalkPathJob.h
===================================================================
--- rl/trunk/engine/ai/include/CreatureWalkPathJob.h	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/ai/include/CreatureWalkPathJob.h	2007-07-02 21:21:48 UTC (rev 3580)
@@ -23,7 +23,7 @@
 #include &quot;LandmarkPath.h&quot;
 
 #include &quot;Job.h&quot;
-#include &quot;MovingCreature.h&quot;
+#include &quot;CreatureController.h&quot;
 
 namespace rl
 {
@@ -35,7 +35,7 @@
         * @param movingCreature the job has to know a moving creature
         * @param startLandmark first landmark, the moving creature has to go to
         */
-        CreatureWalkPathJob(const Ogre::String&amp; name, MovingCreature* movingCreature, Landmark* startLandmark);
+        CreatureWalkPathJob(const Ogre::String&amp; name, CreatureController* movingCreature, Landmark* startLandmark);
         //destructor
         virtual ~CreatureWalkPathJob();
 
@@ -50,13 +50,13 @@
         virtual bool execute(Ogre::Real time);
 
         // @retval the moving creature controlled by this object
-        MovingCreature* getMovingCreature();
+        CreatureController* getMovingCreature();
     private:
         void updateCreature(Ogre::Real time);
 
         LandmarkPath mLandmarkPath;
         Ogre::String mName;
-        MovingCreature* mMovingCreature;
+        CreatureController* mMovingCreature;
 
         Landmark* mCurrentLandmark;
         Landmark* mNextLandmark;

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-07-02 21:21:48 UTC (rev 3580)
@@ -43,7 +43,7 @@
 	class Actor;
 	class Agent;
 	class PhysicalThing;
-    class MovingCreature;
+    class CreatureController;
 
 	/**
 	 * Realises steering for NPCs
@@ -299,7 +299,7 @@
         //! Creature object steered by this vehicle (and controlled by Agent).
         Creature* mCreature;
 
-        MovingCreature* mMovingCreature;
+        CreatureController* mMovingCreature;
 
         // derived from debugvisualisable
         virtual void doCreatePrimitive();

Modified: rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp
===================================================================
--- rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/ai/src/CreatureWalkPathJob.cpp	2007-07-02 21:21:48 UTC (rev 3580)
@@ -18,7 +18,7 @@
 
 namespace rl
 {
-    CreatureWalkPathJob::CreatureWalkPathJob(const Ogre::String&amp; name, MovingCreature* movingCreature, Landmark* startLandmark) 
+    CreatureWalkPathJob::CreatureWalkPathJob(const Ogre::String&amp; name, CreatureController* movingCreature, Landmark* startLandmark) 
         : Job(true, true), mLandmarkPath(&quot;LandmarkPath&quot; + name), mNextLandmarkRequested(false)
     {
         //the moving creature moves from the current position to the landmark
@@ -64,7 +64,7 @@
         mLandmarkPath.addPoint(lm);
     }
 
-    MovingCreature* CreatureWalkPathJob::getMovingCreature()
+    CreatureController* CreatureWalkPathJob::getMovingCreature()
     {
         return mMovingCreature;
     }
@@ -80,7 +80,7 @@
         direction.y = 0;
         if( direction.squaredLength() &lt; 0.04 )
         {
-            mMovingCreature-&gt;setMovement(MovingCreature::MT_STEHEN, Ogre::Vector3::ZERO, Ogre::Vector3::ZERO);
+            mMovingCreature-&gt;setMovement(CreatureController::MT_STEHEN, Ogre::Vector3::ZERO, Ogre::Vector3::ZERO);
             mNextLandmarkRequested = true;
             updatedDirection = false;
             return;
@@ -100,6 +100,6 @@
             timeSinceLastRotation = 0;
         }
 
-        mMovingCreature-&gt;setMovement(MovingCreature::MT_GEHEN, Ogre::Vector3::NEGATIVE_UNIT_Z, usedRotation);
+        mMovingCreature-&gt;setMovement(CreatureController::MT_GEHEN, Ogre::Vector3::NEGATIVE_UNIT_Z, usedRotation);
     }
 }

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-07-02 21:21:48 UTC (rev 3580)
@@ -20,7 +20,7 @@
 #include &quot;Actor.h&quot;
 #include &quot;Creature.h&quot;
 #include &quot;MeshObject.h&quot;
-#include &quot;MovingCreature.h&quot;
+#include &quot;CreatureController.h&quot;
 #include &quot;PhysicalThing.h&quot;
 
 using namespace Ogre;
@@ -56,7 +56,7 @@
 {
     if( mMovingCreature == NULL )
     {
-        mMovingCreature = new MovingCreature(mCreature);
+        mMovingCreature = new CreatureController(mCreature);
     }
 }
 
@@ -145,7 +145,7 @@
         mCreature-&gt;modifyAu(20,true);
 
 
-    AbstractMovement *mov_drehen = mMovingCreature-&gt;getMovementFromId(MovingCreature::MT_DREHEN);
+    AbstractMovement *mov_drehen = mMovingCreature-&gt;getMovementFromId(CreatureController::MT_DREHEN);
     Real vel_drehen(0);
     Radian max_drehen = Degree(0);
     if( mov_drehen-&gt;calculateBaseVelocity(vel_drehen) )
@@ -165,11 +165,11 @@
 
     Ogre::Vector3 direction(Ogre::Vector3::ZERO);
     Ogre::Vector3 rotation(0,yaw.valueRadians(),0);
-    MovingCreature::MovementType movement = MovingCreature::MT_STEHEN;
+    CreatureController::MovementType movement = CreatureController::MT_STEHEN;
     if( result != Ogre::Vector3::ZERO )
     {
         direction.z = -1;
-        movement = MovingCreature::MT_GEHEN;
+        movement = CreatureController::MT_GEHEN;
     }
 
 

Modified: rl/trunk/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/trunk/engine/rules/RlRules2005.vcproj	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/rules/RlRules2005.vcproj	2007-07-02 21:21:48 UTC (rev 3580)
@@ -301,6 +301,14 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\src\CreatureController.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\src\CreatureControllerManager.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\src\Date.cpp&quot;
 				&gt;
 			&lt;/File&gt;
@@ -349,14 +357,6 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\src\MovingCreature.cpp&quot;
-				&gt;
-			&lt;/File&gt;
-			&lt;File
-				RelativePath=&quot;.\src\MovingCreatureManager.cpp&quot;
-				&gt;
-			&lt;/File&gt;
-			&lt;File
 				RelativePath=&quot;.\src\ObjectStateChangeEvent.cpp&quot;
 				&gt;
 			&lt;/File&gt;
@@ -495,6 +495,14 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\include\CreatureController.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\include\CreatureControllerManager.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\include\Date.h&quot;
 				&gt;
 			&lt;/File&gt;
@@ -551,14 +559,6 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
-				RelativePath=&quot;.\include\MovingCreature.h&quot;
-				&gt;
-			&lt;/File&gt;
-			&lt;File
-				RelativePath=&quot;.\include\MovingCreatureManager.h&quot;
-				&gt;
-			&lt;/File&gt;
-			&lt;File
 				RelativePath=&quot;.\include\ObjectStateChangeEvent.h&quot;
 				&gt;
 			&lt;/File&gt;

Modified: rl/trunk/engine/rules/include/CreatureController.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureController.h	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/rules/include/CreatureController.h	2007-07-02 21:21:48 UTC (rev 3580)
@@ -30,14 +30,14 @@
 namespace rl
 {
     class AbstractMovement;
-    class MovingCreatureManager;
+    class CreatureControllerManager;
     class MeshAnimation;
 
     /** 
      * This class provides an interface to control the movement of a creature.
      * It handles all nessessary things like animations and calculates the movement speed.
      */
-    class _RlRulesExport MovingCreature :
+    class _RlRulesExport CreatureController :
         public PhysicsController,
         public PhysicsGenericContactCallback
     {
@@ -46,12 +46,12 @@
 		 * @param creature the creature of the bot/char
 		 * @param actor the actor of the bot/char
 		 */
-        MovingCreature(Creature *character);
-        ~MovingCreature();
+        CreatureController(Creature *character);
+        ~CreatureController();
 
         /**
          * This function is not intented to be called directly
-         * @retval true, if this MovingCreature still needs to be called every frame
+         * @retval true, if this CreatureController still needs to be called every frame
          */
         bool run(Ogre::Real elapsedTime);
 
@@ -162,7 +162,7 @@
         MovementMap mMovementMap;
 
         // in order to copy the contactcallback members correctly;
-        friend class MovingCreatureManager;
+        friend class CreatureControllerManager;
 
     private:
         // only used in setAnimation
@@ -181,13 +181,13 @@
         public OgreNewt::ContactCallback
     {
     public:
-        AbstractMovement(MovingCreature *movingCreature) : mMovingCreature(movingCreature), mActive(false) {}
+        AbstractMovement(CreatureController *movingCreature) : mMovingCreature(movingCreature), mActive(false) {}
 
         /// returns the id of this movement
-        virtual MovingCreature::MovementType getId() const = 0;
+        virtual CreatureController::MovementType getId() const = 0;
 
         /// returns the id of the movement that is used, if this movement isn't possible (any more)
-        virtual MovingCreature::MovementType getFallBackMovement() const = 0;
+        virtual CreatureController::MovementType getFallBackMovement() const = 0;
 
         /**
          * this method calculates the basis velocity (without any changes due to Talentproben etc)
@@ -208,7 +208,7 @@
         virtual int userProcess(OgreNewt::Body *body0, OgreNewt::Body *body1) {return 1;}
 
         /**
-         * this method is called by OnApplyTorqueAndForceCallback of the MovingCreature
+         * this method is called by OnApplyTorqueAndForceCallback of the CreatureController
          * the PhysicalThing can be acquired via the Creature
          */
         virtual void calculateForceAndTorque(Ogre::Vector3 &amp;force, Ogre::Vector3 &amp;torque, Ogre::Real timestep) = 0;
@@ -216,12 +216,12 @@
         /**
          * this method indicates if it is possible to change to the specified movement at this moment
          */
-        virtual bool canChangeToMovement(MovingCreature::MovementType id) {return true;}
+        virtual bool canChangeToMovement(CreatureController::MovementType id) {return true;}
 
         /**
          * this signifies that someone tried to change to another movement, but this was not possible (due to canChangeToMovement returning false)
          */
-        virtual void requestChangeToMovement(MovingCreature::MovementType id) {}
+        virtual void requestChangeToMovement(CreatureController::MovementType id) {}
 
         /**
          * here all the stuff not (directly) relating the physics should be done
@@ -229,7 +229,7 @@
          * Creature is in an active moving state. It is important to handle all 
          * &quot;Talentproben&quot; etc here and not in the physics function!
          * The parameter direction an rotation don't need to obey the rules from isDirectionPossible and isRotationPossible
-         * @retval true indicates that the creature should remain active (in order to activate it use MovingCreatureManager::setActive)
+         * @retval true indicates that the creature should remain active (in order to activate it use CreatureControllerManager::setActive)
          */
         virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation) = 0;
 
@@ -267,7 +267,7 @@
         /// this method is used to return the yaw value of rotation movemenrts etc
         virtual Ogre::Real getMovementDefinedValue() {return 0;}
     protected:
-        MovingCreature *mMovingCreature;
+        CreatureController *mMovingCreature;
         bool mActive;
     };
 }

Modified: rl/trunk/engine/rules/include/CreatureControllerManager.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureControllerManager.h	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/rules/include/CreatureControllerManager.h	2007-07-02 21:21:48 UTC (rev 3580)
@@ -28,29 +28,29 @@
 
 namespace rl
 {
-    class MovingCreature;
+    class CreatureController;
 
-    class _RlRulesExport MovingCreatureManager : 
+    class _RlRulesExport CreatureControllerManager : 
         public GameTask,
-        public Ogre::Singleton&lt;MovingCreatureManager&gt;,
+        public Ogre::Singleton&lt;CreatureControllerManager&gt;,
         public PhysicsGenericContactCallback
     {
     public:
-        MovingCreatureManager();
-        ~MovingCreatureManager();
+        CreatureControllerManager();
+        ~CreatureControllerManager();
 
         /**
          * adds a new movingCreature, this function is not intended to be used directly; 
-         * each MovingCreature is automatically added. a creature is always added in a
+         * each CreatureController is automatically added. a creature is always added in a
          * idle state
          */
-        void add(MovingCreature *movingCreature);
+        void add(CreatureController *movingCreature);
 
         /**
          * removes a movingCreature, this function is not intended to be used directly, 
          * destroy the movingCreature instead.
          */
-        void remove(MovingCreature *movingCreature);
+        void remove(CreatureController *movingCreature);
 
         void run(Ogre::Real elapsedTime);
 
@@ -59,14 +59,14 @@
          * frame. This must be the case, if the creature is moving. If a creature is in an
          * idle state, it is only updated less often
          */
-        void setActive(MovingCreature* movingCreature);
+        void setActive(CreatureController* movingCreature);
 
         const Ogre::String &amp; getName() const {return mName;}
 
         // Newton Contact Callback
         int userProcess();
     protected:
-        typedef std::vector&lt;MovingCreature*&gt; MovingCreatureVector;
+        typedef std::vector&lt;CreatureController*&gt; MovingCreatureVector;
         MovingCreatureVector mActiveCreatures;
         MovingCreatureVector mIdleCreatures;
         MovingCreatureVector mAddToActiveCreatures;
@@ -74,7 +74,7 @@
         Ogre::Real mTimeSinceLastIdleUpdate;
         Ogre::String mName;
 
-        typedef std::map&lt;OgreNewt::Body*,MovingCreature*&gt; MovingCreatureBodyMap;
+        typedef std::map&lt;OgreNewt::Body*,CreatureController*&gt; MovingCreatureBodyMap;
         MovingCreatureBodyMap mMovingCreatureFromBody;
     };
 }

Modified: rl/trunk/engine/rules/include/RulesSubsystem.h
===================================================================
--- rl/trunk/engine/rules/include/RulesSubsystem.h	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/rules/include/RulesSubsystem.h	2007-07-02 21:21:48 UTC (rev 3580)
@@ -27,7 +27,7 @@
     class ActionManager;
     class CombatManager;
     class DsaManager;
-    class MovingCreatureManager;
+    class CreatureControllerManager;
     class TimerManager;
     class XdimlLoader;
 
@@ -45,7 +45,7 @@
         ActionManager* mActionManager;
         CombatManager* mCombatManager;
         DsaManager* mDsaManager;
-        MovingCreatureManager *mMovingCreatureManager;
+        CreatureControllerManager *mMovingCreatureManager;
         TimerManager* mTimerManager;
         XdimlLoader* mXdimlLoader;
     };

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2007-07-02 21:21:48 UTC (rev 3580)
@@ -20,8 +20,8 @@
 #include &quot;DsaManager.h&quot;
 #include &quot;MeshAnimation.h&quot;
 #include &quot;MeshObject.h&quot;
-#include &quot;MovingCreature.h&quot;
-#include &quot;MovingCreatureManager.h&quot;
+#include &quot;CreatureController.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
 #include &quot;PhysicsManager.h&quot;
 #include &quot;PhysicalThing.h&quot;
 
@@ -37,9 +37,9 @@
     class Stehen : public AbstractMovement
     {
     public:
-        Stehen(MovingCreature *creature) : AbstractMovement(creature), mVelocity(Vector3::ZERO), mRotationMovement(NULL) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_STEHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_NONE;}
+        Stehen(CreatureController *creature) : AbstractMovement(creature), mVelocity(Vector3::ZERO), mRotationMovement(NULL) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_STEHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
         virtual void activate()
         {
             AbstractMovement::activate();
@@ -58,7 +58,7 @@
         virtual bool isPossible() const
         {
             return 
-                mMovingCreature-&gt;getAbstractLocation() == MovingCreature::AL_FLOOR &amp;&amp;
+                mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR &amp;&amp;
                 mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 0 &amp;&amp;
                 !(mMovingCreature-&gt;getCreature()-&gt;getStatus() &amp; (Effect::STATUS_DEAD | Effect::STATUS_UNCONSCIOUS | Effect::STATUS_SLEEPING));
         }
@@ -124,7 +124,7 @@
         {
             if( mRotationMovement == NULL)
             {                
-                mRotationMovement = mMovingCreature-&gt;getMovementFromId(MovingCreature::MT_DREHEN);
+                mRotationMovement = mMovingCreature-&gt;getMovementFromId(CreatureController::MT_DREHEN);
             }
             if( mRotationMovement == NULL )
             {
@@ -137,14 +137,14 @@
     class Drehen : public AbstractMovement
     {
     public:
-        Drehen(MovingCreature *creature) : AbstractMovement(creature), mYaw(0)
+        Drehen(CreatureController *creature) : AbstractMovement(creature), mYaw(0)
         {
             mRotLinearSpringK = 600.0f;
             Real relationCoefficient = 1.0f;
             mRotLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mRotLinearSpringK);
         }
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_DREHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_NONE;}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_DREHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_NONE;}
         virtual bool calculateBaseVelocity(Real &amp;velocity)
         {
             velocity = 0.3f;
@@ -153,7 +153,7 @@
         virtual bool isPossible() const
         {
             return 
-                mMovingCreature-&gt;getAbstractLocation() == MovingCreature::AL_FLOOR;// &amp;&amp;
+                mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR;// &amp;&amp;
                 mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 1 &amp;&amp;
                 !(mMovingCreature-&gt;getCreature()-&gt;getStatus() &amp; (Effect::STATUS_IMMOBILE));
         }
@@ -229,9 +229,9 @@
     class Gehen : public Stehen
     {
     public:
-        Gehen(MovingCreature *creature) : Stehen(creature) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_GEHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        Gehen(CreatureController *creature) : Stehen(creature) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_GEHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
         virtual bool calculateBaseVelocity(Real &amp;velocity)
         {
             velocity = mMovingCreature-&gt;getCurrentGS() / 3.6f * 0.7f; 
@@ -240,7 +240,7 @@
         virtual bool isPossible() const
         {
             return 
-                mMovingCreature-&gt;getAbstractLocation() == MovingCreature::AL_FLOOR &amp;&amp; 
+                mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR &amp;&amp; 
                 mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 1 &amp;&amp;
                 !(mMovingCreature-&gt;getCreature()-&gt;getStatus() &amp; Effect::STATUS_IMMOBILE);
         }
@@ -272,14 +272,14 @@
             
             switch( mMovingCreature-&gt;getLastMovementType() )
             {
-            case MovingCreature::MT_NONE:
+            case CreatureController::MT_NONE:
                 break;
-            case MovingCreature::MT_STEHEN:
+            case CreatureController::MT_STEHEN:
                 relTimeOffset = 0.25;
                 break;
-            case MovingCreature::MT_JOGGEN:
-            case MovingCreature::MT_LAUFEN:
-            case MovingCreature::MT_RENNEN:
+            case CreatureController::MT_JOGGEN:
+            case CreatureController::MT_LAUFEN:
+            case CreatureController::MT_RENNEN:
                 relTimeOffset = mMovingCreature-&gt;getAnimationTimePlayed();
                 if( mMovingCreature-&gt;getLastMovementChange() &lt; 1.0f )
                     weight = mMovingCreature-&gt;getLastMovementChange() / 1.0f;
@@ -302,9 +302,9 @@
     class Joggen : public Gehen
     {
     public:
-        Joggen(MovingCreature *creature) : Gehen(creature) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_JOGGEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_GEHEN;}
+        Joggen(CreatureController *creature) : Gehen(creature) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_JOGGEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_GEHEN;}
         virtual bool calculateBaseVelocity(Real &amp;velocity)
         {
             velocity = mMovingCreature-&gt;getCurrentGS() / 2.8f; 
@@ -331,12 +331,12 @@
 
             switch( mMovingCreature-&gt;getLastMovementType() )
             {
-            case MovingCreature::MT_NONE:
+            case CreatureController::MT_NONE:
                 break;
-            case MovingCreature::MT_STEHEN:
+            case CreatureController::MT_STEHEN:
                 relTimeOffset = 0.25;
                 break;
-            case MovingCreature::MT_GEHEN:
+            case CreatureController::MT_GEHEN:
                 relTimeOffset = mMovingCreature-&gt;getAnimationTimePlayed();
                 if( mMovingCreature-&gt;getLastMovementChange() &lt; 0.5f )
                     weight = mMovingCreature-&gt;getLastMovementChange() / 0.5f;
@@ -358,9 +358,9 @@
     class Laufen : public Gehen
     {
     public:
-        Laufen(MovingCreature *creature) : Gehen(creature), mTimePerAu(1), mLastProbe(0) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_LAUFEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_JOGGEN;}
+        Laufen(CreatureController *creature) : Gehen(creature), mTimePerAu(1), mLastProbe(0) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_LAUFEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_JOGGEN;}
         virtual bool calculateBaseVelocity(Real &amp;velocity)
         {
             velocity = mMovingCreature-&gt;getCurrentGS() / 2.0f; 
@@ -399,12 +399,12 @@
 
             switch( mMovingCreature-&gt;getLastMovementType() )
             {
-            case MovingCreature::MT_NONE:
+            case CreatureController::MT_NONE:
                 break;
-            case MovingCreature::MT_STEHEN:
+            case CreatureController::MT_STEHEN:
                 relTimeOffset = 0.25;
                 break;
-            case MovingCreature::MT_GEHEN:
+            case CreatureController::MT_GEHEN:
                 relTimeOffset = mMovingCreature-&gt;getAnimationTimePlayed();
                 if( mMovingCreature-&gt;getLastMovementChange() &lt; 0.5f )
                     weight = mMovingCreature-&gt;getLastMovementChange() / 0.5f;
@@ -464,9 +464,9 @@
     class Rennen : public Gehen
     {
     public:
-        Rennen(MovingCreature *creature) : Gehen(creature), mVelocityImprovement(0), mLastProbe(0) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_RENNEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_LAUFEN;}
+        Rennen(CreatureController *creature) : Gehen(creature), mVelocityImprovement(0), mLastProbe(0) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RENNEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_LAUFEN;}
         virtual bool calculateBaseVelocity(Real &amp;velocity)
         {
             velocity = mMovingCreature-&gt;getCurrentGS(); 
@@ -509,12 +509,12 @@
 
             switch( mMovingCreature-&gt;getLastMovementType() )
             {
-            case MovingCreature::MT_NONE:
+            case CreatureController::MT_NONE:
                 break;
-            case MovingCreature::MT_STEHEN:
+            case CreatureController::MT_STEHEN:
                 relTimeOffset = 0.25;
                 break;
-            case MovingCreature::MT_GEHEN:
+            case CreatureController::MT_GEHEN:
                 relTimeOffset = mMovingCreature-&gt;getAnimationTimePlayed();
                 if( mMovingCreature-&gt;getLastMovementChange() &lt; 0.5f )
                     weight = mMovingCreature-&gt;getLastMovementChange() / 0.5f;
@@ -573,9 +573,9 @@
     class RueckwaertsGehen : public Gehen
     {
     public:
-        RueckwaertsGehen(MovingCreature *creature) : Gehen(creature) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_RUECKWAERTS_GEHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        RueckwaertsGehen(CreatureController *creature) : Gehen(creature) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RUECKWAERTS_GEHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
         virtual bool calculateBaseVelocity(Real &amp;velocity)
         {
             velocity = mMovingCreature-&gt;getCurrentGS() / 4.0; 
@@ -590,9 +590,9 @@
     class RueckwaertsJoggen : public Joggen
     {
     public:
-        RueckwaertsJoggen(MovingCreature *creature) : Joggen(creature) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_RUECKWAERTS_JOGGEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_RUECKWAERTS_GEHEN;}
+        RueckwaertsJoggen(CreatureController *creature) : Joggen(creature) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_RUECKWAERTS_JOGGEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_RUECKWAERTS_GEHEN;}
         virtual bool calculateBaseVelocity(Real &amp;velocity)
         {
             velocity = mMovingCreature-&gt;getCurrentGS() / 3.2; 
@@ -608,9 +608,9 @@
     class SeitwaertsGehen : public Gehen
     {
     public:
-        SeitwaertsGehen(MovingCreature *creature) : Gehen(creature), mLeft(true) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_SEITWAERTS_GEHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        SeitwaertsGehen(CreatureController *creature) : Gehen(creature), mLeft(true) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_SEITWAERTS_GEHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
         virtual bool calculateBaseVelocity(Real &amp;velocity)
         {
             velocity = mMovingCreature-&gt;getCurrentGS() / 4.0; 
@@ -641,9 +641,9 @@
     class Schleichen : public Gehen
     {
     public:
-        Schleichen(MovingCreature *creature) : Gehen(creature), mState(UP), mTimer(0) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_SCHLEICHEN;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        Schleichen(CreatureController *creature) : Gehen(creature), mState(UP), mTimer(0) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_SCHLEICHEN;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
         virtual bool calculateBaseVelocity(Real &amp;velocity)
         {
             velocity = mMovingCreature-&gt;getCurrentGS() / 6.0; 
@@ -659,7 +659,7 @@
             }
             if( mState == UP )
             {
-                mMovingCreature-&gt;setMovement(MovingCreature::MT_STEHEN, direction, rotation);
+                mMovingCreature-&gt;setMovement(CreatureController::MT_STEHEN, direction, rotation);
             }
             if( mState == DOWNTOUP )
             {
@@ -695,11 +695,11 @@
             mMovingCreature-&gt;setAnimation(&quot;idle_zu_hocke&quot;,1,1,&quot;Idle&quot;);
             mTimer = 0;
         }
-        virtual bool canChangeToMovement(MovingCreature::MovementType id)
+        virtual bool canChangeToMovement(CreatureController::MovementType id)
         {
             return mState == UP;
         }
-        virtual void requestChangeToMovement(MovingCreature::MovementType id)
+        virtual void requestChangeToMovement(CreatureController::MovementType id)
         {
             if( mState == DOWN )
             {
@@ -717,9 +717,9 @@
     class Hochsprung : public AbstractMovement
     {
     public:
-        Hochsprung(MovingCreature *creature) : AbstractMovement(creature), mState(DOWN), mHeight(0), mJumpNow(false), mTimer(0) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_HOCHSPRUNG;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        Hochsprung(CreatureController *creature) : AbstractMovement(creature), mState(DOWN), mHeight(0), mJumpNow(false), mTimer(0) {}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_HOCHSPRUNG;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
         virtual void activate()
         {
             AbstractMovement::activate();
@@ -775,13 +775,13 @@
         {
             if( mMovingCreature-&gt;getMovement() == this )
                 return
-                    (mMovingCreature-&gt;getAbstractLocation() == MovingCreature::AL_FLOOR ||
-                    mMovingCreature-&gt;getAbstractLocation() == MovingCreature::AL_AIRBORNE) &amp;&amp;
+                    (mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR ||
+                    mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_AIRBORNE) &amp;&amp;
                     mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 6 &amp;&amp;
                     !(mMovingCreature-&gt;getCreature()-&gt;getStatus() &amp; (Effect::STATUS_IMMOBILE));
             else
                 return 
-                mMovingCreature-&gt;getAbstractLocation() == MovingCreature::AL_FLOOR &amp;&amp;
+                mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR &amp;&amp;
                 mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 8 &amp;&amp;
                 mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; mMovingCreature-&gt;getCreature()-&gt;getAuMax()/3.0 &amp;&amp;
                 !(mMovingCreature-&gt;getCreature()-&gt;getStatus() &amp; (Effect::STATUS_IMMOBILE));
@@ -805,7 +805,7 @@
                 force = Vector3(0,
                     jumpForce,
                     0);
-                mMovingCreature-&gt;setAbstractLocation( MovingCreature::AL_AIRBORNE );
+                mMovingCreature-&gt;setAbstractLocation( CreatureController::AL_AIRBORNE );
             }
 
             Vector3 omega = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getOmega();
@@ -815,7 +815,7 @@
         {
             if( mState == DOWN )
             {
-                mMovingCreature-&gt;setMovement(MovingCreature::MT_STEHEN, direction, rotation);
+                mMovingCreature-&gt;setMovement(CreatureController::MT_STEHEN, direction, rotation);
             }
             if( mState == UPTODOWN )
             {
@@ -830,9 +830,9 @@
                 mTimer += elapsedTime;
                 if( mTimer &lt; 0.5f )
                 {
-                    mMovingCreature-&gt;setAbstractLocation( MovingCreature::AL_AIRBORNE );
+                    mMovingCreature-&gt;setAbstractLocation( CreatureController::AL_AIRBORNE );
                 }
-                else if( mMovingCreature-&gt;getAbstractLocation() != MovingCreature::AL_AIRBORNE )
+                else if( mMovingCreature-&gt;getAbstractLocation() != CreatureController::AL_AIRBORNE )
                 {
                     mState = UPTODOWN;
                     mMovingCreature-&gt;setAnimation(&quot;idle_sprung_landung&quot;, 1, 1, &quot;Idle&quot;);
@@ -845,7 +845,7 @@
                 if( mTimer &gt;= 0.25f )
                 {
                     mState = UP;
-                    mMovingCreature-&gt;setAbstractLocation(MovingCreature::AL_AIRBORNE);
+                    mMovingCreature-&gt;setAbstractLocation(CreatureController::AL_AIRBORNE);
                     //mMovingCreature-&gt;setAnimation(&quot;idle_sprung&quot;); // we also don't need this animation!
                     mJumpNow = true;
                     mTimer = 0;
@@ -866,7 +866,7 @@
             rotation = Vector3::ZERO;
             return false;
         }
-        virtual bool canChangeToMovement(MovingCreature::MovementType id)
+        virtual bool canChangeToMovement(CreatureController::MovementType id)
         {
             return mState == DOWN;
         }
@@ -881,13 +881,13 @@
     class Weitsprung : public AbstractMovement
     {
     public:
-        Weitsprung(MovingCreature *creature) : 
+        Weitsprung(CreatureController *creature) : 
           AbstractMovement(creature), mState(DOWN), mWidth(0),
               mJumpNow(false), mTimer(0), mApplyForceTime(0.12),
               mApplyForceTimer(0), mLastForce(Vector3::ZERO),
               mVelocityBeforeJump(0), mTanJumpAngle(Math::Tan(Degree(17))) {}
-        virtual MovingCreature::MovementType getId() const {return MovingCreature::MT_WEITSPRUNG;}
-        virtual MovingCreature::MovementType getFallBackMovement() const {return MovingCreature::MT_STEHEN;}
+        virtual CreatureController::MovementType getId() const {return CreatureController::MT_WEITSPRUNG;}
+        virtual CreatureController::MovementType getFallBackMovement() const {return CreatureController::MT_STEHEN;}
         virtual void activate()
         {
             AbstractMovement::activate();
@@ -900,7 +900,7 @@
             {
                 // the person will only achieve this width if it is running
                 // retrieve run movement
-                AbstractMovement *run = mMovingCreature-&gt;getMovementFromId(MovingCreature::MT_RENNEN);
+                AbstractMovement *run = mMovingCreature-&gt;getMovementFromId(CreatureController::MT_RENNEN);
                 if( run != NULL )
                 {
                     Real vel(0);
@@ -957,13 +957,13 @@
         {
             if( mMovingCreature-&gt;getMovement() == this )
                 return
-                    (mMovingCreature-&gt;getAbstractLocation() == MovingCreature::AL_FLOOR ||
-                    mMovingCreature-&gt;getAbstractLocation() == MovingCreature::AL_AIRBORNE) &amp;&amp;
+                    (mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR ||
+                    mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_AIRBORNE) &amp;&amp;
                     mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 6 &amp;&amp;
                     !(mMovingCreature-&gt;getCreature()-&gt;getStatus() &amp; (Effect::STATUS_IMMOBILE));
             else
                 return 
-                mMovingCreature-&gt;getAbstractLocation() == MovingCreature::AL_FLOOR &amp;&amp;
+                mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_FLOOR &amp;&amp;
                 mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; 8 &amp;&amp;
                 mMovingCreature-&gt;getCreature()-&gt;getAu() &gt; mMovingCreature-&gt;getCreature()-&gt;getAuMax()/3.0 &amp;&amp;
                 !(mMovingCreature-&gt;getCreature()-&gt;getStatus() &amp; (Effect::STATUS_IMMOBILE));
@@ -1045,7 +1045,7 @@
         {
             if( mState == DOWN )
             {
-                mMovingCreature-&gt;setMovement(MovingCreature::MT_STEHEN, direction, rotation);
+                mMovingCreature-&gt;setMovement(CreatureController::MT_STEHEN, direction, rotation);
             }
             if( mState == UPTODOWN )
             {
@@ -1060,9 +1060,9 @@
                 mTimer += elapsedTime;
                 if( mTimer &lt; 0.5f )
                 {
-                    mMovingCreature-&gt;setAbstractLocation( MovingCreature::AL_AIRBORNE );
+                    mMovingCreature-&gt;setAbstractLocation( CreatureController::AL_AIRBORNE );
                 }
-                else if( mMovingCreature-&gt;getAbstractLocation() != MovingCreature::AL_AIRBORNE )
+                else if( mMovingCreature-&gt;getAbstractLocation() != CreatureController::AL_AIRBORNE )
                 {
                     mState = UPTODOWN;
                     mMovingCreature-&gt;setAnimation(&quot;rennen_sprung_landung&quot;, 1, 1, &quot;Run&quot;);
@@ -1075,7 +1075,7 @@
                 if( mTimer &gt;= 0.3f )
                 {
                     mState = UP;
-                    mMovingCreature-&gt;setAbstractLocation(MovingCreature::AL_AIRBORNE);
+                    mMovingCreature-&gt;setAbstractLocation(CreatureController::AL_AIRBORNE);
                     //mMovingCreature-&gt;setAnimation(&quot;rennen_sprung&quot;);
                     mJumpNow = true;
                     mApplyForceTimer = 0;
@@ -1098,7 +1098,7 @@
             rotation = Vector3::ZERO;
             return false;
         }
-        virtual bool canChangeToMovement(MovingCreature::MovementType id)
+        virtual bool canChangeToMovement(CreatureController::MovementType id)
         {
             return mState == DOWN;
         }
@@ -1131,7 +1131,7 @@
 
 
 
-    MovingCreature::MovingCreature(Creature *creature) :
+    CreatureController::CreatureController(Creature *creature) :
         mCreature(creature),
         mAbstractLocation(AL_AIRBORNE),
         mMovement(NULL),
@@ -1145,7 +1145,7 @@
         mStillWeightedAnimationName(&quot;&quot;),
         mLastFloorContact(0)
     {
-        MovingCreatureManager::getSingleton().add(this);
+        CreatureControllerManager::getSingleton().add(this);
         
         const OgreNewt::MaterialID *material = PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;);
         mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;setMaterialID(material);
@@ -1195,7 +1195,7 @@
         mMovementMap.insert(movementPair);
     }
 
-    MovingCreature::~MovingCreature()
+    CreatureController::~CreatureController()
     {
         MovementMap::iterator iter;
         for(iter = mMovementMap.begin(); iter != mMovementMap.end(); iter++)
@@ -1204,10 +1204,10 @@
 
         mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
 
-        MovingCreatureManager::getSingleton().remove(this);
+        CreatureControllerManager::getSingleton().remove(this);
     }
 
-    MovingCreature::MovementType MovingCreature::getMovementId() const
+    CreatureController::MovementType CreatureController::getMovementId() const
     {
         if (mMovement == NULL) 
             return MT_NONE; 
@@ -1215,7 +1215,7 @@
             return mMovement-&gt;getId();
     }
 
-    int MovingCreature::getCurrentGS() const
+    int CreatureController::getCurrentGS() const
     {
         int act_gs = mCreature-&gt;getWert(Creature::WERT_GS);
         ///@todo wy does this not work
@@ -1223,7 +1223,7 @@
         return max(act_gs,1);
     }
 
-    MeshAnimation *MovingCreature::setAnimation(const Ogre::String &amp;name, Ogre::Real speed, unsigned int timesToPlay, const Ogre::String &amp;collisionName, Real weight)
+    MeshAnimation *CreatureController::setAnimation(const Ogre::String &amp;name, Ogre::Real speed, unsigned int timesToPlay, const Ogre::String &amp;collisionName, Real weight)
     {
         MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(mCreature-&gt;getActor()-&gt;getControlledObject());
         PhysicalThing* pt = mCreature-&gt;getActor()-&gt;getPhysicalThing();
@@ -1303,7 +1303,7 @@
         return meshAnim;
     }
 
-    Ogre::Real MovingCreature::getAnimationTimePlayed() const
+    Ogre::Real CreatureController::getAnimationTimePlayed() const
     {
         MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(mCreature-&gt;getActor()-&gt;getControlledObject());
         MeshAnimation *meshAnim = mesh-&gt;getAnimation(mLastAnimationName);
@@ -1312,19 +1312,19 @@
         return 0;
     }
 
-    Ogre::Vector3 MovingCreature::getVelocity() const
+    Ogre::Vector3 CreatureController::getVelocity() const
     {
         return 
             mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;getOrientation().Inverse() *
             mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getVelocity();
     }
 
-    Ogre::Vector3 MovingCreature::getOmega() const
+    Ogre::Vector3 CreatureController::getOmega() const
     {
         return mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getOmega();
     }
 
-    bool MovingCreature::run(Real elapsedTime)
+    bool CreatureController::run(Real elapsedTime)
     {
         if(mMovement != NULL)
         {
@@ -1343,7 +1343,7 @@
         return false;
     }
 
-    void MovingCreature::OnApplyForceAndTorque(PhysicalThing* thing)
+    void CreatureController::OnApplyForceAndTorque(PhysicalThing* thing)
     {
         Vector3 force, torque;
         OgreNewt::Body *body = thing-&gt;_getBody();
@@ -1371,7 +1371,7 @@
         body-&gt;setTorque(torque);
     }
 
-    int MovingCreature::userProcess()
+    int CreatureController::userProcess()
     {
         // own collision handling (floor, in order to get information for mAbstractLocation)
         Vector3 point;
@@ -1422,7 +1422,7 @@
         return 1;
     }
 
-    AbstractMovement *MovingCreature::getMovementFromId(MovingCreature::MovementType id)
+    AbstractMovement *CreatureController::getMovementFromId(CreatureController::MovementType id)
     {
         MovementMap::iterator iter = mMovementMap.find(id);
         if(iter == mMovementMap.end())
@@ -1433,13 +1433,13 @@
     }
 
 
-    bool MovingCreature::setMovement(MovementType type, Vector3 direction, Vector3 rotation)
+    bool CreatureController::setMovement(MovementType type, Vector3 direction, Vector3 rotation)
     {
         if( mMovement != NULL )
         {
             if( mMovement-&gt;getId() == type )
             {
-                MovingCreatureManager::getSingleton().setActive(this);
+                CreatureControllerManager::getSingleton().setActive(this);
                 mDirection = direction;
                 mRotation = rotation;
                 return true;
@@ -1462,7 +1462,7 @@
         {
             if(movement-&gt;isPossible())
             {
-                MovingCreatureManager::getSingleton().setActive(this); // runs the old movement if idle!
+                CreatureControllerManager::getSingleton().setActive(this); // runs the old movement if idle!
                 if(mMovement == NULL)
                 {
                     mLastMovementType = MT_NONE;
@@ -1488,7 +1488,7 @@
 
 
 
-    Ogre::Radian MovingCreature::getYaw()
+    Ogre::Radian CreatureController::getYaw()
     {
         Radian yaw = mCreature-&gt;getActor()-&gt;getWorldOrientation().getYaw();
 

Modified: rl/trunk/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2007-07-02 21:21:48 UTC (rev 3580)
@@ -20,23 +20,23 @@
 #include &quot;GameTask.h&quot;
 #include &quot;GameLoop.h&quot;
 #include &quot;Exception.h&quot;
-#include &quot;MovingCreatureManager.h&quot;
-#include &quot;MovingCreature.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
+#include &quot;CreatureController.h&quot;
 
 
 using namespace Ogre;
 using namespace std;
 
 
-template&lt;&gt; rl::MovingCreatureManager* Singleton&lt;rl::MovingCreatureManager&gt;::ms_Singleton = 0;
+template&lt;&gt; rl::CreatureControllerManager* Singleton&lt;rl::CreatureControllerManager&gt;::ms_Singleton = 0;
 
 
 namespace rl
 {
-    MovingCreatureManager::MovingCreatureManager() :
+    CreatureControllerManager::CreatureControllerManager() :
             mUpdateIdleTime(1.0f),
             mTimeSinceLastIdleUpdate(0.0f),
-            mName(&quot;MovingCreatureManager&quot;)
+            mName(&quot;CreatureControllerManager&quot;)
     {
         GameLoop::getSingleton().addTask(this, GameLoop::TG_LOGIC);
 
@@ -51,7 +51,7 @@
         physicsManager-&gt;createMaterialPair(char_mat, level_mat)-&gt;setContactCallback(this);
     }
 
-    MovingCreatureManager::~MovingCreatureManager()
+    CreatureControllerManager::~CreatureControllerManager()
     {
         PhysicsManager *physicsManager = PhysicsManager::getSingletonPtr();
         const OgreNewt::MaterialID *char_mat = physicsManager-&gt;getMaterialID(&quot;character&quot;);
@@ -66,7 +66,7 @@
         GameLoop::getSingleton().removeTask(this);
     }
 
-    void MovingCreatureManager::add(MovingCreature *movingCreature)
+    void CreatureControllerManager::add(CreatureController *movingCreature)
     {
         if(movingCreature == NULL)
         {
@@ -78,14 +78,14 @@
         {
             if( (*iter) == movingCreature )
             {
-                Throw(IllegalArgumentException, &quot;MovingCreature wird schon vom MovingCreatureManager verwaltet.&quot;);
+                Throw(IllegalArgumentException, &quot;CreatureController wird schon vom CreatureControllerManager verwaltet.&quot;);
             }
         }
         for(iter = mActiveCreatures.begin(); iter != mActiveCreatures.end(); iter++)
         {
             if( (*iter) == movingCreature )
             {
-                Throw(IllegalArgumentException, &quot;MovingCreature wird schon vom MovingCreatureManager verwaltet.&quot;);
+                Throw(IllegalArgumentException, &quot;CreatureController wird schon vom CreatureControllerManager verwaltet.&quot;);
             }
         }
 
@@ -96,7 +96,7 @@
     }
 
 
-    void MovingCreatureManager::remove(MovingCreature *movingCreature)
+    void CreatureControllerManager::remove(CreatureController *movingCreature)
     {
         if(movingCreature == NULL)
         {
@@ -108,7 +108,7 @@
 
         if( body_iter == mMovingCreatureFromBody.end() )
         {
-            Throw(IllegalArgumentException, &quot;MovingCreature wird nicht vom MovingCreatureManager verwaltet.&quot;);
+            Throw(IllegalArgumentException, &quot;CreatureController wird nicht vom CreatureControllerManager verwaltet.&quot;);
         }
 
         mMovingCreatureFromBody.erase(body_iter);
@@ -141,10 +141,10 @@
         }
 
 
-        Throw(IllegalArgumentException, &quot;MovingCreature wird nicht vom MovingCreatureManager verwaltet.&quot;);
+        Throw(IllegalArgumentException, &quot;CreatureController wird nicht vom CreatureControllerManager verwaltet.&quot;);
     }
 
-    void MovingCreatureManager::run(Real elapsedTime)
+    void CreatureControllerManager::run(Real elapsedTime)
     {
         mTimeSinceLastIdleUpdate += elapsedTime;
 
@@ -166,7 +166,7 @@
     }
 
 
-    void MovingCreatureManager::setActive(MovingCreature* movingCreature)
+    void CreatureControllerManager::setActive(CreatureController* movingCreature)
     {
         if(movingCreature == NULL)
         {
@@ -194,17 +194,17 @@
         {
             if( *iter == movingCreature )
             {
-                LOG_DEBUG(Logger::RULES, &quot;Die angegebene MovingCreature ist schon aktiv.&quot;);
+                LOG_DEBUG(Logger::RULES, &quot;Die angegebene CreatureController ist schon aktiv.&quot;);
                 return;
             }
         }
 
 
-        Throw(IllegalArgumentException, &quot;MovingCreature wird nicht vom MovingCreatureManager verwaltet.&quot;);
+        Throw(IllegalArgumentException, &quot;CreatureController wird nicht vom CreatureControllerManager verwaltet.&quot;);
     }
 
 
-    int MovingCreatureManager::userProcess()
+    int CreatureControllerManager::userProcess()
     {
         MovingCreatureBodyMap::iterator iter;
         iter = mMovingCreatureFromBody.find(m_body0);

Modified: rl/trunk/engine/rules/src/RulesSubsystem.cpp
===================================================================
--- rl/trunk/engine/rules/src/RulesSubsystem.cpp	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/rules/src/RulesSubsystem.cpp	2007-07-02 21:21:48 UTC (rev 3580)
@@ -22,7 +22,7 @@
 #include &quot;DsaDataLoader.h&quot;
 #include &quot;EffectFactory.h&quot;
 #include &quot;Logger.h&quot;
-#include &quot;MovingCreatureManager.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
 #include &quot;TimerManager.h&quot;
 #include &quot;GameObjectManager.h&quot;
 #include &quot;QuestBook.h&quot;
@@ -51,8 +51,8 @@
 		LOG_MESSAGE(Logger::RULES, &quot;CombatManager erzeugt&quot;);
         mDsaManager = new DsaManager();
 		LOG_MESSAGE(Logger::RULES, &quot;DsaManager erzeugt&quot;);
-        mMovingCreatureManager = new MovingCreatureManager();
-		LOG_MESSAGE(Logger::RULES, &quot;MovingCreatureManager erzeugt&quot;);
+        mMovingCreatureManager = new CreatureControllerManager();
+		LOG_MESSAGE(Logger::RULES, &quot;CreatureControllerManager erzeugt&quot;);
         mTimerManager = new TimerManager(); 
 		LOG_MESSAGE(Logger::RULES, &quot;TimerManager erzeugt&quot;);
 		resetQuestBook();

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-07-02 21:21:48 UTC (rev 3580)
@@ -261,7 +261,7 @@
 	class CreatureWalkPathJob : public Job
     {
     public:
-        CreatureWalkPathJob(const Ogre::String&amp; name, MovingCreature* movingCreature, Landmark* startLandmark);
+        CreatureWalkPathJob(const Ogre::String&amp; name, CreatureController* movingCreature, Landmark* startLandmark);
 
         void addLandmark(const Ogre::String&amp; name, const Ogre::Vector3&amp; position);
         void addLandmark(Landmark* lm);

Modified: rl/trunk/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.swig	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/script/swig/RlRules.head.swig	2007-07-02 21:21:48 UTC (rev 3580)
@@ -52,5 +52,5 @@
 #include &quot;TimerListener.h&quot;
 #include &quot;Tripel.h&quot;
 #include &quot;Weapon.h&quot;
-#include &quot;MovingCreature.h&quot;
+#include &quot;CreatureController.h&quot;
 %}

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-07-02 21:21:48 UTC (rev 3580)
@@ -751,10 +751,10 @@
         rl::TimerEventSource* getSource() const;
     };
     
-    class MovingCreature
+    class CreatureController
     {
     public:
-        MovingCreature(Creature *character); 
+        CreatureController(Creature *character); 
         
         typedef enum
         {

Modified: rl/trunk/engine/script/swig/RlUi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.swig	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/script/swig/RlUi.swig	2007-07-02 21:21:48 UTC (rev 3580)
@@ -135,18 +135,18 @@
 } //namespace rl
 
 %{
-static swig_type_info *CharacterController_dynamic_cast(void **ptr)
+static swig_type_info *ControlState_dynamic_cast(void **ptr)
 {
-    rl::ControlState **ppCharacterController =
+    rl::ControlState **ppControlState =
         reinterpret_cast&lt;rl::ControlState**&gt;(ptr);
 
-    rl::CutsceneControlState *pCutSceneCC =
-        dynamic_cast&lt;rl::CutsceneControlState*&gt;(*ppCharacterController);
-    if (pCutSceneCC != NULL) {
-        *ptr=pCutSceneCC;
-        return SWIGTYPE_p_rl__CutsceneCharacterController;
+    rl::CutsceneControlState *pCutSceneCS =
+        dynamic_cast&lt;rl::CutsceneControlState*&gt;(*ppControlState);
+    if (pCutSceneCS != NULL) {
+        *ptr=pCutSceneCS;
+        return SWIGTYPE_p_rl__CutsceneControlState;
     }
     return 0;
 }
 %}
-DYNAMIC_CAST(SWIGTYPE_p_rl__CharacterController, CharacterController_dynamic_cast);
+DYNAMIC_CAST(SWIGTYPE_p_rl__ControlState, ControlState_dynamic_cast);

Modified: rl/trunk/engine/ui/include/MovementControlState.h
===================================================================
--- rl/trunk/engine/ui/include/MovementControlState.h	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/ui/include/MovementControlState.h	2007-07-02 21:21:48 UTC (rev 3580)
@@ -19,7 +19,7 @@
 
 #include &quot;UiPrerequisites.h&quot;
 #include &quot;GameTask.h&quot;
-#include &quot;MovingCreature.h&quot;
+#include &quot;CreatureController.h&quot;
 #include &quot;PhysicsController.h&quot;
 #include &quot;PhysicsGenericContactCallback.h&quot;
 #include &quot;ControlState.h&quot;
@@ -85,7 +85,7 @@
 
     protected:
         virtual void doCreatePrimitive();
-        MovingCreature *mMovingCreature;
+        CreatureController *mMovingCreature;
 
     private:
 

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2007-07-02 20:24:10 UTC (rev 3579)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2007-07-02 21:21:48 UTC (rev 3580)
@@ -180,7 +180,7 @@
     void MovementControlState::resume()
     {
         if( mMovingCreature == NULL )
-            mMovingCreature = new MovingCreature(mCharacter);
+            mMovingCreature = new CreatureController(mCharacter);
 
         // We want to check for visibility from char's POV.
         mSelector.setCheckVisibility(true, mCharacter);
@@ -287,7 +287,7 @@
             int movement = mCharacterState.mCurrentMovementState;
             Degree rotation(0);
 
-            AbstractMovement *drehen = mMovingCreature-&gt;getMovementFromId(MovingCreature::MT_DREHEN);
+            AbstractMovement *drehen = mMovingCreature-&gt;getMovementFromId(CreatureController::MT_DREHEN);
             Real baseVelocity = 0;
             if( drehen-&gt;calculateBaseVelocity(baseVelocity) )
             {
@@ -336,18 +336,18 @@
                 else if( movement &amp; MOVE_BACKWARD)
                     direction.z = 1;
                 mMovingCreature-&gt;setMovement(
-                    MovingCreature::MT_SCHLEICHEN,
+                    CreatureController::MT_SCHLEICHEN,
                     direction,
                     Vector3(0, rotation.valueRadians(), 0) );
             }
             else if( movement &amp; MOVE_JUMP &amp;&amp; 
-                mMovingCreature-&gt;getMovementFromId(MovingCreature::MT_HOCHSPRUNG)-&gt;isPossible() )
+                mMovingCreature-&gt;getMovementFromId(CreatureController::MT_HOCHSPRUNG)-&gt;isPossible() )
             {
-                MovingCreature::MovementType type = MovingCreature::MT_HOCHSPRUNG;
+                CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
                 Vector3 direction = Vector3::UNIT_Y;
                 if( movement &amp; MOVE_FORWARD )
                 {
-                    type = MovingCreature::MT_WEITSPRUNG;
+                    type = CreatureController::MT_WEITSPRUNG;
                     direction += Vector3::NEGATIVE_UNIT_Z;
                 }
                 mMovingCreature-&gt;setMovement(
@@ -357,20 +357,20 @@
             }
             else if( movement &amp; MOVE_FORWARD )
             {
-                MovingCreature::MovementType type = MovingCreature::MT_GEHEN;
+                CreatureController::MovementType type = CreatureController::MT_GEHEN;
                 if( movement &amp; MOVE_RUN_LOCK )
                 {
                     if( movement &amp; MOVE_RUN )
-                        type = MovingCreature::MT_RENNEN;
+                        type = CreatureController::MT_RENNEN;
                     else
-                        type = MovingCreature::MT_LAUFEN;
+                        type = CreatureController::MT_LAUFEN;
                 }
                 else
                 {
                     if( movement &amp; MOVE_RUN )
-                        type = MovingCreature::MT_GEHEN;
+                        type = CreatureController::MT_GEHEN;
                     else
-                        type = MovingCreature::MT_JOGGEN;
+                        type = CreatureController::MT_JOGGEN;
                 }
                 mMovingCreature-&gt;setMovement(
                     type,
@@ -379,9 +379,9 @@
             }
             else if (movement &amp; MOVE_BACKWARD )
             {
-                MovingCreature::MovementType type = MovingCreature::MT_RUECKWAERTS_GEHEN;
+                CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
                 if( !(movement &amp; MOVE_RUN) )
-                    type = MovingCreature::MT_RUECKWAERTS_JOGGEN;
+                    type = CreatureController::MT_RUECKWAERTS_JOGGEN;
                 mMovingCreature-&gt;setMovement(
                     type,
                     Vector3(0,0,1), 
@@ -393,14 +393,14 @@
                 if( movement &amp; MOVE_LEFT )
                     direction = Vector3::NEGATIVE_UNIT_X;
                 mMovingCreature-&gt;setMovement(
-                    MovingCreature::MT_SEITWAERTS_GEHEN,
+                    CreatureController::MT_SEITWAERTS_GEHEN,
                     direction, 
                     Vector3(0, rotation.valueRadians(), 0) );
             }
             else
             {
                 mMovingCreature-&gt;setMovement(
-                    MovingCreature::MT_STEHEN, 
+                    CreatureController::MT_STEHEN, 
                     Vector3(0,0,0),
                     Vector3(0, rotation.valueRadians(), 0) );
             }
@@ -503,7 +503,7 @@
     }
 
     // -------------------------------------------------------------
-    // character collision moved to MovingCreature(Manager)
+    // character collision moved to CreatureController(Manager)
     int MovementControlState::userProcess()
     {
         // only camera collision
@@ -519,7 +519,7 @@
     }
 
     //------------------------------------------------------------------------
-    // character callback moved to MovingCreature
+    // character callback moved to CreatureController
     void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing)
     {
         OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
@@ -530,7 +530,7 @@
 
 
 
-        ///@todo move to MovingCreature?
+        ///@todo move to CreatureController?
         SceneNode* node = mCharacterActor-&gt;_getSceneNode();
         std::ostringstream ss;
         Vector3 bodpos, playpos = node-&gt;getPosition();
@@ -550,7 +550,7 @@
             &lt;&lt; &quot;camera actor : &quot; &lt;&lt; mCameraActor-&gt;getWorldPosition() &lt;&lt; std::endl
             &lt;&lt; &quot;camera body pos : &quot; &lt;&lt; bodpos &lt;&lt; std::endl
             &lt;&lt; &quot;camera distance : &quot; &lt;&lt; mDesiredDistance &lt;&lt; std::endl
-            &lt;&lt; &quot;is airborne: &quot; &lt;&lt; (mMovingCreature-&gt;getAbstractLocation() == MovingCreature::AL_AIRBORNE ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
+            &lt;&lt; &quot;is airborne: &quot; &lt;&lt; (mMovingCreature-&gt;getAbstractLocation() == CreatureController::AL_AIRBORNE ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
 
         LOG_DEBUG(Logger::UI, ss.str());
         DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000650.html">[Dsa-hl-svn] r3579 - rl/trunk/engine/rules/src
</A></li>
	<LI>Next message: <A HREF="000652.html">[Dsa-hl-svn] r3581 - in modules: combattest/scripts/maps	regressiontest/scripts regressiontest/scripts/maps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#651">[ date ]</a>
              <a href="thread.html#651">[ thread ]</a>
              <a href="subject.html#651">[ subject ]</a>
              <a href="author.html#651">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
