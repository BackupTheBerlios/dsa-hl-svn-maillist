From timm at mail.berlios.de  Wed Apr  1 20:35:09 2009
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Wed, 1 Apr 2009 20:35:09 +0200
Subject: [Dsa-hl-svn] r4878 - in rl/trunk/engine: ai/src core script/src
Message-ID: <200904011835.n31IZ9Q5024602@sheep.berlios.de>

Author: timm
Date: 2009-04-01 20:35:03 +0200 (Wed, 01 Apr 2009)
New Revision: 4878

Modified:
   rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
   rl/trunk/engine/core/RlCore2005.vcproj
   rl/trunk/engine/script/src/SceneManager.cpp
Log:
fixed win32 build

Modified: rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-03-31 20:21:50 UTC (rev 4877)
+++ rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-04-01 18:35:03 UTC (rev 4878)
@@ -16,8 +16,13 @@
 #include "stdinc.h"
 
 #include <xercesc/dom/DOM.hpp>
-#include <CEGUI/CEGUIPropertyHelper.h>
 
+#ifdef __APPLE__
+#   include <CEGUI/CEGUIPropertyHelper.h>
+#else
+#   include <CEGUIPropertyHelper.h>
+#endif
+
 #include "DialogLoaderImpl.h"
 
 #include "ConfigurationManager.h"

Modified: rl/trunk/engine/core/RlCore2005.vcproj
===================================================================
--- rl/trunk/engine/core/RlCore2005.vcproj	2009-03-31 20:21:50 UTC (rev 4877)
+++ rl/trunk/engine/core/RlCore2005.vcproj	2009-04-01 18:35:03 UTC (rev 4878)
@@ -548,6 +548,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\PhysicsRagDoll.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\PlayAnimationJob.h"
 				>
 			</File>
@@ -889,6 +893,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\PhysicsRagDoll.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\PlayAnimationJob.cpp"
 				>
 			</File>

Modified: rl/trunk/engine/script/src/SceneManager.cpp
===================================================================
--- rl/trunk/engine/script/src/SceneManager.cpp	2009-03-31 20:21:50 UTC (rev 4877)
+++ rl/trunk/engine/script/src/SceneManager.cpp	2009-04-01 18:35:03 UTC (rev 4878)
@@ -74,10 +74,10 @@
             activeChar->setState(GOS_LOADED);
         }
 
-        /*if (saveCurrent) 
+        if (saveCurrent) 
         {
             mSceneStates[mCurrentScene] = mCurrentScene->getAllProperties();
-        }*/
+        }
 
         std::map<CeGuiString, Scene*>::iterator itScene = mScenes.find(sceneName);
         if (itScene != mScenes.end())



From timm at mail.berlios.de  Wed Apr  1 22:09:55 2009
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Wed, 1 Apr 2009 22:09:55 +0200
Subject: [Dsa-hl-svn] r4879 - in rl/branches/persistence2: .
	Mac/Rastullah.xcodeproj editors/Lockenwickler
	editors/Lockenwickler/_eric4project editors/Lockenwickler/src
	editors/Lockenwickler/src/media
	editors/Lockenwickler/src/media/icons engine/ai
	engine/ai/include engine/ai/include/OpenSteer engine/ai/src
	engine/ai/src/OpenSteer engine/common engine/common/include
	engine/common/src engine/core engine/core/include
	engine/core/src engine/rules engine/rules/include
	engine/rules/src engine/script engine/script/swig
	engine/startup engine/ui engine/ui/include engine/ui/src
	tests tests/dialogtests tools
Message-ID: <200904012009.n31K9t2J003448@sheep.berlios.de>

Author: timm
Date: 2009-04-01 22:08:44 +0200 (Wed, 01 Apr 2009)
New Revision: 4879

Added:
   rl/branches/persistence2/Rastullah2008.sln
   rl/branches/persistence2/editors/Lockenwickler/src/DepthBuffer.py
   rl/branches/persistence2/editors/Lockenwickler/src/ZoneManager.py
   rl/branches/persistence2/editors/Lockenwickler/src/media/depthmap.frag
   rl/branches/persistence2/editors/Lockenwickler/src/media/icons/14_layer_invisible.png
   rl/branches/persistence2/editors/Lockenwickler/src/media/icons/14_layer_visible.png
   rl/branches/persistence2/editors/Lockenwickler/src/media/icons/dissociatecell.png
   rl/branches/persistence2/engine/ai/RlAI2008.vcproj
   rl/branches/persistence2/engine/ai/include/OpenSteer/
   rl/branches/persistence2/engine/ai/include/OpenSteer/AbstractVehicle.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Color.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/LocalSpace.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Obstacle.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Path.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Pathway.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPath.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Proximity.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlike.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPath.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPathway.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/StandardTypes.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/SteerLibrary.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/UnusedParameter.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Utilities.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3Utilities.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/lq.h
   rl/branches/persistence2/engine/ai/src/OpenSteer/
   rl/branches/persistence2/engine/ai/src/OpenSteer/Color.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/Obstacle.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/Path.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/Pathway.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPath.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPathway.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/Vec3.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/lq.c
   rl/branches/persistence2/engine/common/RlCommon2008.vcproj
   rl/branches/persistence2/engine/core/RlCore2008.vcproj
   rl/branches/persistence2/engine/core/include/PhysicsRagDoll.h
   rl/branches/persistence2/engine/core/src/PhysicsRagDoll.cpp
   rl/branches/persistence2/engine/rules/RlRules2008.vcproj
   rl/branches/persistence2/engine/script/RlScript2008.vcproj
   rl/branches/persistence2/engine/script/swig/TypeRlGameObjectList.swig
   rl/branches/persistence2/engine/startup/RlStartup2008.vcproj
   rl/branches/persistence2/engine/ui/RlUI2008.vcproj
   rl/branches/persistence2/tests/dialogtests/
   rl/branches/persistence2/tests/dialogtests/Debug/
   rl/branches/persistence2/tests/dialogtests/Release/
   rl/branches/persistence2/tests/dialogtests/RlDialogTests.vcproj
   rl/branches/persistence2/tests/dialogtests/TestDialog.cpp
Removed:
   rl/branches/persistence2/editors/Lockenwickler/src/CodeDump.py
   rl/branches/persistence2/engine/ai/include/OpenSteer/AbstractVehicle.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Color.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/LocalSpace.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Obstacle.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Path.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Pathway.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPath.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Proximity.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlike.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPath.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPathway.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/StandardTypes.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/SteerLibrary.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/UnusedParameter.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Utilities.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3Utilities.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/lq.h
   rl/branches/persistence2/engine/ai/src/OpenSteer/Color.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/Obstacle.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/Path.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/Pathway.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPath.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPathway.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/Vec3.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/lq.c
   rl/branches/persistence2/tests/RlDialogTests/
   rl/branches/persistence2/tests/dialogtests/Debug/
   rl/branches/persistence2/tests/dialogtests/Release/
   rl/branches/persistence2/tests/dialogtests/RlDialogTests.vcproj
   rl/branches/persistence2/tests/dialogtests/TestDialog.cpp
Modified:
   rl/branches/persistence2/
   rl/branches/persistence2/CMakeLists.txt
   rl/branches/persistence2/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p
   rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
   rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
   rl/branches/persistence2/editors/Lockenwickler/src/ConsoleWindow.py
   rl/branches/persistence2/editors/Lockenwickler/src/GOIntEditor.py
   rl/branches/persistence2/editors/Lockenwickler/src/GOStringEditor.py
   rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py
   rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassManager.py
   rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py
   rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py
   rl/branches/persistence2/editors/Lockenwickler/src/MaterialSelectionDialog.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py
   rl/branches/persistence2/editors/Lockenwickler/src/MovePivot.py
   rl/branches/persistence2/editors/Lockenwickler/src/MyRaySceneQueryListener.py
   rl/branches/persistence2/editors/Lockenwickler/src/NewModuleWizard.py
   rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyModel.py
   rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py
   rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py
   rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py
   rl/branches/persistence2/editors/Lockenwickler/src/Plugins-linux.cfg
   rl/branches/persistence2/editors/Lockenwickler/src/Plugins-windows.cfg
   rl/branches/persistence2/editors/Lockenwickler/src/Plugins.cfg
   rl/branches/persistence2/editors/Lockenwickler/src/PreferencesDialog.py
   rl/branches/persistence2/editors/Lockenwickler/src/Property.py
   rl/branches/persistence2/editors/Lockenwickler/src/PythonOgreConfig.py
   rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py
   rl/branches/persistence2/editors/Lockenwickler/src/Ui_NewModuleWizard.py
   rl/branches/persistence2/editors/Lockenwickler/src/media/Pivot_Point.material
   rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColorVP.glsl
   rl/branches/persistence2/editors/Lockenwickler/src/media/UniCube.mesh
   rl/branches/persistence2/editors/Lockenwickler/src/setup.py
   rl/branches/persistence2/editors/Lockenwickler/src/ui_ConsoleWindow.py
   rl/branches/persistence2/engine/ai/CMakeLists.txt
   rl/branches/persistence2/engine/ai/RlAI2005.vcproj
   rl/branches/persistence2/engine/ai/include/AgentCombatState.h
   rl/branches/persistence2/engine/ai/include/AgentDialogState.h
   rl/branches/persistence2/engine/ai/include/DialogElement.h
   rl/branches/persistence2/engine/ai/include/DialogLoaderImpl.h
   rl/branches/persistence2/engine/ai/include/DialogOption.h
   rl/branches/persistence2/engine/ai/include/DialogResponse.h
   rl/branches/persistence2/engine/ai/include/SteeringVehicle.h
   rl/branches/persistence2/engine/ai/src/AgentCombatState.cpp
   rl/branches/persistence2/engine/ai/src/AgentDialogState.cpp
   rl/branches/persistence2/engine/ai/src/DialogLoaderImpl.cpp
   rl/branches/persistence2/engine/ai/src/DialogOption.cpp
   rl/branches/persistence2/engine/ai/src/DialogResponse.cpp
   rl/branches/persistence2/engine/ai/src/SteeringVehicle.cpp
   rl/branches/persistence2/engine/common/include/FixRubyHeaders.h
   rl/branches/persistence2/engine/common/src/ConfigFile.cpp
   rl/branches/persistence2/engine/core/CMakeLists.txt
   rl/branches/persistence2/engine/core/RlCore2005.vcproj
   rl/branches/persistence2/engine/core/include/PhysicalThing.h
   rl/branches/persistence2/engine/core/include/PhysicsManager.h
   rl/branches/persistence2/engine/core/src/Actor.cpp
   rl/branches/persistence2/engine/core/src/ActorManager.cpp
   rl/branches/persistence2/engine/core/src/AnimationManager.cpp
   rl/branches/persistence2/engine/core/src/ConfigurationManager.cpp
   rl/branches/persistence2/engine/core/src/PhysicalThing.cpp
   rl/branches/persistence2/engine/core/src/PhysicsManager.cpp
   rl/branches/persistence2/engine/rules/CMakeLists.txt
   rl/branches/persistence2/engine/rules/RlRules2005.vcproj
   rl/branches/persistence2/engine/rules/include/Creature.h
   rl/branches/persistence2/engine/rules/include/GameObject.h
   rl/branches/persistence2/engine/rules/include/GoToJob.h
   rl/branches/persistence2/engine/rules/include/Selector.h
   rl/branches/persistence2/engine/rules/src/FetchItemJob.cpp
   rl/branches/persistence2/engine/rules/src/GoToJob.cpp
   rl/branches/persistence2/engine/rules/src/Selector.cpp
   rl/branches/persistence2/engine/script/CMakeLists.txt
   rl/branches/persistence2/engine/script/RlScript2005.vcproj
   rl/branches/persistence2/engine/script/swig/RlAi.swig
   rl/branches/persistence2/engine/script/swig/RlCore.swig
   rl/branches/persistence2/engine/script/swig/RlExports.i
   rl/branches/persistence2/engine/script/swig/RlRules.swig
   rl/branches/persistence2/engine/script/swig/TypeDynamicDirector.swig
   rl/branches/persistence2/engine/script/swig/TypeMaps.i
   rl/branches/persistence2/engine/startup/CMakeLists.txt
   rl/branches/persistence2/engine/startup/RlStartup2005.vcproj
   rl/branches/persistence2/engine/ui/CMakeLists.txt
   rl/branches/persistence2/engine/ui/RlUI2005.vcproj
   rl/branches/persistence2/engine/ui/include/DialogControlState.h
   rl/branches/persistence2/engine/ui/include/DialogController.h
   rl/branches/persistence2/engine/ui/src/CombatControlState.cpp
   rl/branches/persistence2/engine/ui/src/DialogControlState.cpp
   rl/branches/persistence2/engine/ui/src/DialogController.cpp
   rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp
   rl/branches/persistence2/engine/ui/src/InputManager.cpp
   rl/branches/persistence2/engine/ui/src/InventoryWindow.cpp
   rl/branches/persistence2/engine/ui/src/MainMenuWindow.cpp
   rl/branches/persistence2/engine/ui/src/MovementControlState.cpp
   rl/branches/persistence2/tools/copy_dependencies.bat
Log:
merged from trunk and made it compile


Property changes on: rl/branches/persistence2
___________________________________________________________________
Name: svn:ignore
   + logs
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
configure
dependencies
*.in
*.cfg
*.conf
configure
*.log
depcomp
config.guess
config.sub
ltmain.sh
rl.conf
Makefile
test
mkinstalldirs
config.status
rastullah.cfg
libtool
autom4te.cache
missing
*.m4
install-sh
_dependencies
depsources
doc
compile
.cproject
.dep.inc


Modified: rl/branches/persistence2/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/CMakeLists.txt	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/CMakeLists.txt	2009-04-01 20:08:44 UTC (rev 4879)
@@ -70,7 +70,6 @@
 FIND_PACKAGE(CEGUIOGRE 1.6 REQUIRED)
 FIND_PACKAGE(FMODEx REQUIRED)
 FIND_PACKAGE(OgreNewt 2.0 REQUIRED)
-FIND_PACKAGE(OpenSteer REQUIRED)
 FIND_PACKAGE(MeshMagick 0.5 REQUIRED)
 FIND_PACKAGE(Ruby REQUIRED)
 FIND_PACKAGE(Boost 1.34 REQUIRED filesystem)
@@ -81,8 +80,8 @@
 ENDIF(NOT SWIG_DIR MATCHES -rl$)
 
 # Compile settings for build types
-SET(CMAKE_CXX_FLAGS_DEBUG "-O0 -g -DDEBUG")
-SET(CMAKE_CXX_FLAGS_RELWITHDEBINFO "-O2 -g -DDEBUG")
+SET(CMAKE_CXX_FLAGS_DEBUG "-O0 -g -D_DEBUG")
+SET(CMAKE_CXX_FLAGS_RELWITHDEBINFO "-O2 -g -D_DEBUG")
 
 # Path options
 SET(BINDIR "bin" CACHE STRING "Where to install binaries")

Modified: rl/branches/persistence2/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/branches/persistence2/Mac/Rastullah.xcodeproj/project.pbxproj	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/Mac/Rastullah.xcodeproj/project.pbxproj	2009-04-01 20:08:44 UTC (rev 4879)
@@ -429,6 +429,8 @@
 		44D8147A0BF7B62F00534175 /* Trigger.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814750BF7B62F00534175 /* Trigger.h */; };
 		44D8147B0BF7B62F00534175 /* Zone.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814760BF7B62F00534175 /* Zone.h */; };
 		44D8147C0BF7B62F00534175 /* ZoneManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814770BF7B62F00534175 /* ZoneManager.h */; };
+		483373810F65EBF4005979BF /* DialogController.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 483373800F65EBF4005979BF /* DialogController.cpp */; };
+		483373830F65EC01005979BF /* DialogController.h in Headers */ = {isa = PBXBuildFile; fileRef = 483373820F65EC01005979BF /* DialogController.h */; };
 		483646990D83D13700912FEC /* ContentLoader.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646960D83D13700912FEC /* ContentLoader.h */; };
 		4836469A0D83D13700912FEC /* SoundStitching.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646970D83D13700912FEC /* SoundStitching.h */; };
 		4836469B0D83D13700912FEC /* StartAnimationJob.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646980D83D13700912FEC /* StartAnimationJob.h */; };
@@ -1285,6 +1287,9 @@
 		44D814750BF7B62F00534175 /* Trigger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Trigger.h; sourceTree = "<group>"; };
 		44D814760BF7B62F00534175 /* Zone.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Zone.h; sourceTree = "<group>"; };
 		44D814770BF7B62F00534175 /* ZoneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZoneManager.h; sourceTree = "<group>"; };
+		483373800F65EBF4005979BF /* DialogController.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DialogController.cpp; sourceTree = "<group>"; };
+		483373820F65EC01005979BF /* DialogController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DialogController.h; sourceTree = "<group>"; };
+		483374130F6D275A005979BF /* TypeRlGameObjectList.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = TypeRlGameObjectList.swig; path = script/swig/TypeRlGameObjectList.swig; sourceTree = "<group>"; };
 		483646960D83D13700912FEC /* ContentLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ContentLoader.h; sourceTree = "<group>"; };
 		483646970D83D13700912FEC /* SoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundStitching.h; sourceTree = "<group>"; };
 		483646980D83D13700912FEC /* StartAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StartAnimationJob.h; sourceTree = "<group>"; };
@@ -1943,6 +1948,7 @@
 				48389BFB0D8677EE00AFAB66 /* TypeOgreVector3.swig */,
 				48389BFC0D8677EE00AFAB66 /* TypeRlCeGuiString.swig */,
 				48389BFD0D8677EE00AFAB66 /* TypeRlCeGuiStringVector.swig */,
+				483374130F6D275A005979BF /* TypeRlGameObjectList.swig */,
 				48389BFE0D8677EE00AFAB66 /* TypeRlProperty.swig */,
 				48389BFF0D8677EE00AFAB66 /* TypeRlPropertyKeys.swig */,
 				48389C000D8677EE00AFAB66 /* TypeStdPairIntInt.swig */,
@@ -2293,6 +2299,7 @@
 		48EFE0880E8B6822007EB7F8 /* Headers */ = {
 			isa = PBXGroup;
 			children = (
+				483373820F65EC01005979BF /* DialogController.h */,
 				48B006C60ECAC097008141C2 /* windows */,
 				444EAD010BD0E58C00C6D4A0 /* CeGuiHelper.h */,
 				4404DA850C48D037007B4657 /* stdinc.h */,
@@ -2320,6 +2327,7 @@
 		48EFE0890E8B6900007EB7F8 /* Source */ = {
 			isa = PBXGroup;
 			children = (
+				483373800F65EBF4005979BF /* DialogController.cpp */,
 				48B006C30ECABFB0008141C2 /* windows */,
 				444EACCC0BD0E57100C6D4A0 /* UiSubsystem.cpp */,
 				444EACCD0BD0E57100C6D4A0 /* WindowFactory.cpp */,
@@ -2823,6 +2831,7 @@
 				48389B9D0D86743900AFAB66 /* UiMessages.h in Headers */,
 				487029C70E80DCEA00B66388 /* GameOverWindow.h in Headers */,
 				48B006C80ECAC11D008141C2 /* CharacterSelectionWindow.h in Headers */,
+				483373830F65EC01005979BF /* DialogController.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3102,7 +3111,7 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 			shellPath = /bin/sh;
-			shellScript = "pwd\ncd ../engine/script/swig\n/usr/local/bin/swig -ruby -minherit -c++ -Fmicrosoft -addextern RlExports.i";
+			shellScript = "pwd\ncd ../engine/script/swig\n/usr/local/bin/swig -ruby -minherit -c++ -w473 -Fstandard -addextern RlExports.i";
 		};
 		48CA78BF0F221DD700F8E471 /* ShellScript */ = {
 			isa = PBXShellScriptBuildPhase;
@@ -3422,6 +3431,7 @@
 				48389B950D86741F00AFAB66 /* stdinc.cpp in Sources */,
 				487029C90E80DCF900B66388 /* GameOverWindow.cpp in Sources */,
 				48B006C50ECAC05F008141C2 /* CharacterSelectionWindow.cpp in Sources */,
+				483373810F65EBF4005979BF /* DialogController.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};

Copied: rl/branches/persistence2/Rastullah2008.sln (from rev 4878, rl/trunk/Rastullah2008.sln)

Modified: rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,181 +1,182 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE Project SYSTEM "Project-4.6.dtd">
-<!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-03-01, 22:49:19 -->
-<!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
-<Project version="4.6">
-  <Language>en</Language>
-  <ProgLanguage mixed="0">Python</ProgLanguage>
-  <ProjectType>Qt4</ProjectType>
-  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
-  <Version>0.1</Version>
-  <Author>Stefan Stammberger</Author>
-  <Email>sstammberger at web.de</Email>
-  <Sources>
-    <Source>src/Lockenwickler.py</Source>
-    <Source>src/ConsoleWindow.py</Source>
-    <Source>src/ModelSelectionDialog.py</Source>
-    <Source>src/ModuleManager.py</Source>
-    <Source>src/MovePivot.py</Source>
-    <Source>src/ObjectPropertyWin.py</Source>
-    <Source>src/OgreMainWindow.py</Source>
-    <Source>src/OgreWidget.py</Source>
-    <Source>src/PreferencesDialog.py</Source>
-    <Source>src/PythonOgreConfig.py</Source>
-    <Source>src/ui_ConsoleWindow.py</Source>
-    <Source>src/Property.py</Source>
-    <Source>src/ViewportGrid.py</Source>
-    <Source>src/ObjectPropertyModel.py</Source>
-    <Source>src/GameObjectClass.py</Source>
-    <Source>src/GameObjectClassManager.py</Source>
-    <Source>src/setup.py</Source>
-    <Source>src/GameObjectClassView.py</Source>
-    <Source>src/MyRaySceneQueryListener.py</Source>
-    <Source>src/GOStringEditor.py</Source>
-    <Source>src/GOIntEditor.py</Source>
-    <Source>src/CodeDump.py</Source>
-    <Source>src/NewModuleWizard.py</Source>
-    <Source>src/Ui_NewModuleWizard.py</Source>
-    <Source>src/ModuleExplorer.py</Source>
-    <Source>src/SelectionBuffer.py</Source>
-    <Source>src/MaterialSelectionDialog.py</Source>
-  </Sources>
-  <Forms>
-    <Form>ui files/GOPropertyEditorDialogINT.ui</Form>
-    <Form>ui files/GOPropertyEditorDialogSTRING.ui</Form>
-    <Form>ui files/NewModuleWizard.ui</Form>
-  </Forms>
-  <Translations>
-  </Translations>
-  <Resources>
-  </Resources>
-  <Interfaces>
-  </Interfaces>
-  <Others>
-  </Others>
-  <MainScript>src/Lockenwickler.py</MainScript>
-  <Vcs>
-    <VcsType>None</VcsType>
-    <VcsOptions>
-      <dict>
-        <key>
-          <string>add</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>checkout</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>commit</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>diff</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>export</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>global</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>history</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>log</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>remove</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>status</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>tag</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>update</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-      </dict>
-    </VcsOptions>
-    <VcsOtherData>
-      <dict>
-        <key>
-          <string>standardLayout</string>
-        </key>
-        <value>
-          <bool>True</bool>
-        </value>
-      </dict>
-    </VcsOtherData>
-  </Vcs>
-  <FiletypeAssociations>
-    <FiletypeAssociation pattern="*.ui" type="FORMS" />
-    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
-    <FiletypeAssociation pattern="*.qm" type="TRANSLATIONS" />
-    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
-    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
-    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
-    <FiletypeAssociation pattern="*.ts" type="TRANSLATIONS" />
-    <FiletypeAssociation pattern="*.py" type="SOURCES" />
-    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
-  </FiletypeAssociations>
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE Project SYSTEM "Project-4.6.dtd">
+<!-- eric4 project file for project Lockenwickler -->
+<!-- Saved: 2009-03-21, 13:56:34 -->
+<!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
+<Project version="4.6">
+  <Language>en</Language>
+  <ProgLanguage mixed="0">Python</ProgLanguage>
+  <ProjectType>Qt4</ProjectType>
+  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
+  <Version>0.1</Version>
+  <Author>Stefan Stammberger</Author>
+  <Email>sstammberger at web.de</Email>
+  <Sources>
+    <Source>src/Lockenwickler.py</Source>
+    <Source>src/ConsoleWindow.py</Source>
+    <Source>src/ModelSelectionDialog.py</Source>
+    <Source>src/ModuleManager.py</Source>
+    <Source>src/MovePivot.py</Source>
+    <Source>src/ObjectPropertyWin.py</Source>
+    <Source>src/OgreMainWindow.py</Source>
+    <Source>src/OgreWidget.py</Source>
+    <Source>src/PreferencesDialog.py</Source>
+    <Source>src/PythonOgreConfig.py</Source>
+    <Source>src/ui_ConsoleWindow.py</Source>
+    <Source>src/Property.py</Source>
+    <Source>src/ViewportGrid.py</Source>
+    <Source>src/ObjectPropertyModel.py</Source>
+    <Source>src/GameObjectClass.py</Source>
+    <Source>src/GameObjectClassManager.py</Source>
+    <Source>src/setup.py</Source>
+    <Source>src/GameObjectClassView.py</Source>
+    <Source>src/MyRaySceneQueryListener.py</Source>
+    <Source>src/GOStringEditor.py</Source>
+    <Source>src/GOIntEditor.py</Source>
+    <Source>src/NewModuleWizard.py</Source>
+    <Source>src/Ui_NewModuleWizard.py</Source>
+    <Source>src/ModuleExplorer.py</Source>
+    <Source>src/SelectionBuffer.py</Source>
+    <Source>src/MaterialSelectionDialog.py</Source>
+    <Source>src/DepthBuffer.py</Source>
+    <Source>src/ZoneManager.py</Source>
+  </Sources>
+  <Forms>
+    <Form>ui files/GOPropertyEditorDialogINT.ui</Form>
+    <Form>ui files/GOPropertyEditorDialogSTRING.ui</Form>
+    <Form>ui files/NewModuleWizard.ui</Form>
+  </Forms>
+  <Translations>
+  </Translations>
+  <Resources>
+  </Resources>
+  <Interfaces>
+  </Interfaces>
+  <Others>
+  </Others>
+  <MainScript>src/Lockenwickler.py</MainScript>
+  <Vcs>
+    <VcsType>Subversion</VcsType>
+    <VcsOptions>
+      <dict>
+        <key>
+          <string>add</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>checkout</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>commit</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>diff</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>export</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>global</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>history</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>log</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>remove</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>status</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>tag</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>update</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+      </dict>
+    </VcsOptions>
+    <VcsOtherData>
+      <dict>
+        <key>
+          <string>standardLayout</string>
+        </key>
+        <value>
+          <bool>True</bool>
+        </value>
+      </dict>
+    </VcsOtherData>
+  </Vcs>
+  <FiletypeAssociations>
+    <FiletypeAssociation pattern="*.ui" type="FORMS" />
+    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
+    <FiletypeAssociation pattern="*.qm" type="TRANSLATIONS" />
+    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
+    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
+    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
+    <FiletypeAssociation pattern="*.ts" type="TRANSLATIONS" />
+    <FiletypeAssociation pattern="*.py" type="SOURCES" />
+    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
+  </FiletypeAssociations>
 </Project>
\ No newline at end of file

Modified: rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE UserProject SYSTEM "UserProject-4.0.dtd">
 <!-- eric4 user project file for project Lockenwickler -->
-<!-- Saved: 2009-03-01, 22:49:19 -->
+<!-- Saved: 2009-03-20, 23:25:33 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <UserProject version="4.0">
 </UserProject>
\ No newline at end of file

Modified: rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Tasks SYSTEM "Tasks-4.2.dtd">
 <!-- eric4 tasks file for project Lockenwickler -->
-<!-- Saved: 2009-03-01, 22:49:19 -->
+<!-- Saved: 2009-03-20, 23:25:33 -->
 <Tasks version="4.2">
   <Task priority="1" completed="False" bugfix="False">
     <Summary>TODO: not implemented yet</Summary>
@@ -24,10 +24,10 @@
   <Task priority="1" completed="False" bugfix="False">
     <Summary>TODO: implement save here</Summary>
     <Description></Description>
-    <Created>2009-03-01, 21:50:14</Created>
+    <Created>2009-03-20, 23:24:53</Created>
     <Resource>
       <Filename>src/Lockenwickler.py</Filename>
-      <Linenumber>458</Linenumber>
+      <Linenumber>519</Linenumber>
     </Resource>
   </Task>
 </Tasks>
\ No newline at end of file

Deleted: rl/branches/persistence2/editors/Lockenwickler/src/CodeDump.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/CodeDump.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/CodeDump.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,86 +0,0 @@
-    #THIS IS A GENERAL CODE DUMB FOR DEPRECATED CODE
-
-
-    # parses the moduleconfig.rb and searches for all loader.loadmap(" statements in the ruby script
-    # and parses them too
-
-class old():
-
-
-
-    def setResourcePaths(self, path, moduleName):
-        for file in os.listdir(path):
-            curFile = path + "/" + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", moduleName, False)
-                self.setResourcePaths(curFile, moduleName)
-                continue
-            if isfile(curFile):
-                pass
-
-
-
-    def load(self,  moduleName,  mapFiles,  gofFiles):
-        self.moduleName = moduleName
-        self.mapFiles = mapFiles
-        self.gofFiles = gofFiles
-
-        self.gocManager.parseGOFFiles(self.gofFiles)
-
-        for a in self.mapFiles:
-            doc = xml.parse(a)
-            node = doc.getElementsByTagName("entity")
-            if node != None:
-                self.parseSceneNodes(node)
-
-        self.pivot = Pivot(self.sceneManager)
-        self.pivot.hide()
-
-    def parseSceneNodes(self,  nodeList):
-        for ent in nodeList:
-            entityName = ent.attributes["name"].nodeValue # get the name of the ent
-            meshFile = ent.attributes["meshfile"].nodeValue # meshfile
-            nodePosition = None
-            nodeRotation = None
-            nodeScale = None
-
-            for cn in ent.childNodes:
-                if cn.nodeType == cn.ELEMENT_NODE:
-                    if cn.localName == "position":
-                        px = float(cn.attributes["x"].nodeValue)
-                        py = float(cn.attributes["y"].nodeValue)
-                        pz = float(cn.attributes["z"].nodeValue)
-                        nodePosition = og.Vector3(px, py, pz)
-                        continue
-
-                    if cn.localName == "rotation":
-                        qw = float(cn.attributes["qw"].nodeValue)
-                        qx = float(cn.attributes["qx"].nodeValue)
-                        qy = float(cn.attributes["qy"].nodeValue)
-                        qz = float(cn.attributes["qz"].nodeValue)
-                        nodeRotation = og.Quaternion(qw,  qx, qy, qz)
-                        continue
-
-                    if cn.localName == "scale":
-                        px = float(cn.attributes["x"].nodeValue)
-                        py = float(cn.attributes["y"].nodeValue)
-                        pz = float(cn.attributes["z"].nodeValue)
-                        nodeScale = og.Vector3(px, py, pz)
-                        continue
-
-            try:
-                e = self.sceneManager.createEntity(entityName, meshFile)
-            except:
-                print "Warning: Meshfile " + meshFile + " could not be found."
-                return
-
-            n = self.sceneManager.getRootSceneNode().createChild(entityName + "_node")
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            #n.setOrientation(nodeRotation)
-            n.setScale(nodeScale)
-
-        pass

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ConsoleWindow.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ConsoleWindow.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ConsoleWindow.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 import sys

Copied: rl/branches/persistence2/editors/Lockenwickler/src/DepthBuffer.py (from rev 4878, rl/trunk/editors/Lockenwickler/src/DepthBuffer.py)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/GOIntEditor.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/GOIntEditor.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/GOIntEditor.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,4 +1,21 @@
-# -*- coding: utf-8 -*-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 """
 Module implementing GOIntEditor.

Modified: rl/branches/persistence2/editors/Lockenwickler/src/GOStringEditor.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/GOStringEditor.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/GOStringEditor.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,5 +1,21 @@
-# -*- coding: utf-8 -*-
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 """
 Module implementing GOStringEditor.
 """

Modified: rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,209 +1,210 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-#from elementtree.ElementTree import *
-from xml.etree.cElementTree import *
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-import ogre.renderer.OGRE as og
-
-from GOStringEditor import *
-from GOIntEditor import *
-
-class GOCStringProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "STRING"
-
-    def openEditor(self, row, parent = None):
-        dlg = GOStringEditor(parent)
-        dlg.nameEdit.setText(self.name)
-        dlg.dataEdit.setText(self.data)
-        result = dlg.exec_()
-        if result:
-            self.name = dlg.nameEdit.text()
-            self.data = dlg.dataEdit.toPlainText()
-
-        return result
-
-class GOCRealProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "REAL"
-
-    def openEditor(self, row, parent = None):
-        dlg = GOStringEditor(parent)
-        dlg.nameEdit.setText(self.name)
-        dlg.dataEdit.setText(self.data)
-        result = dlg.exec_()
-        if result:
-            self.name = dlg.nameEdit.text()
-            self.data = dlg.dataEdit.toPlainText()
-
-        return result
-
-class GOCBoolProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "BOOL"
-
-class GOCIntProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "INT"
-
-    def openEditor(self, row, parent = None):
-        dlg = GOIntEditor(parent)
-        dlg.nameEdit.setText(self.name)
-        dlg.dataEdit.setText(self.data)
-        result = dlg.exec_()
-        if result:
-            self.name = dlg.nameEdit.text()
-            self.data = dlg.dataEdit.toPlainText()
-
-        return result
-
-class GOCIntPairProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "INTPAIR"
-
-class GOCIntTripleProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "INTTRIPPLE"
-
-class GOCMapProperty():
-    def __init__(self, name):
-        self.name = name
-        self.childProperties = []
-
-    def getType(self):
-        return "MAP"
-
-# gameObjectClass is the id of the class itself
-# since a game object can be ingame more than once there is also a id for those
-class GameObjectRepresentation(og.UserDefinedObject):
-    def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
-        og.UserDefinedObject.__init__(self)
-        self.inWorldId = inWorldId
-        self.gocName = gameObjectClass
-        self.node = node
-        self.meshFile = meshFile
-        self.state = "IN_SCENE"
-
-    def getType(self):
-        return "GAME_OBJECT_REPRESENTATION"
-
-    def setPosition(self, pos):
-        self.node.setPosition(pos)
-
-
-class GameObjectClass():
-    def __init__(self,  parentElement):
-        self.classid = parentElement.get("classid")
-        self.baseclass = parentElement.get("baseclass")
-
-        self.meshFile = None
-
-        self.properties = []
-
-        for property in parentElement:#.getiterator("property"):
-            if property.get("type") == "ARRAY":
-                pass
-            elif property.get("type") == "MAP":
-                self.properties.append(self.createPropertyMap(property))
-            else:
-                self.properties.append(self.createProperty(property))
-
-    def getType(self):
-        return "GAME_OBJECT"
-
-    def createPropertyMap(self, property):
-        propMap = GOCMapProperty(property.get("name"))
-        for subProperty in property:
-            if subProperty.get("type") == "MAP":
-                propMap.childProperties.append(self.createPropertyMap(property))
-            else:
-                for subProperty1 in property:
-                    propMap.childProperties.append(self.createProperty(subProperty1))
-
-        return propMap
-
-    def getMeshFileName(self):
-        if self.meshFile is None:
-            for prop in self.properties:
-                if prop.getType() == "STRING":
-                    if prop.name == "meshfile":
-                        self.meshFile = prop.data
-                        return self.meshFile
-            return None
-        else:
-            return self.meshFile
-
-
-    def createProperty(self, property):
-        if property.get("type") == "STRING":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCStringProperty(name, data)
-        elif property.get("type") == "REAL":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCRealProperty(name, data)
-        elif property.get("type") == "BOOL":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCBoolProperty(name, data)
-        elif property.get("type") == "INT":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCIntProperty(name, data)
-        elif property.get("type") == "INTPAIR":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCIntPairProperty(name, data)
-        elif property.get("type") == "INTTRIPLE":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCIntTripleProperty(name, data)
-        else:
-            print property.get("type")
-
-
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+#from elementtree.ElementTree import *
+from xml.etree.cElementTree import *
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+import ogre.renderer.OGRE as og
+
+from GOStringEditor import *
+from GOIntEditor import *
+
+class GOCStringProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "STRING"
+
+    def openEditor(self, row, parent = None):
+        dlg = GOStringEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCRealProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "REAL"
+
+    def openEditor(self, row, parent = None):
+        dlg = GOStringEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCBoolProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "BOOL"
+
+class GOCIntProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "INT"
+
+    def openEditor(self, row, parent = None):
+        dlg = GOIntEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCIntPairProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "INTPAIR"
+
+class GOCIntTripleProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "INTTRIPPLE"
+
+class GOCMapProperty():
+    def __init__(self, name):
+        self.name = name
+        self.childProperties = []
+
+    def getType(self):
+        return "MAP"
+
+# gameObjectClass is the id of the class itself
+# since a game object can be ingame more than once there is also a id for those
+class GameObjectRepresentation(og.UserDefinedObject):
+    def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
+        og.UserDefinedObject.__init__(self)
+        self.inWorldId = inWorldId
+        self.gocName = str(gameObjectClass)
+        self.node = node
+        self.meshFile = meshFile
+        self.state = "IN_SCENE"
+
+    def getType(self):
+        return "GAME_OBJECT_REPRESENTATION"
+
+    def setPosition(self, pos):
+        self.node.setPosition(pos)
+
+
+class GameObjectClass():
+    def __init__(self,  parentElement):
+        self.classid = parentElement.get("classid")
+        self.baseclass = parentElement.get("baseclass")
+
+        self.meshFile = None
+
+        self.properties = []
+
+        for property in parentElement:#.getiterator("property"):
+            if property.get("type") == "ARRAY":
+                pass
+            elif property.get("type") == "MAP":
+                self.properties.append(self.createPropertyMap(property))
+            else:
+                self.properties.append(self.createProperty(property))
+
+    def getType(self):
+        return "GAME_OBJECT"
+
+    def createPropertyMap(self, property):
+        propMap = GOCMapProperty(property.get("name"))
+        for subProperty in property:
+            if subProperty.get("type") == "MAP":
+                propMap.childProperties.append(self.createPropertyMap(property))
+            else:
+                for subProperty1 in property:
+                    propMap.childProperties.append(self.createProperty(subProperty1))
+
+        return propMap
+
+    def getMeshFileName(self):
+        if self.meshFile is None:
+            for prop in self.properties:
+                if prop.getType() == "STRING":
+                    if prop.name == "meshfile":
+                        self.meshFile = prop.data
+                        return self.meshFile
+            return None
+        else:
+            return self.meshFile
+
+
+    def createProperty(self, property):
+        if property.get("type") == "STRING":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCStringProperty(name, data)
+        elif property.get("type") == "REAL":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCRealProperty(name, data)
+        elif property.get("type") == "BOOL":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCBoolProperty(name, data)
+        elif property.get("type") == "INT":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCIntProperty(name, data)
+        elif property.get("type") == "INTPAIR":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCIntPairProperty(name, data)
+        elif property.get("type") == "INTTRIPLE":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCIntTripleProperty(name, data)
+        else:
+            print property.get("type")
+
+
+

Modified: rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassManager.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassManager.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassManager.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,53 +1,69 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-#from elementtree.ElementTree import parse
-from xml.etree.cElementTree import parse
-
-from GameObjectClass import *
-
-class GameObjectClassManager():
-    def __init__(self):
-        self.fileDict = {}
-        self.callback = None
-
-    def parseGOFFiles(self, filePaths):
-        for filePath in filePaths:
-            tree = parse(filePath)
-            gocList = []
-            for parent in tree.getiterator("gameobjectclass"): # return all allements with the "gameobjectclass" tag
-                go = GameObjectClass(parent)
-                gocList.append(go)
-
-            self.fileDict[filePath] = gocList
-
-        if self.callback is not None:
-            self.callback(self.fileDict)
-
-    def getGameObjectWithClassId(self, id):
-        for key in self.fileDict:
-            for go in self.fileDict[key]:
-                if go.classid == id:
-                    return go
-
-        return None
-
-        # whenever a gameobject changes outside of the view, the view has to update itself wth the new values
-    def setGameObjectsViewUpdateCallback(self, callback):
-        self.callback = callback
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+#from elementtree.ElementTree import parse
+from xml.etree.cElementTree import parse
+
+from GameObjectClass import *
+
+class GameObjectClassManager():
+    def __init__(self):
+        self.fileDict = {}
+        self.callback = None
+
+        # we need to hold a reference to the game object representaions ourself
+        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
+        # and deletes the object
+        self.gameObjectRepresentationDict = []
+
+    def inWorldIdExists(self, id):
+        for rep in self.gameObjectRepresentationDict:
+            if str(rep.inWorldId) == str(id):
+                return True
+        
+        return False
+
+    def addGameObjectRepresentation(self, gocRep):
+        self.gameObjectRepresentationDict.append(gocRep)
+
+    def parseGOFFiles(self, filePaths):
+        for filePath in filePaths:
+            tree = parse(filePath)
+            gocList = []
+            for parent in tree.getiterator("gameobjectclass"): # return all allements with the "gameobjectclass" tag
+                go = GameObjectClass(parent)
+                gocList.append(go)
+
+            self.fileDict[filePath] = gocList
+
+        if self.callback is not None:
+            self.callback(self.fileDict)
+
+    def getGameObjectWithClassId(self, id):
+        for key in self.fileDict:
+            for go in self.fileDict[key]:
+                if go.classid == id:
+                    return go
+
+        return None
+
+        # whenever a gameobject changes outside of the view, the view has to update itself wth the new values
+    def setGameObjectsViewUpdateCallback(self, callback):
+        self.callback = callback
+

Modified: rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 from PyQt4.QtCore import *

Modified: rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,501 +1,551 @@
- #################################################
- #################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-sys.path.insert(0,'..')
-import PythonOgreConfig
-
-from random import randint
-
-from PyQt4 import QtGui, QtCore
-from PreferencesDialog import *
-from ObjectPropertyWin import *
-from ModelSelectionDialog import *
-from MaterialSelectionDialog import *
-from GameObjectClassView import *
-from ConsoleWindow import *
-from ModuleManager import *
-from ModuleExplorer import *
-from NewModuleWizard import *
-from PivotRenderQueueListener import *
-
-import OgreMainWindow
-import ogre.renderer.OGRE as og
-
-class Lockenwickler(QtGui.QMainWindow):
-    def __init__(self, parent=None):
-        QtGui.QWidget.__init__(self, parent)
-
-#        pixmap = QPixmap("media/icons/lockenwickler_provisorium.png")
-#        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
-#        splash.setMask(pixmap.mask())
-#        splash.showMessage("Starting...")
-#        splash.show()
-
-        self.setupUi()
-
-        self.consoleWindow = ConsoleWindow(False,  self)
-
-        self.setupOgre()
-
-        self.prefDialog = PreferencesDialog(self)
-        self.objectPropertyWin = ObjectPropertyWin(self.OgreMainWinSceneMgr, self)
-        self.moduleExplorerWin = ModuleExplorer(self)
-        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
-        self.materialSelectionDialog = MaterialSelectionDialog(self.ogreRoot, self)
-        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
-        self.moduleManager.materialSelectionDialog = self.materialSelectionDialog
-
-        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
-
-        self.createDockWindows()
-
-        self.mainTimer = QtCore.QTimer(self)
-        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL("timeout()"), self.update)
-        self.mainTimer.start(5)
-
-        settings = QtCore.QSettings()
-        self.restoreGeometry(settings.value("MainWindow/Geometry").toByteArray())
-        self.restoreState(settings.value("MainWindow/DockWindows").toByteArray())
-        if not self.prefDialog.setCfgPath(settings.value("Preferences/moduleCfgPath").toString()):
-            self.prefDialog.show()
-            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
-        else:
-            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
-        
-        self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
-        self.moduleManager.setPropertyWindow(self.objectPropertyWin)
-        
-        self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
-        self.setWindowTitle("Rastullahs Lockenwickler")
-        
-        self.editorSetupFinished = False
-        
-#        splash.finish(self)
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
-        action = QtGui.QAction(text, self)
-        if icon is not None:
-            action.setIcon(QtGui.QIcon("media/icons/%s" % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            self.connect(action, QtCore.SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
-
-    def addActions(self, target, actions):
-        for act in actions:
-            if act is None:
-               target.addSeparator()
-            else:
-                target.addAction(act)
-
-    def setupUi(self):
-        self.setObjectName("MainWindow")
-
-        self.centralwidget = QtGui.QWidget(self)
-        self.centralwidget.setObjectName("centralwidget")
-
-        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
-        self.hboxlayout.setObjectName("hboxlayout")
-
-        self.gridlayout = QtGui.QGridLayout()
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.menubar = QtGui.QMenuBar(self)
-        self.menubar.setObjectName("menubar")
-
-        self.menuFile = QtGui.QMenu(self.menubar)
-        self.menuFile.setObjectName("menuFile")
-
-        self.menuEdit = QtGui.QMenu(self.menubar)
-        self.menuEdit.setObjectName("menuEdit")
-
-        self.menuView = QtGui.QMenu(self.menubar)
-        self.menuView.setObjectName("menuView")
-        self.setMenuBar(self.menubar)
-
-
-        self.statusbar = QtGui.QStatusBar(self)
-        self.statusbar.setObjectName("statusbar")
-        self.setStatusBar(self.statusbar)
-
-#####################################
-        self.actionNeu =self.createAction("&New Module",  self.actionNewSlot,  QKeySequence.New,  "filenew.png",  "New Module")
-        self.actionNeu.setObjectName("actionNeu")
-
-        self.actionOpen = self.createAction("&Open Module",  self.actionOpenSlot,  QKeySequence.Open,  "fileopen.png",  "Open Module")
-        self.actionOpen.setObjectName("actionOpen")
-        
-        self.actionSave = self.createAction("&Save",  self.actionSaveSlot,  QKeySequence.Save,  "filesave.png",  "Save Module")
-        self.actionSave.setObjectName("actionSave")
-
-        self.actionClose = self.createAction("Quit",  self.actionQuitSlot,  "Alt + Q",  "exit.png",  "Quit")
-        self.actionClose.setObjectName("actionQuit")
-#####################################
-
-
-#####################################
-        self.actionDelete = self.createAction("Delete",  self.actionDeleteSlot,  QKeySequence.Delete,  "editdelete.png",  "Delete")
-        self.actionDelete.setObjectName("actionDelete")
-
-        self.actionCopy = self.createAction("Copy",  self.actionCopySlot,  QKeySequence.Copy,  "editcopy.png",  "Copy")
-        self.actionCopy.setObjectName("actionCopy")
-
-        self.actionCut = self.createAction("Cut",  self.actionCutSlot,  QKeySequence.Cut,  "editcut.png",  "Cut")
-        self.actionCut.setObjectName("actionCut")
-
-        self.actionPaste = self.createAction("Paste",  self.actionPasteSlot,  QKeySequence.Paste,  "editpaste.png",  "Paste")
-        self.actionPaste.setObjectName("actionPaste")
-
-        self.actionSelect = self.createAction("&Select",  self.actionSelectSlot,  "Space",  "cursor.png",  "Move selected object")
-        self.actionSelect.setObjectName("actionSelect")
-
-        self.actionMove = self.createAction("&Move",  self.actionMoveSlot,  "g",  "move.png",  "Move selected object")
-        self.actionMove.setObjectName("actionMove")
-
-        self.actionRotate = self.createAction("&Rotate",  self.actionRotateSlot,  "r",  "rotate.png",  "Rotate selected object")
-        self.actionRotate.setObjectName("actionRotate")
-
-        self.actionScale = self.createAction("&Scale",  self.actionScaleSlot,  "x",  "resizecol.png",  "Scale selected object")
-        self.actionScale.setObjectName("actionScale")
-
-        self.actionOneClickEntityPlacement = self.createAction("&OneClickEntityPlacement",  self.actionOneClickEntityPlacementSlot,  "",  "resizecol.png",  "Add an Entity just by a click")
-        self.actionOneClickEntityPlacement.setObjectName("actionOneClickEntityPlacement")
-        self.actionOneClickEntityPlacement.setCheckable(True)
-
-#####################################
-#####################################
-        self.actionSceneExplorer = self.createAction("&Scene Exlporer",  self.toggleModuleExplorer,  "Alt + E",  "view_tree.png",  "Module Explorer",  False)
-        self.actionSceneExplorer.setObjectName("actionSceneExplorer")
-        
-        self.actionPreferences = self.createAction("&Preferences",  self.togglePreferencesWindow,  "Alt + P",  "configure.png",  "Lockenwickler Preferences",  False)
-        self.actionPreferences.setObjectName("actionPreferences")
-
-        self.actionProperty_Window = self.createAction("Pr&operty Window",  self.togglePropertyWindow,  "Alt + P",  "unsortedlist1.png",  "Property Window")
-        self.actionProperty_Window.setObjectName("actionProperty_Window")
-
-        self.actionObject_Selection = self.createAction("&Model Preview Window",  self.toggleModelPreviewWindow,  "Alt + O",  "tux.png",  "Model Preview")
-        self.actionObject_Selection.setObjectName("actionObject_Selection")
-        
-        self.actionMaterial_Selection = self.createAction("Material &Preview Window",  self.toggleMaterialPreviewWindow,  "Alt + M",  "colors.png",  "Material Preview")
-        self.actionMaterial_Selection.setObjectName("actionMaterial_Selection")
-
-        self.actionGameObjectClass_Selection = self.createAction("&Game Object Class Preview Window",  self.toggleGameObjectViewWindow,  "Alt + G",  "multirow.png",  "GameObjectClass Preview")
-        self.actionGameObjectClass_Selection.setObjectName("actionObject_Selection")
-
-        self.actionConsole_Window = self.createAction("&Console Window",  self.toggleConsoleWindow,  "Alt + C",  "console.png",  "Console Window")
-        self.actionConsole_Window.setObjectName("actionConsole_Window")
-
-#####################################
-#####################################
-
-
-        self.menuFile.addAction(self.actionNeu)
-        self.menuFile.addAction(self.actionOpen)
-        self.menuFile.addAction(self.actionSave)
-        self.menuFile.addAction(self.actionClose)
-
-        self.menuEdit.addAction(self.actionSelect)
-        self.menuEdit.addAction(self.actionMove)
-        self.menuEdit.addAction(self.actionRotate)
-        self.menuEdit.addAction(self.actionScale)
-        self.menuEdit.addSeparator()
-        self.menuEdit.addAction(self.actionDelete)
-        self.menuEdit.addAction(self.actionCopy)
-        self.menuEdit.addAction(self.actionCut)
-        self.menuEdit.addAction(self.actionPaste)
-        self.menuEdit.addSeparator()
-        self.menuEdit.addAction(self.actionOneClickEntityPlacement)
-        
-
-        self.menuView.addAction(self.actionSceneExplorer)
-        self.menuView.addAction(self.actionPreferences)
-        self.menuView.addAction(self.actionProperty_Window)
-        self.menuView.addAction(self.actionObject_Selection)
-        self.menuView.addAction(self.actionMaterial_Selection)
-        self.menuView.addAction(self.actionGameObjectClass_Selection)
-        self.menuView.addAction(self.actionConsole_Window)
-        self.menubar.addAction(self.menuFile.menuAction())
-        self.menubar.addAction(self.menuEdit.menuAction())
-        self.menubar.addAction(self.menuView.menuAction())
-
-        self.retranslateUi()
-        QtCore.QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuEdit.setTitle(QtGui.QApplication.translate("MainWindow", "Edit", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "New Module", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionMove.setText(QtGui.QApplication.translate("MainWindow", "Move", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionRotate.setText(QtGui.QApplication.translate("MainWindow", "Rotate", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionSceneExplorer.setText(QtGui.QApplication.translate("MainWindow", "Module Explorer", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionClose.setText(QtGui.QApplication.translate("MainWindow", "Quit", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionConsole_Window.setText(QtGui.QApplication.translate("MainWindow", "Console Window", None, QtGui.QApplication.UnicodeUTF8))
-
-    def setupOgre(self, pluginCfgPath="./Plugins.cfg", ogreCfgPath="./ogre.cfg", logPath="./ogre.log"):
-        if platform.system() == "Windows":
-            pluginCfgPath="./Plugins-windows.cfg"
-        else:
-            pluginCfgPath="./Plugins-linux.cfg"
-
-        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
-        self.ogreRoot = root
-
-        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
-            sys.exit('Quit from Config Dialog')
-
-        root.initialise(False)
-
-        self.pivotRenderQueueListener = PivotRenderQueueListener()
-        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, "OgreMainWinSceneMgr")
-        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
-        self.OgreMainWinSceneMgr.addRenderQueueListener(self.pivotRenderQueueListener)
-
-        self.moduleName = ""
-        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
-
-        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
-        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
-        self.hboxlayout.addLayout(self.gridlayout)
-        self.setCentralWidget(self.centralwidget)
-        
-        oglog = og.LogManager.getSingleton().getDefaultLog()
-        oglog.addListener(self.consoleWindow.lockenLog)
-
-    def finishEditorSetup(self):
-        if not self.editorSetupFinished:
-            og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
-            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-            self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
-            self.moduleManager.pivot.hide()
-            self.editorSetupFinished = True
-        
-    def update(self):
-        self.ogreRoot.renderOneFrame()
-        if platform.system() == "Linux":
-            self.ogreMainWindow.updateRenderWindow()
-            self.modelSelectionDialog.updateRenderWindow()
-            self.materialSelectionDialog.updateRenderWindow()
-
-    def actionOpenSlot(self):
-        self.finishEditorSetup()
-        self.moduleManager.openLoadModuleDialog()
-
-    def actionNewSlot(self):
-        newModuleWiz = NewModuleWizard(self.moduleManager, self)
-        newModuleWiz.exec_()
-        return
-        
-    def actionSaveSlot(self):
-        self.moduleManager.save()
-        
-    def actionQuitSlot(self):
-        self.close()
-
-    def actionDeleteSlot(self):
-        self.moduleManager.deleteObjects()
-
-    def actionCopySlot(self):
-        self.moduleManager.copyObjects()
-
-    def actionCutSlot(self):
-        self.moduleManager.cutObjects()
-
-    def actionPasteSlot(self):
-        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
-
-    def actionSelectSlot(self):
-        self.moduleManager.pivot.hide()
-
-    def actionMoveSlot(self):
-        self.moduleManager.pivot.setMoveMode()
-
-    def actionRotateSlot(self):
-        self.moduleManager.pivot.setRotateMode()
-
-    def actionScaleSlot(self):
-        self.moduleManager.pivot.setScaleMode()
-
-    def actionOneClickEntityPlacementSlot(self):
-        self.moduleManager.setOneClickEntityPlacement(self.actionOneClickEntityPlacement.isChecked())
-
-    def togglePreferencesWindow(self):
-        if self.prefDialog.isHidden():
-            self.prefDialog.show()
-        else:
-            self.prefDialog.hide()
-
-    def toggleModelPreviewWindow(self):
-        if self.modelSelectionDock.isHidden():
-            self.modelSelectionDock.show()
-        else:
-            self.modelSelectionDock.hide()
-    
-    def toggleMaterialPreviewWindow(self):
-        if self.materialSelectionDock.isHidden():
-            self.materialSelectionDock.show()
-        else:
-            self.materialSelectionDock.hide()
-
-    def toggleGameObjectViewWindow(self):
-        if self.gameObjectClassViewDock.isHidden():
-            self.gameObjectClassViewDock.show()
-        else:
-            self.gameObjectClassViewDock.hide()
-
-    def toggleModuleExplorer(self):
-        if self.moduleExplorerDock.isHidden():
-            self.moduleExplorerDock.show()
-        else:
-            self.moduleExplorerDock.hide()
-
-    def togglePropertyWindow(self):
-        if self.propertyDock.isHidden():
-            self.propertyDock.show()
-        else:
-            self.propertyDock.hide()
-
-    def toggleConsoleWindow(self):
-        if self.consoleDock.isHidden():
-            self.consoleDock.show()
-        else:
-            self.consoleDock.hide()
-
-    def createDockWindows(self):
-        self.propertyDock = QtGui.QDockWidget(self.tr("Properties"), self)
-        self.propertyDock.setObjectName("PropertyDockWindow")
-        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.propertyDock.setWidget(self.objectPropertyWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
-
-        self.modelSelectionDock = QtGui.QDockWidget(self.tr("Models"), self)
-        self.modelSelectionDock.setObjectName("ModelSelectionDockWindow")
-        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
-        
-        self.materialSelectionDock = QtGui.QDockWidget(self.tr("Materials"), self)
-        self.materialSelectionDock.setObjectName("MaterialSelectionDockWindow")
-        self.materialSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.materialSelectionDock.setWidget(self.materialSelectionDialog)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.materialSelectionDock)
-
-        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr("GameObjectClasses"), self)
-        self.gameObjectClassViewDock.setObjectName("GameObjectClassView")
-        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
-
-        self.moduleExplorerDock = QtGui.QDockWidget(self.tr("Module Explorer"), self)
-        self.moduleExplorerDock.setObjectName("ModuleExplorerDockWindow")
-        self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
-
-        self.consoleDock = QtGui.QDockWidget(self.tr("Console"), self)
-        self.consoleDock.setObjectName("ConsoleDockWindow")
-        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
-        self.consoleDock.setWidget(self.consoleWindow)
-        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
-
-        self.fileToolBar = self.addToolBar("File Toolbar")
-        self.fileToolBar.setObjectName("FileToolBar")
-        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.fileToolBar.addAction(self.actionNeu)
-        self.fileToolBar.addAction(self.actionOpen)
-        self.fileToolBar.addAction(self.actionSave)
-        self.fileToolBar.addAction(self.actionClose)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
-
-        self.moveToolBar = self.addToolBar("Transformation Bar")
-        self.moveToolBar.setObjectName("TransformationBar")
-        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.moveToolBar.addAction(self.actionSelect)
-        self.moveToolBar.addAction(self.actionMove)
-        self.moveToolBar.addAction(self.actionRotate)
-        self.moveToolBar.addAction(self.actionScale)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
-
-    def keyPressEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreMainWindow.keyPressEvent(event)
-
-    def keyReleaseEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreMainWindow.keyReleaseEvent(event)
-        pass
-
-    def connectActionButtons(self):
-        pass
-
-    def saveOnClose(self):
-        reply = QtGui.QMessageBox.question(self,  "Rastullahs Lockenwickler - Unsaved Chages",  "Save unsaved changes?",  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
-        if reply == QtGui.QMessageBox.Cancel:
-            return False
-        if reply == QtGui.QMessageBox.Yes:
-            print""
-            #TODO: implement save here
-        return True
-
-    def closeEvent(self,  event):
-        if self.saveOnClose():
-            settings = QtCore.QSettings()
-            settings.setValue("Preferences/moduleCfgPath", QtCore.QVariant(self.prefDialog.lineEdit.text()))
-            settings.setValue("MainWindow/Geometry",  QtCore.QVariant(self.saveGeometry()))
-            settings.setValue("MainWIndow/DockWindows",  QtCore.QVariant(self.saveState()))
-        else:
-            event.ignore()
-
-if __name__ == "__main__":
-#    # Import Psyco if available
-#    try:
-##        import psyco
-##        psyco.full(0.02)
-#        #psyco.log()
-#        #psyco.profile()
-#    except ImportError:
-#        pass
-    
-    app = QtGui.QApplication(sys.argv)
-    app.setOrganizationName("Team Pantheon")
-    app.setOrganizationDomain("rastullahs-lockenpracht.de/team")
-    app.setApplicationName("Lockenwickler")
-
-    form = Lockenwickler()
-    form.show()
-
-    sys.exit(app.exec_())
-
+#################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import os
+import sys
+import platform
+import subprocess
+
+sys.path.insert(0,'..')
+import PythonOgreConfig
+
+from random import randint
+
+from PyQt4 import QtGui, QtCore
+from PreferencesDialog import *
+from ObjectPropertyWin import *
+from ModelSelectionDialog import *
+from MaterialSelectionDialog import *
+from GameObjectClassView import *
+from ConsoleWindow import *
+from ModuleManager import ModuleManager
+from ModuleExplorer import *
+from NewModuleWizard import *
+from MovePivot import *
+from PivotRenderQueueListener import *
+
+import OgreMainWindow
+import ogre.renderer.OGRE as og
+
+class Lockenwickler(QtGui.QMainWindow):
+    def __init__(self, parent=None):
+        QtGui.QWidget.__init__(self, parent)
+
+#        pixmap = QPixmap("media/icons/lockenwickler_provisorium.png")
+#        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
+#        splash.setMask(pixmap.mask())
+#        splash.showMessage("Starting...")
+#        splash.show() 
+
+        self.setupUi()
+
+        self.consoleWindow = ConsoleWindow(False,  self)
+
+        self.setupOgre()
+
+        self.prefDialog = PreferencesDialog(self)
+        self.objectPropertyWin = ObjectPropertyWin(self.OgreMainWinSceneMgr, self.gocManager, self)
+        self.moduleExplorerWin = ModuleExplorer(self)
+        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        self.materialSelectionDialog = MaterialSelectionDialog(self.ogreRoot, self)
+        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
+        self.moduleManager.materialSelectionDialog = self.materialSelectionDialog
+
+        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
+
+        self.createDockWindows()
+
+        self.mainTimer = QtCore.QTimer(self)
+        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL("timeout()"), self.update)
+        self.mainTimer.start(5)
+
+        settings = QtCore.QSettings()
+        self.restoreGeometry(settings.value("MainWindow/Geometry").toByteArray())
+        self.restoreState(settings.value("MainWindow/DockWindows").toByteArray())
+        if not self.prefDialog.setCfgPath(settings.value("Preferences/moduleCfgPath").toString()):
+            self.prefDialog.show()
+            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        else:
+            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        
+        self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
+        self.moduleManager.setPropertyWindow(self.objectPropertyWin)
+        self.moduleManager.setContextMenuCallback(self.onContextMenuCallback)
+        
+        self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
+        self.setWindowTitle("Rastullahs Lockenwickler")
+        
+        self.editorSetupFinished = False
+        
+#        splash.finish(self)
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QtGui.QAction(text, self)
+        if icon is not None:
+            action.setIcon(QtGui.QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            self.connect(action, QtCore.SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+
+    def addActions(self, target, actions):
+        for act in actions:
+            if act is None:
+               target.addSeparator()
+            else:
+                target.addAction(act)
+
+    def setupUi(self):
+        self.setObjectName("MainWindow")
+
+        self.centralwidget = QtGui.QWidget(self)
+        self.centralwidget.setObjectName("centralwidget")
+
+        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
+        self.hboxlayout.setContentsMargins(0, 0, 0, 0)
+        self.hboxlayout.setObjectName("hboxlayout")
+
+        self.gridlayout = QtGui.QGridLayout()
+        self.gridlayout.setObjectName("gridlayout")
+        self.gridlayout.setContentsMargins(0, 0, 0, 0)
+        
+        self.menubar = QtGui.QMenuBar(self)
+        self.menubar.setObjectName("menubar")
+
+        self.menuFile = QtGui.QMenu(self.menubar)
+        self.menuFile.setObjectName("menuFile")
+
+        self.menuEdit = QtGui.QMenu(self.menubar)
+        self.menuEdit.setObjectName("menuEdit")
+
+        self.menuView = QtGui.QMenu(self.menubar)
+        self.menuView.setObjectName("menuView")
+        self.setMenuBar(self.menubar)
+
+
+        self.statusbar = QtGui.QStatusBar(self)
+        self.statusbar.setObjectName("statusbar")
+        self.setStatusBar(self.statusbar)
+
+#####################################
+        self.actionNeu =self.createAction("&New Module",  self.actionNewSlot,  QKeySequence.New,  "filenew.png",  "New Module")
+        self.actionNeu.setObjectName("actionNeu")
+
+        self.actionOpen = self.createAction("&Open Module",  self.actionOpenSlot,  QKeySequence.Open,  "fileopen.png",  "Open Module")
+        self.actionOpen.setObjectName("actionOpen")
+        
+        self.actionSave = self.createAction("&Save",  self.actionSaveSlot,  QKeySequence.Save,  "filesave.png",  "Save Module")
+        self.actionSave.setObjectName("actionSave")
+        
+        self.actionRunModule = self.createAction("&Save and Run",  self.actionRunModuleSlot,  "Alt+R",  "fileexport.png",  "Save And Run Module")
+        self.actionRunModule.setObjectName("actionRunModule")
+
+        self.actionClose = self.createAction("Quit",  self.actionQuitSlot,  "Alt+Q",  "exit.png",  "Quit")
+        self.actionClose.setObjectName("actionQuit")
+#####################################
+
+
+#####################################
+        self.actionDelete = self.createAction("Delete",  self.actionDeleteSlot,  QKeySequence.Delete,  "editdelete.png",  "Delete")
+        self.actionDelete.setObjectName("actionDelete")
+
+        self.actionCopy = self.createAction("Copy",  self.actionCopySlot,  QKeySequence.Copy,  "editcopy.png",  "Copy")
+        self.actionCopy.setObjectName("actionCopy")
+
+        self.actionCut = self.createAction("Cut",  self.actionCutSlot,  QKeySequence.Cut,  "editcut.png",  "Cut")
+        self.actionCut.setObjectName("actionCut")
+
+        self.actionPaste = self.createAction("Paste",  self.actionPasteSlot,  QKeySequence.Paste,  "editpaste.png",  "Paste")
+        self.actionPaste.setObjectName("actionPaste")
+
+        self.actionSelect = self.createAction("&Select",  self.actionSelectSlot,  "Space",  "cursor.png",  "Move selected object")
+        self.actionSelect.setObjectName("actionSelect")
+
+        self.actionMove = self.createAction("&Move",  self.actionMoveSlot,  "g",  "move.png",  "Move selected object")
+        self.actionMove.setObjectName("actionMove")
+
+        self.actionRotate = self.createAction("&Rotate",  self.actionRotateSlot,  "r",  "rotate.png",  "Rotate selected object")
+        self.actionRotate.setObjectName("actionRotate")
+
+        self.actionScale = self.createAction("&Scale",  self.actionScaleSlot,  "x",  "resizecol.png",  "Scale selected object")
+        self.actionScale.setObjectName("actionScale")
+
+        self.actionOneClickEntityPlacement = self.createAction("&OneClickEntityPlacement",  self.actionOneClickEntityPlacementSlot,  "",  "resizecol.png",  "Add an Entity just by a click")
+        self.actionOneClickEntityPlacement.setObjectName("actionOneClickEntityPlacement")
+        self.actionOneClickEntityPlacement.setCheckable(True)
+
+#####################################
+#####################################
+        self.actionSceneExplorer = self.createAction("&Scene Exlporer",  self.toggleModuleExplorer,  "Alt+E",  "view_tree.png",  "Module Explorer",  False)
+        self.actionSceneExplorer.setObjectName("actionSceneExplorer")
+        
+        self.actionPreferences = self.createAction("&Preferences",  self.togglePreferencesWindow,  "Alt+P",  "configure.png",  "Lockenwickler Preferences",  False)
+        self.actionPreferences.setObjectName("actionPreferences")
+
+        self.actionProperty_Window = self.createAction("Pr&operty Window",  self.togglePropertyWindow,  "Alt+P",  "unsortedlist1.png",  "Property Window")
+        self.actionProperty_Window.setObjectName("actionProperty_Window")
+
+        self.actionObject_Selection = self.createAction("&Model Preview Window",  self.toggleModelPreviewWindow,  "Alt+O",  "tux.png",  "Model Preview")
+        self.actionObject_Selection.setObjectName("actionObject_Selection")
+        
+        self.actionMaterial_Selection = self.createAction("Material &Preview Window",  self.toggleMaterialPreviewWindow,  "Alt+M",  "colors.png",  "Material Preview")
+        self.actionMaterial_Selection.setObjectName("actionMaterial_Selection")
+
+        self.actionGameObjectClass_Selection = self.createAction("&Game Object Class Preview Window",  self.toggleGameObjectViewWindow,  "Ctrl+G",  "multirow.png",  "GameObjectClass Preview")
+        self.actionGameObjectClass_Selection.setObjectName("actionObject_Selection")
+
+        self.actionConsole_Window = self.createAction("&Console Window",  self.toggleConsoleWindow,  "Alt+C",  "console.png",  "Console Window")
+        self.actionConsole_Window.setObjectName("actionConsole_Window")
+        
+        self.actionToggleViewportGrid = self.createAction("&Toggle Grid",  self.toggleViewportGrid,  "Alt+G",  "console.png",  "Toggle Viewport Grid")
+        self.actionToggleViewportGrid.setObjectName("actionToggleViewportGrid")
+
+#####################################
+#####################################
+
+
+        self.menuFile.addAction(self.actionNeu)
+        self.menuFile.addAction(self.actionOpen)
+        self.menuFile.addAction(self.actionSave)
+        self.menuFile.addAction(self.actionRunModule)
+        self.menuFile.addAction(self.actionClose)
+
+        self.menuEdit.addAction(self.actionSelect)
+        self.menuEdit.addAction(self.actionMove)
+        self.menuEdit.addAction(self.actionRotate)
+        self.menuEdit.addAction(self.actionScale)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionDelete)
+        self.menuEdit.addAction(self.actionCopy)
+        self.menuEdit.addAction(self.actionCut)
+        self.menuEdit.addAction(self.actionPaste)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionOneClickEntityPlacement)
+        
+
+        self.menuView.addAction(self.actionSceneExplorer)
+        self.menuView.addAction(self.actionPreferences)
+        self.menuView.addAction(self.actionProperty_Window)
+        self.menuView.addAction(self.actionObject_Selection)
+        self.menuView.addAction(self.actionMaterial_Selection)
+        self.menuView.addAction(self.actionGameObjectClass_Selection)
+        self.menuView.addAction(self.actionConsole_Window)
+        self.menuView.addAction(self.actionToggleViewportGrid)
+        
+        self.menubar.addAction(self.menuFile.menuAction())
+        self.menubar.addAction(self.menuEdit.menuAction())
+        self.menubar.addAction(self.menuView.menuAction())
+
+        self.retranslateUi()
+        QtCore.QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuEdit.setTitle(QtGui.QApplication.translate("MainWindow", "Edit", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "New Module", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionMove.setText(QtGui.QApplication.translate("MainWindow", "Move", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionRotate.setText(QtGui.QApplication.translate("MainWindow", "Rotate", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionSceneExplorer.setText(QtGui.QApplication.translate("MainWindow", "Module Explorer", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionClose.setText(QtGui.QApplication.translate("MainWindow", "Quit", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionConsole_Window.setText(QtGui.QApplication.translate("MainWindow", "Console Window", None, QtGui.QApplication.UnicodeUTF8))
+
+    def setupOgre(self, pluginCfgPath="./Plugins.cfg", ogreCfgPath="./ogre.cfg", logPath="./ogre.log"):
+        if platform.system() == "Windows":
+            pluginCfgPath="./Plugins-windows.cfg"
+        else:
+            pluginCfgPath="./Plugins-linux.cfg"
+
+        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
+        self.ogreRoot = root
+
+        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
+            sys.exit('Quit from Config Dialog')
+
+        root.initialise(False)
+
+        self.pivotRenderQueueListener = PivotRenderQueueListener()
+        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, "OgreMainWinSceneMgr")
+        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
+        self.OgreMainWinSceneMgr.addRenderQueueListener(self.pivotRenderQueueListener)
+        
+        self.moduleName = ""
+        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
+        self.gocManager = self.moduleManager.gocManager
+        
+        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
+        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
+        self.hboxlayout.addLayout(self.gridlayout)
+        self.setCentralWidget(self.centralwidget)
+        
+        oglog = og.LogManager.getSingleton().getDefaultLog()
+        oglog.addListener(self.consoleWindow.lockenLog)
+
+    def finishEditorSetup(self):
+        if not self.editorSetupFinished:
+            og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+            self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
+            self.moduleManager.pivot.hide()
+            self.editorSetupFinished = True
+        
+    def update(self):
+        self.ogreRoot.renderOneFrame()
+        if platform.system() == "Linux":
+            self.ogreMainWindow.updateRenderWindow()
+            self.modelSelectionDialog.updateRenderWindow()
+            self.materialSelectionDialog.updateRenderWindow()
+
+    def actionOpenSlot(self):
+        self.finishEditorSetup()
+        self.moduleManager.openLoadModuleDialog()
+
+    def actionNewSlot(self):
+        newModuleWiz = NewModuleWizard(self.moduleManager, self)
+        newModuleWiz.exec_()
+        return
+        
+    def actionSaveSlot(self):
+        self.moduleManager.save()
+        
+    def actionRunModuleSlot(self):
+        self.moduleManager.save()
+        if platform.system() == "Windows":
+            workingDir = self.prefDialog.moduleCfgPath.replace("/modules/modules.cfg", "")
+            executable = os.path.join(workingDir, "Rastullah.exe")
+            executable = executable.replace("/",  "\\")
+            if os.path.isfile(executable):
+                subprocess.Popen([executable, "--module", self.moduleManager.mainModule.name], 0, None, None, None, None, None, False, False, workingDir)
+
+        
+    def actionQuitSlot(self):
+        self.close()
+
+    def actionDeleteSlot(self):
+        self.moduleManager.deleteObjects()
+
+    def actionCopySlot(self):
+        self.moduleManager.copyObjects()
+
+    def actionCutSlot(self):
+        self.moduleManager.cutObjects()
+
+    def actionPasteSlot(self):
+        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
+
+    def actionSelectSlot(self):
+        self.moduleManager.pivot.hide()
+
+    def actionMoveSlot(self):
+        self.moduleManager.pivot.setMoveMode()
+
+    def actionRotateSlot(self):
+        self.moduleManager.pivot.setRotateMode()
+
+    def actionScaleSlot(self):
+        self.moduleManager.pivot.setScaleMode()
+
+    def actionOneClickEntityPlacementSlot(self):
+        self.moduleManager.setOneClickEntityPlacement(self.actionOneClickEntityPlacement.isChecked())
+
+    def togglePreferencesWindow(self):
+        if self.prefDialog.isHidden():
+            self.prefDialog.show()
+        else:
+            self.prefDialog.hide()
+
+    def toggleModelPreviewWindow(self):
+        if self.modelSelectionDock.isHidden():
+            self.modelSelectionDock.show()
+        else:
+            self.modelSelectionDock.hide()
+    
+    def toggleMaterialPreviewWindow(self):
+        if self.materialSelectionDock.isHidden():
+            self.materialSelectionDock.show()
+        else:
+            self.materialSelectionDock.hide()
+
+    def toggleGameObjectViewWindow(self):
+        if self.gameObjectClassViewDock.isHidden():
+            self.gameObjectClassViewDock.show()
+        else:
+            self.gameObjectClassViewDock.hide()
+
+    def toggleModuleExplorer(self):
+        if self.moduleExplorerDock.isHidden():
+            self.moduleExplorerDock.show()
+        else:
+            self.moduleExplorerDock.hide()
+
+    def togglePropertyWindow(self):
+        if self.propertyDock.isHidden():
+            self.propertyDock.show()
+        else:
+            self.propertyDock.hide()
+
+    def toggleConsoleWindow(self):
+        if self.consoleDock.isHidden():
+            self.consoleDock.show()
+        else:
+            self.consoleDock.hide()
+
+    def toggleViewportGrid(self):
+        self.ogreMainWindow.toggleViewportGrid()
+
+    def createDockWindows(self):
+        self.modelSelectionDock = QtGui.QDockWidget(self.tr("Models"), self)
+        self.modelSelectionDock.setObjectName("ModelSelectionDockWindow")
+        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
+        
+        self.materialSelectionDock = QtGui.QDockWidget(self.tr("Materials"), self)
+        self.materialSelectionDock.setObjectName("MaterialSelectionDockWindow")
+        self.materialSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.materialSelectionDock.setWidget(self.materialSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.materialSelectionDock)
+        self.tabifyDockWidget(self.modelSelectionDock, self.materialSelectionDock)
+        
+        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr("GameObjectClasses"), self)
+        self.gameObjectClassViewDock.setObjectName("GameObjectClassView")
+        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)        
+        self.tabifyDockWidget(self.modelSelectionDock, self.gameObjectClassViewDock)
+        
+        self.propertyDock = QtGui.QDockWidget(self.tr("Properties"), self)
+        self.propertyDock.setObjectName("PropertyDockWindow")
+        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.propertyDock.setWidget(self.objectPropertyWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
+
+        self.moduleExplorerDock = QtGui.QDockWidget(self.tr("Module Explorer"), self)
+        self.moduleExplorerDock.setObjectName("ModuleExplorerDockWindow")
+        self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
+        self.tabifyDockWidget(self.moduleExplorerDock, self.propertyDock)
+        
+        self.consoleDock = QtGui.QDockWidget(self.tr("Console"), self)
+        self.consoleDock.setObjectName("ConsoleDockWindow")
+        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
+        self.consoleDock.setWidget(self.consoleWindow)
+        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
+
+        self.fileToolBar = self.addToolBar("File Toolbar")
+        self.fileToolBar.setObjectName("FileToolBar")
+        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.fileToolBar.addAction(self.actionNeu)
+        self.fileToolBar.addAction(self.actionOpen)
+        self.fileToolBar.addAction(self.actionSave)
+        self.fileToolBar.addAction(self.actionRunModule)
+        self.fileToolBar.addAction(self.actionClose)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
+
+        self.moveToolBar = self.addToolBar("Transformation Bar")
+        self.moveToolBar.setObjectName("TransformationBar")
+        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.moveToolBar.addAction(self.actionSelect)
+        self.moveToolBar.addAction(self.actionMove)
+        self.moveToolBar.addAction(self.actionRotate)
+        self.moveToolBar.addAction(self.actionScale)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
+
+    def keyPressEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreMainWindow.keyPressEvent(event)
+
+    def keyReleaseEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreMainWindow.keyReleaseEvent(event)
+        pass
+
+    def onContextMenuCallback(self, actions, menus):
+        menu = QMenu("My Menu!!")
+        menu.addAction(self.actionDelete)
+        menu.addAction(self.actionCopy)
+        menu.addAction(self.actionCut)
+        menu.addAction(self.actionPaste)
+        menu.addSeparator()
+        
+        for m in menus:
+            menu.addMenu(m)
+        for a in actions:
+            menu.addAction(a)
+
+        menu.exec_(QCursor.pos())
+
+    def connectActionButtons(self):
+        pass
+
+    def saveOnClose(self):
+#        reply = QtGui.QMessageBox.question(self,  "Rastullahs Lockenwickler - Unsaved Chages",  "Save unsaved changes?",  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
+#        if reply == QtGui.QMessageBox.Cancel:
+#            return False
+#        if reply == QtGui.QMessageBox.Yes:
+#            print""
+#            #TODO: implement save here
+        return True
+
+    def closeEvent(self,  event):
+        if self.saveOnClose():
+            settings = QtCore.QSettings()
+            settings.setValue("Preferences/moduleCfgPath", QtCore.QVariant(self.prefDialog.lineEdit.text()))
+            settings.setValue("MainWindow/Geometry",  QtCore.QVariant(self.saveGeometry()))
+            settings.setValue("MainWIndow/DockWindows",  QtCore.QVariant(self.saveState()))
+            
+            #self.ogreRoot.shutdown()
+        else:
+            event.ignore()
+
+if __name__ == "__main__":
+#    # Import Psyco if available
+#    try:
+#        import psyco
+#        psyco.full(0.02)
+#        #psyco.log()
+#        #psyco.profile()
+#    except ImportError:
+#        pass
+    
+    app = QtGui.QApplication(sys.argv)
+    app.setOrganizationName("Team Pantheon")
+    app.setOrganizationDomain("rastullahs-lockenpracht.de/team")
+    app.setApplicationName("Lockenwickler")
+
+    form = Lockenwickler()
+    form.show()
+
+    app.exec_()
+    
+    sys.exit(0)
+

Modified: rl/branches/persistence2/editors/Lockenwickler/src/MaterialSelectionDialog.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/MaterialSelectionDialog.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/MaterialSelectionDialog.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,185 +1,187 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import os
-from os.path import isdir
-from os.path import isfile
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# The drag events are processed in ObgreMainWindow.py
-
-class MaterialListWidget(QListWidget):
-    def __init__(self,  parent):
-        super(MaterialListWidget, self).__init__(parent)
-        self.setDragEnabled(True)
-
-    def startDrag(self,  dropActions):
-        data = QByteArray()
-        stream = QDataStream(data,  QIODevice.WriteOnly)
-        stream << self.currentItem().text()
-        mimeData = QMimeData()
-        mimeData.setData("application/x-material", data)
-        drag = QDrag(self)
-        drag.setMimeData(mimeData)
-        drag.start(Qt.CopyAction)
-
-class MaterialSelectionDialog(QDialog):
-    def __init__(self, ogreRoot, parent=None):
-        QDialog.__init__(self, parent)
-        self.ogreRoot = ogreRoot
-
-        self.setupUi()
-
-        self.connect(self.materialSearchBox, SIGNAL("textChanged(QString)"),
-                               self.updateMaterialList)
-
-        self.connect(self.listWidget, SIGNAL("itemSelectionChanged ()"),
-                               self.setPreviewedMaterial)
-
-        self.materialList = []
-
-        self.ogreMaterialPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
-
-        self.node = self.ogreMaterialPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
-        self.ent = None
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-
-
-    def setupUi(self):
-        self.setObjectName("materialPreviewDialog")
-        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(self)
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.materialSearchBox = QLineEdit(self)
-        self.materialSearchBox.setObjectName("materialSearchBox")
-        self.gridlayout.addWidget(self.materialSearchBox,0,0,1,1)
-
-        self.splitter = QSplitter(self)
-        self.splitter.setOrientation(Qt.Vertical)
-        self.splitter.setObjectName("splitter")
-
-        self.listWidget = MaterialListWidget(self.splitter)
-        self.listWidget.setObjectName("listWidget")
-
-        self.ogreMaterialPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,"ogreMaterialPrevWindowSceneMgr")
-        self.ogreMaterialPrevWindow = OgreWidget.OgreWidget("MaterialPrevWin", self.ogreRoot, self.ogreMaterialPrevWindowSceneMgr, "MaterialPrevCam",
-                                                         self.splitter)
-        self.ogreMaterialPrevWindow.setBackgroundColor(og.ColourValue(1.0, 1.0, 1.0, 1.0))
-        self.ogreMaterialPrevWindow.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)                                                 
-        
-        
-        self.ogreMaterialPrevWindow.setMinimumSize(QSize(200,200))
-        self.ogreMaterialPrevWindow.setObjectName("materialPreviewWindow")
-        self.gridlayout.addWidget(self.splitter,1,0,1,1)
-
-        self.retranslateUi()
-
-    def ogreViewportCreatedCallback(self):
-        self.ogreMaterialPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
-        
-    def retranslateUi(self):
-        self.setWindowTitle(QApplication.translate("materialPreviewDialog", "Dialog", None, QApplication.UnicodeUTF8))
-
-    def setPreviewedMaterial(self):
-        if self.ent == None:
-            self.ent = self.ogreMaterialPrevWindowSceneMgr.createEntity("MaterialPrevEntity9993944", "UniCube.mesh")
-            self.nodeScale = og.Vector3(1,1,1)
-
-            self.node.attachObject(self.ent)
-            self.node.setScale(og.Vector3(6,6,6))
-        self.ent.setMaterialName(str(self.listWidget.currentItem().text()))
-
-    def scanDirForMaterials(self, dir):
-        for file in os.listdir(dir):
-            curFile = dir + "/" + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if isdir(curFile):
-                self.scanDirForMaterials(curFile)
-                continue
-            if isfile(curFile):
-                if file.endswith(".material"):
-                    f = open(curFile, "r")
-                    for line in f:
-                        if line.startswith("material "):
-                            l = line.replace("material ", "").lstrip().rstrip()
-                            l2 = l.split(":")
-                            self.materialList.append(l2[0])
-                            self.listWidget.addItem(l2[0])
-                        
-                    f.close()
-        self.listWidget.sortItems()
-
-    def updateMaterialList(self, text):
-        self.listWidget.clear()
-        for material in self.materialList:
-            if material.find(text) != -1:
-               self.listWidget.addItem(material)
-
-        self.listWidget.sortItems()
-
-    def eventFilter(self, obj, event):
-        if event.type() == 5:
-            self.startDrag()
-            event.accept()
-            return True
-
-        return False
-
-    def event(self, event):
-        if event.type() == 31: # scroll wheel turned
-            if event.delta() < 0:
-                self.ogreMaterialPrevWindow.zoomCamera(-5)
-            else:
-                self.ogreMaterialPrevWindow.zoomCamera( 5)
-            return True
-
-        if event.type() == 5: #mouse moved while button down
-            rotX = (event.globalX() - self.lastMousePosX) * 0.01
-            rotY = (event.globalY() - self.lastMousePosY) * 0.01
-
-            if rotX < 0.1 and rotY < 0.1: # first click, don't do anything at all here
-                self.ogreMaterialPrevWindow.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-            return True
-
-        if event.type() == 3: # mouse released
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-            return True
-
-        return False
-
-    def updateRenderWindow(self):
-        self.ogreMaterialPrevWindow.update()
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+
+import sys
+import os
+from os.path import isdir
+from os.path import isfile
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# The drag events are processed in ObgreMainWindow.py
+
+class MaterialListWidget(QListWidget):
+    def __init__(self,  parent):
+        super(MaterialListWidget, self).__init__(parent)
+        self.setDragEnabled(True)
+
+    def startDrag(self,  dropActions):
+        data = QByteArray()
+        stream = QDataStream(data,  QIODevice.WriteOnly)
+        stream << self.currentItem().text()
+        mimeData = QMimeData()
+        mimeData.setData("application/x-material", data)
+        drag = QDrag(self)
+        drag.setMimeData(mimeData)
+        drag.start(Qt.CopyAction)
+
+class MaterialSelectionDialog(QDialog):
+    def __init__(self, ogreRoot, parent=None):
+        QDialog.__init__(self, parent)
+        self.ogreRoot = ogreRoot
+
+        self.setupUi()
+
+        self.connect(self.materialSearchBox, SIGNAL("textChanged(QString)"),
+                               self.updateMaterialList)
+
+        self.connect(self.listWidget, SIGNAL("itemSelectionChanged ()"),
+                               self.setPreviewedMaterial)
+
+        self.materialList = []
+
+        self.ogreMaterialPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
+
+        self.node = self.ogreMaterialPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
+        self.ent = None
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+
+
+    def setupUi(self):
+        self.setObjectName("materialPreviewDialog")
+        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(self)
+        self.gridlayout.setObjectName("materialSelectionLayout")
+        self.gridlayout.setContentsMargins(2, 2, 2, 2)
+        
+        self.materialSearchBox = QLineEdit(self)
+        self.materialSearchBox.setObjectName("materialSearchBox")
+        self.gridlayout.addWidget(self.materialSearchBox,0,0,1,1)
+
+        self.splitter = QSplitter(self)
+        self.splitter.setOrientation(Qt.Vertical)
+        self.splitter.setObjectName("splitter")
+
+        self.listWidget = MaterialListWidget(self.splitter)
+        self.listWidget.setObjectName("listWidget")
+
+        self.ogreMaterialPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,"ogreMaterialPrevWindowSceneMgr")
+        self.ogreMaterialPrevWindow = OgreWidget.OgreWidget("MaterialPrevWin", self.ogreRoot, self.ogreMaterialPrevWindowSceneMgr, "MaterialPrevCam",
+                                                         self.splitter)
+        self.ogreMaterialPrevWindow.setBackgroundColor(og.ColourValue(1.0, 1.0, 1.0, 1.0))
+        self.ogreMaterialPrevWindow.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)                                                 
+        
+        
+        self.ogreMaterialPrevWindow.setMinimumSize(QSize(200,200))
+        self.ogreMaterialPrevWindow.setObjectName("materialPreviewWindow")
+        self.gridlayout.addWidget(self.splitter,1,0,1,1)
+
+        self.retranslateUi()
+
+    def ogreViewportCreatedCallback(self):
+        self.ogreMaterialPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
+        
+    def retranslateUi(self):
+        self.setWindowTitle(QApplication.translate("materialPreviewDialog", "Dialog", None, QApplication.UnicodeUTF8))
+
+    def setPreviewedMaterial(self):
+        if self.ent == None:
+            self.ent = self.ogreMaterialPrevWindowSceneMgr.createEntity("MaterialPrevEntity9993944", "UniCube.mesh")
+            self.nodeScale = og.Vector3(1,1,1)
+
+            self.node.attachObject(self.ent)
+            self.node.setScale(og.Vector3(6,6,6))
+        self.ent.setMaterialName(str(self.listWidget.currentItem().text()))
+
+    def scanDirForMaterials(self, dir):
+        for file in os.listdir(dir):
+            curFile = dir + "/" + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if isdir(curFile):
+                self.scanDirForMaterials(curFile)
+                continue
+            if isfile(curFile):
+                if file.endswith(".material"):
+                    f = open(curFile, "r")
+                    for line in f:
+                        if line.startswith("material "):
+                            l = line.replace("material ", "").lstrip().rstrip()
+                            l2 = l.split(":")
+                            self.materialList.append(l2[0])
+                            self.listWidget.addItem(l2[0])
+                        
+                    f.close()
+        self.listWidget.sortItems()
+
+    def updateMaterialList(self, text):
+        self.listWidget.clear()
+        for material in self.materialList:
+            if material.find(text) != -1:
+               self.listWidget.addItem(material)
+
+        self.listWidget.sortItems()
+
+    def eventFilter(self, obj, event):
+        if event.type() == 5:
+            self.startDrag()
+            event.accept()
+            return True
+
+        return False
+
+    def event(self, event):
+        if event.type() == 31: # scroll wheel turned
+            if event.delta() < 0:
+                self.ogreMaterialPrevWindow.zoomCamera(-5)
+            else:
+                self.ogreMaterialPrevWindow.zoomCamera( 5)
+            return True
+
+        if event.type() == 5: #mouse moved while button down
+            rotX = (event.globalX() - self.lastMousePosX) * 0.01
+            rotY = (event.globalY() - self.lastMousePosY) * 0.01
+
+            if rotX < 0.1 and rotY < 0.1: # first click, don't do anything at all here
+                self.ogreMaterialPrevWindow.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+            return True
+
+        if event.type() == 3: # mouse released
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+            return True
+
+        return False
+
+    def updateRenderWindow(self):
+        self.ogreMaterialPrevWindow.update()

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 import sys
@@ -73,10 +74,11 @@
 
     def setupUi(self):
         self.setObjectName("modelPreviewDialog")
-        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
+        self.resize(QSize(QRect(0,0,272,450).size()).expandedTo(self.minimumSizeHint()))
 
         self.gridlayout = QGridLayout(self)
         self.gridlayout.setObjectName("gridlayout")
+        self.gridlayout.setContentsMargins(2, 2, 2, 2)
 
         self.modelSearchBox = QLineEdit(self)
         self.modelSearchBox.setObjectName("modelSearchBox")

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,27 +1,69 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
-#dienstag 24.03 15.50
 import sys
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *
 import ogre.renderer.OGRE as og
 
+# get the light out of a light node
+def extractLight(node):
+        i = 0
+        num = node.numAttachedObjects()
+        while i < node.numAttachedObjects():
+            c = node.getAttachedObject(i)
+            tp = str(type(c))
+            if tp == "<class 'ogre.renderer.OGRE._ogre_.Light'>":
+                return c
+            
+            i += 1
+
+class ExplorerOptionsDlg(QDialog):
+    def __init__(self, lights, gameObjects, entities, zones, parent = None):
+        super(ExplorerOptionsDlg, self).__init__(parent)
+        
+        buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        layout = QVBoxLayout()
+        
+        self.lightCheckBox = QCheckBox("Show Lights")
+        self.lightCheckBox.setChecked(lights)        
+        layout.addWidget(self.lightCheckBox)
+        
+        self.gameObjectsCheckBox = QCheckBox("Show Game-Objects")
+        self.gameObjectsCheckBox.setChecked(gameObjects)        
+        layout.addWidget(self.gameObjectsCheckBox)
+        
+        self.entitiesCheckBox = QCheckBox("Show Entities")
+        self.entitiesCheckBox.setChecked(entities)        
+        layout.addWidget(self.entitiesCheckBox)
+        
+        self.zonesCheckBox = QCheckBox("Show Zones")
+        self.zonesCheckBox.setChecked(zones)        
+        layout.addWidget(self.zonesCheckBox)
+        
+        layout.addWidget(buttonBox)
+        layout.setContentsMargins(2, 2, 2, 2)
+        self.setLayout(layout)
+        
+        self.connect(buttonBox, SIGNAL("accepted()"), self, SLOT("accept()"))        
+        self.connect(buttonBox, SIGNAL("rejected()"), self, SLOT("reject()"))
+
 class NameInputDlg(QDialog):
     def __init__(self, parent = None):
         super(NameInputDlg, self).__init__(parent)
@@ -31,12 +73,12 @@
         layout = QVBoxLayout()
         layout.addWidget(self.nameInput)
         layout.addWidget(buttonBox)
+        layout.setContentsMargins(2, 2, 2, 2)
         self.setLayout(layout)
         
         self.connect(buttonBox, SIGNAL("accepted()"), self, SLOT("accept()"))        
         self.connect(buttonBox, SIGNAL("rejected()"), self, SLOT("reject()"))
         
-        
 class ModuleTreeWidget(QTreeWidget):
     def __init__(self, parent = None):
         super(ModuleTreeWidget, self).__init__(parent)
@@ -47,17 +89,14 @@
         self.onMenuCallback = None
         self.setAnimated(True)
 
-#        clearAction= QAction("Clear Window",  self)
-#        self.consoleWindow.textEdit.addAction(clearAction)
-#        self.consoleWindow.textEdit.setContextMenuPolicy(Qt.ActionsContextMenu)
-#        clearAction.setShortcut("Ctrl + R")
-#        self.connect(clearAction, SIGNAL("triggered()"), self.consoleWindow.textEdit.clear)
-
+        self.setHeaderLabels(["Structure", "Visibility"])
+        self.setSelectionMode(QAbstractItemView.ExtendedSelection)
+        
     def setMenuCallback(self, callback):
         self.onMenuCallback = callback
         
     def doMenu(self, point):
-        self.onMenuCallback(self.mapToGlobal(point))
+        self.onMenuCallback(point)
 
 class ModuleExplorer(QWidget):
     def __init__(self, parent=None):
@@ -66,41 +105,144 @@
         
         self.sceneTreeView.setMenuCallback(self.onMenu)
         self.connect(self.sceneTreeView, SIGNAL("itemClicked (QTreeWidgetItem *,int)"), self.onClick)
-        
+        self.connect(self.sceneTreeView, SIGNAL("itemSelectionChanged ()"), self.onSelectionChanged)
+
         vBoxLayout = QVBoxLayout()
         vBoxLayout.addWidget(self.sceneTreeView)
+        vBoxLayout.setContentsMargins(0, 0, 0, 0)
+        
+        self.setLayout(vBoxLayout)
+        self.resize(QSize(QRect(0,0,272,450).size()).expandedTo(self.minimumSizeHint()))
 
-        self.setLayout(vBoxLayout)
-        
         self.nodeDict = {}
         
         self.moduleManager = None
         self.mapSelectedCallback = None
+        self.selectionChangedCallback = None
+        self.mapItems = []
         
         self.lastSelectedMap = None
+        self.onMenuPoint = None
         
+        self.showLights = True
+        self.showGameObjects = True
+        self.showEntities = True
+        self.showZones = True
+
+    def selectItems(self, selectedItems):
+        self.disconnect(self.sceneTreeView, SIGNAL("itemSelectionChanged ()"), self.onSelectionChanged)
+        self.deselectAll()
+        
+        if selectedItems is None:
+            return
+        
+        for so in selectedItems:
+            nodeName = so.entity.getParentNode().getName()
+            items = self.sceneTreeView.findItems(nodeName, Qt.MatchFixedString | Qt.MatchRecursive)
+            for item in items:
+                self.sceneTreeView.setItemSelected(item, True)
+        self.connect(self.sceneTreeView, SIGNAL("itemSelectionChanged ()"), self.onSelectionChanged)
+    
+    def selectItem(self, so, select):
+        self.disconnect(self.sceneTreeView, SIGNAL("itemSelectionChanged ()"), self.onSelectionChanged)
+        nodeName = so.entity.getParentNode().getName()
+       
+        items = None
+        
+        if nodeName.startswith("light_") and self.showLights: 
+            items = self.sceneTreeView.findItems(extractLight(so.entity.getParentNode()).getName(), Qt.MatchFixedString | Qt.MatchRecursive)    
+        elif nodeName.startswith("gameobject_") and self.showGameObjects:
+            go = so.entity.getUserObject()
+            items = self.sceneTreeView.findItems(go.gocName + " id:" + str(go.inWorldId), Qt.MatchFixedString | Qt.MatchRecursive)    
+        elif nodeName.startswith("entity_") and self.showEntities:
+            items = self.sceneTreeView.findItems(so.entityName, Qt.MatchFixedString | Qt.MatchRecursive)    
+        elif nodeName.startswith("area_") and self.showZones:
+            area = so.entity.getUserObject()
+            items = self.sceneTreeView.findItems("Area " + str(area.id), Qt.MatchFixedString | Qt.MatchRecursive)    
+        
+        if select and items is not None:
+            for item in items:
+                self.sceneTreeView.setItemSelected(item, True)
+                self.sceneTreeView.expandItem(item)
+        else:
+            if items is not None:
+                for item in items:
+                    self.sceneTreeView.setItemSelected(item, False)
+        self.connect(self.sceneTreeView, SIGNAL("itemSelectionChanged ()"), self.onSelectionChanged)
+        
+    def onSelectionChanged(self):
+        if self.selectionChangedCallback is None:
+            return
+
+        nodeNames = {}
+        
+        # get all maps and add them as a key to the dictionary
+        # append a empty list to that key
+        items = self.sceneTreeView.findItems("Map: ", Qt.MatchStartsWith | Qt.MatchCaseSensitive | Qt.MatchRecursive)
+        for item in items:
+            nodeNames[str(item.text(0))] = []
+            
+        # get all zones and add them as a key to the dictionary
+        # append a empty list to that key            
+        items = self.sceneTreeView.findItems("Zone: ", Qt.MatchStartsWith | Qt.MatchCaseSensitive | Qt.MatchRecursive)
+        for item in items:
+            nodeNames[str(item.text(0))] = []
+        
+        #get all selected items
+        items = self.sceneTreeView.selectedItems()
+        
+        #end remove all the things from the list we actually don't want to be selected
+        for item in items:
+            if str(item.text(0)).startswith("Scene: ") or str(item.text(0)).startswith("Map: ") or str(item.text(0)).startswith("Zone: "):
+                items.remove(item)
+        
+        for item in items:
+            parentName =  str(item.text(0))
+                        
+            name = str(item.data(0, Qt.UserRole).toString())
+            if len > 0:
+                nodeNames[str(item.parent().text(0))].append(name)
+                
+        self.selectionChangedCallback(nodeNames)
+
+    def deselectAll(self):
+        self.disconnect(self.sceneTreeView, SIGNAL("itemSelectionChanged ()"), self.onSelectionChanged)
+        
+        for item in self.sceneTreeView.selectedItems():
+            self.sceneTreeView.setItemSelected(item, False)
+            
+        self.connect(self.sceneTreeView, SIGNAL("itemSelectionChanged ()"), self.onSelectionChanged)
+
     def onClick(self, item, column):
         if self.mapSelectedCallback is None:
             return
         
         name = str(item.text(0))
         if name.startswith("Map: "):
-            self.mapSelectedCallback(str(item.parent().text(0)).replace("Scene: ", ""), name.replace("Map: ", ""))
-            self.lastSelectedMap = name
-        elif name.startswith("Scene: "):
-            if item.childCount > 0:
-                self.mapSelectedCallback(name.replace("Scene: ", ""), None)
-                return
-            self.mapSelectedCallback(name.replace("Scene: ", ""), str(item.child(0).text(0)).replace("Map: ", ""))
-            self.lastSelectedMap = name
-        else:
-            self.mapSelectedCallback(str(item.parent().parent().text(0)).replace("Scene: ", ""), str(item.parent().text(0)).replace("Map: ", ""))
-            self.lastSelectedMap = name
+            if column == 1:
+                if self.module.getMap(name.replace("Map: ", "")).isHidden:
+                    item.setIcon(1 , QIcon("media/icons/14_layer_visible.png"))
+                    self.module.getMap(name.replace("Map: ", "")).show()
+                else:
+                    item.setIcon(1 , QIcon("media/icons/14_layer_invisible.png"))
+                    self.module.getMap(name.replace("Map: ", "")).hide()
             
-
-        
+        elif name.startswith("Zone: "):
+            if self.moduleManager and column == 1:
+                if self.moduleManager.zoneManager.getZone(name.replace("Zone: ", "")).isHidden:
+                    item.setIcon(1 , QIcon("media/icons/14_layer_visible.png"))
+                    self.moduleManager.zoneManager.getZone(name.replace("Zone: ", "")).show()
+                else:
+                    item.setIcon(1 , QIcon("media/icons/14_layer_invisible.png"))
+                    self.moduleManager.zoneManager.getZone(name.replace("Zone: ", "")).hide()
+            
     def onMenu(self, point):
         if self.moduleManager is not None:
+            index = self.sceneTreeView.indexAt(point)
+            if not index.isValid():
+                return
+            self.onMenuPoint = point
+            
             menu = QMenu(self)
             
             newSceneAction= QAction("New Scene",  self)
@@ -111,12 +253,58 @@
                 newMapAction= QAction("New Map",  self)
                 menu.addAction(newMapAction)
                 self.connect(newMapAction, SIGNAL("triggered()"), self.onNewMap)
-
+            elif self.sceneTreeView.currentItem() is not None and str(self.sceneTreeView.currentItem().text(0)).startswith("Map:"):
+                item = self.sceneTreeView.itemAt(point)
+                self.onClick(item, None)
+                
+                hideMapAction = QAction("Hide",  self)
+                menu.addAction(hideMapAction)
+                self.connect(hideMapAction, SIGNAL("triggered()"), self.onHideMap)
+                revealMapAction = QAction("Show",  self)
+                menu.addAction(revealMapAction)
+                self.connect(revealMapAction, SIGNAL("triggered()"), self.onShowMap)
+                setActiveMapAction = QAction("Set Active",  self)
+                menu.addAction(setActiveMapAction)
+                self.connect(setActiveMapAction, SIGNAL("triggered()"), self.onSetActiveMap)
+                
             deleteAction= QAction("Delete",  self)
             menu.addAction(deleteAction)
             self.connect(deleteAction, SIGNAL("triggered()"), self.onDelete)
+                
+            if self.sceneTreeView.currentItem() is not None and str(self.sceneTreeView.currentItem().text(0)).startswith("Map:"):
+                menu.addSeparator()
+                
+                newZoneAction = QAction("New Zone",  self)
+                menu.addAction(newZoneAction)
+                self.connect(newZoneAction, SIGNAL("triggered()"), self.onNewZone)
             
-            menu.exec_(point)
+            menu.addSeparator()
+            optionsAction= QAction("Open Explorer Options",  self)
+            menu.addAction(optionsAction)
+            self.connect(optionsAction, SIGNAL("triggered()"), self.onOptions)
+            
+            menu.exec_(QCursor().pos())
+    
+    def onOptions(self):
+        dlg = ExplorerOptionsDlg(self.showLights, self.showGameObjects, self.showEntities, self.showZones, self)
+        if dlg.exec_():
+            self.showLights = dlg.lightCheckBox.isChecked()
+            self.showGameObjects = dlg.gameObjectsCheckBox.isChecked()
+            self.showEntities = dlg.entitiesCheckBox.isChecked()
+            self.showZones = dlg.zonesCheckBox.isChecked()
+            self.updateView()
+            
+    def onHideMap(self):
+        if self.module:
+            item = self.sceneTreeView.itemAt(self.onMenuPoint)
+            item.setIcon(1 , QIcon("media/icons/14_layer_invisible.png"))
+            self.module.getMap(self.lastSelectedMap.replace("Map: ", "")).hide()   
+            
+    def onShowMap(self):
+        if self.module:
+            item = self.sceneTreeView.itemAt(self.onMenuPoint)
+            item.setIcon(1, QIcon("media/icons/14_layer_visible.png"))
+            self.module.getMap(self.lastSelectedMap.replace("Map: ", "")).show()
       
     def onNewScene(self):
         dlg = NameInputDlg(self)
@@ -131,11 +319,40 @@
             sceneName = str(self.sceneTreeView.currentItem().text(0)).replace("Scene: ", "")
             self.moduleManager.addMapToScene(sceneName, str(dlg.nameInput.text()))
             self.updateView()
-        
+    
+    def onNewZone(self):
+        dlg = NameInputDlg(self)
+        if dlg.exec_():
+            self.moduleManager.addZoneToMap(str(dlg.nameInput.text()))
+            self.updateView()
+    
     def onDelete(self):
         print "delete"
-      
+        
+    def paintLastSelectedMapBlue(self):
+        print self.lastSelectedMap
+        for item in self.mapItems:
+            if str(item.text(0)) == self.lastSelectedMap:
+                brush = item.foreground(0)
+                brush.setColor(QColor("blue"))
+                item.setForeground(0, brush)
+                item.setIcon(0, QIcon("media/icons/2rightarrow.png"))
+            else:
+                brush = item.foreground(0)
+                brush.setColor(QColor("black"))
+                item.setForeground(0, brush)
+                item.setIcon(0, QIcon())
+                
+    def onSetActiveMap(self):
+        item = self.sceneTreeView.currentItem()
+        self.lastSelectedMap = str(item.text(0))
+        self.paintLastSelectedMapBlue()
+        sceneName = str(item.parent().text(0).replace("Scene: ", ""))
+        mapName = str(item.text(0).replace("Map: ", ""))
+        self.mapSelectedCallback(sceneName, mapName)
+        
     def updateView(self):
+        self.mapItems = []
         self.sceneTreeView.clear()
         
         for s in self.module.scenes:
@@ -144,22 +361,56 @@
             
             for m in s.mapFiles:
                 self.parseMap(m, sceneRootItem)
+        
+        self.paintLastSelectedMapBlue()
 
-
     def parseMap(self, map, sceneRootItem):
         childItem =  QTreeWidgetItem(sceneRootItem)
+        self.mapItems.append(childItem)
+        sceneRootItem.setExpanded(True)
         mn = "Map: " + map.mapName
+        
+        childItem.setIcon(1 , QIcon("media/icons/14_layer_visible.png"))
+        if map.isHidden:
+            childItem.setIcon(1 , QIcon("media/icons/14_layer_invisible.png"))
+        
         childItem.setText(0, mn)
         if mn == self.lastSelectedMap:
             childItem.setSelected(True)
-            childItem.parent().setExpanded(True)
-        
+            childItem.setExpanded(True)
+            
+        if self.showZones:
+            self.parseZone(map, childItem)
+            
         i = 0
-        while i < map.mapNode.numChildren():
-            childItem2 = QTreeWidgetItem(childItem) 
-            childItem2.setText(0, map.mapNode.getChild(i).getName())
+        while i < map.mapNode.numChildren(): 
+            if map.mapNode.getChild(i).getName().startswith("light_") and self.showLights:
+                childItem2 = QTreeWidgetItem(childItem) 
+                childItem2.setData(0, Qt.UserRole, QVariant(map.mapNode.getChild(i).getName()))
+                childItem2.setText(0, extractLight(map.mapNode.getChild(i)).getName()) 
+            elif map.mapNode.getChild(i).getName().startswith("gameobject_") and self.showGameObjects:
+                childItem2 = QTreeWidgetItem(childItem) 
+                go = map.mapNode.getChild(i).getAttachedObject(0).getUserObject()
+                childItem2.setData(0, Qt.UserRole, QVariant(map.mapNode.getChild(i).getName()))
+                childItem2.setText(0, go.gocName + " id:" + str(go.inWorldId)) 
+            elif map.mapNode.getChild(i).getName().startswith("entity_") and self.showEntities:
+                childItem2 = QTreeWidgetItem(childItem) 
+                childItem2.setData(0, Qt.UserRole, QVariant(map.mapNode.getChild(i).getName()))
+                childItem2.setText(0, map.mapNode.getChild(i).getAttachedObject(0).getName()) 
             i = i+1
 
+        
+#            thetype = None
+#            try:
+#                thetype = str(type(map.mapNode.getChild(i).getAttachedObject(0)))
+#            except:
+#                i = i+1
+#                continue
+#                
+#            childItem3 = QTreeWidgetItem(childItem2) 
+#            childItem3.setText(0, thetype)
+#            i = i+1
+            
 
 # this crashed in linux
 #        iter = map.mapNode.getChildIterator()
@@ -169,7 +420,21 @@
 #            if  val is not None:
 #                childItem2.setText(0, val.getName())
 
-        
+    def parseZone(self, map, parentItem):
+        for zone in map.zoneList:
+            childItem = QTreeWidgetItem(parentItem) 
+            childItem.setText(0, "Zone: " + zone.name)
+            childItem.setData(0, Qt.UserRole, QVariant(zone.zoneNode.getName()))
+            childItem.setIcon(0, QIcon("media/icons/dissociatecell.png"))
+            childItem.setIcon(1, QIcon("media/icons/14_layer_visible.png"))
+            
+            i = 0
+            for area in zone.areaList:
+                childItem2 = QTreeWidgetItem(childItem)
+                childItem2.setText(0, "Area " + str(area.id))
+                childItem2.setData(0, Qt.UserRole, QVariant(area.areaNode.getName()))
+                i += 1
+                
     def setCurrentModule(self, module):
         self.module = module
         self.updateView()
@@ -179,3 +444,6 @@
         
     def setMapSelectedCallback(self, callback):
         self.mapSelectedCallback = callback
+
+    def setSelectionChangedCallback(self, callback):
+        self.selectionChangedCallback = callback

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 import sys
 import codecs
@@ -31,33 +32,25 @@
 from PyQt4.QtGui import *
 
 from SelectionBuffer import *
+from DepthBuffer import *
 from MovePivot import *
 from GameObjectClassManager import *
+from MyRaySceneQueryListener import *
+from ZoneManager import ZoneManager
 
 
-#                <zone name="Testzone">
-#                        <area type="sphere">
-#                                <position x="-10" y="0" z="-5"/>
-#                                <scale x="6" y="6" z="6"/>
-#                                <transition_distance>0.5</transition_distance>
-#                        </area>
-#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
-#                                <position x="25" y="0" z="-50"/>
-#                                <transition_distance>0.5</transition_distance>
-#                        </area>
-#                        <area type="sphere" subtract="true">
-#                                <position x="-11" y="0" z="-4"/>
-#                                <scale x="2" y="2" z="2"/>
-#                        </area>
-#                        <light name="red pointlight"/>
-#                        <light name="green spotlight"/>
-#                        <sound name="ruchin001.ogg"/>
-#                        <trigger name="test" classname="TestTrigger">
-#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
-#                        </trigger>
-#                </zone>
+# get the light out of a light node
+def extractLight(node):
+        i = 0
+        num = node.numAttachedObjects()
+        while i < node.numAttachedObjects():
+            c = node.getAttachedObject(i)
+            tp = str(type(c))
+            if tp == "<class 'ogre.renderer.OGRE._ogre_.Light'>":
+                return c
+            
+            i += 1
 
-
 # make the xml file more pretty
 def indent(elem, level=0):
     i = "\n" + level*"  "
@@ -75,8 +68,42 @@
         if level and (not elem.tail or not elem.tail.strip()):
             elem.tail = i
 
+# creates unique names for new entities
+def createUniqueEntityName(sceneManager, name = None):
+    n = ""
+    if name is None:
+        n = "dropMesh" + str(ModuleManager.dropCount)
+    else:
+        n = name
+        
+    while sceneManager.hasEntity(n):
+        n = "dropMesh" + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+    return n
+        
+def printVector3(vec):
+    print str(vec.x) + ";" + str(vec.y) + ";" + str(vec.z)
+    
+class EntityCustomOptions(og.UserDefinedObject):
+    def __init__(self, receivesShadow = True, staticgeometrygroup = 0, physicsproxytype = "none", renderingdistance = "20000"):
+        og.UserDefinedObject.__init__(self)
+        self.receivesShadow = receivesShadow
+        self.staticgeometrygroup = staticgeometrygroup
+        self.physicsproxytype = physicsproxytype
+        self.renderingdistance = renderingdistance
+        self.materialName = "NotChanged"
+        
+        ModuleManager.entityCustomOptionsDict.append(self)
+        
+    def copy(self):
+            return EntityCustomOptions(self.receivesShadow, self.staticgeometrygroup, self.physicsproxytype, self.renderingdistance)
+        
+    def getType(self):
+            return "EntityCustomOptions"
+
 class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyMap = False):
         self.pathToMapFile = pathToFile
         
         mapName = pathToFile.replace("\\", "/")
@@ -90,21 +117,48 @@
         self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
         self.ogreRoot = ogreRoot
         self.gocManager = gocManager
-
+        self.zoneManager = zoneManager
+        self.isHidden = False
+        
+        self.zoneList = []
+        
         if not emptyMap:
             xmlTree = xml.parse(pathToFile)
             root = xmlTree.getroot()
 
             if root.attrib["formatVersion"] == "0.4.0":
                 self.parseMapNodes(root.find("nodes"))
-                #self.parseMapZones(root.find("zones"))
+                self.parseMapZones(root.find("zones"))
             else:
                 print pathToFile + " has wrong format version. It needs to be 0.4.0"
                 return
 
+    def hide(self):
+        try:
+            self.sceneManager.getRootSceneNode().removeChild(self.mapNode)
+        except:
+            print "Error: map is already hidden!"
+            return
+        
+        self.isHidden = True
+        
+    def show(self):
+        try:
+            self.sceneManager.getRootSceneNode().addChild(self.mapNode)
+        except:
+            print "Error: map is already shown!"
+            return
+        
+        self.isHidden = False
+    
+    def parseMapZones(self, zonesElement):
+        self.zoneManager.parseZonesFromXml(zonesElement, self)
+    
     def parseMapNodes(self, nodeElement):
+        nodes = nodeElement.getiterator("gameobject")
+        self.createGameObjects(nodes)
+        
         nodes = nodeElement.getiterator("entity")
-        
         self.createEntites(nodes)
 
         nodes = nodeElement.getiterator("light")
@@ -113,9 +167,6 @@
         nodes = nodeElement.getiterator("sound")
         self.createSound(nodes)
 
-        nodes = nodeElement.getiterator("gameobject")
-        self.createGameObjects(nodes)
-
         nodes = nodeElement.getiterator("particlesystem")
         self.createParticleSystems(nodes)
 
@@ -127,8 +178,36 @@
                 num = int(entityName.replace("dropMesh",  ""))
                 if ModuleManager.dropCount < num:
                     ModuleManager.dropCount = num
+                elif ModuleManager.dropCount < num:
+                    ModuleManager.dropCount = num + 1
                     
             meshFile = nodes.attrib["meshfile"]
+            
+            eco = EntityCustomOptions()
+            
+            try:
+                if nodes.attrib["receivesShadow"] == "False" or nodes.attrib["receivesShadow"] == "false":
+                    eco.receivesShadow = "False"
+            except:
+                pass
+            try:
+                eco.staticgeometrygroup = int(nodes.attrib["staticgeometrygroup"])
+            except:
+                pass
+            try:
+                eco.physicsproxy = nodes.attrib["physicsproxy"]
+            except:
+                pass
+            try:
+                eco.renderingdistance = float(nodes.attrib["renderingdistance"])
+            except:
+                pass
+            try:
+                eco.renderingdistance
+                nodes.attrib["materialName"]
+            except:
+                pass
+                
             nodePosition = None
             nodeScale = None
             qw = qx = qy = qz = None
@@ -152,11 +231,12 @@
                     nodeScale = og.Vector3(scalex, scaley, scalez)
 
             try:
-                e = self.sceneManager.createEntity(entityName, meshFile)
+                e = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager,  entityName), meshFile)
             except:
                 print "Warning: Meshfile " + meshFile + " could not be found."
-                continue
+                return
 
+            e.setUserObject(eco)
             n = self.mapNode.createChild("entity_" + entityName + "_node")
             n.attachObject(e)
             n.setPosition(nodePosition)
@@ -170,13 +250,17 @@
             lightVisible = bool(l.attrib["visible"])
             castShadows = bool(l.attrib["castShadows"])
             lightPosition = None
+            lightDirection = None
             colourDiffuse = None
             colourSpecular = None
             lightAttenuationRange = None
             lightAttenuationConstant= None
             lightAttenuationLinear = None
             lightAttenuationQuadratic = None
-
+            spotlightinner = None
+            spotlightouter = None
+            falloff = None 
+                
             transformations = l.getiterator()
             for t in transformations:
                 if t.tag == "position":
@@ -198,25 +282,38 @@
                     lightAttenuationRange = float(t.attrib["range"])
                     lightAttenuationConstant= float(t.attrib["constant"])
                     lightAttenuationLinear = float(t.attrib["linear"])
-                    lightAttenuationQuadratic = float(t.attrib["quadratic"])
+                    lightAttenuationQuadric  = float(t.attrib["quadratic"])
+                elif t.tag == "spotlightrange":
+                    spotlightinner = float(t.attrib["inner"])
+                    spotlightouter = float(t.attrib["outer"])
+                    falloff = float(t.attrib["falloff"])
+                    
+            light = self.sceneManager.createLight(lightName)
             
-
-            light = self.sceneManager.createLight(lightName)
+            if lightType == "point":
+                light.setType(og.Light.LT_POINT)            
+            elif lightType == "spot":
+                light.setType(og.Light.LT_SPOTLIGHT)
+            elif lightType == "directional":
+                light.setType(og.Light.LT_DIRECTIONAL)
+            
             light.setVisible(lightVisible)
             light.setCastShadows(castShadows)
-            light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadratic)
-            light.setDiffuseColour(colourDiffuse)
-            light.setSpecularColour(colourSpecular)
+            if lightAttenuationRange is not None and lightAttenuationConstant is not None and lightAttenuationLinear is not None and lightAttenuationQuadric is not None:
+                light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadric)
+            if colourDiffuse:
+                light.setDiffuseColour(colourDiffuse)
+            if colourSpecular:
+                light.setSpecularColour(colourSpecular)
+            if spotlightinner and spotlightouter and spotlightouter: 
+                light.setSpotlightRange(spotlightinner, spotlightouter, falloff)
             
-            if lightType == "point":
-                light.setType(og.Light.LT_POINT)
-            
             e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
             n = self.mapNode.createChild("light_" + lightName + "_node")
+            n.attachObject(light)
             n.attachObject(e)
-            n.attachObject(light)
-            n.setPosition(lightPosition)
-
+            if lightPosition:
+                n.setPosition(lightPosition)
             
     def createSound(self, soundNodes):
         #raise NotImplementedError
@@ -225,11 +322,16 @@
     def createGameObjects(self, gameObjectNodes):
         for g in gameObjectNodes:
             classid = g.attrib["class"]
+            
             id = int(g.attrib["id"])
+            if ModuleManager.dropCount < id:
+                ModuleManager.dropCount = id
+            elif ModuleManager.dropCount < id:
+                ModuleManager.dropCount = id + 1
+                
             state = g.attrib["state"]
             nodePosition = None
             nodeRotation = None
-            nodeScale = None
 
             transformations = g.getiterator()
             for t in transformations:
@@ -244,16 +346,12 @@
                     qy = float(t.attrib["qy"])
                     qz = float(t.attrib["qz"])
                     nodeRotation = og.Quaternion(qw, qx, qy, qz)
-                elif t.tag == "scale":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    nodeScale = og.Vector3(x, y, z)
 
             go = self.gocManager.getGameObjectWithClassId(classid)
             if go is not None:
                 meshFile = go.getMeshFileName()
-                ent = self.sceneManager.createEntity("dropMesh" + str(id), str(meshFile))
+                
+                ent = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
                 dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
                 dropNode.attachObject(ent)
 
@@ -261,11 +359,11 @@
                     dropNode.setPosition(nodePosition)
                 if nodeRotation:
                     dropNode.setOrientation(nodeRotation)
-                if nodeScale:
-                    dropNode.setScale(nodeScale)
 
                 go = GameObjectRepresentation(id, classid, dropNode, meshFile)
+                self.gocManager.addGameObjectRepresentation(go)
                 go.inWorldId = id
+                go.state = state
                 ent.setUserObject(go)
 
 
@@ -286,7 +384,13 @@
                 if n.name.startswith("entity_"):
                     entElem = xml.SubElement(nodesElem, "entity")
                     entElem.attrib["name"] = n.getAttachedObject(0).getName()
+                    print "Saving Entity: " + n.getAttachedObject(0).getName()
                     entElem.attrib["meshfile"] = n.getAttachedObject(0).getMesh().getName()
+   
+                    entElem.attrib["receivesShadow"] = str(n.getAttachedObject(0).getUserObject().receivesShadow).lower()
+                    entElem.attrib["staticgeometrygroup"] = str(n.getAttachedObject(0).getUserObject().staticgeometrygroup)
+                    entElem.attrib["physicsproxytype"] = str(n.getAttachedObject(0).getUserObject().physicsproxytype)
+                    entElem.attrib["renderingdistance"] = str(n.getAttachedObject(0).getUserObject().renderingdistance)
                     
                     posElem = xml.SubElement(entElem, "position")
                     posElem.attrib["x"] = str(n.getPosition().x)
@@ -303,11 +407,95 @@
                     scaleElem.attrib["x"] = str(n.getScale().x)
                     scaleElem.attrib["y"] = str(n.getScale().y)
                     scaleElem.attrib["z"] = str(n.getScale().z)
-                
+                    
+                elif n.name.startswith("gameobject_"):
+                    goElem = xml.SubElement(nodesElem, "gameobject")
+                    mname = n.name
+                    print "Saving GOID: " + str(n.getAttachedObject(0).getUserObject().inWorldId)
+                    goElem.attrib["class"] = str(n.getAttachedObject(0).getUserObject().gocName)
+                    goElem.attrib["state"] = str(n.getAttachedObject(0).getUserObject().state)
+                    goElem.attrib["id"] = str(n.getAttachedObject(0).getUserObject().inWorldId)
+                    
+                    posElem = xml.SubElement(goElem, "position")
+                    posElem.attrib["x"] = str(n.getPosition().x)
+                    posElem.attrib["y"] = str(n.getPosition().y)
+                    posElem.attrib["z"] = str(n.getPosition().z)
+                    
+                    rotElem = xml.SubElement(goElem, "rotation")
+                    rotElem.attrib["qw"] = str(n.getOrientation().w)
+                    rotElem.attrib["qx"] = str(n.getOrientation().x)
+                    rotElem.attrib["qy"] = str(n.getOrientation().y)
+                    rotElem.attrib["qz"] = str(n.getOrientation().z)
+                    
+                elif n.name.startswith("light_"):
+                    light = extractLight(n)
+                    lightName = light.getName()
+                    print "Saving Light: " + lightName
+                    lightType = light.getType()
+                    isVisible = "true"
+                    if not light.getVisible():
+                        isVisible = "false"
+                    
+                    castShadows = "false"
+                    if light.getCastShadows():
+                        castShadows = "true"
+                    
+                    if lightType == og.Light.LT_POINT:
+                        lightType = "point"
+                    elif lightType == og.Light.LT_SPOTLIGHT:
+                        lightType = "spot"
+                    elif lightType == og.Light.LT_DIRECTIONAL:
+                        lightType = "directional"
+                    
+                    
+                    lightElem = xml.SubElement(nodesElem, "light")
+                    lightElem.attrib["name"] = lightName
+                    lightElem.attrib["type"] = lightType
+                    lightElem.attrib["visible"] = isVisible
+                    lightElem.attrib["castShadows"] = castShadows
+                    
+                    if lightType == "point" or lightType == "spot":
+                        posElem = xml.SubElement(lightElem, "position")
+                        posElem.attrib["x"] = str(n.getPosition().x)
+                        posElem.attrib["y"] = str(n.getPosition().y)
+                        posElem.attrib["z"] = str(n.getPosition().z)
+                    
+                    colDiffuseElem = xml.SubElement(lightElem, "colourDiffuse")
+                    colDiffuseElem.attrib["r"] = str(light.getDiffuseColour().r)
+                    colDiffuseElem.attrib["g"] = str(light.getDiffuseColour().g)
+                    colDiffuseElem.attrib["b"] = str(light.getDiffuseColour().b)
+
+                    colSpecularElem = xml.SubElement(lightElem, "colourSpecular")
+                    colSpecularElem.attrib["r"] = str(light.getSpecularColour().r)
+                    colSpecularElem.attrib["g"] = str(light.getSpecularColour().g)
+                    colSpecularElem.attrib["b"] = str(light.getSpecularColour().b)
+                    
+                    lightAttenuationElem = xml.SubElement(lightElem, "lightAttenuation")
+                    lightAttenuationElem.attrib["range"] = str(light.getAttenuationRange())
+                    lightAttenuationElem.attrib["constant"] = str(light.getAttenuationConstant())
+                    lightAttenuationElem.attrib["linear"] = str(light.getAttenuationLinear())
+                    lightAttenuationElem.attrib["quadratic"] = str(light.getAttenuationQuadric())
+                    
+                    if lightType == "spot":
+                        spotligthRangeElem = xml.SubElement(lightElem, "spotlightrange")
+                        spotligthRangeElem.attrib["inner"] = str(light.getSpotlightInnerAngle().valueDegrees())
+                        spotligthRangeElem.attrib["outer"] = str(light.getSpotlightOuterAngle().valueDegrees())
+                        spotligthRangeElem.attrib["falloff"] = str(light.getSpotlightFalloff())
+                        
+                    if lightType == "spot" or lightType == "directional":
+                        directionElem = xml.SubElement(lightElem, "direction")
+                        dir = og.Vector3()
+                        n.getOrientation().ToAxes(dir)
+                        directionElem.attrib["x"] = str(dir.x)
+                        directionElem.attrib["y"] = str(dir.y)
+                        directionElem.attrib["z"] = str(dir.z)
+                        
             i = i+1
             
+        self.zoneManager.saveZonesToXml(root, self)
         indent(root)
         xml.ElementTree(root).write(self.pathToMapFile)
+
 # caused a linux crash
 #        iter = self.mapNode.getChildIterator()
 #        while iter.hasMoreElements():
@@ -315,12 +503,13 @@
 #            print name
 
 class Scene():
-    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, emptyScene = False, sceneName = "NewScene"):
+    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyScene = False, sceneName = "NewScene"):
         self.moduleRoot = moduleroot
         self.pathToFile = pathToFile
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
         self.gocManager = gocManager
+        self.zoneManager = zoneManager
         self.mapFiles = [] # a list in case the module has more than one map file
         mappaths = []
         self.name = sceneName
@@ -336,11 +525,11 @@
                 mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
                 
             for m in mappaths:
-                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
             
     def addMap(self, name):
         path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
-        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, True))
+        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True))
         
     def save(self):
         root = xml.Element("scene")
@@ -354,13 +543,12 @@
         indent(root)
         xml.ElementTree(root).write(self.pathToFile)
 
-
-
 class Module():
-    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
+    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager, zoneManager):
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
         self.gocManager = gameObjectManager
+        self.zoneManager = zoneManager
         
         self.name = name
         self.moduleRoot = join(modulePath, name)
@@ -369,15 +557,18 @@
         self.hasDependencies = False
         self.moduleDependencies = []
 
+        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
 
         self.gofFiles = [] # gof File list
 
         self.scenes =[]
 
         self.isLoaded = False
-
+        
+        self.playerStart = None
+        
     def addScene(self, name):
-        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, True, name))
+        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True, name))
     
     def addMapToScene(self, sceneName, mapName):
         for scene in self.scenes:
@@ -389,9 +580,8 @@
         
     
     def isCommon(self):
-        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
+        if isfile(self.modConfig): # is the modconfig existing?
+            f = codecs.open(self.modConfig, 'r', 'utf-8')
         else:
             print ("Module.isCommon() Error: couldn't find module config")
             return
@@ -410,7 +600,14 @@
                     isDependencieLine = False
                 else:
                     self.hasDependencies = True
-                    self.moduleDependencies.append(lStripped.split('"')[1])
+                    pl = lStripped.split('"')
+                    i = 1
+                    while i < 100: 
+                        try:
+                            self.moduleDependencies.append(pl[i])
+                            i += 2
+                        except IndexError, e:
+                            break
 
             elif lStripped == "def getDependencies()":
                 isDependencieLine = True
@@ -420,18 +617,25 @@
     def load(self):
         if self.isLoaded:
             return
-
+        
         self.isLoaded = True
-        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
+        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+        if isfile(self.modConfig): # is the modconfig existing?
+            f = codecs.open(self.modConfig, 'r', 'utf-8')
         else:
             print ("Module.load: Error: couldn't find module config")
             return
 
-        #for i, line in enumerate(f):
-            #lStripped = line.strip() #strip the whitespace away, not needed here
-
+        for line in f:
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith("hero = $GOM.getGameObject("):
+                try:
+                    self.playerStart = int(line.split("(")[1].split(")")[0])
+                except ValueError, e:
+                    print self.modConfig + " ValueError: " + str(e)
+                    self.playerStart = None
+                    continue
+                    
         self.setResourcePaths()
         
         try:
@@ -448,16 +652,33 @@
             cmd = join(self.moduleRoot, "maps/*.rlscene")
             sceneFile = glob.glob(cmd)
             self.loadScenes(sceneFile)
-            
-        
+                
     def loadScenes(self, sceneFiles):
         for s in sceneFiles:
-            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager))
+            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
 
     def save(self):
         for s in self.scenes:
             s.save()
+            
+        self.saveModuleConfig()
 
+    def saveModuleConfig(self):
+        if self.playerStart is not None:
+            f = open(self.modConfig, "r")
+            
+            newconfig = ""
+            for line in f:
+                if line.startswith("       hero = $GOM.getGameObject("):
+                    newconfig += "       hero = $GOM.getGameObject(" + str(self.playerStart) + ");\n"
+                else:
+                    newconfig += line
+            f.close()
+            
+            f = open(self.modConfig, "w")
+            f.write(newconfig)
+            f.close()
+
     def setResourcePaths(self, recurseFolder = ""):
         if recurseFolder == "":
             rootFolder = self.moduleRoot
@@ -466,8 +687,6 @@
 
         for file in os.listdir(rootFolder):
             curFile = join(rootFolder, file)
-            if file == "WindyGrass.program":
-                print "yes!"
 
             if file.startswith('.'): #ignore dot files (hidden)
                 continue
@@ -489,10 +708,26 @@
                 for m in s.mapFiles:
                         if m.mapName == mapName:
                             return m
-                            
+
+class ProgressBarThread(QThread):
+    def __init__(self, min, max, moduleName):
+        QThread.__init__(self)
+        self.progress = QProgressDialog("Loading " + moduleName, "Abort Loading", min, max, None);
+        self.progress.setWindowModality(Qt.WindowModal)
+
+    def setProgress(self, progress, labelText):
+        self.progress.setLabelText(labelText)
+        self.progress.setValue(progress)
+        
+    def run(self):
+        self.progress.show()
+        self.exec_()
+
+        
 class ModuleManager():
     dropCount = 0
-        
+    entityCustomOptionsDict = []
+    
     def __init__(self,  ogreRoot,  sceneManager):
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
@@ -503,10 +738,6 @@
 
         self.gocManager = GameObjectClassManager()
         
-        # we need to hold a reference to the game object representaions ourself
-        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
-        # and deletes the object
-        self.gameObjectRepresentationDict = []
 
         self.mainModule = None
         self.mainModuledependencieList =[]
@@ -528,20 +759,31 @@
         self.middleMouseDown = False
         self.rightMouseDown = False
 
-       
         self.dropNode = None
         self.dropEntity = None
         self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
         self.dropMat = None
         
-        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
         self.moduleConfigIsParsed = False
 
         self.selectionBuffer = None
+        self.depthBuffer = None
         self.propertyWindow = None
     
         self.oneClickEntityPlacement = False
-    
+        
+        self.onContextMenuCallback = None
+        self.contextMenuClickPosition = None
+        self.contextMenuRay = None
+        
+        self.playerStartGameObjectId = None
+        
+        self.entityCustomOptionsDict = []
+        
+        self.raySceneQueryListener = MyRaySceneQueryListener()
+        
+        self.zoneManager = ZoneManager(self.sceneManager)
+        
     def resetParsedModuleConfig(self):
         self.moduleConfigIsParsed = False
         self.moduleList = []
@@ -560,7 +802,7 @@
             if line.startswith('module='):
                 splines = line.split('=')
                 str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager))
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
 
         self.moduleConfigIsParsed = True
 
@@ -579,7 +821,7 @@
 
         self.parseModuleConfig()
 
-        dlg = QDialog()
+        dlg = QDialog(QApplication.focusWidget())
         list = QListWidget()
         btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
         dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
@@ -598,40 +840,43 @@
 
     # I'm sorry for this
     def loadModule(self, moduleName):
+        t = og.Timer()
+        
+#        self.progress = ProgressBarThread(0, 8, moduleName)
+#        self.progress.start()
+        
         for m in self.moduleList:
             if m.name == moduleName:
                 if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
                     for moduleDependencie in m.moduleDependencies:
                         for m2 in self.moduleList:
                             if m2.name == moduleDependencie:
+#                                self.progress.setProgress(2, "Loading Dependencie: " + moduleDependencie)
                                 m2.load()
                                 self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
                                 self.materialSelectionDialog.scanDirForMaterials(m2.moduleRoot)
                                 self.mainModuledependencieList.append(m2)
 
+#                self.progress.setProgress(4, "Loading " + moduleName)
                 m.load()
+#                self.progress.setProgress(6, "Scan for models...")
                 self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
+#                self.progress.setProgress(8, "Scan for materials")
                 self.materialSelectionDialog.scanDirForMaterials(m.moduleRoot)
                 self.mainModule = m
                 self.moduleExplorer.setCurrentModule(m)
-                
-        self.moduleExplorer.updateView()
-        ModuleManager.dropCount += 1
-#        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
-#        e = self.sceneManager.createEntity("west342wt346t",  "UniCube.mesh")
-#        e.setMaterialName("PlainColorGLSL")
-#        e.getSubEntity(0).setCustomParameter(1, og.Vector4(0.0, 0.0, 1.0, 1.0))
-#
-#        e2 = self.sceneManager.createEntity("west342wt34635t",  "UniSphere.mesh")
-#        e2.setMaterialName("PlainColor")
-#        e2.getSubEntity(0).setCustomParameter(1, og.Vector4(0, 1, 0, 1))
-#        n.attachObject(e)
-#        n.attachObject(e2)
-#        n.setScale(og.Vector3(10, 5, 20))
-        
+
         if self.selectionBuffer is None:
-            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
+            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"), self, self.zoneManager)
 
+#        if self.depthBuffer is None:
+#            self.depthBuffer = DepthBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
+
+
+#        self.progress.quit()
+        print "Time to load module: " + str(t.getMilliseconds() / 1000.0) + " seconds"
+        del t
+
     def addSceneToModule(self, name):
         if self.mainModule is not None:
             self.mainModule.addScene(name)
@@ -643,36 +888,50 @@
     def setModuleExplorer(self, moduleExplorer):
         self.moduleExplorer = moduleExplorer
         self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
+        self.moduleExplorer.setSelectionChangedCallback(self.selectionChangedCallback)
         self.moduleExplorer.setModuleManager(self)
     
     def setPropertyWindow(self, propertyWin):
         self.propertyWindow = propertyWin
+    
+    def selectionChangedCallback(self, items):
+        self.resetSelection()
+        self.userSelectionList = self.selectionBuffer.manualSelectObjects(items)
         
     def selectMapCallback(self, sceneName, mapName):
         self.currentMap = self.mainModule.getMap(mapName, sceneName)
+        self.zoneManager.currentMap = self.currentMap
         if self.currentMap is None:
-            QMessageBox.warning(None, "Don't forget to select a map", "You won't be happy without a map!")
+            print "Don't forget to select a map"
 
         
     # called when a click into Main Ogre Window occurs
     def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
         if self.oneClickEntityPlacement:
-            meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
-            self.startDropModelAction(meshFile, ray)
-            return
-            
+            if self.modelSelectionDialog.listWidget.currentItem() is not None:
+                meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
+                self.startDropModelAction(meshFile, ray)
+                self.moduleExplorer.updateView()
+                return
+            else:
+                print "Warning: OneClickEntityPlacement still runing on without any selected mesh!"
+                return
+                
+        #self.depthBuffer.onSelectionClick(screenX, screenY)
+        
         so = None
         if self.selectionBuffer is not None:
             so = self.selectionBuffer.onSelectionClick(screenX, screenY)
         
         if so is not None:
-            if not so.isPivot:
-                self.propertyWindow.showProperties(so)
-                
+            if not so.isPivot:                
                 if not controlDown and not shiftDown:
                     self.resetSelection()
                     so.setSelected(True)
                     self.userSelectionList.append(so)
+                    self.propertyWindow.showProperties(so)
+                    self.moduleExplorer.deselectAll()
+                    self.moduleExplorer.selectItem(so, True)
                     self.updatePivots()
                 elif controlDown and not shiftDown:
                     so.setSelected(True)
@@ -682,6 +941,8 @@
                             return # object already selected
 
                     self.userSelectionList.append(so)
+                    self.propertyWindow.showProperties(so)
+                    self.moduleExplorer.selectItem(so, True)
                     self.updatePivots()
 
 
@@ -690,12 +951,16 @@
                         if so == selo:
                             so.setSelected(False)
                             self.userSelectionList.remove(selo)
+                            self.moduleExplorer.selectItem(selo, False)
                     self.updatePivots()
+                
             else:
                 #so.entity is the pivot direction that was clicked
                 self.pivot.startTransforming(so.entity,  self.userSelectionList)
         else:
             self.resetSelection() # click in empty space, deselect everything
+            self.moduleExplorer.selectItems(None)
+            self.propertyWindow.clear()
             if self.pivot is not None:
                 self.pivot.hide()
 
@@ -727,6 +992,13 @@
 
         for so in self.userSelectionList:
             node = so.entity.getParentNode()
+            if node.getName().startswith("area_"):
+                self.zoneManager.deleteArea(so.entity.getUserObject())
+                continue
+            elif node.getName().startswith("light_"):
+                light = extractLight(node)
+                self.sceneManager.destroyLight(light)
+                
             node.detachAllObjects()
             self.sceneManager.destroySceneNode(node)
             self.sceneManager.destroyEntity(so.entity)
@@ -734,68 +1006,55 @@
 
         self.userSelectionList = []
 
-    def incrementNameSuffixNumber(self, name):
-        newName = ""
-        split = name.split("_")
-        lastPart = len(split)-1
-        newName = name.rstrip(split[lastPart])
-        newName = newName + str(self.numerOfCopys)
-
-#        if split[lastPart].isdigit() and not split[lastPart].startswith("0"):
-#            num = int(split[lastPart])
-#            num = num + 1
-#            newName = name.rstrip(split[lastPart])
-#            newName = newName + str(num)
-#        else:
-#            newName = name + "_1"
-
-        self.numerOfCopys = self.numerOfCopys + 1
-        return newName
-
     def copyObjects(self):
-        if len(self.userSelectionList) < 1:
+        if len(self.userSelectionList) < 1 or self.currentMap is None:
+            print "Warning: No map selected!"
             return
 
         newSelectionList = []
 
         for so in self.userSelectionList:
             if so.entity.getUserObject() is not None:
-                if so.entity.getUserObject().getType() == "GAME_OBJECT_REPRESENTATION":
+                if str(so.entity.getParentNode().getName()).startswith("gameobject_"):
                     go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
                     meshFile = go.getMeshFileName()
 
                     if go is not None:
-                        newEntity = self.sceneManager.createEntity("dropMesh" + str(ModuleManager.dropCount), str(meshFile))
-                        newNode = self.currentMap.mapNode.createChild("gameObject_dropNode" + str(ModuleManager.dropCount))
+                        newEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+                        newNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
                         newNode.attachObject(newEntity)
                         newNode.setPosition(so.entity.getParentNode().getPosition())
 
                         newGO = GameObjectRepresentation(ModuleManager.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
-                        self.gameObjectRepresentationDict.append(newGO)
+                        self.gocManager.addGameObjectRepresentation(newGO)
                         newEntity.setUserObject(newGO)
-                        newGO.setPosition(og.Vector3(0, 0, 0))
 
-                        newSO = SelectionObject(newEntity, so.distance)
+                        newSO = SelectionObject(newEntity)
                         newSO.setSelected(True)
                         newSelectionList.append(newSO)
                         ModuleManager.dropCount += 1
-            else:
-                nodeName = "entity_dropNode" + str(ModuleManager.dropCount)
-                newNode = self.currentMap.mapNode.createChild(nodeName)
+                elif str(so.entity.getParentNode().getName()).startswith("entity_"):
+                    nodeName = "entity_dropNode" + str(ModuleManager.dropCount)
+                    newNode = self.currentMap.mapNode.createChild(nodeName)
 
-                entityName = "dropMesh" + str(ModuleManager.dropCount)
-                newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+                    entityName = createUniqueEntityName(self.sceneManager)
+                    newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
 
-                newNode.attachObject(newEntity)
-                newNode.setPosition(so.entity.getParentNode().getPosition())
-                newNode.setOrientation(so.entity.getParentNode().getOrientation())
-                newNode.setScale(so.entity.getParentNode().getScale())
+                    eco = so.entity.getUserObject().copy()
+                    newEntity.setUserObject(eco)
 
-                newSO = SelectionObject(newEntity)
-                newSO.setSelected(True)
-                newSelectionList.append(newSO)
-                ModuleManager.dropCount += 1
+                    newNode.attachObject(newEntity)
+                    newNode.setPosition(so.entity.getParentNode().getPosition())
+                    newNode.setOrientation(so.entity.getParentNode().getOrientation())
+                    newNode.setScale(so.entity.getParentNode().getScale())
 
+                    newSO = SelectionObject(newEntity)
+                    newSO.setSelected(True)
+                    newSelectionList.append(newSO)
+                    ModuleManager.dropCount += 1
+                elif str(so.entity.getParentNode().getName()).startswith("light_"):
+                    print "Can't copy lights yet :)"
+
         self.resetSelection()
         self.userSelectionList = newSelectionList
 
@@ -840,8 +1099,9 @@
             self.pivot.stopTransforming()
 
     def resetSelection(self):
-        for so in self.userSelectionList:
-            so.setSelected(False)
+        if self.userSelectionList is not None:
+            for so in self.userSelectionList:
+                so.setSelected(False)
 
         self.userSelectionList = []
 
@@ -860,11 +1120,15 @@
         self.mainModule.save()
 
     def startDropGameObjectAction(self, classid, ray):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
         go = self.gocManager.getGameObjectWithClassId(classid)
 
         if go is not None:
             meshFile = go.getMeshFileName()
-            dropEntity = self.sceneManager.createEntity("dropMesh" + str(ModuleManager.dropCount), str(meshFile))
+            dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
             dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
             dropNode.attachObject(dropEntity)
 
@@ -875,11 +1139,15 @@
                 dropNode.setPosition(ray.getPoint(50))
 
             self.dropGO = GameObjectRepresentation(ModuleManager.dropCount, classid, dropNode, meshFile)
+            self.gocManager.addGameObjectRepresentation(self.dropGO)
             dropEntity.setUserObject(self.dropGO)
 
         ModuleManager.dropCount += 1
 
     def moveDropGameObjectAction(self, ray):
+        if self.currentMap is None:
+            return
+        
         result = og.Math.intersects(ray, self.dropCollisionPlane)
         if result.first == True:
             self.dropGO.setPosition(ray.getPoint(result.second))
@@ -887,6 +1155,8 @@
             self.dropGO.setPosition(ray.getPoint(50))
 
     def finishDropGameObjectAction(self, ray):
+        self.moduleExplorer.updateView()
+        self.dropGO = None
         return
 
     def startDropModelAction(self, meshFile, ray):
@@ -894,8 +1164,11 @@
             print "No map selected!"
             return
             
-        self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(ModuleManager.dropCount), meshFile)
-
+        self.dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), meshFile)
+        
+        eco = EntityCustomOptions()
+        self.dropEntity.setUserObject(eco)
+        
         self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(ModuleManager.dropCount))
         self.dropNode.attachObject(self.dropEntity)
 
@@ -918,6 +1191,7 @@
             self.dropNode.setPosition(ray.getPoint(50))
     
     def finishDropModelAction(self, ray):
+        self.moduleExplorer.updateView()
         return
 
     def startDropMaterialAction(self, text):
@@ -931,6 +1205,7 @@
         if so is not None:
             if not so.entity.getNumSubEntities() > 1:
                 so.entity.setMaterialName(self.dropMat)
+                so.entity.getUserObject().materialName = self.dropMat
             else:
                 i = 0
                 text = "Warning this Entity has more than one SubEntities with the folloing materials: \n\n"
@@ -944,6 +1219,138 @@
                     return
                 if reply == QMessageBox.Yes:
                     so.entity.setMaterialName(self.dropMat)
+                    so.entity.getUserObject().materialName = self.dropMat
         
     def setOneClickEntityPlacement(self, state):
         self.oneClickEntityPlacement = state
+    
+    def createLight(self, name):
+        pos = og.Vector3()
+        
+        query = self.sceneManager.createRayQuery(self.contextMenuRay)
+        query.ray = self.contextMenuRay
+        query.setSortByDistance(True)
+        query.execute(self.raySceneQueryListener)
+        if self.raySceneQueryListener.dist < 100000:
+            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
+            self.raySceneQueryListener.dist = 100000
+            
+        light = None
+        if not self.sceneManager.hasLight(name):
+            light = self.sceneManager.createLight(name)
+            
+        return light,  pos
+        
+    def addPointLight(self):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        lightName = "pointLight" + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+        light, pos = self.createLight(lightName)
+        printVector3(pos)
+        
+        if not light:
+            print "Error while creating light"
+            return
+            
+        light.setType(og.Light.LT_POINT)
+        
+        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
+        n.attachObject(light)
+        n.attachObject(e)
+        n.setPosition(pos)
+        self.moduleExplorer.updateView()
+        
+    def addSpotLight(self):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        lightName = "spotLight" + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+        light, pos = self.createLight(lightName)
+        printVector3(pos)
+        
+        if not light:
+            print "Error while creating light"
+            return
+            
+        light.setType(og.Light.LT_SPOTLIGHT)
+        
+        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
+        n.attachObject(light)
+        n.attachObject(e)
+        n.setPosition(pos)
+        self.moduleExplorer.updateView()
+        
+    def addZoneToMap(self, name):
+        self.zoneManager.createZone(name)
+        self.moduleExplorer.updateView()
+        
+    def setPlayerStart(self):
+        self.mainModule.playerStart = str(self.playerStartGameObjectId)
+        print "setting Player Start to " + str(self.playerStartGameObjectId)
+    
+    def onContextMenu(self, screenX, screenY, ray):
+        menus = []
+        actions = []
+        pla = self.createAction("Pointlight", self.addPointLight, None, "idea.png")
+        pls = self.createAction("Spotlight", self.addSpotLight, None, "idea.png")
+        
+        lightMenu = QMenu("Add Light")
+        lightMenu.addAction(pla)
+        lightMenu.addAction(pls)
+        menus.append(lightMenu)
+        
+        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        self.contextMenuClickPosition = og.Vector2(screenX, screenY)
+        self.contextMenuRay = ray
+        
+        pos = og.Vector3()
+        query = self.sceneManager.createRayQuery(self.contextMenuRay)
+        query.ray = self.contextMenuRay
+        query.setSortByDistance(True)
+        query.execute(self.raySceneQueryListener)
+        if self.raySceneQueryListener.dist < 100000:
+            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
+            self.raySceneQueryListener.dist = 100000
+        
+        if so is not None:
+            self.zoneManager.entityUnderMouse = so.entity
+        
+        self.zoneManager.newAreaPosition = pos
+        menus.append(self.zoneManager.getZoneMenu())
+
+        if so is not None and so.entity.getParentNode().getName().startswith("gameobject_"):
+            actions.append(self.createAction("Set Player Starterpoint", self.setPlayerStart))
+            self.playerStartGameObjectId = so.entity.getUserObject().inWorldId
+            
+                
+            
+        if self.onContextMenuCallback is not None:
+            self.onContextMenuCallback(actions,  menus)
+
+    def setContextMenuCallback(self, callback):
+        self.onContextMenuCallback = callback
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QAction(text, None)
+        if icon is not None:
+            action.setIcon(QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            QWidget.connect(action, SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action

Modified: rl/branches/persistence2/editors/Lockenwickler/src/MovePivot.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/MovePivot.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/MovePivot.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,239 +1,254 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import ogre.renderer.OGRE as og
-
-class Pivot():
-    def __init__(self,  sceneManager):
-        self.sceneManager = sceneManager
-        self.camera = self.sceneManager.getCamera("MainCam")
-
-        self.mode = None
-        self.isHidden = True
-
-        self.meshManager = og.MeshManager.getSingleton ()
-
-        self.pivotNode = sceneManager.getRootSceneNode().createChildSceneNode("pivotNode")
-
-        self.__createMovePivot()
-        self.__createRotatePivot()
-        self.__createScalePivot()
-        self.hide()
-        self.setMoveMode()
-
-        self.moveDirection = None
-        self.isTransforming = False
-        self.selectionList = None
-
-    def __createMovePivot(self):
-        self.xMoveEntity = self.sceneManager.createEntity("EditorXArrow",  "Pivot_Arrow.mesh")
-        self.xMoveEntity.setMaterialName("Lockenwickler_Pivot_X")
-        self.xMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.xMoveNode = self.pivotNode.createChildSceneNode()
-        self.xMoveNode.attachObject(self.xMoveEntity)
-        self.xMoveNode.translate(og.Vector3(2, 0, 0))
-        self.xMoveNode.rotate(og.Vector3().UNIT_Y,  og.Degree(90))
-        
-        self.yMoveEntity = self.sceneManager.createEntity("EditorYArrow",  "Pivot_Arrow.mesh")
-        self.yMoveEntity.setMaterialName("Lockenwickler_Pivot_Y")
-        self.yMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.yMoveNode = self.pivotNode.createChildSceneNode()
-        self.yMoveNode.attachObject(self.yMoveEntity)
-        self.yMoveNode.translate(og.Vector3(0, 2, 0))
-        self.yMoveNode.rotate(og.Vector3().UNIT_X,  og.Degree(-90))
-
-
-        self.zMoveEntity = self.sceneManager.createEntity("EditorZArrow",  "Pivot_Arrow.mesh")
-        self.zMoveEntity.setMaterialName("Lockenwickler_Pivot_Z")
-        self.zMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.zMoveNode = self.pivotNode.createChildSceneNode()
-        self.zMoveNode.attachObject(self.zMoveEntity)
-        self.zMoveNode.translate(og.Vector3(0, 0, 2))
-
-
-    def __createRotatePivot(self):
-        self.xRotateEntity = self.sceneManager.createEntity("EditorXRotator",  "Rotate_Torus.mesh")
-        self.xRotateEntity.setMaterialName("Lockenwickler_Pivot_X")
-        self.xRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.xRotateNode = self.pivotNode.createChildSceneNode()
-        self.xRotateNode.attachObject(self.xRotateEntity)
-        #self.xRotateNode.translate(0, 0, -5)
-        self.xRotateNode.rotate(og.Vector3().UNIT_Y,  og.Degree(90))
-
-        self.yRotateEntity = self.sceneManager.createEntity("EditorYRotator",  "Rotate_Torus.mesh")
-        self.yRotateEntity.setMaterialName("Lockenwickler_Pivot_Y")
-        self.yRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.yRotateNode = self.pivotNode.createChildSceneNode()
-        self.yRotateNode.attachObject(self.yRotateEntity)
-        #self.yRotateNode.translate(0, 0, -10)
-        self.yRotateNode.rotate(og.Vector3().UNIT_X,  og.Degree(90))
-
-        self.zRotateEntity = self.sceneManager.createEntity("EditorZRotator",  "Rotate_Torus.mesh")
-        self.zRotateEntity.setMaterialName("Lockenwickler_Pivot_Z")
-        self.zRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.zRotateNode = self.pivotNode.createChildSceneNode()
-        self.zRotateNode.attachObject(self.zRotateEntity)
-
-
-    def __createScalePivot(self):
-        self.xScaleEntity = self.sceneManager.createEntity("EditorXScaler",  "Pivot_Arrow.mesh")
-        self.xScaleEntity.setMaterialName("Lockenwickler_Pivot_X")
-        self.xScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.xScaleNode = self.pivotNode.createChildSceneNode()
-        self.xScaleNode.attachObject(self.xScaleEntity)
-        self.xScaleNode.translate(og.Vector3(2, 0, 0))
-        self.xScaleNode.rotate(og.Vector3().UNIT_Y,  og.Degree(90))
-        
-        self.yScaleEntity = self.sceneManager.createEntity("EditorYScaler",  "Pivot_Arrow.mesh")
-        self.yScaleEntity.setMaterialName("Lockenwickler_Pivot_Y")
-        self.yScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.yScaleNode = self.pivotNode.createChildSceneNode()
-        self.yScaleNode.attachObject(self.yScaleEntity)
-        self.yScaleNode.translate(og.Vector3(0, 2, 0))
-        self.yScaleNode.rotate(og.Vector3().UNIT_X,  og.Degree(-90))
-
-
-        self.zScaleEntity = self.sceneManager.createEntity("EditorZScaler",  "Pivot_Arrow.mesh")
-        self.zScaleEntity.setMaterialName("Lockenwickler_Pivot_Z")
-        self.zScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.zScaleNode = self.pivotNode.createChildSceneNode()
-        self.zScaleNode.attachObject(self.zScaleEntity)
-        self.zScaleNode.translate(og.Vector3(0, 0, 2))
-
-    def setPosition(self,  pos):
-        self.pivotNode.setPosition(pos)
-
-    def getPosition(self):
-        return self.pivotNode.getPosition()
-
-    def startTransforming(self, dirEntity, soList):
-        self.moveDirection = dirEntity.getName()
-        self.selectionList = soList
-        self.isTransforming = True
-        pass
-
-    def stopTransforming(self):
-        self.isTransforming = False
-        pass
-
-    def hide(self):
-        self.pivotNode.removeAllChildren()
-        self.isHidden = True
-
-    def show(self):
-        self.hide()
-        if self.mode == 1:
-            self.pivotNode.addChild(self.xMoveNode)
-            self.pivotNode.addChild(self.yMoveNode)
-            self.pivotNode.addChild(self.zMoveNode)
-        elif self.mode == 2:
-            self.pivotNode.addChild(self.xRotateNode)
-            self.pivotNode.addChild(self.yRotateNode)
-            self.pivotNode.addChild(self.zRotateNode)
-        elif self.mode == 3:
-            return
-        self.isHidden = False
-
-    def setMoveMode(self):
-        self.hide()
-        self.mode = 1
-        self.pivotNode.addChild(self.xMoveNode)
-        self.pivotNode.addChild(self.yMoveNode)
-        self.pivotNode.addChild(self.zMoveNode)
-    
-    def setRotateMode(self):
-        self.hide()
-        self.mode = 2
-        self.pivotNode.addChild(self.xRotateNode)
-        self.pivotNode.addChild(self.yRotateNode)
-        self.pivotNode.addChild(self.zRotateNode)
-    
-    def setScaleMode(self):
-        self.hide()
-        self.mode = 3
-        self.pivotNode.addChild(self.xScaleNode)
-        self.pivotNode.addChild(self.yScaleNode)
-        self.pivotNode.addChild(self.zScaleNode)
-        
-    def onMouseMoved(self, globalX, globalY, incX, incY):
-        # move mode
-        if self.isTransforming:
-            if self.mode == 1:
-                transFactor = 0.1
-                transVec = og.Vector3()
-                if self.moveDirection == "EditorXArrow":
-                    transVec = og.Vector3(-incX, 0.0 , 0.0)
-                elif self.moveDirection == "EditorYArrow":
-                    transVec = og.Vector3(0.0, -incY, 0.0)
-                elif self.moveDirection == "EditorZArrow":
-                    transVec = og.Vector3(0.0, 0.0, incX)
-
-                transVec = transVec * transFactor
-                for so in self.selectionList:
-                    so.entity.getParentNode().translate(transVec)
-                    
-                self.pivotNode.translate(transVec)
-
-            # rotate mode
-            elif self.mode == 2:
-                rotValue = (incX + incY) * 0.05
-
-                if self.moveDirection == "EditorXRotator":
-                    for so in self.selectionList:
-                        so.entity.getParentNode().pitch(rotValue)
-                if self.moveDirection == "EditorYRotator":
-                    for so in self.selectionList:
-                        so.entity.getParentNode().yaw(rotValue)
-                if self.moveDirection == "EditorZRotator":
-                    for so in self.selectionList:
-                        so.entity.getParentNode().roll(rotValue)
-            
-            # scale mode
-            elif self.mode == 3:
-                scaleFactor = 0.3
-                if self.moveDirection == "EditorXScaler":
-                    for so in self.selectionList:
-                        scale = so.entity.getParentNode().getScale() + og.Vector3(incX * scaleFactor, 0, 0)
-                        so.entity.getParentNode().setScale(scale)
-                if self.moveDirection == "EditorYScaler":
-                    for so in self.selectionList:
-                        scale = so.entity.getParentNode().getScale() + og.Vector3(0, incY * scaleFactor, 0)
-                        so.entity.getParentNode().setScale(scale)
-                if self.moveDirection == "EditorZScaler":
-                    for so in self.selectionList:
-                        scale = so.entity.getParentNode().getScale() + og.Vector3(0, 0, incX * scaleFactor)
-                        so.entity.getParentNode().setScale(scale)
-        
-        self.update()
-
-    def update(self):
-        vSize = og.Vector3(1.0,1.0,1.0)
-        vScale = og.Vector3(1.0,1.0,1.0)
-
-        dist = (self.camera.getDerivedPosition() - self.pivotNode._getDerivedPosition()).length()
-        vScale *= dist / 90.0
-
-        self.pivotNode.setScale(vScale.x * vSize.x,vScale.y * vSize.y,vScale.z * vSize.z)
-        #print vScale.x * vSize.x,vScale.y * vSize.y,vScale.z * vSize.z
-#        if not self.isHidden:
-#            dist = self.camera.getPosition().distance(self.pivotNode.getPosition())
-#            self.pivotNode.setScale(og.Vector3(0.5,  0.5,  0.5) * (dist / 30))
-
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+
+import sys
+import ogre.renderer.OGRE as og
+
+class Pivot():
+    def __init__(self,  sceneManager):
+        self.sceneManager = sceneManager
+        self.camera = self.sceneManager.getCamera("MainCam")
+
+        self.mode = None
+        self.isHidden = True
+
+        self.meshManager = og.MeshManager.getSingleton ()
+
+        self.pivotNode = sceneManager.getRootSceneNode().createChildSceneNode("pivotNode")
+
+        self.__createMovePivot()
+        self.__createRotatePivot()
+        self.__createScalePivot()
+        self.hide()
+        self.setMoveMode()
+
+        self.moveDirection = None
+        self.isTransforming = False
+        self.selectionList = None
+
+    def __createMovePivot(self):
+        self.xMoveEntity = self.sceneManager.createEntity("EditorXArrow",  "Pivot_Arrow.mesh")
+        self.xMoveEntity.setMaterialName("Lockenwickler_Pivot_X")
+        self.xMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.xMoveNode = self.pivotNode.createChildSceneNode()
+        self.xMoveNode.attachObject(self.xMoveEntity)
+        self.xMoveNode.translate(og.Vector3(2, 0, 0))
+        self.xMoveNode.rotate(og.Vector3().UNIT_Y,  og.Degree(90))
+        
+        self.yMoveEntity = self.sceneManager.createEntity("EditorYArrow",  "Pivot_Arrow.mesh")
+        self.yMoveEntity.setMaterialName("Lockenwickler_Pivot_Y")
+        self.yMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.yMoveNode = self.pivotNode.createChildSceneNode()
+        self.yMoveNode.attachObject(self.yMoveEntity)
+        self.yMoveNode.translate(og.Vector3(0, 2, 0))
+        self.yMoveNode.rotate(og.Vector3().UNIT_X,  og.Degree(-90))
+
+
+        self.zMoveEntity = self.sceneManager.createEntity("EditorZArrow",  "Pivot_Arrow.mesh")
+        self.zMoveEntity.setMaterialName("Lockenwickler_Pivot_Z")
+        self.zMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.zMoveNode = self.pivotNode.createChildSceneNode()
+        self.zMoveNode.attachObject(self.zMoveEntity)
+        self.zMoveNode.translate(og.Vector3(0, 0, 2))
+
+
+    def __createRotatePivot(self):
+        self.xRotateEntity = self.sceneManager.createEntity("EditorXRotator",  "Rotate_Torus.mesh")
+        self.xRotateEntity.setMaterialName("Lockenwickler_Pivot_X")
+        self.xRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.xRotateNode = self.pivotNode.createChildSceneNode()
+        self.xRotateNode.attachObject(self.xRotateEntity)
+        #self.xRotateNode.translate(0, 0, -5)
+        self.xRotateNode.rotate(og.Vector3().UNIT_Y,  og.Degree(90))
+
+        self.yRotateEntity = self.sceneManager.createEntity("EditorYRotator",  "Rotate_Torus.mesh")
+        self.yRotateEntity.setMaterialName("Lockenwickler_Pivot_Y")
+        self.yRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.yRotateNode = self.pivotNode.createChildSceneNode()
+        self.yRotateNode.attachObject(self.yRotateEntity)
+        #self.yRotateNode.translate(0, 0, -10)
+        self.yRotateNode.rotate(og.Vector3().UNIT_X,  og.Degree(90))
+
+        self.zRotateEntity = self.sceneManager.createEntity("EditorZRotator",  "Rotate_Torus.mesh")
+        self.zRotateEntity.setMaterialName("Lockenwickler_Pivot_Z")
+        self.zRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.zRotateNode = self.pivotNode.createChildSceneNode()
+        self.zRotateNode.attachObject(self.zRotateEntity)
+
+
+    def __createScalePivot(self):
+        self.xScaleEntity = self.sceneManager.createEntity("EditorXScaler",  "Pivot_Arrow.mesh")
+        self.xScaleEntity.setMaterialName("Lockenwickler_Pivot_X")
+        self.xScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.xScaleNode = self.pivotNode.createChildSceneNode()
+        self.xScaleNode.attachObject(self.xScaleEntity)
+        self.xScaleNode.translate(og.Vector3(2, 0, 0))
+        self.xScaleNode.rotate(og.Vector3().UNIT_Y,  og.Degree(90))
+        
+        self.yScaleEntity = self.sceneManager.createEntity("EditorYScaler",  "Pivot_Arrow.mesh")
+        self.yScaleEntity.setMaterialName("Lockenwickler_Pivot_Y")
+        self.yScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.yScaleNode = self.pivotNode.createChildSceneNode()
+        self.yScaleNode.attachObject(self.yScaleEntity)
+        self.yScaleNode.translate(og.Vector3(0, 2, 0))
+        self.yScaleNode.rotate(og.Vector3().UNIT_X,  og.Degree(-90))
+
+
+        self.zScaleEntity = self.sceneManager.createEntity("EditorZScaler",  "Pivot_Arrow.mesh")
+        self.zScaleEntity.setMaterialName("Lockenwickler_Pivot_Z")
+        self.zScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.zScaleNode = self.pivotNode.createChildSceneNode()
+        self.zScaleNode.attachObject(self.zScaleEntity)
+        self.zScaleNode.translate(og.Vector3(0, 0, 2))
+        
+        self.uniScaleEntity = self.sceneManager.createEntity("UniScaler",  "UniCube.mesh")
+        self.uniScaleEntity.setMaterialName("Lockenwickler_FreeMover")
+        self.uniScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.uniScaleNode = self.pivotNode.createChildSceneNode()
+        self.uniScaleNode.attachObject(self.uniScaleEntity)
+
+    def setPosition(self,  pos):
+        self.pivotNode.setPosition(pos)
+
+    def getPosition(self):
+        return self.pivotNode.getPosition()
+
+    def startTransforming(self, dirEntity, soList):
+        self.moveDirection = dirEntity.getName()
+        self.selectionList = soList
+        self.isTransforming = True
+
+    def stopTransforming(self):
+        self.isTransforming = False
+
+    def hide(self):
+        self.pivotNode.removeAllChildren()
+        self.isHidden = True
+
+    def show(self):
+        self.hide()
+        if self.mode == 1:
+            self.pivotNode.addChild(self.xMoveNode)
+            self.pivotNode.addChild(self.yMoveNode)
+            self.pivotNode.addChild(self.zMoveNode)
+        elif self.mode == 2:
+            self.pivotNode.addChild(self.xRotateNode)
+            self.pivotNode.addChild(self.yRotateNode)
+            self.pivotNode.addChild(self.zRotateNode)
+        elif self.mode == 3:
+            self.pivotNode.addChild(self.xScaleNode)
+            self.pivotNode.addChild(self.yScaleNode)
+            self.pivotNode.addChild(self.zScaleNode)
+            self.pivotNode.addChild(self.uniScaleNode)
+        self.isHidden = False
+
+    def setMoveMode(self):
+        self.hide()
+        self.mode = 1
+        self.pivotNode.addChild(self.xMoveNode)
+        self.pivotNode.addChild(self.yMoveNode)
+        self.pivotNode.addChild(self.zMoveNode)
+    
+    def setRotateMode(self):
+        self.hide()
+        self.mode = 2
+        self.pivotNode.addChild(self.xRotateNode)
+        self.pivotNode.addChild(self.yRotateNode)
+        self.pivotNode.addChild(self.zRotateNode)
+    
+    def setScaleMode(self):
+        self.hide()
+        self.mode = 3
+        self.pivotNode.addChild(self.xScaleNode)
+        self.pivotNode.addChild(self.yScaleNode)
+        self.pivotNode.addChild(self.zScaleNode)
+        self.pivotNode.addChild(self.uniScaleNode)
+        
+    def onMouseMoved(self, globalX, globalY, incX, incY):
+        # move mode
+        if self.isTransforming:
+            if self.mode == 1:
+                transFactor = 0.1
+                transVec = og.Vector3()
+                if self.moveDirection == "EditorXArrow":
+                    transVec = og.Vector3(-incX, 0.0 , 0.0)
+                elif self.moveDirection == "EditorYArrow":
+                    transVec = og.Vector3(0.0, -incY, 0.0)
+                elif self.moveDirection == "EditorZArrow":
+                    transVec = og.Vector3(0.0, 0.0, incX)
+
+                transVec = transVec * transFactor
+                for so in self.selectionList:
+                    so.entity.getParentNode().translate(transVec)
+                    
+                self.pivotNode.translate(transVec)
+
+            # rotate mode
+            elif self.mode == 2:
+                rotValue = (incX + incY) * 0.05
+
+                if self.moveDirection == "EditorXRotator":
+                    for so in self.selectionList:
+                        so.entity.getParentNode().pitch(rotValue)
+                if self.moveDirection == "EditorYRotator":
+                    for so in self.selectionList:
+                        so.entity.getParentNode().yaw(rotValue)
+                if self.moveDirection == "EditorZRotator":
+                    for so in self.selectionList:
+                        so.entity.getParentNode().roll(rotValue)
+            
+            # scale mode
+            elif self.mode == 3:
+                scaleFactor = 0.3
+                if self.moveDirection == "EditorXScaler":
+                    for so in self.selectionList:
+                        scale = so.entity.getParentNode().getScale() + og.Vector3(incX * scaleFactor, 0, 0)
+                        so.entity.getParentNode().setScale(scale)
+                if self.moveDirection == "EditorYScaler":
+                    for so in self.selectionList:
+                        scale = so.entity.getParentNode().getScale() + og.Vector3(0, incY * scaleFactor, 0)
+                        so.entity.getParentNode().setScale(scale)
+                if self.moveDirection == "EditorZScaler":
+                    for so in self.selectionList:
+                        scale = so.entity.getParentNode().getScale() + og.Vector3(0, 0, incX * scaleFactor)
+                        so.entity.getParentNode().setScale(scale)
+                if self.moveDirection == "UniScaler":
+                    for so in self.selectionList:
+                        val = incY / 6.0
+                        print val
+                        scale = so.entity.getParentNode().getScale() + og.Vector3(val * scaleFactor, val * scaleFactor, val * scaleFactor)
+                        so.entity.getParentNode().setScale(scale)
+        
+        self.update()
+
+    def update(self):
+        vSize = og.Vector3(1.0,1.0,1.0)
+        vScale = og.Vector3(1.0,1.0,1.0)
+
+        dist = (self.camera.getDerivedPosition() - self.pivotNode._getDerivedPosition()).length()
+        vScale *= dist / 90.0
+
+        self.pivotNode.setScale(vScale.x * vSize.x,vScale.y * vSize.y,vScale.z * vSize.z)
+        #print vScale.x * vSize.x,vScale.y * vSize.y,vScale.z * vSize.z
+#        if not self.isHidden:
+#            dist = self.camera.getPosition().distance(self.pivotNode.getPosition())
+#            self.pivotNode.setScale(og.Vector3(0.5,  0.5,  0.5) * (dist / 30))
+
+

Modified: rl/branches/persistence2/editors/Lockenwickler/src/MyRaySceneQueryListener.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,347 +1,44 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-import ctypes
-import ogre.renderer.OGRE as og
-import ogre.physics.OgreNewt as on
-
-# a class to store information about a object that got selected
-class SelectionObject():
-    def __init__(self,  entity,  distance):
-        self.entityName = entity.getName()
-        self.entity = entity #the selected entity
-        self.distance = distance # the distance from camera at the time of selection
-        self.isPivot = False
-
-#        if self.entity.getUserObject() is not None:
-#            self.isGameObject = True
-#        else:
-#            self.isGameObject = False
-
-    #if True this instance will show its bounding box else it will hide it
-    def setSelected(self,  selected):
-        if selected == True:
-            self.entity.getParentNode().showBoundingBox(True)
-        else:
-            self.entity.getParentNode().showBoundingBox(False)
-
-    def __eq__(self, other):
-        return self.entity.getName() == other.entity.getName()
-
-    def __ne__(self, other):
-        return self.entity.getName() != other.entity.getName()
-
-class MyRaySceneQueryListener ( og.RaySceneQueryListener ):
-    def __init__( self ):
-        super ( MyRaySceneQueryListener, self ).__init__()
-        self.previouseSelection = None
-        self.selectionList = []
-        self.previousSelected = -1
-        self.currentSelected = -1
-
-        self.mNormalList = []
-        self.mVertexList = []
-        self.mIndexList = []
-
-        self.currentRay = None
-        self.lastRay = None
-
-        self.World = on.World()
-        self.World.setWorldSize(og.Vector3(-1000000, -1000000, -1000000), og.Vector3(1000000, 1000000, 1000000))
-
-    def __del__(self):
-        del self.World
-
-    # sort algorithm for the selection list
-    def sortCompareImp(self,  x,  y):
-        if x.distance > y.distance:
-            return 1
-        elif x.distance == y.distance:
-            return 0
-        else: # x<y
-            return -1
-
-    def queryResult ( self, entity, distance ):
-        #print "dbg: " + entity.getName()
-        if distance == 0.0: #camera is in the bounding box, ignore this selection
-            return True
-        elif entity.getName() == "OgreMainWin::0::ViewportGrid":
-            return True
-        elif entity.getName() == "rayLine":
-            return True
-        elif entity.isVisible() and entity.getName() == "EditorXArrow":
-            so = SelectionObject(entity,  distance)
-            so.isPivot = True
-            self.selectionList.append(so)
-            return False
-        elif entity.isVisible() and entity.getName() == "EditorYArrow":
-            so = SelectionObject(entity,  distance)
-            so.isPivot = True
-            self.selectionList.append(so)
-            return False
-        elif entity.isVisible() and entity.getName() == "EditorZArrow":
-            so = SelectionObject(entity,  distance)
-            so.isPivot = True
-            self.selectionList.append(so)
-            return False
-        elif entity.isVisible() and entity.getName() == "EditorFreeMover":
-            return True
-        elif entity.getName() == "EditorXRotator" or entity.getName() == "EditorYRotator" or entity.getName() == "EditorZRotator":
-            if entity.isVisible() and self.rayCastToPolygonLevelOnSingleMesh(self.currentRay,  entity):
-                so = SelectionObject(entity,  distance)
-                so.isPivot = True
-                self.selectionList.append(so)
-                return False
-            else:
-                return True
-        else:
-            so = SelectionObject(entity,  distance)
-            self.selectionList.append(so)
-
-        self.selectionList.sort(self.sortCompareImp)
-
-        return True
-
-    def reset(self):
-        self.previousSelected = -1
-        self.currentSelected = -1
-        del self.selectionList[:]
-        #self.selectionList = []
-
-    def rayCastToPolygonLevel(self,  ray):
-        self.lastRay = ray
-
-        for so in self.selectionList:
-            if so.isPivot:
-                return so
-
-        if len(self.selectionList) >= 1:
-            for so in self.selectionList:
-                if self.rayCastToPolygonLevelOnSingleMesh(ray,  so.entity):
-                    return so
-
-
-    def rayCastToPolygonLevelOnSingleMesh(self,  ray,  entity):
-        col = on.TreeCollision(self.World, entity.getParentNode(), False)
-        bod = on.Body(self.World, col)
-
-
-        start = ray.getOrigin()
-        end = ray.getPoint(10000)
-
-        retNorm = og.Vector3(0.0, 0.0, 0.0)
-
-        val = on.CollisionRayCast(col, start, end, retNorm)
-#        print val
-#
-#        print retNorm.x
-#        print retNorm.y
-#        print retNorm.z
-        del col
-        self.World.destroyAllBodies()
-        
-        if retNorm.x != 0.0 or retNorm.y != 0.0 or retNorm.z != 0.0:
-#           print "yes"
-           return True
-        else:
-#            print "no"
-            return False
-           
-        
-        
-
-#    def iterateEntityUnderMouse(self):
-#        self.previousSelected = self.currentSelected
-#        if len(self.selectionList) >= self.currentSelected: # would mean we are out of bounds
-#            self.selectionList[self.currentSelected].setSelected(False)
-#
-#        self.currentSelected += 1
-#
-#        if len(self.selectionList) == self.currentSelected: # means we are out of bounds and reached the end of the list, reset it to zero
-#            self.currentSelected = 0
-#
-#        if len(self.selectionList) >= self.currentSelected: # would mean we are out of bounds
-#            #print str(self.selectionList[self.currentSelected].distance) + " "  + self.selectionList[self.currentSelected].entity.getName()
-#            if self.rayCastToPolygonLevelOnCurrentSelection():
-#                self.selectionList[self.currentSelected].setSelected(True)
-#                return self.selectionList[self.currentSelected]
-
-
-#    def getMeshInformation(self,  entity):
-#        numVertices = 0
-#        numIndices = 0
-#        useSharedVertices = False
-#
-#        if not entity:
-#            return False
-#
-#        pMesh = entity.getMesh()
-#
-#        position =    entity.getParentNode()._getDerivedPosition()
-#        orient = entity.getParentNode()._getDerivedOrientation()
-#        scale =  entity.getParentNode().getScale()
-#
-#        for i in range ( pMesh.getNumSubMeshes() ):
-#            pSubMesh = pMesh.getSubMesh(i)
-#            if pSubMesh.useSharedVertices:
-#                useSharedVertices = True
-#            else:
-#                numVertices += pSubMesh.vertexData.vertexCount
-#            numIndices += pSubMesh.indexData.indexCount
-#
-#        if useSharedVertices:
-#            numVertices += pMesh.sharedVertexData.vertexCount
-#
-#            storageclass = ctypes.c_float * 3
-#            test=storageclass(0.0,  0.0,  0.0)
-##         mVertexList = new Point[numVertices];
-##         mIndexList = new unsigned int[numIndices];
-#
-#        self.mVertexList = []
-#        self.mIndexList = []
-#
-#        ## Count the number of vertices and incides so we can Set them
-#        indexCount = 0
-#        vertListCount = 0
-#
-#        if useSharedVertices:
-#            ## Real* pVertices (x, y, z order x numVertices)
-#            elem = pMesh.sharedVertexData.vertexDeclaration.findElementBySemantic(og.VES_POSITION)
-#
-#            if not elem:
-#                ogre.Except(Exception.ERR_ITEM_NOT_FOUND, "Can't find position elements in the "
-#                    "mesh to be written!", "MeshSerializerImpl.writeGeometry")
-#
-#            vbuf = pMesh.sharedVertexData.vertexBufferBinding.getBuffer(elem.getSource())
-#
-#            ## need space for the 3 verticies
-#            storageclass = ctypes.c_float * 3
-#            test=storageclass(0.0,  0.0,  0.0)
-#
-#            for j in range ( pMesh.sharedVertexData.vertexCount ):
-#                vbuf.readData(j * vbuf.getVertexSize(), 3 * ctype.sizeof(ctype.c_float), ctype.addressof(test))
-#                pt = og.Vector3(test[0], test[1], test[2])
-#                self.mVertexList.append( (orient * (pt * scale)) + position )
-#                vertListCount+=1
-#
-#        for i in range ( pMesh.getNumSubMeshes() ):
-#            pSubMesh = pMesh.getSubMesh(i)
-#            if not pSubMesh.useSharedVertices:
-#                ## Real* pVertices (x, y, z order x numVertices)
-#                elem = pSubMesh.vertexData.vertexDeclaration.findElementBySemantic(og.VES_POSITION)
-#
-#                if not elem:
-#                    og.Except(Exception.ERR_ITEM_NOT_FOUND, "Can't find position elements in the "
-#                        "mesh to be written!", "MeshSerializerImpl.writeGeometry")
-#
-#                vbuf = pSubMesh.vertexData.vertexBufferBinding.getBuffer(elem.getSource())
-#
-#                ## need space for the verticies
-#                storageclass = ctypes.c_float * (pSubMesh.vertexData.vertexCount * 6)
-#                test=storageclass(0.0)
-#
-#                vbuf.readData(0, pSubMesh.vertexData.vertexCount * 6 * ctypes.sizeof(ctypes.c_float), ctypes.addressof(test))
-#
-#                for j in range ( 0,  pSubMesh.vertexData.vertexCount * 6,  6):
-#                    #print j
-#                    pt = og.Vector3(test[j], test[j+1], test[j+2])
-#                    self.mVertexList.append( (orient * (pt * scale)) + position )
-#                    vertListCount += 1
-#
-#            ibuf = pSubMesh.indexData.indexBuffer
-#            ## need space for the verticies
-#            storageclass = ctypes.c_ushort * pSubMesh.indexData.indexCount
-#            test2=storageclass()
-#
-#
-#            ibuf.readData(0, ibuf.getSizeInBytes(), ctypes.addressof(test2))
-#            for j in range ( pSubMesh.indexData.indexCount ):
-#                self.mIndexList.append (test2[j])   # unsigned short
-#                indexCount += 1
-#
-#            ih = 0
-#            for blah in self.mVertexList:
-#                #print str(ih) + ": "  +  str(blah)
-#                ih += 1
-#
-#    def rayCastToPolygonLevel(self,  ray):
-#        self.lastRay = ray
-#
-#        for so in self.selectionList:
-#            if so.isPivot:
-#                return so
-#
-#        if len(self.selectionList) >= 1:
-#            for so in self.selectionList:
-#                if self.rayCastToPolygonLevelOnSingleMesh(ray,  so.entity):
-#                    return so
-#
-#
-#    def rayCastToPolygonLevelOnSingleMesh(self,  ray,  entity):
-#        self.getMeshInformation(entity)
-#        name = entity.getName()
-#        print "dbg: " + name
-#
-#        temp = []
-#        for vec in self.mVertexList:
-#            temp.append(vec.x)
-#            temp.append(vec.y)
-#            temp.append(vec.z)
-#
-#        globalPosition = entity.getParentNode()._getDerivedPosition()
-#        globalOrientation = entity.getParentNode()._getDerivedOrientation()
-#
-#
-#        i = 0
-#        while i <= (len(self.mIndexList) - 3):
-#            verta = globalPosition + self.mVertexList[self.mIndexList[i]]
-#            vertb = globalPosition + self.mVertexList[self.mIndexList[i+1]]
-#            vertc = globalPosition + self.mVertexList[self.mIndexList[i+2]]
-#
-#            verta = globalOrientation * verta
-#            vertb = globalOrientation * vertb
-#            vertc = globalOrientation * vertc
-#            normal = og.Math.calculateBasicFaceNormal(verta, vertb, vertc)
-#
-#            result = og.Math.intersects(ray, verta, vertb, vertc, True, True)
-#            #result = og.Math.intersects(ray, globalPosition + self.mVertexList[self.mIndexList[i]], globalPosition + self.mVertexList[self.mIndexList[i+1]],
-#            #                                                                                                                                              globalPosition + self.mVertexList[self.mIndexList[i+2]], normal,  True, True)
-#
-#            if result.first:
-#                #print "dbg: Treffer!!!!!!!!!"
-#                return True
-#
-#            i += 3
-#
-#        return False
-#
-#    def rayCastToPolygonLevelOnCurrentSelection(self):
-#        if len(self.selectionList) >= 1:
-#            self.getMeshInformation(self.selectionList[self.currentSelected].entity)
-#
-#            i = 0
-#            while i <= (len(self.mIndexList) - 3):
-#                globalPosition = self.selectionList[self.currentSelected].entity.getParentNode().getPosition()
-#                result = og.Math.intersects(self.lastRay, globalPosition + self.mVertexList[self.mIndexList[i]], globalPosition + self.mVertexList[self.mIndexList[i+1]],
-#                                                                                                                                                          globalPosition + self.mVertexList[self.mIndexList[i+2]], True, True)
-#
-#                if result.first:
-#                   return True
-#
-#                i += 3
-#            return False
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+class MyRaySceneQueryListener ( og.RaySceneQueryListener ):
+    def __init__( self ):
+        super ( MyRaySceneQueryListener, self ).__init__()
+        self.dist = 100000
+        
+    # sort algorithm for the selection list
+    def sortCompareImp(self,  x,  y):
+        if x.distance > y.distance:
+            return 1
+        elif x.distance == y.distance:
+            return 0
+        else: # x<y
+            return -1
+
+    def queryResult ( self, entity, distance ):
+#        if distance == 0.0: #camera is in the bounding box, ignore this selection
+#            return True
+        
+        if self.dist > distance:
+            self.dist = distance
+
+        return True

Modified: rl/branches/persistence2/editors/Lockenwickler/src/NewModuleWizard.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/NewModuleWizard.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/NewModuleWizard.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,5 +1,21 @@
-# -*- coding: utf-8 -*-
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 """
 Module implementing NewModuleWizard.
 """
@@ -119,25 +135,50 @@
         f.write("    def getDependencies()\n")
         f.write("       return [" + str(mdeps) + "];\n")
         f.write("    end\n\n")
-        f.write("    def getTextureLocation()\n")
+        f.write("    def getTextureLocations()\n")
         f.write("       return [\"textures\"];\n")
         f.write("    end\n\n")
-        f.write("    def getModelLocation()\n")
+        f.write("    def getModelLocations()\n")
         f.write("       return [\"models\"];\n")
         f.write("    end\n\n")
-        f.write("    def getSoundLocation()\n")
+        f.write("    def getSoundLocations()\n")
         f.write("       return [\"sound\"];\n")
         f.write("    end\n\n")
         f.write("    def start()\n")
-        f.write(sdeps)
-        f.write("\n\n       SceneManager.getSingleton().loadScene(\"" + self.sceneNameLineEdit.text() + "\");\n")
-        f.write("       $World = $CORE.getWorld();\n")
+        f.write(sdeps + "\n")
+        f.write("       require 'player.rb'\n")
+        f.write("       require 'mckhero.rb'\n")
+        f.write("       $PM.setEnabled(true);\n\n")
+        f.write("\n\n       SceneManager.getSingleton().loadScene(\"" + self.sceneNameLineEdit.text() + "\");\n\n")
+        f.write("       hero = $GOM.getGameObject(XXXXXX);\n")
+        f.write("       PlayerSettings.preparePlayer(hero)\n")
+        f.write("       PartyManager.getSingleton().setActiveCharacter(hero)\n\n")
         f.write("    end\n")
         f.write("end\n\n")
-
         f.write("CoreSubsystem.getSingleton().registerModule(" + mname.capitalize() + "Module.new());\n")
         f.close()
         
+        
+        
+        p = os.path.join(modulePath, "maps")
+        p = os.path.join(p, str(self.sceneNameLineEdit.text()) + ".rlscene")
+        
+        f = open(p, "w")
+        f.write("<scene name=\"" + str(self.sceneNameLineEdit.text()) + "\">\n")
+        f.write("    <map file=\"" + str(self.mapNameLineEdit.text()) + ".rlmap.xml\"" +  "/>\n")
+        f.write("</scene>\n")
+        f.close()
+        
+        p = os.path.join(modulePath, "maps")
+        p = os.path.join(p, str(self.mapNameLineEdit.text()) + ".rlmap.xml")
+        
+        f = open(p, "w")
+        f.write("<rastullahmap formatVersion=\"0.4.0\">\n")
+        f.write("    <nodes>\n")
+        f.write("    </nodes>\n")
+        f.write("</rastullahmap>\n")
+        f.close()
+        
         self.moduleManager.resetParsedModuleConfig()
         self.moduleManager.openLoadModuleDialog()
         

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyModel.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyModel.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyModel.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 import sys
 

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 import sys
@@ -22,14 +23,103 @@
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *
 
+import ogre.renderer.OGRE as og
+
 from Property import *
+import ModuleManager
 
+class BoolEditor(QDialog):
+    def __init__(self, currentSelectedText, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setGeometry(QCursor.pos().x(), QCursor.pos().y(), 100, 30)
+        
+        layout = QVBoxLayout()
+        layout.setContentsMargins(0, 0, 0, 0)
+        
+        currentSelected = False
+        if currentSelectedText == "True" or currentSelectedText == "true":
+            currentSelected = True
+        
+        self.combo = QComboBox()
+        self.combo.addItem("True")
+        self.combo.addItem("False")
+        
+        if not currentSelected:
+            self.combo.setCurrentIndex(1)
+        
+        layout.addWidget(self.combo)
+        self.setLayout(layout)
+        
+        self.connect(self.combo, SIGNAL("currentIndexChanged ( const QString &)"), self.accept)
+    
+    def getValue(self):
+        ret = True
+        if str(self.combo.currentText()) == "False":
+            ret = False
+        
+        return ret
+    
+class GameObjectStateEditor(QDialog):
+    def __init__(self, currentSelectedText, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setGeometry(QCursor.pos().x(), QCursor.pos().y(), 100, 30)
+        
+        layout = QVBoxLayout()
+        layout.setContentsMargins(0, 0, 0, 0)
+        
+        self.combo = QComboBox()
+        self.combo.addItem("IN_SCENE")
+        self.combo.addItem("LOADED")
+        self.combo.addItem("HELD")
+        self.combo.addItem("IN_POSSESSION")
+        self.combo.addItem("READIED")
+
+        self.combo.setCurrentIndex(self.combo.findText(currentSelectedText))
+        
+
+        layout.addWidget(self.combo)
+        self.setLayout(layout)
+        
+        self.connect(self.combo, SIGNAL("currentIndexChanged ( const QString &)"), self.accept)
+    
+    def getValue(self):
+        return str(self.combo.currentText())
+        
+class EntityPhysicsProxyEditor(QDialog):
+    def __init__(self, currentSelectedText, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setGeometry(QCursor.pos().x(), QCursor.pos().y(), 100, 30)
+        
+        layout = QVBoxLayout()
+        layout.setContentsMargins(0, 0, 0, 0)
+        
+        self.combo = QComboBox()
+        self.combo.addItem("none")
+        self.combo.addItem("box")
+        self.combo.addItem("sphere")
+        self.combo.addItem("ellipsoid")
+        self.combo.addItem("pyramid")
+        self.combo.addItem("mesh")
+        self.combo.addItem("convexhull")
+        self.combo.addItem("custom - Not supported by editor yet!")
+
+        self.combo.setCurrentIndex(self.combo.findText(currentSelectedText))
+        
+        layout.addWidget(self.combo)
+        self.setLayout(layout)
+        
+        self.connect(self.combo, SIGNAL("currentIndexChanged ( const QString &)"), self.accept)
+    
+    def getValue(self):
+        return str(self.combo.currentText())
+    
 class ObjectPropertyWin(QDialog):
-    def __init__(self, sceneManager, parent=None):
+    def __init__(self, sceneManager, gocManager, parent=None):
         super(QDialog, self).__init__(parent)
         self.setupUi()
         self.sceneManager = sceneManager
         self.valueBeforeEdit = None
+        self.gocManager = gocManager
         
         self.connect(self.treeWidget, SIGNAL("itemDoubleClicked (QTreeWidgetItem *,int)"),
                                self.onItemClicked)
@@ -58,27 +148,131 @@
 
     def onItemClicked(self, item, column):
         if column == 1:
-            self.valueBeforeEdit = item.text(column)
-            self.treeWidget.editItem(item, column)
+            self.valueBeforeEdit = str(item.text(column))
+            
+            if item.text(0) == "State":
+                ed = GameObjectStateEditor(item.text(column), self)
+                ed.exec_()
+                item.setText(column, ed.getValue())
+                self.node.getAttachedObject(0).getUserObject().state = ed.getValue()
+                
+            elif item.text(0) == "Receives Shadows":
+                bedit = BoolEditor(item.text(column), self)
+                bedit.exec_()
+                item.setText(column, bedit.getValue())
+                self.node.getAttachedObject(0).getUserObject().receivesShadow = str(bedit.getValue())
+            elif item.text(0) == "Physics Proxy Type":
+                bedit = EntityPhysicsProxyEditor(item.text(column), self)
+                bedit.exec_()
+                item.setText(column, bedit.getValue())
+                self.node.getAttachedObject(0).getUserObject().physicsproxytype = bedit.getValue()
+            elif item.text(0) == "Visibility":
+                bedit = BoolEditor(item.text(column), self)
+                bedit.exec_()
+                item.setText(column, str(bedit.getValue()))
+                ModuleManager.extractLight(self.node).setVisible(bedit.getValue())
+            elif item.text(0) == "CastShadows":
+                bedit = BoolEditor(item.text(column), self)
+                bedit.exec_()
+                item.setText(column, str(bedit.getValue()))
+                ModuleManager.extractLight(self.node).setCastShadows(bedit.getValue())
+            elif item.text(0) == "Diffuse Color":
+                min = 1.0 / 255.0
+                col = ModuleManager.extractLight(self.node).getDiffuseColour()
+                newColor = QColorDialog.getColor(QColor(col.r * 255, col.g * 255, col.g * 255), self)
+                ModuleManager.extractLight(self.node).setDiffuseColour(og.ColourValue(min * newColor.red(), min * newColor.green(), min * newColor.blue()))
+                self.showProperties(self.so)
+            elif item.text(0) == "Specular Color":
+                min = 1.0 / 255.0
+                col = ModuleManager.extractLight(self.node).getSpecularColour()
+                newColor = QColorDialog.getColor(QColor(col.r * 255, col.g * 255, col.g * 255), self)
+                ModuleManager.extractLight(self.node).setSpecularColour(og.ColourValue(min * newColor.red(), min * newColor.green(), min * newColor.blue()))
+                self.showProperties(self.so)
+            elif item.text(0) == "Subtract":
+                bedit = BoolEditor(item.text(column), self)
+                bedit.exec_()
+                item.setText(column, str(bedit.getValue()))
+                self.so.entity.getUserObject().subtract = bedit.getValue()                    
+            else:
+                self.treeWidget.editItem(item, column)
 
     def onItemChanged(self, item, column):
         if self.valueBeforeEdit is not None and self.valueBeforeEdit != item.text(column):
             parent = item.parent()
-            if parent is None:
+            if parent is None: # handle properties that don't expand here (pos, rot, scale etc)
                 if item.text(0) == "Name":
-                    if not self.sceneManager.hasEntity(str(item.text(column))):
-                        newEnt = self.node.getAttachedObject(0).clone(str(item.text(column)))
-                        oldEnt = self.node.getAttachedObject(0)
-                        self.node.detachObject(oldEnt)
-                        self.sceneManager.destroyEntity(oldEnt)
-                        self.node.attachObject(newEnt)
+                    if self.node.getName().startswith("entity_"):
+                        if not self.sceneManager.hasEntity(str(item.text(column))):
+                            newEnt = self.node.getAttachedObject(0).clone(str(item.text(column)))
+                            oldEnt = self.node.getAttachedObject(0)
+                            self.node.detachObject(oldEnt)
+                            self.sceneManager.destroyEntity(oldEnt)
+                            self.node.attachObject(newEnt)
+                            
+                            # update the selection object since it still has references to the deleted entity
+                            self.so.entity = newEnt
+                            self.so.entityName = newEnt.getName()
+                        else:
+                            item.setText(column, self.valueBeforeEdit)
+                            print "Error: Name already exists!"
+
+                    elif self.node.getName().startswith("light_"):
+                        if not self.sceneManager.hasLight(str(item.text(column))):
+                            newLight = self.sceneManager.createLight(str(item.text(column)))
+                            oldLight = ModuleManager.extractLight(self.node)
+                            self.node.detachObject(oldLight)
+                            self.node.attachObject(newLight)
+                            newLight.setType(oldLight.getType())
+                            newLight.setVisibilityFlags(newLight.getVisibilityFlags())
+                            newLight.setCastShadows(oldLight.getCastShadows())
+                            newLight.setDiffuseColour(oldLight.getDiffuseColour())
+                            newLight.setSpecularColour(oldLight.getSpecularColour())
+                            newLight.setAttenuation(oldLight.getAttenuationRange(), oldLight.getAttenuationConstant(), oldLight.getAttenuationLinear(), oldLight.getAttenuationQuadric())
+                            if newLight.getType() == og.Light.LT_SPOTLIGHT:
+                                newLight.setSpotlightRange(oldLight.getSpotlightInnerAngle(), oldLight.getSpotlightOuterAngle(), oldLight.getSpotlightFalloff())
+                            if newLight.getType() == og.Light.LT_SPOTLIGHT or newLight.getType() == og.Light.LT_DIRECTIONAL:
+                                newLight.setDirection(oldLight.getDirection())
+                                
+                            self.sceneManager.destroyLight(oldLight)
+                        else:
+                            item.setText(column, self.valueBeforeEdit)
+                            print "Error: Name already exists!"
+
+                elif item.text(0) == "Zone Name":
+                    self.node.getAttachedObject(0).getUserObject().parentZone.name = str(item.text(column))
                         
-                        # update the selection object since it still has references to the deleted entity
-                        self.so.entity = newEnt
-                        self.so.entityName = newEnt.getName()
+                elif item.text(0) == "GameObject Id":
+                    if not self.gocManager.inWorldIdExists(str(item.text(column))):
+                        val = None
+                        try:
+                            val = int(item.text(1))
+                        except ValueError, e:
+                            item.setText(column, self.valueBeforeEdit)
+                            print "ValueError: " + str(e)
+                            return
+                            
+                        self.node.getAttachedObject(0).getUserObject().inWorldId = str(val)
                     else:
                         item.setText(column, self.valueBeforeEdit)
-                        print "Error: Name already exists!"
+                        print "Error: Id exists already!"
+                elif item.text(0) == "Static Geometry Group":                        
+                    val = None
+                    try:
+                        val = int(item.text(1))
+                    except ValueError, e:
+                        item.setText(column, self.valueBeforeEdit)
+                        print "ValueError: " + str(e)
+                        return
+                elif item.text(0) == "Rendering Distance":                        
+                    val = None
+                    try:
+                        val = float(item.text(1))
+                    except ValueError, e:
+                        item.setText(column, self.valueBeforeEdit)
+                        print "ValueError: " + str(e)
+                        return
+                    
+                    self.node.getAttachedObject(0).getUserObject().renderingdistance = val
             else:
                 val = None
                 try:
@@ -111,6 +305,24 @@
                         self.node.setScale(self.node.getScale().x, val, self.node.getScale().z)
                     elif item.text(0) == "Z":
                         self.node.setScale(self.node.getScale().x, self.node.getScale().y, val)
+                elif parent.text(0) == "Attenuation":
+                    light = ModuleManager.extractLight(self.node)
+                    if item.text(0) == "range":
+                        light.setAttenuation(val, light.getAttenuationConstant(), light.getAttenuationLinear(), light.getAttenuationQuadric())
+                    elif item.text(0) == "constant":
+                        light.setAttenuation(light.getAttenuationRange(), val, light.getAttenuationLinear(), light.getAttenuationQuadric())
+                    elif item.text(0) == "linear":
+                        light.setAttenuation(light.getAttenuationRange(), light.getAttenuationConstant(), val, light.getAttenuationQuadric())
+                    elif item.text(0) == "quadratic":
+                        light.setAttenuation(light.getAttenuationRange(), light.getAttenuationConstant(), light.getAttenuationLinear(), val)
+                elif parent.text(0) == "Spotlightrange":
+                    light = ModuleManager.extractLight(self.node)
+                    if item.text(0) == "inner":
+                        light.setSpotlightInnerAngle(og.Degree(val))
+                    elif item.text(0) == "outer":
+                        light.setSpotlightOuterAngle(og.Degree(val))
+                    elif item.text(0) == "falloff":                      
+                      light.setSpotlightFalloff(val)
                         
     def showProperties(self, so):
         # onItemChanged should only be called when the user changes values not when they change by code
@@ -141,17 +353,155 @@
                 it.setText(1, self.node.getAttachedObject(0).getSubEntity(i).getMaterialName())
                 i += 1
                 
+                        
+            self.parsePosition(self.node)
+            self.parseOrientation(self.node)
+            self.parseScale(self.node)
+            self.parseEntityOptions(self.node)
             
-            #item.setFlags(item.flags() | Qt.ItemIsEditable)
+        elif name.startswith("gameobject_"):
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "ClassName")
+            n = str(self.node.getAttachedObject(0).getUserObject().gocName)
+            item.setText(1, n)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
             
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "GameObject Id")
+            n = str(self.node.getAttachedObject(0).getUserObject().inWorldId)
+            item.setText(1, n)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "State")
+            n = str(self.node.getAttachedObject(0).getUserObject().state)
+            item.setText(1, n)            
+            
             self.parsePosition(self.node)
             self.parseOrientation(self.node)
             self.parseScale(self.node)
             
+        elif name.startswith("light_"):
+            item = QTreeWidgetItem(self.treeWidget)
+            light = ModuleManager.extractLight(self.node)
+            n = light.getName()
+            item.setText(0, "Name")
+            item.setText(1, n)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "Type")
+            if light.getType() == og.Light.LT_POINT:
+                item.setText(1, "point")
+            elif light.getType() == og.Light.LT_SPOTLIGHT:
+                item.setText(1, "spot")
+            elif light.getType() == og.Light.LT_DIRECTIONAL:
+                item.setText(1, "directional")
+
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "Visibility")
+            item.setText(1, str(light.getVisible()))
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "CastShadows")
+            item.setText(1, str(light.getCastShadows()))
+            
+            if light.getType() == og.Light.LT_POINT or light.getType() == og.Light.LT_SPOTLIGHT:
+                self.parsePosition(self.node)
+            if light.getType() == og.Light.LT_SPOTLIGHT:
+                self.parseSpotLightProperties(self.node)
+                
+            self.parseDiffuseColor(self.node)
+            self.parseSpecularColor(self.node)
+            self.parseLightAttenuation(self.node)
+        elif name.startswith("area_"):
+            area = so.entity.getUserObject()
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "Zone Name")
+            item.setText(1, area.parentZone.name)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "Type")
+            item.setText(1, area.type)
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "Dbg Area Id:")
+            item.setText(1, str(area.id))
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "Dbg Area Entity Name:")
+            item.setText(1, area.areaEntity.getName())
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "Subtract")
+            item.setText(1, str(area.subtract))
+            
+            self.parsePosition(area.areaNode)
+            self.parseOrientation(area.areaNode)
+            self.parseScale(area.areaNode)
+            
         self.connect(self.treeWidget, SIGNAL("itemChanged (QTreeWidgetItem *,int)"),
                        self.onItemChanged)
                        
-                       
+    
+    def parseDiffuseColor(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, "Diffuse Color")
+        color = ModuleManager.extractLight(self.node).getDiffuseColour()
+        item.setText(1, str(int(255 * color.r)) + "; " + str(int(255 * color.g)) + "; " + str(int(255 * color.b)))
+        
+    def parseSpecularColor(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, "Specular Color")
+        color = ModuleManager.extractLight(self.node).getSpecularColour()
+        item.setText(1, str(int(255 * color.r)) + "; " + str(int(255 * color.g)) + "; " + str(int(255 * color.b)))
+        
+    def parseLightAttenuation(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, "Attenuation")
+        light = ModuleManager.extractLight(self.node)
+        
+        range = QTreeWidgetItem(item)
+        range.setText(0, "range")
+        range.setText(1, str(light.getAttenuationRange()))
+        range.setFlags(range.flags() | Qt.ItemIsEditable)
+        
+        constant = QTreeWidgetItem(item)
+        constant.setText(0, "constant")
+        constant.setText(1,  str(light.getAttenuationConstant()))
+        constant.setFlags(constant.flags() | Qt.ItemIsEditable)
+        
+        linear = QTreeWidgetItem(item)
+        linear.setText(0, "linear")
+        linear.setText(1, str(light.getAttenuationLinear()))
+        linear.setFlags(linear.flags() | Qt.ItemIsEditable)
+        
+        quadratic = QTreeWidgetItem(item)
+        quadratic.setText(0, "quadratic")
+        quadratic.setText(1, str(light.getAttenuationQuadric()))
+        quadratic.setFlags(quadratic.flags() | Qt.ItemIsEditable)
+    
+    def parseSpotLightProperties(self,  node):
+        light = ModuleManager.extractLight(self.node)
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, "Spotlightrange")
+
+        inner = QTreeWidgetItem(item)
+        inner.setText(0, "inner")
+        inner.setText(1, str(light.getSpotlightInnerAngle().valueDegrees()))
+        inner.setFlags(inner.flags() | Qt.ItemIsEditable)
+        
+        outer = QTreeWidgetItem(item)
+        outer.setText(0, "outer")
+        outer.setText(1, str(light.getSpotlightOuterAngle().valueDegrees()))
+        outer.setFlags(outer.flags() | Qt.ItemIsEditable)
+        
+        falloff = QTreeWidgetItem(item)
+        falloff.setText(0, "falloff")
+        falloff.setText(1, str(light.getSpotlightFalloff()))
+        falloff.setFlags(falloff.flags() | Qt.ItemIsEditable)
+
     def parsePosition(self, node):
         item = QTreeWidgetItem(self.treeWidget)
         item.setText(0, "Position")
@@ -217,7 +567,31 @@
         itemZ.setText(1, str(node.getScale().z))
         itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
         
+    def parseEntityOptions(self, node):
+        uo = node.getAttachedObject(0).getUserObject()
+
+        if uo is not None:
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "Receives Shadows")
+            item.setText(1, str(uo.receivesShadow))
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "Static Geometry Group")
+            item.setText(1, str(uo.staticgeometrygroup))
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "Physics Proxy Type")
+            item.setText(1, str(uo.physicsproxytype))  
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "Rendering Distance")
+            item.setText(1, str(uo.renderingdistance))
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
     def updateProperties(self):
         if self.so is not None:
             self.showProperties(self.so)
-            
+    
+    def clear(self):
+        self.treeWidget.clear()

Modified: rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,348 +1,351 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-from ViewportGrid import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# this class is the heart of the 3d part
-# it manages the two ogre render windows and recieves events from the windows through the event filter
-class OgreMainWindow(QWidget):
-    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
-        QWidget.__init__(self, parent)
-        self.moduleManager = moduleManager
-        self.ogreRoot = ogreRoot
-        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
-
-        self.ogreWidget = None
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.mDollyCamera = False
-
-        self.moveCamForward = False
-        self.moveCamBackward = False
-        self.strafeCamLeft = False
-        self.strafeCamRight = False
-
-        self.camUpdateTimer = QTimer(self)
-        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL("timeout()"), self.updateCamera)
-
-        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
-        
-        self.setupUi(self)
-
-    def setupUi(self, Form):
-        Form.setObjectName("Form")
-        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(Form)
-        self.gridlayout.setObjectName("gridlayout")
-
-        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
-        self.splitterV = QSplitter(Form)
-
-        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
-        self.splitterV.setSizePolicy(sizePolicy)
-        self.splitterV.setOrientation(Qt.Vertical)
-        self.splitterV.setObjectName("splitter")
-
-        # create the preferences buttons and connect the signals
-        self.ogreWindowOptions = QToolButton(self)
-        QObject.connect(self.ogreWindowOptions, SIGNAL("clicked()"),
-                                    self.onPreferencesButton)
-        self.ogreWindowOptions.hide()
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
-        self.ogreWindowOptions.setSizePolicy(sizePolicy)
-        self.ogreWindowOptions.setObjectName("ogreWindowPreferences")
-        self.splitterV.addWidget(self.ogreWindowOptions)
-
-        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
-
-        ##################################
-        self.ogreWidget = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterV,  0)
-        self.ogreWidget.setMinimumSize(QSize(250,250))
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
-        self.ogreWidget.setSizePolicy(sizePolicy)
-        self.ogreWidget.setObjectName("ogreWidget")
-        self.splitterV.addWidget(self.ogreWidget)
-        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
-        ####################################
-
-        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
-
-        # register the eventfilters for the render windows
-        # this is needed to catch mouse enter and mouse leave events for these windows
-        self.ogreWidget.installEventFilter(self)
-        self.ogreWidget.setAcceptDrops(True)
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-        self.retranslateUi(Form)
-        QMetaObject.connectSlotsByName(Form)
-        
-        self.ogreWidget.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)
-        
-    def ogreViewportCreatedCallback(self):
-        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
-        self.viewportGrid.enable()
-        
-    def retranslateUi(self, Form):
-        Form.setWindowTitle(QApplication.translate("Form", "Form", None, QApplication.UnicodeUTF8))
-        self.ogreWindowOptions.setText(QApplication.translate("Form", "...", None, QApplication.UnicodeUTF8))
-
-    def onPreferencesButton(self):
-        self.splitterH.setOrientation(Qt.Vertical)
-
-    def keyPressEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = True
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = True
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = True
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= True
-
-    def keyReleaseEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = False
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = False
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = False
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= False
-
-    def eventFilter(self, obj, event):
-        if event.type() == 2:
-            self.ogreWidget.setFocus()
-            if event.button() == 1: # left mouse button is pressed
-                self.leftMouseDown = True
-                self.moduleManager.leftMouseDown = True
-
-                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
-                    self.mDollyCamera = True
-                else:
-                    self.calculateSelectionRay(event)
-
-            elif event.button() == 2: # right mouse button is pressed
-                self.rightMouseDown = True
-                self.moduleManager.rightMouseDown = True
-
-            elif event.button() == 4: # middle mouse button is pressed
-                self.middleMouseDown = True
-                self.moduleManager.middleMouseDown = True
-
-            self.camUpdateTimer.start(15)
-
-        elif event.type() == 3:
-            if event.button() == 1: # left mouse button is released
-                self.leftMouseDown = False
-                self.moduleManager.leftMouseDown = False
-                self.moduleManager.leftMouseUp()
-
-                if self.mDollyCamera == True: #if we dolly the camera set it to false
-                    self.mDollyCamera = False
-
-            elif event.button() == 2: # right mouse button is released
-                self.rightMouseDown = False
-                self.moduleManager.rightMouseDown = False
-            elif event.button() == 4: # middle mouse button is released
-                self.middleMouseDown = False
-                self.moduleManager.middleMouseDown = False
-
-            if not self.rightMouseDown:
-                self.mDollyCamera = False
-                self.camUpdateTimer.stop()
-
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-
-        elif event.type() == 5: #mouse moved while button down
-            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosX = event.globalX()
-            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosY = event.globalY()
-
-            incX =  (event.globalX() - self.lastMousePosX)
-            incY =  (event.globalY() - self.lastMousePosY)
-
-            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
-                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
-
-            rotX = incX * 0.01
-            rotY = incY * 0.01
-
-            if self.mDollyCamera:
-                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
-            elif self.rightMouseDown:
-                obj.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-
-        if event.type() == 60: #drag enter
-            self.dragEnterEvent(event)
-        if event.type() == 61: #drag move
-            self.dragMoveEvent(event)
-#        if event.type() == 62:
-#            self.finishDropEvent(event)
-        if event.type() == 63:
-            self.finishDropEvent(event)
-
-        return False
-
-    def dragEnterEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            data = event.mimeData().data("application/x-static_model")
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream >> text
-
-            self.moduleManager.startDropModelAction(str(text), self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            data = event.mimeData().data("application/x-game_object")
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream >> text
-
-            self.moduleManager.startDropGameObjectAction(str(text), self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-material"):
-            data = event.mimeData().data("application/x-material")
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream >> text
-
-            self.moduleManager.startDropMaterialAction(str(text)) #start the material draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-        else:
-            event.ignore()
-
-
-    def dragMoveEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-material"):
-            self.moduleManager.moveDropMaterialAction(event) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def finishDropEvent(self, event):
-        if event.mimeData().hasFormat("application/x-static_model"):
-            self.moduleManager.finishDropModelAction(self.getCameraToViewportRay())
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-game_object"):
-            self.moduleManager.finishDropGameObjectAction(self.getCameraToViewportRay()) 
-            event.accept()
-        elif event.mimeData().hasFormat("application/x-material"):
-            relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
-            self.moduleManager.finishDropMaterialAction(relMousePos.x(), relMousePos.y()) 
-            event.accept()
-        else:
-            event.ignore()
-
-    def getCameraToViewportRay(self):
-        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
-
-        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
-
-        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
-
-    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
-    def calculateSelectionRay(self,  event):
-        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
-
-#        if self.lastSelectionClick != None:
-#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
-#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
-#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
-#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
-#                return
-
-        self.lastSelectionClick = relMousePos
-        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
-
-        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
-
-        if event.modifiers() == Qt.ControlModifier:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
-        elif event.modifiers() == Qt.ShiftModifier:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
-        else:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
-
-    def getWidth():
-        return self.ogreWidget.getWidth()
-        
-    def getHeight():
-        return self.ogreWidget.getHeight()
-
-    def updateCamera(self):        
-        if self.moveCamForward:
-            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
-        if self.moveCamBackward:
-            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
-        if self.strafeCamLeft:
-            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
-        if self.strafeCamRight:
-            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
-        
-        if self.moduleManager.pivot:
-            self.moduleManager.pivot.update()
-            
-    def updateRenderWindow(self):
-        self.ogreWidget.update()
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+
+import os
+import sys
+import platform
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+from ViewportGrid import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# this class is the heart of the 3d part
+# it manages the two ogre render windows and recieves events from the windows through the event filter
+class OgreMainWindow(QWidget):
+    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
+        QWidget.__init__(self, parent)
+        self.moduleManager = moduleManager
+        self.ogreRoot = ogreRoot
+        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
+
+        self.ogreWidget = None
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.mDollyCamera = False
+
+        self.moveCamForward = False
+        self.moveCamBackward = False
+        self.strafeCamLeft = False
+        self.strafeCamRight = False
+
+        self.camUpdateTimer = QTimer(self)
+        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL("timeout()"), self.updateCamera)
+
+        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
+        
+        self.setupUi(self)
+
+    def setupUi(self, Form):
+        Form.setObjectName("Form")
+        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(Form)
+        self.gridlayout.setContentsMargins(0, 2, 0, 0)
+        self.gridlayout.setObjectName("gridlayout")
+
+        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
+        self.splitterV = QSplitter(Form)
+
+        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
+        self.splitterV.setSizePolicy(sizePolicy)
+        self.splitterV.setOrientation(Qt.Vertical)
+        self.splitterV.setObjectName("splitter")
+
+        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
+
+        ##################################
+        self.ogreWidget = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterV,  0)
+        self.ogreWidget.setMinimumSize(QSize(250,250))
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
+        self.ogreWidget.setSizePolicy(sizePolicy)
+        self.ogreWidget.setObjectName("ogreWidget")
+        self.splitterV.addWidget(self.ogreWidget)
+        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
+        ####################################
+
+        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
+
+        # register the eventfilters for the render windows
+        # this is needed to catch mouse enter and mouse leave events for these windows
+        self.ogreWidget.installEventFilter(self)
+        self.ogreWidget.setAcceptDrops(True)
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+        self.retranslateUi(Form)
+        QMetaObject.connectSlotsByName(Form)
+        
+        self.ogreWidget.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)
+        
+    def ogreViewportCreatedCallback(self):
+        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
+        self.viewportGrid.enable()
+        
+    def retranslateUi(self, Form):
+        Form.setWindowTitle(QApplication.translate("Form", "Form", None, QApplication.UnicodeUTF8))
+
+    def keyPressEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = True
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = True
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = True
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= True
+
+    def keyReleaseEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = False
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = False
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = False
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= False
+
+    def eventFilter(self, obj, event):
+        if event.type() == 2:
+            self.ogreWidget.setFocus()
+            if event.button() == 1: # left mouse button is pressed
+                self.leftMouseDown = True
+                self.moduleManager.leftMouseDown = True
+
+                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
+                    self.mDollyCamera = True
+                else:
+                    self.calculateSelectionRay(event)
+
+            elif event.button() == 2: # right mouse button is pressed
+                self.rightMouseDown = True
+                self.moduleManager.rightMouseDown = True
+                QTimer.singleShot(50, self.onContextMenuTimer)
+
+            elif event.button() == 4: # middle mouse button is pressed
+                self.middleMouseDown = True
+                self.moduleManager.middleMouseDown = True
+
+            self.camUpdateTimer.start(15)
+
+        elif event.type() == 3:
+            if event.button() == 1: # left mouse button is released
+                self.leftMouseDown = False
+                self.moduleManager.leftMouseDown = False
+                self.moduleManager.leftMouseUp()
+
+                if self.mDollyCamera == True: #if we dolly the camera set it to false
+                    self.mDollyCamera = False
+
+            elif event.button() == 2: # right mouse button is released
+                self.rightMouseDown = False
+                self.moduleManager.rightMouseDown = False
+                
+            elif event.button() == 4: # middle mouse button is released
+                self.middleMouseDown = False
+                self.moduleManager.middleMouseDown = False
+
+            if not self.rightMouseDown:
+                self.mDollyCamera = False
+                self.camUpdateTimer.stop()
+
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+
+        elif event.type() == 5: #mouse moved while button down
+            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosX = event.globalX()
+            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosY = event.globalY()
+
+            incX =  (event.globalX() - self.lastMousePosX)
+            incY =  (event.globalY() - self.lastMousePosY)
+
+            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
+                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
+
+            rotX = incX * 0.01
+            rotY = incY * 0.01
+
+            if self.mDollyCamera:
+                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
+            elif self.rightMouseDown:
+                obj.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+
+        if event.type() == 60: #drag enter
+            self.dragEnterEvent(event)
+        if event.type() == 61: #drag move
+            self.dragMoveEvent(event)
+#        if event.type() == 62:
+#            self.finishDropEvent(event)
+        if event.type() == 63:
+            self.finishDropEvent(event)
+
+        return False
+
+    def dragEnterEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            data = event.mimeData().data("application/x-static_model")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            self.moduleManager.startDropModelAction(str(text), self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            data = event.mimeData().data("application/x-game_object")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            self.moduleManager.startDropGameObjectAction(str(text), self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-material"):
+            data = event.mimeData().data("application/x-material")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            self.moduleManager.startDropMaterialAction(str(text)) #start the material draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        else:
+            event.ignore()
+
+
+    def dragMoveEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-material"):
+            self.moduleManager.moveDropMaterialAction(event) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def finishDropEvent(self, event):
+        if event.mimeData().hasFormat("application/x-static_model"):
+            self.moduleManager.finishDropModelAction(self.getCameraToViewportRay())
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            self.moduleManager.finishDropGameObjectAction(self.getCameraToViewportRay()) 
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-material"):
+            relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
+            self.moduleManager.finishDropMaterialAction(relMousePos.x(), relMousePos.y()) 
+            event.accept()
+        else:
+            event.ignore()
+
+    def getCameraToViewportRay(self):
+        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
+
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
+    def calculateSelectionRay(self,  event):
+        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
+
+#        if self.lastSelectionClick != None:
+#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
+#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
+#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
+#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
+#                return
+
+        self.lastSelectionClick = relMousePos
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+        if event.modifiers() == Qt.ControlModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
+        elif event.modifiers() == Qt.ShiftModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
+        else:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
+
+    def getWidth():
+        return self.ogreWidget.getWidth()
+        
+    def getHeight():
+        return self.ogreWidget.getHeight()
+
+    def updateCamera(self):        
+        if self.moveCamForward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
+        if self.moveCamBackward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
+        if self.strafeCamLeft:
+            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
+        if self.strafeCamRight:
+            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
+        
+        if self.moduleManager.pivot:
+            self.moduleManager.pivot.update()
+            
+    def updateRenderWindow(self):
+        self.ogreWidget.update()
+        
+    def onContextMenuTimer(self):
+        if not self.rightMouseDown:
+            relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos()) # get the mose position relative to the ogre window
+            
+            screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+            screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+            mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+            self.moduleManager.onContextMenu(relMousePos.x(), relMousePos.y(), mouseRay)
+            
+    def toggleViewportGrid(self):
+        if self.viewportGrid.isEnabled():
+            self.viewportGrid.disable()
+        else:
+            self.viewportGrid.enable()
+        

Modified: rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,164 +1,163 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import platform
-import os
-
-from PyQt4 import QtGui
-import ogre.renderer.OGRE as og
-
-class OgreWidget(QtGui.QWidget):
-    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
-        QtGui.QWidget.__init__(self, parent)
-        self.painted = False
-        self.renderWindowName = renderWindowName
-        self.parent = parent
-        self.ogreRoot = ogreRoot
-        self.sceneManager = sceneManager
-        self.cameraName = cameraName
-        self.camDistFromFocusNode = camDistFromFocusNode
-        self.initOgreWindow(renderWindowName,cameraName)
-        self.resizeEventListener = []
-        self.ogreViewportCreatedCallback = None
-        self.renderWindow = None
-
-    def initOgreWindow(self, renderWindowName, cameraName):
-        self.renderParameters = og.NameValuePairList()
-        
-
-        if platform.system() == "Windows" or platform.system() == "MAC":
-            hwnd = int(self.winId())
-            self.renderParameters['externalWindowHandle'] = str(hwnd)
-        else:
-            win = str(int(self.winId()))
-            self.renderParameters['parentWindowHandle'] = win
-
-#        else:
-#            import sip
-#            info = self.x11Info()
-#            disp =  str(sip.unwrapinstance(info.display()))
-#            scr = str(info.screen())
-#            win = str(int(self.winId()))
-#            winHandle = disp + ':' + scr + ':' + win
-#            
-#            self.renderParameters['parentWindowHandle'] = win
-
-
-    def setBackgroundColor(self, colorValue):
-        if self.painted:
-            self.viewport.BackgroundColour = colorValue
-        else:
-            self.backGroundColor = colorValue
-
-    def setOgreViewportCreatedCallback(self, callback):
-        self.ogreViewportCreatedCallback = callback
-    
-    def paintEvent(self, event):
-        if not self.painted:
-            renderWindow = self.ogreRoot.createRenderWindow(self.renderWindowName, self.width(), self.height(),
-                                                False, self.renderParameters)
-
-            renderWindow.active = True
-            self.renderWindow = renderWindow
-            
-            self.camera = self.sceneManager.createCamera(self.cameraName)
-            self.camera.NearClipDistance = 0.1
-
-            # Create focus node (camera always points at this)
-            self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
-            self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-            # camera node is offset a ways along the Z axis of focus node
-            self.camNode = self.camFocusNode.createChildSceneNode()
-            # fix yaw on this one too for when we manipulate it directly
-            self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-            self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
-            self.camNode.attachObject(self.camera)
-            
-            self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
-            self.viewport.setClearEveryFrame(True)
-            self.viewport.BackgroundColour = self.backGroundColor
-            
-            if self.ogreViewportCreatedCallback:
-                self.ogreViewportCreatedCallback()
-            
-            self.painted = True
-        
-    def resizeEvent(self, event):
-        if self.renderWindow:
-            self.renderWindow.resize(event.size().width(), event.size().height())
-            self.renderWindow.windowMovedOrResized()
-
-            if platform.system() == "Linux":
-                self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
-
-            self.renderWindow.update(True)
-            self.ogreRoot.renderOneFrame()
-
-            if self.camera:
-                self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
-                
-        for listener in self.resizeEventListener:
-            listener(event.size().width(), event.size().height())
-
-    def addResizeEventListener(self, listener):
-        self.resizeEventListener.append(listener)
-
-    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
-        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
-
-    def getCamera(self):
-        assert(self.camera)
-        return self.camera
-    
-    def getWidth():
-        return self.renderWindow.getActualWidth()
-        
-    def getHeight():
-        return self.renderWindow.getActualHeight()
-    
-    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
-    def orbitCamera( self, horz, vert):
-        #orbit around focus node
-        #yaw around world Y, pitch around local
-        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
-        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
-
-    #void ViewOgreWindow::zoomCamera(float zoom)
-    def zoomCamera(self, zoom):
-        #in perspective mode, zoom by altering camera orbit distance from focus
-        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
-        #make sure we don't go into -Z or even beyond clip distance to focus
-        pos = self.camNode.getPosition()
-        if pos.z < self.camera.getNearClipDistance():
-            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
-
-    #Ogre::Vector3& trans
-    def dollyCamera(self,  trans):
-        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
-
-    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
-    def panCamera( self, horz, vert):
-        self.camNode.yaw(horz, og.Node.TS_WORLD)
-        self.camNode.pitch(vert, og.Node.TS_LOCAL)
-        
-    def update(self):
-        if self.renderWindow is not None:
-            self.renderWindow.update(True)
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+
+import sys
+import platform
+import os
+
+from PyQt4 import QtGui
+import ogre.renderer.OGRE as og
+
+class OgreWidget(QtGui.QWidget):
+    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
+        QtGui.QWidget.__init__(self, parent)
+        self.painted = False
+        self.renderWindowName = renderWindowName
+        self.parent = parent
+        self.ogreRoot = ogreRoot
+        self.sceneManager = sceneManager
+        self.cameraName = cameraName
+        self.camDistFromFocusNode = camDistFromFocusNode
+        self.initOgreWindow(renderWindowName,cameraName)
+        self.resizeEventListener = []
+        self.ogreViewportCreatedCallback = None
+        self.renderWindow = None
+
+    def initOgreWindow(self, renderWindowName, cameraName):
+        self.renderParameters = og.NameValuePairList()
+        
+
+        if platform.system() == "Windows" or platform.system() == "MAC":
+            hwnd = int(self.winId())
+            self.renderParameters['externalWindowHandle'] = str(hwnd)
+        else:
+            win = str(int(self.winId()))
+            self.renderParameters['parentWindowHandle'] = win
+
+#        else:
+#            import sip
+#            info = self.x11Info()
+#            disp =  str(sip.unwrapinstance(info.display()))
+#            scr = str(info.screen())
+#            win = str(int(self.winId()))
+#            winHandle = disp + ':' + scr + ':' + win
+#            
+#            self.renderParameters['parentWindowHandle'] = win
+
+
+    def setBackgroundColor(self, colorValue):
+        if self.painted:
+            self.viewport.BackgroundColour = colorValue
+        else:
+            self.backGroundColor = colorValue
+
+    def setOgreViewportCreatedCallback(self, callback):
+        self.ogreViewportCreatedCallback = callback
+    
+    def paintEvent(self, event):
+        if not self.painted:
+            renderWindow = self.ogreRoot.createRenderWindow(self.renderWindowName, self.width(), self.height(),
+                                                False, self.renderParameters)
+
+            renderWindow.active = True
+            self.renderWindow = renderWindow
+            
+            self.camera = self.sceneManager.createCamera(self.cameraName)
+            self.camera.NearClipDistance = 0.5
+
+            # Create focus node (camera always points at this)
+            self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
+            self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            # camera node is offset a ways along the Z axis of focus node
+            self.camNode = self.camFocusNode.createChildSceneNode()
+            # fix yaw on this one too for when we manipulate it directly
+            self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
+            self.camNode.attachObject(self.camera)
+            
+            self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
+            self.viewport.setClearEveryFrame(True)
+            self.viewport.BackgroundColour = self.backGroundColor
+            
+            if self.ogreViewportCreatedCallback:
+                self.ogreViewportCreatedCallback()
+            
+            self.painted = True
+        
+    def resizeEvent(self, event):
+        if self.renderWindow:
+            self.renderWindow.resize(event.size().width(), event.size().height())
+            self.renderWindow.windowMovedOrResized()
+            self.viewport.update()
+
+            self.renderWindow.update(True)
+            self.ogreRoot.renderOneFrame()
+            
+            if self.camera:
+                self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
+                
+        for listener in self.resizeEventListener:
+            listener(event.size().width(), event.size().height())
+
+    def addResizeEventListener(self, listener):
+        self.resizeEventListener.append(listener)
+
+    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
+        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
+
+    def getCamera(self):
+        assert(self.camera)
+        return self.camera
+    
+    def getWidth():
+        return self.renderWindow.getActualWidth()
+        
+    def getHeight():
+        return self.renderWindow.getActualHeight()
+    
+    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
+    def orbitCamera( self, horz, vert):
+        #orbit around focus node
+        #yaw around world Y, pitch around local
+        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
+        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
+
+    #void ViewOgreWindow::zoomCamera(float zoom)
+    def zoomCamera(self, zoom):
+        #in perspective mode, zoom by altering camera orbit distance from focus
+        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
+        #make sure we don't go into -Z or even beyond clip distance to focus
+        pos = self.camNode.getPosition()
+        if pos.z < self.camera.getNearClipDistance():
+            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
+
+    #Ogre::Vector3& trans
+    def dollyCamera(self,  trans):
+        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
+
+    #(const Ogre::Radian& horz, const Ogre::Radian& vert)
+    def panCamera( self, horz, vert):
+        self.camNode.yaw(horz, og.Node.TS_WORLD)
+        self.camNode.pitch(vert, og.Node.TS_LOCAL)
+        
+    def update(self):
+        if self.renderWindow is not None:
+            self.renderWindow.update(True)
+

Modified: rl/branches/persistence2/editors/Lockenwickler/src/Plugins-linux.cfg
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/Plugins-linux.cfg	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/Plugins-linux.cfg	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,13 +1,13 @@
 # Defines plugins to load
 
 # Define plugin folder
-PluginFolder=/home/fusion/development/root/usr/lib/OGRE/
+PluginFolder=/home/fusion/development/root/usr/lib/OGRE
 #PluginFolder=/usr/lib/OGRE
 
 # default plugins installed with the libogre14 package
 Plugin=RenderSystem_GL.so
 Plugin=Plugin_ParticleFX.so
 Plugin=Plugin_OctreeSceneManager.so
-#Plugin=Plugin_CgProgramManager
+Plugin=Plugin_CgProgramManager
 
 

Modified: rl/branches/persistence2/editors/Lockenwickler/src/Plugins-windows.cfg
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/Plugins-windows.cfg	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/Plugins-windows.cfg	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,7 +1,7 @@
 # Defines plugins to load
 
 # Define plugin folder
-PluginFolder=./plugins
+PluginFolder=../../../../PythonOgre/plugins
 
 # Define plugins
 Plugin=RenderSystem_Direct3D9

Modified: rl/branches/persistence2/editors/Lockenwickler/src/Plugins.cfg
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/Plugins.cfg	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/Plugins.cfg	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,7 +1,7 @@
 # Defines plugins to load
 
 # Define plugin folder
-PluginFolder=./plugins
+PluginFolder=../../../../PythonOgre/plugins
 
 # Define plugins
 Plugin=RenderSystem_Direct3D9

Modified: rl/branches/persistence2/editors/Lockenwickler/src/PreferencesDialog.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/PreferencesDialog.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/PreferencesDialog.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 import sys
@@ -63,7 +64,7 @@
 
     def openModulConfigSelector(self):
         dialog = QFileDialog(self)
-        self.moduleCfgPath = str(dialog.getOpenFileName(self, "Select modules.cfg", "/home/stefan/blubb/rl_modules/modules/", "modules.cfg (*.cfg)"))
+        self.moduleCfgPath = str(dialog.getOpenFileName(self, "Select modules.cfg", "/home/melven/rastullah/rl_dist/modules/", "modules.cfg (*.cfg)"))
         self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
 
         from os.path import isfile

Modified: rl/branches/persistence2/editors/Lockenwickler/src/Property.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/Property.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/Property.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *

Modified: rl/branches/persistence2/editors/Lockenwickler/src/PythonOgreConfig.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/PythonOgreConfig.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/PythonOgreConfig.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 #

Modified: rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,252 +1,317 @@
-import ctypes as ctypes
-import random
-import platform
-
-import ogre.renderer.OGRE as og
-
-
-# a class to store information about a object that got selected
-class SelectionObject():
-    def __init__(self,  entity):
-        self.entityName = entity.getName()
-        self.entity = entity #the selected entity
-        self.isPivot = False
-
-#        if self.entity.getUserObject() is not None:
-#            self.isGameObject = True
-#        else:
-#            self.isGameObject = False
-
-    #if True this instance will show its bounding box else it will hide it
-    def setSelected(self,  selected):
-        if selected == True:
-            self.entity.getParentNode().showBoundingBox(True)
-        else:
-            self.entity.getParentNode().showBoundingBox(False)
-
-    def __eq__(self, other):
-        return self.entity.getName() == other.entity.getName()
-
-    def __ne__(self, other):
-        return self.entity.getName() != other.entity.getName()
-
-# class to handle material switching without having to modify scene materials individually
-class MaterialSwitcher( og.MaterialManager.Listener ):
-    def __init__(self):
-        og.MaterialManager.Listener.__init__(self)
-      
-        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
-        self.currentColorAsVector3 = og.Vector3()
-
-        self.lastEntity = ""
-        self.lastTechnique = None
- 
-
-        if platform.system() == "Windows":
-            self.lastTechnique = og.MaterialManager.getSingleton().load("PlainColor", og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
-        else:
-            self.lastTechnique = og.MaterialManager.getSingleton().load("PlainColorGLSL", og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
-        
-        self.colorDict = {}
-       
-    # takes into account that one Entity can have multiple SubEntities
-    def handleSchemeNotFound(self, index, name, material, lod, subEntity):
-
-        temp = str(type(subEntity))
-        if temp == "<class 'ogre.renderer.OGRE._ogre_.SubEntity'>":
-            if self.lastEntity == subEntity.getParent().getName():
-                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
-                #print str(subEntity.getParent().getRenderQueueGroup())
-                return self.lastTechnique
-            else:
-                self.randomizeColor()
-                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
-                
-                self.lastEntity = subEntity.getParent().getName()
-                self.colorDict[self.lastEntity] = self.currentColorAsVector3
-                return self.lastTechnique
-        
-
-    def randomizeColor(self):
-        r = random.randrange(1, 255)
-        g = random.randrange(1, 255)
-        b = random.randrange(1, 255)
-        self.currentColorAsVector3 = og.Vector3(r, g, b)
-        var = 1.0 / 255.0
-
-        self.currentColor = og.ColourValue(r * var, g * var, b * var)
-
-        #print str(int(self.currentColor.r * 255)) + " " + str(int(255 * self.currentColor.g)) + " " + str(int(255 * self.currentColor.b))
-    
-    def reset(self):
-        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
-        self.lastEntity = ""
-        
-# We need this attached to the depth target, otherwise we get problems with the compositor
-# MaterialManager.Listener should NOT be running all the time - rather only when we're
-# specifically rendering the target that needs it
-class SelectionRenderListener(og.RenderTargetListener):
-    def __init__(self, materialListener):
-        og.RenderTargetListener.__init__(self)
-        self.materialListener = materialListener
- 
-    def preRenderTargetUpdate(self, evt):
-        og.MaterialManager.getSingleton().addListener( self.materialListener )
- 
-    def postRenderTargetUpdate(self, evt):
-        og.MaterialManager.getSingleton().removeListener( self.materialListener )
-
-        
-class SelectionBuffer():
-    def __init__(self, sceneManager,  renderTarget):
-        self.sceneMgr = sceneManager
-        self.camera = sceneManager.getCamera("MainCam")
-
-        self.renderTarget = renderTarget
-        
-        # This is the material listener - Note: it is controlled by a seperate
-        # RenderTargetListener, not applied globally to all targets
-        self.materialSwitchListener = MaterialSwitcher()
-        
-        self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
-        
-        width = self.renderTarget.getWidth()
-        height = self.renderTarget.getHeight()
-        
-        self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
-                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
-                                                                    og.TEX_TYPE_2D, 
-                                                                    width, 
-                                                                    height, 
-                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
-                                                                    
-        self.renderTexture = self.texture.getBuffer().getRenderTarget()
-        self.renderTexture.setAutoUpdated(False)
-        self.renderTexture.setPriority(0)                                                         
-        self.renderTexture.addViewport( self.camera )
-        self.renderTexture.getViewport(0).setOverlaysEnabled(False)
-        self.renderTexture.getViewport(0).setClearEveryFrame(True)
-        self.renderTexture.addListener( self.selectionTargetListener )
-        self.renderTexture.getViewport(0).setMaterialScheme("aa")
-        
-#        self.createRTTOverlays()
-
-    def update(self):
-        self.updateBufferSize()
-        
-        self.renderTexture.update()        
-        self.materialSwitchListener.reset()
-        
-        pixelBuffer = self.texture.getBuffer()
-        bufferSize = pixelBuffer.getSizeInBytes()
-        #buffersize2 = self.renderTexture.getWidth()*self.renderTexture.getHeight()*4
-        
-        storageclass = ctypes.c_uint8 * (bufferSize)
-        self.buffer = storageclass()
-        
-        VoidPointer = og.CastVoidPtr(ctypes.addressof(self.buffer))
-
-        self.pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
-        self.renderTexture.copyContentsToMemory(self.pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
-
-#        i = 0
-#        
-#        while i < len(self.buffer):
-#            #print str(self.buffer[i + 2]) + " " + str(self.buffer[i+1]) + " " + str(self.buffer[i])
-#            
-#            i += 4
-    
-    def updateBufferSize(self):
-        width = self.renderTarget.getWidth()
-        height = self.renderTarget.getHeight()
-        needsSizeUpdate = False
-        
-        if width is not self.renderTexture.getWidth():
-            needsSizeUpdate = True
-        if height is not self.renderTexture.getHeight():
-            needsSizeUpdate = True            
-        
-        if needsSizeUpdate:
-            og.TextureManager.getSingleton().unload("SelectionPassTex")
-            
-            self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
-                                                            og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
-                                                            og.TEX_TYPE_2D, 
-                                                            width, 
-                                                            height, 
-                                                            0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
-                                                                    
-            self.renderTexture = self.texture.getBuffer().getRenderTarget()
-            self.renderTexture.setAutoUpdated(False)
-            self.renderTexture.setPriority(0)                                                         
-            self.renderTexture.addViewport( self.camera )
-            self.renderTexture.getViewport(0).setOverlaysEnabled(False)
-            self.renderTexture.getViewport(0).setClearEveryFrame(True)
-            self.renderTexture.addListener( self.selectionTargetListener )
-            self.renderTexture.getViewport(0).setMaterialScheme("aa")
-        else:
-            return
-            
-    def onSelectionClick(self, x, y):
-        self.update()
-        
-        posInStream = (self.pBox.getWidth() * y - 1)*4
-        posInStream += x*4
-        
-        colVec = og.Vector3(self.buffer[posInStream + 2], self.buffer[posInStream+1], self.buffer[posInStream])
-        
-        for key in self.materialSwitchListener.colorDict:
-            if self.materialSwitchListener.colorDict[key] == colVec:
-                if key == "OgreMainWin::0::ViewportGrid":
-                    return None
-                elif key == "rayLine":
-                    return None
-                elif key == "EditorXArrow":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == "EditorYArrow":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == "EditorZArrow":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == "EditorXRotator" or key == "EditorYRotator" or key == "EditorZRotator":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                elif key == "EditorXScaler" or key == "EditorYScaler" or key == "EditorZScaler":
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                else:
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    return so
-
-        return None
-        
-    def createRTTOverlays(self):
-        baseWhite = og.MaterialManager.getSingletonPtr().getByName("Lockenwickler_Pivot_X")
-        SelectionBufferTexture = baseWhite.clone("SelectionDebugMaterial")
-        textureUnit = SelectionBufferTexture.getTechnique(0).getPass(0).createTextureUnitState()
- 
-        textureUnit.setTextureName("SelectionPassTex")
- 
- 
-        overlayManager = og.OverlayManager.getSingleton()
-        # Create an overlay
-        self.mDebugOverlay = overlayManager.create("OverlayName")
- 
-        # Create a panel
-        panel = overlayManager.createOverlayElement("Panel", "PanelName0")
-        panel.setMetricsMode(og.GMM_PIXELS)
-        panel.setPosition(10, 10)
-        panel.setDimensions(400, 280)
-        panel.setMaterialName("SelectionDebugMaterial") 
-        self.mDebugOverlay.add2D(panel)
- 
-        self.mDebugOverlay.show()
-
-
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import ctypes as ctypes
+import random
+import platform
+
+import ogre.renderer.OGRE as og
+
+# get the light out of a light node
+def extractLight(node):
+        i = 0
+        num = node.numAttachedObjects()
+        while i < node.numAttachedObjects():
+            c = node.getAttachedObject(i)
+            tp = str(type(c))
+            if tp == "<class 'ogre.renderer.OGRE._ogre_.Light'>":
+                return c
+            i += 1
+            
+# get the light out of a light node
+def extractEntity(node):
+        i = 0
+        num = node.numAttachedObjects()
+        while i < node.numAttachedObjects():
+            c = node.getAttachedObject(i)
+            tp = str(type(c))
+            if tp == "<class 'ogre.renderer.OGRE._ogre_.Entity'>":
+                return c
+            i += 1
+
+# a class to store information about a object that got selected
+class SelectionObject():
+    def __init__(self,  entity):
+        self.entityName = entity.getName()
+        self.entity = entity #the selected entity
+        self.isPivot = False
+
+
+
+    #if True this instance will show its bounding box else it will hide it
+    def setSelected(self,  selected):
+        if selected == True:
+            self.entity.getParentNode().showBoundingBox(True)
+        else:
+            self.entity.getParentNode().showBoundingBox(False)
+
+    def __eq__(self, other):
+        return self.entity.getName() == other.entity.getName()
+
+    def __ne__(self, other):
+        return self.entity.getName() != other.entity.getName()
+
+# class to handle material switching without having to modify scene materials individually
+class MaterialSwitcher( og.MaterialManager.Listener ):
+    def __init__(self):
+        og.MaterialManager.Listener.__init__(self)
+      
+        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.currentColorAsVector3 = og.Vector3()
+
+        self.lastEntity = ""
+        self.lastTechnique = None
+ 
+
+        if platform.system() == "Windows":
+            self.lastTechnique = og.MaterialManager.getSingleton().load("PlainColor", og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
+        else:
+            self.lastTechnique = og.MaterialManager.getSingleton().load("PlainColorGLSL", og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
+        
+        self.colorDict = {}
+       
+    # takes into account that one Entity can have multiple SubEntities
+    def handleSchemeNotFound(self, index, name, material, lod, subEntity):
+
+        temp = str(type(subEntity))
+        if temp == "<class 'ogre.renderer.OGRE._ogre_.SubEntity'>":
+            if self.lastEntity == subEntity.getParent().getName():
+                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                #print str(subEntity.getParent().getRenderQueueGroup())
+                return self.lastTechnique
+            else:
+                self.randomizeColor()
+                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                
+                self.lastEntity = subEntity.getParent().getName()
+                self.colorDict[self.lastEntity] = self.currentColorAsVector3
+                return self.lastTechnique
+        
+
+    def randomizeColor(self):
+        r = random.randrange(1, 255)
+        g = random.randrange(1, 255)
+        b = random.randrange(1, 255)
+        self.currentColorAsVector3 = og.Vector3(r, g, b)
+        var = 1.0 / 255.0
+
+        self.currentColor = og.ColourValue(r * var, g * var, b * var)
+
+        #print str(int(self.currentColor.r * 255)) + " " + str(int(255 * self.currentColor.g)) + " " + str(int(255 * self.currentColor.b))
+    
+    def reset(self):
+        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.lastEntity = ""
+        
+# We need this attached to the depth target, otherwise we get problems with the compositor
+# MaterialManager.Listener should NOT be running all the time - rather only when we're
+# specifically rendering the target that needs it
+class SelectionRenderListener(og.RenderTargetListener):
+    def __init__(self, materialListener):
+        og.RenderTargetListener.__init__(self)
+        self.materialListener = materialListener
+ 
+    def preRenderTargetUpdate(self, evt):
+        og.MaterialManager.getSingleton().addListener( self.materialListener )
+ 
+    def postRenderTargetUpdate(self, evt):
+        og.MaterialManager.getSingleton().removeListener( self.materialListener )
+
+        
+class SelectionBuffer():
+    def __init__(self, sceneManager,  renderTarget, moduleManager, zoneManager):
+        self.sceneMgr = sceneManager
+        self.camera = sceneManager.getCamera("MainCam")
+        self.moduleManager = moduleManager
+        self.zoneManager = zoneManager
+        
+        self.renderTarget = renderTarget
+        
+        # This is the material listener - Note: it is controlled by a seperate
+        # RenderTargetListener, not applied globally to all targets
+        self.materialSwitchListener = MaterialSwitcher()
+        
+        self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
+        
+        width = self.renderTarget.getWidth()
+        height = self.renderTarget.getHeight()
+        
+        self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
+                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+                                                                    og.TEX_TYPE_2D, 
+                                                                    width, 
+                                                                    height, 
+                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+        self.renderTexture = self.texture.getBuffer().getRenderTarget()
+        self.renderTexture.setAutoUpdated(False)
+        self.renderTexture.setPriority(0)                                                         
+        self.renderTexture.addViewport( self.camera )
+        self.renderTexture.getViewport(0).setOverlaysEnabled(False)
+        self.renderTexture.getViewport(0).setClearEveryFrame(True)
+        self.renderTexture.addListener( self.selectionTargetListener )
+        self.renderTexture.getViewport(0).setMaterialScheme("aa")
+        
+#        self.createRTTOverlays()
+
+    def update(self):
+        self.updateBufferSize()
+        
+        self.renderTexture.update()        
+        self.materialSwitchListener.reset()
+        
+        pixelBuffer = self.texture.getBuffer()
+        bufferSize = pixelBuffer.getSizeInBytes()
+        #buffersize2 = self.renderTexture.getWidth()*self.renderTexture.getHeight()*4
+        
+        storageclass = ctypes.c_uint8 * (bufferSize)
+        self.buffer = storageclass()
+        
+        VoidPointer = og.CastVoidPtr(ctypes.addressof(self.buffer))
+
+        self.pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
+        self.renderTexture.copyContentsToMemory(self.pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
+
+#        i = 0
+#        
+#        while i < len(self.buffer):
+#            #print str(self.buffer[i + 2]) + " " + str(self.buffer[i+1]) + " " + str(self.buffer[i])
+#            
+#            i += 4
+    
+    def updateBufferSize(self):
+        width = self.renderTarget.getWidth()
+        height = self.renderTarget.getHeight()
+        needsSizeUpdate = False
+        
+        if width is not self.renderTexture.getWidth():
+            needsSizeUpdate = True
+        if height is not self.renderTexture.getHeight():
+            needsSizeUpdate = True            
+        
+        if needsSizeUpdate:
+            og.TextureManager.getSingleton().unload("SelectionPassTex")
+            
+            self.texture = og.TextureManager.getSingleton().createManual("SelectionPassTex", 
+                                                            og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+                                                            og.TEX_TYPE_2D, 
+                                                            width, 
+                                                            height, 
+                                                            0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+            self.renderTexture = self.texture.getBuffer().getRenderTarget()
+            self.renderTexture.setAutoUpdated(False)
+            self.renderTexture.setPriority(0)                                                         
+            self.renderTexture.addViewport( self.camera )
+            self.renderTexture.getViewport(0).setOverlaysEnabled(False)
+            self.renderTexture.getViewport(0).setClearEveryFrame(True)
+            self.renderTexture.addListener( self.selectionTargetListener )
+            self.renderTexture.getViewport(0).setMaterialScheme("aa")
+        else:
+            return
+            
+    def onSelectionClick(self, x, y):
+        self.update()
+        
+        posInStream = (self.pBox.getWidth() * y - 1)*4
+        posInStream += x*4
+        
+        colVec = og.Vector3(self.buffer[posInStream + 2], self.buffer[posInStream+1], self.buffer[posInStream])
+        
+        for key in self.materialSwitchListener.colorDict:
+            if self.materialSwitchListener.colorDict[key] == colVec:
+                if key == "OgreMainWin::0::ViewportGrid":
+                    return None
+                elif key == "rayLine":
+                    return None
+                elif key == "EditorXArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorYArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorZArrow":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorXRotator" or key == "EditorYRotator" or key == "EditorZRotator":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == "EditorXScaler" or key == "EditorYScaler" or key == "EditorZScaler" or key == "UniScaler":
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                else:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    return so
+
+        return None
+        
+    def manualSelectObjects(self, itemNodes):
+        items = []
+        for key in itemNodes:
+            parentNode = None
+            if key.startswith("Map: "):
+                parentNode = self.moduleManager.mainModule.getMap(key.replace("Map: ", "")).mapNode
+                for nodeName in itemNodes[key]:                    
+                    n = parentNode.getChild(nodeName).getAttachedObject(0)
+                    if parentNode.getChild(nodeName).getName().startswith("light_"):
+                        n = extractEntity(parentNode.getChild(nodeName))
+                        
+                    so = SelectionObject(n)
+                    so.setSelected(True)
+                    items.append(so)
+            elif key.startswith("Zone: "):
+                parentNode = self.zoneManager.getZone(key.replace("Zone: ", "")).zoneNode
+                for nodeName in itemNodes[key]:
+                    obj = parentNode.getChild(nodeName).getAttachedObject(0)
+                    so = SelectionObject(obj)
+                    so.setSelected(True)
+                    items.append(so)
+        
+        return items
+        
+        
+    def createRTTOverlays(self):
+        baseWhite = og.MaterialManager.getSingletonPtr().getByName("Lockenwickler_Pivot_X")
+        SelectionBufferTexture = baseWhite.clone("SelectionDebugMaterial")
+        textureUnit = SelectionBufferTexture.getTechnique(0).getPass(0).createTextureUnitState()
+ 
+        textureUnit.setTextureName("SelectionPassTex")
+ 
+ 
+        overlayManager = og.OverlayManager.getSingleton()
+        # Create an overlay
+        self.mDebugOverlay = overlayManager.create("OverlayName")
+ 
+        # Create a panel
+        panel = overlayManager.createOverlayElement("Panel", "PanelName0")
+        panel.setMetricsMode(og.GMM_PIXELS)
+        panel.setPosition(10, 10)
+        panel.setDimensions(400, 280)
+        panel.setMaterialName("SelectionDebugMaterial") 
+        self.mDebugOverlay.add2D(panel)
+ 
+        self.mDebugOverlay.show()
+
+
+

Modified: rl/branches/persistence2/editors/Lockenwickler/src/Ui_NewModuleWizard.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/Ui_NewModuleWizard.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/Ui_NewModuleWizard.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,100 +1,118 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file '/home/stefan/Lockenwickler/ui files/NewModuleWizard.ui'
-#
-# Created: Sun Nov  9 14:15:16 2008
-#      by: PyQt4 UI code generator 4.4.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
-
-class Ui_Dialog(object):
-    def setupUi(self, Dialog):
-        Dialog.setObjectName("Dialog")
-        Dialog.resize(675, 703)
-        self.gridLayout_3 = QtGui.QGridLayout(Dialog)
-        self.gridLayout_3.setObjectName("gridLayout_3")
-        self.label = QtGui.QLabel(Dialog)
-        self.label.setObjectName("label")
-        self.gridLayout_3.addWidget(self.label, 0, 0, 1, 1)
-        self.moduleNameLineEdit = QtGui.QLineEdit(Dialog)
-        self.moduleNameLineEdit.setObjectName("moduleNameLineEdit")
-        self.gridLayout_3.addWidget(self.moduleNameLineEdit, 0, 1, 1, 1)
-        self.label_2 = QtGui.QLabel(Dialog)
-        self.label_2.setObjectName("label_2")
-        self.gridLayout_3.addWidget(self.label_2, 1, 0, 1, 1)
-        self.sceneNameLineEdit = QtGui.QLineEdit(Dialog)
-        self.sceneNameLineEdit.setEnabled(False)
-        self.sceneNameLineEdit.setObjectName("sceneNameLineEdit")
-        self.gridLayout_3.addWidget(self.sceneNameLineEdit, 1, 1, 1, 1)
-        self.label_3 = QtGui.QLabel(Dialog)
-        self.label_3.setObjectName("label_3")
-        self.gridLayout_3.addWidget(self.label_3, 2, 0, 1, 1)
-        self.mapNameLineEdit = QtGui.QLineEdit(Dialog)
-        self.mapNameLineEdit.setEnabled(False)
-        self.mapNameLineEdit.setObjectName("mapNameLineEdit")
-        self.gridLayout_3.addWidget(self.mapNameLineEdit, 2, 1, 1, 1)
-        self.groupBox = QtGui.QGroupBox(Dialog)
-        self.groupBox.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
-        self.groupBox.setObjectName("groupBox")
-        self.gridLayout_2 = QtGui.QGridLayout(self.groupBox)
-        self.gridLayout_2.setObjectName("gridLayout_2")
-        self.moduleDependenciesList = QtGui.QListWidget(self.groupBox)
-        self.moduleDependenciesList.setEnabled(False)
-        self.moduleDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
-        self.moduleDependenciesList.setObjectName("moduleDependenciesList")
-        self.gridLayout_2.addWidget(self.moduleDependenciesList, 1, 0, 1, 1)
-        self.gridLayout_3.addWidget(self.groupBox, 3, 0, 1, 2)
-        self.groupBox_2 = QtGui.QGroupBox(Dialog)
-        self.groupBox_2.setObjectName("groupBox_2")
-        self.gridLayout = QtGui.QGridLayout(self.groupBox_2)
-        self.gridLayout.setObjectName("gridLayout")
-        self.scriptDependenciesList = QtGui.QListWidget(self.groupBox_2)
-        self.scriptDependenciesList.setEnabled(False)
-        self.scriptDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
-        self.scriptDependenciesList.setObjectName("scriptDependenciesList")
-        self.gridLayout.addWidget(self.scriptDependenciesList, 0, 0, 1, 1)
-        self.gridLayout_3.addWidget(self.groupBox_2, 4, 0, 1, 2)
-        self.hboxlayout = QtGui.QHBoxLayout()
-        self.hboxlayout.setSpacing(6)
-        self.hboxlayout.setMargin(0)
-        self.hboxlayout.setObjectName("hboxlayout")
-        spacerItem = QtGui.QSpacerItem(131, 31, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
-        self.hboxlayout.addItem(spacerItem)
-        self.okButton = QtGui.QPushButton(Dialog)
-        self.okButton.setEnabled(False)
-        self.okButton.setObjectName("okButton")
-        self.hboxlayout.addWidget(self.okButton)
-        self.cancelButton = QtGui.QPushButton(Dialog)
-        self.cancelButton.setObjectName("cancelButton")
-        self.hboxlayout.addWidget(self.cancelButton)
-        self.gridLayout_3.addLayout(self.hboxlayout, 5, 0, 1, 2)
-
-        self.retranslateUi(Dialog)
-        QtCore.QObject.connect(self.okButton, QtCore.SIGNAL("clicked()"), Dialog.accept)
-        QtCore.QObject.connect(self.cancelButton, QtCore.SIGNAL("clicked()"), Dialog.reject)
-        QtCore.QMetaObject.connectSlotsByName(Dialog)
-
-    def retranslateUi(self, Dialog):
-        Dialog.setWindowTitle(QtGui.QApplication.translate("Dialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
-        self.label.setText(QtGui.QApplication.translate("Dialog", "Step 1: Module Name", None, QtGui.QApplication.UnicodeUTF8))
-        self.label_2.setText(QtGui.QApplication.translate("Dialog", "Step 2: Scene Name", None, QtGui.QApplication.UnicodeUTF8))
-        self.label_3.setText(QtGui.QApplication.translate("Dialog", "Step 3: Map Name", None, QtGui.QApplication.UnicodeUTF8))
-        self.groupBox.setTitle(QtGui.QApplication.translate("Dialog", "Step 4: Module Dependencies", None, QtGui.QApplication.UnicodeUTF8))
-        self.moduleDependenciesList.setToolTip(QtGui.QApplication.translate("Dialog", "Modules the new module will depend on", None, QtGui.QApplication.UnicodeUTF8))
-        self.groupBox_2.setTitle(QtGui.QApplication.translate("Dialog", "Step 5: Script Dependencies", None, QtGui.QApplication.UnicodeUTF8))
-        self.scriptDependenciesList.setToolTip(QtGui.QApplication.translate("Dialog", "Modules the new module will depend on", None, QtGui.QApplication.UnicodeUTF8))
-        self.okButton.setText(QtGui.QApplication.translate("Dialog", "&OK", None, QtGui.QApplication.UnicodeUTF8))
-        self.cancelButton.setText(QtGui.QApplication.translate("Dialog", "&Cancel", None, QtGui.QApplication.UnicodeUTF8))
-
-
-if __name__ == "__main__":
-    import sys
-    app = QtGui.QApplication(sys.argv)
-    Dialog = QtGui.QDialog()
-    ui = Ui_Dialog()
-    ui.setupUi(Dialog)
-    Dialog.show()
-    sys.exit(app.exec_())
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+ 
+ 
+# Form implementation generated from reading ui file '/home/stefan/Lockenwickler/ui files/NewModuleWizard.ui'
+#
+# Created: Sun Nov  9 14:15:16 2008
+#      by: PyQt4 UI code generator 4.4.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_Dialog(object):
+    def setupUi(self, Dialog):
+        Dialog.setObjectName("Dialog")
+        Dialog.resize(675, 703)
+        self.gridLayout_3 = QtGui.QGridLayout(Dialog)
+        self.gridLayout_3.setObjectName("gridLayout_3")
+        self.label = QtGui.QLabel(Dialog)
+        self.label.setObjectName("label")
+        self.gridLayout_3.addWidget(self.label, 0, 0, 1, 1)
+        self.moduleNameLineEdit = QtGui.QLineEdit(Dialog)
+        self.moduleNameLineEdit.setObjectName("moduleNameLineEdit")
+        self.gridLayout_3.addWidget(self.moduleNameLineEdit, 0, 1, 1, 1)
+        self.label_2 = QtGui.QLabel(Dialog)
+        self.label_2.setObjectName("label_2")
+        self.gridLayout_3.addWidget(self.label_2, 1, 0, 1, 1)
+        self.sceneNameLineEdit = QtGui.QLineEdit(Dialog)
+        self.sceneNameLineEdit.setEnabled(False)
+        self.sceneNameLineEdit.setObjectName("sceneNameLineEdit")
+        self.gridLayout_3.addWidget(self.sceneNameLineEdit, 1, 1, 1, 1)
+        self.label_3 = QtGui.QLabel(Dialog)
+        self.label_3.setObjectName("label_3")
+        self.gridLayout_3.addWidget(self.label_3, 2, 0, 1, 1)
+        self.mapNameLineEdit = QtGui.QLineEdit(Dialog)
+        self.mapNameLineEdit.setEnabled(False)
+        self.mapNameLineEdit.setObjectName("mapNameLineEdit")
+        self.gridLayout_3.addWidget(self.mapNameLineEdit, 2, 1, 1, 1)
+        self.groupBox = QtGui.QGroupBox(Dialog)
+        self.groupBox.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
+        self.groupBox.setObjectName("groupBox")
+        self.gridLayout_2 = QtGui.QGridLayout(self.groupBox)
+        self.gridLayout_2.setObjectName("gridLayout_2")
+        self.moduleDependenciesList = QtGui.QListWidget(self.groupBox)
+        self.moduleDependenciesList.setEnabled(False)
+        self.moduleDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
+        self.moduleDependenciesList.setObjectName("moduleDependenciesList")
+        self.gridLayout_2.addWidget(self.moduleDependenciesList, 1, 0, 1, 1)
+        self.gridLayout_3.addWidget(self.groupBox, 3, 0, 1, 2)
+        self.groupBox_2 = QtGui.QGroupBox(Dialog)
+        self.groupBox_2.setObjectName("groupBox_2")
+        self.gridLayout = QtGui.QGridLayout(self.groupBox_2)
+        self.gridLayout.setObjectName("gridLayout")
+        self.scriptDependenciesList = QtGui.QListWidget(self.groupBox_2)
+        self.scriptDependenciesList.setEnabled(False)
+        self.scriptDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
+        self.scriptDependenciesList.setObjectName("scriptDependenciesList")
+        self.gridLayout.addWidget(self.scriptDependenciesList, 0, 0, 1, 1)
+        self.gridLayout_3.addWidget(self.groupBox_2, 4, 0, 1, 2)
+        self.hboxlayout = QtGui.QHBoxLayout()
+        self.hboxlayout.setSpacing(6)
+        self.hboxlayout.setMargin(0)
+        self.hboxlayout.setObjectName("hboxlayout")
+        spacerItem = QtGui.QSpacerItem(131, 31, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
+        self.hboxlayout.addItem(spacerItem)
+        self.okButton = QtGui.QPushButton(Dialog)
+        self.okButton.setEnabled(False)
+        self.okButton.setObjectName("okButton")
+        self.hboxlayout.addWidget(self.okButton)
+        self.cancelButton = QtGui.QPushButton(Dialog)
+        self.cancelButton.setObjectName("cancelButton")
+        self.hboxlayout.addWidget(self.cancelButton)
+        self.gridLayout_3.addLayout(self.hboxlayout, 5, 0, 1, 2)
+
+        self.retranslateUi(Dialog)
+        QtCore.QObject.connect(self.okButton, QtCore.SIGNAL("clicked()"), Dialog.accept)
+        QtCore.QObject.connect(self.cancelButton, QtCore.SIGNAL("clicked()"), Dialog.reject)
+        QtCore.QMetaObject.connectSlotsByName(Dialog)
+
+    def retranslateUi(self, Dialog):
+        Dialog.setWindowTitle(QtGui.QApplication.translate("Dialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
+        self.label.setText(QtGui.QApplication.translate("Dialog", "Step 1: Module Name", None, QtGui.QApplication.UnicodeUTF8))
+        self.label_2.setText(QtGui.QApplication.translate("Dialog", "Step 2: Scene Name", None, QtGui.QApplication.UnicodeUTF8))
+        self.label_3.setText(QtGui.QApplication.translate("Dialog", "Step 3: Map Name", None, QtGui.QApplication.UnicodeUTF8))
+        self.groupBox.setTitle(QtGui.QApplication.translate("Dialog", "Step 4: Module Dependencies", None, QtGui.QApplication.UnicodeUTF8))
+        self.moduleDependenciesList.setToolTip(QtGui.QApplication.translate("Dialog", "Modules the new module will depend on", None, QtGui.QApplication.UnicodeUTF8))
+        self.groupBox_2.setTitle(QtGui.QApplication.translate("Dialog", "Step 5: Script Dependencies", None, QtGui.QApplication.UnicodeUTF8))
+        self.scriptDependenciesList.setToolTip(QtGui.QApplication.translate("Dialog", "Modules the new module will depend on", None, QtGui.QApplication.UnicodeUTF8))
+        self.okButton.setText(QtGui.QApplication.translate("Dialog", "&OK", None, QtGui.QApplication.UnicodeUTF8))
+        self.cancelButton.setText(QtGui.QApplication.translate("Dialog", "&Cancel", None, QtGui.QApplication.UnicodeUTF8))
+
+
+if __name__ == "__main__":
+    import sys
+    app = QtGui.QApplication(sys.argv)
+    Dialog = QtGui.QDialog()
+    ui = Ui_Dialog()
+    ui.setupUi(Dialog)
+    Dialog.show()
+    sys.exit(app.exec_())
+

Copied: rl/branches/persistence2/editors/Lockenwickler/src/ZoneManager.py (from rev 4878, rl/trunk/editors/Lockenwickler/src/ZoneManager.py)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/media/Pivot_Point.material
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/media/Pivot_Point.material	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/media/Pivot_Point.material	2009-04-01 20:08:44 UTC (rev 4879)
@@ -94,6 +94,31 @@
 	}
 }
 
+material Lockenwickler_Area_Subtract
+{
+	technique
+	{
+                pass
+		{
+                        depth_write off
+                        scene_blend alpha_blend
+                        
+			ambient 0.0 0.0 1.0 0.2
+			diffuse 0.0 0.0 1.0 0.2
+			emissive 0.0 0.0 1.0 0.2
+		}
+
+		pass
+		{
+                        polygon_mode wireframe
+
+			ambient 0.0 0.0 1.0 1.0
+			diffuse 0.0 0.0 1.0 1.0
+			emissive 0.0 0.0 1.0 1.0
+		}
+	}
+}
+
 vertex_program PlainColor_VS cg
 {
 	source PlainColor.cg
@@ -164,10 +189,34 @@
 			vertex_program_ref PlainColorGLSL_VP	
 			{
 			}
-			
+				
 			fragment_program_ref PlainColorGLSL_FP
 			{
 			}
 		}
 	}
 }
+
+fragment_program FragmentDepthMap glsl
+{
+	source depthmap.frag
+}
+
+material DepthMap
+{
+	technique
+	{
+		pass
+		{
+			vertex_program_ref PlainColorGLSL_VP	
+			{
+			}
+
+			fragment_program_ref FragmentDepthMap
+			{
+				param_named_auto fNear near_clip_distance
+				param_named_auto fFar far_clip_distance
+			}
+		}
+	}
+}

Modified: rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColorVP.glsl
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColorVP.glsl	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColorVP.glsl	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,5 +1,8 @@
+varying float depth;
+
 void main()
 {
+	depth = (gl_ModelViewMatrix * gl_Vertex).z;
 	gl_Position = ftransform();
 }
 

Modified: rl/branches/persistence2/editors/Lockenwickler/src/media/UniCube.mesh
===================================================================
(Binary files differ)

Copied: rl/branches/persistence2/editors/Lockenwickler/src/media/depthmap.frag (from rev 4878, rl/trunk/editors/Lockenwickler/src/media/depthmap.frag)

Copied: rl/branches/persistence2/editors/Lockenwickler/src/media/icons/14_layer_invisible.png (from rev 4878, rl/trunk/editors/Lockenwickler/src/media/icons/14_layer_invisible.png)

Copied: rl/branches/persistence2/editors/Lockenwickler/src/media/icons/14_layer_visible.png (from rev 4878, rl/trunk/editors/Lockenwickler/src/media/icons/14_layer_visible.png)

Copied: rl/branches/persistence2/editors/Lockenwickler/src/media/icons/dissociatecell.png (from rev 4878, rl/trunk/editors/Lockenwickler/src/media/icons/dissociatecell.png)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/setup.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/setup.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/setup.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,4 +1,23 @@
-from distutils.core import setup
-import py2exe
-
-setup(windows=["Lockenwickler.py"], options={"py2exe" : {"includes" : ["sip", "PyQt4._qt"]}})
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+from distutils.core import setup
+import py2exe
+
+setup(windows=["Lockenwickler.py"], options={"py2exe" : {"includes" : ["sip", "PyQt4._qt"]}})

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ui_ConsoleWindow.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ui_ConsoleWindow.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ui_ConsoleWindow.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,11 +1,21 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'console_window.ui'
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
 #
-# Created: Mon May 12 15:09:24 2008
-#      by: PyQt4 UI code generator 4.3.3
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
 #
-# WARNING! All changes made in this file will be lost!
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 from PyQt4 import QtCore, QtGui
 
@@ -16,7 +26,8 @@
 
         self.gridlayout = QtGui.QGridLayout(ConsoleWindow)
         self.gridlayout.setObjectName("gridlayout")
-
+        self.gridlayout.setContentsMargins(0, 0, 0, 0)
+        
         self.textEdit = QtGui.QTextEdit(ConsoleWindow)
         self.textEdit.setObjectName("textEdit")
         self.gridlayout.addWidget(self.textEdit,0,0,1,1)

Modified: rl/branches/persistence2/engine/ai/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/ai/CMakeLists.txt	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/CMakeLists.txt	2009-04-01 20:08:44 UTC (rev 4879)
@@ -6,7 +6,8 @@
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIRS}
-${OPENSTEER_INCLUDE_DIR})
+${OPENSTEER_INCLUDE_DIR}
+${XERCESC_INCLUDE_DIR})
 
 SET(RlAi_LIB_SRCS
 src/Agent.cpp
@@ -43,7 +44,17 @@
 src/WalkPathBehaviour.cpp
 src/WayPointNode.cpp
 src/WayPointGraph.cpp
-src/WayPointGraphManager.cpp)
+src/WayPointGraphManager.cpp
+src/OpenSteer/Color.cpp
+src/OpenSteer/lq.c
+src/OpenSteer/Obstacle.cpp
+src/OpenSteer/Path.cpp
+src/OpenSteer/Pathway.cpp
+src/OpenSteer/PolylineSegmentedPath.cpp
+src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp
+src/OpenSteer/SegmentedPath.cpp
+src/OpenSteer/SegmentedPathway.cpp
+src/OpenSteer/Vec3.cpp)
 
 ADD_LIBRARY(RlAi SHARED ${RlAi_LIB_SRCS})
 

Modified: rl/branches/persistence2/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/ai/RlAI2005.vcproj	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/RlAI2005.vcproj	2009-04-01 20:08:44 UTC (rev 4879)
@@ -41,7 +41,7 @@
 				Name="VCCLCompilerTool"
 				AdditionalOptions="-Zm146"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt_ngt\inc;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK2\sdk\;..\..\dependencies\ois\includes;..\..\dependencies\xerces\include;..\..\dependencies\ogrenew\Dependencies\include"
+				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\inc;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\xerces\include"
 				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS;_DEBUG;WIN32;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -76,7 +76,7 @@
 				AdditionalDependencies="OgreMain_d.lib OgreNewt_d.lib CEGUIBase_d.lib opensteerd.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib xerces-c_2D.lib"
 				OutputFile="$(OutDir)/RlAI.dll"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;..\..\dependencies\ogrenewt_ngt\lib\;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK2\sdk\x32\dll_vs7;..\..\dependencies\xerces\lib"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;..\..\dependencies\ogrenewt\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7;..\..\dependencies\xerces\lib"
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
 				ProgramDatabaseFile="$(OutDir)/RlAI.pdb"
@@ -141,7 +141,7 @@
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt_ngt\inc;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\xerces\include"
+				AdditionalIncludeDirectories=".\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\inc;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\xerces\include"
 				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				RuntimeLibrary="2"
 				UsePrecompiledHeader="2"
@@ -164,7 +164,7 @@
 				AdditionalDependencies="OgreMain.lib OgreNewt.lib CEGUIBase.lib opensteer.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib xerces-c_2.lib"
 				OutputFile="$(OutDir)/RlAI.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\xerces\lib"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;..\..\dependencies\ogrenewt\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7;..\..\dependencies\xerces\lib"
 				GenerateDebugInformation="false"
 				SubSystem="2"
 				OptimizeReferences="2"

Copied: rl/branches/persistence2/engine/ai/RlAI2008.vcproj (from rev 4878, rl/trunk/engine/ai/RlAI2008.vcproj)

Modified: rl/branches/persistence2/engine/ai/include/AgentCombatState.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/AgentCombatState.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/AgentCombatState.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -54,3 +54,4 @@
 	};
 }
 #endif
+

Modified: rl/branches/persistence2/engine/ai/include/AgentDialogState.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/AgentDialogState.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/AgentDialogState.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,45 +1,47 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __RlAI_AgentDialogState_H__
-#define __RlAI_AgentDialogState_H__
-
-#include "AgentState.h"
-
-namespace rl
-{
-    class Dialog;
-
-    class _RlAiExport AgentDialogState :
-        public AgentState
-    {
-    public:
-        AgentDialogState(Agent* agent);
-        ~AgentDialogState();
-
-        virtual void update(const Ogre::Real elapsedTime);
-        void setDialogPartner(Agent* partner);
-        void setDialog(Dialog* dialog);
-
-    private:
-        Agent* mPartner;
-        Dialog* mDialog;
-        bool mTalking;
-    };
-
-}
-
-#endif // __RlAI_AgentDialogState_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __RlAI_AgentDialogState_H__
+#define __RlAI_AgentDialogState_H__
+
+#include "AgentState.h"
+
+#include <list>
+
+namespace rl
+{
+    class Dialog;
+
+    class _RlAiExport AgentDialogState :
+        public AgentState
+    {
+    public:
+        AgentDialogState(Agent* agent);
+        ~AgentDialogState();
+
+        virtual void update(const Ogre::Real elapsedTime);
+        void addDialogPartner(Agent* partner);
+        void setDialog(Dialog* dialog);
+
+    private:
+        std::list<Agent*> mPartners;
+        Dialog* mDialog;
+        bool mTalking;
+    };
+
+}
+
+#endif // __RlAI_AgentDialogState_H__

Modified: rl/branches/persistence2/engine/ai/include/DialogElement.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/DialogElement.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/DialogElement.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -32,8 +32,8 @@
         const CeGuiString& getId() const;
         void addParagraph(DialogParagraph* paragraph);
         virtual std::list<DialogParagraph*> getParagraphs(Dialog* dialog);
-		virtual bool isSelection() const;
-		const CeGuiString& getPerson() const;
+        virtual bool isSelection() const;
+        const CeGuiString& getPerson() const;
 
     protected:
         DialogElement(const CeGuiString& id, const CeGuiString& person = "");
@@ -51,8 +51,8 @@
     class DialogSelection : public DialogElementType
     {
     public:
-        DialogSelection(const CeGuiString& id)
-            : DialogElementType(id, false), mVariable(NULL)
+        DialogSelection(const CeGuiString& id, const CeGuiString& person)
+            : DialogElementType(id, person), mVariable(NULL)
         {
         }
 
@@ -97,11 +97,11 @@
 
         DialogElementType* getSelectedElement(Dialog* dialog) const
         {
-			// Recalculate switch variable on start, keep for whole switch evaluation
-			if (mVariable)
-			{
-				mVariable->invalidate();
-			}
+            // Recalculate switch variable on start, keep for whole switch evaluation
+            if (mVariable)
+            {
+                    mVariable->invalidate();
+            }
 
             for (typename CondElemMap::const_iterator it = mElements.begin(); it != mElements.end(); ++it)
             {
@@ -116,10 +116,10 @@
             return NULL;
         }
 
-		virtual bool isSelection() const
-		{
-			return true;
-		}
+        virtual bool isSelection() const
+        {
+            return true;
+        }
 
     private:
         typedef std::vector<std::pair<DialogCondition*, DialogElementType*> > CondElemMap;

Modified: rl/branches/persistence2/engine/ai/include/DialogLoaderImpl.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/DialogLoaderImpl.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/DialogLoaderImpl.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,12 +1,18 @@
-/*
- *  DialogLoaderImpl.h
- *  Rastullah
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
  *
- *  Created by Sascha Kolewa on 04.12.08.
- *  Copyright 2008 __MyCompanyName__. All rights reserved.
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
  *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
-
 #include "AiPrerequisites.h"
 
 #include <list>
@@ -41,16 +47,16 @@
         {
         public:
             DialogParticipant(const CeGuiString& personId,
-                    int goId, const CeGuiString& goClass, const CeGuiString& name);
+                    const CeGuiString &goId, const CeGuiString& goClass, const CeGuiString& name);
 
             bool isMatching(Creature* go) const;
             const CeGuiString& getPersonId() const;
 
         private:
-            const CeGuiString& mPersonId;
-            int mGoId;
-            const CeGuiString& mGoClass;
-            const CeGuiString& mName;
+            const CeGuiString mPersonId;
+            CeGuiString mGoId;
+            const CeGuiString mGoClass;
+            const CeGuiString mName;
         };
 
         class DialogPrototype

Modified: rl/branches/persistence2/engine/ai/include/DialogOption.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/DialogOption.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/DialogOption.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -33,7 +33,7 @@
     class _RlAiExport DialogOption : public DialogElement
     {
     public:
-        DialogOption(const CeGuiString& id, bool isAutoSelected);
+        DialogOption(const CeGuiString& id, const CeGuiString& person, bool autoSelected = false);
         ~DialogOption();
 
         const CeGuiString& getLabel() const;
@@ -46,6 +46,7 @@
         virtual const CeGuiString& getConditionVariableType();
         virtual bool isConditional();
 
+        void setAutoSelected(bool autoSelected);
         bool isAutoSelected() const;
         bool isAvailable(Dialog* dialog) const;
 
@@ -56,7 +57,7 @@
         DialogResponse* mResponse;
         DialogCondition* mPrecondition;
         CeGuiString mLabel;
-        bool mIsAutoSelected;
+        bool mAutoSelected;
     };
 
     typedef DialogSelection<DialogOption> DialogOptionSelection;

Modified: rl/branches/persistence2/engine/ai/include/DialogResponse.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/DialogResponse.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/DialogResponse.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -36,7 +36,7 @@
         typedef std::vector<DialogOption*> Options;
         typedef std::vector<DialogImplication*> Implications;
 
-        DialogResponse(const CeGuiString& id, int npcId = 0);
+        DialogResponse(const CeGuiString& id, const CeGuiString& person);
         virtual ~DialogResponse();
 
         void addOption(DialogOption* option);
@@ -52,13 +52,12 @@
     private:
         Options mOptions;
         Implications mEffects;
-        int mNpcId;
     };
 
     class DialogResponseSelection : public DialogSelection<DialogResponse>
     {
     public:
-        DialogResponseSelection(const CeGuiString& id);
+        DialogResponseSelection(const CeGuiString& id, const CeGuiString& person);
         virtual const Options& getOptions(Dialog* dialog) const;
     };
 

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer (from rev 4878, rl/trunk/engine/ai/include/OpenSteer)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/AbstractVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/AbstractVehicle.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/AbstractVehicle.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,107 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// AbstractVehicle: pure virtual base class for generic steerable vehicles
-//
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 01-30-03 cwr: created 
-//
-//
-// ----------------------------------------------------------------------------
-
-#ifndef OPENSTEER_ABSTRACTVEHICLE_H
-#define OPENSTEER_ABSTRACTVEHICLE_H
-
-
-#include "OpenSteer/LocalSpace.h"
-
-
-// STL vector containers
-#include <vector>
-
-
-// ----------------------------------------------------------------------------
-
-namespace OpenSteer {
-
-    class AbstractVehicle : public AbstractLocalSpace 
-    {
-    public:
-        virtual ~AbstractVehicle() { /* Nothing to do. */ }
-        
-        // mass (defaults to unity so acceleration=force)
-        virtual float getMass (void) const = 0;
-        virtual float setMass (float) = 0;
-
-        // size of bounding sphere, for obstacle avoidance, etc.
-        virtual float getRadius (void) const = 0;
-        virtual float setRadius (float) = 0;
-
-        // velocity of vehicle
-        virtual Vector3 getVelocity (void) const = 0;
-
-        // speed of vehicle  (may be faster than taking magnitude of velocity)
-        virtual float getSpeed (void) const = 0;
-        virtual float setSpeed (float) = 0;
-
-        // groups of (pointers to) abstract vehicles, and iterators over them
-        typedef std::vector<AbstractVehicle*> group;
-        typedef group::const_iterator iterator;    
-
-        // predict position of this vehicle at some time in the future
-        // (assumes velocity remains constant)
-        virtual Vector3 predictFuturePosition (const float predictionTime) const = 0;
-
-        // ----------------------------------------------------------------------
-        // XXX this vehicle-model-specific functionality functionality seems out
-        // XXX of place on the abstract base class, but for now it is expedient
-
-        // the maximum steering force this vehicle can apply
-        virtual float getMaxForce (void) const = 0;
-        virtual float setMaxForce (float) = 0;
-
-        // the maximum speed this vehicle is allowed to move
-        virtual float getMaxSpeed (void) const = 0;
-        virtual float setMaxSpeed (float) = 0;
-
-		// dp - added to support heterogeneous flocks
-		virtual void update(const float currentTime, const float elapsedTime) = 0;
-    };
-
-
-    // more convenient short names for AbstractVehicle group and iterator
-    typedef AbstractVehicle::group AVGroup;
-    typedef AbstractVehicle::iterator AVIterator;
-
-} // namespace OpenSteer
-
-
-// ----------------------------------------------------------------------------
-#endif // OPENSTEER_ABSTRACTVEHICLE_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/AbstractVehicle.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/AbstractVehicle.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/Color.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Color.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/Color.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,153 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// Color class and predefined colors.
-//
-// May 05, 2005 bk:  created 
-//
-//
-// ----------------------------------------------------------------------------
-
-
-#ifndef OPENSTEER_COLOR_H
-#define OPENSTEER_COLOR_H
-
-#include "OpenSteer/Vec3.h"
-
-
-namespace OpenSteer {
-    
-    class Color {
-    public:
-        Color();
-        explicit Color( float greyValue );
-        Color( float rValue, float gValue, float bValue, float aValue = 1.0f );
-        explicit Color( Vector3 const& vector );
-        
-        float r() const;
-        float g() const;
-        float b() const;
-        float a() const;
-        
-        void setR( float value );
-        void setG( float value );
-        void setB( float value );
-		void setA( float value );
-        void set( float rValue, float gValue, float bValue, float aValue = 1.0f );
-        
-        Vector3 convertToVec3() const;
-    
-		// this is necessary so that graphics API's such as DirectX
-		// requiring a pointer to colors can do their conversion
-		// without a lot of copying.
-		float const*const colorFloatArray() const { return &r_; }
-
-        Color& operator+=( Color const& other );
-        
-        /**
-         * @todo What happens if color components become negative?
-         */
-        Color& operator-=( Color const& other );
-        
-        /**
-         * @todo What happens if color components become negative?
-         */
-        Color& operator*=( float factor );
-        
-        /**
-         * @todo What happens if color components become negative?
-         */
-        Color& operator/=( float factor );
-        
-        
-    private:
-        float r_;
-        float g_;
-        float b_;
-		 float a_;	// provided for API's which require four components        
-    }; // class Color
-    
-    
-    Color operator+( Color const& lhs, Color const& rhs );
-    
-    /**
-     * @todo What happens if color components become negative?
-     */
-    Color operator-( Color const& lhs, Color const& rhs );
-    
-    /**
-     * @todo What happens if color components become negative?
-     */
-    Color operator*( Color const& lhs, float rhs );
-    
-    /**
-     * @todo What happens if color components become negative?
-     */
-    Color operator*( float lhs, Color const& rhs );
-    
-    /**
-     * @todo What happens if color components become negative?
-     */
-    Color operator/( Color const& lhs, float rhs );
-    
-    
-    Color grayColor( float value );
-    
-    extern Color const gBlack;
-    extern Color const gWhite; 
-    extern Color const gRed; 
-    extern Color const gGreen;
-    extern Color const gBlue;
-    extern Color const gYellow;
-    extern Color const gCyan;
-    extern Color const gMagenta;
-    extern Color const gOrange;
-    extern Color const gDarkRed;
-    extern Color const gDarkGreen;
-    extern Color const gDarkBlue;
-    extern Color const gDarkYellow;
-    extern Color const gDarkCyan;
-    extern Color const gDarkMagenta;
-    extern Color const gDarkOrange;
-    
-    extern Color const gGray10;
-    extern Color const gGray20;
-    extern Color const gGray30;
-    extern Color const gGray40;
-    extern Color const gGray50;
-    extern Color const gGray60;
-    extern Color const gGray70;
-    extern Color const gGray80;
-    extern Color const gGray90;
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_COLOR_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/Color.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/Color.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/LocalSpace.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/LocalSpace.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/LocalSpace.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,360 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// LocalSpace: a local coordinate system for 3d space
-//
-// Provide functionality such as transforming from local space to global
-// space and vice versa.  Also regenerates a valid space from a perturbed
-// "forward vector" which is the basis of abnstract vehicle turning.
-//
-// These are comparable to a 4x4 homogeneous transformation matrix where the
-// 3x3 (R) portion is constrained to be a pure rotation (no shear or scale).
-// The rows of the 3x3 R matrix are the basis vectors of the space.  They are
-// all constrained to be mutually perpendicular and of unit length.  The top
-// ("x") row is called "side", the middle ("y") row is called "up" and the
-// bottom ("z") row is called forward.  The translation vector is called
-// "position".  Finally the "homogeneous column" is always [0 0 0 1].
-//
-//     [ R R R  0 ]      [ Sx Sy Sz  0 ]
-//     [ R R R  0 ]      [ Ux Uy Uz  0 ]
-//     [ R R R  0 ]  ->  [ Fx Fy Fz  0 ]
-//     [          ]      [             ]
-//     [ T T T  1 ]      [ Tx Ty Tz  1 ]
-//
-// This file defines three classes:
-//   AbstractLocalSpace:  pure virtual interface
-//   LocalSpaceMixin:     mixin to layer LocalSpace functionality on any base
-//   LocalSpace:          a concrete object (can be instantiated)
-//
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 06-05-02 cwr: created 
-//
-//
-// ----------------------------------------------------------------------------
-
-
-#ifndef OPENSTEER_LOCALSPACE_H
-#define OPENSTEER_LOCALSPACE_H
-
-
-#include "OpenSteer/Vec3.h"
-
-
-// ----------------------------------------------------------------------------
-
-
-namespace OpenSteer {
-
-
-    class AbstractLocalSpace
-    {
-    public:
-        virtual ~AbstractLocalSpace() { /* Nothing to do. */ }
-        
-
-        // accessors (get and set) for side, up, forward and position
-        virtual Vector3 getSide (void) const = 0;
-        virtual Vector3 setSide (Vector3 s) = 0;
-        virtual Vector3 getUp (void) const = 0;
-        virtual Vector3 setUp (Vector3 u) = 0;
-        virtual Vector3 getForward (void) const = 0;
-        virtual Vector3 setForward (Vector3 f) = 0;
-        virtual Vector3 getPosition (void) const = 0;
-        virtual Vector3 setPosition (Vector3 p) = 0;
-
-        // use right-(or left-)handed coordinate space
-        virtual bool isRightHanded(void) const = 0;
-
-        // reset transform to identity
-        virtual void resetLocalSpace (void) = 0;
-
-        // transform a direction in global space to its equivalent in local space
-        virtual Vector3 localizeDirection (const Vector3& globalDirection) const = 0;
-
-        // transform a point in global space to its equivalent in local space
-        virtual Vector3 localizePosition (const Vector3& globalPosition) const = 0;
-
-        // transform a point in local space to its equivalent in global space
-        virtual Vector3 globalizePosition (const Vector3& localPosition) const = 0;
-
-        // transform a direction in local space to its equivalent in global space
-        virtual Vector3 globalizeDirection (const Vector3& localDirection) const = 0;
-
-        // set "side" basis vector to normalized cross product of forward and up
-        virtual void setUnitSideFromForwardAndUp (void) = 0;
-
-        // regenerate the orthonormal basis vectors given a new forward
-        // (which is expected to have unit length)
-        virtual void regenerateOrthonormalBasisUF (const Vector3& newUnitForward) = 0;
-
-        // for when the new forward is NOT of unit length
-        virtual void regenerateOrthonormalBasis (const Vector3& newForward) = 0;
-
-        // for supplying both a new forward and and new up
-        virtual void regenerateOrthonormalBasis (const Vector3& newForward,
-                                                 const Vector3& newUp) = 0;
-
-        // rotate 90 degrees in the direction implied by isRightHanded()
-        virtual Vector3 localRotateForwardToSide (const Vector3& v) const = 0;
-        virtual Vector3 globalRotateForwardToSide (const Vector3& globalForward) const=0;
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // LocalSpaceMixin is a mixin layer, a class template with a paramterized base
-    // class.  Allows "LocalSpace-ness" to be layered on any class.
-
-
-    template <class Super>
-    class LocalSpaceMixin : public Super
-    {
-        // transformation as three orthonormal unit basis vectors and the
-        // origin of the local space.  These correspond to the "rows" of
-        // a 3x4 transformation matrix with [0 0 0 1] as the final column
-
-    private:
-
-        Vector3 _side;     //    side-pointing unit basis vector
-        Vector3 _up;       //  upward-pointing unit basis vector
-        Vector3 _forward;  // forward-pointing unit basis vector
-        Vector3 _position; // origin of local space
-
-    public:
-
-        // accessors (get and set) for side, up, forward and position
-        Vector3 getSide     (void) const {return _side;}
-        Vector3 getUp       (void) const {return _up;}
-        Vector3 getForward  (void) const {return _forward;}
-        Vector3 getPosition (void) const {return _position;}
-        Vector3 setSide     (Vector3 s) {return _side = s;}
-        Vector3 setUp       (Vector3 u) {return _up = u;}
-        Vector3 setForward  (Vector3 f) {return _forward = f;}
-        Vector3 setPosition (Vector3 p) {return _position = p;}
-        Vector3 setSide     (float x, float y, float z){return _side = Vector3(x,y,z);}
-        Vector3 setUp       (float x, float y, float z){return _up = Vector3(x,y,z);}
-        Vector3 setForward  (float x, float y, float z){return _forward = Vector3(x,y,z);}
-        Vector3 setPosition (float x, float y, float z){return _position = Vector3(x,y,z);}
-
-
-        // ------------------------------------------------------------------------
-        // Global compile-time switch to control handedness/chirality: should
-        // LocalSpace use a left- or right-handed coordinate system?  This can be
-        // overloaded in derived types (e.g. vehicles) to change handedness.
-
-        bool isRightHanded(void) const {return true;}
-
-
-        // ------------------------------------------------------------------------
-        // constructors
-
-
-        LocalSpaceMixin (void)
-        {
-            resetLocalSpace ();
-        };
-
-        LocalSpaceMixin (const Vector3& Side,
-                         const Vector3& Up,
-                         const Vector3& Forward,
-                         const Vector3& Position)
-            : _side( Side ), _up( Up ), _forward( Forward ), _position( Position ) {}
-
-
-        LocalSpaceMixin (const Vector3& Up,
-                         const Vector3& Forward,
-                         const Vector3& Position)
-            : _side(), _up( Up ), _forward( Forward ), _position( Position )
-        {
-            setUnitSideFromForwardAndUp();
-        }
-
-        
-        virtual ~LocalSpaceMixin() { /* Nothing to do. */ }
-        
-
-        // ------------------------------------------------------------------------
-        // reset transform: set local space to its identity state, equivalent to a
-        // 4x4 homogeneous transform like this:
-        //
-        //     [ X 0 0 0 ]
-        //     [ 0 1 0 0 ]
-        //     [ 0 0 1 0 ]
-        //     [ 0 0 0 1 ]
-        //
-        // where X is 1 for a left-handed system and -1 for a right-handed system.
-
-        void resetLocalSpace (void)
-        {
-            _forward = Vector3(0, 0, 1);
-            _side = localRotateForwardToSide (_forward);
-            _up = Vector3(0, 1, 0);
-            _position = Vector3(0, 0, 0);
-        };
-
-
-        // ------------------------------------------------------------------------
-        // transform a direction in global space to its equivalent in local space
-
-
-        Vector3 localizeDirection (const Vector3& globalDirection) const
-        {
-            // dot offset with local basis vectors to obtain local coordiantes
-            return Vector3 (globalDirection.dotProduct(_side),
-                         globalDirection.dotProduct(_up),
-                         globalDirection.dotProduct(_forward));
-        };
-
-
-        // ------------------------------------------------------------------------
-        // transform a point in global space to its equivalent in local space
-
-
-        Vector3 localizePosition (const Vector3& globalPosition) const
-        {
-            // global offset from local origin
-            Vector3 globalOffset = globalPosition - _position;
-
-            // dot offset with local basis vectors to obtain local coordiantes
-            return localizeDirection (globalOffset);
-        };
-
-
-        // ------------------------------------------------------------------------
-        // transform a point in local space to its equivalent in global space
-
-
-        Vector3 globalizePosition (const Vector3& localPosition) const
-        {
-            return _position + globalizeDirection (localPosition);
-        };
-
-
-        // ------------------------------------------------------------------------
-        // transform a direction in local space to its equivalent in global space
-
-
-        Vector3 globalizeDirection (const Vector3& localDirection) const
-        {
-            return ((_side    * localDirection.x) +
-                    (_up      * localDirection.y) +
-                    (_forward * localDirection.z));
-        };
-
-
-        // ------------------------------------------------------------------------
-        // set "side" basis vector to normalized cross product of forward and up
-
-
-        void setUnitSideFromForwardAndUp (void)
-        {
-            // derive new unit side basis vector from forward and up
-            if (isRightHanded())
-                _side = _forward.crossProduct(_up);
-            else
-                _side = _up.crossProduct(_forward);
-            _side = _side.normalisedCopy();
-        }
-
-
-        // ------------------------------------------------------------------------
-        // regenerate the orthonormal basis vectors given a new forward
-        // (which is expected to have unit length)
-
-
-        void regenerateOrthonormalBasisUF (const Vector3& newUnitForward)
-        {
-            _forward = newUnitForward;
-
-            // derive new side basis vector from NEW forward and OLD up
-            setUnitSideFromForwardAndUp();
-
-            // derive new Up basis vector from new Side and new Forward
-            // (should have unit length since Side and Forward are
-            // perpendicular and unit length)
-            if (isRightHanded())
-                _up = _side.crossProduct(_forward);
-            else
-                _up = _forward.crossProduct(_side);
-        }
-
-
-        // for when the new forward is NOT know to have unit length
-
-        void regenerateOrthonormalBasis (const Vector3& newForward)
-        {
-            regenerateOrthonormalBasisUF (newForward.normalisedCopy());
-        }
-
-
-        // for supplying both a new forward and and new up
-
-        void regenerateOrthonormalBasis (const Vector3& newForward,
-                                         const Vector3& newUp)
-        {
-            _up = newUp;
-            regenerateOrthonormalBasis (newForward.normalisedCopy());
-        }
-
-
-        // ------------------------------------------------------------------------
-        // rotate, in the canonical direction, a vector pointing in the
-        // "forward" (+Z) direction to the "side" (+/-X) direction
-
-
-        Vector3 localRotateForwardToSide (const Vector3& v) const
-        {
-            return Vector3 (isRightHanded() ? -v.z : +v.z,
-                         v.y,
-                         v.x);
-        }
-
-        // not currently used, just added for completeness
-
-        Vector3 globalRotateForwardToSide (const Vector3& globalForward) const
-        {
-            const Vector3 localForward = localizeDirection (globalForward);
-            const Vector3 localSide = localRotateForwardToSide (localForward);
-            return globalizeDirection (localSide);
-        }
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // Concrete LocalSpace class, and a global constant for the identity transform
-
-
-    typedef LocalSpaceMixin<AbstractLocalSpace> LocalSpace;
-
-    const LocalSpace gGlobalSpace;
-
-} // namespace OpenSteer
-
-// ----------------------------------------------------------------------------
-#endif // OPENSTEER_LOCALSPACE_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/LocalSpace.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/LocalSpace.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/Obstacle.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Obstacle.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/Obstacle.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,306 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// Obstacles for use with obstacle avoidance
-//
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 09-05-02 cwr: created
-//
-//
-// ----------------------------------------------------------------------------
-
-
-#ifndef OPENSTEER_OBSTACLE_H
-#define OPENSTEER_OBSTACLE_H
-
-
-#include "OpenSteer/Vec3.h"
-#include "OpenSteer/LocalSpace.h"
-#include "OpenSteer/AbstractVehicle.h"
-
-
-namespace OpenSteer {
-
-    
-    // Forward declaration.
-    class Color;
-    
-
-    // ----------------------------------------------------------------------------
-    // AbstractObstacle: a pure virtual base class for an abstract shape in
-    // space, to be used with obstacle avoidance.  (Oops, its not "pure" since
-    // I added a concrete method to PathIntersection 11-04-04 -cwr).
-
-
-    class AbstractObstacle
-    {
-    public:
-
-        virtual ~AbstractObstacle() { /* Nothing to do. */ }
-        
-        
-        // compute steering for a vehicle to avoid this obstacle, if needed
-        virtual Vector3 steerToAvoid (const AbstractVehicle& v,
-                                   const float minTimeToCollision) const = 0;
-
-        // PathIntersection object: used internally to analyze and store
-        // information about intersections of vehicle paths and obstacles.
-        class PathIntersection
-        {
-        public:
-            bool intersect; // was an intersection found?
-            float distance; // how far was intersection point from vehicle?
-            Vector3 surfacePoint; // position of intersection
-            Vector3 surfaceNormal; // unit normal at point of intersection
-            Vector3 steerHint; // where to steer away from intersection
-            bool vehicleOutside; // is the vehicle outside the obstacle?
-            const AbstractObstacle* obstacle; // obstacle the path intersects
-
-            // determine steering based on path intersection tests
-            Vector3 steerToAvoidIfNeeded (const AbstractVehicle& vehicle,
-                                       const float minTimeToCollision) const;
-
-        };
-
-        // find first intersection of a vehicle's path with this obstacle
-        // (this must be specialized for each new obstacle shape class)
-        virtual void
-        findIntersectionWithVehiclePath (const AbstractVehicle& vehicle,
-                                         PathIntersection& pi)
-            const
-            = 0 ;
-
-        // virtual function for drawing -- normally does nothing, can be
-        // specialized by derived types to provide graphics for obstacles
-        virtual void draw (const bool filled,
-                           const Color& color,
-                           const Vector3& viewpoint)
-            const
-            = 0 ;
-
-        // seenFrom (eversion): does this obstacle contrain vehicle to stay
-        // inside it or outside it (or both)?  "Inside" describes a clear space
-        // within a solid (for example, the interior of a room inside its
-        // walls). "Ouitside" describes a solid chunk in the midst of clear
-        // space.
-        enum seenFromState {outside, inside, both};
-        virtual seenFromState seenFrom (void) const = 0;
-        virtual void setSeenFrom (seenFromState s) = 0;
-    };
-
-
-    // an STL vector of AbstractObstacle pointers and an iterator for it:
-    typedef std::vector<AbstractObstacle*> ObstacleGroup;
-    typedef ObstacleGroup::const_iterator ObstacleIterator;
-
-
-    // ----------------------------------------------------------------------------
-    // Obstacle is a utility base class providing some shared functionality
-
-
-    class Obstacle : public AbstractObstacle
-    {
-    public:
-
-        Obstacle (void) : _seenFrom (outside) {}
-
-        virtual ~Obstacle() { /* Nothing to do. */ }
-        
-        // compute steering for a vehicle to avoid this obstacle, if needed 
-        Vector3 steerToAvoid (const AbstractVehicle& v,
-                           const float minTimeToCollision)
-            const;
-
-        // static method to apply steerToAvoid to nearest obstacle in an
-        // ObstacleGroup
-        static Vector3 steerToAvoidObstacles (const AbstractVehicle& vehicle,
-                                           const float minTimeToCollision,
-                                           const ObstacleGroup& obstacles);
-
-        // static method to find first vehicle path intersection in an
-        // ObstacleGroup
-        static void
-        firstPathIntersectionWithObstacleGroup (const AbstractVehicle& vehicle,
-                                                const ObstacleGroup& obstacles,
-                                                PathIntersection& nearest,
-                                                PathIntersection& next);
-
-        // default do-nothing draw function (derived class can overload this)
-        void draw (const bool, const Color&, const Vector3&) const {}
-
-        seenFromState seenFrom (void) const {return _seenFrom;}
-        void setSeenFrom (seenFromState s) {_seenFrom = s;}
-    private:
-        seenFromState _seenFrom;
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // SphereObstacle a simple ball-shaped obstacle
-
-
-    class SphereObstacle : public Obstacle
-    {
-    public:
-        float radius;
-        Vector3 center;
-
-        // constructors
-        SphereObstacle (float r, Vector3 c) : radius(r), center (c) {}
-        SphereObstacle (void) : radius(1), center (Vector3::ZERO) {}
-
-        virtual ~SphereObstacle() { /* Nothing to do. */ }
-        
-        // find first intersection of a vehicle's path with this obstacle
-        void findIntersectionWithVehiclePath (const AbstractVehicle& vehicle,
-                                              PathIntersection& pi)
-            const;
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // LocalSpaceObstacle: a mixture of LocalSpace and Obstacle methods
-
-
-     typedef LocalSpaceMixin<Obstacle> LocalSpaceObstacle;
-
-
-    // ----------------------------------------------------------------------------
-    // BoxObstacle: a box-shaped (cuboid) obstacle of a given height, width,
-    // depth, position and orientation.  The box is centered on and aligned
-    // with a local space.
-
-
-    class BoxObstacle : public LocalSpaceObstacle
-    {
-    public:
-        float width;  // width  of box centered on local X (side)    axis
-        float height; // height of box centered on local Y (up)      axis
-        float depth;  // depth  of box centered on local Z (forward) axis
-
-        // constructors
-        BoxObstacle (float w, float h, float d) : width(w), height(h), depth(d) {}
-        BoxObstacle (void) :  width(1.0f), height(1.0f), depth(1.0f) {}
-
-        virtual ~BoxObstacle() { /* Nothing to do. */ }
-        
-        
-        // find first intersection of a vehicle's path with this obstacle
-        void findIntersectionWithVehiclePath (const AbstractVehicle& vehicle,
-                                              PathIntersection& pi)
-            const;
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // PlaneObstacle: a planar obstacle of a given position and orientation.
-    // The plane is defined as the XY (aka side/up) plane of a local space.
-    // The +Z (forward) half-space is considered "outside" the obstacle.  
-    //
-    // This is also the base class for several other obstacles which represent
-    // 2d shapes (rectangle, triangle, ...) arbitarily oriented and positioned
-    // in 2d space.  They specialize this class via xyPointInsideShape which
-    // tests if a given point on the XZ plane is inside the obstacle's shape.
-
-
-    class PlaneObstacle : public LocalSpaceObstacle
-    {
-    public:
-        // constructors
-        PlaneObstacle (void) {}
-        PlaneObstacle (const Vector3& s,
-                       const Vector3& u,
-                       const Vector3& f,
-                       const Vector3& p)
-        : LocalSpaceObstacle( s, u, f, p )
-        {
-            /*
-            setSide (s);
-            setUp (u);
-            setForward (f);
-            setPosition (p);
-             */
-        }
-
-        // find first intersection of a vehicle's path with this obstacle
-        void findIntersectionWithVehiclePath (const AbstractVehicle& vehicle,
-                                              PathIntersection& pi)
-            const;
-
-        // determines if a given point on XY plane is inside obstacle shape
-        virtual bool xyPointInsideShape (const Vector3& /*point*/,
-                                         float /*radius*/) const
-        {
-            return true; // always true for PlaneObstacle
-        }
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // RectangleObstacle: a rectangular obstacle of a given height, width,
-    // position and orientation.  It is a rectangle centered on the XY (aka
-    // side/up) plane of a local space.
-
-
-    class RectangleObstacle : public PlaneObstacle
-    {
-    public:
-        float width;  // width  of rectangle centered on local X (side) axis
-        float height; // height of rectangle centered on local Y (up)   axis
-
-        // constructors
-        RectangleObstacle (float w, float h) : width(w), height(h) {}
-        RectangleObstacle (void) :  width(1.0f), height(1.0f) {}
-        RectangleObstacle (float w, float h, const Vector3& s,
-                           const Vector3& u, const Vector3& f, const Vector3& p,
-                           seenFromState sf) 
-            : PlaneObstacle( s, u, f, p ), width(w), height(h)
-        {
-            /*
-            setSide (s);
-            setUp (u);
-            setForward (f);
-            setPosition (p);
-             */
-            setSeenFrom (sf);
-        }
-        
-        virtual ~RectangleObstacle() { /* Nothing to do. */ }
-
-        // determines if a given point on XY plane is inside obstacle shape
-        bool xyPointInsideShape (const Vector3& point, float radius) const;
-    };
-
-
-} // namespace OpenSteer
-    
-    
-// ----------------------------------------------------------------------------
-#endif // OPENSTEER_OBSTACLE_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/Obstacle.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/Obstacle.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/Path.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Path.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/Path.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,106 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original authors: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * Abstract interface for paths.
- */
-#ifndef OPENSTEER_PATH_H
-#define OPENSTEER_PATH_H
-
-
-#include "OpenSteer/Vec3.h"
-
-
-namespace OpenSteer {
-
-    
-    /**
-     * Path in space that might be cyclic.
-     *
-     * Paths are infinitesimal thin.
-     */
-    class Path {
-    public:
-        
-        
-        virtual ~Path() = 0;
-        
-        
-        /**
-         * Returns @c true if the path is valid, @c false otherwise.
-         */
-        virtual bool isValid() const = 0;
-        
-        /**
-         * Given an arbitrary point ("A"), returns the nearest point ("P") on
-		 * this path center line.  Also returns, via output arguments, the path
-         * tangent at P and a measure of how far A is outside the Pathway's 
-         * "tube".  Note that a negative distance indicates A is inside the 
-         * Pathway.
-         *
-         * If @c isValid is @c false the behavior is undefined.
-         */
-		virtual Vector3 mapPointToPath (const Vector3& point,
-                                     Vector3& tangent,
-                                     float& outside) const = 0;
-        
-		/**
-         * Given a distance along the path, convert it to a point on the path.
-         * If @c isValid is @c false the behavior is undefined.
-         */
-		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const = 0;
-        
-		/**
-         * Given an arbitrary point, convert it to a distance along the path.
-         * If @c isValid is @c false the behavior is undefined.
-         */
-		virtual float mapPointToPathDistance (const Vector3& point) const = 0;
-        
-        /**
-         * Returns @c true f the path is closed, otherwise @c false.
-         */
-        virtual bool isCyclic() const = 0;
-        
-        /**
-         * Returns the length of the path.
-         */
-        virtual float length() const = 0;
-        
-    protected:
-        /**
-         * Protected to disable assigning instances of different inherited 
-         * classes to each other.
-         *
-         * @todo Should this be added or not? Have to read a bit...
-         */
-        // Path& operator=( Path const& );
-        
-    }; // class Path
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_PATH_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/Path.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/Path.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/Pathway.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Pathway.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/Pathway.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,100 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * Abstract base class for pathways - paths with associated radii.
- */
-#ifndef OPENSTEER_PATHWAY_H
-#define OPENSTEER_PATHWAY_H
-
-#include "OpenSteer/Vec3.h"
-
-namespace OpenSteer {
-    
-    
-    /**
-     * Pure virtual base class representing an abstract pathway in space.
-     * Could be used for example in path following.
-     */
-    class Pathway {
-    public:
-        virtual ~Pathway() = 0;
-        
-        /**
-         * Returns @c true if the path is valid, @c false otherwise.
-         */
-        virtual bool isValid() const = 0;
-        
-        /**
-         * Given an arbitrary point ("A"), returns the nearest point ("P") on
-		 * this path center line.  Also returns, via output arguments, the path
-         * tangent at P and a measure of how far A is outside the Pathway's 
-         * "tube".  Note that a negative distance indicates A is inside the 
-         * Pathway.
-         *
-         * If @c isValid is @c false the behavior is undefined.
-         */
-		virtual Vector3 mapPointToPath (const Vector3& point,
-                                     Vector3& tangent,
-                                     float& outside) const = 0;
-        
-		/**
-         * Given a distance along the path, convert it to a point on the path.
-         * If @c isValid is @c false the behavior is undefined.
-         */
-		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const = 0;
-        
-		/**
-         * Given an arbitrary point, convert it to a distance along the path.
-         * If @c isValid is @c false the behavior is undefined.
-         */
-		virtual float mapPointToPathDistance (const Vector3& point) const = 0;
-        
-        /**
-         * Returns @c true f the path is closed, otherwise @c false.
-         */
-        virtual bool isCyclic() const = 0;
-        
-        /**
-         * Returns the length of the path.
-         */
-        virtual float length() const = 0;
-        
-    protected:
-        /**
-         * Protected to disable assigning instances of different inherited 
-         * classes to each other.
-         *
-         * @todo Should this be added or not? Have to read a bit...
-         */
-        // Pathway& operator=( Pathway const& );    
-        
-    }; // class Pathway
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_PATHWAY_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/Pathway.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/Pathway.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPath.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/PolylineSegmentedPath.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPath.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,234 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * @author Bjoern Knafla <bknafla at uni-kassel.de>
- *
- * Segmented path build of polylines.
- */
-#ifndef OPENSTEER_POLYLINESEGMENTEDPATH_H
-#define OPENSTEER_POLYLINESEGMENTEDPATH_H
-
-// Include std::vector
-#include <vector>
-
-
-
-// Include OpenSteer::SegmentedPath
-#include "OpenSteer/SegmentedPath.h"
-
-// Include OpenSteer::PointToPathAlikeBaseDataExtractionPolicy
-#include "OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h"
-
-// Include Vector3
-#include "OpenSteer/Vec3.h"
-
-// Include OpenSteer::distance
-#include "OpenSteer/Vec3Utilities.h"
-
-
-
-namespace OpenSteer {
-    
-    
-    /**
-     * Segmented path build by polylines. The last point of the path might be 
-     * connected to the first point building a closed cycle.
-     *
-     * 
-     */
-    class PolylineSegmentedPath : public SegmentedPath {
-    public:
-        typedef std::vector< Vector3 > PathPoints;
-        /**
-         * Constructs an invalid path. Behavior of most member functions is
-         * undefined if a path has less than two distinct points.
-         */
-        PolylineSegmentedPath();
-        
-        /**
-         * Constructs a new path.
-         *
-         * @param numOfPoints Number of points. Must be at least two.
-         * @param newPoints As many points as indicated by @a numOfPoints. Two
-         *                  adjacent points mustn't be identical and the first
-         *                  the last point mustn't be identical.
-         * @param closedCycle If @c true the first point of @a newPoints is
-         *                    copied to the end of the path to represent the 
-         *                    cycle closing segment.
-         */
-        PolylineSegmentedPath( size_type numOfPoints,
-                               Vector3 const newPoints[],
-                               bool closedCycle );
-
-        PolylineSegmentedPath( const PathPoints& newPoints,
-                               bool closedCycle );
-        
-        PolylineSegmentedPath( PolylineSegmentedPath const& other );
-        
-        virtual ~PolylineSegmentedPath();
-        
-        PolylineSegmentedPath& operator=( PolylineSegmentedPath other );
-        
-        void swap( PolylineSegmentedPath& other );
-        
-        
-        /**
-         * Replaces all path information by the given ones.
-         *
-         * @param numOfPoints Number of points. Must be at least two.
-         * @param newPoints As many points as indicated by @a numOfPoints. Two
-         *                  adjacent points mustn't be identical and the first
-         *                  the last point mustn't be identical.
-         * @param closedCycle If @c true the first point of @a newPoints is
-         *                    copied to the end of the path to represent the 
-         *                    cycle closing segment.
-         */
-        void setPath( size_type numOfPoints,
-                      Vector3 const newPoints[],
-                      bool closedCycle );
-
-        void setPath( const PathPoints& newPoints, bool closedCycle);
-        /**
-         * Replaces @a numOfPoints points starting at @a startIndex.
-         *
-         * In the resulting sequence of points there mustn't be two adjacent 
-         * ones that are equal. The first and last point mustn't be identical,
-         * too.
-         *
-         * If the first point is changed and the path is cyclic the duplication
-         * of the first point at the end of the sequence representing the
-         * path closing segment is updated automatically.
-         *
-         * @param startIndex First point to be moved or replaced.
-         * @param numOfPoints Number of points to move or replace. 
-         *                    <code> numOfPoints + startIndex </code> must be
-         *                    lesser or equal to @c pointCount.
-         * @param newPoints Moved points to replace the old ones.
-         */
-        void movePoints( size_type startIndex,
-                         size_type numOfPoints,
-                         Vector3 const newPoints[]);
-        
-        
-        
-        virtual bool isValid() const;
-        virtual Vector3 mapPointToPath (const Vector3& point,
-                                     Vector3& tangent,
-                                     float& outside) const;
-		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const;
-		virtual float mapPointToPathDistance (const Vector3& point) const;
-        virtual bool isCyclic() const;
-        virtual float length() const;
-        
-        
-        virtual size_type pointCount() const;
-        virtual Vector3 point( size_type pointIndex ) const;        
-        
-        
-        virtual size_type segmentCount() const;
-        virtual float segmentLength( size_type segmentIndex ) const;
-        virtual Vector3 segmentStart( size_type segmentIndex ) const;
-        virtual Vector3 segmentEnd( size_type segmentIndex ) const;
-        virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vector3 const& point ) const;
-        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
-                                                float segmentDistance ) const;
-        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
-                                                  float segmentDistance ) const;
-        
-        virtual void mapDistanceToSegmentPointAndTangent( size_type segmentIndex,
-                                                          float distance,
-                                                          Vector3& pointOnPath,
-                                                          Vector3& tangent ) const;
-        
-        virtual void mapPointToSegmentDistanceAndPointAndTangent( size_type segmentIndex,
-                                                                  Vector3 const& point,
-                                                                  float& distance,
-                                                                  Vector3& pointOnPath,
-                                                                  Vector3& tangent ) const;
-        
-    private:
-        std::vector< Vector3 > points_;
-        std::vector< Vector3 > segmentTangents_;
-        std::vector< float > segmentLengths_;
-        bool closedCycle_;
-    }; // class PolylineSegmentedPath
-    
-    
-    /**
-     * Swaps the content of @a lhs and @a rhs.
-     */
-    inline void swap( PolylineSegmentedPath& lhs, PolylineSegmentedPath& rhs ) {
-        lhs.swap( rhs );
-    }
-    
-    
-    /**
-     * Extracts the base data of @c PolylineSegmentedPath.
-     */
-    template<>
-    class PointToPathAlikeBaseDataExtractionPolicy< PolylineSegmentedPath > {
-    public:
-        
-        static void extract( PolylineSegmentedPath const& pathAlike,
-                             PolylineSegmentedPath::size_type segmentIndex,
-                             Vector3 const& point, 
-                             float& segmentDistance, 
-                             float&, 
-                             float& distancePointToPath, 
-                             Vector3& pointOnPathCenterLine, 
-                             Vector3& tangent ) {
-            pathAlike.mapPointToSegmentDistanceAndPointAndTangent( segmentIndex, point, segmentDistance, pointOnPathCenterLine, tangent );
-            distancePointToPath = distance( point, pointOnPathCenterLine );
-        }
-        
-    }; // class PointToPathAlikeBaseDataExtractionPolicy
-    
-    /**
-     * Extracts the base data of @c PolylineSegmentedPath.
-     */
-    template<>
-    class DistanceToPathAlikeBaseDataExtractionPolicy< PolylineSegmentedPath > {
-    public:
-        static void extract( PolylineSegmentedPath const& pathAlike,
-                             PolylineSegmentedPath::size_type segmentIndex,
-                             float segmentDistance, 
-                             Vector3& pointOnPathCenterLine, 
-                             Vector3& tangent, 
-                             float&  )  {
-            pathAlike.mapDistanceToSegmentPointAndTangent( segmentIndex, segmentDistance, pointOnPathCenterLine, tangent );     
-        }
-        
-        
-    }; // DistanceToPathAlikeBaseDataExtractionPolicy
-    
-    
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_POLYLINESEGMENTEDPATH_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPath.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/PolylineSegmentedPath.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,228 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * @author Bjoern Knafla <bknafla at uni-kassel.de>
- *
- * Segmented pathway build of polylines. The whole path has one associated 
- * radius.
- */
-#ifndef OPENSTEER_POLYLINESEGMENTEDPATHWAYSINGLERADIUS_H
-#define OPENSTEER_POLYLINESEGMENTEDPATHWAYSINGLERADIUS_H
-
-// Include OpenSteer::SegmentedPathway
-#include "OpenSteer/SegmentedPathway.h"
-
-// Include OpenSteer::PolylineSegmentedPath
-#include "OpenSteer/PolylineSegmentedPath.h"
-
-// Include OpenSteer::PointToPathAlikeBaseDataExtractionPolicy
-#include "OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h"
-
-// Include Vector3
-#include "OpenSteer/Vec3.h"
-
-// Include OpenSteer::distance
-#include "OpenSteer/Vec3Utilities.h"
-
-
-
-namespace OpenSteer {
-    
-    /**
-     * Segmented pathway build by polylines with a single radius for the whole
-     * pathway.
-     */
-    class PolylineSegmentedPathwaySingleRadius : public SegmentedPathway {
-    public:
-        PolylineSegmentedPathwaySingleRadius();
-        explicit PolylineSegmentedPathwaySingleRadius( float r );
-        PolylineSegmentedPathwaySingleRadius( size_type numOfPoints,
-                                              Vector3 const points[],
-                                              float r,
-                                              bool closeCycle );
-        PolylineSegmentedPathwaySingleRadius( const PolylineSegmentedPath::PathPoints& points,
-                                              float r,
-                                              bool closeCycle );
-        PolylineSegmentedPathwaySingleRadius( PolylineSegmentedPathwaySingleRadius const& other );
-        virtual ~PolylineSegmentedPathwaySingleRadius();
-        PolylineSegmentedPathwaySingleRadius& operator=( PolylineSegmentedPathwaySingleRadius other );
-        
-        /**
-         * Swaps the content with @a other.
-         */
-        void swap( PolylineSegmentedPathwaySingleRadius& other );
-        
-        /**
-         * Replaces @a numOfPoints points starting at @a startIndex.
-         *
-         * In the resulting sequence of points there mustn't be two adjacent 
-         * ones that are equal. The first and last point mustn't be identical,
-         * too.
-         *
-         * If the first point is changed and the path is cyclic the duplication
-         * of the first point at the end of the sequence representing the
-         * path closing segment is updated automatically.
-         *
-         * @param startIndex First point to be moved or replaced.
-         * @param numOfPoints Number of points to move or replace. 
-         *                    <code> numOfPoints + startIndex </code> must be
-         *                    lesser or equal to @c pointCount.
-         * @param newPointValues Moved points to replace the old ones.
-         */
-        void movePoints( size_type startIndex,
-                         size_type numOfPoints,
-                         Vector3 const newPointValues[] );
-        /**
-         * Replaces the pathway information completely.
-         *
-         * If @a closedCycle is @c true then the pathway has @a numOfPoints
-         * segments and the first point is duplicated and added as the last
-         * point to represent the end point of the segment closing the pathway
-         * cycle. If @a closedCycle is false the pathway has 
-         * <code>numOfPoints - 1</code> segments.
-         *
-         * @param numOfPoints Number of points defining the pathway.
-         * @param points The actual points.
-         * @param r Radius of the whole pathway.
-         * @param closedCycle @c true if the pathway is cyclic, @a false 
-         *        otherwise.
-         */
-        void setPathway( size_type numOfPoints,
-                         Vector3 const points[],
-                         float r,
-                         bool closedCycle );
-        
-        /**
-         * Sets the radius of the whole pathway to @a r.
-         */
-        void setRadius( float r );
-        
-        /**
-         * Returns the pathway radius.
-         */
-        float radius() const;
-        
-        
-        virtual bool isValid() const;
-		virtual Vector3 mapPointToPath (const Vector3& point,
-                                     Vector3& tangent,
-                                     float& outside) const;
-		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const;
-		virtual float mapPointToPathDistance (const Vector3& point) const;
-        virtual bool isCyclic() const;
-        virtual float length() const;
-        
-        
-        virtual size_type pointCount() const;
-        virtual Vector3 point( size_type pointIndex ) const;
-        
-        
-        virtual size_type segmentCount() const;
-        virtual float segmentLength( size_type segmentIndex ) const;
-        virtual Vector3 segmentStart( size_type segmentIndex ) const;
-        virtual Vector3 segmentEnd( size_type segmentIndex ) const;
-        virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vector3 const& point ) const;
-        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
-                                                float segmentDistance ) const;
-        virtual float mapSegmentDistanceToRadius( size_type segmentIndex, 
-                                                 float distanceOnSegment ) const;
-        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
-                                                  float segmentDistance ) const;
-        
-        virtual void mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
-                                                                   float segmentDistance,
-                                                                   Vector3& pointOnPath,
-                                                                   Vector3& tangent,
-                                                                   float& radius ) const;
-        
-        virtual void mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
-                                                                           Vector3 const& point,
-                                                                           float& distance,
-                                                                           Vector3& pointOnPath,
-                                                                           Vector3& tangent,
-                                                                           float& radius) const;
-         
-    private:
-        PolylineSegmentedPath path_;
-        float radius_;
-    }; // class PolylineSegmentedPathwaySingleRadius
-    
-    
-    /**
-     * Swaps the content of @a lhs and @a rhs.
-     */
-    inline void swap( PolylineSegmentedPathwaySingleRadius& lhs, 
-               PolylineSegmentedPathwaySingleRadius& rhs ) {
-        lhs.swap( rhs );
-    }
-    
-    
-    /**
-     * Extracts the base data of @c PolylineSegmentedPathwaySingleRadius.
-     */
-    template<>
-    class PointToPathAlikeBaseDataExtractionPolicy< PolylineSegmentedPathwaySingleRadius > {
-    public:
-            
-        static void extract( PolylineSegmentedPathwaySingleRadius const& pathAlike,
-                             PolylineSegmentedPathwaySingleRadius::size_type segmentIndex,
-                             Vector3 const& point, 
-                             float& segmentDistance, 
-                             float& radius, 
-                             float& distancePointToPath, 
-                             Vector3& pointOnPathCenterLine, 
-                             Vector3& tangent ) {
-            pathAlike.mapPointToSegmentDistanceAndPointAndTangentAndRadius( segmentIndex, point, segmentDistance, pointOnPathCenterLine, tangent, radius );
-            distancePointToPath = distance( point, pointOnPathCenterLine ) - radius;
-        }
-            
-    }; // class PointToPathAlikeBaseDataExtractionPolicy
-    
-    
-    /**
-     * Extracts the base data of @c PolylineSegmentedPathwaySingleRadius.
-     */
-    template<>
-    class DistanceToPathAlikeBaseDataExtractionPolicy< PolylineSegmentedPathwaySingleRadius > {
-    public:
-        static void extract( PolylineSegmentedPathwaySingleRadius const& pathAlike,
-                             PolylineSegmentedPathwaySingleRadius::size_type segmentIndex,
-                             float segmentDistance, 
-                             Vector3& pointOnPathCenterLine, 
-                             Vector3& tangent, 
-                             float& radius )  {
-            pathAlike.mapDistanceToSegmentPointAndTangentAndRadius( segmentIndex, segmentDistance, pointOnPathCenterLine, tangent, radius );     
-        }
-        
-        
-    }; // DistanceToPathAlikeBaseDataExtractionPolicy 
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_POLYLINESEGMENTEDPATHWAYSINGLERADIUS_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/Proximity.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Proximity.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/Proximity.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,337 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// Proximity 
-//
-// Data structures for accelerating proximity/locality/neighborhood queries
-//
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 06-20-01 cwr: created
-//
-//
-// ----------------------------------------------------------------------------
-
-
-#ifndef OPENSTEER_PROXIMITY_H
-#define OPENSTEER_PROXIMITY_H
-
-
-#include <algorithm>
-#include <vector>
-#include "OpenSteer/Vec3.h"
-#include "OpenSteer/lq.h"   // XXX temp?
-
-
-namespace OpenSteer {
-
-
-    // ----------------------------------------------------------------------------
-    // "tokens" are the objects manipulated by the spatial database
-
-
-    template <class ContentType>
-    class AbstractTokenForProximityDatabase
-    {
-    public:
-
-        virtual ~AbstractTokenForProximityDatabase () {}
-
-        // the client object calls this each time its position changes
-        virtual void updateForNewPosition (const Vector3& position) = 0;
-
-        // find all neighbors within the given sphere (as center and radius)
-        virtual void findNeighbors (const Vector3& center,
-                                    const float radius,
-                                    std::vector<ContentType>& results) = 0;
-
-#ifndef NO_LQ_BIN_STATS
-        // only meaningful for LQProximityDatabase, provide dummy default
-        virtual void getBinPopulationStats (int& min, int& max, float& average)
-        {min=max=0; average=0.0;}
-#endif // NO_LQ_BIN_STATS
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // abstract type for all kinds of proximity databases
-
-
-    template <class ContentType>
-    class AbstractProximityDatabase
-    {
-    public:
-
-        // type for the "tokens" manipulated by this spatial database
-        typedef AbstractTokenForProximityDatabase<ContentType> tokenType;
-
-        
-        virtual ~AbstractProximityDatabase() { /* Nothing to do? */ }
-        
-        // allocate a token to represent a given client object in this database
-        virtual tokenType* allocateToken (ContentType parentObject) = 0;
-
-        // insert
-        // XXX maybe this should return an iterator?
-        // XXX see http://www.sgi.com/tech/stl/set.html
-        // virtual void insert (const ContentType& x) = 0;
-
-        // XXX name?
-        // returns the number of tokens in the proximity database
-        virtual int getPopulation (void) = 0;
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // This is the "brute force" O(n^2) approach implemented in terms of the
-    // AbstractProximityDatabase protocol so it can be compared directly to other
-    // approaches.  (e.g. the Boids plugin allows switching at runtime.)
-
-
-    template <class ContentType>
-    class BruteForceProximityDatabase
-        : public AbstractProximityDatabase<ContentType>
-    {
-    public:
-
-        // constructor
-        BruteForceProximityDatabase (void)
-        {
-        }
-
-        // destructor
-        virtual ~BruteForceProximityDatabase ()
-        {
-        }
-
-        // "token" to represent objects stored in the database
-        class tokenType : public AbstractTokenForProximityDatabase<ContentType>
-        {
-        public:
-
-            // constructor
-            tokenType (ContentType parentObject, BruteForceProximityDatabase& pd)
-            {
-                // store pointer to our associated database and the object this
-                // token represents, and store this token on the database's vector
-                bfpd = &pd;
-                object = parentObject;
-                bfpd->group.push_back (this);
-            }
-
-            // destructor
-            virtual ~tokenType ()
-            {
-                // remove this token from the database's vector
-                bfpd->group.erase (std::find (bfpd->group.begin(),
-                                              bfpd->group.end(),
-                                              this));
-            }
-
-            // the client object calls this each time its position changes
-            void updateForNewPosition (const Vector3& newPosition)
-            {
-                position = newPosition;
-            }
-
-            // find all neighbors within the given sphere (as center and radius)
-            void findNeighbors (const Vector3& center,
-                                const float radius,
-                                std::vector<ContentType>& results)
-            {
-                // loop over all tokens
-                const float r2 = radius * radius;
-                for (tokenIterator i = bfpd->group.begin();
-                     i != bfpd->group.end();
-                     i++)
-                {
-                    const Vector3 offset = center - (**i).position;
-                    const float d2 = offset.squaredLength();
-
-                    // push onto result vector when within given radius
-                    if (d2 < r2) results.push_back ((**i).object);
-                }
-            }
-
-        private:
-            BruteForceProximityDatabase* bfpd;
-            ContentType object;
-            Vector3 position;
-        };
-
-        typedef std::vector<tokenType*> tokenVector;
-        typedef typename tokenVector::const_iterator tokenIterator;    
-
-        // allocate a token to represent a given client object in this database
-        tokenType* allocateToken (ContentType parentObject)
-        {
-            return new tokenType (parentObject, *this);
-        }
-
-        // return the number of tokens currently in the database
-        int getPopulation (void)
-        {
-            return (int) group.size();
-        }
-        
-    private:
-        // STL vector containing all tokens in database
-        tokenVector group;
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // A AbstractProximityDatabase-style wrapper for the LQ bin lattice system
-
-
-    template <class ContentType>
-    class LQProximityDatabase : public AbstractProximityDatabase<ContentType>
-    {
-    public:
-
-        // constructor
-        LQProximityDatabase (const Vector3& center,
-                             const Vector3& dimensions,
-                             const Vector3& divisions)
-        {
-            const Vector3 halfsize (dimensions * 0.5f);
-            const Vector3 origin (center - halfsize);
-
-            lq = lqCreateDatabase (origin.x, origin.y, origin.z, 
-                                   dimensions.x, dimensions.y, dimensions.z,  
-                                   (int) round (divisions.x),
-                                   (int) round (divisions.y),
-                                   (int) round (divisions.z));
-        }
-
-        // destructor
-        virtual ~LQProximityDatabase ()
-        {
-            lqDeleteDatabase (lq);
-            lq = NULL;
-        }
-
-        // "token" to represent objects stored in the database
-        class tokenType : public AbstractTokenForProximityDatabase<ContentType>
-        {
-        public:
-
-            // constructor
-            tokenType (ContentType parentObject, LQProximityDatabase& lqsd)
-            {
-                lqInitClientProxy (&proxy, parentObject);
-                lq = lqsd.lq;
-            }
-
-            // destructor
-            virtual ~tokenType (void)
-            {
-                lqRemoveFromBin (&proxy);
-            }
-
-            // the client object calls this each time its position changes
-            void updateForNewPosition (const Vector3& p)
-            {
-                lqUpdateForNewLocation (lq, &proxy, p.x, p.y, p.z);
-            }
-
-            // find all neighbors within the given sphere (as center and radius)
-            void findNeighbors (const Vector3& center,
-                                const float radius,
-                                std::vector<ContentType>& results)
-            {
-                lqMapOverAllObjectsInLocality (lq, 
-                                               center.x, center.y, center.z,
-                                               radius,
-                                               perNeighborCallBackFunction,
-                                               (void*)&results);
-            }
-
-            // called by LQ for each clientObject in the specified neighborhood:
-            // push that clientObject onto the ContentType vector in void*
-            // clientQueryState
-            // (parameter names commented out to prevent compiler warning from "-W")
-            static void perNeighborCallBackFunction  (void* clientObject,
-                                                      float /*distanceSquared*/,
-                                                      void* clientQueryState)
-            {
-                typedef std::vector<ContentType> ctv;
-                ctv& results = *((ctv*) clientQueryState);
-                results.push_back ((ContentType) clientObject);
-            }
-
-#ifndef NO_LQ_BIN_STATS
-            // Get statistics about bin populations: min, max and
-            // average of non-empty bins.
-            void getBinPopulationStats (int& min, int& max, float& average)
-            {
-                lqGetBinPopulationStats (lq, &min, &max, &average);
-            }
-#endif // NO_LQ_BIN_STATS
-
-        private:
-            lqClientProxy proxy;
-            lqDB* lq;
-        };
-
-
-        // allocate a token to represent a given client object in this database
-        tokenType* allocateToken (ContentType parentObject)
-        {
-            return new tokenType (parentObject, *this);
-        }
-
-        // count the number of tokens currently in the database
-        int getPopulation (void)
-        {
-            int count = 0;
-            lqMapOverAllObjects (lq, counterCallBackFunction, &count);
-            return count;
-        }
-        
-        // (parameter names commented out to prevent compiler warning from "-W")
-        static void counterCallBackFunction  (void* /*clientObject*/,
-                                              float /*distanceSquared*/,
-                                              void* clientQueryState)
-        {
-            int& counter = *(int*)clientQueryState;
-            counter++;
-        }
-
-
-    private:
-        lqDB* lq;
-    };
-
-} // namespace OpenSteer
-
-
-
-// ----------------------------------------------------------------------------
-#endif // OPENSTEER_PROXIMITY_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/Proximity.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/Proximity.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlike.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/QueryPathAlike.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlike.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,229 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * @author Bjoern Knafla <bknafla at uni-kassel.de>
- *
- * Functionality to map points or distances to path alikes and to extract
- * the assocaited information.
- */
-#ifndef OPENSTEER_QUERYPATHALIKE_H
-#define OPENSTEER_QUERYPATHALIKE_H
-
-
-// Include std::numeric_limits< float >::max
-#include <limits>
-
-
-
-// Include Vector3
-#include "OpenSteer/Vec3.h"
-
-// Include OpenSteer::distance
-#include "OpenSteer/Vec3Utilities.h"
-
-// Include OpenSteer::clamp, OpenSteer::modulo
-#include "OpenSteer/Utilities.h"
-
-// Include OpenSteer::PointToPathAlikeBaseDataExtractionPolicy, OpenSteer::DistanceToPathAlikeBaseDataExtractionPolicy
-#include "OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h"
-
-#ifdef _MSC_VER
-#undef min
-#undef max
-#endif
-
-
-namespace OpenSteer {
-
-    /**
-     * Provides functionality to map points or distances to path alikes and
-     * to extract associated information.
-     */
-    template< class PathAlike, class Mapping, class BaseDataExtractionPolicy = PointToPathAlikeBaseDataExtractionPolicy< PathAlike > >
-    class PointToPathAlikeMapping {
-    public:
-        
-        /**
-         * Maps @a queryPoint to a path alike @a pathAlike and returns the  
-         * queried data in @a mapping.
-         *
-         * @c Mapping must provide the following member functions to
-         * set queried values. Member functions might be empty if the specific 
-         * data isn't needed. A good compiler should optimize the
-         * empty member function calls and the associated calculations for its
-         * parameters away.
-         *
-         * <code> void setPointOnPathCenterLine( Vector3 const& ) </code>
-         * <code> void setPointOnPathBoundary( Vector3 const& ) </code>
-         * <code> void setRadius( float ) </code>
-         * <code> void setTangent( Vector3 const& ) </code>
-         * <code> void setSegmentIndex( typename SegmentedPathAlike::size_type ) </code>
-         * <code> void setDistancePointToPath( float ) </code>
-         * <code> void setDistancePointToPathCenterLine( float ) </code>
-         * <code> void setDistanceOnPath( float ) </code>
-         * <code> void setDistanceOnSegment( float ) </code>
-         *
-         * To query for the distance on the path the two following member functions
-         * of @c Mapping must be provided too:
-         *
-         * <code> void setDistanceOnPathFlag( float ) </code> and
-         * <code> float distanceOnPathFlag() const </code>.
-         *
-         * If the distance along the path shouldn't be extracted empty 
-         * versions of these member functions are possible.
-         *
-         * @c QueryPathAlikeUtilities.h provides some base classes to inherit
-         * from to automatically get some of the functionality described above.
-         */
-        static void map( PathAlike const& pathAlike, Vector3 const& queryPoint, Mapping& mapping ) {
-            float minDistancePointToPath = std::numeric_limits< float >::max();
-            mapping.setDistanceOnPathFlag( 0.0f );
-            
-            typedef typename PathAlike::size_type size_type;
-            size_type const segmentCount = pathAlike.segmentCount();
-            for ( size_type segmentIndex = 0; segmentIndex < segmentCount; ++segmentIndex ) {
-                
-                float segmentDistance = 0.0f;
-                float radius = 0.0f;
-                float distancePointToPath = 0.0f;
-                Vector3 pointOnPathCenterLine( 0.0f, 0.0f, 0.0f );
-                Vector3 tangent( 0.0f, 0.0f, 0.0f );
-                
-                BaseDataExtractionPolicy::extract( pathAlike, segmentIndex, queryPoint, segmentDistance, radius, distancePointToPath, pointOnPathCenterLine, tangent );
-                
-                if ( distancePointToPath < minDistancePointToPath ) {
-                    minDistancePointToPath = distancePointToPath;
-                    mapping.setPointOnPathCenterLine( pointOnPathCenterLine );
-                    mapping.setPointOnPathBoundary( pointOnPathCenterLine + ( ( queryPoint - pointOnPathCenterLine ).normalisedCopy() * radius ) );
-                    mapping.setRadius( radius );
-                    mapping.setTangent( tangent );
-                    mapping.setSegmentIndex( segmentIndex );
-                    mapping.setDistancePointToPath( distancePointToPath );
-                    mapping.setDistancePointToPathCenterLine( distancePointToPath + radius );
-                    mapping.setDistanceOnPath( mapping.distanceOnPathFlag() + segmentDistance );
-                    mapping.setDistanceOnSegment( segmentDistance );
-                }
-                
-                mapping.setDistanceOnPathFlag( mapping.distanceOnPathFlag() + pathAlike.segmentLength( segmentIndex ) );
-            }
-        }
-        
-    }; // class PointToPathAlikeMapping
-    
-    /**
-     * Maps @a point to @a pathAlike and returns the data extracted in 
-     * @a mapping.
-     *
-     * See @c MapPointToPathAlike::map for further information.
-     */
-    template< class PathAlike, class Mapping >
-    void mapPointToPathAlike( PathAlike const& pathAlike, Vector3 const& point, Mapping& mapping ) {
-        PointToPathAlikeMapping< PathAlike, Mapping >::map( pathAlike, point, mapping );
-    }
-    
-        
-    
-    /**
-     * Provides functionality to map distances to path alikes and to extract
-     * the associated data.
-     */
-    template< class PathAlike, class Mapping, class BaseDataExtractionPolicy = DistanceToPathAlikeBaseDataExtractionPolicy< PathAlike > > 
-    class DistanceToPathAlikeMapping {
-    public:
-    
-        /**
-         * Maps @a distanceOnPath to a path alike @a pathAlike and returns the 
-         * queried data in @a mapping.
-         *
-         * @c Mapping must provide the following member functions 
-         * to set queried values. Member functions might be empty if the  
-         * specific data isn't needed. A good compiler should optimize the
-         * empty member function calls and the associated calculations for its
-         * parameters away.
-         *
-         * <code> void setPointOnPathCenterLine( Vector3 const& ) </code>
-         * <code> void setRadius( float ) </code>
-         * <code> void setTangent( Vector3 const& ) </code>
-         * <code> void setSegmentIndex( typename SegmentedPathAlike::size_type ) </code>
-         * <code> void setDistanceOnPath( float ) </code>
-         * <code> void setDistanceOnSegment( float ) </code>
-         */
-        static void map( PathAlike const& pathAlike, float distanceOnPath, Mapping& mapping ) {
-            float const pathLength = pathAlike.length();
-            
-            // Modify @c distanceOnPath to applicable values.
-            if ( pathAlike.isCyclic() ) {
-                distanceOnPath = modulo( distanceOnPath, pathLength );       
-            }
-            distanceOnPath = clamp( distanceOnPath, 0.0f, pathLength );
-            
-            // Which path alike segment is reached by @c distanceOnPath?
-            float remainingDistance = distanceOnPath;
-            typedef typename PathAlike::size_type size_type;
-            size_type segmentIndex = 0;        
-            size_type const maxSegmentIndex = pathAlike.segmentCount() - 1;
-            while( ( segmentIndex < maxSegmentIndex ) && 
-                   ( remainingDistance > pathAlike.segmentLength( segmentIndex ) ) ) {
-                remainingDistance -= pathAlike.segmentLength( segmentIndex );
-                ++segmentIndex;
-            }
-            
-            // Extract the path related data associated with the segment reached
-            // by @c distanceOnPath.
-            Vector3 pointOnPathCenterLine( 0.0f, 0.0f, 0.0f );
-            Vector3 tangent( 0.0f, 0.0f, 0.0f );
-            float radius = 0.0f;
-            BaseDataExtractionPolicy::extract( pathAlike, segmentIndex, remainingDistance, pointOnPathCenterLine, tangent, radius );
-            
-            // Store the extracted data in @c mapping to return it to the caller.
-            mapping.setPointOnPathCenterLine( pointOnPathCenterLine );
-            mapping.setRadius( radius );
-            mapping.setTangent( tangent );
-            mapping.setSegmentIndex( segmentIndex );
-            mapping.setDistanceOnPath( distanceOnPath );
-            mapping.setDistanceOnSegment( remainingDistance );            
-        }
-        
-    }; // class DistanceToPathAlikeMapping
-    
-    
-    
-    /**
-     * Maps @a distance to @a pathAlike and stores the data queried in
-     * @a mapping.
-     *
-     * See @c DistanceToPathAlikeMapping::map for further information.
-     */
-    template< class PathAlike, class Mapping >
-    void mapDistanceToPathAlike( PathAlike const& pathAlike, float distance, Mapping& mapping ) {
-        DistanceToPathAlikeMapping< PathAlike, Mapping >::map( pathAlike, distance, mapping );
-    }
-    
-    
-} // namespace OpenSteer
-
-#endif // OPENSTEER_QUERYPATHALIKE_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlike.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/QueryPathAlike.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,71 +0,0 @@
-/**
-* OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * @author Bjoern Knafla <bknafla at uni-kassel.de>
- *
- * Declarations of policies used by @c OpenSteer::mapPointToPathAlike and
- * @c OpenSteer::mapDistanceToPathAlike to extract informations of path alikes.
- */
-#ifndef OPENSTEER_QUERYPATHALIKEBASEDATAEXTRACTIONPOLICY_H
-#define OPENSTEER_QUERYPATHALIKEBASEDATAEXTRACTIONPOLICY_H
-
-namespace OpenSteer {
-    
-    /**
-     * Extracts the base data like the segment distance, the radius, the
-     * distance of the query point to the path alike, the point on the path
-     * alike center line and the tangent at that point.
-     *
-     * Specialize it for the path alike to use and provide a static member
-     * function with the following signature:
-     *
-     * <code>static void extract( PathAlike const& pathAlike, typename PathAlike::size_type segmentIndex, Vector3 const& point, float& segmentDistance, float& radius, float& distancePointToPath, Vector3& pointOnPathCenterLine, Vector3& tangent )</code>
-     *
-     * @attention Be aware of the references that are passed in.
-     */
-    template< class PathAlike >
-    class PointToPathAlikeBaseDataExtractionPolicy;
-    
-    
-    /**
-     * Extracts the base data like the radius, the point on the path
-     * alike center line and the tangent at that point.
-     *
-     * Specialize it for the path alike to use and provide a static member
-     * function with the following signature:
-     *
-     * <code>static void extract( PathAlike const& pathAlike, typename PathAlike::size_type segmentIndex, float segmentDistance, Vector3& pointOnPathCenterLine, Vector3& tangent, float& radius )</code>
-     *
-     * @attention Be aware of the references that are passed in.
-     */    
-    template< class PathAlike >
-    class DistanceToPathAlikeBaseDataExtractionPolicy;
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_QUERYPATHALIKEBASEDATAEXTRACTIONPOLICY_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,144 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * @author Bjoern Knafla <bknafla at uni-kassel.de>
- *
- * Predefined mappings used by @c OpenSteer::mapPointToPathAlike and 
- * @c OpenSteer::mapDistanceToPathAlike used by implementations of segmented
- * paths and pathways.
- */
-#ifndef OPENSTEER_QUERYPATHALIKEMAPPINGS_H
-#define OPENSTEER_QUERYPATHALIKEMAPPINGS_H
-
-
-// Include OpenSteer::HasNoRadius, OpenSteer::ExtractPathDistance, OpenSteer::DontExtractPathDistance
-#include "OpenSteer/QueryPathAlikeUtilities.h"
-
-// Include Vector3
-#include "OpenSteer/Vec3.h"
-
-// Include OpenSteer::size_t
-#include "OpenSteer/StandardTypes.h"
-
-
-
-namespace OpenSteer {
-    
-    /**
-     * Stores the point on a pathway boundary, the tangent at the associated
-     * path center line and the distance of a query point to the point on the 
-     * path boundary - used by @c OpenSteer::mapPointToPathAlike.
-     */
-    class PointToPathMapping 
-        : public DontExtractPathDistance {
-        
-    public:
-        PointToPathMapping() : pointOnPathCenterLine( 0.0f, 0.0f, 0.0f ), tangent( 0.0f, 0.0f, 0.0f ), distancePointToPath( 0.0f ) {}
-            
-        void setPointOnPathCenterLine( Vector3 const& point ) {
-            pointOnPathCenterLine = point;
-        }
-        void setPointOnPathBoundary( Vector3 const& ) {
-            // pointOnPathBoundary = point;
-        }
-        void setRadius( float ) {}
-        void setTangent( Vector3 const& t) {
-            tangent = t;
-        }
-        void setSegmentIndex( size_t ) {}
-        void setDistancePointToPath( float distance ) {
-            distancePointToPath = distance;
-        }
-        void setDistancePointToPathCenterLine( float ) {}
-        void setDistanceOnPath( float ) {}
-        void setDistanceOnSegment( float ) {}
-            
-        Vector3 pointOnPathCenterLine;
-        // Vector3 pointOnPathBoundary; 
-        Vector3 tangent;
-        float distancePointToPath;
-            
-            
-    }; // class PointToPathMapping
-    
-    
-    /**
-     * Stores the point on a path center line for a given distance from the
-     * start of the path - used by @c OpenSteer::mapDistanceToPathAlike.
-     */
-    class PathDistanceToPointMapping 
-        :  public DontExtractPathDistance {
-            
-    public:
-        
-        void setPointOnPathCenterLine( Vector3 const& vec ){
-            pointOnPathCenterLine = vec;
-        }
-        void setRadius( float ) {}
-        void setTangent( Vector3 const& ){}
-        void setSegmentIndex( size_t ){}
-        void setDistanceOnPath( float ){}
-        void setDistanceOnSegment( float ){}
-            
-            
-        Vector3 pointOnPathCenterLine; 
-            
-            
-    }; // class PathDistanceToPointMapping
-    
-    
-    
-    /**
-     * Stores the distance of from the start of a path to a point on the 
-     * center line of the path - used by @c OpenSteer::mapPointToPathAlike.
-     */
-    class PointToPathDistanceMapping
-        : public ExtractPathDistance {
-    public:
-        PointToPathDistanceMapping() : distanceOnPath( 0.0f ) {}
-            
-        void setPointOnPathCenterLine( Vector3 const& ) {}
-        void setPointOnPathBoundary( Vector3 const&  ) {}
-        void setRadius( float ) {}
-        void setTangent( Vector3 const& ) {}
-        void setSegmentIndex( size_t ) {}
-        void setDistancePointToPath( float  ) {}
-        void setDistancePointToPathCenterLine( float ) {}
-        void setDistanceOnPath( float distance ) {
-            distanceOnPath = distance;
-        }
-        void setDistanceOnSegment( float ) {}
-            
-        float distanceOnPath;
-    }; // class PointToPathDistanceMapping
-    
-    
-} // namespace OpenSteer
-
-
-
-#endif // OPENSTEER_QUERYPATHALIKEMAPPINGS_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,102 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * @author Bjoern Knafla <bknafla at uni-kassel.de>
- *
- * Collection of helper classes to inherit from to create mappings as used by  
- * @c OpenSteer::mapDistanceToPathAlike and 
- * @c OpenSteer::mapPointToPathAlike.
- */
-
-#ifndef OPENSTEER_QUERYPATHALIKEUTILITIES_H
-#define OPENSTEER_QUERYPATHALIKEUTILITIES_H
-
-
-namespace OpenSteer {
-
-    /**
-     * Inherit from it to create a mapping class used by 
-     * @c OpenSteer::mapDistanceToPathAlike and 
-     * @c OpenSteer::mapPointToPathAlike that calculates and extracts the
-     * distance along the path alike.
-     */    
-    class ExtractPathDistance {
-    public:
-        void setDistanceOnPathFlag( float distance ) {
-            distanceOnPathFlag_ = distance;
-        }
-        
-        
-        float distanceOnPathFlag() const {
-            return distanceOnPathFlag_;
-        }
-        
-    protected:
-        ExtractPathDistance() : distanceOnPathFlag_( 0.0f ) {
-            // Nothing to do.
-        }
-        
-        explicit ExtractPathDistance( float distance ) : distanceOnPathFlag_( distance ) {
-            // Nothing to do.
-        }
-        
-        ~ExtractPathDistance() {
-            // Nothing to do.
-        }
-        
-    private:
-        float distanceOnPathFlag_;
-    }; // class ExtractPathDistance
-    
-    
-    /**
-     * Inherit from it to create a mapping class used by 
-     * @c OpenSteer::mapDistanceToPathAlike and 
-     * @c OpenSteer::mapPointToPathAlike that shouldn't calculate and extract the
-     * distance along the path alike.
-     */
-    class DontExtractPathDistance {
-    public:
-        void setDistanceOnPathFlag( float ) {
-            // Nothing to do.
-        }
-        
-        float distanceOnPathFlag() const {
-            return 0.0f;
-        };
-        
-    protected:
-        ~DontExtractPathDistance() {
-            // Nothing to do.
-        }
-    }; // class DontExtractPathDistance
-    
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_QUERYPATHALIKEUTILITIES_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPath.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/SegmentedPath.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPath.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,157 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * @author Bjoern Knafla <bknafla at uni-kassel.de>
- *
- * Abstract segmented path class for paths build of segments between waypoints.
- */
-#ifndef OPENSTEER_SEGMENTEDPATH_H
-#define OPENSTEER_SEGMENTEDPATH_H
-
-// Include OpenSteer::Path
-#include "OpenSteer/Path.h"
-
-// Include OpenSteer::size_t
-#include "OpenSteer/StandardTypes.h"
-
-namespace OpenSteer {
-    
-    /**
-     * Path build by segments between points on the path.
-     */
-    class SegmentedPath : public Path {
-    public:
-        typedef size_t size_type;
-        
-        virtual ~SegmentedPath() = 0;
-        
-        
-        /**
-         * Returns the number of points defining the segments.
-         *
-         * This also includes the duplicated first point if the path is cyclic.
-         */
-        virtual size_type pointCount() const = 0;
-        
-        /**
-         * Returns the point @a pointIndex.
-         *
-         * If the path is cyclic also the last point that is the duplicated
-         * first one is accessible.
-         */
-        virtual Vector3 point( size_type pointIndex ) const = 0;
-        
-        
-        
-        /**
-         * Returns the number of segments that build the pathway.
-         */
-        virtual size_type segmentCount() const = 0;
-        
-        /**
-         * Returns the length of segment @a segmentIndex.
-         */
-        virtual float segmentLength( size_type segmentIndex ) const = 0;
-        
-        /**
-         * Returns the start point of the segment @a segmentIndex.
-         */
-        virtual Vector3 segmentStart( size_type segmentIndex ) const = 0;
-        
-        /**
-         * Returns the end point of segment @a segmentIndex.
-         */
-        virtual Vector3 segmentEnd( size_type segmentIndex ) const = 0;
-        
-        
-        /**
-         * Maps @a point to the nearest point on the center line of segment
-         * @a segmentIndex and returns the distance from the segment start to 
-         * this point.
-         */
-        virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vector3 const& point ) const = 0;
-        
-        
-        /**
-         * Maps @a segmentDistance to the center line of segment @a segmentIndex
-         * and returns the reached point.
-         *
-         * If @a segmentDistance is greater or smaller than the segment length
-         * is is clamped to @c 0.0f or @c segmentLength().
-         */
-        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
-                                                float segmentDistance ) const = 0;
-        
-        /**
-         * Maps @a segmentDistance to the centerline of the segment 
-         * @a segmentIndex and returns the tangent of the pathway at the reached
-         * point.
-         *
-         * If @a segmentDistance is greater or smaller than the segment length
-         * is is clamped to @c 0.0f or @c segmentLength().
-         */
-        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
-                                                  float segmentDistance ) const = 0;
-        
-        
-        /**
-         * Combines @c mapSegmentDistanceToPoint and 
-         * @c mapSegmentDistanceToTangent.
-         */
-        virtual void mapDistanceToSegmentPointAndTangent( size_type segmentIndex,
-                                                          float distance,
-                                                          Vector3& pointOnPath,
-                                                          Vector3& tangent ) const = 0;
-        
-        
-        /**
-         * Combines @c mapPointToSegmentDistance, @c mapSegmentDistanceToPoint, 
-         * and @c mapSegmentDistanceToTangent.
-         */
-        virtual void mapPointToSegmentDistanceAndPointAndTangent( size_type segmentIndex,
-                                                                  Vector3 const& point,
-                                                                  float& distance,
-                                                                  Vector3& pointOnPath,
-                                                                  Vector3& tangent ) const = 0;
-
-    protected:
-        /**
-         * Protected to disable assigning instances of different inherited 
-         * classes to each other.
-         *
-         * @todo Should this be added or not? Have to read a bit...
-         */
-        // SegmentedPath& operator=( SegmentedPath const& );
-        
-    }; // class SegmentedPath
-    
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_SEGMENTEDPATH_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPath.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/SegmentedPath.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPathway.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/SegmentedPathway.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPathway.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,173 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * @author Bjoern Knafla <bknafla at uni-kassel.de>
- *
- * Abstract pathway build of segments between waypoints.
- */
-#ifndef OPENSTEER_SEGMENTEDPATHWAY_H
-#define OPENSTEER_SEGMENTEDPATHWAY_H
-
-
-// Include OpenSteer::Pathway
-#include "OpenSteer/Pathway.h"
-
-// Include OpenSteer::size_t
-#include "OpenSteer/StandardTypes.h"
-
-
-namespace OpenSteer {
-
-    /**
-     * Path defined by path segments.
-     *
-     * Look at @c QueryPathAlikes.h for functionality to query paths and
-     * pathways for information not provided here.
-     */
-    class SegmentedPathway: public Pathway {
-    public:
-        typedef size_t size_type;
-        
-        
-        virtual ~SegmentedPathway() = 0;
-        
-        /**
-         * Returns the number of points defining the segments.
-         *
-         * This also includes the duplicated first point if the path is cyclic.
-         */
-        virtual size_type pointCount() const = 0;
-        
-        /**
-         * Returns the point @a pointIndex.
-         *
-         * If the path is cyclic also the last point that is the duplicated
-         * first one is accessible.
-         */
-        virtual Vector3 point( size_type pointIndex ) const = 0;
-        
-        
-        /**
-         * Returns the number of segments that build the pathway.
-         */
-        virtual size_type segmentCount() const = 0;
-        
-        /**
-         * Returns the length of segment @a segmentIndex.
-         */
-        virtual float segmentLength( size_type segmentIndex ) const = 0;
-        
-        /**
-         * Returns the start point of the segment @a segmentIndex.
-         */
-        virtual Vector3 segmentStart( size_type segmentIndex ) const = 0;
-        
-        /**
-         * Returns the end point of segment @a segmentIndex.
-         */
-        virtual Vector3 segmentEnd( size_type segmentIndex ) const = 0;
-        
-        
-        
-        /**
-         * Maps @a point to the nearest point on the center line of segment
-         * @a segmentIndex and returns the distance from the segment start to 
-         * this point.
-         */
-        virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vector3 const& point ) const = 0;
-        
-        
-        /**
-         * Maps @a segmentDistance to the center line of segment @a segmentIndex
-         * and returns the reached point.
-         *
-         * If @a segmentDistance is greater or smaller than the segment length
-         * is is clamped to @c 0.0f or @c segmentLength().
-         */
-        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
-                                                float segmentDistance ) const = 0;
-        
-        /**
-         * Maps @a segmentDistance to the center line of segment @a segmentIndex
-         * and returns the radius at the reached point.
-         *
-         * If @a segmentDistance is greater or smaller than the segment length
-         * is is clamped to @c 0.0f or @c segmentLength().
-         */
-        virtual float mapSegmentDistanceToRadius( size_type segmentIndex, 
-                                                 float distanceOnSegment ) const = 0;
-        
-        /**
-         * Maps @a segmentDistance to the centerline of the segment 
-         * @a segmentIndex and returns the tangent of the pathway at the reached
-         * point.
-         *
-         * If @a segmentDistance is greater or smaller than the segment length
-         * is is clamped to @c 0.0f or @c segmentLength().
-         */
-        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
-                                                  float segmentDistance ) const = 0;
-        
-        /**
-         * Combines @c mapSegmentDistanceToPoint and 
-         * @c mapSegmentDistanceToTangent and @c mapSegmentDistanceToRadius.
-         */
-        virtual void mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
-                                                                   float segmentDistance,
-                                                                   Vector3& pointOnPath,
-                                                                   Vector3& tangent,
-                                                                   float& radius ) const = 0;        
-        
-        /**
-         * Combines @c mapPointToSegmentDistance, @c mapSegmentDistanceToPoint,
-         * @c mapSegmentDistanceToRadius, and @c mapSegmentDistanceToTangent.
-         */
-        virtual void mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
-                                                                           Vector3 const& point,
-                                                                           float& distance,
-                                                                           Vector3& pointOnPath,
-                                                                           Vector3& tangent,
-                                                                           float& radius) const = 0;
-        
-       
-    protected:
-        /**
-         * Protected to disable assigning instances of different inherited 
-         * classes to each other.
-         *
-         * @todo Should this be added or not? Have to read a bit...
-         */
-        // SegmentedPathway& operator=( SegmentedPathway const& );    
-    }; // class SegmentedPathway
-    
-    
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_SEGMENTEDPATHWAY_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPathway.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/SegmentedPathway.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/StandardTypes.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/StandardTypes.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/StandardTypes.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,46 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original authors: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * Primitive standard types.
- */
-#ifndef OPENSTEER_STANDARDTYPES_H
-#define OPENSTEER_STANDARDTYPES_H
-
-// Include std::size_t, std::ptrdiff_t
-#include <cstddef>
-
-
-namespace OpenSteer {
-    
-    
-    typedef std::size_t size_t;
-    typedef std::ptrdiff_t ptrdiff_t;
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_STANDARDTYPES_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/StandardTypes.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/StandardTypes.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/SteerLibrary.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/SteerLibrary.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/SteerLibrary.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,1076 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// SteerLibraryMixin
-//
-// This mixin (class with templated superclass) adds the "steering library"
-// functionality to a given base class.  SteerLibraryMixin assumes its base
-// class supports the AbstractVehicle interface.
-//
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 02-06-03 cwr: create mixin (from "SteerMass")
-// 06-03-02 cwr: removed TS dependencies
-// 11-21-01 cwr: created
-//
-//
-// ----------------------------------------------------------------------------
-
-
-#ifndef OPENSTEER_STEERLIBRARY_H
-#define OPENSTEER_STEERLIBRARY_H
-
-
-#include "OpenSteer/AbstractVehicle.h"
-#include "OpenSteer/Pathway.h"
-#include "OpenSteer/Obstacle.h"
-#include "OpenSteer/Utilities.h"
-
-// Include OpenSteer::Color, OpenSteer::gBlack, ...
-#include "Color.h"
-
-namespace OpenSteer {
-
-    // ----------------------------------------------------------------------------
-
-
-    template <class Super>
-    class SteerLibraryMixin : public Super
-    {
-    public:
-        using Super::getVelocity;
-        using Super::getMaxSpeed;
-        using Super::getSpeed;
-        using Super::getRadius;
-        using Super::getMaxForce;
-        using Super::getForward;
-        using Super::getPosition;
-        using Super::getSide;
-        using Super::getUp;
-        using Super::predictFuturePosition;
-        
-    public:
-
-        // Constructor: initializes state
-        SteerLibraryMixin ()
-        {
-            // set inital state
-            reset ();
-        }
-
-        // reset state
-        void reset (void)
-        {
-            // initial state of wander behavior
-            WanderSide = 0;
-            WanderUp = 0;
-
-            // default to non-gaudyPursuitAnnotation
-            gaudyPursuitAnnotation = false;
-        }
-
-        // -------------------------------------------------- steering behaviors
-
-        // Wander behavior
-        float WanderSide;
-        float WanderUp;
-        Vector3 steerForWander (float dt);
-
-        // Seek behavior
-        Vector3 steerForSeek (const Vector3& target);
-
-        // Flee behavior
-        Vector3 steerForFlee (const Vector3& target);
-
-        // xxx proposed, experimental new seek/flee [cwr 9-16-02]
-        Vector3 xxxsteerForFlee (const Vector3& target);
-        Vector3 xxxsteerForSeek (const Vector3& target);
-
-        // Path Following behaviors
-        Vector3 steerToFollowPath (const int direction,
-                                const float predictionTime,
-                                Pathway& path);
-        Vector3 steerToStayOnPath (const float predictionTime, Pathway& path);
-
-        // ------------------------------------------------------------------------
-        // Obstacle Avoidance behavior
-        //
-        // Returns a steering force to avoid a given obstacle.  The purely
-        // lateral steering force will turn our vehicle towards a silhouette edge
-        // of the obstacle.  Avoidance is required when (1) the obstacle
-        // intersects the vehicle's current path, (2) it is in front of the
-        // vehicle, and (3) is within minTimeToCollision seconds of travel at the
-        // vehicle's current velocity.  Returns a zero vector value (Vector3::ZERO)
-        // when no avoidance is required.
-
-
-        Vector3 steerToAvoidObstacle (const float minTimeToCollision,
-                                   const Obstacle& obstacle);
-
-
-        // avoids all obstacles in an ObstacleGroup
-
-        Vector3 steerToAvoidObstacles (const float minTimeToCollision,
-                                    const ObstacleGroup& obstacles);
-
-
-        // ------------------------------------------------------------------------
-        // Unaligned collision avoidance behavior: avoid colliding with other
-        // nearby vehicles moving in unconstrained directions.  Determine which
-        // (if any) other other vehicle we would collide with first, then steers
-        // to avoid the site of that potential collision.  Returns a steering
-        // force vector, which is zero length if there is no impending collision.
-
-
-        Vector3 steerToAvoidNeighbors (const float minTimeToCollision,
-                                    const AVGroup& others);
-
-
-        // Given two vehicles, based on their current positions and velocities,
-        // determine the time until nearest approach
-        float predictNearestApproachTime (AbstractVehicle& otherVehicle);
-
-        // Given the time until nearest approach (predictNearestApproachTime)
-        // determine position of each vehicle at that time, and the distance
-        // between them
-        float computeNearestApproachPositions (AbstractVehicle& otherVehicle,
-                                               float time);
-
-
-        /// XXX globals only for the sake of graphical annotation
-        Vector3 hisPositionAtNearestApproach;
-        Vector3 ourPositionAtNearestApproach;
-
-
-        // ------------------------------------------------------------------------
-        // avoidance of "close neighbors" -- used only by steerToAvoidNeighbors
-        //
-        // XXX  Does a hard steer away from any other agent who comes withing a
-        // XXX  critical distance.  Ideally this should be replaced with a call
-        // XXX  to steerForSeparation.
-
-
-        Vector3 steerToAvoidCloseNeighbors (const float minSeparationDistance,
-                                         const AVGroup& others);
-
-
-        // ------------------------------------------------------------------------
-        // used by boid behaviors
-
-
-        bool inBoidNeighborhood (const AbstractVehicle& otherVehicle,
-                                 const float minDistance,
-                                 const float maxDistance,
-                                 const float cosMaxAngle);
-
-
-        // ------------------------------------------------------------------------
-        // Separation behavior -- determines the direction away from nearby boids
-
-
-        Vector3 steerForSeparation (const float maxDistance,
-                                 const float cosMaxAngle,
-                                 const AVGroup& flock);
-
-
-        // ------------------------------------------------------------------------
-        // Alignment behavior
-
-        Vector3 steerForAlignment (const float maxDistance,
-                                const float cosMaxAngle,
-                                const AVGroup& flock);
-
-
-        // ------------------------------------------------------------------------
-        // Cohesion behavior
-
-
-        Vector3 steerForCohesion (const float maxDistance,
-                               const float cosMaxAngle,
-                               const AVGroup& flock);
-
-
-        // ------------------------------------------------------------------------
-        // pursuit of another vehicle (& version with ceiling on prediction time)
-
-
-        Vector3 steerForPursuit (const AbstractVehicle& quarry);
-
-        Vector3 steerForPursuit (const AbstractVehicle& quarry,
-                              const float maxPredictionTime);
-
-        // for annotation
-        bool gaudyPursuitAnnotation;
-
-
-        // ------------------------------------------------------------------------
-        // evasion of another vehicle
-
-
-        Vector3 steerForEvasion (const AbstractVehicle& menace,
-                              const float maxPredictionTime);
-
-
-        // ------------------------------------------------------------------------
-        // tries to maintain a given speed, returns a maxForce-clipped steering
-        // force along the forward/backward axis
-
-
-        Vector3 steerForTargetSpeed (const float targetSpeed);
-
-
-        // ----------------------------------------------------------- utilities
-        // XXX these belong somewhere besides the steering library
-        // XXX above AbstractVehicle, below SimpleVehicle
-        // XXX ("utility vehicle"?)
-
-        // xxx cwr experimental 9-9-02 -- names OK?
-        bool isAhead (const Vector3& target) const {return isAhead (target, 0.707f);};
-        bool isAside (const Vector3& target) const {return isAside (target, 0.707f);};
-        bool isBehind (const Vector3& target) const {return isBehind (target, -0.707f);};
-
-        bool isAhead (const Vector3& target, float cosThreshold) const
-        {
-            const Vector3 targetDirection = (target - getPosition()).normalisedCopy();
-            return getForward().dotProduct(targetDirection) > cosThreshold;
-        };
-        bool isAside (const Vector3& target, float cosThreshold) const
-        {
-            const Vector3 targetDirection = (target - getPosition()).normalisedCopy();
-            const float dp = getForward().dotProduct(targetDirection);
-            return (dp < cosThreshold) && (dp > -cosThreshold);
-        };
-        bool isBehind (const Vector3& target, float cosThreshold) const
-        {
-            const Vector3 targetDirection = (target - getPosition()).normalisedCopy();
-            return getForward().dotProduct(targetDirection) < cosThreshold;
-        };
-
-
-        // ------------------------------------------------ graphical annotation
-        // (parameter names commented out to prevent compiler warning from "-W")
-
-
-        // called when steerToAvoidObstacles decides steering is required
-        // (default action is to do nothing, layered classes can overload it)
-        virtual void annotateAvoidObstacle (const float /*minDistanceToCollision*/)
-        {
-        }
-
-        // called when steerToFollowPath decides steering is required
-        // (default action is to do nothing, layered classes can overload it)
-        virtual void annotatePathFollowing (const Vector3& /*future*/,
-                                            const Vector3& /*onPath*/,
-                                            const Vector3& /*target*/,
-                                            const float /*outside*/)
-        {
-        }
-
-        // called when steerToAvoidCloseNeighbors decides steering is required
-        // (default action is to do nothing, layered classes can overload it)
-        virtual void annotateAvoidCloseNeighbor (const AbstractVehicle& /*other*/,
-                                                 const float /*additionalDistance*/)
-        {
-        }
-
-        // called when steerToAvoidNeighbors decides steering is required
-        // (default action is to do nothing, layered classes can overload it)
-        virtual void annotateAvoidNeighbor (const AbstractVehicle& /*threat*/,
-                                            const float /*steer*/,
-                                            const Vector3& /*ourFuture*/,
-                                            const Vector3& /*threatFuture*/)
-        {
-        }
-    };
-
-    
-} // namespace OpenSteer
-
-// ----------------------------------------------------------------------------
-
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-steerForWander (float dt)
-{
-    // random walk WanderSide and WanderUp between -1 and +1
-    const float speed = 12.0f * dt; // maybe this (12) should be an argument?
-    WanderSide = scalarRandomWalk (WanderSide, speed, -1, +1);
-    WanderUp   = scalarRandomWalk (WanderUp,   speed, -1, +1);
-
-    // return a pure lateral steering vector: (+/-Side) + (+/-Up)
-    return (getSide() * WanderSide) + (getUp() * WanderUp);
-}
-
-
-// ----------------------------------------------------------------------------
-// Seek behavior
-
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-steerForSeek (const Vector3& target)
-{
-    const Vector3 desiredVelocity = target - getPosition();
-    return desiredVelocity - getVelocity();
-}
-
-
-// ----------------------------------------------------------------------------
-// Flee behavior
-
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-steerForFlee (const Vector3& target)
-{
-    const Vector3 desiredVelocity = getPosition() - target;
-    return desiredVelocity - getVelocity();
-}
-
-
-// ----------------------------------------------------------------------------
-// xxx proposed, experimental new seek/flee [cwr 9-16-02]
-
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-xxxsteerForFlee (const Vector3& target)
-{
-//  const Vector3 offset = position - target;
-    const Vector3 offset = getPosition() - target;
-    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, getMaxSpeed()); //xxxnew
-    return desiredVelocity - getVelocity();
-}
-
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-xxxsteerForSeek (const Vector3& target)
-{
-//  const Vector3 offset = target - position;
-    const Vector3 offset = target - getPosition();
-    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, getMaxSpeed()); //xxxnew
-    return desiredVelocity - getVelocity();
-}
-
-
-// ----------------------------------------------------------------------------
-// Path Following behaviors
-
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-steerToStayOnPath (const float predictionTime, Pathway& path)
-{
-    // predict our future position
-    const Vector3 futurePosition = predictFuturePosition (predictionTime);
-
-    // find the point on the path nearest the predicted future position
-    Vector3 tangent;
-    float outside;
-    const Vector3 onPath = path.mapPointToPath (futurePosition,
-                                             tangent,     // output argument
-                                             outside);    // output argument
-
-    if (outside < 0)
-    {
-        // our predicted future position was in the path,
-        // return zero steering.
-        return Vector3::ZERO;
-    }
-    else
-    {
-        // our predicted future position was outside the path, need to
-        // steer towards it.  Use onPath projection of futurePosition
-        // as seek target
-        annotatePathFollowing (futurePosition, onPath, onPath, outside);
-        return steerForSeek (onPath);
-    }
-}
-
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-steerToFollowPath (const int direction,
-                   const float predictionTime,
-                   Pathway& path)
-{
-    // our goal will be offset from our path distance by this amount
-    const float pathDistanceOffset = direction * predictionTime * getSpeed();
-
-    // predict our future position
-    const Vector3 futurePosition = predictFuturePosition (predictionTime);
-
-    // measure distance along path of our current and predicted positions
-    const float nowPathDistance =
-        path.mapPointToPathDistance (getPosition());
-    const float futurePathDistance =
-        path.mapPointToPathDistance (futurePosition);
-
-    // are we facing in the correction direction?
-    const bool rightway = ((pathDistanceOffset > 0) ?
-                           (nowPathDistance < futurePathDistance) :
-                           (nowPathDistance > futurePathDistance));
-
-    // find the point on the path nearest the predicted future position
-    // XXX need to improve calling sequence, maybe change to return a
-    // XXX special path-defined object which includes two Vec3s and a 
-    // XXX bool (onPath,tangent (ignored), withinPath)
-    Vector3 tangent;
-    float outside;
-    const Vector3 onPath = path.mapPointToPath (futurePosition,
-                                             // output arguments:
-                                             tangent,
-                                             outside);
-
-    // no steering is required if (a) our future position is inside
-    // the path tube and (b) we are facing in the correct direction
-    if ((outside < 0) && rightway)
-    {
-        // all is well, return zero steering
-        return Vector3::ZERO;
-    }
-    else
-    {
-        // otherwise we need to steer towards a target point obtained
-        // by adding pathDistanceOffset to our current path position
-
-        float const targetPathDistance = nowPathDistance + pathDistanceOffset;
-        Vector3 const target = path.mapPathDistanceToPoint (targetPathDistance);
-
-        annotatePathFollowing (futurePosition, onPath, target, outside);
-
-        // return steering to seek target on path
-        return steerForSeek (target);
-    }
-}
-
-
-// ----------------------------------------------------------------------------
-// Obstacle Avoidance behavior
-//
-// Returns a steering force to avoid a given obstacle.  The purely lateral
-// steering force will turn our vehicle towards a silhouette edge of the
-// obstacle.  Avoidance is required when (1) the obstacle intersects the
-// vehicle's current path, (2) it is in front of the vehicle, and (3) is
-// within minTimeToCollision seconds of travel at the vehicle's current
-// velocity.  Returns a zero vector value (Vector3::ZERO) when no avoidance is
-// required.
-//
-// XXX The current (4-23-03) scheme is to dump all the work on the various
-// XXX Obstacle classes, making them provide a "steer vehicle to avoid me"
-// XXX method.  This may well change.
-//
-// XXX 9-12-03: this routine is probably obsolete: its name is too close to
-// XXX the new steerToAvoidObstacles and the arguments are reversed
-// XXX (perhaps there should be another version of steerToAvoidObstacles
-// XXX whose second arg is "const Obstacle& obstacle" just in case we want
-// XXX to avoid a non-grouped obstacle)
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-steerToAvoidObstacle (const float minTimeToCollision,
-                      const Obstacle& obstacle)
-{
-    const Vector3 avoidance = obstacle.steerToAvoid (*this, minTimeToCollision);
-
-    // XXX more annotation modularity problems (assumes spherical obstacle)
-    if (avoidance != Vector3::ZERO)
-        annotateAvoidObstacle (minTimeToCollision * getSpeed());
-
-    return avoidance;
-}
-
-
-// this version avoids all of the obstacles in an ObstacleGroup
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-steerToAvoidObstacles (const float minTimeToCollision,
-                       const ObstacleGroup& obstacles)
-{
-    const Vector3 avoidance = Obstacle::steerToAvoidObstacles (*this,
-                                                            minTimeToCollision,
-                                                            obstacles);
-
-    // XXX more annotation modularity problems (assumes spherical obstacle)
-    if (avoidance != Vector3::ZERO)
-        annotateAvoidObstacle (minTimeToCollision * getSpeed());
-
-    return avoidance;
-}
-
-
-// ----------------------------------------------------------------------------
-// Unaligned collision avoidance behavior: avoid colliding with other nearby
-// vehicles moving in unconstrained directions.  Determine which (if any)
-// other other vehicle we would collide with first, then steers to avoid the
-// site of that potential collision.  Returns a steering force vector, which
-// is zero length if there is no impending collision.
-
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-steerToAvoidNeighbors (const float minTimeToCollision,
-                       const AVGroup& others)
-{
-    // first priority is to prevent immediate interpenetration
-    const Vector3 separation = steerToAvoidCloseNeighbors (0, others);
-    if (separation != Vector3::ZERO) return separation;
-
-    // otherwise, go on to consider potential future collisions
-    float steer = 0;
-    AbstractVehicle* threat = NULL;
-
-    // Time (in seconds) until the most immediate collision threat found
-    // so far.  Initial value is a threshold: don't look more than this
-    // many frames into the future.
-    float minTime = minTimeToCollision;
-
-    // xxx solely for annotation
-    Vector3 xxxThreatPositionAtNearestApproach;
-    Vector3 xxxOurPositionAtNearestApproach;
-
-    // for each of the other vehicles, determine which (if any)
-    // pose the most immediate threat of collision.
-    for (AVIterator i = others.begin(); i != others.end(); i++)
-    {
-        AbstractVehicle& other = **i;
-        if (&other != this)
-        {	
-            // avoid when future positions are this close (or less)
-            const float collisionDangerThreshold = getRadius() * 2;
-
-            // predicted time until nearest approach of "this" and "other"
-            const float time = predictNearestApproachTime (other);
-
-            // If the time is in the future, sooner than any other
-            // threatened collision...
-            if ((time >= 0) && (time < minTime))
-            {
-                // if the two will be close enough to collide,
-                // make a note of it
-                if (computeNearestApproachPositions (other, time)
-                    < collisionDangerThreshold)
-                {
-                    minTime = time;
-                    threat = &other;
-                    xxxThreatPositionAtNearestApproach
-                        = hisPositionAtNearestApproach;
-                    xxxOurPositionAtNearestApproach
-                        = ourPositionAtNearestApproach;
-                }
-            }
-        }
-    }
-
-    // if a potential collision was found, compute steering to avoid
-    if (threat != NULL)
-    {
-        // parallel: +1, perpendicular: 0, anti-parallel: -1
-        float parallelness = getForward().dotProduct(threat->getForward());
-        float angle = 0.707f;
-
-        if (parallelness < -angle)
-        {
-            // anti-parallel "head on" paths:
-            // steer away from future threat position
-            Vector3 offset = xxxThreatPositionAtNearestApproach - getPosition();
-            float sideDot = offset.dotProduct(getSide());
-            steer = (sideDot > 0) ? -1.0f : 1.0f;
-        }
-        else
-        {
-            if (parallelness > angle)
-            {
-                // parallel paths: steer away from threat
-                Vector3 offset = threat->getPosition() - getPosition();
-                float sideDot = offset.dotProduct(getSide());
-                steer = (sideDot > 0) ? -1.0f : 1.0f;
-            }
-            else
-            {
-                // perpendicular paths: steer behind threat
-                // (only the slower of the two does this)
-                if (threat->getSpeed() <= getSpeed())
-                {
-                    float sideDot = getSide().dotProduct(threat->getVelocity());
-                    steer = (sideDot > 0) ? -1.0f : 1.0f;
-                }
-            }
-        }
-
-        annotateAvoidNeighbor (*threat,
-                               steer,
-                               xxxOurPositionAtNearestApproach,
-                               xxxThreatPositionAtNearestApproach);
-    }
-
-    return getSide() * steer;
-}
-
-
-
-// Given two vehicles, based on their current positions and velocities,
-// determine the time until nearest approach
-//
-// XXX should this return zero if they are already in contact?
-
-template<class Super>
-float
-OpenSteer::SteerLibraryMixin<Super>::
-predictNearestApproachTime (AbstractVehicle& otherVehicle)
-{
-    // imagine we are at the origin with no velocity,
-    // compute the relative velocity of the other vehicle
-    const Vector3 myVelocity = getVelocity();
-    const Vector3 otherVelocity = otherVehicle.getVelocity();
-    const Vector3 relVelocity = otherVelocity - myVelocity;
-    const float relSpeed = relVelocity.length();
-
-    // for parallel paths, the vehicles will always be at the same distance,
-    // so return 0 (aka "now") since "there is no time like the present"
-    if (relSpeed == 0) return 0;
-
-    // Now consider the path of the other vehicle in this relative
-    // space, a line defined by the relative position and velocity.
-    // The distance from the origin (our vehicle) to that line is
-    // the nearest approach.
-
-    // Take the unit tangent along the other vehicle's path
-    const Vector3 relTangent = relVelocity / relSpeed;
-
-    // find distance from its path to origin (compute offset from
-    // other to us, find length of projection onto path)
-    const Vector3 relPosition = getPosition() - otherVehicle.getPosition();
-    const float projection = relTangent.dotProduct(relPosition);
-
-    return projection / relSpeed;
-}
-
-
-// Given the time until nearest approach (predictNearestApproachTime)
-// determine position of each vehicle at that time, and the distance
-// between them
-
-
-template<class Super>
-float
-OpenSteer::SteerLibraryMixin<Super>::
-computeNearestApproachPositions (AbstractVehicle& otherVehicle,
-                                 float time)
-{
-    const Vector3    myTravel =       getForward() *       getSpeed() * time;
-    const Vector3 otherTravel = otherVehicle.getForward() * otherVehicle.getSpeed () * time;
-
-    const Vector3    myFinal =       getPosition() +    myTravel;
-    const Vector3 otherFinal = otherVehicle.getPosition() + otherTravel;
-
-    // xxx for annotation
-    ourPositionAtNearestApproach = myFinal;
-    hisPositionAtNearestApproach = otherFinal;
-
-    return myFinal.distance(otherFinal);
-}
-
-
-
-// ----------------------------------------------------------------------------
-// avoidance of "close neighbors" -- used only by steerToAvoidNeighbors
-//
-// XXX  Does a hard steer away from any other agent who comes withing a
-// XXX  critical distance.  Ideally this should be replaced with a call
-// XXX  to steerForSeparation.
-
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-steerToAvoidCloseNeighbors (const float minSeparationDistance,
-                            const AVGroup& others)
-{
-    // for each of the other vehicles...
-    for (AVIterator i = others.begin(); i != others.end(); i++)    
-    {
-        AbstractVehicle& other = **i;
-        if (&other != this)
-        {
-            const float sumOfRadii = getRadius() + other.getRadius();
-            const float minCenterToCenter = minSeparationDistance + sumOfRadii;
-            const Vector3 offset = other.getPosition() - getPosition();
-            const float currentDistance = offset.length();
-
-            if (currentDistance < minCenterToCenter)
-            {
-                annotateAvoidCloseNeighbor (other, minSeparationDistance);
-                return Vec3Utils::perpendicularComponent(-offset, getForward());
-            }
-        }
-    }
-
-    // otherwise return zero
-    return Vector3::ZERO;
-}
-
-
-// ----------------------------------------------------------------------------
-// used by boid behaviors: is a given vehicle within this boid's neighborhood?
-
-
-template<class Super>
-bool
-OpenSteer::SteerLibraryMixin<Super>::
-inBoidNeighborhood (const AbstractVehicle& otherVehicle,
-                    const float minDistance,
-                    const float maxDistance,
-                    const float cosMaxAngle)
-{
-    if (&otherVehicle == this)
-    {
-        return false;
-    }
-    else
-    {
-        const Vector3 offset = otherVehicle.getPosition() - getPosition();
-        const float distanceSquared = offset.squaredLength();
-
-        // definitely in neighborhood if inside minDistance sphere
-        if (distanceSquared < (minDistance * minDistance))
-        {
-            return true;
-        }
-        else
-        {
-            // definitely not in neighborhood if outside maxDistance sphere
-            if (distanceSquared > (maxDistance * maxDistance))
-            {
-                return false;
-            }
-            else
-            {
-                // otherwise, test angular offset from forward axis
-                const Vector3 unitOffset = offset / sqrt (distanceSquared);
-                const float forwardness = getForward().dotProduct(unitOffset);
-                return forwardness > cosMaxAngle;
-            }
-        }
-    }
-}
-
-
-// ----------------------------------------------------------------------------
-// Separation behavior: steer away from neighbors
-
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-steerForSeparation (const float maxDistance,
-                    const float cosMaxAngle,
-                    const AVGroup& flock)
-{
-    // steering accumulator and count of neighbors, both initially zero
-    Vector3 steering;
-    int neighbors = 0;
-
-    // for each of the other vehicles...
-    AVIterator flockEndIter = flock.end();
-    for (AVIterator otherVehicle = flock.begin(); otherVehicle != flockEndIter; ++otherVehicle )
-    {
-        if (inBoidNeighborhood (**otherVehicle, getRadius()*3, maxDistance, cosMaxAngle))
-        {
-            // add in steering contribution
-            // (opposite of the offset direction, divided once by distance
-            // to normalize, divided another time to get 1/d falloff)
-            const Vector3 offset = (**otherVehicle).getPosition() - getPosition();
-            const float distanceSquared = offset.dotProduct(offset);
-            steering += (offset / -distanceSquared);
-
-            // count neighbors
-            ++neighbors;
-        }
-    }
-
-    // divide by neighbors, then normalize to pure direction
-    // bk: Why dividing if you normalize afterwards?
-    //     As long as normilization tests for @c 0 we can just call normalize
-    //     and safe the branching if.
-    /*
-    if (neighbors > 0) {
-        steering /= neighbors;
-        steering = steering.normalisedCopy();
-    }
-    */
-    steering = steering.normalisedCopy();
-    
-    return steering;
-}
-
-
-// ----------------------------------------------------------------------------
-// Alignment behavior: steer to head in same direction as neighbors
-
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-steerForAlignment (const float maxDistance,
-                   const float cosMaxAngle,
-                   const AVGroup& flock)
-{
-    // steering accumulator and count of neighbors, both initially zero
-    Vector3 steering;
-    int neighbors = 0;
-
-    // for each of the other vehicles...
-    for (AVIterator otherVehicle = flock.begin(); otherVehicle != flock.end(); otherVehicle++)
-    {
-        if (inBoidNeighborhood (**otherVehicle, getRadius()*3, maxDistance, cosMaxAngle))
-        {
-            // accumulate sum of neighbor's heading
-            steering += (**otherVehicle).getForward();
-
-            // count neighbors
-            neighbors++;
-        }
-    }
-
-    // divide by neighbors, subtract off current heading to get error-
-    // correcting direction, then normalize to pure direction
-    if (neighbors > 0) steering = ((steering / (float)neighbors) - getForward()).normalisedCopy();
-
-    return steering;
-}
-
-
-// ----------------------------------------------------------------------------
-// Cohesion behavior: to to move toward center of neighbors
-
-
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-steerForCohesion (const float maxDistance,
-                  const float cosMaxAngle,
-                  const AVGroup& flock)
-{
-    // steering accumulator and count of neighbors, both initially zero
-    Vector3 steering;
-    int neighbors = 0;
-
-    // for each of the other vehicles...
-    for (AVIterator otherVehicle = flock.begin(); otherVehicle != flock.end(); otherVehicle++)
-    {
-        if (inBoidNeighborhood (**otherVehicle, getRadius()*3, maxDistance, cosMaxAngle))
-        {
-            // accumulate sum of neighbor's positions
-            steering += (**otherVehicle).getPosition();
-
-            // count neighbors
-            neighbors++;
-        }
-    }
-
-    // divide by neighbors, subtract off current position to get error-
-    // correcting direction, then normalize to pure direction
-    if (neighbors > 0) steering = ((steering / (float)neighbors) - getPosition()).normalisedCopy();
-
-    return steering;
-}
-
-
-// ----------------------------------------------------------------------------
-// pursuit of another vehicle (& version with ceiling on prediction time)
-
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-steerForPursuit (const AbstractVehicle& quarry)
-{
-    return steerForPursuit (quarry, FLT_MAX);
-}
-
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-steerForPursuit (const AbstractVehicle& quarry,
-                 const float maxPredictionTime)
-{
-    // offset from this to quarry, that distance, unit vector toward quarry
-    const Vector3 offset = quarry.getPosition() - getPosition();
-    const float distance = offset.length ();
-    const Vector3 unitOffset = offset / distance;
-
-    // how parallel are the paths of "this" and the quarry
-    // (1 means parallel, 0 is pependicular, -1 is anti-parallel)
-    const float parallelness = getForward().dotProduct(quarry.getForward());
-
-    // how "forward" is the direction to the quarry
-    // (1 means dead ahead, 0 is directly to the side, -1 is straight back)
-    const float forwardness = getForward().dotProduct(unitOffset);
-
-    const float directTravelTime = distance / getSpeed();
-    const int f = intervalComparison (forwardness,  -0.707f, 0.707f);
-    const int p = intervalComparison (parallelness, -0.707f, 0.707f);
-
-    float timeFactor = 0; // to be filled in below
-    Color color;           // to be filled in below (xxx just for debugging)
-
-    // Break the pursuit into nine cases, the cross product of the
-    // quarry being [ahead, aside, or behind] us and heading
-    // [parallel, perpendicular, or anti-parallel] to us.
-    switch (f)
-    {
-    case +1:
-        switch (p)
-        {
-        case +1:          // ahead, parallel
-            timeFactor = 4;
-            color = gBlack;
-            break;
-        case 0:           // ahead, perpendicular
-            timeFactor = 1.8f;
-            color = gGray50;
-            break;
-        case -1:          // ahead, anti-parallel
-            timeFactor = 0.85f;
-            color = gWhite;
-            break;
-        }
-        break;
-    case 0:
-        switch (p)
-        {
-        case +1:          // aside, parallel
-            timeFactor = 1;
-            color = gRed;
-            break;
-        case 0:           // aside, perpendicular
-            timeFactor = 0.8f;
-            color = gYellow;
-            break;
-        case -1:          // aside, anti-parallel
-            timeFactor = 4;
-            color = gGreen;
-            break;
-        }
-        break;
-    case -1:
-        switch (p)
-        {
-        case +1:          // behind, parallel
-            timeFactor = 0.5f;
-            color= gCyan;
-            break;
-        case 0:           // behind, perpendicular
-            timeFactor = 2;
-            color= gBlue;
-            break;
-        case -1:          // behind, anti-parallel
-            timeFactor = 2;
-            color = gMagenta;
-            break;
-        }
-        break;
-    }
-
-    // estimated time until intercept of quarry
-    const float et = directTravelTime * timeFactor;
-
-    // xxx experiment, if kept, this limit should be an argument
-    const float etl = (et > maxPredictionTime) ? maxPredictionTime : et;
-
-    // estimated position of quarry at intercept
-    const Vector3 target = quarry.predictFuturePosition (etl);
-
-    // annotation
-/*    annotationLine (getPosition(),
-                    target,
-                    gaudyPursuitAnnotation ? color : gGray40);
-*/
-    return steerForSeek (target);
-}
-
-// ----------------------------------------------------------------------------
-// evasion of another vehicle
-
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-steerForEvasion (const AbstractVehicle& menace,
-                 const float maxPredictionTime)
-{
-    // offset from this to menace, that distance, unit vector toward menace
-    const Vector3 offset = menace.getPosition() - getPosition();
-    const float distance = offset.length ();
-
-    const float roughTime = distance / menace.getSpeed();
-    const float predictionTime = ((roughTime > maxPredictionTime) ?
-                                  maxPredictionTime :
-                                  roughTime);
-
-    const Vector3 target = menace.predictFuturePosition(predictionTime);
-
-    return steerForFlee(target);
-}
-
-
-// ----------------------------------------------------------------------------
-// tries to maintain a given speed, returns a maxForce-clipped steering
-// force along the forward/backward axis
-
-
-template<class Super>
-Vector3
-OpenSteer::SteerLibraryMixin<Super>::
-steerForTargetSpeed (const float targetSpeed)
-{
-    const float mf = getMaxForce();
-    const float speedError = targetSpeed - getSpeed();
-    return getForward() * clip (speedError, -mf, +mf);
-}
-
-
-// ----------------------------------------------------------------------------
-#endif // OPENSTEER_STEERLIBRARY_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/SteerLibrary.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/SteerLibrary.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/UnusedParameter.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/UnusedParameter.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/UnusedParameter.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,47 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// Macro to surpress warnings that parameters aren't used.
-//
-// May 09, 2005 bk:  created 
-//
-//
-// ----------------------------------------------------------------------------
-
-#ifndef OPENSTEER_UNUSEDPARAMETER_H
-#define OPENSTEER_UNUSEDPARAMETER_H
-
-/**
- * Macro to surpress warning that parameters aren't used.
- */
-#define OPENSTEER_UNUSED_PARAMETER(expr) (void)expr
-
-
-#endif // OPENSTEER_UNUSEDPARAMETER_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/UnusedParameter.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/UnusedParameter.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/Utilities.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Utilities.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/Utilities.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,514 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// Utilities for OpenSteering
-//
-// 08-06-05 bk:  added functions to clamp values to a certain value range, to 
-//               compare values using a tolerance, and so on.
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 07-09-02 cwr: created 
-//
-//
-// ----------------------------------------------------------------------------
-
-
-#ifndef OPENSTEER_UTILITIES_H
-#define OPENSTEER_UTILITIES_H
-
-
-#include <iostream>  // for ostream, <<, etc.
-#include <cstdlib>   // for rand, etc.
-#include <cfloat>    // for FLT_MAX, etc.
-#include <cmath>     // for sqrt, etc.
-#include <vector>    // for std::vector
-#include <cassert>   // for assert
-#include <limits>    // for numeric_limits
-
-// ----------------------------------------------------------------------------
-// For the sake of Windows, apparently this is a "Linux/Unix thing"
-
-
-#ifndef OPENSTEER_M_PI
-#define OPENSTEER_M_PI 3.14159265358979323846f
-#endif
-
-#ifdef _MSC_VER
-#undef min
-#undef max
-#endif
-
-
-namespace OpenSteer {
-
-    // ----------------------------------------------------------------------------
-    // Generic interpolation
-
-
-    template<class T> inline T interpolate (float alpha, const T& x0, const T& x1)
-    {
-        return x0 + ((x1 - x0) * alpha);
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // Random number utilities
-
-
-    // Returns a float randomly distributed between 0 and 1
-
-    inline float frandom01 (void)
-    {
-        return (((float) rand ()) / ((float) RAND_MAX));
-    }
-
-
-    // Returns a float randomly distributed between lowerBound and upperBound
-
-    inline float frandom2 (float lowerBound, float upperBound)
-    {
-        return lowerBound + (frandom01 () * (upperBound - lowerBound));
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // Constrain a given value (x) to be between two (ordered) bounds: min
-    // and max.  Returns x if it is between the bounds, otherwise returns
-    // the nearer bound.
-
-
-    inline float clip (const float x, const float min, const float max)
-    {
-        if (x < min) return min;
-        if (x > max) return max;
-        return x;
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // remap a value specified relative to a pair of bounding values
-    // to the corresponding value relative to another pair of bounds.
-    // Inspired by (dyna:remap-interval y y0 y1 z0 z1)
-
-
-    inline float remapInterval (float x,
-                                float in0, float in1,
-                                float out0, float out1)
-    {
-        // uninterpolate: what is x relative to the interval in0:in1?
-        float relative = (x - in0) / (in1 - in0);
-
-        // now interpolate between output interval based on relative x
-        return interpolate (relative, out0, out1);
-    }
-
-
-    // Like remapInterval but the result is clipped to remain between
-    // out0 and out1
-
-
-    inline float remapIntervalClip (float x,
-                                    float in0, float in1,
-                                    float out0, float out1)
-    {
-        // uninterpolate: what is x relative to the interval in0:in1?
-        float relative = (x - in0) / (in1 - in0);
-
-        // now interpolate between output interval based on relative x
-        return interpolate (clip (relative, 0, 1), out0, out1);
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // classify a value relative to the interval between two bounds:
-    //     returns -1 when below the lower bound
-    //     returns  0 when between the bounds (inside the interval)
-    //     returns +1 when above the upper bound
-
-
-    inline int intervalComparison (float x, float lowerBound, float upperBound)
-    {
-        if (x < lowerBound) return -1;
-        if (x > upperBound) return +1;
-        return 0;
-    }
-
-
-
-    // ----------------------------------------------------------------------------
-
-
-    inline float scalarRandomWalk (const float initial, 
-                                   const float walkspeed,
-                                   const float min,
-                                   const float max)
-    {
-        const float next = initial + (((frandom01() * 2) - 1) * walkspeed);
-        if (next < min) return min;
-        if (next > max) return max;
-        return next;
-    }
-
-
-    // ----------------------------------------------------------------------------
-
-
-    inline float square (float x)
-    {
-        return x * x;
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // for debugging: prints one line with a given C expression, an equals sign,
-    // and the value of the expression.  For example "angle = 35.6"
-
-
-    #define debugPrint(e) (std::cout << #e" = " << (e) << std::endl << std::flush)
-
-
-    // ----------------------------------------------------------------------------
-    // blends new values into an accumulator to produce a smoothed time series
-    //
-    // Modifies its third argument, a reference to the float accumulator holding
-    // the "smoothed time series."
-    //
-    // The first argument (smoothRate) is typically made proportional to "dt" the
-    // simulation time step.  If smoothRate is 0 the accumulator will not change,
-    // if smoothRate is 1 the accumulator will be set to the new value with no
-    // smoothing.  Useful values are "near zero".
-    //
-    // Usage:
-    //         blendIntoAccumulator (dt * 0.4f, currentFPS, smoothedFPS);
-
-
-    template<class T>
-    inline void blendIntoAccumulator (const float smoothRate,
-                                      const T& newValue,
-                                      T& smoothedAccumulator)
-    {
-        smoothedAccumulator = interpolate (clip (smoothRate, 0, 1),
-                                           smoothedAccumulator,
-                                           newValue);
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // given a new Angle and an old angle, adjust the new for angle wraparound (the
-    // 0->360 flip), returning a value equivalent to newAngle, but closest in
-    // absolute value to oldAngle.  For radians fullCircle = OPENSTEER_M_PI*2, for degrees
-    // fullCircle = 360.  Based on code in stuart/bird/fish demo's camera.cc
-    //
-    // (not currently used)
-
-    /*
-      inline float distance1D (const float a, const float b)
-      {
-          const float d = a - b;
-          return (d > 0) ? d : -d;
-      }
-
-
-      float adjustForAngleWraparound (float newAngle,
-                                      float oldAngle,
-                                      float fullCircle)
-      {
-          // adjust newAngle for angle wraparound: consider its current value (a)
-          // as well as the angle 2pi larger (b) and 2pi smaller (c).  Select the
-          // one closer (magnitude of difference) to the current value of oldAngle.
-          const float a = newAngle;
-          const float b = newAngle + fullCircle;
-          const float c = newAngle - fullCircle;
-          const float ad = distance1D (a, oldAngle);
-          const float bd = distance1D (b, oldAngle);
-          const float cd = distance1D (c, oldAngle);
-
-          if ((bd < ad) && (bd < cd)) return b;
-          if ((cd < ad) && (cd < bd)) return c;
-          return a;
-      }
-    */
-
-
-    // ----------------------------------------------------------------------------
-    // Functions to encapsulate cross-platform differences for several <cmath>
-    // functions.  Specifically, the C++ standard says that these functions are
-    // in the std namespace (std::sqrt, etc.)  Apparently the MS VC6 compiler (or
-    // its header files) do not implement this correctly and the function names
-    // are in the global namespace.  We hope these -XXX versions are a temporary
-    // expedient, to be removed later.
-
-
-    #ifdef _WIN32
-
-    inline float floorXXX (float x)          {return ::floor (x);}
-    inline float  sqrtXXX (float x)          {return ::sqrt (x);}
-    inline float   sinXXX (float x)          {return ::sin (x);}
-    inline float   cosXXX (float x)          {return ::cos (x);}
-    inline float   absXXX (float x)          {return ::abs (x);}
-    inline int     absXXX (int x)            {return ::abs (x);}
-    inline float   maxXXX (float x, float y) {if (x > y) return x; else return y;}
-    inline float   minXXX (float x, float y) {if (x < y) return x; else return y;}
-
-    #else
-
-    inline float floorXXX (float x)          {return std::floor (x);}
-    inline float  sqrtXXX (float x)          {return std::sqrt (x);}
-    inline float   sinXXX (float x)          {return std::sin (x);}
-    inline float   cosXXX (float x)          {return std::cos (x);}
-    inline float   absXXX (float x)          {return std::abs (x);}
-    inline int     absXXX (int x)            {return std::abs (x);}
-    inline float   maxXXX (float x, float y) {return std::max (x, y);}
-    inline float   minXXX (float x, float y) {return std::min (x, y);}
-
-    #endif
-
-
-    // ----------------------------------------------------------------------------
-    // round (x)  "round off" x to the nearest integer (as a float value)
-    //
-    // This is a Gnu-sanctioned(?) post-ANSI-Standard(?) extension (as in
-    // http://www.opengroup.org/onlinepubs/007904975/basedefs/math.h.html)
-    // which may not be present in all C++ environments.  It is defined in
-    // math.h headers in Linux and Mac OS X, but apparently not in Win32:
-
-
-    #ifdef _WIN32
-
-    inline float round (float x)
-    {
-      if (x < 0)
-          return -floorXXX (0.5f - x);
-      else
-          return  floorXXX (0.5f + x);
-    }
-
-    #else 
-    
-    inline float round( float x )
-    {
-        return ::round( x );
-    }
-    
-    #endif
-
-    
-    /**
-     * Returns @a valueToClamp clamped to the range @a minValue - @a maxValue.
-     */
-    template< typename T >
-    T
-    clamp( T const& valueToClamp, T const& minValue, T const& maxValue) {
-        assert( minValue <= maxValue && "minValue must be lesser or equal to maxValue."  );
-        
-        if ( valueToClamp < minValue ) {
-            return minValue;
-        } else if ( valueToClamp > maxValue ) {
-            return maxValue;
-        }
-        
-        return valueToClamp;
-    }
-    
-    
-    /**
-     * Returns the floating point remainder of the division of @a x by @a y.
-     * If @a y is @c 0 the behavior is undefined.
-     */
-    inline float modulo( float x, float y ) {
-        assert( 0.0f != y && "Division by zero." );
-        return std::fmod( x, y );
-    }
-    
-    /**
-     * Returns the floating point remainder of the division of @a x by @a y.
-     * If @a y is @c 0 the behavior is undefined.
-     */
-    inline double modulo( double x, double y ) {
-        assert( 0.0 != y && "Division by zero." );
-        return std::fmod( x, y );
-    }    
-    
-    /**
-     * Returns the floating point remainder of the division of @a x by @a y.
-     * If @a y is @c 0 the behavior is undefined.
-     */
-    inline long double modulo( long double x, long double y ) {
-        assert( 0.0 != y && "Division by zero." );
-        return std::fmod( x, y );
-    }
-    
-    /**
-     * Returns the floating point remainder of the division of @a x by @a y.
-     * If @a y is @c 0 the behavior is undefined.
-     */
-    inline short modulo( short x, short y ) {
-        assert( 0 != y && "Division by zero." );
-        return x % y;
-    }
-    
-    /**
-     * Returns the floating point remainder of the division of @a x by @a y.
-     * If @a y is @c 0 the behavior is undefined.
-     */
-    inline int modulo( int x, int y ) {
-        assert( 0 != y && "Division by zero." );
-        return x % y;
-    }
-    
-    /**
-     * Returns the floating point remainder of the division of @a x by @a y.
-     * If @a y is @c 0 the behavior is undefined.
-     */
-    inline long modulo( long x, long y ) {
-        assert( 0 != y && "Division by zero." );
-        return x % y;
-    }
-    
-    
-    /**
-     * Returns <code>value</code> if <code>value >= 0 </code>, otherwise
-     * <code>-value</code>.
-     */
-    template< typename T >
-    T abs( T const& value ) {
-        return absXXX( value );
-    }
-    
-    /**
-     * Returns the maximum of the three values @a v0, @a v1, and @a v2.
-     *
-     * @todo Write a unit test.
-     */
-    template< typename T >
-    T
-    max( T const& v0, T const& v1, T const& v2 ) {
-        return maxXXX( v0, maxXXX( v1, v2 ) );
-    }
-    
-    
-    /**
-     * Returns the minimum of the three values @a v0, @a v1, and @a v2.
-     *
-     * @todo Write a unit test.
-     */
-    template< typename T >
-    T
-    min( T const& v0, T const& v1, T const& v2 ) {
-        return minXXX( v0, minXXX( v1, v2 ) );
-    }
-    
-    
-    /**
-     * Compares the absolute value of @a v with @a tolerance.
-     *
-     * See Christer Ericson, Real-Time Collision Detection, Morgan Kaufmann, 
-     * 2005, pp. 441--443.
-     *
-     * @todo Write a unit test.
-     */
-    template< typename T >
-    bool
-    isZero( T const& v, T const& tolerance = std::numeric_limits< T >::epsilon() ) {
-        return abs( v ) <= tolerance;
-    }
-    
-    
-    /**
-     * Compares @a lhs with @a rhs given a specific @a tolerance.
-     *
-     * @attention Adapt @a tolerance to the range of values of @a lhs and 
-     * @a rhs.
-     * See Christer Ericson, Real-Time Collision Detection, Morgan Kaufmann, 
-     * 2005, pp. 441--443.
-     *
-     * @return <code>abs( lhs - rhs ) <= tolerance</code>
-     *
-     * @todo Write a unit test.
-     */
-    template< typename T >
-    bool
-    equalsAbsolute( T const& lhs, T const& rhs, T const& tolerance = std::numeric_limits< T >::epsilon()  ) {
-        return isZero( lhs - rhs, tolerance );
-    }
-    
-    
-    /**
-     * Compares @a lhs with @a rhs given a specific @a tolerance taking the 
-     * range of values into account.
-     *
-     * See Christer Ericson, Real-Time Collision Detection, Morgan Kaufmann, 
-     * 2005, pp. 441--443.
-     *
-     * @return <code>abs( lhs - rhs ) <= tolerance * max( abs( lhs ), abs( rhs ), 1 )</code>
-     *
-     * @todo Write a unit test.
-     */
-    template< typename T >
-    bool
-    equalsRelative( T const& lhs, T const& rhs, T const& tolerance = std::numeric_limits< T >::epsilon()  ) {
-        return isZero( lhs - rhs, tolerance * max( abs( lhs ), abs( rhs ), T( 1 ) ) );
-    }
-    
-    
-    /**
-     * Approximately compares @a lhs with @a rhs given a specific @a tolerance  
-     * taking the range of values into account.
-     *
-     * See Christer Ericson, Real-Time Collision Detection, Morgan Kaufmann, 
-     * 2005, pp. 441--443.
-     *
-     * @return <code>abs( lhs - rhs ) <= tolerance * ( abs( lhs ) + abs( rhs ) + 1 )</code>
-     *
-     * @todo Write a unit test.
-     */
-    template< typename T >
-    bool
-    equalsRelativeApproximately( T const& lhs, T const& rhs, T const& tolerance = std::numeric_limits< T >::epsilon()  ) {
-        return isZero( lhs - rhs, tolerance * ( abs( lhs ) + abs( rhs ) + T( 1 ) ) );
-    }    
-    
-    
-    /**
-     * Shrinks the capacity of a std::vector to fit its content.
-     *
-     * See Scott Meyer, Effective STL, Addison-Wesley, 2001, pp. 77--79.
-     */
-    template< typename T >
-    void shrinkToFit( std::vector< T >& v ) {
-        std::vector< T >( v ).swap( v );
-    }
-    
-
-    
-} // namespace OpenSteer
-    
-    
-// ----------------------------------------------------------------------------
-#endif // OPENSTEER_UTILITIES_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/Utilities.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/Utilities.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Vec3.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,289 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-// Vector3: OpenSteer's generic type for 3d vectors
-//
-// This file defines the class Vector3, which is used throughout OpenSteer to
-// manipulate 3d geometric data.  It includes standard vector operations (like
-// vector addition, subtraction, scale, dot, cross...) and more idiosyncratic
-// utility functions.
-//
-// When integrating OpenSteer into a preexisting 3d application, it may be
-// important to use the 3d vector type of that application.  In that case Vector3
-// can be changed to inherit from the preexisting application' vector type and
-// to match the interface used by OpenSteer to the interface provided by the
-// preexisting 3d vector type.
-//
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 03-26-03 cwr: created to replace for Hiranabe-san's execellent but larger
-//               vecmath package (http://objectclub.esm.co.jp/vecmath/)
-//
-// ----------------------------------------------------------------------------
-
-
-#ifndef OPENSTEER_Vector3_H
-#define OPENSTEER_Vector3_H
-
-
-#include "OpenSteer/Utilities.h"  // for interpolate, etc.
-#ifdef __APPLE__
-	#include <Carbon/Carbon.h>
-    #include <Ogre/Ogre.h>
-#else
-    #include <Ogre.h>
-#endif
-
-using Ogre::Vector3;
-
-namespace OpenSteer {
-
-    // ----------------------------------------------------------------------------
-    class Vec3Utils
-    {
-    public:
-        // return component of vector parallel to a unit basis vector
-        // (IMPORTANT NOTE: assumes "basis" has unit magnitude (length==1))
-
-        static Vector3 parallelComponent (const Vector3& vector, const Vector3& unitBasis)
-        {
-            const float projection = vector.dotProduct(unitBasis);
-            return unitBasis * projection;
-        }
-
-        // return component of vector perpendicular to a unit basis vector
-        // (IMPORTANT NOTE: assumes "basis" has unit magnitude (length==1))
-
-        static Vector3 perpendicularComponent (const Vector3& vector, const Vector3& unitBasis)
-        {
-            return vector - parallelComponent(vector, unitBasis);
-        }
-
-        // clamps the length of a given vector to maxLength.  If the vector is
-        // shorter its value is returned unaltered, if the vector is longer
-        // the value returned has length of maxLength and is paralle to the
-        // original input.
-
-        static Vector3 truncateLength (const Vector3& vector, const float maxLength)
-        {
-            const float vecLength = vector.length();
-            if (vecLength <= maxLength)
-                return vector;
-            else
-                return vector * (maxLength / vecLength);
-        }
-
-        // forces a 3d position onto the XZ (aka y=0) plane
-
-        static Vector3 setYtoZero (const Vector3& vector)
-        {
-            return Vector3 (vector.x, 0, vector.z);
-        }
-
-        // rotate this vector about the global Y (up) axis by the given angle
-
-        static Vector3 rotateAboutGlobalY (const Vector3& vector, float angle)
-        {
-            const float s = sinXXX (angle);
-            const float c = cosXXX (angle);
-            return Vector3 ((vector.x * c) + (vector.z * s),
-                         (vector.y),
-                         (vector.z * c) - (vector.x * s));
-        }
-
-        // version for caching sin/cos computation
-        static Vector3 rotateAboutGlobalY (const Vector3& vector, float angle, float& sin, float& cos)
-        {
-            // is both are zero, they have not be initialized yet
-            if (sin==0 && cos==0)
-            {
-                sin = sinXXX (angle);
-                cos = cosXXX (angle);
-            }
-            return Vector3 ((vector.x * cos) + (vector.z * sin),
-                         (vector.y),
-                         (vector.z * cos) - (vector.x * sin));
-        }
-
-        // if this position is outside sphere, push it back in by one diameter
-
-        static Vector3 sphericalWrapAround (const Vector3& vector, const Vector3& center, float radius)
-        {
-            const Vector3 offset = vector - center;
-            const float r = offset.length();
-            if (r > radius)
-                return vector + ((offset/r) * radius * -2);
-            else
-                return vector;
-        }
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // scalar times vector product ("float * Vector3")
-
-
-    inline Vector3 operator* (float s, const Vector3& v) {return v*s;}
-
-
-	// return cross product a x b
-	inline Vector3 crossProduct(const Vector3& a, const Vector3& b)
-	{
-		Vector3 result((a.y * b.z) - (a.z * b.y),
-					(a.z * b.x) - (a.x * b.z),
-					(a.x * b.y) - (a.y * b.x));
-		return result;
-	}
-
-    // ----------------------------------------------------------------------------
-    // Returns a position randomly distributed inside a sphere of unit radius
-    // centered at the origin.  Orientation will be random and length will range
-    // between 0 and 1
-
-
-    Vector3 RandomVectorInUnitRadiusSphere (void);
-
-
-    // ----------------------------------------------------------------------------
-    // Returns a position randomly distributed on a disk of unit radius
-    // on the XZ (Y=0) plane, centered at the origin.  Orientation will be
-    // random and length will range between 0 and 1
-
-
-    Vector3 randomVectorOnUnitRadiusXZDisk (void);
-
-
-    // ----------------------------------------------------------------------------
-    // Returns a position randomly distributed on the surface of a sphere
-    // of unit radius centered at the origin.  Orientation will be random
-    // and length will be 1
-
-
-    inline Vector3 RandomUnitVector (void)
-    {
-        return RandomVectorInUnitRadiusSphere().normalisedCopy();
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // Returns a position randomly distributed on a circle of unit radius
-    // on the XZ (Y=0) plane, centered at the origin.  Orientation will be
-    // random and length will be 1
-
-
-    inline Vector3 RandomUnitVectorOnXZPlane (void)
-    {
-        return Vec3Utils::setYtoZero(RandomVectorInUnitRadiusSphere()).normalisedCopy();
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // used by limitMaxDeviationAngle / limitMinDeviationAngle below
-
-
-    Vector3 vecLimitDeviationAngleUtility (const bool insideOrOutside,
-                                        const Vector3& source,
-                                        const float cosineOfConeAngle,
-                                        const Vector3& basis);
-
-
-    // ----------------------------------------------------------------------------
-    // Enforce an upper bound on the angle by which a given arbitrary vector
-    // diviates from a given reference direction (specified by a unit basis
-    // vector).  The effect is to clip the "source" vector to be inside a cone
-    // defined by the basis and an angle.
-
-
-    inline Vector3 limitMaxDeviationAngle (const Vector3& source,
-                                        const float cosineOfConeAngle,
-                                        const Vector3& basis)
-    {
-        return vecLimitDeviationAngleUtility (true, // force source INSIDE cone
-                                              source,
-                                              cosineOfConeAngle,
-                                              basis);
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // Enforce a lower bound on the angle by which a given arbitrary vector
-    // diviates from a given reference direction (specified by a unit basis
-    // vector).  The effect is to clip the "source" vector to be outside a cone
-    // defined by the basis and an angle.
-
-
-    inline Vector3 limitMinDeviationAngle (const Vector3& source,
-                                        const float cosineOfConeAngle,
-                                        const Vector3& basis)
-    {    
-        return vecLimitDeviationAngleUtility (false, // force source OUTSIDE cone
-                                              source,
-                                              cosineOfConeAngle,
-                                              basis);
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // Returns the distance between a point and a line.  The line is defined in
-    // terms of a point on the line ("lineOrigin") and a UNIT vector parallel to
-    // the line ("lineUnitTangent")
-
-
-    inline float distanceFromLine (const Vector3& point,
-                                   const Vector3& lineOrigin,
-                                   const Vector3& lineUnitTangent)
-    {
-        const Vector3 offset = point - lineOrigin;
-        const Vector3 perp = Vec3Utils::perpendicularComponent(offset, lineUnitTangent);
-        return perp.length();
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // given a vector, return a vector perpendicular to it (note that this
-    // arbitrarily selects one of the infinitude of perpendicular vectors)
-
-
-    Vector3 findPerpendicularIn3d (const Vector3& direction);
-
-
-    // ----------------------------------------------------------------------------
-    // candidates for global utility functions
-    //
-    // dot
-    // cross
-    // length
-    // distance
-    // normalized
-
-    
-} // namespace OpenSteer
-    
-
-// ----------------------------------------------------------------------------
-#endif // OPENSTEER_Vector3_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/Vec3.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3Utilities.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Vec3Utilities.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3Utilities.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,96 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-// Utilities to work with Vector3.
-//
-// 05-12-05 bk:  Created based on code of PolylinePathway.
-//
-// ----------------------------------------------------------------------------
-
-#ifndef OPENSTEER_VEC3UTILITIES_H
-#define OPENSTEER_VEC3UTILITIES_H
-
-
-// Include Vector3
-#include "OpenSteer/Vec3.h"
-
-// Include OpenSteer::size_t
-#include "OpenSteer/StandardTypes.h"
-
-// Include OpenSteer::equalsRelative
-#include "OpenSteer/Utilities.h"
-
-
-
-namespace OpenSteer {
-
-    /**
-     * Returns the nearest point on the segment @a segmentPoint0 to 
-     * @a segmentPoint1 from @a point.
-     */
-    Vector3  nearestPointOnSegment( const Vector3& point,
-                                            const Vector3& segmentPoint0,
-                                            const Vector3& segmentPoint1 );
-    
-    /**
-     * Computes minimum distance from @a point to the line segment defined by
-     * @a segmentPoint0 and @a segmentPoint1.
-     */
-    float pointToSegmentDistance( const Vector3& point,
-                                  const Vector3& segmentPoint0,
-                                  const Vector3& segmentPoint1);
-        
-    /**
-     * Retuns distance between @a a and @a b.
-     */
-    inline float distance (const Vector3& a, const Vector3& b) {
-        return (a-b).length();
-    } 
-    
-    
-    /**
-     * Elementwise relative tolerance comparison of @a lhs and @a rhs taking
-     * the range of the elements into account.
-     *
-     * See Christer Ericson, Real-Time Collision Detection, Morgan Kaufmann, 
-     * 2005, pp. 441--443.
-     *
-     * @todo Rewrite using the stl or providing an own range based function.
-     */
-    inline
-    bool
-    equalsRelative( Vector3 const& lhs, 
-                     Vector3 const& rhs, 
-                     float const& tolerance = std::numeric_limits< float >::epsilon()  ) {
-        return equalsRelative( lhs.x, rhs.x, tolerance ) && equalsRelative( lhs.y, rhs.y ) && equalsRelative( lhs.z, rhs.z );
-    }
-    
-} // namespace OpenSteer
-
-#endif // OPENSTEER_VEC3UTILITIES_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3Utilities.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/Vec3Utilities.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/lq.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/lq.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/lq.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,323 +0,0 @@
-/*
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-// ----------------------------------------------------------------------------
-*/
-
-/* ------------------------------------------------------------------ */
-/*                                                                    */
-/*                   Locality Query (LQ) Facility                     */
-/*                                                                    */
-/* ------------------------------------------------------------------ */
-/*
-
-    This utility is a spatial database which stores objects each of
-    which is associated with a 3d point (a location in a 3d space).
-    The points serve as the "search key" for the associated object.
-    It is intended to efficiently answer "sphere inclusion" queries,
-    also known as range queries: basically questions like:
-
-        Which objects are within a radius R of the location L?
-
-    In this context, "efficiently" means significantly faster than the
-    naive, brute force O(n) testing of all known points.  Additionally
-    it is assumed that the objects move along unpredictable paths, so
-    that extensive preprocessing (for example, constructing a Delaunay
-    triangulation of the point set) may not be practical.
-
-    The implementation is a "bin lattice": a 3d rectangular array of
-    brick-shaped (rectangular parallelepipeds) regions of space.  Each
-    region is represented by a pointer to a (possibly empty) doubly-
-    linked list of objects.  All of these sub-bricks are the same
-    size.  All bricks are aligned with the global coordinate axes.
-
-    Terminology used here: the region of space associated with a bin
-    is called a sub-brick.  The collection of all sub-bricks is called
-    the super-brick.  The super-brick should be specified to surround
-    the region of space in which (almost) all the key-points will
-    exist.  If key-points move outside the super-brick everything will
-    continue to work, but without the speed advantage provided by the
-    spatial subdivision.  For more details about how to specify the
-    super-brick's position, size and subdivisions see lqCreateDatabase
-    below.
-
-    Overview of usage: an application using this facility would first
-    create a database with lqCreateDatabase.  For each client object
-    the application wants to put in the database it creates a
-    lqClientProxy and initializes it with lqInitClientProxy.  When a
-    client object moves, the application calls lqUpdateForNewLocation.
-    To perform a query lqMapOverAllObjectsInLocality is passed an
-    application-supplied call-back function to be applied to all
-    client objects in the locality.  See lqCallBackFunction below for
-    more detail.  The lqFindNearestNeighborWithinRadius function can
-    be used to find a single nearest neighbor using the database.
-
-    Note that "locality query" is also known as neighborhood query,
-    neighborhood search, near neighbor search, and range query.  For
-    additional information on this and related topics see:
-    http://www.red3d.com/cwr/boids/ips.html
-
-    For some description and illustrations of this database in use,
-    see this paper: http://www.red3d.com/cwr/papers/2000/pip.html
-
-*/
-
-#ifndef	_lq_h
-#define	_lq_h
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-
-/* ------------------------------------------------------------------ */
-/*                                                                    */
-/*                       Data types use by LQ                         */
-/*                                                                    */
-/* ------------------------------------------------------------------ */
-/* This structure represents the spatial database.  Typically one of
-   these would be created (by a call to lqCreateDatabase) for a given
-   application.  */
-
-
-typedef struct lqInternalDB lqDB;
-
-
-/* ------------------------------------------------------------------ */
-/* This structure is a proxy for (and contains a pointer to) a client
-   (application) object in the spatial database.  One of these exists
-   for each client object.  This might be included within the
-   structure of a client object, or could be allocated separately.  */
-
-
-typedef struct lqClientProxy
-{
-    /* previous object in this bin, or NULL */
-    struct lqClientProxy*  prev;
-
-    /* next object in this bin, or NULL */
-    struct lqClientProxy*  next;
-
-    /* bin ID (pointer to pointer to bin contents list) */
-    struct lqClientProxy** bin;
-
-    /* pointer to client object */
-    void* object;
-
-    /* the object's location ("key point") used for spatial sorting */
-    float x;
-    float y;
-    float z;
-} lqClientProxy;
-
-
-/* ------------------------------------------------------------------ */
-/*                                                                    */
-/*                            Basic API                               */
-/*                                                                    */
-/* ------------------------------------------------------------------ */
-/* Allocate and initialize an LQ database, returns a pointer to it.
-   The application needs to call this before using the LQ facility.
-   The nine parameters define the properties of the "super-brick":
-      (1) origin: coordinates of one corner of the super-brick, its
-          minimum x, y and z extent.
-      (2) size: the width, height and depth of the super-brick.
-      (3) the number of subdivisions (sub-bricks) along each axis.
-   This routine also allocates the bin array, and initialize its
-   contents. */
-
-
-lqDB* lqCreateDatabase (float originx, float originy, float originz,
-			float sizex,   float sizey,   float sizez,
-			int   divx,    int   divy,    int   divz);
-
-
-/* ------------------------------------------------------------------ */
-/* Deallocates the LQ database */
-
-
-void lqDeleteDatabase (lqDB*);
-
-
-/* ------------------------------------------------------------------ */
-/* The application needs to call this once on each lqClientProxy at
-   setup time to initialize its list pointers and associate the proxy
-   with its client object. */ 
-
-
-void lqInitClientProxy (lqClientProxy* proxy, void* clientObject);
-
-
-/* ------------------------------------------------------------------ */
-/* Call for each client object every time its location changes.  For
-   example, in an animation application, this would be called each
-   frame for every moving object.  */
-
-
-void lqUpdateForNewLocation (lqDB* lq, 
-			     lqClientProxy* object, 
-			     float x, float y, float z);
-
-
-/* ------------------------------------------------------------------ */
-/* Apply an application-specific function to all objects in a certain
-   locality.  The locality is specified as a sphere with a given
-   center and radius.  All objects whose location (key-point) is
-   within this sphere are identified and the function is applied to
-   them.  The application-supplied function takes three arguments:
-
-     (1) a void* pointer to an lqClientProxy's "object".
-     (2) the square of the distance from the center of the search
-         locality sphere (x,y,z) to object's key-point.
-     (3) a void* pointer to the caller-supplied "client query state"
-         object -- typically NULL, but can be used to store state
-         between calls to the lqCallBackFunction.
-
-   This routine uses the LQ database to quickly reject any objects in
-   bins which do not overlap with the sphere of interest.  Incremental
-   calculation of index values is used to efficiently traverse the
-   bins of interest. */
-
-
-/* type for a pointer to a function used to map over client objects */
-typedef void (* lqCallBackFunction)  (void* clientObject,
-				      float distanceSquared,
-				      void* clientQueryState);
-
-
-void lqMapOverAllObjectsInLocality (lqDB* lq, 
-				    float x, float y, float z,
-				    float radius,
-				    lqCallBackFunction func,
-				    void* clientQueryState);
-
-
-/* ------------------------------------------------------------------ */
-/*                                                                    */
-/*                            Other API                               */
-/*                                                                    */
-/* ------------------------------------------------------------------ */
-/* Search the database to find the object whose key-point is nearest
-   to a given location yet within a given radius.  That is, it finds
-   the object (if any) within a given search sphere which is nearest
-   to the sphere's center.  The ignoreObject argument can be used to
-   exclude an object from consideration (or it can be NULL).  This is
-   useful when looking for the nearest neighbor of an object in the
-   database, since otherwise it would be its own nearest neighbor.
-   The function returns a void* pointer to the nearest object, or
-   NULL if none is found.  */
-
-
-void* lqFindNearestNeighborWithinRadius (lqDB* lq, 
-					 float x, float y, float z,
-					 float radius,
-					 void* ignoreObject);
-
-
-/* ------------------------------------------------------------------ */
-/* Adds a given client object to a given bin, linking it into the bin
-   contents list. */
-
-
-void lqAddToBin (lqClientProxy* object, lqClientProxy** bin);
-
-
-/* ------------------------------------------------------------------ */
-/* Removes a given client object from its current bin, unlinking it
-   from the bin contents list. */
-
-
-void lqRemoveFromBin (lqClientProxy* object);
-
-
-/* ------------------------------------------------------------------ */
-/* Given an LQ database object and the nine basic parameters: fill in
-   the object's slots, allocate the bin array, and initialize its
-   contents.  Normally the application does NOT call this directly, it
-   is called by lqCreateDatabase.  */
-
-
-void lqInitDatabase (lqDB* lq,
-		     float originx, float originy, float originz,
-		     float sizex, float sizey, float sizez,
-		     int divx, int divy, int divz);
-
-
-/* ------------------------------------------------------------------ */
-/* Find the bin ID for a location in space.  The location is given in
-   terms of its XYZ coordinates.  The bin ID is a pointer to a pointer
-   to the bin contents list.  */
-
-
-lqClientProxy** lqBinForLocation (lqDB* lq, float x, float y, float z);
-
-
-/* ------------------------------------------------------------------ */
-/* Apply a user-supplied function to all objects in the database,
-   regardless of locality (cf lqMapOverAllObjectsInLocality) */
-
-
-void lqMapOverAllObjects (lqDB* lq, 
-			  lqCallBackFunction func,
-			  void* clientQueryState);
-
-
-/* ------------------------------------------------------------------ */
-/* Removes (all proxies for) all objects from all bins */
-
-
-void lqRemoveAllObjects (lqDB* lq);
-
-
-/* ------------------------------------------------------------------ */
-/* Get statistics about bin populations: min, max and average of
-   non-empty bins. */
-
-
-#ifndef NO_LQ_BIN_STATS
-void lqGetBinPopulationStats (lqDB* lq,
-                              int* min,
-                              int* max,
-                              float* average);
-#endif /* NO_LQ_BIN_STATS */
-
-/* ------------------------------------------------------------------ */
-
-
-#ifndef	NULL
-#define NULL 0
-#endif
-
-
-/* ------------------------------------------------------------------ */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _lq_h */

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/lq.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/lq.h)

Modified: rl/branches/persistence2/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/SteeringVehicle.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/SteeringVehicle.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -131,6 +131,12 @@
 		 */
 		bool isAhead(Agent* agent, const float threshold);
 
+		/** tests if the specified position is within the threshold.
+		 * @param agent Agent to test against
+		 * @param threshold specifies maximum distance
+		 */
+		bool isAhead(const Vector3& position, const float threshold);
+
 		/** tests if collision will happen within specified timeframe
 		 * @param minTimeToCollision minimum time to next collision
 		 */

Modified: rl/branches/persistence2/engine/ai/src/AgentCombatState.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/AgentCombatState.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/AgentCombatState.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -21,6 +21,7 @@
 #include "CombatManager.h"
 #include "Creature.h"
 #include "CreatureControllerManager.h"
+#include "CreatureWalkPathJob.h"
 
 namespace rl
 {
@@ -77,7 +78,8 @@
 
 	void AgentCombatState::update(const float elapsedTime)
     {
-        mAgent->updateVehicle(0, elapsedTime);
+        // we don't use the vehicle (combat uses GoToJob, the vehicle would change the movement and reset the animation!)
+        //mAgent->updateVehicle(0, elapsedTime);
     }
 
     class DistanceComparator
@@ -123,3 +125,4 @@
         return pos + 10 * oppositeDirection;
     }
 }
+

Modified: rl/branches/persistence2/engine/ai/src/AgentDialogState.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/AgentDialogState.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/AgentDialogState.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,83 +1,94 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#include "stdinc.h"
-#include "AgentDialogState.h"
-
-#include "Agent.h"
-#include "AiMessages.h"
-#include "Creature.h"
-#include "CreatureController.h"
-#include "CreatureControllerManager.h"
-#include "MessagePump.h"
-
-using namespace Ogre;
-
-namespace rl
-{
-
-    AgentDialogState::AgentDialogState(Agent* agent)
-        : AgentState(agent),
-        mPartner(NULL),
-        mTalking(false)
-    {
-    }
-
-    AgentDialogState::~AgentDialogState()
-    {
-    }
-
-    void AgentDialogState::setDialogPartner(Agent* partner)
-    {
-        mPartner = partner;
-    }
-
-    void AgentDialogState::setDialog(Dialog* dialog)
-    {
-        mDialog = dialog;
-    }
-
-    void AgentDialogState::update(const Ogre::Real elapsedTime)
-    {
-        CreatureController* ctrl = 
-                CreatureControllerManager::getSingleton().getCreatureController(
-                    mAgent->getControlledCreature());
-
-        if (mAgent->getPosition().squaredDistance(mPartner->getPosition()) > 1.5
-            || !mAgent->isAhead(mPartner, 0.95))
-        {		
-            mAgent->addForce(mAgent->calcSeek(mPartner->getPosition()));
-            mAgent->updateVehicle(0, elapsedTime);
-        }
-		else
-        {
-			if (!mTalking)
-            {
-                mAgent->reset();
-                ctrl->setMovement(
-                    CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
-
-                ctrl->setAnimation("reden");
-				mTalking = true;
-
-                MessagePump::getSingleton().sendMessage<MessageType_DialogStarted>(mDialog);
-                
-                mAgent->popState();
-            }			
-        }
-
-    }
-} // namespace rl
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#include "stdinc.h"
+#include "AgentDialogState.h"
+
+#include "Agent.h"
+#include "AiMessages.h"
+#include "Creature.h"
+#include "CreatureController.h"
+#include "CreatureControllerManager.h"
+#include "MessagePump.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+
+    AgentDialogState::AgentDialogState(Agent* agent)
+        : AgentState(agent),
+        mTalking(false),
+        mDialog(NULL)
+    {
+    }
+
+    AgentDialogState::~AgentDialogState()
+    {
+    }
+
+    void AgentDialogState::addDialogPartner(Agent* partner)
+    {
+        mPartners.push_back(partner);
+    }
+
+    void AgentDialogState::setDialog(Dialog* dialog)
+    {
+        mDialog = dialog;
+    }
+
+    void AgentDialogState::update(const Ogre::Real elapsedTime)
+    {
+        CreatureController* ctrl = 
+                CreatureControllerManager::getSingleton().getCreatureController(
+                    mAgent->getControlledCreature());
+
+        Vector3 partnerPos(Vector3::ZERO);
+        if (!mPartners.empty())
+        {
+            for (std::list<Agent*>::iterator it = mPartners.begin(), end = mPartners.end(); it != end; ++it)
+            {
+                partnerPos += (*it)->getPosition();
+            }
+            partnerPos /= mPartners.size();
+        }
+
+        if (!mPartners.empty() &&
+            (mAgent->getPosition().squaredDistance(partnerPos) > 1.5
+            || !mAgent->isAhead(partnerPos, 0.95)))
+        {		
+            mAgent->addForce(mAgent->calcSeek(partnerPos));
+            mAgent->updateVehicle(0, elapsedTime);
+        }
+		else
+        {
+			if (!mTalking && mDialog)
+            {
+                mAgent->reset();
+                ctrl->setMovement(
+                    CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
+
+                ctrl->setAnimation("reden");
+				mTalking = true;
+
+                MessagePump::getSingleton().sendMessage<MessageType_DialogStarted>(mDialog);
+                
+                mAgent->popState();
+            }			
+        }
+
+    }
+} // namespace rl

Modified: rl/branches/persistence2/engine/ai/src/DialogLoaderImpl.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/DialogLoaderImpl.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/DialogLoaderImpl.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,15 +1,28 @@
-/*
- *  DialogLoaderImpl.cpp
- *  Rastullah
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
  *
- *  Created by Sascha Kolewa on 04.12.08.
- *  Copyright 2008 __MyCompanyName__. All rights reserved.
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
  *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 #include "stdinc.h"
 
 #include <xercesc/dom/DOM.hpp>
 
+#ifdef __APPLE__
+#   include <CEGUI/CEGUIPropertyHelper.h>
+#else
+#   include <CEGUIPropertyHelper.h>
+#endif
+
 #include "DialogLoaderImpl.h"
 
 #include "ConfigurationManager.h"
@@ -154,17 +167,22 @@
             }
             CeGuiString id = getAttributeValueAsString(dialogElemXml, "id");
             CeGuiString text = getValueAsString(dialogElemXml);
+            CeGuiString person = "";
+            if (hasAttribute(dialogElemXml, "person"))
+            {
+                person = getAttributeValueAsString(dialogElemXml, "person");
+            }
 
             if (hasNodeName(dialogElemXml, "switchoption"))
             {
-                DialogOption* option = new DialogSelection<DialogOption>(id);
+                DialogOption* option = new DialogSelection<DialogOption>(id, person);
                 option->setLabel(text);
                 dialogPrototype->addOption(option);
             }
             else if (hasNodeName(dialogElemXml, "option"))
             {
                 bool isAutoSelected = getAttributeValueAsBool(dialogElemXml, "autoSelect");
-                DialogOption* option = new DialogOption(id, isAutoSelected);
+                DialogOption* option = new DialogOption(id, person, isAutoSelected);
                 if (hasAttribute(dialogElemXml, "label"))
                 {
                     option->setLabel(getAttributeValueAsString(dialogElemXml, "label"));
@@ -177,11 +195,11 @@
             }
             else if (hasNodeName(dialogElemXml, "response"))
             {
-                dialogPrototype->addResponse(new DialogResponse(id));
+                dialogPrototype->addResponse(new DialogResponse(id, person));
             }
             else if (hasNodeName(dialogElemXml, "switchresponse"))
             {
-                dialogPrototype->addResponse(new DialogResponseSelection(id));
+                dialogPrototype->addResponse(new DialogResponseSelection(id, person));
             }
         }
 
@@ -331,6 +349,7 @@
         {
             option = processSwitchOption(static_cast<DOMElement*>(node), dialogPrototype);
         }
+
         return option;
     }
 
@@ -500,11 +519,16 @@
     DialogParagraph* DialogLoaderImpl::processParagraph(DOMElement* paragraphXml)
     {
         Ogre::String voicefile = "";
+        CeGuiString person = "";
         if (hasAttribute(paragraphXml, "voicefile"))
         {
             voicefile = getAttributeValueAsStdString(paragraphXml, "voicefile");
         }
-        return new DialogParagraph(getValueAsString(paragraphXml), voicefile);
+        if (hasAttribute(paragraphXml, "person"))
+        {
+            person = getAttributeValueAsString(paragraphXml, "person");
+        }
+        return new DialogParagraph(getValueAsString(paragraphXml), person, voicefile);
     }
 
     DialogCondition* DialogLoaderImpl::processCase(DOMElement *caseXml)
@@ -612,7 +636,7 @@
 
                 if (!isInParty)
                 {
-                    dialog->addParticipant("nsc", curCr);
+                    dialog->addParticipant("npc", curCr);
                     found1stNpc = true;
                 }
             }
@@ -653,7 +677,7 @@
         mParticipantFilter.push_back(participant);
     }
 
-    DialogLoaderImpl::DialogParticipant::DialogParticipant(const CeGuiString& personId, int goId,
+    DialogLoaderImpl::DialogParticipant::DialogParticipant(const CeGuiString& personId, const CeGuiString &goId,
             const CeGuiString& goClass, const CeGuiString& name)
         : mPersonId(personId), mGoId(goId), mGoClass(goClass), mName(name)
     {
@@ -666,7 +690,7 @@
 
     bool DialogLoaderImpl::DialogParticipant::isMatching(Creature* creature) const
     {
-        return (mGoId == -1 || creature->getId() == mGoId)
+        return (mGoId == "" || creature->getId() == mGoId)
             && (mGoClass.empty() || creature->getClassId() == mGoClass)
             && (mName.empty() || creature->getName() == mName);
     }
@@ -816,7 +840,7 @@
     DialogLoaderImpl::DialogParticipant* DialogLoaderImpl::processPerson(DOMElement* personXml)
     {
         CeGuiString personId(""), goClass(""), name("");
-        int goId = -1;
+        CeGuiString goId;
 
         if (hasAttribute(personXml, "id"))
         {
@@ -827,13 +851,13 @@
             LOG_ERROR("DialogLoader", "person node without id found");
         }
 
-        if (hasAttribute(personXml, "goId"))
+        if (hasAttribute(personXml, "goid"))
         {
-            goId = getAttributeValueAsInteger(personXml, "goId");
+            goId = getAttributeValueAsString(personXml, "goid");
         }
-        if (hasAttribute(personXml, "goClass"))
+        if (hasAttribute(personXml, "goclass"))
         {
-            goClass = getAttributeValueAsString(personXml, "goClass");
+            goClass = getAttributeValueAsString(personXml, "goclass");
         }
         if (hasAttribute(personXml, "name"))
         {

Modified: rl/branches/persistence2/engine/ai/src/DialogOption.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/DialogOption.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/DialogOption.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -22,8 +22,8 @@
 namespace rl
 {
 
-    DialogOption::DialogOption(const CeGuiString& id, bool isAutoSelected)
-    : DialogElement(id), mPrecondition(NULL), mResponse(NULL), mLabel(""), mIsAutoSelected(isAutoSelected)
+    DialogOption::DialogOption(const CeGuiString& id, const CeGuiString& person, bool autoSelected)
+    : DialogElement(id, person), mPrecondition(NULL), mResponse(NULL), mLabel(""), mAutoSelected(autoSelected)
     {
     }
 
@@ -59,9 +59,14 @@
         return (mPrecondition != NULL);
     }
 
+    void DialogOption::setAutoSelected(bool autoSelected)
+    {
+        mAutoSelected = autoSelected;
+    }
+
     bool DialogOption::isAutoSelected() const
     {
-        return mIsAutoSelected;
+        return mAutoSelected;
     }
 
     bool DialogOption::isAvailable(Dialog* dialog) const

Modified: rl/branches/persistence2/engine/ai/src/DialogResponse.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/DialogResponse.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/DialogResponse.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -23,8 +23,8 @@
 
 namespace rl
 {
-	DialogResponse::DialogResponse(const CeGuiString& id, int npcId)
-        : DialogElement(id), mNpcId(npcId)
+	DialogResponse::DialogResponse(const CeGuiString& id, const CeGuiString& person)
+        : DialogElement(id, person)
     {
     }
 
@@ -83,8 +83,8 @@
         return PERSON;
     }
 
-    DialogResponseSelection::DialogResponseSelection(const CeGuiString& id)
-        : DialogSelection<DialogResponse>(id)
+    DialogResponseSelection::DialogResponseSelection(const CeGuiString& id, const CeGuiString& person)
+        : DialogSelection<DialogResponse>(id, person)
     {
     }
 

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer (from rev 4878, rl/trunk/engine/ai/src/OpenSteer)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/Color.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/Color.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/Color.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,262 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-
-#include "OpenSteer/Color.h"
-
-// Include Vector3
-#include "OpenSteer/Vec3.h"
-
-// Include assert
-#include <cassert>
-
-
-OpenSteer::Color::Color()
-    : r_(1.0f), g_(1.0f), b_(1.0f), a_ (1.0f)
-{
-    
-}
-
-
-OpenSteer::Color::Color( float greyValue )
-    : r_( greyValue ), g_( greyValue ), b_( greyValue ), a_ (1.0f)
-{
-    
-}
-
-
-OpenSteer::Color::Color( float rValue, float gValue, float bValue, float aValue )
-    : r_( rValue ), g_( gValue ), b_( bValue ), a_( aValue )
-{
-    
-}
-
-
-OpenSteer::Color::Color( Vector3 const& vector )
-    : r_( vector.x ), g_( vector.y ), b_( vector.z ), a_ (1.0f)
-{
-    
-}
-
-
-
-float 
-OpenSteer::Color::r() const
-{
-    return r_;
-}
-
-
-float 
-OpenSteer::Color::g() const
-{
-    return g_;
-}
-
-
-float 
-OpenSteer::Color::b() const
-{
-    return b_;
-}
-
-
-float 
-OpenSteer::Color::a() const
-{
-    return a_;
-}
-
-
-
-void 
-OpenSteer::Color::setR( float value )
-{
-    r_ = value;
-}
-
-
-void 
-OpenSteer::Color::setG( float value )
-{
-    g_ = value;
-}
-
-
-void 
-OpenSteer::Color::setB( float value )
-{
-    b_ = value;
-}
-
-void 
-OpenSteer::Color::setA( float value )
-{
-	a_ = value;
-}
-
-void
-OpenSteer::Color::set( float rValue, float gValue, float bValue, float aValue )
-{
-    r_ = rValue;
-    g_ = gValue;
-    b_ = bValue;
-	a_ = aValue;
-}
-
-
-Vector3 
-OpenSteer::Color::convertToVec3() const
-{
-    return Vector3( r_, g_, b_ );
-}
-
-
-OpenSteer::Color& 
-OpenSteer::Color::operator+=( Color const& other )
-{
-    r_ += other.r_;
-    g_ += other.g_;
-    b_ += other.b_;
-    return *this;
-}
-
-
-OpenSteer::Color& 
-OpenSteer::Color::operator-=( Color const& other )
-{
-    r_ -= other.r_;
-    g_ -= other.g_;
-    b_ -= other.b_;
-    return *this;    
-}
-
-
-OpenSteer::Color& 
-OpenSteer::Color::operator*=( float factor )
-{
-    r_ *= factor;
-    g_ *= factor;
-    b_ *= factor;
-    return *this;    
-}
-
-
-OpenSteer::Color& 
-OpenSteer::Color::operator/=( float factor )
-{
-    assert( 0.0f != factor && "Division by zero." );
-    return operator*=( 1.0f / factor );
-}
-
-
-
-
-
-
-OpenSteer::Color 
-OpenSteer::grayColor( float value )
-{
-    return Color( value );
-}
-
-
-
-OpenSteer::Color 
-OpenSteer::operator+( Color const& lhs, Color const& rhs )
-{
-    Color result( lhs );
-    return result += rhs;
-}
-
-
-OpenSteer::Color 
-OpenSteer::operator-( Color const& lhs, Color const& rhs )
-{
-    Color result( lhs );
-    return result -= rhs;    
-}
-
-
-OpenSteer::Color 
-OpenSteer::operator*( Color const& lhs, float rhs )
-{
-    Color result( lhs );
-    return result *= rhs;
-}
-
-
-OpenSteer::Color 
-OpenSteer::operator*( float lhs, Color const& rhs )
-{
-    return operator*( rhs, lhs );
-}
-
-
-OpenSteer::Color 
-OpenSteer::operator/( Color const& lhs, float rhs )
-{
-    Color result( lhs );
-    return result /= rhs;
-}
-
-
-
-
-
-
-
-OpenSteer::Color const OpenSteer::gBlack(0.0f, 0.0f, 0.0f);
-OpenSteer::Color const OpenSteer::gWhite(1.0f, 1.0f, 1.0f);
-
-OpenSteer::Color const OpenSteer::gRed(1.0f, 0.0f, 0.0f); 
-OpenSteer::Color const OpenSteer::gGreen(0.0f, 1.0f, 0.0f);
-OpenSteer::Color const OpenSteer::gBlue(0.0f, 0.0f, 1.0f);
-OpenSteer::Color const OpenSteer::gYellow(1.0f, 1.0f, 0.0f);
-OpenSteer::Color const OpenSteer::gCyan(0.0f, 1.0f, 1.0f);
-OpenSteer::Color const OpenSteer::gMagenta(1.0f, 0.0f, 1.0f);
-OpenSteer::Color const OpenSteer::gOrange(1.0f, 0.5f, 0.0f);
-
-OpenSteer::Color const OpenSteer::gDarkRed(0.5f, 0.0f, 0.0f);
-OpenSteer::Color const OpenSteer::gDarkGreen(0.0f, 0.5f, 0.0f);
-OpenSteer::Color const OpenSteer::gDarkBlue(0.0f, 0.0f, 0.5f);
-OpenSteer::Color const OpenSteer::gDarkYellow(0.5f, 0.5f, 0.0f);
-OpenSteer::Color const OpenSteer::gDarkCyan(0.0f, 0.5f, 0.5f);
-OpenSteer::Color const OpenSteer::gDarkMagenta(0.5f, 0.0f, 0.5f);
-OpenSteer::Color const OpenSteer::gDarkOrange(0.5f, 0.25f, 0.0f);
-
-OpenSteer::Color const OpenSteer::gGray10(0.1f);
-OpenSteer::Color const OpenSteer::gGray20(0.2f);
-OpenSteer::Color const OpenSteer::gGray30(0.3f);
-OpenSteer::Color const OpenSteer::gGray40(0.4f);
-OpenSteer::Color const OpenSteer::gGray50(0.5f);
-OpenSteer::Color const OpenSteer::gGray60(0.6f);
-OpenSteer::Color const OpenSteer::gGray70(0.7f);
-OpenSteer::Color const OpenSteer::gGray80(0.8f);
-OpenSteer::Color const OpenSteer::gGray90(0.9f);
-

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/Color.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/Color.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/Obstacle.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/Obstacle.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/Obstacle.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,347 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2004, Sony Computer Entertainment America
-// Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer Obstacle classes
-// 
-// 10-28-04 cwr: split off from Obstacle.h 
-//
-//
-// ----------------------------------------------------------------------------
-
-
-#include "OpenSteer/Obstacle.h"
-
-
-// ----------------------------------------------------------------------------
-// Obstacle
-// compute steering for a vehicle to avoid this obstacle, if needed 
-
-
-Vector3 
-OpenSteer::Obstacle::steerToAvoid (const AbstractVehicle& vehicle,
-                                   const float minTimeToCollision) const
-{
-    // find nearest intersection with this obstacle along vehicle's path
-    PathIntersection pi;
-    findIntersectionWithVehiclePath (vehicle, pi);
-
-    // return steering for vehicle to avoid intersection, or zero if non found
-    return pi.steerToAvoidIfNeeded (vehicle, minTimeToCollision);
-}
-
-
-// ----------------------------------------------------------------------------
-// Obstacle
-// static method to apply steerToAvoid to nearest obstacle in an ObstacleGroup
-
-
-Vector3
-OpenSteer::Obstacle::
-steerToAvoidObstacles (const AbstractVehicle& vehicle,
-                       const float minTimeToCollision,
-                       const ObstacleGroup& obstacles)
-{
-    PathIntersection nearest, next;
-
-    // test all obstacles in group for an intersection with the vehicle's
-    // future path, select the one whose point of intersection is nearest
-    firstPathIntersectionWithObstacleGroup (vehicle, obstacles, nearest, next);
-
-    // if nearby intersection found, steer away from it, otherwise no steering
-    return nearest.steerToAvoidIfNeeded (vehicle, minTimeToCollision);
-}
-
-
-// ----------------------------------------------------------------------------
-// Obstacle
-// static method to find first vehicle path intersection in an ObstacleGroup
-//
-// returns its results in the PathIntersection argument "nearest",
-// "next" is used to store internal state.
-
-
-void
-OpenSteer::Obstacle::
-firstPathIntersectionWithObstacleGroup (const AbstractVehicle& vehicle,
-                                        const ObstacleGroup& obstacles,
-                                        PathIntersection& nearest,
-                                        PathIntersection& next)
-{
-    // test all obstacles in group for an intersection with the vehicle's
-    // future path, select the one whose point of intersection is nearest
-    next.intersect = false;
-    nearest.intersect = false;
-    ObstacleIterator o;
-    for (o = obstacles.begin(); o != obstacles.end(); o++)
-    {
-        // find nearest point (if any) where vehicle path intersects obstacle
-        // o, storing the results in PathIntersection object "next"
-        (**o).findIntersectionWithVehiclePath (vehicle, next);
-
-        // if this is the first intersection found, or it is the nearest found
-        // so far, store it in PathIntersection object "nearest"
-        const bool firstFound = !nearest.intersect;
-        const bool nearestFound = (next.intersect &&
-                                   (next.distance < nearest.distance));
-        if (firstFound || nearestFound) nearest = next;
-    }
-}
-
-
-// ----------------------------------------------------------------------------
-// PathIntersection
-// determine steering once path intersections have been found
-
-
-Vector3 
-OpenSteer::Obstacle::PathIntersection::
-steerToAvoidIfNeeded (const AbstractVehicle& vehicle,
-                      const float minTimeToCollision) const
-{
-    // if nearby intersection found, steer away from it, otherwise no steering
-    const float minDistanceToCollision = minTimeToCollision * vehicle.getSpeed();
-    if (intersect && (distance < minDistanceToCollision))
-    {
-        // compute avoidance steering force: take the component of
-        // steerHint which is lateral (perpendicular to vehicle's
-        // forward direction), set its length to vehicle's maxForce
-        Vector3 lateral = Vec3Utils::perpendicularComponent(steerHint, vehicle.getForward());
-        return lateral.normalisedCopy() * vehicle.getMaxForce();
-    }
-    else
-    {
-        return Vector3::ZERO;
-    }
-}
-
-
-// ----------------------------------------------------------------------------
-// SphereObstacle
-// find first intersection of a vehicle's path with this obstacle
-
-
-void 
-OpenSteer::
-SphereObstacle::
-findIntersectionWithVehiclePath (const AbstractVehicle& vehicle,
-                                 PathIntersection& pi) const
-{
-    // This routine is based on the Paul Bourke's derivation in:
-    //   Intersection of a Line and a Sphere (or circle)
-    //   http://www.swin.edu.au/astronomy/pbourke/geometry/sphereline/
-    // But the computation is done in the vehicle's local space, so
-    // the line in question is the Z (Forward) axis of the space which
-    // simplifies some of the calculations.
-
-    float b, c, d, p, q, s;
-    Vector3 lc;
-
-    // initialize pathIntersection object to "no intersection found"
-    pi.intersect = false;
-
-    // find sphere's "local center" (lc) in the vehicle's coordinate space
-    lc = vehicle.localizePosition (center);
-
-    // compute line-sphere intersection parameters
-    const float r = radius + vehicle.getRadius();
-    b = -2 * lc.z;
-    c = square (lc.x) + square (lc.y) + square (lc.z) - square (r);
-    d = (b * b) - (4 * c);
-
-    // when the path does not intersect the sphere
-    if (d < 0) return;
-
-    // otherwise, the path intersects the sphere in two points with
-    // parametric coordinates of "p" and "q".  (If "d" is zero the two
-    // points are coincident, the path is tangent)
-    s = sqrtXXX (d);
-    p = (-b + s) / 2;
-    q = (-b - s) / 2;
-
-    // both intersections are behind us, so no potential collisions
-    if ((p < 0) && (q < 0)) return; 
-
-    // at least one intersection is in front, so intersects our forward
-    // path
-    pi.intersect = true;
-    pi.obstacle = this;
-    pi.distance =
-        ((p > 0) && (q > 0)) ?
-        // both intersections are in front of us, find nearest one
-        ((p < q) ? p : q) :
-        // otherwise one is ahead and one is behind: we are INSIDE obstacle
-        (seenFrom () == outside ?
-         // inside a solid obstacle, so distance to obstacle is zero
-         0.0f :
-         // hollow obstacle (or "both"), pick point that is in front
-         ((p > 0) ? p : q));
-    pi.surfacePoint =
-        vehicle.getPosition() + (vehicle.getForward() * pi.distance);
-    pi.surfaceNormal = (pi.surfacePoint-center).normalisedCopy();
-    // hmm, note that this was actually determined already in pi.distance calc
-    pi.vehicleOutside = lc.length () > radius;
-    switch (seenFrom ())
-    {
-    case outside:
-        pi.steerHint = pi.surfaceNormal;
-        break;
-    case inside:
-        pi.steerHint = -pi.surfaceNormal;
-        break;
-    case both:
-        pi.steerHint = pi.surfaceNormal * (pi.vehicleOutside ? 1.0f : -1.0f);
-        break;
-    }
-}
-
-
-// ----------------------------------------------------------------------------
-// BoxObstacle
-// find first intersection of a vehicle's path with this obstacle
-
-
-void 
-OpenSteer::
-BoxObstacle::
-findIntersectionWithVehiclePath (const AbstractVehicle& vehicle,
-                                 PathIntersection& pi) const
-{
-    // abbreviations
-    const float w = width; // dimensions
-    const float h = height;
-    const float d = depth;
-    const Vector3 s = getSide(); // local space
-    const Vector3 u = getUp();
-    const Vector3 f = getForward();
-    const Vector3 p = getPosition();
-    const Vector3 hw = s * (0.5f * width); // offsets for face centers
-    const Vector3 hh = u * (0.5f * height);
-    const Vector3 hd = f * (0.5f * depth);
-    const seenFromState sf = seenFrom ();
-
-    // the box's six rectangular faces
-    RectangleObstacle r1 (w, h,  s,  u,  f, p + hd, sf); // front
-    RectangleObstacle r2 (w, h, -s,  u, -f, p - hd, sf); // back
-    RectangleObstacle r3 (d, h, -f,  u,  s, p + hw, sf); // side
-    RectangleObstacle r4 (d, h,  f,  u, -s, p - hw, sf); // other side
-    RectangleObstacle r5 (w, d,  s, -f,  u, p + hh, sf); // top
-    RectangleObstacle r6 (w, d, -s, -f, -u, p - hh, sf); // bottom
-
-    // group the six RectangleObstacle faces together
-    ObstacleGroup faces;
-    faces.push_back (&r1);
-    faces.push_back (&r2);
-    faces.push_back (&r3);
-    faces.push_back (&r4);
-    faces.push_back (&r5);
-    faces.push_back (&r6);
-
-    // find first intersection of vehicle path with group of six faces
-    PathIntersection next;
-    firstPathIntersectionWithObstacleGroup (vehicle, faces, pi, next);
-
-    // when intersection found, adjust PathIntersection for the box case
-    if (pi.intersect)
-    {
-        pi.obstacle = this;
-        pi.steerHint = ((pi.surfacePoint - getPosition()).normalisedCopy() *
-                        (pi.vehicleOutside ? 1.0f : -1.0f));
-    }
-}
-
-
-// ----------------------------------------------------------------------------
-// PlaneObstacle
-// find first intersection of a vehicle's path with this obstacle
-
-
-void 
-OpenSteer::
-PlaneObstacle::
-findIntersectionWithVehiclePath (const AbstractVehicle& vehicle,
-                                 PathIntersection& pi) const
-{
-    // initialize pathIntersection object to "no intersection found"
-    pi.intersect = false;
-
-    const Vector3 lp =  localizePosition (vehicle.getPosition());
-    const Vector3 ld = localizeDirection (vehicle.getForward());
-
-    // no obstacle intersection if path is parallel to XY (side/up) plane
-    if (ld.dotProduct(Vector3::NEGATIVE_UNIT_Z) == 0.0f) return;
-
-    // no obstacle intersection if vehicle is heading away from the XY plane
-    if ((lp.z > 0.0f) && (ld.z > 0.0f)) return;
-    if ((lp.z < 0.0f) && (ld.z < 0.0f)) return;
-
-    // no obstacle intersection if obstacle "not seen" from vehicle's side
-    if ((seenFrom () == outside) && (lp.z < 0.0f)) return;
-    if ((seenFrom () == inside)  && (lp.z > 0.0f)) return;
-
-    // find intersection of path with rectangle's plane (XY plane)
-    const float ix = lp.x - (ld.x * lp.z / ld.z);
-    const float iy = lp.y - (ld.y * lp.z / ld.z);
-    const Vector3 planeIntersection (ix, iy, 0.0f);
-
-    // no obstacle intersection if plane intersection is outside 2d shape
-    if (!xyPointInsideShape (planeIntersection, vehicle.getRadius())) return;
-
-    // otherwise, the vehicle path DOES intersect this rectangle
-    const Vector3 localXYradial = planeIntersection.normalisedCopy();
-    const Vector3 radial = globalizeDirection (localXYradial);
-    const float sideSign = (lp.z > 0.0f) ? +1.0f : -1.0f;
-    const Vector3 opposingNormal = getForward() * sideSign;
-    pi.intersect = true;
-    pi.obstacle = this;
-    pi.distance = (lp - planeIntersection).length ();
-    pi.steerHint = opposingNormal + radial; // should have "toward edge" term?
-    pi.surfacePoint = globalizePosition (planeIntersection);
-    pi.surfaceNormal = opposingNormal;
-    pi.vehicleOutside = lp.z > 0.0f;
-}
-
-
-// ----------------------------------------------------------------------------
-// RectangleObstacle
-// determines if a given point on XY plane is inside obstacle shape
-
-
-bool 
-OpenSteer::
-RectangleObstacle::
-xyPointInsideShape (const Vector3& point, float radius) const
-{
-    const float w = radius + (width * 0.5f);
-    const float h = radius + (height * 0.5f);
-    return !((point.x >  w) || (point.x < -w) || (point.y >  h) || (point.y < -h));
-}
-
-
-// ----------------------------------------------------------------------------

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/Obstacle.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/Obstacle.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/Path.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/Path.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/Path.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,40 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @author Bjoern Knafla <bknafla at uni-kassel.de>
- */
-#include "OpenSteer/Path.h"
-
-OpenSteer::Path::~Path()
-{
-    // Nothing to do.
-}
-
-/*
-OpenSteer::Path& OpenSteer::Path::operator=( Path const& )
-{
-    return *this;
-}
-*/

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/Path.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/Path.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/Pathway.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/Pathway.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/Pathway.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,40 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @author Bjoern Knafla <bknafla at uni-kassel.de>
- */
-#include "OpenSteer/Pathway.h"
-
-OpenSteer::Pathway::~Pathway()
-{
-    // Nothing to do.
-}
-
-/*
-OpenSteer::Pathway& OpenSteer::Pathway::operator=( Pathway const& )
-{
-    return *this;
-}
-*/

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/Pathway.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/Pathway.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,556 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @author Bjoern Knafla <bknafla at uni-kassel.de>
- */
-#include "OpenSteer/PolylineSegmentedPath.h"
-
-// Include std::accumulate
-#include <numeric>
-
-// Include std::swap, std::adjacent_find
-#include <algorithm>
-
-// Include assert
-#include <cassert>
-
-
-
-// Include Vector3
-#include "OpenSteer/Vec3.h"
-
-// Include OpenSteer::mapPointToPathway, OpenSteer::mapDistanceToPointOnPathCenterLine
-#include "OpenSteer/QueryPathAlike.h"
-
-// Include OpenSteer::PointToPathMapping, OpenSteer::PathDistanceToPointMapping, OpenSteer::PointToPathDistanceMapping
-#include "OpenSteer/QueryPathAlikeMappings.h"
-
-// Include OpenSteer::HasNoRadius
-#include "OpenSteer/QueryPathAlikeUtilities.h"
-
-// Include OpenSteer::clamp, OpenSteer::shrinkToFit
-#include "OpenSteer/Utilities.h"
-
-
-
-namespace {
-    
-    typedef OpenSteer::SegmentedPath::size_type size_type;
-    typedef std::vector< Vector3 > Vec3Container;
-    typedef std::vector< float > FloatContainer;
-    
-    /**
-     * Recalculates the segment tangent and length for segment @a segmentIndex.
-     *
-     * @attention @a segmentTangents and @a segmentLengths must have the right
-     *            size.
-     */
-    void
-    updateSegmentTangentAndLength( size_type segmentIndex,
-                                   Vec3Container const& points , 
-                                   Vec3Container& segmentTangents, 
-                                   FloatContainer& segmentLengths ) 
-    {
-        assert( ( ( segmentIndex + 1 ) < points.size() ) && 
-                "Not enough points for segment segmentIndex." );
-        assert( segmentIndex < segmentTangents.size() &&
-                "segmentIndex out of range." );
-        assert( segmentTangents.size() == segmentLengths.size() && "segmentTangents and segmentLengths must have the same size." );
-        
-        Vector3 tangent = points[ segmentIndex + 1 ] - points[ segmentIndex ];
-        float const length = tangent.length();
-        assert( ! OpenSteer::isZero( length ) && 
-                "Segments must have lengths greater than 0." );
-        
-        tangent /= length;
-        
-        segmentTangents[ segmentIndex ] = tangent;
-        segmentLengths[ segmentIndex] = length;        
-    }
-    
-    
-    /**
-     * Helper function to calucate the segment tangent and lengths
-     * in the given range.
-     *
-     * @param points points defining the path.
-     * @param segmentTangents container to store the calculated segment 
-     *                        tangents. Must have the right size.
-     * @param segmentLengths container to store the calculated segment lengths.
-     *                       Must have the right size.
-     * @param firstChangedPointIndex the first point that changed. Segments have 
-     *        to be updated starting with it.
-     * @param numOfPoints number of points that changed beginning with 
-     *        @a startIndex.
-     * @param isCyclic Is the path cyclic or not.
-     *
-     */
-    void 
-    updateTangentsAndLengths( Vec3Container const& points , 
-                              Vec3Container& segmentTangents, 
-                              FloatContainer& segmentLengths, 
-                              size_type firstChangedPointIndex, 
-                              size_type numOfPoints,
-                              bool isCyclic )
-    {
-        assert( 0 < numOfPoints && "Only call if points have really changed." );
-        assert( 1 < points.size() && "Two points are needed for a segment." );
-        assert( points.size() == segmentTangents.size() + 1 && 
-                "Two points are needed for one segment, therefore there must be one segment less than points." );
-        assert( segmentTangents.size() == segmentLengths.size() && "segmentTangents and segmentLengths must have the same size." );
-        // Other assertions aren't tested because the function should only be
-        // called by other functions that guarantee correctness of the 
-        // parameters.
-        
-        
-        // The segment with end point @a firstChangedPointIndex has also 
-        // changed. Beware from range underflow by subtraction.      
-        size_type firstSegmentIndex = firstChangedPointIndex;
-        if ( 0 < firstSegmentIndex ) {
-            firstSegmentIndex -= 1;
-        }
-        
-        // The last segment to update has the last changed point as its start
-        // point. This only holds true if the last changed point isn't the last
-        // point.
-        // lastSegmentIndex is one greater than the real last segment to update
-        // like the last iterators in the stl.
-        size_type lastSegmentIndex = firstChangedPointIndex + numOfPoints;
-        lastSegmentIndex = OpenSteer::clamp( lastSegmentIndex, static_cast< size_t >( 0 ), segmentTangents.size() );
-        
-        for ( size_type i = firstSegmentIndex; i < lastSegmentIndex; ++i ) {
-            updateSegmentTangentAndLength( i, points, segmentTangents, segmentLengths );
-        }
-        
-        // If path is cyclic and the first point changed and the cycle closing
-        // segment hasn't been updated update it now.
-        if ( isCyclic && 
-             ( 0 == firstSegmentIndex ) && 
-             ! ( lastSegmentIndex == segmentTangents.size() ) ) {
-            
-            updateSegmentTangentAndLength( segmentTangents.size() - 1, 
-                                           points, 
-                                           segmentTangents, 
-                                           segmentLengths );
-        }
-        
-    }
-    
-    
-    /**
-     * Checks that no adjacent points are equal. Checks the first and last
-     * point if the path is cyclic, too.
-     */
-    template< typename Iterator >
-    bool adjacentPathPointsDifferent( Iterator first, Iterator last, bool closedCycle  ) {
-        
-        assert( last - first > 1 && "A path needs at least two waypoints." );
-        
-        if ( last != std::adjacent_find( first, last ) ) {
-            return false;
-        }
-    
-        if ( closedCycle ) {
-            Iterator before_last( first );
-            std::advance( before_last, last - first - 1  );
-            
-            return *first == *before_last;
-        }
-        
-        return true;
-    }
-    
-    
-        
-} // anonymous namespace
-
-
-
-
-
-
-
-OpenSteer::PolylineSegmentedPath::PolylineSegmentedPath()
-    : points_( 0 ), segmentTangents_( 0 ), segmentLengths_( 0 ), closedCycle_( false )
-{
-    
-}
-
-
-OpenSteer::PolylineSegmentedPath::PolylineSegmentedPath( size_type numOfPoints,
-                                                         Vector3 const newPoints[],
-                                                         bool closedCycle )
-    : points_( 0 ), segmentTangents_( 0 ), segmentLengths_( 0 ), closedCycle_( closedCycle )
-{
-        setPath( numOfPoints, newPoints, closedCycle );
-}
-
-OpenSteer::PolylineSegmentedPath::PolylineSegmentedPath( const PathPoints& newPoints,
-                                                         bool closedCycle )
-    : points_( 0 ), segmentTangents_( 0 ), segmentLengths_( 0 ), closedCycle_( closedCycle )
-{
-        setPath( newPoints, closedCycle );
-}
-
-OpenSteer::PolylineSegmentedPath::PolylineSegmentedPath( PolylineSegmentedPath const& other )
-    : SegmentedPath( other ), points_( other.points_ ), segmentTangents_( other.segmentTangents_ ), segmentLengths_( other.segmentLengths_ ), closedCycle_( other.closedCycle_ )
-{
-    // Nothing to do.
-}
-
-
-
-OpenSteer::PolylineSegmentedPath::~PolylineSegmentedPath()
-{
-    // Nothing to do.
-}
-
-
-
-OpenSteer::PolylineSegmentedPath& 
-OpenSteer::PolylineSegmentedPath::operator=( PolylineSegmentedPath other )
-{
-    swap( other ); 
-    return *this;
-}
-
-
-
-void 
-OpenSteer::PolylineSegmentedPath::swap( PolylineSegmentedPath& other )
-{
-    points_.swap( other.points_ );
-    segmentTangents_.swap( other.segmentTangents_ );
-    segmentLengths_.swap( other.segmentLengths_ );
-    std::swap( closedCycle_, other.closedCycle_ );
-}
-
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPath::setPath( size_type numOfPoints,
-                                           Vector3 const newPoints[],
-                                           bool closedCycle )
-{
-    assert( 1 < numOfPoints && "Path must have at least two distinct points." );
-    // While testing say that no cyclus is used because the first point hasn't 
-    // been copied to the back.
-    assert( adjacentPathPointsDifferent( newPoints, newPoints + numOfPoints, false ) && "Adjacent path points must be different." );
-    
-    closedCycle_ = closedCycle;
-    
-    size_type numberOfPoints = numOfPoints;
-    if ( closedCycle_ ) {
-        ++numberOfPoints;
-    }
-    
-    points_.reserve( numberOfPoints );
-    segmentTangents_.resize( numberOfPoints - 1 );
-    segmentLengths_.resize( numberOfPoints - 1 );
-    
-    points_.assign( newPoints, newPoints + numOfPoints );
-    
-    if ( closedCycle_ ) {
-        points_.push_back( points_[ 0 ] );
-    }
-    
-    updateTangentsAndLengths( points_ , 
-                              segmentTangents_, 
-                              segmentLengths_, 
-                              0, 
-                              numOfPoints,
-                              closedCycle_ );
-    
-    shrinkToFit( points_ );
-    shrinkToFit( segmentTangents_ );
-    shrinkToFit( segmentLengths_ );
-}
-
-void 
-OpenSteer::PolylineSegmentedPath::setPath( const PathPoints& newPoints,
-                                           bool closedCycle )
-{
-    size_type numberOfPoints = newPoints.size();
-    assert( 1 < numberOfPoints && "Path must have at least two distinct points." );
-    // While testing say that no cyclus is used because the first point hasn't 
-    // been copied to the back.
-    assert( adjacentPathPointsDifferent( newPoints.begin(), newPoints.end(), false ) && "Adjacent path points must be different." );
-    
-    closedCycle_ = closedCycle;
-    
-    
-    if ( closedCycle_ ) {
-        ++numberOfPoints;
-    }
-    
-    points_ = newPoints;
-    segmentTangents_.resize( numberOfPoints - 1 );
-    segmentLengths_.resize( numberOfPoints - 1 );
-    
-    if ( closedCycle_ ) {
-        points_.push_back( points_[ 0 ] );
-    }
-    
-    updateTangentsAndLengths( points_ , 
-                              segmentTangents_, 
-                              segmentLengths_, 
-                              0, 
-                              numberOfPoints,
-                              closedCycle_ );
-    
-    shrinkToFit( points_ );
-    shrinkToFit( segmentTangents_ );
-    shrinkToFit( segmentLengths_ );
-}
-
-
-void 
-OpenSteer::PolylineSegmentedPath::movePoints( size_type startIndex,
-                                              size_type numOfPoints,
-                                              Vector3 const newPoints[] )
-{
-    assert( ( startIndex < ( pointCount() - ( isCyclic() ? 1 : 0 ) ) ) && 
-            "startIndex must be inside index range." );
-    assert( ( ( startIndex + numOfPoints ) <= ( pointCount() - ( isCyclic() ? 1 : 0 ) ) ) && 
-            "The max. index of a point to set must be inside the index range." ); 
-    
-    // Update the point positions.
-    // @todo Remove this line size_type const pathPointCount = pointCount();
-    for ( size_type i = 0; i < numOfPoints; ++i ) {
-        points_[ startIndex + i ] = newPoints[ i ];
-    }
-    
-    // If the first point is changed and the path is cyclic also change the
-    // last point, which is just a copy of the first point.
-    if ( isCyclic() && ( 0 == startIndex ) ) {
-        points_.back() = points_.front();
-    }
-    
-    // Recalculate the tangents and lengths.
-    updateTangentsAndLengths( points_, 
-                              segmentTangents_, 
-                              segmentLengths_, 
-                              startIndex, 
-                              numOfPoints, 
-                              isCyclic() );
-    
-    
-    assert( adjacentPathPointsDifferent( points_.begin(), points_.end(), isCyclic() ) && "Adjacent path points must be different." );
-}
-
-
-bool
-OpenSteer::PolylineSegmentedPath::isValid() const 
-{
-    return pointCount() > 1;
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPath::mapPointToPath (const Vector3& point,
-                                                  Vector3& tangent,
-                                                  float& outside) const
-{
-    PointToPathMapping mapping;
-    mapPointToPathAlike( *this, point, mapping );
-    tangent = mapping.tangent;
-    outside = mapping.distancePointToPath;
-    return mapping.pointOnPathCenterLine;
-}
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPath::mapPathDistanceToPoint (float pathDistance) const
-{
-    PathDistanceToPointMapping mapping;
-    mapDistanceToPathAlike( *this, pathDistance, mapping );
-    return mapping.pointOnPathCenterLine;
-}
-
-
-float 
-OpenSteer::PolylineSegmentedPath::mapPointToPathDistance (const Vector3& point) const
-{
-    PointToPathDistanceMapping mapping;
-    mapPointToPathAlike( *this, point, mapping );
-    return mapping.distanceOnPath;
-}
-
-
-bool 
-OpenSteer::PolylineSegmentedPath::isCyclic() const
-{
-    return closedCycle_;
-}
-
-
-float 
-OpenSteer::PolylineSegmentedPath::length() const
-{
-    return std::accumulate( segmentLengths_.begin(), segmentLengths_.end(), 0.0f );
-}
-
-
-OpenSteer::SegmentedPath::size_type 
-OpenSteer::PolylineSegmentedPath::pointCount() const
-{
-    return points_.size();
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPath::point( size_type pointIndex ) const
-{
-    assert( pointIndex < pointCount() && "pointIndex out of range." );
-    return points_[ pointIndex ];
-}
-
-
-
-
-OpenSteer::PolylineSegmentedPath::size_type 
-OpenSteer::PolylineSegmentedPath::segmentCount() const
-{
-    return segmentTangents_.size();
-}
-
-
-float 
-OpenSteer::PolylineSegmentedPath::segmentLength( size_type segmentIndex ) const
-{
-    assert( segmentIndex < segmentCount() && "segmentIndex out of range." );
-    return segmentLengths_[ segmentIndex ];
-}
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPath::segmentStart( size_type segmentIndex ) const
-{
-    assert( segmentIndex < segmentCount() && "segmentIndex out of range." );
-    assert( segmentIndex < pointCount() && "The max. index of a point must be inside range." );
-    return points_[ segmentIndex ];
-}
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPath::segmentEnd( size_type segmentIndex ) const
-{
-    assert( segmentIndex < segmentCount() && "segmentIndex out of range." );
-    assert( segmentIndex + 1< pointCount() && "The max. index of a point must be inside range." );
-
-    return points_[ segmentIndex + 1 ];
-}
-
-
-float 
-OpenSteer::PolylineSegmentedPath::mapPointToSegmentDistance( size_type segmentIndex, 
-                                                             Vector3 const& point ) const
-{
-    assert( segmentIndex < segmentCount() && "segmentIndex is out of range." );
-    
-    Vector3 const segmentStartToPoint( point - points_[ segmentIndex ] );
-    float const distance = segmentStartToPoint.dotProduct( segmentTangents_[ segmentIndex ] );
-    
-    return clamp( distance, 0.0f, segmentLengths_[ segmentIndex ] );
-}
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPath::mapSegmentDistanceToPoint( size_type segmentIndex, 
-                                                             float segmentDistance ) const
-{
-    assert( segmentIndex < segmentCount() && "segmentIndex is out of range." );
-    
-    float const segmentLength = segmentLengths_[ segmentIndex ];
-    /*
-     * bk: remove behavior that treats negative numbers as distances beginning 
-     * from the end of the segment
-    if ( 0.0f > segmentDistance ) {
-        segmentDistance += segmentLength;
-    }
-    */
-    segmentDistance = clamp( segmentDistance, 0.0f, segmentLength );
-    
-    return segmentTangents_[ segmentIndex ] * segmentDistance + points_[ segmentIndex ];
-}
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPath::mapSegmentDistanceToTangent( size_type segmentIndex, 
-                                                               float ) const
-{
-    assert( segmentIndex < segmentCount() && "segmentIndex is out of range." );
-    return segmentTangents_[ segmentIndex ];
-}
-
-
-void 
-OpenSteer::PolylineSegmentedPath::mapDistanceToSegmentPointAndTangent( size_type segmentIndex,
-                                                                       float segmentDistance,
-                                                                       Vector3& pointOnPath,
-                                                                       Vector3& tangent ) const
-{
-    assert( segmentIndex < segmentCount() && "segmentIndex is out of range." );
-    
-    float const segmentLength = segmentLengths_[ segmentIndex ];
-    
-    /* 
-     * bk: remove behavior that treats negative numbers as distances beginning 
-     * from the end of the segment
-    if ( 0.0f > segmentDistance ) {
-        segmentDistance += segmentLength;
-    }
-    */
-    segmentDistance = clamp( segmentDistance, 0.0f, segmentLength );
-    
-    pointOnPath = segmentTangents_[ segmentIndex ] * segmentDistance + points_[ segmentIndex ];
-    tangent = segmentTangents_[ segmentIndex ];
-}
-
-
-void 
-OpenSteer::PolylineSegmentedPath::mapPointToSegmentDistanceAndPointAndTangent( size_type segmentIndex,
-                                                                               Vector3 const& point,
-                                                                               float& distance,
-                                                                               Vector3& pointOnPath,
-                                                                               Vector3& tangent ) const
-{
-    assert( segmentIndex < segmentCount() && "segmentIndex is out of range." );
-    
-    Vector3 const segmentStartPoint = points_[ segmentIndex ];
-    Vector3 const segmentStartToPoint( point - segmentStartPoint );
-    tangent = segmentTangents_[ segmentIndex ];
-    distance = segmentStartToPoint.dotProduct( tangent );
-    distance =  clamp( distance, 0.0f, segmentLengths_[ segmentIndex ] );
-    pointOnPath = tangent * distance + segmentStartPoint;
-}
-
-
-
-

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,327 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @author Bjoern Knafla <bknafla at uni-kassel.de>
- */
-#include "OpenSteer/PolylineSegmentedPathwaySingleRadius.h"
-
-
-// Include std::swap
-#include <algorithm>
-
-
-// Include OpenSteer::mapPointToPathway, OpenSteer::mapDistanceToPointOnPathCenterLine
-#include "OpenSteer/QueryPathAlike.h"
-
-// Include OpenSteer::PointToPathMapping, OpenSteer::PathDistanceToPointMapping, OpenSteer::PointToPathDistanceMapping
-#include "OpenSteer/QueryPathAlikeMappings.h"
-
-// Include OpenSteer::HasSingleRadius
-#include "OpenSteer/QueryPathAlikeUtilities.h"
-
-// Include OPENSTEER_UNUSED_PARAMETER
-#include "OpenSteer/UnusedParameter.h"
-
-
-OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius()
-    : path_(), radius_ ( 0.0f )
-{
-    
-}
-
-
-
-OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius( float r )
-    : path_(), radius_( r )
-{
-    
-}
-
-
-
-OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius( size_type numOfPoints,
-                                                                                       Vector3 const points[],
-                                                                                       float r,
-                                                                                       bool closeCycle )
-    : path_( numOfPoints, points, closeCycle ), radius_( r )
-{
-    
-}
-
-OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius( const PolylineSegmentedPath::PathPoints& points,
-                                                                                       float r,
-                                                                                       bool closeCycle )
-    : path_( points, closeCycle ), radius_( r )
-{
-    
-}
-
-
-OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius( PolylineSegmentedPathwaySingleRadius const& other )
-    : SegmentedPathway( other ), path_( other.path_ ), radius_( other.radius_ )
-{
-    
-}
-
-
-
-OpenSteer::PolylineSegmentedPathwaySingleRadius::~PolylineSegmentedPathwaySingleRadius()
-{
-    // Nothing to do.
-}
-
-
-
-OpenSteer::PolylineSegmentedPathwaySingleRadius& 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::operator=( PolylineSegmentedPathwaySingleRadius other )
-{
-    swap( other );
-    return *this;
-}
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::swap( PolylineSegmentedPathwaySingleRadius& other )
-{
-    path_.swap( other.path_ );
-    std::swap( radius_, other.radius_ );
-}
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::movePoints( size_type startIndex,
-                                                             size_type numOfPoints,
-                                                             Vector3 const newPointValues[] )
-{
-    path_.movePoints( startIndex, numOfPoints, newPointValues );
-}
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::setPathway( size_type numOfPoints,
-                                                             Vector3 const points[],
-                                                             float r,
-                                                             bool closedCycle )
-{
-    path_.setPath( numOfPoints, points, closedCycle );
-    setRadius( r );
-}
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::setRadius( float r )
-{
-    radius_ = r;
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::radius() const
-{
-    return radius_;
-}
-
-
-
-bool
-OpenSteer::PolylineSegmentedPathwaySingleRadius::isValid() const 
-{
-    return pointCount() > 1;
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToPath (const Vector3& point,
-                                                                 Vector3& tangent,
-                                                                 float& outside) const
-{
-    PointToPathMapping mapping;
-    mapPointToPathAlike( *this, point, mapping );
-    tangent = mapping.tangent;
-    outside = mapping.distancePointToPath;
-    return mapping.pointOnPathCenterLine;
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPathDistanceToPoint (float pathDistance) const
-{
-    PathDistanceToPointMapping mapping;
-    mapDistanceToPathAlike( *this, pathDistance, mapping );
-    return mapping.pointOnPathCenterLine;
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToPathDistance (const Vector3& point) const
-{
-    PointToPathDistanceMapping mapping;
-    mapPointToPathAlike( *this, point, mapping );
-    return mapping.distanceOnPath;
-}
-
-
-
-bool 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::isCyclic() const
-{
-    return path_.isCyclic();
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::length() const
-{
-    return path_.length();
-}
-
-
-
-OpenSteer::SegmentedPathway::size_type 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::pointCount() const 
-{
-    return path_.pointCount();
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::point( size_type pointIndex ) const
-{
-    return path_.point( pointIndex );
-}
-
-
-
-
-OpenSteer::PolylineSegmentedPathwaySingleRadius::size_type 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::segmentCount() const
-{
-    return path_.segmentCount();
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::segmentLength( size_type segmentIndex ) const
-{
-    return path_.segmentLength( segmentIndex );
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::segmentStart( size_type segmentIndex ) const
-{
-    return path_.segmentStart( segmentIndex );
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::segmentEnd( size_type segmentIndex ) const
-{
-    return path_.segmentEnd( segmentIndex );
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToSegmentDistance( size_type segmentIndex, 
-                                                                            Vector3 const& point ) const
-{
-    return path_.mapPointToSegmentDistance( segmentIndex, point );
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapSegmentDistanceToPoint( size_type segmentIndex, 
-                                                                            float segmentDistance ) const
-{
-    return path_.mapSegmentDistanceToPoint( segmentIndex, segmentDistance );
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapSegmentDistanceToRadius( size_type segmentIndex, 
-                                                                             float distanceOnSegment ) const
-{
-    OPENSTEER_UNUSED_PARAMETER(segmentIndex);
-    OPENSTEER_UNUSED_PARAMETER(distanceOnSegment);
-    return radius_;
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapSegmentDistanceToTangent( size_type segmentIndex, 
-                                                                              float segmentDistance ) const
-{
-    return path_.mapSegmentDistanceToTangent( segmentIndex, segmentDistance );
-}
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
-                                                                                               float distance,
-                                                                                               Vector3& pointOnPath,
-                                                                                               Vector3& tangent,
-                                                                                               float& radius ) const
-{
-    path_.mapDistanceToSegmentPointAndTangent( segmentIndex, distance, pointOnPath, tangent );
-    radius = radius_;
-}
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
-                                                                                              Vector3 const& point,
-                                                                                              float& distance,
-                                                                                              Vector3& pointOnPath,
-                                                                                              Vector3& tangent,
-                                                                                              float& radius) const
-{
-    path_.mapPointToSegmentDistanceAndPointAndTangent( segmentIndex, point, distance, pointOnPath, tangent );
-    radius = radius_;
-}
-
-

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPath.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/SegmentedPath.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPath.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,40 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @author Bjoern Knafla <bknafla at uni-kassel.de>
- */
-#include "OpenSteer/SegmentedPath.h"
-
-OpenSteer::SegmentedPath::~SegmentedPath()
-{
-    // Nothing to do.
-}
-
-/*
-OpenSteer::SegmentedPath& OpenSteer::SegmentedPath::operator=( SegmentedPath const& )
-{
-    return *this;
-}
-*/

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPath.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/SegmentedPath.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPathway.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/SegmentedPathway.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPathway.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,40 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @author Bjoern Knafla <bknafla at uni-kassel.de>
- */
-#include "OpenSteer/SegmentedPathway.h"
-
-OpenSteer::SegmentedPathway::~SegmentedPathway()
-{
-    // Nothing to do.
-}
-
-/*
-OpenSteer::SegmentedPathway& OpenSteer::SegmentedPathway::operator=( SegmentedPathway const& )
-{
-    return *this;
-}
-*/

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPathway.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/SegmentedPathway.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/Vec3.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/Vec3.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/Vec3.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,192 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// Vector3: OpenSteer's generic type for 3d vectors
-//
-// This file defines the class Vector3, which is used throughout OpenSteer to
-// manipulate 3d geometric data.  It includes standard vector operations (like
-// vector addition, subtraction, scale, dot, cross...) and more idiosyncratic
-// utility functions.
-//
-// When integrating OpenSteer into a preexisting 3d application, it may be
-// important to use the 3d vector type of that application.  In that case Vector3
-// can be changed to inherit from the preexisting application' vector type and
-// to match the interface used by OpenSteer to the interface provided by the
-// preexisting 3d vector type.
-//
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 03-26-03 cwr: created to replace for Hiranabe-san's execellent but larger
-//               vecmath package (http://objectclub.esm.co.jp/vecmath/)
-//
-//
-// ----------------------------------------------------------------------------
-
-
-#include "OpenSteer/Vec3.h"
-
-
-Vector3 
-OpenSteer::RandomVectorInUnitRadiusSphere (void)
-{
-    Vector3 v;
-
-    do
-    {
-        v.x = (frandom01()*2) - 1;
-        v.y = (frandom01()*2) - 1;
-        v.z = (frandom01()*2) - 1;
-    }
-    while (v.length() >= 1);
-
-    return v;
-}
-
-
-// ----------------------------------------------------------------------------
-// Returns a position randomly distributed on a disk of unit radius
-// on the XZ (Y=0) plane, centered at the origin.  Orientation will be
-// random and length will range between 0 and 1
-
-
-Vector3 
-OpenSteer::randomVectorOnUnitRadiusXZDisk (void)
-{
-    Vector3 v;
-
-    do
-    {
-        v.x = (frandom01()*2) - 1;
-        v.y = 0;
-        v.z = (frandom01()*2) - 1;
-    }
-    while (v.length() >= 1);
-
-    return v;
-}
-
-
-// ----------------------------------------------------------------------------
-// Does a "ceiling" or "floor" operation on the angle by which a given vector
-// deviates from a given reference basis vector.  Consider a cone with "basis"
-// as its axis and slope of "cosineOfConeAngle".  The first argument controls
-// whether the "source" vector is forced to remain inside or outside of this
-// cone.  Called by vecLimitMaxDeviationAngle and vecLimitMinDeviationAngle.
-
-
-Vector3 
-OpenSteer::vecLimitDeviationAngleUtility (const bool insideOrOutside,
-                                          const Vector3& source,
-                                          const float cosineOfConeAngle,
-                                          const Vector3& basis)
-{
-    // immediately return zero length input vectors
-    float sourceLength = source.length();
-    if (sourceLength == 0) return source;
-
-    // measure the angular diviation of "source" from "basis"
-    const Vector3 direction = source / sourceLength;
-    float cosineOfSourceAngle = direction.dotProduct(basis);
-
-    // Simply return "source" if it already meets the angle criteria.
-    // (note: we hope this top "if" gets compiled out since the flag
-    // is a constant when the function is inlined into its caller)
-    if (insideOrOutside)
-    {
-	// source vector is already inside the cone, just return it
-	if (cosineOfSourceAngle >= cosineOfConeAngle) return source;
-    }
-    else
-    {
-	// source vector is already outside the cone, just return it
-	if (cosineOfSourceAngle <= cosineOfConeAngle) return source;
-    }
-
-    // find the portion of "source" that is perpendicular to "basis"
-    const Vector3 perp = Vec3Utils::perpendicularComponent(source, basis);
-
-    // normalize that perpendicular
-    const Vector3 unitPerp = perp.normalisedCopy();
-
-    // construct a new vector whose length equals the source vector,
-    // and lies on the intersection of a plane (formed the source and
-    // basis vectors) and a cone (whose axis is "basis" and whose
-    // angle corresponds to cosineOfConeAngle)
-    float perpDist = sqrtXXX (1 - (cosineOfConeAngle * cosineOfConeAngle));
-    const Vector3 c0 = basis * cosineOfConeAngle;
-    const Vector3 c1 = unitPerp * perpDist;
-    return (c0 + c1) * sourceLength;
-}
-
-
-// ----------------------------------------------------------------------------
-// given a vector, return a vector perpendicular to it.  arbitrarily selects
-// one of the infinitely many perpendicular vectors.  a zero vector maps to
-// itself, otherwise length is irrelevant (empirically, output length seems to
-// remain within 20% of input length).
-
-
-Vector3 
-OpenSteer::findPerpendicularIn3d (const Vector3& direction)
-{
-    // to be filled in:
-    Vector3 quasiPerp;  // a direction which is "almost perpendicular"
-    Vector3 result;     // the computed perpendicular to be returned
-
-    // three mutually perpendicular basis vectors
-    const Vector3 i (1, 0, 0);
-    const Vector3 j (0, 1, 0);
-    const Vector3 k (0, 0, 1);
-
-    // measure the projection of "direction" onto each of the axes
-    const float id = i.dotProduct(direction);
-    const float jd = j.dotProduct(direction);
-    const float kd = k.dotProduct(direction);
-
-    // set quasiPerp to the basis which is least parallel to "direction"
-    if ((id <= jd) && (id <= kd))
-    {
-        quasiPerp = i;               // projection onto i was the smallest
-    }
-    else
-    {
-        if ((jd <= id) && (jd <= kd))
-            quasiPerp = j;           // projection onto j was the smallest
-        else
-            quasiPerp = k;           // projection onto k was the smallest
-    }
-
-    // return the cross product (direction x quasiPerp)
-    // which is guaranteed to be perpendicular to both of them
-    result = crossProduct(direction, quasiPerp);
-    return result;
-}
-
-
-// ----------------------------------------------------------------------------

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/Vec3.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/Vec3.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/lq.c
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/lq.c	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/lq.c	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,712 +0,0 @@
-/*
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds <craig_reynolds at playstation.sony.com>
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the "Software"),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-// ----------------------------------------------------------------------------
-*/
-/* ------------------------------------------------------------------ */
-/*                                                                    */
-/* Locality Query facility                                            */
-/*                                                                    */
-/* (by Craig Reynolds, see lq.h file for documentation)               */
-/*                                                                    */
-/*  5-17-99: created                                                  */
-/*  5-20-99: found elusive "allocate 0 bins" bug                      */
-/*  5-28-99: lqMapOverAllObjectsInLocality: clipped, incremental      */
-/*  6- 7-99: clean up, split off annotation stuff into debuglq.c      */
-/*  6- 8-99: tried screening by sum of coords ("first mean"?) but     */
-/*           it was slightly slower, moved unused code to debuglq     */
-/* 10-19-99: Change lqClientObject, lqObject from: "struct x {};" to  */
-/*           "typedef struct x {} x;" for EE compiler.                */
-/* 12- 2-00: Make lqObject "private" using lqInternalDB.              */
-/* 12- 5-00: Rename lqObject to lqDB, lqClientObject to lqClientProxy */
-/* 12- 6-00: Change lqCallBackFunction from arglist of (void*) to:    */
-/*           (void* clientObject, float distanceSquared, void*        */
-/*           clientQueryState).  Add void* clientQueryState arg to    */
-/*           lqMapOverAllObjectsInLocality and its helper functions   */
-/*           lqMapOverAllObjectsInLocalityClipped and                 */
-/*           lqMapOverAllOutsideObjects. Change macro                 */
-/*           lqTraverseBinClientObjectList to invoke callback         */
-/*           function with three arguments, add "state" to its        */
-/*           arglist.  Remove extern lqDistanceSquared.               */
-/* 12- 7-00: Rename lqInitClientObject to lqInitClientProxy, make     */
-/*           "func" be an argument to lqTraverseBinClientObjectList,  */
-/*           add comments.                                            */
-/* 12- 8-00: Add lqFindNearestNeighborWithinRadius and related        */
-/*           definitions: lqFindNearestHelper lqFindNearestState      */
-/*           Add lqMapOverAllObjects and lqRemoveAllObjects (plus:    */
-/*           lqMapOverAllObjectsInBin and lqRemoveAllObjectsInBin)    */
-/*                                                                    */
-/* ------------------------------------------------------------------ */
-
-
-#include <stdlib.h>
-#include <float.h>
-#include <limits.h> /* for INT_MAX */
-#include "OpenSteer/lq.h"
-
-/* for debugging and graphical annotation (normally unused) */
-#ifdef BOIDS_LQ_DEBUG
-#include "OpenSteer/debuglq.c"
-#endif
-
-#ifndef WIN32
-#define USUSED_PARAM __attribute__ ((unused))
-#else
-#define USUSED_PARAM
-#endif
-
-
-/* ------------------------------------------------------------------ */
-/* This structure represents the spatial database.  Typically one of
-   these would be created, by a call to lqCreateDatabase, for a given
-   application.  */
-
-
-typedef struct lqInternalDB
-{
-
-    /* the origin is the super-brick corner minimum coordinates */
-    float originx, originy, originz;
-
-    /* length of the edges of the super-brick */
-    float sizex, sizey, sizez;
-
-    /* number of sub-brick divisions in each direction */
-    int divx, divy, divz;
-
-    /* pointer to an array of pointers, one for each bin */
-    lqClientProxy** bins;
-
-    /* extra bin for "everything else" (points outside super-brick) */
-    lqClientProxy* other;
-
-} lqInternalDB;
-
-
-/* ------------------------------------------------------------------ */
-/* Allocate and initialize an LQ database, return a pointer to it.
-   The application needs to call this before using the LQ facility.
-   The nine parameters define the properties of the "super-brick":
-      (1) origin: coordinates of one corner of the super-brick, its
-          minimum x, y and z extent.
-      (2) size: the width, height and depth of the super-brick.
-      (3) the number of subdivisions (sub-bricks) along each axis.
-   This routine also allocates the bin array, and initialize its
-   contents. */
-
-
-lqInternalDB* lqCreateDatabase (float originx, float originy, float originz,
-				float sizex, float sizey, float sizez,
-				int divx, int divy, int divz)
-{
-    lqInternalDB* lq = ((lqInternalDB*) malloc (sizeof (lqInternalDB)));
-
-    lqInitDatabase (lq,
-		    originx, originy, originz,
-		    sizex, sizey, sizez,
-		    divx, divy, divz);
-    return lq;
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Deallocate the memory used by the LQ database */
-
-
-void lqDeleteDatabase(lqDB* lq)
-{
-    free (lq->bins);
-    free (lq);
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Given an LQ database object and the nine basic parameters: fill in
-   the object's slots, allocate the bin array, and initialize its
-   contents. */
-
-
-void lqInitDatabase (lqInternalDB* lq,
-		     float originx, float originy, float originz,
-		     float sizex, float sizey, float sizez,
-		     int divx, int divy, int divz)
-{
-    lq->originx = originx;
-    lq->originy = originy;
-    lq->originz = originz;
-    lq->sizex = sizex;
-    lq->sizey = sizey;
-    lq->sizez = sizez;
-    lq->divx = divx;
-    lq->divy = divy;
-    lq->divz = divz;
-    {
-	int i;
-	int bincount = divx * divy * divz;
-	int arraysize = sizeof (lqClientProxy*) * bincount;
-	lq->bins = (lqClientProxy**) malloc (arraysize);
-	for (i=0; i<bincount; i++) lq->bins[i] = NULL;
-    }
-    lq->other = NULL;
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Determine index into linear bin array given 3D bin indices */
-
-
-#define lqBinCoordsToBinIndex(lq, ix, iy, iz) \
-    ((ix * (lq)->divy * (lq)->divz) + (iy * (lq)->divz) + iz)
-
-
-/* ------------------------------------------------------------------ */
-/* Find the bin ID for a location in space.  The location is given in
-   terms of its XYZ coordinates.  The bin ID is a pointer to a pointer
-   to the bin contents list.  */
-
-
-lqClientProxy** lqBinForLocation (lqInternalDB* lq, 
-				  float x, float y, float z)
-{
-    int i, ix, iy, iz;
-
-    /* if point outside super-brick, return the "other" bin */
-    if (x < lq->originx)              return &(lq->other);
-    if (y < lq->originy)              return &(lq->other);
-    if (z < lq->originz)              return &(lq->other);
-    if (x >= lq->originx + lq->sizex) return &(lq->other);
-    if (y >= lq->originy + lq->sizey) return &(lq->other);
-    if (z >= lq->originz + lq->sizez) return &(lq->other);
-
-    /* if point inside super-brick, compute the bin coordinates */
-    ix = (int) (((x - lq->originx) / lq->sizex) * lq->divx);
-    iy = (int) (((y - lq->originy) / lq->sizey) * lq->divy);
-    iz = (int) (((z - lq->originz) / lq->sizez) * lq->divz);
-
-    /* convert to linear bin number */
-    i = lqBinCoordsToBinIndex (lq, ix, iy, iz);
-
-    /* return pointer to that bin */
-    return &(lq->bins[i]);
-}
-
-
-/* ------------------------------------------------------------------ */
-/* The application needs to call this once on each lqClientProxy at
-   setup time to initialize its list pointers and associate the proxy
-   with its client object. */ 
-
-
-void lqInitClientProxy (lqClientProxy* proxy, void* clientObject)
-{
-    proxy->prev   = NULL;
-    proxy->next   = NULL;
-    proxy->bin    = NULL;
-    proxy->object = clientObject;
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Adds a given client object to a given bin, linking it into the bin
-   contents list. */
-
-
-void lqAddToBin (lqClientProxy* object, lqClientProxy** bin)
-{
-    /* if bin is currently empty */    
-    if (*bin == NULL)
-    {
-	object->prev = NULL;
-	object->next = NULL;
-	*bin = object;
-    }
-    else
-    {
-	object->prev = NULL;
-	object->next = *bin;
-	(*bin)->prev = object;
-	*bin = object;
-    }
-
-    /* record bin ID in proxy object */
-    object->bin = bin;
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Removes a given client object from its current bin, unlinking it
-   from the bin contents list. */
-
-
-void lqRemoveFromBin (lqClientProxy* object)
-{
-    /* adjust pointers if object is currently in a bin */
-    if (object->bin != NULL)
-    {
-	/* If this object is at the head of the list, move the bin
-	   pointer to the next item in the list (might be NULL). */
-	if (*(object->bin) == object) *(object->bin) = object->next;
-
-	/* If there is a prev object, link its "next" pointer to the
-	   object after this one. */
-	if (object->prev != NULL) object->prev->next = object->next;
-
-	/* If there is a next object, link its "prev" pointer to the
-	   object before this one. */
-	if (object->next != NULL) object->next->prev = object->prev;
-    }
-
-    /* Null out prev, next and bin pointers of this object. */
-    object->prev = NULL;
-    object->next = NULL;
-    object->bin = NULL;
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Call for each client object every time its location changes.  For
-   example, in an animation application, this would be called each
-   frame for every moving object.  */
-
-
-void lqUpdateForNewLocation  (lqInternalDB* lq, 
-			      lqClientProxy* object, 
-			      float x, float y, float z)
-{
-    /* find bin for new location */
-    lqClientProxy** newBin = lqBinForLocation (lq, x, y, z);
-
-    /* store location in client object, for future reference */
-    object->x = x;
-    object->y = y;
-    object->z = z;
-
-    /* has object moved into a new bin? */
-    if (newBin != object->bin)
-    {
-	lqRemoveFromBin (object);
- 	lqAddToBin (object, newBin);
-    }
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Given a bin's list of client proxies, traverse the list and invoke
-   the given lqCallBackFunction on each object that falls within the
-   search radius.  */
-
-
-#define lqTraverseBinClientObjectList(co, radiusSquared, func, state) \
-    while (co != NULL)                                                \
-    {                                                                 \
-	/* compute distance (squared) from this client   */           \
-	/* object to given locality sphere's centerpoint */           \
-	float dx = x - co->x;                                         \
-	float dy = y - co->y;                                         \
-	float dz = z - co->z;                                         \
-	float distanceSquared = (dx * dx) + (dy * dy) + (dz * dz);    \
-                                                                      \
-	/* apply function if client object within sphere */           \
-	if (distanceSquared < radiusSquared)                          \
-	    (*func) (co->object, distanceSquared, state);             \
-                                                                      \
-	/* consider next client object in bin list */                 \
-	co = co->next;                                                \
-    }
-
-
-/* ------------------------------------------------------------------ */
-/* This subroutine of lqMapOverAllObjectsInLocality efficiently
-   traverses of subset of bins specified by max and min bin
-   coordinates. */
-
-void lqMapOverAllObjectsInLocalityClipped (lqInternalDB* lq, 
-                                           float x, float y, float z,
-                                           float radius,
-                                           lqCallBackFunction func,
-                                           void* clientQueryState,
-                                           int minBinX,
-                                           int minBinY, 
-                                           int minBinZ,
-                                           int maxBinX,
-                                           int maxBinY,
-                                           int maxBinZ);
-
-void lqMapOverAllObjectsInLocalityClipped (lqInternalDB* lq, 
-					   float x, float y, float z,
-					   float radius,
-					   lqCallBackFunction func,
-					   void* clientQueryState,
-					   int minBinX,
-					   int minBinY, 
-					   int minBinZ,
-					   int maxBinX,
-					   int maxBinY,
-					   int maxBinZ)
-{
-    int i, j, k;
-    int iindex, jindex, kindex;
-    int slab = lq->divy * lq->divz;
-    int row = lq->divz;
-    int istart = minBinX * slab;
-    int jstart = minBinY * row;
-    int kstart = minBinZ;
-    lqClientProxy* co;
-    lqClientProxy** bin;
-    float radiusSquared = radius * radius;
-
-#ifdef BOIDS_LQ_DEBUG
-    if (lqAnnoteEnable) drawBallGL (x, y, z, radius);
-#endif
-
-    /* loop for x bins across diameter of sphere */
-    iindex = istart;
-    for (i = minBinX; i <= maxBinX; i++)
-    {
-	/* loop for y bins across diameter of sphere */
-	jindex = jstart;
-	for (j = minBinY; j <= maxBinY; j++)
-	{
-	    /* loop for z bins across diameter of sphere */
-	    kindex = kstart;
-	    for (k = minBinZ; k <= maxBinZ; k++)
-	    {
-		/* get current bin's client object list */
-		bin = &lq->bins[iindex + jindex + kindex];
-		co = *bin;
-
-#ifdef BOIDS_LQ_DEBUG
-		if (lqAnnoteEnable) drawBin (lq, bin);
-#endif
-		/* traverse current bin's client object list */
-		lqTraverseBinClientObjectList (co,
-					       radiusSquared,
-					       func,
-					       clientQueryState);
-		kindex += 1;
-	    }
-	    jindex += row;
-	}
-	iindex += slab;
-    }
-}
-
-
-/* ------------------------------------------------------------------ */
-/* If the query region (sphere) extends outside of the "super-brick"
-   we need to check for objects in the catch-all "other" bin which
-   holds any object which are not inside the regular sub-bricks  */
-
-void lqMapOverAllOutsideObjects (lqInternalDB* lq, 
-                                 float x, float y, float z,
-                                 float radius,
-                                 lqCallBackFunction func,
-                                 void* clientQueryState);
-
-void lqMapOverAllOutsideObjects (lqInternalDB* lq, 
-				 float x, float y, float z,
-				 float radius,
-				 lqCallBackFunction func,
-				 void* clientQueryState)
-{
-    lqClientProxy* co = lq->other;
-    float radiusSquared = radius * radius;
-
-    /* traverse the "other" bin's client object list */
-    lqTraverseBinClientObjectList (co,
-				   radiusSquared,
-				   func,
-				   clientQueryState);
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Apply an application-specific function to all objects in a certain
-   locality.  The locality is specified as a sphere with a given
-   center and radius.  All objects whose location (key-point) is
-   within this sphere are identified and the function is applied to
-   them.  The application-supplied function takes three arguments:
-
-     (1) a void* pointer to an lqClientProxy's "object".
-     (2) the square of the distance from the center of the search
-         locality sphere (x,y,z) to object's key-point.
-     (3) a void* pointer to the caller-supplied "client query state"
-         object -- typically NULL, but can be used to store state
-         between calls to the lqCallBackFunction.
-
-   This routine uses the LQ database to quickly reject any objects in
-   bins which do not overlap with the sphere of interest.  Incremental
-   calculation of index values is used to efficiently traverse the
-   bins of interest. */
-
-
-void lqMapOverAllObjectsInLocality (lqInternalDB* lq, 
-				    float x, float y, float z,
-				    float radius,
-				    lqCallBackFunction func,
-				    void* clientQueryState)
-{
-    int partlyOut = 0;
-    int completelyOutside = 
-	(((x + radius) < lq->originx) ||
-	 ((y + radius) < lq->originy) ||
-	 ((z + radius) < lq->originz) ||
-	 ((x - radius) >= lq->originx + lq->sizex) ||
-	 ((y - radius) >= lq->originy + lq->sizey) ||
-	 ((z - radius) >= lq->originz + lq->sizez));
-    int minBinX, minBinY, minBinZ, maxBinX, maxBinY, maxBinZ;
-
-    /* is the sphere completely outside the "super brick"? */
-    if (completelyOutside)
-    {
-	lqMapOverAllOutsideObjects (lq, x, y, z, radius, func,
-				    clientQueryState);
-	return;
-    }
-
-    /* compute min and max bin coordinates for each dimension */
-    minBinX = (int) ((((x - radius) - lq->originx) / lq->sizex) * lq->divx);
-    minBinY = (int) ((((y - radius) - lq->originy) / lq->sizey) * lq->divy);
-    minBinZ = (int) ((((z - radius) - lq->originz) / lq->sizez) * lq->divz);
-    maxBinX = (int) ((((x + radius) - lq->originx) / lq->sizex) * lq->divx);
-    maxBinY = (int) ((((y + radius) - lq->originy) / lq->sizey) * lq->divy);
-    maxBinZ = (int) ((((z + radius) - lq->originz) / lq->sizez) * lq->divz);
-
-    /* clip bin coordinates */
-    if (minBinX < 0)         {partlyOut = 1; minBinX = 0;}
-    if (minBinY < 0)         {partlyOut = 1; minBinY = 0;}
-    if (minBinZ < 0)         {partlyOut = 1; minBinZ = 0;}
-    if (maxBinX >= lq->divx) {partlyOut = 1; maxBinX = lq->divx - 1;}
-    if (maxBinY >= lq->divy) {partlyOut = 1; maxBinY = lq->divy - 1;}
-    if (maxBinZ >= lq->divz) {partlyOut = 1; maxBinZ = lq->divz - 1;}
-
-    /* map function over outside objects if necessary (if clipped) */
-    if (partlyOut) 
-	lqMapOverAllOutsideObjects (lq, x, y, z, radius, func,
-				    clientQueryState);
-    
-    /* map function over objects in bins */
-    lqMapOverAllObjectsInLocalityClipped (lq,
-					  x, y, z,
-					  radius,
-					  func,
-					  clientQueryState,
-					  minBinX, minBinY, minBinZ,
-					  maxBinX, maxBinY, maxBinZ);
-}
-
-
-/* ------------------------------------------------------------------ */
-/* internal helper function */
-
-
-typedef struct lqFindNearestState
-{
-    void* ignoreObject;
-    void* nearestObject;
-    float minDistanceSquared;
-
-} lqFindNearestState;
-
-
-void lqFindNearestHelper (void* clientObject,
-                          float distanceSquared,
-                          void* clientQueryState);
-
-void lqFindNearestHelper (void* clientObject,
-			  float distanceSquared,
-			  void* clientQueryState)
-{
-    lqFindNearestState* fns = (lqFindNearestState*) clientQueryState;
-
-    /* do nothing if this is the "ignoreObject" */
-    if (fns->ignoreObject != clientObject)
-    {
-	/* record this object if it is the nearest one so far */
-	if (fns->minDistanceSquared > distanceSquared)
-	{
-	    fns->nearestObject = clientObject;
-	    fns->minDistanceSquared = distanceSquared;
-	}
-    }
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Search the database to find the object whose key-point is nearest
-   to a given location yet within a given radius.  That is, it finds
-   the object (if any) within a given search sphere which is nearest
-   to the sphere's center.  The ignoreObject argument can be used to
-   exclude an object from consideration (or it can be NULL).  This is
-   useful when looking for the nearest neighbor of an object in the
-   database, since otherwise it would be its own nearest neighbor.
-   The function returns a void* pointer to the nearest object, or
-   NULL if none is found.  */
-
-
-void* lqFindNearestNeighborWithinRadius (lqInternalDB* lq, 
-					 float x, float y, float z,
-					 float radius,
-					 void* ignoreObject)
-{
-    /* initialize search state */
-    lqFindNearestState lqFNS;
-    lqFNS.nearestObject = NULL;
-    lqFNS.ignoreObject = ignoreObject;
-    lqFNS.minDistanceSquared = FLT_MAX;
-
-    /* map search helper function over all objects within radius */
-    lqMapOverAllObjectsInLocality (lq, 
-				   x, y, z,
-				   radius,
-				   lqFindNearestHelper,
-				   &lqFNS);
-
-    /* return nearest object found, if any */
-    return lqFNS.nearestObject;
-}
-
-
-/* ------------------------------------------------------------------ */
-/* internal helper function */
-
-void lqMapOverAllObjectsInBin (lqClientProxy* binProxyList, 
-                               lqCallBackFunction func,
-                               void* clientQueryState);
-
-void lqMapOverAllObjectsInBin (lqClientProxy* binProxyList, 
-			       lqCallBackFunction func,
-			       void* clientQueryState)
-{
-    /* walk down proxy list, applying call-back function to each one */
-    while (binProxyList != NULL)
-    {
-	(*func) (binProxyList->object, 0, clientQueryState);
-	binProxyList = binProxyList->next;
-    }
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Apply a user-supplied function to all objects in the database,
-   regardless of locality (cf lqMapOverAllObjectsInLocality) */
-
-void lqMapOverAllObjects (lqInternalDB* lq, 
-			  lqCallBackFunction func,
-			  void* clientQueryState)
-{
-    int i;
-    int bincount = lq->divx * lq->divy * lq->divz;
-    for (i=0; i<bincount; i++)
-    {
-	lqMapOverAllObjectsInBin (lq->bins[i], func, clientQueryState);
-    }
-    lqMapOverAllObjectsInBin (lq->other, func, clientQueryState);
-}
-
-/* ------------------------------------------------------------------ */
-/* looks at all bins (except "other") finding the min and max bin
-   populations and the average of NON-EMPTY bin populations.  (The
-   average over all bins is a constant (population/bincount))  */
-
-#ifndef NO_LQ_BIN_STATS
-
-void lqgbpsCounter (void* clientObject    USUSED_PARAM,
-                    float distanceSquared USUSED_PARAM,
-                    void* clientQueryState);
-
-void lqgbpsCounter (void* clientObject    USUSED_PARAM,
-                    float distanceSquared USUSED_PARAM,
-                    void* clientQueryState)
-{
-    (*(int*)clientQueryState)++;
-}
-
-void lqGetBinPopulationStats (lqInternalDB* lq,
-                              int* min,
-                              int* max,
-                              float* average)
-{
-    int minPop = INT_MAX;
-    int maxPop = 0;
-    int totalCount = 0;
-    int nonEmptyBinCount = 0;
-    int bincount = lq->divx * lq->divy * lq->divz;
-    int i;
-
-    for (i=0; i<bincount; i++)
-    {
-        /* clear the counter */
-        int objectCount = 0;
-
-        /* apply counting function to each object in bin[i] */
-	lqMapOverAllObjectsInBin (lq->bins[i], lqgbpsCounter, &objectCount);
-
-        /* collect data: max and min population, count objects and non-empty bins */
-        if (objectCount > 0)
-        {
-            nonEmptyBinCount++;
-            if (maxPop < objectCount) maxPop = objectCount;
-            if (minPop > objectCount) minPop = objectCount;
-            totalCount += objectCount;
-        }
-    }
-
-    /* set return values */
-    *min = minPop;
-    *max = maxPop;
-    *average = ((float) totalCount) / ((float) nonEmptyBinCount);
-}
-
-#endif /* NO_LQ_BIN_STATS */
-
-
-/* ------------------------------------------------------------------ */
-/* internal helper function */
-
-
-#define lqRemoveAllObjectsInBin(bin) \
-    while ((bin) != NULL) lqRemoveFromBin ((bin));
-
-
-/* ------------------------------------------------------------------ */
-/* Removes (all proxies for) all objects from all bins */
-
-
-void lqRemoveAllObjects (lqInternalDB* lq)
-{
-    int i;
-    int bincount = lq->divx * lq->divy * lq->divz;
-    for (i=0; i<bincount; i++)
-    {
-	lqRemoveAllObjectsInBin (lq->bins[i]);
-    }
-    lqRemoveAllObjectsInBin (lq->other);
-}
-
-
-/* ------------------------------------------------------------------ */

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/lq.c (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/lq.c)

Modified: rl/branches/persistence2/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/SteeringVehicle.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/SteeringVehicle.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,346 +1,357 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright(C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h"
-
-#include "SteeringVehicle.h"
-
-#include "AbstractMovement.h"
-#include "AiSubsystem.h"
-#include "AiWorld.h" 
-#include "Agent.h"
-#include "Actor.h"
-#include "Creature.h"
-#include "CreatureController.h"
-#include "CreatureControllerManager.h"
-#include "MeshObject.h"
-#include "CreatureController.h"
-#include "PhysicalThing.h"
-#include "GameObjectManager.h"
-#include "RulesMessages.h"
-
-using namespace Ogre;
-using namespace OpenSteer;
-
-namespace rl {
-
-SteeringVehicle::SteeringVehicle(Creature* creature)
-	: _maxForce(1.0f),
-      _maxSpeed(1.0f),
-      mSpeed(1.0f),
-	  mCurrentForce(Vector3::ZERO), 
-	  mCurrentVelocity(Vector3::ZERO),
-	  mForwardVector(Vector3::NEGATIVE_UNIT_Z),
-      mCreatureId(creature->getId()),
-      mController(NULL),
-      mDebugSteer(Vector3::ZERO),
-      mDebugWander(Vector3::ZERO),
-      mDebugAvoidObstacles(Vector3::ZERO)
-{
-    setCreature(creature);
-	initialize();
-
-    mController = CreatureControllerManager::getSingleton().getCreatureController(
-        mCreature);
-    mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_GameObjectsLoaded>(
-                boost::bind(&SteeringVehicle::refetchCreature, this));
-}
-
-SteeringVehicle::~SteeringVehicle()
-{
-}
-
-void SteeringVehicle::resetLocalSpace()
-{
-	setForward(mForwardVector);
-	setSide(localRotateForwardToSide(getForward()));
-    setUp(Vector3::UNIT_Y);
-	Vector3 pos = mCreature->getPosition();
-	setPosition(pos);
-	Vector3 src = mCreature->getOrientation()*Vector3::NEGATIVE_UNIT_Z;
-
-    // regenerate local space(by default: align vehicle's forward axis with
-    // new velocity, but this behavior may be overridden by derived classes.)
-	regenerateOrthonormalBasisUF(src);
-}
-
-void SteeringVehicle::initialize()
-{
-    // reset LocalSpace state
-	resetLocalSpace();
-	
-    // reset SteerLibraryMixin state
-	SimpleVehicle_2::reset();
-
-	setMaxForce(1.0f);   // steering force is clipped to this magnitude
-	setMaxSpeed(1.0f);   // velocity is clipped to this magnitude
-}
-
-
-void SteeringVehicle::addForce(const Ogre::Vector3& force)
-{
-	mCurrentForce += force;
-}
-
-void SteeringVehicle::update(const float currentTime, const float elapsedTime)
-{
-    SimpleVehicle::update(currentTime, elapsedTime);
-
-    Vector3 pos = mCreature->getPosition();
-	setPosition(pos);
-    
-    OgreNewt::Body* body = mCreature->getActor()->getPhysicalThing()->_getBody();
-    //  Get the velocity vector
-	mCurrentVelocity = body->getVelocity();
-	//  enforce speed limit
-	//  newVelocity = newVelocity.truncateLength(maxSpeed());
-	//  update speed
-	setSpeed(mCurrentVelocity.length());
-	Vector3 newVelocity(mCurrentVelocity);
-
-    //  regenerate local space(by default: align vehicle's forward axis with
-    //  new velocity, but this behavior may be overridden by derived classes.)
-    // use future orientation or not??
-    Quaternion orientation(mController->getYaw(), Ogre::Vector3::UNIT_Y);
-    Vector3 newUnitForward = orientation*Vector3::NEGATIVE_UNIT_Z;
-    regenerateOrthonormalBasisUF(newUnitForward);
-
-    // only process if mMovingCreature not NULL
-    if (mController == NULL || mCreature->getQueryFlags() & QUERYFLAG_PLAYER)
-    {
-        mCurrentForce = Vector3::ZERO;
-        return;
-    }
-    
-    // calculate the result of the force    
-    Vector3 result = mCurrentForce;// + mCurrentVelocity;
-    
-    mDebugSteer = mCurrentForce;
-
-    // @todo remove this
-    if (mCreature->getAu() <= 6)
-        mCreature->modifyAu(20,true);
-
-    AbstractMovement* mov_drehen = mController->getMovementFromId(CreatureController::MT_DREHEN);
-    Real vel_drehen(0);
-    Radian max_drehen = Degree(0);
-    if (mov_drehen->calculateBaseVelocity(vel_drehen))
-    {
-        max_drehen = Degree(vel_drehen * 360 * elapsedTime);
-    }
-
-    Ogre::Quaternion future_orientation(mController->getYaw(), Ogre::Vector3::UNIT_Y);
-    Ogre::Vector3 creatureDirection = future_orientation * Ogre::Vector3::NEGATIVE_UNIT_Z;
-    Radian yaw(0);
-    creatureDirection.y = result.y = 0;
-    yaw = creatureDirection.getRotationTo(result, Ogre::Vector3::UNIT_Y).getYaw();
-    if (yaw > Radian(0) && yaw > max_drehen)
-        yaw = max_drehen;
-    if (yaw < Radian(0) && yaw < -max_drehen)
-        yaw = -max_drehen;
-
-    Ogre::Vector3 direction(Ogre::Vector3::ZERO);
-    Ogre::Vector3 rotation(0,yaw.valueRadians(),0);
-    CreatureController::MovementType movement = CreatureController::MT_STEHEN;
-    if (result != Ogre::Vector3::ZERO)
-    {
-        direction.z = -1;
-        movement = CreatureController::MT_GEHEN;
-    }
-
-    mController->setMovement(movement, direction, rotation);
-    LOG_DEBUG(Logger::AI, "SteeringVehicle: mController->setMovement " + 
-        Ogre::StringConverter::toString(movement) + ", "
-        + Ogre::StringConverter::toString(direction) + ", "
-        + Ogre::StringConverter::toString(rotation));
-
-	mCurrentForce = Ogre::Vector3::ZERO;
-}
-
-Vector3 SteeringVehicle::calcWander(const float elapsedTime)
-{
-	Vector3 steering = mForwardVector;
-	
-    steering += Vec3Utils::setYtoZero(steerForWander(elapsedTime/12.0f));
-
-    mDebugWander = steering;
-	return steering;
-}
-
-Vector3 SteeringVehicle::calcSeek(const Vector3& target)
-{
-	Vector3 steering = Vec3Utils::setYtoZero(steerForSeek(target));
-	return steering;
-}
-
-Vector3 SteeringVehicle::calcFlee(const Vector3& target)
-{
-	Vector3 steering = Vec3Utils::setYtoZero(steerForFlee(target));
-	return steering;
-}
-
-Vector3 SteeringVehicle::calcPursuit(Agent* agent)
-{
-    Vector3 dir = Vec3Utils::setYtoZero(steerForPursuit(*agent));
-	return dir;
-}
-
-Vector3 SteeringVehicle::calcAvoidObstacles(const float minTimeToCollision)
-{
-    ObstacleGroup obstacles = getObstacles();
-    Vector3 steering = Vec3Utils::setYtoZero(steerToAvoidObstacles(minTimeToCollision, obstacles));
-    mDebugAvoidObstacles = steering;
-	return steering;
-}
-
-Vector3 SteeringVehicle::calcAvoidNeighbors(const float minTimeToCollision)
-{
-    const float maxRadius = minTimeToCollision * getMaxSpeed() * 2;
-	Vector3 steering = Vec3Utils::setYtoZero(steerToAvoidNeighbors(minTimeToCollision, getNeighbors(maxRadius)));
-	return steering;
-}
-		
-Vector3 SteeringVehicle::calcSteerTargetSpeed(const float targetSpeed)
-{
-	return Vector3();
-}
-
-bool SteeringVehicle::isAhead(Agent* agent, const float threshold)
-{
-    Vector3 target = agent->getControlledCreature()->getPosition();
-	//target.y = position.y;
-	return SimpleVehicle_2::isAhead(target, threshold);
-}
-
-bool SteeringVehicle::needAvoidance(const float minTimeToCollision)
-{
-	Vector3 rVal = calcAvoidNeighbors(minTimeToCollision) + calcAvoidObstacles(minTimeToCollision);
-	if (rVal == Vector3::ZERO)
-	{
-		return false;
-	}
-	return true;
-}
-
-AVGroup SteeringVehicle::getNeighbors(const float maxRadius) const
-{
-	AVGroup neighbors;
-    //std::vector<SimpleVehicle*> neighbors;
-    if(mProximityToken != NULL)
-    {
-        mProximityToken->findNeighbors(getPosition(), maxRadius, neighbors);
-    }
-	//AgentManager::VehicleList list = AgentManager::getSingleton().getNeighbors(NULL);
-	//AgentManager::VehicleList::const_iterator itr = list.begin();
-	//for(; itr != list.end(); ++itr)
-	//{
-	//	if ((*itr) != this)
-	//	{
-	//		group.push_back((*itr));
-	//	}
-	//}
-	return neighbors;
-}
-
-float SteeringVehicle::calcDistance(const Vector3& vec1, const Vector3& vec2)
-{
-	Vector3 vec = vec1-vec2;
-	return vec.length();
-}
-/*
-Vector3 SteeringVehicle::getPosition()
-{
-	return mCreature->getPosition();
-}
-*/
-
-
-const ObstacleGroup& SteeringVehicle::getObstacles() const
-{
-	return AiSubsystem::getSingleton().getWorld()->getSteeringObstacles();
-}
-/*
-Vector3 SteeringVehicle::predictFuturePosition(const float predictionTime) const
-{
-	//return position() +(velocity() * predictionTime);
-	return getVelocity() * predictionTime;
-}
-*/
-Vector3 SteeringVehicle::adjustRawSteeringForce(const Vector3& force)
-{
-    const float maxAdjustedSpeed = 0.2f * getMaxSpeed();
-
-    if ((getSpeed() > maxAdjustedSpeed) ||(force == Vector3::ZERO))
-    {
-        return force;
-    }
-    else
-    {
-        const float range = getSpeed() / maxAdjustedSpeed;
-        // const float cosine = interpolate(pow(range, 6), 1.0f, -1.0f);
-        // const float cosine = interpolate(pow(range, 10), 1.0f, -1.0f);
-        // const float cosine = interpolate(pow(range, 20), 1.0f, -1.0f);
-        // const float cosine = interpolate(pow(range, 100), 1.0f, -1.0f);
-        // const float cosine = interpolate(pow(range, 50), 1.0f, -1.0f);
-        const float cosine = interpolate(pow(range, 20), 1.0f, -1.0f);
-        return limitMaxDeviationAngle(force, cosine, getForward());
-    }
-}
-
-// methods from debugvisualisable
-DebugVisualisableFlag SteeringVehicle::getFlag() const
-{
-    return DVF_BOT;
-}
-
-void SteeringVehicle::updatePrimitive()
-{
-    if (mSceneNode->getParent() == NULL)
-    {
-        mCreature->getActor()->_getSceneNode()->addChild(mSceneNode);
-    }
-
-    LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
-    lineSet->clear();
-    
-    if (mDebugSteer != Vector3::ZERO)
-    {
-        lineSet->addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugSteer.normalisedCopy()*0.5, ColourValue::Black);
-        mDebugSteer = Vector3::ZERO;
-    }
-    if (mDebugWander != Vector3::ZERO)
-    {
-        lineSet->addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugWander.normalisedCopy()*0.5, ColourValue::Green);
-        mDebugWander = Vector3::ZERO;
-    }
-    if (mDebugAvoidObstacles != Vector3::ZERO)
-    {
-        lineSet->addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugAvoidObstacles.normalisedCopy()*0.5, ColourValue::Red);
-        mDebugAvoidObstacles = Vector3::ZERO;
-    }
-}
-
-void SteeringVehicle::doCreatePrimitive()
-{
-    mPrimitive = new LineSetPrimitive();
-}
-
-bool SteeringVehicle::refetchCreature()
-{
-    mCreature = static_cast<Creature*>(GameObjectManager::getSingleton().getGameObject(mCreatureId));
-    return false;
-}
-
-} // namespace rl
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright(C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h"
+
+#include "SteeringVehicle.h"
+
+#include "AbstractMovement.h"
+#include "AiSubsystem.h"
+#include "AiWorld.h" 
+#include "Agent.h"
+#include "Actor.h"
+#include "Creature.h"
+#include "CreatureController.h"
+#include "CreatureControllerManager.h"
+#include "MeshObject.h"
+#include "CreatureController.h"
+#include "PhysicalThing.h"
+#include "GameObjectManager.h"
+#include "RulesMessages.h"
+
+using namespace Ogre;
+using namespace OpenSteer;
+
+namespace rl {
+
+SteeringVehicle::SteeringVehicle(Creature* creature)
+	: _maxForce(1.0f),
+      _maxSpeed(1.0f),
+      mSpeed(1.0f),
+	  mCurrentForce(Vector3::ZERO), 
+	  mCurrentVelocity(Vector3::ZERO),
+	  mForwardVector(Vector3::NEGATIVE_UNIT_Z),
+      mCreatureId(creature->getId()),
+      mController(NULL),
+      mDebugSteer(Vector3::ZERO),
+      mDebugWander(Vector3::ZERO),
+      mDebugAvoidObstacles(Vector3::ZERO)
+{
+    setCreature(creature);
+	initialize();
+
+    mController = CreatureControllerManager::getSingleton().getCreatureController(
+        mCreature);
+    std::ostringstream oss;
+    oss << " Creature '" << mCreature->getName() << "' controlled by SteeringVehicle.";
+    LOG_DEBUG(Logger::RULES, oss.str());
+    mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler<MessageType_GameObjectsLoaded>(
+                boost::bind(&SteeringVehicle::refetchCreature, this));
+}
+
+SteeringVehicle::~SteeringVehicle()
+{
+    std::ostringstream oss;
+    oss << " Creature '" << mCreature->getName() << "' not controlled by SteeringVehicle any more.";
+    LOG_DEBUG(Logger::RULES, oss.str());
+}
+
+void SteeringVehicle::resetLocalSpace()
+{
+	setForward(mForwardVector);
+	setSide(localRotateForwardToSide(getForward()));
+    setUp(Vector3::UNIT_Y);
+	Vector3 pos = mCreature->getPosition();
+	setPosition(pos);
+	Vector3 src = mCreature->getOrientation()*Vector3::NEGATIVE_UNIT_Z;
+
+    // regenerate local space(by default: align vehicle's forward axis with
+    // new velocity, but this behavior may be overridden by derived classes.)
+	regenerateOrthonormalBasisUF(src);
+}
+
+void SteeringVehicle::initialize()
+{
+    // reset LocalSpace state
+	resetLocalSpace();
+	
+    // reset SteerLibraryMixin state
+	SimpleVehicle_2::reset();
+
+	setMaxForce(1.0f);   // steering force is clipped to this magnitude
+	setMaxSpeed(1.0f);   // velocity is clipped to this magnitude
+}
+
+
+void SteeringVehicle::addForce(const Ogre::Vector3& force)
+{
+	mCurrentForce += force;
+}
+
+void SteeringVehicle::update(const float currentTime, const float elapsedTime)
+{
+    SimpleVehicle::update(currentTime, elapsedTime);
+
+    Vector3 pos = mCreature->getPosition();
+	setPosition(pos);
+    
+    OgreNewt::Body* body = mCreature->getActor()->getPhysicalThing()->_getBody();
+    //  Get the velocity vector
+	mCurrentVelocity = body->getVelocity();
+	//  enforce speed limit
+	//  newVelocity = newVelocity.truncateLength(maxSpeed());
+	//  update speed
+	setSpeed(mCurrentVelocity.length());
+	Vector3 newVelocity(mCurrentVelocity);
+
+    //  regenerate local space(by default: align vehicle's forward axis with
+    //  new velocity, but this behavior may be overridden by derived classes.)
+    // use future orientation or not??
+    Quaternion orientation(mController->getYaw(), Ogre::Vector3::UNIT_Y);
+    Vector3 newUnitForward = orientation*Vector3::NEGATIVE_UNIT_Z;
+    regenerateOrthonormalBasisUF(newUnitForward);
+
+    // only process if mMovingCreature not NULL
+    if (mController == NULL || mCreature->getQueryFlags() & QUERYFLAG_PLAYER)
+    {
+        mCurrentForce = Vector3::ZERO;
+        return;
+    }
+    
+    // calculate the result of the force    
+    Vector3 result = mCurrentForce;// + mCurrentVelocity;
+    
+    mDebugSteer = mCurrentForce;
+
+    // @todo remove this
+    if (mCreature->getAu() <= 6)
+        mCreature->modifyAu(20,true);
+
+    AbstractMovement* mov_drehen = mController->getMovementFromId(CreatureController::MT_DREHEN);
+    Real vel_drehen(0);
+    Radian max_drehen = Degree(0);
+    if (mov_drehen->calculateBaseVelocity(vel_drehen))
+    {
+        max_drehen = Degree(vel_drehen * 360 * elapsedTime);
+    }
+
+    Ogre::Quaternion future_orientation(mController->getYaw(), Ogre::Vector3::UNIT_Y);
+    Ogre::Vector3 creatureDirection = future_orientation * Ogre::Vector3::NEGATIVE_UNIT_Z;
+    Radian yaw(0);
+    creatureDirection.y = result.y = 0;
+    yaw = creatureDirection.getRotationTo(result, Ogre::Vector3::UNIT_Y).getYaw();
+    if (yaw > Radian(0) && yaw > max_drehen)
+        yaw = max_drehen;
+    if (yaw < Radian(0) && yaw < -max_drehen)
+        yaw = -max_drehen;
+
+    Ogre::Vector3 direction(Ogre::Vector3::ZERO);
+    Ogre::Vector3 rotation(0,yaw.valueRadians(),0);
+    CreatureController::MovementType movement = CreatureController::MT_STEHEN;
+    if (result != Ogre::Vector3::ZERO)
+    {
+        direction.z = -1;
+        movement = CreatureController::MT_GEHEN;
+    }
+
+    mController->setMovement(movement, direction, rotation);
+    LOG_DEBUG(Logger::AI, "SteeringVehicle: mController->setMovement " + 
+        Ogre::StringConverter::toString(movement) + ", "
+        + Ogre::StringConverter::toString(direction) + ", "
+        + Ogre::StringConverter::toString(rotation));
+
+	mCurrentForce = Ogre::Vector3::ZERO;
+}
+
+Vector3 SteeringVehicle::calcWander(const float elapsedTime)
+{
+	Vector3 steering = mForwardVector;
+	
+    steering += Vec3Utils::setYtoZero(steerForWander(elapsedTime/12.0f));
+
+    mDebugWander = steering;
+	return steering;
+}
+
+Vector3 SteeringVehicle::calcSeek(const Vector3& target)
+{
+	Vector3 steering = Vec3Utils::setYtoZero(steerForSeek(target));
+	return steering;
+}
+
+Vector3 SteeringVehicle::calcFlee(const Vector3& target)
+{
+	Vector3 steering = Vec3Utils::setYtoZero(steerForFlee(target));
+	return steering;
+}
+
+Vector3 SteeringVehicle::calcPursuit(Agent* agent)
+{
+    Vector3 dir = Vec3Utils::setYtoZero(steerForPursuit(*agent));
+	return dir;
+}
+
+Vector3 SteeringVehicle::calcAvoidObstacles(const float minTimeToCollision)
+{
+    ObstacleGroup obstacles = getObstacles();
+    Vector3 steering = Vec3Utils::setYtoZero(steerToAvoidObstacles(minTimeToCollision, obstacles));
+    mDebugAvoidObstacles = steering;
+	return steering;
+}
+
+Vector3 SteeringVehicle::calcAvoidNeighbors(const float minTimeToCollision)
+{
+    const float maxRadius = minTimeToCollision * getMaxSpeed() * 2;
+	Vector3 steering = Vec3Utils::setYtoZero(steerToAvoidNeighbors(minTimeToCollision, getNeighbors(maxRadius)));
+	return steering;
+}
+		
+Vector3 SteeringVehicle::calcSteerTargetSpeed(const float targetSpeed)
+{
+	return Vector3();
+}
+
+bool SteeringVehicle::isAhead(Agent* agent, const float threshold)
+{
+    Vector3 target = agent->getControlledCreature()->getPosition();
+    //target.y = position.y;
+    return SimpleVehicle_2::isAhead(target, threshold);
+}
+
+bool SteeringVehicle::isAhead(const Vector3& position, const float threshold)
+{
+    return SimpleVehicle_2::isAhead(position, threshold);
+}
+
+bool SteeringVehicle::needAvoidance(const float minTimeToCollision)
+{
+	Vector3 rVal = calcAvoidNeighbors(minTimeToCollision) + calcAvoidObstacles(minTimeToCollision);
+	if (rVal == Vector3::ZERO)
+	{
+		return false;
+	}
+	return true;
+}
+
+AVGroup SteeringVehicle::getNeighbors(const float maxRadius) const
+{
+	AVGroup neighbors;
+    //std::vector<SimpleVehicle*> neighbors;
+    if(mProximityToken != NULL)
+    {
+        mProximityToken->findNeighbors(getPosition(), maxRadius, neighbors);
+    }
+	//AgentManager::VehicleList list = AgentManager::getSingleton().getNeighbors(NULL);
+	//AgentManager::VehicleList::const_iterator itr = list.begin();
+	//for(; itr != list.end(); ++itr)
+	//{
+	//	if ((*itr) != this)
+	//	{
+	//		group.push_back((*itr));
+	//	}
+	//}
+	return neighbors;
+}
+
+float SteeringVehicle::calcDistance(const Vector3& vec1, const Vector3& vec2)
+{
+	Vector3 vec = vec1-vec2;
+	return vec.length();
+}
+/*
+Vector3 SteeringVehicle::getPosition()
+{
+	return mCreature->getPosition();
+}
+*/
+
+
+const ObstacleGroup& SteeringVehicle::getObstacles() const
+{
+	return AiSubsystem::getSingleton().getWorld()->getSteeringObstacles();
+}
+/*
+Vector3 SteeringVehicle::predictFuturePosition(const float predictionTime) const
+{
+	//return position() +(velocity() * predictionTime);
+	return getVelocity() * predictionTime;
+}
+*/
+Vector3 SteeringVehicle::adjustRawSteeringForce(const Vector3& force)
+{
+    const float maxAdjustedSpeed = 0.2f * getMaxSpeed();
+
+    if ((getSpeed() > maxAdjustedSpeed) ||(force == Vector3::ZERO))
+    {
+        return force;
+    }
+    else
+    {
+        const float range = getSpeed() / maxAdjustedSpeed;
+        // const float cosine = interpolate(pow(range, 6), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 10), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 20), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 100), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 50), 1.0f, -1.0f);
+        const float cosine = interpolate(pow(range, 20), 1.0f, -1.0f);
+        return limitMaxDeviationAngle(force, cosine, getForward());
+    }
+}
+
+// methods from debugvisualisable
+DebugVisualisableFlag SteeringVehicle::getFlag() const
+{
+    return DVF_BOT;
+}
+
+void SteeringVehicle::updatePrimitive()
+{
+    if (mSceneNode->getParent() == NULL)
+    {
+        mCreature->getActor()->_getSceneNode()->addChild(mSceneNode);
+    }
+
+    LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
+    lineSet->clear();
+    
+    if (mDebugSteer != Vector3::ZERO)
+    {
+        lineSet->addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugSteer.normalisedCopy()*0.5, ColourValue::Black);
+        mDebugSteer = Vector3::ZERO;
+    }
+    if (mDebugWander != Vector3::ZERO)
+    {
+        lineSet->addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugWander.normalisedCopy()*0.5, ColourValue::Green);
+        mDebugWander = Vector3::ZERO;
+    }
+    if (mDebugAvoidObstacles != Vector3::ZERO)
+    {
+        lineSet->addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugAvoidObstacles.normalisedCopy()*0.5, ColourValue::Red);
+        mDebugAvoidObstacles = Vector3::ZERO;
+    }
+}
+
+void SteeringVehicle::doCreatePrimitive()
+{
+    mPrimitive = new LineSetPrimitive();
+}
+
+bool SteeringVehicle::refetchCreature()
+{
+    mCreature = static_cast<Creature*>(GameObjectManager::getSingleton().getGameObject(mCreatureId));
+    return false;
+}
+
+} // namespace rl

Copied: rl/branches/persistence2/engine/common/RlCommon2008.vcproj (from rev 4878, rl/trunk/engine/common/RlCommon2008.vcproj)

Modified: rl/branches/persistence2/engine/common/include/FixRubyHeaders.h
===================================================================
--- rl/branches/persistence2/engine/common/include/FixRubyHeaders.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/common/include/FixRubyHeaders.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -34,6 +34,7 @@
 #undef write
 #undef max
 #undef min
+#undef check
 
 #undef PACKAGE_VERSION
 #undef PACKAGE_STRING

Modified: rl/branches/persistence2/engine/common/src/ConfigFile.cpp
===================================================================
--- rl/branches/persistence2/engine/common/src/ConfigFile.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/common/src/ConfigFile.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -19,6 +19,12 @@
 #include "ConfigFile.h"
 #include "Exception.h"
 
+#ifdef __APPLE__
+#include <Ogre/OgreMemoryAllocatorConfig.h>
+#else
+#include <OgreMemoryAllocatorConfig.h>
+#endif
+
 using namespace Ogre;
 using namespace std;
 
@@ -92,7 +98,7 @@
     void ConfigFile::addSection(const Ogre::String& section, const Ogre::NameValuePairList& settings)
     {
         // Create new section
-        mSettings[section] = new SettingsMultiMap();
+        mSettings[section] = OGRE_NEW_T(SettingsMultiMap, MEMCATEGORY_GENERAL);
         // Insert values from the settings list
         mSettings[section]->insert(settings.begin(), settings.end());
     }

Modified: rl/branches/persistence2/engine/core/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/core/CMakeLists.txt	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/CMakeLists.txt	2009-04-01 20:08:44 UTC (rev 4879)
@@ -3,6 +3,7 @@
 ${CMAKE_CURRENT_SOURCE_DIR}/include/fmod4driver
 ${CMAKE_CURRENT_SOURCE_DIR}/include/nulldriver
 ${RL_COMMON_INCLUDE_DIR}
+${XERCESC_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR}
@@ -52,6 +53,7 @@
 src/PhysicsGenericContactCallback.cpp
 src/PhysicsManager.cpp
 src/PhysicsMaterialRaycast.cpp
+src/PhysicsRagDoll.cpp
 src/PlayAnimationJob.cpp
 src/PlaySoundJob.cpp
 src/PolynomicSoundFadeFunctor.cpp

Modified: rl/branches/persistence2/engine/core/RlCore2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/core/RlCore2005.vcproj	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/RlCore2005.vcproj	2009-04-01 20:08:44 UTC (rev 4879)
@@ -48,7 +48,7 @@
 				Name="VCCLCompilerTool"
 				AdditionalOptions="-Zm130"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\include;.\include\nulldriver;.\include\fmod4driver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt_ngt\inc;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK2\sdk\;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\meshmagick\include;..\..\dependencies\FMOD4\api\inc"
+				AdditionalIncludeDirectories=".\include;.\include\nulldriver;.\include\fmod4driver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\inc;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\meshmagick\include;..\..\dependencies\FMOD4\api\inc"
 				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS,_DEBUG,WIN32,RLCORE_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -90,7 +90,7 @@
 				OutputFile="./lib/$(ConfigurationName)/RlCore.dll"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\ogrenewt_ngt\lib\;..\..\dependencies\NewtonSDK2\sdk\x32\dll_vs7;..\..\dependencies\meshmagick\lib;..\..\dependencies\FMOD4\api\lib"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\ogrenewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7;..\..\dependencies\meshmagick\lib;..\..\dependencies\FMOD4\api\lib"
 				IgnoreDefaultLibraryNames=""
 				TypeLibraryFile="$(OutDir)\RlCore.lib"
 				GenerateDebugInformation="true"
@@ -163,7 +163,7 @@
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories=".\include;.\include\nulldriver;.\include\fmod4driver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\meshmagick\include;..\..\dependencies\FMOD4\api\inc"
+				AdditionalIncludeDirectories=".\include;.\include\nulldriver;.\include\fmod4driver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\inc;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\meshmagick\include;..\..\dependencies\FMOD4\api\inc"
 				PreprocessorDefinitions="WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLCORE_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				StringPooling="false"
 				ExceptionHandling="1"
@@ -202,7 +202,7 @@
 				OutputFile="./lib/$(ConfigurationName)/RlCore.dll"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\meshmagick\lib;..\..\dependencies\FMOD4\api\lib"
+				AdditionalLibraryDirectories="&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\ogrenewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7;..\..\dependencies\meshmagick\lib;..\..\dependencies\FMOD4\api\lib"
 				TypeLibraryFile="$(OutDir)\RlCore.lib"
 				ProgramDatabaseFile=""
 				SubSystem="2"
@@ -544,6 +544,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\PhysicsRagDoll.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\PlayAnimationJob.h"
 				>
 			</File>
@@ -893,6 +897,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\PhysicsRagDoll.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\PlayAnimationJob.cpp"
 				>
 			</File>

Copied: rl/branches/persistence2/engine/core/RlCore2008.vcproj (from rev 4878, rl/trunk/engine/core/RlCore2008.vcproj)

Modified: rl/branches/persistence2/engine/core/include/PhysicalThing.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicalThing.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/include/PhysicalThing.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -31,6 +31,7 @@
 
 	class Actor;
 	class MeshObject;
+    class PhysicsRagDoll;
 
 	/** PhysicalThing contains the physical representation of an ActorControlledObject.
 	 * It utilizes a default collision primitiv derived from the default mesh, but it
@@ -129,7 +130,7 @@
         Ogre::Real getMass() const;
         void setMass(Ogre::Real mass);
 
-		void createPhysicsProxy(Ogre::SceneNode* node);
+		void createPhysicsProxy();
         void updatePhysicsProxy();
 		void destroyPhysicsProxy();
 
@@ -172,13 +173,20 @@
          */
         const OgreNewt::MaterialID* getMaterialID() const;
 
+        //! retrieve the ragdoll
+        PhysicsRagDoll* getRagDoll() { return mRagDoll; }
+
+        //! create a RagDoll, it is destroyed with
+        void createPhysicsProxy_RagDoll();
+
+/*
     protected:
 		void prepareUserControl(OgreNewt::MaterialID* material);
         void unprepareUserControl();
-
+*/
     private:
         Actor* mActor;
-		//! The newton body object this physical thing works with
+		//! The newton body object this physical thing works with, if it has a ragdoll, this is the main-body!
         OgreNewt::Body* mBody;
 		//! an upjoint to keep the body from falling over
         OgreNewt::BasicJoints::UpVector* mUpVectorJoint;
@@ -197,7 +205,7 @@
 
 		//! typedefinition for easing variable declaration
         typedef std::map<Ogre::String, OgreNewt::CollisionPtr> CollisionMap;
-		//! ??
+		//! Cache for collisions created by fitToPose
         CollisionMap mPoseCollisions;
 
 		//! the objects mass
@@ -219,6 +227,9 @@
 		void setBody(OgreNewt::Body* body);
 
         OgreNewt::CollisionPtr createCollision(PhysicalObject* po, Ogre::Vector3& inertia) const;
+
+        //! the ragdoll, if this thing is controlled by a ragdoll
+        PhysicsRagDoll* mRagDoll;
 	};
 }
 

Modified: rl/branches/persistence2/engine/core/include/PhysicsManager.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicsManager.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/include/PhysicsManager.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -110,8 +110,13 @@
 		/**
 		 * Erschafft den entg?ltigen Physikproxy
 		 */
-		void createPhysicsProxy(PhysicalThing* pt, Ogre::SceneNode* node);
+		void createPhysicsProxy(PhysicalThing* pt);
 
+        /**
+         * Creates a ragdoll as physics proxy
+         */
+        void createPhysicsProxy_RagDoll(PhysicalThing* pt);
+
 		/**
 		 * Removes the physics proxy
 		 * @param pt the physics proxy wrapper; is not deleted
@@ -364,7 +369,7 @@
         PhysicsGenericContactCallback* mGenericCallback;
 
 #ifdef _DEBUG
-        static void _CDECL PhysicsManager::newtonPerBodyLogProperties( const NewtonBody* body );
+        void logBodyProperties( const OgreNewt::Body* body );
 #endif
 
     };

Copied: rl/branches/persistence2/engine/core/include/PhysicsRagDoll.h (from rev 4878, rl/trunk/engine/core/include/PhysicsRagDoll.h)

Modified: rl/branches/persistence2/engine/core/src/Actor.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/Actor.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/src/Actor.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -125,6 +125,8 @@
     void Actor::setPhysicalThing( PhysicalThing* pt )
     {
         mPhysicalThing = pt;
+        if( mPhysicalThing != NULL )
+            mPhysicalThing->_setActor(this);
     }
 
     Ogre::Real Actor::getRenderingDistance() const
@@ -815,7 +817,7 @@
         // Physikverkn?pfung anpassen
         if (mPhysicalThing && mActorControlledObject)
         {
-            PhysicsManager::getSingleton().createPhysicsProxy(mPhysicalThing, mSceneNode);
+            PhysicsManager::getSingleton().createPhysicsProxy(mPhysicalThing);
 
             // Knochen angegeben und handelt sich um ein Mesh
             if( physicsBone.length() > 0 && mActorControlledObject->isMeshObject())

Modified: rl/branches/persistence2/engine/core/src/ActorManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/ActorManager.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/src/ActorManager.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -296,7 +296,7 @@
             PhysicalThing* pt = PhysicsManager::getSingleton()
                 .createPhysicalThing(GT_SPHERE, co,
                 0.001f, true);
-            PhysicsManager::getSingleton().createPhysicsProxy(pt, NULL);
+            PhysicsManager::getSingleton().createPhysicsProxy(pt);
             pt->_getBody()->setMaterialGroupID(
                 PhysicsManager::getSingleton().createMaterialID("camera"));
             actor = new Actor(uniquename, co, pt);

Modified: rl/branches/persistence2/engine/core/src/AnimationManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/AnimationManager.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/src/AnimationManager.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -331,7 +331,9 @@
            AnimationManager::stopAnimation(anim);
            ScriptWrapper::getSingleton().deleted( anim );
            delete anim;
-           mFadeAnimSet.erase(it++);
+           FadeAnimSet::iterator toDelete = it;
+           it++;
+           mFadeAnimSet.erase(toDelete);
         }
         else
             ++it;

Modified: rl/branches/persistence2/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/ConfigurationManager.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/src/ConfigurationManager.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -325,7 +325,7 @@
 
     void ConfigurationManager::saveConfig() const
     {
-        ConfigFile* cfgfile = new ConfigFile();
+        ConfigFile* cfgfile = OGRE_NEW ConfigFile();
 
         for (SectionMap::const_iterator it = mSettings.begin(); it != mSettings.end(); ++it)
         {
@@ -338,7 +338,7 @@
         cfgfile->save(Ogre::String(::getenv("HOME")) + "/.rastullah/" + mRastullahCfgFile);
 #       endif
 
-        delete cfgfile;
+        OGRE_DELETE cfgfile;
     }
 
     Logger::LogLevel ConfigurationManager::getLogLevel() const

Modified: rl/branches/persistence2/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicalThing.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/src/PhysicalThing.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -24,6 +24,7 @@
 #include "MathUtil.h"
 #include "MeshObject.h"
 #include "PhysicalObject.h"
+#include "PhysicsRagDoll.h"
 
 using namespace Ogre;
 using namespace OgreNewt;
@@ -46,15 +47,14 @@
 		mPhysicalObject(po),
 		mMass(mass),
 		mHullModifier(hullModifier),
-        mPhysicsController(NULL)
+        mPhysicsController(NULL),
+        mRagDoll(NULL)
 	{
 	}
 
     PhysicalThing::~PhysicalThing()
 	{
-                mPoseCollisions.clear();
-		delete mBody;
-		mBody = NULL;
+        destroyPhysicsProxy();
     }
 
     Ogre::Vector3 PhysicalThing::getPosition() const
@@ -75,7 +75,10 @@
         Quaternion quat;
         Vector3 oldPos;
         mBody->getPositionOrientation(oldPos, quat);
-        mBody->setPositionOrientation(pos, quat);
+        if( mRagDoll )
+            mRagDoll->setPositionOrientation(pos, quat);
+        else
+            mBody->setPositionOrientation(pos, quat);
     }
 
     Ogre::Quaternion PhysicalThing::getOrientation() const
@@ -96,7 +99,10 @@
         Quaternion oldOrientation;
         Vector3 pos;
         mBody->getPositionOrientation(pos, oldOrientation);
-        mBody->setPositionOrientation(pos, orientation);
+        if( mRagDoll )
+            mRagDoll->setPositionOrientation(pos, orientation);
+        else
+            mBody->setPositionOrientation(pos, orientation);
     }
 
     void PhysicalThing::setVelocity(const Vector3& vel)
@@ -129,9 +135,18 @@
     {
 		if (mBody && mActor)
 		{
-			mBody->setPositionOrientation(
-				mActor->_getSceneNode()->_getDerivedPosition(),
-				mActor->_getSceneNode()->_getDerivedOrientation());
+            if( mRagDoll )
+            {
+                mRagDoll->setPositionOrientation(
+		    		mActor->_getSceneNode()->_getDerivedPosition(),
+				    mActor->_getSceneNode()->_getDerivedOrientation());
+            }
+            else
+            {
+			    mBody->setPositionOrientation(
+		    		mActor->_getSceneNode()->_getDerivedPosition(),
+				    mActor->_getSceneNode()->_getDerivedOrientation());
+            }
 			mActor->_update(Actor::UF_ALL & ~Actor::UF_PHYSICAL_THING);
 		}
     }
@@ -145,7 +160,10 @@
 
     void PhysicalThing::_attachToSceneNode(Ogre::SceneNode* node)
     {
-        mBody->attachNode(node);
+        if( mRagDoll )
+            mRagDoll->setSceneNode( node );
+        else
+            mBody->attachNode(node);
     }
 
     void PhysicalThing::_attachToBone(MeshObject* object, const std::string& boneName )
@@ -162,6 +180,9 @@
 
     void PhysicalThing::setUpConstraint(const Vector3& upVector)
     {
+        RlAssert(!mRagDoll,
+           "PhysicalThing::setUpConstraint: using UpConstraint not possible while a RagDoll controls this PhysicalThing!");
+
         if (!mUpVectorJoint)
         {
             mUpVectorJoint = new OgreNewt::BasicJoints::UpVector(
@@ -185,8 +206,11 @@
 
     void PhysicalThing::clearUpConstraint()
     {
-        delete mUpVectorJoint;
-        mUpVectorJoint = NULL;
+        if( mUpVectorJoint )
+        {
+            delete mUpVectorJoint;
+            mUpVectorJoint = NULL;
+        }
     }
 
     void PhysicalThing::onApplyForceAndTorque(float timestep)
@@ -210,10 +234,16 @@
 
     void PhysicalThing::setMass(Ogre::Real mass)
     {
-        Vector3 inertia;
-        mBody->getMassMatrix(mMass, inertia);
+        // effect on ragdoll?
+
+        if( mBody && !mRagDoll )
+        {
+            Vector3 inertia;
+            mBody->getMassMatrix(mMass, inertia);
+            mMass = mass;
+            mBody->setMassMatrix(mass, inertia);
+        }
         mMass = mass;
-        mBody->setMassMatrix(mass, inertia);
     }
 
     void PhysicalThing::setGravityOverride(bool override, const Vector3& gravity)
@@ -233,7 +263,9 @@
         entity->_updateAnimation();
         Node* node = entity->getParentNode();
         RlAssert(node,
-            "Actor has to be placed in the scene in order to update its collision hull.");
+            "PhysicalThing::updateCollisionHull: Actor has to be placed in the scene in order to update its collision hull.");
+        RlAssert(!mRagDoll,
+            "PhysicalThing::updateCollisionHull: PhysicalThing must not be controlled by a RagDoll in order to update its collision hull.");
 
 
         Vector3 position;
@@ -328,6 +360,9 @@
 
     void PhysicalThing::fitToPose(const Ogre::String& animName)
     {
+        if( mRagDoll )
+            Throw(IllegalArgumentException, "PhysicalThing::fitToPose cannot be used while the PhysicalThing is controlled by a RagDoll!");
+
 		CollisionPtr coll;
 
         if (mPhysicalObject->isMeshObject())
@@ -385,12 +420,27 @@
 
 	void PhysicalThing::destroyPhysicsProxy()
 	{
-		delete mBody;
-		mBody = NULL;
+        setPhysicsController(NULL);
+        clearUpConstraint();
+        mPoseCollisions.clear();
+        if( mRagDoll )
+        {
+            delete mRagDoll;
+            mRagDoll = NULL;
+            mBody = NULL;
+        }
+        else if( mBody )
+        {
+		    delete mBody;
+		    mBody = NULL;
+        }
+
 	}
 
-    void PhysicalThing::createPhysicsProxy(SceneNode* node)
+    void PhysicalThing::createPhysicsProxy()
 	{
+        RlAssert( !mRagDoll,
+                "PhysicalThing::createPhysicsProxy: cannot create physics proxy while the PhysicalThing is controlled by a RagDoll!");
 		if (!mBody)
 		{
             Vector3 inertia;
@@ -409,6 +459,13 @@
 			body->setCustomForceAndTorqueCallback(PhysicsManager::genericForceCallback);
 
             setBody(body);
+
+            if( mActor )
+            {
+                if( mActor->_getSceneNode() )
+                    _attachToSceneNode(mActor->_getSceneNode());
+
+            }
         }
 	}
 
@@ -450,7 +507,7 @@
 
     void PhysicalThing::updatePhysicsProxy()
     {
-        if (mBody)
+        if (mBody && !mRagDoll)
         {
             mPoseCollisions.clear();
 
@@ -498,7 +555,10 @@
 
     void PhysicalThing::setMaterialID(const OgreNewt::MaterialID* materialid)
     {
-        mBody->setMaterialGroupID(materialid);
+        if( mRagDoll )
+            mRagDoll->setMaterialID(materialid);
+        else
+            mBody->setMaterialGroupID(materialid);
     }
 
     const OgreNewt::MaterialID* PhysicalThing::getMaterialID() const
@@ -506,4 +566,37 @@
         return mBody->getMaterialGroupID();
     }
 
+
+    void PhysicalThing::createPhysicsProxy_RagDoll()
+    {
+        if(!mRagDoll)
+        {
+            if( mBody )
+            {
+                Throw(OperationNotSupportedException, "PhysicalThing::createPhysicsProxy_RagDoll: there is already a body connected to this PhysicalThing!");
+            }
+
+
+
+            if( !mPhysicalObject->isMeshObject() )
+                Throw(IllegalArgumentException, "PhysicalThing::createPhysicsProxy_RagDoll needs a Mesh-Actor as argument!");
+            MeshObject* meshObj = static_cast<MeshObject*>(mPhysicalObject);
+
+            String ragdollRes = meshObj->getMeshName();
+            ragdollRes = ragdollRes.substr(0,ragdollRes.find(".mesh")) + "_ragdoll.xml";
+            mRagDoll = new PhysicsRagDoll(ragdollRes, mActor);
+            mBody = NULL;
+            if( mRagDoll->getRootBone() )
+                mBody = mRagDoll->getRootBone()->getBody();
+
+            if( !mBody )
+            {
+                delete mRagDoll;
+                mRagDoll = NULL;
+                Throw(NullPointerException, "Error creating the ragdoll!");
+            }
+        }
+    }
+
 }
+

Modified: rl/branches/persistence2/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicsManager.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/src/PhysicsManager.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -171,13 +171,10 @@
             if( mDebugMode )
             {
                 LOG_DEBUG(Logger::CORE, "\tNewtonBodyLog: &Body  Position  Orientation  Velocity  "\
-                    "Omega  Force  Torque  NewtonBodyGetSleepState  NewtonBodyGetAutoFreeze  "\
-                    "NewtonBodyGetContinuousCollisionMode  ( invMass  invIxx  invIyy  invIzz )");
+                    "Omega  Force  Torque NewtonBodyGetContinuousCollisionMode mass inertia");
                 if( Logger::getSingleton().getLogDetail() <= Logger::LL_DEBUG )
-                for( const NewtonBody* body = NewtonWorldGetFirstBody(mWorld->getNewtonWorld());
-                     body != NULL;
-                     body = NewtonWorldGetNextBody(mWorld->getNewtonWorld(), body)  )
-                    newtonPerBodyLogProperties(body);
+                for( OgreNewt::Body* body = mWorld->getFirstBody(); body != NULL; body = body->getNext() )
+                    logBodyProperties(body);
             }
 #endif
         }
@@ -193,12 +190,9 @@
             if( mDebugMode )
             {
                 LOG_DEBUG(Logger::CORE, "\tNewtonBodyLog: &Body  Position  Orientation  Velocity  "\
-                    "Omega  Force  Torque  NewtonBodyGetSleepState  NewtonBodyGetAutoFreeze  "\
-                    "NewtonBodyGetContinuousCollisionMode  ( invMass  invIxx  invIyy  invIzz )");
-                for( const NewtonBody* body = NewtonWorldGetFirstBody(mWorld->getNewtonWorld());
-                     body != NULL;
-                     body = NewtonWorldGetNextBody(mWorld->getNewtonWorld(), body)  )
-                    newtonPerBodyLogProperties(body);
+                    "Omega  Force  Torque NewtonBodyGetContinuousCollisionMode mass inertia");
+                for( OgreNewt::Body* body = mWorld->getFirstBody(); body != NULL; body = body->getNext() )
+                    logBodyProperties(body);
             }
 #endif
         }
@@ -215,28 +209,22 @@
     }
 
 #ifdef _DEBUG
-    void _CDECL PhysicsManager::newtonPerBodyLogProperties( const NewtonBody* body )
+    void PhysicsManager::logBodyProperties( const OgreNewt::Body* body )
     {
         std::ostringstream oss;
         Quaternion orient;
         Vector3 pos;
-        float matrix[16];
-        NewtonBodyGetMatrix(body,matrix);
-        OgreNewt::Converters::MatrixToQuatPos(matrix,orient,pos);
-        Vector3 force;
-        NewtonBodyGetForce(body, &force.x);
-        Vector3 torque;
-        NewtonBodyGetTorque(body, &torque.x);
-        Vector3 omega;
-        NewtonBodyGetOmega(body, &omega.x);
-        Vector3 velocity;
-        NewtonBodyGetVelocity(body, &velocity.x);
-        Vector3 invMass, invIxx, invIyy, invIzz;
-        NewtonBodyGetInvMass(body, &invMass.x, &invIxx.x, &invIyy.x, &invIzz.x);
+        body->getPositionOrientation(pos, orient);
+        Vector3 force = body->getForce();
+        Vector3 torque = body->getTorque();
+        Vector3 omega = body->getOmega();
+        Vector3 velocity = body->getVelocity();
+        Vector3 inertia;
+        Real mass;
+        body->getMassMatrix(mass, inertia);
         oss << "\tNewtonBodyLog: " << body << "  " << pos << "  " << orient << "  " << velocity << "  "
-            << omega << "  " << force << "  " << torque << "  " << NewtonBodyGetSleepState(body)
-            << "  " << NewtonBodyGetAutoSleep(body) << "  " << NewtonBodyGetContinuousCollisionMode(body) << "  ( "
-            << invMass << "  " << invIxx << "  " << invIyy << "  " << invIzz << " )";
+            << omega << "  " << force << "  " << torque << " " << body->getContinuousCollisionMode()
+            << mass << "  " << inertia;
         LOG_DEBUG(Logger::CORE, oss.str());
     }
 #endif
@@ -378,12 +366,18 @@
         mWorld->setWorldSize(mWorldAABB);
     }
 
-	void PhysicsManager::createPhysicsProxy(PhysicalThing* pt, SceneNode* node)
+	void PhysicsManager::createPhysicsProxy(PhysicalThing* pt)
 	{
-		pt->createPhysicsProxy(node);
+		pt->createPhysicsProxy();
 		mPhysicalThings.push_back(pt);
 	}
 
+    void PhysicsManager::createPhysicsProxy_RagDoll(PhysicalThing* pt)
+    {
+        pt->createPhysicsProxy_RagDoll();
+        mPhysicalThings.push_back(pt);
+    }
+
 	void PhysicsManager::destroyPhysicsProxy(PhysicalThing* pt)
 	{
         vector<PhysicalThing*>::iterator it = find(mPhysicalThings.begin(),
@@ -553,12 +547,6 @@
                     case GT_ELLIPSOID: // from createEllipsoid
                     case GT_PYRAMID: // createPyramid
                     case GT_SPHERE:
-                        {
-                            Vector3 inert_offs=Vector3::ZERO;
-                            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
-                            *inertia *= mass;
-                        }
-                        break;
                     case GT_MESH:
                     case GT_NONE:
                         *inertia = Ogre::Vector3::ZERO;

Copied: rl/branches/persistence2/engine/core/src/PhysicsRagDoll.cpp (from rev 4878, rl/trunk/engine/core/src/PhysicsRagDoll.cpp)

Modified: rl/branches/persistence2/engine/rules/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/rules/CMakeLists.txt	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/CMakeLists.txt	2009-04-01 20:08:44 UTC (rev 4879)
@@ -2,6 +2,7 @@
 ${CMAKE_CURRENT_SOURCE_DIR}/include
 ${RL_COMMON_INCLUDE_DIR}
 ${RL_CORE_INCLUDE_DIR}
+${XERCESC_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR})

Modified: rl/branches/persistence2/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/rules/RlRules2005.vcproj	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/RlRules2005.vcproj	2009-04-01 20:08:44 UTC (rev 4879)
@@ -42,7 +42,7 @@
 				Name="VCCLCompilerTool"
 				AdditionalOptions="-Zm130"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\include;..\core\include;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\OgreNewt_ngt\inc;..\..\dependencies\NewtonSDK2\sdk"
+				AdditionalIncludeDirectories=".\include;..\core\include;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\OgreNewt\inc;..\..\dependencies\NewtonSDK\sdk"
 				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;RLRULES_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -72,7 +72,7 @@
 				AdditionalDependencies="msvcrt-ruby18.lib xerces-c_2D.lib OgreMain_d.lib CEGUIBase_d.lib RlCore.lib OgreNewt_d.lib Newton.lib"
 				OutputFile="$(OutDir)/RlRules.dll"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK2\sdk\x32\dll_vs7;..\..\dependencies\OgreNewt_ngt\lib"
+				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7;..\..\dependencies\OgreNewt\lib"
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
 				ProgramDatabaseFile="$(OutDir)/RlRules.pdb"
@@ -134,7 +134,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				AdditionalOptions="-Zm130"
-				AdditionalIncludeDirectories=".\include;..\core\include;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk"
+				AdditionalIncludeDirectories=".\include;..\core\include;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\OgreNewt\inc;..\..\dependencies\NewtonSDK\sdk"
 				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;RLRULES_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
@@ -160,7 +160,7 @@
 				AdditionalDependencies="msvcrt-ruby18.lib OgreMain.lib xerces-c_2.lib CEGUIBase.lib RlCore.lib OgreNewt.lib Newton.lib"
 				OutputFile="$(OutDir)/RlRules.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll"
+				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7"
 				GenerateDebugInformation="false"
 				SubSystem="2"
 				OptimizeReferences="2"

Copied: rl/branches/persistence2/engine/rules/RlRules2008.vcproj (from rev 4878, rl/trunk/engine/rules/RlRules2008.vcproj)

Modified: rl/branches/persistence2/engine/rules/include/Creature.h
===================================================================
--- rl/branches/persistence2/engine/rules/include/Creature.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/include/Creature.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -873,5 +873,7 @@
              **/
             void setStatus(int& statusVariable, bool value, const Ogre::String& errorMessage);
     };
+    
+    typedef std::list<Creature*> CreatureList;
 }
 #endif //__CREATURE_H__

Modified: rl/branches/persistence2/engine/rules/include/GameObject.h
===================================================================
--- rl/branches/persistence2/engine/rules/include/GameObject.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/include/GameObject.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -19,6 +19,8 @@
 
 #include "RulesPrerequisites.h"
 
+#include <list>
+
 #include "Action.h"
 #include "Actor.h"
 #include "SaveAble.h"
@@ -247,6 +249,8 @@
         ActionOptionVector::iterator findAction(ActionOptionVector::iterator
             begin, ActionOptionVector::iterator end, const Action* action);    
     };
+    
+    typedef std::list<GameObject*> GameObjectList;
 }
 
 #endif

Modified: rl/branches/persistence2/engine/rules/include/GoToJob.h
===================================================================
--- rl/branches/persistence2/engine/rules/include/GoToJob.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/include/GoToJob.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -21,6 +21,7 @@
 #include "Creature.h"
 #include "CreatureController.h"
 #include "Job.h"
+#include "CreatureController.h"
 
 namespace rl
 {
@@ -32,8 +33,12 @@
     public:
 
 		GoToJob(const CeGuiString &id, Creature* actor, const Ogre::Vector3& targetPos,
-			Ogre::Real maxDistance, Ogre::Real duration);
-		GoToJob(const CeGuiString &id, Creature* actor, GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
+			Ogre::Real maxDistance, Ogre::Real duration,
+            CreatureController::MovementType movementType_moving = CreatureController::MT_RENNEN,
+            CreatureController::MovementType movementType_idle = CreatureController::MT_STEHEN);
+		GoToJob(const CeGuiString &id, Creature* actor, GameObject* target, Ogre::Real maxDistance, Ogre::Real duration,
+            CreatureController::MovementType movementType_moving = CreatureController::MT_RENNEN,
+            CreatureController::MovementType movementType_idle = CreatureController::MT_STEHEN);
         virtual ~GoToJob();
 
         virtual bool execute(Ogre::Real time);
@@ -44,6 +49,7 @@
 		Ogre::Vector3 mTargetPos;
 		Ogre::Real mMaxDistance;
 		Ogre::Real mTimeLeft;
+        CreatureController::MovementType mMovementType_moving, mMovementType_idle;
     };
 }
 

Modified: rl/branches/persistence2/engine/rules/include/Selector.h
===================================================================
--- rl/branches/persistence2/engine/rules/include/Selector.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/include/Selector.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,156 +1,191 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __RL_SELECTOR_H__
-#define __RL_SELECTOR_H__
-
-#include "RulesPrerequisites.h"
-#include "SceneQuery.h"
-#include "GameObject.h"
-#include "Creature.h"
-#include "LineSetPrimitive.h"
-#include "DebugVisualisable.h"
-
-namespace rl {
-
-    class _RlRulesExport SelectionFilter
-    {
-    public:
-        virtual ~SelectionFilter() {}
-        /// Return true, if the GameObject passes the filter, false else.
-        virtual bool pass(GameObject*) const = 0;
-    };
-
-    class _RlRulesExport CreatureSelectionFilter : public SelectionFilter
-    {
-    public:
-        CreatureSelectionFilter();
-
-        void setAlignmentMask(unsigned int);
-
-        /// Return true, if the GameObject is a Creature with properties as set in the filter.
-        virtual bool pass(GameObject*) const;
-    private:
-        /// Only have alignment here. Can be mademore generic, if needed later on.
-        unsigned int mAlignment;
-    };
-
-    class _RlRulesExport InSceneSelectionFilter : public SelectionFilter
-    {
-    public:
-        InSceneSelectionFilter();
-
-        /// Return true, if the GameObject is in scene with properties as set in the filter.
-        virtual bool pass(GameObject*) const;
-    };
-
-    /// Superclass for all Selectors in RL.
-    /// Selectors provide a way to query for GameObjects in a game.
-    /// Either in the scene, or inventory, or anywhere else.
-    class _RlRulesExport Selector : public DebugVisualisable
-    {
-    public:
-        typedef std::vector<GameObject*> GameObjectVector;
-
-        Selector(unsigned long mask = 0xffffffff);
-        virtual ~Selector();
-        virtual void updateSelection();
-
-        void setSelectionMask(unsigned long mask);
-        unsigned long getSelectionMask() const;
-
-        /// Set an additional filter to narrow down selection. Set NULL, to unset filtering.
-        void setFilter(SelectionFilter*);
-        SelectionFilter* getFilter() const;
-
-        GameObject* getFirstSelectedObject() const;
-        const GameObjectVector& getAllSelectedObjects() const;
-		unsigned int getSelectionCount() const;
-
-    protected:
-        GameObjectVector mSelection;
-        unsigned long mSelectionMask;
-        SelectionFilter* mFilter;
-
-        virtual const ActorVector& doExecuteQuery() = 0;
-        /// Apply the filter if set, or just return true, if no selection filter is set.
-        virtual bool filter(GameObject*);
-    };
-
-
-    /// A Selector that selects all unoccluded GameObject the ray hits.
-    class _RlRulesExport RaySelector : public Selector
-    {
-    public:
-        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
-		~RaySelector();
-
-        void setRay(const Ogre::Vector3& start, const Ogre::Vector3& end);
-
-        // Overrides from DebugVisualisable
-
-        virtual DebugVisualisableFlag getFlag() const;
-        virtual void updatePrimitive();
-
-    protected:
-        RaySceneQuery* mQuery;
-
-        virtual const ActorVector& doExecuteQuery();
-        virtual void doCreatePrimitive();
-    };
-
-    /// Selects this GameObject within a half sphere pointing to -Z,
-    /// that has the smallest angle difference to the -Z-Axis.
-    class _RlRulesExport HalfSphereSelector : public Selector
-    {
-    public:
-        HalfSphereSelector(Ogre::SceneManager* smgr, unsigned long mask = 0xffffffff);
-		HalfSphereSelector(unsigned long mask = 0xffffffff);
-
-        virtual void updateSelection();
-
-        void setRadius(Ogre::Real radius);
-
-        void setPosition(const Ogre::Vector3& pos);
-
-        void setOrientation(const Ogre::Quaternion& ori);
-
-        /// Instead of using transform set with setPosition/Orientation, use the
-        /// GameObject's transform. Set to NULL to disable tracking.
-        void track(GameObject* go);
-
-        /// If check is true, visibility is checked from the POV of the GameObject reference
-        /// This is currently done by casting a ray from the GameObject to the candidate GOs
-        void setCheckVisibility(bool check, GameObject* reference = NULL);
-
-        // Overrides from DebugVisualisable
-
-        virtual DebugVisualisableFlag getFlag() const;
-        virtual void updatePrimitive();
-
-    protected:
-        HalfSphereSceneQuery mQuery;
-        bool mCheckVisibility;
-        GameObject* mLoSReferenceGo;
-        GameObject* mTrackedGo;
-
-        virtual const ActorVector& doExecuteQuery();
-
-        virtual void doCreatePrimitive();
-    };
-}
-#endif
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __RL_SELECTOR_H__
+#define __RL_SELECTOR_H__
+
+#include "RulesPrerequisites.h"
+#include "SceneQuery.h"
+#include "GameObject.h"
+#include "Creature.h"
+#include "LineSetPrimitive.h"
+#include "DebugVisualisable.h"
+
+namespace rl {
+
+    class _RlRulesExport SelectionFilter
+    {
+    public:
+        virtual ~SelectionFilter() {}
+        /// Return true, if the GameObject passes the filter, false else.
+        virtual bool pass(GameObject*) const = 0;
+    };
+
+    class _RlRulesExport CreatureSelectionFilter : public SelectionFilter
+    {
+    public:
+        CreatureSelectionFilter();
+
+        void setAlignmentMask(unsigned int);
+
+        /// Return true, if the GameObject is a Creature with properties as set in the filter.
+        virtual bool pass(GameObject*) const;
+    private:
+        /// Only have alignment here. Can be mademore generic, if needed later on.
+        unsigned int mAlignment;
+    };
+
+    class _RlRulesExport InSceneSelectionFilter : public SelectionFilter
+    {
+    public:
+        InSceneSelectionFilter();
+
+        /// Return true, if the GameObject is in scene with properties as set in the filter.
+        virtual bool pass(GameObject*) const;
+    };
+
+    /// Superclass for all Selectors in RL.
+    /// Selectors provide a way to query for GameObjects in a game.
+    /// Either in the scene, or inventory, or anywhere else.
+    class _RlRulesExport Selector : public DebugVisualisable
+    {
+    public:
+        Selector(unsigned long mask = 0xffffffff);
+        virtual ~Selector();
+        virtual void updateSelection();
+
+        void setSelectionMask(unsigned long mask);
+        unsigned long getSelectionMask() const;
+
+        /// Set an additional filter to narrow down selection. Set NULL, to unset filtering.
+        void setFilter(SelectionFilter*);
+        SelectionFilter* getFilter() const;
+
+        GameObject* getFirstSelectedObject() const;
+        const GameObjectList& getAllSelectedObjects() const;
+		unsigned int getSelectionCount() const;
+
+    protected:
+        GameObjectList mSelection;
+        unsigned long mSelectionMask;
+        SelectionFilter* mFilter;
+
+        virtual const ActorVector& doExecuteQuery() = 0;
+        /// Apply the filter if set, or just return true, if no selection filter is set.
+        virtual bool filter(GameObject*);
+    };
+
+
+    /// A Selector that selects all unoccluded GameObject the ray hits.
+    class _RlRulesExport RaySelector : public Selector
+    {
+    public:
+        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
+		~RaySelector();
+
+        void setRay(const Ogre::Vector3& start, const Ogre::Vector3& end);
+
+        // Overrides from DebugVisualisable
+
+        virtual DebugVisualisableFlag getFlag() const;
+        virtual void updatePrimitive();
+
+    protected:
+        RaySceneQuery* mQuery;
+
+        virtual const ActorVector& doExecuteQuery();
+        virtual void doCreatePrimitive();
+    };
+
+    /// Selects this GameObject within a half sphere pointing to -Z,
+    /// that has the smallest angle difference to the -Z-Axis.
+    class _RlRulesExport HalfSphereSelector : public Selector
+    {
+    public:
+        HalfSphereSelector(Ogre::SceneManager* smgr, unsigned long mask = 0xffffffff);
+		HalfSphereSelector(unsigned long mask = 0xffffffff);
+
+        virtual void updateSelection();
+
+        void setRadius(Ogre::Real radius);
+
+        void setPosition(const Ogre::Vector3& pos);
+
+        void setOrientation(const Ogre::Quaternion& ori);
+
+        /// Instead of using transform set with setPosition/Orientation, use the
+        /// GameObject's transform. Set to NULL to disable tracking.
+        void track(GameObject* go);
+
+        /// If check is true, visibility is checked from the POV of the GameObject reference
+        /// This is currently done by casting a ray from the GameObject to the candidate GOs
+        void setCheckVisibility(bool check, GameObject* reference = NULL);
+
+        // Overrides from DebugVisualisable
+
+        virtual DebugVisualisableFlag getFlag() const;
+        virtual void updatePrimitive();
+
+    protected:
+        HalfSphereSceneQuery mQuery;
+        bool mCheckVisibility;
+        GameObject* mLoSReferenceGo;
+        GameObject* mTrackedGo;
+
+        virtual const ActorVector& doExecuteQuery();
+
+        virtual void doCreatePrimitive();
+    };
+
+    /// Selects this GameObject within a sphere .
+    class _RlRulesExport SphereSelector : public Selector
+    {
+    public:
+        SphereSelector(Ogre::SceneManager* smgr, unsigned long mask = 0xffffffff);
+	SphereSelector(unsigned long mask = 0xffffffff);
+
+        virtual void updateSelection();
+
+        void setRadius(Ogre::Real radius);
+
+        void setPosition(const Ogre::Vector3& pos);
+
+        /// Instead of using transform set with setPosition/Orientation, use the
+        /// GameObject's transform. Set to NULL to disable tracking.
+        void track(GameObject* go);
+
+        /// If check is true, visibility is checked from the POV of the GameObject reference
+        /// This is currently done by casting a ray from the GameObject to the candidate GOs
+        void setCheckVisibility(bool check, GameObject* reference = NULL);
+
+        // Overrides from DebugVisualisable
+
+        virtual DebugVisualisableFlag getFlag() const;
+        virtual void updatePrimitive();
+
+    protected:
+        SphereSceneQuery mQuery;
+        bool mCheckVisibility;
+        GameObject* mLoSReferenceGo;
+        GameObject* mTrackedGo;
+
+        virtual const ActorVector& doExecuteQuery();
+
+        virtual void doCreatePrimitive();
+    };
+}
+#endif
+

Modified: rl/branches/persistence2/engine/rules/src/FetchItemJob.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/FetchItemJob.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/src/FetchItemJob.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -113,17 +113,29 @@
 		}
         else 
         {
-            // Hard set orientation.
-            /// @todo Use CreatureController properly to turn smoothly
+		
             Vector3 pos = mActor->getCreature()->getPosition();
             pos.y = 0;
             targetPos.y = 0;
-            mActor->getCreature()->setOrientation(Vector3::NEGATIVE_UNIT_Z.getRotationTo(targetPos - pos));
-            mActor->setMovement(CreatureController::MT_LAUFEN, Vector3::NEGATIVE_UNIT_Z, Vector3::ZERO);
-            
+            Degree realYawDiff = (mActor->getCreature()->getOrientation()*Vector3::NEGATIVE_UNIT_Z).getRotationTo(targetPos - pos).getYaw();
+            Vector3 rotation = Vector3::ZERO;
+            Quaternion currentOri(mActor->getYaw(), Vector3::UNIT_Y);
+            rotation.y = (currentOri*Vector3::NEGATIVE_UNIT_Z).getRotationTo(targetPos - pos).getYaw().valueRadians();
+
+            // old code for rotation:
+            //mActor->getCreature()->setOrientation(Vector3::NEGATIVE_UNIT_Z.getRotationTo(targetPos - pos));
+    
+            // first rotate, then move, is this the "desired" behaviour?
+            if( realYawDiff > Degree(5) || realYawDiff < Degree(-5) )
+                mActor->setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, rotation);
+            else
+                mActor->setMovement(CreatureController::MT_LAUFEN, Vector3::NEGATIVE_UNIT_Z, rotation);
+
+    
             mTimeLeft  -= time;
             return false;            
         }
 
 	}
 }
+

Modified: rl/branches/persistence2/engine/rules/src/GoToJob.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/GoToJob.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/src/GoToJob.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -18,6 +18,7 @@
 
 #include "GoToJob.h"
 
+#include "Creature.h"
 #include "CreatureControllerManager.h"
 #include "MathUtil.h"
 
@@ -25,24 +26,30 @@
 
 namespace rl
 {
-	GoToJob::GoToJob(const CeGuiString &id, Creature* actor, const Vector3& targetPos, Real maxDistance, Real duration)
+	GoToJob::GoToJob(const CeGuiString &id, Creature* actor, const Vector3& targetPos, Real maxDistance, Real duration, CreatureController::MovementType movementType_moving,
+            CreatureController::MovementType movementType_idle)
 		: Job(id, false, true, TimeSource::REALTIME_INTERRUPTABLE),
 		  mActor(NULL),
 		  mTarget(NULL),
 		  mTargetPos(targetPos),
 		  mMaxDistance(maxDistance),
-		  mTimeLeft(duration)
+		  mTimeLeft(duration),
+          mMovementType_moving(movementType_moving),
+          mMovementType_idle(movementType_idle)
 	{
 		mActor = CreatureControllerManager::getSingleton().getCreatureController(actor);
 	}
 
-	GoToJob::GoToJob(const CeGuiString &id, Creature* actor, GameObject* target, Real maxDistance, Real duration)
+	GoToJob::GoToJob(const CeGuiString& id, Creature* actor, GameObject* target, Real maxDistance, Real duration, CreatureController::MovementType movementType_moving,
+            CreatureController::MovementType movementType_idle)
 		: Job(id, false, true, TimeSource::REALTIME_INTERRUPTABLE),
 		  mActor(NULL),
 		  mTarget(target),
 		  mTargetPos(Vector3::ZERO),
 		  mMaxDistance(maxDistance),
-		  mTimeLeft(duration)
+		  mTimeLeft(duration),
+          mMovementType_moving(movementType_moving),
+          mMovementType_idle(movementType_idle)
 	{
 		mActor = CreatureControllerManager::getSingleton().getCreatureController(actor);
 	}
@@ -57,7 +64,7 @@
 		if (mTimeLeft < 0)
 		{
 			// Stay put where ever we are.
-			mActor->setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
+			mActor->setMovement(mMovementType_idle, Vector3::ZERO, Vector3::ZERO);
 			return true;
 		}
         
@@ -79,20 +86,31 @@
 		if (distance < mMaxDistance)
 		{
 			// Stay put where ever we are.
-			mActor->setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
+			mActor->setMovement(mMovementType_idle, Vector3::ZERO, Vector3::ZERO);
 			return true;
 		}
 
-		// Hard set orientation.
-		/// @todo Use CreatureController properly to turn smoothly
+
 		Vector3 pos = mActor->getCreature()->getPosition();
 		pos.y = 0;
 		Vector3 targetPos = mTargetPos;
 		targetPos.y = 0;
-		mActor->getCreature()->setOrientation(Vector3::NEGATIVE_UNIT_Z.getRotationTo(targetPos - pos));
-		mActor->setMovement(CreatureController::MT_LAUFEN, Vector3::NEGATIVE_UNIT_Z, Vector3::ZERO);
+        Degree realYawDiff = (mActor->getCreature()->getOrientation()*Vector3::NEGATIVE_UNIT_Z).getRotationTo(targetPos - pos).getYaw();
+        Vector3 rotation = Vector3::ZERO;
+        Quaternion currentOri(mActor->getYaw(), Vector3::UNIT_Y);
+        rotation.y = (currentOri*Vector3::NEGATIVE_UNIT_Z).getRotationTo(targetPos - pos).getYaw().valueRadians();
 
+        // old code for rotation:
+		//mActor->getCreature()->setOrientation(Vector3::NEGATIVE_UNIT_Z.getRotationTo(targetPos - pos));
+        
+        // first rotate, then move, is this the "desired" behaviour?
+        if( realYawDiff > Degree(5) || realYawDiff < Degree(-5) )
+            mActor->setMovement(mMovementType_idle, Vector3::ZERO, rotation);
+        else
+    		mActor->setMovement(mMovementType_moving, Vector3::NEGATIVE_UNIT_Z, rotation);
+
 		mTimeLeft  -= time;
 		return false;
 	}
 }
+

Modified: rl/branches/persistence2/engine/rules/src/Selector.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/Selector.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/src/Selector.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,304 +1,422 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "Selector.h"
-#include "SelectionHelper.h"
-
-#include "CoreSubsystem.h"
-#include "PhysicsManager.h"
-#include "World.h"
-
-using namespace Ogre;
-
-namespace rl
-{
-    CreatureSelectionFilter::CreatureSelectionFilter()
-        : mAlignment(Creature::ALIGNMENT_ALLY |
-                     Creature::ALIGNMENT_NEUTRAL |
-                     Creature::ALIGNMENT_ENEMY)
-    {
-    }
-
-    void CreatureSelectionFilter::setAlignmentMask(unsigned int mask)
-    {
-        mAlignment = mask;
-    }
-
-    bool CreatureSelectionFilter::pass(GameObject* go) const
-    {
-        Creature* creature = dynamic_cast<Creature*>(go);
-        if (creature != NULL)
-        {
-            return (mAlignment & creature->getAlignment()) != 0;
-        }
-        return false;
-    }
-
-    InSceneSelectionFilter::InSceneSelectionFilter()
-    {
-    }
-
-    bool InSceneSelectionFilter::pass(GameObject* go) const
-    {
-        if (go->getState() == GOS_IN_SCENE)
-        {
-            return true;
-        }
-        return false;
-    }
-
-    Selector::Selector(unsigned long mask)
-		: DebugVisualisable(), mSelection(), mSelectionMask(mask), mFilter(NULL)
-    {
-    }
-
-    Selector::~Selector()
-    {
-    }
-
-    void Selector::setFilter(SelectionFilter* filter)
-    {
-        mFilter = filter;
-    }
-
-    SelectionFilter* Selector::getFilter() const
-    {
-        return mFilter;
-    }
-
-    void Selector::setSelectionMask(unsigned long mask)
-    {
-        mSelectionMask = mask;
-    }
-
-    unsigned long Selector::getSelectionMask() const
-    {
-        return mSelectionMask;
-    }
-
-    GameObject* Selector::getFirstSelectedObject() const
-    {
-        return mSelection.empty() ? NULL : mSelection[0];
-    }
-
-    const Selector::GameObjectVector& Selector::getAllSelectedObjects() const
-    {
-        return mSelection;
-    }
-
-	unsigned int Selector::getSelectionCount() const
-	{
-		return mSelection.size();
-	}
-
-    void Selector::updateSelection()
-    {
-        // Remove old selection
-        mSelection.clear();
-
-        // Do the query, results are in proper order
-        const ActorVector& actors = doExecuteQuery();
-
-        // Set selection to first result with a GameObject attached.
-        for (ActorVector::const_iterator it = actors.begin(), end = actors.end();
-            it != end; ++it)
-        {
-            Actor* actor = *it;
-            GameObject* go = static_cast<GameObject*>(actor->getGameObject());
-            if (go != NULL && (go->getQueryFlags() & mSelectionMask) && filter(go))
-            {
-                mSelection.push_back(go);
-            }
-        }
-    }
-
-    bool Selector::filter(GameObject* go)
-    {
-        return mFilter == NULL || mFilter->pass(go);
-    }
-
-    //------------------------------------------------------------------------
-
-    RaySelector::RaySelector(unsigned long mask, bool useOgreQuery)
-        : Selector(mask)
-    {
-		if (useOgreQuery)
-		{
-			mQuery = new OgreRaySceneQuery(mask);
-		}
-		else
-		{
-			mQuery = new RaySceneQuery(mask);
-		}
-    }
-
-    void RaySelector::setRay(const Ogre::Vector3& start, const Ogre::Vector3& end)
-    {
-        mQuery->setRay(start, end);
-    }
-
-    // Overrides from DebugVisualisable
-    DebugVisualisableFlag RaySelector::getFlag() const
-    {
-        return DVF_CONTROL;
-    }
-
-    void RaySelector::updatePrimitive()
-    {
-        LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
-        lineSet->clear();
-        lineSet->addLine(mQuery->getRayStart(), mQuery->getRayEnd(), ColourValue::Red);
-    }
-
-    const ActorVector& RaySelector::doExecuteQuery()
-    {
-        return mQuery->execute();
-    }
-
-    void RaySelector::doCreatePrimitive()
-    {
-        mPrimitive = new LineSetPrimitive();
-    }
-
-	RaySelector::~RaySelector()
-	{
-		delete mQuery;
-	}
-
-    //////////////////////////////////////////////////////////////////////////
-
-    HalfSphereSelector::HalfSphereSelector(Ogre::SceneManager* smgr,
-        unsigned long mask)
-        : Selector(mask),
-          mQuery(smgr, mask),
-          mCheckVisibility(false),
-          mLoSReferenceGo(NULL),
-		  mTrackedGo(NULL)
-    {
-    }
-
-    HalfSphereSelector::HalfSphereSelector(unsigned long mask)
-        : Selector(mask),
-		  mQuery(CoreSubsystem::getSingleton().getWorld()->getSceneManager(), mask),
-          mCheckVisibility(false),
-          mLoSReferenceGo(NULL),
-		  mTrackedGo(NULL)
-    {
-    }
-
-    void HalfSphereSelector::updateSelection()
-    {
-        // Remove old selection
-        mSelection.clear();
-
-        // Auto tracking enabled?
-        if (mTrackedGo != NULL)
-        {
-            // If not in scene, then we're done
-            if ((mTrackedGo->getState() & GOS_IN_SCENE) == 0)
-            {
-                return;
-            }
-
-            // Set query transform according to position and orientation of tracked GO.
-            setPosition(mTrackedGo->getPosition());
-            setOrientation(mTrackedGo->getOrientation());
-        }
-
-        // Do the query, results are in proper order
-        const ActorVector& actors = doExecuteQuery();
-
-        // Set selection to first result with a GameObject attached.
-        for (ActorVector::const_iterator it = actors.begin(), end = actors.end();
-            it != end; ++it)
-        {
-            Actor* actor = *it;
-            GameObject* go = static_cast<GameObject*>(actor->getGameObject());
-            if (go != NULL && (go->getQueryFlags() & mSelectionMask))
-            {
-                // Is this GO seen when we need it to be seen?
-                if (mCheckVisibility && mLoSReferenceGo &&
-                    !SelectionHelper::checkLineOfSight(mLoSReferenceGo, go))
-                {
-                    // Nope, check next.
-                    continue;
-                }
-                else if (filter(go))
-                {
-                    // Ok, LoS either not needed or given.
-                    mSelection.push_back(go);
-                }
-            }
-        }
-    }
-
-    void HalfSphereSelector::updatePrimitive()
-    {
-        LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
-        lineSet->clear();
-
-        Vector3 pos = mQuery.getPosition();
-        Quaternion ori = mQuery.getOrientation();
-        Real radius = mQuery.getRadius();
-
-        lineSet->addLine(pos, pos + radius * (ori * Vector3::UNIT_X), ColourValue::Red);
-        lineSet->addLine(pos, pos + radius * (ori * Vector3::UNIT_Y), ColourValue::Green);
-        lineSet->addLine(pos, pos + radius * (ori * Vector3::NEGATIVE_UNIT_Z),
-            ColourValue::Blue);
-    }
-
-    void HalfSphereSelector::setRadius(Ogre::Real radius)
-    {
-        mQuery.setRadius(radius);
-    }
-
-    void HalfSphereSelector::setPosition(const Ogre::Vector3& pos)
-    {
-        mQuery.setPosition(pos);
-    }
-
-    void HalfSphereSelector::setOrientation(const Ogre::Quaternion& ori)
-    {
-        mQuery.setOrientation(ori);
-    }
-
-    void HalfSphereSelector::setCheckVisibility(bool check, GameObject* reference)
-    {
-        mCheckVisibility = check;
-        mLoSReferenceGo = reference;
-    }
-
-    void HalfSphereSelector::track(GameObject* go)
-    {
-        mTrackedGo = go;
-    }
-
-    DebugVisualisableFlag HalfSphereSelector::getFlag() const
-    {
-        return DVF_CONTROL;
-    }
-
-    const ActorVector& HalfSphereSelector::doExecuteQuery()
-    {
-        return mQuery.execute();
-    }
-
-    void HalfSphereSelector::doCreatePrimitive()
-    {
-        mPrimitive = new LineSetPrimitive();
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include "Selector.h"
+#include "SelectionHelper.h"
+
+#include "CoreSubsystem.h"
+#include "PhysicsManager.h"
+#include "World.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+    CreatureSelectionFilter::CreatureSelectionFilter()
+        : mAlignment(Creature::ALIGNMENT_ALLY |
+                     Creature::ALIGNMENT_NEUTRAL |
+                     Creature::ALIGNMENT_ENEMY)
+    {
+    }
+
+    void CreatureSelectionFilter::setAlignmentMask(unsigned int mask)
+    {
+        mAlignment = mask;
+    }
+
+    bool CreatureSelectionFilter::pass(GameObject* go) const
+    {
+        Creature* creature = dynamic_cast<Creature*>(go);
+        if (creature != NULL)
+        {
+            return (mAlignment & creature->getAlignment()) != 0;
+        }
+        return false;
+    }
+
+    InSceneSelectionFilter::InSceneSelectionFilter()
+    {
+    }
+
+    bool InSceneSelectionFilter::pass(GameObject* go) const
+    {
+        if (go->getState() == GOS_IN_SCENE)
+        {
+            return true;
+        }
+        return false;
+    }
+
+    Selector::Selector(unsigned long mask)
+		: DebugVisualisable(), mSelection(), mSelectionMask(mask), mFilter(NULL)
+    {
+    }
+
+    Selector::~Selector()
+    {
+    }
+
+    void Selector::setFilter(SelectionFilter* filter)
+    {
+        mFilter = filter;
+    }
+
+    SelectionFilter* Selector::getFilter() const
+    {
+        return mFilter;
+    }
+
+    void Selector::setSelectionMask(unsigned long mask)
+    {
+        mSelectionMask = mask;
+    }
+
+    unsigned long Selector::getSelectionMask() const
+    {
+        return mSelectionMask;
+    }
+
+    GameObject* Selector::getFirstSelectedObject() const
+    {
+        return mSelection.empty() ? NULL : *mSelection.begin();
+    }
+
+    const GameObjectList& Selector::getAllSelectedObjects() const
+    {
+        return mSelection;
+    }
+
+	unsigned int Selector::getSelectionCount() const
+	{
+		return mSelection.size();
+	}
+
+    void Selector::updateSelection()
+    {
+        // Remove old selection
+        mSelection.clear();
+
+        // Do the query, results are in proper order
+        const ActorVector& actors = doExecuteQuery();
+
+        // Set selection to first result with a GameObject attached.
+        for (ActorVector::const_iterator it = actors.begin(), end = actors.end();
+            it != end; ++it)
+        {
+            Actor* actor = *it;
+            GameObject* go = static_cast<GameObject*>(actor->getGameObject());
+            if (go != NULL && (go->getQueryFlags() & mSelectionMask) && filter(go))
+            {
+                mSelection.push_back(go);
+            }
+        }
+    }
+
+    bool Selector::filter(GameObject* go)
+    {
+        return mFilter == NULL || mFilter->pass(go);
+    }
+
+    //------------------------------------------------------------------------
+
+    RaySelector::RaySelector(unsigned long mask, bool useOgreQuery)
+        : Selector(mask)
+    {
+		if (useOgreQuery)
+		{
+			mQuery = new OgreRaySceneQuery(mask);
+		}
+		else
+		{
+			mQuery = new RaySceneQuery(mask);
+		}
+    }
+
+    void RaySelector::setRay(const Ogre::Vector3& start, const Ogre::Vector3& end)
+    {
+        mQuery->setRay(start, end);
+    }
+
+    // Overrides from DebugVisualisable
+    DebugVisualisableFlag RaySelector::getFlag() const
+    {
+        return DVF_CONTROL;
+    }
+
+    void RaySelector::updatePrimitive()
+    {
+        LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
+        lineSet->clear();
+        lineSet->addLine(mQuery->getRayStart(), mQuery->getRayEnd(), ColourValue::Red);
+    }
+
+    const ActorVector& RaySelector::doExecuteQuery()
+    {
+        return mQuery->execute();
+    }
+
+    void RaySelector::doCreatePrimitive()
+    {
+        mPrimitive = new LineSetPrimitive();
+    }
+
+	RaySelector::~RaySelector()
+	{
+		delete mQuery;
+	}
+
+    //////////////////////////////////////////////////////////////////////////
+
+    HalfSphereSelector::HalfSphereSelector(Ogre::SceneManager* smgr,
+        unsigned long mask)
+        : Selector(mask),
+          mQuery(smgr, mask),
+          mCheckVisibility(false),
+          mLoSReferenceGo(NULL),
+		  mTrackedGo(NULL)
+    {
+    }
+
+    HalfSphereSelector::HalfSphereSelector(unsigned long mask)
+        : Selector(mask),
+		  mQuery(CoreSubsystem::getSingleton().getWorld()->getSceneManager(), mask),
+          mCheckVisibility(false),
+          mLoSReferenceGo(NULL),
+		  mTrackedGo(NULL)
+    {
+    }
+
+    void HalfSphereSelector::updateSelection()
+    {
+        // Remove old selection
+        mSelection.clear();
+
+        // Auto tracking enabled?
+        if (mTrackedGo != NULL)
+        {
+            // If not in scene, then we're done
+            if ((mTrackedGo->getState() & GOS_IN_SCENE) == 0)
+            {
+                return;
+            }
+
+            // Set query transform according to position and orientation of tracked GO.
+            setPosition(mTrackedGo->getPosition());
+            setOrientation(mTrackedGo->getOrientation());
+        }
+
+        // Do the query, results are in proper order
+        const ActorVector& actors = doExecuteQuery();
+
+        // Set selection to first result with a GameObject attached.
+        for (ActorVector::const_iterator it = actors.begin(), end = actors.end();
+            it != end; ++it)
+        {
+            Actor* actor = *it;
+            GameObject* go = static_cast<GameObject*>(actor->getGameObject());
+            if (go != NULL && (go->getQueryFlags() & mSelectionMask))
+            {
+                // Is this GO seen when we need it to be seen?
+                if (mCheckVisibility && mLoSReferenceGo &&
+                    !SelectionHelper::checkLineOfSight(mLoSReferenceGo, go))
+                {
+                    // Nope, check next.
+                    continue;
+                }
+                else if (filter(go))
+                {
+                    // Ok, LoS either not needed or given.
+                    mSelection.push_back(go);
+                }
+            }
+        }
+    }
+
+    void HalfSphereSelector::updatePrimitive()
+    {
+        LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
+        lineSet->clear();
+
+        Vector3 pos = mQuery.getPosition();
+        Quaternion ori = mQuery.getOrientation();
+        Real radius = mQuery.getRadius();
+
+        lineSet->addLine(pos, pos + radius * (ori * Vector3::UNIT_X), ColourValue::Red);
+        lineSet->addLine(pos, pos + radius * (ori * Vector3::UNIT_Y), ColourValue::Green);
+        lineSet->addLine(pos, pos + radius * (ori * Vector3::NEGATIVE_UNIT_Z),
+            ColourValue::Blue);
+    }
+
+    void HalfSphereSelector::setRadius(Ogre::Real radius)
+    {
+        mQuery.setRadius(radius);
+    }
+
+    void HalfSphereSelector::setPosition(const Ogre::Vector3& pos)
+    {
+        mQuery.setPosition(pos);
+    }
+
+    void HalfSphereSelector::setOrientation(const Ogre::Quaternion& ori)
+    {
+        mQuery.setOrientation(ori);
+    }
+
+    void HalfSphereSelector::setCheckVisibility(bool check, GameObject* reference)
+    {
+        mCheckVisibility = check;
+        mLoSReferenceGo = reference;
+    }
+
+    void HalfSphereSelector::track(GameObject* go)
+    {
+        mTrackedGo = go;
+    }
+
+    DebugVisualisableFlag HalfSphereSelector::getFlag() const
+    {
+        return DVF_CONTROL;
+    }
+
+    const ActorVector& HalfSphereSelector::doExecuteQuery()
+    {
+        return mQuery.execute();
+    }
+
+    void HalfSphereSelector::doCreatePrimitive()
+    {
+        mPrimitive = new LineSetPrimitive();
+    }
+
+    //////////////////////////////////////////////////////////////////////////
+
+    SphereSelector::SphereSelector(Ogre::SceneManager* smgr,
+        unsigned long mask)
+        : Selector(mask),
+          mQuery(smgr, mask),
+          mCheckVisibility(false),
+          mLoSReferenceGo(NULL),
+		  mTrackedGo(NULL)
+    {
+    }
+
+    SphereSelector::SphereSelector(unsigned long mask)
+        : Selector(mask),
+		  mQuery(CoreSubsystem::getSingleton().getWorld()->getSceneManager(), mask),
+          mCheckVisibility(false),
+          mLoSReferenceGo(NULL),
+		  mTrackedGo(NULL)
+    {
+    }
+
+    void SphereSelector::updateSelection()
+    {
+        // Remove old selection
+        mSelection.clear();
+
+        // Auto tracking enabled?
+        if (mTrackedGo != NULL)
+        {
+            // If not in scene, then we're done
+            if (!(mTrackedGo->getState() & GOS_IN_SCENE))
+            {
+                return;
+            }
+
+            // Set query transform according to position and orientation of tracked GO.
+            setPosition(mTrackedGo->getPosition());
+        }
+
+        // Do the query, results are in proper order
+        const ActorVector& actors = doExecuteQuery();
+
+        // Set selection to first result with a GameObject attached.
+        for (ActorVector::const_iterator it = actors.begin(), end = actors.end();
+            it != end; ++it)
+        {
+            Actor* actor = *it;
+            GameObject* go = static_cast<GameObject*>(actor->getGameObject());
+            if (go != NULL && (go->getQueryFlags() & mSelectionMask))
+            {
+                // Is this GO seen when we need it to be seen?
+                if (mCheckVisibility && mLoSReferenceGo &&
+                    !SelectionHelper::checkLineOfSight(mLoSReferenceGo, go))
+                {
+                    // Nope, check next.
+                    continue;
+                }
+                else if (filter(go))
+                {
+                    // Ok, LoS either not needed or given.
+                    mSelection.push_back(go);
+                }
+            }
+        }
+    }
+
+    void SphereSelector::updatePrimitive()
+    {
+        LineSetPrimitive* lineSet = static_cast<LineSetPrimitive*>(mPrimitive);
+        lineSet->clear();
+
+        Vector3 pos = mQuery.getPosition();
+        Quaternion ori = mQuery.getOrientation();
+        Real radius = mQuery.getRadius();
+
+        lineSet->addLine(pos, pos + radius * (ori * Vector3::UNIT_X), ColourValue::Red);
+        lineSet->addLine(pos, pos + radius * (ori * Vector3::UNIT_Y), ColourValue::Green);
+        lineSet->addLine(pos, pos + radius * (ori * Vector3::NEGATIVE_UNIT_Z),
+            ColourValue::Blue);
+    }
+
+    void SphereSelector::setRadius(Ogre::Real radius)
+    {
+        mQuery.setRadius(radius);
+    }
+
+    void SphereSelector::setPosition(const Ogre::Vector3& pos)
+    {
+        mQuery.setPosition(pos);
+    }
+
+    void SphereSelector::setCheckVisibility(bool check, GameObject* reference)
+    {
+        mCheckVisibility = check;
+        mLoSReferenceGo = reference;
+    }
+
+    void SphereSelector::track(GameObject* go)
+    {
+        mTrackedGo = go;
+    }
+
+    DebugVisualisableFlag SphereSelector::getFlag() const
+    {
+        return DVF_CONTROL;
+    }
+
+    const ActorVector& SphereSelector::doExecuteQuery()
+    {
+        return mQuery.execute();
+    }
+
+    void SphereSelector::doCreatePrimitive()
+    {
+        mPrimitive = new LineSetPrimitive();
+    }
+
+}

Modified: rl/branches/persistence2/engine/script/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/script/CMakeLists.txt	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/script/CMakeLists.txt	2009-04-01 20:08:44 UTC (rev 4879)
@@ -8,6 +8,7 @@
 ${RL_RULES_INCLUDE_DIR}
 ${RL_AI_INCLUDE_DIR}
 ${RL_UI_INCLUDE_DIR}
+${XERCESC_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR}

Modified: rl/branches/persistence2/engine/script/RlScript2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/script/RlScript2005.vcproj	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/script/RlScript2005.vcproj	2009-04-01 20:08:44 UTC (rev 4879)
@@ -39,9 +39,9 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalOptions="-Zm130"
+				AdditionalOptions="-Zm144"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\include;..\common\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\OgreNewt_ngt\inc;..\..\dependencies\NewtonSDK2\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\opensteer\include;..\..\dependencies\ois\includes"
+				AdditionalIncludeDirectories=".\include;..\common\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\OgreNewt\inc;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\opensteer\include;..\..\dependencies\ois\includes"
 				PreprocessorDefinitions="WITH_FMOD3;WIN32;_DEBUG;_WINDOWS;_USRDLL;RLSCRIPT_EXPORTS;_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -69,7 +69,7 @@
 				AdditionalDependencies="RlCore.lib RlAi.lib RlUi.lib RlRules.lib OgreMain_d.lib msvcrt-ruby18.lib CEGUIBase_d.lib xerces-c_2D.lib OgreNewt_d.lib Newton.lib"
 				OutputFile="$(OutDir)/RlScript.dll"
 				LinkIncremental="2"
-				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt_ngt\lib;..\..\dependencies\NewtonSDK2\sdk\x32\dll_vs7"
+				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7"
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
 				ProgramDatabaseFile="$(OutDir)/RlScript.pdb"
@@ -131,7 +131,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				AdditionalOptions="-Zm130"
-				AdditionalIncludeDirectories=".\include;..\common\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\opensteer\include;..\..\dependencies\ois\includes"
+				AdditionalIncludeDirectories=".\include;..\common\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\OgreNewt\inc;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\opensteer\include;..\..\dependencies\ois\includes"
 				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLSCRIPT_EXPORTS;_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES;RL_USE_PCH"
 				RuntimeLibrary="2"
 				RuntimeTypeInfo="true"
@@ -155,7 +155,7 @@
 				AdditionalDependencies="RlCore.lib RlAi.lib RlUi.lib RlRules.lib OgreMain.lib msvcrt-ruby18.lib CEGUIBase.lib xerces-c_2.lib OgreNewt.lib Newton.lib"
 				OutputFile="$(OutDir)/RlScript.dll"
 				LinkIncremental="1"
-				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll"
+				AdditionalLibraryDirectories="&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7"
 				GenerateDebugInformation="false"
 				SubSystem="2"
 				OptimizeReferences="2"

Copied: rl/branches/persistence2/engine/script/RlScript2008.vcproj (from rev 4878, rl/trunk/engine/script/RlScript2008.vcproj)

Modified: rl/branches/persistence2/engine/script/swig/RlAi.swig
===================================================================
--- rl/branches/persistence2/engine/script/swig/RlAi.swig	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/script/swig/RlAi.swig	2009-04-01 20:08:44 UTC (rev 4879)
@@ -83,7 +83,7 @@
     class AgentDialogState : public rl::AgentState
     {
     public:
-        void setDialogPartner(rl::Agent* partner);
+        void addDialogPartner(rl::Agent* partner);
         void setDialog(rl::Dialog* dialog);
     private:
         AgentDialogState(rl::Agent* agent);
@@ -302,7 +302,7 @@
     public:
         static rl::DialogManager& getSingleton();
         rl::Dialog* createDialog(const Ogre::String& name, rl::Creature* npc);
-        rl::Dialog* createDialog(const Ogre::String& name, const std::list<rl::Creature*>& npcs);
+        rl::Dialog* createDialog(const Ogre::String& name, rl::CreatureList& npcs);
     private:
         DialogManager();
     };

Modified: rl/branches/persistence2/engine/script/swig/RlCore.swig
===================================================================
--- rl/branches/persistence2/engine/script/swig/RlCore.swig	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/script/swig/RlCore.swig	2009-04-01 20:08:44 UTC (rev 4879)
@@ -702,6 +702,12 @@
 
     void removeAndDestroyPhysicalThing(PhysicalThing* thing);
 
+    void createPhysicsProxy(PhysicalThing* pt);
+
+    void createPhysicsProxy_RagDoll(PhysicalThing* pt);
+
+    void destroyPhysicsProxy(PhysicalThing* pt);
+
     // Global Settings
     void setGravity(Ogre::Real x, Ogre::Real y, Ogre::Real z);
     Ogre::Vector3 getGravity() const;

Modified: rl/branches/persistence2/engine/script/swig/RlExports.i
===================================================================
--- rl/branches/persistence2/engine/script/swig/RlExports.i	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/script/swig/RlExports.i	2009-04-01 20:08:44 UTC (rev 4879)
@@ -197,13 +197,17 @@
 // da dies in allen erzeugten Exceptionhandlern auftritt
 %{
 #pragma warning( disable : 4101 )									
+#include "FixRubyHeaders.h"
 %}
 
 // Include bodies
 
 %include "RlCommon.swig"
 %include "RlCore.swig"
+%include "RlUi.swig"
 %include "RlRules.swig"
-%include "RlUi.swig"
 %include "RlAi.swig"
+%{
+    #include "FixRubyHeaders.h"
+%}
 %include "RlScript.swig"

Modified: rl/branches/persistence2/engine/script/swig/RlRules.swig
===================================================================
--- rl/branches/persistence2/engine/script/swig/RlRules.swig	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/script/swig/RlRules.swig	2009-04-01 20:08:44 UTC (rev 4879)
@@ -119,7 +119,7 @@
         GameObjectFactory();
         virtual ~GameObjectFactory();
     };
-
+    
     class GameObjectManager
     {
     public:
@@ -127,6 +127,7 @@
         rl::GameObject* createGameObject(const Ogre::String& classId, const rl::CeGuiString &id = "");
         rl::GameObject* getGameObject(const rl::CeGuiString id) const;
         void setGameObjectFactory(rl::GameObjectFactory* gof);
+        rl::GameObjectList getAllGameObjects();
 
     private:
         GameObjectManager();
@@ -874,7 +875,7 @@
         unsigned long getSelectionMask() const;
 
         GameObject* getFirstSelectedObject() const;
-		const std::vector<GameObject*>& getAllSelectedObjects() const;
+		const rl::GameObjectList& getAllSelectedObjects() const;
 		unsigned int getSelectionCount() const;
 
 		virtual void updatePrimitive() = 0;
@@ -901,6 +902,16 @@
         void setOrientation(const Ogre::Quaternion& ori);
 		virtual void updatePrimitive();
 	};
+
+    /// Selects GameObjects within a sphere.
+    class SphereSelector : public Selector
+    {
+    public:
+        SphereSelector(unsigned long mask = 0xffffffff);
+	    void setRadius(Ogre::Real radius);
+        void setPosition(const Ogre::Vector3& pos);
+		virtual void updatePrimitive();
+    };
     
     class PartyManager
     {

Modified: rl/branches/persistence2/engine/script/swig/TypeDynamicDirector.swig
===================================================================
--- rl/branches/persistence2/engine/script/swig/TypeDynamicDirector.swig	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/script/swig/TypeDynamicDirector.swig	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,90 +1,90 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-/* Typemaps for all Dynamic or Director Types
- * These typemaps ensure no C++ object 
- * will have links to more than one Ruby objecz
- * 
- */
-
-%{
-static VALUE getInScriptObject( void* ptr, swig_type_info *type )
-{
-    VALUE val = SWIG_RubyInstanceFor( ptr );
-	
-	// Es gab das SkriptObjekt noch nicht
-	if( NIL_P(val) ) 
-		return SWIG_NewPointerObj(ptr, type, 0);			
-	else	
-		return val;
-}
-%}
-
-/// @todo unbenutzt???
-// Actor* getActor oder andere OUTPUT Parameter
-%typemap(out) SWIGTYPE*
-"   $result = getInScriptObject((void *) $1, $1_descriptor );" 
-
-%{
-static VALUE getDirectorInScriptObject( Swig::Director * dir, void* ptr, swig_type_info *type )
-{
-    // Auf Director testen
-    if ( dir ) 
-        return dir->swig_get_self();
-
-	return getInScriptObject( ptr, type );
-}
-%}
-
-/// @todo unbenutzt???
-// doWithActor( Actor* ) oder andere Director-Methoden Parameter
-%typemap(directorin) SWIGTYPE*
-"   $input = getDirectorInScriptObject(dynamic_cast< Swig::Director * >($1), (void *)$1, $1_descriptor);" 
-
-%{
-static VALUE getOutScriptObject( void* ptr, swig_type_info *type )
-{
-	VALUE val = SWIG_RubyInstanceFor( ptr );
-	
-	// Es gab das SkriptObjekt noch nicht
-	if (NIL_P(val))
-	{
-		// Dynamic Cast ausfhren
-		swig_type_info *ty = SWIG_TypeDynamicCast(type, &ptr);
-		return SWIG_NewPointerObj( ptr, ty, 0);		
-	}
-	else	
-		return val;
-}
-%}
-
-// Animation* getActor oder andere OUTPUT Parameter f?r DYNAMICs
-%typemap(out) SWIGTYPE* DYNAMIC, SWIGTYPE& DYNAMIC
-"   $result = getOutScriptObject((void *) $1, $1_descriptor );"
-
-%{
-static VALUE getDirectorOutScriptObject( Swig::Director * dir, void* ptr, swig_type_info *type )
-{
-	if (dir) 
-        return dir->swig_get_self();        	
-
-	return getOutScriptObject( ptr, type );
-}
-%}
-
-// doWithAnimation( Animation* ) oder andere Director-Methoden Parameter fr DYNAMICs
-%typemap(directorin) SWIGTYPE* DYNAMIC, SWIGTYPE& DYNAMIC
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+/* Typemaps for all Dynamic or Director Types
+ * These typemaps ensure no C++ object 
+ * will have links to more than one Ruby objecz
+ * 
+ */
+
+%{
+static VALUE getInScriptObject( void* ptr, swig_type_info *type )
+{
+    VALUE val = SWIG_RubyInstanceFor( ptr );
+	
+	// Es gab das SkriptObjekt noch nicht
+	if( NIL_P(val) ) 
+		return SWIG_NewPointerObj(ptr, type, 0);			
+	else	
+		return val;
+}
+%}
+
+/// @todo unbenutzt???
+// Actor* getActor oder andere OUTPUT Parameter
+%typemap(out) SWIGTYPE*
+"   $result = getInScriptObject((void *) $1, $1_descriptor );" 
+
+%{
+static VALUE getDirectorInScriptObject( Swig::Director * dir, void* ptr, swig_type_info *type )
+{
+    // Auf Director testen
+    if ( dir ) 
+        return dir->swig_get_self();
+
+	return getInScriptObject( ptr, type );
+}
+%}
+
+/// @todo unbenutzt???
+// doWithActor( Actor* ) oder andere Director-Methoden Parameter
+%typemap(directorin) SWIGTYPE*
+"   $input = getDirectorInScriptObject(dynamic_cast< Swig::Director * >($1), (void *)$1, $1_descriptor);" 
+
+%{
+static VALUE getOutScriptObject( void* ptr, swig_type_info *type )
+{
+	VALUE val = SWIG_RubyInstanceFor( ptr );
+	
+	// Es gab das SkriptObjekt noch nicht
+	if (NIL_P(val))
+	{
+		// Dynamic Cast ausfhren
+		swig_type_info *ty = SWIG_TypeDynamicCast(type, &ptr);
+		return SWIG_NewPointerObj( ptr, ty, 0);		
+	}
+	else	
+		return val;
+}
+%}
+
+// Animation* getActor oder andere OUTPUT Parameter f??r DYNAMICs
+%typemap(out) SWIGTYPE* DYNAMIC, SWIGTYPE& DYNAMIC
+"   $result = getOutScriptObject((void *) $1, $1_descriptor );"
+
+%{
+static VALUE getDirectorOutScriptObject( Swig::Director * dir, void* ptr, swig_type_info *type )
+{
+	if (dir) 
+        return dir->swig_get_self();        	
+
+	return getOutScriptObject( ptr, type );
+}
+%}
+
+// doWithAnimation( Animation* ) oder andere Director-Methoden Parameter fr DYNAMICs
+%typemap(directorin) SWIGTYPE* DYNAMIC, SWIGTYPE& DYNAMIC
 "   $input = getDirectorOutScriptObject(dynamic_cast< Swig::Director * >($1), (void *) $1, $1_descriptor );" 
\ No newline at end of file

Modified: rl/branches/persistence2/engine/script/swig/TypeMaps.i
===================================================================
--- rl/branches/persistence2/engine/script/swig/TypeMaps.i	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/script/swig/TypeMaps.i	2009-04-01 20:08:44 UTC (rev 4879)
@@ -17,6 +17,7 @@
 #ifndef __RL_DYNAMICCAST_I__
 #define __RL_DYNAMICCAST_I__
 
+%include "TypeDynamicDirector.swig"
 %include "TypeOgreColourValue.swig"
 %include "TypeOgreQuaternion.swig"
 %include "TypeOgreRadian.swig"
@@ -26,9 +27,9 @@
 %include "TypeOgreVector3.swig"
 %include "TypeRlCeGuiString.swig"
 %include "TypeRlCeGuiStringVector.swig"
+%include "TypeRlGameObjectList.swig"
 %include "TypeRlProperty.swig"
 %include "TypeRlPropertyKeys.swig"
 %include "TypeStdPairIntInt.swig"
-%include "TypeDynamicDirector.swig"
 
 #endif

Copied: rl/branches/persistence2/engine/script/swig/TypeRlGameObjectList.swig (from rev 4878, rl/trunk/engine/script/swig/TypeRlGameObjectList.swig)

Modified: rl/branches/persistence2/engine/startup/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/startup/CMakeLists.txt	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/startup/CMakeLists.txt	2009-04-01 20:08:44 UTC (rev 4879)
@@ -5,6 +5,7 @@
 ${RL_AI_INCLUDE_DIR}
 ${RL_UI_INCLUDE_DIR}
 ${RL_SCRIPT_INCLUDE_DIR}
+${XERCESC_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR}
@@ -17,4 +18,4 @@
 
 TARGET_LINK_LIBRARIES(rastullah RlCommon RlCore RlRules RlAi RlUi RlScript)
 
-INSTALL(TARGETS rastullah RUNTIME DESTINATION ${CMAKE_INSTALL_PREFIX}/${BINDIR})
\ No newline at end of file
+INSTALL(TARGETS rastullah RUNTIME DESTINATION ${CMAKE_INSTALL_PREFIX}/${BINDIR})

Modified: rl/branches/persistence2/engine/startup/RlStartup2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/startup/RlStartup2005.vcproj	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/startup/RlStartup2005.vcproj	2009-04-01 20:08:44 UTC (rev 4879)
@@ -41,7 +41,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;..\common\include;..\script\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\ois\includes"
+				AdditionalIncludeDirectories=".\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;..\common\include;..\script\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\OgreNewt\inc;..\..\dependencies\NewtonSDK\sdk;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\ois\includes"
 				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_CRT_SECURE_NO_DEPRECATE"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -131,7 +131,7 @@
 				Optimization="2"
 				InlineFunctionExpansion="1"
 				OmitFramePointers="true"
-				AdditionalIncludeDirectories=".\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;..\common\include;..\script\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\ois\includes"
+				AdditionalIncludeDirectories=".\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;..\common\include;..\script\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\OgreNewt\inc;..\..\dependencies\NewtonSDK\sdk;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\ois\includes"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_CRT_SECURE_NO_DEPRECATE"
 				StringPooling="true"
 				RuntimeLibrary="2"

Copied: rl/branches/persistence2/engine/startup/RlStartup2008.vcproj (from rev 4878, rl/trunk/engine/startup/RlStartup2008.vcproj)

Modified: rl/branches/persistence2/engine/ui/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/ui/CMakeLists.txt	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/CMakeLists.txt	2009-04-01 20:08:44 UTC (rev 4879)
@@ -4,6 +4,7 @@
 ${RL_CORE_INCLUDE_DIR}
 ${RL_RULES_INCLUDE_DIR}
 ${RL_AI_INCLUDE_DIR}
+${XERCESC_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${OIS_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}

Modified: rl/branches/persistence2/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/ui/RlUI2005.vcproj	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/RlUI2005.vcproj	2009-04-01 20:08:44 UTC (rev 4879)
@@ -46,9 +46,9 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalOptions="-Zm140"
+				AdditionalOptions="-Zm144"
 				Optimization="0"
-				AdditionalIncludeDirectories=".\include;..\common\include;..\ai\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt_ngt\inc;..\..\dependencies\NewtonSDK2\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
+				AdditionalIncludeDirectories=".\include;..\common\include;..\ai\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\inc;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
 				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS,_DEBUG,WIN32,RLUI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -90,7 +90,7 @@
 				OutputFile="$(OutDir)/RlUI.dll"
 				LinkIncremental="2"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt_ngt\lib;..\..\dependencies\NewtonSDK2\sdk\x32\dll_vs7;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;"
+				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;"
 				IgnoreDefaultLibraryNames=""
 				GenerateDebugInformation="true"
 				AssemblyDebug="1"
@@ -162,7 +162,7 @@
 				Optimization="3"
 				EnableIntrinsicFunctions="true"
 				FavorSizeOrSpeed="1"
-				AdditionalIncludeDirectories=".\include;..\common\include;..\ai\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
+				AdditionalIncludeDirectories=".\include;..\common\include;..\ai\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\inc;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
 				PreprocessorDefinitions="WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLUI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"
 				StringPooling="false"
 				ExceptionHandling="1"
@@ -199,7 +199,7 @@
 				OutputFile="$(OutDir)/RlUI.dll"
 				LinkIncremental="1"
 				SuppressStartupBanner="true"
-				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;"
+				AdditionalLibraryDirectories="&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;"
 				ProgramDatabaseFile=""
 				SubSystem="2"
 			/>
@@ -369,6 +369,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\DialogController.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\DialogControlState.h"
 				>
 			</File>
@@ -602,6 +606,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\DialogController.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\DialogControlState.cpp"
 				>
 			</File>

Copied: rl/branches/persistence2/engine/ui/RlUI2008.vcproj (from rev 4878, rl/trunk/engine/ui/RlUI2008.vcproj)

Modified: rl/branches/persistence2/engine/ui/include/DialogControlState.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/DialogControlState.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/include/DialogControlState.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,100 +1,91 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __DialogCharacterController_H__
-#define __DialogCharacterController_H__
-
-#include "UiPrerequisites.h"
-#include "DialogController.h"
-
-namespace rl {
-
-	class Actor;
-    class Creature;
-	class Dialog;
-    class DialogElement;
-	class DialogWindow;
-	class GameLoggerWindow;
-	class MeshAnimation;
-	class SoundObject;
-	class SubtitleWindow;
-
-	/** Diese Klasse
-	  *
-	  */
-	class _RlUiExport DialogControlState : public DialogController
-	{
-	public:
-        enum DialogMode
-		{
-            // Frontperspektive auf Augenh???he, ausgehend von der Mitte zwischen den Redenden
-			DM_FRONT = 1,
-		};
-
-
-		/**
-		*  @throw NullPointerException if camera or character is NULL.
-		*  @throw InvalidArgumentException if character is not placed in the scene.
-		*/
-		DialogControlState(CommandMapper* cmdMapper, Actor* camera, Creature* character);
-		/// Dtor
-		virtual ~DialogControlState();
-
-        virtual void pause();
-        virtual void resume();
-
-		/// @override
-		virtual void run(Ogre::Real elapsedTime);
-
-		void start(Dialog* dialog);
-
-		/// Antwort eines der Dialogf???hrenden
-		void response(Actor* actor, const CeGuiString& text, const Ogre::String& soundFile = "");
-
-		bool handleDialogSelectOption(DialogOption* option);
-		virtual void handleDialogEnd();
-		bool requestDialogClose();
-	    virtual bool textFinished();
-
-	private:
-        enum DialogState
-        {
-            CHOOSING_OPTION = 1,
-            TALKING_PARTNER_CHARACTER,
-            TALKING_PLAYER_CHARACTER,
-            CLOSING_DIALOG
-        };
-
-		/// Die Zielkameraposition in lokalen Koordinaten
-		Ogre::Vector3 mTargetCameraPosition;
-		/// Die ben???tigte lokale Drehung der Kamera
-		Ogre::Vector3 mTargetCameraDirection;
-
-
-        /// Die Art der Kamerapositionierung
-        DialogMode mDialogMode;
-
-        DialogState mDialogState;
-
-
-		DialogWindow* mDialogWindow;
-
-        virtual void recalculateDialogCamera(Creature* speaker, std::list<Creature*> listeners);
-
-        void showOptions(const std::list<DialogOption*>& options);
-	};
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __DialogCharacterController_H__
+#define __DialogCharacterController_H__
+
+#include "UiPrerequisites.h"
+#include "DialogController.h"
+
+namespace rl {
+
+	class Actor;
+    class Creature;
+	class Dialog;
+    class DialogElement;
+	class DialogWindow;
+	class GameLoggerWindow;
+	class MeshAnimation;
+	class SoundObject;
+	class SubtitleWindow;
+
+	/** Diese Klasse
+	  *
+	  */
+	class _RlUiExport DialogControlState : public DialogController
+	{
+	public:
+        enum DialogMode
+		{
+            // Frontperspektive auf Augenh???he, ausgehend von der Mitte zwischen den Redenden
+			DM_FRONT = 1,
+		};
+
+
+		/**
+		*  @throw NullPointerException if camera or character is NULL.
+		*  @throw InvalidArgumentException if character is not placed in the scene.
+		*/
+		DialogControlState(CommandMapper* cmdMapper, Actor* camera, Creature* character);
+		/// Dtor
+		virtual ~DialogControlState();
+
+        virtual void pause();
+        virtual void resume();
+
+		/// @override
+		virtual void run(Ogre::Real elapsedTime);
+
+		void start(Dialog* dialog);
+
+		/// Antwort eines der Dialogf???hrenden
+		void response(Actor* actor, const CeGuiString& text, const Ogre::String& soundFile = "");
+
+		bool handleDialogSelectOption(DialogOption* option);
+		virtual void handleDialogEnd();
+		bool requestDialogClose();
+	    virtual bool textFinished();
+
+	private:
+		/// Die Zielkameraposition in lokalen Koordinaten
+		Ogre::Vector3 mTargetCameraPosition;
+		/// Die ben???tigte lokale Drehung der Kamera
+		Ogre::Vector3 mTargetCameraDirection;
+
+
+        /// Die Art der Kamerapositionierung
+        DialogMode mDialogMode;
+
+
+
+		DialogWindow* mDialogWindow;
+
+        virtual void recalculateDialogCamera(Creature* speaker, std::list<Creature*> listeners);
+
+        void showOptions(const std::list<DialogOption*>& options);
+	};
+}
+#endif

Modified: rl/branches/persistence2/engine/ui/include/DialogController.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/DialogController.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/include/DialogController.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -34,6 +34,16 @@
         virtual bool mouseReleased(const OIS::MouseEvent& evt, OIS::MouseButtonID id, bool handled);
 
     protected:
+        
+        enum DialogState
+        {
+            DS_UNKNOWN = 1,
+            DS_CHOOSING_OPTION,
+            DS_SHOWING_OPTION,
+            DS_SHOWING_RESPONSE,
+            DS_CLOSING_DIALOG
+        };
+        
         DialogController(CommandMapper* commandMapper, Actor* camera, Creature* character,
                 ControlStateType type);
         virtual ~DialogController();
@@ -71,6 +81,7 @@
         Dialog* mDialog;
         GameLoggerWindow* mGameLogger;
         CeGuiString mCurrentResponseText;
+        DialogState mDialogState;
 
         float getShowTextLength(const CeGuiString& text) const;
         void processTextVariables(CeGuiString& text);

Modified: rl/branches/persistence2/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/CombatControlState.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/src/CombatControlState.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,608 +1,608 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h"
-
-#include "CombatControlState.h"
-
-#include "Actor.h"
-#include "CameraObject.h"
-#include "Combat.h"
-#include "CombatGui.h"
-#include "CombatManager.h"
-#include "CommandMapper.h"
-#include "CoreSubsystem.h"
-#include "Creature.h"
-#include "CreatureController.h"
-#include "CreatureControllerManager.h"
-#include "InputManager.h"
-#include "MeshObject.h"
-#include "PhysicalThing.h"
-#include "RulesMessages.h"
-#include "Selector.h"
-#include "UiMessages.h"
-#include "World.h"
-
-using namespace Ogre;
-
-namespace rl {
-    CombatControlState::CombatControlState(CommandMapper* cmdMapper,
-        Actor* camera, Creature* character)
-        : ControlState(cmdMapper, camera, character, CST_COMBAT),
-          Combatant(CombatManager::getSingleton().startCombat(),
-			CreatureControllerManager::getSingleton().getCreatureController(character)),
-		  mAttackedOpponent(NULL),
-		  mParriedOpponent(NULL),
-          mCombatManager(CombatManager::getSingletonPtr()),
-		  mCombatGui(NULL),
-          mEnemySelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
-            QUERYFLAG_CREATURE),
-          mCamera(NULL),
-		  mState(ROUND_EXECUTION),
-          mCameraYaw(0),
-          mCameraPitch(60), // the same value as in resetCamera
-          mMovementState(0),
-          mCameraLinearSpringK(100.0f),
-          mCameraLinearDampingK(Math::NEG_INFINITY),
-          mViewMode(VM_COMBAT_CENTERED),
-          mCameraFocusedCombatant(NULL),
-          mCameraTransitionLookAtActive(false),
-          mCameraTransitionPositionActive(false),
-          mCameraMaxDistance(30.0f),
-          mCameraCombatCenteredMinDistance(5.0f),
-          mCameraThirdPersonMinDistance(1.0f),
-          mCameraSwitchDist(30.0f),
-          mCameraSwitchTransitionDist(0.8f)
-    {
-        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
-        filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
-        mEnemySelector.setFilter(filter);
-
-        // Message handlers
-		mCombatIoAttackOpponentConnection =
-            MessagePump::getSingleton().addMessageHandler<MessageType_CombatIoAttackOpponent>(
-			    boost::bind(&CombatControlState::userRequestAttackOpponent, this, _1));
-		mCombatIoParryOpponentConnection =
-            MessagePump::getSingleton().addMessageHandler<MessageType_CombatIoParryOpponent>(
-			    boost::bind(&CombatControlState::userRequestParryOpponent, this, _1));
-		mCombatIoEndTurnRequestedConnection =
-            MessagePump::getSingleton().addMessageHandler<MessageType_CombatIoEndTurnRequested>(
-			    boost::bind(&CombatControlState::userRequestEndTurn, this));
-		mEnemyLeftCombatConnection =
-            MessagePump::getSingleton().addMessageHandler<MessageType_CombatOpponentLeft>(
-			    boost::bind(&CombatControlState::enemyLeftCombat, this, _1));
-		mCombatEndConnection =
-            MessagePump::getSingleton().addMessageHandler<MessageType_CombatEnded>(
-			    boost::bind(&CombatControlState::combatEnded, this, _1));
-
-        mCamera = static_cast<CameraObject*>(mCameraActor->getControlledObject());
-		mCombatGui = new CombatGui(mCombat, mCamera);
-
-
-        // calculate camera spring-damping system coefficients
-        Real relationCoefficient = 0.8f;
-        mCameraLinearDampingK = relationCoefficient * 2.0 * Math::Sqrt(mCameraLinearSpringK);
-    }
-
-	CombatControlState::~CombatControlState()
-    {
-		delete mCombatGui;
-        delete mEnemySelector.getFilter();
-		CombatManager::getSingleton().stopCombat();
-    }
-
-    void CombatControlState::resume()
-    {
-        // control camera
-        mCameraActor->getPhysicalThing()->setMaterialID(
-        PhysicsManager::getSingleton().getMaterialID("camera"));
-        mCameraActor->getPhysicalThing()->unfreeze();
-        mCameraActor->getPhysicalThing()->setPhysicsController(this);
-        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
-        
-        // We also handle cam<->level, cam<->default cam<->char collision from now on
-        OgreNewt::MaterialPair* mat_pair = NULL;
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("default"));
-        mat_pair->setContactCallback(this);
-        mat_pair->setDefaultCollidable(1);
-        mat_pair->setDefaultFriction(0,0);
-        mat_pair->setDefaultFriction(0,1);
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("level"));
-        mat_pair->setContactCallback(this);
-        mat_pair->setDefaultCollidable(1);
-        mat_pair->setDefaultFriction(0,0);
-        mat_pair->setDefaultFriction(0,1);
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("character"));
-        mat_pair->setContactCallback(this);
-        mat_pair->setDefaultCollidable(1);
-        mat_pair->setDefaultFriction(0,0);
-        mat_pair->setDefaultFriction(0,1);
-
-       
-
-
-        ///\todo Richtig machen, nur tempor?r Ani hier setzen.
-        static_cast<MeshObject*>(mCharacterActor->getControlledObject())
-            ->startAnimation("kampf_schwerter_idle");
-
-        // Set reference to character
-        mEnemySelector.setCheckVisibility(true, mCharacter);
-        mEnemySelector.track(mCharacter);
-        mEnemySelector.setRadius(10.0);
-
-        mEnemySelector.updateSelection();
-        const Selector::GameObjectVector& enemies = mEnemySelector.getAllSelectedObjects();
-        if (!enemies.empty())
-        {
-            for (size_t i = 0; i < enemies.size(); ++i)
-            {
-                mCombat->addOpponent(static_cast<Creature*>(enemies[i]));
-            }
-        }
-        else
-        {
-            // Oops. Nothing to fight. Pop self.
-            InputManager::getSingleton().popControlState();
-            return;
-        }
-
-		mCombatGui->show();
-
-        // We want to play too..
-        mCombat->addAlly(this);
-
-        mCombat->start();
-
-        // reset camera
-        //resetCamera(); // if you don't call this here, the camera should smoothly move to the new position -> looks nicer
-        // perhaps this should be handled differently!
-        mMovementState = 0;
-        // calculate some buffered values, so they are initialized:
-        mCameraTransitionPositionActive = false;
-        mCameraTransitionLookAtActive = false;
-        mCameraFocusedCombatant = this;
-        mCameraYaw = Degree(0);
-        mCameraPitch = Degree(50);
-        mCameraDistance = 30.0f; // only used for third-person
-        mCombatCenter = calculateCombatCenterPosition();
-        mCombatRadius = calculateCombatRadius(mCombatCenter);
-        calculateOptimalCameraPositionAndLookAt();
- 
-        // update CombatGui
-        mCombatGui->update();
-    }
-
-    void CombatControlState::pause()
-    {
-        mCombatGui->hide();
-
-
-        // stop controlling camera actor
-        mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
-        mCameraActor->getPhysicalThing()->freeze();
-        // cam<->Level collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("default"));
-        // cam<->Default collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("level"));
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID("camera"),
-            PhysicsManager::getSingleton().getMaterialID("character"));
-
-        static_cast<MeshObject*>(mCharacterActor->getControlledObject())->stopAllAnimations();
-
-        mCombat->pause();
-    }
-
-    bool CombatControlState::keyPressed(const OIS::KeyEvent& evt, bool handled)
-    {
-        bool retval = false;
-        if( !handled )
-        {
-            int movement = mCommandMapper->getMovement(evt.key);
-            mMovementState |= movement;
-            
-            if( movement != MOVE_NONE )
-                retval = true;
-        }
-
-        if( ControlState::keyPressed(evt, handled || retval) )
-            retval = true;
-
-        return retval;
-    }
-     
-    bool CombatControlState::keyReleased(const OIS::KeyEvent& evt, bool handled)
-    {
-        bool retval = false;
-        int movement = mCommandMapper->getMovement(evt.key);
-        if( movement != MOVE_NONE )
-        {
-            mMovementState &= (~movement);
-            retval = true;
-        }
-
-        if( ControlState::keyReleased(evt, handled || retval) )
-            retval = true;
-        return retval;
-    }
-
-    void CombatControlState::run(Ogre::Real elapsedTime)
-    {
-        // updateCameraLookAt should be called before mCombatGui->update()!
-
-        // update camera look-at position
-        updateCameraLookAt(elapsedTime);
-
-
-        // update CombatGui
-        mCombatGui->update();
-
-
-        // slow down rotational movement, when radius grows
-        if( mMovementState & MOVE_RIGHT )
-            mCameraYaw += Degree( 360.0/2.0 * elapsedTime / Math::Sqrt(mCameraDistance) );
-        if( mMovementState & MOVE_LEFT )
-            mCameraYaw -= Degree( 360.0/2.0 * elapsedTime / Math::Sqrt(mCameraDistance) );
-        if( mMovementState & MOVE_FORWARD )
-            mCameraDistance -= 5 * elapsedTime;
-        if( mMovementState & MOVE_BACKWARD )
-            mCameraDistance += 5 * elapsedTime;
-
-        mCameraDistance = std::max( mCameraDistance, mCameraThirdPersonMinDistance);
-        mCameraDistance = std::min( mCameraDistance, mCameraMaxDistance);
-
-        // switch view mode smoothly if nearer:
-        if( mViewMode == VM_COMBAT_CENTERED )
-        {
-            if( mMovementState & MOVE_FORWARD )
-            {
-                mViewMode = VM_THIRD_PERSON;
-            }
-        }
-        else // VM_THIRD_PERSON
-        {
-            if( mCameraDistance >= mCameraSwitchDist - 0.05f && mMovementState & MOVE_BACKWARD )
-            {
-                mViewMode = VM_COMBAT_CENTERED;
-            }
-        }
-    }
-
-    void CombatControlState::resetCamera(void)
-    {
-        mCombatCenter = calculateCombatCenterPosition();
-        mCombatRadius = calculateCombatRadius(mCombatCenter);
-        mCameraTransitionPositionActive = false;
-        mCameraTransitionLookAtActive = false;
-        mCameraYaw = Degree(0);
-        mCameraPitch = Degree(50);
-        if( mViewMode == VM_THIRD_PERSON )
-            mCameraDistance = 2.0f; // only used for third-person
-        calculateOptimalCameraPositionAndLookAt();
-        mCameraActor->setPosition(mCameraOptPos);
-        SceneNode* cameraNode = mCameraActor->_getSceneNode();
-        cameraNode->lookAt(mCameraLookAt, Node::TS_WORLD);
-    }
-
-    void CombatControlState::updateCameraLookAt(Real elapsedTime)
-    {
-        SceneNode* cameraNode = mCameraActor->_getSceneNode();
-        cameraNode->lookAt(mCameraLookAt, Node::TS_WORLD);
-    }
-
-    Vector3 CombatControlState::calculateCombatCenterPosition()
-    {
-        // get the center of all persons (allies and opponents)
-        int n = 0;
-        Vector3 pos = Vector3::ZERO;
-
-        const Combat::CombatantSet &allies (mCombat->getAllPlayerAllies() );
-        for(Combat::CombatantSet::const_iterator it = allies.begin(); it != allies.end(); it++)
-        {
-            pos += (*it)->getCreature()->getPosition();
-            n++;
-        }
-
-        const Combat::CombatantSet &opponents (mCombat->getAllPlayerOpponents());
-        for(Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); it++)
-        {
-            pos += (*it)->getCreature()->getPosition();
-            n++;
-        }
-
-        if( n > 0 )
-            pos /= n;
-        else
-        {
-            pos = mCharacter->getPosition();
-        }
-
-        return pos;
-    }
-
-    Real CombatControlState::calculateCombatRadius(Vector3 center)
-    {
-        // get the greatest distance from center from all persons
-        Real distance = 0;
-        const Combat::CombatantSet &allies (mCombat->getAllPlayerAllies() );
-        for(Combat::CombatantSet::const_iterator it = allies.begin(); it != allies.end(); it++)
-        {
-            distance = std::max( ( (*it)->getCreature()->getPosition() - center ).length(), distance );
-        }
-        const Combat::CombatantSet &opponents = mCombat->getAllPlayerOpponents();
-        for(Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); it++)
-        {
-            distance = std::max( ( (*it)->getCreature()->getPosition() - center ).length(), distance );
-        }
-        return distance;
-    }
-    
-    void CombatControlState::calculateOptimalCameraPositionAndLookAt()
-    {
-        // some variables:
-        Vector3 playerPos = mCharacter->getPosition();
-        mCombatCenter = calculateCombatCenterPosition();
-        mCombatRadius = calculateCombatRadius(mCombatCenter);
-
-
-
-        // calculate camera-distance for VM_COMBAT_CENTERED (needed for third-person view, too)
-        Real combatCenteredDistance = mCombatRadius + 2; // this is camera-distance from center projected to the plane!
-            
-        // put camera on the line player-center far enough to see all persons
-        // if player is "exactly" in the center, use player orientation as fallback orientation
-        // + rotation from mCameraYaw
-        Vector3 diff = playerPos - mCombatCenter;
-        diff.y = 0;
-        Quaternion combatCenteredCamYaw;
-        combatCenteredCamYaw.FromAngleAxis(mCameraYaw, Vector3::UNIT_Y);
-        if( diff.squaredLength() < 0.01 )
-        {
-            diff = mCharacterActor->getOrientation()*Vector3::UNIT_Z;
-        }
-        diff.y = 0;
-        diff.normalise();
-        diff = combatCenteredCamYaw*diff;
-        diff.y = Math::Tan(mCameraPitch.valueRadians());
-
-        Real cosPitch = Math::Cos(mCameraPitch.valueRadians());
-        combatCenteredDistance = std::max( combatCenteredDistance,  mCameraCombatCenteredMinDistance*cosPitch );
-        combatCenteredDistance = std::min( combatCenteredDistance,  mCameraMaxDistance*cosPitch );
- 
-
-
-
-
-        // TODO
-        // Bewegung wirkt zu eckig... evt hilft es lookat und position separat zu berechnen
-        // und dabei das lookat schneller auf den anvisierten combatant zu setzen...
-        // ideal scheint mir eine "runde" bewegung, a la kamerafahrt!
-
-
-        Vector3 center;
-        Vector3 dist;
-        if( mViewMode == VM_THIRD_PERSON && mCameraFocusedCombatant )
-        {
-            center = mCameraFocusedCombatant->getPosition();
-            // if mCameraDistance is near the one needed for combatCentered,
-            // interpolate the center (between center of third-person-view
-            // and center of combat-centered-view)
-            Real interpolateDist = std::max(0.0f, combatCenteredDistance - mCameraDistance*cosPitch) / cosPitch;
-            if( interpolateDist <  mCameraSwitchTransitionDist*mCameraSwitchDist )
-            {
-                center += (mCombatCenter - center)*(1 - interpolateDist/(mCameraSwitchTransitionDist*mCameraSwitchDist));
-            }
-            dist = mCameraDistance*cosPitch;
-        }
-        else // assume VM_COMBAT_CENTERED
-        {
-            center = mCombatCenter;
-            // update camera-distance variable
-            mCameraDistance = (combatCenteredDistance*diff).length();
-            dist = combatCenteredDistance;
-        }
-
-        mCameraSwitchDist = (combatCenteredDistance*diff).length();
-        mCameraOptPos = center + dist*diff;
-        mCameraLookAt = center + 1.4*Vector3::UNIT_Y;
-    }
-
-    void CombatControlState::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
-    {
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-
-        calculateOptimalCameraPositionAndLookAt();
-
-        // handle transition
-        if( mCameraTransitionPositionActive )
-        {
-            Vector3 diff = mCameraOptPos - mCameraTransitionPosition;
-            Real dist = diff.length();
-            Vector3 dir = diff/dist;
-            mCameraTransitionPosition += dir*std::min(dist, 0.5f*timestep);
-            if( (mCameraTransitionPosition - mCameraOptPos).squaredLength() < 0.02 )
-                mCameraTransitionPositionActive = false;
-            mCameraOptPos = mCameraTransitionPosition;
-        }
-        if( mCameraTransitionLookAtActive )
-        {
-            Vector3 diff = mCameraLookAt - mCameraTransitionLookAt;
-            Real dist = diff.length();
-            Vector3 dir = diff/dist;
-            mCameraTransitionLookAt += dir * std::min(dist,0.5f*timestep);
-            if( (mCameraLookAt-mCameraTransitionLookAt).squaredLength() < 0.02 )
-                mCameraTransitionLookAtActive = false;
-            mCameraLookAt = mCameraTransitionLookAt;
-        }
-
-
-        Vector3 diff = camPos - mCameraOptPos;
-        Vector3 cameraVelocity;
-        cameraVelocity = mCamBody->getVelocity();
-        // spring velocity
-        Vector3 springAcc = -mCameraLinearSpringK*diff - mCameraLinearDampingK * cameraVelocity;
-                                            
-        // get the camera mass
-        Real mass;
-        Vector3 inertia;
-        mCamBody->getMassMatrix(mass, inertia);
-                                                
-        mCamBody->setForce(springAcc * mass);
-    }
-
-    void CombatControlState::setViewMode(ViewMode mode)
-    {
-        if(mode != mViewMode)
-        {
-            mViewMode = mode;
-            mCameraTransitionPosition = mCameraActor->getPosition();
-            mCameraTransitionLookAt = mCameraLookAt;
-            mCameraTransitionLookAtActive = true;
-            mCameraTransitionPositionActive = true;
-        }
-    }
-
-    void CombatControlState::toggleViewMode()
-    {
-        if( mViewMode == VM_COMBAT_CENTERED )
-            setViewMode(VM_THIRD_PERSON);
-        else
-            setViewMode(VM_COMBAT_CENTERED);
-    }
-
-    CombatControlState::ViewMode CombatControlState::getViewMode()
-    {
-        return mViewMode;
-    }
-
-    void CombatControlState::setCameraFocusedCombatant(Combatant* combatant)
-    {
-        if( combatant != mCameraFocusedCombatant )
-        {
-            if( mViewMode == VM_THIRD_PERSON )
-            {
-                mCameraTransitionPosition = mCameraActor->getPosition();
-                mCameraTransitionLookAt = mCameraLookAt;
-                mCameraTransitionLookAtActive = true;
-                mCameraTransitionPositionActive = true;
-            }
-        }
-        mCameraFocusedCombatant = combatant;
-    }
-
-    int CombatControlState::onAABBOverlap(OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex)
-    {
-        // TODO handle camera collisions here
-        return 0;
-    }
-   
-    void CombatControlState::userProcess(OgreNewt::ContactJoint &contactJoint, Ogre::Real timestep, int threadIndex)
-    {
-        // TODO handle camera collisions here
-    }
-
-    Ogre::String CombatControlState::getCombatantTypeName() const
-    {
-        return "CombatControlState";
-    }
-
-    void CombatControlState::requestCombatantAction()
-    {
-        // Change state to allow user to choose actions for next round.
-		mState = REQUEST_USER_INPUT;
-		mCombatGui->enableUserInput(true);
-    }
-
-	bool CombatControlState::userRequestAttackOpponent(Combatant* opponent)
-	{
-		mAttackedOpponent = opponent;
-		return true;
-	}
-
-	bool CombatControlState::userRequestParryOpponent(Combatant* opponent)
-	{
-		mParriedOpponent = opponent;
-		return true;
-	}
-
-	bool CombatControlState::userRequestEndTurn()
-	{
-		// Only handle, if we accept user input now.
-		if (mState != REQUEST_USER_INPUT)
-		{
-			return true;
-		}
-
-		// Do we want to attack someone?
-		if (mAttackedOpponent)
-		{
-			// Are we in weapon range to opponent
-			if (mCombat->canAttack(this, mAttackedOpponent))
-			{
-				// Ok, we can attack
-				mCombat->registerAttacke(this, mAttackedOpponent);
-			}
-			else
-			{
-				// We can't attack from here, so go to opponent.
-				mCombat->registerFolgen(this, mAttackedOpponent);
-			}
-		}
-		if (mParriedOpponent)
-		{
-			mCombat->registerParade(this);
-		}
-
-		mCombat->registerCombatantRoundDone(this);
-
-		mState = ROUND_EXECUTION;
-
-		return true;
-	}
-
-	bool CombatControlState::enemyLeftCombat(Combatant* opponent)
-	{
-		// Make sure we don't have any dangling pointers on invalid Combatants.
-
-		if (opponent == mAttackedOpponent)
-		{
-			mAttackedOpponent = NULL;
-		}
-		if (opponent == mParriedOpponent)
-		{
-			mParriedOpponent = NULL;
-		}
-		return true;
-	}
-
-    bool CombatControlState::combatEnded(bool alliesWon)
-    {
-        ///@todo some feedback, Abenteuerpunkte, anything? 
-        InputManager::getSingleton().popControlState();
-        return true;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h"
+
+#include "CombatControlState.h"
+
+#include "Actor.h"
+#include "CameraObject.h"
+#include "Combat.h"
+#include "CombatGui.h"
+#include "CombatManager.h"
+#include "CommandMapper.h"
+#include "CoreSubsystem.h"
+#include "Creature.h"
+#include "CreatureController.h"
+#include "CreatureControllerManager.h"
+#include "InputManager.h"
+#include "MeshObject.h"
+#include "PhysicalThing.h"
+#include "RulesMessages.h"
+#include "Selector.h"
+#include "UiMessages.h"
+#include "World.h"
+
+using namespace Ogre;
+
+namespace rl {
+    CombatControlState::CombatControlState(CommandMapper* cmdMapper,
+        Actor* camera, Creature* character)
+        : ControlState(cmdMapper, camera, character, CST_COMBAT),
+          Combatant(CombatManager::getSingleton().startCombat(),
+			CreatureControllerManager::getSingleton().getCreatureController(character)),
+		  mAttackedOpponent(NULL),
+		  mParriedOpponent(NULL),
+          mCombatManager(CombatManager::getSingletonPtr()),
+		  mCombatGui(NULL),
+          mEnemySelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
+            QUERYFLAG_CREATURE),
+          mCamera(NULL),
+		  mState(ROUND_EXECUTION),
+          mCameraYaw(0),
+          mCameraPitch(60), // the same value as in resetCamera
+          mMovementState(0),
+          mCameraLinearSpringK(100.0f),
+          mCameraLinearDampingK(Math::NEG_INFINITY),
+          mViewMode(VM_COMBAT_CENTERED),
+          mCameraFocusedCombatant(NULL),
+          mCameraTransitionLookAtActive(false),
+          mCameraTransitionPositionActive(false),
+          mCameraMaxDistance(30.0f),
+          mCameraCombatCenteredMinDistance(5.0f),
+          mCameraThirdPersonMinDistance(1.0f),
+          mCameraSwitchDist(30.0f),
+          mCameraSwitchTransitionDist(0.8f)
+    {
+        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
+        filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
+        mEnemySelector.setFilter(filter);
+
+        // Message handlers
+		mCombatIoAttackOpponentConnection =
+            MessagePump::getSingleton().addMessageHandler<MessageType_CombatIoAttackOpponent>(
+			    boost::bind(&CombatControlState::userRequestAttackOpponent, this, _1));
+		mCombatIoParryOpponentConnection =
+            MessagePump::getSingleton().addMessageHandler<MessageType_CombatIoParryOpponent>(
+			    boost::bind(&CombatControlState::userRequestParryOpponent, this, _1));
+		mCombatIoEndTurnRequestedConnection =
+            MessagePump::getSingleton().addMessageHandler<MessageType_CombatIoEndTurnRequested>(
+			    boost::bind(&CombatControlState::userRequestEndTurn, this));
+		mEnemyLeftCombatConnection =
+            MessagePump::getSingleton().addMessageHandler<MessageType_CombatOpponentLeft>(
+			    boost::bind(&CombatControlState::enemyLeftCombat, this, _1));
+		mCombatEndConnection =
+            MessagePump::getSingleton().addMessageHandler<MessageType_CombatEnded>(
+			    boost::bind(&CombatControlState::combatEnded, this, _1));
+
+        mCamera = static_cast<CameraObject*>(mCameraActor->getControlledObject());
+		mCombatGui = new CombatGui(mCombat, mCamera);
+
+
+        // calculate camera spring-damping system coefficients
+        Real relationCoefficient = 0.8f;
+        mCameraLinearDampingK = relationCoefficient * 2.0 * Math::Sqrt(mCameraLinearSpringK);
+    }
+
+	CombatControlState::~CombatControlState()
+    {
+		delete mCombatGui;
+        delete mEnemySelector.getFilter();
+		CombatManager::getSingleton().stopCombat();
+    }
+
+    void CombatControlState::resume()
+    {
+        // control camera
+        mCameraActor->getPhysicalThing()->setMaterialID(
+        PhysicsManager::getSingleton().getMaterialID("camera"));
+        mCameraActor->getPhysicalThing()->unfreeze();
+        mCameraActor->getPhysicalThing()->setPhysicsController(this);
+        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
+        
+        // We also handle cam<->level, cam<->default cam<->char collision from now on
+        OgreNewt::MaterialPair* mat_pair = NULL;
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("default"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setDefaultFriction(0,1);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("level"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setDefaultFriction(0,1);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"));
+        mat_pair->setContactCallback(this);
+        mat_pair->setDefaultCollidable(1);
+        mat_pair->setDefaultFriction(0,0);
+        mat_pair->setDefaultFriction(0,1);
+
+       
+
+
+        ///\todo Richtig machen, nur tempor???r Ani hier setzen.
+        static_cast<MeshObject*>(mCharacterActor->getControlledObject())
+            ->startAnimation("kampf_schwerter_idle");
+
+        // Set reference to character
+        mEnemySelector.setCheckVisibility(true, mCharacter);
+        mEnemySelector.track(mCharacter);
+        mEnemySelector.setRadius(10.0);
+
+        mEnemySelector.updateSelection();
+        const GameObjectList& enemies = mEnemySelector.getAllSelectedObjects();
+        if (!enemies.empty())
+        {
+            for (GameObjectList::const_iterator it = enemies.begin(); it != enemies.end(); ++it)
+            {
+                mCombat->addOpponent(static_cast<Creature*>(*it));
+            }
+        }
+        else
+        {
+            // Oops. Nothing to fight. Pop self.
+            InputManager::getSingleton().popControlState();
+            return;
+        }
+
+		mCombatGui->show();
+
+        // We want to play too..
+        mCombat->addAlly(this);
+
+        mCombat->start();
+
+        // reset camera
+        //resetCamera(); // if you don't call this here, the camera should smoothly move to the new position -> looks nicer
+        // perhaps this should be handled differently!
+        mMovementState = 0;
+        // calculate some buffered values, so they are initialized:
+        mCameraTransitionPositionActive = false;
+        mCameraTransitionLookAtActive = false;
+        mCameraFocusedCombatant = this;
+        mCameraYaw = Degree(0);
+        mCameraPitch = Degree(50);
+        mCameraDistance = 30.0f; // only used for third-person
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+        calculateOptimalCameraPositionAndLookAt();
+ 
+        // update CombatGui
+        mCombatGui->update();
+    }
+
+    void CombatControlState::pause()
+    {
+        mCombatGui->hide();
+
+
+        // stop controlling camera actor
+        mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
+        mCameraActor->getPhysicalThing()->freeze();
+        // cam<->Level collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("default"));
+        // cam<->Default collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("level"));
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID("camera"),
+            PhysicsManager::getSingleton().getMaterialID("character"));
+
+        static_cast<MeshObject*>(mCharacterActor->getControlledObject())->stopAllAnimations();
+
+        mCombat->pause();
+    }
+
+    bool CombatControlState::keyPressed(const OIS::KeyEvent& evt, bool handled)
+    {
+        bool retval = false;
+        if( !handled )
+        {
+            int movement = mCommandMapper->getMovement(evt.key);
+            mMovementState |= movement;
+            
+            if( movement != MOVE_NONE )
+                retval = true;
+        }
+
+        if( ControlState::keyPressed(evt, handled || retval) )
+            retval = true;
+
+        return retval;
+    }
+     
+    bool CombatControlState::keyReleased(const OIS::KeyEvent& evt, bool handled)
+    {
+        bool retval = false;
+        int movement = mCommandMapper->getMovement(evt.key);
+        if( movement != MOVE_NONE )
+        {
+            mMovementState &= (~movement);
+            retval = true;
+        }
+
+        if( ControlState::keyReleased(evt, handled || retval) )
+            retval = true;
+        return retval;
+    }
+
+    void CombatControlState::run(Ogre::Real elapsedTime)
+    {
+        // updateCameraLookAt should be called before mCombatGui->update()!
+
+        // update camera look-at position
+        updateCameraLookAt(elapsedTime);
+
+
+        // update CombatGui
+        mCombatGui->update();
+
+
+        // slow down rotational movement, when radius grows
+        if( mMovementState & MOVE_RIGHT )
+            mCameraYaw += Degree( 360.0/2.0 * elapsedTime / Math::Sqrt(mCameraDistance) );
+        if( mMovementState & MOVE_LEFT )
+            mCameraYaw -= Degree( 360.0/2.0 * elapsedTime / Math::Sqrt(mCameraDistance) );
+        if( mMovementState & MOVE_FORWARD )
+            mCameraDistance -= 5 * elapsedTime;
+        if( mMovementState & MOVE_BACKWARD )
+            mCameraDistance += 5 * elapsedTime;
+
+        mCameraDistance = std::max( mCameraDistance, mCameraThirdPersonMinDistance);
+        mCameraDistance = std::min( mCameraDistance, mCameraMaxDistance);
+
+        // switch view mode smoothly if nearer:
+        if( mViewMode == VM_COMBAT_CENTERED )
+        {
+            if( mMovementState & MOVE_FORWARD )
+            {
+                mViewMode = VM_THIRD_PERSON;
+            }
+        }
+        else // VM_THIRD_PERSON
+        {
+            if( mCameraDistance >= mCameraSwitchDist - 0.05f && mMovementState & MOVE_BACKWARD )
+            {
+                mViewMode = VM_COMBAT_CENTERED;
+            }
+        }
+    }
+
+    void CombatControlState::resetCamera(void)
+    {
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+        mCameraTransitionPositionActive = false;
+        mCameraTransitionLookAtActive = false;
+        mCameraYaw = Degree(0);
+        mCameraPitch = Degree(50);
+        if( mViewMode == VM_THIRD_PERSON )
+            mCameraDistance = 2.0f; // only used for third-person
+        calculateOptimalCameraPositionAndLookAt();
+        mCameraActor->setPosition(mCameraOptPos);
+        SceneNode* cameraNode = mCameraActor->_getSceneNode();
+        cameraNode->lookAt(mCameraLookAt, Node::TS_WORLD);
+    }
+
+    void CombatControlState::updateCameraLookAt(Real elapsedTime)
+    {
+        SceneNode* cameraNode = mCameraActor->_getSceneNode();
+        cameraNode->lookAt(mCameraLookAt, Node::TS_WORLD);
+    }
+
+    Vector3 CombatControlState::calculateCombatCenterPosition()
+    {
+        // get the center of all persons (allies and opponents)
+        int n = 0;
+        Vector3 pos = Vector3::ZERO;
+
+        const Combat::CombatantSet &allies (mCombat->getAllPlayerAllies() );
+        for(Combat::CombatantSet::const_iterator it = allies.begin(); it != allies.end(); it++)
+        {
+            pos += (*it)->getCreature()->getPosition();
+            n++;
+        }
+
+        const Combat::CombatantSet &opponents (mCombat->getAllPlayerOpponents());
+        for(Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); it++)
+        {
+            pos += (*it)->getCreature()->getPosition();
+            n++;
+        }
+
+        if( n > 0 )
+            pos /= n;
+        else
+        {
+            pos = mCharacter->getPosition();
+        }
+
+        return pos;
+    }
+
+    Real CombatControlState::calculateCombatRadius(Vector3 center)
+    {
+        // get the greatest distance from center from all persons
+        Real distance = 0;
+        const Combat::CombatantSet &allies (mCombat->getAllPlayerAllies() );
+        for(Combat::CombatantSet::const_iterator it = allies.begin(); it != allies.end(); it++)
+        {
+            distance = std::max( ( (*it)->getCreature()->getPosition() - center ).length(), distance );
+        }
+        const Combat::CombatantSet &opponents = mCombat->getAllPlayerOpponents();
+        for(Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); it++)
+        {
+            distance = std::max( ( (*it)->getCreature()->getPosition() - center ).length(), distance );
+        }
+        return distance;
+    }
+    
+    void CombatControlState::calculateOptimalCameraPositionAndLookAt()
+    {
+        // some variables:
+        Vector3 playerPos = mCharacter->getPosition();
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+
+
+
+        // calculate camera-distance for VM_COMBAT_CENTERED (needed for third-person view, too)
+        Real combatCenteredDistance = mCombatRadius + 2; // this is camera-distance from center projected to the plane!
+            
+        // put camera on the line player-center far enough to see all persons
+        // if player is "exactly" in the center, use player orientation as fallback orientation
+        // + rotation from mCameraYaw
+        Vector3 diff = playerPos - mCombatCenter;
+        diff.y = 0;
+        Quaternion combatCenteredCamYaw;
+        combatCenteredCamYaw.FromAngleAxis(mCameraYaw, Vector3::UNIT_Y);
+        if( diff.squaredLength() < 0.01 )
+        {
+            diff = mCharacterActor->getOrientation()*Vector3::UNIT_Z;
+        }
+        diff.y = 0;
+        diff.normalise();
+        diff = combatCenteredCamYaw*diff;
+        diff.y = Math::Tan(mCameraPitch.valueRadians());
+
+        Real cosPitch = Math::Cos(mCameraPitch.valueRadians());
+        combatCenteredDistance = std::max( combatCenteredDistance,  mCameraCombatCenteredMinDistance*cosPitch );
+        combatCenteredDistance = std::min( combatCenteredDistance,  mCameraMaxDistance*cosPitch );
+ 
+
+
+
+
+        // TODO
+        // Bewegung wirkt zu eckig... evt hilft es lookat und position separat zu berechnen
+        // und dabei das lookat schneller auf den anvisierten combatant zu setzen...
+        // ideal scheint mir eine "runde" bewegung, a la kamerafahrt!
+
+
+        Vector3 center;
+        Vector3 dist;
+        if( mViewMode == VM_THIRD_PERSON && mCameraFocusedCombatant )
+        {
+            center = mCameraFocusedCombatant->getPosition();
+            // if mCameraDistance is near the one needed for combatCentered,
+            // interpolate the center (between center of third-person-view
+            // and center of combat-centered-view)
+            Real interpolateDist = std::max(0.0f, combatCenteredDistance - mCameraDistance*cosPitch) / cosPitch;
+            if( interpolateDist <  mCameraSwitchTransitionDist*mCameraSwitchDist )
+            {
+                center += (mCombatCenter - center)*(1 - interpolateDist/(mCameraSwitchTransitionDist*mCameraSwitchDist));
+            }
+            dist = mCameraDistance*cosPitch;
+        }
+        else // assume VM_COMBAT_CENTERED
+        {
+            center = mCombatCenter;
+            // update camera-distance variable
+            mCameraDistance = (combatCenteredDistance*diff).length();
+            dist = combatCenteredDistance;
+        }
+
+        mCameraSwitchDist = (combatCenteredDistance*diff).length();
+        mCameraOptPos = center + dist*diff;
+        mCameraLookAt = center + 1.4*Vector3::UNIT_Y;
+    }
+
+    void CombatControlState::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
+    {
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody->getPositionOrientation(camPos, camOri);
+
+        calculateOptimalCameraPositionAndLookAt();
+
+        // handle transition
+        if( mCameraTransitionPositionActive )
+        {
+            Vector3 diff = mCameraOptPos - mCameraTransitionPosition;
+            Real dist = diff.length();
+            Vector3 dir = diff/dist;
+            mCameraTransitionPosition += dir*std::min(dist, 0.5f*timestep);
+            if( (mCameraTransitionPosition - mCameraOptPos).squaredLength() < 0.02 )
+                mCameraTransitionPositionActive = false;
+            mCameraOptPos = mCameraTransitionPosition;
+        }
+        if( mCameraTransitionLookAtActive )
+        {
+            Vector3 diff = mCameraLookAt - mCameraTransitionLookAt;
+            Real dist = diff.length();
+            Vector3 dir = diff/dist;
+            mCameraTransitionLookAt += dir * std::min(dist,0.5f*timestep);
+            if( (mCameraLookAt-mCameraTransitionLookAt).squaredLength() < 0.02 )
+                mCameraTransitionLookAtActive = false;
+            mCameraLookAt = mCameraTransitionLookAt;
+        }
+
+
+        Vector3 diff = camPos - mCameraOptPos;
+        Vector3 cameraVelocity;
+        cameraVelocity = mCamBody->getVelocity();
+        // spring velocity
+        Vector3 springAcc = -mCameraLinearSpringK*diff - mCameraLinearDampingK * cameraVelocity;
+                                            
+        // get the camera mass
+        Real mass;
+        Vector3 inertia;
+        mCamBody->getMassMatrix(mass, inertia);
+                                                
+        mCamBody->setForce(springAcc * mass);
+    }
+
+    void CombatControlState::setViewMode(ViewMode mode)
+    {
+        if(mode != mViewMode)
+        {
+            mViewMode = mode;
+            mCameraTransitionPosition = mCameraActor->getPosition();
+            mCameraTransitionLookAt = mCameraLookAt;
+            mCameraTransitionLookAtActive = true;
+            mCameraTransitionPositionActive = true;
+        }
+    }
+
+    void CombatControlState::toggleViewMode()
+    {
+        if( mViewMode == VM_COMBAT_CENTERED )
+            setViewMode(VM_THIRD_PERSON);
+        else
+            setViewMode(VM_COMBAT_CENTERED);
+    }
+
+    CombatControlState::ViewMode CombatControlState::getViewMode()
+    {
+        return mViewMode;
+    }
+
+    void CombatControlState::setCameraFocusedCombatant(Combatant* combatant)
+    {
+        if( combatant != mCameraFocusedCombatant )
+        {
+            if( mViewMode == VM_THIRD_PERSON )
+            {
+                mCameraTransitionPosition = mCameraActor->getPosition();
+                mCameraTransitionLookAt = mCameraLookAt;
+                mCameraTransitionLookAtActive = true;
+                mCameraTransitionPositionActive = true;
+            }
+        }
+        mCameraFocusedCombatant = combatant;
+    }
+
+    int CombatControlState::onAABBOverlap(OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex)
+    {
+        // TODO handle camera collisions here
+        return 0;
+    }
+   
+    void CombatControlState::userProcess(OgreNewt::ContactJoint &contactJoint, Ogre::Real timestep, int threadIndex)
+    {
+        // TODO handle camera collisions here
+    }
+
+    Ogre::String CombatControlState::getCombatantTypeName() const
+    {
+        return "CombatControlState";
+    }
+
+    void CombatControlState::requestCombatantAction()
+    {
+        // Change state to allow user to choose actions for next round.
+		mState = REQUEST_USER_INPUT;
+		mCombatGui->enableUserInput(true);
+    }
+
+	bool CombatControlState::userRequestAttackOpponent(Combatant* opponent)
+	{
+		mAttackedOpponent = opponent;
+		return true;
+	}
+
+	bool CombatControlState::userRequestParryOpponent(Combatant* opponent)
+	{
+		mParriedOpponent = opponent;
+		return true;
+	}
+
+	bool CombatControlState::userRequestEndTurn()
+	{
+		// Only handle, if we accept user input now.
+		if (mState != REQUEST_USER_INPUT)
+		{
+			return true;
+		}
+
+		// Do we want to attack someone?
+		if (mAttackedOpponent)
+		{
+			// Are we in weapon range to opponent
+			if (mCombat->canAttack(this, mAttackedOpponent))
+			{
+				// Ok, we can attack
+				mCombat->registerAttacke(this, mAttackedOpponent);
+			}
+			else
+			{
+				// We can't attack from here, so go to opponent.
+				mCombat->registerFolgen(this, mAttackedOpponent);
+			}
+		}
+		if (mParriedOpponent)
+		{
+			mCombat->registerParade(this);
+		}
+
+		mCombat->registerCombatantRoundDone(this);
+
+		mState = ROUND_EXECUTION;
+
+		return true;
+	}
+
+	bool CombatControlState::enemyLeftCombat(Combatant* opponent)
+	{
+		// Make sure we don't have any dangling pointers on invalid Combatants.
+
+		if (opponent == mAttackedOpponent)
+		{
+			mAttackedOpponent = NULL;
+		}
+		if (opponent == mParriedOpponent)
+		{
+			mParriedOpponent = NULL;
+		}
+		return true;
+	}
+
+    bool CombatControlState::combatEnded(bool alliesWon)
+    {
+        ///@todo some feedback, Abenteuerpunkte, anything? 
+        InputManager::getSingleton().popControlState();
+        return true;
+    }
+}

Modified: rl/branches/persistence2/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/DialogControlState.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/src/DialogControlState.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -62,7 +62,8 @@
         : DialogController(cmdMapper, camera, character, CST_DIALOG),
         mTargetCameraPosition(Vector3::ZERO),
         mTargetCameraDirection(Vector3::UNIT_Z),
-        mDialogMode(DM_FRONT)
+        mDialogMode(DM_FRONT),
+        mDialogWindow(NULL)
     {
     }
 
@@ -254,7 +255,7 @@
 
         if (!DialogController::textFinished())
         {
-            if (mDialogState == TALKING_PARTNER_CHARACTER)
+            if (mDialogState == DS_SHOWING_RESPONSE)
             {
 
                 DialogResponse::Options options = mCurrentResponse->getAvailableOptions(mDialog);
@@ -267,9 +268,9 @@
                 }
                 mDialogWindow->setAvailableOptions(options);
                 mDialogWindow->setVisible(true);
-                mDialogState = CHOOSING_OPTION;
+                mDialogState = DS_CHOOSING_OPTION;
             }
-            else if (mDialogState == TALKING_PLAYER_CHARACTER)
+            else if (mDialogState == DS_SHOWING_OPTION)
             {
                 showResponse(mCurrentOption->getResponse());
             }
@@ -294,7 +295,7 @@
             mCurrentOption = option;
         }
 
-        mDialogState = TALKING_PLAYER_CHARACTER;
+        mDialogState = DS_SHOWING_OPTION;
         mCurrentParagraphs = mCurrentOption->getParagraphs(mDialog);
         doTalk(mCurrentParagraphs.front());
 

Modified: rl/branches/persistence2/engine/ui/src/DialogController.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/DialogController.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/src/DialogController.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -42,7 +42,8 @@
         mDialogWindow(NULL),
         mCurrentResponseText(""),
         mGameLogger(NULL),
-        mCurrentSpeaker(NULL)
+        mCurrentSpeaker(NULL),
+        mDialogState(DS_UNKNOWN)
     {
         mSubtitleSpeed = ConfigurationManager::getSingleton().getRealSetting(
             "General", "Subtitle Speed");
@@ -153,6 +154,8 @@
             handleDialogEnd();
             return;
         }
+        
+        mDialogState = DS_SHOWING_RESPONSE;
 
         if (response->isSelection())
         {
@@ -320,5 +323,7 @@
 
             return true;
         }
+
+		return false;
     }
 }

Modified: rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -29,6 +29,9 @@
 #include "CommandMapper.h"
 #include "MeshObject.h"
 #include "WindowManager.h"
+#include "CreatureControllerManager.h"
+#include "Creature.h"
+#include "PhysicsRagDoll.h"
 
 using namespace Ogre;
 
@@ -61,7 +64,8 @@
     {
 		mCameraActor->getPhysicalThing()->freeze();
 		//mCharacterActor->getPhysicalThing()->unfreeze();
-        delete mOgreNewtPlayerController;
+//        delete mOgreNewtPlayerController;
+
         mOgreNewtPlayerController = NULL;
         mCharacterActor->getPhysicalThing()->setUpConstraint();
         mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
@@ -84,7 +88,7 @@
         mCameraActor->getPhysicalThing()->unfreeze();
 		//mCharacterActor->getPhysicalThing()->freeze();
         mCharacterActor->getPhysicalThing()->clearUpConstraint();
-        mOgreNewtPlayerController = new OgreNewt::PlayerController(mCharBody);
+//        mOgreNewtPlayerController = new OgreNewt::PlayerController(mCharBody);
 
         resetCamera();
 
@@ -164,7 +168,8 @@
             // put character here
             if( mCharacterActor != NULL )
             {
-                mCharacterActor->setPosition(
+                //mCharacterActor->setPosition(
+                mCharacterActor->getPhysicalThing()->setPosition(
                     mCameraActor->getPosition()
                     + mCameraActor->getWorldOrientation() * Vector3::NEGATIVE_UNIT_Z * 2
                     - 1.5 * Vector3::UNIT_Y);
@@ -213,8 +218,8 @@
         if (mPitch < mPitchRange.first) mPitch = mPitchRange.first;
         if (mPitch > mPitchRange.second) mPitch = mPitchRange.second;
 
-if( mCollisionsEnabled )
-    mOgreNewtPlayerController->setVelocity(mDesiredVelocity.z, mDesiredVelocity.x, mYaw);
+//if( mCollisionsEnabled )
+//    mOgreNewtPlayerController->setVelocity(mDesiredVelocity.z, mDesiredVelocity.x, mYaw);
 
         mCameraActor->setOrientation(Quaternion::IDENTITY);
         mCameraActor->yaw(mYaw.valueDegrees());
@@ -232,6 +237,20 @@
 		// with or without collision?
         // be careful to enable collision if beeing in another collision
         mCollisionsEnabled = !mCollisionsEnabled;
+
+        if( mCollisionsEnabled )
+        {
+            CreatureControllerManager::getSingleton().detachController(mCharacter);
+            PhysicsManager::getSingleton().destroyPhysicsProxy(mCharacterActor->getPhysicalThing());
+            PhysicsManager::getSingleton().createPhysicsProxy_RagDoll(mCharacterActor->getPhysicalThing());
+        }
+        else
+        {
+            PhysicsManager::getSingleton().destroyPhysicsProxy(mCharacterActor->getPhysicalThing());
+            PhysicsManager::getSingleton().createPhysicsProxy(mCharacterActor->getPhysicalThing());
+            CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
+        }
+
 	}
 
 	void FreeflightControlState::resetCamera()
@@ -285,7 +304,7 @@
             }
             else if (command == "toggle_camera_collision" )
             {
-                mCollisionsEnabled = !mCollisionsEnabled;
+                toggleCameraCollision();
                 retval = true;
             }
         }

Modified: rl/branches/persistence2/engine/ui/src/InputManager.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/InputManager.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/src/InputManager.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -121,7 +121,7 @@
         #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
             pl.insert(std::make_pair(std::string("w32_keyboard"), std::string("DISCL_EXCLUSIVE")));
             pl.insert(std::make_pair(std::string("w32_keyboard"), std::string("DISCL_FOREGROUND")));
-        #elif OGRE_PLATFORM == OGRE_PLATFORM_LINUX & defined DEBUG
+        #elif OGRE_PLATFORM == OGRE_PLATFORM_LINUX & defined _DEBUG
             pl.insert(std::make_pair(std::string("x11_mouse_grab"), std::string("false")));
             pl.insert(std::make_pair(std::string("x11_keyboard_grab"), std::string("false")));
         #endif

Modified: rl/branches/persistence2/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/InventoryWindow.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/src/InventoryWindow.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -458,14 +458,14 @@
 
 		mMouseSelector->setRay(camToWorld.getOrigin(), camToWorld.getPoint(3));
 		mMouseSelector->updateSelection();
-		Selector::GameObjectVector objs = mMouseSelector->getAllSelectedObjects();
+		GameObjectList objs = mMouseSelector->getAllSelectedObjects();
 
 		///@todo select, ...
 		if (!objs.empty())
 		{
 			LOG_MESSAGE(Logger::UI,
 				"Selected "+Ogre::StringConverter::toString(objs.size())+" items.");
-			for (Selector::GameObjectVector::const_iterator it = objs.begin();
+			for (GameObjectList::const_iterator it = objs.begin();
 				it != objs.end(); ++it)
 			{
                 if( !mInventory->getOwner()->canReachItem(static_cast<Item*>(*it)) )
@@ -528,8 +528,8 @@
 				sel.setRadius(10.0);
 
 				sel.updateSelection();
-				Selector::GameObjectVector v = sel.getAllSelectedObjects();
-				for (Selector::GameObjectVector::iterator
+				GameObjectList v = sel.getAllSelectedObjects();
+				for (GameObjectList::iterator
 					it = v.begin(); it != v.end(); ++it)
 				{
                     if( !mInventory->getOwner()->canReachItem(static_cast<Item*>(*it)) )

Modified: rl/branches/persistence2/engine/ui/src/MainMenuWindow.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/MainMenuWindow.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/src/MainMenuWindow.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -102,16 +102,25 @@
 		MenuBase* modulesMenu = getMenu("MainMenu/Modules/Menu");
 
 		ItemEntry* itOld = NULL;
+        CeGuiString activeName;
+        activeName = mActiveModule->getName();
 		for (size_t i=0; i<modulesMenu->getItemCount(); i++)
 		{
 			ItemEntry* curr = modulesMenu->getItemFromIndex(i);
-			if (curr->getText().compare(mActiveModule->getName()+" *") == 0)
+            CeGuiString currName;
+            currName = curr->getText();
+			if (currName.compare(activeName+" *") == 0)
 			{
 				itOld = curr;
 				break;
 			}
 		}
-		itOld->setText(mActiveModule->getName());
+        if( !itOld )
+        {
+            LOG_ERROR(Logger::UI,"Could not determine last active MenuEntry in MainMenuWindow::handleChooseModule");            
+        }
+        else
+            itOld->setText(mActiveModule->getName());
 
 		mActiveModule = module;
 		it->setText(module->getName()+" *");

Modified: rl/branches/persistence2/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/MovementControlState.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/src/MovementControlState.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -222,6 +222,7 @@
             mController =
                 CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
         }
+        mCharBody = mCharacterActor->getPhysicalThing()->_getBody();
 
         // We want to check for visibility from char's POV.
         mSelector.setCheckVisibility(true, mCharacter);
@@ -1120,10 +1121,10 @@
     {
         mCombatSelector.updateSelection();
 
-        const Selector::GameObjectVector& gov = mCombatSelector.getAllSelectedObjects();
-        for (size_t i = 0, end = gov.size(); i < end; ++i)
+        const GameObjectList& gov = mCombatSelector.getAllSelectedObjects();
+        for (GameObjectList::const_iterator it = gov.begin(), end = gov.end(); it != end; ++it)
         {
-            Creature* creature = dynamic_cast<Creature*>(gov.at(i));
+            Creature* creature = dynamic_cast<Creature*>(*it);
             if (creature &&
 				creature->getAlignment() == Creature::ALIGNMENT_ENEMY &&
 				(creature->getLifeState() & Effect::LS_NO_COMBAT) == 0)

Copied: rl/branches/persistence2/tests/dialogtests (from rev 4878, rl/trunk/tests/dialogtests)


Property changes on: rl/branches/persistence2/tests/dialogtests
___________________________________________________________________
Name: svn:ignore
   + 
.deps
.libs
Makefile
testdialog
Makefile.in

Name: svn:mergeinfo
   + 

Copied: rl/branches/persistence2/tests/dialogtests/Debug (from rev 4878, rl/trunk/tests/dialogtests/Debug)

Copied: rl/branches/persistence2/tests/dialogtests/Release (from rev 4878, rl/trunk/tests/dialogtests/Release)

Deleted: rl/branches/persistence2/tests/dialogtests/RlDialogTests.vcproj
===================================================================
--- rl/trunk/tests/dialogtests/RlDialogTests.vcproj	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/tests/dialogtests/RlDialogTests.vcproj	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,186 +0,0 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<VisualStudioProject
-	ProjectType="Visual C++"
-	Version="8,00"
-	Name="RlDialogTests"
-	ProjectGUID="{B1DBC31B-A837-4111-9D7A-4BEE8033A952}"
-	>
-	<Platforms>
-		<Platform
-			Name="Win32"
-		/>
-	</Platforms>
-	<ToolFiles>
-	</ToolFiles>
-	<Configurations>
-		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="..\..\engine\script\include;..\..\engine\ui\include;..\..\engine\uicomponents\include;..\..\engine\dialog\include;..\..\engine\multimedia\include;..\..\engine\common\include;..\..\engine\core\include;..\..\engine\rules\include;..\..\dependencies\cppunit\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenewt\inc;..\..\dependencies\xerces\include;..\..\dependencies\newtonsdk\sdk"
-				PreprocessorDefinitions="WITH_FMOD3;WIN32;_DEBUG;_WINDOWS;_CRT_SECURE_NO_DEPRECATE"
-				MinimalRebuild="true"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="3"
-				BufferSecurityCheck="false"
-				DebugInformationFormat="4"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="CEGUIBase_d.lib OgreMain_d.lib cppunitd_dll.lib user32.lib RlUi.lib RlCore.lib RlMultimedia.lib"
-				LinkIncremental="2"
-				AdditionalLibraryDirectories="&quot;..\..\engine\ui\lib\$(ConfigurationName)&quot;;&quot;..\..\engine\core\lib\$(ConfigurationName)&quot;;&quot;..\..\engine\multimedia\lib\$(ConfigurationName)&quot;;&quot;..\..\dependencies\ogrenew\ogremain\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\cppunit\lib;..\..\dependencies\fmod\api\lib"
-				GenerateDebugInformation="true"
-				AssemblyDebug="1"
-				GenerateMapFile="true"
-				MapExports="true"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-		<Configuration
-			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
-			ConfigurationType="1"
-			>
-			<Tool
-				Name="VCPreBuildEventTool"
-			/>
-			<Tool
-				Name="VCCustomBuildTool"
-			/>
-			<Tool
-				Name="VCXMLDataGeneratorTool"
-			/>
-			<Tool
-				Name="VCWebServiceProxyGeneratorTool"
-			/>
-			<Tool
-				Name="VCMIDLTool"
-			/>
-			<Tool
-				Name="VCCLCompilerTool"
-				AdditionalIncludeDirectories="..\..\engine\script\include;..\..\engine\ui\include;..\..\engine\uicomponents\include;..\..\engine\dialog\include;..\..\engine\multimedia\include;..\..\engine\common\include;..\..\engine\core\include;..\..\engine\rules\include;..\..\dependencies\cppunit\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenewt\inc;..\..\dependencies\xerces\include;..\..\dependencies\newtonsdk\sdk"
-				PreprocessorDefinitions="WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_CRT_SECURE_NO_DEPRECATE"
-			/>
-			<Tool
-				Name="VCManagedResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCResourceCompilerTool"
-			/>
-			<Tool
-				Name="VCPreLinkEventTool"
-			/>
-			<Tool
-				Name="VCLinkerTool"
-				AdditionalDependencies="CEGUIBase.lib OgreMain.lib cppunit_dll.lib user32.lib RlMultimedia.lib RlCore.lib RlUi.lib"
-				AdditionalLibraryDirectories="&quot;..\..\engine\ui\lib\$(ConfigurationName)&quot;;&quot;..\..\engine\core\lib\$(ConfigurationName)&quot;;&quot;..\..\engine\multimedia\lib\$(ConfigurationName)&quot;;&quot;..\..\dependencies\ogrenew\ogremain\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\cppunit\lib;..\..\dependencies\fmod\api\lib"
-			/>
-			<Tool
-				Name="VCALinkTool"
-			/>
-			<Tool
-				Name="VCManifestTool"
-			/>
-			<Tool
-				Name="VCXDCMakeTool"
-			/>
-			<Tool
-				Name="VCBscMakeTool"
-			/>
-			<Tool
-				Name="VCFxCopTool"
-			/>
-			<Tool
-				Name="VCAppVerifierTool"
-			/>
-			<Tool
-				Name="VCWebDeploymentTool"
-			/>
-			<Tool
-				Name="VCPostBuildEventTool"
-			/>
-		</Configuration>
-	</Configurations>
-	<References>
-	</References>
-	<Files>
-		<Filter
-			Name="Source Files"
-			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
-			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
-			>
-			<File
-				RelativePath=".\TestDialog.cpp"
-				>
-			</File>
-		</Filter>
-		<Filter
-			Name="Header Files"
-			Filter="h;hpp;hxx;hm;inl;inc;xsd"
-			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
-			>
-		</Filter>
-		<Filter
-			Name="Resource Files"
-			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
-			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
-			>
-		</Filter>
-	</Files>
-	<Globals>
-	</Globals>
-</VisualStudioProject>

Copied: rl/branches/persistence2/tests/dialogtests/RlDialogTests.vcproj (from rev 4878, rl/trunk/tests/dialogtests/RlDialogTests.vcproj)

Deleted: rl/branches/persistence2/tests/dialogtests/TestDialog.cpp
===================================================================
--- rl/trunk/tests/dialogtests/TestDialog.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/tests/dialogtests/TestDialog.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,119 +0,0 @@
-#include <xercesc/util/XMemory.hpp> // Muss vor Ogre stehen (zumindest f???r VS)
-
-#include <Ogre.h>
-#include <OgreLogManager.h>
-#include <stdexcept>
-#include <errno.h>
-
-#include "Logger.h"
-#include "CoreSubsystem.h"
-#include "RulesSubsystem.h"
-#include "UiSubsystem.h"
-#include "RubyInterpreter.h"
-#include <cppunit/extensions/TestFactoryRegistry.h>
-#include <cppunit/ui/text/TestRunner.h>
-
-
-#include "Exception.h"
-#include <CEGUIExceptions.h>
-
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-    #define WIN32_LEAN_AND_MEAN
-    #include "windows.h"
-#endif
-
-
-int main( int argc, char **argv)
-{
-    rl::CoreSubsystem* core = NULL;
-    rl::MultimediaSubsystem* mm = NULL;
-    rl::RulesSubsystem* rules = NULL;
-    rl::DialogSubsystem* dialog = NULL;
-    rl::UiSubsystem* ui =  NULL;
-    rl::ScriptSubsystem* script =  NULL;
-
-    try {
-
-        /**@todo das nach RastullahApplication
-        * und RastullahApplication nach Startup. */
-        core = new rl::CoreSubsystem();
-        rl::Logger::getSingleton().log(rl::Logger::CORE, Ogre::LML_NORMAL, "CoreSubsystem gestartet");
-
-        mm = new rl::MultimediaSubsystem();
-        rl::Logger::getSingleton().log(rl::Logger::CORE, Ogre::LML_NORMAL, "SoundSubsystem gestartet");
-
-        rules = new rl::RulesSubsystem();
-        rl::Logger::getSingleton().log(rl::Logger::CORE, Ogre::LML_NORMAL, "RulesSubsystem gestartet");
-
-        dialog = new rl::DialogSubsystem();
-        rl::Logger::getSingleton().log(rl::Logger::CORE, Ogre::LML_NORMAL, "DialogSubsystem gestartet");
-
-        ui = new rl::UiSubsystem();
-        rl::Logger::getSingleton().log(rl::Logger::CORE, Ogre::LML_NORMAL, "UiSubsystem gestartet");
-
-        script = new rl::ScriptSubsystem();
-        rl::Logger::getSingleton().log(rl::Logger::CORE, Ogre::LML_NORMAL, "ScriptSubsystem gestartet");
-
-        rl::Logger::getSingleton().log(rl::Logger::CORE, Ogre::LML_NORMAL, "Starte...");
-        //core->getInterpreter()->execute("load 'startup-global.rb'");
-
-        CppUnit::TextUi::TestRunner runner;
-        CppUnit::TestFactoryRegistry &registry = CppUnit::TestFactoryRegistry::getRegistry();
-        runner.addTest( registry.makeTest() );
-        runner.run();
-        rl::Logger::getSingleton().log(rl::Logger::CORE, Ogre::LML_NORMAL, "Ende...");
-
-    }
-    catch(Ogre::Exception& oe) {
-        rl::showError(oe.getFullDescription());
-    }
-    catch(rl::Exception& re) {
-        rl::showError(re.toString());
-    }
-    catch(CEGUI::Exception& ce) {
-        rl::showError(ce.getMessage().c_str());
-    }
-    catch(std::runtime_error& rte) {
-        rl::showError(rte.what());
-    }
-    catch(std::exception& exp) {
-        rl::showError( exp.what() );
-    }
-    catch(std::string& err) {
-        rl::showError( err );
-    }
-    catch(...) {
-        rl::showError( "Unknown exception occured" );
-    }
-
-    try
-    {
-        delete script;
-        delete ui;
-        delete dialog;
-        delete rules;
-        delete mm;
-        delete core;
-    }
-    catch(Ogre::Exception& oe) {
-        rl::showError(oe.getFullDescription());
-    }
-    catch(rl::Exception& re) {
-        rl::showError(re.toString());
-    }
-    catch(std::runtime_error& rte) {
-        rl::showError(rte.what());
-    }
-    catch(std::exception& exp) {
-        rl::showError( exp.what() );
-    }
-    catch(std::string& err) {
-        rl::showError( err );
-    }
-    catch(...) {
-        rl::showError( "Unknown exception occured" );
-    }
-
-
-    return 0;
-}

Copied: rl/branches/persistence2/tests/dialogtests/TestDialog.cpp (from rev 4878, rl/trunk/tests/dialogtests/TestDialog.cpp)

Modified: rl/branches/persistence2/tools/copy_dependencies.bat
===================================================================
--- rl/branches/persistence2/tools/copy_dependencies.bat	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/tools/copy_dependencies.bat	2009-04-01 20:08:44 UTC (rev 4879)
@@ -53,9 +53,9 @@
 REM 
 copy "%RL_ROOT%\dependencies\FMOD4\api\fmodex.dll" "%RL_DIST%"
 
-copy "%RL_ROOT%\Dependencies\NewtonSDK\sdk\dll\Newton.dll" "%RL_DIST%"
-copy "%RL_ROOT%\Dependencies\OgreNewt\lib\debug\OgreNewt_d.dll" "%RL_DIST%"
-copy "%RL_ROOT%\Dependencies\OgreNewt\lib\release\OgreNewt.dll" "%RL_DIST%"
+copy "%RL_ROOT%\Dependencies\NewtonSDK\sdk\x32\dll_vs9\Newton.dll" "%RL_DIST%"
+copy "%RL_ROOT%\Dependencies\OgreNewt\lib\OgreNewt_d.dll" "%RL_DIST%"
+copy "%RL_ROOT%\Dependencies\OgreNewt\lib\OgreNewt.dll" "%RL_DIST%"
 
 copy "%RL_ROOT%\Dependencies\cegui_mk2\bin\*.dll" "%RL_DIST%"
 copy "%RL_ROOT%\Dependencies\xerces\bin\*.dll" "%RL_DIST%"



From alassion at mail.berlios.de  Thu Apr  2 12:08:26 2009
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Thu, 2 Apr 2009 12:08:26 +0200
Subject: [Dsa-hl-svn] r4880 - content/textures
Message-ID: <200904021008.n32A8QB9012022@sheep.berlios.de>

Author: alassion
Date: 2009-04-02 12:04:53 +0200 (Thu, 02 Apr 2009)
New Revision: 4880

Added:
   content/textures/boden_02_kana.png
   content/textures/boden_02_kana_normal.png
   content/textures/boden_02_kana_spec.png
   content/textures/breitschwert.png
   content/textures/breitschwert_normal.png
   content/textures/breitschwert_spec.png
   content/textures/drop_shadow.png
   content/textures/erdeboden_02.jpg
   content/textures/erdeboden_02_normal.jpg.png
   content/textures/fass_kanalisation.png
   content/textures/fass_kanalisation_normal.png
   content/textures/fass_kanalisation_specularity.png
   content/textures/felsen_3_kana.png
   content/textures/felsen_3_kana_normal.png
   content/textures/felsen_3_kana_spec.png
   content/textures/granit_01.png
Log:


Added: content/textures/boden_02_kana.png
===================================================================
(Binary files differ)


Property changes on: content/textures/boden_02_kana.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/boden_02_kana_normal.png
===================================================================
(Binary files differ)


Property changes on: content/textures/boden_02_kana_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/boden_02_kana_spec.png
===================================================================
(Binary files differ)


Property changes on: content/textures/boden_02_kana_spec.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/breitschwert.png
===================================================================
(Binary files differ)


Property changes on: content/textures/breitschwert.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/breitschwert_normal.png
===================================================================
(Binary files differ)


Property changes on: content/textures/breitschwert_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/breitschwert_spec.png
===================================================================
(Binary files differ)


Property changes on: content/textures/breitschwert_spec.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/drop_shadow.png
===================================================================
(Binary files differ)


Property changes on: content/textures/drop_shadow.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/erdeboden_02.jpg
===================================================================
(Binary files differ)


Property changes on: content/textures/erdeboden_02.jpg
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/erdeboden_02_normal.jpg.png
===================================================================
(Binary files differ)


Property changes on: content/textures/erdeboden_02_normal.jpg.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/fass_kanalisation.png
===================================================================
(Binary files differ)


Property changes on: content/textures/fass_kanalisation.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/fass_kanalisation_normal.png
===================================================================
(Binary files differ)


Property changes on: content/textures/fass_kanalisation_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/fass_kanalisation_specularity.png
===================================================================
(Binary files differ)


Property changes on: content/textures/fass_kanalisation_specularity.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/felsen_3_kana.png
===================================================================
(Binary files differ)


Property changes on: content/textures/felsen_3_kana.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/felsen_3_kana_normal.png
===================================================================
(Binary files differ)


Property changes on: content/textures/felsen_3_kana_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/felsen_3_kana_spec.png
===================================================================
(Binary files differ)


Property changes on: content/textures/felsen_3_kana_spec.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/granit_01.png
===================================================================
(Binary files differ)


Property changes on: content/textures/granit_01.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From alassion at mail.berlios.de  Thu Apr  2 12:10:23 2009
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Thu, 2 Apr 2009 12:10:23 +0200
Subject: [Dsa-hl-svn] r4881 - content/textures
Message-ID: <200904021010.n32AANV5012369@sheep.berlios.de>

Author: alassion
Date: 2009-04-02 12:09:32 +0200 (Thu, 02 Apr 2009)
New Revision: 4881

Added:
   content/textures/pilz2.png
   content/textures/pilz3.png
   content/textures/rust_kana.png
   content/textures/rust_kana_normal.png
   content/textures/rust_kana_spec.png
   content/textures/saeule_kana_spec.png
   content/textures/wand_kana_spec.png
Log:


Added: content/textures/pilz2.png
===================================================================
(Binary files differ)


Property changes on: content/textures/pilz2.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/pilz3.png
===================================================================
(Binary files differ)


Property changes on: content/textures/pilz3.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/rust_kana.png
===================================================================
(Binary files differ)


Property changes on: content/textures/rust_kana.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/rust_kana_normal.png
===================================================================
(Binary files differ)


Property changes on: content/textures/rust_kana_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/rust_kana_spec.png
===================================================================
(Binary files differ)


Property changes on: content/textures/rust_kana_spec.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/saeule_kana_spec.png
===================================================================
(Binary files differ)


Property changes on: content/textures/saeule_kana_spec.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: content/textures/wand_kana_spec.png
===================================================================
(Binary files differ)


Property changes on: content/textures/wand_kana_spec.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From melven at mail.berlios.de  Thu Apr  2 12:20:16 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Thu, 2 Apr 2009 12:20:16 +0200
Subject: [Dsa-hl-svn] r4882 - in dependencies/OgreNewt: inc src
Message-ID: <200904021020.n32AKGaQ013496@sheep.berlios.de>

Author: melven
Date: 2009-04-02 12:20:14 +0200 (Thu, 02 Apr 2009)
New Revision: 4882

Modified:
   dependencies/OgreNewt/inc/OgreNewt_Debugger.h
   dependencies/OgreNewt/inc/OgreNewt_World.h
   dependencies/OgreNewt/src/OgreNewt_Debugger.cpp
   dependencies/OgreNewt/src/OgreNewt_World.cpp
Log:
-removed bug when destroying world (caused by the debugger)


Modified: dependencies/OgreNewt/inc/OgreNewt_Debugger.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Debugger.h	2009-04-02 10:09:32 UTC (rev 4881)
+++ dependencies/OgreNewt/inc/OgreNewt_Debugger.h	2009-04-02 10:20:14 UTC (rev 4882)
@@ -17,6 +17,11 @@
 #include "OgreNewt_Tools.h"
 
 
+namespace Ogre
+{
+    class ManualObject;
+}
+
 namespace OgreNewt
 {
 
@@ -128,7 +133,10 @@
         //! clear debug data cache fo bodies (m_cachemap)
         void clearBodyDebugDataCache();
 
+        typedef std::list<Ogre::ManualObject*> ManualObjectList;
+        ManualObjectList mRecordedRaycastObjects;
 
+
     private:
         //! this function is declared private, so nobody can use it!
         Debugger() {}

Modified: dependencies/OgreNewt/inc/OgreNewt_World.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_World.h	2009-04-02 10:09:32 UTC (rev 4881)
+++ dependencies/OgreNewt/inc/OgreNewt_World.h	2009-04-02 10:20:14 UTC (rev 4882)
@@ -209,7 +209,7 @@
     /*!
      * the debugger needs to be initialized (Debugger::init(...) ) in order to work correctly
     */
-    Debugger& getDebugger() const {return m_debugger;}
+    Debugger& getDebugger() const {return *m_debugger;}
 
 protected:
     
@@ -220,7 +220,7 @@
     
     BodyInAABBIterator m_bodyInAABBIterator;
 
-    mutable Debugger m_debugger;
+    mutable Debugger* m_debugger;
 
 private:
 

Modified: dependencies/OgreNewt/src/OgreNewt_Debugger.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Debugger.cpp	2009-04-02 10:09:32 UTC (rev 4881)
+++ dependencies/OgreNewt/src/OgreNewt_Debugger.cpp	2009-04-02 10:20:14 UTC (rev 4882)
@@ -58,18 +58,16 @@
 
 void Debugger::deInit()
 {
+    clearBodyDebugDataCache();
     if (m_debugnode)
     {
         m_debugnode->setListener(NULL);
-        m_debugnode->removeAllChildren();
+        m_debugnode->removeAndDestroyAllChildren();
         m_debugnode->getParentSceneNode()->removeAndDestroyChild( m_debugnode->getName() );
         m_debugnode = NULL;
     }
 
 
-    clearBodyDebugDataCache();
-
-
     clearRaycastsRecorded();
     if( m_raycastsnode )
     {
@@ -84,15 +82,14 @@
 {
     if(node == m_debugnode)
     {
+        m_debugnode = NULL;
         clearBodyDebugDataCache();
-        m_debugnode = NULL;
     }
 
     if(node == m_raycastsnode)
     {
-        //!TODO: check this... this accesses the node, I'm not shure if this is allowed in this function
+        m_raycastsnode = NULL;
         clearRaycastsRecorded();
-        m_raycastsnode = NULL;
     }
 }
 
@@ -104,9 +101,11 @@
             Ogre::ManualObject* mo = it->second.m_lines;
             if( mo )
                 delete mo;
+            OgreNewt::OgreAddons::MovableText *text = it->second.m_text;
+            if( text )
+                delete text;
         }
         m_cachemap.clear();
-
 }
 
 
@@ -136,6 +135,9 @@
             Ogre::ManualObject* mo = it->second.m_lines;
             if( mo )
                 delete mo;
+            OgreNewt::OgreAddons::MovableText *text = it->second.m_text;
+            if( text )
+                delete text;
         }
     }
     m_cachemap.swap(newmap);
@@ -299,13 +301,20 @@
 {
     if( m_raycastsnode )
     {
+/*
         while( m_raycastsnode->numAttachedObjects() > 0 )
         {
             delete m_raycastsnode->detachObject((unsigned short)0);
         }
+*/
+        m_raycastsnode->removeAndDestroyAllChildren();
+    }
 
-        m_raycastsnode->detachAllObjects();
+    for(ManualObjectList::iterator it = mRecordedRaycastObjects.begin(); it != mRecordedRaycastObjects.end(); it++)
+    {
+        delete (*it);
     }
+    mRecordedRaycastObjects.clear();
 }
 
 void Debugger::stopRaycastRecording()
@@ -330,6 +339,7 @@
     std::ostringstream oss;
     oss << "__OgreNewt__Raycast_Debugger__Lines__Raycastline__" << i++ << "__";
     Ogre::ManualObject *line = new Ogre::ManualObject(oss.str());
+    mRecordedRaycastObjects.push_back(line);
 
     line->begin("BaseWhiteNoLighting", Ogre::RenderOperation::OT_LINE_LIST );
     line->colour(m_raycol);
@@ -350,6 +360,7 @@
     std::ostringstream oss;
     oss << "__OgreNewt__Raycast_Debugger__Lines__Convexcastlines__" << i++ << "__";
     Ogre::ManualObject *line = new Ogre::ManualObject(oss.str());
+    mRecordedRaycastObjects.push_back(line);
 
     line->begin("BaseWhiteNoLighting", Ogre::RenderOperation::OT_LINE_LIST );
     line->colour(m_convexcol);
@@ -402,6 +413,7 @@
     std::ostringstream oss;
     oss << "__OgreNewt__Raycast_Debugger__Lines__DiscardedBody__" << i++ << "__";
     Ogre::ManualObject *line = new Ogre::ManualObject(oss.str());
+    mRecordedRaycastObjects.push_back(line);
 
     line->begin("BaseWhiteNoLighting", Ogre::RenderOperation::OT_LINE_LIST );
     line->colour(m_prefilterdiscardedcol);
@@ -427,6 +439,7 @@
     std::ostringstream oss;
     oss << "__OgreNewt__Raycast_Debugger__Lines__HitBody__" << i++ << "__";
     Ogre::ManualObject *line = new Ogre::ManualObject(oss.str());
+    mRecordedRaycastObjects.push_back(line);
 
     line->begin("BaseWhiteNoLighting", Ogre::RenderOperation::OT_LINE_LIST );
     line->colour(m_hitbodycol);

Modified: dependencies/OgreNewt/src/OgreNewt_World.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_World.cpp	2009-04-02 10:09:32 UTC (rev 4881)
+++ dependencies/OgreNewt/src/OgreNewt_World.cpp	2009-04-02 10:20:14 UTC (rev 4882)
@@ -8,8 +8,7 @@
 
 // Constructor
 World::World() :
-    m_bodyInAABBIterator(this),
-    m_debugger(this)
+    m_bodyInAABBIterator(this)
 {
     m_limits = Ogre::AxisAlignedBox(Ogre::Vector3(-100,-100,-100), Ogre::Vector3(100,100,100));
 
@@ -26,16 +25,30 @@
     m_defaultMatID = new OgreNewt::MaterialID( this, NewtonMaterialGetDefaultGroupID( m_world ) );
 
     m_leaveCallback = NULL;
+
+    m_debugger = new Debugger(this);
 }
 
 // Destructor
 World::~World()
 {
+    if (m_debugger)
+    {
+        delete m_debugger;
+        m_debugger = NULL;
+    }
+
     if (m_defaultMatID)
+    {
         delete m_defaultMatID;
+        m_defaultMatID = NULL;
+    }
 
     if (m_world)
+    {
         NewtonDestroy( m_world );
+        m_world = NULL;
+    }
 }
 
 // update



From melven at mail.berlios.de  Fri Apr  3 15:30:57 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Fri, 3 Apr 2009 15:30:57 +0200
Subject: [Dsa-hl-svn] r4883 - in rl/trunk/engine: core/include core/src
	rules/src ui/src
Message-ID: <200904031330.n33DUvT5027977@sheep.berlios.de>

Author: melven
Date: 2009-04-03 15:30:53 +0200 (Fri, 03 Apr 2009)
New Revision: 4883

Modified:
   rl/trunk/engine/core/include/PhysicalThing.h
   rl/trunk/engine/core/include/PhysicsManager.h
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/trunk/engine/rules/src/CreatureController.cpp
   rl/trunk/engine/ui/src/CombatControlState.cpp
   rl/trunk/engine/ui/src/FreeflightControlState.cpp
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
-set center of mass of physics proxy correctly
-some small changes...


Modified: rl/trunk/engine/core/include/PhysicalThing.h
===================================================================
--- rl/trunk/engine/core/include/PhysicalThing.h	2009-04-02 10:20:14 UTC (rev 4882)
+++ rl/trunk/engine/core/include/PhysicalThing.h	2009-04-03 13:30:53 UTC (rev 4883)
@@ -226,7 +226,7 @@
 		GeometryType getGeometryType() const;
 		void setBody(OgreNewt::Body* body);
 
-        OgreNewt::CollisionPtr createCollision(PhysicalObject* po, Ogre::Vector3& inertia) const;
+        OgreNewt::CollisionPtr createCollision(PhysicalObject* po, Ogre::Vector3& inertia, Ogre::Vector3& centerOfMass) const;
 
         //! the ragdoll, if this thing is controlled by a ragdoll
         PhysicsRagDoll* mRagDoll;

Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2009-04-02 10:20:14 UTC (rev 4882)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2009-04-03 13:30:53 UTC (rev 4883)
@@ -222,6 +222,7 @@
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
+		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
 		*/
 		OgreNewt::CollisionPtr createCollision(
 			Ogre::Entity* entity,
@@ -230,7 +231,8 @@
 			Ogre::Vector3* offset = NULL,
 			Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
 
         /** creates a collision primitive for OgreNewt.
 		 * The collision primitive created has got a basic orientation which can be influenced by
@@ -248,6 +250,7 @@
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
+		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
 		*/
         OgreNewt::CollisionPtr createCollision(
             const Ogre::String& name,
@@ -256,7 +259,8 @@
             Ogre::Vector3* offset = NULL,
 			Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
 
         /** Makes the collision primitive generation available to non mesh objects.
          * Non mesh objects need collision objects too. Therefore they can
@@ -401,13 +405,15 @@
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
+		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
 		*/
         OgreNewt::CollisionPtr createCollisionFromEntity(Ogre::Entity* entity,
             const GeometryType& geomType,
             Ogre::Vector3* offset = NULL, 
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real Mass = 0,
-            Ogre::Vector3* inertiaCoefficients = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
 
         /** creates a collision primitive for OgreNewt from an AABB box.
 		 * The collision primitive created has got a basic orientation which can be influenced by
@@ -423,13 +429,15 @@
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
+		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
 		*/
         OgreNewt::CollisionPtr createCollisionFromAABB(const Ogre::AxisAlignedBox aabb,
             const GeometryType& geomType,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real Mass = 0,
-            Ogre::Vector3* inertiaCoefficients = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
     protected:
         /** creates a box collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
@@ -438,12 +446,14 @@
          * @param orientation when not null, specifies the euler angle of orientation.
          * @param mass gives the mass for inertia calculation.
          * @param inertia when not null, an inertia is calculated and passed back.
+         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
         OgreNewt::CollisionPtr createBox(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
         /** creates a pyramid collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
@@ -451,12 +461,14 @@
          * @param orientation when not null, specifies the euler angle of orientation.
          * @param mass gives the mass for inertia calculation.
          * @param inertia when not null, an inertia is calculated and passed back.
+         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
         OgreNewt::CollisionPtr createPyramid(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
         /** creates a sphere collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
@@ -464,12 +476,14 @@
          * @param orientation when not null, specifies the euler angle of orientation.
          * @param mass gives the mass for inertia calculation.
          * @param inertia when not null, an inertia is calculated and passed back.
+         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
         OgreNewt::CollisionPtr createSphere(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
         /** creates a ellipsoid collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
@@ -477,12 +491,14 @@
          * @param orientation when not null, specifies the euler angle of orientation.
          * @param mass gives the mass for inertia calculation.
          * @param inertia when not null, an inertia is calculated and passed back.
+         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
         OgreNewt::CollisionPtr createEllipsoid(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
         /** creates a capsule collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
@@ -490,12 +506,14 @@
          * @param orientation when not null, specifies the euler angle of orientation.
          * @param mass gives the mass for inertia calculation.
          * @param inertia when not null, an inertia is calculated and passed back.
+         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
         OgreNewt::CollisionPtr createCapsule(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
     };
 }
 

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2009-04-02 10:20:14 UTC (rev 4882)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2009-04-03 13:30:53 UTC (rev 4883)
@@ -239,8 +239,12 @@
         if( mBody && !mRagDoll )
         {
             Vector3 inertia;
-            mBody->getMassMatrix(mMass, inertia);
+            Real oldMass;
+            mBody->getMassMatrix(oldMass, inertia);
             mMass = mass;
+            if( oldMass > 0 )
+                inertia = inertia/oldMass*mass;
+                
             mBody->setMassMatrix(mass, inertia);
         }
         mMass = mass;
@@ -443,8 +447,8 @@
                 "PhysicalThing::createPhysicsProxy: cannot create physics proxy while the PhysicalThing is controlled by a RagDoll!");
 		if (!mBody)
 		{
-            Vector3 inertia;
-            OgreNewt::CollisionPtr coll = createCollision(mPhysicalObject, inertia);
+            Vector3 inertia, centerOfMass;
+            OgreNewt::CollisionPtr coll = createCollision(mPhysicalObject, inertia, centerOfMass);
 
 			OgreNewt::Body* body = new OgreNewt::Body(
                 PhysicsManager::getSingleton()._getNewtonWorld(), coll);
@@ -454,6 +458,7 @@
 			if (mass > 0.0 && mGeometryType != GT_MESH)
             {
                 body->setMassMatrix(mass, inertia);
+                body->setCenterOfMass(centerOfMass);
             }
 
 			body->setCustomForceAndTorqueCallback(PhysicsManager::genericForceCallback);
@@ -469,7 +474,7 @@
         }
 	}
 
-    OgreNewt::CollisionPtr PhysicalThing::createCollision(PhysicalObject* po, Vector3& inertia) const
+    OgreNewt::CollisionPtr PhysicalThing::createCollision(PhysicalObject* po, Vector3& inertia, Vector3& centerOfMass) const
     {
         OgreNewt::CollisionPtr coll;
 
@@ -488,7 +493,8 @@
                 NULL,
                 NULL,
                 mMass,
-                &inertia);
+                &inertia,
+                &centerOfMass);
         }
         else
         {
@@ -499,7 +505,8 @@
                 NULL,
                 NULL,
                 mMass,
-                &inertia);
+                &inertia,
+                &centerOfMass);
         }
 
         return coll;
@@ -511,13 +518,14 @@
         {
             mPoseCollisions.clear();
 
-            Vector3 inertia;
+            Vector3 inertia, centerOfMass;
 
             // update the collision
-		    mBody->setCollision(createCollision(mPhysicalObject, inertia));
+		    mBody->setCollision(createCollision(mPhysicalObject, inertia, centerOfMass));
 		    if (mMass > 0.0 && mGeometryType != GT_MESH)
             {
                 mBody->setMassMatrix(mMass, inertia);
+                mBody->setCenterOfMass(centerOfMass);
             }
         }
     }

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2009-04-02 10:20:14 UTC (rev 4882)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2009-04-03 13:30:53 UTC (rev 4883)
@@ -507,7 +507,8 @@
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
         Ogre::Entity* entity, const GeometryType& geomType,
 		const Ogre::String animName, Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia)
+        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
+        Ogre::Vector3* centerOfMass)
     {
         // problem here is that a mesh can have different animations with
         // different extents. Therefore we add the animName to the meshname
@@ -515,7 +516,7 @@
         Ogre::String collisionName (entity->getMesh()->getName() + animName);
 
         // result value
-        CollisionPtr rval;
+        CollisionPtr rval(NULL);
 
         // check if there is a collision primitiv for the specified mesh object
         CollisionInUse &usedcol (mCollisionPrimitives[collisionName]);
@@ -534,70 +535,6 @@
                 // found it
                 rval = usedcol.colPtr;
 
-
-                if( inertia )
-                {
-
-                    // we must set inertia here, the calling function doesn't know we are not creating a new collision
-                    switch(usedcol.geomType)
-                    {
-                    case GT_BOX: // from createBox
-                    case GT_CAPSULE: // from createCapsule
-                    case GT_CONVEXHULL: // from createCollisionFromEntity
-                    case GT_ELLIPSOID: // from createEllipsoid
-                    case GT_PYRAMID: // createPyramid
-                    case GT_SPHERE:
-                    case GT_MESH:
-                    case GT_NONE:
-                        *inertia = Ogre::Vector3::ZERO;
-                        break;
-                    }
-/*
-                    Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
-                    Vector3 size( aabb.getSize() );
-                    switch(usedcol.geomType)
-                    {
-                    case GT_BOX: // from createBox
-                        *inertia = OgreNewt::MomentOfInertia::CalcBoxSolid(mass, aabb.getSize());
-                        break;
-                    case GT_CAPSULE: // from createCapsule
-                        {
-                            double radius = std::max(size.x, size.z) / 2.0;
-                            double sradius = radius*radius;
-                            *inertia = Vector3(sradius, size.y*size.y, sradius) * mass;
-                        }
-                        break;
-                    case GT_CONVEXHULL: // from createCollisionFromEntity
-				        *inertia = Vector3(
-				        size.x*size.x/6.0f,
-				        size.y*size.y/6.0f,
-			            size.z*size.z/6.0f) * mass;
-                        break;
-                    case GT_ELLIPSOID: // from createEllipsoid
-                        {
-                            Vector3 s(size/2.0);
-                            s.x = std::max(s.x, s.z);
-                            s.z = s.x;
-                            *inertia = Vector3(s.x*s.x, s.y*s.y, s.z*s.z) * mass;
-                        }
-                        break;
-                    case GT_MESH:
-                    case GT_NONE:
-                        *inertia = Ogre::Vector3::ZERO;
-                        break;
-                    case GT_PYRAMID: // createPyramid
-                        *inertia = Ogre::Vector3(size.x,size.y/2.0f, size.z) * mass;
-                        break;
-                    case GT_SPHERE:
-                        {
-                            double radius = std::max(size.x, std::max(size.y, size.z)) / 2.0;
-                            //*inertia = OgreNewt::MomentOfInertia::CalcSphereSolid(Mass,radius);
-                            *inertia = mass * Vector3(radius*radius, radius*radius, radius*radius);
-                        }
-                        break;
-                    }
-*/
-                }
             }
         }
 
@@ -605,7 +542,7 @@
         {
             // if there is none, then create a new collision object
             rval = mPhysicsCollisionFactory->createCollisionFromEntity(
-                entity, geomType, offset, orientation, mass, inertia );
+                entity, geomType, offset, orientation, mass, inertia, centerOfMass );
 
             usedcol.geomType = geomType;
             usedcol.colPtr = rval;
@@ -617,10 +554,11 @@
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
         const Ogre::String& name, const Ogre::AxisAlignedBox& aabb,
         const GeometryType& geomType, Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia)
+        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
+        Ogre::Vector3* centerOfMass)
     {
         // result value
-        CollisionPtr rval;
+        CollisionPtr rval(NULL);
 
         // check if there is a collision primitiv for the specified mesh object
         CollisionInUse &usedcol (mCollisionPrimitives[name]);
@@ -645,7 +583,7 @@
         {
             // if there is none, then create a new collision object
             rval = mPhysicsCollisionFactory->createCollisionFromAABB(
-                aabb, geomType, offset, orientation, mass, inertia );
+                aabb, geomType, offset, orientation, mass, inertia, centerOfMass );
 
             usedcol.geomType = geomType;
             usedcol.colPtr = rval;
@@ -732,7 +670,8 @@
         Ogre::Vector3* offset,
         Ogre::Quaternion* orientation,
         const Ogre::Real Mass,
-        Ogre::Vector3* inertia)
+        Ogre::Vector3* inertia,
+        Ogre::Vector3* centerOfMass)
     {
         // size of the mesh
         Vector3 size( aabb.getSize() );
@@ -740,7 +679,7 @@
         bool forceBox (false);
 
         // result value
-        CollisionPtr rval;
+        CollisionPtr rval(NULL);
 
         // size check (if object is too small, it falls back to a box primitiv
         if (checkSize(size) == false )
@@ -772,23 +711,23 @@
 	    */
 		if (geomType == GT_BOX || forceBox == true)
         {
-			rval = createBox(aabb, offset, orientation, Mass, inertia);
+			rval = createBox(aabb, offset, orientation, Mass, inertia, centerOfMass);
         }
         else if (geomType == GT_PYRAMID)
         {
-            rval = createPyramid(aabb, offset, orientation, Mass, inertia);
+            rval = createPyramid(aabb, offset, orientation, Mass, inertia, centerOfMass);
         }
         else if (geomType == GT_SPHERE)
         {
-			rval = createSphere(aabb, offset, orientation, Mass, inertia);
+			rval = createSphere(aabb, offset, orientation, Mass, inertia, centerOfMass);
         }
         else if (geomType == GT_ELLIPSOID)
         {
-            rval = createEllipsoid(aabb, offset, orientation, Mass, inertia);
+            rval = createEllipsoid(aabb, offset, orientation, Mass, inertia, centerOfMass);
         }
 		else if (geomType == GT_CAPSULE)
 		{
-			rval = createCapsule(aabb, offset, orientation, Mass, inertia);
+			rval = createCapsule(aabb, offset, orientation, Mass, inertia, centerOfMass);
 		}
         return rval;
     }
@@ -797,8 +736,9 @@
         const GeometryType& geomType,
         Ogre::Vector3* offset,
         Ogre::Quaternion* orientation,
-        const Ogre::Real Mass,
-        Ogre::Vector3* inertia)
+        const Ogre::Real mass,
+        Ogre::Vector3* inertia,
+        Ogre::Vector3* centerOfMass)
     {
         // bounding box of the mesh
         const Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
@@ -808,7 +748,7 @@
         bool forceBox (false);
 
         // result value
-        CollisionPtr rval;
+        CollisionPtr rval(NULL);
 
         // size check (if object is too small, it falls back to a box primitiv
         if (checkSize(size) == false )
@@ -829,23 +769,23 @@
 	    */
 		if (geomType == GT_BOX || forceBox == true)
         {
-			rval = createBox(aabb, offset, orientation, Mass, inertia);
+			rval = createBox(aabb, offset, orientation, mass, inertia, centerOfMass);
         }
         else if (geomType == GT_PYRAMID)
         {
-            rval = createPyramid(aabb, offset, orientation, Mass, inertia);
+            rval = createPyramid(aabb, offset, orientation, mass, inertia, centerOfMass);
         }
         else if (geomType == GT_SPHERE)
         {
-			rval = createSphere(aabb, offset, orientation, Mass, inertia);
+			rval = createSphere(aabb, offset, orientation, mass, inertia, centerOfMass);
         }
         else if (geomType == GT_ELLIPSOID)
         {
-            rval = createEllipsoid(aabb, offset, orientation, Mass, inertia);
+            rval = createEllipsoid(aabb, offset, orientation, mass, inertia, centerOfMass);
         }
 		else if (geomType == GT_CAPSULE)
 		{
-			rval = createCapsule(aabb, offset, orientation, Mass, inertia);
+			rval = createCapsule(aabb, offset, orientation, mass, inertia, centerOfMass);
 		}
         else if (geomType == GT_CONVEXHULL)
         {
@@ -865,17 +805,22 @@
                 PhysicsManager::getSingleton()._getNewtonWorld(),
 				entity, /*entity->hasSkeleton(),*/ *orientation, *offset));
 
-			if (inertia != NULL)
-			{
-                            Vector3 inert_offs=Vector3::ZERO;
-                            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
-                            *inertia *= Mass;
-			}
+            if (inertia != NULL || centerOfMass != NULL )
+            {
+                Vector3 temp_inertia, temp_centerOfMass;
+                static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+                if( inertia != NULL )
+                    *inertia = temp_inertia*mass;
+                if( centerOfMass != NULL )
+                    *centerOfMass = temp_centerOfMass;
+            }
         }
         else if (geomType == GT_MESH)
         {
             if (inertia != NULL)
                 *inertia = Ogre::Vector3::ZERO;
+            if (centerOfMass != NULL)
+                *centerOfMass = Ogre::Vector3::ZERO;
 
             rval = CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
                 PhysicsManager::getSingleton()._getNewtonWorld(),
@@ -906,7 +851,8 @@
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
             const Ogre::Real mass,
-            Ogre::Vector3* inertia)
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass)
     {
         // offset of the collision primitiv
         Ogre::Vector3 object_offset( aabb.getCenter() );
@@ -923,11 +869,16 @@
         OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             aabb.getSize(), *orientation, *offset));
-        if (inertia)
+
+
+        if (inertia != NULL || centerOfMass != NULL )
         {
-            Vector3 inert_offs=Vector3::ZERO;
-            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
-            *inertia *= mass;
+            Vector3 temp_inertia, temp_centerOfMass;
+            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+            if( inertia )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass )
+                *centerOfMass = temp_centerOfMass;
         }
 
         return rval;
@@ -937,7 +888,8 @@
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
             const Ogre::Real mass,
-            Ogre::Vector3* inertia)
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass)
     {
         Ogre::Vector3 size = aabb.getSize();
         // positional offset of the collision primitiv
@@ -954,13 +906,18 @@
         OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             size, *orientation, *offset));
-        if (inertia)
+
+
+        if (inertia != NULL || centerOfMass != NULL )
         {
-            Vector3 inert_offs=Vector3::ZERO;
-            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
-            *inertia *= mass;
+            Vector3 temp_inertia, temp_centerOfMass;
+            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+            if( inertia )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass )
+                *centerOfMass = temp_centerOfMass;
         }
-
+ 
         return rval;
     }
 
@@ -968,7 +925,8 @@
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
             const Ogre::Real mass,
-            Ogre::Vector3* inertia)
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass)
     {
         Ogre::Vector3 size = aabb.getSize();
         // calculate the maximum radius needed to include 'everything'
@@ -989,12 +947,18 @@
         OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             Vector3(radius, radius, radius), *orientation, *offset));
-        if (inertia)
+ 
+
+        if (inertia != NULL || centerOfMass != NULL )
         {
-            Vector3 inert_offs=Vector3::ZERO;
-            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
-            *inertia *= mass;
+            Vector3 temp_inertia, temp_centerOfMass;
+            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+            if( inertia )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass )
+                *centerOfMass = temp_centerOfMass;
         }
+ 
         return rval;
     }
 
@@ -1002,7 +966,8 @@
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
             const Ogre::Real mass,
-            Ogre::Vector3* inertia)
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass)
     {
         Ogre::Vector3 size = aabb.getSize();
         // set the size x/z values to the maximum
@@ -1025,13 +990,17 @@
             PhysicsManager::getSingleton()._getNewtonWorld(),
             s, *orientation, *offset));
 
-        if (inertia)
+
+        if (inertia != NULL || centerOfMass != NULL )
         {
-            Vector3 inert_offs=Vector3::ZERO;
-            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
-            *inertia *= mass;
+            Vector3 temp_inertia, temp_centerOfMass;
+            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+            if( inertia )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass )
+                *centerOfMass = temp_centerOfMass;
         }
-
+ 
         return rval;
     }
 
@@ -1039,7 +1008,8 @@
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
             const Ogre::Real mass,
-            Ogre::Vector3* inertia)
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass)
     {
         Ogre::Vector3 size = aabb.getSize();
         // positional offset of the collision primitiv
@@ -1064,12 +1034,18 @@
             PhysicsManager::getSingleton()._getNewtonWorld(),
             radius, height, *orientation, *offset));
 
-        if (inertia)
+
+        if (inertia != NULL || centerOfMass != NULL )
         {
-            Vector3 inert_offs=Vector3::ZERO;
-            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
-            *inertia *= mass;
+            Vector3 temp_inertia, temp_centerOfMass;
+            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+            if( inertia )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass )
+                *centerOfMass = temp_centerOfMass;
         }
+ 
+ 
         return rval;
     }
 }

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2009-04-02 10:20:14 UTC (rev 4882)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2009-04-03 13:30:53 UTC (rev 4883)
@@ -80,8 +80,8 @@
 
         mCreature->getActor()->getPhysicalThing()->setPhysicsController(this);
 
-//        mCreature->getActor()->getPhysicalThing()->_getBody()->setAngularDamping(0*Vector3::UNIT_SCALE);
-        mCreature->getActor()->getPhysicalThing()->_getBody()->setContinuousCollisionMode(1);
+        //mCreature->getActor()->getPhysicalThing()->_getBody()->setAngularDamping(0*Vector3::UNIT_SCALE);
+        //mCreature->getActor()->getPhysicalThing()->_getBody()->setContinuousCollisionMode(1);
 
 
         std::pair<MovementType, AbstractMovement*> movementPair;
@@ -407,11 +407,12 @@
 
         Vector3 charPos;
         Quaternion charOri;
-        mCreature->getActor()->getPhysicalThing()->_getBody()->getPositionOrientation(charPos, charOri);
+        OgreNewt::Body* charBody = mCreature->getActor()->getPhysicalThing()->_getBody();
+        charBody->getPositionOrientation(charPos, charOri);
         bool isFloorCollision(false);
 
-        AxisAlignedBox CharAab = mCreature->getActor()->getPhysicalThing()->_getBody()->getCollision()->getAABB();
-        Real charHeight = CharAab.getMaximum().y - CharAab.getMinimum().y;
+        AxisAlignedBox charAab = charBody->getCollision()->getAABB();
+        Real charHeight = charAab.getMaximum().y - charAab.getMinimum().y;
         Real stepHeight = point.y - charPos.y;
 
         if( stepHeight < charHeight/2 )
@@ -426,6 +427,17 @@
                 mLastFloorContact = time;
             }
         }
+
+        // set contact direction to point to the center of mass
+        contact.setNormalDirection((charPos + charBody->getCenterOfMass() - point).normalisedCopy());
+        contact.setNormalAcceleration(0);
+        // no friction
+        contact.setFrictionState(0,0);
+        contact.setFrictionState(0,1);
+        contact.setTangentAcceleration(0,0);
+        contact.setTangentAcceleration(0,1);
+
+
 /*
 //        setContactNormalDirection(((Vector3::UNIT_Y.dotProduct(point-charPos)*Vector3::UNIT_Y + charPos) - point).normalisedCopy());
         setContactNormalDirection(point - (charPos + charHeight/2));
@@ -434,8 +446,8 @@
         setContactFrictionState(0,1);
         setContactTangentAcceleration(0, 0);
         setContactTangentAcceleration(0, 1);
+*/
 
-*/
 //std::ostringstream oss;
 //Vector3 vec1, vec2;
 //oss << " Collision: Point: " << point-charPos;
@@ -448,10 +460,10 @@
 //oss << "  \t Tangent-Directions: " << vec1 << " " << vec2;
 //LOG_MESSAGE(Logger::RULES, oss.str());
 
-        contact.rotateTangentDirections(/*charOri*mDirection + */Vector3::UNIT_Y);
-        contact.setFrictionState(1,0);
-        contact.setFrictionState(0,1);
-
+//        contact.rotateTangentDirections(/*charOri*mDirection + */Vector3::UNIT_Y);
+//        contact.setFrictionState(0,0);
+//        contact.setFrictionState(0,1);
+/*
         if( stepHeight < 0.4 )
         {
             if(stepHeight > 0.01f) // experimantal value, 
@@ -485,6 +497,7 @@
                 //setContactFrictionState(0,1);
             }
         }
+*/
 }
 
         if(mMovement != NULL)

Modified: rl/trunk/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatControlState.cpp	2009-04-02 10:20:14 UTC (rev 4882)
+++ rl/trunk/engine/ui/src/CombatControlState.cpp	2009-04-03 13:30:53 UTC (rev 4883)
@@ -110,7 +110,6 @@
         PhysicsManager::getSingleton().getMaterialID("camera"));
         mCameraActor->getPhysicalThing()->unfreeze();
         mCameraActor->getPhysicalThing()->setPhysicsController(this);
-        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
         
         // We also handle cam<->level, cam<->default cam<->char collision from now on
         OgreNewt::MaterialPair* mat_pair = NULL;

Modified: rl/trunk/engine/ui/src/FreeflightControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeflightControlState.cpp	2009-04-02 10:20:14 UTC (rev 4882)
+++ rl/trunk/engine/ui/src/FreeflightControlState.cpp	2009-04-03 13:30:53 UTC (rev 4883)
@@ -63,11 +63,12 @@
     void FreeflightControlState::pause()
     {
 		mCameraActor->getPhysicalThing()->freeze();
-		//mCharacterActor->getPhysicalThing()->unfreeze();
+		mCharacterActor->getPhysicalThing()->unfreeze();
+
+// for testing the OgreNewt player controller
 //        delete mOgreNewtPlayerController;
 
         mOgreNewtPlayerController = NULL;
-        mCharacterActor->getPhysicalThing()->setUpConstraint();
         mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
 
         // Char<->Level collision back to default
@@ -86,8 +87,9 @@
     void FreeflightControlState::resume()
     {
         mCameraActor->getPhysicalThing()->unfreeze();
-		//mCharacterActor->getPhysicalThing()->freeze();
-        mCharacterActor->getPhysicalThing()->clearUpConstraint();
+		mCharacterActor->getPhysicalThing()->freeze();
+
+// for testing the OgreNewt player controller
 //        mOgreNewtPlayerController = new OgreNewt::PlayerController(mCharBody);
 
         resetCamera();
@@ -352,8 +354,11 @@
             Vector3 currentVel = body->getVelocity();
             Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep();
             Vector3 force = mass*(orientation * mDesiredVelocity - currentVel) / delay;
-if( mCollisionsEnabled )
-    force = mass*(- currentVel) / delay;
+
+// for testing the OgreNewt player controller
+//if( mCollisionsEnabled )
+//    force = mass*(- currentVel) / delay;
+
             body->setForce(force);
         }
     }

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2009-04-02 10:20:14 UTC (rev 4882)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2009-04-03 13:30:53 UTC (rev 4883)
@@ -240,7 +240,6 @@
             PhysicsManager::getSingleton().getMaterialID("camera"));
         mCameraActor->getPhysicalThing()->unfreeze();
         mCameraActor->getPhysicalThing()->setPhysicsController(this);
-        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
 
         // We also handle cam<->level, cam<->default cam<->char collision from now on
         OgreNewt::MaterialPair* mat_pair = NULL;



From melven at mail.berlios.de  Fri Apr  3 15:31:30 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Fri, 3 Apr 2009 15:31:30 +0200
Subject: [Dsa-hl-svn] r4884 - in modules: common/dsa regressiontest/scripts
Message-ID: <200904031331.n33DVU6M028086@sheep.berlios.de>

Author: melven
Date: 2009-04-03 15:31:29 +0200 (Fri, 03 Apr 2009)
New Revision: 4884

Modified:
   modules/common/dsa/animals.gof
   modules/regressiontest/scripts/CombatTest.rb
   modules/regressiontest/scripts/NpcTest.rb
Log:
-setUpConstraint in some scripts
-fixed animation speed of wolf


Modified: modules/common/dsa/animals.gof
===================================================================
--- modules/common/dsa/animals.gof	2009-04-03 13:30:53 UTC (rev 4883)
+++ modules/common/dsa/animals.gof	2009-04-03 13:31:29 UTC (rev 4884)
@@ -74,7 +74,7 @@
 	</property>
 	<property name="animationspeeds" type="MAP">
 		<property name="gehen" type="REAL" data="1.4"/>
-		<property name="joggen" type="REAL" data="1.4"/>
+		<property name="joggen" type="REAL" data="0.4"/>
 		<property name="laufen" type="REAL" data="0.4"/>
 		<property name="rennen" type="REAL" data="0.4"/>
 	</property>

Modified: modules/regressiontest/scripts/CombatTest.rb
===================================================================
--- modules/regressiontest/scripts/CombatTest.rb	2009-04-03 13:30:53 UTC (rev 4883)
+++ modules/regressiontest/scripts/CombatTest.rb	2009-04-03 13:31:29 UTC (rev 4884)
@@ -29,5 +29,6 @@
 
 		npc.setPosition(getCenter());
 		npc.placeIntoScene();
+        npc.getActor().getPhysicalThing().setUpConstraint();
 	end
-end
\ No newline at end of file
+end

Modified: modules/regressiontest/scripts/NpcTest.rb
===================================================================
--- modules/regressiontest/scripts/NpcTest.rb	2009-04-03 13:30:53 UTC (rev 4883)
+++ modules/regressiontest/scripts/NpcTest.rb	2009-04-03 13:31:29 UTC (rev 4884)
@@ -12,17 +12,21 @@
 
         npc1 = $GOM.createGameObject("TestPerson");
         npc1.setPosition(rel_pos([0.0, height, 0.0]));
-
         npc1.placeIntoScene();
+        npc1.getActor().getPhysicalThing().setUpConstraint();
 
+
         npc2 = $GOM.createGameObject("TestPerson2");
         npc2.setPosition(rel_pos([2.2, height, 2.2]));
         npc2.setProperty("dialog", "test_3pers_dialog")
         npc2.placeIntoScene();
+        npc2.getActor().getPhysicalThing().setUpConstraint();
+
         npc3 = $GOM.createGameObject("TestPerson");
         npc3.setPosition(rel_pos([1.8, height, 1.8]));
         npc3.setProperty("dialog", "test_3pers_dialog")
         npc3.setName("TestPerson_byName");
         npc3.placeIntoScene();
+        npc3.getActor().getPhysicalThing().setUpConstraint();
     end
 end



From fusion2 at mail.berlios.de  Sun Apr  5 10:27:47 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Sun, 5 Apr 2009 10:27:47 +0200
Subject: [Dsa-hl-svn] r4885 - rl/trunk/editors/Lockenwickler/src
Message-ID: <200904050827.n358Rllv014012@sheep.berlios.de>

Author: fusion2
Date: 2009-04-05 10:27:45 +0200 (Sun, 05 Apr 2009)
New Revision: 4885

Modified:
   rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
Log:
- bugfixes

Modified: rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-03 13:31:29 UTC (rev 4884)
+++ rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-05 08:27:45 UTC (rev 4885)
@@ -352,6 +352,7 @@
         self.mapSelectedCallback(sceneName, mapName)
         
     def updateView(self):
+        self.disconnect(self.sceneTreeView, SIGNAL("itemSelectionChanged ()"), self.onSelectionChanged)
         self.mapItems = []
         self.sceneTreeView.clear()
         
@@ -363,7 +364,8 @@
                 self.parseMap(m, sceneRootItem)
         
         self.paintLastSelectedMapBlue()
-
+        self.connect(self.sceneTreeView, SIGNAL("itemSelectionChanged ()"), self.onSelectionChanged)
+        
     def parseMap(self, map, sceneRootItem):
         childItem =  QTreeWidgetItem(sceneRootItem)
         self.mapItems.append(childItem)

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-04-03 13:31:29 UTC (rev 4884)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-04-05 08:27:45 UTC (rev 4885)
@@ -1,1356 +1,1365 @@
- #################################################
-# This source file is part of Rastullahs Lockenwickler.
-# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
-
-import sys
-import codecs
-import glob
-import os
-from os.path import isfile,  join
-
-import xml.etree.cElementTree as xml
-
-import ctypes
-import ogre.renderer.OGRE as og
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from SelectionBuffer import *
-from DepthBuffer import *
-from MovePivot import *
-from GameObjectClassManager import *
-from MyRaySceneQueryListener import *
-from ZoneManager import ZoneManager
-
-
-# get the light out of a light node
-def extractLight(node):
-        i = 0
-        num = node.numAttachedObjects()
-        while i < node.numAttachedObjects():
-            c = node.getAttachedObject(i)
-            tp = str(type(c))
-            if tp == "<class 'ogre.renderer.OGRE._ogre_.Light'>":
-                return c
-            
-            i += 1
-
-# make the xml file more pretty
-def indent(elem, level=0):
-    i = "\n" + level*"  "
-    
-    if len(elem):
-        if not elem.text or not elem.text.strip():
-            elem.text = i + "  "
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-        for elem in elem:
-            indent(elem, level+1)
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-    else:
-        if level and (not elem.tail or not elem.tail.strip()):
-            elem.tail = i
-
-# creates unique names for new entities
-def createUniqueEntityName(sceneManager, name = None):
-    n = ""
-    if name is None:
-        n = "dropMesh" + str(ModuleManager.dropCount)
-    else:
-        n = name
-        
-    while sceneManager.hasEntity(n):
-        n = "dropMesh" + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-    return n
-        
-def printVector3(vec):
-    print str(vec.x) + ";" + str(vec.y) + ";" + str(vec.z)
-    
-class EntityCustomOptions(og.UserDefinedObject):
-    def __init__(self, receivesShadow = True, staticgeometrygroup = 0, physicsproxytype = "none", renderingdistance = "20000"):
-        og.UserDefinedObject.__init__(self)
-        self.receivesShadow = receivesShadow
-        self.staticgeometrygroup = staticgeometrygroup
-        self.physicsproxytype = physicsproxytype
-        self.renderingdistance = renderingdistance
-        self.materialName = "NotChanged"
-        
-        ModuleManager.entityCustomOptionsDict.append(self)
-        
-    def copy(self):
-            return EntityCustomOptions(self.receivesShadow, self.staticgeometrygroup, self.physicsproxytype, self.renderingdistance)
-        
-    def getType(self):
-            return "EntityCustomOptions"
-
-class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyMap = False):
-        self.pathToMapFile = pathToFile
-        
-        mapName = pathToFile.replace("\\", "/")
-        mapName = mapName.split("/")
-        mapName = mapName[len(mapName) - 1].split(".")
-        mapName = mapName[len(mapName) - 3]
-        self.mapName = mapName
-        self.mapFileName = self.mapName + ".rlmap.xml"
-        
-        self.sceneManager = sceneManager
-        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-        self.zoneManager = zoneManager
-        self.isHidden = False
-        
-        self.zoneList = []
-        
-        if not emptyMap:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-
-            if root.attrib["formatVersion"] == "0.4.0":
-                self.parseMapNodes(root.find("nodes"))
-                self.parseMapZones(root.find("zones"))
-            else:
-                print pathToFile + " has wrong format version. It needs to be 0.4.0"
-                return
-
-    def hide(self):
-        try:
-            self.sceneManager.getRootSceneNode().removeChild(self.mapNode)
-        except:
-            print "Error: map is already hidden!"
-            return
-        
-        self.isHidden = True
-        
-    def show(self):
-        try:
-            self.sceneManager.getRootSceneNode().addChild(self.mapNode)
-        except:
-            print "Error: map is already shown!"
-            return
-        
-        self.isHidden = False
-    
-    def parseMapZones(self, zonesElement):
-        self.zoneManager.parseZonesFromXml(zonesElement, self)
-    
-    def parseMapNodes(self, nodeElement):
-        nodes = nodeElement.getiterator("gameobject")
-        self.createGameObjects(nodes)
-        
-        nodes = nodeElement.getiterator("entity")
-        self.createEntites(nodes)
-
-        nodes = nodeElement.getiterator("light")
-        self.createLights(nodes)
-
-        nodes = nodeElement.getiterator("sound")
-        self.createSound(nodes)
-
-        nodes = nodeElement.getiterator("particlesystem")
-        self.createParticleSystems(nodes)
-
-    def createEntites(self, entityNodes):
-        for nodes in entityNodes:
-            entityName = nodes.attrib["name"]
-            
-            if entityName.startswith("dropMesh"):
-                num = int(entityName.replace("dropMesh",  ""))
-                if ModuleManager.dropCount < num:
-                    ModuleManager.dropCount = num
-                elif ModuleManager.dropCount < num:
-                    ModuleManager.dropCount = num + 1
-                    
-            meshFile = nodes.attrib["meshfile"]
-            
-            eco = EntityCustomOptions()
-            
-            try:
-                if nodes.attrib["receivesShadow"] == "False" or nodes.attrib["receivesShadow"] == "false":
-                    eco.receivesShadow = "False"
-            except:
-                pass
-            try:
-                eco.staticgeometrygroup = int(nodes.attrib["staticgeometrygroup"])
-            except:
-                pass
-            try:
-                eco.physicsproxy = nodes.attrib["physicsproxy"]
-            except:
-                pass
-            try:
-                eco.renderingdistance = float(nodes.attrib["renderingdistance"])
-            except:
-                pass
-            try:
-                eco.renderingdistance
-                nodes.attrib["materialName"]
-            except:
-                pass
-                
-            nodePosition = None
-            nodeScale = None
-            qw = qx = qy = qz = None
-
-            transformations = nodes.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    posx = float(t.attrib["x"])
-                    posy = float(t.attrib["y"])
-                    posz = float(t.attrib["z"])
-                    nodePosition = og.Vector3(posx, posy, posz)
-                elif t.tag == "rotation":
-                    qw = float(t.attrib["qw"])
-                    qx = float(t.attrib["qx"])
-                    qy = float(t.attrib["qy"])
-                    qz = float(t.attrib["qz"])
-                elif t.tag == "scale":
-                    scalex = float(t.attrib["x"])
-                    scaley = float(t.attrib["y"])
-                    scalez = float(t.attrib["z"])
-                    nodeScale = og.Vector3(scalex, scaley, scalez)
-
-            try:
-                e = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager,  entityName), meshFile)
-            except:
-                print "Warning: Meshfile " + meshFile + " could not be found."
-                return
-
-            e.setUserObject(eco)
-            n = self.mapNode.createChild("entity_" + entityName + "_node")
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            n.setOrientation(qw, qx, qy, qz)
-            n.setScale(nodeScale)
-
-    def createLights(self, lightNodes):
-        for l in lightNodes:
-            lightName = l.attrib["name"]
-            lightType = l.attrib["type"]
-            lightVisible = bool(l.attrib["visible"])
-            castShadows = bool(l.attrib["castShadows"])
-            lightPosition = None
-            lightDirection = None
-            colourDiffuse = None
-            colourSpecular = None
-            lightAttenuationRange = None
-            lightAttenuationConstant= None
-            lightAttenuationLinear = None
-            lightAttenuationQuadratic = None
-            spotlightinner = None
-            spotlightouter = None
-            falloff = None 
-                
-            transformations = l.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    lightPosition = og.Vector3(x, y, z)
-                elif t.tag == "colourDiffuse":
-                    r = float(t.attrib["r"])
-                    g = float(t.attrib["g"])
-                    b= float(t.attrib["b"])
-                    colourDiffuse = og.ColourValue(r, g, b)
-                elif t.tag == "colourSpecular":
-                    r = float(t.attrib["r"])
-                    g = float(t.attrib["g"])
-                    b= float(t.attrib["b"])
-                    colourSpecular = og.ColourValue(r, g, b)
-                elif t.tag == "lightAttenuation":
-                    lightAttenuationRange = float(t.attrib["range"])
-                    lightAttenuationConstant= float(t.attrib["constant"])
-                    lightAttenuationLinear = float(t.attrib["linear"])
-                    lightAttenuationQuadric  = float(t.attrib["quadratic"])
-                elif t.tag == "spotlightrange":
-                    spotlightinner = float(t.attrib["inner"])
-                    spotlightouter = float(t.attrib["outer"])
-                    falloff = float(t.attrib["falloff"])
-                    
-            light = self.sceneManager.createLight(lightName)
-            
-            if lightType == "point":
-                light.setType(og.Light.LT_POINT)            
-            elif lightType == "spot":
-                light.setType(og.Light.LT_SPOTLIGHT)
-            elif lightType == "directional":
-                light.setType(og.Light.LT_DIRECTIONAL)
-            
-            light.setVisible(lightVisible)
-            light.setCastShadows(castShadows)
-            if lightAttenuationRange is not None and lightAttenuationConstant is not None and lightAttenuationLinear is not None and lightAttenuationQuadric is not None:
-                light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadric)
-            if colourDiffuse:
-                light.setDiffuseColour(colourDiffuse)
-            if colourSpecular:
-                light.setSpecularColour(colourSpecular)
-            if spotlightinner and spotlightouter and spotlightouter: 
-                light.setSpotlightRange(spotlightinner, spotlightouter, falloff)
-            
-            e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
-            n = self.mapNode.createChild("light_" + lightName + "_node")
-            n.attachObject(light)
-            n.attachObject(e)
-            if lightPosition:
-                n.setPosition(lightPosition)
-            
-    def createSound(self, soundNodes):
-        #raise NotImplementedError
-        return
-
-    def createGameObjects(self, gameObjectNodes):
-        for g in gameObjectNodes:
-            classid = g.attrib["class"]
-            
-            id = int(g.attrib["id"])
-            if ModuleManager.dropCount < id:
-                ModuleManager.dropCount = id
-            elif ModuleManager.dropCount < id:
-                ModuleManager.dropCount = id + 1
-                
-            state = g.attrib["state"]
-            nodePosition = None
-            nodeRotation = None
-
-            transformations = g.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    nodePosition = og.Vector3(x, y, z)
-                elif t.tag == "rotation":
-                    qw = float(t.attrib["qw"])
-                    qx = float(t.attrib["qx"])
-                    qy = float(t.attrib["qy"])
-                    qz = float(t.attrib["qz"])
-                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
-
-            go = self.gocManager.getGameObjectWithClassId(classid)
-            if go is not None:
-                meshFile = go.getMeshFileName()
-                
-                ent = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-                dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
-                dropNode.attachObject(ent)
-
-                if nodePosition:
-                    dropNode.setPosition(nodePosition)
-                if nodeRotation:
-                    dropNode.setOrientation(nodeRotation)
-
-                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
-                self.gocManager.addGameObjectRepresentation(go)
-                go.inWorldId = id
-                go.state = state
-                ent.setUserObject(go)
-
-
-    def createParticleSystems(self, particleNodes):
-        #raise NotImplementedError
-        return
-        
-    def save(self):
-        root = xml.Element("rastullahmap")
-        root.attrib["formatVersion"] = "0.4.0"
-        
-        nodesElem = xml.SubElement(root, "nodes")
-        
-        i = 0
-        while i < self.mapNode.numChildren():
-            n = self.mapNode.getChild(i)
-            if n.numAttachedObjects() > 0:
-                if n.name.startswith("entity_"):
-                    entElem = xml.SubElement(nodesElem, "entity")
-                    entElem.attrib["name"] = n.getAttachedObject(0).getName()
-                    print "Saving Entity: " + n.getAttachedObject(0).getName()
-                    entElem.attrib["meshfile"] = n.getAttachedObject(0).getMesh().getName()
-   
-                    entElem.attrib["receivesShadow"] = str(n.getAttachedObject(0).getUserObject().receivesShadow).lower()
-                    entElem.attrib["staticgeometrygroup"] = str(n.getAttachedObject(0).getUserObject().staticgeometrygroup)
-                    entElem.attrib["physicsproxytype"] = str(n.getAttachedObject(0).getUserObject().physicsproxytype)
-                    entElem.attrib["renderingdistance"] = str(n.getAttachedObject(0).getUserObject().renderingdistance)
-                    
-                    posElem = xml.SubElement(entElem, "position")
-                    posElem.attrib["x"] = str(n.getPosition().x)
-                    posElem.attrib["y"] = str(n.getPosition().y)
-                    posElem.attrib["z"] = str(n.getPosition().z)
-                    
-                    rotElem = xml.SubElement(entElem, "rotation")
-                    rotElem.attrib["qw"] = str(n.getOrientation().w)
-                    rotElem.attrib["qx"] = str(n.getOrientation().x)
-                    rotElem.attrib["qy"] = str(n.getOrientation().y)
-                    rotElem.attrib["qz"] = str(n.getOrientation().z)
-                    
-                    scaleElem = xml.SubElement(entElem, "scale")
-                    scaleElem.attrib["x"] = str(n.getScale().x)
-                    scaleElem.attrib["y"] = str(n.getScale().y)
-                    scaleElem.attrib["z"] = str(n.getScale().z)
-                    
-                elif n.name.startswith("gameobject_"):
-                    goElem = xml.SubElement(nodesElem, "gameobject")
-                    mname = n.name
-                    print "Saving GOID: " + str(n.getAttachedObject(0).getUserObject().inWorldId)
-                    goElem.attrib["class"] = str(n.getAttachedObject(0).getUserObject().gocName)
-                    goElem.attrib["state"] = str(n.getAttachedObject(0).getUserObject().state)
-                    goElem.attrib["id"] = str(n.getAttachedObject(0).getUserObject().inWorldId)
-                    
-                    posElem = xml.SubElement(goElem, "position")
-                    posElem.attrib["x"] = str(n.getPosition().x)
-                    posElem.attrib["y"] = str(n.getPosition().y)
-                    posElem.attrib["z"] = str(n.getPosition().z)
-                    
-                    rotElem = xml.SubElement(goElem, "rotation")
-                    rotElem.attrib["qw"] = str(n.getOrientation().w)
-                    rotElem.attrib["qx"] = str(n.getOrientation().x)
-                    rotElem.attrib["qy"] = str(n.getOrientation().y)
-                    rotElem.attrib["qz"] = str(n.getOrientation().z)
-                    
-                elif n.name.startswith("light_"):
-                    light = extractLight(n)
-                    lightName = light.getName()
-                    print "Saving Light: " + lightName
-                    lightType = light.getType()
-                    isVisible = "true"
-                    if not light.getVisible():
-                        isVisible = "false"
-                    
-                    castShadows = "false"
-                    if light.getCastShadows():
-                        castShadows = "true"
-                    
-                    if lightType == og.Light.LT_POINT:
-                        lightType = "point"
-                    elif lightType == og.Light.LT_SPOTLIGHT:
-                        lightType = "spot"
-                    elif lightType == og.Light.LT_DIRECTIONAL:
-                        lightType = "directional"
-                    
-                    
-                    lightElem = xml.SubElement(nodesElem, "light")
-                    lightElem.attrib["name"] = lightName
-                    lightElem.attrib["type"] = lightType
-                    lightElem.attrib["visible"] = isVisible
-                    lightElem.attrib["castShadows"] = castShadows
-                    
-                    if lightType == "point" or lightType == "spot":
-                        posElem = xml.SubElement(lightElem, "position")
-                        posElem.attrib["x"] = str(n.getPosition().x)
-                        posElem.attrib["y"] = str(n.getPosition().y)
-                        posElem.attrib["z"] = str(n.getPosition().z)
-                    
-                    colDiffuseElem = xml.SubElement(lightElem, "colourDiffuse")
-                    colDiffuseElem.attrib["r"] = str(light.getDiffuseColour().r)
-                    colDiffuseElem.attrib["g"] = str(light.getDiffuseColour().g)
-                    colDiffuseElem.attrib["b"] = str(light.getDiffuseColour().b)
-
-                    colSpecularElem = xml.SubElement(lightElem, "colourSpecular")
-                    colSpecularElem.attrib["r"] = str(light.getSpecularColour().r)
-                    colSpecularElem.attrib["g"] = str(light.getSpecularColour().g)
-                    colSpecularElem.attrib["b"] = str(light.getSpecularColour().b)
-                    
-                    lightAttenuationElem = xml.SubElement(lightElem, "lightAttenuation")
-                    lightAttenuationElem.attrib["range"] = str(light.getAttenuationRange())
-                    lightAttenuationElem.attrib["constant"] = str(light.getAttenuationConstant())
-                    lightAttenuationElem.attrib["linear"] = str(light.getAttenuationLinear())
-                    lightAttenuationElem.attrib["quadratic"] = str(light.getAttenuationQuadric())
-                    
-                    if lightType == "spot":
-                        spotligthRangeElem = xml.SubElement(lightElem, "spotlightrange")
-                        spotligthRangeElem.attrib["inner"] = str(light.getSpotlightInnerAngle().valueDegrees())
-                        spotligthRangeElem.attrib["outer"] = str(light.getSpotlightOuterAngle().valueDegrees())
-                        spotligthRangeElem.attrib["falloff"] = str(light.getSpotlightFalloff())
-                        
-                    if lightType == "spot" or lightType == "directional":
-                        directionElem = xml.SubElement(lightElem, "direction")
-                        dir = og.Vector3()
-                        n.getOrientation().ToAxes(dir)
-                        directionElem.attrib["x"] = str(dir.x)
-                        directionElem.attrib["y"] = str(dir.y)
-                        directionElem.attrib["z"] = str(dir.z)
-                        
-            i = i+1
-            
-        self.zoneManager.saveZonesToXml(root, self)
-        indent(root)
-        xml.ElementTree(root).write(self.pathToMapFile)
-
-# caused a linux crash
-#        iter = self.mapNode.getChildIterator()
-#        while iter.hasMoreElements():
-#            name = iter.getNext().getName()
-#            print name
-
-class Scene():
-    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyScene = False, sceneName = "NewScene"):
-        self.moduleRoot = moduleroot
-        self.pathToFile = pathToFile
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-        self.zoneManager = zoneManager
-        self.mapFiles = [] # a list in case the module has more than one map file
-        mappaths = []
-        self.name = sceneName
-
-        
-        if not emptyScene:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-            self.name = root.attrib["name"]
-        
-            maps = root.getiterator("map")
-            for m in maps:
-                mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
-                
-            for m in mappaths:
-                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
-            
-    def addMap(self, name):
-        path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
-        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True))
-        
-    def save(self):
-        root = xml.Element("scene")
-        root.attrib["name"] = self.name
-        
-        for m in self.mapFiles:
-            sub = xml.SubElement(root, "map")
-            sub.attrib["file"] = m.mapFileName
-            m.save()
-
-        indent(root)
-        xml.ElementTree(root).write(self.pathToFile)
-
-class Module():
-    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager, zoneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gameObjectManager
-        self.zoneManager = zoneManager
-        
-        self.name = name
-        self.moduleRoot = join(modulePath, name)
-        self.__isCommon = False
-
-        self.hasDependencies = False
-        self.moduleDependencies = []
-
-        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
-
-        self.gofFiles = [] # gof File list
-
-        self.scenes =[]
-
-        self.isLoaded = False
-        
-        self.playerStart = None
-        
-    def addScene(self, name):
-        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True, name))
-    
-    def addMapToScene(self, sceneName, mapName):
-        for scene in self.scenes:
-            if scene.name == sceneName:
-                scene.addMap(mapName)
-                return
-        
-        print "ERROR: could not find scene: " + sceneName
-        
-    
-    def isCommon(self):
-        if isfile(self.modConfig): # is the modconfig existing?
-            f = codecs.open(self.modConfig, 'r', 'utf-8')
-        else:
-            print ("Module.isCommon() Error: couldn't find module config")
-            return
-        isDependencieLine = False
-        for i, line in enumerate(f):
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith("super("):
-                split = lStripped.split(",")
-                if split[2].strip() == unicode("true"):
-                    self.__isCommon = True
-                    return True
-
-
-            elif isDependencieLine:
-                if lStripped == "end":
-                    isDependencieLine = False
-                else:
-                    self.hasDependencies = True
-                    pl = lStripped.split('"')
-                    i = 1
-                    while i < 100: 
-                        try:
-                            self.moduleDependencies.append(pl[i])
-                            i += 2
-                        except IndexError, e:
-                            break
-
-            elif lStripped == "def getDependencies()":
-                isDependencieLine = True
-
-        return False
-
-    def load(self):
-        if self.isLoaded:
-            return
-        
-        self.isLoaded = True
-        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
-        if isfile(self.modConfig): # is the modconfig existing?
-            f = codecs.open(self.modConfig, 'r', 'utf-8')
-        else:
-            print ("Module.load: Error: couldn't find module config")
-            return
-
-        for line in f:
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith("hero = $GOM.getGameObject("):
-                try:
-                    self.playerStart = int(line.split("(")[1].split(")")[0])
-                except ValueError, e:
-                    print self.modConfig + " ValueError: " + str(e)
-                    self.playerStart = None
-                    continue
-                    
-        self.setResourcePaths()
-        
-        try:
-            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-        except og.OgreException, e:
-            print e
-        
-        
-        cmd = join(self.moduleRoot, "dsa/*.gof")
-        self.gofFiles = glob.glob(cmd)
-        self.gocManager.parseGOFFiles(self.gofFiles)
-
-        if not self.isCommon():
-            cmd = join(self.moduleRoot, "maps/*.rlscene")
-            sceneFile = glob.glob(cmd)
-            self.loadScenes(sceneFile)
-                
-    def loadScenes(self, sceneFiles):
-        for s in sceneFiles:
-            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
-
-    def save(self):
-        for s in self.scenes:
-            s.save()
-            
-        self.saveModuleConfig()
-
-    def saveModuleConfig(self):
-        if self.playerStart is not None:
-            f = open(self.modConfig, "r")
-            
-            newconfig = ""
-            for line in f:
-                if line.startswith("       hero = $GOM.getGameObject("):
-                    newconfig += "       hero = $GOM.getGameObject(" + str(self.playerStart) + ");\n"
-                else:
-                    newconfig += line
-            f.close()
-            
-            f = open(self.modConfig, "w")
-            f.write(newconfig)
-            f.close()
-
-    def setResourcePaths(self, recurseFolder = ""):
-        if recurseFolder == "":
-            rootFolder = self.moduleRoot
-        else:
-            rootFolder = join(self.moduleRoot, recurseFolder)
-
-        for file in os.listdir(rootFolder):
-            curFile = join(rootFolder, file)
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            elif os.path.isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
-                self.setResourcePaths(curFile)
-            elif os.path.isfile(curFile):
-                continue
-                
-    def getMap(self, mapName, sceneName = None):
-        if sceneName is not None:
-            for s in self.scenes:
-                if s.name == sceneName:
-                    for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-        else:
-            for s in self.scenes:
-                for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-
-class ProgressBarThread(QThread):
-    def __init__(self, min, max, moduleName):
-        QThread.__init__(self)
-        self.progress = QProgressDialog("Loading " + moduleName, "Abort Loading", min, max, None);
-        self.progress.setWindowModality(Qt.WindowModal)
-
-    def setProgress(self, progress, labelText):
-        self.progress.setLabelText(labelText)
-        self.progress.setValue(progress)
-        
-    def run(self):
-        self.progress.show()
-        self.exec_()
-
-        
-class ModuleManager():
-    dropCount = 0
-    entityCustomOptionsDict = []
-    
-    def __init__(self,  ogreRoot,  sceneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.modelSelectionDialog = None
-        self.materialSelectionDialog = None
-
-        self.moduleCfgPath = ""
-
-        self.gocManager = GameObjectClassManager()
-        
-
-        self.mainModule = None
-        self.mainModuledependencieList =[]
-        self.moduleList = []
-        self.userSelectionList = []
-        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
-        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-        self.currentMap = None
-        self.moduleExplorer = None
-
-        self.lastRay = None
-        self.rayLine = None
-
-        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
-        self.pivot = None
-        self.movingPivot = False
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.dropNode = None
-        self.dropEntity = None
-        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
-        self.dropMat = None
-        
-        self.moduleConfigIsParsed = False
-
-        self.selectionBuffer = None
-        self.depthBuffer = None
-        self.propertyWindow = None
-    
-        self.oneClickEntityPlacement = False
-        
-        self.onContextMenuCallback = None
-        self.contextMenuClickPosition = None
-        self.contextMenuRay = None
-        
-        self.playerStartGameObjectId = None
-        
-        self.entityCustomOptionsDict = []
-        
-        self.raySceneQueryListener = MyRaySceneQueryListener()
-        
-        self.zoneManager = ZoneManager(self.sceneManager)
-        
-    def resetParsedModuleConfig(self):
-        self.moduleConfigIsParsed = False
-        self.moduleList = []
-
-    def parseModuleConfig(self):
-        if self.moduleConfigIsParsed:
-            return
-
-        import codecs
-        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
-
-        for line in f:
-            if line.startswith('#'):
-                continue
-
-            if line.startswith('module='):
-                splines = line.split('=')
-                str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
-
-        self.moduleConfigIsParsed = True
-
-    def moduleExists(self, name):
-        lowerA = str(name).lower()
-        
-        for m in self.moduleList:
-            lowerB = m.name.lower()
-            if lowerA == lowerB:
-                return True
-        
-        return False
-
-    def openLoadModuleDialog(self):
-        self.moduleFolder = str(self.moduleCfgPath.replace("modules.cfg", ""))
-
-        self.parseModuleConfig()
-
-        dlg = QDialog(QApplication.focusWidget())
-        list = QListWidget()
-        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
-        dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
-        dlg.connect(btnBox, SIGNAL("rejected()"), dlg.reject)
-
-        for m in self.moduleList:
-            if not m.isCommon():
-                list.addItem(m.name)
-
-        layout = QVBoxLayout()
-        layout.addWidget(list)
-        layout.addWidget(btnBox)
-        dlg.setLayout(layout)
-        if dlg.exec_():
-            self.loadModule(str(list.currentItem().text()))
-
-    # I'm sorry for this
-    def loadModule(self, moduleName):
-        t = og.Timer()
-        
-#        self.progress = ProgressBarThread(0, 8, moduleName)
-#        self.progress.start()
-        
-        for m in self.moduleList:
-            if m.name == moduleName:
-                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
-                    for moduleDependencie in m.moduleDependencies:
-                        for m2 in self.moduleList:
-                            if m2.name == moduleDependencie:
-#                                self.progress.setProgress(2, "Loading Dependencie: " + moduleDependencie)
-                                m2.load()
-                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
-                                self.materialSelectionDialog.scanDirForMaterials(m2.moduleRoot)
-                                self.mainModuledependencieList.append(m2)
-
-#                self.progress.setProgress(4, "Loading " + moduleName)
-                m.load()
-#                self.progress.setProgress(6, "Scan for models...")
-                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
-#                self.progress.setProgress(8, "Scan for materials")
-                self.materialSelectionDialog.scanDirForMaterials(m.moduleRoot)
-                self.mainModule = m
-                self.moduleExplorer.setCurrentModule(m)
-
-        if self.selectionBuffer is None:
-            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"), self, self.zoneManager)
-
-#        if self.depthBuffer is None:
-#            self.depthBuffer = DepthBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
-
-
-#        self.progress.quit()
-        print "Time to load module: " + str(t.getMilliseconds() / 1000.0) + " seconds"
-        del t
-
-    def addSceneToModule(self, name):
-        if self.mainModule is not None:
-            self.mainModule.addScene(name)
-
-    def addMapToScene(self, sceneName, mapName):
-        if self.mainModule is not None:
-            self.mainModule.addMapToScene(sceneName, mapName)
-
-    def setModuleExplorer(self, moduleExplorer):
-        self.moduleExplorer = moduleExplorer
-        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
-        self.moduleExplorer.setSelectionChangedCallback(self.selectionChangedCallback)
-        self.moduleExplorer.setModuleManager(self)
-    
-    def setPropertyWindow(self, propertyWin):
-        self.propertyWindow = propertyWin
-    
-    def selectionChangedCallback(self, items):
-        self.resetSelection()
-        self.userSelectionList = self.selectionBuffer.manualSelectObjects(items)
-        
-    def selectMapCallback(self, sceneName, mapName):
-        self.currentMap = self.mainModule.getMap(mapName, sceneName)
-        self.zoneManager.currentMap = self.currentMap
-        if self.currentMap is None:
-            print "Don't forget to select a map"
-
-        
-    # called when a click into Main Ogre Window occurs
-    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
-        if self.oneClickEntityPlacement:
-            if self.modelSelectionDialog.listWidget.currentItem() is not None:
-                meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
-                self.startDropModelAction(meshFile, ray)
-                self.moduleExplorer.updateView()
-                return
-            else:
-                print "Warning: OneClickEntityPlacement still runing on without any selected mesh!"
-                return
-                
-        #self.depthBuffer.onSelectionClick(screenX, screenY)
-        
-        so = None
-        if self.selectionBuffer is not None:
-            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        
-        if so is not None:
-            if not so.isPivot:                
-                if not controlDown and not shiftDown:
-                    self.resetSelection()
-                    so.setSelected(True)
-                    self.userSelectionList.append(so)
-                    self.propertyWindow.showProperties(so)
-                    self.moduleExplorer.deselectAll()
-                    self.moduleExplorer.selectItem(so, True)
-                    self.updatePivots()
-                elif controlDown and not shiftDown:
-                    so.setSelected(True)
-
-                    for soFromList in self.userSelectionList:
-                        if soFromList == so:
-                            return # object already selected
-
-                    self.userSelectionList.append(so)
-                    self.propertyWindow.showProperties(so)
-                    self.moduleExplorer.selectItem(so, True)
-                    self.updatePivots()
-
-
-                elif not controlDown and shiftDown:
-                    for selo in self.userSelectionList:
-                        if so == selo:
-                            so.setSelected(False)
-                            self.userSelectionList.remove(selo)
-                            self.moduleExplorer.selectItem(selo, False)
-                    self.updatePivots()
-                
-            else:
-                #so.entity is the pivot direction that was clicked
-                self.pivot.startTransforming(so.entity,  self.userSelectionList)
-        else:
-            self.resetSelection() # click in empty space, deselect everything
-            self.moduleExplorer.selectItems(None)
-            self.propertyWindow.clear()
-            if self.pivot is not None:
-                self.pivot.hide()
-
-#        if self.rayLine == None:
-#            self.rayLine = self.sceneManager.createManualObject("rayLine")
-#            self.rayLine.setDynamic(True)
-#            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
-#
-#            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-#
-#        else:
-#            self.rayLine.beginUpdate(0)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-
-    def deleteObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.pivot.hide()
-
-        for so in self.userSelectionList:
-            node = so.entity.getParentNode()
-            if node.getName().startswith("area_"):
-                self.zoneManager.deleteArea(so.entity.getUserObject())
-                continue
-            elif node.getName().startswith("light_"):
-                light = extractLight(node)
-                self.sceneManager.destroyLight(light)
-                
-            node.detachAllObjects()
-            self.sceneManager.destroySceneNode(node)
-            self.sceneManager.destroyEntity(so.entity)
-            del so
-
-        self.userSelectionList = []
-
-    def copyObjects(self):
-        if len(self.userSelectionList) < 1 or self.currentMap is None:
-            print "Warning: No map selected!"
-            return
-
-        newSelectionList = []
-
-        for so in self.userSelectionList:
-            if so.entity.getUserObject() is not None:
-                if str(so.entity.getParentNode().getName()).startswith("gameobject_"):
-                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
-                    meshFile = go.getMeshFileName()
-
-                    if go is not None:
-                        newEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-                        newNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
-                        newNode.attachObject(newEntity)
-                        newNode.setPosition(so.entity.getParentNode().getPosition())
-
-                        newGO = GameObjectRepresentation(ModuleManager.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
-                        self.gocManager.addGameObjectRepresentation(newGO)
-                        newEntity.setUserObject(newGO)
-
-                        newSO = SelectionObject(newEntity)
-                        newSO.setSelected(True)
-                        newSelectionList.append(newSO)
-                        ModuleManager.dropCount += 1
-                elif str(so.entity.getParentNode().getName()).startswith("entity_"):
-                    nodeName = "entity_dropNode" + str(ModuleManager.dropCount)
-                    newNode = self.currentMap.mapNode.createChild(nodeName)
-
-                    entityName = createUniqueEntityName(self.sceneManager)
-                    newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
-
-                    eco = so.entity.getUserObject().copy()
-                    newEntity.setUserObject(eco)
-
-                    newNode.attachObject(newEntity)
-                    newNode.setPosition(so.entity.getParentNode().getPosition())
-                    newNode.setOrientation(so.entity.getParentNode().getOrientation())
-                    newNode.setScale(so.entity.getParentNode().getScale())
-
-                    newSO = SelectionObject(newEntity)
-                    newSO.setSelected(True)
-                    newSelectionList.append(newSO)
-                    ModuleManager.dropCount += 1
-                elif str(so.entity.getParentNode().getName()).startswith("light_"):
-                    print "Can't copy lights yet :)"
-
-        self.resetSelection()
-        self.userSelectionList = newSelectionList
-
-    def cutObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.cutList = []
-        for so in self.userSelectionList:
-            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
-            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
-            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
-            # so we only have to translate them to their new destination when they get pasted
-            # the position of the pivot point is considered as the center of gravity
-            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
-            self.cutList.append(so)
-        self.resetSelection()
-
-    def pasteObjects(self,  ray):
-        if len(self.cutList) < 1:
-            return
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
-                i = i+1
-        else:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
-                i = i+1
-        self.cutList = []
-
-    def leftMouseUp(self):
-        if self.pivot is not None and self.pivot.isTransforming:
-            self.propertyWindow.updateProperties()
-            self.moduleExplorer.updateView()
-            self.pivot.stopTransforming()
-
-    def resetSelection(self):
-        if self.userSelectionList is not None:
-            for so in self.userSelectionList:
-                so.setSelected(False)
-
-        self.userSelectionList = []
-
-    def updatePivots(self):
-        newPivotPosition = og.Vector3(0, 0, 0)
-
-        for so in self.userSelectionList:
-            newPivotPosition += so.entity.getParentNode().getPosition()
-        if self.pivot is not None:
-            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
-
-    def unload(self,  saveOnUnload=True):
-        pass
-
-    def save(self):
-        self.mainModule.save()
-
-    def startDropGameObjectAction(self, classid, ray):
-        if self.currentMap is None:
-            print "No map selected!"
-            return
-            
-        go = self.gocManager.getGameObjectWithClassId(classid)
-
-        if go is not None:
-            meshFile = go.getMeshFileName()
-            dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
-            dropNode.attachObject(dropEntity)
-
-            result = og.Math.intersects(ray, self.dropCollisionPlane)
-            if result.first == True:
-                dropNode.setPosition(ray.getPoint(result.second))
-            else:
-                dropNode.setPosition(ray.getPoint(50))
-
-            self.dropGO = GameObjectRepresentation(ModuleManager.dropCount, classid, dropNode, meshFile)
-            self.gocManager.addGameObjectRepresentation(self.dropGO)
-            dropEntity.setUserObject(self.dropGO)
-
-        ModuleManager.dropCount += 1
-
-    def moveDropGameObjectAction(self, ray):
-        if self.currentMap is None:
-            return
-        
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropGO.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropGO.setPosition(ray.getPoint(50))
-
-    def finishDropGameObjectAction(self, ray):
-        self.moduleExplorer.updateView()
-        self.dropGO = None
-        return
-
-    def startDropModelAction(self, meshFile, ray):
-        if self.currentMap is None:
-            print "No map selected!"
-            return
-            
-        self.dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), meshFile)
-        
-        eco = EntityCustomOptions()
-        self.dropEntity.setUserObject(eco)
-        
-        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(ModuleManager.dropCount))
-        self.dropNode.attachObject(self.dropEntity)
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-        ModuleManager.dropCount += 1
-
-    def moveDropModelAction(self, ray):
-        if self.currentMap is None:
-            return
-            
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-    
-    def finishDropModelAction(self, ray):
-        self.moduleExplorer.updateView()
-        return
-
-    def startDropMaterialAction(self, text):
-        self.dropMat = text
-        
-    def moveDropMaterialAction(self, event):
-        return
-
-    def finishDropMaterialAction(self, screenX, screenY):
-        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        if so is not None:
-            if not so.entity.getNumSubEntities() > 1:
-                so.entity.setMaterialName(self.dropMat)
-                so.entity.getUserObject().materialName = self.dropMat
-            else:
-                i = 0
-                text = "Warning this Entity has more than one SubEntities with the folloing materials: \n\n"
-                while i < so.entity.getNumSubEntities():
-                    text += "SubMesh" + str(i) + ":  " + so.entity.getSubEntity(i).getMaterialName() + "\n"
-                    i += 1
-                
-                text += "\n Replace the materials?"
-                reply = QMessageBox.question(None, "Warning: multiple materials",  text,  QMessageBox.Yes|QMessageBox.No)
-                if reply == QMessageBox.Cancel:
-                    return
-                if reply == QMessageBox.Yes:
-                    so.entity.setMaterialName(self.dropMat)
-                    so.entity.getUserObject().materialName = self.dropMat
-        
-    def setOneClickEntityPlacement(self, state):
-        self.oneClickEntityPlacement = state
-    
-    def createLight(self, name):
-        pos = og.Vector3()
-        
-        query = self.sceneManager.createRayQuery(self.contextMenuRay)
-        query.ray = self.contextMenuRay
-        query.setSortByDistance(True)
-        query.execute(self.raySceneQueryListener)
-        if self.raySceneQueryListener.dist < 100000:
-            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
-            self.raySceneQueryListener.dist = 100000
-            
-        light = None
-        if not self.sceneManager.hasLight(name):
-            light = self.sceneManager.createLight(name)
-            
-        return light,  pos
-        
-    def addPointLight(self):
-        if self.currentMap is None:
-            print "No map selected!"
-            return
-            
-        lightName = "pointLight" + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-        light, pos = self.createLight(lightName)
-        printVector3(pos)
-        
-        if not light:
-            print "Error while creating light"
-            return
-            
-        light.setType(og.Light.LT_POINT)
-        
-        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
-        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
-        n.attachObject(light)
-        n.attachObject(e)
-        n.setPosition(pos)
-        self.moduleExplorer.updateView()
-        
-    def addSpotLight(self):
-        if self.currentMap is None:
-            print "No map selected!"
-            return
-            
-        lightName = "spotLight" + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-        light, pos = self.createLight(lightName)
-        printVector3(pos)
-        
-        if not light:
-            print "Error while creating light"
-            return
-            
-        light.setType(og.Light.LT_SPOTLIGHT)
-        
-        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
-        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
-        n.attachObject(light)
-        n.attachObject(e)
-        n.setPosition(pos)
-        self.moduleExplorer.updateView()
-        
-    def addZoneToMap(self, name):
-        self.zoneManager.createZone(name)
-        self.moduleExplorer.updateView()
-        
-    def setPlayerStart(self):
-        self.mainModule.playerStart = str(self.playerStartGameObjectId)
-        print "setting Player Start to " + str(self.playerStartGameObjectId)
-    
-    def onContextMenu(self, screenX, screenY, ray):
-        menus = []
-        actions = []
-        pla = self.createAction("Pointlight", self.addPointLight, None, "idea.png")
-        pls = self.createAction("Spotlight", self.addSpotLight, None, "idea.png")
-        
-        lightMenu = QMenu("Add Light")
-        lightMenu.addAction(pla)
-        lightMenu.addAction(pls)
-        menus.append(lightMenu)
-        
-        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        self.contextMenuClickPosition = og.Vector2(screenX, screenY)
-        self.contextMenuRay = ray
-        
-        pos = og.Vector3()
-        query = self.sceneManager.createRayQuery(self.contextMenuRay)
-        query.ray = self.contextMenuRay
-        query.setSortByDistance(True)
-        query.execute(self.raySceneQueryListener)
-        if self.raySceneQueryListener.dist < 100000:
-            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
-            self.raySceneQueryListener.dist = 100000
-        
-        if so is not None:
-            self.zoneManager.entityUnderMouse = so.entity
-        
-        self.zoneManager.newAreaPosition = pos
-        menus.append(self.zoneManager.getZoneMenu())
-
-        if so is not None and so.entity.getParentNode().getName().startswith("gameobject_"):
-            actions.append(self.createAction("Set Player Starterpoint", self.setPlayerStart))
-            self.playerStartGameObjectId = so.entity.getUserObject().inWorldId
-            
-                
-            
-        if self.onContextMenuCallback is not None:
-            self.onContextMenuCallback(actions,  menus)
-
-    def setContextMenuCallback(self, callback):
-        self.onContextMenuCallback = callback
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
-        action = QAction(text, None)
-        if icon is not None:
-            action.setIcon(QIcon("media/icons/%s" % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            QWidget.connect(action, SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import sys
+import codecs
+import glob
+import os
+from os.path import isfile,  join
+
+import xml.etree.cElementTree as xml
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from SelectionBuffer import *
+from DepthBuffer import *
+from MovePivot import *
+from GameObjectClassManager import *
+from MyRaySceneQueryListener import *
+from ZoneManager import ZoneManager
+
+
+# get the light out of a light node
+def extractLight(node):
+        i = 0
+        num = node.numAttachedObjects()
+        while i < node.numAttachedObjects():
+            c = node.getAttachedObject(i)
+            tp = str(type(c))
+            if tp == "<class 'ogre.renderer.OGRE._ogre_.Light'>":
+                return c
+            
+            i += 1
+
+# make the xml file more pretty
+def indent(elem, level=0):
+    i = "\n" + level*"  "
+    
+    if len(elem):
+        if not elem.text or not elem.text.strip():
+            elem.text = i + "  "
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+        for elem in elem:
+            indent(elem, level+1)
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+    else:
+        if level and (not elem.tail or not elem.tail.strip()):
+            elem.tail = i
+
+# creates unique names for new entities
+def createUniqueEntityName(sceneManager, name = None):
+    n = ""
+    if name is None:
+        n = "dropMesh" + str(ModuleManager.dropCount)
+    else:
+        n = name
+        
+    while sceneManager.hasEntity(n):
+        n = "dropMesh" + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+    return n
+        
+def printVector3(vec):
+    print str(vec.x) + ";" + str(vec.y) + ";" + str(vec.z)
+    
+class EntityCustomOptions(og.UserDefinedObject):
+    def __init__(self, receivesShadow = True, staticgeometrygroup = 0, physicsproxytype = "none", renderingdistance = "20000"):
+        og.UserDefinedObject.__init__(self)
+        self.receivesShadow = receivesShadow
+        self.staticgeometrygroup = staticgeometrygroup
+        self.physicsproxytype = physicsproxytype
+        self.renderingdistance = renderingdistance
+        self.materialName = "NotChanged"
+        
+        ModuleManager.entityCustomOptionsDict.append(self)
+        
+    def copy(self):
+            return EntityCustomOptions(self.receivesShadow, self.staticgeometrygroup, self.physicsproxytype, self.renderingdistance)
+        
+    def getType(self):
+            return "EntityCustomOptions"
+
+class Map():
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyMap = False):
+        self.pathToMapFile = pathToFile
+        
+        mapName = pathToFile.replace("\\", "/")
+        mapName = mapName.split("/")
+        mapName = mapName[len(mapName) - 1].split(".")
+        mapName = mapName[len(mapName) - 3]
+        self.mapName = mapName
+        self.mapFileName = self.mapName + ".rlmap.xml"
+        
+        self.sceneManager = sceneManager
+        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        self.zoneManager = zoneManager
+        self.isHidden = False
+        
+        self.zoneList = []
+        
+        if not emptyMap:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+
+            if root.attrib["formatVersion"] == "0.4.0":
+                self.parseMapNodes(root.find("nodes"))
+                self.parseMapZones(root.find("zones"))
+            else:
+                print pathToFile + " has wrong format version. It needs to be 0.4.0"
+                return
+
+    def hide(self):
+        try:
+            self.sceneManager.getRootSceneNode().removeChild(self.mapNode)
+        except:
+            print "Error: map is already hidden!"
+            return
+        
+        self.isHidden = True
+        
+    def show(self):
+        try:
+            self.sceneManager.getRootSceneNode().addChild(self.mapNode)
+        except:
+            print "Error: map is already shown!"
+            return
+        
+        self.isHidden = False
+    
+    def parseMapZones(self, zonesElement):
+        self.zoneManager.parseZonesFromXml(zonesElement, self)
+    
+    def parseMapNodes(self, nodeElement):
+        nodes = nodeElement.getiterator("gameobject")
+        self.createGameObjects(nodes)
+        
+        nodes = nodeElement.getiterator("entity")
+        self.createEntites(nodes)
+
+        nodes = nodeElement.getiterator("light")
+        self.createLights(nodes)
+
+        nodes = nodeElement.getiterator("sound")
+        self.createSound(nodes)
+
+        nodes = nodeElement.getiterator("particlesystem")
+        self.createParticleSystems(nodes)
+
+    def createEntites(self, entityNodes):
+        for nodes in entityNodes:
+            entityName = nodes.attrib["name"]
+            
+            if entityName.startswith("dropMesh"):
+                num = int(entityName.replace("dropMesh",  ""))
+                if ModuleManager.dropCount < num:
+                    ModuleManager.dropCount = num
+                elif ModuleManager.dropCount < num:
+                    ModuleManager.dropCount = num + 1
+                    
+            meshFile = nodes.attrib["meshfile"]
+            
+            eco = EntityCustomOptions()
+            
+            try:
+                if nodes.attrib["receivesShadow"] == "False" or nodes.attrib["receivesShadow"] == "false":
+                    eco.receivesShadow = "False"
+            except:
+                pass
+            try:
+                eco.staticgeometrygroup = int(nodes.attrib["staticgeometrygroup"])
+            except:
+                pass
+            try:
+                eco.physicsproxy = nodes.attrib["physicsproxy"]
+            except:
+                pass
+            try:
+                eco.renderingdistance = float(nodes.attrib["renderingdistance"])
+            except:
+                pass
+            try:
+                eco.renderingdistance
+                nodes.attrib["materialName"]
+            except:
+                pass
+                
+            nodePosition = None
+            nodeScale = None
+            qw = qx = qy = qz = None
+
+            transformations = nodes.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    posx = float(t.attrib["x"])
+                    posy = float(t.attrib["y"])
+                    posz = float(t.attrib["z"])
+                    nodePosition = og.Vector3(posx, posy, posz)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                elif t.tag == "scale":
+                    scalex = float(t.attrib["x"])
+                    scaley = float(t.attrib["y"])
+                    scalez = float(t.attrib["z"])
+                    nodeScale = og.Vector3(scalex, scaley, scalez)
+
+            try:
+                e = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager,  entityName), meshFile)
+            except:
+                print "Warning: Meshfile " + meshFile + " could not be found."
+                return
+
+            e.setUserObject(eco)
+            n = self.mapNode.createChild("entity_" + entityName + "_node")
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            n.setOrientation(qw, qx, qy, qz)
+            n.setScale(nodeScale)
+
+    def createLights(self, lightNodes):
+        for l in lightNodes:
+            lightName = l.attrib["name"]
+            lightType = l.attrib["type"]
+            lightVisible = bool(l.attrib["visible"])
+            castShadows = bool(l.attrib["castShadows"])
+            lightPosition = None
+            lightDirection = None
+            colourDiffuse = None
+            colourSpecular = None
+            lightAttenuationRange = None
+            lightAttenuationConstant= None
+            lightAttenuationLinear = None
+            lightAttenuationQuadratic = None
+            spotlightinner = None
+            spotlightouter = None
+            falloff = None 
+                
+            transformations = l.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    lightPosition = og.Vector3(x, y, z)
+                elif t.tag == "colourDiffuse":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourDiffuse = og.ColourValue(r, g, b)
+                elif t.tag == "colourSpecular":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourSpecular = og.ColourValue(r, g, b)
+                elif t.tag == "lightAttenuation":
+                    lightAttenuationRange = float(t.attrib["range"])
+                    lightAttenuationConstant= float(t.attrib["constant"])
+                    lightAttenuationLinear = float(t.attrib["linear"])
+                    lightAttenuationQuadric  = float(t.attrib["quadratic"])
+                elif t.tag == "spotlightrange":
+                    spotlightinner = float(t.attrib["inner"])
+                    spotlightouter = float(t.attrib["outer"])
+                    falloff = float(t.attrib["falloff"])
+                    
+            light = self.sceneManager.createLight(lightName)
+            
+            if lightType == "point":
+                light.setType(og.Light.LT_POINT)            
+            elif lightType == "spot":
+                light.setType(og.Light.LT_SPOTLIGHT)
+            elif lightType == "directional":
+                light.setType(og.Light.LT_DIRECTIONAL)
+            
+            light.setVisible(lightVisible)
+            light.setCastShadows(castShadows)
+            if lightAttenuationRange is not None and lightAttenuationConstant is not None and lightAttenuationLinear is not None and lightAttenuationQuadric is not None:
+                light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadric)
+            if colourDiffuse:
+                light.setDiffuseColour(colourDiffuse)
+            if colourSpecular:
+                light.setSpecularColour(colourSpecular)
+            if spotlightinner and spotlightouter and spotlightouter: 
+                light.setSpotlightRange(spotlightinner, spotlightouter, falloff)
+            
+            e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+            n = self.mapNode.createChild("light_" + lightName + "_node")
+            n.attachObject(light)
+            n.attachObject(e)
+            if lightPosition:
+                n.setPosition(lightPosition)
+            
+    def createSound(self, soundNodes):
+        #raise NotImplementedError
+        return
+
+    def createGameObjects(self, gameObjectNodes):
+        for g in gameObjectNodes:
+            classid = g.attrib["class"]
+            
+            id = int(g.attrib["id"])
+            if ModuleManager.dropCount < id:
+                ModuleManager.dropCount = id
+            elif ModuleManager.dropCount < id:
+                ModuleManager.dropCount = id + 1
+                
+            state = g.attrib["state"]
+            nodePosition = None
+            nodeRotation = None
+
+            transformations = g.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+
+            go = self.gocManager.getGameObjectWithClassId(classid)
+            if go is not None:
+                meshFile = go.getMeshFileName()
+                
+                ent = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+                dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
+                dropNode.attachObject(ent)
+
+                if nodePosition:
+                    dropNode.setPosition(nodePosition)
+                if nodeRotation:
+                    dropNode.setOrientation(nodeRotation)
+
+                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
+                self.gocManager.addGameObjectRepresentation(go)
+                go.inWorldId = id
+                go.state = state
+                ent.setUserObject(go)
+
+
+    def createParticleSystems(self, particleNodes):
+        #raise NotImplementedError
+        return
+        
+    def save(self):
+        root = xml.Element("rastullahmap")
+        root.attrib["formatVersion"] = "0.4.0"
+        
+        nodesElem = xml.SubElement(root, "nodes")
+        
+        i = 0
+        while i < self.mapNode.numChildren():
+            n = self.mapNode.getChild(i)
+            if n.numAttachedObjects() > 0:
+                if n.name.startswith("entity_"):
+                    entElem = xml.SubElement(nodesElem, "entity")
+                    entElem.attrib["name"] = n.getAttachedObject(0).getName()
+                    entName = n.getAttachedObject(0).getName()
+                    print "Saving Entity: " + n.getAttachedObject(0).getName()
+                    entElem.attrib["meshfile"] = n.getAttachedObject(0).getMesh().getName()
+   
+                    entElem.attrib["receivesShadow"] = str(n.getAttachedObject(0).getUserObject().receivesShadow).lower()
+                    entElem.attrib["staticgeometrygroup"] = str(n.getAttachedObject(0).getUserObject().staticgeometrygroup)
+                    entElem.attrib["physicsproxytype"] = str(n.getAttachedObject(0).getUserObject().physicsproxytype)
+                    entElem.attrib["renderingdistance"] = str(n.getAttachedObject(0).getUserObject().renderingdistance)
+                    
+                    posElem = xml.SubElement(entElem, "position")
+                    posElem.attrib["x"] = str(n.getPosition().x)
+                    posElem.attrib["y"] = str(n.getPosition().y)
+                    posElem.attrib["z"] = str(n.getPosition().z)
+                    
+                    rotElem = xml.SubElement(entElem, "rotation")
+                    rotElem.attrib["qw"] = str(n.getOrientation().w)
+                    rotElem.attrib["qx"] = str(n.getOrientation().x)
+                    rotElem.attrib["qy"] = str(n.getOrientation().y)
+                    rotElem.attrib["qz"] = str(n.getOrientation().z)
+                    
+                    scaleElem = xml.SubElement(entElem, "scale")
+                    scaleElem.attrib["x"] = str(n.getScale().x)
+                    scaleElem.attrib["y"] = str(n.getScale().y)
+                    scaleElem.attrib["z"] = str(n.getScale().z)
+                    
+                elif n.name.startswith("gameobject_"):
+                    goElem = xml.SubElement(nodesElem, "gameobject")
+                    mname = n.name
+                    print "Saving GOID: " + str(n.getAttachedObject(0).getUserObject().inWorldId)
+                    goElem.attrib["class"] = str(n.getAttachedObject(0).getUserObject().gocName)
+                    goElem.attrib["state"] = str(n.getAttachedObject(0).getUserObject().state)
+                    goElem.attrib["id"] = str(n.getAttachedObject(0).getUserObject().inWorldId)
+                    
+                    posElem = xml.SubElement(goElem, "position")
+                    posElem.attrib["x"] = str(n.getPosition().x)
+                    posElem.attrib["y"] = str(n.getPosition().y)
+                    posElem.attrib["z"] = str(n.getPosition().z)
+                    
+                    rotElem = xml.SubElement(goElem, "rotation")
+                    rotElem.attrib["qw"] = str(n.getOrientation().w)
+                    rotElem.attrib["qx"] = str(n.getOrientation().x)
+                    rotElem.attrib["qy"] = str(n.getOrientation().y)
+                    rotElem.attrib["qz"] = str(n.getOrientation().z)
+                    
+                elif n.name.startswith("light_"):
+                    light = extractLight(n)
+                    lightName = light.getName()
+                    print "Saving Light: " + lightName
+                    lightType = light.getType()
+                    isVisible = "true"
+                    if not light.getVisible():
+                        isVisible = "false"
+                    
+                    castShadows = "false"
+                    if light.getCastShadows():
+                        castShadows = "true"
+                    
+                    if lightType == og.Light.LT_POINT:
+                        lightType = "point"
+                    elif lightType == og.Light.LT_SPOTLIGHT:
+                        lightType = "spot"
+                    elif lightType == og.Light.LT_DIRECTIONAL:
+                        lightType = "directional"
+                    
+                    
+                    lightElem = xml.SubElement(nodesElem, "light")
+                    lightElem.attrib["name"] = lightName
+                    lightElem.attrib["type"] = lightType
+                    lightElem.attrib["visible"] = isVisible
+                    lightElem.attrib["castShadows"] = castShadows
+                    
+                    if lightType == "point" or lightType == "spot":
+                        posElem = xml.SubElement(lightElem, "position")
+                        posElem.attrib["x"] = str(n.getPosition().x)
+                        posElem.attrib["y"] = str(n.getPosition().y)
+                        posElem.attrib["z"] = str(n.getPosition().z)
+                    
+                    colDiffuseElem = xml.SubElement(lightElem, "colourDiffuse")
+                    colDiffuseElem.attrib["r"] = str(light.getDiffuseColour().r)
+                    colDiffuseElem.attrib["g"] = str(light.getDiffuseColour().g)
+                    colDiffuseElem.attrib["b"] = str(light.getDiffuseColour().b)
+
+                    colSpecularElem = xml.SubElement(lightElem, "colourSpecular")
+                    colSpecularElem.attrib["r"] = str(light.getSpecularColour().r)
+                    colSpecularElem.attrib["g"] = str(light.getSpecularColour().g)
+                    colSpecularElem.attrib["b"] = str(light.getSpecularColour().b)
+                    
+                    lightAttenuationElem = xml.SubElement(lightElem, "lightAttenuation")
+                    lightAttenuationElem.attrib["range"] = str(light.getAttenuationRange())
+                    lightAttenuationElem.attrib["constant"] = str(light.getAttenuationConstant())
+                    lightAttenuationElem.attrib["linear"] = str(light.getAttenuationLinear())
+                    lightAttenuationElem.attrib["quadratic"] = str(light.getAttenuationQuadric())
+                    
+                    if lightType == "spot":
+                        spotligthRangeElem = xml.SubElement(lightElem, "spotlightrange")
+                        spotligthRangeElem.attrib["inner"] = str(light.getSpotlightInnerAngle().valueDegrees())
+                        spotligthRangeElem.attrib["outer"] = str(light.getSpotlightOuterAngle().valueDegrees())
+                        spotligthRangeElem.attrib["falloff"] = str(light.getSpotlightFalloff())
+                        
+                    if lightType == "spot" or lightType == "directional":
+                        directionElem = xml.SubElement(lightElem, "direction")
+                        dir = og.Vector3()
+                        n.getOrientation().ToAxes(dir)
+                        directionElem.attrib["x"] = str(dir.x)
+                        directionElem.attrib["y"] = str(dir.y)
+                        directionElem.attrib["z"] = str(dir.z)
+                        
+            i = i+1
+            
+        self.zoneManager.saveZonesToXml(root, self)
+        indent(root)
+        xml.ElementTree(root).write(self.pathToMapFile)
+
+# caused a linux crash
+#        iter = self.mapNode.getChildIterator()
+#        while iter.hasMoreElements():
+#            name = iter.getNext().getName()
+#            print name
+
+class Scene():
+    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyScene = False, sceneName = "NewScene"):
+        self.moduleRoot = moduleroot
+        self.pathToFile = pathToFile
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        self.zoneManager = zoneManager
+        self.mapFiles = [] # a list in case the module has more than one map file
+        mappaths = []
+        self.name = sceneName
+
+        
+        if not emptyScene:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+            self.name = root.attrib["name"]
+        
+            maps = root.getiterator("map")
+            for m in maps:
+                mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
+                
+            for m in mappaths:
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
+            
+    def addMap(self, name):
+        path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
+        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True))
+        
+    def save(self):
+        root = xml.Element("scene")
+        root.attrib["name"] = self.name
+        
+        for m in self.mapFiles:
+            sub = xml.SubElement(root, "map")
+            sub.attrib["file"] = m.mapFileName
+            m.save()
+
+        indent(root)
+        xml.ElementTree(root).write(self.pathToFile)
+
+class Module():
+    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager, zoneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gameObjectManager
+        self.zoneManager = zoneManager
+        
+        self.name = name
+        self.moduleRoot = join(modulePath, name)
+        self.__isCommon = False
+
+        self.hasDependencies = False
+        self.moduleDependencies = []
+
+        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+
+        self.gofFiles = [] # gof File list
+
+        self.scenes =[]
+
+        self.isLoaded = False
+        
+        self.playerStart = None
+        
+    def addScene(self, name):
+        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True, name))
+    
+    def addMapToScene(self, sceneName, mapName):
+        for scene in self.scenes:
+            if scene.name == sceneName:
+                scene.addMap(mapName)
+                return
+        
+        print "ERROR: could not find scene: " + sceneName
+        
+    
+    def isCommon(self):
+        if isfile(self.modConfig): # is the modconfig existing?
+            f = codecs.open(self.modConfig, 'r', 'utf-8')
+        else:
+            print ("Module.isCommon() Error: couldn't find module config")
+            return
+        isDependencieLine = False
+        for i, line in enumerate(f):
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith("super("):
+                split = lStripped.split(",")
+                if split[2].strip() == unicode("true"):
+                    self.__isCommon = True
+                    return True
+
+
+            elif isDependencieLine:
+                if lStripped == "end":
+                    isDependencieLine = False
+                else:
+                    self.hasDependencies = True
+                    pl = lStripped.split('"')
+                    i = 1
+                    while i < 100: 
+                        try:
+                            self.moduleDependencies.append(pl[i])
+                            i += 2
+                        except IndexError, e:
+                            break
+
+            elif lStripped == "def getDependencies()":
+                isDependencieLine = True
+
+        return False
+
+    def load(self):
+        if self.isLoaded:
+            return
+        
+        self.isLoaded = True
+        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+        if isfile(self.modConfig): # is the modconfig existing?
+            f = codecs.open(self.modConfig, 'r', 'utf-8')
+        else:
+            print ("Module.load: Error: couldn't find module config")
+            return
+
+        for line in f:
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith("hero = $GOM.getGameObject("):
+                try:
+                    self.playerStart = int(line.split("(")[1].split(")")[0])
+                except ValueError, e:
+                    print self.modConfig + " ValueError: " + str(e)
+                    self.playerStart = None
+                    continue
+                    
+        self.setResourcePaths()
+        
+        try:
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+        except og.OgreException, e:
+            print e
+        
+        
+        cmd = join(self.moduleRoot, "dsa/*.gof")
+        self.gofFiles = glob.glob(cmd)
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
+        if not self.isCommon():
+            cmd = join(self.moduleRoot, "maps/*.rlscene")
+            sceneFile = glob.glob(cmd)
+            self.loadScenes(sceneFile)
+                
+    def loadScenes(self, sceneFiles):
+        for s in sceneFiles:
+            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
+
+    def save(self):
+        for s in self.scenes:
+            s.save()
+            
+        self.saveModuleConfig()
+
+    def saveModuleConfig(self):
+        if self.playerStart is not None:
+            f = open(self.modConfig, "r")
+            
+            newconfig = ""
+            for line in f:
+                if line.startswith("       hero = $GOM.getGameObject("):
+                    newconfig += "       hero = $GOM.getGameObject(" + str(self.playerStart) + ");\n"
+                else:
+                    newconfig += line
+            f.close()
+            
+            f = open(self.modConfig, "w")
+            f.write(newconfig)
+            f.close()
+
+    def setResourcePaths(self, recurseFolder = ""):
+        if recurseFolder == "":
+            rootFolder = self.moduleRoot
+        else:
+            rootFolder = join(self.moduleRoot, recurseFolder)
+
+        for file in os.listdir(rootFolder):
+            curFile = join(rootFolder, file)
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            elif os.path.isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
+                self.setResourcePaths(curFile)
+            elif os.path.isfile(curFile):
+                continue
+                
+    def getMap(self, mapName, sceneName = None):
+        if sceneName is not None:
+            for s in self.scenes:
+                if s.name == sceneName:
+                    for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+        else:
+            for s in self.scenes:
+                for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+
+class ProgressBarThread(QThread):
+    def __init__(self, min, max, moduleName):
+        QThread.__init__(self)
+        self.progress = QProgressDialog("Loading " + moduleName, "Abort Loading", min, max, None);
+        self.progress.setWindowModality(Qt.WindowModal)
+
+    def setProgress(self, progress, labelText):
+        self.progress.setLabelText(labelText)
+        self.progress.setValue(progress)
+        
+    def run(self):
+        self.progress.show()
+        self.exec_()
+
+        
+class ModuleManager():
+    dropCount = 0
+    entityCustomOptionsDict = []
+    
+    def __init__(self,  ogreRoot,  sceneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.modelSelectionDialog = None
+        self.materialSelectionDialog = None
+
+        self.moduleCfgPath = ""
+
+        self.gocManager = GameObjectClassManager()
+        
+
+        self.mainModule = None
+        self.mainModuledependencieList =[]
+        self.moduleList = []
+        self.userSelectionList = []
+        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
+        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
+        self.currentMap = None
+        self.moduleExplorer = None
+
+        self.lastRay = None
+        self.rayLine = None
+
+        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.dropNode = None
+        self.dropEntity = None
+        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
+        self.dropMat = None
+        
+        self.moduleConfigIsParsed = False
+
+        self.selectionBuffer = None
+        self.depthBuffer = None
+        self.propertyWindow = None
+    
+        self.oneClickEntityPlacement = False
+        
+        self.onContextMenuCallback = None
+        self.contextMenuClickPosition = None
+        self.contextMenuRay = None
+        
+        self.playerStartGameObjectId = None
+        
+        self.entityCustomOptionsDict = []
+        
+        self.raySceneQueryListener = MyRaySceneQueryListener()
+        
+        self.zoneManager = ZoneManager(self.sceneManager)
+        
+    def resetParsedModuleConfig(self):
+        self.moduleConfigIsParsed = False
+        self.moduleList = []
+
+    def parseModuleConfig(self):
+        if self.moduleConfigIsParsed:
+            return
+
+        import codecs
+        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
+
+        for line in f:
+            if line.startswith('#'):
+                continue
+
+            if line.startswith('module='):
+                splines = line.split('=')
+                str = splines[1].rstrip().rstrip()
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
+
+        self.moduleConfigIsParsed = True
+
+    def moduleExists(self, name):
+        lowerA = str(name).lower()
+        
+        for m in self.moduleList:
+            lowerB = m.name.lower()
+            if lowerA == lowerB:
+                return True
+        
+        return False
+
+    def openLoadModuleDialog(self):
+        self.moduleFolder = str(self.moduleCfgPath.replace("modules.cfg", ""))
+
+        self.parseModuleConfig()
+
+        dlg = QDialog(QApplication.focusWidget())
+        list = QListWidget()
+        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
+        dlg.connect(btnBox, SIGNAL("rejected()"), dlg.reject)
+
+        for m in self.moduleList:
+            if not m.isCommon():
+                list.addItem(m.name)
+
+        layout = QVBoxLayout()
+        layout.addWidget(list)
+        layout.addWidget(btnBox)
+        dlg.setLayout(layout)
+        if dlg.exec_():
+            self.loadModule(str(list.currentItem().text()))
+
+    # I'm sorry for this
+    def loadModule(self, moduleName):
+        t = og.Timer()
+        
+#        self.progress = ProgressBarThread(0, 8, moduleName)
+#        self.progress.start()
+        
+        for m in self.moduleList:
+            if m.name == moduleName:
+                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
+                    for moduleDependencie in m.moduleDependencies:
+                        for m2 in self.moduleList:
+                            if m2.name == moduleDependencie:
+#                                self.progress.setProgress(2, "Loading Dependencie: " + moduleDependencie)
+                                m2.load()
+                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
+                                self.materialSelectionDialog.scanDirForMaterials(m2.moduleRoot)
+                                self.mainModuledependencieList.append(m2)
+
+#                self.progress.setProgress(4, "Loading " + moduleName)
+                m.load()
+#                self.progress.setProgress(6, "Scan for models...")
+                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
+#                self.progress.setProgress(8, "Scan for materials")
+                self.materialSelectionDialog.scanDirForMaterials(m.moduleRoot)
+                self.mainModule = m
+                self.moduleExplorer.setCurrentModule(m)
+
+        if self.selectionBuffer is None:
+            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"), self, self.zoneManager)
+
+#        if self.depthBuffer is None:
+#            self.depthBuffer = DepthBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
+
+
+#        self.progress.quit()
+        print "Time to load module: " + str(t.getMilliseconds() / 1000.0) + " seconds"
+        del t
+
+    def addSceneToModule(self, name):
+        if self.mainModule is not None:
+            self.mainModule.addScene(name)
+
+    def addMapToScene(self, sceneName, mapName):
+        if self.mainModule is not None:
+            self.mainModule.addMapToScene(sceneName, mapName)
+
+    def setModuleExplorer(self, moduleExplorer):
+        self.moduleExplorer = moduleExplorer
+        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
+        self.moduleExplorer.setSelectionChangedCallback(self.selectionChangedCallback)
+        self.moduleExplorer.setModuleManager(self)
+    
+    def setPropertyWindow(self, propertyWin):
+        self.propertyWindow = propertyWin
+    
+    def selectionChangedCallback(self, items):
+        self.resetSelection()
+        self.userSelectionList = self.selectionBuffer.manualSelectObjects(items)
+        self.updatePivots()
+        
+    def selectMapCallback(self, sceneName, mapName):
+        self.currentMap = self.mainModule.getMap(mapName, sceneName)
+        self.zoneManager.currentMap = self.currentMap
+        if self.currentMap is None:
+            print "Don't forget to select a map"
+
+        
+    # called when a click into Main Ogre Window occurs
+    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
+        if self.oneClickEntityPlacement:
+            if self.modelSelectionDialog.listWidget.currentItem() is not None:
+                meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
+                self.startDropModelAction(meshFile, ray)
+                self.moduleExplorer.updateView()
+                return
+            else:
+                print "Warning: OneClickEntityPlacement still runing on without any selected mesh!"
+                return
+                
+        #self.depthBuffer.onSelectionClick(screenX, screenY)
+        
+        so = None
+        if self.selectionBuffer is not None:
+            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        
+        if so is not None:
+            if not so.isPivot:                
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.propertyWindow.showProperties(so)
+                    self.moduleExplorer.deselectAll()
+                    self.moduleExplorer.selectItem(so, True)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+
+                    for soFromList in self.userSelectionList:
+                        if soFromList == so:
+                            return # object already selected
+
+                    self.userSelectionList.append(so)
+                    self.propertyWindow.showProperties(so)
+                    self.moduleExplorer.selectItem(so, True)
+                    self.updatePivots()
+
+
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so == selo:
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                            self.moduleExplorer.selectItem(selo, False)
+                    self.updatePivots()
+                
+            else:
+                #so.entity is the pivot direction that was clicked
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            self.resetSelection() # click in empty space, deselect everything
+            self.moduleExplorer.selectItems(None)
+            self.propertyWindow.clear()
+            if self.pivot is not None:
+                self.pivot.hide()
+
+#        if self.rayLine == None:
+#            self.rayLine = self.sceneManager.createManualObject("rayLine")
+#            self.rayLine.setDynamic(True)
+#            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
+#
+#            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+#
+#        else:
+#            self.rayLine.beginUpdate(0)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+
+    def deleteObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.pivot.hide()
+
+        for so in self.userSelectionList:
+            node = so.entity.getParentNode()
+            if node.getName().startswith("area_"):
+                self.zoneManager.deleteArea(so.entity.getUserObject())
+                continue
+            elif node.getName().startswith("light_"):
+                light = extractLight(node)
+                self.sceneManager.destroyLight(light)
+                
+            node.detachAllObjects()
+            self.sceneManager.destroySceneNode(node)
+            self.sceneManager.destroyEntity(so.entity)
+            del so
+        
+        self.userSelectionList = []
+        self.moduleExplorer.updateView()
+        
+    def copyObjects(self):
+        if len(self.userSelectionList) < 1 or self.currentMap is None:
+            print "Warning: No map selected!"
+            return
+
+        self.newSelectionList = []
+
+        for so in self.userSelectionList:
+            if so.entity.getUserObject() is not None:
+                if str(so.entity.getParentNode().getName()).startswith("gameobject_"):
+                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
+                    meshFile = go.getMeshFileName()
+
+                    if go is not None:
+                        newEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+                        newNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
+                        newNode.attachObject(newEntity)
+                        newNode.setPosition(so.entity.getParentNode().getPosition())
+
+                        newGO = GameObjectRepresentation(ModuleManager.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
+                        self.gocManager.addGameObjectRepresentation(newGO)
+                        newEntity.setUserObject(newGO)
+
+                        newSO = SelectionObject(newEntity)
+                        newSO.setSelected(True)
+                        self.newSelectionList.append(newSO)
+                        ModuleManager.dropCount += 1
+                elif str(so.entity.getParentNode().getName()).startswith("entity_"):
+                    nodeName = "entity_dropNode" + str(ModuleManager.dropCount)
+                    newNode = self.currentMap.mapNode.createChild(nodeName)
+
+                    entityName = createUniqueEntityName(self.sceneManager)
+                    newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+
+                    eco = so.entity.getUserObject().copy()
+                    newEntity.setUserObject(eco)
+
+                    newNode.attachObject(newEntity)
+                    newNode.setPosition(so.entity.getParentNode().getPosition())
+                    newNode.setOrientation(so.entity.getParentNode().getOrientation())
+                    newNode.setScale(so.entity.getParentNode().getScale())
+
+                    newSO = SelectionObject(newEntity)
+                    newSO.setSelected(True)
+                    self.newSelectionList.append(newSO)
+                    ModuleManager.dropCount += 1
+                elif str(so.entity.getParentNode().getName()).startswith("light_"):
+                    print "Can't copy lights yet :)"
+
+        self.resetSelection()
+        self.userSelectionList = self.newSelectionList
+        self.moduleExplorer.updateView()
+        for so in self.userSelectionList:
+            self.moduleExplorer.selectItem(so, True)
+        self.updatePivots()
+
+        
+    def cutObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.cutList = []
+        for so in self.userSelectionList:
+            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
+            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
+            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
+            # so we only have to translate them to their new destination when they get pasted
+            # the position of the pivot point is considered as the center of gravity
+            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
+            self.cutList.append(so)
+        self.resetSelection()
+        self.moduleExplorer.updateView()
+        
+    def pasteObjects(self,  ray):
+        if len(self.cutList) < 1:
+            return
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
+                i = i+1
+        else:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
+                i = i+1
+        self.cutList = []
+        self.moduleExplorer.updateView()
+        
+    def leftMouseUp(self):
+        if self.pivot is not None and self.pivot.isTransforming:
+            self.propertyWindow.updateProperties()
+            self.pivot.stopTransforming()
+
+    def resetSelection(self):
+        if self.userSelectionList is not None:
+            for so in self.userSelectionList:
+                so.setSelected(False)
+
+        self.userSelectionList = []
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+        if self.pivot is not None and len(self.userSelectionList) > 0:
+            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
+    def unload(self,  saveOnUnload=True):
+        pass
+
+    def save(self):
+        self.mainModule.save()
+
+    def startDropGameObjectAction(self, classid, ray):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        go = self.gocManager.getGameObjectWithClassId(classid)
+
+        if go is not None:
+            meshFile = go.getMeshFileName()
+            dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
+            dropNode.attachObject(dropEntity)
+
+            result = og.Math.intersects(ray, self.dropCollisionPlane)
+            if result.first == True:
+                dropNode.setPosition(ray.getPoint(result.second))
+            else:
+                dropNode.setPosition(ray.getPoint(50))
+
+            self.dropGO = GameObjectRepresentation(ModuleManager.dropCount, classid, dropNode, meshFile)
+            self.gocManager.addGameObjectRepresentation(self.dropGO)
+            dropEntity.setUserObject(self.dropGO)
+
+        ModuleManager.dropCount += 1
+
+    def moveDropGameObjectAction(self, ray):
+        if self.currentMap is None:
+            return
+        
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropGO.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropGO.setPosition(ray.getPoint(50))
+
+    def finishDropGameObjectAction(self, ray):
+        self.moduleExplorer.updateView()
+        self.dropGO = None
+        return
+
+    def startDropModelAction(self, meshFile, ray):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        self.dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), meshFile)
+        
+        eco = EntityCustomOptions()
+        self.dropEntity.setUserObject(eco)
+        
+        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(ModuleManager.dropCount))
+        self.dropNode.attachObject(self.dropEntity)
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+        ModuleManager.dropCount += 1
+
+    def moveDropModelAction(self, ray):
+        if self.currentMap is None:
+            return
+            
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+    
+    def finishDropModelAction(self, ray):
+        self.moduleExplorer.updateView()
+        return
+
+    def startDropMaterialAction(self, text):
+        self.dropMat = text
+        
+    def moveDropMaterialAction(self, event):
+        return
+
+    def finishDropMaterialAction(self, screenX, screenY):
+        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        if so is not None:
+            if not so.entity.getNumSubEntities() > 1:
+                so.entity.setMaterialName(self.dropMat)
+                so.entity.getUserObject().materialName = self.dropMat
+            else:
+                i = 0
+                text = "Warning this Entity has more than one SubEntities with the folloing materials: \n\n"
+                while i < so.entity.getNumSubEntities():
+                    text += "SubMesh" + str(i) + ":  " + so.entity.getSubEntity(i).getMaterialName() + "\n"
+                    i += 1
+                
+                text += "\n Replace the materials?"
+                reply = QMessageBox.question(None, "Warning: multiple materials",  text,  QMessageBox.Yes|QMessageBox.No)
+                if reply == QMessageBox.Cancel:
+                    return
+                if reply == QMessageBox.Yes:
+                    so.entity.setMaterialName(self.dropMat)
+                    so.entity.getUserObject().materialName = self.dropMat
+        
+    def setOneClickEntityPlacement(self, state):
+        self.oneClickEntityPlacement = state
+    
+    def createLight(self, name):
+        pos = og.Vector3()
+        
+        query = self.sceneManager.createRayQuery(self.contextMenuRay)
+        query.ray = self.contextMenuRay
+        query.setSortByDistance(True)
+        query.execute(self.raySceneQueryListener)
+        if self.raySceneQueryListener.dist < 100000:
+            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
+            self.raySceneQueryListener.dist = 100000
+            
+        light = None
+        if not self.sceneManager.hasLight(name):
+            light = self.sceneManager.createLight(name)
+            
+        return light,  pos
+        
+    def addPointLight(self):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        lightName = "pointLight" + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+        light, pos = self.createLight(lightName)
+        printVector3(pos)
+        
+        if not light:
+            print "Error while creating light"
+            return
+            
+        light.setType(og.Light.LT_POINT)
+        
+        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
+        n.attachObject(light)
+        n.attachObject(e)
+        n.setPosition(pos)
+        self.moduleExplorer.updateView()
+        
+    def addSpotLight(self):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        lightName = "spotLight" + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+        light, pos = self.createLight(lightName)
+        printVector3(pos)
+        
+        if not light:
+            print "Error while creating light"
+            return
+            
+        light.setType(og.Light.LT_SPOTLIGHT)
+        
+        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
+        n.attachObject(light)
+        n.attachObject(e)
+        n.setPosition(pos)
+        self.moduleExplorer.updateView()
+        
+    def addZoneToMap(self, name):
+        self.zoneManager.createZone(name)
+        self.moduleExplorer.updateView()
+        
+    def setPlayerStart(self):
+        self.mainModule.playerStart = str(self.playerStartGameObjectId)
+        print "setting Player Start to " + str(self.playerStartGameObjectId)
+    
+    def onContextMenu(self, screenX, screenY, ray):
+        menus = []
+        actions = []
+        pla = self.createAction("Pointlight", self.addPointLight, None, "idea.png")
+        pls = self.createAction("Spotlight", self.addSpotLight, None, "idea.png")
+        
+        lightMenu = QMenu("Add Light")
+        lightMenu.addAction(pla)
+        lightMenu.addAction(pls)
+        menus.append(lightMenu)
+        
+        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        self.contextMenuClickPosition = og.Vector2(screenX, screenY)
+        self.contextMenuRay = ray
+        
+        pos = og.Vector3()
+        query = self.sceneManager.createRayQuery(self.contextMenuRay)
+        query.ray = self.contextMenuRay
+        query.setSortByDistance(True)
+        query.execute(self.raySceneQueryListener)
+        if self.raySceneQueryListener.dist < 100000:
+            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
+            self.raySceneQueryListener.dist = 100000
+        
+        if so is not None:
+            self.zoneManager.entityUnderMouse = so.entity
+        
+        self.zoneManager.newAreaPosition = pos
+        menus.append(self.zoneManager.getZoneMenu())
+
+        if so is not None and so.entity.getParentNode().getName().startswith("gameobject_"):
+            actions.append(self.createAction("Set Player Starterpoint", self.setPlayerStart))
+            self.playerStartGameObjectId = so.entity.getUserObject().inWorldId
+            
+                
+            
+        if self.onContextMenuCallback is not None:
+            self.onContextMenuCallback(actions,  menus)
+
+    def setContextMenuCallback(self, callback):
+        self.onContextMenuCallback = callback
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QAction(text, None)
+        if icon is not None:
+            action.setIcon(QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            QWidget.connect(action, SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action



From alassion at mail.berlios.de  Sun Apr  5 11:39:43 2009
From: alassion at mail.berlios.de (alassion at mail.berlios.de)
Date: Sun, 5 Apr 2009 11:39:43 +0200
Subject: [Dsa-hl-svn] r4886 - in modules/common: materials materials/model
	models
Message-ID: <200904050939.n359dhau032705@sheep.berlios.de>

Author: alassion
Date: 2009-04-05 11:39:03 +0200 (Sun, 05 Apr 2009)
New Revision: 4886

Added:
   modules/common/materials/fass.material
   modules/common/materials/model/fass_kanalisation.png
   modules/common/materials/model/fass_kanalisation_normal.png
   modules/common/materials/model/fass_kanalisation_specularity.png
   modules/common/models/fass_stehend.mesh
Log:
- added fass_stehend.mesh and materials

Added: modules/common/materials/fass.material
===================================================================
--- modules/common/materials/fass.material	2009-04-05 08:27:45 UTC (rev 4885)
+++ modules/common/materials/fass.material	2009-04-05 09:39:03 UTC (rev 4886)
@@ -0,0 +1,7 @@
+import Basic_Normalmapping_kana from Normalmapping.program
+
+material fass_stehend/SOLID/TEX/fass_kanalisation.png : Basic_Normalmapping_kana
+{
+set_texture_alias DiffuseMap fass_kanalisation.png
+set_texture_alias NormalMap fass_kanalisation_normal.png
+}

Added: modules/common/materials/model/fass_kanalisation.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/fass_kanalisation.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/fass_kanalisation_normal.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/fass_kanalisation_normal.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/materials/model/fass_kanalisation_specularity.png
===================================================================
(Binary files differ)


Property changes on: modules/common/materials/model/fass_kanalisation_specularity.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/common/models/fass_stehend.mesh
===================================================================
(Binary files differ)


Property changes on: modules/common/models/fass_stehend.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From melven at mail.berlios.de  Mon Apr  6 15:04:07 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 6 Apr 2009 15:04:07 +0200
Subject: [Dsa-hl-svn] r4887 - in dependencies/OgreNewt: inc src
Message-ID: <200904061304.n36D47rK014432@sheep.berlios.de>

Author: melven
Date: 2009-04-06 15:04:06 +0200 (Mon, 06 Apr 2009)
New Revision: 4887

Modified:
   dependencies/OgreNewt/inc/OgreNewt_CollisionPrimitives.h
   dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp
Log:
-added the scale as a parameter for CollisionPrimitives::ConvexHull


Modified: dependencies/OgreNewt/inc/OgreNewt_CollisionPrimitives.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_CollisionPrimitives.h	2009-04-05 09:39:03 UTC (rev 4886)
+++ dependencies/OgreNewt/inc/OgreNewt_CollisionPrimitives.h	2009-04-06 13:04:06 UTC (rev 4887)
@@ -214,15 +214,17 @@
 
             //! constructor
             /*!
-                Overloaded constructor.  pass a SceneNode*, and it will use the vertex data from the first attached object.
+                Overloaded constructor.  pass an Entity*, and it will use its vertex data. if it is attached to Node*, the collision
+                will be scaled apperently (entity->getParentNode()->getScale())
                 \param world pointer to the OgreNewt::World
                 \param node pointer to an Ogre::SceneNode with a single entity attached
                 \param orient orientation offset of the primitive
                 \param pos position offset of the primitive
                 \parem tolerance a tolerance passed to newton
+                \param forceScale if set to something else then (0,0,0), the value of this argument will be used as scale instead of the parent-node's scale
             */
             ConvexHull( const World* world, Ogre::Entity* ent, 
-                const Ogre::Quaternion& orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3& pos = Ogre::Vector3::ZERO, Ogre::Real tolerance = 0.001f );
+                const Ogre::Quaternion& orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3& pos = Ogre::Vector3::ZERO, Ogre::Real tolerance = 0.001f , const Ogre::Vector3& forceScale = Ogre::Vector3::ZERO);
 
             /*!
                 Overloaded constructor.  pass a pointer to an array of vertices and the hull will be made from that.

Modified: dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp	2009-04-05 09:39:03 UTC (rev 4886)
+++ dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp	2009-04-06 13:04:06 UTC (rev 4887)
@@ -118,7 +118,7 @@
         ConvexHull::ConvexHull(const World* world) : ConvexCollision( world )
         {}
 
-        ConvexHull::ConvexHull( const World* world, Ogre::Entity* obj, const Ogre::Quaternion& orient, const Ogre::Vector3& pos, Ogre::Real tolerance ) : ConvexCollision( world )
+        ConvexHull::ConvexHull( const World* world, Ogre::Entity* obj, const Ogre::Quaternion& orient, const Ogre::Vector3& pos, Ogre::Real tolerance, const Ogre::Vector3& forceScale ) : ConvexCollision( world )
         {
             Ogre::Vector3 scale(1.0,1.0,1.0);
             
@@ -127,9 +127,11 @@
             //Ogre::Entity* obj = (Ogre::Entity*)node->getAttachedObject(0);
             Ogre::MeshPtr mesh = obj->getMesh();
 
-                        // get scale, if attached to node
-                        Ogre::Node * node = obj->getParentNode();
-                        if (node) scale = node->getScale();
+                       
+            // get scale, if attached to node
+            Ogre::Node * node = obj->getParentNode();
+            if (node) scale = node->getScale();
+            if (forceScale != Ogre::Vector3::ZERO) scale = forceScale;
 
             //find number of submeshes
             unsigned short sub = mesh->getNumSubMeshes();



From fusion2 at mail.berlios.de  Tue Apr  7 19:35:45 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Tue, 7 Apr 2009 19:35:45 +0200
Subject: [Dsa-hl-svn] r4888 - rl/trunk/editors/Lockenwickler/src
Message-ID: <200904071735.n37HZjLT025923@sheep.berlios.de>

Author: fusion2
Date: 2009-04-07 19:35:36 +0200 (Tue, 07 Apr 2009)
New Revision: 4888

Modified:
   rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/ZoneManager.py
Log:
- add and remove lights to zones with drag and drop in the Module Explorer

Modified: rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-06 13:04:06 UTC (rev 4887)
+++ rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-07 17:35:36 UTC (rev 4888)
@@ -35,7 +35,7 @@
             i += 1
 
 class ExplorerOptionsDlg(QDialog):
-    def __init__(self, lights, gameObjects, entities, zones, parent = None):
+    def __init__(self, lights, gameObjects, entities, zones, zonelights, parent = None):
         super(ExplorerOptionsDlg, self).__init__(parent)
         
         buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
@@ -57,6 +57,10 @@
         self.zonesCheckBox.setChecked(zones)        
         layout.addWidget(self.zonesCheckBox)
         
+        self.zoneslightsCheckBox = QCheckBox("Show Zonelights")
+        self.zoneslightsCheckBox.setChecked(zonelights)        
+        layout.addWidget(self.zoneslightsCheckBox)
+        
         layout.addWidget(buttonBox)
         layout.setContentsMargins(2, 2, 2, 2)
         self.setLayout(layout)
@@ -83,9 +87,13 @@
     def __init__(self, parent = None):
         super(ModuleTreeWidget, self).__init__(parent)
         
+        self.moduleManager = None
         self.setContextMenuPolicy(Qt.CustomContextMenu)        
         self.connect(self, SIGNAL("customContextMenuRequested(const QPoint &)"), self.doMenu)
-
+        
+        self.setDragEnabled(True)
+        self.setAcceptDrops(True)
+        
         self.onMenuCallback = None
         self.setAnimated(True)
 
@@ -98,7 +106,78 @@
     def doMenu(self, point):
         self.onMenuCallback(point)
 
+    def startDrag(self, lvi):
+        relMousePos = self.mapFromGlobal(QPoint(QCursor.pos().x(), QCursor.pos().y() - self.header().height()))
+        item = self.itemAt(relMousePos)
+        if item is not None and not str(item.data(0, Qt.UserRole).toString()).startswith("light_") and not item.data(0, Qt.UserRole).toInt()[0] == ModuleExplorer.LIGHT_IN_ZONE:
+            return
+        
+        data = QByteArray()
+        stream = QDataStream(data,  QIODevice.WriteOnly)
+        stream << self.currentItem().text(0)
+        mimeData = QMimeData()
+        mimeData.setData("application/light", data)
+        drag = QDrag(self)
+        drag.setMimeData(mimeData)
+        drag.start(Qt.CopyAction)
+
+    def dragEnterEvent(self, event):
+        print "enter"
+        if event.mimeData().hasFormat("application/light"):
+            event.accept()
+            
+            items = self.selectedItems()
+            
+            if items[0].data(0, Qt.UserRole).toInt()[0] == ModuleExplorer.LIGHT_IN_ZONE:
+                zone = self.zoneManager.getZone(str(items[0].parent().parent().text(0)).replace("Zone: ", ""))
+                zone.lightList.remove(str(items[0].text(0)))
+                
+                items[0].parent().removeChild(items[0])
+                
+    def dragMoveEvent (self, event):
+        relMousePos = self.mapFromGlobal(QPoint(QCursor.pos().x(), QCursor.pos().y() - self.header().height()))
+        item = self.itemAt(relMousePos)
+        if item is not None and str(item.text(0)).startswith("Zone: "):
+            event.accept()
+        else:
+            event.ignore()
+            
+
+    def dropEvent(self, event):
+        if event.mimeData().hasFormat("application/light"):
+            data = event.mimeData().data("application/light")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        
+            relMousePos = self.mapFromGlobal(QPoint(QCursor.pos().x(), QCursor.pos().y() - self.header().height()))
+            item = self.itemAt(relMousePos)
+            str(item.data(0, Qt.UserRole).toString())
+            
+            items = self.findItems("Lights", Qt.MatchFixedString | Qt.MatchRecursive)
+            for iitem in items:
+                if iitem.parent() is item:
+                    zoneName = str(item.text(0)).replace("Zone: ", "")
+                    zone = self.zoneManager.getZone(zoneName)
+                    
+                    for light in zone.lightList:
+                        if str(light) == str(text):
+                            print "Zone \"" + zoneName + "\" already has Light \"" + str(light) + "\" attached!"
+                            return
+                    
+                    zone.lightList.append(text)
+                    child = QTreeWidgetItem(iitem)
+                    child.setText(0, text)
+                    child.setData(0, Qt.UserRole, QVariant(ModuleExplorer.LIGHT_IN_ZONE))
+
+
+
 class ModuleExplorer(QWidget):
+    LIGHT_IN_ZONE = 99
+    
     def __init__(self, parent=None):
         QWidget.__init__(self, parent)
         self.sceneTreeView = ModuleTreeWidget()
@@ -125,6 +204,7 @@
         self.onMenuPoint = None
         
         self.showLights = True
+        self.showZoneLights = True
         self.showGameObjects = True
         self.showEntities = True
         self.showZones = True
@@ -174,6 +254,13 @@
         if self.selectionChangedCallback is None:
             return
 
+        #get all selected items
+        items = self.sceneTreeView.selectedItems()
+        if len(items) == 1:
+            if str(items[0].parent().text(0)) == "Lights" and str(items[0].parent().parent().text(0)).startswith("Zone: "):
+                return
+        
+        
         nodeNames = {}
         
         # get all maps and add them as a key to the dictionary
@@ -188,8 +275,7 @@
         for item in items:
             nodeNames[str(item.text(0))] = []
         
-        #get all selected items
-        items = self.sceneTreeView.selectedItems()
+
         
         #end remove all the things from the list we actually don't want to be selected
         for item in items:
@@ -286,7 +372,7 @@
             menu.exec_(QCursor().pos())
     
     def onOptions(self):
-        dlg = ExplorerOptionsDlg(self.showLights, self.showGameObjects, self.showEntities, self.showZones, self)
+        dlg = ExplorerOptionsDlg(self.showLights, self.showGameObjects, self.showEntities, self.showZones, self.showZoneLights, self)
         if dlg.exec_():
             self.showLights = dlg.lightCheckBox.isChecked()
             self.showGameObjects = dlg.gameObjectsCheckBox.isChecked()
@@ -328,7 +414,10 @@
     
     def onDelete(self):
         print "delete"
-        
+
+    def keyPressEvent(self, event):
+        print "key!!!!!!!!!!!!!!"
+    
     def paintLastSelectedMapBlue(self):
         print self.lastSelectedMap
         for item in self.mapItems:
@@ -436,13 +525,23 @@
                 childItem2.setText(0, "Area " + str(area.id))
                 childItem2.setData(0, Qt.UserRole, QVariant(area.areaNode.getName()))
                 i += 1
+             
+            if self.showZoneLights:
+                lightsItem = QTreeWidgetItem(childItem)
+                lightsItem.setText(0, "Lights")
                 
+                for lightName in zone.lightList:
+                    childItem2 = QTreeWidgetItem(lightsItem)
+                    childItem2.setText(0, lightName)
+                    childItem2.setData(0, Qt.UserRole, QVariant(ModuleExplorer.LIGHT_IN_ZONE))
+                    
     def setCurrentModule(self, module):
         self.module = module
         self.updateView()
 
     def setModuleManager(self, moduleManager):
         self.moduleManager = moduleManager
+        self.sceneTreeView.zoneManager = self.moduleManager.zoneManager
         
     def setMapSelectedCallback(self, callback):
         self.mapSelectedCallback = callback

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-04-06 13:04:06 UTC (rev 4887)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-04-07 17:35:36 UTC (rev 4888)
@@ -898,6 +898,14 @@
     def selectionChangedCallback(self, items):
         self.resetSelection()
         self.userSelectionList = self.selectionBuffer.manualSelectObjects(items)
+        
+        if len(self.userSelectionList) > 1:
+            self.propertyWindow.clear()
+        elif len(self.userSelectionList) == 1:
+            self.propertyWindow.showProperties(self.userSelectionList[0])
+        else:
+            return
+            
         self.updatePivots()
         
     def selectMapCallback(self, sceneName, mapName):

Modified: rl/trunk/editors/Lockenwickler/src/ZoneManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ZoneManager.py	2009-04-06 13:04:06 UTC (rev 4887)
+++ rl/trunk/editors/Lockenwickler/src/ZoneManager.py	2009-04-07 17:35:36 UTC (rev 4888)
@@ -1,363 +1,363 @@
-#################################################
-# This source file is part of Rastullahs Lockenwickler.
-# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
-
-import functools
-import xml.etree.cElementTree as xml
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
- 
-import ogre.renderer.OGRE as og
- 
-from ModuleExplorer import NameInputDlg
- 
-#                <zone name="Testzone">
-#                        <area type="sphere">
-#                                <position x="-10" y="0" z="-5"/>
-#                                <scale x="6" y="6" z="6"/>
-#                                <transition_distance>0.5</transition_distance>
-#                        </area>
-#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
-#                                <position x="25" y="0" z="-50"/>
-#                                <transition_distance>0.5</transition_distance>
-#                        </area>
-#                        <area type="sphere" subtract="true">
-#                                <position x="-11" y="0" z="-4"/>
-#                                <scale x="2" y="2" z="2"/>
-#                        </area>
-#                        <light name="red pointlight"/>
-#                        <light name="green spotlight"/>
-#                        <sound name="ruchin001.ogg"/>
-#                        <trigger name="test" classname="TestTrigger">
-#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
-#                        </trigger>
-#                </zone>
- 
-class Area(og.UserDefinedObject):
-    def __init__(self,sceneManager, type, parentZone, id, position, orientation, scale, meshFile = None, transitiondistance = "0.5", subtract = False):
-        og.UserDefinedObject.__init__(self)
-        self.type = type
-        self.parentZone = parentZone
-        if not parentZone:
-           raise Exception("No parentZone")
-
-        self.id = id # editor internal id for entity and node creation
-        self.areaNode = parentZone.zoneNode.createChildSceneNode("area_" + parentZone.name + " " + str(id))
-        self.meshFile = meshFile
-        self.areaEntity = None
-        self.transitiondistance = transitiondistance
-        self.__subtract = subtract
-        self.sceneManager = sceneManager
-        
-        if type == "box":
-            self.areaEntity = self.sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", "UniCube.mesh")
-        elif type == "sphere":
-            self.areaEntity = self.sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", "UniSphere.mesh")        
-        elif type == "ellipsoid":
-            print "not yet"
-        elif type == "capsule":
-            print "not yet"
-        elif type == "pyramid":
-            print "not yet"
-        elif type == "mesh":
-            try:
-                self.areaEntity = sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", self.meshFile)
-            except:
-                print "Mesh " + self.meshFile + " not found!"
-                return None
-                
-        self.areaEntity.setMaterialName("Lockenwickler_Area")
-        if self.__subtract:
-            self.areaEntity.setMaterialName("Lockenwickler_Area_Subtract")
-            
-        self.areaEntity.setUserObject(self)
-        self.areaNode.attachObject(self.areaEntity)
-        self.areaNode.setPosition(position)
-        if orientation is not None:
-            self.areaNode.setOrientation(orientation.w, orientation.x, orientation.y, orientation.z)
-        if scale is not None:
-            self.areaNode.setScale(scale)
-    
-    def __del__(self):
-        self.areaNode.detachAllObjects()
-        self.areaNode.getParent().removeAndDestroyChild(self.areaNode.getName())
-        self.sceneManager.destroyEntity(self.areaEntity.getName())
-    
-    def getsubtract(self):
-        return self.__subtract
-        
-    def setsubtract(self, val):
-        if not val:
-            self.areaEntity.setMaterialName("Lockenwickler_Area")
-        else:
-            self.areaEntity.setMaterialName("Lockenwickler_Area_Subtract")
-        
-        self.__subtract = val
-        
-    subtract = property(getsubtract, setsubtract)
-    
-class Zone():
-    def __init__(self,sceneManager, map, name):
-        self.map = map
-        self.name = name
-        self.areaList = []
-        self.lightList = []
-        self.soundList = []
-        self.triggerList = []
-        self.areaCounter = 0
-        self.sceneManager = sceneManager
-        self.isHidden = False
-        
-        self.zoneNode =  self.sceneManager.getRootSceneNode().createChildSceneNode("zone_" + name + "_node")
-        
-    def addArea(self, type, position, orientation, scale, meshFile = None):
-        area = Area(self.sceneManager, type, self, self.areaCounter, position, orientation, scale, meshFile)
-        if area is not None:
-            self.areaList.append(area)
-            self.areaCounter = self.areaCounter + 1
-    
-    def deleteArea(self, area):
-        for a in self.areaList:
-            if a.id == area.id:
-                self.areaList.remove(a)
-                del a
-    
-    def hide(self):
-        self.sceneManager.getRootSceneNode().removeChild(self.zoneNode)
-        self.isHidden = True
-    
-    def show(self):
-        self.sceneManager.getRootSceneNode().addChild(self.zoneNode)
-        self.isHidden = False
-        
-        
-class ZoneManager():
-    def __init__(self, sceneManager):
-        self.currentMap = None
-        self.zoneList = []
-        self.menuList = []
-        self.entityUnderMouse = None
-        self.newAreaPosition = None
-        self.sceneManager = sceneManager
-        
-    def createZone(self, name):
-        if self.currentMap == None:
-            print "No map selected!"
-            return
-            
-        z = Zone(self.sceneManager, self.currentMap, name)
-        self.zoneList.append(z)
-        self.currentMap.zoneList.append(z)
-        return z
-        
-    def parseZonesFromXml(self, zoneXmlNode, map):
-        if zoneXmlNode is None:
-            return
-        
-        self.currentMap = map
-        
-        zoneNodes = zoneXmlNode.getiterator("zone")
-        for zone in zoneNodes:
-            zoneName = zone.attrib["name"]
-            z = self.createZone(zoneName)
-            
-            areaNodes = zone.getiterator("area")
-            for area in areaNodes:
-                type = area.attrib["type"]
-                meshFile = None
-                if type == "mesh":
-                    meshFile = area.attrib["meshfile"]
-                
-                pos = og.Vector3()
-                qw = qx = qy = qz = 0
-                scale = None
-                hasRotation = False
-                
-                transformations = area.getiterator()
-                for t in transformations:
-                    if t.tag == "position":
-                        posx = float(t.attrib["x"])
-                        posy = float(t.attrib["y"])
-                        posz = float(t.attrib["z"])
-                        pos = og.Vector3(posx, posy, posz)
-                    elif t.tag == "rotation":
-                        qw = float(t.attrib["qw"])
-                        qx = float(t.attrib["qx"])
-                        qy = float(t.attrib["qy"])
-                        qz = float(t.attrib["qz"])
-                        hasRotation = True
-                    elif type == "mesh" and t.tag == "scale":
-                        scalex = float(t.attrib["x"])
-                        scaley = float(t.attrib["y"])
-                        scalez = float(t.attrib["z"])
-                        scale = og.Vector3(scalex, scaley, scalez)
-                    elif t.tag == "size":
-                        scalex = float(t.attrib["x"])
-                        scaley = float(t.attrib["y"])
-                        scalez = float(t.attrib["z"])
-                        scale = og.Vector3(scalex, scaley, scalez)
-                
-                rot = None
-                if hasRotation:
-                    rot = og.Quaternion(qw, qx, qy, qz)
-                    
-                z.addArea(type, pos, rot, scale, meshFile)
-            
-            
-            lightNodes = zone.getiterator("light")
-            for light in lightNodes:
-                name = light.attrib["name"]
-                z.lightList.append(name)
-                
-            soundNodes = zone.getiterator("sound")
-            for sound in soundNodes:
-                name = sound.attrib["name"]
-                z.soundList.append(name)
-            
-
-    def saveZonesToXml(self, root, map):
-        if len(map.zoneList) == 0:
-            return
-        
-        rootZonesElem = xml.SubElement(root, "zones")
-        for zone in map.zoneList:
-            zoneElem = xml.SubElement(rootZonesElem, "zone")
-            zoneElem.attrib["name"] = zone.name
-            
-            for area in zone.areaList:
-                areaElem = xml.SubElement(zoneElem, "area")
-                areaElem.attrib["type"] = area.type
-                print "Saving Zone: " + zone.name + " - Area " + str(area.id)
-                if area.type == "mesh" and area.meshFile is not None:
-                    areaElem.attrib["meshfile"] = area.meshFile
-                    
-                posElem = xml.SubElement(areaElem, "position")
-                posElem.attrib["x"] = str(area.areaNode.getPosition().x)
-                posElem.attrib["y"] = str(area.areaNode.getPosition().y)
-                posElem.attrib["z"] = str(area.areaNode.getPosition().z)
-                
-                rotElem = xml.SubElement(areaElem, "rotation")
-                rotElem.attrib["qw"] = str(area.areaNode.getOrientation().w)
-                rotElem.attrib["qx"] = str(area.areaNode.getOrientation().x)
-                rotElem.attrib["qy"] = str(area.areaNode.getOrientation().y)
-                rotElem.attrib["qz"] = str(area.areaNode.getOrientation().z)
-                
-                scaleElem = None
-                if area.type == "mesh":
-                    scaleElem = xml.SubElement(areaElem, "scale")
-                else:
-                    scaleElem = xml.SubElement(areaElem, "size")
-
-                scaleElem.attrib["x"] = str(area.areaNode.getScale().x)
-                scaleElem.attrib["y"] = str(area.areaNode.getScale().y)
-                scaleElem.attrib["z"] = str(area.areaNode.getScale().z)
-                
-            for lightName in zone.lightList:
-                lightElem = xml.SubElement(zoneElem, "light")
-                lightElem.attrib["name"] = lightName
-            
-            for soundName in zone.soundList:
-                soundElem = xml.SubElement(zoneElem, "sound")
-                soundElem.attrib["name"] = soundName
-                
-    def deleteArea(self, area):
-        for z in self.zoneList:
-            for a in z.areaList:
-                if a.id == area.id:
-                    z.deleteArea(area)
-    
-    def getZoneMenu(self):
-        self.menuList = []
-        menu = QMenu("Add Area")
-        
-        for zone in self.zoneList:
-            m = QMenu(zone.name)
-            self.menuList.append(m)
-            menu.addMenu(m)
-            
-            boxAction = self.createAction("box", functools.partial(self.onZoneNameTriggered, zone, "box"))
-            self.menuList.append(boxAction)
-            m.addAction(boxAction)
-            
-            sphereAction = self.createAction("sphere", functools.partial(self.onZoneNameTriggered, zone, "sphere"))
-            self.menuList.append(sphereAction)
-            m.addAction(sphereAction)
-            
-            ellipsoidAction = self.createAction("ellipsoid", functools.partial(self.onZoneNameTriggered, zone, "ellipsoid"))
-            self.menuList.append(ellipsoidAction)
-            m.addAction(ellipsoidAction)
-            
-            capsuleAction = self.createAction("capsule", functools.partial(self.onZoneNameTriggered, zone, "capsule"))
-            self.menuList.append(capsuleAction)
-            m.addAction(capsuleAction)
-            
-            pyramidAction = self.createAction("pyramid", functools.partial(self.onZoneNameTriggered, zone, "pyramid"))
-            self.menuList.append(pyramidAction)
-            m.addAction(pyramidAction)
-            
-            meshAction = self.createAction("mesh", functools.partial(self.onZoneNameTriggered, zone, "mesh"))
-            self.menuList.append(meshAction)
-            m.addAction(meshAction)
-            
-        return menu
-        
-    def onZoneNameTriggered(self, zone, type):
-        if self.newAreaPosition is not None:
-            if type == "box":
-                zone.addArea("box", self.newAreaPosition, None, None)
-            elif type == "sphere":
-                zone.addArea("sphere", self.newAreaPosition, None, None)
-            elif type == "mesh":
-                dlg = NameInputDlg(QApplication.focusWidget())
-                resName = ""
-                if dlg.exec_():
-                    resName = str(dlg.nameInput.text())
-
-                zone.addArea("mesh", self.newAreaPosition, None, None, resName)
-                
-    def getZone(self, name):
-        for zone in self.zoneList:
-            if zone.name == name:
-                return zone
-        
-    def getZoneList(self):
-        list = []
-        for zone in self.zoneList:
-            list.append(zone.name)
-            
-        return list
-        
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
-        action = QAction(text, None)
-        if icon is not None:
-            action.setIcon(QIcon("media/icons/%s" % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            QWidget.connect(action, SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
-        
-        
-        
+#################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import functools
+import xml.etree.cElementTree as xml
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+ 
+import ogre.renderer.OGRE as og
+ 
+from ModuleExplorer import NameInputDlg
+ 
+#                <zone name="Testzone">
+#                        <area type="sphere">
+#                                <position x="-10" y="0" z="-5"/>
+#                                <scale x="6" y="6" z="6"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
+#                                <position x="25" y="0" z="-50"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="sphere" subtract="true">
+#                                <position x="-11" y="0" z="-4"/>
+#                                <scale x="2" y="2" z="2"/>
+#                        </area>
+#                        <light name="red pointlight"/>
+#                        <light name="green spotlight"/>
+#                        <sound name="ruchin001.ogg"/>
+#                        <trigger name="test" classname="TestTrigger">
+#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
+#                        </trigger>
+#                </zone>
+ 
+class Area(og.UserDefinedObject):
+    def __init__(self,sceneManager, type, parentZone, id, position, orientation, scale, meshFile = None, transitiondistance = "0.5", subtract = False):
+        og.UserDefinedObject.__init__(self)
+        self.type = type
+        self.parentZone = parentZone
+        if not parentZone:
+           raise Exception("No parentZone")
+
+        self.id = id # editor internal id for entity and node creation
+        self.areaNode = parentZone.zoneNode.createChildSceneNode("area_" + parentZone.name + " " + str(id))
+        self.meshFile = meshFile
+        self.areaEntity = None
+        self.transitiondistance = transitiondistance
+        self.__subtract = subtract
+        self.sceneManager = sceneManager
+        
+        if type == "box":
+            self.areaEntity = self.sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", "UniCube.mesh")
+        elif type == "sphere":
+            self.areaEntity = self.sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", "UniSphere.mesh")        
+        elif type == "ellipsoid":
+            print "not yet"
+        elif type == "capsule":
+            print "not yet"
+        elif type == "pyramid":
+            print "not yet"
+        elif type == "mesh":
+            try:
+                self.areaEntity = sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", self.meshFile)
+            except:
+                print "Mesh " + self.meshFile + " not found!"
+                return None
+                
+        self.areaEntity.setMaterialName("Lockenwickler_Area")
+        if self.__subtract:
+            self.areaEntity.setMaterialName("Lockenwickler_Area_Subtract")
+            
+        self.areaEntity.setUserObject(self)
+        self.areaNode.attachObject(self.areaEntity)
+        self.areaNode.setPosition(position)
+        if orientation is not None:
+            self.areaNode.setOrientation(orientation.w, orientation.x, orientation.y, orientation.z)
+        if scale is not None:
+            self.areaNode.setScale(scale)
+    
+    def __del__(self):
+        self.areaNode.detachAllObjects()
+        self.areaNode.getParent().removeAndDestroyChild(self.areaNode.getName())
+        self.sceneManager.destroyEntity(self.areaEntity.getName())
+    
+    def getsubtract(self):
+        return self.__subtract
+        
+    def setsubtract(self, val):
+        if not val:
+            self.areaEntity.setMaterialName("Lockenwickler_Area")
+        else:
+            self.areaEntity.setMaterialName("Lockenwickler_Area_Subtract")
+        
+        self.__subtract = val
+        
+    subtract = property(getsubtract, setsubtract)
+    
+class Zone():
+    def __init__(self,sceneManager, map, name):
+        self.map = map
+        self.name = name
+        self.areaList = []
+        self.lightList = []
+        self.soundList = []
+        self.triggerList = []
+        self.areaCounter = 0
+        self.sceneManager = sceneManager
+        self.isHidden = False
+        
+        self.zoneNode =  self.sceneManager.getRootSceneNode().createChildSceneNode("zone_" + name + "_node")
+        
+    def addArea(self, type, position, orientation, scale, meshFile = None):
+        area = Area(self.sceneManager, type, self, self.areaCounter, position, orientation, scale, meshFile)
+        if area is not None:
+            self.areaList.append(area)
+            self.areaCounter = self.areaCounter + 1
+    
+    def deleteArea(self, area):
+        for a in self.areaList:
+            if a.id == area.id:
+                self.areaList.remove(a)
+                del a
+    
+    def hide(self):
+        self.sceneManager.getRootSceneNode().removeChild(self.zoneNode)
+        self.isHidden = True
+    
+    def show(self):
+        self.sceneManager.getRootSceneNode().addChild(self.zoneNode)
+        self.isHidden = False
+        
+        
+class ZoneManager():
+    def __init__(self, sceneManager):
+        self.currentMap = None
+        self.zoneList = []
+        self.menuList = []
+        self.entityUnderMouse = None
+        self.newAreaPosition = None
+        self.sceneManager = sceneManager
+        
+    def createZone(self, name):
+        if self.currentMap == None:
+            print "No map selected!"
+            return
+            
+        z = Zone(self.sceneManager, self.currentMap, name)
+        self.zoneList.append(z)
+        self.currentMap.zoneList.append(z)
+        return z
+        
+    def parseZonesFromXml(self, zoneXmlNode, map):
+        if zoneXmlNode is None:
+            return
+        
+        self.currentMap = map
+        
+        zoneNodes = zoneXmlNode.getiterator("zone")
+        for zone in zoneNodes:
+            zoneName = zone.attrib["name"]
+            z = self.createZone(zoneName)
+            
+            areaNodes = zone.getiterator("area")
+            for area in areaNodes:
+                type = area.attrib["type"]
+                meshFile = None
+                if type == "mesh":
+                    meshFile = area.attrib["meshfile"]
+                
+                pos = og.Vector3()
+                qw = qx = qy = qz = 0
+                scale = None
+                hasRotation = False
+                
+                transformations = area.getiterator()
+                for t in transformations:
+                    if t.tag == "position":
+                        posx = float(t.attrib["x"])
+                        posy = float(t.attrib["y"])
+                        posz = float(t.attrib["z"])
+                        pos = og.Vector3(posx, posy, posz)
+                    elif t.tag == "rotation":
+                        qw = float(t.attrib["qw"])
+                        qx = float(t.attrib["qx"])
+                        qy = float(t.attrib["qy"])
+                        qz = float(t.attrib["qz"])
+                        hasRotation = True
+                    elif type == "mesh" and t.tag == "scale":
+                        scalex = float(t.attrib["x"])
+                        scaley = float(t.attrib["y"])
+                        scalez = float(t.attrib["z"])
+                        scale = og.Vector3(scalex, scaley, scalez)
+                    elif t.tag == "size":
+                        scalex = float(t.attrib["x"])
+                        scaley = float(t.attrib["y"])
+                        scalez = float(t.attrib["z"])
+                        scale = og.Vector3(scalex, scaley, scalez)
+                
+                rot = None
+                if hasRotation:
+                    rot = og.Quaternion(qw, qx, qy, qz)
+                    
+                z.addArea(type, pos, rot, scale, meshFile)
+            
+            
+            lightNodes = zone.getiterator("light")
+            for light in lightNodes:
+                name = light.attrib["name"]
+                z.lightList.append(name)
+                
+            soundNodes = zone.getiterator("sound")
+            for sound in soundNodes:
+                name = sound.attrib["name"]
+                z.soundList.append(name)
+            
+
+    def saveZonesToXml(self, root, map):
+        if len(map.zoneList) == 0:
+            return
+        
+        rootZonesElem = xml.SubElement(root, "zones")
+        for zone in map.zoneList:
+            zoneElem = xml.SubElement(rootZonesElem, "zone")
+            zoneElem.attrib["name"] = zone.name
+            
+            for area in zone.areaList:
+                areaElem = xml.SubElement(zoneElem, "area")
+                areaElem.attrib["type"] = area.type
+                print "Saving Zone: " + zone.name + " - Area " + str(area.id)
+                if area.type == "mesh" and area.meshFile is not None:
+                    areaElem.attrib["meshfile"] = area.meshFile
+                    
+                posElem = xml.SubElement(areaElem, "position")
+                posElem.attrib["x"] = str(area.areaNode.getPosition().x)
+                posElem.attrib["y"] = str(area.areaNode.getPosition().y)
+                posElem.attrib["z"] = str(area.areaNode.getPosition().z)
+                
+                rotElem = xml.SubElement(areaElem, "rotation")
+                rotElem.attrib["qw"] = str(area.areaNode.getOrientation().w)
+                rotElem.attrib["qx"] = str(area.areaNode.getOrientation().x)
+                rotElem.attrib["qy"] = str(area.areaNode.getOrientation().y)
+                rotElem.attrib["qz"] = str(area.areaNode.getOrientation().z)
+                
+                scaleElem = None
+                if area.type == "mesh":
+                    scaleElem = xml.SubElement(areaElem, "scale")
+                else:
+                    scaleElem = xml.SubElement(areaElem, "size")
+
+                scaleElem.attrib["x"] = str(area.areaNode.getScale().x)
+                scaleElem.attrib["y"] = str(area.areaNode.getScale().y)
+                scaleElem.attrib["z"] = str(area.areaNode.getScale().z)
+                
+            for lightName in zone.lightList:
+                lightElem = xml.SubElement(zoneElem, "light")
+                lightElem.attrib["name"] = lightName
+            
+            for soundName in zone.soundList:
+                soundElem = xml.SubElement(zoneElem, "sound")
+                soundElem.attrib["name"] = soundName
+                
+    def deleteArea(self, area):
+        for z in self.zoneList:
+            for a in z.areaList:
+                if a.id == area.id:
+                    z.deleteArea(area)
+    
+    def getZoneMenu(self):
+        self.menuList = []
+        menu = QMenu("Add Area")
+        
+        for zone in self.zoneList:
+            m = QMenu(zone.name)
+            self.menuList.append(m)
+            menu.addMenu(m)
+            
+            boxAction = self.createAction("box", functools.partial(self.onZoneNameTriggered, zone, "box"))
+            self.menuList.append(boxAction)
+            m.addAction(boxAction)
+            
+            sphereAction = self.createAction("sphere", functools.partial(self.onZoneNameTriggered, zone, "sphere"))
+            self.menuList.append(sphereAction)
+            m.addAction(sphereAction)
+            
+            ellipsoidAction = self.createAction("ellipsoid", functools.partial(self.onZoneNameTriggered, zone, "ellipsoid"))
+            self.menuList.append(ellipsoidAction)
+            m.addAction(ellipsoidAction)
+            
+            capsuleAction = self.createAction("capsule", functools.partial(self.onZoneNameTriggered, zone, "capsule"))
+            self.menuList.append(capsuleAction)
+            m.addAction(capsuleAction)
+            
+            pyramidAction = self.createAction("pyramid", functools.partial(self.onZoneNameTriggered, zone, "pyramid"))
+            self.menuList.append(pyramidAction)
+            m.addAction(pyramidAction)
+            
+            meshAction = self.createAction("mesh", functools.partial(self.onZoneNameTriggered, zone, "mesh"))
+            self.menuList.append(meshAction)
+            m.addAction(meshAction)
+            
+        return menu
+        
+    def onZoneNameTriggered(self, zone, type):
+        if self.newAreaPosition is not None:
+            if type == "box":
+                zone.addArea("box", self.newAreaPosition, None, None)
+            elif type == "sphere":
+                zone.addArea("sphere", self.newAreaPosition, None, None)
+            elif type == "mesh":
+                dlg = NameInputDlg(QApplication.focusWidget())
+                resName = ""
+                if dlg.exec_():
+                    resName = str(dlg.nameInput.text())
+
+                zone.addArea("mesh", self.newAreaPosition, None, None, resName)
+                
+    def getZone(self, name):
+        for zone in self.zoneList:
+            if zone.name == name:
+                return zone
+        
+    def getZoneList(self):
+        list = []
+        for zone in self.zoneList:
+            list.append(zone.name)
+            
+        return list
+        
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QAction(text, None)
+        if icon is not None:
+            action.setIcon(QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            QWidget.connect(action, SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+        
+        
+        



From melven at mail.berlios.de  Wed Apr  8 00:24:44 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 8 Apr 2009 00:24:44 +0200
Subject: [Dsa-hl-svn] r4889 - in dependencies/OgreNewt:
	demos/Demo01_TheBasics demos/Demo02_Joints
	demos/Demo03_CollisionCallbacks demos/Demo04_Raycasting
	demos/Demo05_SimpleVehicle demos/Demo06_SimpleBuoyancy
	demos/Demo07_CustomJoints demos/Demo08_RagdollExample inc src
Message-ID: <200904072224.n37MOiEE032255@sheep.berlios.de>

Author: melven
Date: 2009-04-08 00:24:33 +0200 (Wed, 08 Apr 2009)
New Revision: 4889

Modified:
   dependencies/OgreNewt/demos/Demo01_TheBasics/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo01_TheBasics/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/demos/Demo02_Joints/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo02_Joints/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/ConveyorBelt.cpp
   dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/ConveyorMatCallback.cpp
   dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/demos/Demo04_Raycasting/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo04_Raycasting/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/demos/Demo05_SimpleVehicle/SimpleVehicle.cpp
   dependencies/OgreNewt/demos/Demo06_SimpleBuoyancy/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo06_SimpleBuoyancy/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/demos/Demo07_CustomJoints/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo07_CustomJoints/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/demos/Demo08_RagdollExample/OgreNewtonApplication.cpp
   dependencies/OgreNewt/demos/Demo08_RagdollExample/OgreNewtonFrameListener.cpp
   dependencies/OgreNewt/demos/Demo08_RagdollExample/Ragdoll.cpp
   dependencies/OgreNewt/demos/Demo08_RagdollExample/Ragdoll.h
   dependencies/OgreNewt/inc/OgreNewt.h
   dependencies/OgreNewt/inc/OgreNewt_BasicFrameListener.h
   dependencies/OgreNewt/inc/OgreNewt_Body.h
   dependencies/OgreNewt/inc/OgreNewt_BodyInAABBIterator.h
   dependencies/OgreNewt/inc/OgreNewt_Collision.h
   dependencies/OgreNewt/inc/OgreNewt_CollisionPrimitives.h
   dependencies/OgreNewt/inc/OgreNewt_CollisionSerializer.h
   dependencies/OgreNewt/inc/OgreNewt_ContactCallback.h
   dependencies/OgreNewt/inc/OgreNewt_ContactJoint.h
   dependencies/OgreNewt/inc/OgreNewt_Debugger.h
   dependencies/OgreNewt/inc/OgreNewt_Joint.h
   dependencies/OgreNewt/inc/OgreNewt_MaterialID.h
   dependencies/OgreNewt/inc/OgreNewt_PlayerController.h
   dependencies/OgreNewt/inc/OgreNewt_Prerequisites.h
   dependencies/OgreNewt/inc/OgreNewt_RayCast.h
   dependencies/OgreNewt/inc/OgreNewt_Tools.h
   dependencies/OgreNewt/inc/OgreNewt_Vehicle.h
   dependencies/OgreNewt/inc/OgreNewt_World.h
   dependencies/OgreNewt/src/OgreNewt_Body.cpp
   dependencies/OgreNewt/src/OgreNewt_Collision.cpp
   dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp
   dependencies/OgreNewt/src/OgreNewt_CollisionSerializer.cpp
   dependencies/OgreNewt/src/OgreNewt_Debugger.cpp
   dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp
   dependencies/OgreNewt/src/OgreNewt_RayCast.cpp
   dependencies/OgreNewt/src/OgreNewt_Tools.cpp
Log:
-added preprocessor option OGRENEWT_COLLISION_USE_SHAREDPTR (use boost::shared_ptr for Collisions)
-added preprocessor option OGRENEWT_USE_OGRE_ANY (use Ogre::Any instead of userdata-pointers)


Modified: dependencies/OgreNewt/demos/Demo01_TheBasics/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo01_TheBasics/OgreNewtonApplication.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo01_TheBasics/OgreNewtonApplication.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -55,13 +55,15 @@
 
 	// here's where we make a collision shape for the physics.  note that we use the same size as
 	// above.
-	OgreNewt::Collision* col = new OgreNewt::CollisionPrimitives::Cylinder(m_World, 2.5, 5);
+	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder(m_World, 2.5, 5));
 
 	// now we make a new rigid body based on this collision shape.
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
 	// we`re done with the collision shape, we can delete it now.
 	delete col;
+#endif
 
 	// now we "attach" the rigid body to the scene node that holds the visual object, and set it's
 	// original position and orientation.  all rigid bodies default to mass=0 (static, immobile), so

Modified: dependencies/OgreNewt/demos/Demo01_TheBasics/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo01_TheBasics/OgreNewtonFrameListener.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo01_TheBasics/OgreNewtonFrameListener.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -80,17 +80,20 @@
 			//ent->setNormaliseNormals(true);
 
 			// again, make the collision shape.
-			OgreNewt::ConvexCollision* col = new OgreNewt::CollisionPrimitives::Cylinder(m_World, 1, 1);
+			OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder(m_World, 1, 1));
 			
 			// then make the rigid body.
 			OgreNewt::Body* body = new OgreNewt::Body( m_World, col );
 
 			Ogre::Vector3 inertia, offset;
             col->calculateInertialMatrix(inertia, offset);
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
 			//no longer need the collision shape object
 			delete col;
+#endif
 
 			body->setMassMatrix( 10.0, 10.0*inertia );
+            body->setCenterOfMass(offset);
 
 			// attach to the scene node.
 			body->attachNode( node );

Modified: dependencies/OgreNewt/demos/Demo02_Joints/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo02_Joints/OgreNewtonApplication.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo02_Joints/OgreNewtonApplication.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -74,8 +74,10 @@
 	// SceneNodes (parsing all children), and add collision for all meshes in the tree.
 	OgreNewt::CollisionPrimitives::TreeCollisionSceneParser* stat_col = new OgreNewt::CollisionPrimitives::TreeCollisionSceneParser( m_World );
 	stat_col->parseScene( floornode, true );
-	OgreNewt::Body* bod = new OgreNewt::Body( m_World, stat_col );
+	OgreNewt::Body* bod = new OgreNewt::Body( m_World, OgreNewt::CollisionPtr(stat_col) );
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
 	delete stat_col;
+#endif
 	
 	bod->attachNode( floornode );
 	bod->setPositionOrientation( Ogre::Vector3(0.0,-20.0,0.0), Ogre::Quaternion::IDENTITY );
@@ -160,7 +162,7 @@
 	box1node->setScale( size );
 //	box1->setNormaliseNormals(true);
 
-	OgreNewt::ConvexCollision* col = new OgreNewt::CollisionPrimitives::Box( m_World, size );
+	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 
 
@@ -171,10 +173,13 @@
 	Ogre::Vector3 inertia, offset;
     col->calculateInertialMatrix(inertia, offset);
 
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
 	delete col;
+#endif
 				
 	bod->attachNode( box1node );
 	bod->setMassMatrix( mass, mass*inertia );
+    bod->setCenterOfMass(offset);
 	bod->setStandardForceCallback();
 
 	box1->setMaterialName( "Simple/BumpyMetal" );

Modified: dependencies/OgreNewt/demos/Demo02_Joints/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo02_Joints/OgreNewtonFrameListener.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo02_Joints/OgreNewtonFrameListener.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -74,12 +74,17 @@
 			ent->setMaterialName( "Simple/dirt01" );
 //			ent->setNormaliseNormals(true);
 
-			OgreNewt::ConvexCollision* col = new OgreNewt::CollisionPrimitives::Ellipsoid( m_World, Ogre::Vector3(1,1,1) );
+			OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( m_World, Ogre::Vector3(1,1,1) ));
 			OgreNewt::Body* body = new OgreNewt::Body( m_World, col );
 
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+            delete col;
+#endif
+
 			Ogre::Vector3 inertia, offset;
             col->calculateInertialMatrix(inertia, offset);
 			body->setMassMatrix( 10.0, 10.0*inertia );
+            body->setCenterOfMass(offset);
 			body->attachNode( node );
 			body->setStandardForceCallback();
 			body->setPositionOrientation( pos, camorient );

Modified: dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/ConveyorBelt.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/ConveyorBelt.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/ConveyorBelt.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -27,15 +27,21 @@
 	mNode->setScale( size );
 
 	// create the collision object for the conveyor belt.
-	OgreNewt::Collision* col = new OgreNewt::CollisionPrimitives::Box( world, size );
+	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size ));
 	mBody = new OgreNewt::Body( world, col, conveyorType );
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
 	delete col;
+#endif
 
 	mBody->setMassMatrix( 0.0, Ogre::Vector3(0,0,0) );
 	mBody->attachNode( mNode );
 	mBody->setMaterialGroupID( conveyorMat );
 
+#ifdef OGRENEWT_USE_OGRE_ANY
+	mBody->setUserData( Ogre::Any(this) );
+#else
 	mBody->setUserData( this );
+#endif
 
 	mBody->setPositionOrientation( pos, orient );
 	mNode->setPosition( pos );

Modified: dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/ConveyorMatCallback.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/ConveyorMatCallback.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/ConveyorMatCallback.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -29,13 +29,21 @@
 
 	if (body0->getType() == mConveyorID)
 	{
+#ifdef OGRENEWT_USE_OGRE_ANY
+		belt = Ogre::any_cast<ConveyorBelt*>(body0->getUserData());
+#else
 		belt = (ConveyorBelt*)body0->getUserData();
+#endif
 		object = body1;
 	}
 
 	if (body1->getType() == mConveyorID)
 	{
+#ifdef OGRENEWT_USE_OGRE_ANY
+		belt = Ogre::any_cast<ConveyorBelt*>(body1->getUserData());
+#else
 		belt = (ConveyorBelt*)body1->getUserData();
+#endif
 		object = body0;
 	}
 

Modified: dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/OgreNewtonApplication.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/OgreNewtonApplication.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -79,9 +79,13 @@
 	floor->setCastShadows( false );
 
 	//Ogre::Vector3 siz(100.0, 10.0, 100.0);
-	OgreNewt::Collision* col = new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true );
+	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 	
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+    delete col;
+#endif
+
 	//floornode->setScale( siz );
 	bod->attachNode( floornode );
 	bod->setPositionOrientation( Ogre::Vector3(0.0,-10.0,0.0), Ogre::Quaternion::IDENTITY );

Modified: dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/OgreNewtonFrameListener.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo03_CollisionCallbacks/OgreNewtonFrameListener.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -68,14 +68,18 @@
 
 		ent->setMaterialName( "Simple/BumpyMetal" );
 
-		OgreNewt::ConvexCollision* col = new OgreNewt::CollisionPrimitives::Box( m_World, size );
+		OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size ));
 		OgreNewt::Body* body = new OgreNewt::Body( m_World, col );
 
         Ogre::Vector3 inertia, offset;
         col->calculateInertialMatrix(inertia, offset);
+
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
 		delete col;
+#endif
 
 		body->setMassMatrix( mass, mass*inertia );
+        body->setCenterOfMass(offset);
 		body->attachNode( node );
 		body->setStandardForceCallback();
 		body->setPositionOrientation( Ogre::Vector3(-5,8,0), Ogre::Quaternion::IDENTITY );

Modified: dependencies/OgreNewt/demos/Demo04_Raycasting/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo04_Raycasting/OgreNewtonApplication.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo04_Raycasting/OgreNewtonApplication.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -75,9 +75,11 @@
 
 
 	//Ogre::Vector3 siz(100.0, 10.0, 100.0);
-	OgreNewt::Collision* col = new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true );
+	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
 	delete col;
+#endif
 	
 	//floornode->setScale( siz );
 	bod->attachNode( floornode );
@@ -174,7 +176,7 @@
 	box1node->attachObject( box1 );
 	box1node->setScale( size );
 
-	OgreNewt::ConvexCollision* col = new OgreNewt::CollisionPrimitives::Box( m_World, size );
+	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 
 
@@ -184,10 +186,13 @@
 	Ogre::Vector3 inertia, offset;
     col->calculateInertialMatrix(inertia, offset);
 
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
 	delete col;
+#endif
 				
 	bod->attachNode( box1node );
 	bod->setMassMatrix( mass, mass*inertia );
+    bod->setCenterOfMass(offset);
 	bod->setStandardForceCallback();
 
 	box1->setMaterialName( "Simple/BumpyMetal" );

Modified: dependencies/OgreNewt/demos/Demo04_Raycasting/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo04_Raycasting/OgreNewtonFrameListener.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo04_Raycasting/OgreNewtonFrameListener.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -114,7 +114,12 @@
 				Ogre::Vector3 localpt = bodorient.Inverse() * (globalpt - bodpos);
 
 				// now we need to save this point to apply the spring force, I'm using the userData of the bodies in this example.
+                // (where is it used? probably not needed here...)
+#ifdef OGRENEWT_USE_OGRE_ANY
+                info.mBody->setUserData( Ogre::Any(this) );
+#else
 				info.mBody->setUserData( this );
+#endif
 
 				// now change the force callback from the standard one to the one that applies the spring (drag) force.
 				// this is an example of binding a callback to a member of a specific class.  in previous versions of OgreNewt you were

Modified: dependencies/OgreNewt/demos/Demo05_SimpleVehicle/SimpleVehicle.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo05_SimpleVehicle/SimpleVehicle.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo05_SimpleVehicle/SimpleVehicle.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -172,6 +172,7 @@
 				
 	bod->attachNode( box1node );
 	bod->setMassMatrix( mass, mass*inertia );
+    bod->setCenterOfMass(offset);
 	bod->setStandardForceCallback();
 
 	box1->setMaterialName( "Simple/BumpyMetal" );

Modified: dependencies/OgreNewt/demos/Demo06_SimpleBuoyancy/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo06_SimpleBuoyancy/OgreNewtonApplication.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo06_SimpleBuoyancy/OgreNewtonApplication.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -75,9 +75,11 @@
 
 
 	//Ogre::Vector3 siz(100.0, 10.0, 100.0);
-	OgreNewt::Collision* col = new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true );
+	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
 	delete col;
+#endif
 	
 	//floornode->setScale( siz );
 	bod->attachNode( floornode );
@@ -191,7 +193,7 @@
 	box1node->attachObject( box1 );
 	box1node->setScale( size );
 
-	OgreNewt::ConvexCollision* col = new OgreNewt::CollisionPrimitives::Box( m_World, size );
+	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 
 
@@ -200,11 +202,13 @@
 	// calculate the inertia based on box formula and mass
 	Ogre::Vector3 inertia, offset;
     col->calculateInertialMatrix(inertia, offset);
-
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
 	delete col;
+#endif
 				
 	bod->attachNode( box1node );
 	bod->setMassMatrix( mass, mass*inertia );
+    bod->setCenterOfMass(offset);
 	bod->setStandardForceCallback();
 
 	box1->setMaterialName( "Simple/BumpyMetal" );

Modified: dependencies/OgreNewt/demos/Demo06_SimpleBuoyancy/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo06_SimpleBuoyancy/OgreNewtonFrameListener.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo06_SimpleBuoyancy/OgreNewtonFrameListener.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -114,8 +114,14 @@
 				Ogre::Vector3 localpt = bodorient.Inverse() * (globalpt - bodpos);
 
 				// now we need to save this point to apply the spring force, I'm using the userData of the bodies in this example.
+                // (where is it used? probably not needed here...)
+#ifdef OGRENEWT_USE_OGRE_ANY
+                info.mBody->setUserData( Ogre::Any(this) );
+#else
 				info.mBody->setUserData( this );
+#endif
 
+
 				// now change the force callback from the standard one to the one that applies the spring (drag) force.
 				info.mBody->setCustomForceAndTorqueCallback<OgreNewtonFrameListener>( &OgreNewtonFrameListener::dragCallback, this );
 

Modified: dependencies/OgreNewt/demos/Demo07_CustomJoints/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo07_CustomJoints/OgreNewtonApplication.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo07_CustomJoints/OgreNewtonApplication.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -75,8 +75,10 @@
 	// SceneNodes (parsing all children), and add collision for all meshes in the tree.
 	OgreNewt::CollisionPrimitives::TreeCollisionSceneParser* stat_col = new OgreNewt::CollisionPrimitives::TreeCollisionSceneParser( m_World );
 	stat_col->parseScene( floornode, true );
-	OgreNewt::Body* bod = new OgreNewt::Body( m_World, stat_col );
+	OgreNewt::Body* bod = new OgreNewt::Body( m_World, OgreNewt::CollisionPtr(stat_col) );
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
 	delete stat_col;
+#endif
 	
 	bod->attachNode( floornode );
 	bod->setPositionOrientation( Ogre::Vector3(0.0,-20.0,0.0), Ogre::Quaternion::IDENTITY );
@@ -160,7 +162,7 @@
 	box1node->attachObject( box1 );
 	box1node->setScale( size );
 
-	OgreNewt::ConvexCollision* col = new OgreNewt::CollisionPrimitives::Box( m_World, size );
+	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 
 
@@ -170,11 +172,13 @@
 	// calculate the inertia based on box formula and mass
 	Ogre::Vector3 inertia, offset;
     col->calculateInertialMatrix(inertia, offset);
-
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
 	delete col;
+#endif
 				
 	bod->attachNode( box1node );
 	bod->setMassMatrix( mass, mass*inertia );
+    bod->setCenterOfMass(offset);
 	bod->setStandardForceCallback();
 
 	box1->setMaterialName( "Simple/BumpyMetal" );

Modified: dependencies/OgreNewt/demos/Demo07_CustomJoints/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo07_CustomJoints/OgreNewtonFrameListener.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo07_CustomJoints/OgreNewtonFrameListener.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -73,18 +73,23 @@
 
 			ent->setMaterialName( "Simple/dirt01" );
 
-			OgreNewt::ConvexCollision* col = new OgreNewt::CollisionPrimitives::Ellipsoid( m_World, Ogre::Vector3(1,1,1) );
+			OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( m_World, Ogre::Vector3(1,1,1) ));
 			OgreNewt::Body* body = new OgreNewt::Body( m_World, col );
 
 			Ogre::Vector3 inertia, offset;
             col->calculateInertialMatrix(inertia, offset);
 			body->setMassMatrix( 10.0, 10.0*inertia );
+            body->setCenterOfMass(offset);
 			body->attachNode( node );
 			body->setStandardForceCallback();
 			body->setPositionOrientation( pos, camorient );
 			body->setVelocity( (dir * 50.0) );
 
 			timer = 0.2;
+
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+            delete col;
+#endif
 		}
 	}
 

Modified: dependencies/OgreNewt/demos/Demo08_RagdollExample/OgreNewtonApplication.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo08_RagdollExample/OgreNewtonApplication.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo08_RagdollExample/OgreNewtonApplication.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -49,9 +49,11 @@
 	floor->setCastShadows( false );
 
 	//Ogre::Vector3 siz(100.0, 10.0, 100.0);
-	OgreNewt::Collision* col = new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true );
+	OgreNewt::CollisionPtr col = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision( m_World, floor, true ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
 	delete col;
+#endif
 	
 	//floornode->setScale( siz );
 	bod->attachNode( floornode );
@@ -97,7 +99,7 @@
 	box1node->attachObject( box1 );
 	box1node->setScale( size );
 
-	OgreNewt::ConvexCollision* col = new OgreNewt::CollisionPrimitives::Box( m_World, size );
+	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( m_World, size ));
 	OgreNewt::Body* bod = new OgreNewt::Body( m_World, col );
 
 
@@ -108,10 +110,13 @@
 	Ogre::Vector3 inertia, offset;
     col->calculateInertialMatrix(inertia, offset);
 
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
 	delete col;
+#endif
 				
 	bod->attachNode( box1node );
 	bod->setMassMatrix( mass, mass*inertia );
+    bod->setCenterOfMass(offset);
 	bod->setStandardForceCallback();
 
 	box1->setMaterialName( "Simple/BumpyMetal" );

Modified: dependencies/OgreNewt/demos/Demo08_RagdollExample/OgreNewtonFrameListener.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo08_RagdollExample/OgreNewtonFrameListener.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo08_RagdollExample/OgreNewtonFrameListener.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -87,18 +87,23 @@
 
 			ent->setMaterialName( "Simple/dirt01" );
 
-			OgreNewt::ConvexCollision* col = new OgreNewt::CollisionPrimitives::Ellipsoid( m_World, Ogre::Vector3(1,1,1) );
+			OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( m_World, Ogre::Vector3(1,1,1) ));
 			OgreNewt::Body* body = new OgreNewt::Body( m_World, col );
 
 			Ogre::Vector3 inertia, offset;
             col->calculateInertialMatrix(inertia, offset);
 			body->setMassMatrix( 10.0, 10.0*inertia );
+            body->setCenterOfMass(offset);
 			body->attachNode( node );
 			body->setStandardForceCallback();
 			body->setPositionOrientation( pos, camorient );
 			body->setVelocity( (dir * 50.0) );
 
 			timer = 0.2;
+
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+            delete col;
+#endif
 		}
 	}
 	timer -= evt.timeSinceLastFrame;

Modified: dependencies/OgreNewt/demos/Demo08_RagdollExample/Ragdoll.cpp
===================================================================
--- dependencies/OgreNewt/demos/Demo08_RagdollExample/Ragdoll.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo08_RagdollExample/Ragdoll.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -8,7 +8,11 @@
 	mParent = parent;
 	mOgreBone = ogreBone;
 
-	OgreNewt::ConvexCollision* col = NULL;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+	OgreNewt::ConvexCollisionPtr col;
+#else
+	OgreNewt::ConvexCollisionPtr col = NULL;
+#endif
 
 	// in the case of the cylindrical primitives, they need to be rotated to align the main axis with the direction vector.
 	Ogre::Quaternion orient = Ogre::Quaternion::IDENTITY;
@@ -32,23 +36,23 @@
 	switch (shape)
 	{
 	case RagDoll::RagBone::BS_BOX:
-		col = new OgreNewt::CollisionPrimitives::Box( world, size );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size ));
 		break;
 
 	case RagDoll::RagBone::BS_CAPSULE:
-		col = new OgreNewt::CollisionPrimitives::Capsule( world, size.y, size.x, orient, pos );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Capsule( world, size.y, size.x, orient, pos ));
 		break;
 
 	case RagDoll::RagBone::BS_CONE:
-		col = new OgreNewt::CollisionPrimitives::Cone( world, size.y, size.x, orient, pos );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cone( world, size.y, size.x, orient, pos ));
 		break;
 
 	case RagDoll::RagBone::BS_CYLINDER:
-		col = new OgreNewt::CollisionPrimitives::Cylinder( world, size.y, size.x, orient, pos );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder( world, size.y, size.x, orient, pos ));
 		break;
 
 	case RagDoll::RagBone::BS_ELLIPSOID:
-		col = new OgreNewt::CollisionPrimitives::Ellipsoid( world, size );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( world, size ));
 		break;
 
 	case RagDoll::RagBone::BS_CONVEXHULL:
@@ -56,24 +60,31 @@
 		break;
 
 	default:
-		col = new OgreNewt::CollisionPrimitives::Box( world, size );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size ));
 		break;
 	}
 
 	mBody = new OgreNewt::Body( world, col );
-	mBody->setUserData( this );
+#ifdef OGRENEWT_USE_OGRE_ANY
+	mBody->setUserData( Ogre::Any(this) );
+#else
+    mBody->setUserData( this );
+#endif
 	mBody->setStandardForceCallback();
 
 	Ogre::Vector3 inertia;
-	Ogre::Vector3 com;
-	col->calculateInertialMatrix( inertia, com );
+	Ogre::Vector3 offset;
+	col->calculateInertialMatrix( inertia, offset );
 	
 	mBody->setMassMatrix( mass, inertia * mass );
-	mBody->setCenterOfMass( com );
+	mBody->setCenterOfMass( offset );
 
 	mBody->setCustomTransformCallback( RagDoll::_placementCallback );
 
 
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+    delete col;
+#endif
 }
 
 
@@ -86,7 +97,11 @@
 
 void RagDoll::RagBone::_hingeCallback( OgreNewt::BasicJoints::Hinge* me )
 {
+#ifdef OGRENEWT_USE_OGRE_ANY
+	RagDoll::RagBone* bone = Ogre::any_cast<RagDoll::RagBone*>(me->getUserData());
+#else
 	RagDoll::RagBone* bone = (RagDoll::RagBone*)me->getUserData();
+#endif
 
 	Ogre::Degree angle = me->getJointAngle();
 	Ogre::Degree lim1( bone->getLimit1() );
@@ -107,7 +122,7 @@
 }
 
 
-OgreNewt::ConvexCollision* RagDoll::RagBone::_makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight )
+OgreNewt::ConvexCollisionPtr RagDoll::RagBone::_makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight )
 {
 	std::vector< Ogre::Vector3 > vertexVector;
 
@@ -197,7 +212,7 @@
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////
-	OgreNewt::ConvexCollision* col = new OgreNewt::CollisionPrimitives::ConvexHull( world, verts, numVerts );
+	OgreNewt::ConvexCollisionPtr col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull( world, verts, numVerts ));
 
 	delete []verts;
 
@@ -390,7 +405,11 @@
 	case RagDoll::JT_HINGE:
 		joint = new OgreNewt::BasicJoints::Hinge( child->getBody()->getWorld(), child->getBody(), parent->getBody(), pos, pin );
 		((OgreNewt::BasicJoints::Hinge*)joint)->setCallback( RagBone::_hingeCallback );
-		joint->setUserData( child );
+#ifdef OGRENEWT_USE_OGRE_ANY
+	joint->setUserData( Ogre::Any(child) );
+#else
+	joint->setUserData( child );
+#endif
 		child->setLimits( limit1, limit2 );
 		break;
 	}
@@ -400,7 +419,11 @@
 
 void RagDoll::_placementCallback( OgreNewt::Body* me, const Ogre::Quaternion& orient, const Ogre::Vector3& pos, int threadindex )
 {
+#ifdef OGRENEWT_USE_OGRE_ANY
+	RagDoll::RagBone* bone = Ogre::any_cast<RagDoll::RagBone*>(me->getUserData());
+#else
 	RagDoll::RagBone* bone = (RagDoll::RagBone*)me->getUserData();
+#endif
 	RagDoll* doll = bone->getDoll();
 
 	// is this the root bone?

Modified: dependencies/OgreNewt/demos/Demo08_RagdollExample/Ragdoll.h
===================================================================
--- dependencies/OgreNewt/demos/Demo08_RagdollExample/Ragdoll.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/demos/Demo08_RagdollExample/Ragdoll.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -63,7 +63,7 @@
 
 	private:
 
-		OgreNewt::ConvexCollision* _makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight );
+		OgreNewt::ConvexCollisionPtr _makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight );
 
 		// pointer to the doll to which this bone belongs.
 		RagDoll* mDoll;

Modified: dependencies/OgreNewt/inc/OgreNewt.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -64,13 +64,14 @@
             - joints
             - collision-serializer
             - treecollision raycastcallback 
-        - shared pointers for collisions (atm CollisionPtr := Collision*, but should be Ogre::SharedPtr<Collision>, but there was some problem...)
 
 
     \section new New in this version
 
     New in this version
         - this version uses cmake > 2.6.2!
+        - shared pointers for collisions, in order to use shared pointers define OGRENEWT_COLLISION_USE_SHAREDPTR
+        - support for Ogre::Any instead of void* as userdata, in order to use it, define OGRENEWT_USE_OGRE_ANY
         - several interface-breaking changes:
             - the ContactCallback passes a ContactJoint as argument that can be used to iterate through all contacts
               (the callback is not called for each contact any more, but for each pair of colliding bodies!)

Modified: dependencies/OgreNewt/inc/OgreNewt_BasicFrameListener.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_BasicFrameListener.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_BasicFrameListener.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -29,9 +29,7 @@
 namespace OgreNewt
 {
 
-class World;
 
-
 //! simple frame listener to update the physics.
 /*!
     updates the Newton World at the specified rate, with time-slicing, and

Modified: dependencies/OgreNewt/inc/OgreNewt_Body.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Body.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_Body.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -20,17 +20,12 @@
 #include "OgreNewt_Prerequisites.h"
 #include "OgreNewt_MaterialID.h"
 #include "OgreNewt_Collision.h"
-#include <boost/function.hpp>
-#include <boost/bind.hpp>
 
 
 // OgreNewt namespace.  all functions and classes use this namespace.
 namespace OgreNewt
 {
 
-class World;
-class MaterialID;
-
 /*
     CLASS DEFINITION:
 
@@ -82,7 +77,7 @@
         \param col pointer to an OgreNewt::Collision object that represents the shape of the rigid body.
         \param bodytype simple integer value used to identify the type of rigid body, useful for determining bodies in callbacks.
     */
-    Body( const World* W, const OgreNewt::Collision* col, int bodytype = 0 );
+    Body( const World* W, const OgreNewt::CollisionPtr& col, int bodytype = 0 );
 
     //! destructor
     ~Body();
@@ -92,10 +87,18 @@
         you can use this to store a pointer to a parent class, etc.  then inside one of the many callbacks, you can get the pointer
         using this "userData" system.
     */
+#ifdef OGRENEWT_USE_OGRE_ANY
+    void setUserData( const Ogre::Any& data ) { m_userdata = data; }
+#else
     void setUserData( void* data ) { m_userdata = data; }
+#endif
 
     //! retrieve pointer to previously set user data.
+#ifdef OGRENEWT_USE_OGRE_ANY
+    const Ogre::Any& getUserData() const { return m_userdata; }
+#else
     void* getUserData() const { return m_userdata; }
+#endif
 
     //! get a pointer to the NewtonBody object
     /*!
@@ -260,7 +263,7 @@
         This can be used to change the collision shape of a body mid-simulation.  for example making the collision for a character smaller when crouching, etc.
         \param col pointer to the new OgreNewt::Collision shape.
     */
-    void setCollision( const OgreNewt::Collision* col );
+    void setCollision( const OgreNewt::CollisionPtr& col );
 
     //! set whether the body should "sleep" when equilibruim is reached.
     /*!
@@ -275,7 +278,7 @@
     //void setFreezeThreshold( Ogre::Real speed, Ogre::Real omega, int framecount ) { NewtonBodySetFreezeTreshold( m_body, (float)speed, (float)omega, framecount ); }
 
     //! get a pointer to the OgreNewt::Collision for this body
-    const OgreNewt::Collision* getCollision() const;
+    const OgreNewt::CollisionPtr& getCollision() const;
 
     //! get a pointer to the Material assigned to this body.
     const OgreNewt::MaterialID* getMaterialGroupID() const;
@@ -398,7 +401,7 @@
     /*!
      * usually it is also possible to get this via: body->getCollision()->getCollisionPrimitiveType()
     */
-    CollisionPrimitive getCollisionPrimitiveType() const { return Collision::getCollisionPrimitiveType(getNewtonCollision()); }
+    CollisionPrimitiveType getCollisionPrimitiveType() const { return Collision::getCollisionPrimitiveType(getNewtonCollision()); }
 
     //! Returns the Newton Collision for this Body
     /*!
@@ -408,20 +411,23 @@
 
 protected:
 
-    NewtonBody*         m_body;
-    const Collision*    m_collision;
-    const MaterialID*   m_matid;
-    const World*        m_world;
+    NewtonBody*                     m_body;
+    OgreNewt::CollisionPtr          m_collision;
+    const MaterialID*               m_matid;
+    const World*                    m_world;
     
-
-    void*               m_userdata;
+#ifdef OGRENEWT_USE_OGRE_ANY
+    Ogre::Any                       m_userdata;
+#else
+    void*                           m_userdata;
+#endif
     
-    int                 m_type;
-    Ogre::Node*         m_node;
+    int                             m_type;
+    Ogre::Node*                     m_node;
 
-    ForceCallback           m_forcecallback;
-    TransformCallback       m_transformcallback;
-    buoyancyPlaneCallback   m_buoyancycallback;
+    ForceCallback                   m_forcecallback;
+    TransformCallback               m_transformcallback;
+    buoyancyPlaneCallback           m_buoyancycallback;
 
 private:
 

Modified: dependencies/OgreNewt/inc/OgreNewt_BodyInAABBIterator.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_BodyInAABBIterator.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_BodyInAABBIterator.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -15,17 +15,12 @@
 
 
 #include "OgreNewt_Prerequisites.h"
-#include <boost/function.hpp>
-#include <boost/bind.hpp>
 
 // OgreNewt namespace.  all functions and classes use this namespace.
 namespace OgreNewt
 {
 
-class World;
-class Body;
 
-
 //! Iterate through all bodies in a specific AABB in the world.
 /*!
     this class is an easy way to loop through all bodies in an AABB in the world, performing some kind of action.

Modified: dependencies/OgreNewt/inc/OgreNewt_Collision.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Collision.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_Collision.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -14,30 +14,28 @@
 
 
 #include "OgreNewt_Prerequisites.h"
-#include "OgreNewt_World.h"
-#include "OgreNewt_CollisionSerializer.h"
 
+
 // OgreNewt namespace.  all functions and classes use this namespace.
 namespace OgreNewt
 {
 
-class World;
 
-enum _OgreNewtExport CollisionPrimitive
+enum _OgreNewtExport CollisionPrimitiveType
 {
-    BoxPrimitive                =   SERIALIZE_ID_BOX,
-    ConePrimitive               =   SERIALIZE_ID_CONE,
-    EllipsoidPrimitive          =   SERIALIZE_ID_SPHERE,
-    CapsulePrimitive            =   SERIALIZE_ID_CAPSULE,
-    CylinderPrimitive           =   SERIALIZE_ID_CYLINDER,
-    CompoundCollisionPrimitive  =   SERIALIZE_ID_COMPOUND,
-    ConvexHullPrimitive         =   SERIALIZE_ID_CONVEXHULL,
-    ConvexHullModifierPrimitive =   SERIALIZE_ID_CONVEXMODIFIER,
-    ChamferCylinderPrimitive    =   SERIALIZE_ID_CHAMFERCYLINDER,
-    TreeCollisionPrimitive      =   SERIALIZE_ID_TREE,
-    NullPrimitive               =   SERIALIZE_ID_NULL,
-    HeighFieldPrimitive         =   SERIALIZE_ID_HEIGHTFIELD,
-    ScenePrimitive              =   SERIALIZE_ID_SCENE
+    BoxPrimitiveType                =   SERIALIZE_ID_BOX,
+    ConePrimitiveType               =   SERIALIZE_ID_CONE,
+    EllipsoidPrimitiveType          =   SERIALIZE_ID_SPHERE,
+    CapsulePrimitiveType            =   SERIALIZE_ID_CAPSULE,
+    CylinderPrimitiveType           =   SERIALIZE_ID_CYLINDER,
+    CompoundCollisionPrimitiveType  =   SERIALIZE_ID_COMPOUND,
+    ConvexHullPrimitiveType         =   SERIALIZE_ID_CONVEXHULL,
+    ConvexHullModifierPrimitiveType =   SERIALIZE_ID_CONVEXMODIFIER,
+    ChamferCylinderPrimitiveType    =   SERIALIZE_ID_CHAMFERCYLINDER,
+    TreeCollisionPrimitiveType      =   SERIALIZE_ID_TREE,
+    NullPrimitiveType               =   SERIALIZE_ID_NULL,
+    HeighFieldPrimitiveType         =   SERIALIZE_ID_HEIGHTFIELD,
+    ScenePrimitiveType              =   SERIALIZE_ID_SCENE
 };
 
 /*
@@ -82,20 +80,21 @@
     unsigned getUserID() const { return NewtonCollisionGetUserID( m_col ); }
 
     //! make unique
-    void makeUnique() { NewtonCollisionMakeUnique( m_world->getNewtonWorld(), m_col ); }
+    void makeUnique();
 
     //! get the Axis-Aligned Bounding Box for this collision shape.
     Ogre::AxisAlignedBox getAABB( const Ogre::Quaternion& orient = Ogre::Quaternion::IDENTITY, const Ogre::Vector3& pos = Ogre::Vector3::ZERO ) const;
 
     //! Returns the Collisiontype for this Collision
-    CollisionPrimitive getCollisionPrimitiveType() const { return getCollisionPrimitiveType( m_col ); } 
+    CollisionPrimitiveType getCollisionPrimitiveType() const { return getCollisionPrimitiveType( m_col ); } 
 
     //! Returns the Collisiontype for the given Newton-Collision
-    static CollisionPrimitive getCollisionPrimitiveType(const NewtonCollision *col);
+    static CollisionPrimitiveType getCollisionPrimitiveType(const NewtonCollision *col);
 
     //! friend functions for the Serializer
-    friend void CollisionSerializer::exportCollision(const Collision* collision, const Ogre::String& filename);
-    friend void CollisionSerializer::importCollision(Ogre::DataStreamPtr& stream, Collision* pDest);
+    friend class OgreNewt::CollisionSerializer;
+    //friend void CollisionSerializer::exportCollision(const CollisionPtr& collision, const Ogre::String& filename);
+    //friend CollisionPtr CollisionSerializer::importCollision(Ogre::DataStreamPtr& stream, OgreNewt::World* world);
 
 protected:
 
@@ -104,9 +103,8 @@
 
 };
 
-//typedef Ogre::SharedPtr<Collision> CollisionPtr;
-typedef Collision* CollisionPtr;
 
+
 //! represents a collision shape that is explicitly convex.
 class _OgreNewtExport ConvexCollision : public Collision
 {
@@ -135,14 +133,31 @@
 };
 
 
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+typedef boost::shared_ptr<Collision> CollisionPtr;
+typedef boost::shared_ptr<ConvexCollision> ConvexCollisionPtr;
+#else
+typedef Collision* CollisionPtr;
+typedef ConvexCollision* ConvexCollisionPtr;
+#endif
 
+
+
+
 //! represents a scalable collision shape.
-class _OgreNewtExport ConvexModifierCollision : public Collision
+class _OgreNewtExport ConvexModifierCollision : public ConvexCollision
 {
 public:
     //! constructor
-    ConvexModifierCollision( const OgreNewt::World* world, const OgreNewt::Collision* col );
+    /*!
+      Create a 'blank' box collision object.  Can be used for CollisionSerializer::importCollision
+      \param world pointer to the OgreNewt::World
+    */
+    ConvexModifierCollision( const OgreNewt::World* world );
 
+    //! constructor
+    ConvexModifierCollision( const OgreNewt::World* world, const OgreNewt::ConvexCollisionPtr col );
+
     //! destructor
     ~ConvexModifierCollision();
 

Modified: dependencies/OgreNewt/inc/OgreNewt_CollisionPrimitives.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_CollisionPrimitives.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_CollisionPrimitives.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -388,7 +388,7 @@
                 \param world pointer to the OgreNewt::World
                 \param col_array std::vector of pointers to existing collision objects.
             */
-            CompoundCollision( const World* world, std::vector<OgreNewt::Collision*> col_array );
+            CompoundCollision( const World* world, std::vector<OgreNewt::CollisionPtr> col_array );
 
             //! destructor
             ~CompoundCollision() {}

Modified: dependencies/OgreNewt/inc/OgreNewt_CollisionSerializer.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_CollisionSerializer.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_CollisionSerializer.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -14,12 +14,11 @@
 
 
 #include "OgreNewt_Prerequisites.h"
+#include "OgreNewt_Collision.h"
 
 // OgreNewt namespace.  all functions and classes use this namespace.
 namespace OgreNewt
 {
-    class Collision;
-
   /*!
   This class can be used to (de)serialize a Collision. Pre-building a Collision and serializing from a tool,
   then deserializing it at runtime may be more efficient than building the Collision on the fly, especially for complex objects.
@@ -37,13 +36,13 @@
     /*!
     Serialize the Collision to a file with the given name.
     */
-    void exportCollision(const Collision* collision, const Ogre::String& filename);
+    void exportCollision(const OgreNewt::CollisionPtr& collision, const Ogre::String& filename);
 
     /*!
     Deserialize the Collision from a DataStream.
     this will create a NEW Collision object
     */
-    void importCollision(Ogre::DataStreamPtr& stream, Collision* pDest);
+    OgreNewt::CollisionPtr importCollision(Ogre::DataStreamPtr& stream, OgreNewt::World* world);
 
   private:
     /*!

Modified: dependencies/OgreNewt/inc/OgreNewt_ContactCallback.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_ContactCallback.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_ContactCallback.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -20,7 +20,6 @@
 namespace OgreNewt
 {
 
-class Body;
 
 //! custom contact behavior
 /*!

Modified: dependencies/OgreNewt/inc/OgreNewt_ContactJoint.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_ContactJoint.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_ContactJoint.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -20,8 +20,6 @@
 namespace OgreNewt
 {
 
-class Contact;
-class MaterialPair;
 
 //! with this class you can iterate through all contacts
 /*!

Modified: dependencies/OgreNewt/inc/OgreNewt_Debugger.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Debugger.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_Debugger.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -25,10 +25,6 @@
 namespace OgreNewt
 {
 
-    class World;
-    class Body;
-    class MaterialID;
-    class Collision;
 
     //! For viewing the Newton rigid bodies visually.
     /*!
@@ -90,7 +86,7 @@
         void addRay(const Ogre::Vector3 &startpt, const Ogre::Vector3 &endpt);
 
         //! this function is used internally
-        void addConvexRay(const OgreNewt::Collision* col, const Ogre::Vector3 &startpt, const Ogre::Quaternion &colori, const Ogre::Vector3 &endpt);
+        void addConvexRay(const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3 &startpt, const Ogre::Quaternion &colori, const Ogre::Vector3 &endpt);
 
         //! this function is used internally
         void addDiscardedBody(const OgreNewt::Body* body);
@@ -117,8 +113,12 @@
 
         struct BodyDebugData
         {
-            BodyDebugData() : m_lastcol(NULL), m_node(NULL), m_lines(NULL), m_text(NULL), m_updated(false) {}
-            const Collision* m_lastcol;
+            BodyDebugData() :
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+                m_lastcol(NULL),
+#endif
+                m_node(NULL), m_lines(NULL), m_text(NULL), m_updated(false) {}
+            CollisionPtr m_lastcol;
             Ogre::SceneNode* m_node;
             Ogre::ManualObject* m_lines;
             OgreNewt::OgreAddons::MovableText* m_text;

Modified: dependencies/OgreNewt/inc/OgreNewt_Joint.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Joint.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_Joint.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -20,8 +20,6 @@
 namespace OgreNewt
 {
 
-class World;
-class Body;
 
 //! base class for all joints.
 /*!
@@ -71,22 +69,35 @@
     /*!
         user data can be used to connect this class to other user classes through the use of this general pointer.
     */
-    void setUserData( void* ptr ) { m_userdata = ptr; }
+#ifdef OGRENEWT_USE_OGRE_ANY
+    void setUserData( const Ogre::Any& data ) { m_userdata = data; }
+#else
+    void setUserData( void* data ) { m_userdata = data; }
+#endif
 
     //! get user data for this joint
     /*!
         user data can be used to connect this class to other user classes through the use of this general pointer.
     */
+#ifdef OGRENEWT_USE_OGRE_ANY
+    const Ogre::Any& getUserData() const { return m_userdata; }
+#else
     void* getUserData() const { return m_userdata; }
+#endif
 
-        
+ 
 protected:
 
     NewtonJoint* m_joint;
     const OgreNewt::World* m_world;
 
-    void* m_userdata;
 
+#ifdef OGRENEWT_USE_OGRE_ANY
+    Ogre::Any                       m_userdata;
+#else
+    void*                           m_userdata;
+#endif
+
     static void _CDECL destructor( const NewtonJoint* me );
 
 };

Modified: dependencies/OgreNewt/inc/OgreNewt_MaterialID.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_MaterialID.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_MaterialID.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -19,7 +19,6 @@
 namespace OgreNewt
 {
 
-class World;
 
 //! represents a material
 class _OgreNewtExport MaterialID

Modified: dependencies/OgreNewt/inc/OgreNewt_PlayerController.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_PlayerController.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_PlayerController.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -21,9 +21,6 @@
 namespace OgreNewt
 {
 
-class Collision;
-class ConvexCollision;
-
 //! PlayerController
 /*!
     this class implements a player-controller based on the code of the CustomPlayerController-class in the Newton-CustomJoints library
@@ -85,9 +82,9 @@
     Ogre::Vector3 m_upVector;
 
     bool m_isInJumpState;
-    OgreNewt::ConvexCollision* m_verticalSensorShape;
-    OgreNewt::ConvexCollision* m_horizontalSensorShape;
-    OgreNewt::ConvexCollision* m_dynamicsSensorShape;
+    OgreNewt::ConvexCollisionPtr m_verticalSensorShape;
+    OgreNewt::ConvexCollisionPtr m_horizontalSensorShape;
+    OgreNewt::ConvexCollisionPtr m_dynamicsSensorShape;
 
     virtual bool convexStaticCastPreFilter(OgreNewt::Body *body);
     virtual bool convexDynamicCastPreFilter(OgreNewt::Body *body);
@@ -133,7 +130,7 @@
         public:
             StaticConvexCast(PlayerController *pc) : m_parent(pc) {}
 
-            void go(const OgreNewt::Collision* col, const Ogre::Vector3& startpt,
+            void go(const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3& startpt,
                     const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int thread)
             {
                 go(m_parent->getControlledBody()->getWorld(), col, startpt, colori, endpt, maxcontactscount, thread);
@@ -150,7 +147,7 @@
         public:
             DynamicConvexCast(PlayerController *pc) : m_parent(pc) {}
 
-            void go(const OgreNewt::Collision* col, const Ogre::Vector3& startpt,
+            void go(const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3& startpt,
                     const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int thread)
             {
                 go(m_parent->getControlledBody()->getWorld(), col, startpt, colori, endpt, maxcontactscount, thread);
@@ -167,7 +164,7 @@
         public:
             AllBodyConvexCast(PlayerController *pc) : m_parent(pc) {}
 
-            void go(const OgreNewt::Collision* col, const Ogre::Vector3& startpt,
+            void go(const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3& startpt,
                     const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int thread)
             {
                 go(m_parent->getControlledBody()->getWorld(), col, startpt, colori, endpt, maxcontactscount, thread);

Modified: dependencies/OgreNewt/inc/OgreNewt_Prerequisites.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Prerequisites.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_Prerequisites.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -22,6 +22,12 @@
 #   include <Ogre/OgreRenderable.h>
 #   include <Ogre/OgreNode.h>
 #   include <Ogre/OgreFrameListener.h>
+#   ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+//#       include <Ogre/OgreSharedPtr.h>
+#   endif
+#   ifdef OGRENEWT_USE_OGRE_ANY
+#       include <Ogre/OgreAny.h>
+#   endif
 #else
 #include <OgreVector3.h>
 #include <OgreQuaternion.h>
@@ -29,9 +35,20 @@
 #include <OgreRenderable.h>
 #include <OgreNode.h>
 #include <OgreFrameListener.h>
+#   ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+//#       include <OgreSharedPtr.h>
+#   endif
+#   ifdef OGRENEWT_USE_OGRE_ANY
+#       include <OgreAny.h>
+#   endif
 #endif
 
 #include <Newton.h>
+#include <boost/function.hpp>
+#include <boost/bind.hpp>
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+#   include <boost/shared_ptr.hpp>
+#endif
 
 #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
 #   define _CDECL _cdecl
@@ -47,5 +64,28 @@
 #   define _CDECL
 #endif
 
+
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+#warning "the option OGRENEWT_COLLISION_USE_SHAREDPTR is set"
+#endif
+
+#ifdef OGRENEWT_USE_OGRE_ANY
+#warning "the option OGRENEWT_USE_OGRE_ANY is set"
+#endif
+
+namespace OgreNewt
+{
+    class World;
+    class MaterialID;
+    class Joint;
+    class Contact;
+    class MaterialPair;
+    class Body;
+    class Collision;
+    class CollisionSerializer;
+    class ConvexCollision;
+    class Debugger;
+}
+
 #endif 
 

Modified: dependencies/OgreNewt/inc/OgreNewt_RayCast.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_RayCast.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_RayCast.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -21,8 +21,6 @@
 namespace OgreNewt
 {
 
-class World;
-class Body;
 
 //! general raycast
 /*!
@@ -186,7 +184,7 @@
         \param maxcontactscount maximum number of contacts that should be saved,
                set to 0 if you only need the distance to the first intersection
     */
-    void go( const OgreNewt::World* world, const OgreNewt::Collision* col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int threadIndex);
+    void go( const OgreNewt::World* world, const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int threadIndex);
 
     //! user callback pre-filter function.
     /*!
@@ -254,7 +252,7 @@
         \param endpt ending point of ray in global space
         \param maxcontactscount maximum number of contacts that should be saved        
     */
-    BasicConvexcast( const OgreNewt::World* world, const OgreNewt::Collision* col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int threadIndex);
+    BasicConvexcast( const OgreNewt::World* world, const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int threadIndex);
 
     //! destuctor.
     ~BasicConvexcast();

Modified: dependencies/OgreNewt/inc/OgreNewt_Tools.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Tools.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_Tools.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -14,12 +14,12 @@
 
 
 #include "OgreNewt_Prerequisites.h"
+#include "OgreNewt_Collision.h"
 
 namespace OgreNewt
 {
-    class World;
-    class Collision;
 
+
     //! set of handy convertors.
     namespace Converters
     {
@@ -70,7 +70,7 @@
             \param retnormal returned normal on the collision primitive in global space
         */
         _OgreNewtExport int CollisionPointDistance( const OgreNewt::World* world, const Ogre::Vector3& globalpt, 
-                                    const OgreNewt::Collision* col, const Ogre::Quaternion& colorient, const Ogre::Vector3& colpos, 
+                                    const OgreNewt::CollisionPtr& col, const Ogre::Quaternion& colorient, const Ogre::Vector3& colpos, 
                                     Ogre::Vector3& retpt, Ogre::Vector3& retnormal, int threadIndex );
                                     
 
@@ -88,8 +88,8 @@
             \param retPosB returned position on collision primitive B
             \param retNorm returned collision normal
         */
-        _OgreNewtExport int CollisionClosestPoint( const OgreNewt::World* world, const OgreNewt::Collision* colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA,
-                                                            const OgreNewt::Collision* colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB,
+        _OgreNewtExport int CollisionClosestPoint( const OgreNewt::World* world, const OgreNewt::CollisionPtr& colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA,
+                                                            const OgreNewt::CollisionPtr& colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB,
                                                             Ogre::Vector3& retPosA, Ogre::Vector3& retPosB, Ogre::Vector3& retNorm, int threadIndex );
 
 
@@ -110,8 +110,8 @@
             \param retPenetrations returned penetrations for each contact.
         */
         _OgreNewtExport int CollisionCollide(  const OgreNewt::World* world, int maxSize, 
-            const OgreNewt::Collision* colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA,
-            const OgreNewt::Collision* colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB,
+            const OgreNewt::CollisionPtr& colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA,
+            const OgreNewt::CollisionPtr& colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB,
             Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex );
 
 
@@ -137,8 +137,8 @@
             \param retPenetrations returned penetrations for each contact.
         */
         _OgreNewtExport int CollisionCollideContinue( const OgreNewt::World* world, int maxSize, Ogre::Real timeStep,
-            const OgreNewt::Collision* colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA, const Ogre::Vector3& colVelA, const Ogre::Vector3& colOmegaA,
-            const OgreNewt::Collision* colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB, const Ogre::Vector3& colVelB, const Ogre::Vector3& colOmegaB,
+            const OgreNewt::CollisionPtr& colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA, const Ogre::Vector3& colVelA, const Ogre::Vector3& colOmegaA,
+            const OgreNewt::CollisionPtr& colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB, const Ogre::Vector3& colVelB, const Ogre::Vector3& colOmegaB,
             Ogre::Real& retTimeOfImpact, Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex );
 
 
@@ -152,7 +152,7 @@
             \param normal returned normal where the ray hit the collision.
             \param colID returned ID of the collision primitive hit.
         */
-        _OgreNewtExport Ogre::Real CollisionRayCast( const OgreNewt::Collision* col, const Ogre::Vector3& startPt, const Ogre::Vector3& endPt, 
+        _OgreNewtExport Ogre::Real CollisionRayCast( const OgreNewt::CollisionPtr& col, const Ogre::Vector3& startPt, const Ogre::Vector3& endPt, 
                                                         Ogre::Vector3& retNorm, int& retColID );
                 
 
@@ -163,7 +163,7 @@
             \param orient world orientation of the collision.
             \param pos world position of the collision.
         */
-        _OgreNewtExport Ogre::AxisAlignedBox CollisionCalculateAABB( const OgreNewt::Collision* col, const Ogre::Quaternion& orient, const Ogre::Vector3& pos );
+        _OgreNewtExport Ogre::AxisAlignedBox CollisionCalculateAABB( const OgreNewt::CollisionPtr& col, const Ogre::Quaternion& orient, const Ogre::Vector3& pos );
 
     }   // end namespace "ColliionTools"
 

Modified: dependencies/OgreNewt/inc/OgreNewt_Vehicle.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_Vehicle.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_Vehicle.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -18,8 +18,8 @@
 
 namespace OgreNewt
 {
-    class Body;
-    class World;
+
+
 #ifdef INCLUDE_VEHICLE
 //! Represents a wheeled vehicle
 /*!

Modified: dependencies/OgreNewt/inc/OgreNewt_World.h
===================================================================
--- dependencies/OgreNewt/inc/OgreNewt_World.h	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/inc/OgreNewt_World.h	2009-04-07 22:24:33 UTC (rev 4889)
@@ -15,8 +15,6 @@
 #include "OgreNewt_Prerequisites.h"
 #include "OgreNewt_BodyInAABBIterator.h"
 #include "OgreNewt_Debugger.h"
-#include <boost/function.hpp>
-#include <boost/bind.hpp>
 
 //! main namespace.
 /*!
@@ -26,10 +24,6 @@
 {
 
 
-class Body;
-class MaterialID;
-
-
 //! represents a physics world.
 /*!
     this class represents a NewtonWorld, which is the basic space in which physics elements can exist.  It can have various Rigid Bodies, connected by joints, and other constraints.

Modified: dependencies/OgreNewt/src/OgreNewt_Body.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Body.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/src/OgreNewt_Body.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -8,7 +8,7 @@
 {
 
     
-Body::Body( const World* W, const OgreNewt::Collision* col, int bodytype ) 
+Body::Body( const World* W, const OgreNewt::CollisionPtr& col, int bodytype ) 
 {
     m_world = W;
     m_collision = col;
@@ -204,7 +204,7 @@
 }
 
 //set collision
-void Body::setCollision( const OgreNewt::Collision* col )
+void Body::setCollision( const OgreNewt::CollisionPtr& col )
 {
     NewtonBodySetCollision( m_body, col->getNewtonCollision() );
 
@@ -212,7 +212,7 @@
 }
 
 //get collision
-const OgreNewt::Collision* Body::getCollision() const
+const OgreNewt::CollisionPtr& Body::getCollision() const
 {
     return m_collision;
 }

Modified: dependencies/OgreNewt/src/OgreNewt_Collision.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Collision.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/src/OgreNewt_Collision.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -1,4 +1,5 @@
 #include "OgreNewt_Collision.h"
+#include "OgreNewt_World.h"
 #include "OgreNewt_Tools.h"
 
 
@@ -18,6 +19,12 @@
 }
 
 
+void Collision::makeUnique()
+{
+    NewtonCollisionMakeUnique( m_world->getNewtonWorld(), m_col );
+}
+
+
 Ogre::AxisAlignedBox Collision::getAABB( const Ogre::Quaternion& orient, const Ogre::Vector3& pos ) const
 {
     Ogre::AxisAlignedBox box;
@@ -34,13 +41,13 @@
     return box;
 }
 
-CollisionPrimitive Collision::getCollisionPrimitiveType(const NewtonCollision *col)
+CollisionPrimitiveType Collision::getCollisionPrimitiveType(const NewtonCollision *col)
 {
     NewtonCollisionInfoRecord *info = new NewtonCollisionInfoRecord();
 
     NewtonCollisionGetInfo( col, info );
 
-    return static_cast<CollisionPrimitive>(info->m_collisionType);
+    return static_cast<CollisionPrimitiveType>(info->m_collisionType);
 }
 
 
@@ -55,8 +62,13 @@
 
 
 
-ConvexModifierCollision::ConvexModifierCollision(const World* world, const Collision* col) : Collision(world)
+
+ConvexModifierCollision::ConvexModifierCollision(const World* world) : ConvexCollision(world)
 {
+}
+
+ConvexModifierCollision::ConvexModifierCollision(const World* world, const ConvexCollisionPtr col) : ConvexCollision(world)
+{
     m_col = NewtonCreateConvexHullModifier( world->getNewtonWorld(), col->getNewtonCollision() );
 }
 

Modified: dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/src/OgreNewt_CollisionPrimitives.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -1,6 +1,7 @@
 #include "OgreNewt_CollisionPrimitives.h"
 #include "OgreNewt_Tools.h"
 #include "OgreNewt_RayCast.h"
+#include "OgreNewt_World.h"
 
 #ifdef __APPLE__
 #   include <Ogre/OgreEntity.h>
@@ -719,7 +720,7 @@
         CompoundCollision::CompoundCollision(const World* world) : Collision( world )
         {}
         
-        CompoundCollision::CompoundCollision( const World* world, std::vector<OgreNewt::Collision*> col_array ) : Collision( world )
+        CompoundCollision::CompoundCollision( const World* world, std::vector<OgreNewt::CollisionPtr> col_array ) : Collision( world )
         {
             //get the number of elements.
             unsigned int num = col_array.size();

Modified: dependencies/OgreNewt/src/OgreNewt_CollisionSerializer.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_CollisionSerializer.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/src/OgreNewt_CollisionSerializer.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -1,5 +1,6 @@
 #include "OgreNewt_CollisionSerializer.h"
-#include "OgreNewt_Collision.h"
+#include "OgreNewt_CollisionPrimitives.h"
+#include "OgreNewt_World.h"
 
 namespace OgreNewt
 {
@@ -13,38 +14,76 @@
   }
 
 
-  void CollisionSerializer::exportCollision(const Collision* collision, const Ogre::String& filename)
+  void CollisionSerializer::exportCollision(const CollisionPtr& collision, const Ogre::String& filename)
   {
-    if( collision )
+    if( !collision )
+        OGRE_EXCEPT(Ogre::Exception::ERR_INVALIDPARAMS, "Argument collision is NULL","CollisionSerializer::exportCollision");
+
+    mpfFile=fopen(filename.c_str(),"wb");
+    
+    if (!mpfFile)
     {
-        mpfFile=fopen(filename.c_str(),"wb");
-    
-        if (!mpfFile)
-        {
-          OGRE_EXCEPT(Ogre::Exception::ERR_INVALIDPARAMS, "Unable to open file " + filename + " for writing","CollisionSerializer::exportCollision");
-        }
-    
-        NewtonCollisionSerialize(collision->getWorld()->getNewtonWorld(), collision->m_col, &CollisionSerializer::_newtonSerializeCallback, this);
+        OGRE_EXCEPT(Ogre::Exception::ERR_INVALIDPARAMS, "Unable to open file " + filename + " for writing","CollisionSerializer::exportCollision");
+    }
 
-        fclose(mpfFile);
-    }
+    NewtonCollisionSerialize(collision->getWorld()->getNewtonWorld(), collision->m_col, &CollisionSerializer::_newtonSerializeCallback, this);
+
+
+    fclose(mpfFile);
   }
 
 
-  void CollisionSerializer::importCollision(Ogre::DataStreamPtr& stream, Collision* pDest)
+  CollisionPtr CollisionSerializer::importCollision(Ogre::DataStreamPtr& stream, OgreNewt::World* world)
   {
-    if( pDest )
-    {
-        if( pDest->m_col )
-        {
-            // we need an error here!!
-            NewtonReleaseCollision(pDest->m_world->getNewtonWorld(), pDest->m_col);
-        }
+      CollisionPtr dest;
 
-        NewtonCollision* col = NewtonCreateCollisionFromSerialization(pDest->getWorld()->getNewtonWorld(), &CollisionSerializer::_newtonDeserializeCallback, &stream);
+      NewtonCollision* col = NewtonCreateCollisionFromSerialization(world->getNewtonWorld(), &CollisionSerializer::_newtonDeserializeCallback, &stream);
 
-        pDest->m_col = col;
-    }
+      // the type doesn't really matter... but lets do it correctly
+      switch( Collision::getCollisionPrimitiveType(col) )
+      {
+          case BoxPrimitiveType:
+              dest = CollisionPtr(new CollisionPrimitives::Box(world));
+              break;
+          case ConePrimitiveType:
+              dest = CollisionPtr(new CollisionPrimitives::Cone(world));
+              break;
+          case EllipsoidPrimitiveType:
+              dest = CollisionPtr(new CollisionPrimitives::Ellipsoid(world));
+              break;
+          case CapsulePrimitiveType:
+              dest = CollisionPtr(new CollisionPrimitives::Capsule(world));
+              break;
+          case CylinderPrimitiveType:
+              dest = CollisionPtr(new CollisionPrimitives::Cylinder(world));
+              break;
+          case CompoundCollisionPrimitiveType:
+              dest = CollisionPtr(new CollisionPrimitives::CompoundCollision(world));
+              break;
+          case ConvexHullPrimitiveType:
+              dest = CollisionPtr(new CollisionPrimitives::ConvexHull(world));
+              break;
+          case ConvexHullModifierPrimitiveType:
+              dest = CollisionPtr(new ConvexModifierCollision(world));
+              break;
+          case ChamferCylinderPrimitiveType:
+              dest = CollisionPtr(new CollisionPrimitives::ChamferCylinder(world));
+              break;
+          case TreeCollisionPrimitiveType:
+              dest = CollisionPtr(new CollisionPrimitives::TreeCollision(world));
+              break;
+          case NullPrimitiveType:
+              dest = CollisionPtr(new CollisionPrimitives::Null(world));
+              break;
+          case HeighFieldPrimitiveType:
+          case ScenePrimitiveType:
+          default:
+              dest = CollisionPtr(new Collision(world));
+      }
+
+      dest->m_col = col;
+
+      return dest;
   }
 
 

Modified: dependencies/OgreNewt/src/OgreNewt_Debugger.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Debugger.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/src/OgreNewt_Debugger.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -350,7 +350,7 @@
     m_raycastsnode->attachObject(line);    
 }
 
-void Debugger::addConvexRay(const OgreNewt::Collision* col, const Ogre::Vector3 &startpt, const Ogre::Quaternion &colori, const Ogre::Vector3 &endpt)
+void Debugger::addConvexRay(const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3 &startpt, const Ogre::Quaternion &colori, const Ogre::Vector3 &endpt)
 {
     if (!m_raycastsnode)
         return;

Modified: dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/src/OgreNewt_PlayerController.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -40,9 +40,11 @@
     m_floorFinderRadiusFactor = 1.0f;
     m_maxPlayerHeightPaddFactor = 0.01f;
     m_sensorShapeSegments = 32;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
     m_verticalSensorShape = NULL;
     m_horizontalSensorShape = NULL;
     m_dynamicsSensorShape = NULL;
+#endif
 
 
     updateSensorShapes();
@@ -50,13 +52,14 @@
 
 PlayerController::~PlayerController()
 {
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
     if( m_verticalSensorShape )
         delete m_verticalSensorShape;
     if( m_horizontalSensorShape )
         delete m_horizontalSensorShape;
     if( m_dynamicsSensorShape )
-        delete m_dynamicsSensorShape
-;
+        delete m_dynamicsSensorShape;
+#endif
 }
 
 void PlayerController::updateSensorShapes()
@@ -83,6 +86,7 @@
         abs( newSensorHeight - m_lastSensorHeight ) > 0.04f ||
         abs( newPlayerRadius - m_lastPlayerRadius ) > 0.04f )
     {
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
         // delete old ones
         if( m_verticalSensorShape )
             delete m_verticalSensorShape;
@@ -90,6 +94,7 @@
             delete m_horizontalSensorShape;
         if( m_dynamicsSensorShape )
             delete m_dynamicsSensorShape;
+#endif
 
         m_lastPlayerRadius = newPlayerRadius;
         m_lastSensorHeight = newSensorHeight;
@@ -126,9 +131,9 @@
             horizontalSensorPoints[i + m_sensorShapeSegments].z =  horizontalSensorPoints[i].z;
         }
 
-        m_verticalSensorShape = new OgreNewt::CollisionPrimitives::ConvexHull(m_body->getWorld(), verticalSensorPoints, 2*m_sensorShapeSegments);
-        m_horizontalSensorShape = new OgreNewt::CollisionPrimitives::ConvexHull(m_body->getWorld(), horizontalSensorPoints, 2*m_sensorShapeSegments);
-        m_dynamicsSensorShape = new OgreNewt::CollisionPrimitives::ConvexHull(m_body->getWorld(), dynamicsSensorPoints, 2*m_sensorShapeSegments);
+        m_verticalSensorShape = ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(m_body->getWorld(), verticalSensorPoints, 2*m_sensorShapeSegments));
+        m_horizontalSensorShape = ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(m_body->getWorld(), horizontalSensorPoints, 2*m_sensorShapeSegments));
+        m_dynamicsSensorShape = ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(m_body->getWorld(), dynamicsSensorPoints, 2*m_sensorShapeSegments));
 
         delete[] dynamicsSensorPoints;
         delete[] verticalSensorPoints;

Modified: dependencies/OgreNewt/src/OgreNewt_RayCast.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_RayCast.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/src/OgreNewt_RayCast.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -191,7 +191,7 @@
         }
 
 
-    void Convexcast::go(const OgreNewt::World* world, const OgreNewt::Collision *col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int threadIndex)
+    void Convexcast::go(const OgreNewt::World* world, const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int threadIndex)
     {
 
         if( world->getDebugger().isRaycastRecording() )
@@ -278,7 +278,7 @@
         {
         }
 
-    BasicConvexcast::BasicConvexcast(const OgreNewt::World* world, const OgreNewt::Collision *col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int threadIndex)
+    BasicConvexcast::BasicConvexcast(const OgreNewt::World* world, const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount, int threadIndex)
     {
         go( world, col, startpt, colori, endpt, maxcontactscount, threadIndex);
     }

Modified: dependencies/OgreNewt/src/OgreNewt_Tools.cpp
===================================================================
--- dependencies/OgreNewt/src/OgreNewt_Tools.cpp	2009-04-07 17:35:36 UTC (rev 4888)
+++ dependencies/OgreNewt/src/OgreNewt_Tools.cpp	2009-04-07 22:24:33 UTC (rev 4889)
@@ -1,7 +1,6 @@
 #include "OgreNewt_Tools.h"
 #include "OgreNewt_World.h"
 #include "OgreNewt_Body.h"
-#include "OgreNewt_Collision.h"
 #include <iostream>
 
 #ifdef __APPLE__
@@ -116,7 +115,7 @@
         //! find the point on a collision primitive closest to a global point.
         
         int CollisionPointDistance( const OgreNewt::World* world, const Ogre::Vector3& globalpt, 
-                                    const OgreNewt::Collision* col, const Ogre::Quaternion& colorient, const Ogre::Vector3& colpos, 
+                                    const OgreNewt::CollisionPtr& col, const Ogre::Quaternion& colorient, const Ogre::Vector3& colpos, 
                                     Ogre::Vector3& retpt, Ogre::Vector3& retnormal, int threadIndex )
         {
             float matrix[16];
@@ -131,8 +130,8 @@
 
 
         
-        int CollisionClosestPoint( const OgreNewt::World* world, const OgreNewt::Collision* colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA,
-                                                            const OgreNewt::Collision* colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB,
+        int CollisionClosestPoint( const OgreNewt::World* world, const OgreNewt::CollisionPtr& colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA,
+                                                            const OgreNewt::CollisionPtr& colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB,
                                                             Ogre::Vector3& retPosA, Ogre::Vector3& retPosB, Ogre::Vector3& retNorm, int threadIndex )
         {
             float matrixA[16];
@@ -152,8 +151,8 @@
 
 
         int CollisionCollide(  const OgreNewt::World* world, int maxSize, 
-            const OgreNewt::Collision* colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA,
-            const OgreNewt::Collision* colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB,
+            const OgreNewt::CollisionPtr& colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA,
+            const OgreNewt::CollisionPtr& colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB,
             Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex )
         {
             float matrixA[16];
@@ -173,8 +172,8 @@
 
 
         int CollisionCollideContinue( const OgreNewt::World* world, int maxSize, Ogre::Real timeStep,
-            const OgreNewt::Collision* colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA, const Ogre::Vector3& colVelA, const Ogre::Vector3& colOmegaA,
-            const OgreNewt::Collision* colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB, const Ogre::Vector3& colVelB, const Ogre::Vector3& colOmegaB,
+            const OgreNewt::CollisionPtr& colA, const Ogre::Quaternion& colOrientA, const Ogre::Vector3& colPosA, const Ogre::Vector3& colVelA, const Ogre::Vector3& colOmegaA,
+            const OgreNewt::CollisionPtr& colB, const Ogre::Quaternion& colOrientB, const Ogre::Vector3& colPosB, const Ogre::Vector3& colVelB, const Ogre::Vector3& colOmegaB,
             Ogre::Real& retTimeOfImpact, Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex )
         {
             float matrixA[16];
@@ -197,13 +196,13 @@
         }
 
 
-        Ogre::Real CollisionRayCast( const OgreNewt::Collision* col, const Ogre::Vector3& startPt, const Ogre::Vector3& endPt, 
+        Ogre::Real CollisionRayCast( const OgreNewt::CollisionPtr& col, const Ogre::Vector3& startPt, const Ogre::Vector3& endPt, 
             Ogre::Vector3& retNorm, int& retColID )
         {
             return NewtonCollisionRayCast( col->getNewtonCollision(), &startPt.x, &endPt.x, &retNorm.x, &retColID );
         }
 
-        Ogre::AxisAlignedBox CollisionCalculateAABB( const OgreNewt::Collision* col, const Ogre::Quaternion& orient, const Ogre::Vector3& pos )
+        Ogre::AxisAlignedBox CollisionCalculateAABB( const OgreNewt::CollisionPtr& col, const Ogre::Quaternion& orient, const Ogre::Vector3& pos )
         {
             float matrix[16];
             Converters::QuatPosToMatrix( orient, pos, matrix );



From melven at mail.berlios.de  Wed Apr  8 00:30:02 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 8 Apr 2009 00:30:02 +0200
Subject: [Dsa-hl-svn] r4890 - in rl/trunk/engine: ai/src core/include
	core/src rules/src script/src ui/include ui/src
Message-ID: <200904072230.n37MU2nN032545@sheep.berlios.de>

Author: melven
Date: 2009-04-08 00:29:54 +0200 (Wed, 08 Apr 2009)
New Revision: 4890

Modified:
   rl/trunk/engine/ai/src/PhysicalObstacle.cpp
   rl/trunk/engine/core/include/PhysicsManager.h
   rl/trunk/engine/core/include/PhysicsMaterialRaycast.h
   rl/trunk/engine/core/include/PhysicsRagDoll.h
   rl/trunk/engine/core/src/DotSceneLoader.cpp
   rl/trunk/engine/core/src/GameAreaTypes.cpp
   rl/trunk/engine/core/src/GameEventManager.cpp
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp
   rl/trunk/engine/core/src/PhysicsRagDoll.cpp
   rl/trunk/engine/core/src/SceneQuery.cpp
   rl/trunk/engine/rules/src/CreatureControllerManager.cpp
   rl/trunk/engine/rules/src/SelectionHelper.cpp
   rl/trunk/engine/script/src/EntityNodeProcessor.cpp
   rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
   rl/trunk/engine/ui/include/MovementControlState.h
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
-added support for using Ogre::Any as userdata in OgreNewt and shared-pointers for collisions (can be activated through preprocessor definitions for now)
-fixed some bugs (e.g. PhysicsManager corrects size of objects that are too small correctly)
-EntityNodeProcessor etc use PhysicsManager for creation of collisions... no class should create them directly through OgreNewt, this will be useful to
 implement caching collisions and reading serialized collisions
- DotSceneLoader not adopted, should be removed anyway


Modified: rl/trunk/engine/ai/src/PhysicalObstacle.cpp
===================================================================
--- rl/trunk/engine/ai/src/PhysicalObstacle.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/ai/src/PhysicalObstacle.cpp	2009-04-07 22:29:54 UTC (rev 4890)
@@ -70,7 +70,7 @@
         Quaternion orientation;
         body->getPositionOrientation(position, orientation);
 
-    	const OgreNewt::Collision* collision = body->getCollision();
+    	const OgreNewt::CollisionPtr collision = body->getCollision();
     	RlAssert(collision, "Body has no collision!");
     	AxisAlignedBox box = collision->getAABB();
     	Ogre::Vector3 dims = box.getMaximum() - box.getMinimum();

Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2009-04-07 22:29:54 UTC (rev 4890)
@@ -223,6 +223,8 @@
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
 		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
+         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
+         *                the new collision is not added to the cache
 		*/
 		OgreNewt::CollisionPtr createCollision(
 			Ogre::Entity* entity,
@@ -232,7 +234,8 @@
 			Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
             Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+            Ogre::Vector3* centerOfMass = NULL,
+            bool nocache = false);
 
         /** creates a collision primitive for OgreNewt.
 		 * The collision primitive created has got a basic orientation which can be influenced by
@@ -251,6 +254,8 @@
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
 		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
+         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
+         *                the new collision is not added to the cache
 		*/
         OgreNewt::CollisionPtr createCollision(
             const Ogre::String& name,
@@ -260,7 +265,8 @@
 			Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
             Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+            Ogre::Vector3* centerOfMass = NULL,
+            bool nocache = false);
 
         /** Makes the collision primitive generation available to non mesh objects.
          * Non mesh objects need collision objects too. Therefore they can
@@ -296,7 +302,11 @@
         struct CollisionInUse
         {
         public:
-            CollisionInUse() : colPtr(NULL), geomType(GT_NONE) {}
+            CollisionInUse() :
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+                colPtr(NULL),
+#endif
+                geomType(GT_NONE) {}
             GeometryType geomType;  //! primitive type
             OgreNewt::CollisionPtr colPtr;          //! the collision primitve
         };
@@ -382,13 +392,13 @@
     {
     public:
         /** checks if the specified size is ok for OgreNewt
-         * @param size to check
+         * @param aabb check the aabb's size
          */
-        bool checkSize(const Ogre::Vector3& size) const;
+        bool checkSize(const Ogre::AxisAlignedBox& aabb) const;
         /** corrects the specified size if it is not ok for OgreNewt
-         * @param size to correct
+         * @param aabb correct the aabb's size
          */
-        void correctSize(Ogre::Vector3& size);
+        void correctSize(Ogre::AxisAlignedBox& aabb);
         /** calculates the Inertia for the given primitive type
          */
         //Ogre::Vector3 calculateIntertia(const Ogre::Real& Mass, Ogre::Vector3* inertiaCoefficients);

Modified: rl/trunk/engine/core/include/PhysicsMaterialRaycast.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsMaterialRaycast.h	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/core/include/PhysicsMaterialRaycast.h	2009-04-07 22:29:54 UTC (rev 4890)
@@ -111,7 +111,7 @@
         * @param invertmat if "true", the ray finds all collisions, which do NOT have the material-id "material"
         */
         ConvexcastInfo execute(OgreNewt::World* world, const OgreNewt::MaterialID* material,
-            const OgreNewt::Collision *col, const Ogre::Vector3& startpt, const Ogre::Quaternion &ori,
+            const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3& startpt, const Ogre::Quaternion &ori,
             const Ogre::Vector3& endpt, bool invertmat = false);
         
         /** executes the Convexcast
@@ -125,7 +125,7 @@
         * @param invertmat if "true", the ray finds all collisions, which do NOT have the material-id "material"
         */
         ConvexcastInfo execute(OgreNewt::World* world, const MaterialVector* materials,
-            const OgreNewt::Collision *col, const Ogre::Vector3& startpt, const Ogre::Quaternion &ori,
+            const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3& startpt, const Ogre::Quaternion &ori,
             const Ogre::Vector3& endpt, bool invertmat = false);
 
 

Modified: rl/trunk/engine/core/include/PhysicsRagDoll.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsRagDoll.h	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/core/include/PhysicsRagDoll.h	2009-04-07 22:29:54 UTC (rev 4890)
@@ -112,7 +112,7 @@
 
 	private:
         //! create a convexhull from a mesh
-		OgreNewt::ConvexCollision* _makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight );
+		OgreNewt::ConvexCollisionPtr _makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight );
 
 		//! the ragdoll to that this bone belongs
 		PhysicsRagDoll* mDoll;

Modified: rl/trunk/engine/core/src/DotSceneLoader.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneLoader.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/core/src/DotSceneLoader.cpp	2009-04-07 22:29:54 UTC (rev 4890)
@@ -473,7 +473,11 @@
     // eine benutzerdefinierte Collision
     void DotSceneLoader::processCollisions(XERCES_CPP_NAMESPACE::DOMElement *rootCollisionXml)
     {
-        OgreNewt::CollisionPtr collision = OgreNewt::CollisionPtr();
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+        OgreNewt::CollisionPtr collision;
+#else
+        OgreNewt::CollisionPtr collision = NULL;
+#endif
         DOMNode* child = rootCollisionXml->getFirstChild();
         OgreNewt::World *thisWorld = PhysicsManager::getSingleton()._getNewtonWorld();
 
@@ -492,7 +496,11 @@
                 child = child->getNextSibling();
                 continue;
             }
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            collision.reset();
+#else
             collision = NULL;
+#endif
             // am Anfang steht ein Node mit dem Typ
             std::string typeAsString = transcodeToStdString(child->getNodeName());
 
@@ -701,7 +709,11 @@
                 {
                     LOG_MESSAGE(Logger::CORE,
                         " Mesh-Collisions in <collisions> werden momentan noch nicht unterst?tzt (Eintrag wird ignoriert).");
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+                    collision.reset();
+#else
                     collision = NULL;
+#endif
                 }
 /*
                 else if (typeAsString.compare("meshhull") == 0)  // automatische convexhull mit daten aus mesh
@@ -715,15 +727,18 @@
                 {
                     LOG_MESSAGE(Logger::CORE,
                         " > Parse Error beim Erstellen einer Collision; ung?ltiger typ: '"+typeAsString+"' !");
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+                    collision.reset();
+#else
                     collision = NULL;
-                    //return OgreNewt::CollisionPtr(NULL);
+#endif
                 }
 
             }
 
 
             // Collision dem vektor hinzuf?gen
-            if (collision != NULL)
+            if ( !collision )
                 mCollisions.push_back(collision);
 
             child = child->getNextSibling();

Modified: rl/trunk/engine/core/src/GameAreaTypes.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaTypes.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/core/src/GameAreaTypes.cpp	2009-04-07 22:29:54 UTC (rev 4890)
@@ -244,8 +244,15 @@
             col);
         mBody->setMaterialGroupID(
             PhysicsManager::getSingleton().getMaterialID("gamearea"));
+#ifndef OGRENEWT_USE_OGRE_ANY
         mBody->setUserData(NULL);
-        ((OgreNewt::ConvexCollision*)col)->setAsTriggerVolume(true);
+#endif
+
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+        boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(col)->setAsTriggerVolume(true);
+#else
+        dynamic_cast<OgreNewt::ConvexCollisionPtr>(col)->setAsTriggerVolume(true);
+#endif
     }
 
     GameSimpleCollisionAreaType::GameSimpleCollisionAreaType(
@@ -262,8 +269,15 @@
             col);
         mBody->setMaterialGroupID(
             PhysicsManager::getSingleton().getMaterialID("gamearea"));
+#ifndef OGRENEWT_USE_OGRE_ANY
         mBody->setUserData(NULL);
-        ((OgreNewt::ConvexCollision*)col)->setAsTriggerVolume(true);
+#endif
+
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+        boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(col)->setAsTriggerVolume(true);
+#else
+        dynamic_cast<OgreNewt::ConvexCollisionPtr>(col)->setAsTriggerVolume(true);
+#endif
     }
 
 }

Modified: rl/trunk/engine/core/src/GameEventManager.cpp
===================================================================
--- rl/trunk/engine/core/src/GameEventManager.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/core/src/GameEventManager.cpp	2009-04-07 22:29:54 UTC (rev 4890)
@@ -308,6 +308,10 @@
 
     Actor* GameEventManager::bodyToActor(OgreNewt::Body* body)
     {
+#ifdef OGRENEWT_USE_OGRE_ANY
+        return Ogre::any_cast<Actor*>(body->getUserData());
+#else
         return static_cast<Actor*>(body->getUserData());
+#endif
     }
 }

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2009-04-07 22:29:54 UTC (rev 4890)
@@ -28,7 +28,6 @@
 
 using namespace Ogre;
 using namespace OgreNewt;
-using namespace OgreNewt::CollisionPrimitives;
 
 namespace rl
 {
@@ -128,7 +127,11 @@
 	void PhysicalThing::setBody(OgreNewt::Body* body)
     {
         mBody = body;
-		mBody->setUserData(mActor);
+#ifdef OGRENEWT_USE_OGRE_ANY
+		mBody->setUserData( Ogre::Any(mActor) );
+#else
+        mBody->setUserData( mActor );
+#endif
     }
 
     void PhysicalThing::_update()
@@ -155,7 +158,13 @@
     {
         mActor = actor;
 		if (mBody != NULL)
-			mBody->setUserData(actor);
+        {
+#ifdef OGRENEWT_USE_OGRE_ANY
+    		mBody->setUserData( Ogre::Any(mActor) );
+#else
+            mBody->setUserData( mActor );
+#endif
+        }
     }
 
     void PhysicalThing::_attachToSceneNode(Ogre::SceneNode* node)
@@ -272,10 +281,25 @@
             "PhysicalThing::updateCollisionHull: PhysicalThing must not be controlled by a RagDoll in order to update its collision hull.");
 
 
+        
         Vector3 position;
         Quaternion orientation;
         mBody->getPositionOrientation(position, orientation);
+        CollisionPtr collision = PhysicsManager::getSingleton().createCollision(
+                entity,
+                mGeometryType,
+                "",
+                NULL,
+                NULL,
+                0, NULL, NULL,
+                true); // don't cache
+        if( collision )
+        {
+            mBody->setCollision(collision);
+            mBody->setPositionOrientation(position, orientation);
+        }
 
+/*
 		if (mGeometryType == GT_CONVEXHULL)
 		{
 			Matrix4 transform = node->_getFullTransform().inverse();
@@ -328,18 +352,19 @@
 					vbuffer->unlock();
 				}
 			}
-	        CollisionPtr collision(new ConvexHull(PhysicsManager::getSingleton()._getNewtonWorld(),
+	        CollisionPtr collision(new CollisionPrimitives::ConvexHull(PhysicsManager::getSingleton()._getNewtonWorld(),
 			    &vertices[0], vertices.size()));
 		    mBody->setCollision(collision);
 		}
 		else if (mGeometryType == GT_MESH)
 		{
-	        CollisionPtr collision(new TreeCollision(
+	        CollisionPtr collision(new CollisionPrimitives::TreeCollision(
 				PhysicsManager::getSingleton()._getNewtonWorld(), entity, true));
 		    mBody->setCollision(collision);
 		}
 
         mBody->setPositionOrientation(position, orientation);
+*/
     }
 
     void PhysicalThing::freeze()

Modified: rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp	2009-04-07 22:29:54 UTC (rev 4890)
@@ -29,8 +29,30 @@
     {
         userProcess(contactJoint, timestep, threadid);
 
-        Actor* a1 = static_cast<Actor*>(contactJoint.getBody0()->getUserData());
-        Actor* a2 = static_cast<Actor*>(contactJoint.getBody1()->getUserData());
+        Actor* a1 = NULL;
+        Actor* a2 = NULL;
+
+#ifdef OGRENEWT_USE_OGRE_ANY
+        try
+        {
+            a1 = Ogre::any_cast<Actor*>(contactJoint.getBody0()->getUserData());
+        }
+        catch(...)
+        {
+            LOG_WARNING(Logger::CORE, "Found collision with a OgreNewt::Body that doesn't have an Actor as UserData in PhysicsGenericContactCallback::contactsProcess");
+        }
+        try
+        {
+            a2 = Ogre::any_cast<Actor*>(contactJoint.getBody1()->getUserData());
+        }
+        catch(...)
+        {
+            LOG_WARNING(Logger::CORE, "Found collision with a OgreNewt::Body that doesn't have an Actor as UserData in PhysicsGenericContactCallback::contactsProcess");
+        }
+#else
+        a1 = static_cast<Actor*>(contactJoint.getBody0()->getUserData());
+        a2 = static_cast<Actor*>(contactJoint.getBody1()->getUserData());
+#endif
         if (a1 && a1->getPhysicalThing()->getContactListener())
         {
             a1->getPhysicalThing()->getContactListener()->

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2009-04-07 22:29:54 UTC (rev 4890)
@@ -36,7 +36,7 @@
 
 namespace rl
 {
-    const Ogre::Real PhysicsManager::NEWTON_GRID_WIDTH = 0.01;
+    const Ogre::Real PhysicsManager::NEWTON_GRID_WIDTH = 0.02;
 
 	LQTBodies::LQTBodies(int maxData, int maxDepth, float looseness,
 		const Ogre::Vector2& tlc, const Ogre::Vector2& brc, float mWidth)
@@ -326,7 +326,10 @@
         
 
         // try one compound collision for the entity if there are several collisions
-        OgreNewt::CollisionPtr collision(NULL);
+        OgreNewt::CollisionPtr collision;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        collision = NULL;
+#endif
         switch( collisions.size() )
         {
             case 0:
@@ -335,7 +338,7 @@
                 collision = collisions[0];
                 break;
             default:
-                collision = new OgreNewt::CollisionPrimitives::CompoundCollision(mWorld, collisions);
+                collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::CompoundCollision(mWorld, collisions));
                 break;
         }
 
@@ -403,17 +406,28 @@
     void PhysicsManager::genericForceCallback(OgreNewt::Body* body, float timestep, int)
     {
         // apply saved forces in the PhysicalThing
-        PhysicalThing* thing =
-            static_cast<Actor*>(body->getUserData())->getPhysicalThing();
+        PhysicalThing* thing;
 
+#ifdef OGRENEWT_USE_OGRE_ANY
+        thing = Ogre::any_cast<Actor*>(body->getUserData())->getPhysicalThing();
+#else
+        thing = static_cast<Actor*>(body->getUserData())->getPhysicalThing();
+#endif
+
         thing->onApplyForceAndTorque(timestep);
     }
 
     void PhysicsManager::controlledForceCallback(OgreNewt::Body* body, float timestep, int)
     {
-        PhysicalThing* thing =
-            static_cast<Actor*>(body->getUserData())->getPhysicalThing();
+        PhysicalThing* thing;
 
+#ifdef OGRENEWT_USE_OGRE_ANY
+        thing = Ogre::any_cast<Actor*>(body->getUserData())->getPhysicalThing();
+#else
+        thing = static_cast<Actor*>(body->getUserData())->getPhysicalThing();
+#endif
+
+
         if (thing->getPhysicsController())
         {
             thing->getPhysicsController()->OnApplyForceAndTorque(thing, timestep);
@@ -508,7 +522,7 @@
         Ogre::Entity* entity, const GeometryType& geomType,
 		const Ogre::String animName, Ogre::Vector3* offset,
         Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
-        Ogre::Vector3* centerOfMass)
+        Ogre::Vector3* centerOfMass, bool nocache)
     {
         // problem here is that a mesh can have different animations with
         // different extents. Therefore we add the animName to the meshname
@@ -516,7 +530,10 @@
         Ogre::String collisionName (entity->getMesh()->getName() + animName);
 
         // result value
-        CollisionPtr rval(NULL);
+        CollisionPtr rval;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        rval = NULL;
+#endif
 
         // check if there is a collision primitiv for the specified mesh object
         CollisionInUse &usedcol (mCollisionPrimitives[collisionName]);
@@ -555,10 +572,13 @@
         const Ogre::String& name, const Ogre::AxisAlignedBox& aabb,
         const GeometryType& geomType, Ogre::Vector3* offset,
         Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
-        Ogre::Vector3* centerOfMass)
+        Ogre::Vector3* centerOfMass, bool nocache)
     {
         // result value
-        CollisionPtr rval(NULL);
+        CollisionPtr rval;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        rval = NULL;
+#endif
 
         // check if there is a collision primitiv for the specified mesh object
         CollisionInUse &usedcol (mCollisionPrimitives[name]);
@@ -637,8 +657,9 @@
 		return typestr;
 	}
 
-    bool PhysicsCollisionFactory::checkSize(const Ogre::Vector3& size) const
+    bool PhysicsCollisionFactory::checkSize(const Ogre::AxisAlignedBox& aabb) const
     {
+        Ogre::Vector3 size = aabb.getSize();
         if( size.x < PhysicsManager::NEWTON_GRID_WIDTH ||
             size.y < PhysicsManager::NEWTON_GRID_WIDTH ||
             size.z < PhysicsManager::NEWTON_GRID_WIDTH )
@@ -646,8 +667,9 @@
         return true;
     }
 
-    void PhysicsCollisionFactory::correctSize(Ogre::Vector3& size)
+    void PhysicsCollisionFactory::correctSize(Ogre::AxisAlignedBox& aabb)
     {
+        Ogre::Vector3 size = aabb.getSize();
         // correct size, log warning and fail back to box
         if (size.x < PhysicsManager::NEWTON_GRID_WIDTH)
             size.x = PhysicsManager::NEWTON_GRID_WIDTH;
@@ -656,6 +678,9 @@
         if (size.z < PhysicsManager::NEWTON_GRID_WIDTH)
             size.z = PhysicsManager::NEWTON_GRID_WIDTH;
         LOG_MESSAGE(Logger::CORE, "Correcting collision primitiv size");
+        Ogre::Vector3 center = aabb.getCenter();
+        aabb.setMaximum(center + 0.5*size);
+        aabb.setMinimum(center - 0.5*size);
     }
 
     /*
@@ -665,7 +690,7 @@
     }
     */
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(const Ogre::AxisAlignedBox aabb,
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(const Ogre::AxisAlignedBox passedAabb,
         const GeometryType& geomType,
         Ogre::Vector3* offset,
         Ogre::Quaternion* orientation,
@@ -673,18 +698,20 @@
         Ogre::Vector3* inertia,
         Ogre::Vector3* centerOfMass)
     {
-        // size of the mesh
-        Vector3 size( aabb.getSize() );
+        Ogre::AxisAlignedBox aabb(passedAabb);
         // type for the collision primitiv (can change internally here)
         bool forceBox (false);
 
         // result value
-        CollisionPtr rval(NULL);
+        CollisionPtr rval;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        rval = NULL;
+#endif
 
         // size check (if object is too small, it falls back to a box primitiv
-        if (checkSize(size) == false )
+        if (checkSize(aabb) == false )
         {
-            correctSize(size);
+            correctSize(aabb);
             LOG_MESSAGE(Logger::CORE,
                 " AABB is too small, using 'box' instead of primitiv '" +
                 PhysicsManager::convertGeometryTypeToString(geomType));
@@ -741,19 +768,20 @@
         Ogre::Vector3* centerOfMass)
     {
         // bounding box of the mesh
-        const Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
-        // size of the mesh
-        Vector3 size( aabb.getSize() );
+        Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
         // type for the collision primitiv (can change internally here)
         bool forceBox (false);
 
         // result value
-        CollisionPtr rval(NULL);
+        CollisionPtr rval;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        rval = NULL;
+#endif
 
         // size check (if object is too small, it falls back to a box primitiv
-        if (checkSize(size) == false )
+        if (checkSize(aabb) == false )
         {
-            correctSize(size);
+            correctSize(aabb);
             LOG_MESSAGE(Logger::CORE, " Entity '"+entity->getName()+
                 "' is too small, using 'box' instead of primitiv '"+
                 PhysicsManager::convertGeometryTypeToString(geomType));
@@ -808,7 +836,11 @@
             if (inertia != NULL || centerOfMass != NULL )
             {
                 Vector3 temp_inertia, temp_centerOfMass;
-                static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+                boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+                dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
                 if( inertia != NULL )
                     *inertia = temp_inertia*mass;
                 if( centerOfMass != NULL )
@@ -874,7 +906,11 @@
         if (inertia != NULL || centerOfMass != NULL )
         {
             Vector3 temp_inertia, temp_centerOfMass;
-            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
             if( inertia )
                 *inertia = temp_inertia*mass;
             if( centerOfMass )
@@ -911,7 +947,11 @@
         if (inertia != NULL || centerOfMass != NULL )
         {
             Vector3 temp_inertia, temp_centerOfMass;
-            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
             if( inertia )
                 *inertia = temp_inertia*mass;
             if( centerOfMass )
@@ -952,7 +992,11 @@
         if (inertia != NULL || centerOfMass != NULL )
         {
             Vector3 temp_inertia, temp_centerOfMass;
-            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
             if( inertia )
                 *inertia = temp_inertia*mass;
             if( centerOfMass )
@@ -994,7 +1038,11 @@
         if (inertia != NULL || centerOfMass != NULL )
         {
             Vector3 temp_inertia, temp_centerOfMass;
-            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
             if( inertia )
                 *inertia = temp_inertia*mass;
             if( centerOfMass )
@@ -1030,7 +1078,7 @@
 
         // an capsule primitiv has got its coordinate system at its center, so shift it with radius
         // additionally it is x axis aligned, so rotate it 90 degrees around z axis
-        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Capsule(
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Capsule(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             radius, height, *orientation, *offset));
 
@@ -1038,7 +1086,11 @@
         if (inertia != NULL || centerOfMass != NULL )
         {
             Vector3 temp_inertia, temp_centerOfMass;
-            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
             if( inertia )
                 *inertia = temp_inertia*mass;
             if( centerOfMass )

Modified: rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp	2009-04-07 22:29:54 UTC (rev 4890)
@@ -186,7 +186,7 @@
     }
 
     ConvexcastInfo PhysicsMaterialConvexcast::execute(OgreNewt::World* world, const OgreNewt::MaterialID* material,
-                        const OgreNewt::Collision *col, const Vector3& startpt, const Quaternion &ori,
+                        const OgreNewt::ConvexCollisionPtr& col, const Vector3& startpt, const Quaternion &ori,
                         const Vector3& endpt, bool invertmat)
     {
         mMaterialVector = NULL;
@@ -201,7 +201,7 @@
     }
 
     ConvexcastInfo PhysicsMaterialConvexcast::execute(OgreNewt::World* world, const MaterialVector* materials,
-                        const OgreNewt::Collision *col, const Vector3& startpt, const Quaternion &ori,
+                        const OgreNewt::ConvexCollisionPtr& col, const Vector3& startpt, const Quaternion &ori,
                         const Vector3& endpt, bool invertmat)
     {
         mMaterialVector = materials;

Modified: rl/trunk/engine/core/src/PhysicsRagDoll.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsRagDoll.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/core/src/PhysicsRagDoll.cpp	2009-04-07 22:29:54 UTC (rev 4890)
@@ -35,7 +35,11 @@
 	mParent = parent;
 	mOgreBone = ogreBone;
 
-	OgreNewt::ConvexCollision* col = NULL;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+	OgreNewt::ConvexCollisionPtr col;
+#else
+	OgreNewt::ConvexCollisionPtr col = NULL;
+#endif
 
 	// in the case of the cylindrical primitives, they need to be rotated to align the main axis with the direction vector.
 	Ogre::Quaternion orient = Ogre::Quaternion::IDENTITY;
@@ -59,23 +63,23 @@
 	switch (shape)
 	{
 	case PhysicsRagDoll::RagBone::BS_BOX:
-		col = new OgreNewt::CollisionPrimitives::Box( world, size );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CAPSULE:
-		col = new OgreNewt::CollisionPrimitives::Capsule( world, size.y, size.x, orient, pos );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Capsule( world, size.y, size.x, orient, pos ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CONE:
-		col = new OgreNewt::CollisionPrimitives::Cone( world, size.y, size.x, orient, pos );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cone( world, size.y, size.x, orient, pos ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CYLINDER:
-		col = new OgreNewt::CollisionPrimitives::Cylinder( world, size.y, size.x, orient, pos );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder( world, size.y, size.x, orient, pos ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_ELLIPSOID:
-		col = new OgreNewt::CollisionPrimitives::Ellipsoid( world, size );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( world, size ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CONVEXHULL:
@@ -83,7 +87,7 @@
 		break;
 
 	default:
-		col = new OgreNewt::CollisionPrimitives::Box( world, size );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size ));
 		break;
 	}
 
@@ -91,12 +95,16 @@
     {
         if( col->getNewtonCollision() == NULL )
         {
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            col.reset();
+#else
             delete col;
             col = NULL;
+#endif
         }
     }
 
-    if( col == NULL )
+    if( !col )
     {
         LOG_WARNING(Logger::CORE, " error creating collision for '" + ogreBone->getName() + "', still continuing.");
         mBody = NULL;
@@ -104,7 +112,11 @@
     else
     {
     	mBody = new OgreNewt::Body( world, col );
+#ifdef OGRENEWT_USE_OGRE_ANY
+        mBody->setUserData( Ogre::Any(parentActor) );
+#else
 	    mBody->setUserData( parentActor );
+#endif
     	mBody->setStandardForceCallback();
         const OgreNewt::MaterialID* ragdollMat = PhysicsManager::getSingleton().createMaterialID("default");
         mBody->setMaterialGroupID(ragdollMat);
@@ -134,7 +146,11 @@
 
 void PhysicsRagDoll::RagBone::_hingeCallback( OgreNewt::BasicJoints::Hinge* me )
 {
-	PhysicsRagDoll::RagBone* bone = (PhysicsRagDoll::RagBone*)me->getUserData();
+#ifdef OGRENEWT_USE_OGRE_ANY
+    PhysicsRagDoll::RagBone* bone = Ogre::any_cast<PhysicsRagDoll::RagBone*>(me->getUserData());
+#else
+    PhysicsRagDoll::RagBone* bone = static_cast<PhysicsRagDoll::RagBone*>(me->getUserData());
+#endif
 
 	Ogre::Degree angle = me->getJointAngle();
 	Ogre::Degree lim1( bone->getLimit1() );
@@ -155,7 +171,7 @@
 }
 
 
-OgreNewt::ConvexCollision* PhysicsRagDoll::RagBone::_makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight )
+OgreNewt::ConvexCollisionPtr PhysicsRagDoll::RagBone::_makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight )
 {
 	std::vector< Ogre::Vector3 > vertexVector;
 
@@ -245,9 +261,13 @@
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////
-    OgreNewt::ConvexCollision* col = NULL;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+    OgreNewt::ConvexCollisionPtr col;
+#else
+    OgreNewt::ConvexCollisionPtr col = NULL;
+#endif
     if( numVerts > 0 )
-    	col = new OgreNewt::CollisionPrimitives::ConvexHull( world, verts, numVerts );
+    	col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull( world, verts, numVerts ));
 
 	delete []verts;
 
@@ -444,7 +464,11 @@
 	case PhysicsRagDoll::JT_HINGE:
 		joint = new OgreNewt::BasicJoints::Hinge( world, child->getBody(), parent->getBody(), pos, pin );
 		((OgreNewt::BasicJoints::Hinge*)joint)->setCallback( RagBone::_hingeCallback );
+#ifdef OGRENEWT_USE_OGRE_ANY
+		joint->setUserData( Ogre::Any(child) );
+#else
 		joint->setUserData( child );
+#endif
 		child->setLimits( limit1, limit2 );
 		break;
 	}
@@ -454,7 +478,11 @@
 
 void PhysicsRagDoll::_placementCallback( OgreNewt::Body* me, const Ogre::Quaternion& orient, const Ogre::Vector3& pos, int threadindex )
 {
+#ifdef OGRENEWT_USE_OGRE_ANY
+    Actor* parentActor = Ogre::any_cast<Actor*>(me->getUserData());
+#else
     Actor* parentActor = static_cast<Actor*>(me->getUserData());
+#endif
 	PhysicsRagDoll* doll = parentActor->getPhysicalThing()->getRagDoll();
     PhysicsRagDoll::RagBoneMapIterator it = doll->mRagBonesMap.find(me);
     if( it == doll->mRagBonesMap.end() )

Modified: rl/trunk/engine/core/src/SceneQuery.cpp
===================================================================
--- rl/trunk/engine/core/src/SceneQuery.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/core/src/SceneQuery.cpp	2009-04-07 22:29:54 UTC (rev 4890)
@@ -116,7 +116,11 @@
                 if (mLevelOcclusion && (body->getMaterialGroupID() == levelId)) break;
 
                 // Add actor to this body to the result
+#ifdef OGRENEWT_USE_OGRE_ANY
+                Actor* actor = Ogre::any_cast<Actor*>(body->getUserData());
+#else
                 Actor* actor = static_cast<Actor*>(body->getUserData());
+#endif
                 if (actor != NULL) mResult.push_back(actor);
             }
         }

Modified: rl/trunk/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2009-04-07 22:29:54 UTC (rev 4890)
@@ -166,7 +166,11 @@
 
     void CreatureControllerManager::userProcess(OgreNewt::ContactJoint &contactJoint, Real timestep, int threadid)
     {
+#ifdef OGRENEWT_USE_OGRE_ANY
+        Actor *actor = Ogre::any_cast<Actor*>(contactJoint.getBody0()->getUserData());
+#else
         Actor *actor = static_cast<Actor*>(contactJoint.getBody0()->getUserData());
+#endif
         if( actor != NULL )
         {
             ControllerMap::const_iterator it = mControllers.find(static_cast<Creature*>(actor->getGameObject()));
@@ -178,7 +182,11 @@
         }
 
         // if the controlled body is the second body...
-        actor = static_cast<Actor*>(contactJoint.getBody1()->getUserData());
+#ifdef OGRENEWT_USE_OGRE_ANY
+        actor = Ogre::any_cast<Actor*>(contactJoint.getBody0()->getUserData());
+#else
+        actor = static_cast<Actor*>(contactJoint.getBody0()->getUserData());
+#endif
         if( actor != NULL )
         {
             ControllerMap::const_iterator it = mControllers.find(static_cast<Creature*>(actor->getGameObject()));

Modified: rl/trunk/engine/rules/src/SelectionHelper.cpp
===================================================================
--- rl/trunk/engine/rules/src/SelectionHelper.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/rules/src/SelectionHelper.cpp	2009-04-07 22:29:54 UTC (rev 4890)
@@ -84,7 +84,11 @@
             OgreNewt::Body* body = info.mBody;
             if (body != NULL)
             {
+#ifdef OGRENEWT_USE_OGRE_ANY
+                Actor* hitActor = Ogre::any_cast<Actor*>(body->getUserData());
+#else
                 Actor* hitActor = static_cast<Actor*>(body->getUserData());
+#endif
                 isVisible = hitActor == actor2 || hitActor == actor1;
                 if (!isVisible) break;
             }

Modified: rl/trunk/engine/script/src/EntityNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2009-04-07 22:29:54 UTC (rev 4890)
@@ -43,13 +43,13 @@
 
         Ogre::String entName = getAttributeValueAsStdString(nodeElem, "name");
 
-        LOG_DEBUG(Logger::RULES,
+        LOG_DEBUG(Logger::SCRIPT,
             "Processing entity node "
                 + entName);
 
         if (!hasAttribute(nodeElem, "meshfile"))
         {
-            LOG_ERROR(Logger::RULES, "Entity node defines no meshfile attribute");
+            LOG_ERROR(Logger::SCRIPT, "Entity node defines no meshfile attribute");
             return false;
         }
 
@@ -73,7 +73,7 @@
         }
         else
         {
-            LOG_WARNING(Logger::RULES, "No position given for entity, used (0,0,0)");
+            LOG_WARNING(Logger::SCRIPT, "No position given for entity, used (0,0,0)");
         }
 
         DOMElement* oriElem = getChildNamed(nodeElem, "rotation");
@@ -83,7 +83,7 @@
         }
         else
         {
-            LOG_WARNING(Logger::RULES, "No orientation given for entity, used Identity");
+            LOG_WARNING(Logger::SCRIPT, "No orientation given for entity, used Identity");
         }
 
         ///@todo static geometry groups
@@ -108,11 +108,11 @@
             newEnt = CoreSubsystem::getSingleton().getWorld()
                         ->getSceneManager()->createEntity(entName, meshFile);
 
-            LOG_DEBUG(Logger::RULES, " Loaded meshfile "+meshFile);
+            LOG_DEBUG(Logger::SCRIPT, " Loaded meshfile "+meshFile);
         }
         catch(...)
         {
-	        LOG_ERROR(Logger::RULES, " Entity '"+meshFile+"' mit dem Namen '"+entName+"' konnte nicht geladen werden.");
+	        LOG_ERROR(Logger::SCRIPT, " Entity '"+meshFile+"' mit dem Namen '"+entName+"' konnte nicht geladen werden.");
             return false;
         }
 
@@ -141,6 +141,62 @@
 
     void EntityNodeProcessor::createCollision(Entity* entity, Ogre::String meshName, DOMElement* physicsProxyElem)
 	{
+        Ogre::String physicsProxyTypeAsString;
+        if (physicsProxyElem == NULL || !hasAttribute(physicsProxyElem, "type"))
+        {
+            physicsProxyTypeAsString = "auto";
+        }
+        else
+        {
+            physicsProxyTypeAsString = getAttributeValueAsStdString(physicsProxyElem, "type");
+        }
+
+
+
+        if (physicsProxyTypeAsString == "custom")
+        {
+            ///@todo create physics proxy from custom collision primitives which are defined in children elements of <code>physicsProxyElem<code>
+        }
+        else if (physicsProxyTypeAsString == "none")
+        {
+            LOG_DEBUG(Logger::SCRIPT, "No physics proxy for entity '"+entity->getName()+"'.");
+        }
+        else
+        {
+            GeometryType physicsProxyType = PhysicsManager::getSingleton().convertStringToGeometryType(physicsProxyTypeAsString);
+            if( physicsProxyType == GT_NONE )
+            {
+                // auto -> mesh
+                if (physicsProxyTypeAsString == "auto")
+                    physicsProxyType = GT_MESH;
+                
+                if (physicsProxyTypeAsString == "custom")
+                {
+                    ///@todo create physics proxy from custom collision primitives which are defined in children elements of <code>physicsProxyElem<code>
+                    LOG_WARNING(Logger::SCRIPT, "Physics proxy type 'custom' is not yet implemented.");
+                }
+                else if ( physicsProxyType != GT_NONE )
+                {
+                    OgreNewt::CollisionPtr collision = PhysicsManager::getSingleton().createCollision(entity, physicsProxyType);
+                    if (collision)
+                    {
+                        LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type '" + physicsProxyTypeAsString + "' for entity '"+entity->getName()+"'.");
+                        std::vector<OgreNewt::CollisionPtr> collisionVector;
+                        collisionVector.push_back(collision);
+                        PhysicsManager::getSingleton().addLevelGeometry(entity, collisionVector);
+                    }
+                }
+                else
+                {
+                    LOG_ERROR(Logger::SCRIPT,
+                            "Physics proxy type '" + physicsProxyTypeAsString + "' of entity '"+entity->getName()+"' is unknown.");
+                    return;
+                }
+            }
+
+                
+        }
+/*
         std::vector<OgreNewt::CollisionPtr> collisions;
 
         Ogre::String physicsProxyType;
@@ -164,7 +220,7 @@
         }
         else if (physicsProxyType == "none")
         {
-            LOG_DEBUG(Logger::RULES, "No physics proxy for entity '"+entity->getName()+"'.");
+            LOG_DEBUG(Logger::SCRIPT, "No physics proxy for entity '"+entity->getName()+"'.");
         }
         else
         {
@@ -185,7 +241,7 @@
                 if (size.z < PhysicsManager::NEWTON_GRID_WIDTH)
                     size.z = PhysicsManager::NEWTON_GRID_WIDTH;
 
-                LOG_MESSAGE(Logger::RULES, "Entity '"+entity->getName()+"' is planar, using 'box' as instead of '"+physicsProxyType+"'.");
+                LOG_MESSAGE(Logger::SCRIPT, "Entity '"+entity->getName()+"' is planar, using 'box' as instead of '"+physicsProxyType+"'.");
                 forceBox = true;
             }
             const Quaternion orientation(0,0,0,0);// = parentNode->getOrientation();
@@ -199,7 +255,7 @@
                 (!forceBox)) // sicherheitshalber
             {
                 collision = aucol.ColPtr;
-                LOG_DEBUG(Logger::RULES, " Reused physical body for entity '"+entity->getName()+"'.");
+                LOG_DEBUG(Logger::SCRIPT, " Reused physical body for entity '"+entity->getName()+"'.");
             }
             else
             {
@@ -207,13 +263,13 @@
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
                                      thisWorld, size, orientation, pos));
-                    LOG_DEBUG(Logger::RULES, "Created physics proxy type 'box' for entity '"+entity->getName()+"'.");
+                    LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type 'box' for entity '"+entity->getName()+"'.");
                 }
                 else if (physicsProxyType == "pyramid")
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Pyramid(
                                     thisWorld, size, orientation, pos));
-                    LOG_DEBUG(Logger::RULES, "Created physics proxy type 'pyramid' for entity '"+entity->getName()+"'.");
+                    LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type 'pyramid' for entity '"+entity->getName()+"'.");
                 }
                 else if (physicsProxyType == "sphere")
                 {
@@ -221,7 +277,7 @@
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
                                     thisWorld, Vector3(radius, radius, radius),
                                     orientation, pos));
-                    LOG_DEBUG(Logger::RULES, "Created physics proxy type 'sphere' for entity '"+entity->getName()+"'.");
+                    LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type 'sphere' for entity '"+entity->getName()+"'.");
                 }
                 else if (physicsProxyType == "ellipsoid")
                 {
@@ -232,7 +288,7 @@
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
                                     thisWorld, s,
                                     orientation, pos));
-                    LOG_DEBUG(Logger::RULES, "Created physics proxy type 'ellipsoid' for entity '"+entity->getName()+"'.");
+                    LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type 'ellipsoid' for entity '"+entity->getName()+"'.");
                 }
                 else if (physicsProxyType == "capsule")
                 {
@@ -244,24 +300,24 @@
                                     radius,
                                     height,
                                     orientation, pos));
-                    LOG_DEBUG(Logger::RULES, "Created physics proxy type 'capsule' for entity '"+entity->getName()+"'.");
+                    LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type 'capsule' for entity '"+entity->getName()+"'.");
                 }
                 else if (physicsProxyType == "convexhull")
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
                                     thisWorld,
                                     entity));
-                    LOG_DEBUG(Logger::RULES, "Created physics proxy type 'convexhull' for entity '"+entity->getName()+"'.");
+                    LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type 'convexhull' for entity '"+entity->getName()+"'.");
                 }
                 else if (physicsProxyType == "mesh" || physicsProxyType == "auto")
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
                                     thisWorld, entity, true));
-                    LOG_DEBUG(Logger::RULES, "Created physics proxy type 'mesh' for entity '"+entity->getName()+"'.");
+                    LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type 'mesh' for entity '"+entity->getName()+"'.");
                 }
                 else
                 {
-                    LOG_ERROR(Logger::RULES,
+                    LOG_ERROR(Logger::SCRIPT,
                         "Physics proxy type '"+physicsProxyType+"' of entity '"+entity->getName()+"' is unknown.");
                     return;
                 }
@@ -282,9 +338,10 @@
         if (collisions.size() > 0)
         {
             PhysicsManager::getSingleton().addLevelGeometry(entity, collisions);
-            LOG_DEBUG(Logger::RULES, " Entity '"+entity->getName()+"' in levelGeometry geladen");
+            LOG_DEBUG(Logger::SCRIPT, " Entity '"+entity->getName()+"' in levelGeometry geladen");
         }
-	}
+*/
+    }
 
 	void EntityNodeProcessor::processAnimation(Ogre::Entity* entity, DOMElement *animationElem)
 	{

Modified: rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-04-07 22:29:54 UTC (rev 4890)
@@ -148,7 +148,8 @@
 			const Quaternion orientation(0,0,0,0);// = parentNode->getOrientation();
 			const Ogre::Vector3 pos = aab.getMinimum() * parentNode->getScale() + (size/2.0);
 
-			collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(world, size, orientation, pos));
+			//collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(world, size, orientation, pos));
+            collision = PhysicsManager::getSingleton().createCollision(entity, GT_BOX, "", NULL, NULL, 0, NULL, NULL, true);
 
 			if ( collision != NULL )
 			{

Modified: rl/trunk/engine/ui/include/MovementControlState.h
===================================================================
--- rl/trunk/engine/ui/include/MovementControlState.h	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/ui/include/MovementControlState.h	2009-04-07 22:29:54 UTC (rev 4890)
@@ -126,7 +126,7 @@
 
         PhysicsMaterialRaycast* mRaycast;
         PhysicsMaterialConvexcast * mConvexcast;
-        OgreNewt::Collision *mCameraCastCollision;
+        OgreNewt::ConvexCollisionPtr mCameraCastCollision;
         HalfSphereSelector mSelector;
         HalfSphereSelector mCombatSelector;
 

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2009-04-07 22:29:54 UTC (rev 4890)
@@ -87,7 +87,9 @@
         mViewMode(VM_THIRD_PERSON),
         mRaycast(new PhysicsMaterialRaycast()),
         mConvexcast(new PhysicsMaterialConvexcast()),
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
         mCameraCastCollision(NULL),
+#endif
         mSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager()),
         mCombatSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
             QUERYFLAG_CREATURE),
@@ -158,7 +160,7 @@
             }
         }
         //! TODO: remove this workaround (newton-bug: "spheres don't cast"!)
-        mCameraCastCollision = new OgreNewt::CollisionPrimitives::ConvexHull(mCamBody->getWorld(), verts, 80);
+        mCameraCastCollision = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(mCamBody->getWorld(), verts, 80));
         //mCameraCastCollision = new OgreNewt::CollisionPrimitives::Ellipsoid(mCamBody->getWorld(), Vector3::UNIT_SCALE * camRadius);
     }
 
@@ -171,7 +173,9 @@
         mSelector.setFilter(NULL);
         delete mRaycast;
         delete mConvexcast;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
         delete mCameraCastCollision;
+#endif
 
         if (DebugWindow::getSingletonPtr())
         {



From fusion2 at mail.berlios.de  Fri Apr 10 14:25:23 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Fri, 10 Apr 2009 14:25:23 +0200
Subject: [Dsa-hl-svn] r4891 - rl/trunk/editors/Lockenwickler/src
Message-ID: <200904101225.n3ACPNIO001285@sheep.berlios.de>

Author: fusion2
Date: 2009-04-10 14:25:20 +0200 (Fri, 10 Apr 2009)
New Revision: 4891

Added:
   rl/trunk/editors/Lockenwickler/src/GOGenericEditor.py
Modified:
   rl/trunk/editors/Lockenwickler/src/GameObjectClass.py
   rl/trunk/editors/Lockenwickler/src/GameObjectClassView.py
   rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
   rl/trunk/editors/Lockenwickler/src/ZoneManager.py
Log:
- added support for editing gameobject properties in the property editor
- bugfixes

Added: rl/trunk/editors/Lockenwickler/src/GOGenericEditor.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GOGenericEditor.py	2009-04-07 22:29:54 UTC (rev 4890)
+++ rl/trunk/editors/Lockenwickler/src/GOGenericEditor.py	2009-04-10 12:25:20 UTC (rev 4891)
@@ -0,0 +1,95 @@
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+
+import sys
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+class GOGenericEditor(QDialog):
+    def __init__(self, description = "", type = "STRING", data = "", parent=None):
+        QDialog.__init__(self, parent)
+        
+        self.layout = QVBoxLayout()
+        
+        self.descEditBox = QLineEdit(self)
+        self.descEditBox.setText(description)
+        self.layout.addWidget(self.descEditBox)
+        
+        self.createTypeDropBox()
+        
+
+        if type == "STRING":
+            self.dataEditBox = QLineEdit(self)
+            self.dataEditBox.setText(data)
+            self.layout.addWidget(self.dataEditBox)
+        elif type == "REAL":
+            self.dataEditBox = QLineEdit(self)
+            self.dataEditBox.setText(data)
+            self.dataEditBox.inputMask("9.0")
+            self.layout.addWidget(self.dataEditBox)
+#        elif type == "BOOL":
+#            self.typeDropBox.setCurrentIndex(2)
+#        elif type == "INT":
+#            self.typeDropBox.setCurrentIndex(3)
+#        elif type == "INTPAIR":
+#            self.typeDropBox.setCurrentIndex(4)
+#        elif type == "INTTRIPLE":
+#            self.typeDropBox.setCurrentIndex(5)
+        
+    def createTypeDropBox(self, type):
+        self.typeDropBox = QComboBox(self)
+        self.typeDropBox.addItem("STRING")
+        self.typeDropBox.addItem("REAL")
+        self.typeDropBox.addItem("BOOL")
+        self.typeDropBox.addItem("INT")
+        self.typeDropBox.addItem("INTPAIR")
+        self.typeDropBox.addItem("INTTRIPLE")
+        
+        if type == "STRING":
+            self.typeDropBox.setCurrentIndex(0)
+        elif type == "REAL":
+            self.typeDropBox.setCurrentIndex(1)
+        elif type == "BOOL":
+            self.typeDropBox.setCurrentIndex(2)
+        elif type == "INT":
+            self.typeDropBox.setCurrentIndex(3)
+        elif type == "INTPAIR":
+            self.typeDropBox.setCurrentIndex(4)
+        elif type == "INTTRIPLE":
+            self.typeDropBox.setCurrentIndex(5)
+
+        self.connect(self, SIGNAL("currentIndexChanged ( const QString & text )"), self.onTypeChanged)
+
+    def onTypeChanged(self, type):
+        print str(type)
+        return
+        
+        
+        
+        
+        
+        
+        
+        
+        
+        
+        
+        
+        

Modified: rl/trunk/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2009-04-07 22:29:54 UTC (rev 4890)
+++ rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2009-04-10 12:25:20 UTC (rev 4891)
@@ -117,9 +117,17 @@
     def getType(self):
         return "MAP"
 
+
+
 # gameObjectClass is the id of the class itself
 # since a game object can be ingame more than once there is also a id for those
-class GameObjectRepresentation(og.UserDefinedObject):
+class GameObjectRepresentation(og.UserDefinedObject):     
+    class PropertieRepresentation():
+        def __init__(self, name = "", type = "STRING", data = ""):
+            self.name = name
+            self.type = type
+            self.data = data
+
     def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
         og.UserDefinedObject.__init__(self)
         self.inWorldId = inWorldId
@@ -127,7 +135,14 @@
         self.node = node
         self.meshFile = meshFile
         self.state = "IN_SCENE"
-
+        self.propertieDict = {}
+    
+    def addProperty(self):
+        return
+        
+    def editProperty(self, description):
+        return
+    
     def getType(self):
         return "GAME_OBJECT_REPRESENTATION"
 
@@ -177,7 +192,6 @@
         else:
             return self.meshFile
 
-
     def createProperty(self, property):
         if property.get("type") == "STRING":
             name = property.get("name")

Modified: rl/trunk/editors/Lockenwickler/src/GameObjectClassView.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GameObjectClassView.py	2009-04-07 22:29:54 UTC (rev 4890)
+++ rl/trunk/editors/Lockenwickler/src/GameObjectClassView.py	2009-04-10 12:25:20 UTC (rev 4891)
@@ -30,6 +30,7 @@
         super(GoTreeWidget, self).__init__(parent)
         self.setDragEnabled(True)
         self.setAnimated(True)
+        self.setAlternatingRowColors(True)
         
     def startDrag(self,  dropActions):
         data = QByteArray()
@@ -101,7 +102,6 @@
 
     def updateObjectList(self,  objectsDict):
         for key in objectsDict:
-            changeColor = True
             file = objectsDict[key]
             fileItem = QTreeWidgetItem(self.treeWidget)
             fileItem.setText(0, str(key))
@@ -111,22 +111,12 @@
                 goItem = QTreeWidgetItem(fileItem)
                 self.addItemToDict(go, goItem)
                 goItem.setIcon(0, QIcon("media/icons/agt_games.png"))
-                if changeColor:
-                    goItem.setBackgroundColor(0, QColor("lightGray"))
-                    goItem.setBackgroundColor(1, QColor("lightGray"))
-                    goItem.setBackgroundColor(2, QColor("lightGray"))
                 goItem.setText(0, str(go.classid))
                 goItem.setText(1, str(go.baseclass))
-                changeColor = not changeColor
 
-                changeColor2 = False
                 for prop in go.properties:
                     item1 = QTreeWidgetItem(goItem) #the property item, needs to be created regardless the type
                     self.addItemToDict(prop, item1)
-                    if changeColor:
-                        item1.setBackgroundColor(0, QColor("lightGray"))
-                        item1.setBackgroundColor(1, QColor("lightGray"))
-                        item1.setBackgroundColor(2, QColor("lightGray"))
                     item1.setIcon(0, QIcon("media/icons/agt_multimedia.png"))
                     item1.setText(0, str(prop.name))
                     item1.setText(1, prop.getType())
@@ -137,5 +127,4 @@
                     else:
                         item1.setText(2, unicode(prop.data))
 
-                    changeColor2 = not changeColor
 

Modified: rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-07 22:29:54 UTC (rev 4890)
+++ rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-10 12:25:20 UTC (rev 4891)
@@ -255,9 +255,9 @@
             return
 
         #get all selected items
-        items = self.sceneTreeView.selectedItems()
-        if len(items) == 1:
-            if str(items[0].parent().text(0)) == "Lights" and str(items[0].parent().parent().text(0)).startswith("Zone: "):
+        selItems = self.sceneTreeView.selectedItems()
+        if len(selItems) == 1:
+            if str(selItems[0].parent().text(0)) == "Lights" and str(selItems[0].parent().parent().text(0)).startswith("Zone: "):
                 return
         
         
@@ -278,11 +278,11 @@
 
         
         #end remove all the things from the list we actually don't want to be selected
-        for item in items:
+        for item in selItems:
             if str(item.text(0)).startswith("Scene: ") or str(item.text(0)).startswith("Map: ") or str(item.text(0)).startswith("Zone: "):
                 items.remove(item)
         
-        for item in items:
+        for item in selItems:
             parentName =  str(item.text(0))
                         
             name = str(item.data(0, Qt.UserRole).toString())

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-04-07 22:29:54 UTC (rev 4890)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-04-10 12:25:20 UTC (rev 4891)
@@ -332,7 +332,8 @@
             state = g.attrib["state"]
             nodePosition = None
             nodeRotation = None
-
+            properties = {}
+            
             transformations = g.getiterator()
             for t in transformations:
                 if t.tag == "position":
@@ -346,6 +347,11 @@
                     qy = float(t.attrib["qy"])
                     qz = float(t.attrib["qz"])
                     nodeRotation = og.Quaternion(qw, qx, qy, qz)
+                elif t.tag == "property":
+                    name = t.attrib["name"]
+                    type = t.attrib["type"]
+                    data = t.attrib["data"]
+                    properties[name] = GameObjectRepresentation.PropertieRepresentation(name, type, data)
 
             go = self.gocManager.getGameObjectWithClassId(classid)
             if go is not None:
@@ -364,6 +370,7 @@
                 self.gocManager.addGameObjectRepresentation(go)
                 go.inWorldId = id
                 go.state = state
+                go.propertieDict = properties
                 ent.setUserObject(go)
 
 
@@ -385,7 +392,7 @@
                     entElem = xml.SubElement(nodesElem, "entity")
                     entElem.attrib["name"] = n.getAttachedObject(0).getName()
                     entName = n.getAttachedObject(0).getName()
-                    print "Saving Entity: " + n.getAttachedObject(0).getName()
+                    #print "Saving Entity: " + n.getAttachedObject(0).getName()
                     entElem.attrib["meshfile"] = n.getAttachedObject(0).getMesh().getName()
    
                     entElem.attrib["receivesShadow"] = str(n.getAttachedObject(0).getUserObject().receivesShadow).lower()
@@ -412,7 +419,7 @@
                 elif n.name.startswith("gameobject_"):
                     goElem = xml.SubElement(nodesElem, "gameobject")
                     mname = n.name
-                    print "Saving GOID: " + str(n.getAttachedObject(0).getUserObject().inWorldId)
+                    #print "Saving GOID: " + str(n.getAttachedObject(0).getUserObject().inWorldId)
                     goElem.attrib["class"] = str(n.getAttachedObject(0).getUserObject().gocName)
                     goElem.attrib["state"] = str(n.getAttachedObject(0).getUserObject().state)
                     goElem.attrib["id"] = str(n.getAttachedObject(0).getUserObject().inWorldId)
@@ -428,10 +435,19 @@
                     rotElem.attrib["qy"] = str(n.getOrientation().y)
                     rotElem.attrib["qz"] = str(n.getOrientation().z)
                     
+                    dict = n.getAttachedObject(0).getUserObject().propertieDict
+                    for key in dict:
+                        prop = dict[key]
+                        rotElem = xml.SubElement(goElem, "property")
+                        rotElem.attrib["name"] = prop.name
+                        rotElem.attrib["type"] = prop.type
+                        rotElem.attrib["data"] = prop.data
+
+                    
                 elif n.name.startswith("light_"):
                     light = extractLight(n)
                     lightName = light.getName()
-                    print "Saving Light: " + lightName
+                    #print "Saving Light: " + lightName
                     lightType = light.getType()
                     isVisible = "true"
                     if not light.getVisible():
@@ -899,9 +915,11 @@
         self.resetSelection()
         self.userSelectionList = self.selectionBuffer.manualSelectObjects(items)
         
+        print len(self.userSelectionList)
+        
         if len(self.userSelectionList) > 1:
             self.propertyWindow.clear()
-        elif len(self.userSelectionList) == 1:
+        elif len(self.userSelectionList) > 0 and len(self.userSelectionList) < 2:
             self.propertyWindow.showProperties(self.userSelectionList[0])
         else:
             return

Modified: rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-04-07 22:29:54 UTC (rev 4890)
+++ rl/trunk/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-04-10 12:25:20 UTC (rev 4891)
@@ -22,6 +22,7 @@
 
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *
+from GOGenericEditor import *
 
 import ogre.renderer.OGRE as og
 
@@ -113,9 +114,9 @@
     def getValue(self):
         return str(self.combo.currentText())
     
-class ObjectPropertyWin(QDialog):
+class ObjectPropertyWin(QWidget):
     def __init__(self, sceneManager, gocManager, parent=None):
-        super(QDialog, self).__init__(parent)
+        super(QWidget, self).__init__(parent)
         self.setupUi()
         self.sceneManager = sceneManager
         self.valueBeforeEdit = None
@@ -199,7 +200,7 @@
     def onItemChanged(self, item, column):
         if self.valueBeforeEdit is not None and self.valueBeforeEdit != item.text(column):
             parent = item.parent()
-            if parent is None: # handle properties that don't expand here (pos, rot, scale etc)
+            if parent is None: # handle properties that don't expand here
                 if item.text(0) == "Name":
                     if self.node.getName().startswith("entity_"):
                         if not self.sceneManager.hasEntity(str(item.text(column))):
@@ -274,6 +275,51 @@
                     
                     self.node.getAttachedObject(0).getUserObject().renderingdistance = val
             else:
+                parentOfParent = parent.parent() 
+                if parentOfParent is not None and str(parentOfParent.text(0)).startswith("Properties"):
+                    propertiesDict = self.node.getAttachedObject(0).getUserObject().propertieDict
+                    prop = propertiesDict[str(parent.text(1))]
+                    self.disconnect(self.treeWidget, SIGNAL("itemChanged (QTreeWidgetItem *,int)"), self.onItemChanged)
+                    
+                    if item.text(0) == "Name":
+                        del propertiesDict[self.valueBeforeEdit]
+                        prop.name = str(item.text(1))
+                        propertiesDict[prop.name] = prop
+
+                        parent.setText(1, prop.name)
+
+                        
+                    elif item.text(0) == "Data" and prop.type == "STRING":
+                        prop.data = str(item.text(1))
+                        
+                    elif item.text(0) == "Data" and prop.type == "INT":
+                        val = None
+                        
+                        try:
+                            val = int(item.text(1))
+                        except ValueError, e:
+                            item.setText(column, self.valueBeforeEdit)
+                            print "ValueError: " + str(e)
+                            return
+                        
+                        prop.data = str(val)
+                    elif item.text(0) == "Data" and prop.type == "REAL":
+                        val = None
+                        
+                        try:
+                            val = float(item.text(1))
+                        except ValueError, e:
+                            item.setText(column, self.valueBeforeEdit)
+                            print "ValueError: " + str(e)
+                            return
+
+                        prop.data = str(val)
+                        
+                    self.connect(self.treeWidget, SIGNAL("itemChanged (QTreeWidgetItem *,int)"), self.onItemChanged)
+                    return
+                    
+                
+                
                 val = None
                 try:
                     val = float(item.text(1))
@@ -375,12 +421,37 @@
             item = QTreeWidgetItem(self.treeWidget)
             item.setText(0, "State")
             n = str(self.node.getAttachedObject(0).getUserObject().state)
-            item.setText(1, n)            
-            
+            item.setText(1, n)
+                
             self.parsePosition(self.node)
             self.parseOrientation(self.node)
-            self.parseScale(self.node)
+            self.parseScale(self.node)            
             
+            
+            propDict = self.node.getAttachedObject(0).getUserObject().propertieDict
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "Properties")
+            item.setText(1, str(len(propDict)))
+            
+            for key in propDict:
+                propParent = QTreeWidgetItem(item)
+                propParent.setText(0,  "Name")
+                propParent.setText(1,  propDict[key].name)
+                
+                propItem = QTreeWidgetItem(propParent)
+                propItem.setText(0,  "Name")
+                propItem.setText(1,  propDict[key].name)
+                propItem.setFlags(propItem.flags() | Qt.ItemIsEditable)
+                
+                propItem = QTreeWidgetItem(propParent)
+                propItem.setText(0,  "Type")
+                propItem.setText(1,  propDict[key].type)
+                
+                propItem = QTreeWidgetItem(propParent)
+                propItem.setText(0,  "Data")
+                propItem.setText(1,  propDict[key].data)
+                propItem.setFlags(propItem.flags() | Qt.ItemIsEditable)
+            
         elif name.startswith("light_"):
             item = QTreeWidgetItem(self.treeWidget)
             light = ModuleManager.extractLight(self.node)
@@ -414,6 +485,7 @@
             self.parseDiffuseColor(self.node)
             self.parseSpecularColor(self.node)
             self.parseLightAttenuation(self.node)
+            
         elif name.startswith("area_"):
             area = so.entity.getUserObject()
             item = QTreeWidgetItem(self.treeWidget)

Modified: rl/trunk/editors/Lockenwickler/src/ZoneManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ZoneManager.py	2009-04-07 22:29:54 UTC (rev 4890)
+++ rl/trunk/editors/Lockenwickler/src/ZoneManager.py	2009-04-10 12:25:20 UTC (rev 4891)
@@ -243,7 +243,7 @@
             for area in zone.areaList:
                 areaElem = xml.SubElement(zoneElem, "area")
                 areaElem.attrib["type"] = area.type
-                print "Saving Zone: " + zone.name + " - Area " + str(area.id)
+                #print "Saving Zone: " + zone.name + " - Area " + str(area.id)
                 if area.type == "mesh" and area.meshFile is not None:
                     areaElem.attrib["meshfile"] = area.meshFile
                     



From fusion2 at mail.berlios.de  Fri Apr 10 16:05:28 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Fri, 10 Apr 2009 16:05:28 +0200
Subject: [Dsa-hl-svn] r4892 - in rl/trunk/editors/Lockenwickler: . src
Message-ID: <200904101405.n3AE5SAc011477@sheep.berlios.de>

Author: fusion2
Date: 2009-04-10 16:05:26 +0200 (Fri, 10 Apr 2009)
New Revision: 4892

Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/src/GOGenericEditor.py
   rl/trunk/editors/Lockenwickler/src/GameObjectClass.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
Log:
- added a "Add Property" menu entry when right clicking on a gameobject in the 3d view

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-04-10 12:25:20 UTC (rev 4891)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-04-10 14:05:26 UTC (rev 4892)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Project SYSTEM "Project-4.6.dtd">
 <!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-03-21, 13:56:34 -->
+<!-- Saved: 2009-04-10, 16:03:00 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <Project version="4.6">
   <Language>en</Language>
@@ -40,6 +40,7 @@
     <Source>src/MaterialSelectionDialog.py</Source>
     <Source>src/DepthBuffer.py</Source>
     <Source>src/ZoneManager.py</Source>
+    <Source>src/GOGenericEditor.py</Source>
   </Sources>
   <Forms>
     <Form>ui files/GOPropertyEditorDialogINT.ui</Form>

Modified: rl/trunk/editors/Lockenwickler/src/GOGenericEditor.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GOGenericEditor.py	2009-04-10 12:25:20 UTC (rev 4891)
+++ rl/trunk/editors/Lockenwickler/src/GOGenericEditor.py	2009-04-10 14:05:26 UTC (rev 4892)
@@ -28,13 +28,12 @@
         
         self.layout = QVBoxLayout()
         
-        self.descEditBox = QLineEdit(self)
-        self.descEditBox.setText(description)
-        self.layout.addWidget(self.descEditBox)
+        self.nameEditBox = QLineEdit(self)
+        self.nameEditBox.setText(description)
+        self.layout.addWidget(self.nameEditBox)
         
-        self.createTypeDropBox()
+        self.createTypeDropBox(type)
         
-
         if type == "STRING":
             self.dataEditBox = QLineEdit(self)
             self.dataEditBox.setText(data)
@@ -53,6 +52,14 @@
 #        elif type == "INTTRIPLE":
 #            self.typeDropBox.setCurrentIndex(5)
         
+        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        self.connect(btnBox, SIGNAL("accepted()"), self.accept)
+        self.connect(btnBox, SIGNAL("rejected()"), self.reject)
+        self.layout.addWidget(btnBox)
+        
+        self.setLayout(self.layout)
+        
+        
     def createTypeDropBox(self, type):
         self.typeDropBox = QComboBox(self)
         self.typeDropBox.addItem("STRING")
@@ -74,7 +81,9 @@
             self.typeDropBox.setCurrentIndex(4)
         elif type == "INTTRIPLE":
             self.typeDropBox.setCurrentIndex(5)
-
+            
+        self.layout.addWidget(self.typeDropBox)
+        
         self.connect(self, SIGNAL("currentIndexChanged ( const QString & text )"), self.onTypeChanged)
 
     def onTypeChanged(self, type):

Modified: rl/trunk/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2009-04-10 12:25:20 UTC (rev 4891)
+++ rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2009-04-10 14:05:26 UTC (rev 4892)
@@ -27,6 +27,7 @@
 
 from GOStringEditor import *
 from GOIntEditor import *
+from GOGenericEditor import *
 
 class GOCStringProperty():
     def __init__(self, name, data):
@@ -137,9 +138,29 @@
         self.state = "IN_SCENE"
         self.propertieDict = {}
     
-    def addProperty(self):
-        return
-        
+    def addProperty(self, repeat = False):
+        if not repeat:
+            self.editor = GOGenericEditor("", "STRING", "", QApplication.focusWidget())
+            
+        if self.editor.exec_():
+            rep = GameObjectRepresentation.PropertieRepresentation()
+            rep.name = str(self.editor.nameEditBox.text())
+            rep.type = str(self.editor.typeDropBox.currentText())
+            
+            if rep.type == "STRING" or rep.type == "BOOL" or rep.type == "REAL" or rep.type == "INT":
+                rep.data = str(self.editor.dataEditBox.text())
+            
+            if rep.name in self.propertieDict:
+                reply = QMessageBox.question(QApplication.focusWidget(), "Warning", "Replace the existing property?" , QMessageBox.Yes|QMessageBox.No|QMessageBox.Cancel)
+                if reply == QMessageBox.Cancel:
+                    return
+                elif reply == QMessageBox.Yes:
+                    self.propertieDict[rep.name] = rep
+                elif reply == QMessageBox.No:
+                    self.addProperty(True)
+            else:
+                self.propertieDict[rep.name] = rep
+                
     def editProperty(self, description):
         return
     

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-04-10 12:25:20 UTC (rev 4891)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-04-10 14:05:26 UTC (rev 4892)
@@ -1364,6 +1364,7 @@
 
         if so is not None and so.entity.getParentNode().getName().startswith("gameobject_"):
             actions.append(self.createAction("Set Player Starterpoint", self.setPlayerStart))
+            actions.append(self.createAction("Add Property", so.entity.getUserObject().addProperty))
             self.playerStartGameObjectId = so.entity.getUserObject().inWorldId
             
                 



From timm at mail.berlios.de  Sat Apr 11 12:35:33 2009
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sat, 11 Apr 2009 12:35:33 +0200
Subject: [Dsa-hl-svn] r4893 - in rl/branches/persistence2:
	editors/Lockenwickler editors/Lockenwickler/src engine/ai/src
	engine/core/include engine/core/src engine/rules/src
	engine/script/src engine/ui/include engine/ui/src
Message-ID: <200904111035.n3BAZXXn007955@sheep.berlios.de>

Author: timm
Date: 2009-04-11 12:34:44 +0200 (Sat, 11 Apr 2009)
New Revision: 4893

Added:
   rl/branches/persistence2/editors/Lockenwickler/src/GOGenericEditor.py
Modified:
   rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p
   rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py
   rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py
   rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py
   rl/branches/persistence2/editors/Lockenwickler/src/ZoneManager.py
   rl/branches/persistence2/engine/ai/src/PhysicalObstacle.cpp
   rl/branches/persistence2/engine/core/include/PhysicalThing.h
   rl/branches/persistence2/engine/core/include/PhysicsManager.h
   rl/branches/persistence2/engine/core/include/PhysicsMaterialRaycast.h
   rl/branches/persistence2/engine/core/include/PhysicsRagDoll.h
   rl/branches/persistence2/engine/core/src/GameAreaTypes.cpp
   rl/branches/persistence2/engine/core/src/GameEventManager.cpp
   rl/branches/persistence2/engine/core/src/PhysicalThing.cpp
   rl/branches/persistence2/engine/core/src/PhysicsGenericContactCallback.cpp
   rl/branches/persistence2/engine/core/src/PhysicsManager.cpp
   rl/branches/persistence2/engine/core/src/PhysicsMaterialRaycast.cpp
   rl/branches/persistence2/engine/core/src/PhysicsRagDoll.cpp
   rl/branches/persistence2/engine/core/src/SceneQuery.cpp
   rl/branches/persistence2/engine/rules/src/CreatureController.cpp
   rl/branches/persistence2/engine/rules/src/CreatureControllerManager.cpp
   rl/branches/persistence2/engine/rules/src/SelectionHelper.cpp
   rl/branches/persistence2/engine/script/src/EntityNodeProcessor.cpp
   rl/branches/persistence2/engine/script/src/PlaneNodeProcessor.cpp
   rl/branches/persistence2/engine/ui/include/MovementControlState.h
   rl/branches/persistence2/engine/ui/src/CombatControlState.cpp
   rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp
   rl/branches/persistence2/engine/ui/src/MovementControlState.cpp
Log:
- merged trunk

Modified: rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p	2009-04-11 10:34:44 UTC (rev 4893)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Project SYSTEM "Project-4.6.dtd">
 <!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-03-21, 13:56:34 -->
+<!-- Saved: 2009-04-10, 16:03:00 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <Project version="4.6">
   <Language>en</Language>
@@ -40,6 +40,7 @@
     <Source>src/MaterialSelectionDialog.py</Source>
     <Source>src/DepthBuffer.py</Source>
     <Source>src/ZoneManager.py</Source>
+    <Source>src/GOGenericEditor.py</Source>
   </Sources>
   <Forms>
     <Form>ui files/GOPropertyEditorDialogINT.ui</Form>

Copied: rl/branches/persistence2/editors/Lockenwickler/src/GOGenericEditor.py (from rev 4892, rl/trunk/editors/Lockenwickler/src/GOGenericEditor.py)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py	2009-04-11 10:34:44 UTC (rev 4893)
@@ -27,6 +27,7 @@
 
 from GOStringEditor import *
 from GOIntEditor import *
+from GOGenericEditor import *
 
 class GOCStringProperty():
     def __init__(self, name, data):
@@ -117,9 +118,17 @@
     def getType(self):
         return "MAP"
 
+
+
 # gameObjectClass is the id of the class itself
 # since a game object can be ingame more than once there is also a id for those
-class GameObjectRepresentation(og.UserDefinedObject):
+class GameObjectRepresentation(og.UserDefinedObject):     
+    class PropertieRepresentation():
+        def __init__(self, name = "", type = "STRING", data = ""):
+            self.name = name
+            self.type = type
+            self.data = data
+
     def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
         og.UserDefinedObject.__init__(self)
         self.inWorldId = inWorldId
@@ -127,7 +136,34 @@
         self.node = node
         self.meshFile = meshFile
         self.state = "IN_SCENE"
-
+        self.propertieDict = {}
+    
+    def addProperty(self, repeat = False):
+        if not repeat:
+            self.editor = GOGenericEditor("", "STRING", "", QApplication.focusWidget())
+            
+        if self.editor.exec_():
+            rep = GameObjectRepresentation.PropertieRepresentation()
+            rep.name = str(self.editor.nameEditBox.text())
+            rep.type = str(self.editor.typeDropBox.currentText())
+            
+            if rep.type == "STRING" or rep.type == "BOOL" or rep.type == "REAL" or rep.type == "INT":
+                rep.data = str(self.editor.dataEditBox.text())
+            
+            if rep.name in self.propertieDict:
+                reply = QMessageBox.question(QApplication.focusWidget(), "Warning", "Replace the existing property?" , QMessageBox.Yes|QMessageBox.No|QMessageBox.Cancel)
+                if reply == QMessageBox.Cancel:
+                    return
+                elif reply == QMessageBox.Yes:
+                    self.propertieDict[rep.name] = rep
+                elif reply == QMessageBox.No:
+                    self.addProperty(True)
+            else:
+                self.propertieDict[rep.name] = rep
+                
+    def editProperty(self, description):
+        return
+    
     def getType(self):
         return "GAME_OBJECT_REPRESENTATION"
 
@@ -177,7 +213,6 @@
         else:
             return self.meshFile
 
-
     def createProperty(self, property):
         if property.get("type") == "STRING":
             name = property.get("name")

Modified: rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py	2009-04-11 10:34:44 UTC (rev 4893)
@@ -30,6 +30,7 @@
         super(GoTreeWidget, self).__init__(parent)
         self.setDragEnabled(True)
         self.setAnimated(True)
+        self.setAlternatingRowColors(True)
         
     def startDrag(self,  dropActions):
         data = QByteArray()
@@ -101,7 +102,6 @@
 
     def updateObjectList(self,  objectsDict):
         for key in objectsDict:
-            changeColor = True
             file = objectsDict[key]
             fileItem = QTreeWidgetItem(self.treeWidget)
             fileItem.setText(0, str(key))
@@ -111,22 +111,12 @@
                 goItem = QTreeWidgetItem(fileItem)
                 self.addItemToDict(go, goItem)
                 goItem.setIcon(0, QIcon("media/icons/agt_games.png"))
-                if changeColor:
-                    goItem.setBackgroundColor(0, QColor("lightGray"))
-                    goItem.setBackgroundColor(1, QColor("lightGray"))
-                    goItem.setBackgroundColor(2, QColor("lightGray"))
                 goItem.setText(0, str(go.classid))
                 goItem.setText(1, str(go.baseclass))
-                changeColor = not changeColor
 
-                changeColor2 = False
                 for prop in go.properties:
                     item1 = QTreeWidgetItem(goItem) #the property item, needs to be created regardless the type
                     self.addItemToDict(prop, item1)
-                    if changeColor:
-                        item1.setBackgroundColor(0, QColor("lightGray"))
-                        item1.setBackgroundColor(1, QColor("lightGray"))
-                        item1.setBackgroundColor(2, QColor("lightGray"))
                     item1.setIcon(0, QIcon("media/icons/agt_multimedia.png"))
                     item1.setText(0, str(prop.name))
                     item1.setText(1, prop.getType())
@@ -137,5 +127,4 @@
                     else:
                         item1.setText(2, unicode(prop.data))
 
-                    changeColor2 = not changeColor
 

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-11 10:34:44 UTC (rev 4893)
@@ -35,7 +35,7 @@
             i += 1
 
 class ExplorerOptionsDlg(QDialog):
-    def __init__(self, lights, gameObjects, entities, zones, parent = None):
+    def __init__(self, lights, gameObjects, entities, zones, zonelights, parent = None):
         super(ExplorerOptionsDlg, self).__init__(parent)
         
         buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
@@ -57,6 +57,10 @@
         self.zonesCheckBox.setChecked(zones)        
         layout.addWidget(self.zonesCheckBox)
         
+        self.zoneslightsCheckBox = QCheckBox("Show Zonelights")
+        self.zoneslightsCheckBox.setChecked(zonelights)        
+        layout.addWidget(self.zoneslightsCheckBox)
+        
         layout.addWidget(buttonBox)
         layout.setContentsMargins(2, 2, 2, 2)
         self.setLayout(layout)
@@ -83,9 +87,13 @@
     def __init__(self, parent = None):
         super(ModuleTreeWidget, self).__init__(parent)
         
+        self.moduleManager = None
         self.setContextMenuPolicy(Qt.CustomContextMenu)        
         self.connect(self, SIGNAL("customContextMenuRequested(const QPoint &)"), self.doMenu)
-
+        
+        self.setDragEnabled(True)
+        self.setAcceptDrops(True)
+        
         self.onMenuCallback = None
         self.setAnimated(True)
 
@@ -98,7 +106,78 @@
     def doMenu(self, point):
         self.onMenuCallback(point)
 
+    def startDrag(self, lvi):
+        relMousePos = self.mapFromGlobal(QPoint(QCursor.pos().x(), QCursor.pos().y() - self.header().height()))
+        item = self.itemAt(relMousePos)
+        if item is not None and not str(item.data(0, Qt.UserRole).toString()).startswith("light_") and not item.data(0, Qt.UserRole).toInt()[0] == ModuleExplorer.LIGHT_IN_ZONE:
+            return
+        
+        data = QByteArray()
+        stream = QDataStream(data,  QIODevice.WriteOnly)
+        stream << self.currentItem().text(0)
+        mimeData = QMimeData()
+        mimeData.setData("application/light", data)
+        drag = QDrag(self)
+        drag.setMimeData(mimeData)
+        drag.start(Qt.CopyAction)
+
+    def dragEnterEvent(self, event):
+        print "enter"
+        if event.mimeData().hasFormat("application/light"):
+            event.accept()
+            
+            items = self.selectedItems()
+            
+            if items[0].data(0, Qt.UserRole).toInt()[0] == ModuleExplorer.LIGHT_IN_ZONE:
+                zone = self.zoneManager.getZone(str(items[0].parent().parent().text(0)).replace("Zone: ", ""))
+                zone.lightList.remove(str(items[0].text(0)))
+                
+                items[0].parent().removeChild(items[0])
+                
+    def dragMoveEvent (self, event):
+        relMousePos = self.mapFromGlobal(QPoint(QCursor.pos().x(), QCursor.pos().y() - self.header().height()))
+        item = self.itemAt(relMousePos)
+        if item is not None and str(item.text(0)).startswith("Zone: "):
+            event.accept()
+        else:
+            event.ignore()
+            
+
+    def dropEvent(self, event):
+        if event.mimeData().hasFormat("application/light"):
+            data = event.mimeData().data("application/light")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        
+            relMousePos = self.mapFromGlobal(QPoint(QCursor.pos().x(), QCursor.pos().y() - self.header().height()))
+            item = self.itemAt(relMousePos)
+            str(item.data(0, Qt.UserRole).toString())
+            
+            items = self.findItems("Lights", Qt.MatchFixedString | Qt.MatchRecursive)
+            for iitem in items:
+                if iitem.parent() is item:
+                    zoneName = str(item.text(0)).replace("Zone: ", "")
+                    zone = self.zoneManager.getZone(zoneName)
+                    
+                    for light in zone.lightList:
+                        if str(light) == str(text):
+                            print "Zone \"" + zoneName + "\" already has Light \"" + str(light) + "\" attached!"
+                            return
+                    
+                    zone.lightList.append(text)
+                    child = QTreeWidgetItem(iitem)
+                    child.setText(0, text)
+                    child.setData(0, Qt.UserRole, QVariant(ModuleExplorer.LIGHT_IN_ZONE))
+
+
+
 class ModuleExplorer(QWidget):
+    LIGHT_IN_ZONE = 99
+    
     def __init__(self, parent=None):
         QWidget.__init__(self, parent)
         self.sceneTreeView = ModuleTreeWidget()
@@ -125,6 +204,7 @@
         self.onMenuPoint = None
         
         self.showLights = True
+        self.showZoneLights = True
         self.showGameObjects = True
         self.showEntities = True
         self.showZones = True
@@ -174,6 +254,13 @@
         if self.selectionChangedCallback is None:
             return
 
+        #get all selected items
+        selItems = self.sceneTreeView.selectedItems()
+        if len(selItems) == 1:
+            if str(selItems[0].parent().text(0)) == "Lights" and str(selItems[0].parent().parent().text(0)).startswith("Zone: "):
+                return
+        
+        
         nodeNames = {}
         
         # get all maps and add them as a key to the dictionary
@@ -188,15 +275,14 @@
         for item in items:
             nodeNames[str(item.text(0))] = []
         
-        #get all selected items
-        items = self.sceneTreeView.selectedItems()
+
         
         #end remove all the things from the list we actually don't want to be selected
-        for item in items:
+        for item in selItems:
             if str(item.text(0)).startswith("Scene: ") or str(item.text(0)).startswith("Map: ") or str(item.text(0)).startswith("Zone: "):
                 items.remove(item)
         
-        for item in items:
+        for item in selItems:
             parentName =  str(item.text(0))
                         
             name = str(item.data(0, Qt.UserRole).toString())
@@ -286,7 +372,7 @@
             menu.exec_(QCursor().pos())
     
     def onOptions(self):
-        dlg = ExplorerOptionsDlg(self.showLights, self.showGameObjects, self.showEntities, self.showZones, self)
+        dlg = ExplorerOptionsDlg(self.showLights, self.showGameObjects, self.showEntities, self.showZones, self.showZoneLights, self)
         if dlg.exec_():
             self.showLights = dlg.lightCheckBox.isChecked()
             self.showGameObjects = dlg.gameObjectsCheckBox.isChecked()
@@ -328,7 +414,10 @@
     
     def onDelete(self):
         print "delete"
-        
+
+    def keyPressEvent(self, event):
+        print "key!!!!!!!!!!!!!!"
+    
     def paintLastSelectedMapBlue(self):
         print self.lastSelectedMap
         for item in self.mapItems:
@@ -352,6 +441,7 @@
         self.mapSelectedCallback(sceneName, mapName)
         
     def updateView(self):
+        self.disconnect(self.sceneTreeView, SIGNAL("itemSelectionChanged ()"), self.onSelectionChanged)
         self.mapItems = []
         self.sceneTreeView.clear()
         
@@ -363,7 +453,8 @@
                 self.parseMap(m, sceneRootItem)
         
         self.paintLastSelectedMapBlue()
-
+        self.connect(self.sceneTreeView, SIGNAL("itemSelectionChanged ()"), self.onSelectionChanged)
+        
     def parseMap(self, map, sceneRootItem):
         childItem =  QTreeWidgetItem(sceneRootItem)
         self.mapItems.append(childItem)
@@ -434,13 +525,23 @@
                 childItem2.setText(0, "Area " + str(area.id))
                 childItem2.setData(0, Qt.UserRole, QVariant(area.areaNode.getName()))
                 i += 1
+             
+            if self.showZoneLights:
+                lightsItem = QTreeWidgetItem(childItem)
+                lightsItem.setText(0, "Lights")
                 
+                for lightName in zone.lightList:
+                    childItem2 = QTreeWidgetItem(lightsItem)
+                    childItem2.setText(0, lightName)
+                    childItem2.setData(0, Qt.UserRole, QVariant(ModuleExplorer.LIGHT_IN_ZONE))
+                    
     def setCurrentModule(self, module):
         self.module = module
         self.updateView()
 
     def setModuleManager(self, moduleManager):
         self.moduleManager = moduleManager
+        self.sceneTreeView.zoneManager = self.moduleManager.zoneManager
         
     def setMapSelectedCallback(self, callback):
         self.mapSelectedCallback = callback

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py	2009-04-11 10:34:44 UTC (rev 4893)
@@ -1,1356 +1,1392 @@
- #################################################
-# This source file is part of Rastullahs Lockenwickler.
-# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
-
-import sys
-import codecs
-import glob
-import os
-from os.path import isfile,  join
-
-import xml.etree.cElementTree as xml
-
-import ctypes
-import ogre.renderer.OGRE as og
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from SelectionBuffer import *
-from DepthBuffer import *
-from MovePivot import *
-from GameObjectClassManager import *
-from MyRaySceneQueryListener import *
-from ZoneManager import ZoneManager
-
-
-# get the light out of a light node
-def extractLight(node):
-        i = 0
-        num = node.numAttachedObjects()
-        while i < node.numAttachedObjects():
-            c = node.getAttachedObject(i)
-            tp = str(type(c))
-            if tp == "<class 'ogre.renderer.OGRE._ogre_.Light'>":
-                return c
-            
-            i += 1
-
-# make the xml file more pretty
-def indent(elem, level=0):
-    i = "\n" + level*"  "
-    
-    if len(elem):
-        if not elem.text or not elem.text.strip():
-            elem.text = i + "  "
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-        for elem in elem:
-            indent(elem, level+1)
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-    else:
-        if level and (not elem.tail or not elem.tail.strip()):
-            elem.tail = i
-
-# creates unique names for new entities
-def createUniqueEntityName(sceneManager, name = None):
-    n = ""
-    if name is None:
-        n = "dropMesh" + str(ModuleManager.dropCount)
-    else:
-        n = name
-        
-    while sceneManager.hasEntity(n):
-        n = "dropMesh" + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-    return n
-        
-def printVector3(vec):
-    print str(vec.x) + ";" + str(vec.y) + ";" + str(vec.z)
-    
-class EntityCustomOptions(og.UserDefinedObject):
-    def __init__(self, receivesShadow = True, staticgeometrygroup = 0, physicsproxytype = "none", renderingdistance = "20000"):
-        og.UserDefinedObject.__init__(self)
-        self.receivesShadow = receivesShadow
-        self.staticgeometrygroup = staticgeometrygroup
-        self.physicsproxytype = physicsproxytype
-        self.renderingdistance = renderingdistance
-        self.materialName = "NotChanged"
-        
-        ModuleManager.entityCustomOptionsDict.append(self)
-        
-    def copy(self):
-            return EntityCustomOptions(self.receivesShadow, self.staticgeometrygroup, self.physicsproxytype, self.renderingdistance)
-        
-    def getType(self):
-            return "EntityCustomOptions"
-
-class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyMap = False):
-        self.pathToMapFile = pathToFile
-        
-        mapName = pathToFile.replace("\\", "/")
-        mapName = mapName.split("/")
-        mapName = mapName[len(mapName) - 1].split(".")
-        mapName = mapName[len(mapName) - 3]
-        self.mapName = mapName
-        self.mapFileName = self.mapName + ".rlmap.xml"
-        
-        self.sceneManager = sceneManager
-        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-        self.zoneManager = zoneManager
-        self.isHidden = False
-        
-        self.zoneList = []
-        
-        if not emptyMap:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-
-            if root.attrib["formatVersion"] == "0.4.0":
-                self.parseMapNodes(root.find("nodes"))
-                self.parseMapZones(root.find("zones"))
-            else:
-                print pathToFile + " has wrong format version. It needs to be 0.4.0"
-                return
-
-    def hide(self):
-        try:
-            self.sceneManager.getRootSceneNode().removeChild(self.mapNode)
-        except:
-            print "Error: map is already hidden!"
-            return
-        
-        self.isHidden = True
-        
-    def show(self):
-        try:
-            self.sceneManager.getRootSceneNode().addChild(self.mapNode)
-        except:
-            print "Error: map is already shown!"
-            return
-        
-        self.isHidden = False
-    
-    def parseMapZones(self, zonesElement):
-        self.zoneManager.parseZonesFromXml(zonesElement, self)
-    
-    def parseMapNodes(self, nodeElement):
-        nodes = nodeElement.getiterator("gameobject")
-        self.createGameObjects(nodes)
-        
-        nodes = nodeElement.getiterator("entity")
-        self.createEntites(nodes)
-
-        nodes = nodeElement.getiterator("light")
-        self.createLights(nodes)
-
-        nodes = nodeElement.getiterator("sound")
-        self.createSound(nodes)
-
-        nodes = nodeElement.getiterator("particlesystem")
-        self.createParticleSystems(nodes)
-
-    def createEntites(self, entityNodes):
-        for nodes in entityNodes:
-            entityName = nodes.attrib["name"]
-            
-            if entityName.startswith("dropMesh"):
-                num = int(entityName.replace("dropMesh",  ""))
-                if ModuleManager.dropCount < num:
-                    ModuleManager.dropCount = num
-                elif ModuleManager.dropCount < num:
-                    ModuleManager.dropCount = num + 1
-                    
-            meshFile = nodes.attrib["meshfile"]
-            
-            eco = EntityCustomOptions()
-            
-            try:
-                if nodes.attrib["receivesShadow"] == "False" or nodes.attrib["receivesShadow"] == "false":
-                    eco.receivesShadow = "False"
-            except:
-                pass
-            try:
-                eco.staticgeometrygroup = int(nodes.attrib["staticgeometrygroup"])
-            except:
-                pass
-            try:
-                eco.physicsproxy = nodes.attrib["physicsproxy"]
-            except:
-                pass
-            try:
-                eco.renderingdistance = float(nodes.attrib["renderingdistance"])
-            except:
-                pass
-            try:
-                eco.renderingdistance
-                nodes.attrib["materialName"]
-            except:
-                pass
-                
-            nodePosition = None
-            nodeScale = None
-            qw = qx = qy = qz = None
-
-            transformations = nodes.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    posx = float(t.attrib["x"])
-                    posy = float(t.attrib["y"])
-                    posz = float(t.attrib["z"])
-                    nodePosition = og.Vector3(posx, posy, posz)
-                elif t.tag == "rotation":
-                    qw = float(t.attrib["qw"])
-                    qx = float(t.attrib["qx"])
-                    qy = float(t.attrib["qy"])
-                    qz = float(t.attrib["qz"])
-                elif t.tag == "scale":
-                    scalex = float(t.attrib["x"])
-                    scaley = float(t.attrib["y"])
-                    scalez = float(t.attrib["z"])
-                    nodeScale = og.Vector3(scalex, scaley, scalez)
-
-            try:
-                e = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager,  entityName), meshFile)
-            except:
-                print "Warning: Meshfile " + meshFile + " could not be found."
-                return
-
-            e.setUserObject(eco)
-            n = self.mapNode.createChild("entity_" + entityName + "_node")
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            n.setOrientation(qw, qx, qy, qz)
-            n.setScale(nodeScale)
-
-    def createLights(self, lightNodes):
-        for l in lightNodes:
-            lightName = l.attrib["name"]
-            lightType = l.attrib["type"]
-            lightVisible = bool(l.attrib["visible"])
-            castShadows = bool(l.attrib["castShadows"])
-            lightPosition = None
-            lightDirection = None
-            colourDiffuse = None
-            colourSpecular = None
-            lightAttenuationRange = None
-            lightAttenuationConstant= None
-            lightAttenuationLinear = None
-            lightAttenuationQuadratic = None
-            spotlightinner = None
-            spotlightouter = None
-            falloff = None 
-                
-            transformations = l.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    lightPosition = og.Vector3(x, y, z)
-                elif t.tag == "colourDiffuse":
-                    r = float(t.attrib["r"])
-                    g = float(t.attrib["g"])
-                    b= float(t.attrib["b"])
-                    colourDiffuse = og.ColourValue(r, g, b)
-                elif t.tag == "colourSpecular":
-                    r = float(t.attrib["r"])
-                    g = float(t.attrib["g"])
-                    b= float(t.attrib["b"])
-                    colourSpecular = og.ColourValue(r, g, b)
-                elif t.tag == "lightAttenuation":
-                    lightAttenuationRange = float(t.attrib["range"])
-                    lightAttenuationConstant= float(t.attrib["constant"])
-                    lightAttenuationLinear = float(t.attrib["linear"])
-                    lightAttenuationQuadric  = float(t.attrib["quadratic"])
-                elif t.tag == "spotlightrange":
-                    spotlightinner = float(t.attrib["inner"])
-                    spotlightouter = float(t.attrib["outer"])
-                    falloff = float(t.attrib["falloff"])
-                    
-            light = self.sceneManager.createLight(lightName)
-            
-            if lightType == "point":
-                light.setType(og.Light.LT_POINT)            
-            elif lightType == "spot":
-                light.setType(og.Light.LT_SPOTLIGHT)
-            elif lightType == "directional":
-                light.setType(og.Light.LT_DIRECTIONAL)
-            
-            light.setVisible(lightVisible)
-            light.setCastShadows(castShadows)
-            if lightAttenuationRange is not None and lightAttenuationConstant is not None and lightAttenuationLinear is not None and lightAttenuationQuadric is not None:
-                light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadric)
-            if colourDiffuse:
-                light.setDiffuseColour(colourDiffuse)
-            if colourSpecular:
-                light.setSpecularColour(colourSpecular)
-            if spotlightinner and spotlightouter and spotlightouter: 
-                light.setSpotlightRange(spotlightinner, spotlightouter, falloff)
-            
-            e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
-            n = self.mapNode.createChild("light_" + lightName + "_node")
-            n.attachObject(light)
-            n.attachObject(e)
-            if lightPosition:
-                n.setPosition(lightPosition)
-            
-    def createSound(self, soundNodes):
-        #raise NotImplementedError
-        return
-
-    def createGameObjects(self, gameObjectNodes):
-        for g in gameObjectNodes:
-            classid = g.attrib["class"]
-            
-            id = int(g.attrib["id"])
-            if ModuleManager.dropCount < id:
-                ModuleManager.dropCount = id
-            elif ModuleManager.dropCount < id:
-                ModuleManager.dropCount = id + 1
-                
-            state = g.attrib["state"]
-            nodePosition = None
-            nodeRotation = None
-
-            transformations = g.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    nodePosition = og.Vector3(x, y, z)
-                elif t.tag == "rotation":
-                    qw = float(t.attrib["qw"])
-                    qx = float(t.attrib["qx"])
-                    qy = float(t.attrib["qy"])
-                    qz = float(t.attrib["qz"])
-                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
-
-            go = self.gocManager.getGameObjectWithClassId(classid)
-            if go is not None:
-                meshFile = go.getMeshFileName()
-                
-                ent = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-                dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
-                dropNode.attachObject(ent)
-
-                if nodePosition:
-                    dropNode.setPosition(nodePosition)
-                if nodeRotation:
-                    dropNode.setOrientation(nodeRotation)
-
-                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
-                self.gocManager.addGameObjectRepresentation(go)
-                go.inWorldId = id
-                go.state = state
-                ent.setUserObject(go)
-
-
-    def createParticleSystems(self, particleNodes):
-        #raise NotImplementedError
-        return
-        
-    def save(self):
-        root = xml.Element("rastullahmap")
-        root.attrib["formatVersion"] = "0.4.0"
-        
-        nodesElem = xml.SubElement(root, "nodes")
-        
-        i = 0
-        while i < self.mapNode.numChildren():
-            n = self.mapNode.getChild(i)
-            if n.numAttachedObjects() > 0:
-                if n.name.startswith("entity_"):
-                    entElem = xml.SubElement(nodesElem, "entity")
-                    entElem.attrib["name"] = n.getAttachedObject(0).getName()
-                    print "Saving Entity: " + n.getAttachedObject(0).getName()
-                    entElem.attrib["meshfile"] = n.getAttachedObject(0).getMesh().getName()
-   
-                    entElem.attrib["receivesShadow"] = str(n.getAttachedObject(0).getUserObject().receivesShadow).lower()
-                    entElem.attrib["staticgeometrygroup"] = str(n.getAttachedObject(0).getUserObject().staticgeometrygroup)
-                    entElem.attrib["physicsproxytype"] = str(n.getAttachedObject(0).getUserObject().physicsproxytype)
-                    entElem.attrib["renderingdistance"] = str(n.getAttachedObject(0).getUserObject().renderingdistance)
-                    
-                    posElem = xml.SubElement(entElem, "position")
-                    posElem.attrib["x"] = str(n.getPosition().x)
-                    posElem.attrib["y"] = str(n.getPosition().y)
-                    posElem.attrib["z"] = str(n.getPosition().z)
-                    
-                    rotElem = xml.SubElement(entElem, "rotation")
-                    rotElem.attrib["qw"] = str(n.getOrientation().w)
-                    rotElem.attrib["qx"] = str(n.getOrientation().x)
-                    rotElem.attrib["qy"] = str(n.getOrientation().y)
-                    rotElem.attrib["qz"] = str(n.getOrientation().z)
-                    
-                    scaleElem = xml.SubElement(entElem, "scale")
-                    scaleElem.attrib["x"] = str(n.getScale().x)
-                    scaleElem.attrib["y"] = str(n.getScale().y)
-                    scaleElem.attrib["z"] = str(n.getScale().z)
-                    
-                elif n.name.startswith("gameobject_"):
-                    goElem = xml.SubElement(nodesElem, "gameobject")
-                    mname = n.name
-                    print "Saving GOID: " + str(n.getAttachedObject(0).getUserObject().inWorldId)
-                    goElem.attrib["class"] = str(n.getAttachedObject(0).getUserObject().gocName)
-                    goElem.attrib["state"] = str(n.getAttachedObject(0).getUserObject().state)
-                    goElem.attrib["id"] = str(n.getAttachedObject(0).getUserObject().inWorldId)
-                    
-                    posElem = xml.SubElement(goElem, "position")
-                    posElem.attrib["x"] = str(n.getPosition().x)
-                    posElem.attrib["y"] = str(n.getPosition().y)
-                    posElem.attrib["z"] = str(n.getPosition().z)
-                    
-                    rotElem = xml.SubElement(goElem, "rotation")
-                    rotElem.attrib["qw"] = str(n.getOrientation().w)
-                    rotElem.attrib["qx"] = str(n.getOrientation().x)
-                    rotElem.attrib["qy"] = str(n.getOrientation().y)
-                    rotElem.attrib["qz"] = str(n.getOrientation().z)
-                    
-                elif n.name.startswith("light_"):
-                    light = extractLight(n)
-                    lightName = light.getName()
-                    print "Saving Light: " + lightName
-                    lightType = light.getType()
-                    isVisible = "true"
-                    if not light.getVisible():
-                        isVisible = "false"
-                    
-                    castShadows = "false"
-                    if light.getCastShadows():
-                        castShadows = "true"
-                    
-                    if lightType == og.Light.LT_POINT:
-                        lightType = "point"
-                    elif lightType == og.Light.LT_SPOTLIGHT:
-                        lightType = "spot"
-                    elif lightType == og.Light.LT_DIRECTIONAL:
-                        lightType = "directional"
-                    
-                    
-                    lightElem = xml.SubElement(nodesElem, "light")
-                    lightElem.attrib["name"] = lightName
-                    lightElem.attrib["type"] = lightType
-                    lightElem.attrib["visible"] = isVisible
-                    lightElem.attrib["castShadows"] = castShadows
-                    
-                    if lightType == "point" or lightType == "spot":
-                        posElem = xml.SubElement(lightElem, "position")
-                        posElem.attrib["x"] = str(n.getPosition().x)
-                        posElem.attrib["y"] = str(n.getPosition().y)
-                        posElem.attrib["z"] = str(n.getPosition().z)
-                    
-                    colDiffuseElem = xml.SubElement(lightElem, "colourDiffuse")
-                    colDiffuseElem.attrib["r"] = str(light.getDiffuseColour().r)
-                    colDiffuseElem.attrib["g"] = str(light.getDiffuseColour().g)
-                    colDiffuseElem.attrib["b"] = str(light.getDiffuseColour().b)
-
-                    colSpecularElem = xml.SubElement(lightElem, "colourSpecular")
-                    colSpecularElem.attrib["r"] = str(light.getSpecularColour().r)
-                    colSpecularElem.attrib["g"] = str(light.getSpecularColour().g)
-                    colSpecularElem.attrib["b"] = str(light.getSpecularColour().b)
-                    
-                    lightAttenuationElem = xml.SubElement(lightElem, "lightAttenuation")
-                    lightAttenuationElem.attrib["range"] = str(light.getAttenuationRange())
-                    lightAttenuationElem.attrib["constant"] = str(light.getAttenuationConstant())
-                    lightAttenuationElem.attrib["linear"] = str(light.getAttenuationLinear())
-                    lightAttenuationElem.attrib["quadratic"] = str(light.getAttenuationQuadric())
-                    
-                    if lightType == "spot":
-                        spotligthRangeElem = xml.SubElement(lightElem, "spotlightrange")
-                        spotligthRangeElem.attrib["inner"] = str(light.getSpotlightInnerAngle().valueDegrees())
-                        spotligthRangeElem.attrib["outer"] = str(light.getSpotlightOuterAngle().valueDegrees())
-                        spotligthRangeElem.attrib["falloff"] = str(light.getSpotlightFalloff())
-                        
-                    if lightType == "spot" or lightType == "directional":
-                        directionElem = xml.SubElement(lightElem, "direction")
-                        dir = og.Vector3()
-                        n.getOrientation().ToAxes(dir)
-                        directionElem.attrib["x"] = str(dir.x)
-                        directionElem.attrib["y"] = str(dir.y)
-                        directionElem.attrib["z"] = str(dir.z)
-                        
-            i = i+1
-            
-        self.zoneManager.saveZonesToXml(root, self)
-        indent(root)
-        xml.ElementTree(root).write(self.pathToMapFile)
-
-# caused a linux crash
-#        iter = self.mapNode.getChildIterator()
-#        while iter.hasMoreElements():
-#            name = iter.getNext().getName()
-#            print name
-
-class Scene():
-    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyScene = False, sceneName = "NewScene"):
-        self.moduleRoot = moduleroot
-        self.pathToFile = pathToFile
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-        self.zoneManager = zoneManager
-        self.mapFiles = [] # a list in case the module has more than one map file
-        mappaths = []
-        self.name = sceneName
-
-        
-        if not emptyScene:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-            self.name = root.attrib["name"]
-        
-            maps = root.getiterator("map")
-            for m in maps:
-                mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
-                
-            for m in mappaths:
-                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
-            
-    def addMap(self, name):
-        path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
-        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True))
-        
-    def save(self):
-        root = xml.Element("scene")
-        root.attrib["name"] = self.name
-        
-        for m in self.mapFiles:
-            sub = xml.SubElement(root, "map")
-            sub.attrib["file"] = m.mapFileName
-            m.save()
-
-        indent(root)
-        xml.ElementTree(root).write(self.pathToFile)
-
-class Module():
-    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager, zoneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gameObjectManager
-        self.zoneManager = zoneManager
-        
-        self.name = name
-        self.moduleRoot = join(modulePath, name)
-        self.__isCommon = False
-
-        self.hasDependencies = False
-        self.moduleDependencies = []
-
-        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
-
-        self.gofFiles = [] # gof File list
-
-        self.scenes =[]
-
-        self.isLoaded = False
-        
-        self.playerStart = None
-        
-    def addScene(self, name):
-        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True, name))
-    
-    def addMapToScene(self, sceneName, mapName):
-        for scene in self.scenes:
-            if scene.name == sceneName:
-                scene.addMap(mapName)
-                return
-        
-        print "ERROR: could not find scene: " + sceneName
-        
-    
-    def isCommon(self):
-        if isfile(self.modConfig): # is the modconfig existing?
-            f = codecs.open(self.modConfig, 'r', 'utf-8')
-        else:
-            print ("Module.isCommon() Error: couldn't find module config")
-            return
-        isDependencieLine = False
-        for i, line in enumerate(f):
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith("super("):
-                split = lStripped.split(",")
-                if split[2].strip() == unicode("true"):
-                    self.__isCommon = True
-                    return True
-
-
-            elif isDependencieLine:
-                if lStripped == "end":
-                    isDependencieLine = False
-                else:
-                    self.hasDependencies = True
-                    pl = lStripped.split('"')
-                    i = 1
-                    while i < 100: 
-                        try:
-                            self.moduleDependencies.append(pl[i])
-                            i += 2
-                        except IndexError, e:
-                            break
-
-            elif lStripped == "def getDependencies()":
-                isDependencieLine = True
-
-        return False
-
-    def load(self):
-        if self.isLoaded:
-            return
-        
-        self.isLoaded = True
-        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
-        if isfile(self.modConfig): # is the modconfig existing?
-            f = codecs.open(self.modConfig, 'r', 'utf-8')
-        else:
-            print ("Module.load: Error: couldn't find module config")
-            return
-
-        for line in f:
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith("hero = $GOM.getGameObject("):
-                try:
-                    self.playerStart = int(line.split("(")[1].split(")")[0])
-                except ValueError, e:
-                    print self.modConfig + " ValueError: " + str(e)
-                    self.playerStart = None
-                    continue
-                    
-        self.setResourcePaths()
-        
-        try:
-            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-        except og.OgreException, e:
-            print e
-        
-        
-        cmd = join(self.moduleRoot, "dsa/*.gof")
-        self.gofFiles = glob.glob(cmd)
-        self.gocManager.parseGOFFiles(self.gofFiles)
-
-        if not self.isCommon():
-            cmd = join(self.moduleRoot, "maps/*.rlscene")
-            sceneFile = glob.glob(cmd)
-            self.loadScenes(sceneFile)
-                
-    def loadScenes(self, sceneFiles):
-        for s in sceneFiles:
-            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
-
-    def save(self):
-        for s in self.scenes:
-            s.save()
-            
-        self.saveModuleConfig()
-
-    def saveModuleConfig(self):
-        if self.playerStart is not None:
-            f = open(self.modConfig, "r")
-            
-            newconfig = ""
-            for line in f:
-                if line.startswith("       hero = $GOM.getGameObject("):
-                    newconfig += "       hero = $GOM.getGameObject(" + str(self.playerStart) + ");\n"
-                else:
-                    newconfig += line
-            f.close()
-            
-            f = open(self.modConfig, "w")
-            f.write(newconfig)
-            f.close()
-
-    def setResourcePaths(self, recurseFolder = ""):
-        if recurseFolder == "":
-            rootFolder = self.moduleRoot
-        else:
-            rootFolder = join(self.moduleRoot, recurseFolder)
-
-        for file in os.listdir(rootFolder):
-            curFile = join(rootFolder, file)
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            elif os.path.isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
-                self.setResourcePaths(curFile)
-            elif os.path.isfile(curFile):
-                continue
-                
-    def getMap(self, mapName, sceneName = None):
-        if sceneName is not None:
-            for s in self.scenes:
-                if s.name == sceneName:
-                    for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-        else:
-            for s in self.scenes:
-                for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-
-class ProgressBarThread(QThread):
-    def __init__(self, min, max, moduleName):
-        QThread.__init__(self)
-        self.progress = QProgressDialog("Loading " + moduleName, "Abort Loading", min, max, None);
-        self.progress.setWindowModality(Qt.WindowModal)
-
-    def setProgress(self, progress, labelText):
-        self.progress.setLabelText(labelText)
-        self.progress.setValue(progress)
-        
-    def run(self):
-        self.progress.show()
-        self.exec_()
-
-        
-class ModuleManager():
-    dropCount = 0
-    entityCustomOptionsDict = []
-    
-    def __init__(self,  ogreRoot,  sceneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.modelSelectionDialog = None
-        self.materialSelectionDialog = None
-
-        self.moduleCfgPath = ""
-
-        self.gocManager = GameObjectClassManager()
-        
-
-        self.mainModule = None
-        self.mainModuledependencieList =[]
-        self.moduleList = []
-        self.userSelectionList = []
-        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
-        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-        self.currentMap = None
-        self.moduleExplorer = None
-
-        self.lastRay = None
-        self.rayLine = None
-
-        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
-        self.pivot = None
-        self.movingPivot = False
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.dropNode = None
-        self.dropEntity = None
-        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
-        self.dropMat = None
-        
-        self.moduleConfigIsParsed = False
-
-        self.selectionBuffer = None
-        self.depthBuffer = None
-        self.propertyWindow = None
-    
-        self.oneClickEntityPlacement = False
-        
-        self.onContextMenuCallback = None
-        self.contextMenuClickPosition = None
-        self.contextMenuRay = None
-        
-        self.playerStartGameObjectId = None
-        
-        self.entityCustomOptionsDict = []
-        
-        self.raySceneQueryListener = MyRaySceneQueryListener()
-        
-        self.zoneManager = ZoneManager(self.sceneManager)
-        
-    def resetParsedModuleConfig(self):
-        self.moduleConfigIsParsed = False
-        self.moduleList = []
-
-    def parseModuleConfig(self):
-        if self.moduleConfigIsParsed:
-            return
-
-        import codecs
-        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
-
-        for line in f:
-            if line.startswith('#'):
-                continue
-
-            if line.startswith('module='):
-                splines = line.split('=')
-                str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
-
-        self.moduleConfigIsParsed = True
-
-    def moduleExists(self, name):
-        lowerA = str(name).lower()
-        
-        for m in self.moduleList:
-            lowerB = m.name.lower()
-            if lowerA == lowerB:
-                return True
-        
-        return False
-
-    def openLoadModuleDialog(self):
-        self.moduleFolder = str(self.moduleCfgPath.replace("modules.cfg", ""))
-
-        self.parseModuleConfig()
-
-        dlg = QDialog(QApplication.focusWidget())
-        list = QListWidget()
-        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
-        dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
-        dlg.connect(btnBox, SIGNAL("rejected()"), dlg.reject)
-
-        for m in self.moduleList:
-            if not m.isCommon():
-                list.addItem(m.name)
-
-        layout = QVBoxLayout()
-        layout.addWidget(list)
-        layout.addWidget(btnBox)
-        dlg.setLayout(layout)
-        if dlg.exec_():
-            self.loadModule(str(list.currentItem().text()))
-
-    # I'm sorry for this
-    def loadModule(self, moduleName):
-        t = og.Timer()
-        
-#        self.progress = ProgressBarThread(0, 8, moduleName)
-#        self.progress.start()
-        
-        for m in self.moduleList:
-            if m.name == moduleName:
-                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
-                    for moduleDependencie in m.moduleDependencies:
-                        for m2 in self.moduleList:
-                            if m2.name == moduleDependencie:
-#                                self.progress.setProgress(2, "Loading Dependencie: " + moduleDependencie)
-                                m2.load()
-                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
-                                self.materialSelectionDialog.scanDirForMaterials(m2.moduleRoot)
-                                self.mainModuledependencieList.append(m2)
-
-#                self.progress.setProgress(4, "Loading " + moduleName)
-                m.load()
-#                self.progress.setProgress(6, "Scan for models...")
-                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
-#                self.progress.setProgress(8, "Scan for materials")
-                self.materialSelectionDialog.scanDirForMaterials(m.moduleRoot)
-                self.mainModule = m
-                self.moduleExplorer.setCurrentModule(m)
-
-        if self.selectionBuffer is None:
-            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"), self, self.zoneManager)
-
-#        if self.depthBuffer is None:
-#            self.depthBuffer = DepthBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
-
-
-#        self.progress.quit()
-        print "Time to load module: " + str(t.getMilliseconds() / 1000.0) + " seconds"
-        del t
-
-    def addSceneToModule(self, name):
-        if self.mainModule is not None:
-            self.mainModule.addScene(name)
-
-    def addMapToScene(self, sceneName, mapName):
-        if self.mainModule is not None:
-            self.mainModule.addMapToScene(sceneName, mapName)
-
-    def setModuleExplorer(self, moduleExplorer):
-        self.moduleExplorer = moduleExplorer
-        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
-        self.moduleExplorer.setSelectionChangedCallback(self.selectionChangedCallback)
-        self.moduleExplorer.setModuleManager(self)
-    
-    def setPropertyWindow(self, propertyWin):
-        self.propertyWindow = propertyWin
-    
-    def selectionChangedCallback(self, items):
-        self.resetSelection()
-        self.userSelectionList = self.selectionBuffer.manualSelectObjects(items)
-        
-    def selectMapCallback(self, sceneName, mapName):
-        self.currentMap = self.mainModule.getMap(mapName, sceneName)
-        self.zoneManager.currentMap = self.currentMap
-        if self.currentMap is None:
-            print "Don't forget to select a map"
-
-        
-    # called when a click into Main Ogre Window occurs
-    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
-        if self.oneClickEntityPlacement:
-            if self.modelSelectionDialog.listWidget.currentItem() is not None:
-                meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
-                self.startDropModelAction(meshFile, ray)
-                self.moduleExplorer.updateView()
-                return
-            else:
-                print "Warning: OneClickEntityPlacement still runing on without any selected mesh!"
-                return
-                
-        #self.depthBuffer.onSelectionClick(screenX, screenY)
-        
-        so = None
-        if self.selectionBuffer is not None:
-            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        
-        if so is not None:
-            if not so.isPivot:                
-                if not controlDown and not shiftDown:
-                    self.resetSelection()
-                    so.setSelected(True)
-                    self.userSelectionList.append(so)
-                    self.propertyWindow.showProperties(so)
-                    self.moduleExplorer.deselectAll()
-                    self.moduleExplorer.selectItem(so, True)
-                    self.updatePivots()
-                elif controlDown and not shiftDown:
-                    so.setSelected(True)
-
-                    for soFromList in self.userSelectionList:
-                        if soFromList == so:
-                            return # object already selected
-
-                    self.userSelectionList.append(so)
-                    self.propertyWindow.showProperties(so)
-                    self.moduleExplorer.selectItem(so, True)
-                    self.updatePivots()
-
-
-                elif not controlDown and shiftDown:
-                    for selo in self.userSelectionList:
-                        if so == selo:
-                            so.setSelected(False)
-                            self.userSelectionList.remove(selo)
-                            self.moduleExplorer.selectItem(selo, False)
-                    self.updatePivots()
-                
-            else:
-                #so.entity is the pivot direction that was clicked
-                self.pivot.startTransforming(so.entity,  self.userSelectionList)
-        else:
-            self.resetSelection() # click in empty space, deselect everything
-            self.moduleExplorer.selectItems(None)
-            self.propertyWindow.clear()
-            if self.pivot is not None:
-                self.pivot.hide()
-
-#        if self.rayLine == None:
-#            self.rayLine = self.sceneManager.createManualObject("rayLine")
-#            self.rayLine.setDynamic(True)
-#            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
-#
-#            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-#
-#        else:
-#            self.rayLine.beginUpdate(0)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-
-    def deleteObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.pivot.hide()
-
-        for so in self.userSelectionList:
-            node = so.entity.getParentNode()
-            if node.getName().startswith("area_"):
-                self.zoneManager.deleteArea(so.entity.getUserObject())
-                continue
-            elif node.getName().startswith("light_"):
-                light = extractLight(node)
-                self.sceneManager.destroyLight(light)
-                
-            node.detachAllObjects()
-            self.sceneManager.destroySceneNode(node)
-            self.sceneManager.destroyEntity(so.entity)
-            del so
-
-        self.userSelectionList = []
-
-    def copyObjects(self):
-        if len(self.userSelectionList) < 1 or self.currentMap is None:
-            print "Warning: No map selected!"
-            return
-
-        newSelectionList = []
-
-        for so in self.userSelectionList:
-            if so.entity.getUserObject() is not None:
-                if str(so.entity.getParentNode().getName()).startswith("gameobject_"):
-                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
-                    meshFile = go.getMeshFileName()
-
-                    if go is not None:
-                        newEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-                        newNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
-                        newNode.attachObject(newEntity)
-                        newNode.setPosition(so.entity.getParentNode().getPosition())
-
-                        newGO = GameObjectRepresentation(ModuleManager.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
-                        self.gocManager.addGameObjectRepresentation(newGO)
-                        newEntity.setUserObject(newGO)
-
-                        newSO = SelectionObject(newEntity)
-                        newSO.setSelected(True)
-                        newSelectionList.append(newSO)
-                        ModuleManager.dropCount += 1
-                elif str(so.entity.getParentNode().getName()).startswith("entity_"):
-                    nodeName = "entity_dropNode" + str(ModuleManager.dropCount)
-                    newNode = self.currentMap.mapNode.createChild(nodeName)
-
-                    entityName = createUniqueEntityName(self.sceneManager)
-                    newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
-
-                    eco = so.entity.getUserObject().copy()
-                    newEntity.setUserObject(eco)
-
-                    newNode.attachObject(newEntity)
-                    newNode.setPosition(so.entity.getParentNode().getPosition())
-                    newNode.setOrientation(so.entity.getParentNode().getOrientation())
-                    newNode.setScale(so.entity.getParentNode().getScale())
-
-                    newSO = SelectionObject(newEntity)
-                    newSO.setSelected(True)
-                    newSelectionList.append(newSO)
-                    ModuleManager.dropCount += 1
-                elif str(so.entity.getParentNode().getName()).startswith("light_"):
-                    print "Can't copy lights yet :)"
-
-        self.resetSelection()
-        self.userSelectionList = newSelectionList
-
-    def cutObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.cutList = []
-        for so in self.userSelectionList:
-            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
-            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
-            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
-            # so we only have to translate them to their new destination when they get pasted
-            # the position of the pivot point is considered as the center of gravity
-            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
-            self.cutList.append(so)
-        self.resetSelection()
-
-    def pasteObjects(self,  ray):
-        if len(self.cutList) < 1:
-            return
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
-                i = i+1
-        else:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
-                i = i+1
-        self.cutList = []
-
-    def leftMouseUp(self):
-        if self.pivot is not None and self.pivot.isTransforming:
-            self.propertyWindow.updateProperties()
-            self.moduleExplorer.updateView()
-            self.pivot.stopTransforming()
-
-    def resetSelection(self):
-        if self.userSelectionList is not None:
-            for so in self.userSelectionList:
-                so.setSelected(False)
-
-        self.userSelectionList = []
-
-    def updatePivots(self):
-        newPivotPosition = og.Vector3(0, 0, 0)
-
-        for so in self.userSelectionList:
-            newPivotPosition += so.entity.getParentNode().getPosition()
-        if self.pivot is not None:
-            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
-
-    def unload(self,  saveOnUnload=True):
-        pass
-
-    def save(self):
-        self.mainModule.save()
-
-    def startDropGameObjectAction(self, classid, ray):
-        if self.currentMap is None:
-            print "No map selected!"
-            return
-            
-        go = self.gocManager.getGameObjectWithClassId(classid)
-
-        if go is not None:
-            meshFile = go.getMeshFileName()
-            dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
-            dropNode.attachObject(dropEntity)
-
-            result = og.Math.intersects(ray, self.dropCollisionPlane)
-            if result.first == True:
-                dropNode.setPosition(ray.getPoint(result.second))
-            else:
-                dropNode.setPosition(ray.getPoint(50))
-
-            self.dropGO = GameObjectRepresentation(ModuleManager.dropCount, classid, dropNode, meshFile)
-            self.gocManager.addGameObjectRepresentation(self.dropGO)
-            dropEntity.setUserObject(self.dropGO)
-
-        ModuleManager.dropCount += 1
-
-    def moveDropGameObjectAction(self, ray):
-        if self.currentMap is None:
-            return
-        
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropGO.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropGO.setPosition(ray.getPoint(50))
-
-    def finishDropGameObjectAction(self, ray):
-        self.moduleExplorer.updateView()
-        self.dropGO = None
-        return
-
-    def startDropModelAction(self, meshFile, ray):
-        if self.currentMap is None:
-            print "No map selected!"
-            return
-            
-        self.dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), meshFile)
-        
-        eco = EntityCustomOptions()
-        self.dropEntity.setUserObject(eco)
-        
-        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(ModuleManager.dropCount))
-        self.dropNode.attachObject(self.dropEntity)
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-        ModuleManager.dropCount += 1
-
-    def moveDropModelAction(self, ray):
-        if self.currentMap is None:
-            return
-            
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-    
-    def finishDropModelAction(self, ray):
-        self.moduleExplorer.updateView()
-        return
-
-    def startDropMaterialAction(self, text):
-        self.dropMat = text
-        
-    def moveDropMaterialAction(self, event):
-        return
-
-    def finishDropMaterialAction(self, screenX, screenY):
-        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        if so is not None:
-            if not so.entity.getNumSubEntities() > 1:
-                so.entity.setMaterialName(self.dropMat)
-                so.entity.getUserObject().materialName = self.dropMat
-            else:
-                i = 0
-                text = "Warning this Entity has more than one SubEntities with the folloing materials: \n\n"
-                while i < so.entity.getNumSubEntities():
-                    text += "SubMesh" + str(i) + ":  " + so.entity.getSubEntity(i).getMaterialName() + "\n"
-                    i += 1
-                
-                text += "\n Replace the materials?"
-                reply = QMessageBox.question(None, "Warning: multiple materials",  text,  QMessageBox.Yes|QMessageBox.No)
-                if reply == QMessageBox.Cancel:
-                    return
-                if reply == QMessageBox.Yes:
-                    so.entity.setMaterialName(self.dropMat)
-                    so.entity.getUserObject().materialName = self.dropMat
-        
-    def setOneClickEntityPlacement(self, state):
-        self.oneClickEntityPlacement = state
-    
-    def createLight(self, name):
-        pos = og.Vector3()
-        
-        query = self.sceneManager.createRayQuery(self.contextMenuRay)
-        query.ray = self.contextMenuRay
-        query.setSortByDistance(True)
-        query.execute(self.raySceneQueryListener)
-        if self.raySceneQueryListener.dist < 100000:
-            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
-            self.raySceneQueryListener.dist = 100000
-            
-        light = None
-        if not self.sceneManager.hasLight(name):
-            light = self.sceneManager.createLight(name)
-            
-        return light,  pos
-        
-    def addPointLight(self):
-        if self.currentMap is None:
-            print "No map selected!"
-            return
-            
-        lightName = "pointLight" + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-        light, pos = self.createLight(lightName)
-        printVector3(pos)
-        
-        if not light:
-            print "Error while creating light"
-            return
-            
-        light.setType(og.Light.LT_POINT)
-        
-        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
-        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
-        n.attachObject(light)
-        n.attachObject(e)
-        n.setPosition(pos)
-        self.moduleExplorer.updateView()
-        
-    def addSpotLight(self):
-        if self.currentMap is None:
-            print "No map selected!"
-            return
-            
-        lightName = "spotLight" + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-        light, pos = self.createLight(lightName)
-        printVector3(pos)
-        
-        if not light:
-            print "Error while creating light"
-            return
-            
-        light.setType(og.Light.LT_SPOTLIGHT)
-        
-        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
-        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
-        n.attachObject(light)
-        n.attachObject(e)
-        n.setPosition(pos)
-        self.moduleExplorer.updateView()
-        
-    def addZoneToMap(self, name):
-        self.zoneManager.createZone(name)
-        self.moduleExplorer.updateView()
-        
-    def setPlayerStart(self):
-        self.mainModule.playerStart = str(self.playerStartGameObjectId)
-        print "setting Player Start to " + str(self.playerStartGameObjectId)
-    
-    def onContextMenu(self, screenX, screenY, ray):
-        menus = []
-        actions = []
-        pla = self.createAction("Pointlight", self.addPointLight, None, "idea.png")
-        pls = self.createAction("Spotlight", self.addSpotLight, None, "idea.png")
-        
-        lightMenu = QMenu("Add Light")
-        lightMenu.addAction(pla)
-        lightMenu.addAction(pls)
-        menus.append(lightMenu)
-        
-        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        self.contextMenuClickPosition = og.Vector2(screenX, screenY)
-        self.contextMenuRay = ray
-        
-        pos = og.Vector3()
-        query = self.sceneManager.createRayQuery(self.contextMenuRay)
-        query.ray = self.contextMenuRay
-        query.setSortByDistance(True)
-        query.execute(self.raySceneQueryListener)
-        if self.raySceneQueryListener.dist < 100000:
-            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
-            self.raySceneQueryListener.dist = 100000
-        
-        if so is not None:
-            self.zoneManager.entityUnderMouse = so.entity
-        
-        self.zoneManager.newAreaPosition = pos
-        menus.append(self.zoneManager.getZoneMenu())
-
-        if so is not None and so.entity.getParentNode().getName().startswith("gameobject_"):
-            actions.append(self.createAction("Set Player Starterpoint", self.setPlayerStart))
-            self.playerStartGameObjectId = so.entity.getUserObject().inWorldId
-            
-                
-            
-        if self.onContextMenuCallback is not None:
-            self.onContextMenuCallback(actions,  menus)
-
-    def setContextMenuCallback(self, callback):
-        self.onContextMenuCallback = callback
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
-        action = QAction(text, None)
-        if icon is not None:
-            action.setIcon(QIcon("media/icons/%s" % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            QWidget.connect(action, SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import sys
+import codecs
+import glob
+import os
+from os.path import isfile,  join
+
+import xml.etree.cElementTree as xml
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from SelectionBuffer import *
+from DepthBuffer import *
+from MovePivot import *
+from GameObjectClassManager import *
+from MyRaySceneQueryListener import *
+from ZoneManager import ZoneManager
+
+
+# get the light out of a light node
+def extractLight(node):
+        i = 0
+        num = node.numAttachedObjects()
+        while i < node.numAttachedObjects():
+            c = node.getAttachedObject(i)
+            tp = str(type(c))
+            if tp == "<class 'ogre.renderer.OGRE._ogre_.Light'>":
+                return c
+            
+            i += 1
+
+# make the xml file more pretty
+def indent(elem, level=0):
+    i = "\n" + level*"  "
+    
+    if len(elem):
+        if not elem.text or not elem.text.strip():
+            elem.text = i + "  "
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+        for elem in elem:
+            indent(elem, level+1)
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+    else:
+        if level and (not elem.tail or not elem.tail.strip()):
+            elem.tail = i
+
+# creates unique names for new entities
+def createUniqueEntityName(sceneManager, name = None):
+    n = ""
+    if name is None:
+        n = "dropMesh" + str(ModuleManager.dropCount)
+    else:
+        n = name
+        
+    while sceneManager.hasEntity(n):
+        n = "dropMesh" + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+    return n
+        
+def printVector3(vec):
+    print str(vec.x) + ";" + str(vec.y) + ";" + str(vec.z)
+    
+class EntityCustomOptions(og.UserDefinedObject):
+    def __init__(self, receivesShadow = True, staticgeometrygroup = 0, physicsproxytype = "none", renderingdistance = "20000"):
+        og.UserDefinedObject.__init__(self)
+        self.receivesShadow = receivesShadow
+        self.staticgeometrygroup = staticgeometrygroup
+        self.physicsproxytype = physicsproxytype
+        self.renderingdistance = renderingdistance
+        self.materialName = "NotChanged"
+        
+        ModuleManager.entityCustomOptionsDict.append(self)
+        
+    def copy(self):
+            return EntityCustomOptions(self.receivesShadow, self.staticgeometrygroup, self.physicsproxytype, self.renderingdistance)
+        
+    def getType(self):
+            return "EntityCustomOptions"
+
+class Map():
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyMap = False):
+        self.pathToMapFile = pathToFile
+        
+        mapName = pathToFile.replace("\\", "/")
+        mapName = mapName.split("/")
+        mapName = mapName[len(mapName) - 1].split(".")
+        mapName = mapName[len(mapName) - 3]
+        self.mapName = mapName
+        self.mapFileName = self.mapName + ".rlmap.xml"
+        
+        self.sceneManager = sceneManager
+        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        self.zoneManager = zoneManager
+        self.isHidden = False
+        
+        self.zoneList = []
+        
+        if not emptyMap:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+
+            if root.attrib["formatVersion"] == "0.4.0":
+                self.parseMapNodes(root.find("nodes"))
+                self.parseMapZones(root.find("zones"))
+            else:
+                print pathToFile + " has wrong format version. It needs to be 0.4.0"
+                return
+
+    def hide(self):
+        try:
+            self.sceneManager.getRootSceneNode().removeChild(self.mapNode)
+        except:
+            print "Error: map is already hidden!"
+            return
+        
+        self.isHidden = True
+        
+    def show(self):
+        try:
+            self.sceneManager.getRootSceneNode().addChild(self.mapNode)
+        except:
+            print "Error: map is already shown!"
+            return
+        
+        self.isHidden = False
+    
+    def parseMapZones(self, zonesElement):
+        self.zoneManager.parseZonesFromXml(zonesElement, self)
+    
+    def parseMapNodes(self, nodeElement):
+        nodes = nodeElement.getiterator("gameobject")
+        self.createGameObjects(nodes)
+        
+        nodes = nodeElement.getiterator("entity")
+        self.createEntites(nodes)
+
+        nodes = nodeElement.getiterator("light")
+        self.createLights(nodes)
+
+        nodes = nodeElement.getiterator("sound")
+        self.createSound(nodes)
+
+        nodes = nodeElement.getiterator("particlesystem")
+        self.createParticleSystems(nodes)
+
+    def createEntites(self, entityNodes):
+        for nodes in entityNodes:
+            entityName = nodes.attrib["name"]
+            
+            if entityName.startswith("dropMesh"):
+                num = int(entityName.replace("dropMesh",  ""))
+                if ModuleManager.dropCount < num:
+                    ModuleManager.dropCount = num
+                elif ModuleManager.dropCount < num:
+                    ModuleManager.dropCount = num + 1
+                    
+            meshFile = nodes.attrib["meshfile"]
+            
+            eco = EntityCustomOptions()
+            
+            try:
+                if nodes.attrib["receivesShadow"] == "False" or nodes.attrib["receivesShadow"] == "false":
+                    eco.receivesShadow = "False"
+            except:
+                pass
+            try:
+                eco.staticgeometrygroup = int(nodes.attrib["staticgeometrygroup"])
+            except:
+                pass
+            try:
+                eco.physicsproxy = nodes.attrib["physicsproxy"]
+            except:
+                pass
+            try:
+                eco.renderingdistance = float(nodes.attrib["renderingdistance"])
+            except:
+                pass
+            try:
+                eco.renderingdistance
+                nodes.attrib["materialName"]
+            except:
+                pass
+                
+            nodePosition = None
+            nodeScale = None
+            qw = qx = qy = qz = None
+
+            transformations = nodes.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    posx = float(t.attrib["x"])
+                    posy = float(t.attrib["y"])
+                    posz = float(t.attrib["z"])
+                    nodePosition = og.Vector3(posx, posy, posz)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                elif t.tag == "scale":
+                    scalex = float(t.attrib["x"])
+                    scaley = float(t.attrib["y"])
+                    scalez = float(t.attrib["z"])
+                    nodeScale = og.Vector3(scalex, scaley, scalez)
+
+            try:
+                e = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager,  entityName), meshFile)
+            except:
+                print "Warning: Meshfile " + meshFile + " could not be found."
+                return
+
+            e.setUserObject(eco)
+            n = self.mapNode.createChild("entity_" + entityName + "_node")
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            n.setOrientation(qw, qx, qy, qz)
+            n.setScale(nodeScale)
+
+    def createLights(self, lightNodes):
+        for l in lightNodes:
+            lightName = l.attrib["name"]
+            lightType = l.attrib["type"]
+            lightVisible = bool(l.attrib["visible"])
+            castShadows = bool(l.attrib["castShadows"])
+            lightPosition = None
+            lightDirection = None
+            colourDiffuse = None
+            colourSpecular = None
+            lightAttenuationRange = None
+            lightAttenuationConstant= None
+            lightAttenuationLinear = None
+            lightAttenuationQuadratic = None
+            spotlightinner = None
+            spotlightouter = None
+            falloff = None 
+                
+            transformations = l.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    lightPosition = og.Vector3(x, y, z)
+                elif t.tag == "colourDiffuse":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourDiffuse = og.ColourValue(r, g, b)
+                elif t.tag == "colourSpecular":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourSpecular = og.ColourValue(r, g, b)
+                elif t.tag == "lightAttenuation":
+                    lightAttenuationRange = float(t.attrib["range"])
+                    lightAttenuationConstant= float(t.attrib["constant"])
+                    lightAttenuationLinear = float(t.attrib["linear"])
+                    lightAttenuationQuadric  = float(t.attrib["quadratic"])
+                elif t.tag == "spotlightrange":
+                    spotlightinner = float(t.attrib["inner"])
+                    spotlightouter = float(t.attrib["outer"])
+                    falloff = float(t.attrib["falloff"])
+                    
+            light = self.sceneManager.createLight(lightName)
+            
+            if lightType == "point":
+                light.setType(og.Light.LT_POINT)            
+            elif lightType == "spot":
+                light.setType(og.Light.LT_SPOTLIGHT)
+            elif lightType == "directional":
+                light.setType(og.Light.LT_DIRECTIONAL)
+            
+            light.setVisible(lightVisible)
+            light.setCastShadows(castShadows)
+            if lightAttenuationRange is not None and lightAttenuationConstant is not None and lightAttenuationLinear is not None and lightAttenuationQuadric is not None:
+                light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadric)
+            if colourDiffuse:
+                light.setDiffuseColour(colourDiffuse)
+            if colourSpecular:
+                light.setSpecularColour(colourSpecular)
+            if spotlightinner and spotlightouter and spotlightouter: 
+                light.setSpotlightRange(spotlightinner, spotlightouter, falloff)
+            
+            e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+            n = self.mapNode.createChild("light_" + lightName + "_node")
+            n.attachObject(light)
+            n.attachObject(e)
+            if lightPosition:
+                n.setPosition(lightPosition)
+            
+    def createSound(self, soundNodes):
+        #raise NotImplementedError
+        return
+
+    def createGameObjects(self, gameObjectNodes):
+        for g in gameObjectNodes:
+            classid = g.attrib["class"]
+            
+            id = int(g.attrib["id"])
+            if ModuleManager.dropCount < id:
+                ModuleManager.dropCount = id
+            elif ModuleManager.dropCount < id:
+                ModuleManager.dropCount = id + 1
+                
+            state = g.attrib["state"]
+            nodePosition = None
+            nodeRotation = None
+            properties = {}
+            
+            transformations = g.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+                elif t.tag == "property":
+                    name = t.attrib["name"]
+                    type = t.attrib["type"]
+                    data = t.attrib["data"]
+                    properties[name] = GameObjectRepresentation.PropertieRepresentation(name, type, data)
+
+            go = self.gocManager.getGameObjectWithClassId(classid)
+            if go is not None:
+                meshFile = go.getMeshFileName()
+                
+                ent = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+                dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
+                dropNode.attachObject(ent)
+
+                if nodePosition:
+                    dropNode.setPosition(nodePosition)
+                if nodeRotation:
+                    dropNode.setOrientation(nodeRotation)
+
+                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
+                self.gocManager.addGameObjectRepresentation(go)
+                go.inWorldId = id
+                go.state = state
+                go.propertieDict = properties
+                ent.setUserObject(go)
+
+
+    def createParticleSystems(self, particleNodes):
+        #raise NotImplementedError
+        return
+        
+    def save(self):
+        root = xml.Element("rastullahmap")
+        root.attrib["formatVersion"] = "0.4.0"
+        
+        nodesElem = xml.SubElement(root, "nodes")
+        
+        i = 0
+        while i < self.mapNode.numChildren():
+            n = self.mapNode.getChild(i)
+            if n.numAttachedObjects() > 0:
+                if n.name.startswith("entity_"):
+                    entElem = xml.SubElement(nodesElem, "entity")
+                    entElem.attrib["name"] = n.getAttachedObject(0).getName()
+                    entName = n.getAttachedObject(0).getName()
+                    #print "Saving Entity: " + n.getAttachedObject(0).getName()
+                    entElem.attrib["meshfile"] = n.getAttachedObject(0).getMesh().getName()
+   
+                    entElem.attrib["receivesShadow"] = str(n.getAttachedObject(0).getUserObject().receivesShadow).lower()
+                    entElem.attrib["staticgeometrygroup"] = str(n.getAttachedObject(0).getUserObject().staticgeometrygroup)
+                    entElem.attrib["physicsproxytype"] = str(n.getAttachedObject(0).getUserObject().physicsproxytype)
+                    entElem.attrib["renderingdistance"] = str(n.getAttachedObject(0).getUserObject().renderingdistance)
+                    
+                    posElem = xml.SubElement(entElem, "position")
+                    posElem.attrib["x"] = str(n.getPosition().x)
+                    posElem.attrib["y"] = str(n.getPosition().y)
+                    posElem.attrib["z"] = str(n.getPosition().z)
+                    
+                    rotElem = xml.SubElement(entElem, "rotation")
+                    rotElem.attrib["qw"] = str(n.getOrientation().w)
+                    rotElem.attrib["qx"] = str(n.getOrientation().x)
+                    rotElem.attrib["qy"] = str(n.getOrientation().y)
+                    rotElem.attrib["qz"] = str(n.getOrientation().z)
+                    
+                    scaleElem = xml.SubElement(entElem, "scale")
+                    scaleElem.attrib["x"] = str(n.getScale().x)
+                    scaleElem.attrib["y"] = str(n.getScale().y)
+                    scaleElem.attrib["z"] = str(n.getScale().z)
+                    
+                elif n.name.startswith("gameobject_"):
+                    goElem = xml.SubElement(nodesElem, "gameobject")
+                    mname = n.name
+                    #print "Saving GOID: " + str(n.getAttachedObject(0).getUserObject().inWorldId)
+                    goElem.attrib["class"] = str(n.getAttachedObject(0).getUserObject().gocName)
+                    goElem.attrib["state"] = str(n.getAttachedObject(0).getUserObject().state)
+                    goElem.attrib["id"] = str(n.getAttachedObject(0).getUserObject().inWorldId)
+                    
+                    posElem = xml.SubElement(goElem, "position")
+                    posElem.attrib["x"] = str(n.getPosition().x)
+                    posElem.attrib["y"] = str(n.getPosition().y)
+                    posElem.attrib["z"] = str(n.getPosition().z)
+                    
+                    rotElem = xml.SubElement(goElem, "rotation")
+                    rotElem.attrib["qw"] = str(n.getOrientation().w)
+                    rotElem.attrib["qx"] = str(n.getOrientation().x)
+                    rotElem.attrib["qy"] = str(n.getOrientation().y)
+                    rotElem.attrib["qz"] = str(n.getOrientation().z)
+                    
+                    dict = n.getAttachedObject(0).getUserObject().propertieDict
+                    for key in dict:
+                        prop = dict[key]
+                        rotElem = xml.SubElement(goElem, "property")
+                        rotElem.attrib["name"] = prop.name
+                        rotElem.attrib["type"] = prop.type
+                        rotElem.attrib["data"] = prop.data
+
+                    
+                elif n.name.startswith("light_"):
+                    light = extractLight(n)
+                    lightName = light.getName()
+                    #print "Saving Light: " + lightName
+                    lightType = light.getType()
+                    isVisible = "true"
+                    if not light.getVisible():
+                        isVisible = "false"
+                    
+                    castShadows = "false"
+                    if light.getCastShadows():
+                        castShadows = "true"
+                    
+                    if lightType == og.Light.LT_POINT:
+                        lightType = "point"
+                    elif lightType == og.Light.LT_SPOTLIGHT:
+                        lightType = "spot"
+                    elif lightType == og.Light.LT_DIRECTIONAL:
+                        lightType = "directional"
+                    
+                    
+                    lightElem = xml.SubElement(nodesElem, "light")
+                    lightElem.attrib["name"] = lightName
+                    lightElem.attrib["type"] = lightType
+                    lightElem.attrib["visible"] = isVisible
+                    lightElem.attrib["castShadows"] = castShadows
+                    
+                    if lightType == "point" or lightType == "spot":
+                        posElem = xml.SubElement(lightElem, "position")
+                        posElem.attrib["x"] = str(n.getPosition().x)
+                        posElem.attrib["y"] = str(n.getPosition().y)
+                        posElem.attrib["z"] = str(n.getPosition().z)
+                    
+                    colDiffuseElem = xml.SubElement(lightElem, "colourDiffuse")
+                    colDiffuseElem.attrib["r"] = str(light.getDiffuseColour().r)
+                    colDiffuseElem.attrib["g"] = str(light.getDiffuseColour().g)
+                    colDiffuseElem.attrib["b"] = str(light.getDiffuseColour().b)
+
+                    colSpecularElem = xml.SubElement(lightElem, "colourSpecular")
+                    colSpecularElem.attrib["r"] = str(light.getSpecularColour().r)
+                    colSpecularElem.attrib["g"] = str(light.getSpecularColour().g)
+                    colSpecularElem.attrib["b"] = str(light.getSpecularColour().b)
+                    
+                    lightAttenuationElem = xml.SubElement(lightElem, "lightAttenuation")
+                    lightAttenuationElem.attrib["range"] = str(light.getAttenuationRange())
+                    lightAttenuationElem.attrib["constant"] = str(light.getAttenuationConstant())
+                    lightAttenuationElem.attrib["linear"] = str(light.getAttenuationLinear())
+                    lightAttenuationElem.attrib["quadratic"] = str(light.getAttenuationQuadric())
+                    
+                    if lightType == "spot":
+                        spotligthRangeElem = xml.SubElement(lightElem, "spotlightrange")
+                        spotligthRangeElem.attrib["inner"] = str(light.getSpotlightInnerAngle().valueDegrees())
+                        spotligthRangeElem.attrib["outer"] = str(light.getSpotlightOuterAngle().valueDegrees())
+                        spotligthRangeElem.attrib["falloff"] = str(light.getSpotlightFalloff())
+                        
+                    if lightType == "spot" or lightType == "directional":
+                        directionElem = xml.SubElement(lightElem, "direction")
+                        dir = og.Vector3()
+                        n.getOrientation().ToAxes(dir)
+                        directionElem.attrib["x"] = str(dir.x)
+                        directionElem.attrib["y"] = str(dir.y)
+                        directionElem.attrib["z"] = str(dir.z)
+                        
+            i = i+1
+            
+        self.zoneManager.saveZonesToXml(root, self)
+        indent(root)
+        xml.ElementTree(root).write(self.pathToMapFile)
+
+# caused a linux crash
+#        iter = self.mapNode.getChildIterator()
+#        while iter.hasMoreElements():
+#            name = iter.getNext().getName()
+#            print name
+
+class Scene():
+    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyScene = False, sceneName = "NewScene"):
+        self.moduleRoot = moduleroot
+        self.pathToFile = pathToFile
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        self.zoneManager = zoneManager
+        self.mapFiles = [] # a list in case the module has more than one map file
+        mappaths = []
+        self.name = sceneName
+
+        
+        if not emptyScene:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+            self.name = root.attrib["name"]
+        
+            maps = root.getiterator("map")
+            for m in maps:
+                mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
+                
+            for m in mappaths:
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
+            
+    def addMap(self, name):
+        path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
+        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True))
+        
+    def save(self):
+        root = xml.Element("scene")
+        root.attrib["name"] = self.name
+        
+        for m in self.mapFiles:
+            sub = xml.SubElement(root, "map")
+            sub.attrib["file"] = m.mapFileName
+            m.save()
+
+        indent(root)
+        xml.ElementTree(root).write(self.pathToFile)
+
+class Module():
+    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager, zoneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gameObjectManager
+        self.zoneManager = zoneManager
+        
+        self.name = name
+        self.moduleRoot = join(modulePath, name)
+        self.__isCommon = False
+
+        self.hasDependencies = False
+        self.moduleDependencies = []
+
+        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+
+        self.gofFiles = [] # gof File list
+
+        self.scenes =[]
+
+        self.isLoaded = False
+        
+        self.playerStart = None
+        
+    def addScene(self, name):
+        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True, name))
+    
+    def addMapToScene(self, sceneName, mapName):
+        for scene in self.scenes:
+            if scene.name == sceneName:
+                scene.addMap(mapName)
+                return
+        
+        print "ERROR: could not find scene: " + sceneName
+        
+    
+    def isCommon(self):
+        if isfile(self.modConfig): # is the modconfig existing?
+            f = codecs.open(self.modConfig, 'r', 'utf-8')
+        else:
+            print ("Module.isCommon() Error: couldn't find module config")
+            return
+        isDependencieLine = False
+        for i, line in enumerate(f):
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith("super("):
+                split = lStripped.split(",")
+                if split[2].strip() == unicode("true"):
+                    self.__isCommon = True
+                    return True
+
+
+            elif isDependencieLine:
+                if lStripped == "end":
+                    isDependencieLine = False
+                else:
+                    self.hasDependencies = True
+                    pl = lStripped.split('"')
+                    i = 1
+                    while i < 100: 
+                        try:
+                            self.moduleDependencies.append(pl[i])
+                            i += 2
+                        except IndexError, e:
+                            break
+
+            elif lStripped == "def getDependencies()":
+                isDependencieLine = True
+
+        return False
+
+    def load(self):
+        if self.isLoaded:
+            return
+        
+        self.isLoaded = True
+        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+        if isfile(self.modConfig): # is the modconfig existing?
+            f = codecs.open(self.modConfig, 'r', 'utf-8')
+        else:
+            print ("Module.load: Error: couldn't find module config")
+            return
+
+        for line in f:
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith("hero = $GOM.getGameObject("):
+                try:
+                    self.playerStart = int(line.split("(")[1].split(")")[0])
+                except ValueError, e:
+                    print self.modConfig + " ValueError: " + str(e)
+                    self.playerStart = None
+                    continue
+                    
+        self.setResourcePaths()
+        
+        try:
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+        except og.OgreException, e:
+            print e
+        
+        
+        cmd = join(self.moduleRoot, "dsa/*.gof")
+        self.gofFiles = glob.glob(cmd)
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
+        if not self.isCommon():
+            cmd = join(self.moduleRoot, "maps/*.rlscene")
+            sceneFile = glob.glob(cmd)
+            self.loadScenes(sceneFile)
+                
+    def loadScenes(self, sceneFiles):
+        for s in sceneFiles:
+            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
+
+    def save(self):
+        for s in self.scenes:
+            s.save()
+            
+        self.saveModuleConfig()
+
+    def saveModuleConfig(self):
+        if self.playerStart is not None:
+            f = open(self.modConfig, "r")
+            
+            newconfig = ""
+            for line in f:
+                if line.startswith("       hero = $GOM.getGameObject("):
+                    newconfig += "       hero = $GOM.getGameObject(" + str(self.playerStart) + ");\n"
+                else:
+                    newconfig += line
+            f.close()
+            
+            f = open(self.modConfig, "w")
+            f.write(newconfig)
+            f.close()
+
+    def setResourcePaths(self, recurseFolder = ""):
+        if recurseFolder == "":
+            rootFolder = self.moduleRoot
+        else:
+            rootFolder = join(self.moduleRoot, recurseFolder)
+
+        for file in os.listdir(rootFolder):
+            curFile = join(rootFolder, file)
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            elif os.path.isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
+                self.setResourcePaths(curFile)
+            elif os.path.isfile(curFile):
+                continue
+                
+    def getMap(self, mapName, sceneName = None):
+        if sceneName is not None:
+            for s in self.scenes:
+                if s.name == sceneName:
+                    for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+        else:
+            for s in self.scenes:
+                for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+
+class ProgressBarThread(QThread):
+    def __init__(self, min, max, moduleName):
+        QThread.__init__(self)
+        self.progress = QProgressDialog("Loading " + moduleName, "Abort Loading", min, max, None);
+        self.progress.setWindowModality(Qt.WindowModal)
+
+    def setProgress(self, progress, labelText):
+        self.progress.setLabelText(labelText)
+        self.progress.setValue(progress)
+        
+    def run(self):
+        self.progress.show()
+        self.exec_()
+
+        
+class ModuleManager():
+    dropCount = 0
+    entityCustomOptionsDict = []
+    
+    def __init__(self,  ogreRoot,  sceneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.modelSelectionDialog = None
+        self.materialSelectionDialog = None
+
+        self.moduleCfgPath = ""
+
+        self.gocManager = GameObjectClassManager()
+        
+
+        self.mainModule = None
+        self.mainModuledependencieList =[]
+        self.moduleList = []
+        self.userSelectionList = []
+        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
+        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
+        self.currentMap = None
+        self.moduleExplorer = None
+
+        self.lastRay = None
+        self.rayLine = None
+
+        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.dropNode = None
+        self.dropEntity = None
+        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
+        self.dropMat = None
+        
+        self.moduleConfigIsParsed = False
+
+        self.selectionBuffer = None
+        self.depthBuffer = None
+        self.propertyWindow = None
+    
+        self.oneClickEntityPlacement = False
+        
+        self.onContextMenuCallback = None
+        self.contextMenuClickPosition = None
+        self.contextMenuRay = None
+        
+        self.playerStartGameObjectId = None
+        
+        self.entityCustomOptionsDict = []
+        
+        self.raySceneQueryListener = MyRaySceneQueryListener()
+        
+        self.zoneManager = ZoneManager(self.sceneManager)
+        
+    def resetParsedModuleConfig(self):
+        self.moduleConfigIsParsed = False
+        self.moduleList = []
+
+    def parseModuleConfig(self):
+        if self.moduleConfigIsParsed:
+            return
+
+        import codecs
+        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
+
+        for line in f:
+            if line.startswith('#'):
+                continue
+
+            if line.startswith('module='):
+                splines = line.split('=')
+                str = splines[1].rstrip().rstrip()
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
+
+        self.moduleConfigIsParsed = True
+
+    def moduleExists(self, name):
+        lowerA = str(name).lower()
+        
+        for m in self.moduleList:
+            lowerB = m.name.lower()
+            if lowerA == lowerB:
+                return True
+        
+        return False
+
+    def openLoadModuleDialog(self):
+        self.moduleFolder = str(self.moduleCfgPath.replace("modules.cfg", ""))
+
+        self.parseModuleConfig()
+
+        dlg = QDialog(QApplication.focusWidget())
+        list = QListWidget()
+        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
+        dlg.connect(btnBox, SIGNAL("rejected()"), dlg.reject)
+
+        for m in self.moduleList:
+            if not m.isCommon():
+                list.addItem(m.name)
+
+        layout = QVBoxLayout()
+        layout.addWidget(list)
+        layout.addWidget(btnBox)
+        dlg.setLayout(layout)
+        if dlg.exec_():
+            self.loadModule(str(list.currentItem().text()))
+
+    # I'm sorry for this
+    def loadModule(self, moduleName):
+        t = og.Timer()
+        
+#        self.progress = ProgressBarThread(0, 8, moduleName)
+#        self.progress.start()
+        
+        for m in self.moduleList:
+            if m.name == moduleName:
+                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
+                    for moduleDependencie in m.moduleDependencies:
+                        for m2 in self.moduleList:
+                            if m2.name == moduleDependencie:
+#                                self.progress.setProgress(2, "Loading Dependencie: " + moduleDependencie)
+                                m2.load()
+                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
+                                self.materialSelectionDialog.scanDirForMaterials(m2.moduleRoot)
+                                self.mainModuledependencieList.append(m2)
+
+#                self.progress.setProgress(4, "Loading " + moduleName)
+                m.load()
+#                self.progress.setProgress(6, "Scan for models...")
+                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
+#                self.progress.setProgress(8, "Scan for materials")
+                self.materialSelectionDialog.scanDirForMaterials(m.moduleRoot)
+                self.mainModule = m
+                self.moduleExplorer.setCurrentModule(m)
+
+        if self.selectionBuffer is None:
+            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"), self, self.zoneManager)
+
+#        if self.depthBuffer is None:
+#            self.depthBuffer = DepthBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
+
+
+#        self.progress.quit()
+        print "Time to load module: " + str(t.getMilliseconds() / 1000.0) + " seconds"
+        del t
+
+    def addSceneToModule(self, name):
+        if self.mainModule is not None:
+            self.mainModule.addScene(name)
+
+    def addMapToScene(self, sceneName, mapName):
+        if self.mainModule is not None:
+            self.mainModule.addMapToScene(sceneName, mapName)
+
+    def setModuleExplorer(self, moduleExplorer):
+        self.moduleExplorer = moduleExplorer
+        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
+        self.moduleExplorer.setSelectionChangedCallback(self.selectionChangedCallback)
+        self.moduleExplorer.setModuleManager(self)
+    
+    def setPropertyWindow(self, propertyWin):
+        self.propertyWindow = propertyWin
+    
+    def selectionChangedCallback(self, items):
+        self.resetSelection()
+        self.userSelectionList = self.selectionBuffer.manualSelectObjects(items)
+        
+        print len(self.userSelectionList)
+        
+        if len(self.userSelectionList) > 1:
+            self.propertyWindow.clear()
+        elif len(self.userSelectionList) > 0 and len(self.userSelectionList) < 2:
+            self.propertyWindow.showProperties(self.userSelectionList[0])
+        else:
+            return
+            
+        self.updatePivots()
+        
+    def selectMapCallback(self, sceneName, mapName):
+        self.currentMap = self.mainModule.getMap(mapName, sceneName)
+        self.zoneManager.currentMap = self.currentMap
+        if self.currentMap is None:
+            print "Don't forget to select a map"
+
+        
+    # called when a click into Main Ogre Window occurs
+    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
+        if self.oneClickEntityPlacement:
+            if self.modelSelectionDialog.listWidget.currentItem() is not None:
+                meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
+                self.startDropModelAction(meshFile, ray)
+                self.moduleExplorer.updateView()
+                return
+            else:
+                print "Warning: OneClickEntityPlacement still runing on without any selected mesh!"
+                return
+                
+        #self.depthBuffer.onSelectionClick(screenX, screenY)
+        
+        so = None
+        if self.selectionBuffer is not None:
+            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        
+        if so is not None:
+            if not so.isPivot:                
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.propertyWindow.showProperties(so)
+                    self.moduleExplorer.deselectAll()
+                    self.moduleExplorer.selectItem(so, True)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+
+                    for soFromList in self.userSelectionList:
+                        if soFromList == so:
+                            return # object already selected
+
+                    self.userSelectionList.append(so)
+                    self.propertyWindow.showProperties(so)
+                    self.moduleExplorer.selectItem(so, True)
+                    self.updatePivots()
+
+
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so == selo:
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                            self.moduleExplorer.selectItem(selo, False)
+                    self.updatePivots()
+                
+            else:
+                #so.entity is the pivot direction that was clicked
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            self.resetSelection() # click in empty space, deselect everything
+            self.moduleExplorer.selectItems(None)
+            self.propertyWindow.clear()
+            if self.pivot is not None:
+                self.pivot.hide()
+
+#        if self.rayLine == None:
+#            self.rayLine = self.sceneManager.createManualObject("rayLine")
+#            self.rayLine.setDynamic(True)
+#            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
+#
+#            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+#
+#        else:
+#            self.rayLine.beginUpdate(0)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+
+    def deleteObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.pivot.hide()
+
+        for so in self.userSelectionList:
+            node = so.entity.getParentNode()
+            if node.getName().startswith("area_"):
+                self.zoneManager.deleteArea(so.entity.getUserObject())
+                continue
+            elif node.getName().startswith("light_"):
+                light = extractLight(node)
+                self.sceneManager.destroyLight(light)
+                
+            node.detachAllObjects()
+            self.sceneManager.destroySceneNode(node)
+            self.sceneManager.destroyEntity(so.entity)
+            del so
+        
+        self.userSelectionList = []
+        self.moduleExplorer.updateView()
+        
+    def copyObjects(self):
+        if len(self.userSelectionList) < 1 or self.currentMap is None:
+            print "Warning: No map selected!"
+            return
+
+        self.newSelectionList = []
+
+        for so in self.userSelectionList:
+            if so.entity.getUserObject() is not None:
+                if str(so.entity.getParentNode().getName()).startswith("gameobject_"):
+                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
+                    meshFile = go.getMeshFileName()
+
+                    if go is not None:
+                        newEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+                        newNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
+                        newNode.attachObject(newEntity)
+                        newNode.setPosition(so.entity.getParentNode().getPosition())
+
+                        newGO = GameObjectRepresentation(ModuleManager.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
+                        self.gocManager.addGameObjectRepresentation(newGO)
+                        newEntity.setUserObject(newGO)
+
+                        newSO = SelectionObject(newEntity)
+                        newSO.setSelected(True)
+                        self.newSelectionList.append(newSO)
+                        ModuleManager.dropCount += 1
+                elif str(so.entity.getParentNode().getName()).startswith("entity_"):
+                    nodeName = "entity_dropNode" + str(ModuleManager.dropCount)
+                    newNode = self.currentMap.mapNode.createChild(nodeName)
+
+                    entityName = createUniqueEntityName(self.sceneManager)
+                    newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+
+                    eco = so.entity.getUserObject().copy()
+                    newEntity.setUserObject(eco)
+
+                    newNode.attachObject(newEntity)
+                    newNode.setPosition(so.entity.getParentNode().getPosition())
+                    newNode.setOrientation(so.entity.getParentNode().getOrientation())
+                    newNode.setScale(so.entity.getParentNode().getScale())
+
+                    newSO = SelectionObject(newEntity)
+                    newSO.setSelected(True)
+                    self.newSelectionList.append(newSO)
+                    ModuleManager.dropCount += 1
+                elif str(so.entity.getParentNode().getName()).startswith("light_"):
+                    print "Can't copy lights yet :)"
+
+        self.resetSelection()
+        self.userSelectionList = self.newSelectionList
+        self.moduleExplorer.updateView()
+        for so in self.userSelectionList:
+            self.moduleExplorer.selectItem(so, True)
+        self.updatePivots()
+
+        
+    def cutObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.cutList = []
+        for so in self.userSelectionList:
+            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
+            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
+            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
+            # so we only have to translate them to their new destination when they get pasted
+            # the position of the pivot point is considered as the center of gravity
+            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
+            self.cutList.append(so)
+        self.resetSelection()
+        self.moduleExplorer.updateView()
+        
+    def pasteObjects(self,  ray):
+        if len(self.cutList) < 1:
+            return
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
+                i = i+1
+        else:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
+                i = i+1
+        self.cutList = []
+        self.moduleExplorer.updateView()
+        
+    def leftMouseUp(self):
+        if self.pivot is not None and self.pivot.isTransforming:
+            self.propertyWindow.updateProperties()
+            self.pivot.stopTransforming()
+
+    def resetSelection(self):
+        if self.userSelectionList is not None:
+            for so in self.userSelectionList:
+                so.setSelected(False)
+
+        self.userSelectionList = []
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+        if self.pivot is not None and len(self.userSelectionList) > 0:
+            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
+    def unload(self,  saveOnUnload=True):
+        pass
+
+    def save(self):
+        self.mainModule.save()
+
+    def startDropGameObjectAction(self, classid, ray):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        go = self.gocManager.getGameObjectWithClassId(classid)
+
+        if go is not None:
+            meshFile = go.getMeshFileName()
+            dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
+            dropNode.attachObject(dropEntity)
+
+            result = og.Math.intersects(ray, self.dropCollisionPlane)
+            if result.first == True:
+                dropNode.setPosition(ray.getPoint(result.second))
+            else:
+                dropNode.setPosition(ray.getPoint(50))
+
+            self.dropGO = GameObjectRepresentation(ModuleManager.dropCount, classid, dropNode, meshFile)
+            self.gocManager.addGameObjectRepresentation(self.dropGO)
+            dropEntity.setUserObject(self.dropGO)
+
+        ModuleManager.dropCount += 1
+
+    def moveDropGameObjectAction(self, ray):
+        if self.currentMap is None:
+            return
+        
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropGO.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropGO.setPosition(ray.getPoint(50))
+
+    def finishDropGameObjectAction(self, ray):
+        self.moduleExplorer.updateView()
+        self.dropGO = None
+        return
+
+    def startDropModelAction(self, meshFile, ray):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        self.dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), meshFile)
+        
+        eco = EntityCustomOptions()
+        self.dropEntity.setUserObject(eco)
+        
+        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(ModuleManager.dropCount))
+        self.dropNode.attachObject(self.dropEntity)
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+        ModuleManager.dropCount += 1
+
+    def moveDropModelAction(self, ray):
+        if self.currentMap is None:
+            return
+            
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+    
+    def finishDropModelAction(self, ray):
+        self.moduleExplorer.updateView()
+        return
+
+    def startDropMaterialAction(self, text):
+        self.dropMat = text
+        
+    def moveDropMaterialAction(self, event):
+        return
+
+    def finishDropMaterialAction(self, screenX, screenY):
+        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        if so is not None:
+            if not so.entity.getNumSubEntities() > 1:
+                so.entity.setMaterialName(self.dropMat)
+                so.entity.getUserObject().materialName = self.dropMat
+            else:
+                i = 0
+                text = "Warning this Entity has more than one SubEntities with the folloing materials: \n\n"
+                while i < so.entity.getNumSubEntities():
+                    text += "SubMesh" + str(i) + ":  " + so.entity.getSubEntity(i).getMaterialName() + "\n"
+                    i += 1
+                
+                text += "\n Replace the materials?"
+                reply = QMessageBox.question(None, "Warning: multiple materials",  text,  QMessageBox.Yes|QMessageBox.No)
+                if reply == QMessageBox.Cancel:
+                    return
+                if reply == QMessageBox.Yes:
+                    so.entity.setMaterialName(self.dropMat)
+                    so.entity.getUserObject().materialName = self.dropMat
+        
+    def setOneClickEntityPlacement(self, state):
+        self.oneClickEntityPlacement = state
+    
+    def createLight(self, name):
+        pos = og.Vector3()
+        
+        query = self.sceneManager.createRayQuery(self.contextMenuRay)
+        query.ray = self.contextMenuRay
+        query.setSortByDistance(True)
+        query.execute(self.raySceneQueryListener)
+        if self.raySceneQueryListener.dist < 100000:
+            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
+            self.raySceneQueryListener.dist = 100000
+            
+        light = None
+        if not self.sceneManager.hasLight(name):
+            light = self.sceneManager.createLight(name)
+            
+        return light,  pos
+        
+    def addPointLight(self):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        lightName = "pointLight" + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+        light, pos = self.createLight(lightName)
+        printVector3(pos)
+        
+        if not light:
+            print "Error while creating light"
+            return
+            
+        light.setType(og.Light.LT_POINT)
+        
+        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
+        n.attachObject(light)
+        n.attachObject(e)
+        n.setPosition(pos)
+        self.moduleExplorer.updateView()
+        
+    def addSpotLight(self):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        lightName = "spotLight" + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+        light, pos = self.createLight(lightName)
+        printVector3(pos)
+        
+        if not light:
+            print "Error while creating light"
+            return
+            
+        light.setType(og.Light.LT_SPOTLIGHT)
+        
+        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
+        n.attachObject(light)
+        n.attachObject(e)
+        n.setPosition(pos)
+        self.moduleExplorer.updateView()
+        
+    def addZoneToMap(self, name):
+        self.zoneManager.createZone(name)
+        self.moduleExplorer.updateView()
+        
+    def setPlayerStart(self):
+        self.mainModule.playerStart = str(self.playerStartGameObjectId)
+        print "setting Player Start to " + str(self.playerStartGameObjectId)
+    
+    def onContextMenu(self, screenX, screenY, ray):
+        menus = []
+        actions = []
+        pla = self.createAction("Pointlight", self.addPointLight, None, "idea.png")
+        pls = self.createAction("Spotlight", self.addSpotLight, None, "idea.png")
+        
+        lightMenu = QMenu("Add Light")
+        lightMenu.addAction(pla)
+        lightMenu.addAction(pls)
+        menus.append(lightMenu)
+        
+        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        self.contextMenuClickPosition = og.Vector2(screenX, screenY)
+        self.contextMenuRay = ray
+        
+        pos = og.Vector3()
+        query = self.sceneManager.createRayQuery(self.contextMenuRay)
+        query.ray = self.contextMenuRay
+        query.setSortByDistance(True)
+        query.execute(self.raySceneQueryListener)
+        if self.raySceneQueryListener.dist < 100000:
+            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
+            self.raySceneQueryListener.dist = 100000
+        
+        if so is not None:
+            self.zoneManager.entityUnderMouse = so.entity
+        
+        self.zoneManager.newAreaPosition = pos
+        menus.append(self.zoneManager.getZoneMenu())
+
+        if so is not None and so.entity.getParentNode().getName().startswith("gameobject_"):
+            actions.append(self.createAction("Set Player Starterpoint", self.setPlayerStart))
+            actions.append(self.createAction("Add Property", so.entity.getUserObject().addProperty))
+            self.playerStartGameObjectId = so.entity.getUserObject().inWorldId
+            
+                
+            
+        if self.onContextMenuCallback is not None:
+            self.onContextMenuCallback(actions,  menus)
+
+    def setContextMenuCallback(self, callback):
+        self.onContextMenuCallback = callback
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QAction(text, None)
+        if icon is not None:
+            action.setIcon(QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            QWidget.connect(action, SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-04-11 10:34:44 UTC (rev 4893)
@@ -22,6 +22,7 @@
 
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *
+from GOGenericEditor import *
 
 import ogre.renderer.OGRE as og
 
@@ -113,9 +114,9 @@
     def getValue(self):
         return str(self.combo.currentText())
     
-class ObjectPropertyWin(QDialog):
+class ObjectPropertyWin(QWidget):
     def __init__(self, sceneManager, gocManager, parent=None):
-        super(QDialog, self).__init__(parent)
+        super(QWidget, self).__init__(parent)
         self.setupUi()
         self.sceneManager = sceneManager
         self.valueBeforeEdit = None
@@ -199,7 +200,7 @@
     def onItemChanged(self, item, column):
         if self.valueBeforeEdit is not None and self.valueBeforeEdit != item.text(column):
             parent = item.parent()
-            if parent is None: # handle properties that don't expand here (pos, rot, scale etc)
+            if parent is None: # handle properties that don't expand here
                 if item.text(0) == "Name":
                     if self.node.getName().startswith("entity_"):
                         if not self.sceneManager.hasEntity(str(item.text(column))):
@@ -274,6 +275,51 @@
                     
                     self.node.getAttachedObject(0).getUserObject().renderingdistance = val
             else:
+                parentOfParent = parent.parent() 
+                if parentOfParent is not None and str(parentOfParent.text(0)).startswith("Properties"):
+                    propertiesDict = self.node.getAttachedObject(0).getUserObject().propertieDict
+                    prop = propertiesDict[str(parent.text(1))]
+                    self.disconnect(self.treeWidget, SIGNAL("itemChanged (QTreeWidgetItem *,int)"), self.onItemChanged)
+                    
+                    if item.text(0) == "Name":
+                        del propertiesDict[self.valueBeforeEdit]
+                        prop.name = str(item.text(1))
+                        propertiesDict[prop.name] = prop
+
+                        parent.setText(1, prop.name)
+
+                        
+                    elif item.text(0) == "Data" and prop.type == "STRING":
+                        prop.data = str(item.text(1))
+                        
+                    elif item.text(0) == "Data" and prop.type == "INT":
+                        val = None
+                        
+                        try:
+                            val = int(item.text(1))
+                        except ValueError, e:
+                            item.setText(column, self.valueBeforeEdit)
+                            print "ValueError: " + str(e)
+                            return
+                        
+                        prop.data = str(val)
+                    elif item.text(0) == "Data" and prop.type == "REAL":
+                        val = None
+                        
+                        try:
+                            val = float(item.text(1))
+                        except ValueError, e:
+                            item.setText(column, self.valueBeforeEdit)
+                            print "ValueError: " + str(e)
+                            return
+
+                        prop.data = str(val)
+                        
+                    self.connect(self.treeWidget, SIGNAL("itemChanged (QTreeWidgetItem *,int)"), self.onItemChanged)
+                    return
+                    
+                
+                
                 val = None
                 try:
                     val = float(item.text(1))
@@ -375,12 +421,37 @@
             item = QTreeWidgetItem(self.treeWidget)
             item.setText(0, "State")
             n = str(self.node.getAttachedObject(0).getUserObject().state)
-            item.setText(1, n)            
-            
+            item.setText(1, n)
+                
             self.parsePosition(self.node)
             self.parseOrientation(self.node)
-            self.parseScale(self.node)
+            self.parseScale(self.node)            
             
+            
+            propDict = self.node.getAttachedObject(0).getUserObject().propertieDict
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, "Properties")
+            item.setText(1, str(len(propDict)))
+            
+            for key in propDict:
+                propParent = QTreeWidgetItem(item)
+                propParent.setText(0,  "Name")
+                propParent.setText(1,  propDict[key].name)
+                
+                propItem = QTreeWidgetItem(propParent)
+                propItem.setText(0,  "Name")
+                propItem.setText(1,  propDict[key].name)
+                propItem.setFlags(propItem.flags() | Qt.ItemIsEditable)
+                
+                propItem = QTreeWidgetItem(propParent)
+                propItem.setText(0,  "Type")
+                propItem.setText(1,  propDict[key].type)
+                
+                propItem = QTreeWidgetItem(propParent)
+                propItem.setText(0,  "Data")
+                propItem.setText(1,  propDict[key].data)
+                propItem.setFlags(propItem.flags() | Qt.ItemIsEditable)
+            
         elif name.startswith("light_"):
             item = QTreeWidgetItem(self.treeWidget)
             light = ModuleManager.extractLight(self.node)
@@ -414,6 +485,7 @@
             self.parseDiffuseColor(self.node)
             self.parseSpecularColor(self.node)
             self.parseLightAttenuation(self.node)
+            
         elif name.startswith("area_"):
             area = so.entity.getUserObject()
             item = QTreeWidgetItem(self.treeWidget)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ZoneManager.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ZoneManager.py	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ZoneManager.py	2009-04-11 10:34:44 UTC (rev 4893)
@@ -1,363 +1,363 @@
-#################################################
-# This source file is part of Rastullahs Lockenwickler.
-# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
-
-import functools
-import xml.etree.cElementTree as xml
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
- 
-import ogre.renderer.OGRE as og
- 
-from ModuleExplorer import NameInputDlg
- 
-#                <zone name="Testzone">
-#                        <area type="sphere">
-#                                <position x="-10" y="0" z="-5"/>
-#                                <scale x="6" y="6" z="6"/>
-#                                <transition_distance>0.5</transition_distance>
-#                        </area>
-#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
-#                                <position x="25" y="0" z="-50"/>
-#                                <transition_distance>0.5</transition_distance>
-#                        </area>
-#                        <area type="sphere" subtract="true">
-#                                <position x="-11" y="0" z="-4"/>
-#                                <scale x="2" y="2" z="2"/>
-#                        </area>
-#                        <light name="red pointlight"/>
-#                        <light name="green spotlight"/>
-#                        <sound name="ruchin001.ogg"/>
-#                        <trigger name="test" classname="TestTrigger">
-#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
-#                        </trigger>
-#                </zone>
- 
-class Area(og.UserDefinedObject):
-    def __init__(self,sceneManager, type, parentZone, id, position, orientation, scale, meshFile = None, transitiondistance = "0.5", subtract = False):
-        og.UserDefinedObject.__init__(self)
-        self.type = type
-        self.parentZone = parentZone
-        if not parentZone:
-           raise Exception("No parentZone")
-
-        self.id = id # editor internal id for entity and node creation
-        self.areaNode = parentZone.zoneNode.createChildSceneNode("area_" + parentZone.name + " " + str(id))
-        self.meshFile = meshFile
-        self.areaEntity = None
-        self.transitiondistance = transitiondistance
-        self.__subtract = subtract
-        self.sceneManager = sceneManager
-        
-        if type == "box":
-            self.areaEntity = self.sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", "UniCube.mesh")
-        elif type == "sphere":
-            self.areaEntity = self.sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", "UniSphere.mesh")        
-        elif type == "ellipsoid":
-            print "not yet"
-        elif type == "capsule":
-            print "not yet"
-        elif type == "pyramid":
-            print "not yet"
-        elif type == "mesh":
-            try:
-                self.areaEntity = sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", self.meshFile)
-            except:
-                print "Mesh " + self.meshFile + " not found!"
-                return None
-                
-        self.areaEntity.setMaterialName("Lockenwickler_Area")
-        if self.__subtract:
-            self.areaEntity.setMaterialName("Lockenwickler_Area_Subtract")
-            
-        self.areaEntity.setUserObject(self)
-        self.areaNode.attachObject(self.areaEntity)
-        self.areaNode.setPosition(position)
-        if orientation is not None:
-            self.areaNode.setOrientation(orientation.w, orientation.x, orientation.y, orientation.z)
-        if scale is not None:
-            self.areaNode.setScale(scale)
-    
-    def __del__(self):
-        self.areaNode.detachAllObjects()
-        self.areaNode.getParent().removeAndDestroyChild(self.areaNode.getName())
-        self.sceneManager.destroyEntity(self.areaEntity.getName())
-    
-    def getsubtract(self):
-        return self.__subtract
-        
-    def setsubtract(self, val):
-        if not val:
-            self.areaEntity.setMaterialName("Lockenwickler_Area")
-        else:
-            self.areaEntity.setMaterialName("Lockenwickler_Area_Subtract")
-        
-        self.__subtract = val
-        
-    subtract = property(getsubtract, setsubtract)
-    
-class Zone():
-    def __init__(self,sceneManager, map, name):
-        self.map = map
-        self.name = name
-        self.areaList = []
-        self.lightList = []
-        self.soundList = []
-        self.triggerList = []
-        self.areaCounter = 0
-        self.sceneManager = sceneManager
-        self.isHidden = False
-        
-        self.zoneNode =  self.sceneManager.getRootSceneNode().createChildSceneNode("zone_" + name + "_node")
-        
-    def addArea(self, type, position, orientation, scale, meshFile = None):
-        area = Area(self.sceneManager, type, self, self.areaCounter, position, orientation, scale, meshFile)
-        if area is not None:
-            self.areaList.append(area)
-            self.areaCounter = self.areaCounter + 1
-    
-    def deleteArea(self, area):
-        for a in self.areaList:
-            if a.id == area.id:
-                self.areaList.remove(a)
-                del a
-    
-    def hide(self):
-        self.sceneManager.getRootSceneNode().removeChild(self.zoneNode)
-        self.isHidden = True
-    
-    def show(self):
-        self.sceneManager.getRootSceneNode().addChild(self.zoneNode)
-        self.isHidden = False
-        
-        
-class ZoneManager():
-    def __init__(self, sceneManager):
-        self.currentMap = None
-        self.zoneList = []
-        self.menuList = []
-        self.entityUnderMouse = None
-        self.newAreaPosition = None
-        self.sceneManager = sceneManager
-        
-    def createZone(self, name):
-        if self.currentMap == None:
-            print "No map selected!"
-            return
-            
-        z = Zone(self.sceneManager, self.currentMap, name)
-        self.zoneList.append(z)
-        self.currentMap.zoneList.append(z)
-        return z
-        
-    def parseZonesFromXml(self, zoneXmlNode, map):
-        if zoneXmlNode is None:
-            return
-        
-        self.currentMap = map
-        
-        zoneNodes = zoneXmlNode.getiterator("zone")
-        for zone in zoneNodes:
-            zoneName = zone.attrib["name"]
-            z = self.createZone(zoneName)
-            
-            areaNodes = zone.getiterator("area")
-            for area in areaNodes:
-                type = area.attrib["type"]
-                meshFile = None
-                if type == "mesh":
-                    meshFile = area.attrib["meshfile"]
-                
-                pos = og.Vector3()
-                qw = qx = qy = qz = 0
-                scale = None
-                hasRotation = False
-                
-                transformations = area.getiterator()
-                for t in transformations:
-                    if t.tag == "position":
-                        posx = float(t.attrib["x"])
-                        posy = float(t.attrib["y"])
-                        posz = float(t.attrib["z"])
-                        pos = og.Vector3(posx, posy, posz)
-                    elif t.tag == "rotation":
-                        qw = float(t.attrib["qw"])
-                        qx = float(t.attrib["qx"])
-                        qy = float(t.attrib["qy"])
-                        qz = float(t.attrib["qz"])
-                        hasRotation = True
-                    elif type == "mesh" and t.tag == "scale":
-                        scalex = float(t.attrib["x"])
-                        scaley = float(t.attrib["y"])
-                        scalez = float(t.attrib["z"])
-                        scale = og.Vector3(scalex, scaley, scalez)
-                    elif t.tag == "size":
-                        scalex = float(t.attrib["x"])
-                        scaley = float(t.attrib["y"])
-                        scalez = float(t.attrib["z"])
-                        scale = og.Vector3(scalex, scaley, scalez)
-                
-                rot = None
-                if hasRotation:
-                    rot = og.Quaternion(qw, qx, qy, qz)
-                    
-                z.addArea(type, pos, rot, scale, meshFile)
-            
-            
-            lightNodes = zone.getiterator("light")
-            for light in lightNodes:
-                name = light.attrib["name"]
-                z.lightList.append(name)
-                
-            soundNodes = zone.getiterator("sound")
-            for sound in soundNodes:
-                name = sound.attrib["name"]
-                z.soundList.append(name)
-            
-
-    def saveZonesToXml(self, root, map):
-        if len(map.zoneList) == 0:
-            return
-        
-        rootZonesElem = xml.SubElement(root, "zones")
-        for zone in map.zoneList:
-            zoneElem = xml.SubElement(rootZonesElem, "zone")
-            zoneElem.attrib["name"] = zone.name
-            
-            for area in zone.areaList:
-                areaElem = xml.SubElement(zoneElem, "area")
-                areaElem.attrib["type"] = area.type
-                print "Saving Zone: " + zone.name + " - Area " + str(area.id)
-                if area.type == "mesh" and area.meshFile is not None:
-                    areaElem.attrib["meshfile"] = area.meshFile
-                    
-                posElem = xml.SubElement(areaElem, "position")
-                posElem.attrib["x"] = str(area.areaNode.getPosition().x)
-                posElem.attrib["y"] = str(area.areaNode.getPosition().y)
-                posElem.attrib["z"] = str(area.areaNode.getPosition().z)
-                
-                rotElem = xml.SubElement(areaElem, "rotation")
-                rotElem.attrib["qw"] = str(area.areaNode.getOrientation().w)
-                rotElem.attrib["qx"] = str(area.areaNode.getOrientation().x)
-                rotElem.attrib["qy"] = str(area.areaNode.getOrientation().y)
-                rotElem.attrib["qz"] = str(area.areaNode.getOrientation().z)
-                
-                scaleElem = None
-                if area.type == "mesh":
-                    scaleElem = xml.SubElement(areaElem, "scale")
-                else:
-                    scaleElem = xml.SubElement(areaElem, "size")
-
-                scaleElem.attrib["x"] = str(area.areaNode.getScale().x)
-                scaleElem.attrib["y"] = str(area.areaNode.getScale().y)
-                scaleElem.attrib["z"] = str(area.areaNode.getScale().z)
-                
-            for lightName in zone.lightList:
-                lightElem = xml.SubElement(zoneElem, "light")
-                lightElem.attrib["name"] = lightName
-            
-            for soundName in zone.soundList:
-                soundElem = xml.SubElement(zoneElem, "sound")
-                soundElem.attrib["name"] = soundName
-                
-    def deleteArea(self, area):
-        for z in self.zoneList:
-            for a in z.areaList:
-                if a.id == area.id:
-                    z.deleteArea(area)
-    
-    def getZoneMenu(self):
-        self.menuList = []
-        menu = QMenu("Add Area")
-        
-        for zone in self.zoneList:
-            m = QMenu(zone.name)
-            self.menuList.append(m)
-            menu.addMenu(m)
-            
-            boxAction = self.createAction("box", functools.partial(self.onZoneNameTriggered, zone, "box"))
-            self.menuList.append(boxAction)
-            m.addAction(boxAction)
-            
-            sphereAction = self.createAction("sphere", functools.partial(self.onZoneNameTriggered, zone, "sphere"))
-            self.menuList.append(sphereAction)
-            m.addAction(sphereAction)
-            
-            ellipsoidAction = self.createAction("ellipsoid", functools.partial(self.onZoneNameTriggered, zone, "ellipsoid"))
-            self.menuList.append(ellipsoidAction)
-            m.addAction(ellipsoidAction)
-            
-            capsuleAction = self.createAction("capsule", functools.partial(self.onZoneNameTriggered, zone, "capsule"))
-            self.menuList.append(capsuleAction)
-            m.addAction(capsuleAction)
-            
-            pyramidAction = self.createAction("pyramid", functools.partial(self.onZoneNameTriggered, zone, "pyramid"))
-            self.menuList.append(pyramidAction)
-            m.addAction(pyramidAction)
-            
-            meshAction = self.createAction("mesh", functools.partial(self.onZoneNameTriggered, zone, "mesh"))
-            self.menuList.append(meshAction)
-            m.addAction(meshAction)
-            
-        return menu
-        
-    def onZoneNameTriggered(self, zone, type):
-        if self.newAreaPosition is not None:
-            if type == "box":
-                zone.addArea("box", self.newAreaPosition, None, None)
-            elif type == "sphere":
-                zone.addArea("sphere", self.newAreaPosition, None, None)
-            elif type == "mesh":
-                dlg = NameInputDlg(QApplication.focusWidget())
-                resName = ""
-                if dlg.exec_():
-                    resName = str(dlg.nameInput.text())
-
-                zone.addArea("mesh", self.newAreaPosition, None, None, resName)
-                
-    def getZone(self, name):
-        for zone in self.zoneList:
-            if zone.name == name:
-                return zone
-        
-    def getZoneList(self):
-        list = []
-        for zone in self.zoneList:
-            list.append(zone.name)
-            
-        return list
-        
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
-        action = QAction(text, None)
-        if icon is not None:
-            action.setIcon(QIcon("media/icons/%s" % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            QWidget.connect(action, SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
-        
-        
-        
+#################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import functools
+import xml.etree.cElementTree as xml
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+ 
+import ogre.renderer.OGRE as og
+ 
+from ModuleExplorer import NameInputDlg
+ 
+#                <zone name="Testzone">
+#                        <area type="sphere">
+#                                <position x="-10" y="0" z="-5"/>
+#                                <scale x="6" y="6" z="6"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
+#                                <position x="25" y="0" z="-50"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="sphere" subtract="true">
+#                                <position x="-11" y="0" z="-4"/>
+#                                <scale x="2" y="2" z="2"/>
+#                        </area>
+#                        <light name="red pointlight"/>
+#                        <light name="green spotlight"/>
+#                        <sound name="ruchin001.ogg"/>
+#                        <trigger name="test" classname="TestTrigger">
+#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
+#                        </trigger>
+#                </zone>
+ 
+class Area(og.UserDefinedObject):
+    def __init__(self,sceneManager, type, parentZone, id, position, orientation, scale, meshFile = None, transitiondistance = "0.5", subtract = False):
+        og.UserDefinedObject.__init__(self)
+        self.type = type
+        self.parentZone = parentZone
+        if not parentZone:
+           raise Exception("No parentZone")
+
+        self.id = id # editor internal id for entity and node creation
+        self.areaNode = parentZone.zoneNode.createChildSceneNode("area_" + parentZone.name + " " + str(id))
+        self.meshFile = meshFile
+        self.areaEntity = None
+        self.transitiondistance = transitiondistance
+        self.__subtract = subtract
+        self.sceneManager = sceneManager
+        
+        if type == "box":
+            self.areaEntity = self.sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", "UniCube.mesh")
+        elif type == "sphere":
+            self.areaEntity = self.sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", "UniSphere.mesh")        
+        elif type == "ellipsoid":
+            print "not yet"
+        elif type == "capsule":
+            print "not yet"
+        elif type == "pyramid":
+            print "not yet"
+        elif type == "mesh":
+            try:
+                self.areaEntity = sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", self.meshFile)
+            except:
+                print "Mesh " + self.meshFile + " not found!"
+                return None
+                
+        self.areaEntity.setMaterialName("Lockenwickler_Area")
+        if self.__subtract:
+            self.areaEntity.setMaterialName("Lockenwickler_Area_Subtract")
+            
+        self.areaEntity.setUserObject(self)
+        self.areaNode.attachObject(self.areaEntity)
+        self.areaNode.setPosition(position)
+        if orientation is not None:
+            self.areaNode.setOrientation(orientation.w, orientation.x, orientation.y, orientation.z)
+        if scale is not None:
+            self.areaNode.setScale(scale)
+    
+    def __del__(self):
+        self.areaNode.detachAllObjects()
+        self.areaNode.getParent().removeAndDestroyChild(self.areaNode.getName())
+        self.sceneManager.destroyEntity(self.areaEntity.getName())
+    
+    def getsubtract(self):
+        return self.__subtract
+        
+    def setsubtract(self, val):
+        if not val:
+            self.areaEntity.setMaterialName("Lockenwickler_Area")
+        else:
+            self.areaEntity.setMaterialName("Lockenwickler_Area_Subtract")
+        
+        self.__subtract = val
+        
+    subtract = property(getsubtract, setsubtract)
+    
+class Zone():
+    def __init__(self,sceneManager, map, name):
+        self.map = map
+        self.name = name
+        self.areaList = []
+        self.lightList = []
+        self.soundList = []
+        self.triggerList = []
+        self.areaCounter = 0
+        self.sceneManager = sceneManager
+        self.isHidden = False
+        
+        self.zoneNode =  self.sceneManager.getRootSceneNode().createChildSceneNode("zone_" + name + "_node")
+        
+    def addArea(self, type, position, orientation, scale, meshFile = None):
+        area = Area(self.sceneManager, type, self, self.areaCounter, position, orientation, scale, meshFile)
+        if area is not None:
+            self.areaList.append(area)
+            self.areaCounter = self.areaCounter + 1
+    
+    def deleteArea(self, area):
+        for a in self.areaList:
+            if a.id == area.id:
+                self.areaList.remove(a)
+                del a
+    
+    def hide(self):
+        self.sceneManager.getRootSceneNode().removeChild(self.zoneNode)
+        self.isHidden = True
+    
+    def show(self):
+        self.sceneManager.getRootSceneNode().addChild(self.zoneNode)
+        self.isHidden = False
+        
+        
+class ZoneManager():
+    def __init__(self, sceneManager):
+        self.currentMap = None
+        self.zoneList = []
+        self.menuList = []
+        self.entityUnderMouse = None
+        self.newAreaPosition = None
+        self.sceneManager = sceneManager
+        
+    def createZone(self, name):
+        if self.currentMap == None:
+            print "No map selected!"
+            return
+            
+        z = Zone(self.sceneManager, self.currentMap, name)
+        self.zoneList.append(z)
+        self.currentMap.zoneList.append(z)
+        return z
+        
+    def parseZonesFromXml(self, zoneXmlNode, map):
+        if zoneXmlNode is None:
+            return
+        
+        self.currentMap = map
+        
+        zoneNodes = zoneXmlNode.getiterator("zone")
+        for zone in zoneNodes:
+            zoneName = zone.attrib["name"]
+            z = self.createZone(zoneName)
+            
+            areaNodes = zone.getiterator("area")
+            for area in areaNodes:
+                type = area.attrib["type"]
+                meshFile = None
+                if type == "mesh":
+                    meshFile = area.attrib["meshfile"]
+                
+                pos = og.Vector3()
+                qw = qx = qy = qz = 0
+                scale = None
+                hasRotation = False
+                
+                transformations = area.getiterator()
+                for t in transformations:
+                    if t.tag == "position":
+                        posx = float(t.attrib["x"])
+                        posy = float(t.attrib["y"])
+                        posz = float(t.attrib["z"])
+                        pos = og.Vector3(posx, posy, posz)
+                    elif t.tag == "rotation":
+                        qw = float(t.attrib["qw"])
+                        qx = float(t.attrib["qx"])
+                        qy = float(t.attrib["qy"])
+                        qz = float(t.attrib["qz"])
+                        hasRotation = True
+                    elif type == "mesh" and t.tag == "scale":
+                        scalex = float(t.attrib["x"])
+                        scaley = float(t.attrib["y"])
+                        scalez = float(t.attrib["z"])
+                        scale = og.Vector3(scalex, scaley, scalez)
+                    elif t.tag == "size":
+                        scalex = float(t.attrib["x"])
+                        scaley = float(t.attrib["y"])
+                        scalez = float(t.attrib["z"])
+                        scale = og.Vector3(scalex, scaley, scalez)
+                
+                rot = None
+                if hasRotation:
+                    rot = og.Quaternion(qw, qx, qy, qz)
+                    
+                z.addArea(type, pos, rot, scale, meshFile)
+            
+            
+            lightNodes = zone.getiterator("light")
+            for light in lightNodes:
+                name = light.attrib["name"]
+                z.lightList.append(name)
+                
+            soundNodes = zone.getiterator("sound")
+            for sound in soundNodes:
+                name = sound.attrib["name"]
+                z.soundList.append(name)
+            
+
+    def saveZonesToXml(self, root, map):
+        if len(map.zoneList) == 0:
+            return
+        
+        rootZonesElem = xml.SubElement(root, "zones")
+        for zone in map.zoneList:
+            zoneElem = xml.SubElement(rootZonesElem, "zone")
+            zoneElem.attrib["name"] = zone.name
+            
+            for area in zone.areaList:
+                areaElem = xml.SubElement(zoneElem, "area")
+                areaElem.attrib["type"] = area.type
+                #print "Saving Zone: " + zone.name + " - Area " + str(area.id)
+                if area.type == "mesh" and area.meshFile is not None:
+                    areaElem.attrib["meshfile"] = area.meshFile
+                    
+                posElem = xml.SubElement(areaElem, "position")
+                posElem.attrib["x"] = str(area.areaNode.getPosition().x)
+                posElem.attrib["y"] = str(area.areaNode.getPosition().y)
+                posElem.attrib["z"] = str(area.areaNode.getPosition().z)
+                
+                rotElem = xml.SubElement(areaElem, "rotation")
+                rotElem.attrib["qw"] = str(area.areaNode.getOrientation().w)
+                rotElem.attrib["qx"] = str(area.areaNode.getOrientation().x)
+                rotElem.attrib["qy"] = str(area.areaNode.getOrientation().y)
+                rotElem.attrib["qz"] = str(area.areaNode.getOrientation().z)
+                
+                scaleElem = None
+                if area.type == "mesh":
+                    scaleElem = xml.SubElement(areaElem, "scale")
+                else:
+                    scaleElem = xml.SubElement(areaElem, "size")
+
+                scaleElem.attrib["x"] = str(area.areaNode.getScale().x)
+                scaleElem.attrib["y"] = str(area.areaNode.getScale().y)
+                scaleElem.attrib["z"] = str(area.areaNode.getScale().z)
+                
+            for lightName in zone.lightList:
+                lightElem = xml.SubElement(zoneElem, "light")
+                lightElem.attrib["name"] = lightName
+            
+            for soundName in zone.soundList:
+                soundElem = xml.SubElement(zoneElem, "sound")
+                soundElem.attrib["name"] = soundName
+                
+    def deleteArea(self, area):
+        for z in self.zoneList:
+            for a in z.areaList:
+                if a.id == area.id:
+                    z.deleteArea(area)
+    
+    def getZoneMenu(self):
+        self.menuList = []
+        menu = QMenu("Add Area")
+        
+        for zone in self.zoneList:
+            m = QMenu(zone.name)
+            self.menuList.append(m)
+            menu.addMenu(m)
+            
+            boxAction = self.createAction("box", functools.partial(self.onZoneNameTriggered, zone, "box"))
+            self.menuList.append(boxAction)
+            m.addAction(boxAction)
+            
+            sphereAction = self.createAction("sphere", functools.partial(self.onZoneNameTriggered, zone, "sphere"))
+            self.menuList.append(sphereAction)
+            m.addAction(sphereAction)
+            
+            ellipsoidAction = self.createAction("ellipsoid", functools.partial(self.onZoneNameTriggered, zone, "ellipsoid"))
+            self.menuList.append(ellipsoidAction)
+            m.addAction(ellipsoidAction)
+            
+            capsuleAction = self.createAction("capsule", functools.partial(self.onZoneNameTriggered, zone, "capsule"))
+            self.menuList.append(capsuleAction)
+            m.addAction(capsuleAction)
+            
+            pyramidAction = self.createAction("pyramid", functools.partial(self.onZoneNameTriggered, zone, "pyramid"))
+            self.menuList.append(pyramidAction)
+            m.addAction(pyramidAction)
+            
+            meshAction = self.createAction("mesh", functools.partial(self.onZoneNameTriggered, zone, "mesh"))
+            self.menuList.append(meshAction)
+            m.addAction(meshAction)
+            
+        return menu
+        
+    def onZoneNameTriggered(self, zone, type):
+        if self.newAreaPosition is not None:
+            if type == "box":
+                zone.addArea("box", self.newAreaPosition, None, None)
+            elif type == "sphere":
+                zone.addArea("sphere", self.newAreaPosition, None, None)
+            elif type == "mesh":
+                dlg = NameInputDlg(QApplication.focusWidget())
+                resName = ""
+                if dlg.exec_():
+                    resName = str(dlg.nameInput.text())
+
+                zone.addArea("mesh", self.newAreaPosition, None, None, resName)
+                
+    def getZone(self, name):
+        for zone in self.zoneList:
+            if zone.name == name:
+                return zone
+        
+    def getZoneList(self):
+        list = []
+        for zone in self.zoneList:
+            list.append(zone.name)
+            
+        return list
+        
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QAction(text, None)
+        if icon is not None:
+            action.setIcon(QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            QWidget.connect(action, SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+        
+        
+        

Modified: rl/branches/persistence2/engine/ai/src/PhysicalObstacle.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/PhysicalObstacle.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/ai/src/PhysicalObstacle.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -70,7 +70,7 @@
         Quaternion orientation;
         body->getPositionOrientation(position, orientation);
 
-    	const OgreNewt::Collision* collision = body->getCollision();
+    	const OgreNewt::CollisionPtr collision = body->getCollision();
     	RlAssert(collision, "Body has no collision!");
     	AxisAlignedBox box = collision->getAABB();
     	Ogre::Vector3 dims = box.getMaximum() - box.getMinimum();

Modified: rl/branches/persistence2/engine/core/include/PhysicalThing.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicalThing.h	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/include/PhysicalThing.h	2009-04-11 10:34:44 UTC (rev 4893)
@@ -226,7 +226,7 @@
 		GeometryType getGeometryType() const;
 		void setBody(OgreNewt::Body* body);
 
-        OgreNewt::CollisionPtr createCollision(PhysicalObject* po, Ogre::Vector3& inertia) const;
+        OgreNewt::CollisionPtr createCollision(PhysicalObject* po, Ogre::Vector3& inertia, Ogre::Vector3& centerOfMass) const;
 
         //! the ragdoll, if this thing is controlled by a ragdoll
         PhysicsRagDoll* mRagDoll;

Modified: rl/branches/persistence2/engine/core/include/PhysicsManager.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicsManager.h	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/include/PhysicsManager.h	2009-04-11 10:34:44 UTC (rev 4893)
@@ -222,6 +222,9 @@
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
+		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
+         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
+         *                the new collision is not added to the cache
 		*/
 		OgreNewt::CollisionPtr createCollision(
 			Ogre::Entity* entity,
@@ -230,7 +233,9 @@
 			Ogre::Vector3* offset = NULL,
 			Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL,
+            bool nocache = false);
 
         /** creates a collision primitive for OgreNewt.
 		 * The collision primitive created has got a basic orientation which can be influenced by
@@ -248,6 +253,9 @@
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
+		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
+         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
+         *                the new collision is not added to the cache
 		*/
         OgreNewt::CollisionPtr createCollision(
             const Ogre::String& name,
@@ -256,7 +264,9 @@
             Ogre::Vector3* offset = NULL,
 			Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL,
+            bool nocache = false);
 
         /** Makes the collision primitive generation available to non mesh objects.
          * Non mesh objects need collision objects too. Therefore they can
@@ -292,7 +302,11 @@
         struct CollisionInUse
         {
         public:
-            CollisionInUse() : colPtr(NULL), geomType(GT_NONE) {}
+            CollisionInUse() :
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+                colPtr(NULL),
+#endif
+                geomType(GT_NONE) {}
             GeometryType geomType;  //! primitive type
             OgreNewt::CollisionPtr colPtr;          //! the collision primitve
         };
@@ -378,13 +392,13 @@
     {
     public:
         /** checks if the specified size is ok for OgreNewt
-         * @param size to check
+         * @param aabb check the aabb's size
          */
-        bool checkSize(const Ogre::Vector3& size) const;
+        bool checkSize(const Ogre::AxisAlignedBox& aabb) const;
         /** corrects the specified size if it is not ok for OgreNewt
-         * @param size to correct
+         * @param aabb correct the aabb's size
          */
-        void correctSize(Ogre::Vector3& size);
+        void correctSize(Ogre::AxisAlignedBox& aabb);
         /** calculates the Inertia for the given primitive type
          */
         //Ogre::Vector3 calculateIntertia(const Ogre::Real& Mass, Ogre::Vector3* inertiaCoefficients);
@@ -401,13 +415,15 @@
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
+		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
 		*/
         OgreNewt::CollisionPtr createCollisionFromEntity(Ogre::Entity* entity,
             const GeometryType& geomType,
             Ogre::Vector3* offset = NULL, 
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real Mass = 0,
-            Ogre::Vector3* inertiaCoefficients = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
 
         /** creates a collision primitive for OgreNewt from an AABB box.
 		 * The collision primitive created has got a basic orientation which can be influenced by
@@ -423,13 +439,15 @@
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
+		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
 		*/
         OgreNewt::CollisionPtr createCollisionFromAABB(const Ogre::AxisAlignedBox aabb,
             const GeometryType& geomType,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real Mass = 0,
-            Ogre::Vector3* inertiaCoefficients = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
     protected:
         /** creates a box collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
@@ -438,12 +456,14 @@
          * @param orientation when not null, specifies the euler angle of orientation.
          * @param mass gives the mass for inertia calculation.
          * @param inertia when not null, an inertia is calculated and passed back.
+         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
         OgreNewt::CollisionPtr createBox(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
         /** creates a pyramid collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
@@ -451,12 +471,14 @@
          * @param orientation when not null, specifies the euler angle of orientation.
          * @param mass gives the mass for inertia calculation.
          * @param inertia when not null, an inertia is calculated and passed back.
+         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
         OgreNewt::CollisionPtr createPyramid(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
         /** creates a sphere collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
@@ -464,12 +486,14 @@
          * @param orientation when not null, specifies the euler angle of orientation.
          * @param mass gives the mass for inertia calculation.
          * @param inertia when not null, an inertia is calculated and passed back.
+         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
         OgreNewt::CollisionPtr createSphere(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
         /** creates a ellipsoid collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
@@ -477,12 +501,14 @@
          * @param orientation when not null, specifies the euler angle of orientation.
          * @param mass gives the mass for inertia calculation.
          * @param inertia when not null, an inertia is calculated and passed back.
+         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
         OgreNewt::CollisionPtr createEllipsoid(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
         /** creates a capsule collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
@@ -490,12 +516,14 @@
          * @param orientation when not null, specifies the euler angle of orientation.
          * @param mass gives the mass for inertia calculation.
          * @param inertia when not null, an inertia is calculated and passed back.
+         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
         OgreNewt::CollisionPtr createCapsule(const Ogre::AxisAlignedBox& aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
     };
 }
 

Modified: rl/branches/persistence2/engine/core/include/PhysicsMaterialRaycast.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicsMaterialRaycast.h	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/include/PhysicsMaterialRaycast.h	2009-04-11 10:34:44 UTC (rev 4893)
@@ -111,7 +111,7 @@
         * @param invertmat if "true", the ray finds all collisions, which do NOT have the material-id "material"
         */
         ConvexcastInfo execute(OgreNewt::World* world, const OgreNewt::MaterialID* material,
-            const OgreNewt::Collision *col, const Ogre::Vector3& startpt, const Ogre::Quaternion &ori,
+            const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3& startpt, const Ogre::Quaternion &ori,
             const Ogre::Vector3& endpt, bool invertmat = false);
         
         /** executes the Convexcast
@@ -125,7 +125,7 @@
         * @param invertmat if "true", the ray finds all collisions, which do NOT have the material-id "material"
         */
         ConvexcastInfo execute(OgreNewt::World* world, const MaterialVector* materials,
-            const OgreNewt::Collision *col, const Ogre::Vector3& startpt, const Ogre::Quaternion &ori,
+            const OgreNewt::ConvexCollisionPtr& col, const Ogre::Vector3& startpt, const Ogre::Quaternion &ori,
             const Ogre::Vector3& endpt, bool invertmat = false);
 
 

Modified: rl/branches/persistence2/engine/core/include/PhysicsRagDoll.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicsRagDoll.h	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/include/PhysicsRagDoll.h	2009-04-11 10:34:44 UTC (rev 4893)
@@ -112,7 +112,7 @@
 
 	private:
         //! create a convexhull from a mesh
-		OgreNewt::ConvexCollision* _makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight );
+		OgreNewt::ConvexCollisionPtr _makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight );
 
 		//! the ragdoll to that this bone belongs
 		PhysicsRagDoll* mDoll;

Modified: rl/branches/persistence2/engine/core/src/GameAreaTypes.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/GameAreaTypes.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/src/GameAreaTypes.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -244,8 +244,15 @@
             col);
         mBody->setMaterialGroupID(
             PhysicsManager::getSingleton().getMaterialID("gamearea"));
+#ifndef OGRENEWT_USE_OGRE_ANY
         mBody->setUserData(NULL);
-        ((OgreNewt::ConvexCollision*)col)->setAsTriggerVolume(true);
+#endif
+
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+        boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(col)->setAsTriggerVolume(true);
+#else
+        dynamic_cast<OgreNewt::ConvexCollisionPtr>(col)->setAsTriggerVolume(true);
+#endif
     }
 
     GameSimpleCollisionAreaType::GameSimpleCollisionAreaType(
@@ -262,8 +269,15 @@
             col);
         mBody->setMaterialGroupID(
             PhysicsManager::getSingleton().getMaterialID("gamearea"));
+#ifndef OGRENEWT_USE_OGRE_ANY
         mBody->setUserData(NULL);
-        ((OgreNewt::ConvexCollision*)col)->setAsTriggerVolume(true);
+#endif
+
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+        boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(col)->setAsTriggerVolume(true);
+#else
+        dynamic_cast<OgreNewt::ConvexCollisionPtr>(col)->setAsTriggerVolume(true);
+#endif
     }
 
 }

Modified: rl/branches/persistence2/engine/core/src/GameEventManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/GameEventManager.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/src/GameEventManager.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -308,6 +308,10 @@
 
     Actor* GameEventManager::bodyToActor(OgreNewt::Body* body)
     {
+#ifdef OGRENEWT_USE_OGRE_ANY
+        return Ogre::any_cast<Actor*>(body->getUserData());
+#else
         return static_cast<Actor*>(body->getUserData());
+#endif
     }
 }

Modified: rl/branches/persistence2/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicalThing.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/src/PhysicalThing.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -28,7 +28,6 @@
 
 using namespace Ogre;
 using namespace OgreNewt;
-using namespace OgreNewt::CollisionPrimitives;
 
 namespace rl
 {
@@ -128,7 +127,11 @@
 	void PhysicalThing::setBody(OgreNewt::Body* body)
     {
         mBody = body;
-		mBody->setUserData(mActor);
+#ifdef OGRENEWT_USE_OGRE_ANY
+		mBody->setUserData( Ogre::Any(mActor) );
+#else
+        mBody->setUserData( mActor );
+#endif
     }
 
     void PhysicalThing::_update()
@@ -155,7 +158,13 @@
     {
         mActor = actor;
 		if (mBody != NULL)
-			mBody->setUserData(actor);
+        {
+#ifdef OGRENEWT_USE_OGRE_ANY
+    		mBody->setUserData( Ogre::Any(mActor) );
+#else
+            mBody->setUserData( mActor );
+#endif
+        }
     }
 
     void PhysicalThing::_attachToSceneNode(Ogre::SceneNode* node)
@@ -239,8 +248,12 @@
         if( mBody && !mRagDoll )
         {
             Vector3 inertia;
-            mBody->getMassMatrix(mMass, inertia);
+            Real oldMass;
+            mBody->getMassMatrix(oldMass, inertia);
             mMass = mass;
+            if( oldMass > 0 )
+                inertia = inertia/oldMass*mass;
+                
             mBody->setMassMatrix(mass, inertia);
         }
         mMass = mass;
@@ -268,10 +281,25 @@
             "PhysicalThing::updateCollisionHull: PhysicalThing must not be controlled by a RagDoll in order to update its collision hull.");
 
 
+        
         Vector3 position;
         Quaternion orientation;
         mBody->getPositionOrientation(position, orientation);
+        CollisionPtr collision = PhysicsManager::getSingleton().createCollision(
+                entity,
+                mGeometryType,
+                "",
+                NULL,
+                NULL,
+                0, NULL, NULL,
+                true); // don't cache
+        if( collision )
+        {
+            mBody->setCollision(collision);
+            mBody->setPositionOrientation(position, orientation);
+        }
 
+/*
 		if (mGeometryType == GT_CONVEXHULL)
 		{
 			Matrix4 transform = node->_getFullTransform().inverse();
@@ -324,18 +352,19 @@
 					vbuffer->unlock();
 				}
 			}
-	        CollisionPtr collision(new ConvexHull(PhysicsManager::getSingleton()._getNewtonWorld(),
+	        CollisionPtr collision(new CollisionPrimitives::ConvexHull(PhysicsManager::getSingleton()._getNewtonWorld(),
 			    &vertices[0], vertices.size()));
 		    mBody->setCollision(collision);
 		}
 		else if (mGeometryType == GT_MESH)
 		{
-	        CollisionPtr collision(new TreeCollision(
+	        CollisionPtr collision(new CollisionPrimitives::TreeCollision(
 				PhysicsManager::getSingleton()._getNewtonWorld(), entity, true));
 		    mBody->setCollision(collision);
 		}
 
         mBody->setPositionOrientation(position, orientation);
+*/
     }
 
     void PhysicalThing::freeze()
@@ -443,8 +472,8 @@
                 "PhysicalThing::createPhysicsProxy: cannot create physics proxy while the PhysicalThing is controlled by a RagDoll!");
 		if (!mBody)
 		{
-            Vector3 inertia;
-            OgreNewt::CollisionPtr coll = createCollision(mPhysicalObject, inertia);
+            Vector3 inertia, centerOfMass;
+            OgreNewt::CollisionPtr coll = createCollision(mPhysicalObject, inertia, centerOfMass);
 
 			OgreNewt::Body* body = new OgreNewt::Body(
                 PhysicsManager::getSingleton()._getNewtonWorld(), coll);
@@ -454,6 +483,7 @@
 			if (mass > 0.0 && mGeometryType != GT_MESH)
             {
                 body->setMassMatrix(mass, inertia);
+                body->setCenterOfMass(centerOfMass);
             }
 
 			body->setCustomForceAndTorqueCallback(PhysicsManager::genericForceCallback);
@@ -469,7 +499,7 @@
         }
 	}
 
-    OgreNewt::CollisionPtr PhysicalThing::createCollision(PhysicalObject* po, Vector3& inertia) const
+    OgreNewt::CollisionPtr PhysicalThing::createCollision(PhysicalObject* po, Vector3& inertia, Vector3& centerOfMass) const
     {
         OgreNewt::CollisionPtr coll;
 
@@ -488,7 +518,8 @@
                 NULL,
                 NULL,
                 mMass,
-                &inertia);
+                &inertia,
+                &centerOfMass);
         }
         else
         {
@@ -499,7 +530,8 @@
                 NULL,
                 NULL,
                 mMass,
-                &inertia);
+                &inertia,
+                &centerOfMass);
         }
 
         return coll;
@@ -511,13 +543,14 @@
         {
             mPoseCollisions.clear();
 
-            Vector3 inertia;
+            Vector3 inertia, centerOfMass;
 
             // update the collision
-		    mBody->setCollision(createCollision(mPhysicalObject, inertia));
+		    mBody->setCollision(createCollision(mPhysicalObject, inertia, centerOfMass));
 		    if (mMass > 0.0 && mGeometryType != GT_MESH)
             {
                 mBody->setMassMatrix(mMass, inertia);
+                mBody->setCenterOfMass(centerOfMass);
             }
         }
     }

Modified: rl/branches/persistence2/engine/core/src/PhysicsGenericContactCallback.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicsGenericContactCallback.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/src/PhysicsGenericContactCallback.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -29,8 +29,30 @@
     {
         userProcess(contactJoint, timestep, threadid);
 
-        Actor* a1 = static_cast<Actor*>(contactJoint.getBody0()->getUserData());
-        Actor* a2 = static_cast<Actor*>(contactJoint.getBody1()->getUserData());
+        Actor* a1 = NULL;
+        Actor* a2 = NULL;
+
+#ifdef OGRENEWT_USE_OGRE_ANY
+        try
+        {
+            a1 = Ogre::any_cast<Actor*>(contactJoint.getBody0()->getUserData());
+        }
+        catch(...)
+        {
+            LOG_WARNING(Logger::CORE, "Found collision with a OgreNewt::Body that doesn't have an Actor as UserData in PhysicsGenericContactCallback::contactsProcess");
+        }
+        try
+        {
+            a2 = Ogre::any_cast<Actor*>(contactJoint.getBody1()->getUserData());
+        }
+        catch(...)
+        {
+            LOG_WARNING(Logger::CORE, "Found collision with a OgreNewt::Body that doesn't have an Actor as UserData in PhysicsGenericContactCallback::contactsProcess");
+        }
+#else
+        a1 = static_cast<Actor*>(contactJoint.getBody0()->getUserData());
+        a2 = static_cast<Actor*>(contactJoint.getBody1()->getUserData());
+#endif
         if (a1 && a1->getPhysicalThing()->getContactListener())
         {
             a1->getPhysicalThing()->getContactListener()->

Modified: rl/branches/persistence2/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicsManager.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/src/PhysicsManager.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -36,7 +36,7 @@
 
 namespace rl
 {
-    const Ogre::Real PhysicsManager::NEWTON_GRID_WIDTH = 0.01;
+    const Ogre::Real PhysicsManager::NEWTON_GRID_WIDTH = 0.02;
 
 	LQTBodies::LQTBodies(int maxData, int maxDepth, float looseness,
 		const Ogre::Vector2& tlc, const Ogre::Vector2& brc, float mWidth)
@@ -326,7 +326,10 @@
         
 
         // try one compound collision for the entity if there are several collisions
-        OgreNewt::CollisionPtr collision(NULL);
+        OgreNewt::CollisionPtr collision;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        collision = NULL;
+#endif
         switch( collisions.size() )
         {
             case 0:
@@ -335,7 +338,7 @@
                 collision = collisions[0];
                 break;
             default:
-                collision = new OgreNewt::CollisionPrimitives::CompoundCollision(mWorld, collisions);
+                collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::CompoundCollision(mWorld, collisions));
                 break;
         }
 
@@ -403,17 +406,28 @@
     void PhysicsManager::genericForceCallback(OgreNewt::Body* body, float timestep, int)
     {
         // apply saved forces in the PhysicalThing
-        PhysicalThing* thing =
-            static_cast<Actor*>(body->getUserData())->getPhysicalThing();
+        PhysicalThing* thing;
 
+#ifdef OGRENEWT_USE_OGRE_ANY
+        thing = Ogre::any_cast<Actor*>(body->getUserData())->getPhysicalThing();
+#else
+        thing = static_cast<Actor*>(body->getUserData())->getPhysicalThing();
+#endif
+
         thing->onApplyForceAndTorque(timestep);
     }
 
     void PhysicsManager::controlledForceCallback(OgreNewt::Body* body, float timestep, int)
     {
-        PhysicalThing* thing =
-            static_cast<Actor*>(body->getUserData())->getPhysicalThing();
+        PhysicalThing* thing;
 
+#ifdef OGRENEWT_USE_OGRE_ANY
+        thing = Ogre::any_cast<Actor*>(body->getUserData())->getPhysicalThing();
+#else
+        thing = static_cast<Actor*>(body->getUserData())->getPhysicalThing();
+#endif
+
+
         if (thing->getPhysicsController())
         {
             thing->getPhysicsController()->OnApplyForceAndTorque(thing, timestep);
@@ -507,7 +521,8 @@
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
         Ogre::Entity* entity, const GeometryType& geomType,
 		const Ogre::String animName, Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia)
+        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
+        Ogre::Vector3* centerOfMass, bool nocache)
     {
         // problem here is that a mesh can have different animations with
         // different extents. Therefore we add the animName to the meshname
@@ -516,6 +531,9 @@
 
         // result value
         CollisionPtr rval;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        rval = NULL;
+#endif
 
         // check if there is a collision primitiv for the specified mesh object
         CollisionInUse &usedcol (mCollisionPrimitives[collisionName]);
@@ -534,70 +552,6 @@
                 // found it
                 rval = usedcol.colPtr;
 
-
-                if( inertia )
-                {
-
-                    // we must set inertia here, the calling function doesn't know we are not creating a new collision
-                    switch(usedcol.geomType)
-                    {
-                    case GT_BOX: // from createBox
-                    case GT_CAPSULE: // from createCapsule
-                    case GT_CONVEXHULL: // from createCollisionFromEntity
-                    case GT_ELLIPSOID: // from createEllipsoid
-                    case GT_PYRAMID: // createPyramid
-                    case GT_SPHERE:
-                    case GT_MESH:
-                    case GT_NONE:
-                        *inertia = Ogre::Vector3::ZERO;
-                        break;
-                    }
-/*
-                    Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
-                    Vector3 size( aabb.getSize() );
-                    switch(usedcol.geomType)
-                    {
-                    case GT_BOX: // from createBox
-                        *inertia = OgreNewt::MomentOfInertia::CalcBoxSolid(mass, aabb.getSize());
-                        break;
-                    case GT_CAPSULE: // from createCapsule
-                        {
-                            double radius = std::max(size.x, size.z) / 2.0;
-                            double sradius = radius*radius;
-                            *inertia = Vector3(sradius, size.y*size.y, sradius) * mass;
-                        }
-                        break;
-                    case GT_CONVEXHULL: // from createCollisionFromEntity
-				        *inertia = Vector3(
-				        size.x*size.x/6.0f,
-				        size.y*size.y/6.0f,
-			            size.z*size.z/6.0f) * mass;
-                        break;
-                    case GT_ELLIPSOID: // from createEllipsoid
-                        {
-                            Vector3 s(size/2.0);
-                            s.x = std::max(s.x, s.z);
-                            s.z = s.x;
-                            *inertia = Vector3(s.x*s.x, s.y*s.y, s.z*s.z) * mass;
-                        }
-                        break;
-                    case GT_MESH:
-                    case GT_NONE:
-                        *inertia = Ogre::Vector3::ZERO;
-                        break;
-                    case GT_PYRAMID: // createPyramid
-                        *inertia = Ogre::Vector3(size.x,size.y/2.0f, size.z) * mass;
-                        break;
-                    case GT_SPHERE:
-                        {
-                            double radius = std::max(size.x, std::max(size.y, size.z)) / 2.0;
-                            //*inertia = OgreNewt::MomentOfInertia::CalcSphereSolid(Mass,radius);
-                            *inertia = mass * Vector3(radius*radius, radius*radius, radius*radius);
-                        }
-                        break;
-                    }
-*/
-                }
             }
         }
 
@@ -605,7 +559,7 @@
         {
             // if there is none, then create a new collision object
             rval = mPhysicsCollisionFactory->createCollisionFromEntity(
-                entity, geomType, offset, orientation, mass, inertia );
+                entity, geomType, offset, orientation, mass, inertia, centerOfMass );
 
             usedcol.geomType = geomType;
             usedcol.colPtr = rval;
@@ -617,10 +571,14 @@
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
         const Ogre::String& name, const Ogre::AxisAlignedBox& aabb,
         const GeometryType& geomType, Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia)
+        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
+        Ogre::Vector3* centerOfMass, bool nocache)
     {
         // result value
         CollisionPtr rval;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        rval = NULL;
+#endif
 
         // check if there is a collision primitiv for the specified mesh object
         CollisionInUse &usedcol (mCollisionPrimitives[name]);
@@ -645,7 +603,7 @@
         {
             // if there is none, then create a new collision object
             rval = mPhysicsCollisionFactory->createCollisionFromAABB(
-                aabb, geomType, offset, orientation, mass, inertia );
+                aabb, geomType, offset, orientation, mass, inertia, centerOfMass );
 
             usedcol.geomType = geomType;
             usedcol.colPtr = rval;
@@ -699,8 +657,9 @@
 		return typestr;
 	}
 
-    bool PhysicsCollisionFactory::checkSize(const Ogre::Vector3& size) const
+    bool PhysicsCollisionFactory::checkSize(const Ogre::AxisAlignedBox& aabb) const
     {
+        Ogre::Vector3 size = aabb.getSize();
         if( size.x < PhysicsManager::NEWTON_GRID_WIDTH ||
             size.y < PhysicsManager::NEWTON_GRID_WIDTH ||
             size.z < PhysicsManager::NEWTON_GRID_WIDTH )
@@ -708,8 +667,9 @@
         return true;
     }
 
-    void PhysicsCollisionFactory::correctSize(Ogre::Vector3& size)
+    void PhysicsCollisionFactory::correctSize(Ogre::AxisAlignedBox& aabb)
     {
+        Ogre::Vector3 size = aabb.getSize();
         // correct size, log warning and fail back to box
         if (size.x < PhysicsManager::NEWTON_GRID_WIDTH)
             size.x = PhysicsManager::NEWTON_GRID_WIDTH;
@@ -718,6 +678,9 @@
         if (size.z < PhysicsManager::NEWTON_GRID_WIDTH)
             size.z = PhysicsManager::NEWTON_GRID_WIDTH;
         LOG_MESSAGE(Logger::CORE, "Correcting collision primitiv size");
+        Ogre::Vector3 center = aabb.getCenter();
+        aabb.setMaximum(center + 0.5*size);
+        aabb.setMinimum(center - 0.5*size);
     }
 
     /*
@@ -727,25 +690,28 @@
     }
     */
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(const Ogre::AxisAlignedBox aabb,
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(const Ogre::AxisAlignedBox passedAabb,
         const GeometryType& geomType,
         Ogre::Vector3* offset,
         Ogre::Quaternion* orientation,
         const Ogre::Real Mass,
-        Ogre::Vector3* inertia)
+        Ogre::Vector3* inertia,
+        Ogre::Vector3* centerOfMass)
     {
-        // size of the mesh
-        Vector3 size( aabb.getSize() );
+        Ogre::AxisAlignedBox aabb(passedAabb);
         // type for the collision primitiv (can change internally here)
         bool forceBox (false);
 
         // result value
         CollisionPtr rval;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        rval = NULL;
+#endif
 
         // size check (if object is too small, it falls back to a box primitiv
-        if (checkSize(size) == false )
+        if (checkSize(aabb) == false )
         {
-            correctSize(size);
+            correctSize(aabb);
             LOG_MESSAGE(Logger::CORE,
                 " AABB is too small, using 'box' instead of primitiv '" +
                 PhysicsManager::convertGeometryTypeToString(geomType));
@@ -772,23 +738,23 @@
 	    */
 		if (geomType == GT_BOX || forceBox == true)
         {
-			rval = createBox(aabb, offset, orientation, Mass, inertia);
+			rval = createBox(aabb, offset, orientation, Mass, inertia, centerOfMass);
         }
         else if (geomType == GT_PYRAMID)
         {
-            rval = createPyramid(aabb, offset, orientation, Mass, inertia);
+            rval = createPyramid(aabb, offset, orientation, Mass, inertia, centerOfMass);
         }
         else if (geomType == GT_SPHERE)
         {
-			rval = createSphere(aabb, offset, orientation, Mass, inertia);
+			rval = createSphere(aabb, offset, orientation, Mass, inertia, centerOfMass);
         }
         else if (geomType == GT_ELLIPSOID)
         {
-            rval = createEllipsoid(aabb, offset, orientation, Mass, inertia);
+            rval = createEllipsoid(aabb, offset, orientation, Mass, inertia, centerOfMass);
         }
 		else if (geomType == GT_CAPSULE)
 		{
-			rval = createCapsule(aabb, offset, orientation, Mass, inertia);
+			rval = createCapsule(aabb, offset, orientation, Mass, inertia, centerOfMass);
 		}
         return rval;
     }
@@ -797,23 +763,25 @@
         const GeometryType& geomType,
         Ogre::Vector3* offset,
         Ogre::Quaternion* orientation,
-        const Ogre::Real Mass,
-        Ogre::Vector3* inertia)
+        const Ogre::Real mass,
+        Ogre::Vector3* inertia,
+        Ogre::Vector3* centerOfMass)
     {
         // bounding box of the mesh
-        const Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
-        // size of the mesh
-        Vector3 size( aabb.getSize() );
+        Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
         // type for the collision primitiv (can change internally here)
         bool forceBox (false);
 
         // result value
         CollisionPtr rval;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        rval = NULL;
+#endif
 
         // size check (if object is too small, it falls back to a box primitiv
-        if (checkSize(size) == false )
+        if (checkSize(aabb) == false )
         {
-            correctSize(size);
+            correctSize(aabb);
             LOG_MESSAGE(Logger::CORE, " Entity '"+entity->getName()+
                 "' is too small, using 'box' instead of primitiv '"+
                 PhysicsManager::convertGeometryTypeToString(geomType));
@@ -829,23 +797,23 @@
 	    */
 		if (geomType == GT_BOX || forceBox == true)
         {
-			rval = createBox(aabb, offset, orientation, Mass, inertia);
+			rval = createBox(aabb, offset, orientation, mass, inertia, centerOfMass);
         }
         else if (geomType == GT_PYRAMID)
         {
-            rval = createPyramid(aabb, offset, orientation, Mass, inertia);
+            rval = createPyramid(aabb, offset, orientation, mass, inertia, centerOfMass);
         }
         else if (geomType == GT_SPHERE)
         {
-			rval = createSphere(aabb, offset, orientation, Mass, inertia);
+			rval = createSphere(aabb, offset, orientation, mass, inertia, centerOfMass);
         }
         else if (geomType == GT_ELLIPSOID)
         {
-            rval = createEllipsoid(aabb, offset, orientation, Mass, inertia);
+            rval = createEllipsoid(aabb, offset, orientation, mass, inertia, centerOfMass);
         }
 		else if (geomType == GT_CAPSULE)
 		{
-			rval = createCapsule(aabb, offset, orientation, Mass, inertia);
+			rval = createCapsule(aabb, offset, orientation, mass, inertia, centerOfMass);
 		}
         else if (geomType == GT_CONVEXHULL)
         {
@@ -865,17 +833,26 @@
                 PhysicsManager::getSingleton()._getNewtonWorld(),
 				entity, /*entity->hasSkeleton(),*/ *orientation, *offset));
 
-			if (inertia != NULL)
-			{
-                            Vector3 inert_offs=Vector3::ZERO;
-                            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
-                            *inertia *= Mass;
-			}
+            if (inertia != NULL || centerOfMass != NULL )
+            {
+                Vector3 temp_inertia, temp_centerOfMass;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+                boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+                dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
+                if( inertia != NULL )
+                    *inertia = temp_inertia*mass;
+                if( centerOfMass != NULL )
+                    *centerOfMass = temp_centerOfMass;
+            }
         }
         else if (geomType == GT_MESH)
         {
             if (inertia != NULL)
                 *inertia = Ogre::Vector3::ZERO;
+            if (centerOfMass != NULL)
+                *centerOfMass = Ogre::Vector3::ZERO;
 
             rval = CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
                 PhysicsManager::getSingleton()._getNewtonWorld(),
@@ -906,7 +883,8 @@
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
             const Ogre::Real mass,
-            Ogre::Vector3* inertia)
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass)
     {
         // offset of the collision primitiv
         Ogre::Vector3 object_offset( aabb.getCenter() );
@@ -923,11 +901,20 @@
         OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             aabb.getSize(), *orientation, *offset));
-        if (inertia)
+
+
+        if (inertia != NULL || centerOfMass != NULL )
         {
-            Vector3 inert_offs=Vector3::ZERO;
-            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
-            *inertia *= mass;
+            Vector3 temp_inertia, temp_centerOfMass;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
+            if( inertia )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass )
+                *centerOfMass = temp_centerOfMass;
         }
 
         return rval;
@@ -937,7 +924,8 @@
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
             const Ogre::Real mass,
-            Ogre::Vector3* inertia)
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass)
     {
         Ogre::Vector3 size = aabb.getSize();
         // positional offset of the collision primitiv
@@ -954,13 +942,22 @@
         OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             size, *orientation, *offset));
-        if (inertia)
+
+
+        if (inertia != NULL || centerOfMass != NULL )
         {
-            Vector3 inert_offs=Vector3::ZERO;
-            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
-            *inertia *= mass;
+            Vector3 temp_inertia, temp_centerOfMass;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
+            if( inertia )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass )
+                *centerOfMass = temp_centerOfMass;
         }
-
+ 
         return rval;
     }
 
@@ -968,7 +965,8 @@
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
             const Ogre::Real mass,
-            Ogre::Vector3* inertia)
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass)
     {
         Ogre::Vector3 size = aabb.getSize();
         // calculate the maximum radius needed to include 'everything'
@@ -989,12 +987,22 @@
         OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             Vector3(radius, radius, radius), *orientation, *offset));
-        if (inertia)
+ 
+
+        if (inertia != NULL || centerOfMass != NULL )
         {
-            Vector3 inert_offs=Vector3::ZERO;
-            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
-            *inertia *= mass;
+            Vector3 temp_inertia, temp_centerOfMass;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
+            if( inertia )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass )
+                *centerOfMass = temp_centerOfMass;
         }
+ 
         return rval;
     }
 
@@ -1002,7 +1010,8 @@
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
             const Ogre::Real mass,
-            Ogre::Vector3* inertia)
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass)
     {
         Ogre::Vector3 size = aabb.getSize();
         // set the size x/z values to the maximum
@@ -1025,13 +1034,21 @@
             PhysicsManager::getSingleton()._getNewtonWorld(),
             s, *orientation, *offset));
 
-        if (inertia)
+
+        if (inertia != NULL || centerOfMass != NULL )
         {
-            Vector3 inert_offs=Vector3::ZERO;
-            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
-            *inertia *= mass;
+            Vector3 temp_inertia, temp_centerOfMass;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
+            if( inertia )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass )
+                *centerOfMass = temp_centerOfMass;
         }
-
+ 
         return rval;
     }
 
@@ -1039,7 +1056,8 @@
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
             const Ogre::Real mass,
-            Ogre::Vector3* inertia)
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass)
     {
         Ogre::Vector3 size = aabb.getSize();
         // positional offset of the collision primitiv
@@ -1060,16 +1078,26 @@
 
         // an capsule primitiv has got its coordinate system at its center, so shift it with radius
         // additionally it is x axis aligned, so rotate it 90 degrees around z axis
-        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Capsule(
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Capsule(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             radius, height, *orientation, *offset));
 
-        if (inertia)
+
+        if (inertia != NULL || centerOfMass != NULL )
         {
-            Vector3 inert_offs=Vector3::ZERO;
-            static_cast<OgreNewt::ConvexCollision*>(rval)->calculateInertialMatrix(*inertia, inert_offs);
-            *inertia *= mass;
+            Vector3 temp_inertia, temp_centerOfMass;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
+            if( inertia )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass )
+                *centerOfMass = temp_centerOfMass;
         }
+ 
+ 
         return rval;
     }
 }

Modified: rl/branches/persistence2/engine/core/src/PhysicsMaterialRaycast.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicsMaterialRaycast.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/src/PhysicsMaterialRaycast.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -186,7 +186,7 @@
     }
 
     ConvexcastInfo PhysicsMaterialConvexcast::execute(OgreNewt::World* world, const OgreNewt::MaterialID* material,
-                        const OgreNewt::Collision *col, const Vector3& startpt, const Quaternion &ori,
+                        const OgreNewt::ConvexCollisionPtr& col, const Vector3& startpt, const Quaternion &ori,
                         const Vector3& endpt, bool invertmat)
     {
         mMaterialVector = NULL;
@@ -201,7 +201,7 @@
     }
 
     ConvexcastInfo PhysicsMaterialConvexcast::execute(OgreNewt::World* world, const MaterialVector* materials,
-                        const OgreNewt::Collision *col, const Vector3& startpt, const Quaternion &ori,
+                        const OgreNewt::ConvexCollisionPtr& col, const Vector3& startpt, const Quaternion &ori,
                         const Vector3& endpt, bool invertmat)
     {
         mMaterialVector = materials;

Modified: rl/branches/persistence2/engine/core/src/PhysicsRagDoll.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicsRagDoll.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/src/PhysicsRagDoll.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -35,7 +35,11 @@
 	mParent = parent;
 	mOgreBone = ogreBone;
 
-	OgreNewt::ConvexCollision* col = NULL;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+	OgreNewt::ConvexCollisionPtr col;
+#else
+	OgreNewt::ConvexCollisionPtr col = NULL;
+#endif
 
 	// in the case of the cylindrical primitives, they need to be rotated to align the main axis with the direction vector.
 	Ogre::Quaternion orient = Ogre::Quaternion::IDENTITY;
@@ -59,23 +63,23 @@
 	switch (shape)
 	{
 	case PhysicsRagDoll::RagBone::BS_BOX:
-		col = new OgreNewt::CollisionPrimitives::Box( world, size );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CAPSULE:
-		col = new OgreNewt::CollisionPrimitives::Capsule( world, size.y, size.x, orient, pos );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Capsule( world, size.y, size.x, orient, pos ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CONE:
-		col = new OgreNewt::CollisionPrimitives::Cone( world, size.y, size.x, orient, pos );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cone( world, size.y, size.x, orient, pos ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CYLINDER:
-		col = new OgreNewt::CollisionPrimitives::Cylinder( world, size.y, size.x, orient, pos );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder( world, size.y, size.x, orient, pos ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_ELLIPSOID:
-		col = new OgreNewt::CollisionPrimitives::Ellipsoid( world, size );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( world, size ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CONVEXHULL:
@@ -83,7 +87,7 @@
 		break;
 
 	default:
-		col = new OgreNewt::CollisionPrimitives::Box( world, size );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size ));
 		break;
 	}
 
@@ -91,12 +95,16 @@
     {
         if( col->getNewtonCollision() == NULL )
         {
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            col.reset();
+#else
             delete col;
             col = NULL;
+#endif
         }
     }
 
-    if( col == NULL )
+    if( !col )
     {
         LOG_WARNING(Logger::CORE, " error creating collision for '" + ogreBone->getName() + "', still continuing.");
         mBody = NULL;
@@ -104,7 +112,11 @@
     else
     {
     	mBody = new OgreNewt::Body( world, col );
+#ifdef OGRENEWT_USE_OGRE_ANY
+        mBody->setUserData( Ogre::Any(parentActor) );
+#else
 	    mBody->setUserData( parentActor );
+#endif
     	mBody->setStandardForceCallback();
         const OgreNewt::MaterialID* ragdollMat = PhysicsManager::getSingleton().createMaterialID("default");
         mBody->setMaterialGroupID(ragdollMat);
@@ -134,7 +146,11 @@
 
 void PhysicsRagDoll::RagBone::_hingeCallback( OgreNewt::BasicJoints::Hinge* me )
 {
-	PhysicsRagDoll::RagBone* bone = (PhysicsRagDoll::RagBone*)me->getUserData();
+#ifdef OGRENEWT_USE_OGRE_ANY
+    PhysicsRagDoll::RagBone* bone = Ogre::any_cast<PhysicsRagDoll::RagBone*>(me->getUserData());
+#else
+    PhysicsRagDoll::RagBone* bone = static_cast<PhysicsRagDoll::RagBone*>(me->getUserData());
+#endif
 
 	Ogre::Degree angle = me->getJointAngle();
 	Ogre::Degree lim1( bone->getLimit1() );
@@ -155,7 +171,7 @@
 }
 
 
-OgreNewt::ConvexCollision* PhysicsRagDoll::RagBone::_makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight )
+OgreNewt::ConvexCollisionPtr PhysicsRagDoll::RagBone::_makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight )
 {
 	std::vector< Ogre::Vector3 > vertexVector;
 
@@ -245,9 +261,13 @@
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////
-    OgreNewt::ConvexCollision* col = NULL;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+    OgreNewt::ConvexCollisionPtr col;
+#else
+    OgreNewt::ConvexCollisionPtr col = NULL;
+#endif
     if( numVerts > 0 )
-    	col = new OgreNewt::CollisionPrimitives::ConvexHull( world, verts, numVerts );
+    	col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull( world, verts, numVerts ));
 
 	delete []verts;
 
@@ -444,7 +464,11 @@
 	case PhysicsRagDoll::JT_HINGE:
 		joint = new OgreNewt::BasicJoints::Hinge( world, child->getBody(), parent->getBody(), pos, pin );
 		((OgreNewt::BasicJoints::Hinge*)joint)->setCallback( RagBone::_hingeCallback );
+#ifdef OGRENEWT_USE_OGRE_ANY
+		joint->setUserData( Ogre::Any(child) );
+#else
 		joint->setUserData( child );
+#endif
 		child->setLimits( limit1, limit2 );
 		break;
 	}
@@ -454,7 +478,11 @@
 
 void PhysicsRagDoll::_placementCallback( OgreNewt::Body* me, const Ogre::Quaternion& orient, const Ogre::Vector3& pos, int threadindex )
 {
+#ifdef OGRENEWT_USE_OGRE_ANY
+    Actor* parentActor = Ogre::any_cast<Actor*>(me->getUserData());
+#else
     Actor* parentActor = static_cast<Actor*>(me->getUserData());
+#endif
 	PhysicsRagDoll* doll = parentActor->getPhysicalThing()->getRagDoll();
     PhysicsRagDoll::RagBoneMapIterator it = doll->mRagBonesMap.find(me);
     if( it == doll->mRagBonesMap.end() )

Modified: rl/branches/persistence2/engine/core/src/SceneQuery.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/SceneQuery.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/src/SceneQuery.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -116,7 +116,11 @@
                 if (mLevelOcclusion && (body->getMaterialGroupID() == levelId)) break;
 
                 // Add actor to this body to the result
+#ifdef OGRENEWT_USE_OGRE_ANY
+                Actor* actor = Ogre::any_cast<Actor*>(body->getUserData());
+#else
                 Actor* actor = static_cast<Actor*>(body->getUserData());
+#endif
                 if (actor != NULL) mResult.push_back(actor);
             }
         }

Modified: rl/branches/persistence2/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/CreatureController.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/rules/src/CreatureController.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -80,8 +80,8 @@
 
         mCreature->getActor()->getPhysicalThing()->setPhysicsController(this);
 
-//        mCreature->getActor()->getPhysicalThing()->_getBody()->setAngularDamping(0*Vector3::UNIT_SCALE);
-        mCreature->getActor()->getPhysicalThing()->_getBody()->setContinuousCollisionMode(1);
+        //mCreature->getActor()->getPhysicalThing()->_getBody()->setAngularDamping(0*Vector3::UNIT_SCALE);
+        //mCreature->getActor()->getPhysicalThing()->_getBody()->setContinuousCollisionMode(1);
 
 
         std::pair<MovementType, AbstractMovement*> movementPair;
@@ -407,11 +407,12 @@
 
         Vector3 charPos;
         Quaternion charOri;
-        mCreature->getActor()->getPhysicalThing()->_getBody()->getPositionOrientation(charPos, charOri);
+        OgreNewt::Body* charBody = mCreature->getActor()->getPhysicalThing()->_getBody();
+        charBody->getPositionOrientation(charPos, charOri);
         bool isFloorCollision(false);
 
-        AxisAlignedBox CharAab = mCreature->getActor()->getPhysicalThing()->_getBody()->getCollision()->getAABB();
-        Real charHeight = CharAab.getMaximum().y - CharAab.getMinimum().y;
+        AxisAlignedBox charAab = charBody->getCollision()->getAABB();
+        Real charHeight = charAab.getMaximum().y - charAab.getMinimum().y;
         Real stepHeight = point.y - charPos.y;
 
         if( stepHeight < charHeight/2 )
@@ -426,6 +427,17 @@
                 mLastFloorContact = time;
             }
         }
+
+        // set contact direction to point to the center of mass
+        contact.setNormalDirection((charPos + charBody->getCenterOfMass() - point).normalisedCopy());
+        contact.setNormalAcceleration(0);
+        // no friction
+        contact.setFrictionState(0,0);
+        contact.setFrictionState(0,1);
+        contact.setTangentAcceleration(0,0);
+        contact.setTangentAcceleration(0,1);
+
+
 /*
 //        setContactNormalDirection(((Vector3::UNIT_Y.dotProduct(point-charPos)*Vector3::UNIT_Y + charPos) - point).normalisedCopy());
         setContactNormalDirection(point - (charPos + charHeight/2));
@@ -434,8 +446,8 @@
         setContactFrictionState(0,1);
         setContactTangentAcceleration(0, 0);
         setContactTangentAcceleration(0, 1);
+*/
 
-*/
 //std::ostringstream oss;
 //Vector3 vec1, vec2;
 //oss << " Collision: Point: " << point-charPos;
@@ -448,10 +460,10 @@
 //oss << "  \t Tangent-Directions: " << vec1 << " " << vec2;
 //LOG_MESSAGE(Logger::RULES, oss.str());
 
-        contact.rotateTangentDirections(/*charOri*mDirection + */Vector3::UNIT_Y);
-        contact.setFrictionState(1,0);
-        contact.setFrictionState(0,1);
-
+//        contact.rotateTangentDirections(/*charOri*mDirection + */Vector3::UNIT_Y);
+//        contact.setFrictionState(0,0);
+//        contact.setFrictionState(0,1);
+/*
         if( stepHeight < 0.4 )
         {
             if(stepHeight > 0.01f) // experimantal value, 
@@ -485,6 +497,7 @@
                 //setContactFrictionState(0,1);
             }
         }
+*/
 }
 
         if(mMovement != NULL)

Modified: rl/branches/persistence2/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/CreatureControllerManager.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/rules/src/CreatureControllerManager.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -166,7 +166,11 @@
 
     void CreatureControllerManager::userProcess(OgreNewt::ContactJoint &contactJoint, Real timestep, int threadid)
     {
+#ifdef OGRENEWT_USE_OGRE_ANY
+        Actor *actor = Ogre::any_cast<Actor*>(contactJoint.getBody0()->getUserData());
+#else
         Actor *actor = static_cast<Actor*>(contactJoint.getBody0()->getUserData());
+#endif
         if( actor != NULL )
         {
             ControllerMap::const_iterator it = mControllers.find(static_cast<Creature*>(actor->getGameObject()));
@@ -178,7 +182,11 @@
         }
 
         // if the controlled body is the second body...
-        actor = static_cast<Actor*>(contactJoint.getBody1()->getUserData());
+#ifdef OGRENEWT_USE_OGRE_ANY
+        actor = Ogre::any_cast<Actor*>(contactJoint.getBody0()->getUserData());
+#else
+        actor = static_cast<Actor*>(contactJoint.getBody0()->getUserData());
+#endif
         if( actor != NULL )
         {
             ControllerMap::const_iterator it = mControllers.find(static_cast<Creature*>(actor->getGameObject()));

Modified: rl/branches/persistence2/engine/rules/src/SelectionHelper.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/SelectionHelper.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/rules/src/SelectionHelper.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -84,7 +84,11 @@
             OgreNewt::Body* body = info.mBody;
             if (body != NULL)
             {
+#ifdef OGRENEWT_USE_OGRE_ANY
+                Actor* hitActor = Ogre::any_cast<Actor*>(body->getUserData());
+#else
                 Actor* hitActor = static_cast<Actor*>(body->getUserData());
+#endif
                 isVisible = hitActor == actor2 || hitActor == actor1;
                 if (!isVisible) break;
             }

Modified: rl/branches/persistence2/engine/script/src/EntityNodeProcessor.cpp
===================================================================
--- rl/branches/persistence2/engine/script/src/EntityNodeProcessor.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/script/src/EntityNodeProcessor.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -43,13 +43,13 @@
 
         Ogre::String entName = getAttributeValueAsStdString(nodeElem, "name");
 
-        LOG_DEBUG(Logger::RULES,
+        LOG_DEBUG(Logger::SCRIPT,
             "Processing entity node "
                 + entName);
 
         if (!hasAttribute(nodeElem, "meshfile"))
         {
-            LOG_ERROR(Logger::RULES, "Entity node defines no meshfile attribute");
+            LOG_ERROR(Logger::SCRIPT, "Entity node defines no meshfile attribute");
             return false;
         }
 
@@ -73,7 +73,7 @@
         }
         else
         {
-            LOG_WARNING(Logger::RULES, "No position given for entity, used (0,0,0)");
+            LOG_WARNING(Logger::SCRIPT, "No position given for entity, used (0,0,0)");
         }
 
         DOMElement* oriElem = getChildNamed(nodeElem, "rotation");
@@ -83,7 +83,7 @@
         }
         else
         {
-            LOG_WARNING(Logger::RULES, "No orientation given for entity, used Identity");
+            LOG_WARNING(Logger::SCRIPT, "No orientation given for entity, used Identity");
         }
 
         ///@todo static geometry groups
@@ -108,11 +108,11 @@
             newEnt = CoreSubsystem::getSingleton().getWorld()
                         ->getSceneManager()->createEntity(entName, meshFile);
 
-            LOG_DEBUG(Logger::RULES, " Loaded meshfile "+meshFile);
+            LOG_DEBUG(Logger::SCRIPT, " Loaded meshfile "+meshFile);
         }
         catch(...)
         {
-	        LOG_ERROR(Logger::RULES, " Entity '"+meshFile+"' mit dem Namen '"+entName+"' konnte nicht geladen werden.");
+	        LOG_ERROR(Logger::SCRIPT, " Entity '"+meshFile+"' mit dem Namen '"+entName+"' konnte nicht geladen werden.");
             return false;
         }
 
@@ -141,6 +141,62 @@
 
     void EntityNodeProcessor::createCollision(Entity* entity, Ogre::String meshName, DOMElement* physicsProxyElem)
 	{
+        Ogre::String physicsProxyTypeAsString;
+        if (physicsProxyElem == NULL || !hasAttribute(physicsProxyElem, "type"))
+        {
+            physicsProxyTypeAsString = "auto";
+        }
+        else
+        {
+            physicsProxyTypeAsString = getAttributeValueAsStdString(physicsProxyElem, "type");
+        }
+
+
+
+        if (physicsProxyTypeAsString == "custom")
+        {
+            ///@todo create physics proxy from custom collision primitives which are defined in children elements of <code>physicsProxyElem<code>
+        }
+        else if (physicsProxyTypeAsString == "none")
+        {
+            LOG_DEBUG(Logger::SCRIPT, "No physics proxy for entity '"+entity->getName()+"'.");
+        }
+        else
+        {
+            GeometryType physicsProxyType = PhysicsManager::getSingleton().convertStringToGeometryType(physicsProxyTypeAsString);
+            if( physicsProxyType == GT_NONE )
+            {
+                // auto -> mesh
+                if (physicsProxyTypeAsString == "auto")
+                    physicsProxyType = GT_MESH;
+                
+                if (physicsProxyTypeAsString == "custom")
+                {
+                    ///@todo create physics proxy from custom collision primitives which are defined in children elements of <code>physicsProxyElem<code>
+                    LOG_WARNING(Logger::SCRIPT, "Physics proxy type 'custom' is not yet implemented.");
+                }
+                else if ( physicsProxyType != GT_NONE )
+                {
+                    OgreNewt::CollisionPtr collision = PhysicsManager::getSingleton().createCollision(entity, physicsProxyType);
+                    if (collision)
+                    {
+                        LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type '" + physicsProxyTypeAsString + "' for entity '"+entity->getName()+"'.");
+                        std::vector<OgreNewt::CollisionPtr> collisionVector;
+                        collisionVector.push_back(collision);
+                        PhysicsManager::getSingleton().addLevelGeometry(entity, collisionVector);
+                    }
+                }
+                else
+                {
+                    LOG_ERROR(Logger::SCRIPT,
+                            "Physics proxy type '" + physicsProxyTypeAsString + "' of entity '"+entity->getName()+"' is unknown.");
+                    return;
+                }
+            }
+
+                
+        }
+/*
         std::vector<OgreNewt::CollisionPtr> collisions;
 
         Ogre::String physicsProxyType;
@@ -164,7 +220,7 @@
         }
         else if (physicsProxyType == "none")
         {
-            LOG_DEBUG(Logger::RULES, "No physics proxy for entity '"+entity->getName()+"'.");
+            LOG_DEBUG(Logger::SCRIPT, "No physics proxy for entity '"+entity->getName()+"'.");
         }
         else
         {
@@ -185,7 +241,7 @@
                 if (size.z < PhysicsManager::NEWTON_GRID_WIDTH)
                     size.z = PhysicsManager::NEWTON_GRID_WIDTH;
 
-                LOG_MESSAGE(Logger::RULES, "Entity '"+entity->getName()+"' is planar, using 'box' as instead of '"+physicsProxyType+"'.");
+                LOG_MESSAGE(Logger::SCRIPT, "Entity '"+entity->getName()+"' is planar, using 'box' as instead of '"+physicsProxyType+"'.");
                 forceBox = true;
             }
             const Quaternion orientation(0,0,0,0);// = parentNode->getOrientation();
@@ -199,7 +255,7 @@
                 (!forceBox)) // sicherheitshalber
             {
                 collision = aucol.ColPtr;
-                LOG_DEBUG(Logger::RULES, " Reused physical body for entity '"+entity->getName()+"'.");
+                LOG_DEBUG(Logger::SCRIPT, " Reused physical body for entity '"+entity->getName()+"'.");
             }
             else
             {
@@ -207,13 +263,13 @@
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
                                      thisWorld, size, orientation, pos));
-                    LOG_DEBUG(Logger::RULES, "Created physics proxy type 'box' for entity '"+entity->getName()+"'.");
+                    LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type 'box' for entity '"+entity->getName()+"'.");
                 }
                 else if (physicsProxyType == "pyramid")
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Pyramid(
                                     thisWorld, size, orientation, pos));
-                    LOG_DEBUG(Logger::RULES, "Created physics proxy type 'pyramid' for entity '"+entity->getName()+"'.");
+                    LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type 'pyramid' for entity '"+entity->getName()+"'.");
                 }
                 else if (physicsProxyType == "sphere")
                 {
@@ -221,7 +277,7 @@
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
                                     thisWorld, Vector3(radius, radius, radius),
                                     orientation, pos));
-                    LOG_DEBUG(Logger::RULES, "Created physics proxy type 'sphere' for entity '"+entity->getName()+"'.");
+                    LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type 'sphere' for entity '"+entity->getName()+"'.");
                 }
                 else if (physicsProxyType == "ellipsoid")
                 {
@@ -232,7 +288,7 @@
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
                                     thisWorld, s,
                                     orientation, pos));
-                    LOG_DEBUG(Logger::RULES, "Created physics proxy type 'ellipsoid' for entity '"+entity->getName()+"'.");
+                    LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type 'ellipsoid' for entity '"+entity->getName()+"'.");
                 }
                 else if (physicsProxyType == "capsule")
                 {
@@ -244,24 +300,24 @@
                                     radius,
                                     height,
                                     orientation, pos));
-                    LOG_DEBUG(Logger::RULES, "Created physics proxy type 'capsule' for entity '"+entity->getName()+"'.");
+                    LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type 'capsule' for entity '"+entity->getName()+"'.");
                 }
                 else if (physicsProxyType == "convexhull")
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
                                     thisWorld,
                                     entity));
-                    LOG_DEBUG(Logger::RULES, "Created physics proxy type 'convexhull' for entity '"+entity->getName()+"'.");
+                    LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type 'convexhull' for entity '"+entity->getName()+"'.");
                 }
                 else if (physicsProxyType == "mesh" || physicsProxyType == "auto")
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
                                     thisWorld, entity, true));
-                    LOG_DEBUG(Logger::RULES, "Created physics proxy type 'mesh' for entity '"+entity->getName()+"'.");
+                    LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type 'mesh' for entity '"+entity->getName()+"'.");
                 }
                 else
                 {
-                    LOG_ERROR(Logger::RULES,
+                    LOG_ERROR(Logger::SCRIPT,
                         "Physics proxy type '"+physicsProxyType+"' of entity '"+entity->getName()+"' is unknown.");
                     return;
                 }
@@ -282,9 +338,10 @@
         if (collisions.size() > 0)
         {
             PhysicsManager::getSingleton().addLevelGeometry(entity, collisions);
-            LOG_DEBUG(Logger::RULES, " Entity '"+entity->getName()+"' in levelGeometry geladen");
+            LOG_DEBUG(Logger::SCRIPT, " Entity '"+entity->getName()+"' in levelGeometry geladen");
         }
-	}
+*/
+    }
 
 	void EntityNodeProcessor::processAnimation(Ogre::Entity* entity, DOMElement *animationElem)
 	{

Modified: rl/branches/persistence2/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/branches/persistence2/engine/script/src/PlaneNodeProcessor.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/script/src/PlaneNodeProcessor.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -148,7 +148,8 @@
 			const Quaternion orientation(0,0,0,0);// = parentNode->getOrientation();
 			const Ogre::Vector3 pos = aab.getMinimum() * parentNode->getScale() + (size/2.0);
 
-			collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(world, size, orientation, pos));
+			//collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(world, size, orientation, pos));
+            collision = PhysicsManager::getSingleton().createCollision(entity, GT_BOX, "", NULL, NULL, 0, NULL, NULL, true);
 
 			if ( collision != NULL )
 			{

Modified: rl/branches/persistence2/engine/ui/include/MovementControlState.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/MovementControlState.h	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/ui/include/MovementControlState.h	2009-04-11 10:34:44 UTC (rev 4893)
@@ -126,7 +126,7 @@
 
         PhysicsMaterialRaycast* mRaycast;
         PhysicsMaterialConvexcast * mConvexcast;
-        OgreNewt::Collision *mCameraCastCollision;
+        OgreNewt::ConvexCollisionPtr mCameraCastCollision;
         HalfSphereSelector mSelector;
         HalfSphereSelector mCombatSelector;
 

Modified: rl/branches/persistence2/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/CombatControlState.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/ui/src/CombatControlState.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -110,7 +110,6 @@
         PhysicsManager::getSingleton().getMaterialID("camera"));
         mCameraActor->getPhysicalThing()->unfreeze();
         mCameraActor->getPhysicalThing()->setPhysicsController(this);
-        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
         
         // We also handle cam<->level, cam<->default cam<->char collision from now on
         OgreNewt::MaterialPair* mat_pair = NULL;

Modified: rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -63,11 +63,12 @@
     void FreeflightControlState::pause()
     {
 		mCameraActor->getPhysicalThing()->freeze();
-		//mCharacterActor->getPhysicalThing()->unfreeze();
+		mCharacterActor->getPhysicalThing()->unfreeze();
+
+// for testing the OgreNewt player controller
 //        delete mOgreNewtPlayerController;
 
         mOgreNewtPlayerController = NULL;
-        mCharacterActor->getPhysicalThing()->setUpConstraint();
         mCameraActor->getPhysicalThing()->setPhysicsController(NULL);
 
         // Char<->Level collision back to default
@@ -86,8 +87,9 @@
     void FreeflightControlState::resume()
     {
         mCameraActor->getPhysicalThing()->unfreeze();
-		//mCharacterActor->getPhysicalThing()->freeze();
-        mCharacterActor->getPhysicalThing()->clearUpConstraint();
+		mCharacterActor->getPhysicalThing()->freeze();
+
+// for testing the OgreNewt player controller
 //        mOgreNewtPlayerController = new OgreNewt::PlayerController(mCharBody);
 
         resetCamera();
@@ -352,8 +354,11 @@
             Vector3 currentVel = body->getVelocity();
             Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep();
             Vector3 force = mass*(orientation * mDesiredVelocity - currentVel) / delay;
-if( mCollisionsEnabled )
-    force = mass*(- currentVel) / delay;
+
+// for testing the OgreNewt player controller
+//if( mCollisionsEnabled )
+//    force = mass*(- currentVel) / delay;
+
             body->setForce(force);
         }
     }

Modified: rl/branches/persistence2/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/MovementControlState.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/ui/src/MovementControlState.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -87,7 +87,9 @@
         mViewMode(VM_THIRD_PERSON),
         mRaycast(new PhysicsMaterialRaycast()),
         mConvexcast(new PhysicsMaterialConvexcast()),
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
         mCameraCastCollision(NULL),
+#endif
         mSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager()),
         mCombatSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
             QUERYFLAG_CREATURE),
@@ -158,7 +160,7 @@
             }
         }
         //! TODO: remove this workaround (newton-bug: "spheres don't cast"!)
-        mCameraCastCollision = new OgreNewt::CollisionPrimitives::ConvexHull(mCamBody->getWorld(), verts, 80);
+        mCameraCastCollision = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(mCamBody->getWorld(), verts, 80));
         //mCameraCastCollision = new OgreNewt::CollisionPrimitives::Ellipsoid(mCamBody->getWorld(), Vector3::UNIT_SCALE * camRadius);
     }
 
@@ -171,7 +173,9 @@
         mSelector.setFilter(NULL);
         delete mRaycast;
         delete mConvexcast;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
         delete mCameraCastCollision;
+#endif
 
         if (DebugWindow::getSingletonPtr())
         {
@@ -240,7 +244,6 @@
             PhysicsManager::getSingleton().getMaterialID("camera"));
         mCameraActor->getPhysicalThing()->unfreeze();
         mCameraActor->getPhysicalThing()->setPhysicsController(this);
-        mCameraActor->getPhysicalThing()->setUpConstraint(Vector3::ZERO);
 
         // We also handle cam<->level, cam<->default cam<->char collision from now on
         OgreNewt::MaterialPair* mat_pair = NULL;



From timm at mail.berlios.de  Sat Apr 11 12:36:33 2009
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sat, 11 Apr 2009 12:36:33 +0200
Subject: [Dsa-hl-svn] r4894 - rl/branches/persistence2/engine/common/src
Message-ID: <200904111036.n3BAaXsW008993@sheep.berlios.de>

Author: timm
Date: 2009-04-11 12:36:25 +0200 (Sat, 11 Apr 2009)
New Revision: 4894

Modified:
   rl/branches/persistence2/engine/common/src/XmlResource.cpp
Log:
- little dirty workaround: fixing crash when loading a xml resource a second time

Modified: rl/branches/persistence2/engine/common/src/XmlResource.cpp
===================================================================
--- rl/branches/persistence2/engine/common/src/XmlResource.cpp	2009-04-11 10:34:44 UTC (rev 4893)
+++ rl/branches/persistence2/engine/common/src/XmlResource.cpp	2009-04-11 10:36:25 UTC (rev 4894)
@@ -32,11 +32,17 @@
 	mCharBuffer(NULL),
 	mXmlBuffer(NULL)
 {
+#ifdef _DEBUG
+    LOG_MESSAGE(Logger::COMMON, "XML Resource " + mName + " loaded!");
+#endif
 }
 
 
 XmlResource::~XmlResource()
 {
+#ifdef _DEBUG
+    LOG_MESSAGE(Logger::COMMON, "XML Resource " + mName + " unloaded!");
+#endif
 	unload();
 }
 
@@ -47,10 +53,6 @@
 	
 	mCharBuffer = new XMLByte[mSize];
 	ds->read(mCharBuffer, mSize);
-
-	mXmlBuffer = new MemBufInputSource(
-        mCharBuffer,
-	    static_cast<const unsigned int>(mSize), "rl::XmlResourceManager");
 }
 
 void XmlResource::unloadImpl()
@@ -80,11 +82,17 @@
         parser->setErrorHandler(errorHandler);
     }
 
+    mXmlBuffer = new MemBufInputSource(
+        mCharBuffer,
+        static_cast<const unsigned int>(mSize), ((Ogre::String)("rl::XmlResourceManager " + mName)).c_str());
+
     parser->parse(*mXmlBuffer);
     if(parser->getErrorCount() > 0)
     {
+        delete mXmlBuffer;
         return false;
     }
+    delete mXmlBuffer;
     return true;
 }
 



From fusion2 at mail.berlios.de  Sun Apr 12 21:49:48 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Sun, 12 Apr 2009 21:49:48 +0200
Subject: [Dsa-hl-svn] r4895 - rl/trunk/editors/Lockenwickler/src
Message-ID: <200904121949.n3CJnm2Y015262@sheep.berlios.de>

Author: fusion2
Date: 2009-04-12 21:49:46 +0200 (Sun, 12 Apr 2009)
New Revision: 4895

Modified:
   rl/trunk/editors/Lockenwickler/src/GameObjectClass.py
   rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
Log:
- bugfix

Modified: rl/trunk/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2009-04-11 10:36:25 UTC (rev 4894)
+++ rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2009-04-12 19:49:46 UTC (rev 4895)
@@ -151,7 +151,7 @@
                 rep.data = str(self.editor.dataEditBox.text())
             
             if rep.name in self.propertieDict:
-                reply = QMessageBox.question(QApplication.focusWidget(), "Warning", "Replace the existing property?" , QMessageBox.Yes|QMessageBox.No|QMessageBox.Cancel)
+                reply = QMessageBox.question(QApplication.focusWidget(), "Warning...", "Replace the existing property?" , QMessageBox.Yes|QMessageBox.No|QMessageBox.Cancel)
                 if reply == QMessageBox.Cancel:
                     return
                 elif reply == QMessageBox.Yes:

Modified: rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-11 10:36:25 UTC (rev 4894)
+++ rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-12 19:49:46 UTC (rev 4895)
@@ -280,7 +280,7 @@
         #end remove all the things from the list we actually don't want to be selected
         for item in selItems:
             if str(item.text(0)).startswith("Scene: ") or str(item.text(0)).startswith("Map: ") or str(item.text(0)).startswith("Zone: "):
-                items.remove(item)
+                selItems.remove(item)
         
         for item in selItems:
             parentName =  str(item.text(0))



From melven at mail.berlios.de  Tue Apr 14 02:07:49 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 14 Apr 2009 02:07:49 +0200
Subject: [Dsa-hl-svn] r4896 - in rl/trunk/engine: ai/include ai/src core
	core/include core/src rules/src script/include script/src
	script/swig ui/include ui/src
Message-ID: <200904140007.n3E07mNY014864@sheep.berlios.de>

Author: melven
Date: 2009-04-14 02:07:38 +0200 (Tue, 14 Apr 2009)
New Revision: 4896

Added:
   rl/trunk/engine/core/include/GenericWorld.h
   rl/trunk/engine/core/src/GenericWorld.cpp
Removed:
   rl/trunk/engine/core/include/DotSceneLoader.h
   rl/trunk/engine/core/include/DotSceneOctreeWorld.h
   rl/trunk/engine/core/src/DotSceneLoader.cpp
   rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp
Modified:
   rl/trunk/engine/ai/include/AiSubsystem.h
   rl/trunk/engine/ai/src/AiSubsystem.cpp
   rl/trunk/engine/core/CMakeLists.txt
   rl/trunk/engine/core/include/CoreSubsystem.h
   rl/trunk/engine/core/include/PhysicsManager.h
   rl/trunk/engine/core/include/World.h
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/core/src/GameAreaTypes.cpp
   rl/trunk/engine/core/src/GameEventManager.cpp
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/trunk/engine/core/src/SceneQuery.cpp
   rl/trunk/engine/rules/src/CreatureControllerManager.cpp
   rl/trunk/engine/rules/src/SelectionHelper.cpp
   rl/trunk/engine/script/include/EntityNodeProcessor.h
   rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/engine/ui/include/UiSubsystem.h
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
VC project files need to be updated!
- removed DotSceneLoader and related stuff (moved DotSceneOctreeWorld to GenericWorld (it creates a world with SceneType 'generic'))
- fixed some bugs when using OGRENEWT_USE_OGRE_ANY
- reorganized the collision-creation a bit (all real work is done in the CollisionsFactory (also the caching will be done there)) in order
  to simplify the code, caching of collisions still not implemented


Modified: rl/trunk/engine/ai/include/AiSubsystem.h
===================================================================
--- rl/trunk/engine/ai/include/AiSubsystem.h	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/ai/include/AiSubsystem.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -20,7 +20,6 @@
 #include "AiPrerequisites.h"
 
 #include "MessagePump.h"
-#include "World.h"
 
 namespace rl
 {

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -24,9 +24,7 @@
 #include "GameLoop.h"
 #include "Landmark.h"
 #include "LandmarkPath.h"
-#include "Logger.h"
 #include "WayPointGraphManager.h"
-#include "World.h"
 
 #include <xercesc/util/PlatformUtils.hpp>
 

Modified: rl/trunk/engine/core/CMakeLists.txt
===================================================================
--- rl/trunk/engine/core/CMakeLists.txt	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/CMakeLists.txt	2009-04-14 00:07:38 UTC (rev 4896)
@@ -25,8 +25,6 @@
 src/CoreSubsystem.cpp
 src/DebugVisualisable.cpp
 src/DebugVisualsManager.cpp
-src/DotSceneLoader.cpp
-src/DotSceneOctreeWorld.cpp
 src/FadeAnimation.cpp
 src/GameAreaEvent.cpp
 src/GameAreaEventSource.cpp
@@ -34,6 +32,7 @@
 src/GameAreaTypes.cpp
 src/GameEventManager.cpp
 src/GameLoop.cpp
+src/GenericWorld.cpp
 src/Job.cpp
 src/JobQueue.cpp
 src/JobScheduler.cpp

Modified: rl/trunk/engine/core/include/CoreSubsystem.h
===================================================================
--- rl/trunk/engine/core/include/CoreSubsystem.h	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/include/CoreSubsystem.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -23,6 +23,7 @@
 #include "EventSource.h"
 #include "EventCaster.h"
 #include "CorePrerequisites.h"
+#include "World.h"
 
 namespace rl {
 
@@ -69,9 +70,10 @@
     void renderOneFrame(bool executeTasks = true);
 
     World* getWorld();
-    void loadMap(const Ogre::String& type, const Ogre::String& filename,
-        const Ogre::String& module);
 
+    // obsolete
+    // void loadMap(const Ogre::String& type, const Ogre::String& filename, const Ogre::String& module);
+
     RubyInterpreter* getRubyInterpreter();
 
     ContentModule* getActiveAdventureModule() const;

Deleted: rl/trunk/engine/core/include/DotSceneLoader.h
===================================================================
--- rl/trunk/engine/core/include/DotSceneLoader.h	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/include/DotSceneLoader.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -1,160 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __DotSceneLoader_H__
-#define __DotSceneLoader_H__
-
-#include "CorePrerequisites.h"
-
-#ifdef __APPLE__
-#   include <OgreNewt/OgreNewt.h>
-#else
-#   include <OgreNewt.h>
-#endif
-
-#include <string>
-#include <map>
-
-#include "XmlResourceManager.h"
-#include "XmlPropertyReader.h"
-
-namespace Ogre {
-	class SceneNode;
-}
-
-namespace XERCES_CPP_NAMESPACE {
-	class DOMElement;
-}
-
-namespace rl {
-
-	/** Diese Klasse parst eine .scene.xml Datei.
-	 *  
-	 *  Zur Zeit sind folgenende Dinge (partiell) unterst?tzt 
-	 *   - Nodes ( Name, Hierarchie + Platzierung + Skalierung + Rotation )
-	 *   - Entities ( Name, TriMeshPhysik )
-	 */
-    class DotSceneLoader : private XmlPropertyReader
-	{
-	public:
-		/// Erstellt einen Dotscene Loader, der das gew?nschte File einliest
-        DotSceneLoader(const std::string& filename, const std::string& resourceGroup);
-		/// Standard Destruktor
-		virtual ~DotSceneLoader();
-
-		/// Laden der Szene
-		void initializeScene(Ogre::SceneManager* sceneManager);
-
-	private:
-        struct NodeUserData
-        {
-            std::string physical_body;
-			Ogre::Real renderingdistance;
-			int staticgeom_group;
-            bool is_dynamic;
-			bool is_inheriting;
-			OgreNewt::CollisionPtr collision;
-        };
-
-		// wird verwendet um einen Zeiger auf eine vorherige identische
-        // Collision zu erhalten
-        struct AlreadyUsedCollision
-        {
-        public:
-            std::string Type;
-            Ogre::Vector3 Scale;
-            OgreNewt::CollisionPtr ColPtr;
-        };
-
-
-		/// Geht alle Nodes in der .scene durch
-		void processNodes(XERCES_CPP_NAMESPACE::DOMElement* rootNodesXml, 
-			Ogre::SceneManager* sceneManager,
-			Ogre::SceneNode* parentNode );
-		/// Node und alle Unterelemente
-		void processNode(XERCES_CPP_NAMESPACE::DOMElement* rootNodeXml, 
-			Ogre::SceneManager* sceneManager,
-			Ogre::SceneNode* parentNode, NodeUserData* parentUserData );
-		/// Eine Entity+Attribute
-		void processEntity( XERCES_CPP_NAMESPACE::DOMElement* rootEntityXml, 
-			Ogre::SceneManager* sceneManager, Ogre::SceneNode* parentNode, 
-			Ogre::Real renderingDistance, const std::string &bodyproxy_type );
-        /// Ein benutzerdefinierter Bereich im Node
-        void processNodeUserData( XERCES_CPP_NAMESPACE::DOMElement* rootUserDataXml, 
-			NodeUserData* userData );
-		/// Ein benutzerdefinierter Bereich in der Szene
-		void processSceneUserData( XERCES_CPP_NAMESPACE::DOMElement* rootUserDataXml );
-
-		/** Liest einen Vector aus einem XML Element, ?ber die Attribute x, y, z
-		 *  Sollten die Attribute nicht korrekt definiert sein, gibt es Vector::ZERO zur?ck (0,0,0)
-		 */
-		Ogre::Vector3 processPosition( XERCES_CPP_NAMESPACE::DOMElement* rootPositionXml );
-
-		/** Liest einen Vector aus einem XML Element, ?ber die Attribute x, y, z
-		*  Sollten die Attribute nicht korrekt definiert sein, gibt es Vector::UNIT_SCALE zur?ck (1,1,1)
-		*/
-		Ogre::Vector3 processScale( XERCES_CPP_NAMESPACE::DOMElement* rootPositionXml );
-		/** Liest einen Vector aus einem XML Element, ?ber die Attribute x, y, z
-		*  Sollten die Attribute nicht korrekt definiert sein, wird error auf true gesetzt.
-		*/
-		Ogre::Vector3 processVector( XERCES_CPP_NAMESPACE::DOMElement* rootPositionXml, bool &error );
-		/** Liest ein Quaternion aus einem XML Element, 
-		*  ?ber die Attribute qw, qx, qy, qz  ODER angle, axisX, axisY, axisZ
-		*  Sollten die Attribute nicht korrekt definiert sein, gibt es Quaternion::IDENTITY zur?ck (1,0,0,0)
-		*/
-		Ogre::Quaternion processRotation( XERCES_CPP_NAMESPACE::DOMElement* rootQuatXml );
-		/** Liest eine Liste von ein bis mehreren Bodyproxies (Collisions)
-		* SceneUserData ein.
-		* Sollten die Attribute falsch gesetzt sein, gibt es NULL zur?ck; Dadurch wird keine Collision verwendet
-		*/
-		void processCollisions( XERCES_CPP_NAMESPACE::DOMElement* rootCollisionXml );
-
-        std::string getRandomName(const std::string& baseName);
-        /// Builds a string from a xerces exception
-        std::string toString( const std::string& type, const XERCES_CPP_NAMESPACE::SAXParseException& exc ) const;
-
-		/// Der Node der Scene
-		Ogre::SceneNode* mSceneNode;
-		/// Alle statischen GeometrieNodes
-		std::map<int,Ogre::SceneNode*> mStaticNodes;
-
-		/// Alle bodyproxies, die schon automatisch erstellt worden sind
-		typedef std::map<const std::string,AlreadyUsedCollision>
-			USEDCOLLISIONSMAP;
-		USEDCOLLISIONSMAP mAutoCreatedCollisions;
-        std::vector<OgreNewt::CollisionPtr> mCollisions;
-
-		Ogre::Real mRenderingDistance;
-		std::map<int,Ogre::Real> mStaticgeomRenderingDistances;
-		std::map<int,Ogre::Real> mStaticgeomBatchSizes;
-		
-		/// Der Name der Scene
-		const std::string mSceneName;
-        /// ResourceGroup der dotscene-Resource
-        const std::string mResourceGroup;
-
-        /// Have any errors occured
-        int mErrorCount;
-
-        /// The Ressource
-        XmlPtr mRessource;
-        // The Parser
-        XERCES_CPP_NAMESPACE::XercesDOMParser* mParser;
-	};
-
-}
-
-#endif

Deleted: rl/trunk/engine/core/include/DotSceneOctreeWorld.h
===================================================================
--- rl/trunk/engine/core/include/DotSceneOctreeWorld.h	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/include/DotSceneOctreeWorld.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -1,39 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __DotSceneOctreeWorld_H__
-#define __DotSceneOctreeWorld_H__
-
-#include "World.h"
-
-#include "CorePrerequisites.h"
-
-namespace rl {
-
-    class _RlCoreExport DotSceneOctreeWorld : public World
-    {
-    public:
-        DotSceneOctreeWorld();
-        ~DotSceneOctreeWorld();
-
-        virtual void clearScene();
-        virtual void initializeDefaultCamera();	
-		virtual void setCastShadows(bool enabled);
-        virtual void loadScene(const Ogre::String& levelName, const Ogre::String& module);
-    };
-
-}
-#endif

Copied: rl/trunk/engine/core/include/GenericWorld.h (from rev 4889, rl/trunk/engine/core/include/DotSceneOctreeWorld.h)
===================================================================
--- rl/trunk/engine/core/include/DotSceneOctreeWorld.h	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/core/include/GenericWorld.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -0,0 +1,38 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __GenericWorld_H__
+#define __GenericWorld_H__
+
+#include "World.h"
+
+#include "CorePrerequisites.h"
+
+namespace rl {
+
+    class _RlCoreExport GenericWorld : public World
+    {
+    public:
+        GenericWorld();
+        ~GenericWorld();
+
+        virtual void clearScene();
+        virtual void initializeDefaultCamera();	
+		virtual void setCastShadows(bool enabled);
+    };
+
+}
+#endif

Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -141,7 +141,7 @@
 		/// Komplette Levelgeometrie aufl?sen
 		void clearLevelGeometry();
 		
-	void toggleDebugMode();
+        void toggleDebugMode();
         int isDebugMode() const;
 
         // Newton callbacks ...
@@ -207,75 +207,30 @@
         void resetMaterialPair( const OgreNewt::MaterialID* M1,
             const OgreNewt::MaterialID* M2);
 
-        /** creates a collision primitive for OgreNewt.
-		 * The collision primitive created has got a basic orientation which can be influenced by
-		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
-		 * calculated according to the size and type of collision primitiv.
-         * Whenever any of the parameters is a null pointer, it is ignored.
-         * The created collision primitive gets cached for the given mesh,
-         * so whenever an other entity with the same mesh tries to fetch
-         * a collision primitive here, then it gets back the already existing
-         * one (no need to duplicate).
-		 * @param entity gives the mesh entity that needs a collision primitive
-         * @param geomType defines the geometry of the collision type
-         * @param offset Vector3 gives the offset of the coordinate system of the coll. primitiv
-		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
-         * @param mass gives the mass of the collision primitive used for calculating the inertia
-		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
-		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
-         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
-         *                the new collision is not added to the cache
-		*/
+        /// calls PhysicsCollisionFactory::createCollisionFromEntity
 		OgreNewt::CollisionPtr createCollision(
 			Ogre::Entity* entity,
             const GeometryType& geomType = GT_NONE,
-            const Ogre::String animName = "",
-			Ogre::Vector3* offset = NULL,
-			Ogre::Quaternion* orientation = NULL,
+            const Ogre::String& animName = "",
+			const Ogre::Vector3* offset = NULL,
+			const Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
             Ogre::Vector3* inertia = NULL,
             Ogre::Vector3* centerOfMass = NULL,
             bool nocache = false);
 
-        /** creates a collision primitive for OgreNewt.
-		 * The collision primitive created has got a basic orientation which can be influenced by
-		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
-		 * calculated according to the size and type of collision primitiv.
-         * Whenever any of the parameters is a null pointer, it is ignored.
-         * The created collision primitive gets cached for the given aabb,
-         * so whenever an other aabb with the same name tries to fetch
-         * a collision primitive here, then it gets back the already existing
-         * one (no need to duplicate).
-		 * @param aabb AxisAlignedBox that contains the extents for the collision primitive to be created
-         * @param name gives the name of the AxisAlignedBox
-         * @param geomType defines the geometry of the collision type
-         * @param offset Vector3 gives the offset of the coordinate system of the coll. primitiv
-		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
-         * @param mass gives the mass of the collision primitive used for calculating the inertia
-		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
-		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
-         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
-         *                the new collision is not added to the cache
-		*/
+        /// calls PhysicsCollisionFactory::createCollisionFromAABB
         OgreNewt::CollisionPtr createCollision(
             const Ogre::String& name,
             const Ogre::AxisAlignedBox& aabb,
             const GeometryType& geomType = GT_NONE,
-            Ogre::Vector3* offset = NULL,
-			Ogre::Quaternion* orientation = NULL,
+            const Ogre::Vector3* offset = NULL,
+			const Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
             Ogre::Vector3* inertia = NULL,
             Ogre::Vector3* centerOfMass = NULL,
             bool nocache = false);
 
-        /** Makes the collision primitive generation available to non mesh objects.
-         * Non mesh objects need collision objects too. Therefore they can
-         * utilise this function for bypassing the caching mechanism of
-         * PhysicalManager.
-         * @returns a collision primitive creating factory object.
-         */
-        PhysicsCollisionFactory* getCollisionFactory();
-
         /** converts a string identifying a collision property into an enum.
          * Mainly for making string definitions of the collision property
          * possible in .gof files.
@@ -294,30 +249,6 @@
         OgreNewt::Debugger* getNewtonDebugger() {return &mWorld->getDebugger();}
 
     private:
-
-        /** structure containing further information about the collision primitive.
-         * Actually this information should go into either the collisionptr or the
-         * object for the primitive ...
-         */
-        struct CollisionInUse
-        {
-        public:
-            CollisionInUse() :
-#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
-                colPtr(NULL),
-#endif
-                geomType(GT_NONE) {}
-            GeometryType geomType;  //! primitive type
-            OgreNewt::CollisionPtr colPtr;          //! the collision primitve
-        };
-
-        /** shortens definition of a list of collision primitives.
-         * currently only one geometry type per entity (mesh) is allowed.
-         * if multiple should be possible, the geometry type should be
-         * moved from the above struct into the key.
-         */
-        typedef std::map< std::string, CollisionInUse > CollisionMap;
-
         bool mEnabled;
         //! the globally used physical representation of the world by Newton
         OgreNewt::World* mWorld;
@@ -326,8 +257,6 @@
 
         //! factory for creating new collision primitives
         PhysicsCollisionFactory* mPhysicsCollisionFactory;
-        //! a list of collision primitives
-        CollisionMap mCollisionPrimitives;
 
         //! a list of objects of the physical world
         std::vector<PhysicalThing*> mPhysicalThings;
@@ -391,139 +320,248 @@
     class PhysicsCollisionFactory
     {
     public:
-        /** checks if the specified size is ok for OgreNewt
-         * @param aabb check the aabb's size
-         */
-        bool checkSize(const Ogre::AxisAlignedBox& aabb) const;
-        /** corrects the specified size if it is not ok for OgreNewt
-         * @param aabb correct the aabb's size
-         */
-        void correctSize(Ogre::AxisAlignedBox& aabb);
-        /** calculates the Inertia for the given primitive type
-         */
-        //Ogre::Vector3 calculateIntertia(const Ogre::Real& Mass, Ogre::Vector3* inertiaCoefficients);
+        //! destructor, releases the collisions from the collision cache
+        ~PhysicsCollisionFactory();
 
-        /** creates a collision primitive for OgreNewt an Ogre::Entity.
+        /** creates a collision primitive for OgreNewt from an Ogre::Entity.
 		 * The collision primitive created has got a basic orientation which can be influenced by
-		 * offset and orientation parameters.
+		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
+		 * calculated according to the size and type of collision primitiv.
          * Whenever any of the parameters is a null pointer, it is ignored.
+         * The created collision primitive gets cached for the given mesh,
+         * so whenever an other entity with the same mesh tries to fetch
+         * a collision primitive here, then it gets back the already existing
+         * one (no need to duplicate).
+         * 
          * Scaling should be implemented through attaching to a scene node.
          * if that is not the case, we'll have to fix OgreNewt ...
-		 * @param entity Ogre::Entity mesh object
+		 * @param entity gives the mesh entity that needs a collision primitive
 		 * @param geomType specifies the type of collision primitiv to create.
 		 * @param offset gives the offset of the coordinate system of the coll. primitiv
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
 		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
+         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
+         *                the new collision is not added to the cache
 		*/
-        OgreNewt::CollisionPtr createCollisionFromEntity(Ogre::Entity* entity,
+        OgreNewt::CollisionPtr createCollisionFromEntity(
+            Ogre::Entity* entity,
             const GeometryType& geomType,
-            Ogre::Vector3* offset = NULL, 
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real Mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation,
+            const Ogre::Real Mass,
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass,
+            bool nocache);
 
-        /** creates a collision primitive for OgreNewt from an AABB box.
+        /** creates a collision primitive for OgreNewt.
 		 * The collision primitive created has got a basic orientation which can be influenced by
-		 * offset and orientation parameters.
+		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
+		 * calculated according to the size and type of collision primitiv.
          * Whenever any of the parameters is a null pointer, it is ignored.
+         * The created collision primitive gets cached for the given aabb,
+         * so whenever an other aabb with the same name tries to fetch
+         * a collision primitive here, then it gets back the already existing
+         * one (no need to duplicate). There's no difference between Collisions created through an aabb or through
+         * the entity in the cache. In order to supply a support for 'scaling' the size of the cached collision is
+         * checked.
          * Since no entity is given several physical collision primitives are not
          * possible (convexhull, tree, etc.)
-         * Scaling should be implemented through attaching to a scene node.
-         * if that is not the case, we'll have to fix OgreNewt ...
-		 * @param entity Ogre::Entity mesh object
+         * // no scaling at the moment, the correct scale must be given (OgreNewt cannot scale a collision, this is a limitation
+         * // of newton. It is only possible to 'scale' a convex collision by created a ConvexHullModifier (a new collision,
+         * // that uses the old one and applies transformation through a matrix), so for aabbs (-> convex collisions) a scale
+         * // that udpates with the scale of the node could be implemented, but as this would be different for treecollisions,
+         * // it is better to create a collision with the correct scale...
+         * // "Scaling should be implemented through attaching to a scene node.
+         * // if that is not the case, we'll have to fix OgreNewt ..."
+         * @param name gives the name of the AxisAlignedBox
+		 * @param aabb AxisAlignedBox that contains the extents for the collision primitive to be created
 		 * @param geomType specifies the type of collision primitiv to create.
 		 * @param offset gives the offset of the coordinate system of the coll. primitiv
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
 		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
+         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
+         *                the new collision is not added to the cache
 		*/
-        OgreNewt::CollisionPtr createCollisionFromAABB(const Ogre::AxisAlignedBox aabb,
+        OgreNewt::CollisionPtr createCollisionFromAABB(
+            const Ogre::String& name,
+            const Ogre::AxisAlignedBox& aabb,
             const GeometryType& geomType,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real Mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation,
+            const Ogre::Real Mass,
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass,
+            bool nocache);
+
+        /// clear the collision cache
+        void clearCollisionCache();
+
     protected:
+        /** checks if the specified size is ok for OgreNewt
+         * @param aabb check the aabb's size
+         */
+        bool checkSize(const Ogre::AxisAlignedBox& aabb) const;
+
+        /** corrects the specified size if it is not ok for OgreNewt
+         * @param aabb correct the aabb's size
+         */
+        void correctSize(Ogre::AxisAlignedBox& aabb);
+
         /** creates a box collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
          * @param offset when not null, specifies a different offset than the standard.
          * @param orientation when not null, specifies the euler angle of orientation.
-         * @param mass gives the mass for inertia calculation.
-         * @param inertia when not null, an inertia is calculated and passed back.
-         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
-        OgreNewt::CollisionPtr createBox(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+        OgreNewt::ConvexCollisionPtr createBox(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
         /** creates a pyramid collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
          * @param offset when not null, specifies a different offset than the standard.
          * @param orientation when not null, specifies the euler angle of orientation.
-         * @param mass gives the mass for inertia calculation.
-         * @param inertia when not null, an inertia is calculated and passed back.
-         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
-        OgreNewt::CollisionPtr createPyramid(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+        OgreNewt::ConvexCollisionPtr createPyramid(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
         /** creates a sphere collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
          * @param offset when not null, specifies a different offset than the standard.
          * @param orientation when not null, specifies the euler angle of orientation.
-         * @param mass gives the mass for inertia calculation.
-         * @param inertia when not null, an inertia is calculated and passed back.
-         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
-        OgreNewt::CollisionPtr createSphere(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+        OgreNewt::ConvexCollisionPtr createSphere(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
         /** creates a ellipsoid collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
          * @param offset when not null, specifies a different offset than the standard.
          * @param orientation when not null, specifies the euler angle of orientation.
-         * @param mass gives the mass for inertia calculation.
-         * @param inertia when not null, an inertia is calculated and passed back.
-         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
-        OgreNewt::CollisionPtr createEllipsoid(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+        OgreNewt::ConvexCollisionPtr createEllipsoid(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
         /** creates a capsule collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
          * @param offset when not null, specifies a different offset than the standard.
          * @param orientation when not null, specifies the euler angle of orientation.
-         * @param mass gives the mass for inertia calculation.
-         * @param inertia when not null, an inertia is calculated and passed back.
-         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
-        OgreNewt::CollisionPtr createCapsule(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+        OgreNewt::ConvexCollisionPtr createCapsule(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
+        /** creates a convex-hull collision primitive with offset at middle of bottom layer.
+         * It's actually a convenience function used by createCollisionFromEntity
+         * @param entity the entity for which a convexhull should be created, if it is attached to
+         *               a node the scale of the node is used (see OgreNewt)
+         * @param offset when not null, specifies a different offset than the standard.
+         * @param orientation when not null, specifies the euler angle of orientation.
+         */
+        OgreNewt::ConvexCollisionPtr createConvexHull(
+            Ogre::Entity* entity,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
+
+        //! class for caching convex collisions (box...convexhull), saves additionally the scale, so it can be rescaled if necessary
+        class ConvexCollisionCacheObject
+        {
+            public:
+                ConvexCollisionCacheObject() :
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+                    col(NULL),
+#endif
+                    scale(Ogre::Vector3::ZERO),
+                    type(GT_NONE)
+                    {}
+                OgreNewt::ConvexCollisionPtr col;
+                Ogre::Vector3 scale;
+                GeometryType type;
+        };
+
+        typedef std::map<Ogre::String, ConvexCollisionCacheObject> ConvexCollisionCacheMap;
+
+        //! cache for convex collisions
+        ConvexCollisionCacheMap mConvexCollisionsCache;
+
+        //! for using a string and a vector as key in a map... we should implement here a hash-function
+        class StringVector
+        {
+            public:
+                StringVector(const Ogre::String& str, const Ogre::Vector3& vec) : mStr(str)
+                {
+                    setVector(vec);
+                }
+                void setString(const Ogre::String& str) {mStr = str;}
+                void setVector(const Ogre::Vector3& vec)
+                {
+                    mVec = vec;
+                }
+                const Ogre::String& getString() const {return mStr;}
+                const Ogre::Vector3& getVector() const {return mVec;}
+
+                bool operator==(const StringVector& strVec) const
+                {
+                    if( mStr != strVec.mStr )
+                        return false;
+
+                    Ogre::Vector3 diff = mVec - strVec.mVec;
+                    if( abs(diff.x) > 0.01 )
+                        return false;
+                    if( abs(diff.y) > 0.01 )
+                        return false;
+                    if( abs(diff.z) > 0.01 )
+                        return false;
+
+                    return true;
+                }
+
+                bool operator<(const StringVector& strVec) const
+                {
+                    int strCompare = mStr.compare(strVec.mStr);
+                    if( strCompare == 0 ) // strings are the same
+                    {
+                        // compare vectors
+                        Ogre::Vector3 diff = mVec - strVec.mVec;
+                        if( diff.x < -0.01 )
+                            return true;
+                        if( diff.x > 0.01 )
+                            return false;
+                        if( diff.y < -0.01 )
+                            return true;
+                        if( diff.y > 0.01 )
+                            return false;
+                        if( diff.y < -0.01 )
+                            return true;
+
+                        return false;
+                    }
+                    
+                    return strCompare < 0;
+                }
+            private:
+                Ogre::String mStr;
+                Ogre::Vector3 mVec;
+        };
+
+        typedef std::map<StringVector, OgreNewt::CollisionPtr> MeshCollisionCacheMap;
+
+        //! cache for mesh collisions
+        MeshCollisionCacheMap mMeshCollisionsCache;
+
+
+
     };
 }
 

Modified: rl/trunk/engine/core/include/World.h
===================================================================
--- rl/trunk/engine/core/include/World.h	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/include/World.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -42,9 +42,10 @@
         virtual Ogre::Vector3 getStartPoint() const;
 
         virtual void clearScene(void) = 0;
-        virtual void loadScene(const Ogre::String& levelName,
-            const Ogre::String& module) = 0;
 
+        // obsolete
+        //virtual void loadScene(const Ogre::String& levelName, const Ogre::String& module) = 0;
+
         //Enables / disables a 'sky plane' i.e.
         virtual void setSkyPlane(bool enable, const Ogre::Plane &plane,
             const Ogre::String &materialName,

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -26,7 +26,7 @@
 #include "ContentModule.h"
 #include "ConfigurationManager.h"
 #include "DebugVisualsManager.h"
-#include "DotSceneOctreeWorld.h"
+#include "GenericWorld.h"
 #include "Exception.h"
 #include "GameEventManager.h"
 #include "GameLoop.h"
@@ -280,7 +280,7 @@
                 "Video", "Max Anisotropy"));
 
 
-        mWorld = new DotSceneOctreeWorld();
+        mWorld = new GenericWorld();
         mActorManager->setWorld(mWorld);
 
         mPhysicsManager = new PhysicsManager();  // the World needs to be initialized before!
@@ -571,12 +571,15 @@
         return mModules;
     }
 
+    // obsolete
+/*
     void CoreSubsystem::loadMap(const Ogre::String& type, const Ogre::String& filename,
         const Ogre::String& module)
     {
         mWorld->loadScene(filename, module);
     }
-    
+*/  
+
     void CoreSubsystem::loadPlugin(const Ogre::String& plugin)
     {
         Ogre::String pluginFile;

Deleted: rl/trunk/engine/core/src/DotSceneLoader.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneLoader.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/src/DotSceneLoader.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -1,1095 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include <xercesc/dom/DOM.hpp>
-
-#include "DotSceneLoader.h"
-#include "World.h"
-
-#include "PhysicsManager.h"
-#include "ActorManager.h"
-#include "CoreSubsystem.h"
-#include "ConfigurationManager.h"
-
-#include "Property.h"
-
-#include "Exception.h"
-
-#include <cstdlib>
-#include <ctime>
-
-using namespace XERCES_CPP_NAMESPACE;
-using namespace std;
-using namespace Ogre;
-
-namespace rl {
-    using XERCES_CPP_NAMESPACE::DOMDocument;
-
-    DotSceneLoader::DotSceneLoader(const string& filename, const string& resourceGroup)
-        : mSceneName(filename),
-          mResourceGroup(resourceGroup),
-          mStaticNodes(),
-          mRenderingDistance(ActorManager::getSingleton().getDefaultActorRenderingDistance()),
-          mStaticgeomRenderingDistances(),
-          mStaticgeomBatchSizes(),
-          mRessource(NULL),
-          mParser(NULL),
-          mErrorCount(0)
-    {
-        srand(static_cast<unsigned int>(time(NULL)));
-    }
-
-    DotSceneLoader::~DotSceneLoader()
-    {
-        if (!mRessource.isNull() && mRessource->isLoaded())
-        {
-            XmlResourceManager::getSingleton().unload(mSceneName);
-            XmlResourceManager::getSingleton().remove(mRessource->getHandle());
-        }
-    }
-
-    void DotSceneLoader::initializeScene(SceneManager* sceneManager)
-    {
-        initializeXml();
-
-        LOG_MESSAGE(Logger::CORE, "Loading Scene from " + mSceneName);
-        DOMDocument* doc = loadDocument(mSceneName, mResourceGroup);
-
-        // Durch alle Unterelemente iterieren
-        DOMNode* child = doc->getDocumentElement()->getFirstChild();
-
-        while(child != NULL)
-        {
-            // Ein Node
-            if (XMLString::compareIString(child->getNodeName(), AutoXMLCh("userData").data()) == 0 )
-            {
-                processSceneUserData(static_cast<DOMElement*>(child));
-            }
-            child = child->getNextSibling();
-        }
-
-        LOG_DEBUG(Logger::CORE, " Beginne parsen der Unterelemente");
-        DOMElement* nodes = getChildNamed(doc->getDocumentElement(), "nodes");
-
-        // Eine .scene wird in einem SceneNode mit dem Namen der .scene befestigt
-        mSceneNode = sceneManager->getRootSceneNode()->createChildSceneNode(mSceneName);
-        processNodes(nodes, sceneManager, mSceneNode);
-
-        // Find out, if static geometry should be used
-        Ogre::String temp = ConfigurationManager::getSingleton().getStringSetting(
-            "Video", "Use Static Geometry");
-        bool useStaticGeometry;
-
-        if (temp == "yes")
-        {
-            useStaticGeometry = true;
-        }
-        else if (temp == "no")
-        {
-            useStaticGeometry = false;
-        }
-        else
-        {
-            // Check, if Renderer supports vertex buffer
-            useStaticGeometry = Ogre::Root::getSingleton().getRenderSystem()->getCapabilities()->hasCapability(Ogre::RSC_VBO);
-        }
-
-        if (useStaticGeometry)
-        {
-            for(std::map<int,Ogre::SceneNode*>::iterator it = mStaticNodes.begin();
-                it != mStaticNodes.end();)
-            {
-                Ogre::SceneNode* staticNode = it->second;
-                string staticName = Ogre::StringConverter::toString(it->first);
-                Ogre::Real renderDist = mRenderingDistance;
-                Ogre::Real batchSize = 25.0;
-
-                if (mStaticgeomRenderingDistances.find(it->first) != mStaticgeomRenderingDistances.end())
-                    renderDist = mStaticgeomRenderingDistances[it->first];
-                if (mStaticgeomBatchSizes.find(it->first) != mStaticgeomBatchSizes.end())
-                    batchSize = mStaticgeomBatchSizes[it->first];
-
-                StaticGeometry* staticGeom = sceneManager->createStaticGeometry(mSceneName + staticName );
-
-                staticGeom->setRenderingDistance(renderDist);
-                staticGeom->addSceneNode(staticNode);
-                staticGeom->setRegionDimensions(batchSize * Vector3::UNIT_SCALE);
-                // Statische Geometrie bauen
-                staticGeom->build();
-                // Nicht mehr den Original-Knoten rendern, da dieser noch erhalten ist.
-                staticNode->setVisible(false);
-                staticNode->removeAndDestroyAllChildren();
-                sceneManager->destroySceneNode(staticNode->getName());
-                staticNode = NULL;
-                LOG_DEBUG(Logger::CORE, " Statische Geometrie "+staticName+" erstellt");
-                ++it;
-            }
-        }
-        else
-            LOG_DEBUG(Logger::CORE, " Keine statischen Geometrien erstellt");
-
-        shutdownXml();
-        LOG_DEBUG(Logger::CORE, "Szenenbeschreibung aus " + mSceneName +" fertig geparst");
-    }
-
-    // Iteriert durch die einzelnen Nodes
-    void DotSceneLoader::processNodes(DOMElement* rootNodesXml, SceneManager* sceneManager,
-        Ogre::SceneNode* parentNode)
-    {
-        if (rootNodesXml == NULL)
-            return;
-        if (parentNode == NULL)
-            Throw(NullPointerException, "parentNode darf nicht null sein");
-
-
-        // Durch alle Unterelemente iterieren
-        DOMNode* child = rootNodesXml->getFirstChild();
-
-        while(child != NULL)
-        {
-            // Ein Node
-            if (XMLString::compareIString(child->getNodeName(), AutoXMLCh("node").data()) == 0 )
-            {
-                processNode(static_cast<DOMElement*>(child), sceneManager, parentNode, NULL);
-            }
-            child = child->getNextSibling();
-        }
-    }
-
-    // Befasst sich mit einem Node
-    void DotSceneLoader::processNode(DOMElement* rootNodeXml, SceneManager* sceneManager, Ogre::SceneNode* parentNode, NodeUserData* parentUserData)
-    {
-        if (rootNodeXml == NULL)
-            return;
-        if (parentNode == NULL)
-            Throw(NullPointerException, "parentNode darf nicht null sein");
-
-        string nodeName = getAttributeValueAsStdString(rootNodeXml,
-                        "name");
-
-        Ogre::SceneNode* newNode;
-        // Wurde dem Node ein Name zugewiesen?
-        if (nodeName.length() > 0)
-        {
-            if (!parentNode->getCreator()->hasSceneNode(nodeName))
-            {
-                // Dann versuche einen Knoten mit dem Namen zu erstellen
-                newNode = parentNode->createChildSceneNode(nodeName);
-            }
-            else
-            {
-                // Name schon vergeben
-                newNode = parentNode->createChildSceneNode();
-                LOG_DEBUG(Logger::CORE,
-                    " NodeName '"+nodeName+"' war schon vergeben! Es wurde der Name '"+newNode->getName()+"' benutzt.");
-            }
-        }
-        else
-        {
-            newNode = parentNode->createChildSceneNode();
-        }
-
-        LOG_DEBUG(Logger::CORE,
-                    " Node '"+newNode->getName()+"' als Unterknoten von '"+parentNode->getName()+"' erstellt.");
-
-
-        NodeUserData userData;
-        // Defaults einstellen
-        if (parentUserData == NULL || !parentUserData->is_inheriting)
-        {
-            userData.is_dynamic = false;
-            userData.is_inheriting = false;
-            userData.physical_body = "mesh";
-            userData.staticgeom_group = -1;
-            userData.renderingdistance = mRenderingDistance;
-        }
-        // Vom Vorg?nger erben
-        else
-        {
-            userData.is_dynamic = parentUserData->is_dynamic;
-            userData.is_inheriting = parentUserData->is_inheriting;
-            userData.physical_body = parentUserData->physical_body;
-            userData.staticgeom_group = parentUserData->staticgeom_group;
-            userData.renderingdistance = parentUserData->renderingdistance;
-        }
-
-
-        mCollisions.clear();
-        DOMNode* child = rootNodeXml->getFirstChild();
-        DOMNode *childScale = NULL, *childPosition = NULL,
-        *childRotation = NULL;
-        // Durch alle Unterelemente iterieren und gefundenes speichern
-        while(child != NULL)
-        {
-            // Ein selbstdefinierter Bereich
-            if (XMLString::compareIString(child->getNodeName(),
-                AutoXMLCh("userData").data()) == 0)
-            {
-                // UserData direkt auslesen
-                processNodeUserData(static_cast<DOMElement*>(child) , &userData);
-            }
-            else if (XMLString::compareIString(child->getNodeName(),
-                     AutoXMLCh("position").data()) == 0)
-                childPosition = child;//rootNodeXml->removeChild(child);
-            else if (XMLString::compareIString(child->getNodeName(),
-                     AutoXMLCh("rotation").data()) == 0)
-                childRotation = child;//rootNodeXml->removeChild(child);
-            else if (XMLString::compareIString(child->getNodeName(),
-                     AutoXMLCh("scale").data()) == 0)
-                childScale = child;//rootNodeXml->removeChild(child);
-
-            child = child->getNextSibling();
-        }
-        // so jetzt stehen nur noch entities und nodes in der liste
-
-
-
-
-
-        if (userData.staticgeom_group > -1)
-        {
-            newNode->getParentSceneNode()->removeChild(newNode);
-
-            // Existiert noch nicht
-            if (mStaticNodes.find(userData.staticgeom_group) == mStaticNodes.end())
-            {
-                mStaticNodes[userData.staticgeom_group] =
-                sceneManager->getRootSceneNode()->createChildSceneNode(
-                mSceneName+"_static_"+Ogre::StringConverter::toString(userData.staticgeom_group));
-            }
-
-            mStaticNodes[userData.staticgeom_group]->addChild(newNode);
-        }
-
-
-        // Einzelne weitere childs auslesen, falls n?tig, in der richtigen Reihenfolge
-
-        // Position des Nodes
-        if (childPosition != NULL)
-            newNode->setPosition(processPosition(static_cast<DOMElement*>(childPosition)));
-
-        // Rotation des Nodes
-        if (childRotation != NULL)
-            newNode->setOrientation(processRotation(static_cast<DOMElement*>(childRotation)));
-
-        // Skalierung des Nodes
-        if (childScale != NULL)
-            newNode->setScale(processScale(static_cast<DOMElement*>(childScale)));
-
-/*      // nun nicht mehr n?tig!
-        {
-            // Skalierung auf alle Entities ?bertragen
-            for(unsigned short i = 0; i < newNode->numAttachedObjects(); i++)
-            {
-                MovableObject* mo = newNode->getAttachedObject(i);
-                if (mo->getMovableType().compare("Entity") == 0)
-                    static_cast<Entity*>(mo)->setNormaliseNormals(newNode->getScale() != Vector3::UNIT_SCALE);
-            }
-        }
-*/
-
-
-
-        // Alle Entities und Subnodes auslesen
-        child = rootNodeXml->getFirstChild();
-        while(child != NULL)
-        {
-            // geschachteltes weiteres Node
-            if (XMLString::compareIString(child->getNodeName(),
-                AutoXMLCh("node").data()) == 0)
-                processNode(static_cast<DOMElement*>(child), sceneManager, newNode, &userData);
-            // Eine Entity
-            else if (XMLString::compareIString(child->getNodeName(),
-                     AutoXMLCh("entity").data()) == 0)
-                processEntity(static_cast<DOMElement*>(child),
-                                sceneManager,
-                                newNode,
-                                userData.renderingdistance,
-                                userData.physical_body);
-
-            child = child->getNextSibling();
-        }
-    }
-
-    void DotSceneLoader::processSceneUserData(XERCES_CPP_NAMESPACE::DOMElement* rootUserDataXml)
-    {
-        DOMNode* child = rootUserDataXml->getFirstChild();
-        LOG_DEBUG(Logger::CORE, " SceneUserData gefunden");
-        XmlPropertyReader* propertyReader = new XmlPropertyReader();
-
-        // Durch alle Unterelemente iterieren, um die properties zu finden
-        while(child != NULL)
-        {
-            // Ein selbstdefinierter Bereich
-            if (XMLString::compareIString(child->getNodeName(),
-                AutoXMLCh("property").data()) == 0)
-            {
-                DOMElement* propertyXml = static_cast<DOMElement*>(child);
-
-                PropertyEntry entry = propertyReader->processProperty(propertyXml);
-
-                try
-                {
-                    if (entry.first == "default_renderingdistance")
-                    {
-                        mRenderingDistance = entry.second.toReal();
-                    }
-                    else if (Ogre::StringUtil::startsWith(entry.first, "staticgeom_renderingdistance_"))
-                    {
-                        int groupId = Ogre::StringConverter::parseInt(entry.first.substr(29));
-                        mStaticgeomRenderingDistances[groupId] = entry.second.toReal();
-                    }
-                    else if (Ogre::StringUtil::startsWith(entry.first, "staticgeom_batchsize_"))
-                    {
-                        int groupId = Ogre::StringConverter::parseInt(entry.first.substr(21));
-                        mStaticgeomBatchSizes[groupId] = entry.second.toReal();
-                    }
-                }
-                catch(...)
-                {
-                    LOG_DEBUG(Logger::CORE,
-                        " > Parse Error beim ?bernehmen der Property '"+entry.first+"'!");
-                }
-
-            }
-            // Manuell definiertes LOD
-            else if (XMLString::compareIString(child->getNodeName(),
-                AutoXMLCh("manualLOD").data()) == 0)
-            {
-                DOMElement* lodXml = static_cast<DOMElement*>(child);
-                string meshName = getAttributeValueAsStdString(lodXml,
-                    "mesh");
-
-                try
-                {
-                    Ogre::MeshPtr mesh = Ogre::MeshManager::getSingleton().getByName(meshName);
-                    mesh->removeLodLevels();
-
-                    DOMNode* lodchild = child->getFirstChild();
-                    LOG_DEBUG(Logger::CORE, " LOD-Bereich f?r "+meshName+" gefunden");
-                    Ogre::Real loddist = 10.0;
-                    string lodmeshName = "";
-
-                    // Durch alle Unterelemente iterieren, um die LODs zu finden
-                    while(lodchild != NULL)
-                    {
-                        if (XMLString::compareIString(lodchild->getNodeName(),
-                            AutoXMLCh("LOD").data()) == 0)
-                        {
-                            loddist = 0.0;
-                            lodmeshName = "";
-
-                            try
-                            {
-                                lodXml = static_cast<DOMElement*>(lodchild);
-                                loddist = getAttributeValueAsReal(lodXml,
-                                    "distance");
-                                lodmeshName = getAttributeValueAsStdString(lodXml,
-                                    "mesh");
-
-                                if (lodmeshName.length() > 0 && loddist > 0)
-                                {
-                                    mesh->createManualLodLevel(loddist, lodmeshName);
-                                    LOG_DEBUG(Logger::CORE,
-                                        " LOD f?r bei '"+Ogre::StringConverter::toString(loddist)+
-                                        "' als '"+lodmeshName+"' gesetzt!");
-                                }
-                            }
-                            catch(...) { }
-                        }
-
-                        lodchild = lodchild->getNextSibling();
-                    }
-                }
-                catch(...)
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        " > Parse Error beim Setzen der LOD f?r '"+meshName+"'!");
-                }
-            }
-            child = child->getNextSibling();
-        }
-
-        delete propertyReader;
-    }
-
-    void DotSceneLoader::processNodeUserData(XERCES_CPP_NAMESPACE::DOMElement* rootUserDataXml,
-        NodeUserData* userData)
-    {
-        DOMNode* child = rootUserDataXml->getFirstChild();
-        LOG_DEBUG(Logger::CORE, " NodeUserData gefunden");
-
-        // Durch alle Unterelemente iterieren, um die properties zu finden
-        while(child != NULL)
-        {
-            // Ein selbstdefinierter Bereich
-            if (XMLString::compareIString(child->getNodeName(),
-                AutoXMLCh("property").data()) == 0)
-            {
-                DOMElement* propertyXml = static_cast<DOMElement*>(child);
-                PropertyEntry entry = processProperty(propertyXml);
-
-                try
-                {
-                    if (entry.first == "physical_body")
-                        userData->physical_body = entry.second.toString().c_str();
-                    else if (entry.first == "dynamic")
-                        userData->is_dynamic = entry.second.toInt() != 0;
-                    else if (entry.first == "staticgeom_group")
-                        userData->staticgeom_group = entry.second.toInt();
-                    else if (entry.first == "renderingdistance")
-                        userData->renderingdistance = entry.second.toReal();
-                }
-                catch(...)
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        " > Parse Error beim ?bernehmen der Property '"+entry.first+"'!");
-                }
-
-            }
-            else if (XMLString::compareIString(child->getNodeName(),
-                        AutoXMLCh("collisions").data()) == 0)
-                    processCollisions(static_cast<DOMElement*> (child));
-
-
-            child = child->getNextSibling();
-        }
-    }
-
-    // eine benutzerdefinierte Collision
-    void DotSceneLoader::processCollisions(XERCES_CPP_NAMESPACE::DOMElement *rootCollisionXml)
-    {
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-        OgreNewt::CollisionPtr collision;
-#else
-        OgreNewt::CollisionPtr collision = NULL;
-#endif
-        DOMNode* child = rootCollisionXml->getFirstChild();
-        OgreNewt::World *thisWorld = PhysicsManager::getSingleton()._getNewtonWorld();
-
-        std::vector<Ogre::Vector3> vec3Vector;
-        Ogre::Vector3 scale, offset;
-        Ogre::Quaternion rotation;
-
-
-        LOG_DEBUG(Logger::CORE, " collisions in NodeUserData gefunden");
-
-
-        while(child != NULL)
-        {
-            if (child->getNodeType() != DOMNode::ELEMENT_NODE)
-            {
-                child = child->getNextSibling();
-                continue;
-            }
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            collision.reset();
-#else
-            collision = NULL;
-#endif
-            // am Anfang steht ein Node mit dem Typ
-            std::string typeAsString = transcodeToStdString(child->getNodeName());
-
-            scale = Ogre::Vector3::UNIT_SCALE;
-            offset = Ogre::Vector3::ZERO;
-            rotation = Ogre::Quaternion::IDENTITY;
-            vec3Vector.clear();
-
-            DOMNode *childChild = static_cast<DOMElement*>(child)->getFirstChild();
-            while(childChild != NULL)
-            {
-                if (childChild->getNodeType() == DOMNode::ELEMENT_NODE)
-                {
-                    if (XMLString::compareIString(childChild->getNodeName(),
-                        AutoXMLCh("scale").data()) == 0)
-                        scale = processScale(static_cast<DOMElement*>(childChild));
-                    else if (XMLString::compareIString(childChild->getNodeName(),
-                             AutoXMLCh("offset").data()) == 0)
-                        offset = processPosition(static_cast<DOMElement*>(childChild));
-                    else if (XMLString::compareIString(childChild->getNodeName(),
-                             AutoXMLCh("rotation").data()) == 0)
-                        rotation = processRotation(static_cast<DOMElement*>(childChild));
-
-                    else if (XMLString::compareIString(childChild->getNodeName(),
-                             AutoXMLCh("vertices").data()) == 0)
-                    {
-                        DOMNode *childChildChild = static_cast<DOMElement*>(childChild)->getFirstChild();
-                        while(childChildChild != NULL)
-                        {
-                            if (childChild->getNodeType() == DOMNode::ELEMENT_NODE)
-                            {
-                                if (XMLString::compareIString(childChildChild->getNodeName(),
-                                    AutoXMLCh("vertex").data()) == 0)
-                                {
-                                    bool error = false;
-                                    Ogre::Vector3 vec3 = processVector(static_cast<DOMElement*>(childChildChild), error);
-                                    if (!error)
-                                        vec3Vector.push_back(vec3);
-                                }
-                            }
-                            childChildChild = childChildChild->getNextSibling();
-                        }
-                    }
-                }
-                childChild = childChild->getNextSibling();
-            }
-
-            // typangabe aus String extrahieren
-            if (typeAsString == "convexhull")
-            {
-                int vertcount = vec3Vector.size();
-                Ogre::Vector3 *vertices = new Ogre::Vector3[ vertcount ];
-                Ogre::Vector3 vec3Min(0,0,0), vec3Max(0,0,0);
-                for(int i = 0; i < vertcount; i++)
-                {
-                    vertices[i] = vec3Vector[i] * scale; // in array ?bertragen
-
-
-                    if (vertices[i].x < vec3Min.x)   // und gr??e des k?rpers bestimmen
-                        vec3Min.x = vertices[i].x;
-                    if (vertices[i].y < vec3Min.y)
-                        vec3Min.y = vertices[i].y;
-                    if (vertices[i].z < vec3Min.z)
-                        vec3Min.z = vertices[i].z;
-
-                    if (vertices[i].x > vec3Max.x)
-                        vec3Max.x = vertices[i].x;
-                    if (vertices[i].y > vec3Max.y)
-                        vec3Max.y = vertices[i].y;
-                    if (vertices[i].z > vec3Max.z)
-                        vec3Max.z = vertices[i].z;
-                }
-
-                Ogre::Vector3 size = vec3Max - vec3Min;
-                // Gr??e ?berpr?fen
-                if (size.x < PhysicsManager::NEWTON_GRID_WIDTH ||
-                    size.y < PhysicsManager::NEWTON_GRID_WIDTH ||
-                    size.z < PhysicsManager::NEWTON_GRID_WIDTH ||
-                    vertcount < 4)
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        " physical_body 'convexhull' in <collisions> konnte nicht erstellt werden; der K?rper ist zu klein!");
-
-                    // Minimale Gr??e verwenden
-                    if (size.x < PhysicsManager::NEWTON_GRID_WIDTH)
-                        size.x = PhysicsManager::NEWTON_GRID_WIDTH;
-                    if (size.y < PhysicsManager::NEWTON_GRID_WIDTH)
-                        size.y = PhysicsManager::NEWTON_GRID_WIDTH;
-                    if (size.z < PhysicsManager::NEWTON_GRID_WIDTH)
-                        size.z = PhysicsManager::NEWTON_GRID_WIDTH;
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
-                                     thisWorld, size, rotation, offset));
-
-                    LOG_MESSAGE(Logger::CORE, " stattdessen physical_body 'box' erstellt. ");
-                }
-                else
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
-                                    thisWorld,
-                                    vertices,
-                                    vertcount,
-                                    rotation, offset));
-
-                    LOG_DEBUG(Logger::CORE, " physical_body 'convexhull' in <collisions> erstellt. ");
-                }
-
-                delete [] vertices;
-            }
-            else
-            {
-                if (!vec3Vector.empty())   // fehler!
-                {
-                    LOG_MESSAGE(Logger::CORE, " > Parse Error beim Einlesen einer Collision; Es k?nne nur f?r Convexhull Vektoren definiert werden!");
-                }
-
-                if (typeAsString.compare("box") == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
-                                    thisWorld, scale, rotation, offset));
-                    LOG_DEBUG(Logger::CORE, " physical_body 'box' in <collisions> erstellt. ");
-                }
-                else if (typeAsString.compare("sphere") == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-                                    thisWorld, scale, rotation, offset));
-                    LOG_DEBUG(Logger::CORE, " physical_body 'sphere' in <collisions> erstellt. ");
-                }
-                else if (typeAsString.compare("ellipsoid") == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-                    thisWorld, scale, rotation, offset));
-                    LOG_DEBUG(Logger::CORE, " physical_body 'ellipsoid' in <collisions> erstellt. ");
-                }
-                else if (typeAsString.compare("pyramid") == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Pyramid(
-                    thisWorld, scale, rotation, offset));
-                    LOG_DEBUG(Logger::CORE, " physical_body 'pyramid' in <collisions> erstellt. ");
-                }
-                else if (typeAsString.compare("capsule") == 0)
-                {
-                    double radius = std::max(scale.x, scale.z) / 2.0;
-                    double height = scale.y;
-                    offset.x -= scale.y/2;
-                    Ogre::Quaternion tempRot;
-                    tempRot.FromAngleAxis(Degree(90), Ogre::Vector3::UNIT_Z);
-                    rotation = (rotation * tempRot);
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Capsule(
-                                    thisWorld,
-                                    radius,
-                                    height,
-                                    rotation, offset));
-                    LOG_DEBUG(Logger::CORE, " physical_body 'capsule' in <collisions> erstellt. ");
-                }
-                else if (typeAsString.compare("cone") == 0)
-                {
-                    double radius = std::max(scale.x, scale.z) / 2.0;
-                    double height = scale.y;
-                    offset.x -= scale.y/2;
-                    Ogre::Quaternion tempRot;
-                    tempRot.FromAngleAxis(Degree(90), Ogre::Vector3::UNIT_Z);
-                    rotation = (rotation * tempRot);
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Cone(
-                                    thisWorld,
-                                    radius,
-                                    height,
-                                    rotation, offset));
-                    LOG_DEBUG(Logger::CORE, " physical_body 'cone' in <collisions> erstellt. ");
-                }
-                else if (typeAsString.compare("cylinder") == 0)
-                {
-                    double radius = std::max(scale.x, scale.z) / 2.0;
-                    double height = scale.y;
-                    offset.x -= scale.y/2;
-                    Ogre::Quaternion tempRot;
-                    tempRot.FromAngleAxis(Degree(90), Ogre::Vector3::UNIT_Z);
-                    rotation = (rotation * tempRot);
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder(
-                                    thisWorld,
-                                    radius,
-                                    height,
-                                    rotation, offset));
-                    LOG_DEBUG(Logger::CORE, " physical_body 'cylinder' in <collisions> erstellt. ");
-                }
-                else if (typeAsString.compare("chamfer_cylinder") == 0)
-                {
-                    double radius = std::max(scale.x, scale.z) / 2.0;
-                    double height = scale.y;
-                    offset.x -= scale.y/2;
-                    Ogre::Quaternion tempRot;
-                    tempRot.FromAngleAxis(Degree(90), Ogre::Vector3::UNIT_Z);
-                    rotation = (rotation * tempRot);
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ChamferCylinder(
-                                    thisWorld,
-                                    radius,
-                                    height,
-                                    rotation, offset));
-                    LOG_DEBUG(Logger::CORE, " physical_body 'chamfer_cylinder' in <collisions> erstellt. ");
-                }
-                else if (typeAsString.compare("mesh") == 0)
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        " Mesh-Collisions in <collisions> werden momentan noch nicht unterst?tzt (Eintrag wird ignoriert).");
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-                    collision.reset();
-#else
-                    collision = NULL;
-#endif
-                }
-/*
-                else if (typeAsString.compare("meshhull") == 0)  // automatische convexhull mit daten aus mesh
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        " Entityhull-Collisions werden momentan noch nicht unterst?tzt (Eintrag wird ignoriert).");
-                    collision = NULL;
-                }
-*/
-                else
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        " > Parse Error beim Erstellen einer Collision; ung?ltiger typ: '"+typeAsString+"' !");
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-                    collision.reset();
-#else
-                    collision = NULL;
-#endif
-                }
-
-            }
-
-
-            // Collision dem vektor hinzuf?gen
-            if ( !collision )
-                mCollisions.push_back(collision);
-
-            child = child->getNextSibling();
-        }
-    }
-
-    // Eine Entity
-    void DotSceneLoader::processEntity(DOMElement* rootEntityXml,
-        SceneManager* sceneManager, Ogre::SceneNode* parentNode,
-        Ogre::Real renderingDistance, const std::string &physical_body)
-    {
-        string entName = getAttributeValueAsStdString(
-            rootEntityXml, "name");
-        string meshName = getAttributeValueAsStdString(
-            rootEntityXml, "meshFile");
-
-        Ogre::Entity* newEnt = NULL;
-
-        // Wurde der Entity bisher kein Name zugewiesen
-        if (entName.length() == 0)
-        {
-            entName = getRandomName(mSceneName+"_"+parentNode->getName());
-        }
-
-        ResourceGroupManager& resGroupMgr = ResourceGroupManager::getSingleton();
-        while(parentNode->getCreator()->hasEntity(entName))
-        {
-            entName = getRandomName(entName);
-        }
-
-        try
-        {
-            // if this mesh exists in our module's resource group: preload it
-            if (resGroupMgr.resourceExists(mResourceGroup, meshName))
-            {
-                MeshManager::getSingleton().load(meshName, mResourceGroup);
-            }
-
-            // If not, it is now loaded implicitly from the default group
-            newEnt = sceneManager->createEntity(entName, meshName);
-        }
-        catch(...)
-        {
-              LOG_ERROR(Logger::CORE, " Entity '"+meshName+"' mit dem Namen '"+entName+"' konnte nicht geladen werden.");
-              return;
-        }
-
-        /*if (parentNode->getScale() != Vector3::UNIT_SCALE) 
-		{
-            newEnt->setNormaliseNormals(true);
-		}*/
-
-        parentNode->attachObject(newEnt);
-
-        LOG_DEBUG(Logger::CORE, " Entity '"+meshName+"' mit dem Namen '"+entName+"' in den Knoten '"+parentNode->getName()+"' eingef?gt.");
-
-
-        // ------- Falls n?tig automatisch bodyproxy erstellen -------------
-        // (wenn physical_body gesetzt wurde)
-        OgreNewt::CollisionPtr collision = OgreNewt::CollisionPtr();
-        OgreNewt::World *thisWorld = PhysicsManager::getSingleton()._getNewtonWorld();
-
-        if (physical_body.compare("none") != 0)
-        {
-            const AxisAlignedBox &aab = newEnt->getMesh()->getBounds();
-            Ogre::Vector3 size = (aab.getMaximum() - aab.getMinimum()) * parentNode->getScale();
-            bool forceBox = false;
-
-            if ((size.x < PhysicsManager::NEWTON_GRID_WIDTH ||
-                 size.y < PhysicsManager::NEWTON_GRID_WIDTH ||
-                 size.z < PhysicsManager::NEWTON_GRID_WIDTH) &&
-                 physical_body.compare("convexhull") == 0)
-            {
-                if (size.x < PhysicsManager::NEWTON_GRID_WIDTH)
-                    size.x = PhysicsManager::NEWTON_GRID_WIDTH;
-                if (size.y < PhysicsManager::NEWTON_GRID_WIDTH)
-                    size.y = PhysicsManager::NEWTON_GRID_WIDTH;
-                if (size.z < PhysicsManager::NEWTON_GRID_WIDTH)
-                    size.z = PhysicsManager::NEWTON_GRID_WIDTH;
-
-                LOG_MESSAGE(Logger::CORE, " Die Entity '"+entName+"' liegt in einer Ebene, verwende 'box' f?r physical_body '"+physical_body+"' ");
-                forceBox = true;
-            }
-            const Quaternion orientation(0,0,0,0);// = parentNode->getOrientation();
-            const Ogre::Vector3 pos = aab.getMinimum()* parentNode->getScale() + (size/2.0);
-
-
-            // Pr?fen, ob schon ein identischer Proxy erstellt wurde um diesen erneut zu verwenden
-            AlreadyUsedCollision &aucol (mAutoCreatedCollisions[meshName]);
-            if (aucol.Type.compare(physical_body) == 0  &&
-                aucol.Scale == parentNode->getScale() &&
-                (!forceBox)) // sicherheitshalber
-            {
-                collision = aucol.ColPtr;
-                LOG_DEBUG(Logger::CORE, " Schon fr?her erstellten physical_body f?r Entity '"+entName+"' wieder verwendet. ");
-            }
-            else
-            {
-
-                if (physical_body.compare("box") == 0 || forceBox)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
-                                     thisWorld, size, orientation, pos));
-                    LOG_DEBUG(Logger::CORE, " physical_body 'box' f?r Entity '"+entName+"' erstellt. ");
-                }
-                else if (physical_body.compare("pyramid") == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Pyramid(
-                                    thisWorld, size, orientation, pos));
-                    LOG_DEBUG(Logger::CORE, " physical_body 'pyramid' f?r Entity '"+entName+"' erstellt. ");
-                }
-                else if (physical_body.compare("sphere") == 0)
-                {
-                    double radius = std::max(size.x, std::max(size.y, size.z)) / 2.0;
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-                                    thisWorld, Vector3(radius, radius, radius),
-                                    orientation, pos));
-                    LOG_DEBUG(Logger::CORE, " physical_body 'sphere' f?r Entity '"+entName+"' erstellt. ");
-                }
-                else if (physical_body.compare("ellipsoid") == 0)
-                {
-                    // set the size x/z values to the maximum
-                    Ogre::Vector3 s(size/2.0);
-                    s.x = std::max(s.x, s.z);
-                    s.z = s.x;
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-                                    thisWorld, s,
-                                    orientation, pos));
-                    LOG_DEBUG(Logger::CORE, " physical_body 'ellipsoid' f?r Entity '"+entName+"' erstellt. ");
-                }
-                else if (physical_body.compare("capsule") == 0)
-                {
-                    double radius = std::max(size.x, size.z) / 2.0;
-                    double height = size.y;
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Capsule(
-                                    thisWorld,
-                                    radius,
-                                    height,
-                                    orientation, pos));
-                    LOG_DEBUG(Logger::CORE, " physical_body 'capsule' f?r Entity '"+entName+"' erstellt. ");
-                }
-                else if (physical_body.compare("convexhull") == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
-                                    thisWorld,
-                                    newEnt));
-                    LOG_DEBUG(Logger::CORE, " physical_body 'convexhull' f?r Entity '"+entName+"' erstellt. ");
-                }
-                else if (physical_body.compare("mesh") == 0 || physical_body.compare("auto") == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
-                                    thisWorld, newEnt, true));
-                    LOG_DEBUG(Logger::CORE, " physical_body 'mesh' f?r Entity '"+entName+"' erstellt. ");
-                }
-                else
-                    LOG_MESSAGE(Logger::CORE,
-                        " Der bodyproxy_type '"+physical_body+"'(aus userData) der Entity '"+meshName+"' ist ung?ltig.");
-
-                // proxy in die liste der schon erstellten proxies hinzuf?gen
-                aucol.ColPtr = collision;
-                aucol.Scale = parentNode->getScale();
-                aucol.Type = physical_body;
-            }
-        }
-
-        // zur liste hinzuf?gen
-        if (collision != NULL)
-        {
-            mCollisions.push_back(collision);
-        }
-
-
-        // Zur Physik des Levels hinzuf?gen
-        if (mCollisions.size() > 0)
-        {
-            PhysicsManager::getSingleton().addLevelGeometry(newEnt, mCollisions);
-            LOG_DEBUG(Logger::CORE, " Entity '"+entName+"' in levelGeometry geladen");
-        }
-
-
-        // wieder aus der liste entfernen, falls mehrere entities hier definiert werden
-        if (collision != NULL)
-        {
-            mCollisions.pop_back();
-        }
-
-        // Renderingdistanz berechnen
-        if (renderingDistance == mRenderingDistance)
-        {
-            Ogre::Real diameter
-                = (newEnt->getBoundingBox().getMaximum() - newEnt->getBoundingBox().getMinimum()).length();
-
-            // Gerade mal 10cm? => 10m
-            if (diameter <= 0.5)
-                renderingDistance = 15;
-            // Gerade mal 1,5m? => 25m
-            else if (diameter <= 1.5)
-                renderingDistance = 30;
-            // Gerade mal 2,5m? => 50m
-            else if (diameter <= 2.5)
-                renderingDistance = 60;
-            else if (diameter <= 10)
-                renderingDistance = 150;
-            else if (diameter <= 50)
-                renderingDistance = 250;
-            else if (diameter <= 100)
-                renderingDistance = 450;
-            else
-                renderingDistance = 1500;
-
-            newEnt->setRenderingDistance(renderingDistance);
-        }
-        else
-            newEnt->setRenderingDistance(renderingDistance);
-        newEnt->setCastShadows(false);
-    }
-
-    string DotSceneLoader::getRandomName(const string& baseName)
-    {
-        int rnd = rand();
-        stringstream rval;
-        rval << baseName << "_" << rnd;
-        return rval.str();
-    }
-
-    Ogre::Vector3 DotSceneLoader::processPosition(DOMElement* rootPositionXml)
-    {
-        LOG_DEBUG(Logger::CORE, " Position gefunden");
-
-        try
-        {
-            if (hasAttribute(rootPositionXml, "x") &&
-                hasAttribute(rootPositionXml, "y") &&
-                hasAttribute(rootPositionXml, "z"))
-            {
-                return Ogre::Vector3(
-                    getAttributeValueAsReal(rootPositionXml, "x"),
-                    getAttributeValueAsReal(rootPositionXml, "y"),
-                    getAttributeValueAsReal(rootPositionXml, "z"));
-            }
-        }
-        catch(...) { }
-
-        LOG_MESSAGE(Logger::CORE, " > Parse Error beim ?bernehmen der Position! ");
-
-        return Ogre::Vector3::ZERO;
-    }
-
-
-    Ogre::Vector3 DotSceneLoader::processScale(DOMElement* rootScaleXml)
-    {
-        LOG_DEBUG(Logger::CORE, " Skalierung gefunden");
-
-        try
-        {
-            if (hasAttribute(rootScaleXml, "x") &&
-                hasAttribute(rootScaleXml, "y") &&
-                hasAttribute(rootScaleXml, "z"))
-            {
-                return Ogre::Vector3(
-                    getAttributeValueAsReal(rootScaleXml, "x"),
-                    getAttributeValueAsReal(rootScaleXml, "y"),
-                    getAttributeValueAsReal(rootScaleXml, "z"));
-            }
-        }
-        catch(...) { }
-
-        LOG_MESSAGE(Logger::CORE, " > Parse Error beim ?bernehmen der Skalierung! ");
-
-        return Ogre::Vector3::UNIT_SCALE;
-    }
-
-    Ogre::Vector3 DotSceneLoader::processVector(DOMElement* rootScaleXml, bool &error)
-    {
-        LOG_DEBUG(Logger::CORE, " Vector gefunden");
-
-        try
-        {
-            if (hasAttribute(rootScaleXml, "x") &&
-                hasAttribute(rootScaleXml, "y") &&
-                hasAttribute(rootScaleXml, "z"))
-            {
-                error = false;
-                return Ogre::Vector3(
-                    getAttributeValueAsReal(rootScaleXml, "x"),
-                    getAttributeValueAsReal(rootScaleXml, "y"),
-                    getAttributeValueAsReal(rootScaleXml, "z"));
-            }
-        }
-        catch(...) { }
-
-        LOG_MESSAGE(Logger::CORE, " > Parse Error beim Lesen eines Vectors! ");
-        error = true;
-
-        return Ogre::Vector3::UNIT_SCALE;
-    }
-
-    /// @TODO Sollten drei M?glichkeiten sein...
-    Ogre::Quaternion DotSceneLoader::processRotation(DOMElement* rootQuatXml)
-    {
-        LOG_DEBUG(Logger::CORE, " Rotation gefunden");
-
-        try
-        {
-            // Durch w,x,y,z definiert
-            if (hasAttribute(rootQuatXml, "qw") &&
-                hasAttribute(rootQuatXml, "qx") &&
-                hasAttribute(rootQuatXml, "qy") &&
-                hasAttribute(rootQuatXml, "qz"))
-            {
-
-                return Ogre::Quaternion(
-                    getAttributeValueAsReal(rootQuatXml, "qw"),
-                    getAttributeValueAsReal(rootQuatXml, "qx"),
-                    getAttributeValueAsReal(rootQuatXml, "qy"),
-                    getAttributeValueAsReal(rootQuatXml, "qz"));
-            }
-
-            // Durch axisX,axisY,axisZ,angle definiert
-            if (hasAttribute(rootQuatXml, "angle") &&
-                hasAttribute(rootQuatXml, "axisX") &&
-                hasAttribute(rootQuatXml, "axisY") &&
-                hasAttribute(rootQuatXml, "axisZ"))
-            {
-                return Ogre::Quaternion(
-                    Ogre::Degree(getAttributeValueAsReal(rootQuatXml, "angle")),
-                    Ogre::Vector3(
-                    getAttributeValueAsReal(rootQuatXml, "axisX"),
-                    getAttributeValueAsReal(rootQuatXml, "axisY"),
-                    getAttributeValueAsReal(rootQuatXml, "axisZ")));
-            }
-
-            // Durch angleX,angleY,angleZ definiert
-            if (hasAttribute(rootQuatXml, "angleX") &&
-                hasAttribute(rootQuatXml, "angleY") &&
-                hasAttribute(rootQuatXml, "angleZ") )
-            {
-                Ogre::Matrix3 mat;
-                mat.FromEulerAnglesXYZ(
-                    Degree(getAttributeValueAsReal(rootQuatXml, "angleX")),
-                    Degree(getAttributeValueAsReal(rootQuatXml, "angleY")),
-                    Degree(getAttributeValueAsReal(rootQuatXml, "angleZ")));
-                return Quaternion(mat);
-            }
-        }
-        catch(...) {}
-
-        LOG_MESSAGE(Logger::CORE, " > Parse Error beim ?bernehmen der Rotation! ");
-
-        return Ogre::Quaternion::IDENTITY;
-    }
-}
-

Deleted: rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -1,160 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-// Xerces geht vor allen Ogre includes...
-#include "XmlResourceManager.h"
-
-#include "DotSceneOctreeWorld.h"
-
-
-#include "CoreSubsystem.h"
-#include "ConfigurationManager.h"
-#include "ActorManager.h"
-#include "Actor.h"
-#include "PhysicsManager.h"
-#include "DotSceneLoader.h"
-#include "ZoneManager.h"
-
-using namespace Ogre;
-
-namespace rl {
-
-    DotSceneOctreeWorld::DotSceneOctreeWorld( )
-        :   World(ST_GENERIC)
-    {
-        mSceneFile = "";
-    }
-
-    DotSceneOctreeWorld::~DotSceneOctreeWorld()
-    {
-        clearScene();
-    }
-
-    void DotSceneOctreeWorld::initializeDefaultCamera(void)
-    {
-        if (mCamera == 0)
-        {
-            // Kamera erstellen..
-            Actor* actor = ActorManager::getSingleton().createCameraActor("DefaultCamera");
-            // und initialisieren.
-            mCamera = mSceneMgr->getCamera("DefaultCamera");
-
-            mCamera->setPosition( getStartPoint() );
-            mCamera->setFOVy(Degree(60));
-            mCamera->setFixedYawAxis(true);
-            mCamera->setAutoAspectRatio(true);
-
-            actor->placeIntoScene();
-
-			// Ein Viewport, das komplette Fenster
-			Viewport* newVp = CoreSubsystem::getSingleton().getRenderWindow()->addViewport(mCamera, 1);
-
-			// Schwarzer Hintergrund
-			newVp->setBackgroundColour(ColourValue(0,0,0));
-
-		}
-    }
-
-    void DotSceneOctreeWorld::loadScene(const Ogre::String& levelName, const Ogre::String& module)
-    {
-        // Alte Szene l?schen
-        clearScene();
-
-		setCastShadows( true );
-
-        // Leerer Ogre::String, keine Map laden
-        if (levelName.length() != 0)
-        {
-            /// TODO - In den Sky-Sonnenpart verschieben
-            mSceneMgr->setAmbientLight(ColourValue(0.55, 0.55, 0.55));
-            mSceneFile = levelName;
-
-            DotSceneLoader* dot = NULL;
-            try
-            {
-                dot = new DotSceneLoader( mSceneFile, module );
-                dot->initializeScene( mSceneMgr );
-                delete dot;
-            }
-            catch( ... )
-            {
-                LOG_CRITICAL(Logger::CORE,
-                    "Laden der Szenenbeschreibung aus '" + mSceneFile + "' ist fehlgeschlagen." );
-                delete dot;
-            }
-        }
-        else
-        {
-            mSceneFile = "";
-        }
-
-        initializeDefaultCamera();
-        fireAfterSceneLoaded();
-    }
-
-    void DotSceneOctreeWorld::clearScene()
-    {
-        fireBeforeClearScene();
-
-        // This is necessary to destroy cameras too.
-        CoreSubsystem::getSingleton().getRenderWindow()->removeAllViewports();
-        ZoneManager::getSingleton().destroyAllZones();
-        ActorManager::getSingleton().destroyAllActors();
-        mSceneMgr->clearScene();
-        PhysicsManager::getSingleton().clearLevelGeometry();
-
-        mSceneFile = "";
-        mCamera = NULL;
-    }
-
-    void DotSceneOctreeWorld::setCastShadows(bool enabled)
-    {
-		bool castShadows = false;
-
-		if( enabled )
-		{
-			Ogre::String tmp =
-				ConfigurationManager::getSingleton().getStringSetting(
-					"Video", "Cast Shadows" );
-
-			if (tmp == "yes")
-				castShadows = true;
-			else if (tmp == "no")
-				castShadows = false;
-		}
-
-		/// @todo Settings for multiple Shadow-Types?
-		if( castShadows )
-		{
-			int textureSize =
-				ConfigurationManager::getSingleton().getIntSetting(
-					"Video", "Shadow Texture Size" );
-			textureSize = std::max( 64, std::min( 4096, textureSize ) );
-
-			mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_MODULATIVE);
-			mSceneMgr->setShadowTextureSize( textureSize );
-			mSceneMgr->setShadowColour(ColourValue(0.7, 0.7, 0.7));
-			mSceneMgr->setShadowFarDistance(8.0f);
-			mSceneMgr->setShadowDirLightTextureOffset(0.8f);
-            mSceneMgr->setShadowCameraSetup((Ogre::ShadowCameraSetupPtr) new Ogre::LiSPSMShadowCameraSetup());
-		}
-		else
-		{
-			mSceneMgr->setShadowTechnique( SHADOWTYPE_NONE);
-		}
-    }
-}

Modified: rl/trunk/engine/core/src/GameAreaTypes.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaTypes.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/src/GameAreaTypes.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -237,8 +237,8 @@
             geomType = GT_CONVEXHULL;
         }
         OgreNewt::CollisionPtr col =
-            PhysicsManager::getSingleton().getCollisionFactory()->createCollisionFromEntity(entity,
-            geomType, &offset, &orientation);
+            PhysicsManager::getSingleton().createCollision(entity,
+            geomType, "", &offset, &orientation);
         mBody = new OgreNewt::Body(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             col);
@@ -262,8 +262,8 @@
             Ogre::Quaternion orientation)
     {
         OgreNewt::CollisionPtr col =
-            PhysicsManager::getSingleton().getCollisionFactory()->createCollisionFromAABB(
-            aabb, geomType, &offset, &orientation);
+            PhysicsManager::getSingleton().createCollision(
+            "", aabb, geomType, &offset, &orientation, 0, NULL, NULL, true);
         mBody = new OgreNewt::Body(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             col);

Modified: rl/trunk/engine/core/src/GameEventManager.cpp
===================================================================
--- rl/trunk/engine/core/src/GameEventManager.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/src/GameEventManager.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -309,7 +309,10 @@
     Actor* GameEventManager::bodyToActor(OgreNewt::Body* body)
     {
 #ifdef OGRENEWT_USE_OGRE_ANY
-        return Ogre::any_cast<Actor*>(body->getUserData());
+        if( body->getUserData().getType() == typeid(Actor*) )
+            return Ogre::any_cast<Actor*>(body->getUserData());
+        else
+            return NULL;
 #else
         return static_cast<Actor*>(body->getUserData());
 #endif

Copied: rl/trunk/engine/core/src/GenericWorld.cpp (from rev 4889, rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp)
===================================================================
--- rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/core/src/GenericWorld.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -0,0 +1,122 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+// Xerces geht vor allen Ogre includes...
+#include "XmlResourceManager.h"
+
+#include "GenericWorld.h"
+
+
+#include "CoreSubsystem.h"
+#include "ConfigurationManager.h"
+#include "ActorManager.h"
+#include "Actor.h"
+#include "PhysicsManager.h"
+#include "ZoneManager.h"
+
+using namespace Ogre;
+
+namespace rl {
+
+    GenericWorld::GenericWorld( )
+        :   World(ST_GENERIC)
+    {
+        mSceneFile = "";
+    }
+
+    GenericWorld::~GenericWorld()
+    {
+        clearScene();
+    }
+
+    void GenericWorld::initializeDefaultCamera(void)
+    {
+        if (mCamera == 0)
+        {
+            // Kamera erstellen..
+            Actor* actor = ActorManager::getSingleton().createCameraActor("DefaultCamera");
+            // und initialisieren.
+            mCamera = mSceneMgr->getCamera("DefaultCamera");
+
+            mCamera->setPosition( getStartPoint() );
+            mCamera->setFOVy(Degree(60));
+            mCamera->setFixedYawAxis(true);
+            mCamera->setAutoAspectRatio(true);
+
+            actor->placeIntoScene();
+
+			// Ein Viewport, das komplette Fenster
+			Viewport* newVp = CoreSubsystem::getSingleton().getRenderWindow()->addViewport(mCamera, 1);
+
+			// Schwarzer Hintergrund
+			newVp->setBackgroundColour(ColourValue(0,0,0));
+
+		}
+    }
+
+    void GenericWorld::clearScene()
+    {
+        fireBeforeClearScene();
+
+        // This is necessary to destroy cameras too.
+        CoreSubsystem::getSingleton().getRenderWindow()->removeAllViewports();
+        ZoneManager::getSingleton().destroyAllZones();
+        ActorManager::getSingleton().destroyAllActors();
+        mSceneMgr->clearScene();
+        PhysicsManager::getSingleton().clearLevelGeometry();
+
+        mSceneFile = "";
+        mCamera = NULL;
+    }
+
+    void GenericWorld::setCastShadows(bool enabled)
+    {
+		bool castShadows = false;
+
+		if( enabled )
+		{
+			Ogre::String tmp =
+				ConfigurationManager::getSingleton().getStringSetting(
+					"Video", "Cast Shadows" );
+
+			if (tmp == "yes")
+				castShadows = true;
+			else if (tmp == "no")
+				castShadows = false;
+		}
+
+		/// @todo Settings for multiple Shadow-Types?
+		if( castShadows )
+		{
+			int textureSize =
+				ConfigurationManager::getSingleton().getIntSetting(
+					"Video", "Shadow Texture Size" );
+			textureSize = std::max( 64, std::min( 4096, textureSize ) );
+
+			mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_MODULATIVE);
+			mSceneMgr->setShadowTextureSize( textureSize );
+			mSceneMgr->setShadowColour(ColourValue(0.7, 0.7, 0.7));
+			mSceneMgr->setShadowFarDistance(8.0f);
+			mSceneMgr->setShadowDirLightTextureOffset(0.8f);
+            mSceneMgr->setShadowCameraSetup((Ogre::ShadowCameraSetupPtr) new Ogre::LiSPSMShadowCameraSetup());
+		}
+		else
+		{
+			mSceneMgr->setShadowTechnique( SHADOWTYPE_NONE);
+		}
+    }
+}

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -524,7 +524,8 @@
         else
         {
             const AxisAlignedBox& aabb = mPhysicalObject->getDefaultSize();
-            coll = PhysicsManager::getSingleton().getCollisionFactory()->createCollisionFromAABB(
+            coll = PhysicsManager::getSingleton().createCollision(
+                "", // @todo: can we use a name here?
                 aabb,
                 mGeometryType,
                 NULL,

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -113,9 +113,6 @@
 
     PhysicsManager::~PhysicsManager()
     {
-        // simply remove all collision ptrs (is this really ok?)
-        mCollisionPrimitives.clear();
-
         // remove all material-pairs
         for (MaterialPairMap::iterator it = mMaterialPairs.begin(); it != mMaterialPairs.end(); it++)
         {
@@ -520,10 +517,13 @@
 
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
         Ogre::Entity* entity, const GeometryType& geomType,
-		const Ogre::String animName, Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
+		const Ogre::String& animName, const Ogre::Vector3* offset,
+        const Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
         Ogre::Vector3* centerOfMass, bool nocache)
     {
+        return mPhysicsCollisionFactory->createCollisionFromEntity(
+                entity, geomType, offset, orientation, mass, inertia, centerOfMass, nocache );
+/*
         // problem here is that a mesh can have different animations with
         // different extents. Therefore we add the animName to the meshname
         // to compute a unique name for the collision primitiv.
@@ -566,14 +566,18 @@
         }
 
         return rval;
+*/
     }
 
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
         const Ogre::String& name, const Ogre::AxisAlignedBox& aabb,
-        const GeometryType& geomType, Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
+        const GeometryType& geomType, const Ogre::Vector3* offset,
+        const Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
         Ogre::Vector3* centerOfMass, bool nocache)
     {
+        return mPhysicsCollisionFactory->createCollisionFromAABB(
+                name, aabb, geomType, offset, orientation, mass, inertia, centerOfMass, nocache );
+/*
         // result value
         CollisionPtr rval;
 #ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
@@ -610,13 +614,9 @@
         }
 
         return rval;
+*/
     }
 
-    PhysicsCollisionFactory* PhysicsManager::getCollisionFactory()
-    {
-        return mPhysicsCollisionFactory;
-    }
-
 	GeometryType PhysicsManager::convertStringToGeometryType(const Ogre::String& geomTypeString)
 	{
 		if (geomTypeString == "box")
@@ -657,6 +657,17 @@
 		return typestr;
 	}
 
+    PhysicsCollisionFactory::~PhysicsCollisionFactory()
+    {
+        clearCollisionCache();
+    }
+
+    void PhysicsCollisionFactory::clearCollisionCache()
+    {
+        mMeshCollisionsCache.clear();
+        mConvexCollisionsCache.clear();
+    }
+
     bool PhysicsCollisionFactory::checkSize(const Ogre::AxisAlignedBox& aabb) const
     {
         Ogre::Vector3 size = aabb.getSize();
@@ -690,20 +701,23 @@
     }
     */
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(const Ogre::AxisAlignedBox passedAabb,
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(
+        const Ogre::String& name,
+        const Ogre::AxisAlignedBox& passedAabb,
         const GeometryType& geomType,
-        Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation,
-        const Ogre::Real Mass,
+        const Ogre::Vector3* offset,
+        const Ogre::Quaternion* orientation,
+        const Ogre::Real mass,
         Ogre::Vector3* inertia,
-        Ogre::Vector3* centerOfMass)
+        Ogre::Vector3* centerOfMass,
+        bool nocache)
     {
         Ogre::AxisAlignedBox aabb(passedAabb);
         // type for the collision primitiv (can change internally here)
         bool forceBox (false);
 
         // result value
-        CollisionPtr rval;
+        ConvexCollisionPtr rval;
 #ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
         rval = NULL;
 #endif
@@ -738,44 +752,64 @@
 	    */
 		if (geomType == GT_BOX || forceBox == true)
         {
-			rval = createBox(aabb, offset, orientation, Mass, inertia, centerOfMass);
+			rval = createBox(aabb, offset, orientation);
         }
         else if (geomType == GT_PYRAMID)
         {
-            rval = createPyramid(aabb, offset, orientation, Mass, inertia, centerOfMass);
+            rval = createPyramid(aabb, offset, orientation);
         }
         else if (geomType == GT_SPHERE)
         {
-			rval = createSphere(aabb, offset, orientation, Mass, inertia, centerOfMass);
+			rval = createSphere(aabb, offset, orientation);
         }
         else if (geomType == GT_ELLIPSOID)
         {
-            rval = createEllipsoid(aabb, offset, orientation, Mass, inertia, centerOfMass);
+            rval = createEllipsoid(aabb, offset, orientation);
         }
 		else if (geomType == GT_CAPSULE)
 		{
-			rval = createCapsule(aabb, offset, orientation, Mass, inertia, centerOfMass);
+			rval = createCapsule(aabb, offset, orientation);
 		}
+
+        // calculate inertia / centerOfMass if needed
+        if (inertia != NULL || centerOfMass != NULL )
+        {
+            Vector3 temp_inertia, temp_centerOfMass;
+            rval->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+            if( inertia != NULL )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass != NULL )
+                *centerOfMass = temp_centerOfMass;
+        }
+
         return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromEntity(Ogre::Entity* entity,
         const GeometryType& geomType,
-        Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation,
+        const Ogre::Vector3* offset,
+        const Ogre::Quaternion* orientation,
         const Ogre::Real mass,
         Ogre::Vector3* inertia,
-        Ogre::Vector3* centerOfMass)
+        Ogre::Vector3* centerOfMass,
+        bool nocache)
     {
         // bounding box of the mesh
         Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
+        // apply scale if attached to a node (like in OgreNewt for convexhull)
+        if( entity->getParentNode() )
+            aabb.scale(entity->getParentNode()->getScale());
+
         // type for the collision primitiv (can change internally here)
         bool forceBox (false);
 
         // result value
         CollisionPtr rval;
+        ConvexCollisionPtr rvalAsConvexCollision; // store pointer to ConvexCollision, so we don't need to cast
+                                                  // this also indicates, that it is possible to calculate inertia/centerOfMass
 #ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
         rval = NULL;
+        rvalAsConvexCollision = NULL;
 #endif
 
         // size check (if object is too small, it falls back to a box primitiv
@@ -797,55 +831,33 @@
 	    */
 		if (geomType == GT_BOX || forceBox == true)
         {
-			rval = createBox(aabb, offset, orientation, mass, inertia, centerOfMass);
+            rvalAsConvexCollision = createBox(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
         }
         else if (geomType == GT_PYRAMID)
         {
-            rval = createPyramid(aabb, offset, orientation, mass, inertia, centerOfMass);
+            rvalAsConvexCollision = createPyramid(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
         }
         else if (geomType == GT_SPHERE)
         {
-			rval = createSphere(aabb, offset, orientation, mass, inertia, centerOfMass);
+            rvalAsConvexCollision = createSphere(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
         }
         else if (geomType == GT_ELLIPSOID)
         {
-            rval = createEllipsoid(aabb, offset, orientation, mass, inertia, centerOfMass);
+            rvalAsConvexCollision = createEllipsoid(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
         }
 		else if (geomType == GT_CAPSULE)
 		{
-			rval = createCapsule(aabb, offset, orientation, mass, inertia, centerOfMass);
+            rvalAsConvexCollision = createCapsule(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
 		}
         else if (geomType == GT_CONVEXHULL)
         {
-            // offset of the collision primitiv
-	    	Ogre::Vector3 object_offset( Ogre::Vector3::ZERO );
-            // orientation of the collision primitiv
-		    Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
-
-            // set offset/orientation when they are null
-			if (! offset)
-				offset = &object_offset;
-			if (! orientation)
-				orientation = &object_orientation;
-
-			// calculate the convex hull of the animated mesh
-			rval = CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
-                PhysicsManager::getSingleton()._getNewtonWorld(),
-				entity, /*entity->hasSkeleton(),*/ *orientation, *offset));
-
-            if (inertia != NULL || centerOfMass != NULL )
-            {
-                Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-                boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-                dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-                if( inertia != NULL )
-                    *inertia = temp_inertia*mass;
-                if( centerOfMass != NULL )
-                    *centerOfMass = temp_centerOfMass;
-            }
+            rvalAsConvexCollision = createConvexHull(entity, offset, orientation);
+            rval = rvalAsConvexCollision;
         }
         else if (geomType == GT_MESH)
         {
@@ -876,15 +888,26 @@
                 entity->getName()+"'");
         }
 
+        // calculate inertia / centerOfMass if requested
+        if( rvalAsConvexCollision )
+        {
+            if (inertia != NULL || centerOfMass != NULL )
+            {
+                Vector3 temp_inertia, temp_centerOfMass;
+                rvalAsConvexCollision->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+                if( inertia != NULL )
+                    *inertia = temp_inertia*mass;
+                if( centerOfMass != NULL )
+                    *centerOfMass = temp_centerOfMass;
+            }
+        }
+
         return rval;
     }
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createBox(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset,
-            Ogre::Quaternion* orientation,
-            const Ogre::Real mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass)
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createBox(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
     {
         // offset of the collision primitiv
         Ogre::Vector3 object_offset( aabb.getCenter() );
@@ -898,34 +921,16 @@
 			orientation = &object_orientation;
 
         // a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
-        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             aabb.getSize(), *orientation, *offset));
 
-
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-            if( inertia )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass )
-                *centerOfMass = temp_centerOfMass;
-        }
-
-        return rval;
+       return rval;
     }
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createPyramid(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset,
-            Ogre::Quaternion* orientation,
-            const Ogre::Real mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass)
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createPyramid(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
     {
         Ogre::Vector3 size = aabb.getSize();
         // positional offset of the collision primitiv
@@ -939,34 +944,16 @@
 		if (! orientation)
 			orientation = &object_orientation;
 
-        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             size, *orientation, *offset));
 
-
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-            if( inertia )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass )
-                *centerOfMass = temp_centerOfMass;
-        }
- 
-        return rval;
+       return rval;
     }
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createSphere(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset,
-            Ogre::Quaternion* orientation,
-            const Ogre::Real mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass)
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createSphere(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
     {
         Ogre::Vector3 size = aabb.getSize();
         // calculate the maximum radius needed to include 'everything'
@@ -984,34 +971,16 @@
 			orientation = &object_orientation;
  
         // a sphere primitiv has got its coordinate system at its center, so shift it with radius
-        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             Vector3(radius, radius, radius), *orientation, *offset));
  
-
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-            if( inertia )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass )
-                *centerOfMass = temp_centerOfMass;
-        }
- 
-        return rval;
+       return rval;
     }
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createEllipsoid(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset,
-            Ogre::Quaternion* orientation,
-            const Ogre::Real mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass)
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createEllipsoid(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
     {
         Ogre::Vector3 size = aabb.getSize();
         // set the size x/z values to the maximum
@@ -1030,34 +999,16 @@
 			orientation = &object_orientation;
 
         // an ellipsoid primitiv has got its coordinate system at its center, so shift it with radius
-        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             s, *orientation, *offset));
 
-
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-            if( inertia )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass )
-                *centerOfMass = temp_centerOfMass;
-        }
- 
-        return rval;
+       return rval;
     }
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCapsule(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset,
-            Ogre::Quaternion* orientation,
-            const Ogre::Real mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass)
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createCapsule(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
     {
         Ogre::Vector3 size = aabb.getSize();
         // positional offset of the collision primitiv
@@ -1066,7 +1017,7 @@
 		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
         double radius = std::max(size.x, size.z) / 2.0;
 		double height = size.y;
-        // fixme: this is a semi ugly fix - because the orientation should be set by the loader
+        // @todo: fixme: this is a semi ugly fix - because the orientation should be set by the loader
         object_orientation.FromAngleAxis(Degree(90), Vector3::UNIT_Z);
 
 		// set offset/orientation when they are null
@@ -1083,22 +1034,35 @@
             radius, height, *orientation, *offset));
 
 
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-            if( inertia )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass )
-                *centerOfMass = temp_centerOfMass;
-        }
- 
- 
         return rval;
     }
+
+
+
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createConvexHull(
+            Ogre::Entity* entity,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
+    {
+        // offset of the collision primitiv
+        Ogre::Vector3 object_offset( Ogre::Vector3::ZERO );
+        // orientation of the collision primitiv
+        Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
+
+        // set offset/orientation when they are null
+        if (! offset)
+            offset = &object_offset;
+        if (! orientation)
+            orientation = &object_orientation;
+
+        // calculate the convex hull of the animated mesh
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::ConvexHull(
+                    PhysicsManager::getSingleton()._getNewtonWorld(),
+                    entity, *orientation, *offset));
+
+        return rval;
+    }
+
+
 }
 

Modified: rl/trunk/engine/core/src/SceneQuery.cpp
===================================================================
--- rl/trunk/engine/core/src/SceneQuery.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/src/SceneQuery.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -117,7 +117,11 @@
 
                 // Add actor to this body to the result
 #ifdef OGRENEWT_USE_OGRE_ANY
-                Actor* actor = Ogre::any_cast<Actor*>(body->getUserData());
+                Actor* actor = NULL;
+                if( body->getUserData().getType() == typeid(Actor*) )
+                {
+                    actor = Ogre::any_cast<Actor*>(body->getUserData());
+                }
 #else
                 Actor* actor = static_cast<Actor*>(body->getUserData());
 #endif

Modified: rl/trunk/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -167,7 +167,9 @@
     void CreatureControllerManager::userProcess(OgreNewt::ContactJoint &contactJoint, Real timestep, int threadid)
     {
 #ifdef OGRENEWT_USE_OGRE_ANY
-        Actor *actor = Ogre::any_cast<Actor*>(contactJoint.getBody0()->getUserData());
+        Actor *actor = NULL;
+        if( contactJoint.getBody0()->getUserData().getType() == typeid(Actor*) )
+            actor = Ogre::any_cast<Actor*>(contactJoint.getBody0()->getUserData());
 #else
         Actor *actor = static_cast<Actor*>(contactJoint.getBody0()->getUserData());
 #endif
@@ -183,9 +185,10 @@
 
         // if the controlled body is the second body...
 #ifdef OGRENEWT_USE_OGRE_ANY
-        actor = Ogre::any_cast<Actor*>(contactJoint.getBody0()->getUserData());
+        if( contactJoint.getBody1()->getUserData().getType() == typeid(Actor*) )
+            actor = Ogre::any_cast<Actor*>(contactJoint.getBody1()->getUserData());
 #else
-        actor = static_cast<Actor*>(contactJoint.getBody0()->getUserData());
+        actor = static_cast<Actor*>(contactJoint.getBody1()->getUserData());
 #endif
         if( actor != NULL )
         {

Modified: rl/trunk/engine/rules/src/SelectionHelper.cpp
===================================================================
--- rl/trunk/engine/rules/src/SelectionHelper.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/rules/src/SelectionHelper.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -85,7 +85,9 @@
             if (body != NULL)
             {
 #ifdef OGRENEWT_USE_OGRE_ANY
-                Actor* hitActor = Ogre::any_cast<Actor*>(body->getUserData());
+                Actor* hitActor = NULL;
+                if( body->getUserData().getType() == typeid(Actor*) )
+                    hitActor = Ogre::any_cast<Actor*>(body->getUserData());
 #else
                 Actor* hitActor = static_cast<Actor*>(body->getUserData());
 #endif

Modified: rl/trunk/engine/script/include/EntityNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/EntityNodeProcessor.h	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/script/include/EntityNodeProcessor.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -38,16 +38,6 @@
         virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
 
     private:
-		/// stores already constructed collision proxies for reuse
-        struct AlreadyUsedCollision
-        {
-        public:
-            Ogre::String Type;
-            Ogre::Vector3 Scale;
-            OgreNewt::CollisionPtr ColPtr;
-        };
-
-		std::map<Ogre::String,AlreadyUsedCollision> mAutoCreatedCollisions;
         Ogre::String mResourceGroup;
 
         void createCollision(Ogre::Entity* entity, Ogre::String meshFile, XERCES_CPP_NAMESPACE::DOMElement* physicsProxyElem);

Modified: rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -148,7 +148,6 @@
 			const Quaternion orientation(0,0,0,0);// = parentNode->getOrientation();
 			const Ogre::Vector3 pos = aab.getMinimum() * parentNode->getScale() + (size/2.0);
 
-			//collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(world, size, orientation, pos));
             collision = PhysicsManager::getSingleton().createCollision(entity, GT_BOX, "", NULL, NULL, 0, NULL, NULL, true);
 
 			if ( collision != NULL )

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/script/swig/RlCore.swig	2009-04-14 00:07:38 UTC (rev 4896)
@@ -172,8 +172,6 @@
 public:	
 	enum FogMode { FOG_NONE, FOG_EXP, FOG_EXP2, FOG_LINEAR  };
 
-	void loadScene(const Ogre::String& levelName, const Ogre::String& resourceGroup ) = 0;
-
     virtual void setSkyBox (bool enable, const Ogre::String& materialName, Ogre::Real distance=2500, bool drawFirst=true );
     virtual void setSkyDome (bool enable, const Ogre::String& materialName, Ogre::Real curvature=10, Ogre::Real tiling=8, Ogre::Real distance=4000, bool drawFirst=true );
     virtual void setFog ( FogMode mode=FOG_NONE, const Ogre::ColourValue &colour=Ogre::ColourValue::White, Ogre::Real expDensity=0.001, Ogre::Real linearStart=0.0, Ogre::Real linearEnd=1.0);
@@ -184,6 +182,8 @@
     virtual void setAmbientLight(Ogre::Real r, Ogre::Real g, Ogre::Real b);
     virtual Ogre::Vector3 getStartPoint() const;
     virtual void setCastShadows(bool);
+    virtual void clearScene() = 0;
+    virtual void initializeDefaultCamera() = 0;
 
     void setShowBoundingBoxes( bool dis );
 };
@@ -777,8 +777,8 @@
 public:
     static CoreSubsystem& getSingleton(void);
     
-    void loadMap(const Ogre::String& type, const Ogre::String& filename,
-		const Ogre::String& resourceGroup);
+    // obsolete
+    // void loadMap(const Ogre::String& type, const Ogre::String& filename, const Ogre::String& resourceGroup);
 
 	void registerModule(rl::ContentModule* module);
 

Modified: rl/trunk/engine/ui/include/UiSubsystem.h
===================================================================
--- rl/trunk/engine/ui/include/UiSubsystem.h	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/ui/include/UiSubsystem.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -18,7 +18,6 @@
 #define __UiSubsystem_H__
 
 #include "UiPrerequisites.h"
-#include "World.h"
 
 
 #include "ControlState.h"

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -162,6 +162,7 @@
         //! TODO: remove this workaround (newton-bug: "spheres don't cast"!)
         mCameraCastCollision = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(mCamBody->getWorld(), verts, 80));
         //mCameraCastCollision = new OgreNewt::CollisionPrimitives::Ellipsoid(mCamBody->getWorld(), Vector3::UNIT_SCALE * camRadius);
+        // we could use the real collision of the camera here...
     }
 
     //------------------------------------------------------------------------



From timm at mail.berlios.de  Tue Apr 14 10:19:37 2009
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Tue, 14 Apr 2009 10:19:37 +0200
Subject: [Dsa-hl-svn] r4897 - in rl/branches/persistence2:
	editors/Lockenwickler/src engine/ai/include engine/ai/src
	engine/core engine/core/include engine/core/src
	engine/rules/src engine/script/include engine/script/src
	engine/script/swig engine/ui/include engine/ui/src
Message-ID: <200904140819.n3E8JbNW025843@sheep.berlios.de>

Author: timm
Date: 2009-04-14 10:19:08 +0200 (Tue, 14 Apr 2009)
New Revision: 4897

Added:
   rl/branches/persistence2/engine/core/include/GenericWorld.h
   rl/branches/persistence2/engine/core/src/GenericWorld.cpp
Removed:
   rl/branches/persistence2/engine/core/include/DotSceneOctreeWorld.h
   rl/branches/persistence2/engine/core/src/DotSceneOctreeWorld.cpp
Modified:
   rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py
   rl/branches/persistence2/engine/ai/include/AiSubsystem.h
   rl/branches/persistence2/engine/ai/src/AiSubsystem.cpp
   rl/branches/persistence2/engine/core/CMakeLists.txt
   rl/branches/persistence2/engine/core/RlCore2005.vcproj
   rl/branches/persistence2/engine/core/include/CoreSubsystem.h
   rl/branches/persistence2/engine/core/include/PhysicsManager.h
   rl/branches/persistence2/engine/core/include/World.h
   rl/branches/persistence2/engine/core/src/CoreSubsystem.cpp
   rl/branches/persistence2/engine/core/src/GameAreaTypes.cpp
   rl/branches/persistence2/engine/core/src/GameEventManager.cpp
   rl/branches/persistence2/engine/core/src/PhysicalThing.cpp
   rl/branches/persistence2/engine/core/src/PhysicsManager.cpp
   rl/branches/persistence2/engine/core/src/SceneQuery.cpp
   rl/branches/persistence2/engine/rules/src/CreatureControllerManager.cpp
   rl/branches/persistence2/engine/rules/src/SelectionHelper.cpp
   rl/branches/persistence2/engine/script/include/EntityNodeProcessor.h
   rl/branches/persistence2/engine/script/src/PlaneNodeProcessor.cpp
   rl/branches/persistence2/engine/script/swig/RlCore.swig
   rl/branches/persistence2/engine/ui/include/UiSubsystem.h
   rl/branches/persistence2/engine/ui/src/MovementControlState.cpp
Log:
- merged from trunk and updated vs project

Modified: rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py	2009-04-14 08:19:08 UTC (rev 4897)
@@ -151,7 +151,7 @@
                 rep.data = str(self.editor.dataEditBox.text())
             
             if rep.name in self.propertieDict:
-                reply = QMessageBox.question(QApplication.focusWidget(), "Warning", "Replace the existing property?" , QMessageBox.Yes|QMessageBox.No|QMessageBox.Cancel)
+                reply = QMessageBox.question(QApplication.focusWidget(), "Warning...", "Replace the existing property?" , QMessageBox.Yes|QMessageBox.No|QMessageBox.Cancel)
                 if reply == QMessageBox.Cancel:
                     return
                 elif reply == QMessageBox.Yes:

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-14 08:19:08 UTC (rev 4897)
@@ -280,7 +280,7 @@
         #end remove all the things from the list we actually don't want to be selected
         for item in selItems:
             if str(item.text(0)).startswith("Scene: ") or str(item.text(0)).startswith("Map: ") or str(item.text(0)).startswith("Zone: "):
-                items.remove(item)
+                selItems.remove(item)
         
         for item in selItems:
             parentName =  str(item.text(0))

Modified: rl/branches/persistence2/engine/ai/include/AiSubsystem.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/AiSubsystem.h	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/ai/include/AiSubsystem.h	2009-04-14 08:19:08 UTC (rev 4897)
@@ -20,7 +20,6 @@
 #include "AiPrerequisites.h"
 
 #include "MessagePump.h"
-#include "World.h"
 
 namespace rl
 {

Modified: rl/branches/persistence2/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/AiSubsystem.cpp	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/ai/src/AiSubsystem.cpp	2009-04-14 08:19:08 UTC (rev 4897)
@@ -24,9 +24,7 @@
 #include "GameLoop.h"
 #include "Landmark.h"
 #include "LandmarkPath.h"
-#include "Logger.h"
 #include "WayPointGraphManager.h"
-#include "World.h"
 
 #include <xercesc/util/PlatformUtils.hpp>
 

Modified: rl/branches/persistence2/engine/core/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/core/CMakeLists.txt	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/core/CMakeLists.txt	2009-04-14 08:19:08 UTC (rev 4897)
@@ -25,7 +25,6 @@
 src/CoreSubsystem.cpp
 src/DebugVisualisable.cpp
 src/DebugVisualsManager.cpp
-src/DotSceneOctreeWorld.cpp
 src/FadeAnimation.cpp
 src/GameAreaEvent.cpp
 src/GameAreaEventSource.cpp
@@ -33,6 +32,7 @@
 src/GameAreaTypes.cpp
 src/GameEventManager.cpp
 src/GameLoop.cpp
+src/GenericWorld.cpp
 src/Job.cpp
 src/JobQueue.cpp
 src/JobScheduler.cpp

Modified: rl/branches/persistence2/engine/core/RlCore2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/core/RlCore2005.vcproj	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/core/RlCore2005.vcproj	2009-04-14 08:19:08 UTC (rev 4897)
@@ -416,10 +416,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\DotSceneOctreeWorld.h"
-				>
-			</File>
-			<File
 				RelativePath=".\include\FadeAnimation.h"
 				>
 			</File>
@@ -448,6 +444,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\GenericWorld.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\Job.h"
 				>
 			</File>
@@ -789,10 +789,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\src\DotSceneOctreeWorld.cpp"
-				>
-			</File>
-			<File
 				RelativePath=".\src\FadeAnimation.cpp"
 				>
 			</File>
@@ -821,6 +817,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\GenericWorld.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\Job.cpp"
 				>
 			</File>

Modified: rl/branches/persistence2/engine/core/include/CoreSubsystem.h
===================================================================
--- rl/branches/persistence2/engine/core/include/CoreSubsystem.h	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/core/include/CoreSubsystem.h	2009-04-14 08:19:08 UTC (rev 4897)
@@ -23,6 +23,7 @@
 #include "EventSource.h"
 #include "EventCaster.h"
 #include "CorePrerequisites.h"
+#include "World.h"
 
 namespace rl {
 
@@ -72,6 +73,9 @@
 
     World* getWorld();
 
+    // obsolete
+    // void loadMap(const Ogre::String& type, const Ogre::String& filename, const Ogre::String& module);
+
     RubyInterpreter* getRubyInterpreter();
 
     ContentModule* getActiveAdventureModule() const;
@@ -159,8 +163,8 @@
     void unloadPlugins();
 
     /**
-     * Sammelt alle Default-Techniques, um sie sp?ter bei jedem aktivierten Scheme
-     * benutzen zu k?nnen
+     * Sammelt alle Default-Techniques, um sie sp???ter bei jedem aktivierten Scheme
+     * benutzen zu k??nnen
      */
     void updateDefaultScheme();
 

Deleted: rl/branches/persistence2/engine/core/include/DotSceneOctreeWorld.h
===================================================================
--- rl/branches/persistence2/engine/core/include/DotSceneOctreeWorld.h	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/core/include/DotSceneOctreeWorld.h	2009-04-14 08:19:08 UTC (rev 4897)
@@ -1,38 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __DotSceneOctreeWorld_H__
-#define __DotSceneOctreeWorld_H__
-
-#include "World.h"
-
-#include "CorePrerequisites.h"
-
-namespace rl {
-
-    class _RlCoreExport DotSceneOctreeWorld : public World
-    {
-    public:
-        DotSceneOctreeWorld();
-        ~DotSceneOctreeWorld();
-
-        virtual void clearScene();
-        virtual void initializeDefaultCamera();	
-		virtual void setCastShadows(bool enabled);
-    };
-
-}
-#endif

Copied: rl/branches/persistence2/engine/core/include/GenericWorld.h (from rev 4896, rl/trunk/engine/core/include/GenericWorld.h)

Modified: rl/branches/persistence2/engine/core/include/PhysicsManager.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicsManager.h	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/core/include/PhysicsManager.h	2009-04-14 08:19:08 UTC (rev 4897)
@@ -141,7 +141,7 @@
 		/// Komplette Levelgeometrie aufl?sen
 		void clearLevelGeometry();
 		
-	void toggleDebugMode();
+        void toggleDebugMode();
         int isDebugMode() const;
 
         // Newton callbacks ...
@@ -207,75 +207,30 @@
         void resetMaterialPair( const OgreNewt::MaterialID* M1,
             const OgreNewt::MaterialID* M2);
 
-        /** creates a collision primitive for OgreNewt.
-		 * The collision primitive created has got a basic orientation which can be influenced by
-		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
-		 * calculated according to the size and type of collision primitiv.
-         * Whenever any of the parameters is a null pointer, it is ignored.
-         * The created collision primitive gets cached for the given mesh,
-         * so whenever an other entity with the same mesh tries to fetch
-         * a collision primitive here, then it gets back the already existing
-         * one (no need to duplicate).
-		 * @param entity gives the mesh entity that needs a collision primitive
-         * @param geomType defines the geometry of the collision type
-         * @param offset Vector3 gives the offset of the coordinate system of the coll. primitiv
-		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
-         * @param mass gives the mass of the collision primitive used for calculating the inertia
-		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
-		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
-         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
-         *                the new collision is not added to the cache
-		*/
+        /// calls PhysicsCollisionFactory::createCollisionFromEntity
 		OgreNewt::CollisionPtr createCollision(
 			Ogre::Entity* entity,
             const GeometryType& geomType = GT_NONE,
-            const Ogre::String animName = "",
-			Ogre::Vector3* offset = NULL,
-			Ogre::Quaternion* orientation = NULL,
+            const Ogre::String& animName = "",
+			const Ogre::Vector3* offset = NULL,
+			const Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
             Ogre::Vector3* inertia = NULL,
             Ogre::Vector3* centerOfMass = NULL,
             bool nocache = false);
 
-        /** creates a collision primitive for OgreNewt.
-		 * The collision primitive created has got a basic orientation which can be influenced by
-		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
-		 * calculated according to the size and type of collision primitiv.
-         * Whenever any of the parameters is a null pointer, it is ignored.
-         * The created collision primitive gets cached for the given aabb,
-         * so whenever an other aabb with the same name tries to fetch
-         * a collision primitive here, then it gets back the already existing
-         * one (no need to duplicate).
-		 * @param aabb AxisAlignedBox that contains the extents for the collision primitive to be created
-         * @param name gives the name of the AxisAlignedBox
-         * @param geomType defines the geometry of the collision type
-         * @param offset Vector3 gives the offset of the coordinate system of the coll. primitiv
-		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
-         * @param mass gives the mass of the collision primitive used for calculating the inertia
-		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
-		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
-         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
-         *                the new collision is not added to the cache
-		*/
+        /// calls PhysicsCollisionFactory::createCollisionFromAABB
         OgreNewt::CollisionPtr createCollision(
             const Ogre::String& name,
             const Ogre::AxisAlignedBox& aabb,
             const GeometryType& geomType = GT_NONE,
-            Ogre::Vector3* offset = NULL,
-			Ogre::Quaternion* orientation = NULL,
+            const Ogre::Vector3* offset = NULL,
+			const Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
             Ogre::Vector3* inertia = NULL,
             Ogre::Vector3* centerOfMass = NULL,
             bool nocache = false);
 
-        /** Makes the collision primitive generation available to non mesh objects.
-         * Non mesh objects need collision objects too. Therefore they can
-         * utilise this function for bypassing the caching mechanism of
-         * PhysicalManager.
-         * @returns a collision primitive creating factory object.
-         */
-        PhysicsCollisionFactory* getCollisionFactory();
-
         /** converts a string identifying a collision property into an enum.
          * Mainly for making string definitions of the collision property
          * possible in .gof files.
@@ -294,30 +249,6 @@
         OgreNewt::Debugger* getNewtonDebugger() {return &mWorld->getDebugger();}
 
     private:
-
-        /** structure containing further information about the collision primitive.
-         * Actually this information should go into either the collisionptr or the
-         * object for the primitive ...
-         */
-        struct CollisionInUse
-        {
-        public:
-            CollisionInUse() :
-#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
-                colPtr(NULL),
-#endif
-                geomType(GT_NONE) {}
-            GeometryType geomType;  //! primitive type
-            OgreNewt::CollisionPtr colPtr;          //! the collision primitve
-        };
-
-        /** shortens definition of a list of collision primitives.
-         * currently only one geometry type per entity (mesh) is allowed.
-         * if multiple should be possible, the geometry type should be
-         * moved from the above struct into the key.
-         */
-        typedef std::map< std::string, CollisionInUse > CollisionMap;
-
         bool mEnabled;
         //! the globally used physical representation of the world by Newton
         OgreNewt::World* mWorld;
@@ -326,8 +257,6 @@
 
         //! factory for creating new collision primitives
         PhysicsCollisionFactory* mPhysicsCollisionFactory;
-        //! a list of collision primitives
-        CollisionMap mCollisionPrimitives;
 
         //! a list of objects of the physical world
         std::vector<PhysicalThing*> mPhysicalThings;
@@ -391,139 +320,248 @@
     class PhysicsCollisionFactory
     {
     public:
-        /** checks if the specified size is ok for OgreNewt
-         * @param aabb check the aabb's size
-         */
-        bool checkSize(const Ogre::AxisAlignedBox& aabb) const;
-        /** corrects the specified size if it is not ok for OgreNewt
-         * @param aabb correct the aabb's size
-         */
-        void correctSize(Ogre::AxisAlignedBox& aabb);
-        /** calculates the Inertia for the given primitive type
-         */
-        //Ogre::Vector3 calculateIntertia(const Ogre::Real& Mass, Ogre::Vector3* inertiaCoefficients);
+        //! destructor, releases the collisions from the collision cache
+        ~PhysicsCollisionFactory();
 
-        /** creates a collision primitive for OgreNewt an Ogre::Entity.
+        /** creates a collision primitive for OgreNewt from an Ogre::Entity.
 		 * The collision primitive created has got a basic orientation which can be influenced by
-		 * offset and orientation parameters.
+		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
+		 * calculated according to the size and type of collision primitiv.
          * Whenever any of the parameters is a null pointer, it is ignored.
+         * The created collision primitive gets cached for the given mesh,
+         * so whenever an other entity with the same mesh tries to fetch
+         * a collision primitive here, then it gets back the already existing
+         * one (no need to duplicate).
+         * 
          * Scaling should be implemented through attaching to a scene node.
          * if that is not the case, we'll have to fix OgreNewt ...
-		 * @param entity Ogre::Entity mesh object
+		 * @param entity gives the mesh entity that needs a collision primitive
 		 * @param geomType specifies the type of collision primitiv to create.
 		 * @param offset gives the offset of the coordinate system of the coll. primitiv
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
 		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
+         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
+         *                the new collision is not added to the cache
 		*/
-        OgreNewt::CollisionPtr createCollisionFromEntity(Ogre::Entity* entity,
+        OgreNewt::CollisionPtr createCollisionFromEntity(
+            Ogre::Entity* entity,
             const GeometryType& geomType,
-            Ogre::Vector3* offset = NULL, 
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real Mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation,
+            const Ogre::Real Mass,
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass,
+            bool nocache);
 
-        /** creates a collision primitive for OgreNewt from an AABB box.
+        /** creates a collision primitive for OgreNewt.
 		 * The collision primitive created has got a basic orientation which can be influenced by
-		 * offset and orientation parameters.
+		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
+		 * calculated according to the size and type of collision primitiv.
          * Whenever any of the parameters is a null pointer, it is ignored.
+         * The created collision primitive gets cached for the given aabb,
+         * so whenever an other aabb with the same name tries to fetch
+         * a collision primitive here, then it gets back the already existing
+         * one (no need to duplicate). There's no difference between Collisions created through an aabb or through
+         * the entity in the cache. In order to supply a support for 'scaling' the size of the cached collision is
+         * checked.
          * Since no entity is given several physical collision primitives are not
          * possible (convexhull, tree, etc.)
-         * Scaling should be implemented through attaching to a scene node.
-         * if that is not the case, we'll have to fix OgreNewt ...
-		 * @param entity Ogre::Entity mesh object
+         * // no scaling at the moment, the correct scale must be given (OgreNewt cannot scale a collision, this is a limitation
+         * // of newton. It is only possible to 'scale' a convex collision by created a ConvexHullModifier (a new collision,
+         * // that uses the old one and applies transformation through a matrix), so for aabbs (-> convex collisions) a scale
+         * // that udpates with the scale of the node could be implemented, but as this would be different for treecollisions,
+         * // it is better to create a collision with the correct scale...
+         * // "Scaling should be implemented through attaching to a scene node.
+         * // if that is not the case, we'll have to fix OgreNewt ..."
+         * @param name gives the name of the AxisAlignedBox
+		 * @param aabb AxisAlignedBox that contains the extents for the collision primitive to be created
 		 * @param geomType specifies the type of collision primitiv to create.
 		 * @param offset gives the offset of the coordinate system of the coll. primitiv
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
 		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
+         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
+         *                the new collision is not added to the cache
 		*/
-        OgreNewt::CollisionPtr createCollisionFromAABB(const Ogre::AxisAlignedBox aabb,
+        OgreNewt::CollisionPtr createCollisionFromAABB(
+            const Ogre::String& name,
+            const Ogre::AxisAlignedBox& aabb,
             const GeometryType& geomType,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real Mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation,
+            const Ogre::Real Mass,
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass,
+            bool nocache);
+
+        /// clear the collision cache
+        void clearCollisionCache();
+
     protected:
+        /** checks if the specified size is ok for OgreNewt
+         * @param aabb check the aabb's size
+         */
+        bool checkSize(const Ogre::AxisAlignedBox& aabb) const;
+
+        /** corrects the specified size if it is not ok for OgreNewt
+         * @param aabb correct the aabb's size
+         */
+        void correctSize(Ogre::AxisAlignedBox& aabb);
+
         /** creates a box collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
          * @param offset when not null, specifies a different offset than the standard.
          * @param orientation when not null, specifies the euler angle of orientation.
-         * @param mass gives the mass for inertia calculation.
-         * @param inertia when not null, an inertia is calculated and passed back.
-         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
-        OgreNewt::CollisionPtr createBox(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+        OgreNewt::ConvexCollisionPtr createBox(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
         /** creates a pyramid collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
          * @param offset when not null, specifies a different offset than the standard.
          * @param orientation when not null, specifies the euler angle of orientation.
-         * @param mass gives the mass for inertia calculation.
-         * @param inertia when not null, an inertia is calculated and passed back.
-         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
-        OgreNewt::CollisionPtr createPyramid(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+        OgreNewt::ConvexCollisionPtr createPyramid(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
         /** creates a sphere collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
          * @param offset when not null, specifies a different offset than the standard.
          * @param orientation when not null, specifies the euler angle of orientation.
-         * @param mass gives the mass for inertia calculation.
-         * @param inertia when not null, an inertia is calculated and passed back.
-         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
-        OgreNewt::CollisionPtr createSphere(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+        OgreNewt::ConvexCollisionPtr createSphere(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
         /** creates a ellipsoid collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
          * @param offset when not null, specifies a different offset than the standard.
          * @param orientation when not null, specifies the euler angle of orientation.
-         * @param mass gives the mass for inertia calculation.
-         * @param inertia when not null, an inertia is calculated and passed back.
-         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
-        OgreNewt::CollisionPtr createEllipsoid(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+        OgreNewt::ConvexCollisionPtr createEllipsoid(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
         /** creates a capsule collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
          * @param offset when not null, specifies a different offset than the standard.
          * @param orientation when not null, specifies the euler angle of orientation.
-         * @param mass gives the mass for inertia calculation.
-         * @param inertia when not null, an inertia is calculated and passed back.
-         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
-        OgreNewt::CollisionPtr createCapsule(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+        OgreNewt::ConvexCollisionPtr createCapsule(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
+        /** creates a convex-hull collision primitive with offset at middle of bottom layer.
+         * It's actually a convenience function used by createCollisionFromEntity
+         * @param entity the entity for which a convexhull should be created, if it is attached to
+         *               a node the scale of the node is used (see OgreNewt)
+         * @param offset when not null, specifies a different offset than the standard.
+         * @param orientation when not null, specifies the euler angle of orientation.
+         */
+        OgreNewt::ConvexCollisionPtr createConvexHull(
+            Ogre::Entity* entity,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
+
+        //! class for caching convex collisions (box...convexhull), saves additionally the scale, so it can be rescaled if necessary
+        class ConvexCollisionCacheObject
+        {
+            public:
+                ConvexCollisionCacheObject() :
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+                    col(NULL),
+#endif
+                    scale(Ogre::Vector3::ZERO),
+                    type(GT_NONE)
+                    {}
+                OgreNewt::ConvexCollisionPtr col;
+                Ogre::Vector3 scale;
+                GeometryType type;
+        };
+
+        typedef std::map<Ogre::String, ConvexCollisionCacheObject> ConvexCollisionCacheMap;
+
+        //! cache for convex collisions
+        ConvexCollisionCacheMap mConvexCollisionsCache;
+
+        //! for using a string and a vector as key in a map... we should implement here a hash-function
+        class StringVector
+        {
+            public:
+                StringVector(const Ogre::String& str, const Ogre::Vector3& vec) : mStr(str)
+                {
+                    setVector(vec);
+                }
+                void setString(const Ogre::String& str) {mStr = str;}
+                void setVector(const Ogre::Vector3& vec)
+                {
+                    mVec = vec;
+                }
+                const Ogre::String& getString() const {return mStr;}
+                const Ogre::Vector3& getVector() const {return mVec;}
+
+                bool operator==(const StringVector& strVec) const
+                {
+                    if( mStr != strVec.mStr )
+                        return false;
+
+                    Ogre::Vector3 diff = mVec - strVec.mVec;
+                    if( abs(diff.x) > 0.01 )
+                        return false;
+                    if( abs(diff.y) > 0.01 )
+                        return false;
+                    if( abs(diff.z) > 0.01 )
+                        return false;
+
+                    return true;
+                }
+
+                bool operator<(const StringVector& strVec) const
+                {
+                    int strCompare = mStr.compare(strVec.mStr);
+                    if( strCompare == 0 ) // strings are the same
+                    {
+                        // compare vectors
+                        Ogre::Vector3 diff = mVec - strVec.mVec;
+                        if( diff.x < -0.01 )
+                            return true;
+                        if( diff.x > 0.01 )
+                            return false;
+                        if( diff.y < -0.01 )
+                            return true;
+                        if( diff.y > 0.01 )
+                            return false;
+                        if( diff.y < -0.01 )
+                            return true;
+
+                        return false;
+                    }
+                    
+                    return strCompare < 0;
+                }
+            private:
+                Ogre::String mStr;
+                Ogre::Vector3 mVec;
+        };
+
+        typedef std::map<StringVector, OgreNewt::CollisionPtr> MeshCollisionCacheMap;
+
+        //! cache for mesh collisions
+        MeshCollisionCacheMap mMeshCollisionsCache;
+
+
+
     };
 }
 

Modified: rl/branches/persistence2/engine/core/include/World.h
===================================================================
--- rl/branches/persistence2/engine/core/include/World.h	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/core/include/World.h	2009-04-14 08:19:08 UTC (rev 4897)
@@ -43,6 +43,9 @@
 
         virtual void clearScene(void) = 0;
 
+        // obsolete
+        //virtual void loadScene(const Ogre::String& levelName, const Ogre::String& module) = 0;
+
         //Enables / disables a 'sky plane' i.e.
         virtual void setSkyPlane(bool enable, const Ogre::Plane &plane,
             const Ogre::String &materialName,

Modified: rl/branches/persistence2/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/CoreSubsystem.cpp	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/core/src/CoreSubsystem.cpp	2009-04-14 08:19:08 UTC (rev 4897)
@@ -26,7 +26,7 @@
 #include "ContentModule.h"
 #include "ConfigurationManager.h"
 #include "DebugVisualsManager.h"
-#include "DotSceneOctreeWorld.h"
+#include "GenericWorld.h"
 #include "Exception.h"
 #include "GameEventManager.h"
 #include "GameLoop.h"
@@ -288,7 +288,7 @@
                 "Video", "Max Anisotropy"));
 
 
-        mWorld = new DotSceneOctreeWorld();
+        mWorld = new GenericWorld();
         mActorManager->setWorld(mWorld);
 
         mPhysicsManager = new PhysicsManager();  // the World needs to be initialized before!
@@ -579,7 +579,7 @@
         return mModules;
     }
 
-    void CoreSubsystem::loadPlugin(const Ogre::String& plugin)
+    void CoreSubsystem::loadPlugin(const Ogre::String& plugin)
     {
         Ogre::String pluginFile;
         

Deleted: rl/branches/persistence2/engine/core/src/DotSceneOctreeWorld.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/DotSceneOctreeWorld.cpp	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/core/src/DotSceneOctreeWorld.cpp	2009-04-14 08:19:08 UTC (rev 4897)
@@ -1,121 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-// Xerces geht vor allen Ogre includes...
-#include "XmlResourceManager.h"
-
-#include "DotSceneOctreeWorld.h"
-
-
-#include "CoreSubsystem.h"
-#include "ConfigurationManager.h"
-#include "ActorManager.h"
-#include "Actor.h"
-#include "PhysicsManager.h"
-#include "ZoneManager.h"
-
-using namespace Ogre;
-
-namespace rl {
-
-    DotSceneOctreeWorld::DotSceneOctreeWorld( )
-        :   World(ST_GENERIC)
-    {
-        mSceneFile = "";
-    }
-
-    DotSceneOctreeWorld::~DotSceneOctreeWorld()
-    {
-        clearScene();
-    }
-
-    void DotSceneOctreeWorld::initializeDefaultCamera(void)
-    {
-        if (mCamera == 0)
-        {
-            // Kamera erstellen..
-            Actor* actor = ActorManager::getSingleton().createCameraActor("DefaultCamera");
-            // und initialisieren.
-            mCamera = mSceneMgr->getCamera("DefaultCamera");
-
-            mCamera->setPosition( getStartPoint() );
-            mCamera->setFOVy(Degree(60));
-            mCamera->setFixedYawAxis(true);
-            mCamera->setAutoAspectRatio(true);
-
-            actor->placeIntoScene();
-
-			// Ein Viewport, das komplette Fenster
-			Viewport* newVp = CoreSubsystem::getSingleton().getRenderWindow()->addViewport(mCamera, 1);
-
-			// Schwarzer Hintergrund
-			newVp->setBackgroundColour(ColourValue(0,0,0));
-		}
-    }
-
-    void DotSceneOctreeWorld::clearScene()
-    {
-        fireBeforeClearScene();
-
-        // This is necessary to destroy cameras too.
-        CoreSubsystem::getSingleton().getRenderWindow()->removeAllViewports();
-        ZoneManager::getSingleton().destroyAllZones();
-        ActorManager::getSingleton().destroyAllActors();
-        mSceneMgr->clearScene();
-        PhysicsManager::getSingleton().clearLevelGeometry();
-
-        mSceneFile = "";
-        mCamera = NULL;
-    }
-
-    void DotSceneOctreeWorld::setCastShadows(bool enabled)
-    {
-		bool castShadows = false;
-
-		if( enabled )
-		{
-			Ogre::String tmp =
-				ConfigurationManager::getSingleton().getStringSetting(
-					"Video", "Cast Shadows" );
-
-			if (tmp == "yes")
-				castShadows = true;
-			else if (tmp == "no")
-				castShadows = false;
-		}
-
-		/// @todo Settings for multiple Shadow-Types?
-		if( castShadows )
-		{
-			int textureSize =
-				ConfigurationManager::getSingleton().getIntSetting(
-					"Video", "Shadow Texture Size" );
-			textureSize = std::max( 64, std::min( 4096, textureSize ) );
-
-			mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_MODULATIVE);
-			mSceneMgr->setShadowTextureSize( textureSize );
-			mSceneMgr->setShadowColour(ColourValue(0.7, 0.7, 0.7));
-			mSceneMgr->setShadowFarDistance(8.0f);
-			mSceneMgr->setShadowDirLightTextureOffset(0.8f);
-            mSceneMgr->setShadowCameraSetup((Ogre::ShadowCameraSetupPtr) new Ogre::LiSPSMShadowCameraSetup());
-		}
-		else
-		{
-			mSceneMgr->setShadowTechnique( SHADOWTYPE_NONE);
-		}
-    }
-}

Modified: rl/branches/persistence2/engine/core/src/GameAreaTypes.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/GameAreaTypes.cpp	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/core/src/GameAreaTypes.cpp	2009-04-14 08:19:08 UTC (rev 4897)
@@ -237,8 +237,8 @@
             geomType = GT_CONVEXHULL;
         }
         OgreNewt::CollisionPtr col =
-            PhysicsManager::getSingleton().getCollisionFactory()->createCollisionFromEntity(entity,
-            geomType, &offset, &orientation);
+            PhysicsManager::getSingleton().createCollision(entity,
+            geomType, "", &offset, &orientation);
         mBody = new OgreNewt::Body(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             col);
@@ -262,8 +262,8 @@
             Ogre::Quaternion orientation)
     {
         OgreNewt::CollisionPtr col =
-            PhysicsManager::getSingleton().getCollisionFactory()->createCollisionFromAABB(
-            aabb, geomType, &offset, &orientation);
+            PhysicsManager::getSingleton().createCollision(
+            "", aabb, geomType, &offset, &orientation, 0, NULL, NULL, true);
         mBody = new OgreNewt::Body(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             col);

Modified: rl/branches/persistence2/engine/core/src/GameEventManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/GameEventManager.cpp	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/core/src/GameEventManager.cpp	2009-04-14 08:19:08 UTC (rev 4897)
@@ -309,7 +309,10 @@
     Actor* GameEventManager::bodyToActor(OgreNewt::Body* body)
     {
 #ifdef OGRENEWT_USE_OGRE_ANY
-        return Ogre::any_cast<Actor*>(body->getUserData());
+        if( body->getUserData().getType() == typeid(Actor*) )
+            return Ogre::any_cast<Actor*>(body->getUserData());
+        else
+            return NULL;
 #else
         return static_cast<Actor*>(body->getUserData());
 #endif

Copied: rl/branches/persistence2/engine/core/src/GenericWorld.cpp (from rev 4896, rl/trunk/engine/core/src/GenericWorld.cpp)

Modified: rl/branches/persistence2/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicalThing.cpp	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/core/src/PhysicalThing.cpp	2009-04-14 08:19:08 UTC (rev 4897)
@@ -524,7 +524,8 @@
         else
         {
             const AxisAlignedBox& aabb = mPhysicalObject->getDefaultSize();
-            coll = PhysicsManager::getSingleton().getCollisionFactory()->createCollisionFromAABB(
+            coll = PhysicsManager::getSingleton().createCollision(
+                "", // @todo: can we use a name here?
                 aabb,
                 mGeometryType,
                 NULL,

Modified: rl/branches/persistence2/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicsManager.cpp	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/core/src/PhysicsManager.cpp	2009-04-14 08:19:08 UTC (rev 4897)
@@ -113,9 +113,6 @@
 
     PhysicsManager::~PhysicsManager()
     {
-        // simply remove all collision ptrs (is this really ok?)
-        mCollisionPrimitives.clear();
-
         // remove all material-pairs
         for (MaterialPairMap::iterator it = mMaterialPairs.begin(); it != mMaterialPairs.end(); it++)
         {
@@ -520,10 +517,13 @@
 
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
         Ogre::Entity* entity, const GeometryType& geomType,
-		const Ogre::String animName, Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
+		const Ogre::String& animName, const Ogre::Vector3* offset,
+        const Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
         Ogre::Vector3* centerOfMass, bool nocache)
     {
+        return mPhysicsCollisionFactory->createCollisionFromEntity(
+                entity, geomType, offset, orientation, mass, inertia, centerOfMass, nocache );
+/*
         // problem here is that a mesh can have different animations with
         // different extents. Therefore we add the animName to the meshname
         // to compute a unique name for the collision primitiv.
@@ -566,14 +566,18 @@
         }
 
         return rval;
+*/
     }
 
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
         const Ogre::String& name, const Ogre::AxisAlignedBox& aabb,
-        const GeometryType& geomType, Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
+        const GeometryType& geomType, const Ogre::Vector3* offset,
+        const Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
         Ogre::Vector3* centerOfMass, bool nocache)
     {
+        return mPhysicsCollisionFactory->createCollisionFromAABB(
+                name, aabb, geomType, offset, orientation, mass, inertia, centerOfMass, nocache );
+/*
         // result value
         CollisionPtr rval;
 #ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
@@ -610,13 +614,9 @@
         }
 
         return rval;
+*/
     }
 
-    PhysicsCollisionFactory* PhysicsManager::getCollisionFactory()
-    {
-        return mPhysicsCollisionFactory;
-    }
-
 	GeometryType PhysicsManager::convertStringToGeometryType(const Ogre::String& geomTypeString)
 	{
 		if (geomTypeString == "box")
@@ -657,6 +657,17 @@
 		return typestr;
 	}
 
+    PhysicsCollisionFactory::~PhysicsCollisionFactory()
+    {
+        clearCollisionCache();
+    }
+
+    void PhysicsCollisionFactory::clearCollisionCache()
+    {
+        mMeshCollisionsCache.clear();
+        mConvexCollisionsCache.clear();
+    }
+
     bool PhysicsCollisionFactory::checkSize(const Ogre::AxisAlignedBox& aabb) const
     {
         Ogre::Vector3 size = aabb.getSize();
@@ -690,20 +701,23 @@
     }
     */
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(const Ogre::AxisAlignedBox passedAabb,
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(
+        const Ogre::String& name,
+        const Ogre::AxisAlignedBox& passedAabb,
         const GeometryType& geomType,
-        Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation,
-        const Ogre::Real Mass,
+        const Ogre::Vector3* offset,
+        const Ogre::Quaternion* orientation,
+        const Ogre::Real mass,
         Ogre::Vector3* inertia,
-        Ogre::Vector3* centerOfMass)
+        Ogre::Vector3* centerOfMass,
+        bool nocache)
     {
         Ogre::AxisAlignedBox aabb(passedAabb);
         // type for the collision primitiv (can change internally here)
         bool forceBox (false);
 
         // result value
-        CollisionPtr rval;
+        ConvexCollisionPtr rval;
 #ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
         rval = NULL;
 #endif
@@ -738,44 +752,64 @@
 	    */
 		if (geomType == GT_BOX || forceBox == true)
         {
-			rval = createBox(aabb, offset, orientation, Mass, inertia, centerOfMass);
+			rval = createBox(aabb, offset, orientation);
         }
         else if (geomType == GT_PYRAMID)
         {
-            rval = createPyramid(aabb, offset, orientation, Mass, inertia, centerOfMass);
+            rval = createPyramid(aabb, offset, orientation);
         }
         else if (geomType == GT_SPHERE)
         {
-			rval = createSphere(aabb, offset, orientation, Mass, inertia, centerOfMass);
+			rval = createSphere(aabb, offset, orientation);
         }
         else if (geomType == GT_ELLIPSOID)
         {
-            rval = createEllipsoid(aabb, offset, orientation, Mass, inertia, centerOfMass);
+            rval = createEllipsoid(aabb, offset, orientation);
         }
 		else if (geomType == GT_CAPSULE)
 		{
-			rval = createCapsule(aabb, offset, orientation, Mass, inertia, centerOfMass);
+			rval = createCapsule(aabb, offset, orientation);
 		}
+
+        // calculate inertia / centerOfMass if needed
+        if (inertia != NULL || centerOfMass != NULL )
+        {
+            Vector3 temp_inertia, temp_centerOfMass;
+            rval->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+            if( inertia != NULL )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass != NULL )
+                *centerOfMass = temp_centerOfMass;
+        }
+
         return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromEntity(Ogre::Entity* entity,
         const GeometryType& geomType,
-        Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation,
+        const Ogre::Vector3* offset,
+        const Ogre::Quaternion* orientation,
         const Ogre::Real mass,
         Ogre::Vector3* inertia,
-        Ogre::Vector3* centerOfMass)
+        Ogre::Vector3* centerOfMass,
+        bool nocache)
     {
         // bounding box of the mesh
         Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
+        // apply scale if attached to a node (like in OgreNewt for convexhull)
+        if( entity->getParentNode() )
+            aabb.scale(entity->getParentNode()->getScale());
+
         // type for the collision primitiv (can change internally here)
         bool forceBox (false);
 
         // result value
         CollisionPtr rval;
+        ConvexCollisionPtr rvalAsConvexCollision; // store pointer to ConvexCollision, so we don't need to cast
+                                                  // this also indicates, that it is possible to calculate inertia/centerOfMass
 #ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
         rval = NULL;
+        rvalAsConvexCollision = NULL;
 #endif
 
         // size check (if object is too small, it falls back to a box primitiv
@@ -797,55 +831,33 @@
 	    */
 		if (geomType == GT_BOX || forceBox == true)
         {
-			rval = createBox(aabb, offset, orientation, mass, inertia, centerOfMass);
+            rvalAsConvexCollision = createBox(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
         }
         else if (geomType == GT_PYRAMID)
         {
-            rval = createPyramid(aabb, offset, orientation, mass, inertia, centerOfMass);
+            rvalAsConvexCollision = createPyramid(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
         }
         else if (geomType == GT_SPHERE)
         {
-			rval = createSphere(aabb, offset, orientation, mass, inertia, centerOfMass);
+            rvalAsConvexCollision = createSphere(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
         }
         else if (geomType == GT_ELLIPSOID)
         {
-            rval = createEllipsoid(aabb, offset, orientation, mass, inertia, centerOfMass);
+            rvalAsConvexCollision = createEllipsoid(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
         }
 		else if (geomType == GT_CAPSULE)
 		{
-			rval = createCapsule(aabb, offset, orientation, mass, inertia, centerOfMass);
+            rvalAsConvexCollision = createCapsule(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
 		}
         else if (geomType == GT_CONVEXHULL)
         {
-            // offset of the collision primitiv
-	    	Ogre::Vector3 object_offset( Ogre::Vector3::ZERO );
-            // orientation of the collision primitiv
-		    Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
-
-            // set offset/orientation when they are null
-			if (! offset)
-				offset = &object_offset;
-			if (! orientation)
-				orientation = &object_orientation;
-
-			// calculate the convex hull of the animated mesh
-			rval = CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
-                PhysicsManager::getSingleton()._getNewtonWorld(),
-				entity, /*entity->hasSkeleton(),*/ *orientation, *offset));
-
-            if (inertia != NULL || centerOfMass != NULL )
-            {
-                Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-                boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-                dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-                if( inertia != NULL )
-                    *inertia = temp_inertia*mass;
-                if( centerOfMass != NULL )
-                    *centerOfMass = temp_centerOfMass;
-            }
+            rvalAsConvexCollision = createConvexHull(entity, offset, orientation);
+            rval = rvalAsConvexCollision;
         }
         else if (geomType == GT_MESH)
         {
@@ -876,15 +888,26 @@
                 entity->getName()+"'");
         }
 
+        // calculate inertia / centerOfMass if requested
+        if( rvalAsConvexCollision )
+        {
+            if (inertia != NULL || centerOfMass != NULL )
+            {
+                Vector3 temp_inertia, temp_centerOfMass;
+                rvalAsConvexCollision->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+                if( inertia != NULL )
+                    *inertia = temp_inertia*mass;
+                if( centerOfMass != NULL )
+                    *centerOfMass = temp_centerOfMass;
+            }
+        }
+
         return rval;
     }
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createBox(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset,
-            Ogre::Quaternion* orientation,
-            const Ogre::Real mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass)
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createBox(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
     {
         // offset of the collision primitiv
         Ogre::Vector3 object_offset( aabb.getCenter() );
@@ -898,34 +921,16 @@
 			orientation = &object_orientation;
 
         // a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
-        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             aabb.getSize(), *orientation, *offset));
 
-
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-            if( inertia )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass )
-                *centerOfMass = temp_centerOfMass;
-        }
-
-        return rval;
+       return rval;
     }
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createPyramid(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset,
-            Ogre::Quaternion* orientation,
-            const Ogre::Real mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass)
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createPyramid(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
     {
         Ogre::Vector3 size = aabb.getSize();
         // positional offset of the collision primitiv
@@ -939,34 +944,16 @@
 		if (! orientation)
 			orientation = &object_orientation;
 
-        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             size, *orientation, *offset));
 
-
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-            if( inertia )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass )
-                *centerOfMass = temp_centerOfMass;
-        }
- 
-        return rval;
+       return rval;
     }
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createSphere(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset,
-            Ogre::Quaternion* orientation,
-            const Ogre::Real mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass)
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createSphere(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
     {
         Ogre::Vector3 size = aabb.getSize();
         // calculate the maximum radius needed to include 'everything'
@@ -984,34 +971,16 @@
 			orientation = &object_orientation;
  
         // a sphere primitiv has got its coordinate system at its center, so shift it with radius
-        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             Vector3(radius, radius, radius), *orientation, *offset));
  
-
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-            if( inertia )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass )
-                *centerOfMass = temp_centerOfMass;
-        }
- 
-        return rval;
+       return rval;
     }
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createEllipsoid(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset,
-            Ogre::Quaternion* orientation,
-            const Ogre::Real mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass)
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createEllipsoid(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
     {
         Ogre::Vector3 size = aabb.getSize();
         // set the size x/z values to the maximum
@@ -1030,34 +999,16 @@
 			orientation = &object_orientation;
 
         // an ellipsoid primitiv has got its coordinate system at its center, so shift it with radius
-        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             s, *orientation, *offset));
 
-
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-            if( inertia )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass )
-                *centerOfMass = temp_centerOfMass;
-        }
- 
-        return rval;
+       return rval;
     }
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCapsule(const Ogre::AxisAlignedBox& aabb,
-            Ogre::Vector3* offset,
-            Ogre::Quaternion* orientation,
-            const Ogre::Real mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass)
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createCapsule(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
     {
         Ogre::Vector3 size = aabb.getSize();
         // positional offset of the collision primitiv
@@ -1066,7 +1017,7 @@
 		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
         double radius = std::max(size.x, size.z) / 2.0;
 		double height = size.y;
-        // fixme: this is a semi ugly fix - because the orientation should be set by the loader
+        // @todo: fixme: this is a semi ugly fix - because the orientation should be set by the loader
         object_orientation.FromAngleAxis(Degree(90), Vector3::UNIT_Z);
 
 		// set offset/orientation when they are null
@@ -1083,22 +1034,35 @@
             radius, height, *orientation, *offset));
 
 
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            boost::dynamic_pointer_cast<OgreNewt::ConvexCollision>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-            dynamic_cast<OgreNewt::ConvexCollisionPtr>(rval)->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-            if( inertia )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass )
-                *centerOfMass = temp_centerOfMass;
-        }
- 
- 
         return rval;
     }
+
+
+
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createConvexHull(
+            Ogre::Entity* entity,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
+    {
+        // offset of the collision primitiv
+        Ogre::Vector3 object_offset( Ogre::Vector3::ZERO );
+        // orientation of the collision primitiv
+        Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
+
+        // set offset/orientation when they are null
+        if (! offset)
+            offset = &object_offset;
+        if (! orientation)
+            orientation = &object_orientation;
+
+        // calculate the convex hull of the animated mesh
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::ConvexHull(
+                    PhysicsManager::getSingleton()._getNewtonWorld(),
+                    entity, *orientation, *offset));
+
+        return rval;
+    }
+
+
 }
 

Modified: rl/branches/persistence2/engine/core/src/SceneQuery.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/SceneQuery.cpp	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/core/src/SceneQuery.cpp	2009-04-14 08:19:08 UTC (rev 4897)
@@ -117,7 +117,11 @@
 
                 // Add actor to this body to the result
 #ifdef OGRENEWT_USE_OGRE_ANY
-                Actor* actor = Ogre::any_cast<Actor*>(body->getUserData());
+                Actor* actor = NULL;
+                if( body->getUserData().getType() == typeid(Actor*) )
+                {
+                    actor = Ogre::any_cast<Actor*>(body->getUserData());
+                }
 #else
                 Actor* actor = static_cast<Actor*>(body->getUserData());
 #endif

Modified: rl/branches/persistence2/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/CreatureControllerManager.cpp	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/rules/src/CreatureControllerManager.cpp	2009-04-14 08:19:08 UTC (rev 4897)
@@ -167,7 +167,9 @@
     void CreatureControllerManager::userProcess(OgreNewt::ContactJoint &contactJoint, Real timestep, int threadid)
     {
 #ifdef OGRENEWT_USE_OGRE_ANY
-        Actor *actor = Ogre::any_cast<Actor*>(contactJoint.getBody0()->getUserData());
+        Actor *actor = NULL;
+        if( contactJoint.getBody0()->getUserData().getType() == typeid(Actor*) )
+            actor = Ogre::any_cast<Actor*>(contactJoint.getBody0()->getUserData());
 #else
         Actor *actor = static_cast<Actor*>(contactJoint.getBody0()->getUserData());
 #endif
@@ -183,9 +185,10 @@
 
         // if the controlled body is the second body...
 #ifdef OGRENEWT_USE_OGRE_ANY
-        actor = Ogre::any_cast<Actor*>(contactJoint.getBody0()->getUserData());
+        if( contactJoint.getBody1()->getUserData().getType() == typeid(Actor*) )
+            actor = Ogre::any_cast<Actor*>(contactJoint.getBody1()->getUserData());
 #else
-        actor = static_cast<Actor*>(contactJoint.getBody0()->getUserData());
+        actor = static_cast<Actor*>(contactJoint.getBody1()->getUserData());
 #endif
         if( actor != NULL )
         {

Modified: rl/branches/persistence2/engine/rules/src/SelectionHelper.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/SelectionHelper.cpp	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/rules/src/SelectionHelper.cpp	2009-04-14 08:19:08 UTC (rev 4897)
@@ -85,7 +85,9 @@
             if (body != NULL)
             {
 #ifdef OGRENEWT_USE_OGRE_ANY
-                Actor* hitActor = Ogre::any_cast<Actor*>(body->getUserData());
+                Actor* hitActor = NULL;
+                if( body->getUserData().getType() == typeid(Actor*) )
+                    hitActor = Ogre::any_cast<Actor*>(body->getUserData());
 #else
                 Actor* hitActor = static_cast<Actor*>(body->getUserData());
 #endif

Modified: rl/branches/persistence2/engine/script/include/EntityNodeProcessor.h
===================================================================
--- rl/branches/persistence2/engine/script/include/EntityNodeProcessor.h	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/script/include/EntityNodeProcessor.h	2009-04-14 08:19:08 UTC (rev 4897)
@@ -38,16 +38,6 @@
         virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
 
     private:
-		/// stores already constructed collision proxies for reuse
-        struct AlreadyUsedCollision
-        {
-        public:
-            Ogre::String Type;
-            Ogre::Vector3 Scale;
-            OgreNewt::CollisionPtr ColPtr;
-        };
-
-		std::map<Ogre::String,AlreadyUsedCollision> mAutoCreatedCollisions;
         Ogre::String mResourceGroup;
 
         void createCollision(Ogre::Entity* entity, Ogre::String meshFile, XERCES_CPP_NAMESPACE::DOMElement* physicsProxyElem);

Modified: rl/branches/persistence2/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/branches/persistence2/engine/script/src/PlaneNodeProcessor.cpp	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/script/src/PlaneNodeProcessor.cpp	2009-04-14 08:19:08 UTC (rev 4897)
@@ -148,7 +148,6 @@
 			const Quaternion orientation(0,0,0,0);// = parentNode->getOrientation();
 			const Ogre::Vector3 pos = aab.getMinimum() * parentNode->getScale() + (size/2.0);
 
-			//collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(world, size, orientation, pos));
             collision = PhysicsManager::getSingleton().createCollision(entity, GT_BOX, "", NULL, NULL, 0, NULL, NULL, true);
 
 			if ( collision != NULL )

Modified: rl/branches/persistence2/engine/script/swig/RlCore.swig
===================================================================
--- rl/branches/persistence2/engine/script/swig/RlCore.swig	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/script/swig/RlCore.swig	2009-04-14 08:19:08 UTC (rev 4897)
@@ -184,6 +184,8 @@
     virtual void setAmbientLight(Ogre::Real r, Ogre::Real g, Ogre::Real b);
     virtual Ogre::Vector3 getStartPoint() const;
     virtual void setCastShadows(bool);
+    virtual void clearScene() = 0;
+    virtual void initializeDefaultCamera() = 0;
 
     void setShowBoundingBoxes( bool dis );
 };
@@ -777,6 +779,7 @@
 public:
     static CoreSubsystem& getSingleton(void);
     
+
 	void registerModule(rl::ContentModule* module);
 
 	rl::ContentModule* getActiveAdventureModule() const;

Modified: rl/branches/persistence2/engine/ui/include/UiSubsystem.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/UiSubsystem.h	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/ui/include/UiSubsystem.h	2009-04-14 08:19:08 UTC (rev 4897)
@@ -18,7 +18,6 @@
 #define __UiSubsystem_H__
 
 #include "UiPrerequisites.h"
-#include "World.h"
 
 
 #include "ControlState.h"

Modified: rl/branches/persistence2/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/MovementControlState.cpp	2009-04-14 00:07:38 UTC (rev 4896)
+++ rl/branches/persistence2/engine/ui/src/MovementControlState.cpp	2009-04-14 08:19:08 UTC (rev 4897)
@@ -162,6 +162,7 @@
         //! TODO: remove this workaround (newton-bug: "spheres don't cast"!)
         mCameraCastCollision = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(mCamBody->getWorld(), verts, 80));
         //mCameraCastCollision = new OgreNewt::CollisionPrimitives::Ellipsoid(mCamBody->getWorld(), Vector3::UNIT_SCALE * camRadius);
+        // we could use the real collision of the camera here...
     }
 
     //------------------------------------------------------------------------



From fusion2 at mail.berlios.de  Wed Apr 15 18:43:46 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Wed, 15 Apr 2009 18:43:46 +0200
Subject: [Dsa-hl-svn] r4898 - in rl/trunk/editors/Lockenwickler/src: .
	media/icons
Message-ID: <200904151643.n3FGhkZq002295@sheep.berlios.de>

Author: fusion2
Date: 2009-04-15 18:43:40 +0200 (Wed, 15 Apr 2009)
New Revision: 4898

Added:
   rl/trunk/editors/Lockenwickler/src/media/icons/2rightarrow.png
Modified:
   rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py
Log:
- bugfix in the New Module WIzard

Modified: rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py	2009-04-14 08:19:08 UTC (rev 4897)
+++ rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py	2009-04-15 16:43:40 UTC (rev 4898)
@@ -108,6 +108,7 @@
         os.mkdir(os.path.join(modulePath, "quests"))
         os.mkdir(os.path.join(modulePath, "scripts"))
         os.mkdir(os.path.join(modulePath, "scripts/maps"))
+        os.mkdir(os.path.join(modulePath, "scripts/triggers"))
         os.mkdir(os.path.join(modulePath, "sound"))
         
         mname = str(self.moduleNameLineEdit.text())
@@ -146,8 +147,6 @@
         f.write("    end\n\n")
         f.write("    def start()\n")
         f.write(sdeps + "\n")
-        f.write("       require 'player.rb'\n")
-        f.write("       require 'mckhero.rb'\n")
         f.write("       $PM.setEnabled(true);\n\n")
         f.write("\n\n       SceneManager.getSingleton().loadScene(\"" + self.sceneNameLineEdit.text() + "\");\n\n")
         f.write("       hero = $GOM.getGameObject(XXXXXX);\n")
@@ -158,8 +157,6 @@
         f.write("CoreSubsystem.getSingleton().registerModule(" + mname.capitalize() + "Module.new());\n")
         f.close()
         
-        
-        
         p = os.path.join(modulePath, "maps")
         p = os.path.join(p, str(self.sceneNameLineEdit.text()) + ".rlscene")
         

Added: rl/trunk/editors/Lockenwickler/src/media/icons/2rightarrow.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/2rightarrow.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From fusion2 at mail.berlios.de  Wed Apr 15 19:58:26 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Wed, 15 Apr 2009 19:58:26 +0200
Subject: [Dsa-hl-svn] r4899 - rl/trunk/editors/Lockenwickler/src
Message-ID: <200904151758.n3FHwQSY007825@sheep.berlios.de>

Author: fusion2
Date: 2009-04-15 19:58:20 +0200 (Wed, 15 Apr 2009)
New Revision: 4899

Added:
   rl/trunk/editors/Lockenwickler/src/ModuleDirectoryView.py
Modified:
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/ZoneManager.py
Log:
- added a Module Directory Explorer
- fixed a bug when saving zones


Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-04-15 16:43:40 UTC (rev 4898)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-04-15 17:58:20 UTC (rev 4899)
@@ -1,551 +1,572 @@
-#################################################
-# This source file is part of Rastullahs Lockenwickler.
-# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
-
-import os
-import sys
-import platform
-import subprocess
-
-sys.path.insert(0,'..')
-import PythonOgreConfig
-
-from random import randint
-
-from PyQt4 import QtGui, QtCore
-from PreferencesDialog import *
-from ObjectPropertyWin import *
-from ModelSelectionDialog import *
-from MaterialSelectionDialog import *
-from GameObjectClassView import *
-from ConsoleWindow import *
-from ModuleManager import ModuleManager
-from ModuleExplorer import *
-from NewModuleWizard import *
-from MovePivot import *
-from PivotRenderQueueListener import *
-
-import OgreMainWindow
-import ogre.renderer.OGRE as og
-
-class Lockenwickler(QtGui.QMainWindow):
-    def __init__(self, parent=None):
-        QtGui.QWidget.__init__(self, parent)
-
-#        pixmap = QPixmap("media/icons/lockenwickler_provisorium.png")
-#        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
-#        splash.setMask(pixmap.mask())
-#        splash.showMessage("Starting...")
-#        splash.show() 
-
-        self.setupUi()
-
-        self.consoleWindow = ConsoleWindow(False,  self)
-
-        self.setupOgre()
-
-        self.prefDialog = PreferencesDialog(self)
-        self.objectPropertyWin = ObjectPropertyWin(self.OgreMainWinSceneMgr, self.gocManager, self)
-        self.moduleExplorerWin = ModuleExplorer(self)
-        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
-        self.materialSelectionDialog = MaterialSelectionDialog(self.ogreRoot, self)
-        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
-        self.moduleManager.materialSelectionDialog = self.materialSelectionDialog
-
-        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
-
-        self.createDockWindows()
-
-        self.mainTimer = QtCore.QTimer(self)
-        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL("timeout()"), self.update)
-        self.mainTimer.start(5)
-
-        settings = QtCore.QSettings()
-        self.restoreGeometry(settings.value("MainWindow/Geometry").toByteArray())
-        self.restoreState(settings.value("MainWindow/DockWindows").toByteArray())
-        if not self.prefDialog.setCfgPath(settings.value("Preferences/moduleCfgPath").toString()):
-            self.prefDialog.show()
-            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
-        else:
-            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
-        
-        self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
-        self.moduleManager.setPropertyWindow(self.objectPropertyWin)
-        self.moduleManager.setContextMenuCallback(self.onContextMenuCallback)
-        
-        self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
-        self.setWindowTitle("Rastullahs Lockenwickler")
-        
-        self.editorSetupFinished = False
-        
-#        splash.finish(self)
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
-        action = QtGui.QAction(text, self)
-        if icon is not None:
-            action.setIcon(QtGui.QIcon("media/icons/%s" % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            self.connect(action, QtCore.SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
-
-    def addActions(self, target, actions):
-        for act in actions:
-            if act is None:
-               target.addSeparator()
-            else:
-                target.addAction(act)
-
-    def setupUi(self):
-        self.setObjectName("MainWindow")
-
-        self.centralwidget = QtGui.QWidget(self)
-        self.centralwidget.setObjectName("centralwidget")
-
-        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
-        self.hboxlayout.setContentsMargins(0, 0, 0, 0)
-        self.hboxlayout.setObjectName("hboxlayout")
-
-        self.gridlayout = QtGui.QGridLayout()
-        self.gridlayout.setObjectName("gridlayout")
-        self.gridlayout.setContentsMargins(0, 0, 0, 0)
-        
-        self.menubar = QtGui.QMenuBar(self)
-        self.menubar.setObjectName("menubar")
-
-        self.menuFile = QtGui.QMenu(self.menubar)
-        self.menuFile.setObjectName("menuFile")
-
-        self.menuEdit = QtGui.QMenu(self.menubar)
-        self.menuEdit.setObjectName("menuEdit")
-
-        self.menuView = QtGui.QMenu(self.menubar)
-        self.menuView.setObjectName("menuView")
-        self.setMenuBar(self.menubar)
-
-
-        self.statusbar = QtGui.QStatusBar(self)
-        self.statusbar.setObjectName("statusbar")
-        self.setStatusBar(self.statusbar)
-
-#####################################
-        self.actionNeu =self.createAction("&New Module",  self.actionNewSlot,  QKeySequence.New,  "filenew.png",  "New Module")
-        self.actionNeu.setObjectName("actionNeu")
-
-        self.actionOpen = self.createAction("&Open Module",  self.actionOpenSlot,  QKeySequence.Open,  "fileopen.png",  "Open Module")
-        self.actionOpen.setObjectName("actionOpen")
-        
-        self.actionSave = self.createAction("&Save",  self.actionSaveSlot,  QKeySequence.Save,  "filesave.png",  "Save Module")
-        self.actionSave.setObjectName("actionSave")
-        
-        self.actionRunModule = self.createAction("&Save and Run",  self.actionRunModuleSlot,  "Alt+R",  "fileexport.png",  "Save And Run Module")
-        self.actionRunModule.setObjectName("actionRunModule")
-
-        self.actionClose = self.createAction("Quit",  self.actionQuitSlot,  "Alt+Q",  "exit.png",  "Quit")
-        self.actionClose.setObjectName("actionQuit")
-#####################################
-
-
-#####################################
-        self.actionDelete = self.createAction("Delete",  self.actionDeleteSlot,  QKeySequence.Delete,  "editdelete.png",  "Delete")
-        self.actionDelete.setObjectName("actionDelete")
-
-        self.actionCopy = self.createAction("Copy",  self.actionCopySlot,  QKeySequence.Copy,  "editcopy.png",  "Copy")
-        self.actionCopy.setObjectName("actionCopy")
-
-        self.actionCut = self.createAction("Cut",  self.actionCutSlot,  QKeySequence.Cut,  "editcut.png",  "Cut")
-        self.actionCut.setObjectName("actionCut")
-
-        self.actionPaste = self.createAction("Paste",  self.actionPasteSlot,  QKeySequence.Paste,  "editpaste.png",  "Paste")
-        self.actionPaste.setObjectName("actionPaste")
-
-        self.actionSelect = self.createAction("&Select",  self.actionSelectSlot,  "Space",  "cursor.png",  "Move selected object")
-        self.actionSelect.setObjectName("actionSelect")
-
-        self.actionMove = self.createAction("&Move",  self.actionMoveSlot,  "g",  "move.png",  "Move selected object")
-        self.actionMove.setObjectName("actionMove")
-
-        self.actionRotate = self.createAction("&Rotate",  self.actionRotateSlot,  "r",  "rotate.png",  "Rotate selected object")
-        self.actionRotate.setObjectName("actionRotate")
-
-        self.actionScale = self.createAction("&Scale",  self.actionScaleSlot,  "x",  "resizecol.png",  "Scale selected object")
-        self.actionScale.setObjectName("actionScale")
-
-        self.actionOneClickEntityPlacement = self.createAction("&OneClickEntityPlacement",  self.actionOneClickEntityPlacementSlot,  "",  "resizecol.png",  "Add an Entity just by a click")
-        self.actionOneClickEntityPlacement.setObjectName("actionOneClickEntityPlacement")
-        self.actionOneClickEntityPlacement.setCheckable(True)
-
-#####################################
-#####################################
-        self.actionSceneExplorer = self.createAction("&Scene Exlporer",  self.toggleModuleExplorer,  "Alt+E",  "view_tree.png",  "Module Explorer",  False)
-        self.actionSceneExplorer.setObjectName("actionSceneExplorer")
-        
-        self.actionPreferences = self.createAction("&Preferences",  self.togglePreferencesWindow,  "Alt+P",  "configure.png",  "Lockenwickler Preferences",  False)
-        self.actionPreferences.setObjectName("actionPreferences")
-
-        self.actionProperty_Window = self.createAction("Pr&operty Window",  self.togglePropertyWindow,  "Alt+P",  "unsortedlist1.png",  "Property Window")
-        self.actionProperty_Window.setObjectName("actionProperty_Window")
-
-        self.actionObject_Selection = self.createAction("&Model Preview Window",  self.toggleModelPreviewWindow,  "Alt+O",  "tux.png",  "Model Preview")
-        self.actionObject_Selection.setObjectName("actionObject_Selection")
-        
-        self.actionMaterial_Selection = self.createAction("Material &Preview Window",  self.toggleMaterialPreviewWindow,  "Alt+M",  "colors.png",  "Material Preview")
-        self.actionMaterial_Selection.setObjectName("actionMaterial_Selection")
-
-        self.actionGameObjectClass_Selection = self.createAction("&Game Object Class Preview Window",  self.toggleGameObjectViewWindow,  "Ctrl+G",  "multirow.png",  "GameObjectClass Preview")
-        self.actionGameObjectClass_Selection.setObjectName("actionObject_Selection")
-
-        self.actionConsole_Window = self.createAction("&Console Window",  self.toggleConsoleWindow,  "Alt+C",  "console.png",  "Console Window")
-        self.actionConsole_Window.setObjectName("actionConsole_Window")
-        
-        self.actionToggleViewportGrid = self.createAction("&Toggle Grid",  self.toggleViewportGrid,  "Alt+G",  "console.png",  "Toggle Viewport Grid")
-        self.actionToggleViewportGrid.setObjectName("actionToggleViewportGrid")
-
-#####################################
-#####################################
-
-
-        self.menuFile.addAction(self.actionNeu)
-        self.menuFile.addAction(self.actionOpen)
-        self.menuFile.addAction(self.actionSave)
-        self.menuFile.addAction(self.actionRunModule)
-        self.menuFile.addAction(self.actionClose)
-
-        self.menuEdit.addAction(self.actionSelect)
-        self.menuEdit.addAction(self.actionMove)
-        self.menuEdit.addAction(self.actionRotate)
-        self.menuEdit.addAction(self.actionScale)
-        self.menuEdit.addSeparator()
-        self.menuEdit.addAction(self.actionDelete)
-        self.menuEdit.addAction(self.actionCopy)
-        self.menuEdit.addAction(self.actionCut)
-        self.menuEdit.addAction(self.actionPaste)
-        self.menuEdit.addSeparator()
-        self.menuEdit.addAction(self.actionOneClickEntityPlacement)
-        
-
-        self.menuView.addAction(self.actionSceneExplorer)
-        self.menuView.addAction(self.actionPreferences)
-        self.menuView.addAction(self.actionProperty_Window)
-        self.menuView.addAction(self.actionObject_Selection)
-        self.menuView.addAction(self.actionMaterial_Selection)
-        self.menuView.addAction(self.actionGameObjectClass_Selection)
-        self.menuView.addAction(self.actionConsole_Window)
-        self.menuView.addAction(self.actionToggleViewportGrid)
-        
-        self.menubar.addAction(self.menuFile.menuAction())
-        self.menubar.addAction(self.menuEdit.menuAction())
-        self.menubar.addAction(self.menuView.menuAction())
-
-        self.retranslateUi()
-        QtCore.QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuEdit.setTitle(QtGui.QApplication.translate("MainWindow", "Edit", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "New Module", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionMove.setText(QtGui.QApplication.translate("MainWindow", "Move", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionRotate.setText(QtGui.QApplication.translate("MainWindow", "Rotate", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionSceneExplorer.setText(QtGui.QApplication.translate("MainWindow", "Module Explorer", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionClose.setText(QtGui.QApplication.translate("MainWindow", "Quit", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionConsole_Window.setText(QtGui.QApplication.translate("MainWindow", "Console Window", None, QtGui.QApplication.UnicodeUTF8))
-
-    def setupOgre(self, pluginCfgPath="./Plugins.cfg", ogreCfgPath="./ogre.cfg", logPath="./ogre.log"):
-        if platform.system() == "Windows":
-            pluginCfgPath="./Plugins-windows.cfg"
-        else:
-            pluginCfgPath="./Plugins-linux.cfg"
-
-        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
-        self.ogreRoot = root
-
-        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
-            sys.exit('Quit from Config Dialog')
-
-        root.initialise(False)
-
-        self.pivotRenderQueueListener = PivotRenderQueueListener()
-        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, "OgreMainWinSceneMgr")
-        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
-        self.OgreMainWinSceneMgr.addRenderQueueListener(self.pivotRenderQueueListener)
-        
-        self.moduleName = ""
-        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
-        self.gocManager = self.moduleManager.gocManager
-        
-        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
-        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
-        self.hboxlayout.addLayout(self.gridlayout)
-        self.setCentralWidget(self.centralwidget)
-        
-        oglog = og.LogManager.getSingleton().getDefaultLog()
-        oglog.addListener(self.consoleWindow.lockenLog)
-
-    def finishEditorSetup(self):
-        if not self.editorSetupFinished:
-            og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
-            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-            self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
-            self.moduleManager.pivot.hide()
-            self.editorSetupFinished = True
-        
-    def update(self):
-        self.ogreRoot.renderOneFrame()
-        if platform.system() == "Linux":
-            self.ogreMainWindow.updateRenderWindow()
-            self.modelSelectionDialog.updateRenderWindow()
-            self.materialSelectionDialog.updateRenderWindow()
-
-    def actionOpenSlot(self):
-        self.finishEditorSetup()
-        self.moduleManager.openLoadModuleDialog()
-
-    def actionNewSlot(self):
-        newModuleWiz = NewModuleWizard(self.moduleManager, self)
-        newModuleWiz.exec_()
-        return
-        
-    def actionSaveSlot(self):
-        self.moduleManager.save()
-        
-    def actionRunModuleSlot(self):
-        self.moduleManager.save()
-        if platform.system() == "Windows":
-            workingDir = self.prefDialog.moduleCfgPath.replace("/modules/modules.cfg", "")
-            executable = os.path.join(workingDir, "Rastullah.exe")
-            executable = executable.replace("/",  "\\")
-            if os.path.isfile(executable):
-                subprocess.Popen([executable, "--module", self.moduleManager.mainModule.name], 0, None, None, None, None, None, False, False, workingDir)
-
-        
-    def actionQuitSlot(self):
-        self.close()
-
-    def actionDeleteSlot(self):
-        self.moduleManager.deleteObjects()
-
-    def actionCopySlot(self):
-        self.moduleManager.copyObjects()
-
-    def actionCutSlot(self):
-        self.moduleManager.cutObjects()
-
-    def actionPasteSlot(self):
-        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
-
-    def actionSelectSlot(self):
-        self.moduleManager.pivot.hide()
-
-    def actionMoveSlot(self):
-        self.moduleManager.pivot.setMoveMode()
-
-    def actionRotateSlot(self):
-        self.moduleManager.pivot.setRotateMode()
-
-    def actionScaleSlot(self):
-        self.moduleManager.pivot.setScaleMode()
-
-    def actionOneClickEntityPlacementSlot(self):
-        self.moduleManager.setOneClickEntityPlacement(self.actionOneClickEntityPlacement.isChecked())
-
-    def togglePreferencesWindow(self):
-        if self.prefDialog.isHidden():
-            self.prefDialog.show()
-        else:
-            self.prefDialog.hide()
-
-    def toggleModelPreviewWindow(self):
-        if self.modelSelectionDock.isHidden():
-            self.modelSelectionDock.show()
-        else:
-            self.modelSelectionDock.hide()
-    
-    def toggleMaterialPreviewWindow(self):
-        if self.materialSelectionDock.isHidden():
-            self.materialSelectionDock.show()
-        else:
-            self.materialSelectionDock.hide()
-
-    def toggleGameObjectViewWindow(self):
-        if self.gameObjectClassViewDock.isHidden():
-            self.gameObjectClassViewDock.show()
-        else:
-            self.gameObjectClassViewDock.hide()
-
-    def toggleModuleExplorer(self):
-        if self.moduleExplorerDock.isHidden():
-            self.moduleExplorerDock.show()
-        else:
-            self.moduleExplorerDock.hide()
-
-    def togglePropertyWindow(self):
-        if self.propertyDock.isHidden():
-            self.propertyDock.show()
-        else:
-            self.propertyDock.hide()
-
-    def toggleConsoleWindow(self):
-        if self.consoleDock.isHidden():
-            self.consoleDock.show()
-        else:
-            self.consoleDock.hide()
-
-    def toggleViewportGrid(self):
-        self.ogreMainWindow.toggleViewportGrid()
-
-    def createDockWindows(self):
-        self.modelSelectionDock = QtGui.QDockWidget(self.tr("Models"), self)
-        self.modelSelectionDock.setObjectName("ModelSelectionDockWindow")
-        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
-        
-        self.materialSelectionDock = QtGui.QDockWidget(self.tr("Materials"), self)
-        self.materialSelectionDock.setObjectName("MaterialSelectionDockWindow")
-        self.materialSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.materialSelectionDock.setWidget(self.materialSelectionDialog)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.materialSelectionDock)
-        self.tabifyDockWidget(self.modelSelectionDock, self.materialSelectionDock)
-        
-        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr("GameObjectClasses"), self)
-        self.gameObjectClassViewDock.setObjectName("GameObjectClassView")
-        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)        
-        self.tabifyDockWidget(self.modelSelectionDock, self.gameObjectClassViewDock)
-        
-        self.propertyDock = QtGui.QDockWidget(self.tr("Properties"), self)
-        self.propertyDock.setObjectName("PropertyDockWindow")
-        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.propertyDock.setWidget(self.objectPropertyWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
-
-        self.moduleExplorerDock = QtGui.QDockWidget(self.tr("Module Explorer"), self)
-        self.moduleExplorerDock.setObjectName("ModuleExplorerDockWindow")
-        self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
-        self.tabifyDockWidget(self.moduleExplorerDock, self.propertyDock)
-        
-        self.consoleDock = QtGui.QDockWidget(self.tr("Console"), self)
-        self.consoleDock.setObjectName("ConsoleDockWindow")
-        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
-        self.consoleDock.setWidget(self.consoleWindow)
-        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
-
-        self.fileToolBar = self.addToolBar("File Toolbar")
-        self.fileToolBar.setObjectName("FileToolBar")
-        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.fileToolBar.addAction(self.actionNeu)
-        self.fileToolBar.addAction(self.actionOpen)
-        self.fileToolBar.addAction(self.actionSave)
-        self.fileToolBar.addAction(self.actionRunModule)
-        self.fileToolBar.addAction(self.actionClose)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
-
-        self.moveToolBar = self.addToolBar("Transformation Bar")
-        self.moveToolBar.setObjectName("TransformationBar")
-        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.moveToolBar.addAction(self.actionSelect)
-        self.moveToolBar.addAction(self.actionMove)
-        self.moveToolBar.addAction(self.actionRotate)
-        self.moveToolBar.addAction(self.actionScale)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
-
-    def keyPressEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreMainWindow.keyPressEvent(event)
-
-    def keyReleaseEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreMainWindow.keyReleaseEvent(event)
-        pass
-
-    def onContextMenuCallback(self, actions, menus):
-        menu = QMenu("My Menu!!")
-        menu.addAction(self.actionDelete)
-        menu.addAction(self.actionCopy)
-        menu.addAction(self.actionCut)
-        menu.addAction(self.actionPaste)
-        menu.addSeparator()
-        
-        for m in menus:
-            menu.addMenu(m)
-        for a in actions:
-            menu.addAction(a)
-
-        menu.exec_(QCursor.pos())
-
-    def connectActionButtons(self):
-        pass
-
-    def saveOnClose(self):
-#        reply = QtGui.QMessageBox.question(self,  "Rastullahs Lockenwickler - Unsaved Chages",  "Save unsaved changes?",  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
-#        if reply == QtGui.QMessageBox.Cancel:
-#            return False
-#        if reply == QtGui.QMessageBox.Yes:
-#            print""
-#            #TODO: implement save here
-        return True
-
-    def closeEvent(self,  event):
-        if self.saveOnClose():
-            settings = QtCore.QSettings()
-            settings.setValue("Preferences/moduleCfgPath", QtCore.QVariant(self.prefDialog.lineEdit.text()))
-            settings.setValue("MainWindow/Geometry",  QtCore.QVariant(self.saveGeometry()))
-            settings.setValue("MainWIndow/DockWindows",  QtCore.QVariant(self.saveState()))
-            
-            #self.ogreRoot.shutdown()
-        else:
-            event.ignore()
-
-if __name__ == "__main__":
-#    # Import Psyco if available
-#    try:
-#        import psyco
-#        psyco.full(0.02)
-#        #psyco.log()
-#        #psyco.profile()
-#    except ImportError:
-#        pass
-    
-    app = QtGui.QApplication(sys.argv)
-    app.setOrganizationName("Team Pantheon")
-    app.setOrganizationDomain("rastullahs-lockenpracht.de/team")
-    app.setApplicationName("Lockenwickler")
-
-    form = Lockenwickler()
-    form.show()
-
-    app.exec_()
-    
-    sys.exit(0)
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import os
+import sys
+import platform
+import subprocess
+
+sys.path.insert(0,'..')
+import PythonOgreConfig
+
+from random import randint
+
+from PyQt4 import QtGui, QtCore
+from PreferencesDialog import *
+from ObjectPropertyWin import *
+from ModelSelectionDialog import *
+from MaterialSelectionDialog import *
+from GameObjectClassView import *
+from ConsoleWindow import *
+from ModuleManager import ModuleManager
+from ModuleExplorer import *
+from NewModuleWizard import *
+from MovePivot import *
+from PivotRenderQueueListener import *
+from ModuleDirectoryView import *
+
+import OgreMainWindow
+import ogre.renderer.OGRE as og
+
+class Lockenwickler(QtGui.QMainWindow):
+    def __init__(self, parent=None):
+        QtGui.QWidget.__init__(self, parent)
+
+#        pixmap = QPixmap("media/icons/lockenwickler_provisorium.png")
+#        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
+#        splash.setMask(pixmap.mask())
+#        splash.showMessage("Starting...")
+#        splash.show() 
+
+        self.setupUi()
+
+        self.consoleWindow = ConsoleWindow(False,  self)
+
+        self.setupOgre()
+
+        self.prefDialog = PreferencesDialog(self)
+        self.objectPropertyWin = ObjectPropertyWin(self.OgreMainWinSceneMgr, self.gocManager, self)
+        self.moduleExplorerWin = ModuleExplorer(self)
+        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        self.materialSelectionDialog = MaterialSelectionDialog(self.ogreRoot, self)
+        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
+        self.moduleManager.materialSelectionDialog = self.materialSelectionDialog
+        self.moduleDirectoryViewWin = ModuleDirectoryView(self)
+        
+        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
+
+        self.createDockWindows()
+
+        self.mainTimer = QtCore.QTimer(self)
+        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL("timeout()"), self.update)
+        self.mainTimer.start(5)
+
+        settings = QtCore.QSettings()
+        self.restoreGeometry(settings.value("MainWindow/Geometry").toByteArray())
+        self.restoreState(settings.value("MainWindow/DockWindows").toByteArray())
+        if not self.prefDialog.setCfgPath(settings.value("Preferences/moduleCfgPath").toString()):
+            self.prefDialog.show()
+            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        else:
+            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        
+        self.moduleDirectoryViewWin.parseDirectory(self.prefDialog.moduleCfgPath.replace("modules.cfg", ""))
+        
+        self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
+        self.moduleManager.setModuleDirView(self.moduleDirectoryViewWin)
+        self.moduleManager.setPropertyWindow(self.objectPropertyWin)
+        self.moduleManager.setContextMenuCallback(self.onContextMenuCallback)
+        
+        self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
+        self.setWindowTitle("Rastullahs Lockenwickler")
+        
+        self.editorSetupFinished = False
+        
+#        splash.finish(self)
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QtGui.QAction(text, self)
+        if icon is not None:
+            action.setIcon(QtGui.QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            self.connect(action, QtCore.SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+
+    def addActions(self, target, actions):
+        for act in actions:
+            if act is None:
+               target.addSeparator()
+            else:
+                target.addAction(act)
+
+    def setupUi(self):
+        self.setObjectName("MainWindow")
+
+        self.centralwidget = QtGui.QWidget(self)
+        self.centralwidget.setObjectName("centralwidget")
+
+        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
+        self.hboxlayout.setContentsMargins(0, 0, 0, 0)
+        self.hboxlayout.setObjectName("hboxlayout")
+
+        self.gridlayout = QtGui.QGridLayout()
+        self.gridlayout.setObjectName("gridlayout")
+        self.gridlayout.setContentsMargins(0, 0, 0, 0)
+        
+        self.menubar = QtGui.QMenuBar(self)
+        self.menubar.setObjectName("menubar")
+
+        self.menuFile = QtGui.QMenu(self.menubar)
+        self.menuFile.setObjectName("menuFile")
+
+        self.menuEdit = QtGui.QMenu(self.menubar)
+        self.menuEdit.setObjectName("menuEdit")
+
+        self.menuView = QtGui.QMenu(self.menubar)
+        self.menuView.setObjectName("menuView")
+        self.setMenuBar(self.menubar)
+
+
+        self.statusbar = QtGui.QStatusBar(self)
+        self.statusbar.setObjectName("statusbar")
+        self.setStatusBar(self.statusbar)
+
+#####################################
+        self.actionNeu =self.createAction("&New Module",  self.actionNewSlot,  QKeySequence.New,  "filenew.png",  "New Module")
+        self.actionNeu.setObjectName("actionNeu")
+
+        self.actionOpen = self.createAction("&Open Module",  self.actionOpenSlot,  QKeySequence.Open,  "fileopen.png",  "Open Module")
+        self.actionOpen.setObjectName("actionOpen")
+        
+        self.actionSave = self.createAction("&Save",  self.actionSaveSlot,  QKeySequence.Save,  "filesave.png",  "Save Module")
+        self.actionSave.setObjectName("actionSave")
+        
+        self.actionRunModule = self.createAction("&Save and Run",  self.actionRunModuleSlot,  "Alt+R",  "fileexport.png",  "Save And Run Module")
+        self.actionRunModule.setObjectName("actionRunModule")
+
+        self.actionClose = self.createAction("Quit",  self.actionQuitSlot,  "Alt+Q",  "exit.png",  "Quit")
+        self.actionClose.setObjectName("actionQuit")
+#####################################
+
+
+#####################################
+        self.actionDelete = self.createAction("Delete",  self.actionDeleteSlot,  QKeySequence.Delete,  "editdelete.png",  "Delete")
+        self.actionDelete.setObjectName("actionDelete")
+
+        self.actionCopy = self.createAction("Copy",  self.actionCopySlot,  QKeySequence.Copy,  "editcopy.png",  "Copy")
+        self.actionCopy.setObjectName("actionCopy")
+
+        self.actionCut = self.createAction("Cut",  self.actionCutSlot,  QKeySequence.Cut,  "editcut.png",  "Cut")
+        self.actionCut.setObjectName("actionCut")
+
+        self.actionPaste = self.createAction("Paste",  self.actionPasteSlot,  QKeySequence.Paste,  "editpaste.png",  "Paste")
+        self.actionPaste.setObjectName("actionPaste")
+
+        self.actionSelect = self.createAction("&Select",  self.actionSelectSlot,  "Space",  "cursor.png",  "Move selected object")
+        self.actionSelect.setObjectName("actionSelect")
+
+        self.actionMove = self.createAction("&Move",  self.actionMoveSlot,  "g",  "move.png",  "Move selected object")
+        self.actionMove.setObjectName("actionMove")
+
+        self.actionRotate = self.createAction("&Rotate",  self.actionRotateSlot,  "r",  "rotate.png",  "Rotate selected object")
+        self.actionRotate.setObjectName("actionRotate")
+
+        self.actionScale = self.createAction("&Scale",  self.actionScaleSlot,  "x",  "resizecol.png",  "Scale selected object")
+        self.actionScale.setObjectName("actionScale")
+
+        self.actionOneClickEntityPlacement = self.createAction("&OneClickEntityPlacement",  self.actionOneClickEntityPlacementSlot,  "",  "resizecol.png",  "Add an Entity just by a click")
+        self.actionOneClickEntityPlacement.setObjectName("actionOneClickEntityPlacement")
+        self.actionOneClickEntityPlacement.setCheckable(True)
+
+#####################################
+#####################################
+        self.actionSceneExplorer = self.createAction("&Scene Exlporer",  self.toggleModuleExplorer,  "Alt+E",  "view_tree.png",  "Module Explorer",  False)
+        self.actionSceneExplorer.setObjectName("actionSceneExplorer")
+        
+        self.actionModuleDirView = self.createAction("&Directory Explorer",  self.toggleModuleDirView,  "Alt+D",  "view_tree.png",  "Module Directory Explorer",  False)
+        self.actionModuleDirView.setObjectName("actionDirectoryExplorer")
+        
+        self.actionPreferences = self.createAction("&Preferences",  self.togglePreferencesWindow,  "Alt+P",  "configure.png",  "Lockenwickler Preferences",  False)
+        self.actionPreferences.setObjectName("actionPreferences")
+
+        self.actionProperty_Window = self.createAction("Pr&operty Window",  self.togglePropertyWindow,  "Alt+P",  "unsortedlist1.png",  "Property Window")
+        self.actionProperty_Window.setObjectName("actionProperty_Window")
+
+        self.actionObject_Selection = self.createAction("&Model Preview Window",  self.toggleModelPreviewWindow,  "Alt+O",  "tux.png",  "Model Preview")
+        self.actionObject_Selection.setObjectName("actionObject_Selection")
+        
+        self.actionMaterial_Selection = self.createAction("Material &Preview Window",  self.toggleMaterialPreviewWindow,  "Alt+M",  "colors.png",  "Material Preview")
+        self.actionMaterial_Selection.setObjectName("actionMaterial_Selection")
+
+        self.actionGameObjectClass_Selection = self.createAction("&Game Object Class Preview Window",  self.toggleGameObjectViewWindow,  "Ctrl+G",  "multirow.png",  "GameObjectClass Preview")
+        self.actionGameObjectClass_Selection.setObjectName("actionObject_Selection")
+
+        self.actionConsole_Window = self.createAction("&Console Window",  self.toggleConsoleWindow,  "Alt+C",  "console.png",  "Console Window")
+        self.actionConsole_Window.setObjectName("actionConsole_Window")
+        
+        self.actionToggleViewportGrid = self.createAction("&Toggle Grid",  self.toggleViewportGrid,  "Alt+G",  "console.png",  "Toggle Viewport Grid")
+        self.actionToggleViewportGrid.setObjectName("actionToggleViewportGrid")
+
+#####################################
+#####################################
+
+
+        self.menuFile.addAction(self.actionNeu)
+        self.menuFile.addAction(self.actionOpen)
+        self.menuFile.addAction(self.actionSave)
+        self.menuFile.addAction(self.actionRunModule)
+        self.menuFile.addAction(self.actionClose)
+
+        self.menuEdit.addAction(self.actionSelect)
+        self.menuEdit.addAction(self.actionMove)
+        self.menuEdit.addAction(self.actionRotate)
+        self.menuEdit.addAction(self.actionScale)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionDelete)
+        self.menuEdit.addAction(self.actionCopy)
+        self.menuEdit.addAction(self.actionCut)
+        self.menuEdit.addAction(self.actionPaste)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionOneClickEntityPlacement)
+        
+
+        self.menuView.addAction(self.actionSceneExplorer)
+        self.menuView.addAction(self.actionModuleDirView)
+        self.menuView.addAction(self.actionPreferences)
+        self.menuView.addAction(self.actionProperty_Window)
+        self.menuView.addAction(self.actionObject_Selection)
+        self.menuView.addAction(self.actionMaterial_Selection)
+        self.menuView.addAction(self.actionGameObjectClass_Selection)
+        self.menuView.addAction(self.actionConsole_Window)
+        self.menuView.addAction(self.actionToggleViewportGrid)
+        
+        self.menubar.addAction(self.menuFile.menuAction())
+        self.menubar.addAction(self.menuEdit.menuAction())
+        self.menubar.addAction(self.menuView.menuAction())
+
+        self.retranslateUi()
+        QtCore.QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuEdit.setTitle(QtGui.QApplication.translate("MainWindow", "Edit", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "New Module", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionMove.setText(QtGui.QApplication.translate("MainWindow", "Move", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionRotate.setText(QtGui.QApplication.translate("MainWindow", "Rotate", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionSceneExplorer.setText(QtGui.QApplication.translate("MainWindow", "Module Explorer", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionClose.setText(QtGui.QApplication.translate("MainWindow", "Quit", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionConsole_Window.setText(QtGui.QApplication.translate("MainWindow", "Console Window", None, QtGui.QApplication.UnicodeUTF8))
+
+    def setupOgre(self, pluginCfgPath="./Plugins.cfg", ogreCfgPath="./ogre.cfg", logPath="./ogre.log"):
+        if platform.system() == "Windows":
+            pluginCfgPath="./Plugins-windows.cfg"
+        else:
+            pluginCfgPath="./Plugins-linux.cfg"
+
+        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
+        self.ogreRoot = root
+
+        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
+            sys.exit('Quit from Config Dialog')
+
+        root.initialise(False)
+
+        self.pivotRenderQueueListener = PivotRenderQueueListener()
+        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, "OgreMainWinSceneMgr")
+        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
+        self.OgreMainWinSceneMgr.addRenderQueueListener(self.pivotRenderQueueListener)
+        
+        self.moduleName = ""
+        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
+        self.gocManager = self.moduleManager.gocManager
+        
+        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
+        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
+        self.hboxlayout.addLayout(self.gridlayout)
+        self.setCentralWidget(self.centralwidget)
+        
+        oglog = og.LogManager.getSingleton().getDefaultLog()
+        oglog.addListener(self.consoleWindow.lockenLog)
+
+    def finishEditorSetup(self):
+        if not self.editorSetupFinished:
+            og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+            self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
+            self.moduleManager.pivot.hide()
+            self.editorSetupFinished = True
+        
+    def update(self):
+        self.ogreRoot.renderOneFrame()
+        if platform.system() == "Linux":
+            self.ogreMainWindow.updateRenderWindow()
+            self.modelSelectionDialog.updateRenderWindow()
+            self.materialSelectionDialog.updateRenderWindow()
+
+    def actionOpenSlot(self):
+        self.finishEditorSetup()
+        self.moduleManager.openLoadModuleDialog()
+
+    def actionNewSlot(self):
+        newModuleWiz = NewModuleWizard(self.moduleManager, self)
+        newModuleWiz.exec_()
+        return
+        
+    def actionSaveSlot(self):
+        self.moduleManager.save()
+        
+    def actionRunModuleSlot(self):
+        self.moduleManager.save()
+        if platform.system() == "Windows":
+            workingDir = self.prefDialog.moduleCfgPath.replace("/modules/modules.cfg", "")
+            executable = os.path.join(workingDir, "Rastullah.exe")
+            executable = executable.replace("/",  "\\")
+            if os.path.isfile(executable):
+                subprocess.Popen([executable, "--module", self.moduleManager.mainModule.name], 0, None, None, None, None, None, False, False, workingDir)
+
+        
+    def actionQuitSlot(self):
+        self.close()
+
+    def actionDeleteSlot(self):
+        self.moduleManager.deleteObjects()
+
+    def actionCopySlot(self):
+        self.moduleManager.copyObjects()
+
+    def actionCutSlot(self):
+        self.moduleManager.cutObjects()
+
+    def actionPasteSlot(self):
+        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
+
+    def actionSelectSlot(self):
+        self.moduleManager.pivot.hide()
+
+    def actionMoveSlot(self):
+        self.moduleManager.pivot.setMoveMode()
+
+    def actionRotateSlot(self):
+        self.moduleManager.pivot.setRotateMode()
+
+    def actionScaleSlot(self):
+        self.moduleManager.pivot.setScaleMode()
+
+    def actionOneClickEntityPlacementSlot(self):
+        self.moduleManager.setOneClickEntityPlacement(self.actionOneClickEntityPlacement.isChecked())
+
+    def togglePreferencesWindow(self):
+        if self.prefDialog.isHidden():
+            self.prefDialog.show()
+        else:
+            self.prefDialog.hide()
+
+    def toggleModelPreviewWindow(self):
+        if self.modelSelectionDock.isHidden():
+            self.modelSelectionDock.show()
+        else:
+            self.modelSelectionDock.hide()
+    
+    def toggleMaterialPreviewWindow(self):
+        if self.materialSelectionDock.isHidden():
+            self.materialSelectionDock.show()
+        else:
+            self.materialSelectionDock.hide()
+
+    def toggleGameObjectViewWindow(self):
+        if self.gameObjectClassViewDock.isHidden():
+            self.gameObjectClassViewDock.show()
+        else:
+            self.gameObjectClassViewDock.hide()
+
+    def toggleModuleExplorer(self):
+        if self.moduleExplorerDock.isHidden():
+            self.moduleExplorerDock.show()
+        else:
+            self.moduleExplorerDock.hide()
+            
+    def toggleModuleDirView(self):
+        if self.moduleDirectoryViewDock.isHidden():
+            self.moduleDirectoryViewDock.show()
+        else:
+            self.moduleDirectoryViewDock.hide()
+
+    def togglePropertyWindow(self):
+        if self.propertyDock.isHidden():
+            self.propertyDock.show()
+        else:
+            self.propertyDock.hide()
+
+    def toggleConsoleWindow(self):
+        if self.consoleDock.isHidden():
+            self.consoleDock.show()
+        else:
+            self.consoleDock.hide()
+
+    def toggleViewportGrid(self):
+        self.ogreMainWindow.toggleViewportGrid()
+
+    def createDockWindows(self):
+        self.modelSelectionDock = QtGui.QDockWidget(self.tr("Models"), self)
+        self.modelSelectionDock.setObjectName("ModelSelectionDockWindow")
+        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
+        
+        self.materialSelectionDock = QtGui.QDockWidget(self.tr("Materials"), self)
+        self.materialSelectionDock.setObjectName("MaterialSelectionDockWindow")
+        self.materialSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.materialSelectionDock.setWidget(self.materialSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.materialSelectionDock)
+        self.tabifyDockWidget(self.modelSelectionDock, self.materialSelectionDock)
+        
+        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr("GameObjectClasses"), self)
+        self.gameObjectClassViewDock.setObjectName("GameObjectClassView")
+        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)        
+        self.tabifyDockWidget(self.modelSelectionDock, self.gameObjectClassViewDock)
+        
+        self.propertyDock = QtGui.QDockWidget(self.tr("Properties"), self)
+        self.propertyDock.setObjectName("PropertyDockWindow")
+        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.propertyDock.setWidget(self.objectPropertyWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
+
+        self.moduleExplorerDock = QtGui.QDockWidget(self.tr("Module Explorer"), self)
+        self.moduleExplorerDock.setObjectName("ModuleExplorerDockWindow")
+        self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
+        self.tabifyDockWidget(self.moduleExplorerDock, self.propertyDock)
+        
+        self.moduleDirectoryViewDock = QtGui.QDockWidget(self.tr("Module Directory View"), self)
+        self.moduleDirectoryViewDock.setObjectName("ModuleDirectoryViewDockWindow")
+        self.moduleDirectoryViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.moduleDirectoryViewDock.setWidget(self.moduleDirectoryViewWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleDirectoryViewDock)
+        
+        self.consoleDock = QtGui.QDockWidget(self.tr("Console"), self)
+        self.consoleDock.setObjectName("ConsoleDockWindow")
+        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
+        self.consoleDock.setWidget(self.consoleWindow)
+        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
+
+        self.fileToolBar = self.addToolBar("File Toolbar")
+        self.fileToolBar.setObjectName("FileToolBar")
+        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.fileToolBar.addAction(self.actionNeu)
+        self.fileToolBar.addAction(self.actionOpen)
+        self.fileToolBar.addAction(self.actionSave)
+        self.fileToolBar.addAction(self.actionRunModule)
+        self.fileToolBar.addAction(self.actionClose)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
+
+        self.moveToolBar = self.addToolBar("Transformation Bar")
+        self.moveToolBar.setObjectName("TransformationBar")
+        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.moveToolBar.addAction(self.actionSelect)
+        self.moveToolBar.addAction(self.actionMove)
+        self.moveToolBar.addAction(self.actionRotate)
+        self.moveToolBar.addAction(self.actionScale)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
+
+    def keyPressEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreMainWindow.keyPressEvent(event)
+
+    def keyReleaseEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreMainWindow.keyReleaseEvent(event)
+        pass
+
+    def onContextMenuCallback(self, actions, menus):
+        menu = QMenu("My Menu!!")
+        menu.addAction(self.actionDelete)
+        menu.addAction(self.actionCopy)
+        menu.addAction(self.actionCut)
+        menu.addAction(self.actionPaste)
+        menu.addSeparator()
+        
+        for m in menus:
+            menu.addMenu(m)
+        for a in actions:
+            menu.addAction(a)
+
+        menu.exec_(QCursor.pos())
+
+    def connectActionButtons(self):
+        pass
+
+    def saveOnClose(self):
+#        reply = QtGui.QMessageBox.question(self,  "Rastullahs Lockenwickler - Unsaved Chages",  "Save unsaved changes?",  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
+#        if reply == QtGui.QMessageBox.Cancel:
+#            return False
+#        if reply == QtGui.QMessageBox.Yes:
+#            print""
+#            #TODO: implement save here
+        return True
+
+    def closeEvent(self,  event):
+        if self.saveOnClose():
+            settings = QtCore.QSettings()
+            settings.setValue("Preferences/moduleCfgPath", QtCore.QVariant(self.prefDialog.lineEdit.text()))
+            settings.setValue("MainWindow/Geometry",  QtCore.QVariant(self.saveGeometry()))
+            settings.setValue("MainWIndow/DockWindows",  QtCore.QVariant(self.saveState()))
+            
+            #self.ogreRoot.shutdown()
+        else:
+            event.ignore()
+
+if __name__ == "__main__":
+#    # Import Psyco if available
+#    try:
+#        import psyco
+#        psyco.full(0.02)
+#        #psyco.log()
+#        #psyco.profile()
+#    except ImportError:
+#        pass
+    
+    app = QtGui.QApplication(sys.argv)
+    app.setOrganizationName("Team Pantheon")
+    app.setOrganizationDomain("rastullahs-lockenpracht.de/team")
+    app.setApplicationName("Lockenwickler")
+
+    form = Lockenwickler()
+    form.show()
+
+    app.exec_()
+    
+    sys.exit(0)
+

Added: rl/trunk/editors/Lockenwickler/src/ModuleDirectoryView.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleDirectoryView.py	2009-04-15 16:43:40 UTC (rev 4898)
+++ rl/trunk/editors/Lockenwickler/src/ModuleDirectoryView.py	2009-04-15 17:58:20 UTC (rev 4899)
@@ -0,0 +1,43 @@
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import sys
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+
+class ModuleDirectoryView(QWidget):        
+    def __init__(self, parent = None):
+        super(ModuleDirectoryView, self).__init__(parent)
+        
+        self.model = QDirModel()
+        self.model.setReadOnly(False)
+        
+        self.tree = QTreeView()
+        self.tree.setModel(self.model)
+        
+        self.tree.setWindowTitle("Module Dir View")
+        layout = QVBoxLayout()
+        layout.setContentsMargins(0, 0, 0, 0)
+        layout.addWidget(self.tree)
+        self.setLayout(layout)
+        
+    def parseDirectory(self, dir):
+        self.tree.setRootIndex(self.model.index(dir));
+

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-04-15 16:43:40 UTC (rev 4898)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-04-15 17:58:20 UTC (rev 4899)
@@ -1,1392 +1,1397 @@
- #################################################
-# This source file is part of Rastullahs Lockenwickler.
-# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
-
-import sys
-import codecs
-import glob
-import os
-from os.path import isfile,  join
-
-import xml.etree.cElementTree as xml
-
-import ctypes
-import ogre.renderer.OGRE as og
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from SelectionBuffer import *
-from DepthBuffer import *
-from MovePivot import *
-from GameObjectClassManager import *
-from MyRaySceneQueryListener import *
-from ZoneManager import ZoneManager
-
-
-# get the light out of a light node
-def extractLight(node):
-        i = 0
-        num = node.numAttachedObjects()
-        while i < node.numAttachedObjects():
-            c = node.getAttachedObject(i)
-            tp = str(type(c))
-            if tp == "<class 'ogre.renderer.OGRE._ogre_.Light'>":
-                return c
-            
-            i += 1
-
-# make the xml file more pretty
-def indent(elem, level=0):
-    i = "\n" + level*"  "
-    
-    if len(elem):
-        if not elem.text or not elem.text.strip():
-            elem.text = i + "  "
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-        for elem in elem:
-            indent(elem, level+1)
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-    else:
-        if level and (not elem.tail or not elem.tail.strip()):
-            elem.tail = i
-
-# creates unique names for new entities
-def createUniqueEntityName(sceneManager, name = None):
-    n = ""
-    if name is None:
-        n = "dropMesh" + str(ModuleManager.dropCount)
-    else:
-        n = name
-        
-    while sceneManager.hasEntity(n):
-        n = "dropMesh" + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-    return n
-        
-def printVector3(vec):
-    print str(vec.x) + ";" + str(vec.y) + ";" + str(vec.z)
-    
-class EntityCustomOptions(og.UserDefinedObject):
-    def __init__(self, receivesShadow = True, staticgeometrygroup = 0, physicsproxytype = "none", renderingdistance = "20000"):
-        og.UserDefinedObject.__init__(self)
-        self.receivesShadow = receivesShadow
-        self.staticgeometrygroup = staticgeometrygroup
-        self.physicsproxytype = physicsproxytype
-        self.renderingdistance = renderingdistance
-        self.materialName = "NotChanged"
-        
-        ModuleManager.entityCustomOptionsDict.append(self)
-        
-    def copy(self):
-            return EntityCustomOptions(self.receivesShadow, self.staticgeometrygroup, self.physicsproxytype, self.renderingdistance)
-        
-    def getType(self):
-            return "EntityCustomOptions"
-
-class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyMap = False):
-        self.pathToMapFile = pathToFile
-        
-        mapName = pathToFile.replace("\\", "/")
-        mapName = mapName.split("/")
-        mapName = mapName[len(mapName) - 1].split(".")
-        mapName = mapName[len(mapName) - 3]
-        self.mapName = mapName
-        self.mapFileName = self.mapName + ".rlmap.xml"
-        
-        self.sceneManager = sceneManager
-        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-        self.zoneManager = zoneManager
-        self.isHidden = False
-        
-        self.zoneList = []
-        
-        if not emptyMap:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-
-            if root.attrib["formatVersion"] == "0.4.0":
-                self.parseMapNodes(root.find("nodes"))
-                self.parseMapZones(root.find("zones"))
-            else:
-                print pathToFile + " has wrong format version. It needs to be 0.4.0"
-                return
-
-    def hide(self):
-        try:
-            self.sceneManager.getRootSceneNode().removeChild(self.mapNode)
-        except:
-            print "Error: map is already hidden!"
-            return
-        
-        self.isHidden = True
-        
-    def show(self):
-        try:
-            self.sceneManager.getRootSceneNode().addChild(self.mapNode)
-        except:
-            print "Error: map is already shown!"
-            return
-        
-        self.isHidden = False
-    
-    def parseMapZones(self, zonesElement):
-        self.zoneManager.parseZonesFromXml(zonesElement, self)
-    
-    def parseMapNodes(self, nodeElement):
-        nodes = nodeElement.getiterator("gameobject")
-        self.createGameObjects(nodes)
-        
-        nodes = nodeElement.getiterator("entity")
-        self.createEntites(nodes)
-
-        nodes = nodeElement.getiterator("light")
-        self.createLights(nodes)
-
-        nodes = nodeElement.getiterator("sound")
-        self.createSound(nodes)
-
-        nodes = nodeElement.getiterator("particlesystem")
-        self.createParticleSystems(nodes)
-
-    def createEntites(self, entityNodes):
-        for nodes in entityNodes:
-            entityName = nodes.attrib["name"]
-            
-            if entityName.startswith("dropMesh"):
-                num = int(entityName.replace("dropMesh",  ""))
-                if ModuleManager.dropCount < num:
-                    ModuleManager.dropCount = num
-                elif ModuleManager.dropCount < num:
-                    ModuleManager.dropCount = num + 1
-                    
-            meshFile = nodes.attrib["meshfile"]
-            
-            eco = EntityCustomOptions()
-            
-            try:
-                if nodes.attrib["receivesShadow"] == "False" or nodes.attrib["receivesShadow"] == "false":
-                    eco.receivesShadow = "False"
-            except:
-                pass
-            try:
-                eco.staticgeometrygroup = int(nodes.attrib["staticgeometrygroup"])
-            except:
-                pass
-            try:
-                eco.physicsproxy = nodes.attrib["physicsproxy"]
-            except:
-                pass
-            try:
-                eco.renderingdistance = float(nodes.attrib["renderingdistance"])
-            except:
-                pass
-            try:
-                eco.renderingdistance
-                nodes.attrib["materialName"]
-            except:
-                pass
-                
-            nodePosition = None
-            nodeScale = None
-            qw = qx = qy = qz = None
-
-            transformations = nodes.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    posx = float(t.attrib["x"])
-                    posy = float(t.attrib["y"])
-                    posz = float(t.attrib["z"])
-                    nodePosition = og.Vector3(posx, posy, posz)
-                elif t.tag == "rotation":
-                    qw = float(t.attrib["qw"])
-                    qx = float(t.attrib["qx"])
-                    qy = float(t.attrib["qy"])
-                    qz = float(t.attrib["qz"])
-                elif t.tag == "scale":
-                    scalex = float(t.attrib["x"])
-                    scaley = float(t.attrib["y"])
-                    scalez = float(t.attrib["z"])
-                    nodeScale = og.Vector3(scalex, scaley, scalez)
-
-            try:
-                e = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager,  entityName), meshFile)
-            except:
-                print "Warning: Meshfile " + meshFile + " could not be found."
-                return
-
-            e.setUserObject(eco)
-            n = self.mapNode.createChild("entity_" + entityName + "_node")
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            n.setOrientation(qw, qx, qy, qz)
-            n.setScale(nodeScale)
-
-    def createLights(self, lightNodes):
-        for l in lightNodes:
-            lightName = l.attrib["name"]
-            lightType = l.attrib["type"]
-            lightVisible = bool(l.attrib["visible"])
-            castShadows = bool(l.attrib["castShadows"])
-            lightPosition = None
-            lightDirection = None
-            colourDiffuse = None
-            colourSpecular = None
-            lightAttenuationRange = None
-            lightAttenuationConstant= None
-            lightAttenuationLinear = None
-            lightAttenuationQuadratic = None
-            spotlightinner = None
-            spotlightouter = None
-            falloff = None 
-                
-            transformations = l.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    lightPosition = og.Vector3(x, y, z)
-                elif t.tag == "colourDiffuse":
-                    r = float(t.attrib["r"])
-                    g = float(t.attrib["g"])
-                    b= float(t.attrib["b"])
-                    colourDiffuse = og.ColourValue(r, g, b)
-                elif t.tag == "colourSpecular":
-                    r = float(t.attrib["r"])
-                    g = float(t.attrib["g"])
-                    b= float(t.attrib["b"])
-                    colourSpecular = og.ColourValue(r, g, b)
-                elif t.tag == "lightAttenuation":
-                    lightAttenuationRange = float(t.attrib["range"])
-                    lightAttenuationConstant= float(t.attrib["constant"])
-                    lightAttenuationLinear = float(t.attrib["linear"])
-                    lightAttenuationQuadric  = float(t.attrib["quadratic"])
-                elif t.tag == "spotlightrange":
-                    spotlightinner = float(t.attrib["inner"])
-                    spotlightouter = float(t.attrib["outer"])
-                    falloff = float(t.attrib["falloff"])
-                    
-            light = self.sceneManager.createLight(lightName)
-            
-            if lightType == "point":
-                light.setType(og.Light.LT_POINT)            
-            elif lightType == "spot":
-                light.setType(og.Light.LT_SPOTLIGHT)
-            elif lightType == "directional":
-                light.setType(og.Light.LT_DIRECTIONAL)
-            
-            light.setVisible(lightVisible)
-            light.setCastShadows(castShadows)
-            if lightAttenuationRange is not None and lightAttenuationConstant is not None and lightAttenuationLinear is not None and lightAttenuationQuadric is not None:
-                light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadric)
-            if colourDiffuse:
-                light.setDiffuseColour(colourDiffuse)
-            if colourSpecular:
-                light.setSpecularColour(colourSpecular)
-            if spotlightinner and spotlightouter and spotlightouter: 
-                light.setSpotlightRange(spotlightinner, spotlightouter, falloff)
-            
-            e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
-            n = self.mapNode.createChild("light_" + lightName + "_node")
-            n.attachObject(light)
-            n.attachObject(e)
-            if lightPosition:
-                n.setPosition(lightPosition)
-            
-    def createSound(self, soundNodes):
-        #raise NotImplementedError
-        return
-
-    def createGameObjects(self, gameObjectNodes):
-        for g in gameObjectNodes:
-            classid = g.attrib["class"]
-            
-            id = int(g.attrib["id"])
-            if ModuleManager.dropCount < id:
-                ModuleManager.dropCount = id
-            elif ModuleManager.dropCount < id:
-                ModuleManager.dropCount = id + 1
-                
-            state = g.attrib["state"]
-            nodePosition = None
-            nodeRotation = None
-            properties = {}
-            
-            transformations = g.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    nodePosition = og.Vector3(x, y, z)
-                elif t.tag == "rotation":
-                    qw = float(t.attrib["qw"])
-                    qx = float(t.attrib["qx"])
-                    qy = float(t.attrib["qy"])
-                    qz = float(t.attrib["qz"])
-                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
-                elif t.tag == "property":
-                    name = t.attrib["name"]
-                    type = t.attrib["type"]
-                    data = t.attrib["data"]
-                    properties[name] = GameObjectRepresentation.PropertieRepresentation(name, type, data)
-
-            go = self.gocManager.getGameObjectWithClassId(classid)
-            if go is not None:
-                meshFile = go.getMeshFileName()
-                
-                ent = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-                dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
-                dropNode.attachObject(ent)
-
-                if nodePosition:
-                    dropNode.setPosition(nodePosition)
-                if nodeRotation:
-                    dropNode.setOrientation(nodeRotation)
-
-                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
-                self.gocManager.addGameObjectRepresentation(go)
-                go.inWorldId = id
-                go.state = state
-                go.propertieDict = properties
-                ent.setUserObject(go)
-
-
-    def createParticleSystems(self, particleNodes):
-        #raise NotImplementedError
-        return
-        
-    def save(self):
-        root = xml.Element("rastullahmap")
-        root.attrib["formatVersion"] = "0.4.0"
-        
-        nodesElem = xml.SubElement(root, "nodes")
-        
-        i = 0
-        while i < self.mapNode.numChildren():
-            n = self.mapNode.getChild(i)
-            if n.numAttachedObjects() > 0:
-                if n.name.startswith("entity_"):
-                    entElem = xml.SubElement(nodesElem, "entity")
-                    entElem.attrib["name"] = n.getAttachedObject(0).getName()
-                    entName = n.getAttachedObject(0).getName()
-                    #print "Saving Entity: " + n.getAttachedObject(0).getName()
-                    entElem.attrib["meshfile"] = n.getAttachedObject(0).getMesh().getName()
-   
-                    entElem.attrib["receivesShadow"] = str(n.getAttachedObject(0).getUserObject().receivesShadow).lower()
-                    entElem.attrib["staticgeometrygroup"] = str(n.getAttachedObject(0).getUserObject().staticgeometrygroup)
-                    entElem.attrib["physicsproxytype"] = str(n.getAttachedObject(0).getUserObject().physicsproxytype)
-                    entElem.attrib["renderingdistance"] = str(n.getAttachedObject(0).getUserObject().renderingdistance)
-                    
-                    posElem = xml.SubElement(entElem, "position")
-                    posElem.attrib["x"] = str(n.getPosition().x)
-                    posElem.attrib["y"] = str(n.getPosition().y)
-                    posElem.attrib["z"] = str(n.getPosition().z)
-                    
-                    rotElem = xml.SubElement(entElem, "rotation")
-                    rotElem.attrib["qw"] = str(n.getOrientation().w)
-                    rotElem.attrib["qx"] = str(n.getOrientation().x)
-                    rotElem.attrib["qy"] = str(n.getOrientation().y)
-                    rotElem.attrib["qz"] = str(n.getOrientation().z)
-                    
-                    scaleElem = xml.SubElement(entElem, "scale")
-                    scaleElem.attrib["x"] = str(n.getScale().x)
-                    scaleElem.attrib["y"] = str(n.getScale().y)
-                    scaleElem.attrib["z"] = str(n.getScale().z)
-                    
-                elif n.name.startswith("gameobject_"):
-                    goElem = xml.SubElement(nodesElem, "gameobject")
-                    mname = n.name
-                    #print "Saving GOID: " + str(n.getAttachedObject(0).getUserObject().inWorldId)
-                    goElem.attrib["class"] = str(n.getAttachedObject(0).getUserObject().gocName)
-                    goElem.attrib["state"] = str(n.getAttachedObject(0).getUserObject().state)
-                    goElem.attrib["id"] = str(n.getAttachedObject(0).getUserObject().inWorldId)
-                    
-                    posElem = xml.SubElement(goElem, "position")
-                    posElem.attrib["x"] = str(n.getPosition().x)
-                    posElem.attrib["y"] = str(n.getPosition().y)
-                    posElem.attrib["z"] = str(n.getPosition().z)
-                    
-                    rotElem = xml.SubElement(goElem, "rotation")
-                    rotElem.attrib["qw"] = str(n.getOrientation().w)
-                    rotElem.attrib["qx"] = str(n.getOrientation().x)
-                    rotElem.attrib["qy"] = str(n.getOrientation().y)
-                    rotElem.attrib["qz"] = str(n.getOrientation().z)
-                    
-                    dict = n.getAttachedObject(0).getUserObject().propertieDict
-                    for key in dict:
-                        prop = dict[key]
-                        rotElem = xml.SubElement(goElem, "property")
-                        rotElem.attrib["name"] = prop.name
-                        rotElem.attrib["type"] = prop.type
-                        rotElem.attrib["data"] = prop.data
-
-                    
-                elif n.name.startswith("light_"):
-                    light = extractLight(n)
-                    lightName = light.getName()
-                    #print "Saving Light: " + lightName
-                    lightType = light.getType()
-                    isVisible = "true"
-                    if not light.getVisible():
-                        isVisible = "false"
-                    
-                    castShadows = "false"
-                    if light.getCastShadows():
-                        castShadows = "true"
-                    
-                    if lightType == og.Light.LT_POINT:
-                        lightType = "point"
-                    elif lightType == og.Light.LT_SPOTLIGHT:
-                        lightType = "spot"
-                    elif lightType == og.Light.LT_DIRECTIONAL:
-                        lightType = "directional"
-                    
-                    
-                    lightElem = xml.SubElement(nodesElem, "light")
-                    lightElem.attrib["name"] = lightName
-                    lightElem.attrib["type"] = lightType
-                    lightElem.attrib["visible"] = isVisible
-                    lightElem.attrib["castShadows"] = castShadows
-                    
-                    if lightType == "point" or lightType == "spot":
-                        posElem = xml.SubElement(lightElem, "position")
-                        posElem.attrib["x"] = str(n.getPosition().x)
-                        posElem.attrib["y"] = str(n.getPosition().y)
-                        posElem.attrib["z"] = str(n.getPosition().z)
-                    
-                    colDiffuseElem = xml.SubElement(lightElem, "colourDiffuse")
-                    colDiffuseElem.attrib["r"] = str(light.getDiffuseColour().r)
-                    colDiffuseElem.attrib["g"] = str(light.getDiffuseColour().g)
-                    colDiffuseElem.attrib["b"] = str(light.getDiffuseColour().b)
-
-                    colSpecularElem = xml.SubElement(lightElem, "colourSpecular")
-                    colSpecularElem.attrib["r"] = str(light.getSpecularColour().r)
-                    colSpecularElem.attrib["g"] = str(light.getSpecularColour().g)
-                    colSpecularElem.attrib["b"] = str(light.getSpecularColour().b)
-                    
-                    lightAttenuationElem = xml.SubElement(lightElem, "lightAttenuation")
-                    lightAttenuationElem.attrib["range"] = str(light.getAttenuationRange())
-                    lightAttenuationElem.attrib["constant"] = str(light.getAttenuationConstant())
-                    lightAttenuationElem.attrib["linear"] = str(light.getAttenuationLinear())
-                    lightAttenuationElem.attrib["quadratic"] = str(light.getAttenuationQuadric())
-                    
-                    if lightType == "spot":
-                        spotligthRangeElem = xml.SubElement(lightElem, "spotlightrange")
-                        spotligthRangeElem.attrib["inner"] = str(light.getSpotlightInnerAngle().valueDegrees())
-                        spotligthRangeElem.attrib["outer"] = str(light.getSpotlightOuterAngle().valueDegrees())
-                        spotligthRangeElem.attrib["falloff"] = str(light.getSpotlightFalloff())
-                        
-                    if lightType == "spot" or lightType == "directional":
-                        directionElem = xml.SubElement(lightElem, "direction")
-                        dir = og.Vector3()
-                        n.getOrientation().ToAxes(dir)
-                        directionElem.attrib["x"] = str(dir.x)
-                        directionElem.attrib["y"] = str(dir.y)
-                        directionElem.attrib["z"] = str(dir.z)
-                        
-            i = i+1
-            
-        self.zoneManager.saveZonesToXml(root, self)
-        indent(root)
-        xml.ElementTree(root).write(self.pathToMapFile)
-
-# caused a linux crash
-#        iter = self.mapNode.getChildIterator()
-#        while iter.hasMoreElements():
-#            name = iter.getNext().getName()
-#            print name
-
-class Scene():
-    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyScene = False, sceneName = "NewScene"):
-        self.moduleRoot = moduleroot
-        self.pathToFile = pathToFile
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-        self.zoneManager = zoneManager
-        self.mapFiles = [] # a list in case the module has more than one map file
-        mappaths = []
-        self.name = sceneName
-
-        
-        if not emptyScene:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-            self.name = root.attrib["name"]
-        
-            maps = root.getiterator("map")
-            for m in maps:
-                mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
-                
-            for m in mappaths:
-                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
-            
-    def addMap(self, name):
-        path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
-        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True))
-        
-    def save(self):
-        root = xml.Element("scene")
-        root.attrib["name"] = self.name
-        
-        for m in self.mapFiles:
-            sub = xml.SubElement(root, "map")
-            sub.attrib["file"] = m.mapFileName
-            m.save()
-
-        indent(root)
-        xml.ElementTree(root).write(self.pathToFile)
-
-class Module():
-    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager, zoneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gameObjectManager
-        self.zoneManager = zoneManager
-        
-        self.name = name
-        self.moduleRoot = join(modulePath, name)
-        self.__isCommon = False
-
-        self.hasDependencies = False
-        self.moduleDependencies = []
-
-        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
-
-        self.gofFiles = [] # gof File list
-
-        self.scenes =[]
-
-        self.isLoaded = False
-        
-        self.playerStart = None
-        
-    def addScene(self, name):
-        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True, name))
-    
-    def addMapToScene(self, sceneName, mapName):
-        for scene in self.scenes:
-            if scene.name == sceneName:
-                scene.addMap(mapName)
-                return
-        
-        print "ERROR: could not find scene: " + sceneName
-        
-    
-    def isCommon(self):
-        if isfile(self.modConfig): # is the modconfig existing?
-            f = codecs.open(self.modConfig, 'r', 'utf-8')
-        else:
-            print ("Module.isCommon() Error: couldn't find module config")
-            return
-        isDependencieLine = False
-        for i, line in enumerate(f):
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith("super("):
-                split = lStripped.split(",")
-                if split[2].strip() == unicode("true"):
-                    self.__isCommon = True
-                    return True
-
-
-            elif isDependencieLine:
-                if lStripped == "end":
-                    isDependencieLine = False
-                else:
-                    self.hasDependencies = True
-                    pl = lStripped.split('"')
-                    i = 1
-                    while i < 100: 
-                        try:
-                            self.moduleDependencies.append(pl[i])
-                            i += 2
-                        except IndexError, e:
-                            break
-
-            elif lStripped == "def getDependencies()":
-                isDependencieLine = True
-
-        return False
-
-    def load(self):
-        if self.isLoaded:
-            return
-        
-        self.isLoaded = True
-        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
-        if isfile(self.modConfig): # is the modconfig existing?
-            f = codecs.open(self.modConfig, 'r', 'utf-8')
-        else:
-            print ("Module.load: Error: couldn't find module config")
-            return
-
-        for line in f:
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith("hero = $GOM.getGameObject("):
-                try:
-                    self.playerStart = int(line.split("(")[1].split(")")[0])
-                except ValueError, e:
-                    print self.modConfig + " ValueError: " + str(e)
-                    self.playerStart = None
-                    continue
-                    
-        self.setResourcePaths()
-        
-        try:
-            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-        except og.OgreException, e:
-            print e
-        
-        
-        cmd = join(self.moduleRoot, "dsa/*.gof")
-        self.gofFiles = glob.glob(cmd)
-        self.gocManager.parseGOFFiles(self.gofFiles)
-
-        if not self.isCommon():
-            cmd = join(self.moduleRoot, "maps/*.rlscene")
-            sceneFile = glob.glob(cmd)
-            self.loadScenes(sceneFile)
-                
-    def loadScenes(self, sceneFiles):
-        for s in sceneFiles:
-            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
-
-    def save(self):
-        for s in self.scenes:
-            s.save()
-            
-        self.saveModuleConfig()
-
-    def saveModuleConfig(self):
-        if self.playerStart is not None:
-            f = open(self.modConfig, "r")
-            
-            newconfig = ""
-            for line in f:
-                if line.startswith("       hero = $GOM.getGameObject("):
-                    newconfig += "       hero = $GOM.getGameObject(" + str(self.playerStart) + ");\n"
-                else:
-                    newconfig += line
-            f.close()
-            
-            f = open(self.modConfig, "w")
-            f.write(newconfig)
-            f.close()
-
-    def setResourcePaths(self, recurseFolder = ""):
-        if recurseFolder == "":
-            rootFolder = self.moduleRoot
-        else:
-            rootFolder = join(self.moduleRoot, recurseFolder)
-
-        for file in os.listdir(rootFolder):
-            curFile = join(rootFolder, file)
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            elif os.path.isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
-                self.setResourcePaths(curFile)
-            elif os.path.isfile(curFile):
-                continue
-                
-    def getMap(self, mapName, sceneName = None):
-        if sceneName is not None:
-            for s in self.scenes:
-                if s.name == sceneName:
-                    for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-        else:
-            for s in self.scenes:
-                for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-
-class ProgressBarThread(QThread):
-    def __init__(self, min, max, moduleName):
-        QThread.__init__(self)
-        self.progress = QProgressDialog("Loading " + moduleName, "Abort Loading", min, max, None);
-        self.progress.setWindowModality(Qt.WindowModal)
-
-    def setProgress(self, progress, labelText):
-        self.progress.setLabelText(labelText)
-        self.progress.setValue(progress)
-        
-    def run(self):
-        self.progress.show()
-        self.exec_()
-
-        
-class ModuleManager():
-    dropCount = 0
-    entityCustomOptionsDict = []
-    
-    def __init__(self,  ogreRoot,  sceneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.modelSelectionDialog = None
-        self.materialSelectionDialog = None
-
-        self.moduleCfgPath = ""
-
-        self.gocManager = GameObjectClassManager()
-        
-
-        self.mainModule = None
-        self.mainModuledependencieList =[]
-        self.moduleList = []
-        self.userSelectionList = []
-        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
-        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-        self.currentMap = None
-        self.moduleExplorer = None
-
-        self.lastRay = None
-        self.rayLine = None
-
-        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
-        self.pivot = None
-        self.movingPivot = False
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.dropNode = None
-        self.dropEntity = None
-        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
-        self.dropMat = None
-        
-        self.moduleConfigIsParsed = False
-
-        self.selectionBuffer = None
-        self.depthBuffer = None
-        self.propertyWindow = None
-    
-        self.oneClickEntityPlacement = False
-        
-        self.onContextMenuCallback = None
-        self.contextMenuClickPosition = None
-        self.contextMenuRay = None
-        
-        self.playerStartGameObjectId = None
-        
-        self.entityCustomOptionsDict = []
-        
-        self.raySceneQueryListener = MyRaySceneQueryListener()
-        
-        self.zoneManager = ZoneManager(self.sceneManager)
-        
-    def resetParsedModuleConfig(self):
-        self.moduleConfigIsParsed = False
-        self.moduleList = []
-
-    def parseModuleConfig(self):
-        if self.moduleConfigIsParsed:
-            return
-
-        import codecs
-        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
-
-        for line in f:
-            if line.startswith('#'):
-                continue
-
-            if line.startswith('module='):
-                splines = line.split('=')
-                str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
-
-        self.moduleConfigIsParsed = True
-
-    def moduleExists(self, name):
-        lowerA = str(name).lower()
-        
-        for m in self.moduleList:
-            lowerB = m.name.lower()
-            if lowerA == lowerB:
-                return True
-        
-        return False
-
-    def openLoadModuleDialog(self):
-        self.moduleFolder = str(self.moduleCfgPath.replace("modules.cfg", ""))
-
-        self.parseModuleConfig()
-
-        dlg = QDialog(QApplication.focusWidget())
-        list = QListWidget()
-        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
-        dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
-        dlg.connect(btnBox, SIGNAL("rejected()"), dlg.reject)
-
-        for m in self.moduleList:
-            if not m.isCommon():
-                list.addItem(m.name)
-
-        layout = QVBoxLayout()
-        layout.addWidget(list)
-        layout.addWidget(btnBox)
-        dlg.setLayout(layout)
-        if dlg.exec_():
-            self.loadModule(str(list.currentItem().text()))
-
-    # I'm sorry for this
-    def loadModule(self, moduleName):
-        t = og.Timer()
-        
-#        self.progress = ProgressBarThread(0, 8, moduleName)
-#        self.progress.start()
-        
-        for m in self.moduleList:
-            if m.name == moduleName:
-                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
-                    for moduleDependencie in m.moduleDependencies:
-                        for m2 in self.moduleList:
-                            if m2.name == moduleDependencie:
-#                                self.progress.setProgress(2, "Loading Dependencie: " + moduleDependencie)
-                                m2.load()
-                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
-                                self.materialSelectionDialog.scanDirForMaterials(m2.moduleRoot)
-                                self.mainModuledependencieList.append(m2)
-
-#                self.progress.setProgress(4, "Loading " + moduleName)
-                m.load()
-#                self.progress.setProgress(6, "Scan for models...")
-                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
-#                self.progress.setProgress(8, "Scan for materials")
-                self.materialSelectionDialog.scanDirForMaterials(m.moduleRoot)
-                self.mainModule = m
-                self.moduleExplorer.setCurrentModule(m)
-
-        if self.selectionBuffer is None:
-            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"), self, self.zoneManager)
-
-#        if self.depthBuffer is None:
-#            self.depthBuffer = DepthBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
-
-
-#        self.progress.quit()
-        print "Time to load module: " + str(t.getMilliseconds() / 1000.0) + " seconds"
-        del t
-
-    def addSceneToModule(self, name):
-        if self.mainModule is not None:
-            self.mainModule.addScene(name)
-
-    def addMapToScene(self, sceneName, mapName):
-        if self.mainModule is not None:
-            self.mainModule.addMapToScene(sceneName, mapName)
-
-    def setModuleExplorer(self, moduleExplorer):
-        self.moduleExplorer = moduleExplorer
-        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
-        self.moduleExplorer.setSelectionChangedCallback(self.selectionChangedCallback)
-        self.moduleExplorer.setModuleManager(self)
-    
-    def setPropertyWindow(self, propertyWin):
-        self.propertyWindow = propertyWin
-    
-    def selectionChangedCallback(self, items):
-        self.resetSelection()
-        self.userSelectionList = self.selectionBuffer.manualSelectObjects(items)
-        
-        print len(self.userSelectionList)
-        
-        if len(self.userSelectionList) > 1:
-            self.propertyWindow.clear()
-        elif len(self.userSelectionList) > 0 and len(self.userSelectionList) < 2:
-            self.propertyWindow.showProperties(self.userSelectionList[0])
-        else:
-            return
-            
-        self.updatePivots()
-        
-    def selectMapCallback(self, sceneName, mapName):
-        self.currentMap = self.mainModule.getMap(mapName, sceneName)
-        self.zoneManager.currentMap = self.currentMap
-        if self.currentMap is None:
-            print "Don't forget to select a map"
-
-        
-    # called when a click into Main Ogre Window occurs
-    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
-        if self.oneClickEntityPlacement:
-            if self.modelSelectionDialog.listWidget.currentItem() is not None:
-                meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
-                self.startDropModelAction(meshFile, ray)
-                self.moduleExplorer.updateView()
-                return
-            else:
-                print "Warning: OneClickEntityPlacement still runing on without any selected mesh!"
-                return
-                
-        #self.depthBuffer.onSelectionClick(screenX, screenY)
-        
-        so = None
-        if self.selectionBuffer is not None:
-            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        
-        if so is not None:
-            if not so.isPivot:                
-                if not controlDown and not shiftDown:
-                    self.resetSelection()
-                    so.setSelected(True)
-                    self.userSelectionList.append(so)
-                    self.propertyWindow.showProperties(so)
-                    self.moduleExplorer.deselectAll()
-                    self.moduleExplorer.selectItem(so, True)
-                    self.updatePivots()
-                elif controlDown and not shiftDown:
-                    so.setSelected(True)
-
-                    for soFromList in self.userSelectionList:
-                        if soFromList == so:
-                            return # object already selected
-
-                    self.userSelectionList.append(so)
-                    self.propertyWindow.showProperties(so)
-                    self.moduleExplorer.selectItem(so, True)
-                    self.updatePivots()
-
-
-                elif not controlDown and shiftDown:
-                    for selo in self.userSelectionList:
-                        if so == selo:
-                            so.setSelected(False)
-                            self.userSelectionList.remove(selo)
-                            self.moduleExplorer.selectItem(selo, False)
-                    self.updatePivots()
-                
-            else:
-                #so.entity is the pivot direction that was clicked
-                self.pivot.startTransforming(so.entity,  self.userSelectionList)
-        else:
-            self.resetSelection() # click in empty space, deselect everything
-            self.moduleExplorer.selectItems(None)
-            self.propertyWindow.clear()
-            if self.pivot is not None:
-                self.pivot.hide()
-
-#        if self.rayLine == None:
-#            self.rayLine = self.sceneManager.createManualObject("rayLine")
-#            self.rayLine.setDynamic(True)
-#            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
-#
-#            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-#
-#        else:
-#            self.rayLine.beginUpdate(0)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-
-    def deleteObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.pivot.hide()
-
-        for so in self.userSelectionList:
-            node = so.entity.getParentNode()
-            if node.getName().startswith("area_"):
-                self.zoneManager.deleteArea(so.entity.getUserObject())
-                continue
-            elif node.getName().startswith("light_"):
-                light = extractLight(node)
-                self.sceneManager.destroyLight(light)
-                
-            node.detachAllObjects()
-            self.sceneManager.destroySceneNode(node)
-            self.sceneManager.destroyEntity(so.entity)
-            del so
-        
-        self.userSelectionList = []
-        self.moduleExplorer.updateView()
-        
-    def copyObjects(self):
-        if len(self.userSelectionList) < 1 or self.currentMap is None:
-            print "Warning: No map selected!"
-            return
-
-        self.newSelectionList = []
-
-        for so in self.userSelectionList:
-            if so.entity.getUserObject() is not None:
-                if str(so.entity.getParentNode().getName()).startswith("gameobject_"):
-                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
-                    meshFile = go.getMeshFileName()
-
-                    if go is not None:
-                        newEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-                        newNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
-                        newNode.attachObject(newEntity)
-                        newNode.setPosition(so.entity.getParentNode().getPosition())
-
-                        newGO = GameObjectRepresentation(ModuleManager.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
-                        self.gocManager.addGameObjectRepresentation(newGO)
-                        newEntity.setUserObject(newGO)
-
-                        newSO = SelectionObject(newEntity)
-                        newSO.setSelected(True)
-                        self.newSelectionList.append(newSO)
-                        ModuleManager.dropCount += 1
-                elif str(so.entity.getParentNode().getName()).startswith("entity_"):
-                    nodeName = "entity_dropNode" + str(ModuleManager.dropCount)
-                    newNode = self.currentMap.mapNode.createChild(nodeName)
-
-                    entityName = createUniqueEntityName(self.sceneManager)
-                    newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
-
-                    eco = so.entity.getUserObject().copy()
-                    newEntity.setUserObject(eco)
-
-                    newNode.attachObject(newEntity)
-                    newNode.setPosition(so.entity.getParentNode().getPosition())
-                    newNode.setOrientation(so.entity.getParentNode().getOrientation())
-                    newNode.setScale(so.entity.getParentNode().getScale())
-
-                    newSO = SelectionObject(newEntity)
-                    newSO.setSelected(True)
-                    self.newSelectionList.append(newSO)
-                    ModuleManager.dropCount += 1
-                elif str(so.entity.getParentNode().getName()).startswith("light_"):
-                    print "Can't copy lights yet :)"
-
-        self.resetSelection()
-        self.userSelectionList = self.newSelectionList
-        self.moduleExplorer.updateView()
-        for so in self.userSelectionList:
-            self.moduleExplorer.selectItem(so, True)
-        self.updatePivots()
-
-        
-    def cutObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.cutList = []
-        for so in self.userSelectionList:
-            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
-            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
-            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
-            # so we only have to translate them to their new destination when they get pasted
-            # the position of the pivot point is considered as the center of gravity
-            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
-            self.cutList.append(so)
-        self.resetSelection()
-        self.moduleExplorer.updateView()
-        
-    def pasteObjects(self,  ray):
-        if len(self.cutList) < 1:
-            return
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
-                i = i+1
-        else:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
-                i = i+1
-        self.cutList = []
-        self.moduleExplorer.updateView()
-        
-    def leftMouseUp(self):
-        if self.pivot is not None and self.pivot.isTransforming:
-            self.propertyWindow.updateProperties()
-            self.pivot.stopTransforming()
-
-    def resetSelection(self):
-        if self.userSelectionList is not None:
-            for so in self.userSelectionList:
-                so.setSelected(False)
-
-        self.userSelectionList = []
-
-    def updatePivots(self):
-        newPivotPosition = og.Vector3(0, 0, 0)
-
-        for so in self.userSelectionList:
-            newPivotPosition += so.entity.getParentNode().getPosition()
-        if self.pivot is not None and len(self.userSelectionList) > 0:
-            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
-
-    def unload(self,  saveOnUnload=True):
-        pass
-
-    def save(self):
-        self.mainModule.save()
-
-    def startDropGameObjectAction(self, classid, ray):
-        if self.currentMap is None:
-            print "No map selected!"
-            return
-            
-        go = self.gocManager.getGameObjectWithClassId(classid)
-
-        if go is not None:
-            meshFile = go.getMeshFileName()
-            dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
-            dropNode.attachObject(dropEntity)
-
-            result = og.Math.intersects(ray, self.dropCollisionPlane)
-            if result.first == True:
-                dropNode.setPosition(ray.getPoint(result.second))
-            else:
-                dropNode.setPosition(ray.getPoint(50))
-
-            self.dropGO = GameObjectRepresentation(ModuleManager.dropCount, classid, dropNode, meshFile)
-            self.gocManager.addGameObjectRepresentation(self.dropGO)
-            dropEntity.setUserObject(self.dropGO)
-
-        ModuleManager.dropCount += 1
-
-    def moveDropGameObjectAction(self, ray):
-        if self.currentMap is None:
-            return
-        
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropGO.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropGO.setPosition(ray.getPoint(50))
-
-    def finishDropGameObjectAction(self, ray):
-        self.moduleExplorer.updateView()
-        self.dropGO = None
-        return
-
-    def startDropModelAction(self, meshFile, ray):
-        if self.currentMap is None:
-            print "No map selected!"
-            return
-            
-        self.dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), meshFile)
-        
-        eco = EntityCustomOptions()
-        self.dropEntity.setUserObject(eco)
-        
-        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(ModuleManager.dropCount))
-        self.dropNode.attachObject(self.dropEntity)
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-        ModuleManager.dropCount += 1
-
-    def moveDropModelAction(self, ray):
-        if self.currentMap is None:
-            return
-            
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-    
-    def finishDropModelAction(self, ray):
-        self.moduleExplorer.updateView()
-        return
-
-    def startDropMaterialAction(self, text):
-        self.dropMat = text
-        
-    def moveDropMaterialAction(self, event):
-        return
-
-    def finishDropMaterialAction(self, screenX, screenY):
-        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        if so is not None:
-            if not so.entity.getNumSubEntities() > 1:
-                so.entity.setMaterialName(self.dropMat)
-                so.entity.getUserObject().materialName = self.dropMat
-            else:
-                i = 0
-                text = "Warning this Entity has more than one SubEntities with the folloing materials: \n\n"
-                while i < so.entity.getNumSubEntities():
-                    text += "SubMesh" + str(i) + ":  " + so.entity.getSubEntity(i).getMaterialName() + "\n"
-                    i += 1
-                
-                text += "\n Replace the materials?"
-                reply = QMessageBox.question(None, "Warning: multiple materials",  text,  QMessageBox.Yes|QMessageBox.No)
-                if reply == QMessageBox.Cancel:
-                    return
-                if reply == QMessageBox.Yes:
-                    so.entity.setMaterialName(self.dropMat)
-                    so.entity.getUserObject().materialName = self.dropMat
-        
-    def setOneClickEntityPlacement(self, state):
-        self.oneClickEntityPlacement = state
-    
-    def createLight(self, name):
-        pos = og.Vector3()
-        
-        query = self.sceneManager.createRayQuery(self.contextMenuRay)
-        query.ray = self.contextMenuRay
-        query.setSortByDistance(True)
-        query.execute(self.raySceneQueryListener)
-        if self.raySceneQueryListener.dist < 100000:
-            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
-            self.raySceneQueryListener.dist = 100000
-            
-        light = None
-        if not self.sceneManager.hasLight(name):
-            light = self.sceneManager.createLight(name)
-            
-        return light,  pos
-        
-    def addPointLight(self):
-        if self.currentMap is None:
-            print "No map selected!"
-            return
-            
-        lightName = "pointLight" + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-        light, pos = self.createLight(lightName)
-        printVector3(pos)
-        
-        if not light:
-            print "Error while creating light"
-            return
-            
-        light.setType(og.Light.LT_POINT)
-        
-        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
-        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
-        n.attachObject(light)
-        n.attachObject(e)
-        n.setPosition(pos)
-        self.moduleExplorer.updateView()
-        
-    def addSpotLight(self):
-        if self.currentMap is None:
-            print "No map selected!"
-            return
-            
-        lightName = "spotLight" + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-        light, pos = self.createLight(lightName)
-        printVector3(pos)
-        
-        if not light:
-            print "Error while creating light"
-            return
-            
-        light.setType(og.Light.LT_SPOTLIGHT)
-        
-        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
-        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
-        n.attachObject(light)
-        n.attachObject(e)
-        n.setPosition(pos)
-        self.moduleExplorer.updateView()
-        
-    def addZoneToMap(self, name):
-        self.zoneManager.createZone(name)
-        self.moduleExplorer.updateView()
-        
-    def setPlayerStart(self):
-        self.mainModule.playerStart = str(self.playerStartGameObjectId)
-        print "setting Player Start to " + str(self.playerStartGameObjectId)
-    
-    def onContextMenu(self, screenX, screenY, ray):
-        menus = []
-        actions = []
-        pla = self.createAction("Pointlight", self.addPointLight, None, "idea.png")
-        pls = self.createAction("Spotlight", self.addSpotLight, None, "idea.png")
-        
-        lightMenu = QMenu("Add Light")
-        lightMenu.addAction(pla)
-        lightMenu.addAction(pls)
-        menus.append(lightMenu)
-        
-        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        self.contextMenuClickPosition = og.Vector2(screenX, screenY)
-        self.contextMenuRay = ray
-        
-        pos = og.Vector3()
-        query = self.sceneManager.createRayQuery(self.contextMenuRay)
-        query.ray = self.contextMenuRay
-        query.setSortByDistance(True)
-        query.execute(self.raySceneQueryListener)
-        if self.raySceneQueryListener.dist < 100000:
-            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
-            self.raySceneQueryListener.dist = 100000
-        
-        if so is not None:
-            self.zoneManager.entityUnderMouse = so.entity
-        
-        self.zoneManager.newAreaPosition = pos
-        menus.append(self.zoneManager.getZoneMenu())
-
-        if so is not None and so.entity.getParentNode().getName().startswith("gameobject_"):
-            actions.append(self.createAction("Set Player Starterpoint", self.setPlayerStart))
-            actions.append(self.createAction("Add Property", so.entity.getUserObject().addProperty))
-            self.playerStartGameObjectId = so.entity.getUserObject().inWorldId
-            
-                
-            
-        if self.onContextMenuCallback is not None:
-            self.onContextMenuCallback(actions,  menus)
-
-    def setContextMenuCallback(self, callback):
-        self.onContextMenuCallback = callback
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
-        action = QAction(text, None)
-        if icon is not None:
-            action.setIcon(QIcon("media/icons/%s" % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            QWidget.connect(action, SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import sys
+import codecs
+import glob
+import os
+from os.path import isfile,  join
+
+import xml.etree.cElementTree as xml
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from SelectionBuffer import *
+from DepthBuffer import *
+from MovePivot import *
+from GameObjectClassManager import *
+from MyRaySceneQueryListener import *
+from ZoneManager import ZoneManager
+
+
+# get the light out of a light node
+def extractLight(node):
+        i = 0
+        num = node.numAttachedObjects()
+        while i < node.numAttachedObjects():
+            c = node.getAttachedObject(i)
+            tp = str(type(c))
+            if tp == "<class 'ogre.renderer.OGRE._ogre_.Light'>":
+                return c
+            
+            i += 1
+
+# make the xml file more pretty
+def indent(elem, level=0):
+    i = "\n" + level*"  "
+    
+    if len(elem):
+        if not elem.text or not elem.text.strip():
+            elem.text = i + "  "
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+        for elem in elem:
+            indent(elem, level+1)
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+    else:
+        if level and (not elem.tail or not elem.tail.strip()):
+            elem.tail = i
+
+# creates unique names for new entities
+def createUniqueEntityName(sceneManager, name = None):
+    n = ""
+    if name is None:
+        n = "dropMesh" + str(ModuleManager.dropCount)
+    else:
+        n = name
+        
+    while sceneManager.hasEntity(n):
+        n = "dropMesh" + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+    return n
+        
+def printVector3(vec):
+    print str(vec.x) + ";" + str(vec.y) + ";" + str(vec.z)
+    
+class EntityCustomOptions(og.UserDefinedObject):
+    def __init__(self, receivesShadow = True, staticgeometrygroup = 0, physicsproxytype = "none", renderingdistance = "20000"):
+        og.UserDefinedObject.__init__(self)
+        self.receivesShadow = receivesShadow
+        self.staticgeometrygroup = staticgeometrygroup
+        self.physicsproxytype = physicsproxytype
+        self.renderingdistance = renderingdistance
+        self.materialName = "NotChanged"
+        
+        ModuleManager.entityCustomOptionsDict.append(self)
+        
+    def copy(self):
+            return EntityCustomOptions(self.receivesShadow, self.staticgeometrygroup, self.physicsproxytype, self.renderingdistance)
+        
+    def getType(self):
+            return "EntityCustomOptions"
+
+class Map():
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyMap = False):
+        self.pathToMapFile = pathToFile
+        
+        mapName = pathToFile.replace("\\", "/")
+        mapName = mapName.split("/")
+        mapName = mapName[len(mapName) - 1].split(".")
+        mapName = mapName[len(mapName) - 3]
+        self.mapName = mapName
+        self.mapFileName = self.mapName + ".rlmap.xml"
+        
+        self.sceneManager = sceneManager
+        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        self.zoneManager = zoneManager
+        self.isHidden = False
+        
+        self.zoneList = []
+        
+        if not emptyMap:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+
+            if root.attrib["formatVersion"] == "0.4.0":
+                self.parseMapNodes(root.find("nodes"))
+                self.parseMapZones(root.find("zones"))
+            else:
+                print pathToFile + " has wrong format version. It needs to be 0.4.0"
+                return
+
+    def hide(self):
+        try:
+            self.sceneManager.getRootSceneNode().removeChild(self.mapNode)
+        except:
+            print "Error: map is already hidden!"
+            return
+        
+        self.isHidden = True
+        
+    def show(self):
+        try:
+            self.sceneManager.getRootSceneNode().addChild(self.mapNode)
+        except:
+            print "Error: map is already shown!"
+            return
+        
+        self.isHidden = False
+    
+    def parseMapZones(self, zonesElement):
+        self.zoneManager.parseZonesFromXml(zonesElement, self)
+    
+    def parseMapNodes(self, nodeElement):
+        nodes = nodeElement.getiterator("gameobject")
+        self.createGameObjects(nodes)
+        
+        nodes = nodeElement.getiterator("entity")
+        self.createEntites(nodes)
+
+        nodes = nodeElement.getiterator("light")
+        self.createLights(nodes)
+
+        nodes = nodeElement.getiterator("sound")
+        self.createSound(nodes)
+
+        nodes = nodeElement.getiterator("particlesystem")
+        self.createParticleSystems(nodes)
+
+    def createEntites(self, entityNodes):
+        for nodes in entityNodes:
+            entityName = nodes.attrib["name"]
+            
+            if entityName.startswith("dropMesh"):
+                num = int(entityName.replace("dropMesh",  ""))
+                if ModuleManager.dropCount < num:
+                    ModuleManager.dropCount = num
+                elif ModuleManager.dropCount < num:
+                    ModuleManager.dropCount = num + 1
+                    
+            meshFile = nodes.attrib["meshfile"]
+            
+            eco = EntityCustomOptions()
+            
+            try:
+                if nodes.attrib["receivesShadow"] == "False" or nodes.attrib["receivesShadow"] == "false":
+                    eco.receivesShadow = "False"
+            except:
+                pass
+            try:
+                eco.staticgeometrygroup = int(nodes.attrib["staticgeometrygroup"])
+            except:
+                pass
+            try:
+                eco.physicsproxy = nodes.attrib["physicsproxy"]
+            except:
+                pass
+            try:
+                eco.renderingdistance = float(nodes.attrib["renderingdistance"])
+            except:
+                pass
+            try:
+                eco.renderingdistance
+                nodes.attrib["materialName"]
+            except:
+                pass
+                
+            nodePosition = None
+            nodeScale = None
+            qw = qx = qy = qz = None
+
+            transformations = nodes.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    posx = float(t.attrib["x"])
+                    posy = float(t.attrib["y"])
+                    posz = float(t.attrib["z"])
+                    nodePosition = og.Vector3(posx, posy, posz)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                elif t.tag == "scale":
+                    scalex = float(t.attrib["x"])
+                    scaley = float(t.attrib["y"])
+                    scalez = float(t.attrib["z"])
+                    nodeScale = og.Vector3(scalex, scaley, scalez)
+
+            try:
+                e = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager,  entityName), meshFile)
+            except:
+                print "Warning: Meshfile " + meshFile + " could not be found."
+                return
+
+            e.setUserObject(eco)
+            n = self.mapNode.createChild("entity_" + entityName + "_node")
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            n.setOrientation(qw, qx, qy, qz)
+            n.setScale(nodeScale)
+
+    def createLights(self, lightNodes):
+        for l in lightNodes:
+            lightName = l.attrib["name"]
+            lightType = l.attrib["type"]
+            lightVisible = bool(l.attrib["visible"])
+            castShadows = bool(l.attrib["castShadows"])
+            lightPosition = None
+            lightDirection = None
+            colourDiffuse = None
+            colourSpecular = None
+            lightAttenuationRange = None
+            lightAttenuationConstant= None
+            lightAttenuationLinear = None
+            lightAttenuationQuadratic = None
+            spotlightinner = None
+            spotlightouter = None
+            falloff = None 
+                
+            transformations = l.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    lightPosition = og.Vector3(x, y, z)
+                elif t.tag == "colourDiffuse":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourDiffuse = og.ColourValue(r, g, b)
+                elif t.tag == "colourSpecular":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourSpecular = og.ColourValue(r, g, b)
+                elif t.tag == "lightAttenuation":
+                    lightAttenuationRange = float(t.attrib["range"])
+                    lightAttenuationConstant= float(t.attrib["constant"])
+                    lightAttenuationLinear = float(t.attrib["linear"])
+                    lightAttenuationQuadric  = float(t.attrib["quadratic"])
+                elif t.tag == "spotlightrange":
+                    spotlightinner = float(t.attrib["inner"])
+                    spotlightouter = float(t.attrib["outer"])
+                    falloff = float(t.attrib["falloff"])
+                    
+            light = self.sceneManager.createLight(lightName)
+            
+            if lightType == "point":
+                light.setType(og.Light.LT_POINT)            
+            elif lightType == "spot":
+                light.setType(og.Light.LT_SPOTLIGHT)
+            elif lightType == "directional":
+                light.setType(og.Light.LT_DIRECTIONAL)
+            
+            light.setVisible(lightVisible)
+            light.setCastShadows(castShadows)
+            if lightAttenuationRange is not None and lightAttenuationConstant is not None and lightAttenuationLinear is not None and lightAttenuationQuadric is not None:
+                light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadric)
+            if colourDiffuse:
+                light.setDiffuseColour(colourDiffuse)
+            if colourSpecular:
+                light.setSpecularColour(colourSpecular)
+            if spotlightinner and spotlightouter and spotlightouter: 
+                light.setSpotlightRange(spotlightinner, spotlightouter, falloff)
+            
+            e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+            n = self.mapNode.createChild("light_" + lightName + "_node")
+            n.attachObject(light)
+            n.attachObject(e)
+            if lightPosition:
+                n.setPosition(lightPosition)
+            
+    def createSound(self, soundNodes):
+        #raise NotImplementedError
+        return
+
+    def createGameObjects(self, gameObjectNodes):
+        for g in gameObjectNodes:
+            classid = g.attrib["class"]
+            
+            id = int(g.attrib["id"])
+            if ModuleManager.dropCount < id:
+                ModuleManager.dropCount = id
+            elif ModuleManager.dropCount < id:
+                ModuleManager.dropCount = id + 1
+                
+            state = g.attrib["state"]
+            nodePosition = None
+            nodeRotation = None
+            properties = {}
+            
+            transformations = g.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+                elif t.tag == "property":
+                    name = t.attrib["name"]
+                    type = t.attrib["type"]
+                    data = t.attrib["data"]
+                    properties[name] = GameObjectRepresentation.PropertieRepresentation(name, type, data)
+
+            go = self.gocManager.getGameObjectWithClassId(classid)
+            if go is not None:
+                meshFile = go.getMeshFileName()
+                
+                ent = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+                dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
+                dropNode.attachObject(ent)
+
+                if nodePosition:
+                    dropNode.setPosition(nodePosition)
+                if nodeRotation:
+                    dropNode.setOrientation(nodeRotation)
+
+                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
+                self.gocManager.addGameObjectRepresentation(go)
+                go.inWorldId = id
+                go.state = state
+                go.propertieDict = properties
+                ent.setUserObject(go)
+
+
+    def createParticleSystems(self, particleNodes):
+        #raise NotImplementedError
+        return
+        
+    def save(self):
+        root = xml.Element("rastullahmap")
+        root.attrib["formatVersion"] = "0.4.0"
+        
+        nodesElem = xml.SubElement(root, "nodes")
+        
+        i = 0
+        while i < self.mapNode.numChildren():
+            n = self.mapNode.getChild(i)
+            if n.numAttachedObjects() > 0:
+                if n.name.startswith("entity_"):
+                    entElem = xml.SubElement(nodesElem, "entity")
+                    entElem.attrib["name"] = n.getAttachedObject(0).getName()
+                    entName = n.getAttachedObject(0).getName()
+                    #print "Saving Entity: " + n.getAttachedObject(0).getName()
+                    entElem.attrib["meshfile"] = n.getAttachedObject(0).getMesh().getName()
+   
+                    entElem.attrib["receivesShadow"] = str(n.getAttachedObject(0).getUserObject().receivesShadow).lower()
+                    entElem.attrib["staticgeometrygroup"] = str(n.getAttachedObject(0).getUserObject().staticgeometrygroup)
+                    entElem.attrib["physicsproxytype"] = str(n.getAttachedObject(0).getUserObject().physicsproxytype)
+                    entElem.attrib["renderingdistance"] = str(n.getAttachedObject(0).getUserObject().renderingdistance)
+                    
+                    posElem = xml.SubElement(entElem, "position")
+                    posElem.attrib["x"] = str(n.getPosition().x)
+                    posElem.attrib["y"] = str(n.getPosition().y)
+                    posElem.attrib["z"] = str(n.getPosition().z)
+                    
+                    rotElem = xml.SubElement(entElem, "rotation")
+                    rotElem.attrib["qw"] = str(n.getOrientation().w)
+                    rotElem.attrib["qx"] = str(n.getOrientation().x)
+                    rotElem.attrib["qy"] = str(n.getOrientation().y)
+                    rotElem.attrib["qz"] = str(n.getOrientation().z)
+                    
+                    scaleElem = xml.SubElement(entElem, "scale")
+                    scaleElem.attrib["x"] = str(n.getScale().x)
+                    scaleElem.attrib["y"] = str(n.getScale().y)
+                    scaleElem.attrib["z"] = str(n.getScale().z)
+                    
+                elif n.name.startswith("gameobject_"):
+                    goElem = xml.SubElement(nodesElem, "gameobject")
+                    mname = n.name
+                    #print "Saving GOID: " + str(n.getAttachedObject(0).getUserObject().inWorldId)
+                    goElem.attrib["class"] = str(n.getAttachedObject(0).getUserObject().gocName)
+                    goElem.attrib["state"] = str(n.getAttachedObject(0).getUserObject().state)
+                    goElem.attrib["id"] = str(n.getAttachedObject(0).getUserObject().inWorldId)
+                    
+                    posElem = xml.SubElement(goElem, "position")
+                    posElem.attrib["x"] = str(n.getPosition().x)
+                    posElem.attrib["y"] = str(n.getPosition().y)
+                    posElem.attrib["z"] = str(n.getPosition().z)
+                    
+                    rotElem = xml.SubElement(goElem, "rotation")
+                    rotElem.attrib["qw"] = str(n.getOrientation().w)
+                    rotElem.attrib["qx"] = str(n.getOrientation().x)
+                    rotElem.attrib["qy"] = str(n.getOrientation().y)
+                    rotElem.attrib["qz"] = str(n.getOrientation().z)
+                    
+                    dict = n.getAttachedObject(0).getUserObject().propertieDict
+                    for key in dict:
+                        prop = dict[key]
+                        rotElem = xml.SubElement(goElem, "property")
+                        rotElem.attrib["name"] = prop.name
+                        rotElem.attrib["type"] = prop.type
+                        rotElem.attrib["data"] = prop.data
+
+                    
+                elif n.name.startswith("light_"):
+                    light = extractLight(n)
+                    lightName = light.getName()
+                    #print "Saving Light: " + lightName
+                    lightType = light.getType()
+                    isVisible = "true"
+                    if not light.getVisible():
+                        isVisible = "false"
+                    
+                    castShadows = "false"
+                    if light.getCastShadows():
+                        castShadows = "true"
+                    
+                    if lightType == og.Light.LT_POINT:
+                        lightType = "point"
+                    elif lightType == og.Light.LT_SPOTLIGHT:
+                        lightType = "spot"
+                    elif lightType == og.Light.LT_DIRECTIONAL:
+                        lightType = "directional"
+                    
+                    
+                    lightElem = xml.SubElement(nodesElem, "light")
+                    lightElem.attrib["name"] = lightName
+                    lightElem.attrib["type"] = lightType
+                    lightElem.attrib["visible"] = isVisible
+                    lightElem.attrib["castShadows"] = castShadows
+                    
+                    if lightType == "point" or lightType == "spot":
+                        posElem = xml.SubElement(lightElem, "position")
+                        posElem.attrib["x"] = str(n.getPosition().x)
+                        posElem.attrib["y"] = str(n.getPosition().y)
+                        posElem.attrib["z"] = str(n.getPosition().z)
+                    
+                    colDiffuseElem = xml.SubElement(lightElem, "colourDiffuse")
+                    colDiffuseElem.attrib["r"] = str(light.getDiffuseColour().r)
+                    colDiffuseElem.attrib["g"] = str(light.getDiffuseColour().g)
+                    colDiffuseElem.attrib["b"] = str(light.getDiffuseColour().b)
+
+                    colSpecularElem = xml.SubElement(lightElem, "colourSpecular")
+                    colSpecularElem.attrib["r"] = str(light.getSpecularColour().r)
+                    colSpecularElem.attrib["g"] = str(light.getSpecularColour().g)
+                    colSpecularElem.attrib["b"] = str(light.getSpecularColour().b)
+                    
+                    lightAttenuationElem = xml.SubElement(lightElem, "lightAttenuation")
+                    lightAttenuationElem.attrib["range"] = str(light.getAttenuationRange())
+                    lightAttenuationElem.attrib["constant"] = str(light.getAttenuationConstant())
+                    lightAttenuationElem.attrib["linear"] = str(light.getAttenuationLinear())
+                    lightAttenuationElem.attrib["quadratic"] = str(light.getAttenuationQuadric())
+                    
+                    if lightType == "spot":
+                        spotligthRangeElem = xml.SubElement(lightElem, "spotlightrange")
+                        spotligthRangeElem.attrib["inner"] = str(light.getSpotlightInnerAngle().valueDegrees())
+                        spotligthRangeElem.attrib["outer"] = str(light.getSpotlightOuterAngle().valueDegrees())
+                        spotligthRangeElem.attrib["falloff"] = str(light.getSpotlightFalloff())
+                        
+                    if lightType == "spot" or lightType == "directional":
+                        directionElem = xml.SubElement(lightElem, "direction")
+                        dir = og.Vector3()
+                        n.getOrientation().ToAxes(dir)
+                        directionElem.attrib["x"] = str(dir.x)
+                        directionElem.attrib["y"] = str(dir.y)
+                        directionElem.attrib["z"] = str(dir.z)
+                        
+            i = i+1
+            
+        self.zoneManager.saveZonesToXml(root, self)
+        indent(root)
+        xml.ElementTree(root).write(self.pathToMapFile)
+
+# caused a linux crash
+#        iter = self.mapNode.getChildIterator()
+#        while iter.hasMoreElements():
+#            name = iter.getNext().getName()
+#            print name
+
+class Scene():
+    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyScene = False, sceneName = "NewScene"):
+        self.moduleRoot = moduleroot
+        self.pathToFile = pathToFile
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        self.zoneManager = zoneManager
+        self.mapFiles = [] # a list in case the module has more than one map file
+        mappaths = []
+        self.name = sceneName
+
+        
+        if not emptyScene:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+            self.name = root.attrib["name"]
+        
+            maps = root.getiterator("map")
+            for m in maps:
+                mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
+                
+            for m in mappaths:
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
+            
+    def addMap(self, name):
+        path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
+        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True))
+        
+    def save(self):
+        root = xml.Element("scene")
+        root.attrib["name"] = self.name
+        
+        for m in self.mapFiles:
+            sub = xml.SubElement(root, "map")
+            sub.attrib["file"] = m.mapFileName
+            m.save()
+
+        indent(root)
+        xml.ElementTree(root).write(self.pathToFile)
+
+class Module():
+    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager, zoneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gameObjectManager
+        self.zoneManager = zoneManager
+        
+        self.name = name
+        self.moduleRoot = join(modulePath, name)
+        self.__isCommon = False
+
+        self.hasDependencies = False
+        self.moduleDependencies = []
+
+        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+
+        self.gofFiles = [] # gof File list
+
+        self.scenes =[]
+
+        self.isLoaded = False
+        
+        self.playerStart = None
+        
+    def addScene(self, name):
+        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True, name))
+    
+    def addMapToScene(self, sceneName, mapName):
+        for scene in self.scenes:
+            if scene.name == sceneName:
+                scene.addMap(mapName)
+                return
+        
+        print "ERROR: could not find scene: " + sceneName
+        
+    
+    def isCommon(self):
+        if isfile(self.modConfig): # is the modconfig existing?
+            f = codecs.open(self.modConfig, 'r', 'utf-8')
+        else:
+            print ("Module.isCommon() Error: couldn't find module config")
+            return
+        isDependencieLine = False
+        for i, line in enumerate(f):
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith("super("):
+                split = lStripped.split(",")
+                if split[2].strip() == unicode("true"):
+                    self.__isCommon = True
+                    return True
+
+
+            elif isDependencieLine:
+                if lStripped == "end":
+                    isDependencieLine = False
+                else:
+                    self.hasDependencies = True
+                    pl = lStripped.split('"')
+                    i = 1
+                    while i < 100: 
+                        try:
+                            self.moduleDependencies.append(pl[i])
+                            i += 2
+                        except IndexError, e:
+                            break
+
+            elif lStripped == "def getDependencies()":
+                isDependencieLine = True
+
+        return False
+
+    def load(self):
+        if self.isLoaded:
+            return
+        
+        self.isLoaded = True
+        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+        if isfile(self.modConfig): # is the modconfig existing?
+            f = codecs.open(self.modConfig, 'r', 'utf-8')
+        else:
+            print ("Module.load: Error: couldn't find module config")
+            return
+
+        for line in f:
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith("hero = $GOM.getGameObject("):
+                try:
+                    self.playerStart = int(line.split("(")[1].split(")")[0])
+                except ValueError, e:
+                    print self.modConfig + " ValueError: " + str(e)
+                    self.playerStart = None
+                    continue
+                    
+        self.setResourcePaths()
+        
+        try:
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+        except og.OgreException, e:
+            print e
+        
+        
+        cmd = join(self.moduleRoot, "dsa/*.gof")
+        self.gofFiles = glob.glob(cmd)
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
+        if not self.isCommon():
+            cmd = join(self.moduleRoot, "maps/*.rlscene")
+            sceneFile = glob.glob(cmd)
+            self.loadScenes(sceneFile)
+                
+    def loadScenes(self, sceneFiles):
+        for s in sceneFiles:
+            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
+
+    def save(self):
+        for s in self.scenes:
+            s.save()
+            
+        self.saveModuleConfig()
+
+    def saveModuleConfig(self):
+        if self.playerStart is not None:
+            f = open(self.modConfig, "r")
+            
+            newconfig = ""
+            for line in f:
+                if line.startswith("       hero = $GOM.getGameObject("):
+                    newconfig += "       hero = $GOM.getGameObject(" + str(self.playerStart) + ");\n"
+                else:
+                    newconfig += line
+            f.close()
+            
+            f = open(self.modConfig, "w")
+            f.write(newconfig)
+            f.close()
+
+    def setResourcePaths(self, recurseFolder = ""):
+        if recurseFolder == "":
+            rootFolder = self.moduleRoot
+        else:
+            rootFolder = join(self.moduleRoot, recurseFolder)
+
+        for file in os.listdir(rootFolder):
+            curFile = join(rootFolder, file)
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            elif os.path.isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
+                self.setResourcePaths(curFile)
+            elif os.path.isfile(curFile):
+                continue
+                
+    def getMap(self, mapName, sceneName = None):
+        if sceneName is not None:
+            for s in self.scenes:
+                if s.name == sceneName:
+                    for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+        else:
+            for s in self.scenes:
+                for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+
+class ProgressBarThread(QThread):
+    def __init__(self, min, max, moduleName):
+        QThread.__init__(self)
+        self.progress = QProgressDialog("Loading " + moduleName, "Abort Loading", min, max, None);
+        self.progress.setWindowModality(Qt.WindowModal)
+
+    def setProgress(self, progress, labelText):
+        self.progress.setLabelText(labelText)
+        self.progress.setValue(progress)
+        
+    def run(self):
+        self.progress.show()
+        self.exec_()
+
+        
+class ModuleManager():
+    dropCount = 0
+    entityCustomOptionsDict = []
+    
+    def __init__(self,  ogreRoot,  sceneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.modelSelectionDialog = None
+        self.materialSelectionDialog = None
+
+        self.moduleCfgPath = ""
+
+        self.gocManager = GameObjectClassManager()
+        
+
+        self.mainModule = None
+        self.mainModuledependencieList =[]
+        self.moduleList = []
+        self.userSelectionList = []
+        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
+        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
+        self.currentMap = None
+        self.moduleExplorer = None
+        self.moduleDirView = None
+
+        self.lastRay = None
+        self.rayLine = None
+
+        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.dropNode = None
+        self.dropEntity = None
+        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
+        self.dropMat = None
+        
+        self.moduleConfigIsParsed = False
+
+        self.selectionBuffer = None
+        self.depthBuffer = None
+        self.propertyWindow = None
+    
+        self.oneClickEntityPlacement = False
+        
+        self.onContextMenuCallback = None
+        self.contextMenuClickPosition = None
+        self.contextMenuRay = None
+        
+        self.playerStartGameObjectId = None
+        
+        self.entityCustomOptionsDict = []
+        
+        self.raySceneQueryListener = MyRaySceneQueryListener()
+        
+        self.zoneManager = ZoneManager(self.sceneManager)
+        
+    def resetParsedModuleConfig(self):
+        self.moduleConfigIsParsed = False
+        self.moduleList = []
+
+    def parseModuleConfig(self):
+        if self.moduleConfigIsParsed:
+            return
+
+        import codecs
+        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
+
+        for line in f:
+            if line.startswith('#'):
+                continue
+
+            if line.startswith('module='):
+                splines = line.split('=')
+                str = splines[1].rstrip().rstrip()
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
+
+        self.moduleConfigIsParsed = True
+
+    def moduleExists(self, name):
+        lowerA = str(name).lower()
+        
+        for m in self.moduleList:
+            lowerB = m.name.lower()
+            if lowerA == lowerB:
+                return True
+        
+        return False
+
+    def openLoadModuleDialog(self):
+        self.moduleFolder = str(self.moduleCfgPath.replace("modules.cfg", ""))
+
+        self.parseModuleConfig()
+
+        dlg = QDialog(QApplication.focusWidget())
+        list = QListWidget()
+        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
+        dlg.connect(btnBox, SIGNAL("rejected()"), dlg.reject)
+
+        for m in self.moduleList:
+            if not m.isCommon():
+                list.addItem(m.name)
+
+        layout = QVBoxLayout()
+        layout.addWidget(list)
+        layout.addWidget(btnBox)
+        dlg.setLayout(layout)
+        if dlg.exec_():
+            self.loadModule(str(list.currentItem().text()))
+
+    # I'm sorry for this
+    def loadModule(self, moduleName):
+        t = og.Timer()
+        
+#        self.progress = ProgressBarThread(0, 8, moduleName)
+#        self.progress.start()
+        
+        for m in self.moduleList:
+            if m.name == moduleName:
+                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
+                    for moduleDependencie in m.moduleDependencies:
+                        for m2 in self.moduleList:
+                            if m2.name == moduleDependencie:
+#                                self.progress.setProgress(2, "Loading Dependencie: " + moduleDependencie)
+                                m2.load()
+                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
+                                self.materialSelectionDialog.scanDirForMaterials(m2.moduleRoot)
+                                self.mainModuledependencieList.append(m2)
+
+#                self.progress.setProgress(4, "Loading " + moduleName)
+                m.load()
+#                self.progress.setProgress(6, "Scan for models...")
+                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
+#                self.progress.setProgress(8, "Scan for materials")
+                self.materialSelectionDialog.scanDirForMaterials(m.moduleRoot)
+                self.mainModule = m
+                self.moduleExplorer.setCurrentModule(m)
+                self.moduleDirView.parseDirectory(m.moduleRoot)
+                
+        if self.selectionBuffer is None:
+            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"), self, self.zoneManager)
+
+#        if self.depthBuffer is None:
+#            self.depthBuffer = DepthBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
+
+
+#        self.progress.quit()
+        print "Time to load module: " + str(t.getMilliseconds() / 1000.0) + " seconds"
+        del t
+
+    def addSceneToModule(self, name):
+        if self.mainModule is not None:
+            self.mainModule.addScene(name)
+
+    def addMapToScene(self, sceneName, mapName):
+        if self.mainModule is not None:
+            self.mainModule.addMapToScene(sceneName, mapName)
+
+    def setModuleExplorer(self, moduleExplorer):
+        self.moduleExplorer = moduleExplorer
+        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
+        self.moduleExplorer.setSelectionChangedCallback(self.selectionChangedCallback)
+        self.moduleExplorer.setModuleManager(self)
+    
+    def setModuleDirView(self, dirView):
+        self.moduleDirView = dirView
+    
+    def setPropertyWindow(self, propertyWin):
+        self.propertyWindow = propertyWin
+    
+    def selectionChangedCallback(self, items):
+        self.resetSelection()
+        self.userSelectionList = self.selectionBuffer.manualSelectObjects(items)
+        
+        print len(self.userSelectionList)
+        
+        if len(self.userSelectionList) > 1:
+            self.propertyWindow.clear()
+        elif len(self.userSelectionList) > 0 and len(self.userSelectionList) < 2:
+            self.propertyWindow.showProperties(self.userSelectionList[0])
+        else:
+            return
+            
+        self.updatePivots()
+        
+    def selectMapCallback(self, sceneName, mapName):
+        self.currentMap = self.mainModule.getMap(mapName, sceneName)
+        self.zoneManager.currentMap = self.currentMap
+        if self.currentMap is None:
+            print "Don't forget to select a map"
+
+        
+    # called when a click into Main Ogre Window occurs
+    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
+        if self.oneClickEntityPlacement:
+            if self.modelSelectionDialog.listWidget.currentItem() is not None:
+                meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
+                self.startDropModelAction(meshFile, ray)
+                self.moduleExplorer.updateView()
+                return
+            else:
+                print "Warning: OneClickEntityPlacement still runing on without any selected mesh!"
+                return
+                
+        #self.depthBuffer.onSelectionClick(screenX, screenY)
+        
+        so = None
+        if self.selectionBuffer is not None:
+            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        
+        if so is not None:
+            if not so.isPivot:                
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.propertyWindow.showProperties(so)
+                    self.moduleExplorer.deselectAll()
+                    self.moduleExplorer.selectItem(so, True)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+
+                    for soFromList in self.userSelectionList:
+                        if soFromList == so:
+                            return # object already selected
+
+                    self.userSelectionList.append(so)
+                    self.propertyWindow.showProperties(so)
+                    self.moduleExplorer.selectItem(so, True)
+                    self.updatePivots()
+
+
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so == selo:
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                            self.moduleExplorer.selectItem(selo, False)
+                    self.updatePivots()
+                
+            else:
+                #so.entity is the pivot direction that was clicked
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            self.resetSelection() # click in empty space, deselect everything
+            self.moduleExplorer.selectItems(None)
+            self.propertyWindow.clear()
+            if self.pivot is not None:
+                self.pivot.hide()
+
+#        if self.rayLine == None:
+#            self.rayLine = self.sceneManager.createManualObject("rayLine")
+#            self.rayLine.setDynamic(True)
+#            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
+#
+#            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+#
+#        else:
+#            self.rayLine.beginUpdate(0)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+
+    def deleteObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.pivot.hide()
+
+        for so in self.userSelectionList:
+            node = so.entity.getParentNode()
+            if node.getName().startswith("area_"):
+                self.zoneManager.deleteArea(so.entity.getUserObject())
+                continue
+            elif node.getName().startswith("light_"):
+                light = extractLight(node)
+                self.sceneManager.destroyLight(light)
+                
+            node.detachAllObjects()
+            self.sceneManager.destroySceneNode(node)
+            self.sceneManager.destroyEntity(so.entity)
+            del so
+        
+        self.userSelectionList = []
+        self.moduleExplorer.updateView()
+        
+    def copyObjects(self):
+        if len(self.userSelectionList) < 1 or self.currentMap is None:
+            print "Warning: No map selected!"
+            return
+
+        self.newSelectionList = []
+
+        for so in self.userSelectionList:
+            if so.entity.getUserObject() is not None:
+                if str(so.entity.getParentNode().getName()).startswith("gameobject_"):
+                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
+                    meshFile = go.getMeshFileName()
+
+                    if go is not None:
+                        newEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+                        newNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
+                        newNode.attachObject(newEntity)
+                        newNode.setPosition(so.entity.getParentNode().getPosition())
+
+                        newGO = GameObjectRepresentation(ModuleManager.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
+                        self.gocManager.addGameObjectRepresentation(newGO)
+                        newEntity.setUserObject(newGO)
+
+                        newSO = SelectionObject(newEntity)
+                        newSO.setSelected(True)
+                        self.newSelectionList.append(newSO)
+                        ModuleManager.dropCount += 1
+                elif str(so.entity.getParentNode().getName()).startswith("entity_"):
+                    nodeName = "entity_dropNode" + str(ModuleManager.dropCount)
+                    newNode = self.currentMap.mapNode.createChild(nodeName)
+
+                    entityName = createUniqueEntityName(self.sceneManager)
+                    newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+
+                    eco = so.entity.getUserObject().copy()
+                    newEntity.setUserObject(eco)
+
+                    newNode.attachObject(newEntity)
+                    newNode.setPosition(so.entity.getParentNode().getPosition())
+                    newNode.setOrientation(so.entity.getParentNode().getOrientation())
+                    newNode.setScale(so.entity.getParentNode().getScale())
+
+                    newSO = SelectionObject(newEntity)
+                    newSO.setSelected(True)
+                    self.newSelectionList.append(newSO)
+                    ModuleManager.dropCount += 1
+                elif str(so.entity.getParentNode().getName()).startswith("light_"):
+                    print "Can't copy lights yet :)"
+
+        self.resetSelection()
+        self.userSelectionList = self.newSelectionList
+        self.moduleExplorer.updateView()
+        for so in self.userSelectionList:
+            self.moduleExplorer.selectItem(so, True)
+        self.updatePivots()
+
+        
+    def cutObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.cutList = []
+        for so in self.userSelectionList:
+            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
+            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
+            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
+            # so we only have to translate them to their new destination when they get pasted
+            # the position of the pivot point is considered as the center of gravity
+            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
+            self.cutList.append(so)
+        self.resetSelection()
+        self.moduleExplorer.updateView()
+        
+    def pasteObjects(self,  ray):
+        if len(self.cutList) < 1:
+            return
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
+                i = i+1
+        else:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
+                i = i+1
+        self.cutList = []
+        self.moduleExplorer.updateView()
+        
+    def leftMouseUp(self):
+        if self.pivot is not None and self.pivot.isTransforming:
+            self.propertyWindow.updateProperties()
+            self.pivot.stopTransforming()
+
+    def resetSelection(self):
+        if self.userSelectionList is not None:
+            for so in self.userSelectionList:
+                so.setSelected(False)
+
+        self.userSelectionList = []
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+        if self.pivot is not None and len(self.userSelectionList) > 0:
+            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
+    def unload(self,  saveOnUnload=True):
+        pass
+
+    def save(self):
+        self.mainModule.save()
+
+    def startDropGameObjectAction(self, classid, ray):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        go = self.gocManager.getGameObjectWithClassId(classid)
+
+        if go is not None:
+            meshFile = go.getMeshFileName()
+            dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
+            dropNode.attachObject(dropEntity)
+
+            result = og.Math.intersects(ray, self.dropCollisionPlane)
+            if result.first == True:
+                dropNode.setPosition(ray.getPoint(result.second))
+            else:
+                dropNode.setPosition(ray.getPoint(50))
+
+            self.dropGO = GameObjectRepresentation(ModuleManager.dropCount, classid, dropNode, meshFile)
+            self.gocManager.addGameObjectRepresentation(self.dropGO)
+            dropEntity.setUserObject(self.dropGO)
+
+        ModuleManager.dropCount += 1
+
+    def moveDropGameObjectAction(self, ray):
+        if self.currentMap is None:
+            return
+        
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropGO.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropGO.setPosition(ray.getPoint(50))
+
+    def finishDropGameObjectAction(self, ray):
+        self.moduleExplorer.updateView()
+        self.dropGO = None
+        return
+
+    def startDropModelAction(self, meshFile, ray):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        self.dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), meshFile)
+        
+        eco = EntityCustomOptions()
+        self.dropEntity.setUserObject(eco)
+        
+        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(ModuleManager.dropCount))
+        self.dropNode.attachObject(self.dropEntity)
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+        ModuleManager.dropCount += 1
+
+    def moveDropModelAction(self, ray):
+        if self.currentMap is None:
+            return
+            
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+    
+    def finishDropModelAction(self, ray):
+        self.moduleExplorer.updateView()
+        return
+
+    def startDropMaterialAction(self, text):
+        self.dropMat = text
+        
+    def moveDropMaterialAction(self, event):
+        return
+
+    def finishDropMaterialAction(self, screenX, screenY):
+        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        if so is not None:
+            if not so.entity.getNumSubEntities() > 1:
+                so.entity.setMaterialName(self.dropMat)
+                so.entity.getUserObject().materialName = self.dropMat
+            else:
+                i = 0
+                text = "Warning this Entity has more than one SubEntities with the folloing materials: \n\n"
+                while i < so.entity.getNumSubEntities():
+                    text += "SubMesh" + str(i) + ":  " + so.entity.getSubEntity(i).getMaterialName() + "\n"
+                    i += 1
+                
+                text += "\n Replace the materials?"
+                reply = QMessageBox.question(None, "Warning: multiple materials",  text,  QMessageBox.Yes|QMessageBox.No)
+                if reply == QMessageBox.Cancel:
+                    return
+                if reply == QMessageBox.Yes:
+                    so.entity.setMaterialName(self.dropMat)
+                    so.entity.getUserObject().materialName = self.dropMat
+        
+    def setOneClickEntityPlacement(self, state):
+        self.oneClickEntityPlacement = state
+    
+    def createLight(self, name):
+        pos = og.Vector3()
+        
+        query = self.sceneManager.createRayQuery(self.contextMenuRay)
+        query.ray = self.contextMenuRay
+        query.setSortByDistance(True)
+        query.execute(self.raySceneQueryListener)
+        if self.raySceneQueryListener.dist < 100000:
+            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
+            self.raySceneQueryListener.dist = 100000
+            
+        light = None
+        if not self.sceneManager.hasLight(name):
+            light = self.sceneManager.createLight(name)
+            
+        return light,  pos
+        
+    def addPointLight(self):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        lightName = "pointLight" + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+        light, pos = self.createLight(lightName)
+        printVector3(pos)
+        
+        if not light:
+            print "Error while creating light"
+            return
+            
+        light.setType(og.Light.LT_POINT)
+        
+        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
+        n.attachObject(light)
+        n.attachObject(e)
+        n.setPosition(pos)
+        self.moduleExplorer.updateView()
+        
+    def addSpotLight(self):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        lightName = "spotLight" + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+        light, pos = self.createLight(lightName)
+        printVector3(pos)
+        
+        if not light:
+            print "Error while creating light"
+            return
+            
+        light.setType(og.Light.LT_SPOTLIGHT)
+        
+        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
+        n.attachObject(light)
+        n.attachObject(e)
+        n.setPosition(pos)
+        self.moduleExplorer.updateView()
+        
+    def addZoneToMap(self, name):
+        self.zoneManager.createZone(name)
+        self.moduleExplorer.updateView()
+        
+    def setPlayerStart(self):
+        self.mainModule.playerStart = str(self.playerStartGameObjectId)
+        print "setting Player Start to " + str(self.playerStartGameObjectId)
+    
+    def onContextMenu(self, screenX, screenY, ray):
+        menus = []
+        actions = []
+        pla = self.createAction("Pointlight", self.addPointLight, None, "idea.png")
+        pls = self.createAction("Spotlight", self.addSpotLight, None, "idea.png")
+        
+        lightMenu = QMenu("Add Light")
+        lightMenu.addAction(pla)
+        lightMenu.addAction(pls)
+        menus.append(lightMenu)
+        
+        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        self.contextMenuClickPosition = og.Vector2(screenX, screenY)
+        self.contextMenuRay = ray
+        
+        pos = og.Vector3()
+        query = self.sceneManager.createRayQuery(self.contextMenuRay)
+        query.ray = self.contextMenuRay
+        query.setSortByDistance(True)
+        query.execute(self.raySceneQueryListener)
+        if self.raySceneQueryListener.dist < 100000:
+            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
+            self.raySceneQueryListener.dist = 100000
+        
+        if so is not None:
+            self.zoneManager.entityUnderMouse = so.entity
+        
+        self.zoneManager.newAreaPosition = pos
+        menus.append(self.zoneManager.getZoneMenu())
+
+        if so is not None and so.entity.getParentNode().getName().startswith("gameobject_"):
+            actions.append(self.createAction("Set Player Starterpoint", self.setPlayerStart))
+            actions.append(self.createAction("Add Property", so.entity.getUserObject().addProperty))
+            self.playerStartGameObjectId = so.entity.getUserObject().inWorldId
+            
+                
+            
+        if self.onContextMenuCallback is not None:
+            self.onContextMenuCallback(actions,  menus)
+
+    def setContextMenuCallback(self, callback):
+        self.onContextMenuCallback = callback
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QAction(text, None)
+        if icon is not None:
+            action.setIcon(QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            QWidget.connect(action, SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action

Modified: rl/trunk/editors/Lockenwickler/src/ZoneManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ZoneManager.py	2009-04-15 16:43:40 UTC (rev 4898)
+++ rl/trunk/editors/Lockenwickler/src/ZoneManager.py	2009-04-15 17:58:20 UTC (rev 4899)
@@ -1,363 +1,363 @@
-#################################################
-# This source file is part of Rastullahs Lockenwickler.
-# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
-
-import functools
-import xml.etree.cElementTree as xml
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
- 
-import ogre.renderer.OGRE as og
- 
-from ModuleExplorer import NameInputDlg
- 
-#                <zone name="Testzone">
-#                        <area type="sphere">
-#                                <position x="-10" y="0" z="-5"/>
-#                                <scale x="6" y="6" z="6"/>
-#                                <transition_distance>0.5</transition_distance>
-#                        </area>
-#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
-#                                <position x="25" y="0" z="-50"/>
-#                                <transition_distance>0.5</transition_distance>
-#                        </area>
-#                        <area type="sphere" subtract="true">
-#                                <position x="-11" y="0" z="-4"/>
-#                                <scale x="2" y="2" z="2"/>
-#                        </area>
-#                        <light name="red pointlight"/>
-#                        <light name="green spotlight"/>
-#                        <sound name="ruchin001.ogg"/>
-#                        <trigger name="test" classname="TestTrigger">
-#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
-#                        </trigger>
-#                </zone>
- 
-class Area(og.UserDefinedObject):
-    def __init__(self,sceneManager, type, parentZone, id, position, orientation, scale, meshFile = None, transitiondistance = "0.5", subtract = False):
-        og.UserDefinedObject.__init__(self)
-        self.type = type
-        self.parentZone = parentZone
-        if not parentZone:
-           raise Exception("No parentZone")
-
-        self.id = id # editor internal id for entity and node creation
-        self.areaNode = parentZone.zoneNode.createChildSceneNode("area_" + parentZone.name + " " + str(id))
-        self.meshFile = meshFile
-        self.areaEntity = None
-        self.transitiondistance = transitiondistance
-        self.__subtract = subtract
-        self.sceneManager = sceneManager
-        
-        if type == "box":
-            self.areaEntity = self.sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", "UniCube.mesh")
-        elif type == "sphere":
-            self.areaEntity = self.sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", "UniSphere.mesh")        
-        elif type == "ellipsoid":
-            print "not yet"
-        elif type == "capsule":
-            print "not yet"
-        elif type == "pyramid":
-            print "not yet"
-        elif type == "mesh":
-            try:
-                self.areaEntity = sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", self.meshFile)
-            except:
-                print "Mesh " + self.meshFile + " not found!"
-                return None
-                
-        self.areaEntity.setMaterialName("Lockenwickler_Area")
-        if self.__subtract:
-            self.areaEntity.setMaterialName("Lockenwickler_Area_Subtract")
-            
-        self.areaEntity.setUserObject(self)
-        self.areaNode.attachObject(self.areaEntity)
-        self.areaNode.setPosition(position)
-        if orientation is not None:
-            self.areaNode.setOrientation(orientation.w, orientation.x, orientation.y, orientation.z)
-        if scale is not None:
-            self.areaNode.setScale(scale)
-    
-    def __del__(self):
-        self.areaNode.detachAllObjects()
-        self.areaNode.getParent().removeAndDestroyChild(self.areaNode.getName())
-        self.sceneManager.destroyEntity(self.areaEntity.getName())
-    
-    def getsubtract(self):
-        return self.__subtract
-        
-    def setsubtract(self, val):
-        if not val:
-            self.areaEntity.setMaterialName("Lockenwickler_Area")
-        else:
-            self.areaEntity.setMaterialName("Lockenwickler_Area_Subtract")
-        
-        self.__subtract = val
-        
-    subtract = property(getsubtract, setsubtract)
-    
-class Zone():
-    def __init__(self,sceneManager, map, name):
-        self.map = map
-        self.name = name
-        self.areaList = []
-        self.lightList = []
-        self.soundList = []
-        self.triggerList = []
-        self.areaCounter = 0
-        self.sceneManager = sceneManager
-        self.isHidden = False
-        
-        self.zoneNode =  self.sceneManager.getRootSceneNode().createChildSceneNode("zone_" + name + "_node")
-        
-    def addArea(self, type, position, orientation, scale, meshFile = None):
-        area = Area(self.sceneManager, type, self, self.areaCounter, position, orientation, scale, meshFile)
-        if area is not None:
-            self.areaList.append(area)
-            self.areaCounter = self.areaCounter + 1
-    
-    def deleteArea(self, area):
-        for a in self.areaList:
-            if a.id == area.id:
-                self.areaList.remove(a)
-                del a
-    
-    def hide(self):
-        self.sceneManager.getRootSceneNode().removeChild(self.zoneNode)
-        self.isHidden = True
-    
-    def show(self):
-        self.sceneManager.getRootSceneNode().addChild(self.zoneNode)
-        self.isHidden = False
-        
-        
-class ZoneManager():
-    def __init__(self, sceneManager):
-        self.currentMap = None
-        self.zoneList = []
-        self.menuList = []
-        self.entityUnderMouse = None
-        self.newAreaPosition = None
-        self.sceneManager = sceneManager
-        
-    def createZone(self, name):
-        if self.currentMap == None:
-            print "No map selected!"
-            return
-            
-        z = Zone(self.sceneManager, self.currentMap, name)
-        self.zoneList.append(z)
-        self.currentMap.zoneList.append(z)
-        return z
-        
-    def parseZonesFromXml(self, zoneXmlNode, map):
-        if zoneXmlNode is None:
-            return
-        
-        self.currentMap = map
-        
-        zoneNodes = zoneXmlNode.getiterator("zone")
-        for zone in zoneNodes:
-            zoneName = zone.attrib["name"]
-            z = self.createZone(zoneName)
-            
-            areaNodes = zone.getiterator("area")
-            for area in areaNodes:
-                type = area.attrib["type"]
-                meshFile = None
-                if type == "mesh":
-                    meshFile = area.attrib["meshfile"]
-                
-                pos = og.Vector3()
-                qw = qx = qy = qz = 0
-                scale = None
-                hasRotation = False
-                
-                transformations = area.getiterator()
-                for t in transformations:
-                    if t.tag == "position":
-                        posx = float(t.attrib["x"])
-                        posy = float(t.attrib["y"])
-                        posz = float(t.attrib["z"])
-                        pos = og.Vector3(posx, posy, posz)
-                    elif t.tag == "rotation":
-                        qw = float(t.attrib["qw"])
-                        qx = float(t.attrib["qx"])
-                        qy = float(t.attrib["qy"])
-                        qz = float(t.attrib["qz"])
-                        hasRotation = True
-                    elif type == "mesh" and t.tag == "scale":
-                        scalex = float(t.attrib["x"])
-                        scaley = float(t.attrib["y"])
-                        scalez = float(t.attrib["z"])
-                        scale = og.Vector3(scalex, scaley, scalez)
-                    elif t.tag == "size":
-                        scalex = float(t.attrib["x"])
-                        scaley = float(t.attrib["y"])
-                        scalez = float(t.attrib["z"])
-                        scale = og.Vector3(scalex, scaley, scalez)
-                
-                rot = None
-                if hasRotation:
-                    rot = og.Quaternion(qw, qx, qy, qz)
-                    
-                z.addArea(type, pos, rot, scale, meshFile)
-            
-            
-            lightNodes = zone.getiterator("light")
-            for light in lightNodes:
-                name = light.attrib["name"]
-                z.lightList.append(name)
-                
-            soundNodes = zone.getiterator("sound")
-            for sound in soundNodes:
-                name = sound.attrib["name"]
-                z.soundList.append(name)
-            
-
-    def saveZonesToXml(self, root, map):
-        if len(map.zoneList) == 0:
-            return
-        
-        rootZonesElem = xml.SubElement(root, "zones")
-        for zone in map.zoneList:
-            zoneElem = xml.SubElement(rootZonesElem, "zone")
-            zoneElem.attrib["name"] = zone.name
-            
-            for area in zone.areaList:
-                areaElem = xml.SubElement(zoneElem, "area")
-                areaElem.attrib["type"] = area.type
-                #print "Saving Zone: " + zone.name + " - Area " + str(area.id)
-                if area.type == "mesh" and area.meshFile is not None:
-                    areaElem.attrib["meshfile"] = area.meshFile
-                    
-                posElem = xml.SubElement(areaElem, "position")
-                posElem.attrib["x"] = str(area.areaNode.getPosition().x)
-                posElem.attrib["y"] = str(area.areaNode.getPosition().y)
-                posElem.attrib["z"] = str(area.areaNode.getPosition().z)
-                
-                rotElem = xml.SubElement(areaElem, "rotation")
-                rotElem.attrib["qw"] = str(area.areaNode.getOrientation().w)
-                rotElem.attrib["qx"] = str(area.areaNode.getOrientation().x)
-                rotElem.attrib["qy"] = str(area.areaNode.getOrientation().y)
-                rotElem.attrib["qz"] = str(area.areaNode.getOrientation().z)
-                
-                scaleElem = None
-                if area.type == "mesh":
-                    scaleElem = xml.SubElement(areaElem, "scale")
-                else:
-                    scaleElem = xml.SubElement(areaElem, "size")
-
-                scaleElem.attrib["x"] = str(area.areaNode.getScale().x)
-                scaleElem.attrib["y"] = str(area.areaNode.getScale().y)
-                scaleElem.attrib["z"] = str(area.areaNode.getScale().z)
-                
-            for lightName in zone.lightList:
-                lightElem = xml.SubElement(zoneElem, "light")
-                lightElem.attrib["name"] = lightName
-            
-            for soundName in zone.soundList:
-                soundElem = xml.SubElement(zoneElem, "sound")
-                soundElem.attrib["name"] = soundName
-                
-    def deleteArea(self, area):
-        for z in self.zoneList:
-            for a in z.areaList:
-                if a.id == area.id:
-                    z.deleteArea(area)
-    
-    def getZoneMenu(self):
-        self.menuList = []
-        menu = QMenu("Add Area")
-        
-        for zone in self.zoneList:
-            m = QMenu(zone.name)
-            self.menuList.append(m)
-            menu.addMenu(m)
-            
-            boxAction = self.createAction("box", functools.partial(self.onZoneNameTriggered, zone, "box"))
-            self.menuList.append(boxAction)
-            m.addAction(boxAction)
-            
-            sphereAction = self.createAction("sphere", functools.partial(self.onZoneNameTriggered, zone, "sphere"))
-            self.menuList.append(sphereAction)
-            m.addAction(sphereAction)
-            
-            ellipsoidAction = self.createAction("ellipsoid", functools.partial(self.onZoneNameTriggered, zone, "ellipsoid"))
-            self.menuList.append(ellipsoidAction)
-            m.addAction(ellipsoidAction)
-            
-            capsuleAction = self.createAction("capsule", functools.partial(self.onZoneNameTriggered, zone, "capsule"))
-            self.menuList.append(capsuleAction)
-            m.addAction(capsuleAction)
-            
-            pyramidAction = self.createAction("pyramid", functools.partial(self.onZoneNameTriggered, zone, "pyramid"))
-            self.menuList.append(pyramidAction)
-            m.addAction(pyramidAction)
-            
-            meshAction = self.createAction("mesh", functools.partial(self.onZoneNameTriggered, zone, "mesh"))
-            self.menuList.append(meshAction)
-            m.addAction(meshAction)
-            
-        return menu
-        
-    def onZoneNameTriggered(self, zone, type):
-        if self.newAreaPosition is not None:
-            if type == "box":
-                zone.addArea("box", self.newAreaPosition, None, None)
-            elif type == "sphere":
-                zone.addArea("sphere", self.newAreaPosition, None, None)
-            elif type == "mesh":
-                dlg = NameInputDlg(QApplication.focusWidget())
-                resName = ""
-                if dlg.exec_():
-                    resName = str(dlg.nameInput.text())
-
-                zone.addArea("mesh", self.newAreaPosition, None, None, resName)
-                
-    def getZone(self, name):
-        for zone in self.zoneList:
-            if zone.name == name:
-                return zone
-        
-    def getZoneList(self):
-        list = []
-        for zone in self.zoneList:
-            list.append(zone.name)
-            
-        return list
-        
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
-        action = QAction(text, None)
-        if icon is not None:
-            action.setIcon(QIcon("media/icons/%s" % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            QWidget.connect(action, SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
-        
-        
-        
+#################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import functools
+import xml.etree.cElementTree as xml
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+ 
+import ogre.renderer.OGRE as og
+ 
+from ModuleExplorer import NameInputDlg
+ 
+#                <zone name="Testzone">
+#                        <area type="sphere">
+#                                <position x="-10" y="0" z="-5"/>
+#                                <scale x="6" y="6" z="6"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
+#                                <position x="25" y="0" z="-50"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="sphere" subtract="true">
+#                                <position x="-11" y="0" z="-4"/>
+#                                <scale x="2" y="2" z="2"/>
+#                        </area>
+#                        <light name="red pointlight"/>
+#                        <light name="green spotlight"/>
+#                        <sound name="ruchin001.ogg"/>
+#                        <trigger name="test" classname="TestTrigger">
+#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
+#                        </trigger>
+#                </zone>
+ 
+class Area(og.UserDefinedObject):
+    def __init__(self,sceneManager, type, parentZone, id, position, orientation, scale, meshFile = None, transitiondistance = "0.5", subtract = False):
+        og.UserDefinedObject.__init__(self)
+        self.type = type
+        self.parentZone = parentZone
+        if not parentZone:
+           raise Exception("No parentZone")
+
+        self.id = id # editor internal id for entity and node creation
+        self.areaNode = parentZone.zoneNode.createChildSceneNode("area_" + parentZone.name + " " + str(id))
+        self.meshFile = meshFile
+        self.areaEntity = None
+        self.transitiondistance = transitiondistance
+        self.__subtract = subtract
+        self.sceneManager = sceneManager
+        
+        if type == "box":
+            self.areaEntity = self.sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", "UniCube.mesh")
+        elif type == "sphere":
+            self.areaEntity = self.sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", "UniSphere.mesh")        
+        elif type == "ellipsoid":
+            print "not yet"
+        elif type == "capsule":
+            print "not yet"
+        elif type == "pyramid":
+            print "not yet"
+        elif type == "mesh":
+            try:
+                self.areaEntity = sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", self.meshFile)
+            except:
+                print "Mesh " + self.meshFile + " not found!"
+                return None
+                
+        self.areaEntity.setMaterialName("Lockenwickler_Area")
+        if self.__subtract:
+            self.areaEntity.setMaterialName("Lockenwickler_Area_Subtract")
+            
+        self.areaEntity.setUserObject(self)
+        self.areaNode.attachObject(self.areaEntity)
+        self.areaNode.setPosition(position)
+        if orientation is not None:
+            self.areaNode.setOrientation(orientation.w, orientation.x, orientation.y, orientation.z)
+        if scale is not None:
+            self.areaNode.setScale(scale)
+    
+    def __del__(self):
+        self.areaNode.detachAllObjects()
+        self.areaNode.getParent().removeAndDestroyChild(self.areaNode.getName())
+        self.sceneManager.destroyEntity(self.areaEntity.getName())
+    
+    def getsubtract(self):
+        return self.__subtract
+        
+    def setsubtract(self, val):
+        if not val:
+            self.areaEntity.setMaterialName("Lockenwickler_Area")
+        else:
+            self.areaEntity.setMaterialName("Lockenwickler_Area_Subtract")
+        
+        self.__subtract = val
+        
+    subtract = property(getsubtract, setsubtract)
+    
+class Zone():
+    def __init__(self,sceneManager, map, name):
+        self.map = map
+        self.name = name
+        self.areaList = []
+        self.lightList = []
+        self.soundList = []
+        self.triggerList = []
+        self.areaCounter = 0
+        self.sceneManager = sceneManager
+        self.isHidden = False
+        
+        self.zoneNode =  self.sceneManager.getRootSceneNode().createChildSceneNode("zone_" + name + "_node")
+        
+    def addArea(self, type, position, orientation, scale, meshFile = None):
+        area = Area(self.sceneManager, type, self, self.areaCounter, position, orientation, scale, meshFile)
+        if area is not None:
+            self.areaList.append(area)
+            self.areaCounter = self.areaCounter + 1
+    
+    def deleteArea(self, area):
+        for a in self.areaList:
+            if a.id == area.id:
+                self.areaList.remove(a)
+                del a
+    
+    def hide(self):
+        self.sceneManager.getRootSceneNode().removeChild(self.zoneNode)
+        self.isHidden = True
+    
+    def show(self):
+        self.sceneManager.getRootSceneNode().addChild(self.zoneNode)
+        self.isHidden = False
+        
+        
+class ZoneManager():
+    def __init__(self, sceneManager):
+        self.currentMap = None
+        self.zoneList = []
+        self.menuList = []
+        self.entityUnderMouse = None
+        self.newAreaPosition = None
+        self.sceneManager = sceneManager
+        
+    def createZone(self, name):
+        if self.currentMap == None:
+            print "No map selected!"
+            return
+            
+        z = Zone(self.sceneManager, self.currentMap, name)
+        self.zoneList.append(z)
+        self.currentMap.zoneList.append(z)
+        return z
+        
+    def parseZonesFromXml(self, zoneXmlNode, map):
+        if zoneXmlNode is None:
+            return
+        
+        self.currentMap = map
+        
+        zoneNodes = zoneXmlNode.getiterator("zone")
+        for zone in zoneNodes:
+            zoneName = zone.attrib["name"]
+            z = self.createZone(zoneName)
+            
+            areaNodes = zone.getiterator("area")
+            for area in areaNodes:
+                type = area.attrib["type"]
+                meshFile = None
+                if type == "mesh":
+                    meshFile = area.attrib["meshfile"]
+                
+                pos = og.Vector3()
+                qw = qx = qy = qz = 0
+                scale = None
+                hasRotation = False
+                
+                transformations = area.getiterator()
+                for t in transformations:
+                    if t.tag == "position":
+                        posx = float(t.attrib["x"])
+                        posy = float(t.attrib["y"])
+                        posz = float(t.attrib["z"])
+                        pos = og.Vector3(posx, posy, posz)
+                    elif t.tag == "rotation":
+                        qw = float(t.attrib["qw"])
+                        qx = float(t.attrib["qx"])
+                        qy = float(t.attrib["qy"])
+                        qz = float(t.attrib["qz"])
+                        hasRotation = True
+                    elif type == "mesh" and t.tag == "scale":
+                        scalex = float(t.attrib["x"])
+                        scaley = float(t.attrib["y"])
+                        scalez = float(t.attrib["z"])
+                        scale = og.Vector3(scalex, scaley, scalez)
+                    elif t.tag == "size":
+                        scalex = float(t.attrib["x"])
+                        scaley = float(t.attrib["y"])
+                        scalez = float(t.attrib["z"])
+                        scale = og.Vector3(scalex, scaley, scalez)
+                
+                rot = None
+                if hasRotation:
+                    rot = og.Quaternion(qw, qx, qy, qz)
+                    
+                z.addArea(type, pos, rot, scale, meshFile)
+            
+            
+            lightNodes = zone.getiterator("light")
+            for light in lightNodes:
+                name = light.attrib["name"]
+                z.lightList.append(name)
+                
+            soundNodes = zone.getiterator("sound")
+            for sound in soundNodes:
+                name = sound.attrib["name"]
+                z.soundList.append(name)
+            
+
+    def saveZonesToXml(self, root, map):
+        if len(map.zoneList) == 0:
+            return
+        
+        rootZonesElem = xml.SubElement(root, "zones")
+        for zone in map.zoneList:
+            zoneElem = xml.SubElement(rootZonesElem, "zone")
+            zoneElem.attrib["name"] = zone.name
+            
+            for area in zone.areaList:
+                areaElem = xml.SubElement(zoneElem, "area")
+                areaElem.attrib["type"] = area.type
+                #print "Saving Zone: " + zone.name + " - Area " + str(area.id)
+                if area.type == "mesh" and area.meshFile is not None:
+                    areaElem.attrib["meshfile"] = area.meshFile
+                    
+                posElem = xml.SubElement(areaElem, "position")
+                posElem.attrib["x"] = str(area.areaNode.getPosition().x)
+                posElem.attrib["y"] = str(area.areaNode.getPosition().y)
+                posElem.attrib["z"] = str(area.areaNode.getPosition().z)
+                
+                rotElem = xml.SubElement(areaElem, "rotation")
+                rotElem.attrib["qw"] = str(area.areaNode.getOrientation().w)
+                rotElem.attrib["qx"] = str(area.areaNode.getOrientation().x)
+                rotElem.attrib["qy"] = str(area.areaNode.getOrientation().y)
+                rotElem.attrib["qz"] = str(area.areaNode.getOrientation().z)
+                
+                scaleElem = None
+                if area.type == "mesh":
+                    scaleElem = xml.SubElement(areaElem, "scale")
+                else:
+                    scaleElem = xml.SubElement(areaElem, "size")
+
+                scaleElem.attrib["x"] = str(area.areaNode.getScale().x)
+                scaleElem.attrib["y"] = str(area.areaNode.getScale().y)
+                scaleElem.attrib["z"] = str(area.areaNode.getScale().z)
+                
+            for lightName in zone.lightList:
+                lightElem = xml.SubElement(zoneElem, "light")
+                lightElem.attrib["name"] = str(lightName)
+            
+            for soundName in zone.soundList:
+                soundElem = xml.SubElement(zoneElem, "sound")
+                soundElem.attrib["name"] = str(soundName)
+                
+    def deleteArea(self, area):
+        for z in self.zoneList:
+            for a in z.areaList:
+                if a.id == area.id:
+                    z.deleteArea(area)
+    
+    def getZoneMenu(self):
+        self.menuList = []
+        menu = QMenu("Add Area")
+        
+        for zone in self.zoneList:
+            m = QMenu(zone.name)
+            self.menuList.append(m)
+            menu.addMenu(m)
+            
+            boxAction = self.createAction("box", functools.partial(self.onZoneNameTriggered, zone, "box"))
+            self.menuList.append(boxAction)
+            m.addAction(boxAction)
+            
+            sphereAction = self.createAction("sphere", functools.partial(self.onZoneNameTriggered, zone, "sphere"))
+            self.menuList.append(sphereAction)
+            m.addAction(sphereAction)
+            
+            ellipsoidAction = self.createAction("ellipsoid", functools.partial(self.onZoneNameTriggered, zone, "ellipsoid"))
+            self.menuList.append(ellipsoidAction)
+            m.addAction(ellipsoidAction)
+            
+            capsuleAction = self.createAction("capsule", functools.partial(self.onZoneNameTriggered, zone, "capsule"))
+            self.menuList.append(capsuleAction)
+            m.addAction(capsuleAction)
+            
+            pyramidAction = self.createAction("pyramid", functools.partial(self.onZoneNameTriggered, zone, "pyramid"))
+            self.menuList.append(pyramidAction)
+            m.addAction(pyramidAction)
+            
+            meshAction = self.createAction("mesh", functools.partial(self.onZoneNameTriggered, zone, "mesh"))
+            self.menuList.append(meshAction)
+            m.addAction(meshAction)
+            
+        return menu
+        
+    def onZoneNameTriggered(self, zone, type):
+        if self.newAreaPosition is not None:
+            if type == "box":
+                zone.addArea("box", self.newAreaPosition, None, None)
+            elif type == "sphere":
+                zone.addArea("sphere", self.newAreaPosition, None, None)
+            elif type == "mesh":
+                dlg = NameInputDlg(QApplication.focusWidget())
+                resName = ""
+                if dlg.exec_():
+                    resName = str(dlg.nameInput.text())
+
+                zone.addArea("mesh", self.newAreaPosition, None, None, resName)
+                
+    def getZone(self, name):
+        for zone in self.zoneList:
+            if zone.name == name:
+                return zone
+        
+    def getZoneList(self):
+        list = []
+        for zone in self.zoneList:
+            list.append(zone.name)
+            
+        return list
+        
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QAction(text, None)
+        if icon is not None:
+            action.setIcon(QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            QWidget.connect(action, SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+        
+        
+        



From fusion2 at mail.berlios.de  Wed Apr 15 20:02:40 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Wed, 15 Apr 2009 20:02:40 +0200
Subject: [Dsa-hl-svn] r4900 - in rl/trunk/editors/Lockenwickler: .
	_eric4project
Message-ID: <200904151802.n3FI2er4008447@sheep.berlios.de>

Author: fusion2
Date: 2009-04-15 20:02:38 +0200 (Wed, 15 Apr 2009)
New Revision: 4900

Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
   rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
Log:
- forgot to commit the project files

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-04-15 17:58:20 UTC (rev 4899)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-04-15 18:02:38 UTC (rev 4900)
@@ -1,183 +1,183 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE Project SYSTEM "Project-4.6.dtd">
-<!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-04-10, 16:03:00 -->
-<!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
-<Project version="4.6">
-  <Language>en</Language>
-  <ProgLanguage mixed="0">Python</ProgLanguage>
-  <ProjectType>Qt4</ProjectType>
-  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
-  <Version>0.1</Version>
-  <Author>Stefan Stammberger</Author>
-  <Email>sstammberger at web.de</Email>
-  <Sources>
-    <Source>src/Lockenwickler.py</Source>
-    <Source>src/ConsoleWindow.py</Source>
-    <Source>src/ModelSelectionDialog.py</Source>
-    <Source>src/ModuleManager.py</Source>
-    <Source>src/MovePivot.py</Source>
-    <Source>src/ObjectPropertyWin.py</Source>
-    <Source>src/OgreMainWindow.py</Source>
-    <Source>src/OgreWidget.py</Source>
-    <Source>src/PreferencesDialog.py</Source>
-    <Source>src/PythonOgreConfig.py</Source>
-    <Source>src/ui_ConsoleWindow.py</Source>
-    <Source>src/Property.py</Source>
-    <Source>src/ViewportGrid.py</Source>
-    <Source>src/ObjectPropertyModel.py</Source>
-    <Source>src/GameObjectClass.py</Source>
-    <Source>src/GameObjectClassManager.py</Source>
-    <Source>src/setup.py</Source>
-    <Source>src/GameObjectClassView.py</Source>
-    <Source>src/MyRaySceneQueryListener.py</Source>
-    <Source>src/GOStringEditor.py</Source>
-    <Source>src/GOIntEditor.py</Source>
-    <Source>src/NewModuleWizard.py</Source>
-    <Source>src/Ui_NewModuleWizard.py</Source>
-    <Source>src/ModuleExplorer.py</Source>
-    <Source>src/SelectionBuffer.py</Source>
-    <Source>src/MaterialSelectionDialog.py</Source>
-    <Source>src/DepthBuffer.py</Source>
-    <Source>src/ZoneManager.py</Source>
-    <Source>src/GOGenericEditor.py</Source>
-  </Sources>
-  <Forms>
-    <Form>ui files/GOPropertyEditorDialogINT.ui</Form>
-    <Form>ui files/GOPropertyEditorDialogSTRING.ui</Form>
-    <Form>ui files/NewModuleWizard.ui</Form>
-  </Forms>
-  <Translations>
-  </Translations>
-  <Resources>
-  </Resources>
-  <Interfaces>
-  </Interfaces>
-  <Others>
-  </Others>
-  <MainScript>src/Lockenwickler.py</MainScript>
-  <Vcs>
-    <VcsType>Subversion</VcsType>
-    <VcsOptions>
-      <dict>
-        <key>
-          <string>add</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>checkout</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>commit</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>diff</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>export</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>global</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>history</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>log</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>remove</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>status</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>tag</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>update</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-      </dict>
-    </VcsOptions>
-    <VcsOtherData>
-      <dict>
-        <key>
-          <string>standardLayout</string>
-        </key>
-        <value>
-          <bool>True</bool>
-        </value>
-      </dict>
-    </VcsOtherData>
-  </Vcs>
-  <FiletypeAssociations>
-    <FiletypeAssociation pattern="*.ui" type="FORMS" />
-    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
-    <FiletypeAssociation pattern="*.qm" type="TRANSLATIONS" />
-    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
-    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
-    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
-    <FiletypeAssociation pattern="*.ts" type="TRANSLATIONS" />
-    <FiletypeAssociation pattern="*.py" type="SOURCES" />
-    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
-  </FiletypeAssociations>
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE Project SYSTEM "Project-4.6.dtd">
+<!-- eric4 project file for project Lockenwickler -->
+<!-- Saved: 2009-04-15, 19:54:27 -->
+<!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
+<Project version="4.6">
+  <Language>en</Language>
+  <ProgLanguage mixed="0">Python</ProgLanguage>
+  <ProjectType>Qt4</ProjectType>
+  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
+  <Version>0.1</Version>
+  <Author>Stefan Stammberger</Author>
+  <Email>sstammberger at web.de</Email>
+  <Sources>
+    <Source>src/Lockenwickler.py</Source>
+    <Source>src/ConsoleWindow.py</Source>
+    <Source>src/ModelSelectionDialog.py</Source>
+    <Source>src/ModuleManager.py</Source>
+    <Source>src/MovePivot.py</Source>
+    <Source>src/ObjectPropertyWin.py</Source>
+    <Source>src/OgreMainWindow.py</Source>
+    <Source>src/OgreWidget.py</Source>
+    <Source>src/PreferencesDialog.py</Source>
+    <Source>src/PythonOgreConfig.py</Source>
+    <Source>src/ui_ConsoleWindow.py</Source>
+    <Source>src/Property.py</Source>
+    <Source>src/ViewportGrid.py</Source>
+    <Source>src/ObjectPropertyModel.py</Source>
+    <Source>src/GameObjectClass.py</Source>
+    <Source>src/GameObjectClassManager.py</Source>
+    <Source>src/setup.py</Source>
+    <Source>src/GameObjectClassView.py</Source>
+    <Source>src/MyRaySceneQueryListener.py</Source>
+    <Source>src/GOStringEditor.py</Source>
+    <Source>src/GOIntEditor.py</Source>
+    <Source>src/NewModuleWizard.py</Source>
+    <Source>src/Ui_NewModuleWizard.py</Source>
+    <Source>src/ModuleExplorer.py</Source>
+    <Source>src/SelectionBuffer.py</Source>
+    <Source>src/MaterialSelectionDialog.py</Source>
+    <Source>src/DepthBuffer.py</Source>
+    <Source>src/ZoneManager.py</Source>
+    <Source>src/GOGenericEditor.py</Source>
+  </Sources>
+  <Forms>
+    <Form>ui files/GOPropertyEditorDialogINT.ui</Form>
+    <Form>ui files/GOPropertyEditorDialogSTRING.ui</Form>
+    <Form>ui files/NewModuleWizard.ui</Form>
+  </Forms>
+  <Translations>
+  </Translations>
+  <Resources>
+  </Resources>
+  <Interfaces>
+  </Interfaces>
+  <Others>
+  </Others>
+  <MainScript>src/Lockenwickler.py</MainScript>
+  <Vcs>
+    <VcsType>None</VcsType>
+    <VcsOptions>
+      <dict>
+        <key>
+          <string>add</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>checkout</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>commit</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>diff</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>export</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>global</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>history</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>log</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>remove</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>status</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>tag</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>update</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+      </dict>
+    </VcsOptions>
+    <VcsOtherData>
+      <dict>
+        <key>
+          <string>standardLayout</string>
+        </key>
+        <value>
+          <bool>True</bool>
+        </value>
+      </dict>
+    </VcsOtherData>
+  </Vcs>
+  <FiletypeAssociations>
+    <FiletypeAssociation pattern="*.ui" type="FORMS" />
+    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
+    <FiletypeAssociation pattern="*.qm" type="TRANSLATIONS" />
+    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
+    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
+    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
+    <FiletypeAssociation pattern="*.ts" type="TRANSLATIONS" />
+    <FiletypeAssociation pattern="*.py" type="SOURCES" />
+    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
+  </FiletypeAssociations>
 </Project>
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-04-15 17:58:20 UTC (rev 4899)
+++ rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-04-15 18:02:38 UTC (rev 4900)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE UserProject SYSTEM "UserProject-4.0.dtd">
 <!-- eric4 user project file for project Lockenwickler -->
-<!-- Saved: 2009-03-01, 22:49:19 -->
+<!-- Saved: 2009-04-15, 19:54:27 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <UserProject version="4.0">
 </UserProject>
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
===================================================================
--- rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-04-15 17:58:20 UTC (rev 4899)
+++ rl/trunk/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-04-15 18:02:38 UTC (rev 4900)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Tasks SYSTEM "Tasks-4.2.dtd">
 <!-- eric4 tasks file for project Lockenwickler -->
-<!-- Saved: 2009-03-01, 22:49:19 -->
+<!-- Saved: 2009-04-15, 19:54:27 -->
 <Tasks version="4.2">
   <Task priority="1" completed="False" bugfix="False">
     <Summary>TODO: not implemented yet</Summary>
@@ -24,10 +24,10 @@
   <Task priority="1" completed="False" bugfix="False">
     <Summary>TODO: implement save here</Summary>
     <Description></Description>
-    <Created>2009-03-01, 21:50:14</Created>
+    <Created>2009-04-15, 19:40:07</Created>
     <Resource>
       <Filename>src/Lockenwickler.py</Filename>
-      <Linenumber>458</Linenumber>
+      <Linenumber>537</Linenumber>
     </Resource>
   </Task>
 </Tasks>
\ No newline at end of file



From timm at mail.berlios.de  Thu Apr 16 15:42:31 2009
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Thu, 16 Apr 2009 15:42:31 +0200
Subject: [Dsa-hl-svn] r4901 - in rl/branches/persistence2/engine/rules:
	include src
Message-ID: <200904161342.n3GDgVIK015649@sheep.berlios.de>

Author: timm
Date: 2009-04-16 15:42:21 +0200 (Thu, 16 Apr 2009)
New Revision: 4901

Modified:
   rl/branches/persistence2/engine/rules/include/PartyManager.h
   rl/branches/persistence2/engine/rules/src/PartyManager.cpp
Log:
- typo in party manager
- added remove all member

Modified: rl/branches/persistence2/engine/rules/include/PartyManager.h
===================================================================
--- rl/branches/persistence2/engine/rules/include/PartyManager.h	2009-04-15 18:02:38 UTC (rev 4900)
+++ rl/branches/persistence2/engine/rules/include/PartyManager.h	2009-04-16 13:42:21 UTC (rev 4901)
@@ -36,6 +36,7 @@
         void setActiveCharacter(Creature* character);
         void addCharacter(Creature* character);
         void removeCharacter(Creature* character);
+        void removeAllCharacters();
         Party getCharacters() const;
         bool isInParty(Creature* creature) const;
         

Modified: rl/branches/persistence2/engine/rules/src/PartyManager.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/PartyManager.cpp	2009-04-15 18:02:38 UTC (rev 4900)
+++ rl/branches/persistence2/engine/rules/src/PartyManager.cpp	2009-04-16 13:42:21 UTC (rev 4901)
@@ -41,7 +41,7 @@
     void PartyManager::addCharacter(Creature* character)
     {
         mParty.push_back(character);
-        MessagePump::getSingleton().sendMessage<MessageType_PlayerCharRemoved>(
+        MessagePump::getSingleton().sendMessage<MessageType_PlayerCharAdded>(
 			character);
         
         if (mActiveCharacter == NULL)
@@ -65,10 +65,21 @@
         }
         checkParty();
     }
+
+    void PartyManager::removeAllCharacters()
+    {
+        for (std::vector<Creature*>::iterator it = mParty.begin();
+             it != mParty.end(); ++it)
+        {    
+            MessagePump::getSingleton().sendMessage<MessageType_PlayerCharRemoved>(*it);
+            mParty.erase(it);
+        }
+        checkParty();
+    }
     
     void PartyManager::setActiveCharacter(Creature* character)
     {
-        if (!isInParty(character))
+        if (!isInParty(character) && character)
         {
             addCharacter(character);
         }



From fusion2 at mail.berlios.de  Fri Apr 17 20:31:45 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Fri, 17 Apr 2009 20:31:45 +0200
Subject: [Dsa-hl-svn] r4902 - in rl/trunk/editors/Lockenwickler: . src
Message-ID: <200904171831.n3HIVjga026114@sheep.berlios.de>

Author: fusion2
Date: 2009-04-17 20:31:40 +0200 (Fri, 17 Apr 2009)
New Revision: 4902

Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModuleDirectoryView.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
Log:
- changes to the preferences dialog
- more work on the module directory view

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-04-16 13:42:21 UTC (rev 4901)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-04-17 18:31:40 UTC (rev 4902)
@@ -1,183 +1,184 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE Project SYSTEM "Project-4.6.dtd">
-<!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-04-15, 19:54:27 -->
-<!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
-<Project version="4.6">
-  <Language>en</Language>
-  <ProgLanguage mixed="0">Python</ProgLanguage>
-  <ProjectType>Qt4</ProjectType>
-  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
-  <Version>0.1</Version>
-  <Author>Stefan Stammberger</Author>
-  <Email>sstammberger at web.de</Email>
-  <Sources>
-    <Source>src/Lockenwickler.py</Source>
-    <Source>src/ConsoleWindow.py</Source>
-    <Source>src/ModelSelectionDialog.py</Source>
-    <Source>src/ModuleManager.py</Source>
-    <Source>src/MovePivot.py</Source>
-    <Source>src/ObjectPropertyWin.py</Source>
-    <Source>src/OgreMainWindow.py</Source>
-    <Source>src/OgreWidget.py</Source>
-    <Source>src/PreferencesDialog.py</Source>
-    <Source>src/PythonOgreConfig.py</Source>
-    <Source>src/ui_ConsoleWindow.py</Source>
-    <Source>src/Property.py</Source>
-    <Source>src/ViewportGrid.py</Source>
-    <Source>src/ObjectPropertyModel.py</Source>
-    <Source>src/GameObjectClass.py</Source>
-    <Source>src/GameObjectClassManager.py</Source>
-    <Source>src/setup.py</Source>
-    <Source>src/GameObjectClassView.py</Source>
-    <Source>src/MyRaySceneQueryListener.py</Source>
-    <Source>src/GOStringEditor.py</Source>
-    <Source>src/GOIntEditor.py</Source>
-    <Source>src/NewModuleWizard.py</Source>
-    <Source>src/Ui_NewModuleWizard.py</Source>
-    <Source>src/ModuleExplorer.py</Source>
-    <Source>src/SelectionBuffer.py</Source>
-    <Source>src/MaterialSelectionDialog.py</Source>
-    <Source>src/DepthBuffer.py</Source>
-    <Source>src/ZoneManager.py</Source>
-    <Source>src/GOGenericEditor.py</Source>
-  </Sources>
-  <Forms>
-    <Form>ui files/GOPropertyEditorDialogINT.ui</Form>
-    <Form>ui files/GOPropertyEditorDialogSTRING.ui</Form>
-    <Form>ui files/NewModuleWizard.ui</Form>
-  </Forms>
-  <Translations>
-  </Translations>
-  <Resources>
-  </Resources>
-  <Interfaces>
-  </Interfaces>
-  <Others>
-  </Others>
-  <MainScript>src/Lockenwickler.py</MainScript>
-  <Vcs>
-    <VcsType>None</VcsType>
-    <VcsOptions>
-      <dict>
-        <key>
-          <string>add</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>checkout</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>commit</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>diff</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>export</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>global</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>history</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>log</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>remove</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>status</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>tag</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-        <key>
-          <string>update</string>
-        </key>
-        <value>
-          <list>
-            <string></string>
-          </list>
-        </value>
-      </dict>
-    </VcsOptions>
-    <VcsOtherData>
-      <dict>
-        <key>
-          <string>standardLayout</string>
-        </key>
-        <value>
-          <bool>True</bool>
-        </value>
-      </dict>
-    </VcsOtherData>
-  </Vcs>
-  <FiletypeAssociations>
-    <FiletypeAssociation pattern="*.ui" type="FORMS" />
-    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
-    <FiletypeAssociation pattern="*.qm" type="TRANSLATIONS" />
-    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
-    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
-    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
-    <FiletypeAssociation pattern="*.ts" type="TRANSLATIONS" />
-    <FiletypeAssociation pattern="*.py" type="SOURCES" />
-    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
-  </FiletypeAssociations>
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE Project SYSTEM "Project-4.6.dtd">
+<!-- eric4 project file for project Lockenwickler -->
+<!-- Saved: 2009-04-16, 19:30:12 -->
+<!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
+<Project version="4.6">
+  <Language>en</Language>
+  <ProgLanguage mixed="0">Python</ProgLanguage>
+  <ProjectType>Qt4</ProjectType>
+  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
+  <Version>0.1</Version>
+  <Author>Stefan Stammberger</Author>
+  <Email>sstammberger at web.de</Email>
+  <Sources>
+    <Source>src/Lockenwickler.py</Source>
+    <Source>src/ConsoleWindow.py</Source>
+    <Source>src/ModelSelectionDialog.py</Source>
+    <Source>src/ModuleManager.py</Source>
+    <Source>src/MovePivot.py</Source>
+    <Source>src/ObjectPropertyWin.py</Source>
+    <Source>src/OgreMainWindow.py</Source>
+    <Source>src/OgreWidget.py</Source>
+    <Source>src/PreferencesDialog.py</Source>
+    <Source>src/PythonOgreConfig.py</Source>
+    <Source>src/ui_ConsoleWindow.py</Source>
+    <Source>src/Property.py</Source>
+    <Source>src/ViewportGrid.py</Source>
+    <Source>src/ObjectPropertyModel.py</Source>
+    <Source>src/GameObjectClass.py</Source>
+    <Source>src/GameObjectClassManager.py</Source>
+    <Source>src/setup.py</Source>
+    <Source>src/GameObjectClassView.py</Source>
+    <Source>src/MyRaySceneQueryListener.py</Source>
+    <Source>src/GOStringEditor.py</Source>
+    <Source>src/GOIntEditor.py</Source>
+    <Source>src/NewModuleWizard.py</Source>
+    <Source>src/Ui_NewModuleWizard.py</Source>
+    <Source>src/ModuleExplorer.py</Source>
+    <Source>src/SelectionBuffer.py</Source>
+    <Source>src/MaterialSelectionDialog.py</Source>
+    <Source>src/DepthBuffer.py</Source>
+    <Source>src/ZoneManager.py</Source>
+    <Source>src/GOGenericEditor.py</Source>
+    <Source>src/ModuleDirectoryView.py</Source>
+  </Sources>
+  <Forms>
+    <Form>ui files/GOPropertyEditorDialogINT.ui</Form>
+    <Form>ui files/GOPropertyEditorDialogSTRING.ui</Form>
+    <Form>ui files/NewModuleWizard.ui</Form>
+  </Forms>
+  <Translations>
+  </Translations>
+  <Resources>
+  </Resources>
+  <Interfaces>
+  </Interfaces>
+  <Others>
+  </Others>
+  <MainScript>src/Lockenwickler.py</MainScript>
+  <Vcs>
+    <VcsType>Subversion</VcsType>
+    <VcsOptions>
+      <dict>
+        <key>
+          <string>add</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>checkout</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>commit</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>diff</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>export</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>global</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>history</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>log</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>remove</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>status</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>tag</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>update</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+      </dict>
+    </VcsOptions>
+    <VcsOtherData>
+      <dict>
+        <key>
+          <string>standardLayout</string>
+        </key>
+        <value>
+          <bool>True</bool>
+        </value>
+      </dict>
+    </VcsOtherData>
+  </Vcs>
+  <FiletypeAssociations>
+    <FiletypeAssociation pattern="*.ui" type="FORMS" />
+    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
+    <FiletypeAssociation pattern="*.qm" type="TRANSLATIONS" />
+    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
+    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
+    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
+    <FiletypeAssociation pattern="*.ts" type="TRANSLATIONS" />
+    <FiletypeAssociation pattern="*.py" type="SOURCES" />
+    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
+  </FiletypeAssociations>
 </Project>
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-04-16 13:42:21 UTC (rev 4901)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-04-17 18:31:40 UTC (rev 4902)
@@ -1,572 +1,572 @@
- #################################################
-# This source file is part of Rastullahs Lockenwickler.
-# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
-
-import os
-import sys
-import platform
-import subprocess
-
-sys.path.insert(0,'..')
-import PythonOgreConfig
-
-from random import randint
-
-from PyQt4 import QtGui, QtCore
-from PreferencesDialog import *
-from ObjectPropertyWin import *
-from ModelSelectionDialog import *
-from MaterialSelectionDialog import *
-from GameObjectClassView import *
-from ConsoleWindow import *
-from ModuleManager import ModuleManager
-from ModuleExplorer import *
-from NewModuleWizard import *
-from MovePivot import *
-from PivotRenderQueueListener import *
-from ModuleDirectoryView import *
-
-import OgreMainWindow
-import ogre.renderer.OGRE as og
-
-class Lockenwickler(QtGui.QMainWindow):
-    def __init__(self, parent=None):
-        QtGui.QWidget.__init__(self, parent)
-
-#        pixmap = QPixmap("media/icons/lockenwickler_provisorium.png")
-#        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
-#        splash.setMask(pixmap.mask())
-#        splash.showMessage("Starting...")
-#        splash.show() 
-
-        self.setupUi()
-
-        self.consoleWindow = ConsoleWindow(False,  self)
-
-        self.setupOgre()
-
-        self.prefDialog = PreferencesDialog(self)
-        self.objectPropertyWin = ObjectPropertyWin(self.OgreMainWinSceneMgr, self.gocManager, self)
-        self.moduleExplorerWin = ModuleExplorer(self)
-        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
-        self.materialSelectionDialog = MaterialSelectionDialog(self.ogreRoot, self)
-        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
-        self.moduleManager.materialSelectionDialog = self.materialSelectionDialog
-        self.moduleDirectoryViewWin = ModuleDirectoryView(self)
-        
-        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
-
-        self.createDockWindows()
-
-        self.mainTimer = QtCore.QTimer(self)
-        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL("timeout()"), self.update)
-        self.mainTimer.start(5)
-
-        settings = QtCore.QSettings()
-        self.restoreGeometry(settings.value("MainWindow/Geometry").toByteArray())
-        self.restoreState(settings.value("MainWindow/DockWindows").toByteArray())
-        if not self.prefDialog.setCfgPath(settings.value("Preferences/moduleCfgPath").toString()):
-            self.prefDialog.show()
-            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
-        else:
-            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
-        
-        self.moduleDirectoryViewWin.parseDirectory(self.prefDialog.moduleCfgPath.replace("modules.cfg", ""))
-        
-        self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
-        self.moduleManager.setModuleDirView(self.moduleDirectoryViewWin)
-        self.moduleManager.setPropertyWindow(self.objectPropertyWin)
-        self.moduleManager.setContextMenuCallback(self.onContextMenuCallback)
-        
-        self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
-        self.setWindowTitle("Rastullahs Lockenwickler")
-        
-        self.editorSetupFinished = False
-        
-#        splash.finish(self)
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
-        action = QtGui.QAction(text, self)
-        if icon is not None:
-            action.setIcon(QtGui.QIcon("media/icons/%s" % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            self.connect(action, QtCore.SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
-
-    def addActions(self, target, actions):
-        for act in actions:
-            if act is None:
-               target.addSeparator()
-            else:
-                target.addAction(act)
-
-    def setupUi(self):
-        self.setObjectName("MainWindow")
-
-        self.centralwidget = QtGui.QWidget(self)
-        self.centralwidget.setObjectName("centralwidget")
-
-        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
-        self.hboxlayout.setContentsMargins(0, 0, 0, 0)
-        self.hboxlayout.setObjectName("hboxlayout")
-
-        self.gridlayout = QtGui.QGridLayout()
-        self.gridlayout.setObjectName("gridlayout")
-        self.gridlayout.setContentsMargins(0, 0, 0, 0)
-        
-        self.menubar = QtGui.QMenuBar(self)
-        self.menubar.setObjectName("menubar")
-
-        self.menuFile = QtGui.QMenu(self.menubar)
-        self.menuFile.setObjectName("menuFile")
-
-        self.menuEdit = QtGui.QMenu(self.menubar)
-        self.menuEdit.setObjectName("menuEdit")
-
-        self.menuView = QtGui.QMenu(self.menubar)
-        self.menuView.setObjectName("menuView")
-        self.setMenuBar(self.menubar)
-
-
-        self.statusbar = QtGui.QStatusBar(self)
-        self.statusbar.setObjectName("statusbar")
-        self.setStatusBar(self.statusbar)
-
-#####################################
-        self.actionNeu =self.createAction("&New Module",  self.actionNewSlot,  QKeySequence.New,  "filenew.png",  "New Module")
-        self.actionNeu.setObjectName("actionNeu")
-
-        self.actionOpen = self.createAction("&Open Module",  self.actionOpenSlot,  QKeySequence.Open,  "fileopen.png",  "Open Module")
-        self.actionOpen.setObjectName("actionOpen")
-        
-        self.actionSave = self.createAction("&Save",  self.actionSaveSlot,  QKeySequence.Save,  "filesave.png",  "Save Module")
-        self.actionSave.setObjectName("actionSave")
-        
-        self.actionRunModule = self.createAction("&Save and Run",  self.actionRunModuleSlot,  "Alt+R",  "fileexport.png",  "Save And Run Module")
-        self.actionRunModule.setObjectName("actionRunModule")
-
-        self.actionClose = self.createAction("Quit",  self.actionQuitSlot,  "Alt+Q",  "exit.png",  "Quit")
-        self.actionClose.setObjectName("actionQuit")
-#####################################
-
-
-#####################################
-        self.actionDelete = self.createAction("Delete",  self.actionDeleteSlot,  QKeySequence.Delete,  "editdelete.png",  "Delete")
-        self.actionDelete.setObjectName("actionDelete")
-
-        self.actionCopy = self.createAction("Copy",  self.actionCopySlot,  QKeySequence.Copy,  "editcopy.png",  "Copy")
-        self.actionCopy.setObjectName("actionCopy")
-
-        self.actionCut = self.createAction("Cut",  self.actionCutSlot,  QKeySequence.Cut,  "editcut.png",  "Cut")
-        self.actionCut.setObjectName("actionCut")
-
-        self.actionPaste = self.createAction("Paste",  self.actionPasteSlot,  QKeySequence.Paste,  "editpaste.png",  "Paste")
-        self.actionPaste.setObjectName("actionPaste")
-
-        self.actionSelect = self.createAction("&Select",  self.actionSelectSlot,  "Space",  "cursor.png",  "Move selected object")
-        self.actionSelect.setObjectName("actionSelect")
-
-        self.actionMove = self.createAction("&Move",  self.actionMoveSlot,  "g",  "move.png",  "Move selected object")
-        self.actionMove.setObjectName("actionMove")
-
-        self.actionRotate = self.createAction("&Rotate",  self.actionRotateSlot,  "r",  "rotate.png",  "Rotate selected object")
-        self.actionRotate.setObjectName("actionRotate")
-
-        self.actionScale = self.createAction("&Scale",  self.actionScaleSlot,  "x",  "resizecol.png",  "Scale selected object")
-        self.actionScale.setObjectName("actionScale")
-
-        self.actionOneClickEntityPlacement = self.createAction("&OneClickEntityPlacement",  self.actionOneClickEntityPlacementSlot,  "",  "resizecol.png",  "Add an Entity just by a click")
-        self.actionOneClickEntityPlacement.setObjectName("actionOneClickEntityPlacement")
-        self.actionOneClickEntityPlacement.setCheckable(True)
-
-#####################################
-#####################################
-        self.actionSceneExplorer = self.createAction("&Scene Exlporer",  self.toggleModuleExplorer,  "Alt+E",  "view_tree.png",  "Module Explorer",  False)
-        self.actionSceneExplorer.setObjectName("actionSceneExplorer")
-        
-        self.actionModuleDirView = self.createAction("&Directory Explorer",  self.toggleModuleDirView,  "Alt+D",  "view_tree.png",  "Module Directory Explorer",  False)
-        self.actionModuleDirView.setObjectName("actionDirectoryExplorer")
-        
-        self.actionPreferences = self.createAction("&Preferences",  self.togglePreferencesWindow,  "Alt+P",  "configure.png",  "Lockenwickler Preferences",  False)
-        self.actionPreferences.setObjectName("actionPreferences")
-
-        self.actionProperty_Window = self.createAction("Pr&operty Window",  self.togglePropertyWindow,  "Alt+P",  "unsortedlist1.png",  "Property Window")
-        self.actionProperty_Window.setObjectName("actionProperty_Window")
-
-        self.actionObject_Selection = self.createAction("&Model Preview Window",  self.toggleModelPreviewWindow,  "Alt+O",  "tux.png",  "Model Preview")
-        self.actionObject_Selection.setObjectName("actionObject_Selection")
-        
-        self.actionMaterial_Selection = self.createAction("Material &Preview Window",  self.toggleMaterialPreviewWindow,  "Alt+M",  "colors.png",  "Material Preview")
-        self.actionMaterial_Selection.setObjectName("actionMaterial_Selection")
-
-        self.actionGameObjectClass_Selection = self.createAction("&Game Object Class Preview Window",  self.toggleGameObjectViewWindow,  "Ctrl+G",  "multirow.png",  "GameObjectClass Preview")
-        self.actionGameObjectClass_Selection.setObjectName("actionObject_Selection")
-
-        self.actionConsole_Window = self.createAction("&Console Window",  self.toggleConsoleWindow,  "Alt+C",  "console.png",  "Console Window")
-        self.actionConsole_Window.setObjectName("actionConsole_Window")
-        
-        self.actionToggleViewportGrid = self.createAction("&Toggle Grid",  self.toggleViewportGrid,  "Alt+G",  "console.png",  "Toggle Viewport Grid")
-        self.actionToggleViewportGrid.setObjectName("actionToggleViewportGrid")
-
-#####################################
-#####################################
-
-
-        self.menuFile.addAction(self.actionNeu)
-        self.menuFile.addAction(self.actionOpen)
-        self.menuFile.addAction(self.actionSave)
-        self.menuFile.addAction(self.actionRunModule)
-        self.menuFile.addAction(self.actionClose)
-
-        self.menuEdit.addAction(self.actionSelect)
-        self.menuEdit.addAction(self.actionMove)
-        self.menuEdit.addAction(self.actionRotate)
-        self.menuEdit.addAction(self.actionScale)
-        self.menuEdit.addSeparator()
-        self.menuEdit.addAction(self.actionDelete)
-        self.menuEdit.addAction(self.actionCopy)
-        self.menuEdit.addAction(self.actionCut)
-        self.menuEdit.addAction(self.actionPaste)
-        self.menuEdit.addSeparator()
-        self.menuEdit.addAction(self.actionOneClickEntityPlacement)
-        
-
-        self.menuView.addAction(self.actionSceneExplorer)
-        self.menuView.addAction(self.actionModuleDirView)
-        self.menuView.addAction(self.actionPreferences)
-        self.menuView.addAction(self.actionProperty_Window)
-        self.menuView.addAction(self.actionObject_Selection)
-        self.menuView.addAction(self.actionMaterial_Selection)
-        self.menuView.addAction(self.actionGameObjectClass_Selection)
-        self.menuView.addAction(self.actionConsole_Window)
-        self.menuView.addAction(self.actionToggleViewportGrid)
-        
-        self.menubar.addAction(self.menuFile.menuAction())
-        self.menubar.addAction(self.menuEdit.menuAction())
-        self.menubar.addAction(self.menuView.menuAction())
-
-        self.retranslateUi()
-        QtCore.QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuEdit.setTitle(QtGui.QApplication.translate("MainWindow", "Edit", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "New Module", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionMove.setText(QtGui.QApplication.translate("MainWindow", "Move", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionRotate.setText(QtGui.QApplication.translate("MainWindow", "Rotate", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionSceneExplorer.setText(QtGui.QApplication.translate("MainWindow", "Module Explorer", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionClose.setText(QtGui.QApplication.translate("MainWindow", "Quit", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionConsole_Window.setText(QtGui.QApplication.translate("MainWindow", "Console Window", None, QtGui.QApplication.UnicodeUTF8))
-
-    def setupOgre(self, pluginCfgPath="./Plugins.cfg", ogreCfgPath="./ogre.cfg", logPath="./ogre.log"):
-        if platform.system() == "Windows":
-            pluginCfgPath="./Plugins-windows.cfg"
-        else:
-            pluginCfgPath="./Plugins-linux.cfg"
-
-        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
-        self.ogreRoot = root
-
-        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
-            sys.exit('Quit from Config Dialog')
-
-        root.initialise(False)
-
-        self.pivotRenderQueueListener = PivotRenderQueueListener()
-        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, "OgreMainWinSceneMgr")
-        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
-        self.OgreMainWinSceneMgr.addRenderQueueListener(self.pivotRenderQueueListener)
-        
-        self.moduleName = ""
-        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
-        self.gocManager = self.moduleManager.gocManager
-        
-        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
-        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
-        self.hboxlayout.addLayout(self.gridlayout)
-        self.setCentralWidget(self.centralwidget)
-        
-        oglog = og.LogManager.getSingleton().getDefaultLog()
-        oglog.addListener(self.consoleWindow.lockenLog)
-
-    def finishEditorSetup(self):
-        if not self.editorSetupFinished:
-            og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
-            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-            self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
-            self.moduleManager.pivot.hide()
-            self.editorSetupFinished = True
-        
-    def update(self):
-        self.ogreRoot.renderOneFrame()
-        if platform.system() == "Linux":
-            self.ogreMainWindow.updateRenderWindow()
-            self.modelSelectionDialog.updateRenderWindow()
-            self.materialSelectionDialog.updateRenderWindow()
-
-    def actionOpenSlot(self):
-        self.finishEditorSetup()
-        self.moduleManager.openLoadModuleDialog()
-
-    def actionNewSlot(self):
-        newModuleWiz = NewModuleWizard(self.moduleManager, self)
-        newModuleWiz.exec_()
-        return
-        
-    def actionSaveSlot(self):
-        self.moduleManager.save()
-        
-    def actionRunModuleSlot(self):
-        self.moduleManager.save()
-        if platform.system() == "Windows":
-            workingDir = self.prefDialog.moduleCfgPath.replace("/modules/modules.cfg", "")
-            executable = os.path.join(workingDir, "Rastullah.exe")
-            executable = executable.replace("/",  "\\")
-            if os.path.isfile(executable):
-                subprocess.Popen([executable, "--module", self.moduleManager.mainModule.name], 0, None, None, None, None, None, False, False, workingDir)
-
-        
-    def actionQuitSlot(self):
-        self.close()
-
-    def actionDeleteSlot(self):
-        self.moduleManager.deleteObjects()
-
-    def actionCopySlot(self):
-        self.moduleManager.copyObjects()
-
-    def actionCutSlot(self):
-        self.moduleManager.cutObjects()
-
-    def actionPasteSlot(self):
-        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
-
-    def actionSelectSlot(self):
-        self.moduleManager.pivot.hide()
-
-    def actionMoveSlot(self):
-        self.moduleManager.pivot.setMoveMode()
-
-    def actionRotateSlot(self):
-        self.moduleManager.pivot.setRotateMode()
-
-    def actionScaleSlot(self):
-        self.moduleManager.pivot.setScaleMode()
-
-    def actionOneClickEntityPlacementSlot(self):
-        self.moduleManager.setOneClickEntityPlacement(self.actionOneClickEntityPlacement.isChecked())
-
-    def togglePreferencesWindow(self):
-        if self.prefDialog.isHidden():
-            self.prefDialog.show()
-        else:
-            self.prefDialog.hide()
-
-    def toggleModelPreviewWindow(self):
-        if self.modelSelectionDock.isHidden():
-            self.modelSelectionDock.show()
-        else:
-            self.modelSelectionDock.hide()
-    
-    def toggleMaterialPreviewWindow(self):
-        if self.materialSelectionDock.isHidden():
-            self.materialSelectionDock.show()
-        else:
-            self.materialSelectionDock.hide()
-
-    def toggleGameObjectViewWindow(self):
-        if self.gameObjectClassViewDock.isHidden():
-            self.gameObjectClassViewDock.show()
-        else:
-            self.gameObjectClassViewDock.hide()
-
-    def toggleModuleExplorer(self):
-        if self.moduleExplorerDock.isHidden():
-            self.moduleExplorerDock.show()
-        else:
-            self.moduleExplorerDock.hide()
-            
-    def toggleModuleDirView(self):
-        if self.moduleDirectoryViewDock.isHidden():
-            self.moduleDirectoryViewDock.show()
-        else:
-            self.moduleDirectoryViewDock.hide()
-
-    def togglePropertyWindow(self):
-        if self.propertyDock.isHidden():
-            self.propertyDock.show()
-        else:
-            self.propertyDock.hide()
-
-    def toggleConsoleWindow(self):
-        if self.consoleDock.isHidden():
-            self.consoleDock.show()
-        else:
-            self.consoleDock.hide()
-
-    def toggleViewportGrid(self):
-        self.ogreMainWindow.toggleViewportGrid()
-
-    def createDockWindows(self):
-        self.modelSelectionDock = QtGui.QDockWidget(self.tr("Models"), self)
-        self.modelSelectionDock.setObjectName("ModelSelectionDockWindow")
-        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
-        
-        self.materialSelectionDock = QtGui.QDockWidget(self.tr("Materials"), self)
-        self.materialSelectionDock.setObjectName("MaterialSelectionDockWindow")
-        self.materialSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.materialSelectionDock.setWidget(self.materialSelectionDialog)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.materialSelectionDock)
-        self.tabifyDockWidget(self.modelSelectionDock, self.materialSelectionDock)
-        
-        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr("GameObjectClasses"), self)
-        self.gameObjectClassViewDock.setObjectName("GameObjectClassView")
-        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)        
-        self.tabifyDockWidget(self.modelSelectionDock, self.gameObjectClassViewDock)
-        
-        self.propertyDock = QtGui.QDockWidget(self.tr("Properties"), self)
-        self.propertyDock.setObjectName("PropertyDockWindow")
-        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.propertyDock.setWidget(self.objectPropertyWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
-
-        self.moduleExplorerDock = QtGui.QDockWidget(self.tr("Module Explorer"), self)
-        self.moduleExplorerDock.setObjectName("ModuleExplorerDockWindow")
-        self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
-        self.tabifyDockWidget(self.moduleExplorerDock, self.propertyDock)
-        
-        self.moduleDirectoryViewDock = QtGui.QDockWidget(self.tr("Module Directory View"), self)
-        self.moduleDirectoryViewDock.setObjectName("ModuleDirectoryViewDockWindow")
-        self.moduleDirectoryViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.moduleDirectoryViewDock.setWidget(self.moduleDirectoryViewWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleDirectoryViewDock)
-        
-        self.consoleDock = QtGui.QDockWidget(self.tr("Console"), self)
-        self.consoleDock.setObjectName("ConsoleDockWindow")
-        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
-        self.consoleDock.setWidget(self.consoleWindow)
-        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
-
-        self.fileToolBar = self.addToolBar("File Toolbar")
-        self.fileToolBar.setObjectName("FileToolBar")
-        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.fileToolBar.addAction(self.actionNeu)
-        self.fileToolBar.addAction(self.actionOpen)
-        self.fileToolBar.addAction(self.actionSave)
-        self.fileToolBar.addAction(self.actionRunModule)
-        self.fileToolBar.addAction(self.actionClose)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
-
-        self.moveToolBar = self.addToolBar("Transformation Bar")
-        self.moveToolBar.setObjectName("TransformationBar")
-        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.moveToolBar.addAction(self.actionSelect)
-        self.moveToolBar.addAction(self.actionMove)
-        self.moveToolBar.addAction(self.actionRotate)
-        self.moveToolBar.addAction(self.actionScale)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
-
-    def keyPressEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreMainWindow.keyPressEvent(event)
-
-    def keyReleaseEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreMainWindow.keyReleaseEvent(event)
-        pass
-
-    def onContextMenuCallback(self, actions, menus):
-        menu = QMenu("My Menu!!")
-        menu.addAction(self.actionDelete)
-        menu.addAction(self.actionCopy)
-        menu.addAction(self.actionCut)
-        menu.addAction(self.actionPaste)
-        menu.addSeparator()
-        
-        for m in menus:
-            menu.addMenu(m)
-        for a in actions:
-            menu.addAction(a)
-
-        menu.exec_(QCursor.pos())
-
-    def connectActionButtons(self):
-        pass
-
-    def saveOnClose(self):
-#        reply = QtGui.QMessageBox.question(self,  "Rastullahs Lockenwickler - Unsaved Chages",  "Save unsaved changes?",  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
-#        if reply == QtGui.QMessageBox.Cancel:
-#            return False
-#        if reply == QtGui.QMessageBox.Yes:
-#            print""
-#            #TODO: implement save here
-        return True
-
-    def closeEvent(self,  event):
-        if self.saveOnClose():
-            settings = QtCore.QSettings()
-            settings.setValue("Preferences/moduleCfgPath", QtCore.QVariant(self.prefDialog.lineEdit.text()))
-            settings.setValue("MainWindow/Geometry",  QtCore.QVariant(self.saveGeometry()))
-            settings.setValue("MainWIndow/DockWindows",  QtCore.QVariant(self.saveState()))
-            
-            #self.ogreRoot.shutdown()
-        else:
-            event.ignore()
-
-if __name__ == "__main__":
-#    # Import Psyco if available
-#    try:
-#        import psyco
-#        psyco.full(0.02)
-#        #psyco.log()
-#        #psyco.profile()
-#    except ImportError:
-#        pass
-    
-    app = QtGui.QApplication(sys.argv)
-    app.setOrganizationName("Team Pantheon")
-    app.setOrganizationDomain("rastullahs-lockenpracht.de/team")
-    app.setApplicationName("Lockenwickler")
-
-    form = Lockenwickler()
-    form.show()
-
-    app.exec_()
-    
-    sys.exit(0)
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import os
+import sys
+import platform
+import subprocess
+
+sys.path.insert(0,'..')
+import PythonOgreConfig
+
+from random import randint
+
+from PyQt4 import QtGui, QtCore
+from PreferencesDialog import *
+from ObjectPropertyWin import *
+from ModelSelectionDialog import *
+from MaterialSelectionDialog import *
+from GameObjectClassView import *
+from ConsoleWindow import *
+from ModuleManager import ModuleManager
+from ModuleExplorer import *
+from NewModuleWizard import *
+from MovePivot import *
+from PivotRenderQueueListener import *
+from ModuleDirectoryView import *
+
+import OgreMainWindow
+import ogre.renderer.OGRE as og
+
+class Lockenwickler(QtGui.QMainWindow):
+    def __init__(self, parent=None):
+        QtGui.QWidget.__init__(self, parent)
+
+#        pixmap = QPixmap("media/icons/lockenwickler_provisorium.png")
+#        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
+#        splash.setMask(pixmap.mask())
+#        splash.showMessage("Starting...")
+#        splash.show() 
+
+        self.setupUi()
+
+        self.consoleWindow = ConsoleWindow(False,  self)
+
+        self.setupOgre()
+
+        self.prefDialog = PreferencesDialog(self)
+        self.objectPropertyWin = ObjectPropertyWin(self.OgreMainWinSceneMgr, self.gocManager, self)
+        self.moduleExplorerWin = ModuleExplorer(self)
+        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        self.materialSelectionDialog = MaterialSelectionDialog(self.ogreRoot, self)
+        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
+        self.moduleManager.materialSelectionDialog = self.materialSelectionDialog
+        self.moduleDirectoryViewWin = ModuleDirectoryView(self)
+        
+        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
+
+        self.createDockWindows()
+
+        self.mainTimer = QtCore.QTimer(self)
+        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL("timeout()"), self.update)
+        self.mainTimer.start(5)
+
+        settings = QtCore.QSettings()
+        self.restoreGeometry(settings.value("MainWindow/Geometry").toByteArray())
+        self.restoreState(settings.value("MainWindow/DockWindows").toByteArray())
+        if not self.prefDialog.setCfgPath(settings.value("Preferences/moduleCfgPath").toString()):
+            self.prefDialog.show()
+            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        else:
+            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        
+        self.moduleDirectoryViewWin.modulesPath = self.prefDialog.moduleCfgPath.replace("modules.cfg", "")
+        
+        self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
+        self.moduleManager.setModuleDirView(self.moduleDirectoryViewWin)
+        self.moduleManager.setPropertyWindow(self.objectPropertyWin)
+        self.moduleManager.setContextMenuCallback(self.onContextMenuCallback)
+        
+        self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
+        self.setWindowTitle("Rastullahs Lockenwickler")
+        
+        self.editorSetupFinished = False
+        
+#        splash.finish(self)
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QtGui.QAction(text, self)
+        if icon is not None:
+            action.setIcon(QtGui.QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            self.connect(action, QtCore.SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+
+    def addActions(self, target, actions):
+        for act in actions:
+            if act is None:
+               target.addSeparator()
+            else:
+                target.addAction(act)
+
+    def setupUi(self):
+        self.setObjectName("MainWindow")
+
+        self.centralwidget = QtGui.QWidget(self)
+        self.centralwidget.setObjectName("centralwidget")
+
+        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
+        self.hboxlayout.setContentsMargins(0, 0, 0, 0)
+        self.hboxlayout.setObjectName("hboxlayout")
+
+        self.gridlayout = QtGui.QGridLayout()
+        self.gridlayout.setObjectName("gridlayout")
+        self.gridlayout.setContentsMargins(0, 0, 0, 0)
+        
+        self.menubar = QtGui.QMenuBar(self)
+        self.menubar.setObjectName("menubar")
+
+        self.menuFile = QtGui.QMenu(self.menubar)
+        self.menuFile.setObjectName("menuFile")
+
+        self.menuEdit = QtGui.QMenu(self.menubar)
+        self.menuEdit.setObjectName("menuEdit")
+
+        self.menuView = QtGui.QMenu(self.menubar)
+        self.menuView.setObjectName("menuView")
+        self.setMenuBar(self.menubar)
+
+
+        self.statusbar = QtGui.QStatusBar(self)
+        self.statusbar.setObjectName("statusbar")
+        self.setStatusBar(self.statusbar)
+
+#####################################
+        self.actionNeu =self.createAction("&New Module",  self.actionNewSlot,  QKeySequence.New,  "filenew.png",  "New Module")
+        self.actionNeu.setObjectName("actionNeu")
+
+        self.actionOpen = self.createAction("&Open Module",  self.actionOpenSlot,  QKeySequence.Open,  "fileopen.png",  "Open Module")
+        self.actionOpen.setObjectName("actionOpen")
+        
+        self.actionSave = self.createAction("&Save",  self.actionSaveSlot,  QKeySequence.Save,  "filesave.png",  "Save Module")
+        self.actionSave.setObjectName("actionSave")
+        
+        self.actionRunModule = self.createAction("&Save and Run",  self.actionRunModuleSlot,  "Alt+R",  "fileexport.png",  "Save And Run Module")
+        self.actionRunModule.setObjectName("actionRunModule")
+
+        self.actionClose = self.createAction("Quit",  self.actionQuitSlot,  "Alt+Q",  "exit.png",  "Quit")
+        self.actionClose.setObjectName("actionQuit")
+#####################################
+
+
+#####################################
+        self.actionDelete = self.createAction("Delete",  self.actionDeleteSlot,  QKeySequence.Delete,  "editdelete.png",  "Delete")
+        self.actionDelete.setObjectName("actionDelete")
+
+        self.actionCopy = self.createAction("Copy",  self.actionCopySlot,  QKeySequence.Copy,  "editcopy.png",  "Copy")
+        self.actionCopy.setObjectName("actionCopy")
+
+        self.actionCut = self.createAction("Cut",  self.actionCutSlot,  QKeySequence.Cut,  "editcut.png",  "Cut")
+        self.actionCut.setObjectName("actionCut")
+
+        self.actionPaste = self.createAction("Paste",  self.actionPasteSlot,  QKeySequence.Paste,  "editpaste.png",  "Paste")
+        self.actionPaste.setObjectName("actionPaste")
+
+        self.actionSelect = self.createAction("&Select",  self.actionSelectSlot,  "Space",  "cursor.png",  "Move selected object")
+        self.actionSelect.setObjectName("actionSelect")
+
+        self.actionMove = self.createAction("&Move",  self.actionMoveSlot,  "g",  "move.png",  "Move selected object")
+        self.actionMove.setObjectName("actionMove")
+
+        self.actionRotate = self.createAction("&Rotate",  self.actionRotateSlot,  "r",  "rotate.png",  "Rotate selected object")
+        self.actionRotate.setObjectName("actionRotate")
+
+        self.actionScale = self.createAction("&Scale",  self.actionScaleSlot,  "x",  "resizecol.png",  "Scale selected object")
+        self.actionScale.setObjectName("actionScale")
+
+        self.actionOneClickEntityPlacement = self.createAction("&OneClickEntityPlacement",  self.actionOneClickEntityPlacementSlot,  "",  "resizecol.png",  "Add an Entity just by a click")
+        self.actionOneClickEntityPlacement.setObjectName("actionOneClickEntityPlacement")
+        self.actionOneClickEntityPlacement.setCheckable(True)
+
+#####################################
+#####################################
+        self.actionSceneExplorer = self.createAction("&Scene Exlporer",  self.toggleModuleExplorer,  "Alt+E",  "view_tree.png",  "Module Explorer",  False)
+        self.actionSceneExplorer.setObjectName("actionSceneExplorer")
+        
+        self.actionModuleDirView = self.createAction("&Directory Explorer",  self.toggleModuleDirView,  "Alt+D",  "view_tree.png",  "Module Directory Explorer",  False)
+        self.actionModuleDirView.setObjectName("actionDirectoryExplorer")
+        
+        self.actionPreferences = self.createAction("&Preferences",  self.togglePreferencesWindow,  "Alt+P",  "configure.png",  "Lockenwickler Preferences",  False)
+        self.actionPreferences.setObjectName("actionPreferences")
+
+        self.actionProperty_Window = self.createAction("Pr&operty Window",  self.togglePropertyWindow,  "Alt+P",  "unsortedlist1.png",  "Property Window")
+        self.actionProperty_Window.setObjectName("actionProperty_Window")
+
+        self.actionObject_Selection = self.createAction("&Model Preview Window",  self.toggleModelPreviewWindow,  "Alt+O",  "tux.png",  "Model Preview")
+        self.actionObject_Selection.setObjectName("actionObject_Selection")
+        
+        self.actionMaterial_Selection = self.createAction("Material &Preview Window",  self.toggleMaterialPreviewWindow,  "Alt+M",  "colors.png",  "Material Preview")
+        self.actionMaterial_Selection.setObjectName("actionMaterial_Selection")
+
+        self.actionGameObjectClass_Selection = self.createAction("&Game Object Class Preview Window",  self.toggleGameObjectViewWindow,  "Ctrl+G",  "multirow.png",  "GameObjectClass Preview")
+        self.actionGameObjectClass_Selection.setObjectName("actionObject_Selection")
+
+        self.actionConsole_Window = self.createAction("&Console Window",  self.toggleConsoleWindow,  "Alt+C",  "console.png",  "Console Window")
+        self.actionConsole_Window.setObjectName("actionConsole_Window")
+        
+        self.actionToggleViewportGrid = self.createAction("&Toggle Grid",  self.toggleViewportGrid,  "Alt+G",  "console.png",  "Toggle Viewport Grid")
+        self.actionToggleViewportGrid.setObjectName("actionToggleViewportGrid")
+
+#####################################
+#####################################
+
+
+        self.menuFile.addAction(self.actionNeu)
+        self.menuFile.addAction(self.actionOpen)
+        self.menuFile.addAction(self.actionSave)
+        self.menuFile.addAction(self.actionRunModule)
+        self.menuFile.addAction(self.actionClose)
+
+        self.menuEdit.addAction(self.actionSelect)
+        self.menuEdit.addAction(self.actionMove)
+        self.menuEdit.addAction(self.actionRotate)
+        self.menuEdit.addAction(self.actionScale)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionDelete)
+        self.menuEdit.addAction(self.actionCopy)
+        self.menuEdit.addAction(self.actionCut)
+        self.menuEdit.addAction(self.actionPaste)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionOneClickEntityPlacement)
+        
+
+        self.menuView.addAction(self.actionSceneExplorer)
+        self.menuView.addAction(self.actionModuleDirView)
+        self.menuView.addAction(self.actionPreferences)
+        self.menuView.addAction(self.actionProperty_Window)
+        self.menuView.addAction(self.actionObject_Selection)
+        self.menuView.addAction(self.actionMaterial_Selection)
+        self.menuView.addAction(self.actionGameObjectClass_Selection)
+        self.menuView.addAction(self.actionConsole_Window)
+        self.menuView.addAction(self.actionToggleViewportGrid)
+        
+        self.menubar.addAction(self.menuFile.menuAction())
+        self.menubar.addAction(self.menuEdit.menuAction())
+        self.menubar.addAction(self.menuView.menuAction())
+
+        self.retranslateUi()
+        QtCore.QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuEdit.setTitle(QtGui.QApplication.translate("MainWindow", "Edit", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "New Module", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionMove.setText(QtGui.QApplication.translate("MainWindow", "Move", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionRotate.setText(QtGui.QApplication.translate("MainWindow", "Rotate", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionSceneExplorer.setText(QtGui.QApplication.translate("MainWindow", "Module Explorer", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionClose.setText(QtGui.QApplication.translate("MainWindow", "Quit", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionConsole_Window.setText(QtGui.QApplication.translate("MainWindow", "Console Window", None, QtGui.QApplication.UnicodeUTF8))
+
+    def setupOgre(self, pluginCfgPath="./Plugins.cfg", ogreCfgPath="./ogre.cfg", logPath="./ogre.log"):
+        if platform.system() == "Windows":
+            pluginCfgPath="./Plugins-windows.cfg"
+        else:
+            pluginCfgPath="./Plugins-linux.cfg"
+
+        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
+        self.ogreRoot = root
+
+        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
+            sys.exit('Quit from Config Dialog')
+
+        root.initialise(False)
+
+        self.pivotRenderQueueListener = PivotRenderQueueListener()
+        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, "OgreMainWinSceneMgr")
+        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
+        self.OgreMainWinSceneMgr.addRenderQueueListener(self.pivotRenderQueueListener)
+        
+        self.moduleName = ""
+        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
+        self.gocManager = self.moduleManager.gocManager
+        
+        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
+        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
+        self.hboxlayout.addLayout(self.gridlayout)
+        self.setCentralWidget(self.centralwidget)
+        
+        oglog = og.LogManager.getSingleton().getDefaultLog()
+        oglog.addListener(self.consoleWindow.lockenLog)
+
+    def finishEditorSetup(self):
+        if not self.editorSetupFinished:
+            og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+            self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
+            self.moduleManager.pivot.hide()
+            self.editorSetupFinished = True
+        
+    def update(self):
+        self.ogreRoot.renderOneFrame()
+        if platform.system() == "Linux":
+            self.ogreMainWindow.updateRenderWindow()
+            self.modelSelectionDialog.updateRenderWindow()
+            self.materialSelectionDialog.updateRenderWindow()
+
+    def actionOpenSlot(self):
+        self.finishEditorSetup()
+        self.moduleManager.openLoadModuleDialog()
+
+    def actionNewSlot(self):
+        newModuleWiz = NewModuleWizard(self.moduleManager, self)
+        newModuleWiz.exec_()
+        return
+        
+    def actionSaveSlot(self):
+        self.moduleManager.save()
+        
+    def actionRunModuleSlot(self):
+        self.moduleManager.save()
+        if platform.system() == "Windows":
+            workingDir = self.prefDialog.moduleCfgPath.replace("/modules/modules.cfg", "")
+            executable = os.path.join(workingDir, "Rastullah.exe")
+            executable = executable.replace("/",  "\\")
+            if os.path.isfile(executable):
+                subprocess.Popen([executable, "--module", self.moduleManager.mainModule.name], 0, None, None, None, None, None, False, False, workingDir)
+
+        
+    def actionQuitSlot(self):
+        self.close()
+
+    def actionDeleteSlot(self):
+        self.moduleManager.deleteObjects()
+
+    def actionCopySlot(self):
+        self.moduleManager.copyObjects()
+
+    def actionCutSlot(self):
+        self.moduleManager.cutObjects()
+
+    def actionPasteSlot(self):
+        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
+
+    def actionSelectSlot(self):
+        self.moduleManager.pivot.hide()
+
+    def actionMoveSlot(self):
+        self.moduleManager.pivot.setMoveMode()
+
+    def actionRotateSlot(self):
+        self.moduleManager.pivot.setRotateMode()
+
+    def actionScaleSlot(self):
+        self.moduleManager.pivot.setScaleMode()
+
+    def actionOneClickEntityPlacementSlot(self):
+        self.moduleManager.setOneClickEntityPlacement(self.actionOneClickEntityPlacement.isChecked())
+
+    def togglePreferencesWindow(self):
+        if self.prefDialog.isHidden():
+            self.prefDialog.show()
+        else:
+            self.prefDialog.hide()
+
+    def toggleModelPreviewWindow(self):
+        if self.modelSelectionDock.isHidden():
+            self.modelSelectionDock.show()
+        else:
+            self.modelSelectionDock.hide()
+    
+    def toggleMaterialPreviewWindow(self):
+        if self.materialSelectionDock.isHidden():
+            self.materialSelectionDock.show()
+        else:
+            self.materialSelectionDock.hide()
+
+    def toggleGameObjectViewWindow(self):
+        if self.gameObjectClassViewDock.isHidden():
+            self.gameObjectClassViewDock.show()
+        else:
+            self.gameObjectClassViewDock.hide()
+
+    def toggleModuleExplorer(self):
+        if self.moduleExplorerDock.isHidden():
+            self.moduleExplorerDock.show()
+        else:
+            self.moduleExplorerDock.hide()
+            
+    def toggleModuleDirView(self):
+        if self.moduleDirectoryViewDock.isHidden():
+            self.moduleDirectoryViewDock.show()
+        else:
+            self.moduleDirectoryViewDock.hide()
+
+    def togglePropertyWindow(self):
+        if self.propertyDock.isHidden():
+            self.propertyDock.show()
+        else:
+            self.propertyDock.hide()
+
+    def toggleConsoleWindow(self):
+        if self.consoleDock.isHidden():
+            self.consoleDock.show()
+        else:
+            self.consoleDock.hide()
+
+    def toggleViewportGrid(self):
+        self.ogreMainWindow.toggleViewportGrid()
+
+    def createDockWindows(self):
+        self.modelSelectionDock = QtGui.QDockWidget(self.tr("Models"), self)
+        self.modelSelectionDock.setObjectName("ModelSelectionDockWindow")
+        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
+        
+        self.materialSelectionDock = QtGui.QDockWidget(self.tr("Materials"), self)
+        self.materialSelectionDock.setObjectName("MaterialSelectionDockWindow")
+        self.materialSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.materialSelectionDock.setWidget(self.materialSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.materialSelectionDock)
+        self.tabifyDockWidget(self.modelSelectionDock, self.materialSelectionDock)
+        
+        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr("GameObjectClasses"), self)
+        self.gameObjectClassViewDock.setObjectName("GameObjectClassView")
+        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)        
+        self.tabifyDockWidget(self.modelSelectionDock, self.gameObjectClassViewDock)
+        
+        self.propertyDock = QtGui.QDockWidget(self.tr("Properties"), self)
+        self.propertyDock.setObjectName("PropertyDockWindow")
+        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.propertyDock.setWidget(self.objectPropertyWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
+
+        self.moduleExplorerDock = QtGui.QDockWidget(self.tr("Module Explorer"), self)
+        self.moduleExplorerDock.setObjectName("ModuleExplorerDockWindow")
+        self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
+        self.tabifyDockWidget(self.moduleExplorerDock, self.propertyDock)
+        
+        self.moduleDirectoryViewDock = QtGui.QDockWidget(self.tr("Module Directory View"), self)
+        self.moduleDirectoryViewDock.setObjectName("ModuleDirectoryViewDockWindow")
+        self.moduleDirectoryViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea | QtCore.Qt.TopDockWidgetArea | QtCore.Qt.BottomDockWidgetArea)
+        self.moduleDirectoryViewDock.setWidget(self.moduleDirectoryViewWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleDirectoryViewDock)
+        
+        self.consoleDock = QtGui.QDockWidget(self.tr("Console"), self)
+        self.consoleDock.setObjectName("ConsoleDockWindow")
+        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
+        self.consoleDock.setWidget(self.consoleWindow)
+        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
+
+        self.fileToolBar = self.addToolBar("File Toolbar")
+        self.fileToolBar.setObjectName("FileToolBar")
+        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.fileToolBar.addAction(self.actionNeu)
+        self.fileToolBar.addAction(self.actionOpen)
+        self.fileToolBar.addAction(self.actionSave)
+        self.fileToolBar.addAction(self.actionRunModule)
+        self.fileToolBar.addAction(self.actionClose)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
+
+        self.moveToolBar = self.addToolBar("Transformation Bar")
+        self.moveToolBar.setObjectName("TransformationBar")
+        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.moveToolBar.addAction(self.actionSelect)
+        self.moveToolBar.addAction(self.actionMove)
+        self.moveToolBar.addAction(self.actionRotate)
+        self.moveToolBar.addAction(self.actionScale)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
+
+    def keyPressEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreMainWindow.keyPressEvent(event)
+
+    def keyReleaseEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreMainWindow.keyReleaseEvent(event)
+        pass
+
+    def onContextMenuCallback(self, actions, menus):
+        menu = QMenu("My Menu!!")
+        menu.addAction(self.actionDelete)
+        menu.addAction(self.actionCopy)
+        menu.addAction(self.actionCut)
+        menu.addAction(self.actionPaste)
+        menu.addSeparator()
+        
+        for m in menus:
+            menu.addMenu(m)
+        for a in actions:
+            menu.addAction(a)
+
+        menu.exec_(QCursor.pos())
+
+    def connectActionButtons(self):
+        pass
+
+    def saveOnClose(self):
+#        reply = QtGui.QMessageBox.question(self,  "Rastullahs Lockenwickler - Unsaved Chages",  "Save unsaved changes?",  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
+#        if reply == QtGui.QMessageBox.Cancel:
+#            return False
+#        if reply == QtGui.QMessageBox.Yes:
+#            print""
+#            #TODO: implement save here
+        return True
+
+    def closeEvent(self,  event):
+        if self.saveOnClose():
+            settings = QtCore.QSettings()
+            settings.setValue("Preferences/moduleCfgPath", QtCore.QVariant(self.prefDialog.lineEdit.text()))
+            settings.setValue("MainWindow/Geometry",  QtCore.QVariant(self.saveGeometry()))
+            settings.setValue("MainWIndow/DockWindows",  QtCore.QVariant(self.saveState()))
+            
+            #self.ogreRoot.shutdown()
+        else:
+            event.ignore()
+
+if __name__ == "__main__":
+#    # Import Psyco if available
+#    try:
+#        import psyco
+#        psyco.full(0.02)
+#        #psyco.log()
+#        #psyco.profile()
+#    except ImportError:
+#        pass
+    
+    app = QtGui.QApplication(sys.argv)
+    app.setOrganizationName("Team Pantheon")
+    app.setOrganizationDomain("rastullahs-lockenpracht.de/team")
+    app.setApplicationName("Lockenwickler")
+
+    form = Lockenwickler()
+    form.show()
+
+    app.exec_()
+    
+    sys.exit(0)
+

Modified: rl/trunk/editors/Lockenwickler/src/ModuleDirectoryView.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleDirectoryView.py	2009-04-16 13:42:21 UTC (rev 4901)
+++ rl/trunk/editors/Lockenwickler/src/ModuleDirectoryView.py	2009-04-17 18:31:40 UTC (rev 4902)
@@ -1,43 +1,109 @@
- #################################################
-# This source file is part of Rastullahs Lockenwickler.
-# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
 import sys
-from PyQt4.QtCore import *
+import os
+import subprocess
+
+                
+from PyQt4.QtCore import *
 from PyQt4.QtGui import *
 
+from PreferencesDialog import *
 
-class ModuleDirectoryView(QWidget):        
-    def __init__(self, parent = None):
+class ModuleDirectoryView(QWidget):        
+    def __init__(self, parent = None):
         super(ModuleDirectoryView, self).__init__(parent)
-        
+        self.modulesPath = ""
+
         self.model = QDirModel()
-        self.model.setReadOnly(False)
-        
+
+        self.model.setFilter(QDir.Files | QDir.Dirs | QDir.System | QDir.NoDotAndDotDot | QDir.Drives)
+
         self.tree = QTreeView()
+        
+        self.tree.setContextMenuPolicy(Qt.CustomContextMenu)        
+        self.connect(self.tree, SIGNAL("customContextMenuRequested(const QPoint &)"), self.doMenu)
+        
         self.tree.setModel(self.model)
-        
         self.tree.setWindowTitle("Module Dir View")
-        layout = QVBoxLayout()
-        layout.setContentsMargins(0, 0, 0, 0)
-        layout.addWidget(self.tree)
-        self.setLayout(layout)
+        layout = QVBoxLayout()
+        layout.setContentsMargins(0, 0, 0, 0)
+        layout.addWidget(self.tree)
+        self.setLayout(layout)
         
-    def parseDirectory(self, dir):
-        self.tree.setRootIndex(self.model.index(dir));
-
+    def doMenu(self, point):
+        menu = QMenu(self)
+        #item = self.tree.itemAt(point)
+            
+        action= self.createAction("Delete", self.onDelete, None, "editdelete.png")
+        menu.addAction(action)
+        
+        menu.exec_(QCursor.pos())
+        #subprocess.Popen(PreferencesDialog.externalTextAppCmd)
+
+    def onDelete(self):
+        print "delete"
+        
+    def getFilters(self, dir, list):
+        for f in os.listdir(dir):
+            if f.startswith("."):
+                continue
+            list.append(f)
+            if os.path.isdir(os.path.join(dir, f)):
+                self.getFilters(os.path.join(dir, f), list)
+        
+    def parseDirectory(self, dirs):
+#        nameFilters = []
+#        for dir in dirs:
+#            self.getFilters(dir, nameFilters)
+
+        self.tree.setRootIndex(self.model.index(self.modulesPath))
+
+    
+
+        
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QAction(text, self)
+        if icon is not None:
+            action.setIcon(QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            self.connect(action, SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+        
+
+        
+        
+        
+        
+        
+        
+        
+        
+        
+        
+        

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-04-16 13:42:21 UTC (rev 4901)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-04-17 18:31:40 UTC (rev 4902)
@@ -1,1397 +1,1400 @@
- #################################################
-# This source file is part of Rastullahs Lockenwickler.
-# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
-
-import sys
-import codecs
-import glob
-import os
-from os.path import isfile,  join
-
-import xml.etree.cElementTree as xml
-
-import ctypes
-import ogre.renderer.OGRE as og
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from SelectionBuffer import *
-from DepthBuffer import *
-from MovePivot import *
-from GameObjectClassManager import *
-from MyRaySceneQueryListener import *
-from ZoneManager import ZoneManager
-
-
-# get the light out of a light node
-def extractLight(node):
-        i = 0
-        num = node.numAttachedObjects()
-        while i < node.numAttachedObjects():
-            c = node.getAttachedObject(i)
-            tp = str(type(c))
-            if tp == "<class 'ogre.renderer.OGRE._ogre_.Light'>":
-                return c
-            
-            i += 1
-
-# make the xml file more pretty
-def indent(elem, level=0):
-    i = "\n" + level*"  "
-    
-    if len(elem):
-        if not elem.text or not elem.text.strip():
-            elem.text = i + "  "
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-        for elem in elem:
-            indent(elem, level+1)
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-    else:
-        if level and (not elem.tail or not elem.tail.strip()):
-            elem.tail = i
-
-# creates unique names for new entities
-def createUniqueEntityName(sceneManager, name = None):
-    n = ""
-    if name is None:
-        n = "dropMesh" + str(ModuleManager.dropCount)
-    else:
-        n = name
-        
-    while sceneManager.hasEntity(n):
-        n = "dropMesh" + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-    return n
-        
-def printVector3(vec):
-    print str(vec.x) + ";" + str(vec.y) + ";" + str(vec.z)
-    
-class EntityCustomOptions(og.UserDefinedObject):
-    def __init__(self, receivesShadow = True, staticgeometrygroup = 0, physicsproxytype = "none", renderingdistance = "20000"):
-        og.UserDefinedObject.__init__(self)
-        self.receivesShadow = receivesShadow
-        self.staticgeometrygroup = staticgeometrygroup
-        self.physicsproxytype = physicsproxytype
-        self.renderingdistance = renderingdistance
-        self.materialName = "NotChanged"
-        
-        ModuleManager.entityCustomOptionsDict.append(self)
-        
-    def copy(self):
-            return EntityCustomOptions(self.receivesShadow, self.staticgeometrygroup, self.physicsproxytype, self.renderingdistance)
-        
-    def getType(self):
-            return "EntityCustomOptions"
-
-class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyMap = False):
-        self.pathToMapFile = pathToFile
-        
-        mapName = pathToFile.replace("\\", "/")
-        mapName = mapName.split("/")
-        mapName = mapName[len(mapName) - 1].split(".")
-        mapName = mapName[len(mapName) - 3]
-        self.mapName = mapName
-        self.mapFileName = self.mapName + ".rlmap.xml"
-        
-        self.sceneManager = sceneManager
-        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-        self.zoneManager = zoneManager
-        self.isHidden = False
-        
-        self.zoneList = []
-        
-        if not emptyMap:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-
-            if root.attrib["formatVersion"] == "0.4.0":
-                self.parseMapNodes(root.find("nodes"))
-                self.parseMapZones(root.find("zones"))
-            else:
-                print pathToFile + " has wrong format version. It needs to be 0.4.0"
-                return
-
-    def hide(self):
-        try:
-            self.sceneManager.getRootSceneNode().removeChild(self.mapNode)
-        except:
-            print "Error: map is already hidden!"
-            return
-        
-        self.isHidden = True
-        
-    def show(self):
-        try:
-            self.sceneManager.getRootSceneNode().addChild(self.mapNode)
-        except:
-            print "Error: map is already shown!"
-            return
-        
-        self.isHidden = False
-    
-    def parseMapZones(self, zonesElement):
-        self.zoneManager.parseZonesFromXml(zonesElement, self)
-    
-    def parseMapNodes(self, nodeElement):
-        nodes = nodeElement.getiterator("gameobject")
-        self.createGameObjects(nodes)
-        
-        nodes = nodeElement.getiterator("entity")
-        self.createEntites(nodes)
-
-        nodes = nodeElement.getiterator("light")
-        self.createLights(nodes)
-
-        nodes = nodeElement.getiterator("sound")
-        self.createSound(nodes)
-
-        nodes = nodeElement.getiterator("particlesystem")
-        self.createParticleSystems(nodes)
-
-    def createEntites(self, entityNodes):
-        for nodes in entityNodes:
-            entityName = nodes.attrib["name"]
-            
-            if entityName.startswith("dropMesh"):
-                num = int(entityName.replace("dropMesh",  ""))
-                if ModuleManager.dropCount < num:
-                    ModuleManager.dropCount = num
-                elif ModuleManager.dropCount < num:
-                    ModuleManager.dropCount = num + 1
-                    
-            meshFile = nodes.attrib["meshfile"]
-            
-            eco = EntityCustomOptions()
-            
-            try:
-                if nodes.attrib["receivesShadow"] == "False" or nodes.attrib["receivesShadow"] == "false":
-                    eco.receivesShadow = "False"
-            except:
-                pass
-            try:
-                eco.staticgeometrygroup = int(nodes.attrib["staticgeometrygroup"])
-            except:
-                pass
-            try:
-                eco.physicsproxy = nodes.attrib["physicsproxy"]
-            except:
-                pass
-            try:
-                eco.renderingdistance = float(nodes.attrib["renderingdistance"])
-            except:
-                pass
-            try:
-                eco.renderingdistance
-                nodes.attrib["materialName"]
-            except:
-                pass
-                
-            nodePosition = None
-            nodeScale = None
-            qw = qx = qy = qz = None
-
-            transformations = nodes.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    posx = float(t.attrib["x"])
-                    posy = float(t.attrib["y"])
-                    posz = float(t.attrib["z"])
-                    nodePosition = og.Vector3(posx, posy, posz)
-                elif t.tag == "rotation":
-                    qw = float(t.attrib["qw"])
-                    qx = float(t.attrib["qx"])
-                    qy = float(t.attrib["qy"])
-                    qz = float(t.attrib["qz"])
-                elif t.tag == "scale":
-                    scalex = float(t.attrib["x"])
-                    scaley = float(t.attrib["y"])
-                    scalez = float(t.attrib["z"])
-                    nodeScale = og.Vector3(scalex, scaley, scalez)
-
-            try:
-                e = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager,  entityName), meshFile)
-            except:
-                print "Warning: Meshfile " + meshFile + " could not be found."
-                return
-
-            e.setUserObject(eco)
-            n = self.mapNode.createChild("entity_" + entityName + "_node")
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            n.setOrientation(qw, qx, qy, qz)
-            n.setScale(nodeScale)
-
-    def createLights(self, lightNodes):
-        for l in lightNodes:
-            lightName = l.attrib["name"]
-            lightType = l.attrib["type"]
-            lightVisible = bool(l.attrib["visible"])
-            castShadows = bool(l.attrib["castShadows"])
-            lightPosition = None
-            lightDirection = None
-            colourDiffuse = None
-            colourSpecular = None
-            lightAttenuationRange = None
-            lightAttenuationConstant= None
-            lightAttenuationLinear = None
-            lightAttenuationQuadratic = None
-            spotlightinner = None
-            spotlightouter = None
-            falloff = None 
-                
-            transformations = l.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    lightPosition = og.Vector3(x, y, z)
-                elif t.tag == "colourDiffuse":
-                    r = float(t.attrib["r"])
-                    g = float(t.attrib["g"])
-                    b= float(t.attrib["b"])
-                    colourDiffuse = og.ColourValue(r, g, b)
-                elif t.tag == "colourSpecular":
-                    r = float(t.attrib["r"])
-                    g = float(t.attrib["g"])
-                    b= float(t.attrib["b"])
-                    colourSpecular = og.ColourValue(r, g, b)
-                elif t.tag == "lightAttenuation":
-                    lightAttenuationRange = float(t.attrib["range"])
-                    lightAttenuationConstant= float(t.attrib["constant"])
-                    lightAttenuationLinear = float(t.attrib["linear"])
-                    lightAttenuationQuadric  = float(t.attrib["quadratic"])
-                elif t.tag == "spotlightrange":
-                    spotlightinner = float(t.attrib["inner"])
-                    spotlightouter = float(t.attrib["outer"])
-                    falloff = float(t.attrib["falloff"])
-                    
-            light = self.sceneManager.createLight(lightName)
-            
-            if lightType == "point":
-                light.setType(og.Light.LT_POINT)            
-            elif lightType == "spot":
-                light.setType(og.Light.LT_SPOTLIGHT)
-            elif lightType == "directional":
-                light.setType(og.Light.LT_DIRECTIONAL)
-            
-            light.setVisible(lightVisible)
-            light.setCastShadows(castShadows)
-            if lightAttenuationRange is not None and lightAttenuationConstant is not None and lightAttenuationLinear is not None and lightAttenuationQuadric is not None:
-                light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadric)
-            if colourDiffuse:
-                light.setDiffuseColour(colourDiffuse)
-            if colourSpecular:
-                light.setSpecularColour(colourSpecular)
-            if spotlightinner and spotlightouter and spotlightouter: 
-                light.setSpotlightRange(spotlightinner, spotlightouter, falloff)
-            
-            e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
-            n = self.mapNode.createChild("light_" + lightName + "_node")
-            n.attachObject(light)
-            n.attachObject(e)
-            if lightPosition:
-                n.setPosition(lightPosition)
-            
-    def createSound(self, soundNodes):
-        #raise NotImplementedError
-        return
-
-    def createGameObjects(self, gameObjectNodes):
-        for g in gameObjectNodes:
-            classid = g.attrib["class"]
-            
-            id = int(g.attrib["id"])
-            if ModuleManager.dropCount < id:
-                ModuleManager.dropCount = id
-            elif ModuleManager.dropCount < id:
-                ModuleManager.dropCount = id + 1
-                
-            state = g.attrib["state"]
-            nodePosition = None
-            nodeRotation = None
-            properties = {}
-            
-            transformations = g.getiterator()
-            for t in transformations:
-                if t.tag == "position":
-                    x = float(t.attrib["x"])
-                    y = float(t.attrib["y"])
-                    z = float(t.attrib["z"])
-                    nodePosition = og.Vector3(x, y, z)
-                elif t.tag == "rotation":
-                    qw = float(t.attrib["qw"])
-                    qx = float(t.attrib["qx"])
-                    qy = float(t.attrib["qy"])
-                    qz = float(t.attrib["qz"])
-                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
-                elif t.tag == "property":
-                    name = t.attrib["name"]
-                    type = t.attrib["type"]
-                    data = t.attrib["data"]
-                    properties[name] = GameObjectRepresentation.PropertieRepresentation(name, type, data)
-
-            go = self.gocManager.getGameObjectWithClassId(classid)
-            if go is not None:
-                meshFile = go.getMeshFileName()
-                
-                ent = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-                dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
-                dropNode.attachObject(ent)
-
-                if nodePosition:
-                    dropNode.setPosition(nodePosition)
-                if nodeRotation:
-                    dropNode.setOrientation(nodeRotation)
-
-                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
-                self.gocManager.addGameObjectRepresentation(go)
-                go.inWorldId = id
-                go.state = state
-                go.propertieDict = properties
-                ent.setUserObject(go)
-
-
-    def createParticleSystems(self, particleNodes):
-        #raise NotImplementedError
-        return
-        
-    def save(self):
-        root = xml.Element("rastullahmap")
-        root.attrib["formatVersion"] = "0.4.0"
-        
-        nodesElem = xml.SubElement(root, "nodes")
-        
-        i = 0
-        while i < self.mapNode.numChildren():
-            n = self.mapNode.getChild(i)
-            if n.numAttachedObjects() > 0:
-                if n.name.startswith("entity_"):
-                    entElem = xml.SubElement(nodesElem, "entity")
-                    entElem.attrib["name"] = n.getAttachedObject(0).getName()
-                    entName = n.getAttachedObject(0).getName()
-                    #print "Saving Entity: " + n.getAttachedObject(0).getName()
-                    entElem.attrib["meshfile"] = n.getAttachedObject(0).getMesh().getName()
-   
-                    entElem.attrib["receivesShadow"] = str(n.getAttachedObject(0).getUserObject().receivesShadow).lower()
-                    entElem.attrib["staticgeometrygroup"] = str(n.getAttachedObject(0).getUserObject().staticgeometrygroup)
-                    entElem.attrib["physicsproxytype"] = str(n.getAttachedObject(0).getUserObject().physicsproxytype)
-                    entElem.attrib["renderingdistance"] = str(n.getAttachedObject(0).getUserObject().renderingdistance)
-                    
-                    posElem = xml.SubElement(entElem, "position")
-                    posElem.attrib["x"] = str(n.getPosition().x)
-                    posElem.attrib["y"] = str(n.getPosition().y)
-                    posElem.attrib["z"] = str(n.getPosition().z)
-                    
-                    rotElem = xml.SubElement(entElem, "rotation")
-                    rotElem.attrib["qw"] = str(n.getOrientation().w)
-                    rotElem.attrib["qx"] = str(n.getOrientation().x)
-                    rotElem.attrib["qy"] = str(n.getOrientation().y)
-                    rotElem.attrib["qz"] = str(n.getOrientation().z)
-                    
-                    scaleElem = xml.SubElement(entElem, "scale")
-                    scaleElem.attrib["x"] = str(n.getScale().x)
-                    scaleElem.attrib["y"] = str(n.getScale().y)
-                    scaleElem.attrib["z"] = str(n.getScale().z)
-                    
-                elif n.name.startswith("gameobject_"):
-                    goElem = xml.SubElement(nodesElem, "gameobject")
-                    mname = n.name
-                    #print "Saving GOID: " + str(n.getAttachedObject(0).getUserObject().inWorldId)
-                    goElem.attrib["class"] = str(n.getAttachedObject(0).getUserObject().gocName)
-                    goElem.attrib["state"] = str(n.getAttachedObject(0).getUserObject().state)
-                    goElem.attrib["id"] = str(n.getAttachedObject(0).getUserObject().inWorldId)
-                    
-                    posElem = xml.SubElement(goElem, "position")
-                    posElem.attrib["x"] = str(n.getPosition().x)
-                    posElem.attrib["y"] = str(n.getPosition().y)
-                    posElem.attrib["z"] = str(n.getPosition().z)
-                    
-                    rotElem = xml.SubElement(goElem, "rotation")
-                    rotElem.attrib["qw"] = str(n.getOrientation().w)
-                    rotElem.attrib["qx"] = str(n.getOrientation().x)
-                    rotElem.attrib["qy"] = str(n.getOrientation().y)
-                    rotElem.attrib["qz"] = str(n.getOrientation().z)
-                    
-                    dict = n.getAttachedObject(0).getUserObject().propertieDict
-                    for key in dict:
-                        prop = dict[key]
-                        rotElem = xml.SubElement(goElem, "property")
-                        rotElem.attrib["name"] = prop.name
-                        rotElem.attrib["type"] = prop.type
-                        rotElem.attrib["data"] = prop.data
-
-                    
-                elif n.name.startswith("light_"):
-                    light = extractLight(n)
-                    lightName = light.getName()
-                    #print "Saving Light: " + lightName
-                    lightType = light.getType()
-                    isVisible = "true"
-                    if not light.getVisible():
-                        isVisible = "false"
-                    
-                    castShadows = "false"
-                    if light.getCastShadows():
-                        castShadows = "true"
-                    
-                    if lightType == og.Light.LT_POINT:
-                        lightType = "point"
-                    elif lightType == og.Light.LT_SPOTLIGHT:
-                        lightType = "spot"
-                    elif lightType == og.Light.LT_DIRECTIONAL:
-                        lightType = "directional"
-                    
-                    
-                    lightElem = xml.SubElement(nodesElem, "light")
-                    lightElem.attrib["name"] = lightName
-                    lightElem.attrib["type"] = lightType
-                    lightElem.attrib["visible"] = isVisible
-                    lightElem.attrib["castShadows"] = castShadows
-                    
-                    if lightType == "point" or lightType == "spot":
-                        posElem = xml.SubElement(lightElem, "position")
-                        posElem.attrib["x"] = str(n.getPosition().x)
-                        posElem.attrib["y"] = str(n.getPosition().y)
-                        posElem.attrib["z"] = str(n.getPosition().z)
-                    
-                    colDiffuseElem = xml.SubElement(lightElem, "colourDiffuse")
-                    colDiffuseElem.attrib["r"] = str(light.getDiffuseColour().r)
-                    colDiffuseElem.attrib["g"] = str(light.getDiffuseColour().g)
-                    colDiffuseElem.attrib["b"] = str(light.getDiffuseColour().b)
-
-                    colSpecularElem = xml.SubElement(lightElem, "colourSpecular")
-                    colSpecularElem.attrib["r"] = str(light.getSpecularColour().r)
-                    colSpecularElem.attrib["g"] = str(light.getSpecularColour().g)
-                    colSpecularElem.attrib["b"] = str(light.getSpecularColour().b)
-                    
-                    lightAttenuationElem = xml.SubElement(lightElem, "lightAttenuation")
-                    lightAttenuationElem.attrib["range"] = str(light.getAttenuationRange())
-                    lightAttenuationElem.attrib["constant"] = str(light.getAttenuationConstant())
-                    lightAttenuationElem.attrib["linear"] = str(light.getAttenuationLinear())
-                    lightAttenuationElem.attrib["quadratic"] = str(light.getAttenuationQuadric())
-                    
-                    if lightType == "spot":
-                        spotligthRangeElem = xml.SubElement(lightElem, "spotlightrange")
-                        spotligthRangeElem.attrib["inner"] = str(light.getSpotlightInnerAngle().valueDegrees())
-                        spotligthRangeElem.attrib["outer"] = str(light.getSpotlightOuterAngle().valueDegrees())
-                        spotligthRangeElem.attrib["falloff"] = str(light.getSpotlightFalloff())
-                        
-                    if lightType == "spot" or lightType == "directional":
-                        directionElem = xml.SubElement(lightElem, "direction")
-                        dir = og.Vector3()
-                        n.getOrientation().ToAxes(dir)
-                        directionElem.attrib["x"] = str(dir.x)
-                        directionElem.attrib["y"] = str(dir.y)
-                        directionElem.attrib["z"] = str(dir.z)
-                        
-            i = i+1
-            
-        self.zoneManager.saveZonesToXml(root, self)
-        indent(root)
-        xml.ElementTree(root).write(self.pathToMapFile)
-
-# caused a linux crash
-#        iter = self.mapNode.getChildIterator()
-#        while iter.hasMoreElements():
-#            name = iter.getNext().getName()
-#            print name
-
-class Scene():
-    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyScene = False, sceneName = "NewScene"):
-        self.moduleRoot = moduleroot
-        self.pathToFile = pathToFile
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-        self.zoneManager = zoneManager
-        self.mapFiles = [] # a list in case the module has more than one map file
-        mappaths = []
-        self.name = sceneName
-
-        
-        if not emptyScene:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-            self.name = root.attrib["name"]
-        
-            maps = root.getiterator("map")
-            for m in maps:
-                mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
-                
-            for m in mappaths:
-                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
-            
-    def addMap(self, name):
-        path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
-        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True))
-        
-    def save(self):
-        root = xml.Element("scene")
-        root.attrib["name"] = self.name
-        
-        for m in self.mapFiles:
-            sub = xml.SubElement(root, "map")
-            sub.attrib["file"] = m.mapFileName
-            m.save()
-
-        indent(root)
-        xml.ElementTree(root).write(self.pathToFile)
-
-class Module():
-    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager, zoneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gameObjectManager
-        self.zoneManager = zoneManager
-        
-        self.name = name
-        self.moduleRoot = join(modulePath, name)
-        self.__isCommon = False
-
-        self.hasDependencies = False
-        self.moduleDependencies = []
-
-        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
-
-        self.gofFiles = [] # gof File list
-
-        self.scenes =[]
-
-        self.isLoaded = False
-        
-        self.playerStart = None
-        
-    def addScene(self, name):
-        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True, name))
-    
-    def addMapToScene(self, sceneName, mapName):
-        for scene in self.scenes:
-            if scene.name == sceneName:
-                scene.addMap(mapName)
-                return
-        
-        print "ERROR: could not find scene: " + sceneName
-        
-    
-    def isCommon(self):
-        if isfile(self.modConfig): # is the modconfig existing?
-            f = codecs.open(self.modConfig, 'r', 'utf-8')
-        else:
-            print ("Module.isCommon() Error: couldn't find module config")
-            return
-        isDependencieLine = False
-        for i, line in enumerate(f):
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith("super("):
-                split = lStripped.split(",")
-                if split[2].strip() == unicode("true"):
-                    self.__isCommon = True
-                    return True
-
-
-            elif isDependencieLine:
-                if lStripped == "end":
-                    isDependencieLine = False
-                else:
-                    self.hasDependencies = True
-                    pl = lStripped.split('"')
-                    i = 1
-                    while i < 100: 
-                        try:
-                            self.moduleDependencies.append(pl[i])
-                            i += 2
-                        except IndexError, e:
-                            break
-
-            elif lStripped == "def getDependencies()":
-                isDependencieLine = True
-
-        return False
-
-    def load(self):
-        if self.isLoaded:
-            return
-        
-        self.isLoaded = True
-        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
-        if isfile(self.modConfig): # is the modconfig existing?
-            f = codecs.open(self.modConfig, 'r', 'utf-8')
-        else:
-            print ("Module.load: Error: couldn't find module config")
-            return
-
-        for line in f:
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith("hero = $GOM.getGameObject("):
-                try:
-                    self.playerStart = int(line.split("(")[1].split(")")[0])
-                except ValueError, e:
-                    print self.modConfig + " ValueError: " + str(e)
-                    self.playerStart = None
-                    continue
-                    
-        self.setResourcePaths()
-        
-        try:
-            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-        except og.OgreException, e:
-            print e
-        
-        
-        cmd = join(self.moduleRoot, "dsa/*.gof")
-        self.gofFiles = glob.glob(cmd)
-        self.gocManager.parseGOFFiles(self.gofFiles)
-
-        if not self.isCommon():
-            cmd = join(self.moduleRoot, "maps/*.rlscene")
-            sceneFile = glob.glob(cmd)
-            self.loadScenes(sceneFile)
-                
-    def loadScenes(self, sceneFiles):
-        for s in sceneFiles:
-            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
-
-    def save(self):
-        for s in self.scenes:
-            s.save()
-            
-        self.saveModuleConfig()
-
-    def saveModuleConfig(self):
-        if self.playerStart is not None:
-            f = open(self.modConfig, "r")
-            
-            newconfig = ""
-            for line in f:
-                if line.startswith("       hero = $GOM.getGameObject("):
-                    newconfig += "       hero = $GOM.getGameObject(" + str(self.playerStart) + ");\n"
-                else:
-                    newconfig += line
-            f.close()
-            
-            f = open(self.modConfig, "w")
-            f.write(newconfig)
-            f.close()
-
-    def setResourcePaths(self, recurseFolder = ""):
-        if recurseFolder == "":
-            rootFolder = self.moduleRoot
-        else:
-            rootFolder = join(self.moduleRoot, recurseFolder)
-
-        for file in os.listdir(rootFolder):
-            curFile = join(rootFolder, file)
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            elif os.path.isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
-                self.setResourcePaths(curFile)
-            elif os.path.isfile(curFile):
-                continue
-                
-    def getMap(self, mapName, sceneName = None):
-        if sceneName is not None:
-            for s in self.scenes:
-                if s.name == sceneName:
-                    for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-        else:
-            for s in self.scenes:
-                for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-
-class ProgressBarThread(QThread):
-    def __init__(self, min, max, moduleName):
-        QThread.__init__(self)
-        self.progress = QProgressDialog("Loading " + moduleName, "Abort Loading", min, max, None);
-        self.progress.setWindowModality(Qt.WindowModal)
-
-    def setProgress(self, progress, labelText):
-        self.progress.setLabelText(labelText)
-        self.progress.setValue(progress)
-        
-    def run(self):
-        self.progress.show()
-        self.exec_()
-
-        
-class ModuleManager():
-    dropCount = 0
-    entityCustomOptionsDict = []
-    
-    def __init__(self,  ogreRoot,  sceneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.modelSelectionDialog = None
-        self.materialSelectionDialog = None
-
-        self.moduleCfgPath = ""
-
-        self.gocManager = GameObjectClassManager()
-        
-
-        self.mainModule = None
-        self.mainModuledependencieList =[]
-        self.moduleList = []
-        self.userSelectionList = []
-        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
-        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-        self.currentMap = None
-        self.moduleExplorer = None
-        self.moduleDirView = None
-
-        self.lastRay = None
-        self.rayLine = None
-
-        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
-        self.pivot = None
-        self.movingPivot = False
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.dropNode = None
-        self.dropEntity = None
-        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
-        self.dropMat = None
-        
-        self.moduleConfigIsParsed = False
-
-        self.selectionBuffer = None
-        self.depthBuffer = None
-        self.propertyWindow = None
-    
-        self.oneClickEntityPlacement = False
-        
-        self.onContextMenuCallback = None
-        self.contextMenuClickPosition = None
-        self.contextMenuRay = None
-        
-        self.playerStartGameObjectId = None
-        
-        self.entityCustomOptionsDict = []
-        
-        self.raySceneQueryListener = MyRaySceneQueryListener()
-        
-        self.zoneManager = ZoneManager(self.sceneManager)
-        
-    def resetParsedModuleConfig(self):
-        self.moduleConfigIsParsed = False
-        self.moduleList = []
-
-    def parseModuleConfig(self):
-        if self.moduleConfigIsParsed:
-            return
-
-        import codecs
-        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
-
-        for line in f:
-            if line.startswith('#'):
-                continue
-
-            if line.startswith('module='):
-                splines = line.split('=')
-                str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
-
-        self.moduleConfigIsParsed = True
-
-    def moduleExists(self, name):
-        lowerA = str(name).lower()
-        
-        for m in self.moduleList:
-            lowerB = m.name.lower()
-            if lowerA == lowerB:
-                return True
-        
-        return False
-
-    def openLoadModuleDialog(self):
-        self.moduleFolder = str(self.moduleCfgPath.replace("modules.cfg", ""))
-
-        self.parseModuleConfig()
-
-        dlg = QDialog(QApplication.focusWidget())
-        list = QListWidget()
-        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
-        dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
-        dlg.connect(btnBox, SIGNAL("rejected()"), dlg.reject)
-
-        for m in self.moduleList:
-            if not m.isCommon():
-                list.addItem(m.name)
-
-        layout = QVBoxLayout()
-        layout.addWidget(list)
-        layout.addWidget(btnBox)
-        dlg.setLayout(layout)
-        if dlg.exec_():
-            self.loadModule(str(list.currentItem().text()))
-
-    # I'm sorry for this
-    def loadModule(self, moduleName):
-        t = og.Timer()
-        
-#        self.progress = ProgressBarThread(0, 8, moduleName)
-#        self.progress.start()
-        
-        for m in self.moduleList:
-            if m.name == moduleName:
-                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
-                    for moduleDependencie in m.moduleDependencies:
-                        for m2 in self.moduleList:
-                            if m2.name == moduleDependencie:
-#                                self.progress.setProgress(2, "Loading Dependencie: " + moduleDependencie)
-                                m2.load()
-                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
-                                self.materialSelectionDialog.scanDirForMaterials(m2.moduleRoot)
-                                self.mainModuledependencieList.append(m2)
-
-#                self.progress.setProgress(4, "Loading " + moduleName)
-                m.load()
-#                self.progress.setProgress(6, "Scan for models...")
-                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
-#                self.progress.setProgress(8, "Scan for materials")
-                self.materialSelectionDialog.scanDirForMaterials(m.moduleRoot)
-                self.mainModule = m
-                self.moduleExplorer.setCurrentModule(m)
-                self.moduleDirView.parseDirectory(m.moduleRoot)
-                
-        if self.selectionBuffer is None:
-            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"), self, self.zoneManager)
-
-#        if self.depthBuffer is None:
-#            self.depthBuffer = DepthBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
-
-
-#        self.progress.quit()
-        print "Time to load module: " + str(t.getMilliseconds() / 1000.0) + " seconds"
-        del t
-
-    def addSceneToModule(self, name):
-        if self.mainModule is not None:
-            self.mainModule.addScene(name)
-
-    def addMapToScene(self, sceneName, mapName):
-        if self.mainModule is not None:
-            self.mainModule.addMapToScene(sceneName, mapName)
-
-    def setModuleExplorer(self, moduleExplorer):
-        self.moduleExplorer = moduleExplorer
-        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
-        self.moduleExplorer.setSelectionChangedCallback(self.selectionChangedCallback)
-        self.moduleExplorer.setModuleManager(self)
-    
-    def setModuleDirView(self, dirView):
-        self.moduleDirView = dirView
-    
-    def setPropertyWindow(self, propertyWin):
-        self.propertyWindow = propertyWin
-    
-    def selectionChangedCallback(self, items):
-        self.resetSelection()
-        self.userSelectionList = self.selectionBuffer.manualSelectObjects(items)
-        
-        print len(self.userSelectionList)
-        
-        if len(self.userSelectionList) > 1:
-            self.propertyWindow.clear()
-        elif len(self.userSelectionList) > 0 and len(self.userSelectionList) < 2:
-            self.propertyWindow.showProperties(self.userSelectionList[0])
-        else:
-            return
-            
-        self.updatePivots()
-        
-    def selectMapCallback(self, sceneName, mapName):
-        self.currentMap = self.mainModule.getMap(mapName, sceneName)
-        self.zoneManager.currentMap = self.currentMap
-        if self.currentMap is None:
-            print "Don't forget to select a map"
-
-        
-    # called when a click into Main Ogre Window occurs
-    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
-        if self.oneClickEntityPlacement:
-            if self.modelSelectionDialog.listWidget.currentItem() is not None:
-                meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
-                self.startDropModelAction(meshFile, ray)
-                self.moduleExplorer.updateView()
-                return
-            else:
-                print "Warning: OneClickEntityPlacement still runing on without any selected mesh!"
-                return
-                
-        #self.depthBuffer.onSelectionClick(screenX, screenY)
-        
-        so = None
-        if self.selectionBuffer is not None:
-            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        
-        if so is not None:
-            if not so.isPivot:                
-                if not controlDown and not shiftDown:
-                    self.resetSelection()
-                    so.setSelected(True)
-                    self.userSelectionList.append(so)
-                    self.propertyWindow.showProperties(so)
-                    self.moduleExplorer.deselectAll()
-                    self.moduleExplorer.selectItem(so, True)
-                    self.updatePivots()
-                elif controlDown and not shiftDown:
-                    so.setSelected(True)
-
-                    for soFromList in self.userSelectionList:
-                        if soFromList == so:
-                            return # object already selected
-
-                    self.userSelectionList.append(so)
-                    self.propertyWindow.showProperties(so)
-                    self.moduleExplorer.selectItem(so, True)
-                    self.updatePivots()
-
-
-                elif not controlDown and shiftDown:
-                    for selo in self.userSelectionList:
-                        if so == selo:
-                            so.setSelected(False)
-                            self.userSelectionList.remove(selo)
-                            self.moduleExplorer.selectItem(selo, False)
-                    self.updatePivots()
-                
-            else:
-                #so.entity is the pivot direction that was clicked
-                self.pivot.startTransforming(so.entity,  self.userSelectionList)
-        else:
-            self.resetSelection() # click in empty space, deselect everything
-            self.moduleExplorer.selectItems(None)
-            self.propertyWindow.clear()
-            if self.pivot is not None:
-                self.pivot.hide()
-
-#        if self.rayLine == None:
-#            self.rayLine = self.sceneManager.createManualObject("rayLine")
-#            self.rayLine.setDynamic(True)
-#            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
-#
-#            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-#
-#        else:
-#            self.rayLine.beginUpdate(0)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-
-    def deleteObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.pivot.hide()
-
-        for so in self.userSelectionList:
-            node = so.entity.getParentNode()
-            if node.getName().startswith("area_"):
-                self.zoneManager.deleteArea(so.entity.getUserObject())
-                continue
-            elif node.getName().startswith("light_"):
-                light = extractLight(node)
-                self.sceneManager.destroyLight(light)
-                
-            node.detachAllObjects()
-            self.sceneManager.destroySceneNode(node)
-            self.sceneManager.destroyEntity(so.entity)
-            del so
-        
-        self.userSelectionList = []
-        self.moduleExplorer.updateView()
-        
-    def copyObjects(self):
-        if len(self.userSelectionList) < 1 or self.currentMap is None:
-            print "Warning: No map selected!"
-            return
-
-        self.newSelectionList = []
-
-        for so in self.userSelectionList:
-            if so.entity.getUserObject() is not None:
-                if str(so.entity.getParentNode().getName()).startswith("gameobject_"):
-                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
-                    meshFile = go.getMeshFileName()
-
-                    if go is not None:
-                        newEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-                        newNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
-                        newNode.attachObject(newEntity)
-                        newNode.setPosition(so.entity.getParentNode().getPosition())
-
-                        newGO = GameObjectRepresentation(ModuleManager.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
-                        self.gocManager.addGameObjectRepresentation(newGO)
-                        newEntity.setUserObject(newGO)
-
-                        newSO = SelectionObject(newEntity)
-                        newSO.setSelected(True)
-                        self.newSelectionList.append(newSO)
-                        ModuleManager.dropCount += 1
-                elif str(so.entity.getParentNode().getName()).startswith("entity_"):
-                    nodeName = "entity_dropNode" + str(ModuleManager.dropCount)
-                    newNode = self.currentMap.mapNode.createChild(nodeName)
-
-                    entityName = createUniqueEntityName(self.sceneManager)
-                    newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
-
-                    eco = so.entity.getUserObject().copy()
-                    newEntity.setUserObject(eco)
-
-                    newNode.attachObject(newEntity)
-                    newNode.setPosition(so.entity.getParentNode().getPosition())
-                    newNode.setOrientation(so.entity.getParentNode().getOrientation())
-                    newNode.setScale(so.entity.getParentNode().getScale())
-
-                    newSO = SelectionObject(newEntity)
-                    newSO.setSelected(True)
-                    self.newSelectionList.append(newSO)
-                    ModuleManager.dropCount += 1
-                elif str(so.entity.getParentNode().getName()).startswith("light_"):
-                    print "Can't copy lights yet :)"
-
-        self.resetSelection()
-        self.userSelectionList = self.newSelectionList
-        self.moduleExplorer.updateView()
-        for so in self.userSelectionList:
-            self.moduleExplorer.selectItem(so, True)
-        self.updatePivots()
-
-        
-    def cutObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.cutList = []
-        for so in self.userSelectionList:
-            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
-            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
-            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
-            # so we only have to translate them to their new destination when they get pasted
-            # the position of the pivot point is considered as the center of gravity
-            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
-            self.cutList.append(so)
-        self.resetSelection()
-        self.moduleExplorer.updateView()
-        
-    def pasteObjects(self,  ray):
-        if len(self.cutList) < 1:
-            return
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
-                i = i+1
-        else:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
-                i = i+1
-        self.cutList = []
-        self.moduleExplorer.updateView()
-        
-    def leftMouseUp(self):
-        if self.pivot is not None and self.pivot.isTransforming:
-            self.propertyWindow.updateProperties()
-            self.pivot.stopTransforming()
-
-    def resetSelection(self):
-        if self.userSelectionList is not None:
-            for so in self.userSelectionList:
-                so.setSelected(False)
-
-        self.userSelectionList = []
-
-    def updatePivots(self):
-        newPivotPosition = og.Vector3(0, 0, 0)
-
-        for so in self.userSelectionList:
-            newPivotPosition += so.entity.getParentNode().getPosition()
-        if self.pivot is not None and len(self.userSelectionList) > 0:
-            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
-
-    def unload(self,  saveOnUnload=True):
-        pass
-
-    def save(self):
-        self.mainModule.save()
-
-    def startDropGameObjectAction(self, classid, ray):
-        if self.currentMap is None:
-            print "No map selected!"
-            return
-            
-        go = self.gocManager.getGameObjectWithClassId(classid)
-
-        if go is not None:
-            meshFile = go.getMeshFileName()
-            dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
-            dropNode.attachObject(dropEntity)
-
-            result = og.Math.intersects(ray, self.dropCollisionPlane)
-            if result.first == True:
-                dropNode.setPosition(ray.getPoint(result.second))
-            else:
-                dropNode.setPosition(ray.getPoint(50))
-
-            self.dropGO = GameObjectRepresentation(ModuleManager.dropCount, classid, dropNode, meshFile)
-            self.gocManager.addGameObjectRepresentation(self.dropGO)
-            dropEntity.setUserObject(self.dropGO)
-
-        ModuleManager.dropCount += 1
-
-    def moveDropGameObjectAction(self, ray):
-        if self.currentMap is None:
-            return
-        
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropGO.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropGO.setPosition(ray.getPoint(50))
-
-    def finishDropGameObjectAction(self, ray):
-        self.moduleExplorer.updateView()
-        self.dropGO = None
-        return
-
-    def startDropModelAction(self, meshFile, ray):
-        if self.currentMap is None:
-            print "No map selected!"
-            return
-            
-        self.dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), meshFile)
-        
-        eco = EntityCustomOptions()
-        self.dropEntity.setUserObject(eco)
-        
-        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(ModuleManager.dropCount))
-        self.dropNode.attachObject(self.dropEntity)
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-        ModuleManager.dropCount += 1
-
-    def moveDropModelAction(self, ray):
-        if self.currentMap is None:
-            return
-            
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-    
-    def finishDropModelAction(self, ray):
-        self.moduleExplorer.updateView()
-        return
-
-    def startDropMaterialAction(self, text):
-        self.dropMat = text
-        
-    def moveDropMaterialAction(self, event):
-        return
-
-    def finishDropMaterialAction(self, screenX, screenY):
-        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        if so is not None:
-            if not so.entity.getNumSubEntities() > 1:
-                so.entity.setMaterialName(self.dropMat)
-                so.entity.getUserObject().materialName = self.dropMat
-            else:
-                i = 0
-                text = "Warning this Entity has more than one SubEntities with the folloing materials: \n\n"
-                while i < so.entity.getNumSubEntities():
-                    text += "SubMesh" + str(i) + ":  " + so.entity.getSubEntity(i).getMaterialName() + "\n"
-                    i += 1
-                
-                text += "\n Replace the materials?"
-                reply = QMessageBox.question(None, "Warning: multiple materials",  text,  QMessageBox.Yes|QMessageBox.No)
-                if reply == QMessageBox.Cancel:
-                    return
-                if reply == QMessageBox.Yes:
-                    so.entity.setMaterialName(self.dropMat)
-                    so.entity.getUserObject().materialName = self.dropMat
-        
-    def setOneClickEntityPlacement(self, state):
-        self.oneClickEntityPlacement = state
-    
-    def createLight(self, name):
-        pos = og.Vector3()
-        
-        query = self.sceneManager.createRayQuery(self.contextMenuRay)
-        query.ray = self.contextMenuRay
-        query.setSortByDistance(True)
-        query.execute(self.raySceneQueryListener)
-        if self.raySceneQueryListener.dist < 100000:
-            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
-            self.raySceneQueryListener.dist = 100000
-            
-        light = None
-        if not self.sceneManager.hasLight(name):
-            light = self.sceneManager.createLight(name)
-            
-        return light,  pos
-        
-    def addPointLight(self):
-        if self.currentMap is None:
-            print "No map selected!"
-            return
-            
-        lightName = "pointLight" + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-        light, pos = self.createLight(lightName)
-        printVector3(pos)
-        
-        if not light:
-            print "Error while creating light"
-            return
-            
-        light.setType(og.Light.LT_POINT)
-        
-        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
-        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
-        n.attachObject(light)
-        n.attachObject(e)
-        n.setPosition(pos)
-        self.moduleExplorer.updateView()
-        
-    def addSpotLight(self):
-        if self.currentMap is None:
-            print "No map selected!"
-            return
-            
-        lightName = "spotLight" + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-        light, pos = self.createLight(lightName)
-        printVector3(pos)
-        
-        if not light:
-            print "Error while creating light"
-            return
-            
-        light.setType(og.Light.LT_SPOTLIGHT)
-        
-        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
-        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
-        n.attachObject(light)
-        n.attachObject(e)
-        n.setPosition(pos)
-        self.moduleExplorer.updateView()
-        
-    def addZoneToMap(self, name):
-        self.zoneManager.createZone(name)
-        self.moduleExplorer.updateView()
-        
-    def setPlayerStart(self):
-        self.mainModule.playerStart = str(self.playerStartGameObjectId)
-        print "setting Player Start to " + str(self.playerStartGameObjectId)
-    
-    def onContextMenu(self, screenX, screenY, ray):
-        menus = []
-        actions = []
-        pla = self.createAction("Pointlight", self.addPointLight, None, "idea.png")
-        pls = self.createAction("Spotlight", self.addSpotLight, None, "idea.png")
-        
-        lightMenu = QMenu("Add Light")
-        lightMenu.addAction(pla)
-        lightMenu.addAction(pls)
-        menus.append(lightMenu)
-        
-        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        self.contextMenuClickPosition = og.Vector2(screenX, screenY)
-        self.contextMenuRay = ray
-        
-        pos = og.Vector3()
-        query = self.sceneManager.createRayQuery(self.contextMenuRay)
-        query.ray = self.contextMenuRay
-        query.setSortByDistance(True)
-        query.execute(self.raySceneQueryListener)
-        if self.raySceneQueryListener.dist < 100000:
-            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
-            self.raySceneQueryListener.dist = 100000
-        
-        if so is not None:
-            self.zoneManager.entityUnderMouse = so.entity
-        
-        self.zoneManager.newAreaPosition = pos
-        menus.append(self.zoneManager.getZoneMenu())
-
-        if so is not None and so.entity.getParentNode().getName().startswith("gameobject_"):
-            actions.append(self.createAction("Set Player Starterpoint", self.setPlayerStart))
-            actions.append(self.createAction("Add Property", so.entity.getUserObject().addProperty))
-            self.playerStartGameObjectId = so.entity.getUserObject().inWorldId
-            
-                
-            
-        if self.onContextMenuCallback is not None:
-            self.onContextMenuCallback(actions,  menus)
-
-    def setContextMenuCallback(self, callback):
-        self.onContextMenuCallback = callback
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
-        action = QAction(text, None)
-        if icon is not None:
-            action.setIcon(QIcon("media/icons/%s" % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            QWidget.connect(action, SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import sys
+import codecs
+import glob
+import os
+from os.path import isfile,  join
+
+import xml.etree.cElementTree as xml
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from SelectionBuffer import *
+from DepthBuffer import *
+from MovePivot import *
+from GameObjectClassManager import *
+from MyRaySceneQueryListener import *
+from ZoneManager import ZoneManager
+
+
+# get the light out of a light node
+def extractLight(node):
+        i = 0
+        num = node.numAttachedObjects()
+        while i < node.numAttachedObjects():
+            c = node.getAttachedObject(i)
+            tp = str(type(c))
+            if tp == "<class 'ogre.renderer.OGRE._ogre_.Light'>":
+                return c
+            
+            i += 1
+
+# make the xml file more pretty
+def indent(elem, level=0):
+    i = "\n" + level*"  "
+    
+    if len(elem):
+        if not elem.text or not elem.text.strip():
+            elem.text = i + "  "
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+        for elem in elem:
+            indent(elem, level+1)
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+    else:
+        if level and (not elem.tail or not elem.tail.strip()):
+            elem.tail = i
+
+# creates unique names for new entities
+def createUniqueEntityName(sceneManager, name = None):
+    n = ""
+    if name is None:
+        n = "dropMesh" + str(ModuleManager.dropCount)
+    else:
+        n = name
+        
+    while sceneManager.hasEntity(n):
+        n = "dropMesh" + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+    return n
+        
+def printVector3(vec):
+    print str(vec.x) + ";" + str(vec.y) + ";" + str(vec.z)
+    
+class EntityCustomOptions(og.UserDefinedObject):
+    def __init__(self, receivesShadow = True, staticgeometrygroup = 0, physicsproxytype = "none", renderingdistance = "20000"):
+        og.UserDefinedObject.__init__(self)
+        self.receivesShadow = receivesShadow
+        self.staticgeometrygroup = staticgeometrygroup
+        self.physicsproxytype = physicsproxytype
+        self.renderingdistance = renderingdistance
+        self.materialName = "NotChanged"
+        
+        ModuleManager.entityCustomOptionsDict.append(self)
+        
+    def copy(self):
+            return EntityCustomOptions(self.receivesShadow, self.staticgeometrygroup, self.physicsproxytype, self.renderingdistance)
+        
+    def getType(self):
+            return "EntityCustomOptions"
+
+class Map():
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyMap = False):
+        self.pathToMapFile = pathToFile
+        
+        mapName = pathToFile.replace("\\", "/")
+        mapName = mapName.split("/")
+        mapName = mapName[len(mapName) - 1].split(".")
+        mapName = mapName[len(mapName) - 3]
+        self.mapName = mapName
+        self.mapFileName = self.mapName + ".rlmap.xml"
+        
+        self.sceneManager = sceneManager
+        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        self.zoneManager = zoneManager
+        self.isHidden = False
+        
+        self.zoneList = []
+        
+        if not emptyMap:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+
+            if root.attrib["formatVersion"] == "0.4.0":
+                self.parseMapNodes(root.find("nodes"))
+                self.parseMapZones(root.find("zones"))
+            else:
+                print pathToFile + " has wrong format version. It needs to be 0.4.0"
+                return
+
+    def hide(self):
+        try:
+            self.sceneManager.getRootSceneNode().removeChild(self.mapNode)
+        except:
+            print "Error: map is already hidden!"
+            return
+        
+        self.isHidden = True
+        
+    def show(self):
+        try:
+            self.sceneManager.getRootSceneNode().addChild(self.mapNode)
+        except:
+            print "Error: map is already shown!"
+            return
+        
+        self.isHidden = False
+    
+    def parseMapZones(self, zonesElement):
+        self.zoneManager.parseZonesFromXml(zonesElement, self)
+    
+    def parseMapNodes(self, nodeElement):
+        nodes = nodeElement.getiterator("gameobject")
+        self.createGameObjects(nodes)
+        
+        nodes = nodeElement.getiterator("entity")
+        self.createEntites(nodes)
+
+        nodes = nodeElement.getiterator("light")
+        self.createLights(nodes)
+
+        nodes = nodeElement.getiterator("sound")
+        self.createSound(nodes)
+
+        nodes = nodeElement.getiterator("particlesystem")
+        self.createParticleSystems(nodes)
+
+    def createEntites(self, entityNodes):
+        for nodes in entityNodes:
+            entityName = nodes.attrib["name"]
+            
+            if entityName.startswith("dropMesh"):
+                num = int(entityName.replace("dropMesh",  ""))
+                if ModuleManager.dropCount < num:
+                    ModuleManager.dropCount = num
+                elif ModuleManager.dropCount < num:
+                    ModuleManager.dropCount = num + 1
+                    
+            meshFile = nodes.attrib["meshfile"]
+            
+            eco = EntityCustomOptions()
+            
+            try:
+                if nodes.attrib["receivesShadow"] == "False" or nodes.attrib["receivesShadow"] == "false":
+                    eco.receivesShadow = "False"
+            except:
+                pass
+            try:
+                eco.staticgeometrygroup = int(nodes.attrib["staticgeometrygroup"])
+            except:
+                pass
+            try:
+                eco.physicsproxy = nodes.attrib["physicsproxy"]
+            except:
+                pass
+            try:
+                eco.renderingdistance = float(nodes.attrib["renderingdistance"])
+            except:
+                pass
+            try:
+                eco.renderingdistance
+                nodes.attrib["materialName"]
+            except:
+                pass
+                
+            nodePosition = None
+            nodeScale = None
+            qw = qx = qy = qz = None
+
+            transformations = nodes.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    posx = float(t.attrib["x"])
+                    posy = float(t.attrib["y"])
+                    posz = float(t.attrib["z"])
+                    nodePosition = og.Vector3(posx, posy, posz)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                elif t.tag == "scale":
+                    scalex = float(t.attrib["x"])
+                    scaley = float(t.attrib["y"])
+                    scalez = float(t.attrib["z"])
+                    nodeScale = og.Vector3(scalex, scaley, scalez)
+
+            try:
+                e = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager,  entityName), meshFile)
+            except:
+                print "Warning: Meshfile " + meshFile + " could not be found."
+                return
+
+            e.setUserObject(eco)
+            n = self.mapNode.createChild("entity_" + entityName + "_node")
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            n.setOrientation(qw, qx, qy, qz)
+            n.setScale(nodeScale)
+
+    def createLights(self, lightNodes):
+        for l in lightNodes:
+            lightName = l.attrib["name"]
+            lightType = l.attrib["type"]
+            lightVisible = bool(l.attrib["visible"])
+            castShadows = bool(l.attrib["castShadows"])
+            lightPosition = None
+            lightDirection = None
+            colourDiffuse = None
+            colourSpecular = None
+            lightAttenuationRange = None
+            lightAttenuationConstant= None
+            lightAttenuationLinear = None
+            lightAttenuationQuadratic = None
+            spotlightinner = None
+            spotlightouter = None
+            falloff = None 
+                
+            transformations = l.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    lightPosition = og.Vector3(x, y, z)
+                elif t.tag == "colourDiffuse":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourDiffuse = og.ColourValue(r, g, b)
+                elif t.tag == "colourSpecular":
+                    r = float(t.attrib["r"])
+                    g = float(t.attrib["g"])
+                    b= float(t.attrib["b"])
+                    colourSpecular = og.ColourValue(r, g, b)
+                elif t.tag == "lightAttenuation":
+                    lightAttenuationRange = float(t.attrib["range"])
+                    lightAttenuationConstant= float(t.attrib["constant"])
+                    lightAttenuationLinear = float(t.attrib["linear"])
+                    lightAttenuationQuadric  = float(t.attrib["quadratic"])
+                elif t.tag == "spotlightrange":
+                    spotlightinner = float(t.attrib["inner"])
+                    spotlightouter = float(t.attrib["outer"])
+                    falloff = float(t.attrib["falloff"])
+                    
+            light = self.sceneManager.createLight(lightName)
+            
+            if lightType == "point":
+                light.setType(og.Light.LT_POINT)            
+            elif lightType == "spot":
+                light.setType(og.Light.LT_SPOTLIGHT)
+            elif lightType == "directional":
+                light.setType(og.Light.LT_DIRECTIONAL)
+            
+            light.setVisible(lightVisible)
+            light.setCastShadows(castShadows)
+            if lightAttenuationRange is not None and lightAttenuationConstant is not None and lightAttenuationLinear is not None and lightAttenuationQuadric is not None:
+                light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadric)
+            if colourDiffuse:
+                light.setDiffuseColour(colourDiffuse)
+            if colourSpecular:
+                light.setSpecularColour(colourSpecular)
+            if spotlightinner and spotlightouter and spotlightouter: 
+                light.setSpotlightRange(spotlightinner, spotlightouter, falloff)
+            
+            e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+            n = self.mapNode.createChild("light_" + lightName + "_node")
+            n.attachObject(light)
+            n.attachObject(e)
+            if lightPosition:
+                n.setPosition(lightPosition)
+            
+    def createSound(self, soundNodes):
+        #raise NotImplementedError
+        return
+
+    def createGameObjects(self, gameObjectNodes):
+        for g in gameObjectNodes:
+            classid = g.attrib["class"]
+            
+            id = int(g.attrib["id"])
+            if ModuleManager.dropCount < id:
+                ModuleManager.dropCount = id
+            elif ModuleManager.dropCount < id:
+                ModuleManager.dropCount = id + 1
+                
+            state = g.attrib["state"]
+            nodePosition = None
+            nodeRotation = None
+            properties = {}
+            
+            transformations = g.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+                elif t.tag == "property":
+                    name = t.attrib["name"]
+                    type = t.attrib["type"]
+                    data = t.attrib["data"]
+                    properties[name] = GameObjectRepresentation.PropertieRepresentation(name, type, data)
+
+            go = self.gocManager.getGameObjectWithClassId(classid)
+            if go is not None:
+                meshFile = go.getMeshFileName()
+                
+                ent = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+                dropNode = self.mapNode.createChild("gameobject_" + "dropNode" + str(id))
+                dropNode.attachObject(ent)
+
+                if nodePosition:
+                    dropNode.setPosition(nodePosition)
+                if nodeRotation:
+                    dropNode.setOrientation(nodeRotation)
+
+                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
+                self.gocManager.addGameObjectRepresentation(go)
+                go.inWorldId = id
+                go.state = state
+                go.propertieDict = properties
+                ent.setUserObject(go)
+
+
+    def createParticleSystems(self, particleNodes):
+        #raise NotImplementedError
+        return
+        
+    def save(self):
+        root = xml.Element("rastullahmap")
+        root.attrib["formatVersion"] = "0.4.0"
+        
+        nodesElem = xml.SubElement(root, "nodes")
+        
+        i = 0
+        while i < self.mapNode.numChildren():
+            n = self.mapNode.getChild(i)
+            if n.numAttachedObjects() > 0:
+                if n.name.startswith("entity_"):
+                    entElem = xml.SubElement(nodesElem, "entity")
+                    entElem.attrib["name"] = n.getAttachedObject(0).getName()
+                    entName = n.getAttachedObject(0).getName()
+                    #print "Saving Entity: " + n.getAttachedObject(0).getName()
+                    entElem.attrib["meshfile"] = n.getAttachedObject(0).getMesh().getName()
+   
+                    entElem.attrib["receivesShadow"] = str(n.getAttachedObject(0).getUserObject().receivesShadow).lower()
+                    entElem.attrib["staticgeometrygroup"] = str(n.getAttachedObject(0).getUserObject().staticgeometrygroup)
+                    entElem.attrib["physicsproxytype"] = str(n.getAttachedObject(0).getUserObject().physicsproxytype)
+                    entElem.attrib["renderingdistance"] = str(n.getAttachedObject(0).getUserObject().renderingdistance)
+                    
+                    posElem = xml.SubElement(entElem, "position")
+                    posElem.attrib["x"] = str(n.getPosition().x)
+                    posElem.attrib["y"] = str(n.getPosition().y)
+                    posElem.attrib["z"] = str(n.getPosition().z)
+                    
+                    rotElem = xml.SubElement(entElem, "rotation")
+                    rotElem.attrib["qw"] = str(n.getOrientation().w)
+                    rotElem.attrib["qx"] = str(n.getOrientation().x)
+                    rotElem.attrib["qy"] = str(n.getOrientation().y)
+                    rotElem.attrib["qz"] = str(n.getOrientation().z)
+                    
+                    scaleElem = xml.SubElement(entElem, "scale")
+                    scaleElem.attrib["x"] = str(n.getScale().x)
+                    scaleElem.attrib["y"] = str(n.getScale().y)
+                    scaleElem.attrib["z"] = str(n.getScale().z)
+                    
+                elif n.name.startswith("gameobject_"):
+                    goElem = xml.SubElement(nodesElem, "gameobject")
+                    mname = n.name
+                    #print "Saving GOID: " + str(n.getAttachedObject(0).getUserObject().inWorldId)
+                    goElem.attrib["class"] = str(n.getAttachedObject(0).getUserObject().gocName)
+                    goElem.attrib["state"] = str(n.getAttachedObject(0).getUserObject().state)
+                    goElem.attrib["id"] = str(n.getAttachedObject(0).getUserObject().inWorldId)
+                    
+                    posElem = xml.SubElement(goElem, "position")
+                    posElem.attrib["x"] = str(n.getPosition().x)
+                    posElem.attrib["y"] = str(n.getPosition().y)
+                    posElem.attrib["z"] = str(n.getPosition().z)
+                    
+                    rotElem = xml.SubElement(goElem, "rotation")
+                    rotElem.attrib["qw"] = str(n.getOrientation().w)
+                    rotElem.attrib["qx"] = str(n.getOrientation().x)
+                    rotElem.attrib["qy"] = str(n.getOrientation().y)
+                    rotElem.attrib["qz"] = str(n.getOrientation().z)
+                    
+                    dict = n.getAttachedObject(0).getUserObject().propertieDict
+                    for key in dict:
+                        prop = dict[key]
+                        rotElem = xml.SubElement(goElem, "property")
+                        rotElem.attrib["name"] = prop.name
+                        rotElem.attrib["type"] = prop.type
+                        rotElem.attrib["data"] = prop.data
+
+                    
+                elif n.name.startswith("light_"):
+                    light = extractLight(n)
+                    lightName = light.getName()
+                    #print "Saving Light: " + lightName
+                    lightType = light.getType()
+                    isVisible = "true"
+                    if not light.getVisible():
+                        isVisible = "false"
+                    
+                    castShadows = "false"
+                    if light.getCastShadows():
+                        castShadows = "true"
+                    
+                    if lightType == og.Light.LT_POINT:
+                        lightType = "point"
+                    elif lightType == og.Light.LT_SPOTLIGHT:
+                        lightType = "spot"
+                    elif lightType == og.Light.LT_DIRECTIONAL:
+                        lightType = "directional"
+                    
+                    
+                    lightElem = xml.SubElement(nodesElem, "light")
+                    lightElem.attrib["name"] = lightName
+                    lightElem.attrib["type"] = lightType
+                    lightElem.attrib["visible"] = isVisible
+                    lightElem.attrib["castShadows"] = castShadows
+                    
+                    if lightType == "point" or lightType == "spot":
+                        posElem = xml.SubElement(lightElem, "position")
+                        posElem.attrib["x"] = str(n.getPosition().x)
+                        posElem.attrib["y"] = str(n.getPosition().y)
+                        posElem.attrib["z"] = str(n.getPosition().z)
+                    
+                    colDiffuseElem = xml.SubElement(lightElem, "colourDiffuse")
+                    colDiffuseElem.attrib["r"] = str(light.getDiffuseColour().r)
+                    colDiffuseElem.attrib["g"] = str(light.getDiffuseColour().g)
+                    colDiffuseElem.attrib["b"] = str(light.getDiffuseColour().b)
+
+                    colSpecularElem = xml.SubElement(lightElem, "colourSpecular")
+                    colSpecularElem.attrib["r"] = str(light.getSpecularColour().r)
+                    colSpecularElem.attrib["g"] = str(light.getSpecularColour().g)
+                    colSpecularElem.attrib["b"] = str(light.getSpecularColour().b)
+                    
+                    lightAttenuationElem = xml.SubElement(lightElem, "lightAttenuation")
+                    lightAttenuationElem.attrib["range"] = str(light.getAttenuationRange())
+                    lightAttenuationElem.attrib["constant"] = str(light.getAttenuationConstant())
+                    lightAttenuationElem.attrib["linear"] = str(light.getAttenuationLinear())
+                    lightAttenuationElem.attrib["quadratic"] = str(light.getAttenuationQuadric())
+                    
+                    if lightType == "spot":
+                        spotligthRangeElem = xml.SubElement(lightElem, "spotlightrange")
+                        spotligthRangeElem.attrib["inner"] = str(light.getSpotlightInnerAngle().valueDegrees())
+                        spotligthRangeElem.attrib["outer"] = str(light.getSpotlightOuterAngle().valueDegrees())
+                        spotligthRangeElem.attrib["falloff"] = str(light.getSpotlightFalloff())
+                        
+                    if lightType == "spot" or lightType == "directional":
+                        directionElem = xml.SubElement(lightElem, "direction")
+                        dir = og.Vector3()
+                        n.getOrientation().ToAxes(dir)
+                        directionElem.attrib["x"] = str(dir.x)
+                        directionElem.attrib["y"] = str(dir.y)
+                        directionElem.attrib["z"] = str(dir.z)
+                        
+            i = i+1
+            
+        self.zoneManager.saveZonesToXml(root, self)
+        indent(root)
+        xml.ElementTree(root).write(self.pathToMapFile)
+
+# caused a linux crash
+#        iter = self.mapNode.getChildIterator()
+#        while iter.hasMoreElements():
+#            name = iter.getNext().getName()
+#            print name
+
+class Scene():
+    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyScene = False, sceneName = "NewScene"):
+        self.moduleRoot = moduleroot
+        self.pathToFile = pathToFile
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        self.zoneManager = zoneManager
+        self.mapFiles = [] # a list in case the module has more than one map file
+        mappaths = []
+        self.name = sceneName
+
+        
+        if not emptyScene:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+            self.name = root.attrib["name"]
+        
+            maps = root.getiterator("map")
+            for m in maps:
+                mappaths.append(join(self.moduleRoot, join("maps", m.attrib["file"])))
+                
+            for m in mappaths:
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
+            
+    def addMap(self, name):
+        path = join(self.moduleRoot, join("maps", name + ".rlmap.xml"))
+        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True))
+        
+    def save(self):
+        root = xml.Element("scene")
+        root.attrib["name"] = self.name
+        
+        for m in self.mapFiles:
+            sub = xml.SubElement(root, "map")
+            sub.attrib["file"] = m.mapFileName
+            m.save()
+
+        indent(root)
+        xml.ElementTree(root).write(self.pathToFile)
+
+class Module():
+    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager, zoneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gameObjectManager
+        self.zoneManager = zoneManager
+        
+        self.name = name
+        self.moduleRoot = join(modulePath, name)
+        self.__isCommon = False
+
+        self.hasDependencies = False
+        self.moduleDependencies = []
+
+        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+
+        self.gofFiles = [] # gof File list
+
+        self.scenes =[]
+
+        self.isLoaded = False
+        
+        self.playerStart = None
+        
+    def addScene(self, name):
+        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, ("maps/" + name + ".rlscene")), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True, name))
+    
+    def addMapToScene(self, sceneName, mapName):
+        for scene in self.scenes:
+            if scene.name == sceneName:
+                scene.addMap(mapName)
+                return
+        
+        print "ERROR: could not find scene: " + sceneName
+        
+    
+    def isCommon(self):
+        if isfile(self.modConfig): # is the modconfig existing?
+            f = codecs.open(self.modConfig, 'r', 'utf-8')
+        else:
+            print ("Module.isCommon() Error: couldn't find module config")
+            return
+        isDependencieLine = False
+        for i, line in enumerate(f):
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith("super("):
+                split = lStripped.split(",")
+                if split[2].strip() == unicode("true"):
+                    self.__isCommon = True
+                    return True
+
+
+            elif isDependencieLine:
+                if lStripped == "end":
+                    isDependencieLine = False
+                else:
+                    self.hasDependencies = True
+                    pl = lStripped.split('"')
+                    i = 1
+                    while i < 100: 
+                        try:
+                            self.moduleDependencies.append(pl[i])
+                            i += 2
+                        except IndexError, e:
+                            break
+
+            elif lStripped == "def getDependencies()":
+                isDependencieLine = True
+
+        return False
+
+    def load(self):
+        if self.isLoaded:
+            return
+        
+        self.isLoaded = True
+        self.modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+        if isfile(self.modConfig): # is the modconfig existing?
+            f = codecs.open(self.modConfig, 'r', 'utf-8')
+        else:
+            print ("Module.load: Error: couldn't find module config")
+            return
+
+        for line in f:
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith("hero = $GOM.getGameObject("):
+                try:
+                    self.playerStart = int(line.split("(")[1].split(")")[0])
+                except ValueError, e:
+                    print self.modConfig + " ValueError: " + str(e)
+                    self.playerStart = None
+                    continue
+                    
+        self.setResourcePaths()
+        
+        try:
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+        except og.OgreException, e:
+            print e
+        
+        
+        cmd = join(self.moduleRoot, "dsa/*.gof")
+        self.gofFiles = glob.glob(cmd)
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
+        if not self.isCommon():
+            cmd = join(self.moduleRoot, "maps/*.rlscene")
+            sceneFile = glob.glob(cmd)
+            self.loadScenes(sceneFile)
+                
+    def loadScenes(self, sceneFiles):
+        for s in sceneFiles:
+            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
+
+    def save(self):
+        for s in self.scenes:
+            s.save()
+            
+        self.saveModuleConfig()
+
+    def saveModuleConfig(self):
+        if self.playerStart is not None:
+            f = open(self.modConfig, "r")
+            
+            newconfig = ""
+            for line in f:
+                if line.startswith("       hero = $GOM.getGameObject("):
+                    newconfig += "       hero = $GOM.getGameObject(" + str(self.playerStart) + ");\n"
+                else:
+                    newconfig += line
+            f.close()
+            
+            f = open(self.modConfig, "w")
+            f.write(newconfig)
+            f.close()
+
+    def setResourcePaths(self, recurseFolder = ""):
+        if recurseFolder == "":
+            rootFolder = self.moduleRoot
+        else:
+            rootFolder = join(self.moduleRoot, recurseFolder)
+
+        for file in os.listdir(rootFolder):
+            curFile = join(rootFolder, file)
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            elif os.path.isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
+                self.setResourcePaths(curFile)
+            elif os.path.isfile(curFile):
+                continue
+                
+    def getMap(self, mapName, sceneName = None):
+        if sceneName is not None:
+            for s in self.scenes:
+                if s.name == sceneName:
+                    for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+        else:
+            for s in self.scenes:
+                for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+
+class ProgressBarThread(QThread):
+    def __init__(self, min, max, moduleName):
+        QThread.__init__(self)
+        self.progress = QProgressDialog("Loading " + moduleName, "Abort Loading", min, max, None);
+        self.progress.setWindowModality(Qt.WindowModal)
+
+    def setProgress(self, progress, labelText):
+        self.progress.setLabelText(labelText)
+        self.progress.setValue(progress)
+        
+    def run(self):
+        self.progress.show()
+        self.exec_()
+
+        
+class ModuleManager():
+    dropCount = 0
+    entityCustomOptionsDict = []
+    
+    def __init__(self,  ogreRoot,  sceneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.modelSelectionDialog = None
+        self.materialSelectionDialog = None
+
+        self.moduleCfgPath = ""
+
+        self.gocManager = GameObjectClassManager()
+        
+
+        self.mainModule = None
+        self.mainModuledependencieList =[]
+        self.moduleList = []
+        self.userSelectionList = []
+        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
+        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
+        self.currentMap = None
+        self.moduleExplorer = None
+        self.moduleDirView = None
+
+        self.lastRay = None
+        self.rayLine = None
+
+        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.dropNode = None
+        self.dropEntity = None
+        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
+        self.dropMat = None
+        
+        self.moduleConfigIsParsed = False
+
+        self.selectionBuffer = None
+        self.depthBuffer = None
+        self.propertyWindow = None
+    
+        self.oneClickEntityPlacement = False
+        
+        self.onContextMenuCallback = None
+        self.contextMenuClickPosition = None
+        self.contextMenuRay = None
+        
+        self.playerStartGameObjectId = None
+        
+        self.entityCustomOptionsDict = []
+        
+        self.raySceneQueryListener = MyRaySceneQueryListener()
+        
+        self.zoneManager = ZoneManager(self.sceneManager)
+        
+    def resetParsedModuleConfig(self):
+        self.moduleConfigIsParsed = False
+        self.moduleList = []
+
+    def parseModuleConfig(self):
+        if self.moduleConfigIsParsed:
+            return
+
+        import codecs
+        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
+
+        for line in f:
+            if line.startswith('#'):
+                continue
+
+            if line.startswith('module='):
+                splines = line.split('=')
+                str = splines[1].rstrip().rstrip()
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
+
+        self.moduleConfigIsParsed = True
+
+    def moduleExists(self, name):
+        lowerA = str(name).lower()
+        
+        for m in self.moduleList:
+            lowerB = m.name.lower()
+            if lowerA == lowerB:
+                return True
+        
+        return False
+
+    def openLoadModuleDialog(self):
+        self.moduleFolder = str(self.moduleCfgPath.replace("modules.cfg", ""))
+
+        self.parseModuleConfig()
+
+        dlg = QDialog(QApplication.focusWidget())
+        list = QListWidget()
+        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
+        dlg.connect(btnBox, SIGNAL("rejected()"), dlg.reject)
+
+        for m in self.moduleList:
+            if not m.isCommon():
+                list.addItem(m.name)
+
+        layout = QVBoxLayout()
+        layout.addWidget(list)
+        layout.addWidget(btnBox)
+        dlg.setLayout(layout)
+        if dlg.exec_():
+            self.loadModule(str(list.currentItem().text()))
+
+    # I'm sorry for this
+    def loadModule(self, moduleName):
+        t = og.Timer()
+        
+#        self.progress = ProgressBarThread(0, 8, moduleName)
+#        self.progress.start()
+        
+        directories = []
+        
+        for m in self.moduleList:
+            if m.name == moduleName:
+                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
+                    for moduleDependencie in m.moduleDependencies:
+                        for m2 in self.moduleList:
+                            if m2.name == moduleDependencie:
+#                                self.progress.setProgress(2, "Loading Dependencie: " + moduleDependencie)
+                                m2.load()
+                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
+                                self.materialSelectionDialog.scanDirForMaterials(m2.moduleRoot)
+                                self.mainModuledependencieList.append(m2)
+                                directories.append(m2.moduleRoot)
+#                self.progress.setProgress(4, "Loading " + moduleName)
+                m.load()
+#                self.progress.setProgress(6, "Scan for models...")
+                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
+#                self.progress.setProgress(8, "Scan for materials")
+                self.materialSelectionDialog.scanDirForMaterials(m.moduleRoot)
+                directories.append(m.moduleRoot)
+                self.mainModule = m
+                self.moduleExplorer.setCurrentModule(m)
+                self.moduleDirView.parseDirectory(directories)
+                
+        if self.selectionBuffer is None:
+            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"), self, self.zoneManager)
+
+#        if self.depthBuffer is None:
+#            self.depthBuffer = DepthBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"))
+
+
+#        self.progress.quit()
+        print "Time to load module: " + str(t.getMilliseconds() / 1000.0) + " seconds"
+        del t
+
+    def addSceneToModule(self, name):
+        if self.mainModule is not None:
+            self.mainModule.addScene(name)
+
+    def addMapToScene(self, sceneName, mapName):
+        if self.mainModule is not None:
+            self.mainModule.addMapToScene(sceneName, mapName)
+
+    def setModuleExplorer(self, moduleExplorer):
+        self.moduleExplorer = moduleExplorer
+        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
+        self.moduleExplorer.setSelectionChangedCallback(self.selectionChangedCallback)
+        self.moduleExplorer.setModuleManager(self)
+    
+    def setModuleDirView(self, dirView):
+        self.moduleDirView = dirView
+    
+    def setPropertyWindow(self, propertyWin):
+        self.propertyWindow = propertyWin
+    
+    def selectionChangedCallback(self, items):
+        self.resetSelection()
+        self.userSelectionList = self.selectionBuffer.manualSelectObjects(items)
+        
+        print len(self.userSelectionList)
+        
+        if len(self.userSelectionList) > 1:
+            self.propertyWindow.clear()
+        elif len(self.userSelectionList) > 0 and len(self.userSelectionList) < 2:
+            self.propertyWindow.showProperties(self.userSelectionList[0])
+        else:
+            return
+            
+        self.updatePivots()
+        
+    def selectMapCallback(self, sceneName, mapName):
+        self.currentMap = self.mainModule.getMap(mapName, sceneName)
+        self.zoneManager.currentMap = self.currentMap
+        if self.currentMap is None:
+            print "Don't forget to select a map"
+
+        
+    # called when a click into Main Ogre Window occurs
+    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
+        if self.oneClickEntityPlacement:
+            if self.modelSelectionDialog.listWidget.currentItem() is not None:
+                meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
+                self.startDropModelAction(meshFile, ray)
+                self.moduleExplorer.updateView()
+                return
+            else:
+                print "Warning: OneClickEntityPlacement still runing on without any selected mesh!"
+                return
+                
+        #self.depthBuffer.onSelectionClick(screenX, screenY)
+        
+        so = None
+        if self.selectionBuffer is not None:
+            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        
+        if so is not None:
+            if not so.isPivot:                
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.propertyWindow.showProperties(so)
+                    self.moduleExplorer.deselectAll()
+                    self.moduleExplorer.selectItem(so, True)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+
+                    for soFromList in self.userSelectionList:
+                        if soFromList == so:
+                            return # object already selected
+
+                    self.userSelectionList.append(so)
+                    self.propertyWindow.showProperties(so)
+                    self.moduleExplorer.selectItem(so, True)
+                    self.updatePivots()
+
+
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so == selo:
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                            self.moduleExplorer.selectItem(selo, False)
+                    self.updatePivots()
+                
+            else:
+                #so.entity is the pivot direction that was clicked
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            self.resetSelection() # click in empty space, deselect everything
+            self.moduleExplorer.selectItems(None)
+            self.propertyWindow.clear()
+            if self.pivot is not None:
+                self.pivot.hide()
+
+#        if self.rayLine == None:
+#            self.rayLine = self.sceneManager.createManualObject("rayLine")
+#            self.rayLine.setDynamic(True)
+#            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
+#
+#            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+#
+#        else:
+#            self.rayLine.beginUpdate(0)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+
+    def deleteObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.pivot.hide()
+
+        for so in self.userSelectionList:
+            node = so.entity.getParentNode()
+            if node.getName().startswith("area_"):
+                self.zoneManager.deleteArea(so.entity.getUserObject())
+                continue
+            elif node.getName().startswith("light_"):
+                light = extractLight(node)
+                self.sceneManager.destroyLight(light)
+                
+            node.detachAllObjects()
+            self.sceneManager.destroySceneNode(node)
+            self.sceneManager.destroyEntity(so.entity)
+            del so
+        
+        self.userSelectionList = []
+        self.moduleExplorer.updateView()
+        
+    def copyObjects(self):
+        if len(self.userSelectionList) < 1 or self.currentMap is None:
+            print "Warning: No map selected!"
+            return
+
+        self.newSelectionList = []
+
+        for so in self.userSelectionList:
+            if so.entity.getUserObject() is not None:
+                if str(so.entity.getParentNode().getName()).startswith("gameobject_"):
+                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
+                    meshFile = go.getMeshFileName()
+
+                    if go is not None:
+                        newEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+                        newNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
+                        newNode.attachObject(newEntity)
+                        newNode.setPosition(so.entity.getParentNode().getPosition())
+
+                        newGO = GameObjectRepresentation(ModuleManager.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
+                        self.gocManager.addGameObjectRepresentation(newGO)
+                        newEntity.setUserObject(newGO)
+
+                        newSO = SelectionObject(newEntity)
+                        newSO.setSelected(True)
+                        self.newSelectionList.append(newSO)
+                        ModuleManager.dropCount += 1
+                elif str(so.entity.getParentNode().getName()).startswith("entity_"):
+                    nodeName = "entity_dropNode" + str(ModuleManager.dropCount)
+                    newNode = self.currentMap.mapNode.createChild(nodeName)
+
+                    entityName = createUniqueEntityName(self.sceneManager)
+                    newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+
+                    eco = so.entity.getUserObject().copy()
+                    newEntity.setUserObject(eco)
+
+                    newNode.attachObject(newEntity)
+                    newNode.setPosition(so.entity.getParentNode().getPosition())
+                    newNode.setOrientation(so.entity.getParentNode().getOrientation())
+                    newNode.setScale(so.entity.getParentNode().getScale())
+
+                    newSO = SelectionObject(newEntity)
+                    newSO.setSelected(True)
+                    self.newSelectionList.append(newSO)
+                    ModuleManager.dropCount += 1
+                elif str(so.entity.getParentNode().getName()).startswith("light_"):
+                    print "Can't copy lights yet :)"
+
+        self.resetSelection()
+        self.userSelectionList = self.newSelectionList
+        self.moduleExplorer.updateView()
+        for so in self.userSelectionList:
+            self.moduleExplorer.selectItem(so, True)
+        self.updatePivots()
+
+        
+    def cutObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.cutList = []
+        for so in self.userSelectionList:
+            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
+            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
+            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
+            # so we only have to translate them to their new destination when they get pasted
+            # the position of the pivot point is considered as the center of gravity
+            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
+            self.cutList.append(so)
+        self.resetSelection()
+        self.moduleExplorer.updateView()
+        
+    def pasteObjects(self,  ray):
+        if len(self.cutList) < 1:
+            return
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
+                i = i+1
+        else:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
+                i = i+1
+        self.cutList = []
+        self.moduleExplorer.updateView()
+        
+    def leftMouseUp(self):
+        if self.pivot is not None and self.pivot.isTransforming:
+            self.propertyWindow.updateProperties()
+            self.pivot.stopTransforming()
+
+    def resetSelection(self):
+        if self.userSelectionList is not None:
+            for so in self.userSelectionList:
+                so.setSelected(False)
+
+        self.userSelectionList = []
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+        if self.pivot is not None and len(self.userSelectionList) > 0:
+            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
+    def unload(self,  saveOnUnload=True):
+        pass
+
+    def save(self):
+        self.mainModule.save()
+
+    def startDropGameObjectAction(self, classid, ray):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        go = self.gocManager.getGameObjectWithClassId(classid)
+
+        if go is not None:
+            meshFile = go.getMeshFileName()
+            dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+            dropNode = self.currentMap.mapNode.createChild("gameobject_dropNode" + str(ModuleManager.dropCount))
+            dropNode.attachObject(dropEntity)
+
+            result = og.Math.intersects(ray, self.dropCollisionPlane)
+            if result.first == True:
+                dropNode.setPosition(ray.getPoint(result.second))
+            else:
+                dropNode.setPosition(ray.getPoint(50))
+
+            self.dropGO = GameObjectRepresentation(ModuleManager.dropCount, classid, dropNode, meshFile)
+            self.gocManager.addGameObjectRepresentation(self.dropGO)
+            dropEntity.setUserObject(self.dropGO)
+
+        ModuleManager.dropCount += 1
+
+    def moveDropGameObjectAction(self, ray):
+        if self.currentMap is None:
+            return
+        
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropGO.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropGO.setPosition(ray.getPoint(50))
+
+    def finishDropGameObjectAction(self, ray):
+        self.moduleExplorer.updateView()
+        self.dropGO = None
+        return
+
+    def startDropModelAction(self, meshFile, ray):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        self.dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), meshFile)
+        
+        eco = EntityCustomOptions()
+        self.dropEntity.setUserObject(eco)
+        
+        self.dropNode = self.currentMap.mapNode.createChild("entity_dropNode" + str(ModuleManager.dropCount))
+        self.dropNode.attachObject(self.dropEntity)
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+        ModuleManager.dropCount += 1
+
+    def moveDropModelAction(self, ray):
+        if self.currentMap is None:
+            return
+            
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+    
+    def finishDropModelAction(self, ray):
+        self.moduleExplorer.updateView()
+        return
+
+    def startDropMaterialAction(self, text):
+        self.dropMat = text
+        
+    def moveDropMaterialAction(self, event):
+        return
+
+    def finishDropMaterialAction(self, screenX, screenY):
+        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        if so is not None:
+            if not so.entity.getNumSubEntities() > 1:
+                so.entity.setMaterialName(self.dropMat)
+                so.entity.getUserObject().materialName = self.dropMat
+            else:
+                i = 0
+                text = "Warning this Entity has more than one SubEntities with the folloing materials: \n\n"
+                while i < so.entity.getNumSubEntities():
+                    text += "SubMesh" + str(i) + ":  " + so.entity.getSubEntity(i).getMaterialName() + "\n"
+                    i += 1
+                
+                text += "\n Replace the materials?"
+                reply = QMessageBox.question(None, "Warning: multiple materials",  text,  QMessageBox.Yes|QMessageBox.No)
+                if reply == QMessageBox.Cancel:
+                    return
+                if reply == QMessageBox.Yes:
+                    so.entity.setMaterialName(self.dropMat)
+                    so.entity.getUserObject().materialName = self.dropMat
+        
+    def setOneClickEntityPlacement(self, state):
+        self.oneClickEntityPlacement = state
+    
+    def createLight(self, name):
+        pos = og.Vector3()
+        
+        query = self.sceneManager.createRayQuery(self.contextMenuRay)
+        query.ray = self.contextMenuRay
+        query.setSortByDistance(True)
+        query.execute(self.raySceneQueryListener)
+        if self.raySceneQueryListener.dist < 100000:
+            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
+            self.raySceneQueryListener.dist = 100000
+            
+        light = None
+        if not self.sceneManager.hasLight(name):
+            light = self.sceneManager.createLight(name)
+            
+        return light,  pos
+        
+    def addPointLight(self):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        lightName = "pointLight" + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+        light, pos = self.createLight(lightName)
+        printVector3(pos)
+        
+        if not light:
+            print "Error while creating light"
+            return
+            
+        light.setType(og.Light.LT_POINT)
+        
+        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
+        n.attachObject(light)
+        n.attachObject(e)
+        n.setPosition(pos)
+        self.moduleExplorer.updateView()
+        
+    def addSpotLight(self):
+        if self.currentMap is None:
+            print "No map selected!"
+            return
+            
+        lightName = "spotLight" + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+        light, pos = self.createLight(lightName)
+        printVector3(pos)
+        
+        if not light:
+            print "Error while creating light"
+            return
+            
+        light.setType(og.Light.LT_SPOTLIGHT)
+        
+        e = self.sceneManager.createEntity(lightName + "_ent", "lightbulp.mesh")
+        n = self.currentMap.mapNode.createChild("light_" + lightName + "_node")
+        n.attachObject(light)
+        n.attachObject(e)
+        n.setPosition(pos)
+        self.moduleExplorer.updateView()
+        
+    def addZoneToMap(self, name):
+        self.zoneManager.createZone(name)
+        self.moduleExplorer.updateView()
+        
+    def setPlayerStart(self):
+        self.mainModule.playerStart = str(self.playerStartGameObjectId)
+        print "setting Player Start to " + str(self.playerStartGameObjectId)
+    
+    def onContextMenu(self, screenX, screenY, ray):
+        menus = []
+        actions = []
+        pla = self.createAction("Pointlight", self.addPointLight, None, "idea.png")
+        pls = self.createAction("Spotlight", self.addSpotLight, None, "idea.png")
+        
+        lightMenu = QMenu("Add Light")
+        lightMenu.addAction(pla)
+        lightMenu.addAction(pls)
+        menus.append(lightMenu)
+        
+        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        self.contextMenuClickPosition = og.Vector2(screenX, screenY)
+        self.contextMenuRay = ray
+        
+        pos = og.Vector3()
+        query = self.sceneManager.createRayQuery(self.contextMenuRay)
+        query.ray = self.contextMenuRay
+        query.setSortByDistance(True)
+        query.execute(self.raySceneQueryListener)
+        if self.raySceneQueryListener.dist < 100000:
+            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
+            self.raySceneQueryListener.dist = 100000
+        
+        if so is not None:
+            self.zoneManager.entityUnderMouse = so.entity
+        
+        self.zoneManager.newAreaPosition = pos
+        menus.append(self.zoneManager.getZoneMenu())
+
+        if so is not None and so.entity.getParentNode().getName().startswith("gameobject_"):
+            actions.append(self.createAction("Set Player Starterpoint", self.setPlayerStart))
+            actions.append(self.createAction("Add Property", so.entity.getUserObject().addProperty))
+            self.playerStartGameObjectId = so.entity.getUserObject().inWorldId
+            
+                
+            
+        if self.onContextMenuCallback is not None:
+            self.onContextMenuCallback(actions,  menus)
+
+    def setContextMenuCallback(self, callback):
+        self.onContextMenuCallback = callback
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QAction(text, None)
+        if icon is not None:
+            action.setIcon(QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            QWidget.connect(action, SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action

Modified: rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2009-04-16 13:42:21 UTC (rev 4901)
+++ rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2009-04-17 18:31:40 UTC (rev 4902)
@@ -26,6 +26,9 @@
 from PyQt4.QtGui import *
 
 class PreferencesDialog(QDialog):
+    pathToModuleConfig = None
+    externalTextAppCmd = None
+    
     def __init__(self, parent=None):
         QDialog.__init__(self, parent)
 
@@ -39,22 +42,47 @@
         layout.addWidget(self.label, 0, 0, 1, 2)
         layout.addWidget(self.lineEdit, 1, 0)
         layout.addWidget(self.modulConfigSelector, 1, 1)
+        QObject.connect(self.modulConfigSelector, SIGNAL("clicked()"),
+                               self.openModulConfigSelector)
 
+        self.externalTextApplabel = QLabel()
+        self.externalTextApplabel.setText("Please select the Texteditor to use.")
+        self.externalTextAppSelector = QPushButton()
+        self.externalTextAppSelector.setText("...")
+        self.externalTextAppLineEdit = QLineEdit()
+
+        layout.addWidget(self.externalTextApplabel, 2, 0, 1, 2)
+        layout.addWidget(self.externalTextAppLineEdit, 3, 0)
+        layout.addWidget(self.externalTextAppSelector, 3, 1)
+        QObject.connect(self.externalTextAppSelector, SIGNAL("clicked()"),
+                               self.openExternalTextEditorSelector)
+
+    
+
         self.setLayout(layout)
-        
+        self.setMinimumSize(600, 100)
         self.moduleCfgPath = None
-        
-        QObject.connect(self.modulConfigSelector, SIGNAL("clicked()"),
-                               self.openModulConfigSelector)
+        self.externalEditorPath = None
 
+
         self.setModal(True)
 
+        buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
+        layout.addWidget(buttonBox)
+        self.connect(buttonBox, SIGNAL("accepted()"), self.onOk)       
+        
+    def onOk(self):
+        PreferencesDialog.externalTextAppCmd = str(self.externalTextAppLineEdit.text())
+        self.accept()
+        
+        
     def setCfgPath(self, inPath):
         path = str(inPath)
 
         from os.path import isfile
 
         if isfile(path):
+            PreferencesDialog.pathToModuleConfig = path
             self.moduleCfgPath = path
             self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
             self.lineEdit.setText(self.moduleCfgPath)
@@ -62,11 +90,22 @@
         else:
             return False
 
+    def openExternalTextEditorSelector(self):
+        dialog = QFileDialog(self)
+        self.externalEditorPath = str(dialog.getOpenFileName(self, "Select the executable", "/home/melven/rastullah/rl_dist/modules/"))
+
+        from os.path import isfile
+
+        if isfile(self.externalEditorPath):
+            self.externalTextAppLineEdit.setText(self.externalEditorPath)
+            PreferencesDialog.externalTextAppCmd = str(self.externalTextAppLineEdit.text())
+            
     def openModulConfigSelector(self):
         dialog = QFileDialog(self)
         self.moduleCfgPath = str(dialog.getOpenFileName(self, "Select modules.cfg", "/home/melven/rastullah/rl_dist/modules/", "modules.cfg (*.cfg)"))
         self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
-
+        PreferencesDialog.pathToModuleConfig = self.moduleCfgPath
+        
         from os.path import isfile
 
         if isfile(self.moduleCfgPath):



From fusion2 at mail.berlios.de  Fri Apr 17 21:24:21 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Fri, 17 Apr 2009 21:24:21 +0200
Subject: [Dsa-hl-svn] r4903 - rl/trunk/editors/Lockenwickler/src
Message-ID: <200904171924.n3HJOLfj030494@sheep.berlios.de>

Author: fusion2
Date: 2009-04-17 21:24:20 +0200 (Fri, 17 Apr 2009)
New Revision: 4903

Modified:
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModuleDirectoryView.py
   rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
Log:
- save text editor path on shutdown


Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-04-17 18:31:40 UTC (rev 4902)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-04-17 19:24:20 UTC (rev 4903)
@@ -85,6 +85,8 @@
             self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
         else:
             self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+            
+        self.prefDialog.setExternalEditorPath(str(settings.value("Preferences/externalEditorPath").toString()))
         
         self.moduleDirectoryViewWin.modulesPath = self.prefDialog.moduleCfgPath.replace("modules.cfg", "")
         
@@ -210,7 +212,7 @@
         self.actionModuleDirView = self.createAction("&Directory Explorer",  self.toggleModuleDirView,  "Alt+D",  "view_tree.png",  "Module Directory Explorer",  False)
         self.actionModuleDirView.setObjectName("actionDirectoryExplorer")
         
-        self.actionPreferences = self.createAction("&Preferences",  self.togglePreferencesWindow,  "Alt+P",  "configure.png",  "Lockenwickler Preferences",  False)
+        self.actionPreferences = self.createAction("&Preferences",  self.togglePreferencesWindow,  None,  "configure.png",  "Lockenwickler Preferences",  False)
         self.actionPreferences.setObjectName("actionPreferences")
 
         self.actionProperty_Window = self.createAction("Pr&operty Window",  self.togglePropertyWindow,  "Alt+P",  "unsortedlist1.png",  "Property Window")
@@ -543,7 +545,7 @@
             settings.setValue("Preferences/moduleCfgPath", QtCore.QVariant(self.prefDialog.lineEdit.text()))
             settings.setValue("MainWindow/Geometry",  QtCore.QVariant(self.saveGeometry()))
             settings.setValue("MainWIndow/DockWindows",  QtCore.QVariant(self.saveState()))
-            
+            settings.setValue("Preferences/externalEditorPath",  QtCore.QVariant(self.prefDialog.externalTextAppLineEdit.text()))
             #self.ogreRoot.shutdown()
         else:
             event.ignore()

Modified: rl/trunk/editors/Lockenwickler/src/ModuleDirectoryView.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleDirectoryView.py	2009-04-17 18:31:40 UTC (rev 4902)
+++ rl/trunk/editors/Lockenwickler/src/ModuleDirectoryView.py	2009-04-17 19:24:20 UTC (rev 4903)
@@ -40,6 +40,7 @@
         
         self.tree.setContextMenuPolicy(Qt.CustomContextMenu)        
         self.connect(self.tree, SIGNAL("customContextMenuRequested(const QPoint &)"), self.doMenu)
+        self.connect(self.tree, SIGNAL("doubleClicked(const QModelIndex &)"), self.onDoubleClicked)
         
         self.tree.setModel(self.model)
         self.tree.setWindowTitle("Module Dir View")
@@ -50,16 +51,31 @@
         
     def doMenu(self, point):
         menu = QMenu(self)
-        #item = self.tree.itemAt(point)
             
         action= self.createAction("Delete", self.onDelete, None, "editdelete.png")
         menu.addAction(action)
         
+        action= self.createAction("Refresh", self.model.refresh)
+        menu.addAction(action)
+        
+        
+        
         menu.exec_(QCursor.pos())
         #subprocess.Popen(PreferencesDialog.externalTextAppCmd)
-
+    
+    def onDoubleClicked(self, index):
+        if PreferencesDialog.externalTextAppCmd is not None:
+            fileInfo = self.model.fileInfo(index)
+            if not fileInfo.isDir():
+                fileName = str(fileInfo.fileName())
+                if fileName.endswith(".rb") or fileName.endswith(".material") or fileName.endswith(".xml"):
+                    subprocess.Popen([PreferencesDialog.externalTextAppCmd, str(fileInfo.filePath())])
+        
+    
     def onDelete(self):
-        print "delete"
+        fileInfo = self.model.fileInfo(self.tree.currentIndex())
+        os.remove(str(fileInfo.filePath()))
+        self.model.refresh()
         
     def getFilters(self, dir, list):
         for f in os.listdir(dir):
@@ -75,9 +91,6 @@
 #            self.getFilters(dir, nameFilters)
 
         self.tree.setRootIndex(self.model.index(self.modulesPath))
-
-    
-
         
     def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
         action = QAction(text, self)

Modified: rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2009-04-17 18:31:40 UTC (rev 4902)
+++ rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2009-04-17 19:24:20 UTC (rev 4903)
@@ -75,6 +75,9 @@
         PreferencesDialog.externalTextAppCmd = str(self.externalTextAppLineEdit.text())
         self.accept()
         
+    def setExternalEditorPath(self, path):
+        PreferencesDialog.externalTextAppCmd = path
+        self.externalTextAppLineEdit.setText(path)
         
     def setCfgPath(self, inPath):
         path = str(inPath)



From fusion2 at mail.berlios.de  Sun Apr 19 16:55:12 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Sun, 19 Apr 2009 16:55:12 +0200
Subject: [Dsa-hl-svn] r4904 - in rl/trunk/editors/Lockenwickler: . src ui
	files
Message-ID: <200904191455.n3JEtCXo016999@sheep.berlios.de>

Author: fusion2
Date: 2009-04-19 16:55:07 +0200 (Sun, 19 Apr 2009)
New Revision: 4904

Added:
   rl/trunk/editors/Lockenwickler/src/AddTriggerDialog.py
   rl/trunk/editors/Lockenwickler/src/GlobDirectoryWalker.py
   rl/trunk/editors/Lockenwickler/src/TriggerManager.py
   rl/trunk/editors/Lockenwickler/src/Ui_AddTriggerDialog.py
   rl/trunk/editors/Lockenwickler/ui files/AddTriggerDialog.ui
Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/src/GameObjectClass.py
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/ZoneManager.py
Log:
- startet work on adding triggers to zones
- added a generic directory walker


Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-04-17 19:24:20 UTC (rev 4903)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-04-19 14:55:07 UTC (rev 4904)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Project SYSTEM "Project-4.6.dtd">
 <!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-04-16, 19:30:12 -->
+<!-- Saved: 2009-04-19, 16:52:11 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <Project version="4.6">
   <Language>en</Language>
@@ -42,11 +42,20 @@
     <Source>src/ZoneManager.py</Source>
     <Source>src/GOGenericEditor.py</Source>
     <Source>src/ModuleDirectoryView.py</Source>
+    <Source>src/TriggerManager.py</Source>
+    <Source>src/GlobDirectoryWalker.py</Source>
+    <Source>ui files/Ui_GOPropertyEditorDialogINT.py</Source>
+    <Source>ui files/Ui_GOPropertyEditorDialogSTRING.py</Source>
+    <Source>ui files/Ui_NewModuleWizard.py</Source>
+    <Source>ui files/Ui_AddTriggerDialog.py</Source>
+    <Source>src/AddTriggerDialog.py</Source>
+    <Source>src/Ui_AddTriggerDialog.py</Source>
   </Sources>
   <Forms>
     <Form>ui files/GOPropertyEditorDialogINT.ui</Form>
     <Form>ui files/GOPropertyEditorDialogSTRING.ui</Form>
     <Form>ui files/NewModuleWizard.ui</Form>
+    <Form>ui files/AddTriggerDialog.ui</Form>
   </Forms>
   <Translations>
   </Translations>

Added: rl/trunk/editors/Lockenwickler/src/AddTriggerDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/AddTriggerDialog.py	2009-04-17 19:24:20 UTC (rev 4903)
+++ rl/trunk/editors/Lockenwickler/src/AddTriggerDialog.py	2009-04-19 14:55:07 UTC (rev 4904)
@@ -0,0 +1,32 @@
+# -*- coding: utf-8 -*-
+
+"""
+Module implementing AddTriggerDialog.
+"""
+
+from PyQt4.QtGui import QDialog
+from PyQt4.QtCore import pyqtSignature
+
+from Ui_AddTriggerDialog import Ui_Dialog
+
+class AddTriggerDialog(QDialog, Ui_Dialog):
+    def __init__(self, parent = None):
+
+        QDialog.__init__(self, parent)
+        self.setupUi(self)
+    
+    @pyqtSignature("QString")
+    def on_lineEdit_textChanged(self, p0):
+        """
+        Slot documentation goes here.
+        """
+        # TODO: not implemented yet
+        raise NotImplementedError
+    
+    @pyqtSignature("")
+    def on_pushButton_clicked(self):
+        """
+        Slot documentation goes here.
+        """
+        # TODO: not implemented yet
+        raise NotImplementedError

Modified: rl/trunk/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2009-04-17 19:24:20 UTC (rev 4903)
+++ rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2009-04-19 14:55:07 UTC (rev 4904)
@@ -1,4 +1,4 @@
- #################################################
+#################################################
 # This source file is part of Rastullahs Lockenwickler.
 # Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
 #
@@ -15,7 +15,7 @@
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
+#################################################
 
 #from elementtree.ElementTree import *
 from xml.etree.cElementTree import *
@@ -147,9 +147,44 @@
             rep.name = str(self.editor.nameEditBox.text())
             rep.type = str(self.editor.typeDropBox.currentText())
             
-            if rep.type == "STRING" or rep.type == "BOOL" or rep.type == "REAL" or rep.type == "INT":
+            if rep.type == "STRING":
                 rep.data = str(self.editor.dataEditBox.text())
-            
+            elif rep.type == "BOOL":
+                text = str(self.editor.dataEditBox.text())
+                if text == "True" or text == "1" or text == "true":
+                    rep.data = "True"
+                elif text == "False" or text == "0" or text == "false":
+                    rep.data = "False"
+                else:
+                    reply = QMessageBox.question(QApplication.focusWidget(), "Try again?", "Data is not a BOOL" , QMessageBox.Yes|QMessageBox.No)
+                    if reply == QMessageBox.Yes:
+                        self.addProperty(True)
+                        return
+                    elif reply == QMessageBox.No:
+                        return
+            elif rep.type == "REAL":
+                try:
+                     rep.data = str(float(self.editor.dataEditBox.text()))
+                except ValueError, e:
+                    reply = QMessageBox.question(QApplication.focusWidget(), "Try again?", "Data is not a REAL" , QMessageBox.Yes|QMessageBox.No)
+                    if reply == QMessageBox.Yes:
+                        self.addProperty(True)
+                        print "ValueError: " + str(e)
+                        return
+                    elif reply == QMessageBox.No:
+                        return
+            elif rep.type == "INT":
+                try:
+                     rep.data = str(int(self.editor.dataEditBox.text()))
+                except ValueError, e:
+                    reply = QMessageBox.question(QApplication.focusWidget(), "Try again?", "Data is not a INT" , QMessageBox.Yes|QMessageBox.No)
+                    if reply == QMessageBox.Yes:
+                        self.addProperty(True)
+                        print "ValueError: " + str(e)
+                        return
+                    elif reply == QMessageBox.No:
+                        return
+                
             if rep.name in self.propertieDict:
                 reply = QMessageBox.question(QApplication.focusWidget(), "Warning...", "Replace the existing property?" , QMessageBox.Yes|QMessageBox.No|QMessageBox.Cancel)
                 if reply == QMessageBox.Cancel:

Added: rl/trunk/editors/Lockenwickler/src/GlobDirectoryWalker.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GlobDirectoryWalker.py	2009-04-17 19:24:20 UTC (rev 4903)
+++ rl/trunk/editors/Lockenwickler/src/GlobDirectoryWalker.py	2009-04-19 14:55:07 UTC (rev 4904)
@@ -0,0 +1,35 @@
+#
+# adapted from os-path-walk-example-3.py
+
+import os
+import fnmatch
+
+class GlobDirectoryWalker:
+    # a forward iterator that traverses a directory tree
+
+    def __init__(self, directory, pattern="*"):
+        self.stack = [directory]
+        self.pattern = pattern
+        self.files = []
+        self.index = 0
+
+    def __getitem__(self, index):
+        while 1:
+            try:
+                file = self.files[self.index]
+                self.index = self.index + 1
+            except IndexError:
+                # pop next directory from stack
+                self.directory = self.stack.pop()
+                self.files = os.listdir(self.directory)
+                self.index = 0
+            else:
+                # got a filename
+                fullname = os.path.join(self.directory, file)
+                if os.path.isdir(fullname) and not os.path.islink(fullname):
+                    self.stack.append(fullname)
+                if fnmatch.fnmatch(file, self.pattern):
+                    return fullname
+
+#for file in GlobDirectoryWalker(".", "*.py"):
+#    print file

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-04-17 19:24:20 UTC (rev 4903)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2009-04-19 14:55:07 UTC (rev 4904)
@@ -1,4 +1,4 @@
- #################################################
+#################################################
 # This source file is part of Rastullahs Lockenwickler.
 # Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
 #
@@ -15,7 +15,7 @@
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
+#################################################
 
 import os
 import sys
@@ -40,7 +40,9 @@
 from MovePivot import *
 from PivotRenderQueueListener import *
 from ModuleDirectoryView import *
+from TriggerManager import *
 
+
 import OgreMainWindow
 import ogre.renderer.OGRE as og
 
@@ -69,6 +71,8 @@
         self.moduleManager.materialSelectionDialog = self.materialSelectionDialog
         self.moduleDirectoryViewWin = ModuleDirectoryView(self)
         
+        triggerManager = TriggerManager()
+        
         self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
 
         self.createDockWindows()

Modified: rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-17 19:24:20 UTC (rev 4903)
+++ rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-19 14:55:07 UTC (rev 4904)
@@ -1,4 +1,4 @@
- #################################################
+#################################################
 # This source file is part of Rastullahs Lockenwickler.
 # Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
 #
@@ -15,13 +15,15 @@
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
+#################################################
 
 import sys
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *
 import ogre.renderer.OGRE as og
 
+from ZoneManager import ZoneManager
+
 # get the light out of a light node
 def extractLight(node):
         i = 0
@@ -352,6 +354,11 @@
                 setActiveMapAction = QAction("Set Active",  self)
                 menu.addAction(setActiveMapAction)
                 self.connect(setActiveMapAction, SIGNAL("triggered()"), self.onSetActiveMap)
+            elif self.sceneTreeView.currentItem() is not None and str(self.sceneTreeView.currentItem().text(0)).startswith("Zone:"):
+                item = self.sceneTreeView.itemAt(point)
+                addTriggerAction = QAction("Add Trigger",  self)
+                menu.addAction(addTriggerAction)
+                self.connect(addTriggerAction, SIGNAL("triggered()"), self.onAddTriggerToZone)
                 
             deleteAction= QAction("Delete",  self)
             menu.addAction(deleteAction)
@@ -371,6 +378,10 @@
             
             menu.exec_(QCursor().pos())
     
+    def onAddTriggerToZone(self):
+        zoneName = str(self.sceneTreeView.currentItem().text(0)).replace("Zone: ", "")
+        ZoneManager.instance.getZone(zoneName).addTrigger()
+        
     def onOptions(self):
         dlg = ExplorerOptionsDlg(self.showLights, self.showGameObjects, self.showEntities, self.showZones, self.showZoneLights, self)
         if dlg.exec_():

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-04-17 19:24:20 UTC (rev 4903)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2009-04-19 14:55:07 UTC (rev 4904)
@@ -1,4 +1,4 @@
- #################################################
+#################################################
 # This source file is part of Rastullahs Lockenwickler.
 # Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
 #
@@ -15,7 +15,7 @@
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
+#################################################
 
 import sys
 import codecs
@@ -37,8 +37,8 @@
 from GameObjectClassManager import *
 from MyRaySceneQueryListener import *
 from ZoneManager import ZoneManager
+from TriggerManager import TriggerManager 
 
-
 # get the light out of a light node
 def extractLight(node):
         i = 0
@@ -875,6 +875,7 @@
                                 m2.load()
                                 self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
                                 self.materialSelectionDialog.scanDirForMaterials(m2.moduleRoot)
+                                TriggerManager.instance.addDirectory(m2.moduleRoot)
                                 self.mainModuledependencieList.append(m2)
                                 directories.append(m2.moduleRoot)
 #                self.progress.setProgress(4, "Loading " + moduleName)
@@ -883,10 +884,13 @@
                 self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
 #                self.progress.setProgress(8, "Scan for materials")
                 self.materialSelectionDialog.scanDirForMaterials(m.moduleRoot)
+                TriggerManager.instance.addDirectory(m.moduleRoot)
                 directories.append(m.moduleRoot)
                 self.mainModule = m
                 self.moduleExplorer.setCurrentModule(m)
                 self.moduleDirView.parseDirectory(directories)
+        
+        TriggerManager.instance.update()
                 
         if self.selectionBuffer is None:
             self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget("OgreMainWin"), self, self.zoneManager)
@@ -1375,8 +1379,6 @@
             actions.append(self.createAction("Add Property", so.entity.getUserObject().addProperty))
             self.playerStartGameObjectId = so.entity.getUserObject().inWorldId
             
-                
-            
         if self.onContextMenuCallback is not None:
             self.onContextMenuCallback(actions,  menus)
 

Added: rl/trunk/editors/Lockenwickler/src/TriggerManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/TriggerManager.py	2009-04-17 19:24:20 UTC (rev 4903)
+++ rl/trunk/editors/Lockenwickler/src/TriggerManager.py	2009-04-19 14:55:07 UTC (rev 4904)
@@ -0,0 +1,77 @@
+#################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+#################################################
+
+from os.path import isfile,  join
+from GlobDirectoryWalker import GlobDirectoryWalker
+
+class TriggerProperty():
+    def __init__(self, name, type, data):
+        self.name = name
+        self.type = type
+        self.data = data
+
+class Trigger():
+    def __init__(self, className, name):
+        self.className = className
+        self.name = name
+        self.properties = []
+        
+    def addProperty(self, name, type, data):
+        prop = TriggerProperty(name,  type, data)
+        self.properties.append(prop)
+        
+    def removeProperty(self, name):
+        for prop in self.properties:
+            if prop.name == name:
+                self.properties.remove(prop)
+                return
+        
+class TriggerManager():
+    instance = None
+    availableTriggers = []
+    
+    def __init__(self):
+        self.triggerInstances = ()
+        self.directories = []
+        
+        if TriggerManager.instance == None:
+            TriggerManager.instance = self
+        
+    def addDirectory(self, dir):
+        self.directories.append(dir)
+        
+        self.update()
+    
+    def createTrigger(self, className, name):
+        trigger = Trigger(className, name)
+        self.triggerInstances.append(trigger)
+        return trigger
+    
+    def update(self):
+        TriggerManager.availableTriggers = []
+        
+        for dir in self.directories:
+            for file in GlobDirectoryWalker(dir, "*.rb"):
+                f = open(file, "r")
+                for line in f:
+                    if line.startswith("class ") and "< Trigger" in line:
+                        split = line.split(" ")
+                        TriggerManager.availableTriggers.append(split[1])
+
+    

Added: rl/trunk/editors/Lockenwickler/src/Ui_AddTriggerDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Ui_AddTriggerDialog.py	2009-04-17 19:24:20 UTC (rev 4903)
+++ rl/trunk/editors/Lockenwickler/src/Ui_AddTriggerDialog.py	2009-04-19 14:55:07 UTC (rev 4904)
@@ -0,0 +1,76 @@
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file '/home/fusion/dev/ui files/AddTriggerDialog.ui'
+#
+# Created: Sun Apr 19 16:38:41 2009
+#      by: PyQt4 UI code generator 4.4.4
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_Dialog(object):
+    def setupUi(self, Dialog):
+        Dialog.setObjectName("Dialog")
+        Dialog.resize(354, 500)
+        self.gridLayout = QtGui.QGridLayout(Dialog)
+        self.gridLayout.setObjectName("gridLayout")
+        self.label_2 = QtGui.QLabel(Dialog)
+        self.label_2.setAlignment(QtCore.Qt.AlignCenter)
+        self.label_2.setObjectName("label_2")
+        self.gridLayout.addWidget(self.label_2, 2, 0, 1, 1)
+        self.lineEdit = QtGui.QLineEdit(Dialog)
+        self.lineEdit.setObjectName("lineEdit")
+        self.gridLayout.addWidget(self.lineEdit, 3, 0, 1, 1)
+        self.label_3 = QtGui.QLabel(Dialog)
+        self.label_3.setAlignment(QtCore.Qt.AlignCenter)
+        self.label_3.setObjectName("label_3")
+        self.gridLayout.addWidget(self.label_3, 4, 0, 1, 1)
+        self.pushButton = QtGui.QPushButton(Dialog)
+        self.pushButton.setLayoutDirection(QtCore.Qt.LeftToRight)
+        self.pushButton.setObjectName("pushButton")
+        self.gridLayout.addWidget(self.pushButton, 5, 0, 1, 1)
+        self.listView = QtGui.QListView(Dialog)
+        self.listView.setObjectName("listView")
+        self.gridLayout.addWidget(self.listView, 6, 0, 1, 1)
+        self.buttonBox = QtGui.QDialogButtonBox(Dialog)
+        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
+        self.buttonBox.setObjectName("buttonBox")
+        self.gridLayout.addWidget(self.buttonBox, 7, 0, 1, 1)
+        self.comboBox = QtGui.QComboBox(Dialog)
+        self.comboBox.setObjectName("comboBox")
+        self.gridLayout.addWidget(self.comboBox, 1, 0, 1, 1)
+        self.label = QtGui.QLabel(Dialog)
+        self.label.setAlignment(QtCore.Qt.AlignCenter)
+        self.label.setObjectName("label")
+        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
+        self.label_2.setBuddy(self.lineEdit)
+        self.label_3.setBuddy(self.pushButton)
+        self.label.setBuddy(self.comboBox)
+
+        self.retranslateUi(Dialog)
+        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL("accepted()"), Dialog.accept)
+        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL("rejected()"), Dialog.reject)
+        QtCore.QMetaObject.connectSlotsByName(Dialog)
+        Dialog.setTabOrder(self.comboBox, self.lineEdit)
+        Dialog.setTabOrder(self.lineEdit, self.pushButton)
+        Dialog.setTabOrder(self.pushButton, self.listView)
+        Dialog.setTabOrder(self.listView, self.buttonBox)
+
+    def retranslateUi(self, Dialog):
+        Dialog.setWindowTitle(QtGui.QApplication.translate("Dialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
+        self.label_2.setText(QtGui.QApplication.translate("Dialog", "Identifier Name", None, QtGui.QApplication.UnicodeUTF8))
+        self.label_3.setText(QtGui.QApplication.translate("Dialog", "Properties", None, QtGui.QApplication.UnicodeUTF8))
+        self.pushButton.setText(QtGui.QApplication.translate("Dialog", "Add Property", None, QtGui.QApplication.UnicodeUTF8))
+        self.label.setText(QtGui.QApplication.translate("Dialog", "ClassName", None, QtGui.QApplication.UnicodeUTF8))
+
+
+if __name__ == "__main__":
+    import sys
+    app = QtGui.QApplication(sys.argv)
+    Dialog = QtGui.QDialog()
+    ui = Ui_Dialog()
+    ui.setupUi(Dialog)
+    Dialog.show()
+    sys.exit(app.exec_())
+

Modified: rl/trunk/editors/Lockenwickler/src/ZoneManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ZoneManager.py	2009-04-17 19:24:20 UTC (rev 4903)
+++ rl/trunk/editors/Lockenwickler/src/ZoneManager.py	2009-04-19 14:55:07 UTC (rev 4904)
@@ -1,363 +1,377 @@
-#################################################
-# This source file is part of Rastullahs Lockenwickler.
-# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
-
-import functools
-import xml.etree.cElementTree as xml
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
- 
-import ogre.renderer.OGRE as og
- 
-from ModuleExplorer import NameInputDlg
- 
-#                <zone name="Testzone">
-#                        <area type="sphere">
-#                                <position x="-10" y="0" z="-5"/>
-#                                <scale x="6" y="6" z="6"/>
-#                                <transition_distance>0.5</transition_distance>
-#                        </area>
-#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
-#                                <position x="25" y="0" z="-50"/>
-#                                <transition_distance>0.5</transition_distance>
-#                        </area>
-#                        <area type="sphere" subtract="true">
-#                                <position x="-11" y="0" z="-4"/>
-#                                <scale x="2" y="2" z="2"/>
-#                        </area>
-#                        <light name="red pointlight"/>
-#                        <light name="green spotlight"/>
-#                        <sound name="ruchin001.ogg"/>
-#                        <trigger name="test" classname="TestTrigger">
-#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
-#                        </trigger>
-#                </zone>
- 
-class Area(og.UserDefinedObject):
-    def __init__(self,sceneManager, type, parentZone, id, position, orientation, scale, meshFile = None, transitiondistance = "0.5", subtract = False):
-        og.UserDefinedObject.__init__(self)
-        self.type = type
-        self.parentZone = parentZone
-        if not parentZone:
-           raise Exception("No parentZone")
-
-        self.id = id # editor internal id for entity and node creation
-        self.areaNode = parentZone.zoneNode.createChildSceneNode("area_" + parentZone.name + " " + str(id))
-        self.meshFile = meshFile
-        self.areaEntity = None
-        self.transitiondistance = transitiondistance
-        self.__subtract = subtract
-        self.sceneManager = sceneManager
-        
-        if type == "box":
-            self.areaEntity = self.sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", "UniCube.mesh")
-        elif type == "sphere":
-            self.areaEntity = self.sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", "UniSphere.mesh")        
-        elif type == "ellipsoid":
-            print "not yet"
-        elif type == "capsule":
-            print "not yet"
-        elif type == "pyramid":
-            print "not yet"
-        elif type == "mesh":
-            try:
-                self.areaEntity = sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", self.meshFile)
-            except:
-                print "Mesh " + self.meshFile + " not found!"
-                return None
-                
-        self.areaEntity.setMaterialName("Lockenwickler_Area")
-        if self.__subtract:
-            self.areaEntity.setMaterialName("Lockenwickler_Area_Subtract")
-            
-        self.areaEntity.setUserObject(self)
-        self.areaNode.attachObject(self.areaEntity)
-        self.areaNode.setPosition(position)
-        if orientation is not None:
-            self.areaNode.setOrientation(orientation.w, orientation.x, orientation.y, orientation.z)
-        if scale is not None:
-            self.areaNode.setScale(scale)
-    
-    def __del__(self):
-        self.areaNode.detachAllObjects()
-        self.areaNode.getParent().removeAndDestroyChild(self.areaNode.getName())
-        self.sceneManager.destroyEntity(self.areaEntity.getName())
-    
-    def getsubtract(self):
-        return self.__subtract
-        
-    def setsubtract(self, val):
-        if not val:
-            self.areaEntity.setMaterialName("Lockenwickler_Area")
-        else:
-            self.areaEntity.setMaterialName("Lockenwickler_Area_Subtract")
-        
-        self.__subtract = val
-        
-    subtract = property(getsubtract, setsubtract)
-    
-class Zone():
-    def __init__(self,sceneManager, map, name):
-        self.map = map
-        self.name = name
-        self.areaList = []
-        self.lightList = []
-        self.soundList = []
-        self.triggerList = []
-        self.areaCounter = 0
-        self.sceneManager = sceneManager
-        self.isHidden = False
-        
-        self.zoneNode =  self.sceneManager.getRootSceneNode().createChildSceneNode("zone_" + name + "_node")
-        
-    def addArea(self, type, position, orientation, scale, meshFile = None):
-        area = Area(self.sceneManager, type, self, self.areaCounter, position, orientation, scale, meshFile)
-        if area is not None:
-            self.areaList.append(area)
-            self.areaCounter = self.areaCounter + 1
-    
-    def deleteArea(self, area):
-        for a in self.areaList:
-            if a.id == area.id:
-                self.areaList.remove(a)
-                del a
-    
-    def hide(self):
-        self.sceneManager.getRootSceneNode().removeChild(self.zoneNode)
-        self.isHidden = True
-    
-    def show(self):
-        self.sceneManager.getRootSceneNode().addChild(self.zoneNode)
-        self.isHidden = False
-        
-        
-class ZoneManager():
-    def __init__(self, sceneManager):
-        self.currentMap = None
-        self.zoneList = []
-        self.menuList = []
-        self.entityUnderMouse = None
-        self.newAreaPosition = None
-        self.sceneManager = sceneManager
-        
-    def createZone(self, name):
-        if self.currentMap == None:
-            print "No map selected!"
-            return
-            
-        z = Zone(self.sceneManager, self.currentMap, name)
-        self.zoneList.append(z)
-        self.currentMap.zoneList.append(z)
-        return z
-        
-    def parseZonesFromXml(self, zoneXmlNode, map):
-        if zoneXmlNode is None:
-            return
-        
-        self.currentMap = map
-        
-        zoneNodes = zoneXmlNode.getiterator("zone")
-        for zone in zoneNodes:
-            zoneName = zone.attrib["name"]
-            z = self.createZone(zoneName)
-            
-            areaNodes = zone.getiterator("area")
-            for area in areaNodes:
-                type = area.attrib["type"]
-                meshFile = None
-                if type == "mesh":
-                    meshFile = area.attrib["meshfile"]
-                
-                pos = og.Vector3()
-                qw = qx = qy = qz = 0
-                scale = None
-                hasRotation = False
-                
-                transformations = area.getiterator()
-                for t in transformations:
-                    if t.tag == "position":
-                        posx = float(t.attrib["x"])
-                        posy = float(t.attrib["y"])
-                        posz = float(t.attrib["z"])
-                        pos = og.Vector3(posx, posy, posz)
-                    elif t.tag == "rotation":
-                        qw = float(t.attrib["qw"])
-                        qx = float(t.attrib["qx"])
-                        qy = float(t.attrib["qy"])
-                        qz = float(t.attrib["qz"])
-                        hasRotation = True
-                    elif type == "mesh" and t.tag == "scale":
-                        scalex = float(t.attrib["x"])
-                        scaley = float(t.attrib["y"])
-                        scalez = float(t.attrib["z"])
-                        scale = og.Vector3(scalex, scaley, scalez)
-                    elif t.tag == "size":
-                        scalex = float(t.attrib["x"])
-                        scaley = float(t.attrib["y"])
-                        scalez = float(t.attrib["z"])
-                        scale = og.Vector3(scalex, scaley, scalez)
-                
-                rot = None
-                if hasRotation:
-                    rot = og.Quaternion(qw, qx, qy, qz)
-                    
-                z.addArea(type, pos, rot, scale, meshFile)
-            
-            
-            lightNodes = zone.getiterator("light")
-            for light in lightNodes:
-                name = light.attrib["name"]
-                z.lightList.append(name)
-                
-            soundNodes = zone.getiterator("sound")
-            for sound in soundNodes:
-                name = sound.attrib["name"]
-                z.soundList.append(name)
-            
-
-    def saveZonesToXml(self, root, map):
-        if len(map.zoneList) == 0:
-            return
-        
-        rootZonesElem = xml.SubElement(root, "zones")
-        for zone in map.zoneList:
-            zoneElem = xml.SubElement(rootZonesElem, "zone")
-            zoneElem.attrib["name"] = zone.name
-            
-            for area in zone.areaList:
-                areaElem = xml.SubElement(zoneElem, "area")
-                areaElem.attrib["type"] = area.type
-                #print "Saving Zone: " + zone.name + " - Area " + str(area.id)
-                if area.type == "mesh" and area.meshFile is not None:
-                    areaElem.attrib["meshfile"] = area.meshFile
-                    
-                posElem = xml.SubElement(areaElem, "position")
-                posElem.attrib["x"] = str(area.areaNode.getPosition().x)
-                posElem.attrib["y"] = str(area.areaNode.getPosition().y)
-                posElem.attrib["z"] = str(area.areaNode.getPosition().z)
-                
-                rotElem = xml.SubElement(areaElem, "rotation")
-                rotElem.attrib["qw"] = str(area.areaNode.getOrientation().w)
-                rotElem.attrib["qx"] = str(area.areaNode.getOrientation().x)
-                rotElem.attrib["qy"] = str(area.areaNode.getOrientation().y)
-                rotElem.attrib["qz"] = str(area.areaNode.getOrientation().z)
-                
-                scaleElem = None
-                if area.type == "mesh":
-                    scaleElem = xml.SubElement(areaElem, "scale")
-                else:
-                    scaleElem = xml.SubElement(areaElem, "size")
-
-                scaleElem.attrib["x"] = str(area.areaNode.getScale().x)
-                scaleElem.attrib["y"] = str(area.areaNode.getScale().y)
-                scaleElem.attrib["z"] = str(area.areaNode.getScale().z)
-                
-            for lightName in zone.lightList:
-                lightElem = xml.SubElement(zoneElem, "light")
-                lightElem.attrib["name"] = str(lightName)
-            
-            for soundName in zone.soundList:
-                soundElem = xml.SubElement(zoneElem, "sound")
-                soundElem.attrib["name"] = str(soundName)
-                
-    def deleteArea(self, area):
-        for z in self.zoneList:
-            for a in z.areaList:
-                if a.id == area.id:
-                    z.deleteArea(area)
-    
-    def getZoneMenu(self):
-        self.menuList = []
-        menu = QMenu("Add Area")
-        
-        for zone in self.zoneList:
-            m = QMenu(zone.name)
-            self.menuList.append(m)
-            menu.addMenu(m)
-            
-            boxAction = self.createAction("box", functools.partial(self.onZoneNameTriggered, zone, "box"))
-            self.menuList.append(boxAction)
-            m.addAction(boxAction)
-            
-            sphereAction = self.createAction("sphere", functools.partial(self.onZoneNameTriggered, zone, "sphere"))
-            self.menuList.append(sphereAction)
-            m.addAction(sphereAction)
-            
-            ellipsoidAction = self.createAction("ellipsoid", functools.partial(self.onZoneNameTriggered, zone, "ellipsoid"))
-            self.menuList.append(ellipsoidAction)
-            m.addAction(ellipsoidAction)
-            
-            capsuleAction = self.createAction("capsule", functools.partial(self.onZoneNameTriggered, zone, "capsule"))
-            self.menuList.append(capsuleAction)
-            m.addAction(capsuleAction)
-            
-            pyramidAction = self.createAction("pyramid", functools.partial(self.onZoneNameTriggered, zone, "pyramid"))
-            self.menuList.append(pyramidAction)
-            m.addAction(pyramidAction)
-            
-            meshAction = self.createAction("mesh", functools.partial(self.onZoneNameTriggered, zone, "mesh"))
-            self.menuList.append(meshAction)
-            m.addAction(meshAction)
-            
-        return menu
-        
-    def onZoneNameTriggered(self, zone, type):
-        if self.newAreaPosition is not None:
-            if type == "box":
-                zone.addArea("box", self.newAreaPosition, None, None)
-            elif type == "sphere":
-                zone.addArea("sphere", self.newAreaPosition, None, None)
-            elif type == "mesh":
-                dlg = NameInputDlg(QApplication.focusWidget())
-                resName = ""
-                if dlg.exec_():
-                    resName = str(dlg.nameInput.text())
-
-                zone.addArea("mesh", self.newAreaPosition, None, None, resName)
-                
-    def getZone(self, name):
-        for zone in self.zoneList:
-            if zone.name == name:
-                return zone
-        
-    def getZoneList(self):
-        list = []
-        for zone in self.zoneList:
-            list.append(zone.name)
-            
-        return list
-        
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
-        action = QAction(text, None)
-        if icon is not None:
-            action.setIcon(QIcon("media/icons/%s" % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            QWidget.connect(action, SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
-        
-        
-        
+#################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. http://www.team-pantheon.de
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+#################################################
+
+import functools
+import xml.etree.cElementTree as xml
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+ 
+import ogre.renderer.OGRE as og
+ 
+from ModuleExplorer import NameInputDlg
+from TriggerManager import TriggerManager
+from AddTriggerDialog import AddTriggerDialog
+
+#                <zone name="Testzone">
+#                        <area type="sphere">
+#                                <position x="-10" y="0" z="-5"/>
+#                                <scale x="6" y="6" z="6"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="mesh" meshfile="arc_UnbHaus_07.mesh">
+#                                <position x="25" y="0" z="-50"/>
+#                                <transition_distance>0.5</transition_distance>
+#                        </area>
+#                        <area type="sphere" subtract="true">
+#                                <position x="-11" y="0" z="-4"/>
+#                                <scale x="2" y="2" z="2"/>
+#                        </area>
+#                        <light name="red pointlight"/>
+#                        <light name="green spotlight"/>
+#                        <sound name="ruchin001.ogg"/>
+#                        <trigger name="test" classname="TestTrigger">
+#                                <property name="message" type="STRING" data="You triggered the dooms day device!" />
+#                        </trigger>
+#                </zone>
+ 
+       
+class Area(og.UserDefinedObject):
+    def __init__(self,sceneManager, type, parentZone, id, position, orientation, scale, meshFile = None, transitiondistance = "0.5", subtract = False):
+        og.UserDefinedObject.__init__(self)
+        self.type = type
+        self.parentZone = parentZone
+        if not parentZone:
+           raise Exception("No parentZone")
+
+        self.id = id # editor internal id for entity and node creation
+        self.areaNode = parentZone.zoneNode.createChildSceneNode("area_" + parentZone.name + " " + str(id))
+        self.meshFile = meshFile
+        self.areaEntity = None
+        self.transitiondistance = transitiondistance
+        self.__subtract = subtract
+        self.sceneManager = sceneManager
+        
+        if type == "box":
+            self.areaEntity = self.sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", "UniCube.mesh")
+        elif type == "sphere":
+            self.areaEntity = self.sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", "UniSphere.mesh")        
+        elif type == "ellipsoid":
+            print "not yet"
+        elif type == "capsule":
+            print "not yet"
+        elif type == "pyramid":
+            print "not yet"
+        elif type == "mesh":
+            try:
+                self.areaEntity = sceneManager.createEntity("area_" + parentZone.name + str(id) + "_entity", self.meshFile)
+            except:
+                print "Mesh " + self.meshFile + " not found!"
+                return None
+                
+        self.areaEntity.setMaterialName("Lockenwickler_Area")
+        if self.__subtract:
+            self.areaEntity.setMaterialName("Lockenwickler_Area_Subtract")
+            
+        self.areaEntity.setUserObject(self)
+        self.areaNode.attachObject(self.areaEntity)
+        self.areaNode.setPosition(position)
+        if orientation is not None:
+            self.areaNode.setOrientation(orientation.w, orientation.x, orientation.y, orientation.z)
+        if scale is not None:
+            self.areaNode.setScale(scale)
+    
+    def __del__(self):
+        self.areaNode.detachAllObjects()
+        self.areaNode.getParent().removeAndDestroyChild(self.areaNode.getName())
+        self.sceneManager.destroyEntity(self.areaEntity.getName())
+    
+    def getsubtract(self):
+        return self.__subtract
+        
+    def setsubtract(self, val):
+        if not val:
+            self.areaEntity.setMaterialName("Lockenwickler_Area")
+        else:
+            self.areaEntity.setMaterialName("Lockenwickler_Area_Subtract")
+        
+        self.__subtract = val
+        
+    subtract = property(getsubtract, setsubtract)
+    
+class Zone():
+    def __init__(self,sceneManager, map, name):
+        self.map = map
+        self.name = name
+        self.areaList = []
+        self.lightList = []
+        self.soundList = []
+        self.triggerList = []
+        self.areaCounter = 0
+        self.sceneManager = sceneManager
+        self.isHidden = False
+        
+        self.zoneNode =  self.sceneManager.getRootSceneNode().createChildSceneNode("zone_" + name + "_node")
+        
+    def addArea(self, type, position, orientation, scale, meshFile = None):
+        area = Area(self.sceneManager, type, self, self.areaCounter, position, orientation, scale, meshFile)
+        if area is not None:
+            self.areaList.append(area)
+            self.areaCounter = self.areaCounter + 1
+    
+    def deleteArea(self, area):
+        for a in self.areaList:
+            if a.id == area.id:
+                self.areaList.remove(a)
+                del a
+    
+    def addTrigger(self):
+        dlg = AddTriggerDialog()
+        dlg.exec_(QCursor.pos())
+    
+    def hide(self):
+        self.sceneManager.getRootSceneNode().removeChild(self.zoneNode)
+        self.isHidden = True
+    
+    def show(self):
+        self.sceneManager.getRootSceneNode().addChild(self.zoneNode)
+        self.isHidden = False
+        
+        
+class ZoneManager():
+    instance = None
+    
+    def __init__(self, sceneManager):
+        if ZoneManager.instance == None:
+            ZoneManager.instance = self
+        
+            self.currentMap = None
+            self.zoneList = []
+            self.menuList = []
+            self.entityUnderMouse = None
+            self.newAreaPosition = None
+            self.sceneManager = sceneManager
+        
+        
+        
+    def createZone(self, name):
+        if self.currentMap == None:
+            print "No map selected!"
+            return
+            
+        z = Zone(self.sceneManager, self.currentMap, name)
+        self.zoneList.append(z)
+        self.currentMap.zoneList.append(z)
+        return z
+        
+    def parseZonesFromXml(self, zoneXmlNode, map):
+        if zoneXmlNode is None:
+            return
+        
+        self.currentMap = map
+        
+        zoneNodes = zoneXmlNode.getiterator("zone")
+        for zone in zoneNodes:
+            zoneName = zone.attrib["name"]
+            z = self.createZone(zoneName)
+            
+            areaNodes = zone.getiterator("area")
+            for area in areaNodes:
+                type = area.attrib["type"]
+                meshFile = None
+                if type == "mesh":
+                    meshFile = area.attrib["meshfile"]
+                
+                pos = og.Vector3()
+                qw = qx = qy = qz = 0
+                scale = None
+                hasRotation = False
+                
+                transformations = area.getiterator()
+                for t in transformations:
+                    if t.tag == "position":
+                        posx = float(t.attrib["x"])
+                        posy = float(t.attrib["y"])
+                        posz = float(t.attrib["z"])
+                        pos = og.Vector3(posx, posy, posz)
+                    elif t.tag == "rotation":
+                        qw = float(t.attrib["qw"])
+                        qx = float(t.attrib["qx"])
+                        qy = float(t.attrib["qy"])
+                        qz = float(t.attrib["qz"])
+                        hasRotation = True
+                    elif type == "mesh" and t.tag == "scale":
+                        scalex = float(t.attrib["x"])
+                        scaley = float(t.attrib["y"])
+                        scalez = float(t.attrib["z"])
+                        scale = og.Vector3(scalex, scaley, scalez)
+                    elif t.tag == "size":
+                        scalex = float(t.attrib["x"])
+                        scaley = float(t.attrib["y"])
+                        scalez = float(t.attrib["z"])
+                        scale = og.Vector3(scalex, scaley, scalez)
+                
+                rot = None
+                if hasRotation:
+                    rot = og.Quaternion(qw, qx, qy, qz)
+                    
+                z.addArea(type, pos, rot, scale, meshFile)
+            
+            
+            lightNodes = zone.getiterator("light")
+            for light in lightNodes:
+                name = light.attrib["name"]
+                z.lightList.append(name)
+                
+            soundNodes = zone.getiterator("sound")
+            for sound in soundNodes:
+                name = sound.attrib["name"]
+                z.soundList.append(name)
+            
+
+    def saveZonesToXml(self, root, map):
+        if len(map.zoneList) == 0:
+            return
+        
+        rootZonesElem = xml.SubElement(root, "zones")
+        for zone in map.zoneList:
+            zoneElem = xml.SubElement(rootZonesElem, "zone")
+            zoneElem.attrib["name"] = zone.name
+            
+            for area in zone.areaList:
+                areaElem = xml.SubElement(zoneElem, "area")
+                areaElem.attrib["type"] = area.type
+                #print "Saving Zone: " + zone.name + " - Area " + str(area.id)
+                if area.type == "mesh" and area.meshFile is not None:
+                    areaElem.attrib["meshfile"] = area.meshFile
+                    
+                posElem = xml.SubElement(areaElem, "position")
+                posElem.attrib["x"] = str(area.areaNode.getPosition().x)
+                posElem.attrib["y"] = str(area.areaNode.getPosition().y)
+                posElem.attrib["z"] = str(area.areaNode.getPosition().z)
+                
+                rotElem = xml.SubElement(areaElem, "rotation")
+                rotElem.attrib["qw"] = str(area.areaNode.getOrientation().w)
+                rotElem.attrib["qx"] = str(area.areaNode.getOrientation().x)
+                rotElem.attrib["qy"] = str(area.areaNode.getOrientation().y)
+                rotElem.attrib["qz"] = str(area.areaNode.getOrientation().z)
+                
+                scaleElem = None
+                if area.type == "mesh":
+                    scaleElem = xml.SubElement(areaElem, "scale")
+                else:
+                    scaleElem = xml.SubElement(areaElem, "size")
+
+                scaleElem.attrib["x"] = str(area.areaNode.getScale().x)
+                scaleElem.attrib["y"] = str(area.areaNode.getScale().y)
+                scaleElem.attrib["z"] = str(area.areaNode.getScale().z)
+                
+            for lightName in zone.lightList:
+                lightElem = xml.SubElement(zoneElem, "light")
+                lightElem.attrib["name"] = str(lightName)
+            
+            for soundName in zone.soundList:
+                soundElem = xml.SubElement(zoneElem, "sound")
+                soundElem.attrib["name"] = str(soundName)
+                
+    def deleteArea(self, area):
+        for z in self.zoneList:
+            for a in z.areaList:
+                if a.id == area.id:
+                    z.deleteArea(area)
+    
+    def getZoneMenu(self):
+        self.menuList = []
+        menu = QMenu("Add Area")
+        
+        for zone in self.zoneList:
+            m = QMenu(zone.name)
+            self.menuList.append(m)
+            menu.addMenu(m)
+            
+            boxAction = self.createAction("box", functools.partial(self.onZoneNameTriggered, zone, "box"))
+            self.menuList.append(boxAction)
+            m.addAction(boxAction)
+            
+            sphereAction = self.createAction("sphere", functools.partial(self.onZoneNameTriggered, zone, "sphere"))
+            self.menuList.append(sphereAction)
+            m.addAction(sphereAction)
+            
+            ellipsoidAction = self.createAction("ellipsoid", functools.partial(self.onZoneNameTriggered, zone, "ellipsoid"))
+            self.menuList.append(ellipsoidAction)
+            m.addAction(ellipsoidAction)
+            
+            capsuleAction = self.createAction("capsule", functools.partial(self.onZoneNameTriggered, zone, "capsule"))
+            self.menuList.append(capsuleAction)
+            m.addAction(capsuleAction)
+            
+            pyramidAction = self.createAction("pyramid", functools.partial(self.onZoneNameTriggered, zone, "pyramid"))
+            self.menuList.append(pyramidAction)
+            m.addAction(pyramidAction)
+            
+            meshAction = self.createAction("mesh", functools.partial(self.onZoneNameTriggered, zone, "mesh"))
+            self.menuList.append(meshAction)
+            m.addAction(meshAction)
+            
+        return menu
+        
+    def onZoneNameTriggered(self, zone, type):
+        if self.newAreaPosition is not None:
+            if type == "box":
+                zone.addArea("box", self.newAreaPosition, None, None)
+            elif type == "sphere":
+                zone.addArea("sphere", self.newAreaPosition, None, None)
+            elif type == "mesh":
+                dlg = NameInputDlg(QApplication.focusWidget())
+                resName = ""
+                if dlg.exec_():
+                    resName = str(dlg.nameInput.text())
+
+                zone.addArea("mesh", self.newAreaPosition, None, None, resName)
+                
+    def getZone(self, name):
+        for zone in self.zoneList:
+            if zone.name == name:
+                return zone
+        
+    def getZoneList(self):
+        list = []
+        for zone in self.zoneList:
+            list.append(zone.name)
+            
+        return list
+        
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QAction(text, None)
+        if icon is not None:
+            action.setIcon(QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            QWidget.connect(action, SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+        
+        
+        

Added: rl/trunk/editors/Lockenwickler/ui files/AddTriggerDialog.ui
===================================================================
--- rl/trunk/editors/Lockenwickler/ui files/AddTriggerDialog.ui	2009-04-17 19:24:20 UTC (rev 4903)
+++ rl/trunk/editors/Lockenwickler/ui files/AddTriggerDialog.ui	2009-04-19 14:55:07 UTC (rev 4904)
@@ -0,0 +1,125 @@
+<ui version="4.0" >
+ <class>Dialog</class>
+ <widget class="QDialog" name="Dialog" >
+  <property name="geometry" >
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>354</width>
+    <height>500</height>
+   </rect>
+  </property>
+  <property name="windowTitle" >
+   <string>Dialog</string>
+  </property>
+  <layout class="QGridLayout" name="gridLayout" >
+   <item row="2" column="0" >
+    <widget class="QLabel" name="label_2" >
+     <property name="text" >
+      <string>Identifier Name</string>
+     </property>
+     <property name="alignment" >
+      <set>Qt::AlignCenter</set>
+     </property>
+     <property name="buddy" >
+      <cstring>lineEdit</cstring>
+     </property>
+    </widget>
+   </item>
+   <item row="3" column="0" >
+    <widget class="QLineEdit" name="lineEdit" />
+   </item>
+   <item row="4" column="0" >
+    <widget class="QLabel" name="label_3" >
+     <property name="text" >
+      <string>Properties</string>
+     </property>
+     <property name="alignment" >
+      <set>Qt::AlignCenter</set>
+     </property>
+     <property name="buddy" >
+      <cstring>pushButton</cstring>
+     </property>
+    </widget>
+   </item>
+   <item row="5" column="0" >
+    <widget class="QPushButton" name="pushButton" >
+     <property name="layoutDirection" >
+      <enum>Qt::LeftToRight</enum>
+     </property>
+     <property name="text" >
+      <string>Add Property</string>
+     </property>
+    </widget>
+   </item>
+   <item row="6" column="0" >
+    <widget class="QListView" name="listView" />
+   </item>
+   <item row="7" column="0" >
+    <widget class="QDialogButtonBox" name="buttonBox" >
+     <property name="standardButtons" >
+      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
+     </property>
+    </widget>
+   </item>
+   <item row="1" column="0" >
+    <widget class="QComboBox" name="comboBox" />
+   </item>
+   <item row="0" column="0" >
+    <widget class="QLabel" name="label" >
+     <property name="text" >
+      <string>ClassName</string>
+     </property>
+     <property name="alignment" >
+      <set>Qt::AlignCenter</set>
+     </property>
+     <property name="buddy" >
+      <cstring>comboBox</cstring>
+     </property>
+    </widget>
+   </item>
+  </layout>
+ </widget>
+ <tabstops>
+  <tabstop>comboBox</tabstop>
+  <tabstop>lineEdit</tabstop>
+  <tabstop>pushButton</tabstop>
+  <tabstop>listView</tabstop>
+  <tabstop>buttonBox</tabstop>
+ </tabstops>
+ <resources/>
+ <connections>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>accepted()</signal>
+   <receiver>Dialog</receiver>
+   <slot>accept()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>301</x>
+     <y>469</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>329</x>
+     <y>478</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>buttonBox</sender>
+   <signal>rejected()</signal>
+   <receiver>Dialog</receiver>
+   <slot>reject()</slot>
+   <hints>
+    <hint type="sourcelabel" >
+     <x>208</x>
+     <y>470</y>
+    </hint>
+    <hint type="destinationlabel" >
+     <x>205</x>
+     <y>485</y>
+    </hint>
+   </hints>
+  </connection>
+ </connections>
+</ui>



From melven at mail.berlios.de  Tue Apr 21 00:43:42 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 21 Apr 2009 00:43:42 +0200
Subject: [Dsa-hl-svn] r4905 - in rl/trunk/engine: core core/include core/src
	script/src
Message-ID: <200904202243.n3KMhgnl016479@sheep.berlios.de>

Author: melven
Date: 2009-04-21 00:43:33 +0200 (Tue, 21 Apr 2009)
New Revision: 4905

Added:
   rl/trunk/engine/core/include/PhysicsCollisionFactory.h
   rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp
Modified:
   rl/trunk/engine/core/CMakeLists.txt
   rl/trunk/engine/core/include/PhysicsManager.h
   rl/trunk/engine/core/src/GameAreaTypes.cpp
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/trunk/engine/script/src/EntityNodeProcessor.cpp
   rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
Log:
-added rudimentary caching mechanism for tree-collisions
-still pending: caching of convex collisions and loading/saving (for caching purposes) of collisions


Modified: rl/trunk/engine/core/CMakeLists.txt
===================================================================
--- rl/trunk/engine/core/CMakeLists.txt	2009-04-19 14:55:07 UTC (rev 4904)
+++ rl/trunk/engine/core/CMakeLists.txt	2009-04-20 22:43:33 UTC (rev 4905)
@@ -49,6 +49,7 @@
 src/MovableText.cpp
 src/ParticleSystemObject.cpp
 src/PhysicsContactListener.cpp
+src/PhysicsCollisionFactory.cpp
 src/PhysicalThing.cpp
 src/PhysicsGenericContactCallback.cpp
 src/PhysicsManager.cpp

Added: rl/trunk/engine/core/include/PhysicsCollisionFactory.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsCollisionFactory.h	2009-04-19 14:55:07 UTC (rev 4904)
+++ rl/trunk/engine/core/include/PhysicsCollisionFactory.h	2009-04-20 22:43:33 UTC (rev 4905)
@@ -0,0 +1,309 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __PhysicsCollisionFactory_H__
+#define __PhysicsCollisionFactory_H__
+
+#include "CorePrerequisites.h"
+
+#include <map>
+
+#ifdef __APPLE__
+#   include <OgreNewt/OgreNewt.h>
+#else
+#   include <OgreNewt.h>
+#endif
+
+#include "CorePrerequisites.h"
+#include "CoreDefines.h"
+
+namespace rl {
+
+    /** Helper class for the PhysicsManager for creating collision primitives. Don't use this class directly to create
+     * collision primitives, use the PhysicsManager::createCollision functions instead.
+     * Additionally this class takes care about caching of collisions, loading collisions from files and saving them to
+     * a file. You don't have to care about loading or saving collisions, this is only done for caching purposes.
+    */
+    class PhysicsCollisionFactory
+    {
+    public:
+        //! destructor, releases the collisions from the collision cache
+        ~PhysicsCollisionFactory();
+
+        /** creates a collision primitive for OgreNewt from an Ogre::Entity.
+		 * The collision primitive created has got a basic orientation which can be influenced by
+		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
+		 * calculated according to the size and type of collision primitiv.
+         * Whenever any of the parameters is a null pointer, it is ignored.
+         * The created collision primitive gets cached for the given mesh,
+         * so whenever an other entity with the same mesh tries to fetch
+         * a collision primitive here, then it gets back the already existing
+         * one (no need to duplicate).
+         * 
+         * Scaling should be implemented through attaching to a scene node.
+         * if that is not the case, we'll have to fix OgreNewt ...
+		 * @param entity gives the mesh entity that needs a collision primitive
+		 * @param geomType specifies the type of collision primitiv to create.
+		 * @param animName gives the name of the currently set animation (this is used in the collisionscache
+		 * @param offset gives the offset of the coordinate system of the coll. primitiv,
+         *        it is relative to the standard offset (center of the aabb of an entity for simple collision types)
+		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
+         * @param mass gives the mass of the collision primitive used for calculating the inertia
+		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
+		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
+         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
+         *                the new collision is not added to the cache
+		*/
+        OgreNewt::CollisionPtr createCollisionFromEntity(
+            Ogre::Entity* entity,
+            const GeometryType& geomType,
+            const Ogre::String& animName,
+			const Ogre::Vector3 &offset,
+			const Ogre::Quaternion &orientation,
+            const Ogre::Real Mass,
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass,
+            bool nocache);
+
+        /** creates a collision primitive for OgreNewt.
+		 * The collision primitive created has got a basic orientation which can be influenced by
+		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
+		 * calculated according to the size and type of collision primitiv.
+         * Whenever any of the parameters is a null pointer, it is ignored.
+         * The created collision primitive gets cached for the given aabb,
+         * so whenever an other aabb with the same name tries to fetch
+         * a collision primitive here, then it gets back the already existing
+         * one (no need to duplicate). There's no difference between Collisions created through an aabb or through
+         * the entity in the cache. In order to supply a support for 'scaling' the size of the cached collision is
+         * checked.
+         * Since no entity is given several physical collision primitives are not
+         * possible (convexhull, tree, etc.)
+         * // no scaling at the moment, the correct scale must be given (OgreNewt cannot scale a collision, this is a limitation
+         * // of newton. It is only possible to 'scale' a convex collision by created a ConvexHullModifier (a new collision,
+         * // that uses the old one and applies transformation through a matrix), so for aabbs (-> convex collisions) a scale
+         * // that udpates with the scale of the node could be implemented, but as this would be different for treecollisions,
+         * // it is better to create a collision with the correct scale...
+         * // "Scaling should be implemented through attaching to a scene node.
+         * // if that is not the case, we'll have to fix OgreNewt ..."
+         * @param name gives the name of the AxisAlignedBox
+		 * @param aabb AxisAlignedBox that contains the extents for the collision primitive to be created
+		 * @param geomType specifies the type of collision primitiv to create.
+		 * @param offset gives the offset of the coordinate system of the coll. primitiv, it is relative to the standard offset (center of the aabb)
+		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
+         * @param mass gives the mass of the collision primitive used for calculating the inertia
+		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
+		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
+         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
+         *                the new collision is not added to the cache
+		*/
+        OgreNewt::CollisionPtr createCollisionFromAABB(
+            const Ogre::String& name,
+            const Ogre::AxisAlignedBox& aabb,
+            const GeometryType& geomType,
+			const Ogre::Vector3 &offset,
+			const Ogre::Quaternion &orientation,
+            const Ogre::Real Mass,
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass,
+            bool nocache);
+
+        /// clear the collision cache
+        void clearCollisionCache();
+
+    protected:
+        /** checks if the specified size is ok for OgreNewt
+         * @param aabb check the aabb's size
+         */
+        bool checkSize(const Ogre::AxisAlignedBox& aabb) const;
+
+        /** corrects the specified size if it is not ok for OgreNewt
+         * @param aabb correct the aabb's size
+         */
+        void correctSize(Ogre::AxisAlignedBox& aabb);
+
+        /** creates a box collision primitive with offset at middle of bottom layer.
+         * It's actually a convenience function used by both createCollision functions.
+         * @param aabb gives the axis aligned dimension to create the primitive for.
+         * @param offset when not null, specifies a different offset than the standard.
+         * @param orientation when not null, specifies the euler angle of orientation.
+         */
+        OgreNewt::ConvexCollisionPtr createBox(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3 &offset,
+            const Ogre::Quaternion &orientation);
+
+        /** creates a pyramid collision primitive with offset at middle of bottom layer.
+         * It's actually a convenience function used by both createCollision functions.
+         * @param aabb gives the axis aligned dimension to create the primitive for.
+         * @param offset when not null, specifies a different offset than the standard.
+         * @param orientation when not null, specifies the euler angle of orientation.
+         */
+        OgreNewt::ConvexCollisionPtr createPyramid(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3 &offset,
+            const Ogre::Quaternion &orientation);
+
+        /** creates a sphere collision primitive with offset at middle of bottom layer.
+         * It's actually a convenience function used by both createCollision functions.
+         * @param aabb gives the axis aligned dimension to create the primitive for.
+         * @param offset when not null, specifies a different offset than the standard.
+         * @param orientation when not null, specifies the euler angle of orientation.
+         */
+        OgreNewt::ConvexCollisionPtr createSphere(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3 &offset,
+            const Ogre::Quaternion &orientation);
+
+        /** creates a ellipsoid collision primitive with offset at middle of bottom layer.
+         * It's actually a convenience function used by both createCollision functions.
+         * @param aabb gives the axis aligned dimension to create the primitive for.
+         * @param offset when not null, specifies a different offset than the standard.
+         * @param orientation when not null, specifies the euler angle of orientation.
+         */
+        OgreNewt::ConvexCollisionPtr createEllipsoid(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3 &offset,
+            const Ogre::Quaternion &orientation);
+
+        /** creates a capsule collision primitive with offset at middle of bottom layer.
+         * It's actually a convenience function used by both createCollision functions.
+         * @param aabb gives the axis aligned dimension to create the primitive for.
+         * @param offset when not null, specifies a different offset than the standard.
+         * @param orientation when not null, specifies the euler angle of orientation.
+         */
+        OgreNewt::ConvexCollisionPtr createCapsule(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3 &offset,
+            const Ogre::Quaternion &orientation);
+
+        /** creates a convex-hull collision primitive with offset at middle of bottom layer.
+         * It's actually a convenience function used by createCollisionFromEntity
+         * @param entity the entity for which a convexhull should be created, if it is attached to
+         *               a node the scale of the node is used (see OgreNewt)
+         * @param offset when not null, specifies a different offset than the standard.
+         * @param orientation when not null, specifies the euler angle of orientation.
+         */
+        OgreNewt::ConvexCollisionPtr createConvexHull(
+            Ogre::Entity* entity,
+            const Ogre::Vector3 &offset,
+            const Ogre::Quaternion &orientation);
+
+
+        //! class for caching convex collisions (box...convexhull), saves additionally the scale, so it can be rescaled if necessary
+        class ConvexCollisionCacheObject
+        {
+            public:
+                ConvexCollisionCacheObject() :
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+                    col(NULL),
+#endif
+                    scale(Ogre::Vector3::ZERO),
+                    offset(Ogre::Vector3::ZERO),
+                    orientation(Ogre::Quaternion::IDENTITY),
+                    inertia(Ogre::Vector3::ZERO),
+                    centerOfMass(Ogre::Vector3::ZERO),
+                    type(GT_NONE)
+                    {}
+                OgreNewt::ConvexCollisionPtr col;
+                Ogre::Vector3 scale;
+                Ogre::Vector3 offset;
+                Ogre::Quaternion orientation;
+                Ogre::Vector3 inertia, centerOfMass; // cached values
+                GeometryType type;
+        };
+
+        typedef std::map<Ogre::String, ConvexCollisionCacheObject> ConvexCollisionCacheMap;
+
+        //! cache for convex collisions
+        ConvexCollisionCacheMap mConvexCollisionsCache;
+
+        //! for using a string and a vector as key in a map... we should implement here a hash-function
+        class StringVector
+        {
+            public:
+                StringVector(const Ogre::String& str, const Ogre::Vector3& vec) : mStr(str)
+                {
+                    setVector(vec);
+                }
+                void setString(const Ogre::String& str) {mStr = str;}
+                void setVector(const Ogre::Vector3& vec)
+                {
+                    mVec = vec;
+                }
+                const Ogre::String& getString() const {return mStr;}
+                const Ogre::Vector3& getVector() const {return mVec;}
+
+                bool operator==(const StringVector& strVec) const
+                {
+                    if( mStr != strVec.mStr )
+                        return false;
+
+                    Ogre::Vector3 diff = mVec - strVec.mVec;
+                    if( abs(diff.x) > 0.01 )
+                        return false;
+                    if( abs(diff.y) > 0.01 )
+                        return false;
+                    if( abs(diff.z) > 0.01 )
+                        return false;
+
+                    return true;
+                }
+
+                bool operator<(const StringVector& strVec) const
+                {
+                    int strCompare = mStr.compare(strVec.mStr);
+                    if( strCompare == 0 ) // strings are the same
+                    {
+                        // compare vectors
+                        Ogre::Vector3 diff = mVec - strVec.mVec;
+                        if( diff.x < -0.01 )
+                            return true;
+                        if( diff.x > 0.01 )
+                            return false;
+                        if( diff.y < -0.01 )
+                            return true;
+                        if( diff.y > 0.01 )
+                            return false;
+                        if( diff.y < -0.01 )
+                            return true;
+
+                        return false;
+                    }
+                    
+                    return strCompare < 0;
+                }
+            private:
+                Ogre::String mStr;
+                Ogre::Vector3 mVec;
+        };
+
+        //! class for caching mesh collisions
+        class MeshCollisionCacheObject
+        {
+            public:
+                MeshCollisionCacheObject()
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+                    : col(NULL)
+#endif
+                    {}
+                OgreNewt::CollisionPtr col;
+        };
+
+
+        typedef std::map<StringVector, MeshCollisionCacheObject> MeshCollisionCacheMap;
+
+        //! cache for mesh collisions
+        MeshCollisionCacheMap mMeshCollisionsCache;
+    };
+}
+
+#endif
+

Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2009-04-19 14:55:07 UTC (rev 4904)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2009-04-20 22:43:33 UTC (rev 4905)
@@ -28,12 +28,6 @@
 #   include <OgreNewt.h>
 #endif
 
-namespace OgreNewt {
-    class Body;
-    class MaterialID;
-    class MaterialPair;
-    class World;
-}
 
 #include "CorePrerequisites.h"
 #include "CoreDefines.h"
@@ -212,8 +206,8 @@
 			Ogre::Entity* entity,
             const GeometryType& geomType = GT_NONE,
             const Ogre::String& animName = "",
-			const Ogre::Vector3* offset = NULL,
-			const Ogre::Quaternion* orientation = NULL,
+			const Ogre::Vector3 &offset = Ogre::Vector3::ZERO,
+			const Ogre::Quaternion &orientation = Ogre::Quaternion::IDENTITY,
             const Ogre::Real mass = 0,
             Ogre::Vector3* inertia = NULL,
             Ogre::Vector3* centerOfMass = NULL,
@@ -224,8 +218,8 @@
             const Ogre::String& name,
             const Ogre::AxisAlignedBox& aabb,
             const GeometryType& geomType = GT_NONE,
-            const Ogre::Vector3* offset = NULL,
-			const Ogre::Quaternion* orientation = NULL,
+			const Ogre::Vector3 &offset = Ogre::Vector3::ZERO,
+			const Ogre::Quaternion &orientation = Ogre::Quaternion::IDENTITY,
             const Ogre::Real mass = 0,
             Ogre::Vector3* inertia = NULL,
             Ogre::Vector3* centerOfMass = NULL,
@@ -316,253 +310,7 @@
 #endif
 
     };
-
-    class PhysicsCollisionFactory
-    {
-    public:
-        //! destructor, releases the collisions from the collision cache
-        ~PhysicsCollisionFactory();
-
-        /** creates a collision primitive for OgreNewt from an Ogre::Entity.
-		 * The collision primitive created has got a basic orientation which can be influenced by
-		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
-		 * calculated according to the size and type of collision primitiv.
-         * Whenever any of the parameters is a null pointer, it is ignored.
-         * The created collision primitive gets cached for the given mesh,
-         * so whenever an other entity with the same mesh tries to fetch
-         * a collision primitive here, then it gets back the already existing
-         * one (no need to duplicate).
-         * 
-         * Scaling should be implemented through attaching to a scene node.
-         * if that is not the case, we'll have to fix OgreNewt ...
-		 * @param entity gives the mesh entity that needs a collision primitive
-		 * @param geomType specifies the type of collision primitiv to create.
-		 * @param offset gives the offset of the coordinate system of the coll. primitiv
-		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
-         * @param mass gives the mass of the collision primitive used for calculating the inertia
-		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
-		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
-         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
-         *                the new collision is not added to the cache
-		*/
-        OgreNewt::CollisionPtr createCollisionFromEntity(
-            Ogre::Entity* entity,
-            const GeometryType& geomType,
-            const Ogre::Vector3* offset,
-            const Ogre::Quaternion* orientation,
-            const Ogre::Real Mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass,
-            bool nocache);
-
-        /** creates a collision primitive for OgreNewt.
-		 * The collision primitive created has got a basic orientation which can be influenced by
-		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
-		 * calculated according to the size and type of collision primitiv.
-         * Whenever any of the parameters is a null pointer, it is ignored.
-         * The created collision primitive gets cached for the given aabb,
-         * so whenever an other aabb with the same name tries to fetch
-         * a collision primitive here, then it gets back the already existing
-         * one (no need to duplicate). There's no difference between Collisions created through an aabb or through
-         * the entity in the cache. In order to supply a support for 'scaling' the size of the cached collision is
-         * checked.
-         * Since no entity is given several physical collision primitives are not
-         * possible (convexhull, tree, etc.)
-         * // no scaling at the moment, the correct scale must be given (OgreNewt cannot scale a collision, this is a limitation
-         * // of newton. It is only possible to 'scale' a convex collision by created a ConvexHullModifier (a new collision,
-         * // that uses the old one and applies transformation through a matrix), so for aabbs (-> convex collisions) a scale
-         * // that udpates with the scale of the node could be implemented, but as this would be different for treecollisions,
-         * // it is better to create a collision with the correct scale...
-         * // "Scaling should be implemented through attaching to a scene node.
-         * // if that is not the case, we'll have to fix OgreNewt ..."
-         * @param name gives the name of the AxisAlignedBox
-		 * @param aabb AxisAlignedBox that contains the extents for the collision primitive to be created
-		 * @param geomType specifies the type of collision primitiv to create.
-		 * @param offset gives the offset of the coordinate system of the coll. primitiv
-		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
-         * @param mass gives the mass of the collision primitive used for calculating the inertia
-		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
-		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
-         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
-         *                the new collision is not added to the cache
-		*/
-        OgreNewt::CollisionPtr createCollisionFromAABB(
-            const Ogre::String& name,
-            const Ogre::AxisAlignedBox& aabb,
-            const GeometryType& geomType,
-            const Ogre::Vector3* offset,
-            const Ogre::Quaternion* orientation,
-            const Ogre::Real Mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass,
-            bool nocache);
-
-        /// clear the collision cache
-        void clearCollisionCache();
-
-    protected:
-        /** checks if the specified size is ok for OgreNewt
-         * @param aabb check the aabb's size
-         */
-        bool checkSize(const Ogre::AxisAlignedBox& aabb) const;
-
-        /** corrects the specified size if it is not ok for OgreNewt
-         * @param aabb correct the aabb's size
-         */
-        void correctSize(Ogre::AxisAlignedBox& aabb);
-
-        /** creates a box collision primitive with offset at middle of bottom layer.
-         * It's actually a convenience function used by both createCollision functions.
-         * @param aabb gives the axis aligned dimension to create the primitive for.
-         * @param offset when not null, specifies a different offset than the standard.
-         * @param orientation when not null, specifies the euler angle of orientation.
-         */
-        OgreNewt::ConvexCollisionPtr createBox(const Ogre::AxisAlignedBox& aabb,
-            const Ogre::Vector3* offset,
-            const Ogre::Quaternion* orientation);
-
-        /** creates a pyramid collision primitive with offset at middle of bottom layer.
-         * It's actually a convenience function used by both createCollision functions.
-         * @param aabb gives the axis aligned dimension to create the primitive for.
-         * @param offset when not null, specifies a different offset than the standard.
-         * @param orientation when not null, specifies the euler angle of orientation.
-         */
-        OgreNewt::ConvexCollisionPtr createPyramid(const Ogre::AxisAlignedBox& aabb,
-            const Ogre::Vector3* offset,
-            const Ogre::Quaternion* orientation);
-
-        /** creates a sphere collision primitive with offset at middle of bottom layer.
-         * It's actually a convenience function used by both createCollision functions.
-         * @param aabb gives the axis aligned dimension to create the primitive for.
-         * @param offset when not null, specifies a different offset than the standard.
-         * @param orientation when not null, specifies the euler angle of orientation.
-         */
-        OgreNewt::ConvexCollisionPtr createSphere(const Ogre::AxisAlignedBox& aabb,
-            const Ogre::Vector3* offset,
-            const Ogre::Quaternion* orientation);
-
-        /** creates a ellipsoid collision primitive with offset at middle of bottom layer.
-         * It's actually a convenience function used by both createCollision functions.
-         * @param aabb gives the axis aligned dimension to create the primitive for.
-         * @param offset when not null, specifies a different offset than the standard.
-         * @param orientation when not null, specifies the euler angle of orientation.
-         */
-        OgreNewt::ConvexCollisionPtr createEllipsoid(const Ogre::AxisAlignedBox& aabb,
-            const Ogre::Vector3* offset,
-            const Ogre::Quaternion* orientation);
-
-        /** creates a capsule collision primitive with offset at middle of bottom layer.
-         * It's actually a convenience function used by both createCollision functions.
-         * @param aabb gives the axis aligned dimension to create the primitive for.
-         * @param offset when not null, specifies a different offset than the standard.
-         * @param orientation when not null, specifies the euler angle of orientation.
-         */
-        OgreNewt::ConvexCollisionPtr createCapsule(const Ogre::AxisAlignedBox& aabb,
-            const Ogre::Vector3* offset,
-            const Ogre::Quaternion* orientation);
-
-        /** creates a convex-hull collision primitive with offset at middle of bottom layer.
-         * It's actually a convenience function used by createCollisionFromEntity
-         * @param entity the entity for which a convexhull should be created, if it is attached to
-         *               a node the scale of the node is used (see OgreNewt)
-         * @param offset when not null, specifies a different offset than the standard.
-         * @param orientation when not null, specifies the euler angle of orientation.
-         */
-        OgreNewt::ConvexCollisionPtr createConvexHull(
-            Ogre::Entity* entity,
-            const Ogre::Vector3* offset,
-            const Ogre::Quaternion* orientation);
-
-
-        //! class for caching convex collisions (box...convexhull), saves additionally the scale, so it can be rescaled if necessary
-        class ConvexCollisionCacheObject
-        {
-            public:
-                ConvexCollisionCacheObject() :
-#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
-                    col(NULL),
-#endif
-                    scale(Ogre::Vector3::ZERO),
-                    type(GT_NONE)
-                    {}
-                OgreNewt::ConvexCollisionPtr col;
-                Ogre::Vector3 scale;
-                GeometryType type;
-        };
-
-        typedef std::map<Ogre::String, ConvexCollisionCacheObject> ConvexCollisionCacheMap;
-
-        //! cache for convex collisions
-        ConvexCollisionCacheMap mConvexCollisionsCache;
-
-        //! for using a string and a vector as key in a map... we should implement here a hash-function
-        class StringVector
-        {
-            public:
-                StringVector(const Ogre::String& str, const Ogre::Vector3& vec) : mStr(str)
-                {
-                    setVector(vec);
-                }
-                void setString(const Ogre::String& str) {mStr = str;}
-                void setVector(const Ogre::Vector3& vec)
-                {
-                    mVec = vec;
-                }
-                const Ogre::String& getString() const {return mStr;}
-                const Ogre::Vector3& getVector() const {return mVec;}
-
-                bool operator==(const StringVector& strVec) const
-                {
-                    if( mStr != strVec.mStr )
-                        return false;
-
-                    Ogre::Vector3 diff = mVec - strVec.mVec;
-                    if( abs(diff.x) > 0.01 )
-                        return false;
-                    if( abs(diff.y) > 0.01 )
-                        return false;
-                    if( abs(diff.z) > 0.01 )
-                        return false;
-
-                    return true;
-                }
-
-                bool operator<(const StringVector& strVec) const
-                {
-                    int strCompare = mStr.compare(strVec.mStr);
-                    if( strCompare == 0 ) // strings are the same
-                    {
-                        // compare vectors
-                        Ogre::Vector3 diff = mVec - strVec.mVec;
-                        if( diff.x < -0.01 )
-                            return true;
-                        if( diff.x > 0.01 )
-                            return false;
-                        if( diff.y < -0.01 )
-                            return true;
-                        if( diff.y > 0.01 )
-                            return false;
-                        if( diff.y < -0.01 )
-                            return true;
-
-                        return false;
-                    }
-                    
-                    return strCompare < 0;
-                }
-            private:
-                Ogre::String mStr;
-                Ogre::Vector3 mVec;
-        };
-
-        typedef std::map<StringVector, OgreNewt::CollisionPtr> MeshCollisionCacheMap;
-
-        //! cache for mesh collisions
-        MeshCollisionCacheMap mMeshCollisionsCache;
-
-
-
-    };
 }
 
 #endif
+

Modified: rl/trunk/engine/core/src/GameAreaTypes.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaTypes.cpp	2009-04-19 14:55:07 UTC (rev 4904)
+++ rl/trunk/engine/core/src/GameAreaTypes.cpp	2009-04-20 22:43:33 UTC (rev 4905)
@@ -238,7 +238,7 @@
         }
         OgreNewt::CollisionPtr col =
             PhysicsManager::getSingleton().createCollision(entity,
-            geomType, "", &offset, &orientation);
+            geomType, "", offset, orientation);
         mBody = new OgreNewt::Body(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             col);
@@ -263,7 +263,7 @@
     {
         OgreNewt::CollisionPtr col =
             PhysicsManager::getSingleton().createCollision(
-            "", aabb, geomType, &offset, &orientation, 0, NULL, NULL, true);
+            "", aabb, geomType, offset, orientation, 0, NULL, NULL, true);
         mBody = new OgreNewt::Body(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             col);

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2009-04-19 14:55:07 UTC (rev 4904)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2009-04-20 22:43:33 UTC (rev 4905)
@@ -289,8 +289,8 @@
                 entity,
                 mGeometryType,
                 "",
-                NULL,
-                NULL,
+                Vector3::ZERO,
+                Quaternion::IDENTITY,
                 0, NULL, NULL,
                 true); // don't cache
         if( collision )
@@ -515,8 +515,8 @@
                 entity,
                 mGeometryType,
                 "",
-                NULL,
-                NULL,
+                Vector3::ZERO,
+                Quaternion::IDENTITY,
                 mMass,
                 &inertia,
                 &centerOfMass);
@@ -528,8 +528,8 @@
                 "", // @todo: can we use a name here?
                 aabb,
                 mGeometryType,
-                NULL,
-                NULL,
+                Vector3::ZERO,
+                Quaternion::IDENTITY,
                 mMass,
                 &inertia,
                 &centerOfMass);

Added: rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp	2009-04-19 14:55:07 UTC (rev 4904)
+++ rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp	2009-04-20 22:43:33 UTC (rev 4905)
@@ -0,0 +1,440 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "Exception.h"
+#include "PhysicsCollisionFactory.h"
+#include "PhysicsManager.h"
+
+#ifdef __APPLE__
+#   include <Ogre/OgreMesh.h>
+#else
+#   include <OgreMesh.h>
+#endif
+
+
+
+using namespace std;
+using namespace OgreNewt;
+using namespace Ogre;
+
+
+namespace rl
+{
+    PhysicsCollisionFactory::~PhysicsCollisionFactory()
+    {
+        clearCollisionCache();
+    }
+
+    void PhysicsCollisionFactory::clearCollisionCache()
+    {
+        mMeshCollisionsCache.clear();
+        mConvexCollisionsCache.clear();
+    }
+
+    bool PhysicsCollisionFactory::checkSize(const Ogre::AxisAlignedBox& aabb) const
+    {
+        Ogre::Vector3 size = aabb.getSize();
+        if( size.x < PhysicsManager::NEWTON_GRID_WIDTH ||
+            size.y < PhysicsManager::NEWTON_GRID_WIDTH ||
+            size.z < PhysicsManager::NEWTON_GRID_WIDTH )
+            return false;
+        return true;
+    }
+
+    void PhysicsCollisionFactory::correctSize(Ogre::AxisAlignedBox& aabb)
+    {
+        Ogre::Vector3 size = aabb.getSize();
+        // correct size, log warning and fail back to box
+        if (size.x < PhysicsManager::NEWTON_GRID_WIDTH)
+            size.x = PhysicsManager::NEWTON_GRID_WIDTH;
+        if (size.y < PhysicsManager::NEWTON_GRID_WIDTH)
+            size.y = PhysicsManager::NEWTON_GRID_WIDTH;
+        if (size.z < PhysicsManager::NEWTON_GRID_WIDTH)
+            size.z = PhysicsManager::NEWTON_GRID_WIDTH;
+        LOG_MESSAGE(Logger::CORE, "Correcting collision primitiv size");
+        Ogre::Vector3 center = aabb.getCenter();
+        aabb.setMaximum(center + 0.5*size);
+        aabb.setMinimum(center - 0.5*size);
+    }
+
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(
+        const Ogre::String& name,
+        const Ogre::AxisAlignedBox& passedAabb,
+        const GeometryType& geomType,
+        const Ogre::Vector3 &offset,
+        const Ogre::Quaternion &orientation,
+        const Ogre::Real mass,
+        Ogre::Vector3* inertia,
+        Ogre::Vector3* centerOfMass,
+        bool nocache)
+    {
+        Ogre::AxisAlignedBox aabb(passedAabb);
+        // type for the collision primitiv (can change internally here)
+        bool forceBox (false);
+
+        // result value
+        ConvexCollisionPtr rval;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        rval = NULL;
+#endif
+
+        // size check (if object is too small, it falls back to a box primitiv
+        if (checkSize(aabb) == false )
+        {
+            correctSize(aabb);
+            LOG_WARNING(Logger::CORE,
+                " AABB is too small, using 'box' instead of primitiv '" +
+                PhysicsManager::convertGeometryTypeToString(geomType));
+            forceBox = true;
+        }
+
+        // check if the geometry type is supported for aabb
+        if (geomType == GT_CONVEXHULL ||
+            geomType == GT_MESH)
+        {
+            LOG_WARNING(Logger::CORE,
+                " the geometry type '"+
+                PhysicsManager::convertGeometryTypeToString(geomType)+
+                "' is not supported for aabb, fail back to box");
+            forceBox = true;
+        }
+
+        /* differentiate between the different collision primitives, because they all
+		   need different offset and probably different orientation values.
+		   Newton SDK is really nifty and helps here, because we can shift the origin
+		   of the coordinate system of the primitiv we create into any position we
+		   desire. Actually this is the bottom middle of our mesh - as the meshes are
+		   always constructed like that.
+	    */
+		if (geomType == GT_BOX || forceBox == true)
+        {
+			rval = createBox(aabb, offset, orientation);
+        }
+        else if (geomType == GT_PYRAMID)
+        {
+            rval = createPyramid(aabb, offset, orientation);
+        }
+        else if (geomType == GT_SPHERE)
+        {
+			rval = createSphere(aabb, offset, orientation);
+        }
+        else if (geomType == GT_ELLIPSOID)
+        {
+            rval = createEllipsoid(aabb, offset, orientation);
+        }
+		else if (geomType == GT_CAPSULE)
+		{
+			rval = createCapsule(aabb, offset, orientation);
+		}
+
+        // calculate inertia / centerOfMass if needed
+        if (inertia != NULL || centerOfMass != NULL )
+        {
+            Vector3 temp_inertia, temp_centerOfMass;
+            rval->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+            if( inertia != NULL )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass != NULL )
+                *centerOfMass = temp_centerOfMass;
+        }
+
+        return rval;
+    }
+
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromEntity(Ogre::Entity* entity,
+        const GeometryType& geomType,
+        const Ogre::String& animName,
+        const Ogre::Vector3 &offset,
+        const Ogre::Quaternion &orientation,
+        const Ogre::Real mass,
+        Ogre::Vector3* inertia,
+        Ogre::Vector3* centerOfMass,
+        bool nocache)
+    {
+        // bounding box of the mesh
+        Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
+        // apply scale if attached to a node (like in OgreNewt for convexhull)
+        if( entity->getParentNode() )
+            aabb.scale(entity->getParentNode()->getScale());
+
+        // type for the collision primitiv (can change internally here)
+        bool forceBox (false);
+
+        // result value
+        CollisionPtr rval;
+        ConvexCollisionPtr rvalAsConvexCollision; // store pointer to ConvexCollision, so we don't need to cast
+                                                  // this also indicates, that it is possible to calculate inertia/centerOfMass
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        rval = NULL;
+        rvalAsConvexCollision = NULL;
+#endif
+
+        // size check (if object is too small, it falls back to a box primitiv
+        if (checkSize(aabb) == false )
+        {
+            correctSize(aabb);
+            LOG_MESSAGE(Logger::CORE, " Entity '"+entity->getName()+
+                "' is too small, using 'box' instead of primitiv '"+
+                PhysicsManager::convertGeometryTypeToString(geomType));
+            forceBox = true;
+        }
+
+
+        MeshCollisionCacheMap::iterator meshCacheIt = mMeshCollisionsCache.end();
+        ConvexCollisionCacheMap::iterator convexCacheIt = mConvexCollisionsCache.end();
+
+        // check if we can reuse a cached collision
+        if( !nocache )
+        {
+            // use meshcollisionscache
+            if( geomType == GT_MESH && !forceBox )
+            {
+                Ogre::Vector3 scale = Ogre::Vector3::ZERO;
+                if( entity->getParentNode() )
+                    scale = entity->getParentNode()->getScale();
+
+                StringVector index(entity->getMesh()->getName() + animName, scale);
+                std::pair<MeshCollisionCacheMap::iterator,bool> iterBoolPair = mMeshCollisionsCache.insert(std::make_pair(index, MeshCollisionCacheObject()));
+                meshCacheIt = iterBoolPair.first;
+                if( !iterBoolPair.second )
+                {
+                    // there was already an element -- so we can reuse it
+
+                    LOG_DEBUG(Logger::CORE, "Reused collision for entity '" + entity->getName() + "' (mesh: '"
+                            + entity->getMesh()->getName() + "', animation: '" + animName + "').");
+                    rval = iterBoolPair.first->second.col;
+                }
+            }
+            // use convexcollisionscache
+            else
+            {
+            }
+        }
+
+		/* differentiate between the different collision primitives, because they all
+		   need different offset and probably different orientation values.
+		   Newton SDK is really nifty and helps here, because we can shift the origin
+		   of the coordinate system of the primitiv we create into any position we
+		   desire. Actually this is the bottom middle of our mesh - as the meshes are
+		   always constructed like that.
+	    */
+        if( !rval )
+        {
+            if (geomType == GT_BOX || forceBox == true)
+            {
+                rvalAsConvexCollision = createBox(aabb, offset, orientation);
+                rval = rvalAsConvexCollision;
+            }
+            else if (geomType == GT_PYRAMID)
+            {
+                rvalAsConvexCollision = createPyramid(aabb, offset, orientation);
+                rval = rvalAsConvexCollision;
+            }
+            else if (geomType == GT_SPHERE)
+            {
+                rvalAsConvexCollision = createSphere(aabb, offset, orientation);
+                rval = rvalAsConvexCollision;
+            }
+            else if (geomType == GT_ELLIPSOID)
+            {
+                rvalAsConvexCollision = createEllipsoid(aabb, offset, orientation);
+                rval = rvalAsConvexCollision;
+            }
+            else if (geomType == GT_CAPSULE)
+            {
+                rvalAsConvexCollision = createCapsule(aabb, offset, orientation);
+                rval = rvalAsConvexCollision;
+            }
+            else if (geomType == GT_CONVEXHULL)
+            {
+                rvalAsConvexCollision = createConvexHull(entity, offset, orientation);
+                rval = rvalAsConvexCollision;
+            }
+            else if (geomType == GT_MESH)
+            {
+                rval = CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
+                    PhysicsManager::getSingleton()._getNewtonWorld(),
+                    entity, true ));
+
+                if( meshCacheIt != mMeshCollisionsCache.end() )
+                    meshCacheIt->second.col = rval;
+            }
+            else
+            {
+                Throw(IllegalArgumentException, "unknown geometry type.");
+            }
+        }
+
+        if ( rval == NULL )
+        {
+            LOG_WARNING(Logger::CORE, " creating collision primitiv '"+
+                PhysicsManager::convertGeometryTypeToString(geomType)+"' for Entity '"+
+                entity->getName()+"' failed.");
+
+            // delete cacheobject
+            if( meshCacheIt != mMeshCollisionsCache.end() )
+            {
+                mMeshCollisionsCache.erase( meshCacheIt );
+            }
+            if( convexCacheIt != mConvexCollisionsCache.end() )
+            {
+                mConvexCollisionsCache.erase( convexCacheIt );
+            }
+        }
+        else
+        {
+            LOG_DEBUG(Logger::CORE, " collision primitiv '"+
+                PhysicsManager::convertGeometryTypeToString(geomType)+"' created for Entity '"+
+                entity->getName()+"'");
+        }
+
+        // calculate inertia / centerOfMass if requested
+        if( rvalAsConvexCollision )
+        {
+            if (inertia != NULL || centerOfMass != NULL )
+            {
+                Vector3 temp_inertia, temp_centerOfMass;
+                rvalAsConvexCollision->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+                if( inertia != NULL )
+                    *inertia = temp_inertia*mass;
+                if( centerOfMass != NULL )
+                    *centerOfMass = temp_centerOfMass;
+            }
+        }
+        else
+        {
+            if (inertia != NULL)
+                *inertia = Ogre::Vector3::ZERO;
+            if (centerOfMass != NULL)
+                *centerOfMass = Ogre::Vector3::ZERO;
+        }
+
+        return rval;
+    }
+
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createBox(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3 &offset,
+            const Ogre::Quaternion &orientation)
+    {
+        // offset relative to center
+        Ogre::Vector3 offsetInGlobalSpace = offset + aabb.getCenter();
+
+        // a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            aabb.getSize(), orientation, offsetInGlobalSpace));
+
+       return rval;
+    }
+
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createPyramid(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3 &offset,
+            const Ogre::Quaternion &orientation)
+    {
+        // offset relative to center
+        Ogre::Vector3 offsetInGlobalSpace = offset + aabb.getCenter();
+
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            aabb.getSize(), orientation, offsetInGlobalSpace));
+
+       return rval;
+    }
+
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createSphere(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3 &offset,
+            const Ogre::Quaternion &orientation)
+    {
+        // offset relative to center
+        Ogre::Vector3 offsetInGlobalSpace = offset + aabb.getCenter();
+
+        Ogre::Vector3 size = aabb.getSize();
+        // calculate the maximum radius needed to include 'everything'
+        double radius = std::max(size.x, std::max(size.y, size.z)) / 2.0;
+ 
+        // a sphere primitiv has got its coordinate system at its center, so shift it with radius
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            Vector3(radius, radius, radius), orientation, offsetInGlobalSpace));
+ 
+       return rval;
+    }
+
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createEllipsoid(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3 &offset,
+            const Ogre::Quaternion &orientation)
+    {
+        // offset relative to center
+        Ogre::Vector3 offsetInGlobalSpace = offset + aabb.getCenter();
+
+        Ogre::Vector3 size = aabb.getSize();
+        // set the size x/z values to the maximum
+        Vector3 s(size/2.0);
+        s.x = std::max(s.x, s.z);
+        s.z = s.x;
+
+        // an ellipsoid primitiv has got its coordinate system at its center, so shift it with radius
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            s, orientation, offsetInGlobalSpace));
+
+       return rval;
+    }
+
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createCapsule(const Ogre::AxisAlignedBox& aabb,
+            const Ogre::Vector3 &offset,
+            const Ogre::Quaternion &orientation)
+    {
+        // offset relative to center
+        Ogre::Vector3 offsetInGlobalSpace = offset + aabb.getCenter();
+        // @todo: fixme: this is a semi ugly fix - because the orientation should be set by the loader
+        //object_orientation.FromAngleAxis(Degree(90), Vector3::UNIT_Z);
+
+        Ogre::Vector3 size = aabb.getSize();
+
+        double radius = std::max(size.x, size.z) / 2.0;
+		double height = size.y;
+
+        // an capsule primitiv has got its coordinate system at its center, so shift it with radius
+        // additionally it is x axis aligned, so rotate it 90 degrees around z axis
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Capsule(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            radius, height, orientation, offsetInGlobalSpace));
+
+        return rval;
+    }
+
+
+
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createConvexHull(
+            Ogre::Entity* entity,
+            const Ogre::Vector3 &offset,
+            const Ogre::Quaternion &orientation)
+    {
+        Ogre::Vector3 offsetInGlobalSpace = offset;
+
+        // calculate the convex hull of the animated mesh
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::ConvexHull(
+                    PhysicsManager::getSingleton()._getNewtonWorld(),
+                    entity, orientation, offsetInGlobalSpace));
+
+        return rval;
+    }
+
+
+}
+

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2009-04-19 14:55:07 UTC (rev 4904)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2009-04-20 22:43:33 UTC (rev 4905)
@@ -23,6 +23,7 @@
 #include "Exception.h"
 #include "GameEventManager.h"
 #include "PhysicsController.h"
+#include "PhysicsCollisionFactory.h"
 #include "PhysicsGenericContactCallback.h"
 #include "PhysicalObject.h"
 #include "PhysicalThing.h"
@@ -517,12 +518,12 @@
 
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
         Ogre::Entity* entity, const GeometryType& geomType,
-		const Ogre::String& animName, const Ogre::Vector3* offset,
-        const Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
+		const Ogre::String& animName, const Ogre::Vector3 &offset,
+        const Ogre::Quaternion &orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
         Ogre::Vector3* centerOfMass, bool nocache)
     {
         return mPhysicsCollisionFactory->createCollisionFromEntity(
-                entity, geomType, offset, orientation, mass, inertia, centerOfMass, nocache );
+                entity, geomType, animName, offset, orientation, mass, inertia, centerOfMass, nocache );
 /*
         // problem here is that a mesh can have different animations with
         // different extents. Therefore we add the animName to the meshname
@@ -571,8 +572,8 @@
 
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
         const Ogre::String& name, const Ogre::AxisAlignedBox& aabb,
-        const GeometryType& geomType, const Ogre::Vector3* offset,
-        const Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
+        const GeometryType& geomType, const Ogre::Vector3 &offset,
+        const Ogre::Quaternion &orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
         Ogre::Vector3* centerOfMass, bool nocache)
     {
         return mPhysicsCollisionFactory->createCollisionFromAABB(
@@ -656,413 +657,5 @@
 			typestr = "convexhull";
 		return typestr;
 	}
-
-    PhysicsCollisionFactory::~PhysicsCollisionFactory()
-    {
-        clearCollisionCache();
-    }
-
-    void PhysicsCollisionFactory::clearCollisionCache()
-    {
-        mMeshCollisionsCache.clear();
-        mConvexCollisionsCache.clear();
-    }
-
-    bool PhysicsCollisionFactory::checkSize(const Ogre::AxisAlignedBox& aabb) const
-    {
-        Ogre::Vector3 size = aabb.getSize();
-        if( size.x < PhysicsManager::NEWTON_GRID_WIDTH ||
-            size.y < PhysicsManager::NEWTON_GRID_WIDTH ||
-            size.z < PhysicsManager::NEWTON_GRID_WIDTH )
-            return false;
-        return true;
-    }
-
-    void PhysicsCollisionFactory::correctSize(Ogre::AxisAlignedBox& aabb)
-    {
-        Ogre::Vector3 size = aabb.getSize();
-        // correct size, log warning and fail back to box
-        if (size.x < PhysicsManager::NEWTON_GRID_WIDTH)
-            size.x = PhysicsManager::NEWTON_GRID_WIDTH;
-        if (size.y < PhysicsManager::NEWTON_GRID_WIDTH)
-            size.y = PhysicsManager::NEWTON_GRID_WIDTH;
-        if (size.z < PhysicsManager::NEWTON_GRID_WIDTH)
-            size.z = PhysicsManager::NEWTON_GRID_WIDTH;
-        LOG_MESSAGE(Logger::CORE, "Correcting collision primitiv size");
-        Ogre::Vector3 center = aabb.getCenter();
-        aabb.setMaximum(center + 0.5*size);
-        aabb.setMinimum(center - 0.5*size);
-    }
-
-    /*
-    Ogre::Vector3 PhysicsCollisionFactory::calculateIntertia(const Ogre::Real& Mass, Ogre::Vector3* inertiaCoefficients)
-    {
-        return Ogre::Vector3(0,0,0);
-    }
-    */
-
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(
-        const Ogre::String& name,
-        const Ogre::AxisAlignedBox& passedAabb,
-        const GeometryType& geomType,
-        const Ogre::Vector3* offset,
-        const Ogre::Quaternion* orientation,
-        const Ogre::Real mass,
-        Ogre::Vector3* inertia,
-        Ogre::Vector3* centerOfMass,
-        bool nocache)
-    {
-        Ogre::AxisAlignedBox aabb(passedAabb);
-        // type for the collision primitiv (can change internally here)
-        bool forceBox (false);
-
-        // result value
-        ConvexCollisionPtr rval;
-#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
-        rval = NULL;
-#endif
-
-        // size check (if object is too small, it falls back to a box primitiv
-        if (checkSize(aabb) == false )
-        {
-            correctSize(aabb);
-            LOG_MESSAGE(Logger::CORE,
-                " AABB is too small, using 'box' instead of primitiv '" +
-                PhysicsManager::convertGeometryTypeToString(geomType));
-            forceBox = true;
-        }
-
-        // check if the geometry type is supported for aabb
-        if (geomType == GT_CONVEXHULL ||
-            geomType == GT_MESH)
-        {
-            LOG_MESSAGE(Logger::CORE,
-                " the geometry type '"+
-                PhysicsManager::convertGeometryTypeToString(geomType)+
-                "' is not supported for aabb, fail back to box");
-            forceBox = true;
-        }
-
-        /* differentiate between the different collision primitives, because they all
-		   need different offset and probably different orientation values.
-		   Newton SDK is really nifty and helps here, because we can shift the origin
-		   of the coordinate system of the primitiv we create into any position we
-		   desire. Actually this is the bottom middle of our mesh - as the meshes are
-		   always constructed like that.
-	    */
-		if (geomType == GT_BOX || forceBox == true)
-        {
-			rval = createBox(aabb, offset, orientation);
-        }
-        else if (geomType == GT_PYRAMID)
-        {
-            rval = createPyramid(aabb, offset, orientation);
-        }
-        else if (geomType == GT_SPHERE)
-        {
-			rval = createSphere(aabb, offset, orientation);
-        }
-        else if (geomType == GT_ELLIPSOID)
-        {
-            rval = createEllipsoid(aabb, offset, orientation);
-        }
-		else if (geomType == GT_CAPSULE)
-		{
-			rval = createCapsule(aabb, offset, orientation);
-		}
-
-        // calculate inertia / centerOfMass if needed
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-            rval->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-            if( inertia != NULL )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass != NULL )
-                *centerOfMass = temp_centerOfMass;
-        }
-
-        return rval;
-    }
-
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromEntity(Ogre::Entity* entity,
-        const GeometryType& geomType,
-        const Ogre::Vector3* offset,
-        const Ogre::Quaternion* orientation,
-        const Ogre::Real mass,
-        Ogre::Vector3* inertia,
-        Ogre::Vector3* centerOfMass,
-        bool nocache)
-    {
-        // bounding box of the mesh
-        Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
-        // apply scale if attached to a node (like in OgreNewt for convexhull)
-        if( entity->getParentNode() )
-            aabb.scale(entity->getParentNode()->getScale());
-
-        // type for the collision primitiv (can change internally here)
-        bool forceBox (false);
-
-        // result value
-        CollisionPtr rval;
-        ConvexCollisionPtr rvalAsConvexCollision; // store pointer to ConvexCollision, so we don't need to cast
-                                                  // this also indicates, that it is possible to calculate inertia/centerOfMass
-#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
-        rval = NULL;
-        rvalAsConvexCollision = NULL;
-#endif
-
-        // size check (if object is too small, it falls back to a box primitiv
-        if (checkSize(aabb) == false )
-        {
-            correctSize(aabb);
-            LOG_MESSAGE(Logger::CORE, " Entity '"+entity->getName()+
-                "' is too small, using 'box' instead of primitiv '"+
-                PhysicsManager::convertGeometryTypeToString(geomType));
-            forceBox = true;
-        }
-
-		/* differentiate between the different collision primitives, because they all
-		   need different offset and probably different orientation values.
-		   Newton SDK is really nifty and helps here, because we can shift the origin
-		   of the coordinate system of the primitiv we create into any position we
-		   desire. Actually this is the bottom middle of our mesh - as the meshes are
-		   always constructed like that.
-	    */
-		if (geomType == GT_BOX || forceBox == true)
-        {
-            rvalAsConvexCollision = createBox(aabb, offset, orientation);
-            rval = rvalAsConvexCollision;
-        }
-        else if (geomType == GT_PYRAMID)
-        {
-            rvalAsConvexCollision = createPyramid(aabb, offset, orientation);
-            rval = rvalAsConvexCollision;
-        }
-        else if (geomType == GT_SPHERE)
-        {
-            rvalAsConvexCollision = createSphere(aabb, offset, orientation);
-            rval = rvalAsConvexCollision;
-        }
-        else if (geomType == GT_ELLIPSOID)
-        {
-            rvalAsConvexCollision = createEllipsoid(aabb, offset, orientation);
-            rval = rvalAsConvexCollision;
-        }
-		else if (geomType == GT_CAPSULE)
-		{
-            rvalAsConvexCollision = createCapsule(aabb, offset, orientation);
-            rval = rvalAsConvexCollision;
-		}
-        else if (geomType == GT_CONVEXHULL)
-        {
-            rvalAsConvexCollision = createConvexHull(entity, offset, orientation);
-            rval = rvalAsConvexCollision;
-        }
-        else if (geomType == GT_MESH)
-        {
-            if (inertia != NULL)
-                *inertia = Ogre::Vector3::ZERO;
-            if (centerOfMass != NULL)
-                *centerOfMass = Ogre::Vector3::ZERO;
-
-            rval = CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
-                PhysicsManager::getSingleton()._getNewtonWorld(),
-                entity, true ));
-        }
-        else
-        {
-            Throw(IllegalArgumentException, "unknown geometry type.");
-        }
-
-        if ( rval == NULL )
-        {
-            LOG_DEBUG(Logger::CORE, " creating collision primitiv '"+
-                PhysicsManager::convertGeometryTypeToString(geomType)+"' for Entity '"+
-                entity->getName()+"' failed.");
-        }
-        else
-        {
-            LOG_DEBUG(Logger::CORE, " collision primitiv '"+
-                PhysicsManager::convertGeometryTypeToString(geomType)+"' created for Entity '"+
-                entity->getName()+"'");
-        }
-
-        // calculate inertia / centerOfMass if requested
-        if( rvalAsConvexCollision )
-        {
-            if (inertia != NULL || centerOfMass != NULL )
-            {
-                Vector3 temp_inertia, temp_centerOfMass;
-                rvalAsConvexCollision->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-                if( inertia != NULL )
-                    *inertia = temp_inertia*mass;
-                if( centerOfMass != NULL )
-                    *centerOfMass = temp_centerOfMass;
-            }
-        }
-
-        return rval;
-    }
-
-    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createBox(const Ogre::AxisAlignedBox& aabb,
-            const Ogre::Vector3* offset,
-            const Ogre::Quaternion* orientation)
-    {
-        // offset of the collision primitiv
-        Ogre::Vector3 object_offset( aabb.getCenter() );
-        // orientation of the collision primitiv
-		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
-
-        // set offset/orientation when they are null
-		if (! offset)
-			offset = &object_offset;
-		if (! orientation)
-			orientation = &object_orientation;
-
-        // a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
-        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
-            PhysicsManager::getSingleton()._getNewtonWorld(),
-            aabb.getSize(), *orientation, *offset));
-
-       return rval;
-    }
-
-    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createPyramid(const Ogre::AxisAlignedBox& aabb,
-            const Ogre::Vector3* offset,
-            const Ogre::Quaternion* orientation)
-    {
-        Ogre::Vector3 size = aabb.getSize();
-        // positional offset of the collision primitiv
-        Ogre::Vector3 object_offset(aabb.getCenter());
-        // orientation of the collision primitiv
-		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
-
-        // set offset/orientation when they are null
-		if (! offset)
-			offset = &object_offset;
-		if (! orientation)
-			orientation = &object_orientation;
-
-        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
-            PhysicsManager::getSingleton()._getNewtonWorld(),
-            size, *orientation, *offset));
-
-       return rval;
-    }
-
-    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createSphere(const Ogre::AxisAlignedBox& aabb,
-            const Ogre::Vector3* offset,
-            const Ogre::Quaternion* orientation)
-    {
-        Ogre::Vector3 size = aabb.getSize();
-        // calculate the maximum radius needed to include 'everything'
-        double radius = std::max(size.x, std::max(size.y, size.z)) / 2.0;
-        // positional offset of the collision primitiv
-        Ogre::Vector3 object_offset(aabb.getCenter());
-        //object_offset.y = aabb.getMinimum().y;
-        // orientation of the collision primitiv
-		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
-
-		// set offset/orientation when they are null
-		if (! offset)
-			offset = &object_offset;
-		if (! orientation)
-			orientation = &object_orientation;
- 
-        // a sphere primitiv has got its coordinate system at its center, so shift it with radius
-        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
-            PhysicsManager::getSingleton()._getNewtonWorld(),
-            Vector3(radius, radius, radius), *orientation, *offset));
- 
-       return rval;
-    }
-
-    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createEllipsoid(const Ogre::AxisAlignedBox& aabb,
-            const Ogre::Vector3* offset,
-            const Ogre::Quaternion* orientation)
-    {
-        Ogre::Vector3 size = aabb.getSize();
-        // set the size x/z values to the maximum
-        Vector3 s(size/2.0);
-        s.x = std::max(s.x, s.z);
-        s.z = s.x;
-        // positional offset of the collision primitiv
-		Ogre::Vector3 object_offset(aabb.getCenter());
-        // orientation of the collision primitiv
-		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
-
-		// set offset/orientation when they are null
-		if (! offset)
-			offset = &object_offset;
-		if (! orientation)
-			orientation = &object_orientation;
-
-        // an ellipsoid primitiv has got its coordinate system at its center, so shift it with radius
-        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
-            PhysicsManager::getSingleton()._getNewtonWorld(),
-            s, *orientation, *offset));
-
-       return rval;
-    }
-
-    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createCapsule(const Ogre::AxisAlignedBox& aabb,
-            const Ogre::Vector3* offset,
-            const Ogre::Quaternion* orientation)
-    {
-        Ogre::Vector3 size = aabb.getSize();
-        // positional offset of the collision primitiv
-		Ogre::Vector3 object_offset(aabb.getCenter());
-        // orientation of the collision primitiv
-		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
-        double radius = std::max(size.x, size.z) / 2.0;
-		double height = size.y;
-        // @todo: fixme: this is a semi ugly fix - because the orientation should be set by the loader
-        object_orientation.FromAngleAxis(Degree(90), Vector3::UNIT_Z);
-
-		// set offset/orientation when they are null
-		if (! offset)
-    		offset = &object_offset;
-		if (! orientation)
-			orientation = &object_orientation;
-
-
-        // an capsule primitiv has got its coordinate system at its center, so shift it with radius
-        // additionally it is x axis aligned, so rotate it 90 degrees around z axis
-        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Capsule(
-            PhysicsManager::getSingleton()._getNewtonWorld(),
-            radius, height, *orientation, *offset));
-
-
-        return rval;
-    }
-
-
-
-    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createConvexHull(
-            Ogre::Entity* entity,
-            const Ogre::Vector3* offset,
-            const Ogre::Quaternion* orientation)
-    {
-        // offset of the collision primitiv
-        Ogre::Vector3 object_offset( Ogre::Vector3::ZERO );
-        // orientation of the collision primitiv
-        Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
-
-        // set offset/orientation when they are null
-        if (! offset)
-            offset = &object_offset;
-        if (! orientation)
-            orientation = &object_orientation;
-
-        // calculate the convex hull of the animated mesh
-        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::ConvexHull(
-                    PhysicsManager::getSingleton()._getNewtonWorld(),
-                    entity, *orientation, *offset));
-
-        return rval;
-    }
-
-
 }
 

Modified: rl/trunk/engine/script/src/EntityNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2009-04-19 14:55:07 UTC (rev 4904)
+++ rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2009-04-20 22:43:33 UTC (rev 4905)
@@ -117,7 +117,6 @@
         }
 
         parentNode->attachObject(newEnt);
-        createCollision(newEnt, meshFile, getChildNamed(nodeElem, "physicsproxy"));
 
         DOMElement* scaleElem = getChildNamed(nodeElem, "scale");
         if (scaleElem != NULL)
@@ -125,6 +124,9 @@
             parentNode->scale(processVector3(scaleElem));
         }
 
+        // in order for the scale to work correctly the collision needs to be created after the scale was applied
+        createCollision(newEnt, meshFile, getChildNamed(nodeElem, "physicsproxy"));
+
 		AutoXMLCh animation("animation");
 		DOMNodeList* list = nodeElem->getElementsByTagName(animation.data());
 		for (XMLSize_t idx = 0; idx < list->getLength(); idx++)

Modified: rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-04-19 14:55:07 UTC (rev 4904)
+++ rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-04-20 22:43:33 UTC (rev 4905)
@@ -148,7 +148,7 @@
 			const Quaternion orientation(0,0,0,0);// = parentNode->getOrientation();
 			const Ogre::Vector3 pos = aab.getMinimum() * parentNode->getScale() + (size/2.0);
 
-            collision = PhysicsManager::getSingleton().createCollision(entity, GT_BOX, "", NULL, NULL, 0, NULL, NULL, true);
+            collision = PhysicsManager::getSingleton().createCollision(entity, GT_BOX, "", Vector3::ZERO, Quaternion::IDENTITY, 0, NULL, NULL, true);
 
 			if ( collision != NULL )
 			{



From melven at mail.berlios.de  Tue Apr 21 00:44:50 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Tue, 21 Apr 2009 00:44:50 +0200
Subject: [Dsa-hl-svn] r4906 - in modules/regressiontest: maps scripts
	scripts/maps
Message-ID: <200904202244.n3KMioYP016727@sheep.berlios.de>

Author: melven
Date: 2009-04-21 00:44:43 +0200 (Tue, 21 Apr 2009)
New Revision: 4906

Added:
   modules/regressiontest/maps/collisionscachetest.rlmap
   modules/regressiontest/scripts/CollisionsCacheTest.rb
Modified:
   modules/regressiontest/scripts/maps/regressiontest.rb
Log:
added test for caching of collisions


Added: modules/regressiontest/maps/collisionscachetest.rlmap
===================================================================
--- modules/regressiontest/maps/collisionscachetest.rlmap	2009-04-20 22:43:33 UTC (rev 4905)
+++ modules/regressiontest/maps/collisionscachetest.rlmap	2009-04-20 22:44:43 UTC (rev 4906)
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<rastullahmap formatVersion="0.4.0">
+  <nodes>
+    <entity name="zaun2" meshfile="zaun.mesh">
+      <position x="-62" y="0" z="-10"/>
+      <scale x="0.1" y="0.1" z="0.1"/>
+    </entity>
+    <entity name="zaun3" meshfile="zaun.mesh">
+      <position x="-62" y="3" z="-10"/>
+    </entity>
+    <entity name="zaun4" meshfile="zaun.mesh">
+      <position x="-62" y="5" z="-10"/>
+      <scale x="0.1" y="0.2" z="0.1"/>
+    </entity>
+    <entity name="zaun5" meshfile="zaun.mesh">
+      <position x="-62" y="6" z="-10"/>
+      <scale x="0.1" y="0.1" z="0.1"/>
+      <rotation qw="0.766" qx="0.0" qy="-0.642" qz="0.0" />
+    </entity>
+    <entity name="zaun6" meshfile="zaun.mesh">
+      <position x="-62" y="7" z="-10"/>
+      <scale x="0.1" y="0.1" z="0.1"/>
+    </entity>
+  </nodes>
+</rastullahmap>

Added: modules/regressiontest/scripts/CollisionsCacheTest.rb
===================================================================
--- modules/regressiontest/scripts/CollisionsCacheTest.rb	2009-04-20 22:43:33 UTC (rev 4905)
+++ modules/regressiontest/scripts/CollisionsCacheTest.rb	2009-04-20 22:44:43 UTC (rev 4906)
@@ -0,0 +1,7 @@
+require 'testcase.rb'
+
+class CollisionsCacheTest < TestCase
+    def execute()
+		MapLoader.new().loadMap("collisionscachetest.rlmap");
+	end
+end

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2009-04-20 22:43:33 UTC (rev 4905)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2009-04-20 22:44:43 UTC (rev 4906)
@@ -40,6 +40,7 @@
 require 'CombatTest.rb'
 require 'WalkJobTest.rb'
 require 'CharacterSelectionTest.rb'
+require 'CollisionsCacheTest.rb'
 
 class RegressionTestSuite
 	def initialize
@@ -79,6 +80,7 @@
 		runTest(CombatTest, [15, 0, 15])
   	runTest(FetchItemJobTest, [-15, 0, 15])
    runTest(CharacterSelectionTest, [-15, 0, -15])
+   runTest(CollisionsCacheTest, [62, 0, -10])
 
 		if @mErrors > 0
 		  MessageBox.showModal(



From fusion2 at mail.berlios.de  Tue Apr 21 19:49:03 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Tue, 21 Apr 2009 19:49:03 +0200
Subject: [Dsa-hl-svn] r4907 - in rl/trunk/editors/Lockenwickler: . src
Message-ID: <200904211749.n3LHn3Cs029102@sheep.berlios.de>

Author: fusion2
Date: 2009-04-21 19:49:01 +0200 (Tue, 21 Apr 2009)
New Revision: 4907

Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/src/AddTriggerDialog.py
   rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
   rl/trunk/editors/Lockenwickler/src/TriggerManager.py
   rl/trunk/editors/Lockenwickler/src/Ui_AddTriggerDialog.py
   rl/trunk/editors/Lockenwickler/src/ZoneManager.py
Log:
- more work on trigger support

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-04-20 22:44:43 UTC (rev 4906)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2009-04-21 17:49:01 UTC (rev 4907)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Project SYSTEM "Project-4.6.dtd">
 <!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2009-04-19, 16:52:11 -->
+<!-- Saved: 2009-04-19, 16:59:45 -->
 <!-- Copyright (C) 2009 Stefan Stammberger, sstammberger at web.de -->
 <Project version="4.6">
   <Language>en</Language>
@@ -47,7 +47,6 @@
     <Source>ui files/Ui_GOPropertyEditorDialogINT.py</Source>
     <Source>ui files/Ui_GOPropertyEditorDialogSTRING.py</Source>
     <Source>ui files/Ui_NewModuleWizard.py</Source>
-    <Source>ui files/Ui_AddTriggerDialog.py</Source>
     <Source>src/AddTriggerDialog.py</Source>
     <Source>src/Ui_AddTriggerDialog.py</Source>
   </Sources>

Modified: rl/trunk/editors/Lockenwickler/src/AddTriggerDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/AddTriggerDialog.py	2009-04-20 22:44:43 UTC (rev 4906)
+++ rl/trunk/editors/Lockenwickler/src/AddTriggerDialog.py	2009-04-21 17:49:01 UTC (rev 4907)
@@ -7,26 +7,43 @@
 from PyQt4.QtGui import QDialog
 from PyQt4.QtCore import pyqtSignature
 
+
 from Ui_AddTriggerDialog import Ui_Dialog
 
 class AddTriggerDialog(QDialog, Ui_Dialog):
-    def __init__(self, parent = None):
-
+    def __init__(self, trigger, triggerClassNames, triggerManager, parent = None):
         QDialog.__init__(self, parent)
         self.setupUi(self)
-    
+        self.triggerManager = triggerManager
+        self.trigger = trigger
+
+        self.buttonBox.setEnabled(False)
+        
+        for trigger in triggerClassNames:
+            self.comboBox.addItem(trigger)
+        
     @pyqtSignature("QString")
     def on_lineEdit_textChanged(self, p0):
-        """
-        Slot documentation goes here.
-        """
-        # TODO: not implemented yet
-        raise NotImplementedError
-    
+        for trigger in self.triggerManager.triggerInstances:
+            if trigger.name is p0:
+                self.buttonBox.setEnabled(False)
+            else:
+                self.buttonBox.setEnabled(True)
+                
+        if len(self.triggerManager.triggerInstances) == 0:
+            self.buttonBox.setEnabled(True)
+            
     @pyqtSignature("")
     def on_pushButton_clicked(self):
-        """
-        Slot documentation goes here.
-        """
-        # TODO: not implemented yet
-        raise NotImplementedError
+        if self.trigger.addProperty():
+            self.updateProperties()
+        
+    def accept(self):
+        self.trigger.name = str(self.lineEdit.text())
+        self.trigger.className = str(self.comboBox.currentText())
+        self.close()
+        
+    def updateProperties(self):
+        self.listView.clear()
+        for prop in self.trigger.properties:
+            self.listView.addItem(prop.name + "  " + prop.type + "  " + prop.data)

Modified: rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-20 22:44:43 UTC (rev 4906)
+++ rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-21 17:49:01 UTC (rev 4907)
@@ -22,7 +22,6 @@
 from PyQt4.QtGui import *
 import ogre.renderer.OGRE as og
 
-from ZoneManager import ZoneManager
 
 # get the light out of a light node
 def extractLight(node):
@@ -380,7 +379,7 @@
     
     def onAddTriggerToZone(self):
         zoneName = str(self.sceneTreeView.currentItem().text(0)).replace("Zone: ", "")
-        ZoneManager.instance.getZone(zoneName).addTrigger()
+        self.moduleManager.zoneManager.getZone(zoneName).addTrigger()
         
     def onOptions(self):
         dlg = ExplorerOptionsDlg(self.showLights, self.showGameObjects, self.showEntities, self.showZones, self.showZoneLights, self)

Modified: rl/trunk/editors/Lockenwickler/src/TriggerManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/TriggerManager.py	2009-04-20 22:44:43 UTC (rev 4906)
+++ rl/trunk/editors/Lockenwickler/src/TriggerManager.py	2009-04-21 17:49:01 UTC (rev 4907)
@@ -18,7 +18,13 @@
 #################################################
 
 from os.path import isfile,  join
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
 from GlobDirectoryWalker import GlobDirectoryWalker
+from AddTriggerDialog import AddTriggerDialog
+from GOGenericEditor import *
 
 class TriggerProperty():
     def __init__(self, name, type, data):
@@ -27,14 +33,21 @@
         self.data = data
 
 class Trigger():
-    def __init__(self, className, name):
-        self.className = className
-        self.name = name
+    def __init__(self):
+        self.className = ""
+        self.name = ""
         self.properties = []
         
-    def addProperty(self, name, type, data):
-        prop = TriggerProperty(name,  type, data)
-        self.properties.append(prop)
+    def addProperty(self):
+        editor = GOGenericEditor("", "STRING", "", QApplication.focusWidget())
+        if editor.exec_():
+            name = str(editor.nameEditBox.text())
+            type = str(editor.typeDropBox.currentText())
+            data = str(editor.dataEditBox.text())
+            prop = TriggerProperty(name,  type, data)
+            self.properties.append(prop)
+            return True
+        return False
         
     def removeProperty(self, name):
         for prop in self.properties:
@@ -47,7 +60,7 @@
     availableTriggers = []
     
     def __init__(self):
-        self.triggerInstances = ()
+        self.triggerInstances = []
         self.directories = []
         
         if TriggerManager.instance == None:
@@ -58,10 +71,15 @@
         
         self.update()
     
-    def createTrigger(self, className, name):
-        trigger = Trigger(className, name)
-        self.triggerInstances.append(trigger)
-        return trigger
+    def createTrigger(self):
+        trigger = Trigger()
+        
+        dlg = AddTriggerDialog(trigger, TriggerManager.availableTriggers, self, QApplication.focusWidget())
+        if dlg.exec_():
+            self.triggerInstances.append(trigger)
+            return trigger
+        
+        return False
     
     def update(self):
         TriggerManager.availableTriggers = []

Modified: rl/trunk/editors/Lockenwickler/src/Ui_AddTriggerDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Ui_AddTriggerDialog.py	2009-04-20 22:44:43 UTC (rev 4906)
+++ rl/trunk/editors/Lockenwickler/src/Ui_AddTriggerDialog.py	2009-04-21 17:49:01 UTC (rev 4907)
@@ -30,7 +30,7 @@
         self.pushButton.setLayoutDirection(QtCore.Qt.LeftToRight)
         self.pushButton.setObjectName("pushButton")
         self.gridLayout.addWidget(self.pushButton, 5, 0, 1, 1)
-        self.listView = QtGui.QListView(Dialog)
+        self.listView = QtGui.QListWidget(Dialog)
         self.listView.setObjectName("listView")
         self.gridLayout.addWidget(self.listView, 6, 0, 1, 1)
         self.buttonBox = QtGui.QDialogButtonBox(Dialog)

Modified: rl/trunk/editors/Lockenwickler/src/ZoneManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ZoneManager.py	2009-04-20 22:44:43 UTC (rev 4906)
+++ rl/trunk/editors/Lockenwickler/src/ZoneManager.py	2009-04-21 17:49:01 UTC (rev 4907)
@@ -27,8 +27,8 @@
  
 from ModuleExplorer import NameInputDlg
 from TriggerManager import TriggerManager
-from AddTriggerDialog import AddTriggerDialog
 
+
 #                <zone name="Testzone">
 #                        <area type="sphere">
 #                                <position x="-10" y="0" z="-5"/>
@@ -142,8 +142,7 @@
                 del a
     
     def addTrigger(self):
-        dlg = AddTriggerDialog()
-        dlg.exec_(QCursor.pos())
+        trigger = TriggerManager.instance.createTrigger()
     
     def hide(self):
         self.sceneManager.getRootSceneNode().removeChild(self.zoneNode)



From melven at mail.berlios.de  Wed Apr 22 20:06:19 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 22 Apr 2009 20:06:19 +0200
Subject: [Dsa-hl-svn] r4908 - in rl/trunk/engine: core/include core/src
	script/src
Message-ID: <200904221806.n3MI6J9R019132@sheep.berlios.de>

Author: melven
Date: 2009-04-22 20:06:13 +0200 (Wed, 22 Apr 2009)
New Revision: 4908

Modified:
   rl/trunk/engine/core/include/PhysicsCollisionFactory.h
   rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp
   rl/trunk/engine/script/src/EntityNodeProcessor.cpp
Log:
-fixed bug in the EntityNodeProcessor (created by myself some commits ago)
-collisions from aabbs are now also cached (need the same name, using a name (different to "") is currently not widely used in the engine...)


Modified: rl/trunk/engine/core/include/PhysicsCollisionFactory.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsCollisionFactory.h	2009-04-21 17:49:01 UTC (rev 4907)
+++ rl/trunk/engine/core/include/PhysicsCollisionFactory.h	2009-04-22 18:06:13 UTC (rev 4908)
@@ -222,64 +222,23 @@
 
         typedef std::map<Ogre::String, ConvexCollisionCacheObject> ConvexCollisionCacheMap;
 
-        //! cache for convex collisions
+        //! cache for convex collisions created with the 'FromEntity'-function
         ConvexCollisionCacheMap mConvexCollisionsCache;
 
+        //! cache for convex collisions created with the 'FromAABB'-function
+        ConvexCollisionCacheMap mConvexAABBCollisionsCache;
+
         //! for using a string and a vector as key in a map... we should implement here a hash-function
         class StringVector
         {
             public:
-                StringVector(const Ogre::String& str, const Ogre::Vector3& vec) : mStr(str)
-                {
-                    setVector(vec);
-                }
-                void setString(const Ogre::String& str) {mStr = str;}
-                void setVector(const Ogre::Vector3& vec)
-                {
-                    mVec = vec;
-                }
-                const Ogre::String& getString() const {return mStr;}
-                const Ogre::Vector3& getVector() const {return mVec;}
-
-                bool operator==(const StringVector& strVec) const
-                {
-                    if( mStr != strVec.mStr )
-                        return false;
-
-                    Ogre::Vector3 diff = mVec - strVec.mVec;
-                    if( abs(diff.x) > 0.01 )
-                        return false;
-                    if( abs(diff.y) > 0.01 )
-                        return false;
-                    if( abs(diff.z) > 0.01 )
-                        return false;
-
-                    return true;
-                }
-
-                bool operator<(const StringVector& strVec) const
-                {
-                    int strCompare = mStr.compare(strVec.mStr);
-                    if( strCompare == 0 ) // strings are the same
-                    {
-                        // compare vectors
-                        Ogre::Vector3 diff = mVec - strVec.mVec;
-                        if( diff.x < -0.01 )
-                            return true;
-                        if( diff.x > 0.01 )
-                            return false;
-                        if( diff.y < -0.01 )
-                            return true;
-                        if( diff.y > 0.01 )
-                            return false;
-                        if( diff.y < -0.01 )
-                            return true;
-
-                        return false;
-                    }
-                    
-                    return strCompare < 0;
-                }
+                StringVector(const Ogre::String& str, const Ogre::Vector3& vec);
+                void setString(const Ogre::String& str);
+                void setVector(const Ogre::Vector3& vec);
+                const Ogre::String& getString() const;
+                const Ogre::Vector3& getVector() const;
+                bool operator==(const StringVector& strVec) const;
+                bool operator<(const StringVector& strVec) const;
             private:
                 Ogre::String mStr;
                 Ogre::Vector3 mVec;

Modified: rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp	2009-04-21 17:49:01 UTC (rev 4907)
+++ rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp	2009-04-22 18:06:13 UTC (rev 4908)
@@ -43,6 +43,7 @@
     {
         mMeshCollisionsCache.clear();
         mConvexCollisionsCache.clear();
+        mConvexAABBCollisionsCache.clear();
     }
 
     bool PhysicsCollisionFactory::checkSize(const Ogre::AxisAlignedBox& aabb) const
@@ -82,6 +83,12 @@
         Ogre::Vector3* centerOfMass,
         bool nocache)
     {
+
+        // don't cache if the name is ""
+        if( name == "" )
+            nocache = true;
+
+
         Ogre::AxisAlignedBox aabb(passedAabb);
         // type for the collision primitiv (can change internally here)
         bool forceBox (false);
@@ -113,6 +120,45 @@
             forceBox = true;
         }
 
+
+        ConvexCollisionCacheMap::iterator convexCacheIt = mConvexAABBCollisionsCache.end();
+
+        // check if we can reuse a cached collision
+        if( !nocache )
+        {
+            if( !forceBox )
+            {
+                Ogre::String index(name);
+                std::pair<ConvexCollisionCacheMap::iterator,bool> iterBoolPair = mConvexAABBCollisionsCache.insert(std::make_pair(index, ConvexCollisionCacheObject()));
+                convexCacheIt = iterBoolPair.first;
+                if( !iterBoolPair.second )
+                {
+                    // there was already an element, check type, the size, offset etc if we can use it
+                    if( geomType != convexCacheIt->second.type )
+                    {
+                        LOG_MESSAGE(Logger::CORE, "Performance warning: trying to create a collision for aabb '" + name +
+                                "' with geometry-type '"+PhysicsManager::convertGeometryTypeToString(geomType)+
+                                "'. There's already a collision with type '"+PhysicsManager::convertGeometryTypeToString(convexCacheIt->second.type)+"'!");
+                    }
+                    else if( aabb.getSize() == convexCacheIt->second.scale && offset == convexCacheIt->second.offset && orientation == convexCacheIt->second.orientation )
+                    {
+                        // everything fine, reuse it
+                        rval = convexCacheIt->second.col;
+
+                        if( inertia != NULL )
+                            *inertia = convexCacheIt->second.inertia;
+                        if( centerOfMass != NULL )
+                            *centerOfMass = convexCacheIt->second.centerOfMass;
+
+                        LOG_DEBUG(Logger::CORE, "Reused collision for aabb '" + name + "'.");
+
+                        return rval;
+                    }
+                }
+            }
+        }
+
+
         /* differentiate between the different collision primitives, because they all
 		   need different offset and probably different orientation values.
 		   Newton SDK is really nifty and helps here, because we can shift the origin
@@ -120,41 +166,88 @@
 		   desire. Actually this is the bottom middle of our mesh - as the meshes are
 		   always constructed like that.
 	    */
-		if (geomType == GT_BOX || forceBox == true)
+        if( !rval )
         {
-			rval = createBox(aabb, offset, orientation);
+            if (geomType == GT_BOX || forceBox == true)
+            {
+                rval = createBox(aabb, offset, orientation);
+            }
+            else if (geomType == GT_PYRAMID)
+            {
+                rval = createPyramid(aabb, offset, orientation);
+            }
+            else if (geomType == GT_SPHERE)
+            {
+                rval = createSphere(aabb, offset, orientation);
+            }
+            else if (geomType == GT_ELLIPSOID)
+            {
+                rval = createEllipsoid(aabb, offset, orientation);
+            }
+            else if (geomType == GT_CAPSULE)
+            {
+                rval = createCapsule(aabb, offset, orientation);
+            }
         }
-        else if (geomType == GT_PYRAMID)
+
+        if ( rval == NULL )
         {
-            rval = createPyramid(aabb, offset, orientation);
+            LOG_WARNING(Logger::CORE, " creating collision primitiv '"+
+                PhysicsManager::convertGeometryTypeToString(geomType)+"' for AABB '"+ name
+                +"' failed.");
+
+            // delete cacheobject
+            if( convexCacheIt != mConvexAABBCollisionsCache.end() )
+            {
+                mConvexAABBCollisionsCache.erase( convexCacheIt );
+            }
         }
-        else if (geomType == GT_SPHERE)
+        else
         {
-			rval = createSphere(aabb, offset, orientation);
+            LOG_DEBUG(Logger::CORE, " collision primitiv '"+
+                PhysicsManager::convertGeometryTypeToString(geomType)+"' created for AABB '"+
+                name+"'");
         }
-        else if (geomType == GT_ELLIPSOID)
+
+
+        // calculate inertia / centerOfMass if requested
+        // and save collision in cache
+        if( rval)
         {
-            rval = createEllipsoid(aabb, offset, orientation);
-        }
-		else if (geomType == GT_CAPSULE)
-		{
-			rval = createCapsule(aabb, offset, orientation);
-		}
+            if( convexCacheIt != mConvexAABBCollisionsCache.end() )
+            {
+                // save collision in cache
+                Vector3 temp_inertia, temp_centerOfMass;
+                rval->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
 
-        // calculate inertia / centerOfMass if needed
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-            rval->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-            if( inertia != NULL )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass != NULL )
-                *centerOfMass = temp_centerOfMass;
+                convexCacheIt->second.col = rval;
+                convexCacheIt->second.scale = aabb.getSize();
+                convexCacheIt->second.offset = offset;
+                convexCacheIt->second.orientation = orientation;
+                convexCacheIt->second.inertia = temp_inertia;
+                convexCacheIt->second.centerOfMass = temp_centerOfMass;
+                convexCacheIt->second.type = geomType;
+
+                if( inertia != NULL )
+                    *inertia = temp_inertia*mass;
+                if( centerOfMass != NULL )
+                    *centerOfMass = temp_centerOfMass;
+            }
+            else if (inertia != NULL || centerOfMass != NULL )
+            {
+                Vector3 temp_inertia, temp_centerOfMass;
+                rval->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+                if( inertia != NULL )
+                    *inertia = temp_inertia*mass;
+                if( centerOfMass != NULL )
+                    *centerOfMass = temp_centerOfMass;
+            }
         }
 
         return rval;
     }
 
+
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromEntity(Ogre::Entity* entity,
         const GeometryType& geomType,
         const Ogre::String& animName,
@@ -168,8 +261,12 @@
         // bounding box of the mesh
         Ogre::AxisAlignedBox aabb(entity->getBoundingBox());
         // apply scale if attached to a node (like in OgreNewt for convexhull)
+        Ogre::Vector3 scale = Ogre::Vector3::UNIT_SCALE;
         if( entity->getParentNode() )
-            aabb.scale(entity->getParentNode()->getScale());
+        {
+            scale = entity->getParentNode()->getScale();
+            aabb.scale(scale);
+        }
 
         // type for the collision primitiv (can change internally here)
         bool forceBox (false);
@@ -194,6 +291,16 @@
         }
 
 
+        if( geomType == GT_MESH )
+        {
+            if( offset != Ogre::Vector3::ZERO || orientation != Ogre::Quaternion::IDENTITY )
+            {
+                LOG_WARNING(Logger::CORE, " Cannot set collision offset or orientation when using mesh-collision (entity: '" +
+                        entity->getName()+"')!");
+            }
+        }
+
+
         MeshCollisionCacheMap::iterator meshCacheIt = mMeshCollisionsCache.end();
         ConvexCollisionCacheMap::iterator convexCacheIt = mConvexCollisionsCache.end();
 
@@ -203,10 +310,6 @@
             // use meshcollisionscache
             if( geomType == GT_MESH && !forceBox )
             {
-                Ogre::Vector3 scale = Ogre::Vector3::ZERO;
-                if( entity->getParentNode() )
-                    scale = entity->getParentNode()->getScale();
-
                 StringVector index(entity->getMesh()->getName() + animName, scale);
                 std::pair<MeshCollisionCacheMap::iterator,bool> iterBoolPair = mMeshCollisionsCache.insert(std::make_pair(index, MeshCollisionCacheObject()));
                 meshCacheIt = iterBoolPair.first;
@@ -217,11 +320,78 @@
                     LOG_DEBUG(Logger::CORE, "Reused collision for entity '" + entity->getName() + "' (mesh: '"
                             + entity->getMesh()->getName() + "', animation: '" + animName + "').");
                     rval = iterBoolPair.first->second.col;
+
+                    return rval;
                 }
             }
             // use convexcollisionscache
-            else
+            else if( !forceBox )
             {
+                Ogre::String index(entity->getMesh()->getName() + animName);
+                std::pair<ConvexCollisionCacheMap::iterator,bool> iterBoolPair = mConvexCollisionsCache.insert(std::make_pair(index, ConvexCollisionCacheObject()));
+                convexCacheIt = iterBoolPair.first;
+                if( !iterBoolPair.second )
+                {
+                    // there was already an element, check type, the size, offset etc if we can use it
+                    if( geomType != convexCacheIt->second.type )
+                    {
+                        LOG_MESSAGE(Logger::CORE, "Performance warning: trying to create a collision for entity '"+entity->getName()+"' with animation '"+
+                                animName+"' with geometry-type '"+PhysicsManager::convertGeometryTypeToString(geomType)+
+                                "'. There's already a collision with type '"+PhysicsManager::convertGeometryTypeToString(convexCacheIt->second.type)+"'!");
+                    }
+                    else if( scale == convexCacheIt->second.scale && offset == convexCacheIt->second.offset && orientation == convexCacheIt->second.orientation )
+                    {
+                        // everything fine, reuse it
+                        rval = convexCacheIt->second.col;
+
+                        if( inertia != NULL )
+                            *inertia = convexCacheIt->second.inertia;
+                        if( centerOfMass != NULL )
+                            *centerOfMass = convexCacheIt->second.centerOfMass;
+
+                        LOG_DEBUG(Logger::CORE, "Reused collision for entity '" + entity->getName() + "' (mesh: '"
+                            + entity->getMesh()->getName() + "', animation: '" + animName + "').");
+
+                        return rval;
+                    }
+                    else if( geomType == GT_CONVEXHULL ) // for simple types just use create a new collision
+                    {
+                        // we need to rescale (or change offset or orientation)
+                        // the old transformation
+                        Ogre::Matrix4 oldInvTransformation;
+                        oldInvTransformation.makeInverseTransform(convexCacheIt->second.offset, convexCacheIt->second.scale, convexCacheIt->second.orientation);
+                        // the new transformation
+                        Ogre::Matrix4 newTransformation;
+                        newTransformation.makeTransform(offset, scale, orientation);
+
+                        // the needed transformation from old to new:
+                        Ogre::Matrix4 transformation = oldInvTransformation*newTransformation;
+
+                        OgreNewt::ConvexModifierCollision *convexModCol = new OgreNewt::ConvexModifierCollision(
+                                PhysicsManager::getSingleton()._getNewtonWorld(),convexCacheIt->second.col);
+                        convexModCol->setScalarMatrix(transformation);
+
+                        // set the convexcollision-ptr, so centerOfMass and inertia can be calculated
+                        rval = OgreNewt::ConvexCollisionPtr(convexModCol);
+
+
+                        LOG_DEBUG(Logger::CORE, "Reused collision for entity '" + entity->getName() + "' (mesh: '"
+                                + entity->getMesh()->getName() + "', animation: '" + animName + "') with a ConvexModifierCollision.");
+
+                        // calculate inertia / centerOfMass if needed
+                        if (inertia != NULL || centerOfMass != NULL )
+                        {
+                            Vector3 temp_inertia, temp_centerOfMass;
+                            rvalAsConvexCollision->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+                            if( inertia != NULL )
+                                *inertia = temp_inertia*mass;
+                            if( centerOfMass != NULL )
+                                *centerOfMass = temp_centerOfMass;
+                        }
+
+                        return rval;
+                    }
+                }
             }
         }
 
@@ -232,53 +402,51 @@
 		   desire. Actually this is the bottom middle of our mesh - as the meshes are
 		   always constructed like that.
 	    */
-        if( !rval )
+        if (geomType == GT_BOX || forceBox == true)
         {
-            if (geomType == GT_BOX || forceBox == true)
-            {
-                rvalAsConvexCollision = createBox(aabb, offset, orientation);
-                rval = rvalAsConvexCollision;
-            }
-            else if (geomType == GT_PYRAMID)
-            {
-                rvalAsConvexCollision = createPyramid(aabb, offset, orientation);
-                rval = rvalAsConvexCollision;
-            }
-            else if (geomType == GT_SPHERE)
-            {
-                rvalAsConvexCollision = createSphere(aabb, offset, orientation);
-                rval = rvalAsConvexCollision;
-            }
-            else if (geomType == GT_ELLIPSOID)
-            {
-                rvalAsConvexCollision = createEllipsoid(aabb, offset, orientation);
-                rval = rvalAsConvexCollision;
-            }
-            else if (geomType == GT_CAPSULE)
-            {
-                rvalAsConvexCollision = createCapsule(aabb, offset, orientation);
-                rval = rvalAsConvexCollision;
-            }
-            else if (geomType == GT_CONVEXHULL)
-            {
-                rvalAsConvexCollision = createConvexHull(entity, offset, orientation);
-                rval = rvalAsConvexCollision;
-            }
-            else if (geomType == GT_MESH)
-            {
-                rval = CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
-                    PhysicsManager::getSingleton()._getNewtonWorld(),
-                    entity, true ));
+            rvalAsConvexCollision = createBox(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
+        }
+        else if (geomType == GT_PYRAMID)
+        {
+            rvalAsConvexCollision = createPyramid(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
+        }
+        else if (geomType == GT_SPHERE)
+        {
+            rvalAsConvexCollision = createSphere(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
+        }
+        else if (geomType == GT_ELLIPSOID)
+        {
+            rvalAsConvexCollision = createEllipsoid(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
+        }
+        else if (geomType == GT_CAPSULE)
+        {
+            rvalAsConvexCollision = createCapsule(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
+        }
+        else if (geomType == GT_CONVEXHULL)
+        {
+            rvalAsConvexCollision = createConvexHull(entity, offset, orientation);
+            rval = rvalAsConvexCollision;
+        }
+        else if (geomType == GT_MESH)
+        {
+            rval = CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
+                PhysicsManager::getSingleton()._getNewtonWorld(),
+                entity, true ));
 
-                if( meshCacheIt != mMeshCollisionsCache.end() )
-                    meshCacheIt->second.col = rval;
-            }
-            else
-            {
-                Throw(IllegalArgumentException, "unknown geometry type.");
-            }
+            if( meshCacheIt != mMeshCollisionsCache.end() )
+                meshCacheIt->second.col = rval;
         }
+        else
+        {
+            Throw(IllegalArgumentException, "unknown geometry type.");
+        }
 
+
         if ( rval == NULL )
         {
             LOG_WARNING(Logger::CORE, " creating collision primitiv '"+
@@ -303,29 +471,43 @@
         }
 
         // calculate inertia / centerOfMass if requested
+        // and save collision in cache
         if( rvalAsConvexCollision )
         {
-            if (inertia != NULL || centerOfMass != NULL )
+            if( convexCacheIt != mConvexCollisionsCache.end() )
             {
+                // save collision in cache
                 Vector3 temp_inertia, temp_centerOfMass;
                 rvalAsConvexCollision->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+
+                convexCacheIt->second.col = rvalAsConvexCollision;
+                convexCacheIt->second.scale = scale;
+                convexCacheIt->second.offset = offset;
+                convexCacheIt->second.orientation = orientation;
+                convexCacheIt->second.inertia = temp_inertia;
+                convexCacheIt->second.centerOfMass = temp_centerOfMass;
+                convexCacheIt->second.type = geomType;
+
                 if( inertia != NULL )
                     *inertia = temp_inertia*mass;
                 if( centerOfMass != NULL )
                     *centerOfMass = temp_centerOfMass;
             }
+            else if (inertia != NULL || centerOfMass != NULL )
+            {
+                Vector3 temp_inertia, temp_centerOfMass;
+                rvalAsConvexCollision->calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+                if( inertia != NULL )
+                    *inertia = temp_inertia*mass;
+                if( centerOfMass != NULL )
+                    *centerOfMass = temp_centerOfMass;
+            }
         }
-        else
-        {
-            if (inertia != NULL)
-                *inertia = Ogre::Vector3::ZERO;
-            if (centerOfMass != NULL)
-                *centerOfMass = Ogre::Vector3::ZERO;
-        }
 
         return rval;
     }
 
+
     OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createBox(const Ogre::AxisAlignedBox& aabb,
             const Ogre::Vector3 &offset,
             const Ogre::Quaternion &orientation)
@@ -436,5 +618,74 @@
     }
 
 
+
+    PhysicsCollisionFactory::StringVector::StringVector(const Ogre::String& str, const Ogre::Vector3& vec)
+    {
+        setString(str);
+        setVector(vec);
+    }
+    
+    void PhysicsCollisionFactory::StringVector::setString(const Ogre::String& str)
+    {
+        mStr = str;
+    }
+    
+    void PhysicsCollisionFactory::StringVector::setVector(const Ogre::Vector3& vec)
+    {
+        mVec = vec;
+    }
+    
+    const Ogre::String& PhysicsCollisionFactory::StringVector::getString() const
+    {
+        return mStr;
+    }
+    
+    const Ogre::Vector3& PhysicsCollisionFactory::StringVector::getVector() const
+    {
+        return mVec;
+    }
+
+    bool PhysicsCollisionFactory::StringVector::operator==(const PhysicsCollisionFactory::StringVector& strVec) const
+    {
+        if( mStr != strVec.mStr )
+            return false;
+
+        Ogre::Vector3 diff = mVec - strVec.mVec;
+        if( abs(diff.x) > 0.01 )
+            return false;
+        if( abs(diff.y) > 0.01 )
+            return false;
+        if( abs(diff.z) > 0.01 )
+            return false;
+
+        return true;
+    }
+
+    bool PhysicsCollisionFactory::StringVector::operator<(const PhysicsCollisionFactory::StringVector& strVec) const
+    {
+        int strCompare = mStr.compare(strVec.mStr);
+        // @todo: use a hash or so
+        if( strCompare == 0 ) // strings are the same
+        {
+            // compare vectors
+            Ogre::Vector3 diff = mVec - strVec.mVec;
+            if( diff.x < -0.01 )
+                return true;
+            if( diff.x > 0.01 )
+                return false;
+            if( diff.y < -0.01 )
+                return true;
+            if( diff.y > 0.01 )
+                return false;
+            if( diff.y < -0.01 )
+                return true;
+
+            return false;
+        }
+        
+        return strCompare < 0;
+    }
+
+
 }
 

Modified: rl/trunk/engine/script/src/EntityNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2009-04-21 17:49:01 UTC (rev 4907)
+++ rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2009-04-22 18:06:13 UTC (rev 4908)
@@ -175,26 +175,28 @@
                 if (physicsProxyTypeAsString == "custom")
                 {
                     ///@todo create physics proxy from custom collision primitives which are defined in children elements of <code>physicsProxyElem<code>
-                    LOG_WARNING(Logger::SCRIPT, "Physics proxy type 'custom' is not yet implemented.");
+                    LOG_WARNING(Logger::SCRIPT, "Physics proxy type 'custom' is not yet implemented, using mesh instead");
+                    physicsProxyType = GT_MESH;
                 }
-                else if ( physicsProxyType != GT_NONE )
+            }
+
+            if ( physicsProxyType != GT_NONE )
+            {
+                OgreNewt::CollisionPtr collision = PhysicsManager::getSingleton().createCollision(entity, physicsProxyType);
+                if (collision)
                 {
-                    OgreNewt::CollisionPtr collision = PhysicsManager::getSingleton().createCollision(entity, physicsProxyType);
-                    if (collision)
-                    {
-                        LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type '" + physicsProxyTypeAsString + "' for entity '"+entity->getName()+"'.");
-                        std::vector<OgreNewt::CollisionPtr> collisionVector;
-                        collisionVector.push_back(collision);
-                        PhysicsManager::getSingleton().addLevelGeometry(entity, collisionVector);
-                    }
+                    LOG_DEBUG(Logger::SCRIPT, "Created physics proxy type '" + physicsProxyTypeAsString + "' for entity '"+entity->getName()+"'.");
+                    std::vector<OgreNewt::CollisionPtr> collisionVector;
+                    collisionVector.push_back(collision);
+                    PhysicsManager::getSingleton().addLevelGeometry(entity, collisionVector);
                 }
-                else
-                {
-                    LOG_ERROR(Logger::SCRIPT,
-                            "Physics proxy type '" + physicsProxyTypeAsString + "' of entity '"+entity->getName()+"' is unknown.");
-                    return;
-                }
             }
+            else
+            {
+                LOG_ERROR(Logger::SCRIPT,
+                        "Physics proxy type '" + physicsProxyTypeAsString + "' of entity '"+entity->getName()+"' is unknown.");
+                return;
+            }
 
                 
         }



From melven at mail.berlios.de  Thu Apr 23 16:42:04 2009
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Thu, 23 Apr 2009 16:42:04 +0200
Subject: [Dsa-hl-svn] r4909 - in rl/trunk/engine/core: include src
Message-ID: <200904231442.n3NEg4Nv029749@sheep.berlios.de>

Author: melven
Date: 2009-04-23 16:42:02 +0200 (Thu, 23 Apr 2009)
New Revision: 4909

Modified:
   rl/trunk/engine/core/include/PhysicsCollisionFactory.h
   rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
Log:
-using cache files for treecollisions


Modified: rl/trunk/engine/core/include/PhysicsCollisionFactory.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsCollisionFactory.h	2009-04-22 18:06:13 UTC (rev 4908)
+++ rl/trunk/engine/core/include/PhysicsCollisionFactory.h	2009-04-23 14:42:02 UTC (rev 4909)
@@ -40,6 +40,10 @@
     class PhysicsCollisionFactory
     {
     public:
+        //! constructor
+        PhysicsCollisionFactory();
+
+
         //! destructor, releases the collisions from the collision cache
         ~PhysicsCollisionFactory();
 
@@ -57,7 +61,7 @@
          * if that is not the case, we'll have to fix OgreNewt ...
 		 * @param entity gives the mesh entity that needs a collision primitive
 		 * @param geomType specifies the type of collision primitiv to create.
-		 * @param animName gives the name of the currently set animation (this is used in the collisionscache
+		 * @param animName gives the name of the currently set animation (this is used in the collisionscache)
 		 * @param offset gives the offset of the coordinate system of the coll. primitiv,
          *        it is relative to the standard offset (center of the aabb of an entity for simple collision types)
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
@@ -196,7 +200,16 @@
             const Ogre::Vector3 &offset,
             const Ogre::Quaternion &orientation);
 
+        /** creates a mesh collision primitive from aabb
+         * It's actually a convenience function used by createCollisionFromEntity
+         * @param entity the entity for which a convexhull should be created, if it is attached to
+         *               a node the scale of the node is used (see OgreNewt)
+		 * @param animName gives the name of the currently set animation (this is used in the collisionscache)
+         * @param nocache if true, the function doesn't try to load the collision from a cache file
+         */
+        OgreNewt::CollisionPtr createMesh( Ogre::Entity* entity, const Ogre::String & animName, bool nocache );
 
+
         //! class for caching convex collisions (box...convexhull), saves additionally the scale, so it can be rescaled if necessary
         class ConvexCollisionCacheObject
         {
@@ -261,6 +274,23 @@
 
         //! cache for mesh collisions
         MeshCollisionCacheMap mMeshCollisionsCache;
+
+
+        //! OgreNewt collision serializer
+        OgreNewt::CollisionSerializer mCollisionSerializer;
+
+        /** load a collision from a file
+         * It's actually a convenience function used internally
+        */
+        OgreNewt::CollisionPtr loadFromFile(const Ogre::String& filename);
+
+        /** save a collision to a file
+         * It's actually a convenience function used internally
+        */
+        void saveToFile(OgreNewt::CollisionPtr col, const Ogre::String& filename);
+
+        //! the path for cached collision files
+        Ogre::String mCachePathName;
     };
 }
 

Modified: rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp	2009-04-22 18:06:13 UTC (rev 4908)
+++ rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp	2009-04-23 14:42:02 UTC (rev 4909)
@@ -19,6 +19,11 @@
 #include "PhysicsCollisionFactory.h"
 #include "PhysicsManager.h"
 
+#include <boost/filesystem/operations.hpp>
+#include <boost/filesystem/exception.hpp>
+
+namespace fs = boost::filesystem;
+
 #ifdef __APPLE__
 #   include <Ogre/OgreMesh.h>
 #else
@@ -34,6 +39,24 @@
 
 namespace rl
 {
+
+    PhysicsCollisionFactory::PhysicsCollisionFactory() :
+        mCollisionSerializer()
+    {
+
+#       if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
+        mCachePathName = Ogre::String( Ogre::String(::getenv("HOME")) + "/.rastullah/cache/");
+        fs::path cachePath( mCachePathName, fs::portable_posix_name);
+#       else
+        mCachePathName = Ogre::String( ConfigurationManager::getSingleton().getModulesRootDirectory() + "/cache/" );
+        fs::path cachePath( mCachePathName );
+#       endif
+
+        if( !fs::exists(cachePath) )
+            fs::create_directory(cachePath);
+    }
+
+
     PhysicsCollisionFactory::~PhysicsCollisionFactory()
     {
         clearCollisionCache();
@@ -298,6 +321,11 @@
                 LOG_WARNING(Logger::CORE, " Cannot set collision offset or orientation when using mesh-collision (entity: '" +
                         entity->getName()+"')!");
             }
+            if( inertia || centerOfMass )
+            {
+                LOG_WARNING(Logger::CORE, " Cannot calculate inertia or center of mass when using mesh-collision (entity: '" +
+                        entity->getName()+"')!");
+            }
         }
 
 
@@ -434,9 +462,7 @@
         }
         else if (geomType == GT_MESH)
         {
-            rval = CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
-                PhysicsManager::getSingleton()._getNewtonWorld(),
-                entity, true ));
+            rval = createMesh( entity, animName, nocache );
 
             if( meshCacheIt != mMeshCollisionsCache.end() )
                 meshCacheIt->second.col = rval;
@@ -618,7 +644,92 @@
     }
 
 
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::loadFromFile(const Ogre::String& filename)
+    {
+        OgreNewt::CollisionPtr rval;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        rval = NULL;
+#endif
+        Ogre::String fullfilename = mCachePathName+filename;
+        FILE* pFile = fopen(fullfilename.c_str(), "r" );
+        if( pFile )
+        {
+            Ogre::DataStreamPtr streamPtr( new Ogre::FileHandleDataStream( pFile ) );
+            rval = mCollisionSerializer.importCollision( streamPtr, PhysicsManager::getSingleton()._getNewtonWorld() );
 
+            if( rval )
+            {
+                LOG_DEBUG(Logger::CORE, "Loaded collision from file '" + filename + "'.");
+            }
+        }
+
+        return rval;
+    }
+
+
+
+    void PhysicsCollisionFactory::saveToFile(OgreNewt::CollisionPtr col, const Ogre::String& filename)
+    {
+        mCollisionSerializer.exportCollision(col, mCachePathName + filename);
+    }
+
+
+
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createMesh( Ogre::Entity* entity, const Ogre::String& animName, bool nocache )
+    {
+        OgreNewt::CollisionPtr rval;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        rval = NULL;
+#endif
+        Ogre::String filename;
+
+        if( !nocache )
+        {
+            Ogre::Vector3 scale(Ogre::Vector3::UNIT_SCALE);
+            if( entity->getParentNode() )
+                scale = entity->getParentNode()->getScale();
+
+            filename = entity->getMesh()->getName() + animName + Ogre::StringConverter::toString(scale) + ".collision";
+
+            // check date of cache file and mesh
+            time_t meshFileModified = 
+                Ogre::ResourceGroupManager::getSingleton().resourceModifiedTime(
+                        entity->getMesh()->getGroup(),
+                        entity->getMesh()->getName());
+
+#if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
+            fs::path cacheFilePath( mCachePathName+filename, fs::portable_posix_name);
+#else
+            fs::path cacheFilePath( mCachePathName+filename );
+#endif
+
+            time_t cacheFileModified = 0;
+            if( fs::exists(cacheFilePath) )
+                cacheFileModified = fs::last_write_time(cacheFilePath);
+
+
+            if( cacheFileModified > meshFileModified )        
+                rval = loadFromFile( filename );
+        }
+
+
+        if( !rval )
+        {
+            rval = OgreNewt::CollisionPtr( new OgreNewt::CollisionPrimitives::TreeCollision(
+                        PhysicsManager::getSingleton()._getNewtonWorld(),
+                        entity, true ));
+
+            if( !nocache )
+            {
+                saveToFile(rval, filename );
+            }
+        }
+
+        return rval;
+    }
+
+
+
     PhysicsCollisionFactory::StringVector::StringVector(const Ogre::String& str, const Ogre::Vector3& vec)
     {
         setString(str);

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2009-04-22 18:06:13 UTC (rev 4908)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2009-04-23 14:42:02 UTC (rev 4909)
@@ -114,6 +114,16 @@
 
     PhysicsManager::~PhysicsManager()
     {
+        // remove all bodies
+        clearLevelGeometry();
+
+        // remove all physical things
+        for( vector<PhysicalThing*>::iterator it = mPhysicalThings.begin(); it != mPhysicalThings.end(); it++ )
+        {
+            delete (*it);
+        }
+
+
         // remove all material-pairs
         for (MaterialPairMap::iterator it = mMaterialPairs.begin(); it != mMaterialPairs.end(); it++)
         {



From fusion2 at mail.berlios.de  Sun Apr 26 13:10:28 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Sun, 26 Apr 2009 13:10:28 +0200
Subject: [Dsa-hl-svn] r4910 - rl/trunk/editors/Lockenwickler/src
Message-ID: <200904261110.n3QBASqw002189@sheep.berlios.de>

Author: fusion2
Date: 2009-04-26 13:10:24 +0200 (Sun, 26 Apr 2009)
New Revision: 4910

Modified:
   rl/trunk/editors/Lockenwickler/src/AddTriggerDialog.py
   rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
   rl/trunk/editors/Lockenwickler/src/TriggerManager.py
   rl/trunk/editors/Lockenwickler/src/ZoneManager.py
Log:
- loading and saving of triggers works
- minor bugfixes

Modified: rl/trunk/editors/Lockenwickler/src/AddTriggerDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/AddTriggerDialog.py	2009-04-23 14:42:02 UTC (rev 4909)
+++ rl/trunk/editors/Lockenwickler/src/AddTriggerDialog.py	2009-04-26 11:10:24 UTC (rev 4910)
@@ -4,10 +4,9 @@
 Module implementing AddTriggerDialog.
 """
 
-from PyQt4.QtGui import QDialog
-from PyQt4.QtCore import pyqtSignature
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
 
-
 from Ui_AddTriggerDialog import Ui_Dialog
 
 class AddTriggerDialog(QDialog, Ui_Dialog):
@@ -22,6 +21,8 @@
         for trigger in triggerClassNames:
             self.comboBox.addItem(trigger)
         
+        self.connect(self, SIGNAL("accepted()"), self.onAccepted)
+        
     @pyqtSignature("QString")
     def on_lineEdit_textChanged(self, p0):
         for trigger in self.triggerManager.triggerInstances:
@@ -35,13 +36,12 @@
             
     @pyqtSignature("")
     def on_pushButton_clicked(self):
-        if self.trigger.addProperty():
+        if self.trigger.manualAddProperty():
             self.updateProperties()
         
-    def accept(self):
+    def onAccepted(self):
         self.trigger.name = str(self.lineEdit.text())
         self.trigger.className = str(self.comboBox.currentText())
-        self.close()
         
     def updateProperties(self):
         self.listView.clear()

Modified: rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-23 14:42:02 UTC (rev 4909)
+++ rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-26 11:10:24 UTC (rev 4910)
@@ -36,7 +36,7 @@
             i += 1
 
 class ExplorerOptionsDlg(QDialog):
-    def __init__(self, lights, gameObjects, entities, zones, zonelights, parent = None):
+    def __init__(self, lights, gameObjects, entities, zones, zonelights, zonetriggers, parent = None):
         super(ExplorerOptionsDlg, self).__init__(parent)
         
         buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
@@ -62,6 +62,10 @@
         self.zoneslightsCheckBox.setChecked(zonelights)        
         layout.addWidget(self.zoneslightsCheckBox)
         
+        self.zonesTriggersCheckBox = QCheckBox("Show Zonetriggers")
+        self.zonesTriggersCheckBox.setChecked(zoneTriggers)        
+        layout.addWidget(self.zonesTriggersCheckBox)
+        
         layout.addWidget(buttonBox)
         layout.setContentsMargins(2, 2, 2, 2)
         self.setLayout(layout)
@@ -178,6 +182,7 @@
 
 class ModuleExplorer(QWidget):
     LIGHT_IN_ZONE = 99
+    TRIGGER_IN_ZONE = 100
     
     def __init__(self, parent=None):
         QWidget.__init__(self, parent)
@@ -206,6 +211,7 @@
         
         self.showLights = True
         self.showZoneLights = True
+        self.showZoneTriggers = True
         self.showGameObjects = True
         self.showEntities = True
         self.showZones = True
@@ -280,8 +286,16 @@
         
         #end remove all the things from the list we actually don't want to be selected
         for item in selItems:
+            print str(item.text(0))
+            print str(item.parent().text(0))
+            
             if str(item.text(0)).startswith("Scene: ") or str(item.text(0)).startswith("Map: ") or str(item.text(0)).startswith("Zone: "):
                 selItems.remove(item)
+            elif item.data(0, Qt.UserRole).toInt()[0] == ModuleExplorer.LIGHT_IN_ZONE or item.data(0, Qt.UserRole).toInt()[0] == ModuleExplorer.TRIGGER_IN_ZONE:
+                selItems.remove(item)
+            elif item.text(0) == "Lights" and item.text(0) == "Triggers":
+                if str(item.parent().text(0)).startswith("Zone: "):
+                    selItems.remove(item)
         
         for item in selItems:
             parentName =  str(item.text(0))
@@ -379,10 +393,11 @@
     
     def onAddTriggerToZone(self):
         zoneName = str(self.sceneTreeView.currentItem().text(0)).replace("Zone: ", "")
-        self.moduleManager.zoneManager.getZone(zoneName).addTrigger()
+        self.moduleManager.zoneManager.getZone(zoneName).manualAddTrigger()
+        self.updateView()
         
     def onOptions(self):
-        dlg = ExplorerOptionsDlg(self.showLights, self.showGameObjects, self.showEntities, self.showZones, self.showZoneLights, self)
+        dlg = ExplorerOptionsDlg(self.showLights, self.showGameObjects, self.showEntities, self.showZones, self.showZoneLights, self.showZoneTriggers, self)
         if dlg.exec_():
             self.showLights = dlg.lightCheckBox.isChecked()
             self.showGameObjects = dlg.gameObjectsCheckBox.isChecked()
@@ -545,6 +560,15 @@
                     childItem2.setText(0, lightName)
                     childItem2.setData(0, Qt.UserRole, QVariant(ModuleExplorer.LIGHT_IN_ZONE))
                     
+            if self.showZoneTriggers:
+                triggersItem = QTreeWidgetItem(childItem)
+                triggersItem.setText(0, "Triggers")
+                
+                for trigger in zone.triggerList:
+                    childItem2 = QTreeWidgetItem(triggersItem)
+                    childItem2.setText(0, trigger.name)
+                    childItem2.setData(0, Qt.UserRole, QVariant(ModuleExplorer.TRIGGER_IN_ZONE))
+                    
     def setCurrentModule(self, module):
         self.module = module
         self.updateView()

Modified: rl/trunk/editors/Lockenwickler/src/TriggerManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/TriggerManager.py	2009-04-23 14:42:02 UTC (rev 4909)
+++ rl/trunk/editors/Lockenwickler/src/TriggerManager.py	2009-04-26 11:10:24 UTC (rev 4910)
@@ -33,12 +33,16 @@
         self.data = data
 
 class Trigger():
-    def __init__(self):
-        self.className = ""
-        self.name = ""
+    def __init__(self, name = "", className = ""):
+        self.name = name
+        self.className = className
         self.properties = []
         
-    def addProperty(self):
+    def addProperty(self, name, type, data):
+        prop = TriggerProperty(name,  type, data)
+        self.properties.append(prop)
+        
+    def manualAddProperty(self):
         editor = GOGenericEditor("", "STRING", "", QApplication.focusWidget())
         if editor.exec_():
             name = str(editor.nameEditBox.text())
@@ -68,10 +72,18 @@
         
     def addDirectory(self, dir):
         self.directories.append(dir)
-        
         self.update()
     
-    def createTrigger(self):
+    def createTrigger(self, name, classname, properties):
+        trigger = Trigger(name, classname)
+        for prop in properties:
+            name = prop.attrib["name"]
+            type = prop.attrib["type"]
+            data = prop.attrib["data"]
+            trigger.addProperty(name, type, data)
+        return trigger
+        
+    def manualCreateTrigger(self):
         trigger = Trigger()
         
         dlg = AddTriggerDialog(trigger, TriggerManager.availableTriggers, self, QApplication.focusWidget())
@@ -81,6 +93,13 @@
         
         return False
     
+    def getTrigger(self, name):
+        for trigger in self.triggerInstances:
+            if trigger.name == name:
+                return trigger
+        
+        return None
+    
     def update(self):
         TriggerManager.availableTriggers = []
         

Modified: rl/trunk/editors/Lockenwickler/src/ZoneManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ZoneManager.py	2009-04-23 14:42:02 UTC (rev 4909)
+++ rl/trunk/editors/Lockenwickler/src/ZoneManager.py	2009-04-26 11:10:24 UTC (rev 4910)
@@ -141,8 +141,14 @@
                 self.areaList.remove(a)
                 del a
     
-    def addTrigger(self):
-        trigger = TriggerManager.instance.createTrigger()
+    def addTrigger(self, trigger):
+        if trigger is not None:
+            self.triggerList.append(trigger)
+            
+    def manualAddTrigger(self):
+        trigger = TriggerManager.instance.manualCreateTrigger()
+        if trigger is not False:
+            self.triggerList.append(trigger)
     
     def hide(self):
         self.sceneManager.getRootSceneNode().removeChild(self.zoneNode)
@@ -238,6 +244,16 @@
                 name = light.attrib["name"]
                 z.lightList.append(name)
                 
+            triggerNodes = zone.getiterator("trigger")
+            for trigger in triggerNodes:
+                name = trigger.attrib["name"]
+                classname = trigger.attrib["classname"]
+                properties = trigger.getiterator("property")
+                
+                trigger = TriggerManager.instance.createTrigger(name, classname, properties)
+                
+                z.addTrigger(name)
+                
             soundNodes = zone.getiterator("sound")
             for sound in soundNodes:
                 name = sound.attrib["name"]
@@ -284,6 +300,19 @@
             for lightName in zone.lightList:
                 lightElem = xml.SubElement(zoneElem, "light")
                 lightElem.attrib["name"] = str(lightName)
+                
+            for triggerName in zone.triggerList:
+                trigger = TriggerManager.instance.getTrigger(triggerName)
+                
+                triggerElem = xml.SubElement(zoneElem, "trigger")
+                triggerElem.attrib["name"] = str(trigger.name)
+                triggerElem.attrib["classname"] = str(trigger.name)
+                
+                for prop in trigger.properties:
+                    propElem = xml.SubElement(triggerElen, "property")
+                    triggerElem.attrib["name"] = str(trigger.name)
+                    triggerElem.attrib["type"] = str(trigger.type)
+                    triggerElem.attrib["data"] = str(trigger.data)
             
             for soundName in zone.soundList:
                 soundElem = xml.SubElement(zoneElem, "sound")



From fusion2 at mail.berlios.de  Sun Apr 26 13:48:51 2009
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Sun, 26 Apr 2009 13:48:51 +0200
Subject: [Dsa-hl-svn] r4911 - rl/trunk/editors/Lockenwickler/src
Message-ID: <200904261148.n3QBmpaG013194@sheep.berlios.de>

Author: fusion2
Date: 2009-04-26 13:48:49 +0200 (Sun, 26 Apr 2009)
New Revision: 4911

Modified:
   rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
   rl/trunk/editors/Lockenwickler/src/ZoneManager.py
Log:
- bugfixes in the trigger code and in the zone manager

Modified: rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-26 11:10:24 UTC (rev 4910)
+++ rl/trunk/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-26 11:48:49 UTC (rev 4911)
@@ -286,15 +286,15 @@
         
         #end remove all the things from the list we actually don't want to be selected
         for item in selItems:
-            print str(item.text(0))
-            print str(item.parent().text(0))
+            itemText = str(item.text(0))
+            parentText = str(item.parent().text(0))
             
-            if str(item.text(0)).startswith("Scene: ") or str(item.text(0)).startswith("Map: ") or str(item.text(0)).startswith("Zone: "):
+            if itemText.startswith("Scene: ") or itemText.startswith("Map: ") or itemText.startswith("Zone: "):
                 selItems.remove(item)
             elif item.data(0, Qt.UserRole).toInt()[0] == ModuleExplorer.LIGHT_IN_ZONE or item.data(0, Qt.UserRole).toInt()[0] == ModuleExplorer.TRIGGER_IN_ZONE:
                 selItems.remove(item)
-            elif item.text(0) == "Lights" and item.text(0) == "Triggers":
-                if str(item.parent().text(0)).startswith("Zone: "):
+            elif itemText == "Lights" or itemText == "Triggers":
+                if parentText.startswith("Zone: "):
                     selItems.remove(item)
         
         for item in selItems:

Modified: rl/trunk/editors/Lockenwickler/src/ZoneManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ZoneManager.py	2009-04-26 11:10:24 UTC (rev 4910)
+++ rl/trunk/editors/Lockenwickler/src/ZoneManager.py	2009-04-26 11:48:49 UTC (rev 4911)
@@ -147,7 +147,7 @@
             
     def manualAddTrigger(self):
         trigger = TriggerManager.instance.manualCreateTrigger()
-        if trigger is not False:
+        if trigger is not False and trigger is not None:
             self.triggerList.append(trigger)
     
     def hide(self):
@@ -252,7 +252,7 @@
                 
                 trigger = TriggerManager.instance.createTrigger(name, classname, properties)
                 
-                z.addTrigger(name)
+                z.addTrigger(trigger)
                 
             soundNodes = zone.getiterator("sound")
             for sound in soundNodes:
@@ -301,18 +301,16 @@
                 lightElem = xml.SubElement(zoneElem, "light")
                 lightElem.attrib["name"] = str(lightName)
                 
-            for triggerName in zone.triggerList:
-                trigger = TriggerManager.instance.getTrigger(triggerName)
-                
+            for trigger in zone.triggerList:
                 triggerElem = xml.SubElement(zoneElem, "trigger")
                 triggerElem.attrib["name"] = str(trigger.name)
                 triggerElem.attrib["classname"] = str(trigger.name)
                 
                 for prop in trigger.properties:
-                    propElem = xml.SubElement(triggerElen, "property")
-                    triggerElem.attrib["name"] = str(trigger.name)
-                    triggerElem.attrib["type"] = str(trigger.type)
-                    triggerElem.attrib["data"] = str(trigger.data)
+                    propElem = xml.SubElement(triggerElem, "property")
+                    propElem.attrib["name"] = str(prop.name)
+                    propElem.attrib["type"] = str(prop.type)
+                    propElem.attrib["data"] = str(prop.data)
             
             for soundName in zone.soundList:
                 soundElem = xml.SubElement(zoneElem, "sound")



