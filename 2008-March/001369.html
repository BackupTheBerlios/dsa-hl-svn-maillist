<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4298 - dependencies/OgreNewt/Mac/OgreNewt.xcodeproj	rl/trunk/Mac/Rastullah.xcodeproj rl/trunk/engine/ai/include	rl/trunk/engine/ai/src rl/trunk/engine/common/include	rl/trunk/engine/common/src rl/trunk/engine/core/src	rl/trunk/engine/core/src/nulldriver rl/trunk/engine/rules/src	rl/trunk/engine/script/include rl/trunk/engine/script/src	rl/trunk/engine/ui/include rl/trunk/engine/ui/src	rl/trunk/plugins/fmod4driver/include	rl/trunk/plugins/fmod4driver/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-March/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4298%20-%20dependencies/OgreNewt/Mac/OgreNewt.xcodeproj%0A%09rl/trunk/Mac/Rastullah.xcodeproj%20rl/trunk/engine/ai/include%0A%09rl/trunk/engine/ai/src%20rl/trunk/engine/common/include%0A%09rl/trunk/engine/common/src%20rl/trunk/engine/core/src%0A%09rl/trunk/engine/core/src/nulldriver%20rl/trunk/engine/rules/src%0A%09rl/trunk/engine/script/include%20rl/trunk/engine/script/src%0A%09rl/trunk/engine/ui/include%20rl/trunk/engine/ui/src%0A%09rl/trunk/plugins/fmod4driver/include%0A%09rl/trunk/plugins/fmod4driver/src&In-Reply-To=%3C200803182118.m2ILIKUf030709%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001368.html">
   <LINK REL="Next"  HREF="001370.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4298 - dependencies/OgreNewt/Mac/OgreNewt.xcodeproj	rl/trunk/Mac/Rastullah.xcodeproj rl/trunk/engine/ai/include	rl/trunk/engine/ai/src rl/trunk/engine/common/include	rl/trunk/engine/common/src rl/trunk/engine/core/src	rl/trunk/engine/core/src/nulldriver rl/trunk/engine/rules/src	rl/trunk/engine/script/include rl/trunk/engine/script/src	rl/trunk/engine/ui/include rl/trunk/engine/ui/src	rl/trunk/plugins/fmod4driver/include	rl/trunk/plugins/fmod4driver/src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4298%20-%20dependencies/OgreNewt/Mac/OgreNewt.xcodeproj%0A%09rl/trunk/Mac/Rastullah.xcodeproj%20rl/trunk/engine/ai/include%0A%09rl/trunk/engine/ai/src%20rl/trunk/engine/common/include%0A%09rl/trunk/engine/common/src%20rl/trunk/engine/core/src%0A%09rl/trunk/engine/core/src/nulldriver%20rl/trunk/engine/rules/src%0A%09rl/trunk/engine/script/include%20rl/trunk/engine/script/src%0A%09rl/trunk/engine/ui/include%20rl/trunk/engine/ui/src%0A%09rl/trunk/plugins/fmod4driver/include%0A%09rl/trunk/plugins/fmod4driver/src&In-Reply-To=%3C200803182118.m2ILIKUf030709%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4298 - dependencies/OgreNewt/Mac/OgreNewt.xcodeproj	rl/trunk/Mac/Rastullah.xcodeproj rl/trunk/engine/ai/include	rl/trunk/engine/ai/src rl/trunk/engine/common/include	rl/trunk/engine/common/src rl/trunk/engine/core/src	rl/trunk/engine/core/src/nulldriver rl/trunk/engine/rules/src	rl/trunk/engine/script/include rl/trunk/engine/script/src	rl/trunk/engine/ui/include rl/trunk/engine/ui/src	rl/trunk/plugins/fmod4driver/include	rl/trunk/plugins/fmod4driver/src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Tue Mar 18 22:18:20 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001368.html">[Dsa-hl-svn] r4297 - rl/trunk/engine/core/src
</A></li>
        <LI>Next message: <A HREF="001370.html">[Dsa-hl-svn] r4299 - rl/trunk/engine/script/swig
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1369">[ date ]</a>
              <a href="thread.html#1369">[ thread ]</a>
              <a href="subject.html#1369">[ subject ]</a>
              <a href="author.html#1369">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2008-03-18 22:18:05 +0100 (Tue, 18 Mar 2008)
New Revision: 4298

Removed:
   rl/trunk/engine/script/src/UnifiedFactory.cpp
Modified:
   dependencies/OgreNewt/Mac/OgreNewt.xcodeproj/project.pbxproj
   rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/trunk/engine/ai/include/AStar.h
   rl/trunk/engine/ai/include/AiWorld.h
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/ai/src/PhysicalObstacle.cpp
   rl/trunk/engine/common/include/Logger.h
   rl/trunk/engine/common/src/Logger.cpp
   rl/trunk/engine/core/src/ConfigurationManager.cpp
   rl/trunk/engine/core/src/RubyInterpreter.cpp
   rl/trunk/engine/core/src/SaveGameFile.cpp
   rl/trunk/engine/core/src/SaveGameFileWriter.cpp
   rl/trunk/engine/core/src/nulldriver/NullSound.cpp
   rl/trunk/engine/core/src/nulldriver/NullSoundStitching.cpp
   rl/trunk/engine/rules/src/SelectionHelper.cpp
   rl/trunk/engine/script/include/EntityNodeProcessor.h
   rl/trunk/engine/script/include/ScriptSubsystem.h
   rl/trunk/engine/script/src/EntityNodeProcessor.cpp
   rl/trunk/engine/ui/include/CombatGui.h
   rl/trunk/engine/ui/include/ControlState.h
   rl/trunk/engine/ui/include/FreeflightControlState.h
   rl/trunk/engine/ui/include/InputManager.h
   rl/trunk/engine/ui/include/WindowFactory.h
   rl/trunk/engine/ui/include/WindowManager.h
   rl/trunk/engine/ui/src/CombatWindow.cpp
   rl/trunk/engine/ui/src/DialogControlState.cpp
   rl/trunk/engine/ui/src/InputManager.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/UiSubsystem.cpp
   rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h
   rl/trunk/plugins/fmod4driver/include/Fmod4DriverPrerequisites.h
   rl/trunk/plugins/fmod4driver/include/Fmod4Listener.h
   rl/trunk/plugins/fmod4driver/include/Fmod4Sound.h
   rl/trunk/plugins/fmod4driver/include/Fmod4SoundStitching.h
   rl/trunk/plugins/fmod4driver/src/Fmod4ConfigComponent.cpp
   rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp
   rl/trunk/plugins/fmod4driver/src/Fmod4Sound.cpp
   rl/trunk/plugins/fmod4driver/src/Fmod4SoundStitching.cpp
Log:
Fix MacOS build
* Change OgreNewt includes
* remove unneccessary includes
* add MacOS target for RlScript.bundle

Modified: dependencies/OgreNewt/Mac/OgreNewt.xcodeproj/project.pbxproj
===================================================================
--- dependencies/OgreNewt/Mac/OgreNewt.xcodeproj/project.pbxproj	2008-03-18 18:57:00 UTC (rev 4297)
+++ dependencies/OgreNewt/Mac/OgreNewt.xcodeproj/project.pbxproj	2008-03-18 21:18:05 UTC (rev 4298)
@@ -306,6 +306,10 @@
 		4FADC24308B4156D00ABE55E /* Debug */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
+				ARCHS = (
+					i386,
+					ppc,
+				);
 				COPY_PHASE_STRIP = NO;
 				DYLIB_COMPATIBILITY_VERSION = 1;
 				DYLIB_CURRENT_VERSION = 1;
@@ -329,9 +333,13 @@
 		4FADC24408B4156D00ABE55E /* Release */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
-				ARCHS = i386;
+				ARCHS = (
+					i386,
+					ppc,
+				);
 				DYLIB_COMPATIBILITY_VERSION = 1;
 				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_SEARCH_PATHS = &quot;/Library/Frameworks/Ogre.framework/**&quot;;
 				FRAMEWORK_VERSION = A;
 				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
 				GCC_MODEL_TUNING = G5;
@@ -343,6 +351,10 @@
 				LIBRARY_SEARCH_PATHS = /usr/local/lib;
 				LIBRARY_STYLE = DYNAMIC;
 				MACH_O_TYPE = mh_dylib;
+				OTHER_LDFLAGS = (
+					&quot;-framework&quot;,
+					Ogre,
+				);
 				PRODUCT_NAME = OgreNewt;
 				WRAPPER_EXTENSION = framework;
 			};
@@ -364,8 +376,12 @@
 			buildSettings = {
 				GCC_WARN_ABOUT_RETURN_TYPE = YES;
 				GCC_WARN_UNUSED_VARIABLE = YES;
-				HEADER_SEARCH_PATHS = /Library/Frameworks/Ogre.framework/Headers;
+				HEADER_SEARCH_PATHS = (
+					/usr/local/include,
+					/Library/Frameworks/Ogre.framework/Headers,
+				);
 				PREBINDING = NO;
+				SCAN_ALL_SOURCE_FILES_FOR_INCLUDES = YES;
 				SDKROOT = /Developer/SDKs/MacOSX10.4u.sdk;
 			};
 			name = Release;

Modified: rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-03-18 21:18:05 UTC (rev 4298)
@@ -349,16 +349,13 @@
 		444EAE590BD0E65B00C6D4A0 /* TalentStateSet.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE2B0BD0E65B00C6D4A0 /* TalentStateSet.h */; };
 		444EAE5E0BD0E65B00C6D4A0 /* Weapon.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE300BD0E65B00C6D4A0 /* Weapon.h */; };
 		444EAE5F0BD0E65B00C6D4A0 /* ZauberStateSet.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE310BD0E65B00C6D4A0 /* ZauberStateSet.h */; };
-		444EAEBA0BD0F06700C6D4A0 /* libxerces-c.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */; };
 		444EAEBF0BD0F09900C6D4A0 /* CEGUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
 		444EAEC00BD0F09900C6D4A0 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
 		444EAEF30BD1150500C6D4A0 /* CEGUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
-		444EAEF50BD1150500C6D4A0 /* libxerces-c.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */; };
 		444EAEF60BD1150500C6D4A0 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
 		444EB0890BD1153500C6D4A0 /* OgreNewt.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0880BD1153500C6D4A0 /* OgreNewt.framework */; };
 		444EB0AB0BD115CB00C6D4A0 /* libRlCommon.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */; };
 		444EB0D40BD1198B00C6D4A0 /* CEGUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
-		444EB0D50BD1198B00C6D4A0 /* libxerces-c.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */; };
 		444EB0D60BD1198B00C6D4A0 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
 		444EB0D80BD1198B00C6D4A0 /* OgreNewt.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0880BD1153500C6D4A0 /* OgreNewt.framework */; };
 		444EB0DB0BD119BB00C6D4A0 /* OpenSteer.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0DA0BD119BB00C6D4A0 /* OpenSteer.framework */; };
@@ -371,7 +368,6 @@
 		444EB1CE0BD1595100C6D4A0 /* OgreNewt.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0880BD1153500C6D4A0 /* OgreNewt.framework */; };
 		444EB3410BD172BA00C6D4A0 /* CEGUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
 		444EB3420BD172BA00C6D4A0 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
-		444EB3430BD172FA00C6D4A0 /* libxerces-c.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */; };
 		444EB3440BD1730C00C6D4A0 /* libRlCommon.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */; };
 		444EB3450BD1730C00C6D4A0 /* libRlCore.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */; };
 		444EB3480BD1733900C6D4A0 /* OgreNewt.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0880BD1153500C6D4A0 /* OgreNewt.framework */; };
@@ -384,7 +380,6 @@
 		444EB79E0BD195E800C6D4A0 /* libRlRules.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC370BD0E44900C6D4A0 /* libRlRules.dylib */; };
 		444EB7A00BD195E800C6D4A0 /* libRlUi.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC3E0BD0E46000C6D4A0 /* libRlUi.dylib */; };
 		444EB7A20BD1963A00C6D4A0 /* CEGUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
-		444EB7A70BD1963A00C6D4A0 /* libxerces-c.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */; };
 		444EB7A80BD1963A00C6D4A0 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
 		444EB7A90BD1963A00C6D4A0 /* OgreCEGUIRenderer.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB3720BD1784A00C6D4A0 /* OgreCEGUIRenderer.framework */; };
 		444EB7AA0BD1963A00C6D4A0 /* OgreNewt.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0880BD1153500C6D4A0 /* OgreNewt.framework */; };
@@ -421,7 +416,6 @@
 		446BF4D20C453B9E0013C214 /* CombatControlState.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4D00C453B9E0013C214 /* CombatControlState.h */; };
 		446BF4D30C453B9E0013C214 /* CombatWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4D10C453B9E0013C214 /* CombatWindow.h */; };
 		446BF4D60C453C1D0013C214 /* ItemDescriptionDragContainer.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 446BF4D50C453C1D0013C214 /* ItemDescriptionDragContainer.cpp */; };
-		44D8145C0BF7B52600534175 /* GameObjectConstants.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814590BF7B52600534175 /* GameObjectConstants.h */; };
 		44D8145D0BF7B52600534175 /* SelectionHelper.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D8145A0BF7B52600534175 /* SelectionHelper.h */; };
 		44D8145E0BF7B52600534175 /* Selector.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D8145B0BF7B52600534175 /* Selector.h */; };
 		44D814610BF7B58A00534175 /* ProgressWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D8145F0BF7B58A00534175 /* ProgressWindow.h */; };
@@ -437,15 +431,20 @@
 		44D8147A0BF7B62F00534175 /* Trigger.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814750BF7B62F00534175 /* Trigger.h */; };
 		44D8147B0BF7B62F00534175 /* Zone.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814760BF7B62F00534175 /* Zone.h */; };
 		44D8147C0BF7B62F00534175 /* ZoneManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814770BF7B62F00534175 /* ZoneManager.h */; };
-		481879EC0D885BBE00CE6689 /* libxerces-c.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */; };
-		481879ED0D885BC000CE6689 /* libxerces-c.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */; };
-		48187A960D885BD800CE6689 /* CEGUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
 		48187AAB0D885CBB00CE6689 /* libRlCommon.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */; };
 		48187AAC0D885CBB00CE6689 /* libRlCore.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */; };
 		48187AAD0D885CBB00CE6689 /* libRlAi.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 444EAC270BD0E3FF00C6D4A0 /* libRlAi.dylib */; };
 		48187AAE0D885CBB00CE6689 /* libRlRules.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 444EAC370BD0E44900C6D4A0 /* libRlRules.dylib */; };
 		48187AAF0D885CBB00CE6689 /* libRlUi.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 444EAC3E0BD0E46000C6D4A0 /* libRlUi.dylib */; };
-		48187AB00D885CBB00CE6689 /* libRlScript.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 4836F88D0D88592800E3632F /* libRlScript.dylib */; };
+		483514870D8AED510077477D /* OIS.framework in Resources */ = {isa = PBXBuildFile; fileRef = 4857E4E40D46A664009D376D /* OIS.framework */; };
+		483514880D8AED510077477D /* libboost_filesystem.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 4857E3A40D469FEA009D376D /* libboost_filesystem.dylib */; };
+		483514890D8AED510077477D /* libmeshmagick.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 440785DD0C09D231006E496D /* libmeshmagick.dylib */; };
+		4835148A0D8AED510077477D /* libruby.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 483646A10D83D57800912FEC /* libruby.dylib */; };
+		4835148B0D8AED510077477D /* OgreCEGUIRenderer.framework in Resources */ = {isa = PBXBuildFile; fileRef = 444EB3720BD1784A00C6D4A0 /* OgreCEGUIRenderer.framework */; };
+		4835148C0D8AED510077477D /* OpenSteer.framework in Resources */ = {isa = PBXBuildFile; fileRef = 444EB0DA0BD119BB00C6D4A0 /* OpenSteer.framework */; };
+		4835148D0D8AED510077477D /* CEGUI.framework in Resources */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
+		4835148E0D8AED510077477D /* Ogre.framework in Resources */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
+		4835148F0D8AED510077477D /* OgreNewt.framework in Resources */ = {isa = PBXBuildFile; fileRef = 444EB0880BD1153500C6D4A0 /* OgreNewt.framework */; };
 		483646990D83D13700912FEC /* ContentLoader.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646960D83D13700912FEC /* ContentLoader.h */; };
 		4836469A0D83D13700912FEC /* SoundStitching.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646970D83D13700912FEC /* SoundStitching.h */; };
 		4836469B0D83D13700912FEC /* StartAnimationJob.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646980D83D13700912FEC /* StartAnimationJob.h */; };
@@ -456,46 +455,21 @@
 		483646C40D83D62E00912FEC /* SaveGameFileWriter.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485A05820D71EDF20024198D /* SaveGameFileWriter.cpp */; };
 		483646C50D83D62E00912FEC /* SaveGameManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485A05830D71EDF20024198D /* SaveGameManager.cpp */; };
 		483646D30D83D6DD00912FEC /* SaveGameFile.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485A05800D71EDF20024198D /* SaveGameFile.cpp */; };
-		4836F8910D88594A00E3632F /* stdinc.h in Headers */ = {isa = PBXBuildFile; fileRef = 4404DA840C48D01E007B4657 /* stdinc.h */; };
-		4836F8920D88594A00E3632F /* UnifiedFactory.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4810C4532B50013C214 /* UnifiedFactory.h */; };
-		4836F8930D88594A00E3632F /* AbstractMapNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825ED0BF7B32100C5A94F /* AbstractMapNodeProcessor.h */; };
-		4836F8940D88594A00E3632F /* EntityNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825EE0BF7B32100C5A94F /* EntityNodeProcessor.h */; };
-		4836F8950D88594A00E3632F /* EnvironmentProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825EF0BF7B32100C5A94F /* EnvironmentProcessor.h */; };
-		4836F8960D88594A00E3632F /* GameObjectNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825F00BF7B32100C5A94F /* GameObjectNodeProcessor.h */; };
-		4836F8970D88594A00E3632F /* LightNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825F10BF7B32100C5A94F /* LightNodeProcessor.h */; };
-		4836F8980D88594A00E3632F /* MapLoader.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825F20BF7B32100C5A94F /* MapLoader.h */; };
-		4836F8990D88594A00E3632F /* ParticleSystemNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825F30BF7B32100C5A94F /* ParticleSystemNodeProcessor.h */; };
-		4836F89A0D88594A00E3632F /* SoundNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825F40BF7B32100C5A94F /* SoundNodeProcessor.h */; };
-		4836F89B0D88594A00E3632F /* TriggerFactory.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825F50BF7B32100C5A94F /* TriggerFactory.h */; };
-		4836F89C0D88594A00E3632F /* WaypointProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825F60BF7B32100C5A94F /* WaypointProcessor.h */; };
-		4836F89D0D88594A00E3632F /* ZoneProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825F70BF7B32100C5A94F /* ZoneProcessor.h */; };
-		4836F89E0D88594A00E3632F /* AbstractMapNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825D90BF7B2B200C5A94F /* AbstractMapNodeProcessor.cpp */; };
-		4836F89F0D88594A00E3632F /* EntityNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DA0BF7B2B200C5A94F /* EntityNodeProcessor.cpp */; };
-		4836F8A00D88594A00E3632F /* EnvironmentProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DB0BF7B2B200C5A94F /* EnvironmentProcessor.cpp */; };
-		4836F8A10D88594A00E3632F /* GameObjectNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DC0BF7B2B200C5A94F /* GameObjectNodeProcessor.cpp */; };
-		4836F8A20D88594A00E3632F /* LightNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DD0BF7B2B200C5A94F /* LightNodeProcessor.cpp */; };
-		4836F8A30D88594A00E3632F /* MapLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DE0BF7B2B200C5A94F /* MapLoader.cpp */; };
-		4836F8A40D88594A00E3632F /* ParticleSystemNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DF0BF7B2B200C5A94F /* ParticleSystemNodeProcessor.cpp */; };
-		4836F8A50D88594A00E3632F /* SoundNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825E00BF7B2B200C5A94F /* SoundNodeProcessor.cpp */; };
-		4836F8A60D88594A00E3632F /* WaypointProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825E10BF7B2B200C5A94F /* WaypointProcessor.cpp */; };
-		4836F8A70D88594A00E3632F /* ZoneProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825E20BF7B2B200C5A94F /* ZoneProcessor.cpp */; };
-		4836F8A80D88594A00E3632F /* RlExports.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EB6BC0BD1891400C6D4A0 /* RlExports.cpp */; };
-		4836F8A90D88594A00E3632F /* ScriptObjectMarker.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAE670BD0E6D400C6D4A0 /* ScriptObjectMarker.cpp */; };
-		4836F8AA0D88594A00E3632F /* ScriptSubsystem.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAE680BD0E6D400C6D4A0 /* ScriptSubsystem.cpp */; };
-		4836F8AB0D88594A00E3632F /* ScriptObjectMarker.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE610BD0E6C000C6D4A0 /* ScriptObjectMarker.h */; };
-		4836F8AC0D88594A00E3632F /* ScriptPrerequisites.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE620BD0E6C000C6D4A0 /* ScriptPrerequisites.h */; };
-		4836F8AD0D88594A00E3632F /* ScriptSubsystem.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE630BD0E6C000C6D4A0 /* ScriptSubsystem.h */; };
-		4836F8AE0D88595800E3632F /* libRlScript.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 4836F88D0D88592800E3632F /* libRlScript.dylib */; };
-		4836F8B60D885A8A00E3632F /* libRlAi.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC270BD0E3FF00C6D4A0 /* libRlAi.dylib */; };
-		4836F8B70D885A8A00E3632F /* libRlCommon.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */; };
-		4836F8B80D885A8A00E3632F /* libRlCore.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */; };
-		4836F8B90D885A8A00E3632F /* libRlRules.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC370BD0E44900C6D4A0 /* libRlRules.dylib */; };
-		4836F8BA0D885A8A00E3632F /* libRlUi.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC3E0BD0E46000C6D4A0 /* libRlUi.dylib */; };
-		4836F8BB0D885AA800E3632F /* libruby.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 483646A10D83D57800912FEC /* libruby.dylib */; };
+		48365BE60D8D560E00BF3313 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
+		48365BE80D8D562D00BF3313 /* libRlCore.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */; };
+		48365BE90D8D562D00BF3313 /* libRlUi.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC3E0BD0E46000C6D4A0 /* libRlUi.dylib */; };
+		48365BEC0D8D56DC00BF3313 /* libRlCommon.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */; };
+		48365C950D8D56EA00BF3313 /* CEGUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
+		48365C980D8D576100BF3313 /* RlScriptExports.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48365C970D8D576100BF3313 /* RlScriptExports.cpp */; };
+		48365CA30D8D57ED00BF3313 /* RlScriptExports.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48365C970D8D576100BF3313 /* RlScriptExports.cpp */; };
+		4836CBC90D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4836CBC80D8FB0BE002FE5D7 /* Xerces.framework */; };
+		4836CBCA0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4836CBC80D8FB0BE002FE5D7 /* Xerces.framework */; };
+		4836CBCB0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4836CBC80D8FB0BE002FE5D7 /* Xerces.framework */; };
+		4836CBCC0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4836CBC80D8FB0BE002FE5D7 /* Xerces.framework */; };
+		4836CBCD0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4836CBC80D8FB0BE002FE5D7 /* Xerces.framework */; };
+		4836CBCE0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4836CBC80D8FB0BE002FE5D7 /* Xerces.framework */; };
+		4836CBCF0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4836CBC80D8FB0BE002FE5D7 /* Xerces.framework */; };
 		4836F8BC0D885AAA00E3632F /* libruby.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 483646A10D83D57800912FEC /* libruby.dylib */; };
-		4836F9B70D885ACF00E3632F /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
-		4836F9B80D885ACF00E3632F /* OgreNewt.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0880BD1153500C6D4A0 /* OgreNewt.framework */; };
-		4836F9BA0D885AF000E3632F /* TriggerFactory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48389C1A0D867AA900AFAB66 /* TriggerFactory.cpp */; };
 		48380B190D800EED0013EE0C /* StartAnimationJob.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48380B180D800EED0013EE0C /* StartAnimationJob.cpp */; };
 		48380B1A0D8010ED0013EE0C /* TimeSource.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485A05850D71EDF20024198D /* TimeSource.cpp */; };
 		48389B920D86741F00AFAB66 /* CombatGui.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48389B8E0D86741F00AFAB66 /* CombatGui.cpp */; };
@@ -521,6 +495,7 @@
 		48389C290D867B1A00AFAB66 /* Trigger.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485A05860D71EDF20024198D /* Trigger.cpp */; };
 		48389C2C0D867B2A00AFAB66 /* PolynomicSoundFadeFunctor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */; };
 		48389C2D0D867B2A00AFAB66 /* PolynomicSoundFadeFunctor.h in Headers */ = {isa = PBXBuildFile; fileRef = 485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */; };
+		483B69DB0D8D4BC900C4C190 /* RlExports.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EB6BC0BD1891400C6D4A0 /* RlExports.cpp */; };
 		483D31110D85B1AF003477A0 /* NullSoundStitching.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D31100D85B1AF003477A0 /* NullSoundStitching.h */; };
 		483D31130D85B1C2003477A0 /* NullSoundStitching.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */; };
 		483D31200D85B215003477A0 /* Combatant.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D31150D85B215003477A0 /* Combatant.h */; };
@@ -568,6 +543,58 @@
 		483D31810D85B3B7003477A0 /* stdinc.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 483D31720D85B3B7003477A0 /* stdinc.cpp */; };
 		483D31820D85B3B7003477A0 /* WalkPathBehaviour.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 483D31730D85B3B7003477A0 /* WalkPathBehaviour.cpp */; };
 		483D31B50D85B72D003477A0 /* libboost_filesystem.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 4857E3A40D469FEA009D376D /* libboost_filesystem.dylib */; };
+		483D869D0D8C3DA200F3629E /* Fmod4ConfigComponent.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D868C0D8C3DA200F3629E /* Fmod4ConfigComponent.h */; };
+		483D869E0D8C3DA200F3629E /* Fmod4Driver.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D868D0D8C3DA200F3629E /* Fmod4Driver.h */; };
+		483D869F0D8C3DA200F3629E /* Fmod4DriverPrerequisites.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D868E0D8C3DA200F3629E /* Fmod4DriverPrerequisites.h */; };
+		483D86A00D8C3DA200F3629E /* Fmod4Listener.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D868F0D8C3DA200F3629E /* Fmod4Listener.h */; };
+		483D86A10D8C3DA200F3629E /* Fmod4Sound.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D86900D8C3DA200F3629E /* Fmod4Sound.h */; };
+		483D86A20D8C3DA200F3629E /* Fmod4SoundStitching.h in Headers */ = {isa = PBXBuildFile; fileRef = 483D86910D8C3DA200F3629E /* Fmod4SoundStitching.h */; };
+		483D86A30D8C3DA200F3629E /* Fmod4ConfigComponent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 483D86960D8C3DA200F3629E /* Fmod4ConfigComponent.cpp */; };
+		483D86A40D8C3DA200F3629E /* Fmod4Driver.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 483D86970D8C3DA200F3629E /* Fmod4Driver.cpp */; };
+		483D86A50D8C3DA200F3629E /* Fmod4DriverDllMain.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 483D86980D8C3DA200F3629E /* Fmod4DriverDllMain.cpp */; };
+		483D86A60D8C3DA200F3629E /* Fmod4Listener.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 483D86990D8C3DA200F3629E /* Fmod4Listener.cpp */; };
+		483D86A70D8C3DA200F3629E /* Fmod4Sound.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 483D869A0D8C3DA200F3629E /* Fmod4Sound.cpp */; };
+		483D86A80D8C3DA200F3629E /* Fmod4SoundStitching.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 483D869B0D8C3DA200F3629E /* Fmod4SoundStitching.cpp */; };
+		483D87CE0D8C564400F3629E /* libRlScript.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48570C1B0D8A6C5400096E35 /* libRlScript.dylib */; };
+		48570C210D8A6C9000096E35 /* stdinc.h in Headers */ = {isa = PBXBuildFile; fileRef = 4404DA840C48D01E007B4657 /* stdinc.h */; };
+		48570C220D8A6C9000096E35 /* UnifiedFactory.h in Headers */ = {isa = PBXBuildFile; fileRef = 446BF4810C4532B50013C214 /* UnifiedFactory.h */; };
+		48570C230D8A6C9000096E35 /* AbstractMapNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825ED0BF7B32100C5A94F /* AbstractMapNodeProcessor.h */; };
+		48570C240D8A6C9000096E35 /* EntityNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825EE0BF7B32100C5A94F /* EntityNodeProcessor.h */; };
+		48570C250D8A6C9000096E35 /* EnvironmentProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825EF0BF7B32100C5A94F /* EnvironmentProcessor.h */; };
+		48570C260D8A6C9000096E35 /* GameObjectNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825F00BF7B32100C5A94F /* GameObjectNodeProcessor.h */; };
+		48570C270D8A6C9000096E35 /* LightNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825F10BF7B32100C5A94F /* LightNodeProcessor.h */; };
+		48570C280D8A6C9000096E35 /* MapLoader.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825F20BF7B32100C5A94F /* MapLoader.h */; };
+		48570C290D8A6C9000096E35 /* ParticleSystemNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825F30BF7B32100C5A94F /* ParticleSystemNodeProcessor.h */; };
+		48570C2A0D8A6C9000096E35 /* SoundNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825F40BF7B32100C5A94F /* SoundNodeProcessor.h */; };
+		48570C2B0D8A6C9000096E35 /* TriggerFactory.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825F50BF7B32100C5A94F /* TriggerFactory.h */; };
+		48570C2C0D8A6C9000096E35 /* WaypointProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825F60BF7B32100C5A94F /* WaypointProcessor.h */; };
+		48570C2D0D8A6C9000096E35 /* ZoneProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 444825F70BF7B32100C5A94F /* ZoneProcessor.h */; };
+		48570C2E0D8A6C9000096E35 /* AbstractMapNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825D90BF7B2B200C5A94F /* AbstractMapNodeProcessor.cpp */; };
+		48570C2F0D8A6C9000096E35 /* EntityNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DA0BF7B2B200C5A94F /* EntityNodeProcessor.cpp */; };
+		48570C300D8A6C9000096E35 /* EnvironmentProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DB0BF7B2B200C5A94F /* EnvironmentProcessor.cpp */; };
+		48570C310D8A6C9000096E35 /* GameObjectNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DC0BF7B2B200C5A94F /* GameObjectNodeProcessor.cpp */; };
+		48570C320D8A6C9000096E35 /* LightNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DD0BF7B2B200C5A94F /* LightNodeProcessor.cpp */; };
+		48570C330D8A6C9000096E35 /* MapLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DE0BF7B2B200C5A94F /* MapLoader.cpp */; };
+		48570C340D8A6C9000096E35 /* ParticleSystemNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825DF0BF7B2B200C5A94F /* ParticleSystemNodeProcessor.cpp */; };
+		48570C350D8A6C9000096E35 /* SoundNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825E00BF7B2B200C5A94F /* SoundNodeProcessor.cpp */; };
+		48570C360D8A6C9000096E35 /* WaypointProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825E10BF7B2B200C5A94F /* WaypointProcessor.cpp */; };
+		48570C370D8A6C9000096E35 /* ZoneProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444825E20BF7B2B200C5A94F /* ZoneProcessor.cpp */; };
+		48570C390D8A6C9000096E35 /* ScriptObjectMarker.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAE670BD0E6D400C6D4A0 /* ScriptObjectMarker.cpp */; };
+		48570C3A0D8A6C9000096E35 /* ScriptSubsystem.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAE680BD0E6D400C6D4A0 /* ScriptSubsystem.cpp */; };
+		48570C3B0D8A6C9000096E35 /* ScriptObjectMarker.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE610BD0E6C000C6D4A0 /* ScriptObjectMarker.h */; };
+		48570C3C0D8A6C9000096E35 /* ScriptPrerequisites.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE620BD0E6C000C6D4A0 /* ScriptPrerequisites.h */; };
+		48570C3D0D8A6C9000096E35 /* ScriptSubsystem.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EAE630BD0E6C000C6D4A0 /* ScriptSubsystem.h */; };
+		48570C450D8A6E9900096E35 /* libRlAi.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC270BD0E3FF00C6D4A0 /* libRlAi.dylib */; };
+		48570C460D8A6E9900096E35 /* libRlCommon.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */; };
+		48570C470D8A6E9900096E35 /* libRlCore.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAB610BD0E2DA00C6D4A0 /* libRlCore.dylib */; };
+		48570C480D8A6E9900096E35 /* libRlRules.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC370BD0E44900C6D4A0 /* libRlRules.dylib */; };
+		48570C490D8A6E9900096E35 /* libRlUi.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAC3E0BD0E46000C6D4A0 /* libRlUi.dylib */; };
+		48570C4A0D8A6EA200096E35 /* CEGUI.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */; };
+		48570CF20D8A6EA600096E35 /* libruby.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 483646A10D83D57800912FEC /* libruby.dylib */; };
+		48570CF30D8A6EAD00096E35 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */; };
+		48570DDA0D8A6EB500096E35 /* OgreNewt.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EB0880BD1153500C6D4A0 /* OgreNewt.framework */; };
+		48570DFE0D8A6F3300096E35 /* TriggerFactory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48389C1A0D867AA900AFAB66 /* TriggerFactory.cpp */; };
+		48570E020D8A6F8300096E35 /* libRlScript.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48570C1B0D8A6C5400096E35 /* libRlScript.dylib */; };
 		4857E3A50D469FEA009D376D /* libboost_filesystem.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 4857E3A40D469FEA009D376D /* libboost_filesystem.dylib */; };
 		4857E3A60D469FEA009D376D /* libboost_filesystem.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 4857E3A40D469FEA009D376D /* libboost_filesystem.dylib */; };
 		4857E3A70D469FEA009D376D /* libboost_filesystem.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 4857E3A40D469FEA009D376D /* libboost_filesystem.dylib */; };
@@ -650,20 +677,83 @@
 			remoteGlobalIDString = 444EAB600BD0E2DA00C6D4A0;
 			remoteInfo = RlCore;
 		};
-		4836F8B30D8859E400E3632F /* PBXContainerItemProxy */ = {
+		48389BC50D86762F00AFAB66 /* PBXContainerItemProxy */ = {
 			isa = PBXContainerItemProxy;
 			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
 			proxyType = 1;
-			remoteGlobalIDString = 4836F88C0D88592800E3632F;
+			remoteGlobalIDString = 444EAC260BD0E3FF00C6D4A0;
+			remoteInfo = RlAi;
+		};
+		483B69C10D8D4A3500C4C190 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 48570C1A0D8A6C5400096E35;
 			remoteInfo = RlScript;
 		};
-		48389BC50D86762F00AFAB66 /* PBXContainerItemProxy */ = {
+		483B69C30D8D4A3500C4C190 /* PBXContainerItemProxy */ = {
 			isa = PBXContainerItemProxy;
 			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
 			proxyType = 1;
+			remoteGlobalIDString = 444EAC3D0BD0E46000C6D4A0;
+			remoteInfo = RlUi;
+		};
+		483B69C50D8D4A3500C4C190 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 444EAC360BD0E44900C6D4A0;
+			remoteInfo = RlRules;
+		};
+		483B69C70D8D4A3500C4C190 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
 			remoteGlobalIDString = 444EAC260BD0E3FF00C6D4A0;
 			remoteInfo = RlAi;
 		};
+		483B69C90D8D4A3500C4C190 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 444EAB600BD0E2DA00C6D4A0;
+			remoteInfo = RlCore;
+		};
+		483B69CB0D8D4A3500C4C190 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 444EAAB10BD0E0FB00C6D4A0;
+			remoteInfo = RlCommon;
+		};
+		483B6A010D8D4C0A00C4C190 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 483D866F0D8C3A3300F3629E;
+			remoteInfo = RlFmod4Driver;
+		};
+		483B6A040D8D4C2700C4C190 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 444EAC3D0BD0E46000C6D4A0;
+			remoteInfo = RlUi;
+		};
+		483D87D70D8C566400F3629E /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 483D87C80D8C55E500F3629E;
+			remoteInfo = RlScriptExports;
+		};
+		48570C1E0D8A6C6900096E35 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = 20286C28FDCF999611CA2CEA /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = 48570C1A0D8A6C5400096E35;
+			remoteInfo = RlScript;
+		};
 /* End PBXContainerItemProxy section */
 
 /* Begin PBXFileReference section */
@@ -672,7 +762,6 @@
 		4404DA6E0C48CEE2007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/ai/include/stdinc.h; sourceTree = SOURCE_ROOT; };
 		4404DA7C0C48CFB3007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/common/include/stdinc.h; sourceTree = SOURCE_ROOT; };
 		4404DA7E0C48CFC7007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/core/include/stdinc.h; sourceTree = SOURCE_ROOT; };
-		4404DA800C48CFDE007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/dialog/include/stdinc.h; sourceTree = SOURCE_ROOT; };
 		4404DA820C48D005007B4657 /* stdinc.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = stdinc.cpp; path = ../engine/rules/src/stdinc.cpp; sourceTree = SOURCE_ROOT; };
 		4404DA840C48D01E007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/script/include/stdinc.h; sourceTree = SOURCE_ROOT; };
 		4404DA850C48D037007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/ui/include/stdinc.h; sourceTree = SOURCE_ROOT; };
@@ -962,43 +1051,6 @@
 		444EAD2B0BD0E58C00C6D4A0 /* WindowFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WindowFactory.h; path = ../engine/ui/include/WindowFactory.h; sourceTree = SOURCE_ROOT; };
 		444EAD2C0BD0E58C00C6D4A0 /* WindowFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WindowFadeJob.h; path = ../engine/ui/include/WindowFadeJob.h; sourceTree = SOURCE_ROOT; };
 		444EAD2D0BD0E58C00C6D4A0 /* WindowManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WindowManager.h; path = ../engine/ui/include/WindowManager.h; sourceTree = SOURCE_ROOT; };
-		444EAD600BD0E5D500C6D4A0 /* ContextConditionProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ContextConditionProcessor.cpp; path = ../engine/dialog/src/ContextConditionProcessor.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD610BD0E5D500C6D4A0 /* ContextInterpreter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ContextInterpreter.cpp; path = ../engine/dialog/src/ContextInterpreter.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD620BD0E5D500C6D4A0 /* DialogCharacter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogCharacter.cpp; path = ../engine/dialog/src/DialogCharacter.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD630BD0E5D500C6D4A0 /* DialogOption.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogOption.cpp; path = ../engine/dialog/src/DialogOption.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD640BD0E5D500C6D4A0 /* DialogResponse.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogResponse.cpp; path = ../engine/dialog/src/DialogResponse.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD650BD0E5D500C6D4A0 /* DialogScriptProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogScriptProcessor.cpp; path = ../engine/dialog/src/DialogScriptProcessor.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD660BD0E5D500C6D4A0 /* DialogSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogSubsystem.cpp; path = ../engine/dialog/src/DialogSubsystem.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD670BD0E5D500C6D4A0 /* ScriptProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ScriptProcessor.cpp; path = ../engine/dialog/src/ScriptProcessor.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD720BD0E5E900C6D4A0 /* CreaturePredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CreaturePredicates.cpp; path = ../engine/dialog/src/predicates/CreaturePredicates.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD730BD0E5E900C6D4A0 /* EigenschaftsProbePredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = EigenschaftsProbePredicates.cpp; path = ../engine/dialog/src/predicates/EigenschaftsProbePredicates.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD740BD0E5E900C6D4A0 /* EigenschaftsWertPredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = EigenschaftsWertPredicates.cpp; path = ../engine/dialog/src/predicates/EigenschaftsWertPredicates.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD750BD0E5E900C6D4A0 /* GrundWertPredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GrundWertPredicates.cpp; path = ../engine/dialog/src/predicates/GrundWertPredicates.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD760BD0E5E900C6D4A0 /* QuestKnownPredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = QuestKnownPredicates.cpp; path = ../engine/dialog/src/predicates/QuestKnownPredicates.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD770BD0E5E900C6D4A0 /* QuestPartsPredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = QuestPartsPredicates.cpp; path = ../engine/dialog/src/predicates/QuestPartsPredicates.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD780BD0E5E900C6D4A0 /* QuestStatePredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = QuestStatePredicates.cpp; path = ../engine/dialog/src/predicates/QuestStatePredicates.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD790BD0E5E900C6D4A0 /* ScriptPredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ScriptPredicates.cpp; path = ../engine/dialog/src/predicates/ScriptPredicates.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD7A0BD0E5E900C6D4A0 /* TalentProbePredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TalentProbePredicates.cpp; path = ../engine/dialog/src/predicates/TalentProbePredicates.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD7B0BD0E5E900C6D4A0 /* TalentWertPredicates.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TalentWertPredicates.cpp; path = ../engine/dialog/src/predicates/TalentWertPredicates.cpp; sourceTree = SOURCE_ROOT; };
-		444EAD880BD0E60000C6D4A0 /* ContextConditionProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ContextConditionProcessor.h; path = ../engine/dialog/include/ContextConditionProcessor.h; sourceTree = SOURCE_ROOT; };
-		444EAD890BD0E60000C6D4A0 /* ContextInterpreter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ContextInterpreter.h; path = ../engine/dialog/include/ContextInterpreter.h; sourceTree = SOURCE_ROOT; };
-		444EAD8A0BD0E60000C6D4A0 /* DialogCharacter.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogCharacter.h; path = ../engine/dialog/include/DialogCharacter.h; sourceTree = SOURCE_ROOT; };
-		444EAD8B0BD0E60000C6D4A0 /* DialogOption.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogOption.h; path = ../engine/dialog/include/DialogOption.h; sourceTree = SOURCE_ROOT; };
-		444EAD8C0BD0E60000C6D4A0 /* DialogPrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogPrerequisites.h; path = ../engine/dialog/include/DialogPrerequisites.h; sourceTree = SOURCE_ROOT; };
-		444EAD8D0BD0E60000C6D4A0 /* DialogResponse.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogResponse.h; path = ../engine/dialog/include/DialogResponse.h; sourceTree = SOURCE_ROOT; };
-		444EAD8E0BD0E60000C6D4A0 /* DialogScriptProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogScriptProcessor.h; path = ../engine/dialog/include/DialogScriptProcessor.h; sourceTree = SOURCE_ROOT; };
-		444EAD8F0BD0E60000C6D4A0 /* DialogSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogSubsystem.h; path = ../engine/dialog/include/DialogSubsystem.h; sourceTree = SOURCE_ROOT; };
-		444EAD900BD0E60000C6D4A0 /* ScriptProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ScriptProcessor.h; path = ../engine/dialog/include/ScriptProcessor.h; sourceTree = SOURCE_ROOT; };
-		444EAD9C0BD0E61400C6D4A0 /* CreaturePredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CreaturePredicates.h; path = ../engine/dialog/include/predicates/CreaturePredicates.h; sourceTree = SOURCE_ROOT; };
-		444EAD9D0BD0E61400C6D4A0 /* EigenschaftsProbePredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EigenschaftsProbePredicates.h; path = ../engine/dialog/include/predicates/EigenschaftsProbePredicates.h; sourceTree = SOURCE_ROOT; };
-		444EAD9E0BD0E61400C6D4A0 /* EigenschaftsWertPredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EigenschaftsWertPredicates.h; path = ../engine/dialog/include/predicates/EigenschaftsWertPredicates.h; sourceTree = SOURCE_ROOT; };
-		444EAD9F0BD0E61400C6D4A0 /* GrundWertPredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GrundWertPredicates.h; path = ../engine/dialog/include/predicates/GrundWertPredicates.h; sourceTree = SOURCE_ROOT; };
-		444EADA00BD0E61400C6D4A0 /* QuestKnownPredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuestKnownPredicates.h; path = ../engine/dialog/include/predicates/QuestKnownPredicates.h; sourceTree = SOURCE_ROOT; };
-		444EADA10BD0E61400C6D4A0 /* QuestPartsPredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuestPartsPredicates.h; path = ../engine/dialog/include/predicates/QuestPartsPredicates.h; sourceTree = SOURCE_ROOT; };
-		444EADA20BD0E61400C6D4A0 /* QuestStatePredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuestStatePredicates.h; path = ../engine/dialog/include/predicates/QuestStatePredicates.h; sourceTree = SOURCE_ROOT; };
-		444EADA30BD0E61400C6D4A0 /* ScriptPredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ScriptPredicates.h; path = ../engine/dialog/include/predicates/ScriptPredicates.h; sourceTree = SOURCE_ROOT; };
-		444EADA40BD0E61400C6D4A0 /* TalentProbePredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TalentProbePredicates.h; path = ../engine/dialog/include/predicates/TalentProbePredicates.h; sourceTree = SOURCE_ROOT; };
-		444EADA50BD0E61400C6D4A0 /* TalentWertPredicates.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TalentWertPredicates.h; path = ../engine/dialog/include/predicates/TalentWertPredicates.h; sourceTree = SOURCE_ROOT; };
 		444EADB00BD0E64100C6D4A0 /* Action.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Action.cpp; path = ../engine/rules/src/Action.cpp; sourceTree = SOURCE_ROOT; };
 		444EADB10BD0E64100C6D4A0 /* ActionManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ActionManager.cpp; path = ../engine/rules/src/ActionManager.cpp; sourceTree = SOURCE_ROOT; };
 		444EADB20BD0E64100C6D4A0 /* Armor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Armor.cpp; path = ../engine/rules/src/Armor.cpp; sourceTree = SOURCE_ROOT; };
@@ -1081,13 +1133,12 @@
 		444EAE630BD0E6C000C6D4A0 /* ScriptSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ScriptSubsystem.h; path = ../engine/script/include/ScriptSubsystem.h; sourceTree = SOURCE_ROOT; };
 		444EAE670BD0E6D400C6D4A0 /* ScriptObjectMarker.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ScriptObjectMarker.cpp; path = ../engine/script/src/ScriptObjectMarker.cpp; sourceTree = SOURCE_ROOT; };
 		444EAE680BD0E6D400C6D4A0 /* ScriptSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ScriptSubsystem.cpp; path = ../engine/script/src/ScriptSubsystem.cpp; sourceTree = SOURCE_ROOT; };
-		444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */ = {isa = PBXFileReference; lastKnownFileType = &quot;compiled.mach-o.dylib&quot;; name = &quot;libxerces-c.dylib&quot;; path = &quot;/usr/local/lib/libxerces-c.dylib&quot;; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CEGUI.framework; path = /Library/Frameworks/CEGUI.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Ogre.framework; path = /Library/Frameworks/Ogre.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		444EB0880BD1153500C6D4A0 /* OgreNewt.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OgreNewt.framework; path = /Library/Frameworks/OgreNewt.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		444EB0DA0BD119BB00C6D4A0 /* OpenSteer.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OpenSteer.framework; path = /Library/Frameworks/OpenSteer.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		444EB3720BD1784A00C6D4A0 /* OgreCEGUIRenderer.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OgreCEGUIRenderer.framework; path = /Library/Frameworks/OgreCEGUIRenderer.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
-		444EB6BC0BD1891400C6D4A0 /* RlExports.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RlExports.cpp; path = ../engine/script/swig/RlExports.cpp; sourceTree = SOURCE_ROOT; };
+		444EB6BC0BD1891400C6D4A0 /* RlExports.cpp */ = {isa = PBXFileReference; fileEncoding = 4; includeInIndex = 0; lastKnownFileType = sourcecode.cpp.cpp; name = RlExports.cpp; path = ../engine/script/swig/RlExports.cpp; sourceTree = SOURCE_ROOT; };
 		446BF4690C4531FA0013C214 /* LinearSoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LinearSoundFadeFunctor.h; path = ../engine/core/include/LinearSoundFadeFunctor.h; sourceTree = SOURCE_ROOT; };
 		446BF46A0C4531FA0013C214 /* SoundFadeFunctor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundFadeFunctor.h; path = ../engine/core/include/SoundFadeFunctor.h; sourceTree = SOURCE_ROOT; };
 		446BF46B0C4531FA0013C214 /* SoundFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundFadeJob.h; path = ../engine/core/include/SoundFadeJob.h; sourceTree = SOURCE_ROOT; };
@@ -1121,7 +1172,6 @@
 		446BF4D00C453B9E0013C214 /* CombatControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CombatControlState.h; path = ../engine/ui/include/CombatControlState.h; sourceTree = SOURCE_ROOT; };
 		446BF4D10C453B9E0013C214 /* CombatWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CombatWindow.h; path = ../engine/ui/include/CombatWindow.h; sourceTree = SOURCE_ROOT; };
 		446BF4D50C453C1D0013C214 /* ItemDescriptionDragContainer.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ItemDescriptionDragContainer.cpp; path = ../engine/ui/src/ItemDescriptionDragContainer.cpp; sourceTree = SOURCE_ROOT; };
-		44D814590BF7B52600534175 /* GameObjectConstants.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameObjectConstants.h; path = ../engine/rules/include/GameObjectConstants.h; sourceTree = SOURCE_ROOT; };
 		44D8145A0BF7B52600534175 /* SelectionHelper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SelectionHelper.h; path = ../engine/rules/include/SelectionHelper.h; sourceTree = SOURCE_ROOT; };
 		44D8145B0BF7B52600534175 /* Selector.h */ = {isa = PBXFileReference; explicitFileType = sourcecode.c.h; fileEncoding = 4; name = Selector.h; path = ../engine/rules/include/Selector.h; sourceTree = SOURCE_ROOT; };
 		44D8145F0BF7B58A00534175 /* ProgressWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ProgressWindow.h; path = ../engine/ui/include/ProgressWindow.h; sourceTree = SOURCE_ROOT; };
@@ -1145,7 +1195,8 @@
 		4836469C0D83D15600912FEC /* ContentLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ContentLoader.cpp; path = ../engine/core/src/ContentLoader.cpp; sourceTree = SOURCE_ROOT; };
 		4836469D0D83D15600912FEC /* SoundStitching.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundStitching.cpp; path = ../engine/core/src/SoundStitching.cpp; sourceTree = SOURCE_ROOT; };
 		483646A10D83D57800912FEC /* libruby.dylib */ = {isa = PBXFileReference; lastKnownFileType = &quot;compiled.mach-o.dylib&quot;; name = libruby.dylib; path = /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/libruby.dylib; sourceTree = &quot;&lt;absolute&gt;&quot;; };
-		4836F88D0D88592800E3632F /* libRlScript.dylib */ = {isa = PBXFileReference; explicitFileType = &quot;compiled.mach-o.dylib&quot;; includeInIndex = 0; path = libRlScript.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
+		48365C970D8D576100BF3313 /* RlScriptExports.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RlScriptExports.cpp; path = ../engine/script/swig/test.cpp; sourceTree = SOURCE_ROOT; };
+		4836CBC80D8FB0BE002FE5D7 /* Xerces.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Xerces.framework; path = /Library/Frameworks/Xerces.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		48380B180D800EED0013EE0C /* StartAnimationJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = StartAnimationJob.cpp; path = ../engine/core/src/StartAnimationJob.cpp; sourceTree = SOURCE_ROOT; };
 		48389B8E0D86741F00AFAB66 /* CombatGui.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CombatGui.cpp; path = ../engine/ui/src/CombatGui.cpp; sourceTree = SOURCE_ROOT; };
 		48389B8F0D86741F00AFAB66 /* GameSaveLoadWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameSaveLoadWindow.cpp; path = ../engine/ui/src/GameSaveLoadWindow.cpp; sourceTree = SOURCE_ROOT; };
@@ -1237,6 +1288,22 @@
 		483D31710D85B3B7003477A0 /* SimpleVehicle.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SimpleVehicle.cpp; path = ../engine/ai/src/SimpleVehicle.cpp; sourceTree = SOURCE_ROOT; };
 		483D31720D85B3B7003477A0 /* stdinc.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = stdinc.cpp; path = ../engine/ai/src/stdinc.cpp; sourceTree = SOURCE_ROOT; };
 		483D31730D85B3B7003477A0 /* WalkPathBehaviour.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WalkPathBehaviour.cpp; path = ../engine/ai/src/WalkPathBehaviour.cpp; sourceTree = SOURCE_ROOT; };
+		483D86700D8C3A3300F3629E /* libRlFmod4Driver.dylib */ = {isa = PBXFileReference; explicitFileType = &quot;compiled.mach-o.dylib&quot;; includeInIndex = 0; path = libRlFmod4Driver.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
+		483D86850D8C3C4F00F3629E /* RlScriptExports-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = &quot;RlScriptExports-Info.plist&quot;; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483D868C0D8C3DA200F3629E /* Fmod4ConfigComponent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Fmod4ConfigComponent.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483D868D0D8C3DA200F3629E /* Fmod4Driver.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Fmod4Driver.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483D868E0D8C3DA200F3629E /* Fmod4DriverPrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Fmod4DriverPrerequisites.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483D868F0D8C3DA200F3629E /* Fmod4Listener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Fmod4Listener.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483D86900D8C3DA200F3629E /* Fmod4Sound.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Fmod4Sound.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483D86910D8C3DA200F3629E /* Fmod4SoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Fmod4SoundStitching.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483D86960D8C3DA200F3629E /* Fmod4ConfigComponent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Fmod4ConfigComponent.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483D86970D8C3DA200F3629E /* Fmod4Driver.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Fmod4Driver.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483D86980D8C3DA200F3629E /* Fmod4DriverDllMain.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Fmod4DriverDllMain.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483D86990D8C3DA200F3629E /* Fmod4Listener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Fmod4Listener.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483D869A0D8C3DA200F3629E /* Fmod4Sound.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Fmod4Sound.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483D869B0D8C3DA200F3629E /* Fmod4SoundStitching.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Fmod4SoundStitching.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483D87C90D8C55E500F3629E /* RlScript.bundle */ = {isa = PBXFileReference; explicitFileType = &quot;compiled.mach-o.dylib&quot;; includeInIndex = 0; path = RlScript.bundle; sourceTree = BUILT_PRODUCTS_DIR; };
+		48570C1B0D8A6C5400096E35 /* libRlScript.dylib */ = {isa = PBXFileReference; explicitFileType = &quot;compiled.mach-o.dylib&quot;; includeInIndex = 0; path = libRlScript.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
 		4857E3A40D469FEA009D376D /* libboost_filesystem.dylib */ = {isa = PBXFileReference; lastKnownFileType = &quot;compiled.mach-o.dylib&quot;; name = libboost_filesystem.dylib; path = /sw/lib/libboost_filesystem.dylib; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		4857E4E40D46A664009D376D /* OIS.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = OIS.framework; path = /Library/Frameworks/OIS.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		485A05670D71ED8D0024198D /* CoreMessages.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CoreMessages.h; path = ../engine/core/include/CoreMessages.h; sourceTree = SOURCE_ROOT; };
@@ -1274,10 +1341,10 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				444EAEBA0BD0F06700C6D4A0 /* libxerces-c.dylib in Frameworks */,
 				444EAEBF0BD0F09900C6D4A0 /* CEGUI.framework in Frameworks */,
 				444EAEC00BD0F09900C6D4A0 /* Ogre.framework in Frameworks */,
 				4857E3A70D469FEA009D376D /* libboost_filesystem.dylib in Frameworks */,
+				4836CBCE0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1288,11 +1355,11 @@
 				444EB0AB0BD115CB00C6D4A0 /* libRlCommon.dylib in Frameworks */,
 				483646A20D83D57800912FEC /* libruby.dylib in Frameworks */,
 				444EAEF30BD1150500C6D4A0 /* CEGUI.framework in Frameworks */,
-				444EAEF50BD1150500C6D4A0 /* libxerces-c.dylib in Frameworks */,
 				444EAEF60BD1150500C6D4A0 /* Ogre.framework in Frameworks */,
 				444EB0890BD1153500C6D4A0 /* OgreNewt.framework in Frameworks */,
 				440785DE0C09D231006E496D /* libmeshmagick.dylib in Frameworks */,
 				4857E3A60D469FEA009D376D /* libboost_filesystem.dylib in Frameworks */,
+				4836CBCD0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1305,11 +1372,11 @@
 				444EB12D0BD11A0C00C6D4A0 /* libRlCore.dylib in Frameworks */,
 				444EB1290BD119FB00C6D4A0 /* libRlCommon.dylib in Frameworks */,
 				444EB0D40BD1198B00C6D4A0 /* CEGUI.framework in Frameworks */,
-				444EB0D50BD1198B00C6D4A0 /* libxerces-c.dylib in Frameworks */,
 				444EB0D60BD1198B00C6D4A0 /* Ogre.framework in Frameworks */,
 				444EB0D80BD1198B00C6D4A0 /* OgreNewt.framework in Frameworks */,
 				444EB0DB0BD119BB00C6D4A0 /* OpenSteer.framework in Frameworks */,
 				483D31B50D85B72D003477A0 /* libboost_filesystem.dylib in Frameworks */,
+				4836CBCC0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1321,9 +1388,9 @@
 				444EB3480BD1733900C6D4A0 /* OgreNewt.framework in Frameworks */,
 				444EB3440BD1730C00C6D4A0 /* libRlCommon.dylib in Frameworks */,
 				444EB3450BD1730C00C6D4A0 /* libRlCore.dylib in Frameworks */,
-				444EB3430BD172FA00C6D4A0 /* libxerces-c.dylib in Frameworks */,
 				444EB3410BD172BA00C6D4A0 /* CEGUI.framework in Frameworks */,
 				444EB3420BD172BA00C6D4A0 /* Ogre.framework in Frameworks */,
+				4836CBCB0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1340,34 +1407,53 @@
 				444EB1C30BD136F200C6D4A0 /* Ogre.framework in Frameworks */,
 				444EB3730BD1784A00C6D4A0 /* OgreCEGUIRenderer.framework in Frameworks */,
 				4857E4E50D46A664009D376D /* OIS.framework in Frameworks */,
-				481879ED0D885BC000CE6689 /* libxerces-c.dylib in Frameworks */,
+				4836CBCA0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
-		4836F88B0D88592800E3632F /* Frameworks */ = {
+		483D866E0D8C3A3300F3629E /* Frameworks */ = {
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				4836F8B60D885A8A00E3632F /* libRlAi.dylib in Frameworks */,
-				4836F8B70D885A8A00E3632F /* libRlCommon.dylib in Frameworks */,
-				4836F8B80D885A8A00E3632F /* libRlCore.dylib in Frameworks */,
-				4836F8B90D885A8A00E3632F /* libRlRules.dylib in Frameworks */,
-				4836F8BA0D885A8A00E3632F /* libRlUi.dylib in Frameworks */,
-				4836F8BB0D885AA800E3632F /* libruby.dylib in Frameworks */,
-				4836F9B70D885ACF00E3632F /* Ogre.framework in Frameworks */,
-				4836F9B80D885ACF00E3632F /* OgreNewt.framework in Frameworks */,
-				481879EC0D885BBE00CE6689 /* libxerces-c.dylib in Frameworks */,
-				48187A960D885BD800CE6689 /* CEGUI.framework in Frameworks */,
+				48365BE60D8D560E00BF3313 /* Ogre.framework in Frameworks */,
+				48365BE80D8D562D00BF3313 /* libRlCore.dylib in Frameworks */,
+				48365BE90D8D562D00BF3313 /* libRlUi.dylib in Frameworks */,
+				48365BEC0D8D56DC00BF3313 /* libRlCommon.dylib in Frameworks */,
+				48365C950D8D56EA00BF3313 /* CEGUI.framework in Frameworks */,
+				4836CBCF0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		483D87C70D8C55E500F3629E /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				483D87CE0D8C564400F3629E /* libRlScript.dylib in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		48570C190D8A6C5400096E35 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				48570DDA0D8A6EB500096E35 /* OgreNewt.framework in Frameworks */,
+				48570CF30D8A6EAD00096E35 /* Ogre.framework in Frameworks */,
+				48570CF20D8A6EA600096E35 /* libruby.dylib in Frameworks */,
+				48570C450D8A6E9900096E35 /* libRlAi.dylib in Frameworks */,
+				48570C460D8A6E9900096E35 /* libRlCommon.dylib in Frameworks */,
+				48570C4A0D8A6EA200096E35 /* CEGUI.framework in Frameworks */,
+				48570C470D8A6E9900096E35 /* libRlCore.dylib in Frameworks */,
+				48570C480D8A6E9900096E35 /* libRlRules.dylib in Frameworks */,
+				48570C490D8A6E9900096E35 /* libRlUi.dylib in Frameworks */,
+				4836CBC90D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 		8D0C4E910486CD37000505A6 /* Frameworks */ = {
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				4836F8AE0D88595800E3632F /* libRlScript.dylib in Frameworks */,
 				444EB7A20BD1963A00C6D4A0 /* CEGUI.framework in Frameworks */,
-				444EB7A70BD1963A00C6D4A0 /* libxerces-c.dylib in Frameworks */,
 				444EB7A80BD1963A00C6D4A0 /* Ogre.framework in Frameworks */,
 				444EB7A90BD1963A00C6D4A0 /* OgreCEGUIRenderer.framework in Frameworks */,
 				444EB7AA0BD1963A00C6D4A0 /* OgreNewt.framework in Frameworks */,
@@ -1379,6 +1465,7 @@
 				444EB7A00BD195E800C6D4A0 /* libRlUi.dylib in Frameworks */,
 				4857E3A50D469FEA009D376D /* libboost_filesystem.dylib in Frameworks */,
 				4836F8BC0D885AAA00E3632F /* libruby.dylib in Frameworks */,
+				48570E020D8A6F8300096E35 /* libRlScript.dylib in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1394,7 +1481,9 @@
 				444EAC270BD0E3FF00C6D4A0 /* libRlAi.dylib */,
 				444EAC370BD0E44900C6D4A0 /* libRlRules.dylib */,
 				444EAC3E0BD0E46000C6D4A0 /* libRlUi.dylib */,
-				4836F88D0D88592800E3632F /* libRlScript.dylib */,
+				48570C1B0D8A6C5400096E35 /* libRlScript.dylib */,
+				483D86700D8C3A3300F3629E /* libRlFmod4Driver.dylib */,
+				483D87C90D8C55E500F3629E /* RlScript.bundle */,
 			);
 			name = Products;
 			sourceTree = &quot;&lt;group&gt;&quot;;
@@ -1402,89 +1491,12 @@
 		20286C29FDCF999611CA2CEA /* Rastullah */ = {
 			isa = PBXGroup;
 			children = (
-				48389C190D867AA900AFAB66 /* stdinc.cpp */,
-				48389C1A0D867AA900AFAB66 /* TriggerFactory.cpp */,
-				48389C100D86798600AFAB66 /* SoundStitchingObject.cpp */,
-				48389C0E0D86797000AFAB66 /* SoundStitchingObject.h */,
-				48389B960D86743900AFAB66 /* CombatGui.h */,
-				48389B970D86743900AFAB66 /* GameSaveLoadWindow.h */,
-				48389B980D86743900AFAB66 /* MainMenuLoadWindow.h */,
-				48389B990D86743900AFAB66 /* UiMessages.h */,
-				48389B8E0D86741F00AFAB66 /* CombatGui.cpp */,
-				48389B8F0D86741F00AFAB66 /* GameSaveLoadWindow.cpp */,
-				48389B900D86741F00AFAB66 /* MainMenuLoadWindow.cpp */,
-				48389B910D86741F00AFAB66 /* stdinc.cpp */,
-				483D31650D85B3B7003477A0 /* AgentCombatState.cpp */,
-				483D31660D85B3B7003477A0 /* AgentDialogState.cpp */,
-				483D31670D85B3B7003477A0 /* AgentSteeringState.cpp */,
-				483D31680D85B3B7003477A0 /* Dialog.cpp */,
-				483D31690D85B3B7003477A0 /* DialogCondition.cpp */,
-				483D316A0D85B3B7003477A0 /* DialogElement.cpp */,
-				483D316B0D85B3B7003477A0 /* DialogImplication.cpp */,
-				483D316C0D85B3B7003477A0 /* DialogManager.cpp */,
-				483D316D0D85B3B7003477A0 /* DialogOption.cpp */,
-				483D316E0D85B3B7003477A0 /* DialogParagraph.cpp */,
-				483D316F0D85B3B7003477A0 /* DialogResponse.cpp */,
-				483D31700D85B3B7003477A0 /* DialogVariable.cpp */,
-				483D31710D85B3B7003477A0 /* SimpleVehicle.cpp */,
-				483D31720D85B3B7003477A0 /* stdinc.cpp */,
-				483D31730D85B3B7003477A0 /* WalkPathBehaviour.cpp */,
-				483D31450D85B398003477A0 /* AgentCombatState.h */,
-				483D31460D85B398003477A0 /* AgentDialogState.h */,
-				483D31470D85B398003477A0 /* AgentState.h */,
-				483D31480D85B398003477A0 /* AgentSteeringState.h */,
-				483D31490D85B398003477A0 /* AiMessages.h */,
-				483D314A0D85B398003477A0 /* Dialog.h */,
-				483D314B0D85B398003477A0 /* DialogCondition.h */,
-				483D314C0D85B398003477A0 /* DialogElement.h */,
-				483D314D0D85B398003477A0 /* DialogImplication.h */,
-				483D314E0D85B398003477A0 /* DialogManager.h */,
-				483D314F0D85B398003477A0 /* DialogOption.h */,
-				483D31500D85B398003477A0 /* DialogParagraph.h */,
-				483D31510D85B398003477A0 /* DialogResponse.h */,
-				483D31520D85B398003477A0 /* DialogVariable.h */,
-				483D31530D85B398003477A0 /* SimpleVehicle.h */,
-				483D31540D85B398003477A0 /* WalkPathBehaviour.h */,
-				483D312B0D85B22C003477A0 /* Combatant.cpp */,
-				483D312C0D85B22C003477A0 /* EffectManagementTask.cpp */,
-				483D312D0D85B22C003477A0 /* GameEventLog.cpp */,
-				483D312E0D85B22C003477A0 /* GameTimeSource.cpp */,
-				483D312F0D85B22C003477A0 /* GlobalProperties.cpp */,
-				483D31300D85B22C003477A0 /* GoToJob.cpp */,
-				483D31310D85B22C003477A0 /* Kampfaktion.cpp */,
-				483D31320D85B22C003477A0 /* WaitJob.cpp */,
-				483D31150D85B215003477A0 /* Combatant.h */,
-				483D31160D85B215003477A0 /* EffectManagementTask.h */,
-				483D31170D85B215003477A0 /* GameEventLog.h */,
-				483D31180D85B215003477A0 /* GameTimeSource.h */,
-				483D31190D85B215003477A0 /* GlobalProperties.h */,
-				483D311A0D85B215003477A0 /* GoToJob.h */,
-				483D311B0D85B215003477A0 /* Kampfaktion.h */,
-				483D311C0D85B215003477A0 /* RulesConstants.h */,
-				483D311D0D85B215003477A0 /* RulesMessages.h */,
-				483D311E0D85B215003477A0 /* stdinc.h */,
-				483D311F0D85B215003477A0 /* WaitJob.h */,
-				483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */,
-				483D31100D85B1AF003477A0 /* NullSoundStitching.h */,
-				4836469C0D83D15600912FEC /* ContentLoader.cpp */,
-				4836469D0D83D15600912FEC /* SoundStitching.cpp */,
-				483646960D83D13700912FEC /* ContentLoader.h */,
-				483646970D83D13700912FEC /* SoundStitching.h */,
-				483646980D83D13700912FEC /* StartAnimationJob.h */,
-				485A057D0D71EDF20024198D /* JobQueue.cpp */,
-				485A05800D71EDF20024198D /* SaveGameFile.cpp */,
-				485A05810D71EDF20024198D /* SaveGameFileReader.cpp */,
-				485A05820D71EDF20024198D /* SaveGameFileWriter.cpp */,
-				485A05830D71EDF20024198D /* SaveGameManager.cpp */,
-				485A05850D71EDF20024198D /* TimeSource.cpp */,
-				485A05860D71EDF20024198D /* Trigger.cpp */,
-				485A05690D71EDC40024198D /* JobQueue.h */,
-				485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */,
-				485A05720D71EDC40024198D /* TimeSource.h */,
 				20286C2AFDCF999611CA2CEA /* Sources */,
 				20286C2CFDCF999611CA2CEA /* Resources */,
 				20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */,
 				195DF8CFFE9D517E11CA2CBB /* Products */,
+				483D86850D8C3C4F00F3629E /* RlScriptExports-Info.plist */,
+				48365C970D8D576100BF3313 /* RlScriptExports.cpp */,
 			);
 			name = Rastullah;
 			sourceTree = &quot;&lt;group&gt;&quot;;
@@ -1492,10 +1504,10 @@
 		20286C2AFDCF999611CA2CEA /* Sources */ = {
 			isa = PBXGroup;
 			children = (
+				483D86890D8C3DA200F3629E /* RlFmod4Driver */,
 				444EAC220BD0E3E000C6D4A0 /* RlAi */,
 				444EAB1F0BD0E25C00C6D4A0 /* RlCommon */,
 				444EAB200BD0E27400C6D4A0 /* RlCore */,
-				444EAC580BD0E4F900C6D4A0 /* RlDialog */,
 				444EAC590BD0E50600C6D4A0 /* RlRules */,
 				444EAE600BD0E66500C6D4A0 /* RlScript */,
 				444EAC570BD0E4CD00C6D4A0 /* RlUi */,
@@ -1518,6 +1530,7 @@
 		20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */ = {
 			isa = PBXGroup;
 			children = (
+				4836CBC80D8FB0BE002FE5D7 /* Xerces.framework */,
 				4857E4E40D46A664009D376D /* OIS.framework */,
 				4857E3A40D469FEA009D376D /* libboost_filesystem.dylib */,
 				440785DD0C09D231006E496D /* libmeshmagick.dylib */,
@@ -1526,7 +1539,6 @@
 				444EB0DA0BD119BB00C6D4A0 /* OpenSteer.framework */,
 				444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */,
 				444EAEBE0BD0F09900C6D4A0 /* Ogre.framework */,
-				444EAEB90BD0F06700C6D4A0 /* libxerces-c.dylib */,
 				444EB0880BD1153500C6D4A0 /* OgreNewt.framework */,
 			);
 			name = &quot;External Frameworks and Libraries&quot;;
@@ -1585,6 +1597,18 @@
 		444EAB200BD0E27400C6D4A0 /* RlCore */ = {
 			isa = PBXGroup;
 			children = (
+				485A05860D71EDF20024198D /* Trigger.cpp */,
+				48389C100D86798600AFAB66 /* SoundStitchingObject.cpp */,
+				48389C0E0D86797000AFAB66 /* SoundStitchingObject.h */,
+				485A05690D71EDC40024198D /* JobQueue.h */,
+				485A056D0D71EDC40024198D /* PolynomicSoundFadeFunctor.h */,
+				485A05720D71EDC40024198D /* TimeSource.h */,
+				483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */,
+				483D31100D85B1AF003477A0 /* NullSoundStitching.h */,
+				485A05850D71EDF20024198D /* TimeSource.cpp */,
+				4836469C0D83D15600912FEC /* ContentLoader.cpp */,
+				483646960D83D13700912FEC /* ContentLoader.h */,
+				4836469D0D83D15600912FEC /* SoundStitching.cpp */,
 				485A057F0D71EDF20024198D /* PolynomicSoundFadeFunctor.cpp */,
 				48380B180D800EED0013EE0C /* StartAnimationJob.cpp */,
 				485A056E0D71EDC40024198D /* SaveGameFile.h */,
@@ -1593,6 +1617,13 @@
 				485A05700D71EDC40024198D /* SaveGameFileWriter.h */,
 				485A05710D71EDC40024198D /* SaveGameManager.h */,
 				4404DA7E0C48CFC7007B4657 /* stdinc.h */,
+				483646970D83D13700912FEC /* SoundStitching.h */,
+				483646980D83D13700912FEC /* StartAnimationJob.h */,
+				485A057D0D71EDF20024198D /* JobQueue.cpp */,
+				485A05800D71EDF20024198D /* SaveGameFile.cpp */,
+				485A05810D71EDF20024198D /* SaveGameFileReader.cpp */,
+				485A05820D71EDF20024198D /* SaveGameFileWriter.cpp */,
+				485A05830D71EDF20024198D /* SaveGameManager.cpp */,
 				446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */,
 				446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */,
 				446BF4710C4532120013C214 /* SoundFadeJob.cpp */,
@@ -1726,6 +1757,37 @@
 		444EAC220BD0E3E000C6D4A0 /* RlAi */ = {
 			isa = PBXGroup;
 			children = (
+				483D31720D85B3B7003477A0 /* stdinc.cpp */,
+				483D31730D85B3B7003477A0 /* WalkPathBehaviour.cpp */,
+				483D31450D85B398003477A0 /* AgentCombatState.h */,
+				483D31650D85B3B7003477A0 /* AgentCombatState.cpp */,
+				483D31660D85B3B7003477A0 /* AgentDialogState.cpp */,
+				483D31670D85B3B7003477A0 /* AgentSteeringState.cpp */,
+				483D31680D85B3B7003477A0 /* Dialog.cpp */,
+				483D31690D85B3B7003477A0 /* DialogCondition.cpp */,
+				483D316A0D85B3B7003477A0 /* DialogElement.cpp */,
+				483D316B0D85B3B7003477A0 /* DialogImplication.cpp */,
+				483D316C0D85B3B7003477A0 /* DialogManager.cpp */,
+				483D316D0D85B3B7003477A0 /* DialogOption.cpp */,
+				483D316E0D85B3B7003477A0 /* DialogParagraph.cpp */,
+				483D316F0D85B3B7003477A0 /* DialogResponse.cpp */,
+				483D31700D85B3B7003477A0 /* DialogVariable.cpp */,
+				483D31710D85B3B7003477A0 /* SimpleVehicle.cpp */,
+				483D31460D85B398003477A0 /* AgentDialogState.h */,
+				483D31470D85B398003477A0 /* AgentState.h */,
+				483D31480D85B398003477A0 /* AgentSteeringState.h */,
+				483D31490D85B398003477A0 /* AiMessages.h */,
+				483D314A0D85B398003477A0 /* Dialog.h */,
+				483D314B0D85B398003477A0 /* DialogCondition.h */,
+				483D314C0D85B398003477A0 /* DialogElement.h */,
+				483D314D0D85B398003477A0 /* DialogImplication.h */,
+				483D314E0D85B398003477A0 /* DialogManager.h */,
+				483D314F0D85B398003477A0 /* DialogOption.h */,
+				483D31500D85B398003477A0 /* DialogParagraph.h */,
+				483D31510D85B398003477A0 /* DialogResponse.h */,
+				483D31520D85B398003477A0 /* DialogVariable.h */,
+				483D31530D85B398003477A0 /* SimpleVehicle.h */,
+				483D31540D85B398003477A0 /* WalkPathBehaviour.h */,
 				4404DA6E0C48CEE2007B4657 /* stdinc.h */,
 				44125A310C083D1100C24C0A /* CreatureWalkPathJob.h */,
 				44125A2F0C083D0100C24C0A /* CreatureWalkPathJob.cpp */,
@@ -1774,6 +1836,14 @@
 		444EAC570BD0E4CD00C6D4A0 /* RlUi */ = {
 			isa = PBXGroup;
 			children = (
+				48389B960D86743900AFAB66 /* CombatGui.h */,
+				48389B970D86743900AFAB66 /* GameSaveLoadWindow.h */,
+				48389B980D86743900AFAB66 /* MainMenuLoadWindow.h */,
+				48389B990D86743900AFAB66 /* UiMessages.h */,
+				48389B8E0D86741F00AFAB66 /* CombatGui.cpp */,
+				48389B8F0D86741F00AFAB66 /* GameSaveLoadWindow.cpp */,
+				48389B900D86741F00AFAB66 /* MainMenuLoadWindow.cpp */,
+				48389B910D86741F00AFAB66 /* stdinc.cpp */,
 				4404DA850C48D037007B4657 /* stdinc.h */,
 				446BF4D50C453C1D0013C214 /* ItemDescriptionDragContainer.cpp */,
 				446BF4D00C453B9E0013C214 /* CombatControlState.h */,
@@ -1877,63 +1947,36 @@
 			name = RlUi;
 			sourceTree = &quot;&lt;group&gt;&quot;;
 		};
-		444EAC580BD0E4F900C6D4A0 /* RlDialog */ = {
-			isa = PBXGroup;
-			children = (
-				4404DA800C48CFDE007B4657 /* stdinc.h */,
-				444EAD9C0BD0E61400C6D4A0 /* CreaturePredicates.h */,
-				444EAD9D0BD0E61400C6D4A0 /* EigenschaftsProbePredicates.h */,
-				444EAD9E0BD0E61400C6D4A0 /* EigenschaftsWertPredicates.h */,
-				444EAD9F0BD0E61400C6D4A0 /* GrundWertPredicates.h */,
-				444EADA00BD0E61400C6D4A0 /* QuestKnownPredicates.h */,
-				444EADA10BD0E61400C6D4A0 /* QuestPartsPredicates.h */,
-				444EADA20BD0E61400C6D4A0 /* QuestStatePredicates.h */,
-				444EADA30BD0E61400C6D4A0 /* ScriptPredicates.h */,
-				444EADA40BD0E61400C6D4A0 /* TalentProbePredicates.h */,
-				444EADA50BD0E61400C6D4A0 /* TalentWertPredicates.h */,
-				444EAD880BD0E60000C6D4A0 /* ContextConditionProcessor.h */,
-				444EAD890BD0E60000C6D4A0 /* ContextInterpreter.h */,
-				444EAD8A0BD0E60000C6D4A0 /* DialogCharacter.h */,
-				444EAD8B0BD0E60000C6D4A0 /* DialogOption.h */,
-				444EAD8C0BD0E60000C6D4A0 /* DialogPrerequisites.h */,
-				444EAD8D0BD0E60000C6D4A0 /* DialogResponse.h */,
-				444EAD8E0BD0E60000C6D4A0 /* DialogScriptProcessor.h */,
-				444EAD8F0BD0E60000C6D4A0 /* DialogSubsystem.h */,
-				444EAD900BD0E60000C6D4A0 /* ScriptProcessor.h */,
-				444EAD720BD0E5E900C6D4A0 /* CreaturePredicates.cpp */,
-				444EAD730BD0E5E900C6D4A0 /* EigenschaftsProbePredicates.cpp */,
-				444EAD740BD0E5E900C6D4A0 /* EigenschaftsWertPredicates.cpp */,
-				444EAD750BD0E5E900C6D4A0 /* GrundWertPredicates.cpp */,
-				444EAD760BD0E5E900C6D4A0 /* QuestKnownPredicates.cpp */,
-				444EAD770BD0E5E900C6D4A0 /* QuestPartsPredicates.cpp */,
-				444EAD780BD0E5E900C6D4A0 /* QuestStatePredicates.cpp */,
-				444EAD790BD0E5E900C6D4A0 /* ScriptPredicates.cpp */,
-				444EAD7A0BD0E5E900C6D4A0 /* TalentProbePredicates.cpp */,
-				444EAD7B0BD0E5E900C6D4A0 /* TalentWertPredicates.cpp */,
-				444EAD600BD0E5D500C6D4A0 /* ContextConditionProcessor.cpp */,
-				444EAD610BD0E5D500C6D4A0 /* ContextInterpreter.cpp */,
-				444EAD620BD0E5D500C6D4A0 /* DialogCharacter.cpp */,
-				444EAD630BD0E5D500C6D4A0 /* DialogOption.cpp */,
-				444EAD640BD0E5D500C6D4A0 /* DialogResponse.cpp */,
-				444EAD650BD0E5D500C6D4A0 /* DialogScriptProcessor.cpp */,
-				444EAD660BD0E5D500C6D4A0 /* DialogSubsystem.cpp */,
-				444EAD670BD0E5D500C6D4A0 /* ScriptProcessor.cpp */,
-			);
-			name = RlDialog;
-			sourceTree = &quot;&lt;group&gt;&quot;;
-		};
 		444EAC590BD0E50600C6D4A0 /* RlRules */ = {
 			isa = PBXGroup;
 			children = (
+				483D311E0D85B215003477A0 /* stdinc.h */,
+				483D312D0D85B22C003477A0 /* GameEventLog.cpp */,
+				483D312E0D85B22C003477A0 /* GameTimeSource.cpp */,
+				483D31300D85B22C003477A0 /* GoToJob.cpp */,
+				483D31170D85B215003477A0 /* GameEventLog.h */,
+				483D311F0D85B215003477A0 /* WaitJob.h */,
+				483D31190D85B215003477A0 /* GlobalProperties.h */,
 				4404DA820C48D005007B4657 /* stdinc.cpp */,
 				446BF47B0C45329F0013C214 /* CreatureController.cpp */,
 				446BF47C0C45329F0013C214 /* CreatureControllerManager.cpp */,
+				483D31150D85B215003477A0 /* Combatant.h */,
 				446BF47D0C45329F0013C214 /* EffectFactory.cpp */,
 				446BF4750C4532720013C214 /* CreatureController.h */,
 				446BF4760C4532720013C214 /* CreatureControllerManager.h */,
 				446BF4770C4532720013C214 /* EffectFactory.h */,
-				44D814590BF7B52600534175 /* GameObjectConstants.h */,
 				44D8145A0BF7B52600534175 /* SelectionHelper.h */,
+				483D311A0D85B215003477A0 /* GoToJob.h */,
+				483D31180D85B215003477A0 /* GameTimeSource.h */,
+				483D312F0D85B22C003477A0 /* GlobalProperties.cpp */,
+				483D312B0D85B22C003477A0 /* Combatant.cpp */,
+				483D312C0D85B22C003477A0 /* EffectManagementTask.cpp */,
+				483D31310D85B22C003477A0 /* Kampfaktion.cpp */,
+				483D31320D85B22C003477A0 /* WaitJob.cpp */,
+				483D311B0D85B215003477A0 /* Kampfaktion.h */,
+				483D311C0D85B215003477A0 /* RulesConstants.h */,
+				483D31160D85B215003477A0 /* EffectManagementTask.h */,
+				483D311D0D85B215003477A0 /* RulesMessages.h */,
 				44D8145B0BF7B52600534175 /* Selector.h */,
 				444826030BF7B37D00C5A94F /* SelectionHelper.cpp */,
 				444826040BF7B37D00C5A94F /* Selector.cpp */,
@@ -2022,6 +2065,7 @@
 			isa = PBXGroup;
 			children = (
 				48389C010D86783200AFAB66 /* swig */,
+				48389C190D867AA900AFAB66 /* stdinc.cpp */,
 				4404DA840C48D01E007B4657 /* stdinc.h */,
 				446BF4810C4532B50013C214 /* UnifiedFactory.h */,
 				444825ED0BF7B32100C5A94F /* AbstractMapNodeProcessor.h */,
@@ -2031,6 +2075,7 @@
 				444825F10BF7B32100C5A94F /* LightNodeProcessor.h */,
 				444825F20BF7B32100C5A94F /* MapLoader.h */,
 				444825F30BF7B32100C5A94F /* ParticleSystemNodeProcessor.h */,
+				48389C1A0D867AA900AFAB66 /* TriggerFactory.cpp */,
 				444825F40BF7B32100C5A94F /* SoundNodeProcessor.h */,
 				444825F50BF7B32100C5A94F /* TriggerFactory.h */,
 				444825F60BF7B32100C5A94F /* WaypointProcessor.h */,
@@ -2088,6 +2133,42 @@
 			name = swig;
 			sourceTree = &quot;&lt;group&gt;&quot;;
 		};
+		483D86890D8C3DA200F3629E /* RlFmod4Driver */ = {
+			isa = PBXGroup;
+			children = (
+				483D868B0D8C3DA200F3629E /* include */,
+				483D86950D8C3DA200F3629E /* src */,
+			);
+			name = RlFmod4Driver;
+			path = ../plugins/fmod4driver;
+			sourceTree = SOURCE_ROOT;
+		};
+		483D868B0D8C3DA200F3629E /* include */ = {
+			isa = PBXGroup;
+			children = (
+				483D868C0D8C3DA200F3629E /* Fmod4ConfigComponent.h */,
+				483D868D0D8C3DA200F3629E /* Fmod4Driver.h */,
+				483D868E0D8C3DA200F3629E /* Fmod4DriverPrerequisites.h */,
+				483D868F0D8C3DA200F3629E /* Fmod4Listener.h */,
+				483D86900D8C3DA200F3629E /* Fmod4Sound.h */,
+				483D86910D8C3DA200F3629E /* Fmod4SoundStitching.h */,
+			);
+			path = include;
+			sourceTree = &quot;&lt;group&gt;&quot;;
+		};
+		483D86950D8C3DA200F3629E /* src */ = {
+			isa = PBXGroup;
+			children = (
+				483D86960D8C3DA200F3629E /* Fmod4ConfigComponent.cpp */,
+				483D86970D8C3DA200F3629E /* Fmod4Driver.cpp */,
+				483D86980D8C3DA200F3629E /* Fmod4DriverDllMain.cpp */,
+				483D86990D8C3DA200F3629E /* Fmod4Listener.cpp */,
+				483D869A0D8C3DA200F3629E /* Fmod4Sound.cpp */,
+				483D869B0D8C3DA200F3629E /* Fmod4SoundStitching.cpp */,
+			);
+			path = src;
+			sourceTree = &quot;&lt;group&gt;&quot;;
+		};
 /* End PBXGroup section */
 
 /* Begin PBXHeadersBuildPhase section */
@@ -2296,7 +2377,6 @@
 				444EAE590BD0E65B00C6D4A0 /* TalentStateSet.h in Headers */,
 				444EAE5E0BD0E65B00C6D4A0 /* Weapon.h in Headers */,
 				444EAE5F0BD0E65B00C6D4A0 /* ZauberStateSet.h in Headers */,
-				44D8145C0BF7B52600534175 /* GameObjectConstants.h in Headers */,
 				44D8145D0BF7B52600534175 /* SelectionHelper.h in Headers */,
 				44D8145E0BF7B52600534175 /* Selector.h in Headers */,
 				446BF4780C4532720013C214 /* CreatureController.h in Headers */,
@@ -2377,29 +2457,49 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
-		4836F8890D88592800E3632F /* Headers */ = {
+		483D866C0D8C3A3300F3629E /* Headers */ = {
 			isa = PBXHeadersBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				4836F8910D88594A00E3632F /* stdinc.h in Headers */,
-				4836F8920D88594A00E3632F /* UnifiedFactory.h in Headers */,
-				4836F8930D88594A00E3632F /* AbstractMapNodeProcessor.h in Headers */,
-				4836F8940D88594A00E3632F /* EntityNodeProcessor.h in Headers */,
-				4836F8950D88594A00E3632F /* EnvironmentProcessor.h in Headers */,
-				4836F8960D88594A00E3632F /* GameObjectNodeProcessor.h in Headers */,
-				4836F8970D88594A00E3632F /* LightNodeProcessor.h in Headers */,
-				4836F8980D88594A00E3632F /* MapLoader.h in Headers */,
-				4836F8990D88594A00E3632F /* ParticleSystemNodeProcessor.h in Headers */,
-				4836F89A0D88594A00E3632F /* SoundNodeProcessor.h in Headers */,
-				4836F89B0D88594A00E3632F /* TriggerFactory.h in Headers */,
-				4836F89C0D88594A00E3632F /* WaypointProcessor.h in Headers */,
-				4836F89D0D88594A00E3632F /* ZoneProcessor.h in Headers */,
-				4836F8AB0D88594A00E3632F /* ScriptObjectMarker.h in Headers */,
-				4836F8AC0D88594A00E3632F /* ScriptPrerequisites.h in Headers */,
-				4836F8AD0D88594A00E3632F /* ScriptSubsystem.h in Headers */,
+				483D869D0D8C3DA200F3629E /* Fmod4ConfigComponent.h in Headers */,
+				483D869E0D8C3DA200F3629E /* Fmod4Driver.h in Headers */,
+				483D869F0D8C3DA200F3629E /* Fmod4DriverPrerequisites.h in Headers */,
+				483D86A00D8C3DA200F3629E /* Fmod4Listener.h in Headers */,
+				483D86A10D8C3DA200F3629E /* Fmod4Sound.h in Headers */,
+				483D86A20D8C3DA200F3629E /* Fmod4SoundStitching.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		483D87C50D8C55E500F3629E /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		48570C170D8A6C5400096E35 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				48570C210D8A6C9000096E35 /* stdinc.h in Headers */,
+				48570C220D8A6C9000096E35 /* UnifiedFactory.h in Headers */,
+				48570C230D8A6C9000096E35 /* AbstractMapNodeProcessor.h in Headers */,
+				48570C240D8A6C9000096E35 /* EntityNodeProcessor.h in Headers */,
+				48570C250D8A6C9000096E35 /* EnvironmentProcessor.h in Headers */,
+				48570C260D8A6C9000096E35 /* GameObjectNodeProcessor.h in Headers */,
+				48570C270D8A6C9000096E35 /* LightNodeProcessor.h in Headers */,
+				48570C280D8A6C9000096E35 /* MapLoader.h in Headers */,
+				48570C290D8A6C9000096E35 /* ParticleSystemNodeProcessor.h in Headers */,
+				48570C2A0D8A6C9000096E35 /* SoundNodeProcessor.h in Headers */,
+				48570C2B0D8A6C9000096E35 /* TriggerFactory.h in Headers */,
+				48570C2C0D8A6C9000096E35 /* WaypointProcessor.h in Headers */,
+				48570C2D0D8A6C9000096E35 /* ZoneProcessor.h in Headers */,
+				48570C3B0D8A6C9000096E35 /* ScriptObjectMarker.h in Headers */,
+				48570C3C0D8A6C9000096E35 /* ScriptPrerequisites.h in Headers */,
+				48570C3D0D8A6C9000096E35 /* ScriptSubsystem.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 /* End PBXHeadersBuildPhase section */
 
 /* Begin PBXNativeTarget section */
@@ -2493,21 +2593,62 @@
 			productReference = 444EAC3E0BD0E46000C6D4A0 /* libRlUi.dylib */;
 			productType = &quot;com.apple.product-type.library.dynamic&quot;;
 		};
-		4836F88C0D88592800E3632F /* RlScript */ = {
+		483D866F0D8C3A3300F3629E /* RlFmod4Driver */ = {
 			isa = PBXNativeTarget;
-			buildConfigurationList = 4836F8900D88594600E3632F /* Build configuration list for PBXNativeTarget &quot;RlScript&quot; */;
+			buildConfigurationList = 483D86750D8C3A5F00F3629E /* Build configuration list for PBXNativeTarget &quot;RlFmod4Driver&quot; */;
 			buildPhases = (
-				4836F8890D88592800E3632F /* Headers */,
-				4836F88A0D88592800E3632F /* Sources */,
-				4836F88B0D88592800E3632F /* Frameworks */,
+				483D866C0D8C3A3300F3629E /* Headers */,
+				483D866D0D8C3A3300F3629E /* Sources */,
+				483D866E0D8C3A3300F3629E /* Frameworks */,
 			);
 			buildRules = (
 			);
 			dependencies = (
+				483B6A050D8D4C2700C4C190 /* PBXTargetDependency */,
 			);
+			name = RlFmod4Driver;
+			productName = RlFmod4Driver;
+			productReference = 483D86700D8C3A3300F3629E /* libRlFmod4Driver.dylib */;
+			productType = &quot;com.apple.product-type.library.dynamic&quot;;
+		};
+		483D87C80D8C55E500F3629E /* RlScriptExports */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 483D87D60D8C564E00F3629E /* Build configuration list for PBXNativeTarget &quot;RlScriptExports&quot; */;
+			buildPhases = (
+				483D87C50D8C55E500F3629E /* Headers */,
+				483D87C60D8C55E500F3629E /* Sources */,
+				483D87C70D8C55E500F3629E /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+				483B69CC0D8D4A3500C4C190 /* PBXTargetDependency */,
+				483B69CA0D8D4A3500C4C190 /* PBXTargetDependency */,
+				483B69C80D8D4A3500C4C190 /* PBXTargetDependency */,
+				483B69C60D8D4A3500C4C190 /* PBXTargetDependency */,
+				483B69C40D8D4A3500C4C190 /* PBXTargetDependency */,
+				483B69C20D8D4A3500C4C190 /* PBXTargetDependency */,
+			);
+			name = RlScriptExports;
+			productName = RlScriptExports;
+			productReference = 483D87C90D8C55E500F3629E /* RlScript.bundle */;
+			productType = &quot;com.apple.product-type.library.dynamic&quot;;
+		};
+		48570C1A0D8A6C5400096E35 /* RlScript */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 48570C3F0D8A6CAE00096E35 /* Build configuration list for PBXNativeTarget &quot;RlScript&quot; */;
+			buildPhases = (
+				48570C170D8A6C5400096E35 /* Headers */,
+				48570C180D8A6C5400096E35 /* Sources */,
+				48570C190D8A6C5400096E35 /* Frameworks */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
 			name = RlScript;
 			productName = RlScript;
-			productReference = 4836F88D0D88592800E3632F /* libRlScript.dylib */;
+			productReference = 48570C1B0D8A6C5400096E35 /* libRlScript.dylib */;
 			productType = &quot;com.apple.product-type.library.dynamic&quot;;
 		};
 		8D0C4E890486CD37000505A6 /* Rastullah */ = {
@@ -2521,10 +2662,12 @@
 			buildRules = (
 			);
 			dependencies = (
-				4836F8B40D8859E400E3632F /* PBXTargetDependency */,
+				483B6A020D8D4C0A00C4C190 /* PBXTargetDependency */,
+				483D87D80D8C566400F3629E /* PBXTargetDependency */,
 				444EAC1F0BD0E3A800C6D4A0 /* PBXTargetDependency */,
 				444EAC210BD0E3A800C6D4A0 /* PBXTargetDependency */,
 				444EAC4B0BD0E49900C6D4A0 /* PBXTargetDependency */,
+				48570C1F0D8A6C6900096E35 /* PBXTargetDependency */,
 				444EAC4F0BD0E49900C6D4A0 /* PBXTargetDependency */,
 				444EAC510BD0E49900C6D4A0 /* PBXTargetDependency */,
 			);
@@ -2555,7 +2698,9 @@
 				444EAC260BD0E3FF00C6D4A0 /* RlAi */,
 				444EAC360BD0E44900C6D4A0 /* RlRules */,
 				444EAC3D0BD0E46000C6D4A0 /* RlUi */,
-				4836F88C0D88592800E3632F /* RlScript */,
+				48570C1A0D8A6C5400096E35 /* RlScript */,
+				483D866F0D8C3A3300F3629E /* RlFmod4Driver */,
+				483D87C80D8C55E500F3629E /* RlScriptExports */,
 			);
 		};
 /* End PBXProject section */
@@ -2567,10 +2712,18 @@
 			files = (
 				48187AAB0D885CBB00CE6689 /* libRlCommon.dylib in Resources */,
 				48187AAC0D885CBB00CE6689 /* libRlCore.dylib in Resources */,
+				483514870D8AED510077477D /* OIS.framework in Resources */,
+				483514880D8AED510077477D /* libboost_filesystem.dylib in Resources */,
+				483514890D8AED510077477D /* libmeshmagick.dylib in Resources */,
+				4835148A0D8AED510077477D /* libruby.dylib in Resources */,
+				4835148B0D8AED510077477D /* OgreCEGUIRenderer.framework in Resources */,
+				4835148C0D8AED510077477D /* OpenSteer.framework in Resources */,
+				4835148D0D8AED510077477D /* CEGUI.framework in Resources */,
+				4835148E0D8AED510077477D /* Ogre.framework in Resources */,
+				4835148F0D8AED510077477D /* OgreNewt.framework in Resources */,
 				48187AAD0D885CBB00CE6689 /* libRlAi.dylib in Resources */,
 				48187AAE0D885CBB00CE6689 /* libRlRules.dylib in Resources */,
 				48187AAF0D885CBB00CE6689 /* libRlUi.dylib in Resources */,
-				48187AB00D885CBB00CE6689 /* libRlScript.dylib in Resources */,
 				8D0C4E8D0486CD37000505A6 /* InfoPlist.strings in Resources */,
 				8D0C4E8E0486CD37000505A6 /* main.nib in Resources */,
 			);
@@ -2838,27 +2991,49 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
-		4836F88A0D88592800E3632F /* Sources */ = {
+		483D866D0D8C3A3300F3629E /* Sources */ = {
 			isa = PBXSourcesBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				4836F89E0D88594A00E3632F /* AbstractMapNodeProcessor.cpp in Sources */,
-				4836F89F0D88594A00E3632F /* EntityNodeProcessor.cpp in Sources */,
-				4836F8A00D88594A00E3632F /* EnvironmentProcessor.cpp in Sources */,
-				4836F8A10D88594A00E3632F /* GameObjectNodeProcessor.cpp in Sources */,
-				4836F8A20D88594A00E3632F /* LightNodeProcessor.cpp in Sources */,
-				4836F8A30D88594A00E3632F /* MapLoader.cpp in Sources */,
-				4836F8A40D88594A00E3632F /* ParticleSystemNodeProcessor.cpp in Sources */,
-				4836F8A50D88594A00E3632F /* SoundNodeProcessor.cpp in Sources */,
-				4836F8A60D88594A00E3632F /* WaypointProcessor.cpp in Sources */,
-				4836F8A70D88594A00E3632F /* ZoneProcessor.cpp in Sources */,
-				4836F8A80D88594A00E3632F /* RlExports.cpp in Sources */,
-				4836F8A90D88594A00E3632F /* ScriptObjectMarker.cpp in Sources */,
-				4836F8AA0D88594A00E3632F /* ScriptSubsystem.cpp in Sources */,
-				4836F9BA0D885AF000E3632F /* TriggerFactory.cpp in Sources */,
+				483D86A30D8C3DA200F3629E /* Fmod4ConfigComponent.cpp in Sources */,
+				483D86A40D8C3DA200F3629E /* Fmod4Driver.cpp in Sources */,
+				483D86A50D8C3DA200F3629E /* Fmod4DriverDllMain.cpp in Sources */,
+				483D86A60D8C3DA200F3629E /* Fmod4Listener.cpp in Sources */,
+				483D86A70D8C3DA200F3629E /* Fmod4Sound.cpp in Sources */,
+				483D86A80D8C3DA200F3629E /* Fmod4SoundStitching.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		483D87C60D8C55E500F3629E /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				48365CA30D8D57ED00BF3313 /* RlScriptExports.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		48570C180D8A6C5400096E35 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				48570C2E0D8A6C9000096E35 /* AbstractMapNodeProcessor.cpp in Sources */,
+				48570C2F0D8A6C9000096E35 /* EntityNodeProcessor.cpp in Sources */,
+				48570C300D8A6C9000096E35 /* EnvironmentProcessor.cpp in Sources */,
+				48570C310D8A6C9000096E35 /* GameObjectNodeProcessor.cpp in Sources */,
+				48570C320D8A6C9000096E35 /* LightNodeProcessor.cpp in Sources */,
+				48570C330D8A6C9000096E35 /* MapLoader.cpp in Sources */,
+				48570C340D8A6C9000096E35 /* ParticleSystemNodeProcessor.cpp in Sources */,
+				48570C350D8A6C9000096E35 /* SoundNodeProcessor.cpp in Sources */,
+				48570C360D8A6C9000096E35 /* WaypointProcessor.cpp in Sources */,
+				48570C370D8A6C9000096E35 /* ZoneProcessor.cpp in Sources */,
+				48570C390D8A6C9000096E35 /* ScriptObjectMarker.cpp in Sources */,
+				48570C3A0D8A6C9000096E35 /* ScriptSubsystem.cpp in Sources */,
+				48570DFE0D8A6F3300096E35 /* TriggerFactory.cpp in Sources */,
+				483B69DB0D8D4BC900C4C190 /* RlExports.cpp in Sources */,
+				48365C980D8D576100BF3313 /* RlScriptExports.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 		8D0C4E8F0486CD37000505A6 /* Sources */ = {
 			isa = PBXSourcesBuildPhase;
 			buildActionMask = 2147483647;
@@ -2915,16 +3090,61 @@
 			target = 444EAB600BD0E2DA00C6D4A0 /* RlCore */;
 			targetProxy = 44F21A050BD2143D00EF01CF /* PBXContainerItemProxy */;
 		};
-		4836F8B40D8859E400E3632F /* PBXTargetDependency */ = {
-			isa = PBXTargetDependency;
-			target = 4836F88C0D88592800E3632F /* RlScript */;
-			targetProxy = 4836F8B30D8859E400E3632F /* PBXContainerItemProxy */;
-		};
 		48389BC60D86762F00AFAB66 /* PBXTargetDependency */ = {
 			isa = PBXTargetDependency;
 			target = 444EAC260BD0E3FF00C6D4A0 /* RlAi */;
 			targetProxy = 48389BC50D86762F00AFAB66 /* PBXContainerItemProxy */;
 		};
+		483B69C20D8D4A3500C4C190 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 48570C1A0D8A6C5400096E35 /* RlScript */;
+			targetProxy = 483B69C10D8D4A3500C4C190 /* PBXContainerItemProxy */;
+		};
+		483B69C40D8D4A3500C4C190 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAC3D0BD0E46000C6D4A0 /* RlUi */;
+			targetProxy = 483B69C30D8D4A3500C4C190 /* PBXContainerItemProxy */;
+		};
+		483B69C60D8D4A3500C4C190 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAC360BD0E44900C6D4A0 /* RlRules */;
+			targetProxy = 483B69C50D8D4A3500C4C190 /* PBXContainerItemProxy */;
+		};
+		483B69C80D8D4A3500C4C190 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAC260BD0E3FF00C6D4A0 /* RlAi */;
+			targetProxy = 483B69C70D8D4A3500C4C190 /* PBXContainerItemProxy */;
+		};
+		483B69CA0D8D4A3500C4C190 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAB600BD0E2DA00C6D4A0 /* RlCore */;
+			targetProxy = 483B69C90D8D4A3500C4C190 /* PBXContainerItemProxy */;
+		};
+		483B69CC0D8D4A3500C4C190 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAAB10BD0E0FB00C6D4A0 /* RlCommon */;
+			targetProxy = 483B69CB0D8D4A3500C4C190 /* PBXContainerItemProxy */;
+		};
+		483B6A020D8D4C0A00C4C190 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 483D866F0D8C3A3300F3629E /* RlFmod4Driver */;
+			targetProxy = 483B6A010D8D4C0A00C4C190 /* PBXContainerItemProxy */;
+		};
+		483B6A050D8D4C2700C4C190 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 444EAC3D0BD0E46000C6D4A0 /* RlUi */;
+			targetProxy = 483B6A040D8D4C2700C4C190 /* PBXContainerItemProxy */;
+		};
+		483D87D80D8C566400F3629E /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 483D87C80D8C55E500F3629E /* RlScriptExports */;
+			targetProxy = 483D87D70D8C566400F3629E /* PBXContainerItemProxy */;
+		};
+		48570C1F0D8A6C6900096E35 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = 48570C1A0D8A6C5400096E35 /* RlScript */;
+			targetProxy = 48570C1E0D8A6C6900096E35 /* PBXContainerItemProxy */;
+		};
 /* End PBXTargetDependency section */
 
 /* Begin PBXVariantGroup section */
@@ -2960,13 +3180,19 @@
 				GCC_OPTIMIZATION_LEVEL = 0;
 				GCC_PRECOMPILE_PREFIX_HEADER = YES;
 				GCC_PREFIX_HEADER = ../engine/common/include/stdinc.h;
+				HEADER_SEARCH_PATHS = (
+					/usr/local/include,
+					&quot;/usr/local/lib/ruby/1.8/i686-darwin8.9.1&quot;,
+					/sw/include,
+					/Library/Frameworks/CEGUI.framework/Headers,
+					/Library/Frameworks/Xerces.framework/Headers,
+				);
 				INSTALL_PATH = /usr/local/lib;
 				LIBRARY_SEARCH_PATHS = (
 					&quot;$(inherited)&quot;,
-					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_1)&quot;,
 					/sw/lib,
+					/usr/local/lib,
 				);
-				LIBRARY_SEARCH_PATHS_QUOTED_1 = &quot;\&quot;$(SRCROOT)/build/Debug\&quot;&quot;;
 				MACH_O_TYPE = mh_dylib;
 				OTHER_LDFLAGS = &quot;&quot;;
 				PREBINDING = NO;
@@ -3243,14 +3469,117 @@
 				);
 				PREBINDING = NO;
 				PRODUCT_NAME = RlUi;
+				ZERO_LINK = YES;
+			};
+			name = Release;
+		};
+		483D86710D8C3A3400F3629E /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				EXECUTABLE_PREFIX = lib;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				HEADER_SEARCH_PATHS = (
+					&quot;$(HEADER_SEARCH_PATHS_QUOTED_FOR_TARGET_1)&quot;,
+					/Library/Frameworks/CEGUI.framework/Headers,
+					/usr/local/include,
+					/sw/include,
+				);
+				HEADER_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = &quot;\&quot;/Developer/FMOD Programmers API/api/inc\&quot;&quot;;
+				INSTALL_PATH = /usr/local/lib;
+				LIBRARY_SEARCH_PATHS = &quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1)&quot;;
+				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = &quot;\&quot;/Developer/FMOD Programmers API/api/lib\&quot;&quot;;
+				OTHER_LDFLAGS = &quot;-lfmodex&quot;;
+				PREBINDING = NO;
+				PRODUCT_NAME = RlFmod4Driver;
+				ZERO_LINK = YES;
+			};
+			name = Debug;
+		};
+		483D86720D8C3A3400F3629E /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DEBUG_INFORMATION_FORMAT = &quot;dwarf-with-dsym&quot;;
+				EXECUTABLE_PREFIX = lib;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_MODEL_TUNING = G5;
+				HEADER_SEARCH_PATHS = (
+					&quot;$(HEADER_SEARCH_PATHS_QUOTED_FOR_TARGET_1)&quot;,
+					/Library/Frameworks/CEGUI.framework/Headers,
+					/usr/local/include,
+					/sw/include,
+				);
+				HEADER_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = &quot;\&quot;/Developer/FMOD Programmers API/api/inc\&quot;&quot;;
+				INSTALL_PATH = /usr/local/lib;
+				LIBRARY_SEARCH_PATHS = &quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1)&quot;;
+				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = &quot;\&quot;/Developer/FMOD Programmers API/api/lib\&quot;&quot;;
+				OTHER_LDFLAGS = &quot;-lfmodex&quot;;
+				PREBINDING = NO;
+				PRODUCT_NAME = RlFmod4Driver;
 				ZERO_LINK = NO;
 			};
 			name = Release;
 		};
-		4836F88E0D88592800E3632F /* Debug */ = {
+		483D87CA0D8C55E500F3629E /* Debug */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
 				COPY_PHASE_STRIP = NO;
+				DYLIB_COMPATIBILITY_VERSION = &quot;&quot;;
+				DYLIB_CURRENT_VERSION = &quot;&quot;;
+				EXECUTABLE_EXTENSION = bundle;
+				EXECUTABLE_PREFIX = &quot;&quot;;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				HEADER_SEARCH_PATHS = (
+					/sw/include,
+					/System/Library/Frameworks/Ruby.framework/Headers,
+				);
+				INSTALL_PATH = /usr/local/lib;
+				LIBRARY_SEARCH_PATHS = /System/Library/Frameworks/Ruby.framework/Versions/Current/usr/lib/;
+				MACH_O_TYPE = mh_bundle;
+				PREBINDING = NO;
+				PRODUCT_NAME = RlScript;
+				ZERO_LINK = YES;
+			};
+			name = Debug;
+		};
+		483D87CB0D8C55E500F3629E /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = YES;
+				DEBUG_INFORMATION_FORMAT = &quot;dwarf-with-dsym&quot;;
+				DYLIB_COMPATIBILITY_VERSION = &quot;&quot;;
+				DYLIB_CURRENT_VERSION = &quot;&quot;;
+				EXECUTABLE_EXTENSION = bundle;
+				EXECUTABLE_PREFIX = &quot;&quot;;
+				GCC_ENABLE_FIX_AND_CONTINUE = NO;
+				GCC_MODEL_TUNING = G5;
+				HEADER_SEARCH_PATHS = (
+					/sw/include,
+					/System/Library/Frameworks/Ruby.framework/Headers,
+				);
+				INSTALL_PATH = /usr/local/lib;
+				LIBRARY_SEARCH_PATHS = /System/Library/Frameworks/Ruby.framework/Versions/Current/usr/lib/;
+				MACH_O_TYPE = mh_bundle;
+				PREBINDING = NO;
+				PRODUCT_NAME = RlScript;
+				ZERO_LINK = NO;
+			};
+			name = Release;
+		};
+		48570C1C0D8A6C5400096E35 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				COPY_PHASE_STRIP = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				EXECUTABLE_EXTENSION = dylib;
 				EXECUTABLE_PREFIX = lib;
 				GCC_DYNAMIC_NO_PIC = NO;
 				GCC_ENABLE_FIX_AND_CONTINUE = YES;
@@ -3266,30 +3595,43 @@
 				INSTALL_PATH = /usr/local/lib;
 				LIBRARY_SEARCH_PATHS = (
 					/sw/lib,
-					/System/Library/Frameworks/Ruby.framework/Versions/Current/usr/lib,
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1)&quot;,
+					/System/Library/Frameworks/Ruby.framework/Versions/Current/usr/lib/,
 				);
 				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = &quot;\&quot;$(SYSTEM_LIBRARY_DIR)/Frameworks/Ruby.framework/Versions/1.8/usr/lib\&quot;&quot;;
+				MACH_O_TYPE = mh_dylib;
 				PREBINDING = NO;
 				PRODUCT_NAME = RlScript;
 				ZERO_LINK = YES;
 			};
 			name = Debug;
 		};
-		4836F88F0D88592800E3632F /* Release */ = {
+		48570C1D0D8A6C5400096E35 /* Release */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
 				COPY_PHASE_STRIP = YES;
 				DEBUG_INFORMATION_FORMAT = &quot;dwarf-with-dsym&quot;;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				EXECUTABLE_EXTENSION = dylib;
 				EXECUTABLE_PREFIX = lib;
 				GCC_ENABLE_FIX_AND_CONTINUE = NO;
 				GCC_MODEL_TUNING = G5;
+				HEADER_SEARCH_PATHS = (
+					/usr/local/include,
+					&quot;/usr/local/lib/ruby/1.8/i686-darwin8.9.1&quot;,
+					/sw/include,
+					/Library/Frameworks/CEGUI.framework/Headers,
+					/System/Library/Frameworks/Ruby.framework/Headers,
+				);
 				INSTALL_PATH = /usr/local/lib;
 				LIBRARY_SEARCH_PATHS = (
-					&quot;$(inherited)&quot;,
+					/sw/lib,
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1)&quot;,
+					/System/Library/Frameworks/Ruby.framework/Versions/Current/usr/lib/,
 				);
 				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = &quot;\&quot;$(SYSTEM_LIBRARY_DIR)/Frameworks/Ruby.framework/Versions/1.8/usr/lib\&quot;&quot;;
+				MACH_O_TYPE = mh_dylib;
 				PREBINDING = NO;
 				PRODUCT_NAME = RlScript;
 				ZERO_LINK = NO;
@@ -3313,9 +3655,11 @@
 					/sw/lib,
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1)&quot;,
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_2)&quot;,
+					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_3)&quot;,
 				);
 				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = &quot;\&quot;$(SRCROOT)/build/Debug\&quot;&quot;;
 				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_2 = &quot;\&quot;$(SYSTEM_LIBRARY_DIR)/Frameworks/Ruby.framework/Versions/1.8/usr/lib\&quot;&quot;;
+				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_3 = &quot;\&quot;$(SRCROOT)/build/Debug\&quot;&quot;;
 				PRODUCT_NAME = Rastullah;
 				WRAPPER_EXTENSION = app;
 				ZERO_LINK = YES;
@@ -3337,9 +3681,11 @@
 					/sw/lib,
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_1)&quot;,
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_2)&quot;,
+					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_3)&quot;,
 				);
 				LIBRARY_SEARCH_PATHS_QUOTED_1 = &quot;\&quot;$(SRCROOT)/build/Debug\&quot;&quot;;
 				LIBRARY_SEARCH_PATHS_QUOTED_2 = &quot;\&quot;$(SYSTEM_LIBRARY_DIR)/Frameworks/Ruby.framework/Versions/1.8/usr/lib\&quot;&quot;;
+				LIBRARY_SEARCH_PATHS_QUOTED_3 = &quot;\&quot;$(SRCROOT)/build/Debug\&quot;&quot;;
 				PRODUCT_NAME = Rastullah;
 				WRAPPER_EXTENSION = app;
 			};
@@ -3439,15 +3785,33 @@
 			defaultConfigurationIsVisible = 0;
 			defaultConfigurationName = Release;
 		};
-		4836F8900D88594600E3632F /* Build configuration list for PBXNativeTarget &quot;RlScript&quot; */ = {
+		483D86750D8C3A5F00F3629E /* Build configuration list for PBXNativeTarget &quot;RlFmod4Driver&quot; */ = {
 			isa = XCConfigurationList;
 			buildConfigurations = (
-				4836F88E0D88592800E3632F /* Debug */,
-				4836F88F0D88592800E3632F /* Release */,
+				483D86710D8C3A3400F3629E /* Debug */,
+				483D86720D8C3A3400F3629E /* Release */,
 			);
 			defaultConfigurationIsVisible = 0;
 			defaultConfigurationName = Release;
 		};
+		483D87D60D8C564E00F3629E /* Build configuration list for PBXNativeTarget &quot;RlScriptExports&quot; */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				483D87CA0D8C55E500F3629E /* Debug */,
+				483D87CB0D8C55E500F3629E /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		48570C3F0D8A6CAE00096E35 /* Build configuration list for PBXNativeTarget &quot;RlScript&quot; */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				48570C1C0D8A6C5400096E35 /* Debug */,
+				48570C1D0D8A6C5400096E35 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
 		C0E91AC508A95435008D54AB /* Build configuration list for PBXNativeTarget &quot;Rastullah&quot; */ = {
 			isa = XCConfigurationList;
 			buildConfigurations = (

Modified: rl/trunk/engine/ai/include/AStar.h
===================================================================
--- rl/trunk/engine/ai/include/AStar.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/ai/include/AStar.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -19,7 +19,6 @@
 #include &quot;AiPrerequisites.h&quot;
 #include &quot;AStarWayPointNode.h&quot;
 #include &quot;DebugVisualisable.h&quot;
-#include &quot;OgreVector3.h&quot;
 
 namespace rl
 {

Modified: rl/trunk/engine/ai/include/AiWorld.h
===================================================================
--- rl/trunk/engine/ai/include/AiWorld.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/ai/include/AiWorld.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -19,7 +19,12 @@
 #include &quot;OpenSteer/Obstacle.h&quot;
 #include &quot;DebugVisualisable.h&quot;
 #include &quot;SimpleVehicle.h&quot;
+
+#ifdef __APPLE__
+#include &lt;OgreNewt/OgreNewt.h&gt;
+#else
 #include &lt;OgreNewt.h&gt;
+#endif
 #include &lt;vector&gt;
 
 namespace OpenSteer

Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -20,8 +20,7 @@
 #include &quot;AgentManager.h&quot;
 #include &quot;DebugVisualisable.h&quot;
 #include &quot;LineSetPrimitive.h&quot;
-#include &quot;OgreVector3.h&quot;
-#include &quot;OpenSteer/SteerLibrary.h&quot;
+#include &lt;OpenSteer/SteerLibrary.h&gt;
 #include &quot;SimpleVehicle.h&quot;
 #include &quot;MessagePump.h&quot;
 

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -15,9 +15,12 @@
  */
 #include &quot;stdinc.h&quot; //precompiled header
 
-#include &lt;OgreNewt.h&gt;
+#ifdef __APPLE__
+#   include &lt;OgreNewt/OgreNewt.h&gt;
+#else
+#   include &lt;OgreNewt.h&gt;
+#endif
 
-
 #include &quot;AiWorld.h&quot;
 #include &quot;PhysicsManager.h&quot;
 #include &quot;LineSetPrimitive.h&quot;
@@ -25,10 +28,9 @@
 #include &quot;SteeringVehicle.h&quot;
 #include &quot;Actor.h&quot;
 #include &quot;PhysicalThing.h&quot;
-#include &quot;OgreVector3.h&quot;
 #include &quot;PhysicsMaterialRaycast.h&quot;
 #include &quot;World.h&quot;
-#include &quot;OpenSteer/Proximity.h&quot;
+#include &lt;OpenSteer/Proximity.h&gt;
 
 using namespace OpenSteer;
 using namespace Ogre;

Modified: rl/trunk/engine/ai/src/PhysicalObstacle.cpp
===================================================================
--- rl/trunk/engine/ai/src/PhysicalObstacle.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/ai/src/PhysicalObstacle.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -19,8 +19,13 @@
 #include &quot;PhysicalThing.h&quot;
 #include &quot;Exception.h&quot;
 #include &lt;OpenSteer/Obstacle.h&gt;
-#include &lt;OgreNewt.h&gt;
 
+#ifdef __APPLE__
+#   include &lt;OgreNewt/OgreNewt.h&gt;
+#else
+#   include &lt;OgreNewt.h&gt;
+#endif
+
 using namespace Ogre;
 
 namespace rl {

Modified: rl/trunk/engine/common/include/Logger.h
===================================================================
--- rl/trunk/engine/common/include/Logger.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/common/include/Logger.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -1,145 +1,140 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#ifndef __LOGGER_H__
-#define __LOGGER_H__
-
-#include &quot;CommonPrerequisites.h&quot;
-
-#ifdef __APPLE__
-#   include &lt;CEGUI/CEGUILogger.h&gt;
-#else
-#   include &lt;CEGUILogger.h&gt;
-#endif
-
-#include &lt;boost/filesystem/operations.hpp&gt;
-#include &lt;boost/filesystem/exception.hpp&gt;
-
-namespace fs = boost::filesystem;
-
-namespace rl {
-	class _RlCommonExport Logger : public Ogre::Singleton&lt;Logger&gt;
-	{
-	public:
-
-		static const char* COMMON;
-		static const char* RULES;
-		static const char* CORE;
-		static const char* DIALOG;
-		static const char* AI;
-		static const char* UI;
-		static const char* MULTIMEDIA;
-		static const char* MAIN;
-		static const char* SCRIPT;
-
-		enum LogLevel
-		{
-			LL_DEBUG = 1,
-			LL_MESSAGE,
-			LL_WARNING,
-			LL_ERROR,
-			LL_CRITICAL
-		};
-
-		static const char* LEVEL_TEXT[6];
-
-		Logger(const Ogre::String&amp; logDirectory, const Ogre::String&amp; ogreLogFile, const Ogre::String&amp; rastullahLogFile);
-		virtual ~Logger();
-
-		void log(
-			const LogLevel level,
-			const Ogre::String&amp; component,
-			const char* message,
-			const Ogre::String&amp; ident = &quot;&quot;);
-
-		void log(
-			const LogLevel level,
-			const Ogre::String&amp; component,
-			const Ogre::String&amp; message,
-			const Ogre::String&amp; ident = &quot;&quot;);
-
-		void log(
-			const LogLevel level,
-			const Ogre::String&amp; component,
-			const CeGuiString&amp; msg,
-			const Ogre::String&amp; ident = &quot;&quot;);
-
-		void setLogDetail(const LogLevel level);
-        const LogLevel&amp; getLogDetail();
-		const CEGUI::LoggingLevel getCeGuiLogDetail() const;
-
-		bool isErrorPresent() const;
-		void resetErrorState();
-		const Ogre::String&amp; getErrorLog() const;
-
-		Ogre::Log* _getLog() const;
-	private:
-		void log(const LogLevel level, const Ogre::String&amp; msg );
-
-        const Ogre::LoggingLevel getOgreLogDetail() const;
-
-		Ogre::Log* mLog;
-		LogLevel mLogLevel;
-		Ogre::String mErrorBuffer;
-		bool mErrorPresent;
-	};
-}
-
-#define RL_LOG2(level, component, msg, ident) \
-    if (rl::Logger::getSingletonPtr() != NULL &amp;&amp; level &gt;= rl::Logger::getSingleton().getLogDetail()) \
-		rl::Logger::getSingleton().log(level, component, msg, ident)
-
-#define RL_LOG(level, component, msg) \
-    RL_LOG2(level, component, msg, &quot;&quot;)
-
-#define RL_LOG_SHORT(level, msg) \
-    RL_LOG2(level, &quot;&quot;, msg, &quot;&quot;)
-
-#define LOG_DEBUG(component, msg) \
-    RL_LOG(rl::Logger::LL_DEBUG, component, msg)
-#define LOG_DEBUG2(component, msg, ident) \
-    RL_LOG2(rl::Logger::LL_DEBUG, component, msg, ident)
-#define LOG_DEBUG_SHORT(msg) \
-    RL_LOG_SHORT(rl::Logger::LL_DEBUG, msg)
-
-#define LOG_MESSAGE(component, msg) \
-    RL_LOG(rl::Logger::LL_MESSAGE, component, msg)
-#define LOG_MESSAGE2(component, msg, ident) \
-    RL_LOG2(rl::Logger::LL_MESSAGE, component, msg, ident)
-#define LOG_MESSAGE_SHORT(msg) \
-    RL_LOG_SHORT(rl::Logger::LL_MESSAGE, msg)
-
-#define LOG_WARNING(component, msg) \
-    RL_LOG(rl::Logger::LL_WARNING, component, msg)
-#define LOG_WARNING2(component, msg, ident) \
-    RL_LOG2(rl::Logger::LL_WARNING, component, msg, ident)
-#define LOG_WARNING_SHORT(msg) \
-    RL_LOG_SHORT(rl::Logger::LL_WARNING, msg)
-
-#define LOG_ERROR(component, msg) \
-    RL_LOG(rl::Logger::LL_ERROR, component, msg)
-#define LOG_ERROR2(component, msg, ident) \
-    RL_LOG2(rl::Logger::LL_ERROR, component, msg, ident)
-#define LOG_ERROR_SHORT(msg) \
-    RL_LOG_SHORT(rl::Logger::LL_ERROR, msg)
-
-#define LOG_CRITICAL(component, msg) \
-    RL_LOG(rl::Logger::LL_CRITICAL, component, msg)
-#define LOG_CRITICAL2(component, msg, ident) \
-    RL_LOG2(rl::Logger::LL_CRITICAL, component, msg, ident)
-#define LOG_CRITICAL_SHORT(msg) \
-    RL_LOG_SHORT(rl::Logger::LL_CRITICAL, msg)
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#ifndef __LOGGER_H__
+#define __LOGGER_H__
+
+#include &quot;CommonPrerequisites.h&quot;
+
+#ifdef __APPLE__
+#   include &lt;CEGUI/CEGUILogger.h&gt;
+#else
+#   include &lt;CEGUILogger.h&gt;
+#endif
+
+namespace rl {
+	class _RlCommonExport Logger : public Ogre::Singleton&lt;Logger&gt;
+	{
+	public:
+
+		static const char* COMMON;
+		static const char* RULES;
+		static const char* CORE;
+		static const char* DIALOG;
+		static const char* AI;
+		static const char* UI;
+		static const char* MULTIMEDIA;
+		static const char* MAIN;
+		static const char* SCRIPT;
+
+		enum LogLevel
+		{
+			LL_DEBUG = 1,
+			LL_MESSAGE,
+			LL_WARNING,
+			LL_ERROR,
+			LL_CRITICAL
+		};
+
+		static const char* LEVEL_TEXT[6];
+
+		Logger(const Ogre::String&amp; logDirectory, const Ogre::String&amp; ogreLogFile, const Ogre::String&amp; rastullahLogFile);
+		virtual ~Logger();
+
+		void log(
+			const LogLevel level,
+			const Ogre::String&amp; component,
+			const char* message,
+			const Ogre::String&amp; ident = &quot;&quot;);
+
+		void log(
+			const LogLevel level,
+			const Ogre::String&amp; component,
+			const Ogre::String&amp; message,
+			const Ogre::String&amp; ident = &quot;&quot;);
+
+		void log(
+			const LogLevel level,
+			const Ogre::String&amp; component,
+			const CeGuiString&amp; msg,
+			const Ogre::String&amp; ident = &quot;&quot;);
+
+		void setLogDetail(const LogLevel level);
+        const LogLevel&amp; getLogDetail();
+		const CEGUI::LoggingLevel getCeGuiLogDetail() const;
+
+		bool isErrorPresent() const;
+		void resetErrorState();
+		const Ogre::String&amp; getErrorLog() const;
+
+		Ogre::Log* _getLog() const;
+	private:
+		void log(const LogLevel level, const Ogre::String&amp; msg );
+
+        const Ogre::LoggingLevel getOgreLogDetail() const;
+
+		Ogre::Log* mLog;
+		LogLevel mLogLevel;
+		Ogre::String mErrorBuffer;
+		bool mErrorPresent;
+	};
+}
+
+#define RL_LOG2(level, component, msg, ident) \
+    if (rl::Logger::getSingletonPtr() != NULL &amp;&amp; level &gt;= rl::Logger::getSingleton().getLogDetail()) \
+		rl::Logger::getSingleton().log(level, component, msg, ident)
+
+#define RL_LOG(level, component, msg) \
+    RL_LOG2(level, component, msg, &quot;&quot;)
+
+#define RL_LOG_SHORT(level, msg) \
+    RL_LOG2(level, &quot;&quot;, msg, &quot;&quot;)
+
+#define LOG_DEBUG(component, msg) \
+    RL_LOG(rl::Logger::LL_DEBUG, component, msg)
+#define LOG_DEBUG2(component, msg, ident) \
+    RL_LOG2(rl::Logger::LL_DEBUG, component, msg, ident)
+#define LOG_DEBUG_SHORT(msg) \
+    RL_LOG_SHORT(rl::Logger::LL_DEBUG, msg)
+
+#define LOG_MESSAGE(component, msg) \
+    RL_LOG(rl::Logger::LL_MESSAGE, component, msg)
+#define LOG_MESSAGE2(component, msg, ident) \
+    RL_LOG2(rl::Logger::LL_MESSAGE, component, msg, ident)
+#define LOG_MESSAGE_SHORT(msg) \
+    RL_LOG_SHORT(rl::Logger::LL_MESSAGE, msg)
+
+#define LOG_WARNING(component, msg) \
+    RL_LOG(rl::Logger::LL_WARNING, component, msg)
+#define LOG_WARNING2(component, msg, ident) \
+    RL_LOG2(rl::Logger::LL_WARNING, component, msg, ident)
+#define LOG_WARNING_SHORT(msg) \
+    RL_LOG_SHORT(rl::Logger::LL_WARNING, msg)
+
+#define LOG_ERROR(component, msg) \
+    RL_LOG(rl::Logger::LL_ERROR, component, msg)
+#define LOG_ERROR2(component, msg, ident) \
+    RL_LOG2(rl::Logger::LL_ERROR, component, msg, ident)
+#define LOG_ERROR_SHORT(msg) \
+    RL_LOG_SHORT(rl::Logger::LL_ERROR, msg)
+
+#define LOG_CRITICAL(component, msg) \
+    RL_LOG(rl::Logger::LL_CRITICAL, component, msg)
+#define LOG_CRITICAL2(component, msg, ident) \
+    RL_LOG2(rl::Logger::LL_CRITICAL, component, msg, ident)
+#define LOG_CRITICAL_SHORT(msg) \
+    RL_LOG_SHORT(rl::Logger::LL_CRITICAL, msg)
+
+#endif

Modified: rl/trunk/engine/common/src/Logger.cpp
===================================================================
--- rl/trunk/engine/common/src/Logger.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/common/src/Logger.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -18,7 +18,11 @@
 
 #include &quot;Logger.h&quot;
 
+#include &lt;boost/filesystem/operations.hpp&gt;
+#include &lt;boost/filesystem/exception.hpp&gt;
 
+namespace fs = boost::filesystem;
+
 using Ogre::LogManager;
 using Ogre::Singleton;
 

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -1,452 +1,455 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-/**
- * \file ConfigurationManager.h
- *
- * Implementation of the ConfigurationManager subsystem
- */
-
-#include &quot;ConfigurationManager.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-
-template&lt;&gt; rl::ConfigurationManager* Ogre::Singleton&lt;rl::ConfigurationManager&gt;::ms_Singleton = 0;
-
-namespace rl
-{
-    ConfigurationManager* ConfigurationManager::getSingletonPtr()
-    {
-        if (ms_Singleton == NULL)
-        {
-            ms_Singleton = new ConfigurationManager();
-        }
-
-        return ms_Singleton;
-    }
-
-    ConfigurationManager&amp; ConfigurationManager::getSingleton()
-    {
-        if (ms_Singleton == NULL)
-        {
-            ms_Singleton = new ConfigurationManager();
-        }
-
-        return *ms_Singleton;
-    }
-
-    ConfigurationManager::ConfigurationManager()
-    {
-        // Filenames for log and configuration files
-        mRastullahCfgFile = &quot;rastullah.conf&quot;;
-        mOgreLogFile = &quot;ogre.log&quot;;
-        mCeguiLogFile = &quot;cegui.log&quot;;
-        mRastullahLogFile = &quot;rastullah.log&quot;;
-        mModulesCfgFile = &quot;modules.cfg&quot;;
-
-        // Setup general default values
-        addSetting(&quot;General&quot;, &quot;Log Level&quot;, &quot;2&quot;);
-        addSetting(&quot;General&quot;, &quot;Subtitle Speed&quot;, &quot;0.0&quot;);
-        addSetting(&quot;General&quot;, &quot;Save Console History&quot;, &quot;50&quot;);
-
-        // Setup sound default values
-        addSetting(&quot;Sound&quot;, &quot;DefaultMusicVolume&quot;, &quot;0.4&quot;);
-        addSetting(&quot;Sound&quot;, &quot;DefaultSoundVolume&quot;, &quot;0.9&quot;);
-        addSetting(&quot;Sound&quot;, &quot;MasterVolume&quot;, &quot;1&quot;);
-
-        // Setup graphic default values
-#       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-        addSetting(&quot;Video&quot;, &quot;Render System&quot;, &quot;Direct3D9 Rendering Subsystem&quot;);
-#       else
-        addSetting(&quot;Video&quot;, &quot;Render System&quot;,&quot;OpenGL Rendering Subsystem&quot;);
-        addSetting(&quot;Video&quot;, &quot;RTT Preferred Mode&quot;, &quot;FBO&quot;);
-#       endif
-        addSetting(&quot;Video&quot;, &quot;Fullscreen&quot;, &quot;no&quot;);
-        addSetting(&quot;Video&quot;, &quot;FSAA&quot;, &quot;0&quot;);
-        addSetting(&quot;Video&quot;, &quot;Video Mode&quot;, &quot;800 x 600&quot;);
-        addSetting(&quot;Video&quot;, &quot;Use Static Geometry&quot;, &quot;auto&quot;);
-        addSetting(&quot;Video&quot;, &quot;Max Anisotropy&quot;, &quot;1&quot;);
-		addSetting(&quot;Video&quot;, &quot;Cast Shadows&quot;, &quot;yes&quot;);
-		addSetting(&quot;Video&quot;, &quot;Shadow Texture Size&quot;, &quot;512&quot;);
-
-        // Setup input default values
-        addSetting(&quot;Input&quot;, &quot;Mouse Sensitivity&quot;, &quot;4&quot;);
-        addSetting(&quot;Input&quot;, &quot;Mouse Invert&quot;, &quot;no&quot;);
-
-        addSetting(&quot;Movement keys&quot;, &quot;turn_left&quot;, &quot;Q&quot;);
-        addSetting(&quot;Movement keys&quot;, &quot;turn_right&quot;, &quot;E&quot;);
-        addSetting(&quot;Movement keys&quot;, &quot;move_left&quot;, &quot;A&quot;);
-        addSetting(&quot;Movement keys&quot;, &quot;move_right&quot;, &quot;D&quot;);
-        addSetting(&quot;Movement keys&quot;, &quot;move_forward&quot;, &quot;W&quot;);
-        addSetting(&quot;Movement keys&quot;, &quot;move_backward&quot;, &quot;S&quot;);
-        addSetting(&quot;Movement keys&quot;, &quot;jump&quot;, &quot;Leertaste&quot;);
-        addSetting(&quot;Movement keys&quot;, &quot;run&quot;, &quot;Umschalt links&quot;);
-        addSetting(&quot;Movement keys&quot;, &quot;sneak&quot;, &quot;Strg links&quot;);
-        addSetting(&quot;Movement keys&quot;, &quot;run_lock&quot;, &quot;&lt; | &gt;&quot;);
-
-        addSetting(&quot;Action keys&quot;, &quot;quitgame&quot;, &quot;Ctrl+X&quot;);
-        addSetting(&quot;Action keys&quot;, &quot;closecurrentwindow&quot;, &quot;Escape&quot;);
-        addSetting(&quot;Action keys&quot;, &quot;toggleconsole&quot;, &quot;Tabulator&quot;);
-        addSetting(&quot;Action keys&quot;, &quot;toggledebugwindow&quot;, &quot;F2&quot;);
-        addSetting(&quot;Action keys&quot;, &quot;togglegamelogwindow&quot;, &quot;F3&quot;);
-        addSetting(&quot;Action keys&quot;, &quot;makescreenshot&quot;, &quot;P,Ctrl+P&quot;);
-        addSetting(&quot;Action keys&quot;, &quot;togglecollisiondebug&quot;, &quot;L,Ctrl+L&quot;);
-        addSetting(&quot;Action keys&quot;, &quot;toggledebugvisualisation&quot;, &quot;Ctrl+O&quot;);
-        addSetting(&quot;Action keys&quot;, &quot;usecurrentobjectdefaultaction&quot;, &quot;R&quot;);
-        addSetting(&quot;Action keys&quot;, &quot;toggleinventorywindow&quot;, &quot;I&quot;);
-        addSetting(&quot;Action keys&quot;, &quot;showjournalwindow&quot;, &quot;J&quot;);
-        addSetting(&quot;Action keys&quot;, &quot;showcharactersheet&quot;, &quot;C&quot;);
-        addSetting(&quot;Action keys&quot;, &quot;togglecharacterstatewindow&quot;, &quot;O&quot;);
-        addSetting(&quot;Action keys&quot;, &quot;toggleingameglobalmenu&quot;, &quot;F10&quot;);
-        addSetting(&quot;Action keys&quot;, &quot;shownextdebugwindowpage&quot;, &quot;Ctrl+M&quot;);
-        addSetting(&quot;Action keys&quot;, &quot;showobjectactions&quot;, &quot;U&quot;);
-        addSetting(&quot;Action keys&quot;, &quot;inventoryshowworldobjects&quot;, &quot;Strg links&quot;);
-
-        addSetting(&quot;FreeflightController keys&quot;, &quot;back_to_character_movement&quot;, &quot;M&quot;);
-        addSetting(&quot;FreeflightController keys&quot;, &quot;toggle_camera_collision&quot;, &quot;F&quot;);
-
-        addSetting(&quot;MovementController keys&quot;, &quot;freeflight_mode&quot;, &quot;M&quot;);
-        addSetting(&quot;MovementController keys&quot;, &quot;toggle_view_mode&quot;, &quot;F&quot;);
-        addSetting(&quot;MovementController keys&quot;, &quot;reset_camera&quot;, &quot;0 (Nummernblock)&quot;);
-
-        addSetting(&quot;Localization&quot;, &quot;language&quot;, &quot;de&quot;);
-
-        setRastullahCfgPath();
-    }
-
-    ConfigurationManager::~ConfigurationManager()
-    {
-    }
-
-    Ogre::String ConfigurationManager::getOgreLogFile() const
-    {
-        return mRastullahLogDirectory + &quot;/&quot; + mOgreLogFile;
-    }
-
-    Ogre::String ConfigurationManager::getRastullahLogFile() const
-    {
-        return mRastullahLogDirectory + &quot;/&quot; + mRastullahLogFile;
-    }
-
-    Ogre::String ConfigurationManager::getCeguiLogFile() const
-    {
-        return mRastullahLogDirectory + &quot;/&quot; + mCeguiLogFile;
-    }
-
-    Ogre::String ConfigurationManager::getModulesRootDirectory() const
-    {
-        return mModulesRootDirectory;
-    }
-
-    Ogre::String ConfigurationManager::getRastullahLogDirectory() const
-    {
-        return mRastullahLogDirectory;
-    }
-
-    Ogre::NameValuePairList ConfigurationManager::getSettings(const Ogre::String&amp; section) const
-    {
-        SectionMap::const_iterator it = mSettings.find(section);
-        if (it != mSettings.end())
-        {
-            return it-&gt;second;
-        }
-        else
-        {
-            return Ogre::NameValuePairList();
-        }
-    }
-
-    Ogre::StringVector ConfigurationManager::getPluginList() const
-    {
-        return mPluginList;
-    }
-
-    Ogre::StringVector ConfigurationManager::getModuleList() const
-    {
-        return mModuleList;
-    }
-
-    void ConfigurationManager::loadConfig()
-    {
-        // On Linux, we create the .rastullah directory
-#       if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-        fs::path rastullahCfgDirectory(Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah&quot;,
-            fs::portable_posix_name);
-
-        if (!fs::exists(rastullahCfgDirectory))
-        {
-            fs::create_directory(rastullahCfgDirectory);
-        }
-#       endif
-
-        // First check, if we have found any directory
-        if (!mRastullahCfgPath.empty())
-        {
-            ConfigFile* configfile = new ConfigFile();
-
-            // Split the path at the ':' character
-            std::vector&lt;Ogre::String&gt; cfg_paths = Ogre::StringUtil::split(mRastullahCfgPath, &quot;:&quot;);
-
-            for (unsigned int i = 0; i &lt; cfg_paths.size(); i++)
-            {
-                try
-                {
-                    std::cout &lt;&lt; &quot;Loading Configuration File &quot; &lt;&lt; cfg_paths[i]
-                        &lt;&lt; mRastullahCfgFile &lt;&lt; std::endl;
-                    configfile-&gt;load(cfg_paths[i] + mRastullahCfgFile, &quot;=&quot;, true);
-                }
-                catch (Ogre::Exception)
-                {
-                    LOG_ERROR2(Logger::CORE,
-                         &quot;Konnte Rastullah-Konfiguration in '&quot; + cfg_paths[i] +
-                         &quot;' nicht laden! Defaulteinstellungen werden benutzt.&quot;,&quot;Configuration&quot;);
-                }
-
-                try
-                {
-                    for (ConfigFile::SectionIterator it = configfile-&gt;getSectionIterator();
-                            it.hasMoreElements(); it.moveNext())
-                    {
-                        Ogre::String sectionName = it.peekNextKey();
-                        Ogre::NameValuePairList settings = mSettings[sectionName];
-                        for (ConfigFile::SettingsIterator it =
-                            configfile-&gt;getSettingsIterator(sectionName);
-                            it.hasMoreElements(); it.moveNext())
-                        {
-                            settings[it.peekNextKey()] = it.peekNextValue();
-                        }
-                        mSettings[sectionName] = settings;
-                    }
-                }
-                catch (Ogre::Exception&amp;)
-                {
-                    // Log it as information
-                    LOG_WARNING(Logger::CORE, &quot;Configuration File &quot; + cfg_paths[i] +
-                        mRastullahCfgFile + &quot; - Error on parsing.&quot;);
-                }
-            }
-
-            delete configfile;
-        }
-
-        mRastullahLogDirectory = findSetting(&quot;Paths&quot;, &quot;LogDirectory&quot;);
-        mModulesRootDirectory = findSetting(&quot;Paths&quot;, &quot;ModulesDirectory&quot;);
-        mOgrePluginDirectory = findSetting(&quot;Paths&quot;, &quot;OgrePluginDirectory&quot;);
-
-        if (mRastullahLogDirectory.empty())
-        {
-#           if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-            mRastullahLogDirectory = Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/logs&quot;;
-#           else
-            mRastullahLogDirectory = &quot;./logs&quot;;
-#           endif
-        }
-
-        if (mModulesRootDirectory.empty())
-        {
-#           if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-                mModulesRootDirectory = RL_MODULEDIR;
-#           else
-                mModulesRootDirectory = &quot;./modules&quot;;
-#           endif
-        }
-
-        if (mOgrePluginDirectory.empty())
-        {
-#           if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-            mOgrePluginDirectory = OGRE_PLUGINDIR;
-#           else
-            mOgrePluginDirectory = &quot;.&quot;;
-#           endif
-        }
-
-        // Plugin list for OGRE specific to operating system
-#       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-        addPlugin(&quot;RenderSystem_Direct3D9&quot;, mOgrePluginDirectory);
-#       endif
-        addPlugin(&quot;RenderSystem_GL&quot;, mOgrePluginDirectory);
-        addPlugin(&quot;Plugin_ParticleFX&quot;, mOgrePluginDirectory);
-        addPlugin(&quot;Plugin_OctreeSceneManager&quot;, mOgrePluginDirectory);
-
-        // Load the module list
-        ConfigFile* configfile = new ConfigFile();
-        configfile-&gt;load(fs::path(mModulesRootDirectory + &quot;/&quot; + mModulesCfgFile).native_directory_string());
-
-        ConfigFile::SettingsIterator it = configfile-&gt;getSettingsIterator();
-        for (ConfigFile::SettingsIterator it = configfile-&gt;getSettingsIterator();
-             it.hasMoreElements(); it.moveNext())
-        {
-            // If key is module, we add value to our module list
-            if (it.peekNextKey() == &quot;module&quot;)
-            {
-                mModuleList.push_back(it.peekNextValue());
-            }
-        }
-
-        delete configfile;
-    }
-
-    void ConfigurationManager::saveConfig() const
-    {
-        ConfigFile* cfgfile = new ConfigFile();
-
-        for (SectionMap::const_iterator it = mSettings.begin(); it != mSettings.end(); ++it)
-        {
-            cfgfile-&gt;addSection(it-&gt;first, it-&gt;second);
-        }
-
-#       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-        cfgfile-&gt;save(fs::path(&quot;./modules/config/&quot; + mRastullahCfgFile).native_file_string());
-#       else
-        cfgfile-&gt;save(Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/&quot; + mRastullahCfgFile);
-#       endif
-
-        delete cfgfile;
-    }
-
-    Logger::LogLevel ConfigurationManager::getLogLevel() const
-    {
-        return static_cast&lt;Logger::LogLevel&gt;(getIntSetting(&quot;General&quot;,
-            &quot;Log Level&quot;));
-    }
-
-    Ogre::String ConfigurationManager::getStringSetting(const Ogre::String&amp; section,
-        const Ogre::String&amp; key) const
-    {
-        // Get the value we are looking for
-        return findSetting(section, key);
-    }
-
-    int ConfigurationManager::getIntSetting(const Ogre::String&amp; section,
-        const Ogre::String&amp; key) const
-    {
-        // Get the value we are looking for
-        return Ogre::StringConverter::parseInt(findSetting(section, key));
-    }
-
-    bool ConfigurationManager::getBoolSetting(const Ogre::String&amp; section,
-        const Ogre::String&amp; key) const
-    {
-        // Get the value we are looking for
-        return Ogre::StringConverter::parseBool(findSetting(section, key));
-    }
-
-    Ogre::Real ConfigurationManager::getRealSetting(const Ogre::String&amp; section,
-        const Ogre::String&amp; key) const
-    {
-        // Get the value we are looking for
-        return Ogre::StringConverter::parseReal(findSetting(section, key));
-    }
-
-    Ogre::String ConfigurationManager::findSetting(const Ogre::String&amp; section,
-        const Ogre::String&amp; key) const
-    {
-        SectionMap::const_iterator sectionIt = mSettings.find(section);
-        if (sectionIt != mSettings.end())
-        {
-            Ogre::NameValuePairList::const_iterator it = sectionIt-&gt;second.find(key);
-
-            if (it != sectionIt-&gt;second.end())
-            {
-                return it-&gt;second;
-            }
-        }
-        return &quot;&quot;;
-    }
-
-    void ConfigurationManager::addSetting(const Ogre::String&amp; section,
-        const Ogre::String&amp; key, const Ogre::String&amp; value)
-    {
-        mSettings[section][key] = value;
-    }
-
-    Ogre::String ConfigurationManager::getKeymap() const
-    {
-        return Ogre::String(&quot;config/keymap-german.xml&quot;);
-    }
-
-    void ConfigurationManager::setRastullahCfgPath()
-    {
-        // First try: Current directory
-        addToCfgPath(&quot;./&quot;);
-
-#       if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-        // Check system wide /etc/rastullah directory
-        addToCfgPath(&quot;/etc/rastullah/&quot;);
-        // Check home .rastullah directory
-        addToCfgPath(Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/&quot;);
-#       else
-        addToCfgPath(&quot;./modules/config/&quot;);
-#       endif
-    }
-
-    void ConfigurationManager::addToCfgPath(const Ogre::String&amp; path)
-    {
-        std::cout &lt;&lt; &quot;Checking for &quot; &lt;&lt; mRastullahCfgFile &lt;&lt; &quot; in &quot; &lt;&lt; path &lt;&lt; std::endl;
-
-        if (checkForFile(path + mRastullahCfgFile))
-        {
-            if (mRastullahCfgPath.size() &gt; 0)
-            {
-                mRastullahCfgPath += &quot;:&quot; + path;
-            }
-            else
-            {
-                mRastullahCfgPath = path;
-            }
-
-            std::cout &lt;&lt; &quot;Adding path &quot; &lt;&lt; path &lt;&lt; &quot; to Rastullah configuration path.&quot;
-                &lt;&lt; std::endl;
-        }
-    }
-
-    bool ConfigurationManager::checkForFile(const Ogre::String&amp; filename)
-    {
-        try {
-#           if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-            if (fs::exists(filename))
-#           else
-            if (fs::exists(fs::path(filename, fs::portable_posix_name)))
-#           endif
-            {
-                return true;
-            }
-        }
-        catch (fs::filesystem_error&amp;) {
-            return false;
-        }
-
-        return false;
-    }
-
-    void ConfigurationManager::addPlugin(const Ogre::String&amp; plugin, const Ogre::String&amp; pluginDir)
-    {
-        // In Windows Ogre now uses a _d suffix for debug plugins. But client application is
-        // responsible for loading the proper vesion.
-        Ogre::String pluginSuffix = &quot;&quot;;
-
-#       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-        Ogre::String dirSeparator = &quot;\\&quot;;
-#          ifdef _DEBUG
-        pluginSuffix = &quot;_d&quot;;
-#          endif
-#       else
-        Ogre::String dirSeparator = &quot;/&quot;;
-#       endif
-
-        mPluginList.push_back(pluginDir + dirSeparator + plugin + pluginSuffix);
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+/**
+ * \file ConfigurationManager.h
+ *
+ * Implementation of the ConfigurationManager subsystem
+ */
+
+#include &quot;ConfigurationManager.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+
+template&lt;&gt; rl::ConfigurationManager* Ogre::Singleton&lt;rl::ConfigurationManager&gt;::ms_Singleton = 0;
+
+namespace rl
+{
+    ConfigurationManager* ConfigurationManager::getSingletonPtr()
+    {
+        if (ms_Singleton == NULL)
+        {
+            ms_Singleton = new ConfigurationManager();
+        }
+
+        return ms_Singleton;
+    }
+
+    ConfigurationManager&amp; ConfigurationManager::getSingleton()
+    {
+        if (ms_Singleton == NULL)
+        {
+            ms_Singleton = new ConfigurationManager();
+        }
+
+        return *ms_Singleton;
+    }
+
+    ConfigurationManager::ConfigurationManager()
+    {
+        // Filenames for log and configuration files
+        mRastullahCfgFile = &quot;rastullah.conf&quot;;
+        mOgreLogFile = &quot;ogre.log&quot;;
+        mCeguiLogFile = &quot;cegui.log&quot;;
+        mRastullahLogFile = &quot;rastullah.log&quot;;
+        mModulesCfgFile = &quot;modules.cfg&quot;;
+
+        // Setup general default values
+        addSetting(&quot;General&quot;, &quot;Log Level&quot;, &quot;2&quot;);
+        addSetting(&quot;General&quot;, &quot;Subtitle Speed&quot;, &quot;0.0&quot;);
+        addSetting(&quot;General&quot;, &quot;Save Console History&quot;, &quot;50&quot;);
+
+        // Setup sound default values
+        addSetting(&quot;Sound&quot;, &quot;DefaultMusicVolume&quot;, &quot;0.4&quot;);
+        addSetting(&quot;Sound&quot;, &quot;DefaultSoundVolume&quot;, &quot;0.9&quot;);
+        addSetting(&quot;Sound&quot;, &quot;MasterVolume&quot;, &quot;1&quot;);
+
+        // Setup graphic default values
+#       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+        addSetting(&quot;Video&quot;, &quot;Render System&quot;, &quot;Direct3D9 Rendering Subsystem&quot;);
+#       else
+        addSetting(&quot;Video&quot;, &quot;Render System&quot;,&quot;OpenGL Rendering Subsystem&quot;);
+        addSetting(&quot;Video&quot;, &quot;RTT Preferred Mode&quot;, &quot;FBO&quot;);
+#       endif
+        addSetting(&quot;Video&quot;, &quot;Fullscreen&quot;, &quot;no&quot;);
+        addSetting(&quot;Video&quot;, &quot;FSAA&quot;, &quot;0&quot;);
+        addSetting(&quot;Video&quot;, &quot;Video Mode&quot;, &quot;800 x 600&quot;);
+        addSetting(&quot;Video&quot;, &quot;Use Static Geometry&quot;, &quot;auto&quot;);
+        addSetting(&quot;Video&quot;, &quot;Max Anisotropy&quot;, &quot;1&quot;);
+		addSetting(&quot;Video&quot;, &quot;Cast Shadows&quot;, &quot;yes&quot;);
+		addSetting(&quot;Video&quot;, &quot;Shadow Texture Size&quot;, &quot;512&quot;);
+
+        // Setup input default values
+        addSetting(&quot;Input&quot;, &quot;Mouse Sensitivity&quot;, &quot;4&quot;);
+        addSetting(&quot;Input&quot;, &quot;Mouse Invert&quot;, &quot;no&quot;);
+
+        addSetting(&quot;Movement keys&quot;, &quot;turn_left&quot;, &quot;Q&quot;);
+        addSetting(&quot;Movement keys&quot;, &quot;turn_right&quot;, &quot;E&quot;);
+        addSetting(&quot;Movement keys&quot;, &quot;move_left&quot;, &quot;A&quot;);
+        addSetting(&quot;Movement keys&quot;, &quot;move_right&quot;, &quot;D&quot;);
+        addSetting(&quot;Movement keys&quot;, &quot;move_forward&quot;, &quot;W&quot;);
+        addSetting(&quot;Movement keys&quot;, &quot;move_backward&quot;, &quot;S&quot;);
+        addSetting(&quot;Movement keys&quot;, &quot;jump&quot;, &quot;Leertaste&quot;);
+        addSetting(&quot;Movement keys&quot;, &quot;run&quot;, &quot;Umschalt links&quot;);
+        addSetting(&quot;Movement keys&quot;, &quot;sneak&quot;, &quot;Strg links&quot;);
+        addSetting(&quot;Movement keys&quot;, &quot;run_lock&quot;, &quot;&lt; | &gt;&quot;);
+
+        addSetting(&quot;Action keys&quot;, &quot;quitgame&quot;, &quot;Ctrl+X&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;closecurrentwindow&quot;, &quot;Escape&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;toggleconsole&quot;, &quot;Tabulator&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;toggledebugwindow&quot;, &quot;F2&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;togglegamelogwindow&quot;, &quot;F3&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;makescreenshot&quot;, &quot;P,Ctrl+P&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;togglecollisiondebug&quot;, &quot;L,Ctrl+L&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;toggledebugvisualisation&quot;, &quot;Ctrl+O&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;usecurrentobjectdefaultaction&quot;, &quot;R&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;toggleinventorywindow&quot;, &quot;I&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;showjournalwindow&quot;, &quot;J&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;showcharactersheet&quot;, &quot;C&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;togglecharacterstatewindow&quot;, &quot;O&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;toggleingameglobalmenu&quot;, &quot;F10&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;shownextdebugwindowpage&quot;, &quot;Ctrl+M&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;showobjectactions&quot;, &quot;U&quot;);
+        addSetting(&quot;Action keys&quot;, &quot;inventoryshowworldobjects&quot;, &quot;Strg links&quot;);
+
+        addSetting(&quot;FreeflightController keys&quot;, &quot;back_to_character_movement&quot;, &quot;M&quot;);
+        addSetting(&quot;FreeflightController keys&quot;, &quot;toggle_camera_collision&quot;, &quot;F&quot;);
+
+        addSetting(&quot;MovementController keys&quot;, &quot;freeflight_mode&quot;, &quot;M&quot;);
+        addSetting(&quot;MovementController keys&quot;, &quot;toggle_view_mode&quot;, &quot;F&quot;);
+        addSetting(&quot;MovementController keys&quot;, &quot;reset_camera&quot;, &quot;0 (Nummernblock)&quot;);
+
+        addSetting(&quot;Localization&quot;, &quot;language&quot;, &quot;de&quot;);
+
+        setRastullahCfgPath();
+    }
+
+    ConfigurationManager::~ConfigurationManager()
+    {
+    }
+
+    Ogre::String ConfigurationManager::getOgreLogFile() const
+    {
+        return mRastullahLogDirectory + &quot;/&quot; + mOgreLogFile;
+    }
+
+    Ogre::String ConfigurationManager::getRastullahLogFile() const
+    {
+        return mRastullahLogDirectory + &quot;/&quot; + mRastullahLogFile;
+    }
+
+    Ogre::String ConfigurationManager::getCeguiLogFile() const
+    {
+        return mRastullahLogDirectory + &quot;/&quot; + mCeguiLogFile;
+    }
+
+    Ogre::String ConfigurationManager::getModulesRootDirectory() const
+    {
+        return mModulesRootDirectory;
+    }
+
+    Ogre::String ConfigurationManager::getRastullahLogDirectory() const
+    {
+        return mRastullahLogDirectory;
+    }
+
+    Ogre::NameValuePairList ConfigurationManager::getSettings(const Ogre::String&amp; section) const
+    {
+        SectionMap::const_iterator it = mSettings.find(section);
+        if (it != mSettings.end())
+        {
+            return it-&gt;second;
+        }
+        else
+        {
+            return Ogre::NameValuePairList();
+        }
+    }
+
+    Ogre::StringVector ConfigurationManager::getPluginList() const
+    {
+        return mPluginList;
+    }
+
+    Ogre::StringVector ConfigurationManager::getModuleList() const
+    {
+        return mModuleList;
+    }
+
+    void ConfigurationManager::loadConfig()
+    {
+        // On Linux, we create the .rastullah directory
+#       if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
+        fs::path rastullahCfgDirectory(Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah&quot;,
+            fs::portable_posix_name);
+
+        if (!fs::exists(rastullahCfgDirectory))
+        {
+            fs::create_directory(rastullahCfgDirectory);
+        }
+#       endif
+
+        // First check, if we have found any directory
+        if (!mRastullahCfgPath.empty())
+        {
+            ConfigFile* configfile = new ConfigFile();
+
+            // Split the path at the ':' character
+            std::vector&lt;Ogre::String&gt; cfg_paths = Ogre::StringUtil::split(mRastullahCfgPath, &quot;:&quot;);
+
+            for (unsigned int i = 0; i &lt; cfg_paths.size(); i++)
+            {
+                try
+                {
+                    std::cout &lt;&lt; &quot;Loading Configuration File &quot; &lt;&lt; cfg_paths[i]
+                        &lt;&lt; mRastullahCfgFile &lt;&lt; std::endl;
+                    configfile-&gt;load(cfg_paths[i] + mRastullahCfgFile, &quot;=&quot;, true);
+                }
+                catch (Ogre::Exception)
+                {
+                    LOG_ERROR2(Logger::CORE,
+                         &quot;Konnte Rastullah-Konfiguration in '&quot; + cfg_paths[i] +
+                         &quot;' nicht laden! Defaulteinstellungen werden benutzt.&quot;,&quot;Configuration&quot;);
+                }
+
+                try
+                {
+                    for (ConfigFile::SectionIterator it = configfile-&gt;getSectionIterator();
+                            it.hasMoreElements(); it.moveNext())
+                    {
+                        Ogre::String sectionName = it.peekNextKey();
+                        Ogre::NameValuePairList settings = mSettings[sectionName];
+                        for (ConfigFile::SettingsIterator it =
+                            configfile-&gt;getSettingsIterator(sectionName);
+                            it.hasMoreElements(); it.moveNext())
+                        {
+                            settings[it.peekNextKey()] = it.peekNextValue();
+                        }
+                        mSettings[sectionName] = settings;
+                    }
+                }
+                catch (Ogre::Exception&amp;)
+                {
+                    // Log it as information
+                    LOG_WARNING(Logger::CORE, &quot;Configuration File &quot; + cfg_paths[i] +
+                        mRastullahCfgFile + &quot; - Error on parsing.&quot;);
+                }
+            }
+
+            delete configfile;
+        }
+
+        mRastullahLogDirectory = findSetting(&quot;Paths&quot;, &quot;LogDirectory&quot;);
+        mModulesRootDirectory = findSetting(&quot;Paths&quot;, &quot;ModulesDirectory&quot;);
+        mOgrePluginDirectory = findSetting(&quot;Paths&quot;, &quot;OgrePluginDirectory&quot;);
+
+        if (mRastullahLogDirectory.empty())
+        {
+#           if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+            mRastullahLogDirectory = &quot;./logs&quot;;
+#           else
+            mRastullahLogDirectory = Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/logs&quot;;
+#           endif
+        }
+
+        if (mModulesRootDirectory.empty())
+        {
+#           if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
+            mModulesRootDirectory = RL_MODULEDIR;
+#           else
+            mModulesRootDirectory = &quot;./modules&quot;;
+#           endif
+        }
+
+        if (mOgrePluginDirectory.empty())
+        {
+#           if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
+            mOgrePluginDirectory = OGRE_PLUGINDIR;
+#           else
+            mOgrePluginDirectory = &quot;.&quot;;
+#           endif
+        }
+
+        // Plugin list for OGRE specific to operating system
+#       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+        addPlugin(&quot;RenderSystem_Direct3D9&quot;, mOgrePluginDirectory);
+#       endif
+        addPlugin(&quot;RenderSystem_GL&quot;, mOgrePluginDirectory);
+        addPlugin(&quot;Plugin_ParticleFX&quot;, mOgrePluginDirectory);
+        addPlugin(&quot;Plugin_OctreeSceneManager&quot;, mOgrePluginDirectory);
+
+        // Load the module list
+        ConfigFile* configfile = new ConfigFile();
+        configfile-&gt;load(fs::path(mModulesRootDirectory + &quot;/&quot; + mModulesCfgFile).native_directory_string());
+
+        ConfigFile::SettingsIterator it = configfile-&gt;getSettingsIterator();
+        for (ConfigFile::SettingsIterator it = configfile-&gt;getSettingsIterator();
+             it.hasMoreElements(); it.moveNext())
+        {
+            // If key is module, we add value to our module list
+            if (it.peekNextKey() == &quot;module&quot;)
+            {
+                mModuleList.push_back(it.peekNextValue());
+            }
+        }
+
+        delete configfile;
+    }
+
+    void ConfigurationManager::saveConfig() const
+    {
+        ConfigFile* cfgfile = new ConfigFile();
+
+        for (SectionMap::const_iterator it = mSettings.begin(); it != mSettings.end(); ++it)
+        {
+            cfgfile-&gt;addSection(it-&gt;first, it-&gt;second);
+        }
+
+#       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+        cfgfile-&gt;save(fs::path(&quot;./modules/config/&quot; + mRastullahCfgFile).native_file_string());
+#       else
+        cfgfile-&gt;save(Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/&quot; + mRastullahCfgFile);
+#       endif
+
+        delete cfgfile;
+    }
+
+    Logger::LogLevel ConfigurationManager::getLogLevel() const
+    {
+        return static_cast&lt;Logger::LogLevel&gt;(getIntSetting(&quot;General&quot;,
+            &quot;Log Level&quot;));
+    }
+
+    Ogre::String ConfigurationManager::getStringSetting(const Ogre::String&amp; section,
+        const Ogre::String&amp; key) const
+    {
+        // Get the value we are looking for
+        return findSetting(section, key);
+    }
+
+    int ConfigurationManager::getIntSetting(const Ogre::String&amp; section,
+        const Ogre::String&amp; key) const
+    {
+        // Get the value we are looking for
+        return Ogre::StringConverter::parseInt(findSetting(section, key));
+    }
+
+    bool ConfigurationManager::getBoolSetting(const Ogre::String&amp; section,
+        const Ogre::String&amp; key) const
+    {
+        // Get the value we are looking for
+        return Ogre::StringConverter::parseBool(findSetting(section, key));
+    }
+
+    Ogre::Real ConfigurationManager::getRealSetting(const Ogre::String&amp; section,
+        const Ogre::String&amp; key) const
+    {
+        // Get the value we are looking for
+        return Ogre::StringConverter::parseReal(findSetting(section, key));
+    }
+
+    Ogre::String ConfigurationManager::findSetting(const Ogre::String&amp; section,
+        const Ogre::String&amp; key) const
+    {
+        SectionMap::const_iterator sectionIt = mSettings.find(section);
+        if (sectionIt != mSettings.end())
+        {
+            Ogre::NameValuePairList::const_iterator it = sectionIt-&gt;second.find(key);
+
+            if (it != sectionIt-&gt;second.end())
+            {
+                return it-&gt;second;
+            }
+        }
+        return &quot;&quot;;
+    }
+
+    void ConfigurationManager::addSetting(const Ogre::String&amp; section,
+        const Ogre::String&amp; key, const Ogre::String&amp; value)
+    {
+        mSettings[section][key] = value;
+    }
+
+    Ogre::String ConfigurationManager::getKeymap() const
+    {
+        return Ogre::String(&quot;config/keymap-german.xml&quot;);
+    }
+
+    void ConfigurationManager::setRastullahCfgPath()
+    {
+        // First try: Current directory
+        addToCfgPath(&quot;./&quot;);
+
+#       if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
+        // Check system wide /etc/rastullah directory
+        addToCfgPath(&quot;/etc/rastullah/&quot;);
+        // Check home .rastullah directory
+        addToCfgPath(Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/&quot;);
+#       endif
+        addToCfgPath(&quot;./modules/config/&quot;);
+    }
+
+    void ConfigurationManager::addToCfgPath(const Ogre::String&amp; path)
+    {
+        std::cout &lt;&lt; &quot;Checking for &quot; &lt;&lt; mRastullahCfgFile &lt;&lt; &quot; in &quot; &lt;&lt; path &lt;&lt; std::endl;
+
+        if (checkForFile(path + mRastullahCfgFile))
+        {
+            if (mRastullahCfgPath.size() &gt; 0)
+            {
+                mRastullahCfgPath += &quot;:&quot; + path;
+            }
+            else
+            {
+                mRastullahCfgPath = path;
+            }
+
+            std::cout &lt;&lt; &quot;Adding path &quot; &lt;&lt; path &lt;&lt; &quot; to Rastullah configuration path.&quot;
+                &lt;&lt; std::endl;
+        }
+    }
+
+    bool ConfigurationManager::checkForFile(const Ogre::String&amp; filename)
+    {
+        try {
+#           if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+            if (fs::exists(filename))
+#           else
+            if (fs::exists(fs::path(filename, fs::portable_posix_name)))
+#           endif
+            {
+                return true;
+            }
+        }
+        catch (fs::filesystem_error&amp;) {
+            return false;
+        }
+
+        return false;
+    }
+
+    void ConfigurationManager::addPlugin(const Ogre::String&amp; plugin, const Ogre::String&amp; pluginDir)
+    {
+        // In Windows Ogre now uses a _d suffix for debug plugins. But client application is
+        // responsible for loading the proper vesion.
+        Ogre::String pluginSuffix = &quot;&quot;;
+
+#       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+        Ogre::String dirSeparator = &quot;\\&quot;;
+#          ifdef _DEBUG
+        pluginSuffix = &quot;_d&quot;;
+#          endif
+#       else
+        Ogre::String dirSeparator = &quot;/&quot;;
+#       endif
+        
+#       if OGRE_PLATFORM == OGRE_PLATFORM_APPLE
+        mPluginList.push_back(plugin + pluginSuffix);
+#       else
+        mPluginList.push_back(pluginDir + dirSeparator + plugin + pluginSuffix);
+#       endif
+    }
+}

Modified: rl/trunk/engine/core/src/RubyInterpreter.cpp
===================================================================
--- rl/trunk/engine/core/src/RubyInterpreter.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/core/src/RubyInterpreter.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -1,166 +1,168 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-
-#include &quot;RubyInterpreter.h&quot;
-
-#include &quot;FixRubyHeaders.h&quot;
-
-#include &lt;ruby.h&gt;
-
-#include &quot;FixRubyHeaders.h&quot;
-
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;ConfigurationManager.h&quot;
-#include &quot;ContentModule.h&quot;
-
-using namespace Ogre;
-
-namespace rl {
-
-RubyInterpreter::RubyInterpreter()
-{
-
-}
-
-RubyInterpreter::~RubyInterpreter()
-{
-
-}
-
-void RubyInterpreter::initializeInterpreter()
-{
-    #if defined(NT)
-        static int dummyargc(0);
-        static char** vec;
-        NtInitialize(&amp;dummyargc, &amp;vec);
-    #endif
-
-    //Ruby Initialisieren
-    ruby_init();
-
-    // UTF 8 aktivieren
-    execute( &quot;$KCODE = 'u'&quot; );
-
-    //Skript-Verzeichnisse der  Dateien duerfen auch in /script liegen
-    ModuleMap modules = CoreSubsystem::getSingleton().getAllModules();
-    for (ModuleMap::iterator iter = modules.begin(); iter != modules.end(); iter++)
-    {
-        ContentModule* mod = (*iter).second;
-        //wir suchen die Scripte im modules Verzeichnis relativ zum ModuleRootPath!
-        addSearchPath(mod-&gt;getDirectory() + &quot;/conf&quot;);
-        addSearchPath(mod-&gt;getDirectory() + &quot;/scripts&quot;);
-        addSearchPath(mod-&gt;getDirectory() + &quot;/scripts/maps&quot;);
-    }
-
-    ruby_init_loadpath();
-    //Skriptname
-    ruby_script(&quot;Rastullah&quot;);
-    // Fuer Ruby .dll oder .so dazu laden
-
-    loadProtected(&amp;RubyInterpreter::loadDlls, 0, &quot;Ruby error while loading dlls&quot;);
-}
-
-
-void RubyInterpreter::finalizeInterpreter()
-{
-    ruby_finalize();
-}
-
-void RubyInterpreter::setOutputFunction(staticValueMethod func)
-{
-    //Ersetzt die Standard-Ausgabe von Ruby durch Ausgaben in die Console
-    rb_defout = rb_str_new(&quot;&quot;, 0);
-    // Eigentlich nicht mehr notwendig, aber ohne das gibts nen Absturz?!?!
-    // rb_define_singleton_method(rb_defout, &quot;write&quot;, (VALUE(*)(...))console_write, 1);
-    rb_define_singleton_method(rb_defout, &quot;write&quot;, func, 1);
-}
-
-void RubyInterpreter::addSearchPath(const Ogre::String&amp; path)
-{
-    ruby_incpush(path.c_str());
-}
-
-VALUE RubyInterpreter::loadDlls(VALUE val)
-{
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-    rb_require(&quot;RlScript&quot;);
-#else
-    rb_require(&quot;libRlScript&quot;);
-#endif
-
-    return Qnil;
-}
-
-void RubyInterpreter::loadProtected(ProtectedMethod func, VALUE val, const std::string&amp; msg, bool exitOnFail)
-{
-    int error = 0;
-    rb_protect(func, val, &amp;error);
-    logRubyErrors(&quot;Ruby error while initializing&quot;, error);
-}
-
-void RubyInterpreter::logRubyErrors(const std::string&amp; intro, int errorcode)
-{
-    if(errorcode != 0)
-    {
-        VALUE info = rb_inspect(ruby_errinfo);
-        rb_backtrace();
-        if (intro.length() &gt; 0)
-            LOG_ERROR(Logger::CORE, intro);
-        LOG_ERROR(Logger::CORE, STR2CSTR(info));
-    }
-}
-
-bool RubyInterpreter::execute(const Ogre::String&amp; command)
-{
-    int status = -1;
-
-    LOG_MESSAGE2(Logger::CORE, command, &quot;RubyInterpreter::execute&quot; );
-    rb_eval_string_protect(command.c_str(), &amp;status);
-
-    logRubyErrors(&quot;&quot;, status);
-
-    if( status )
-    {
-        rb_eval_string_protect(&quot;print $!&quot;, &amp;status);
-        return false;
-    }
-
-    return true;
-}
-
-bool RubyInterpreter::executeFile(Ogre::String rubyfile)
-{
-    bool error = execute(&quot;load '&quot; + rubyfile + &quot;'&quot;);
-    if (CoreSubsystem::getSingleton().isInitialized())
-    {
-        execute(&quot;load 'checkerrors.rb'&quot;);
-    }
-    return error;
-}
-
-CeGuiString RubyInterpreter::val2ceguistr(const VALUE rval)
-{
-    return CeGuiString(
-        (CEGUI::utf8*)STR2CSTR(
-            rb_funcall(
-                rval,
-                rb_intern(&quot;to_s&quot;),
-                0)));
-}
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+
+#include &quot;RubyInterpreter.h&quot;
+
+#include &quot;FixRubyHeaders.h&quot;
+
+#include &lt;ruby.h&gt;
+
+#include &quot;FixRubyHeaders.h&quot;
+
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;ConfigurationManager.h&quot;
+#include &quot;ContentModule.h&quot;
+
+using namespace Ogre;
+
+namespace rl {
+
+RubyInterpreter::RubyInterpreter()
+{
+
+}
+
+RubyInterpreter::~RubyInterpreter()
+{
+
+}
+
+void RubyInterpreter::initializeInterpreter()
+{
+    #if defined(NT)
+        static int dummyargc(0);
+        static char** vec;
+        NtInitialize(&amp;dummyargc, &amp;vec);
+    #endif
+
+    //Ruby Initialisieren
+    ruby_init();
+
+    // UTF 8 aktivieren
+    execute( &quot;$KCODE = 'u'&quot; );
+
+    //Skript-Verzeichnisse der  Dateien duerfen auch in /script liegen
+    ModuleMap modules = CoreSubsystem::getSingleton().getAllModules();
+    for (ModuleMap::iterator iter = modules.begin(); iter != modules.end(); iter++)
+    {
+        ContentModule* mod = (*iter).second;
+        //wir suchen die Scripte im modules Verzeichnis relativ zum ModuleRootPath!
+        addSearchPath(mod-&gt;getDirectory() + &quot;/conf&quot;);
+        addSearchPath(mod-&gt;getDirectory() + &quot;/scripts&quot;);
+        addSearchPath(mod-&gt;getDirectory() + &quot;/scripts/maps&quot;);
+    }
+
+    ruby_init_loadpath();
+    //Skriptname
+    ruby_script(&quot;Rastullah&quot;);
+    // Fuer Ruby .dll oder .so dazu laden
+
+    loadProtected(&amp;RubyInterpreter::loadDlls, 0, &quot;Ruby error while loading dlls&quot;);
+}
+
+
+void RubyInterpreter::finalizeInterpreter()
+{
+    ruby_finalize();
+}
+
+void RubyInterpreter::setOutputFunction(staticValueMethod func)
+{
+    //Ersetzt die Standard-Ausgabe von Ruby durch Ausgaben in die Console
+    rb_defout = rb_str_new(&quot;&quot;, 0);
+    // Eigentlich nicht mehr notwendig, aber ohne das gibts nen Absturz?!?!
+    // rb_define_singleton_method(rb_defout, &quot;write&quot;, (VALUE(*)(...))console_write, 1);
+    rb_define_singleton_method(rb_defout, &quot;write&quot;, func, 1);
+}
+
+void RubyInterpreter::addSearchPath(const Ogre::String&amp; path)
+{
+    ruby_incpush(path.c_str());
+}
+
+VALUE RubyInterpreter::loadDlls(VALUE val)
+{
+    Ogre::String lib;
+#if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
+    lib = &quot;libRlScript&quot;;
+#else
+    lib = &quot;RlScript&quot;;
+#endif
+    
+    LOG_DEBUG(&quot;RubyInterpreter&quot;, &quot;Loading library '&quot; + lib + &quot;'&quot;);
+    return rb_require(lib.c_str());
+}
+
+void RubyInterpreter::loadProtected(ProtectedMethod func, VALUE val, const std::string&amp; msg, bool exitOnFail)
+{
+    int error = 0;
+    rb_protect(func, val, &amp;error);
+    logRubyErrors(&quot;Ruby error while initializing&quot;, error);
+}
+
+void RubyInterpreter::logRubyErrors(const std::string&amp; intro, int errorcode)
+{
+    if(errorcode != 0)
+    {
+        VALUE info = rb_inspect(ruby_errinfo);
+        rb_backtrace();
+        if (intro.length() &gt; 0)
+            LOG_ERROR(Logger::CORE, intro);
+        LOG_ERROR(Logger::CORE, STR2CSTR(info));
+    }
+}
+
+bool RubyInterpreter::execute(const Ogre::String&amp; command)
+{
+    int status = -1;
+
+    LOG_MESSAGE2(Logger::CORE, command, &quot;RubyInterpreter::execute&quot; );
+    rb_eval_string_protect(command.c_str(), &amp;status);
+
+    logRubyErrors(&quot;&quot;, status);
+
+    if( status )
+    {
+        rb_eval_string_protect(&quot;print $!&quot;, &amp;status);
+        return false;
+    }
+
+    return true;
+}
+
+bool RubyInterpreter::executeFile(Ogre::String rubyfile)
+{
+    bool error = execute(&quot;load '&quot; + rubyfile + &quot;'&quot;);
+    if (CoreSubsystem::getSingleton().isInitialized())
+    {
+        execute(&quot;load 'checkerrors.rb'&quot;);
+    }
+    return error;
+}
+
+CeGuiString RubyInterpreter::val2ceguistr(const VALUE rval)
+{
+    return CeGuiString(
+        (CEGUI::utf8*)STR2CSTR(
+            rb_funcall(
+                rval,
+                rb_intern(&quot;to_s&quot;),
+                0)));
+}
+
+}

Modified: rl/trunk/engine/core/src/SaveGameFile.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveGameFile.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/core/src/SaveGameFile.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -18,7 +18,6 @@
 
 #include &quot;SaveGameFile.h&quot;
 #include &quot;SaveGameManager.h&quot;
-#include &quot;OgreString.h&quot;
 #include &lt;xercesc/framework/LocalFileFormatTarget.hpp&gt;
 
 #include &lt;ConfigurationManager.h&gt;

Modified: rl/trunk/engine/core/src/SaveGameFileWriter.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveGameFileWriter.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/core/src/SaveGameFileWriter.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -26,7 +26,12 @@
 #include &lt;xercesc/dom/DOMElement.hpp&gt;
 #include &lt;Properties.h&gt;
 
-#include &lt;CEGUIPropertyHelper.h&gt;
+#ifdef __APPLE__
+#   include &lt;CEGUI/CEGUIPropertyHelper.h&gt;
+#else
+#   include &lt;CEGUIPropertyHelper.h&gt;
+#endif
+
 #include &lt;CoreSubsystem.h&gt;
 #include &lt;ContentModule.h&gt;
 #include &lt;TimeSource.h&gt;

Modified: rl/trunk/engine/core/src/nulldriver/NullSound.cpp
===================================================================
--- rl/trunk/engine/core/src/nulldriver/NullSound.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/core/src/nulldriver/NullSound.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -22,7 +22,6 @@
 #include &quot;SoundResource.h&quot;
 
 using namespace Ogre;
-using namespace boost;
 
 Ogre::String rl::NullSound::msMovableType = &quot;NullSound&quot;;
 

Modified: rl/trunk/engine/core/src/nulldriver/NullSoundStitching.cpp
===================================================================
--- rl/trunk/engine/core/src/nulldriver/NullSoundStitching.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/core/src/nulldriver/NullSoundStitching.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -22,7 +22,6 @@
 #include &quot;SoundResource.h&quot;
 
 using namespace Ogre;
-using namespace boost;
 
 Ogre::String rl::NullSoundStitching::msMovableType = &quot;NullSoundStitching&quot;;
 

Modified: rl/trunk/engine/rules/src/SelectionHelper.cpp
===================================================================
--- rl/trunk/engine/rules/src/SelectionHelper.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/rules/src/SelectionHelper.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -22,7 +22,11 @@
 #include &quot;PhysicalObject.h&quot;
 #include &quot;PhysicsManager.h&quot;
 
-#include &lt;OgreNewt.h&gt;
+#ifdef __APPLE__
+#   include &lt;OgreNewt/OgreNewt.h&gt;
+#else
+#   include &lt;OgreNewt.h&gt;
+#endif
 
 using namespace Ogre;
 using namespace OgreNewt;

Modified: rl/trunk/engine/script/include/EntityNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/EntityNodeProcessor.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/script/include/EntityNodeProcessor.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -20,7 +20,12 @@
 
 #include &quot;ScriptPrerequisites.h&quot;
 
-#include &lt;OgreNewt.h&gt;
+#ifdef __APPLE__
+#   include &lt;OgreNewt/OgreNewt.h&gt;
+#else
+#   include &lt;OgreNewt.h&gt;
+#endif
+
 #include &quot;AbstractMapNodeProcessor.h&quot;
 
 namespace rl

Modified: rl/trunk/engine/script/include/ScriptSubsystem.h
===================================================================
--- rl/trunk/engine/script/include/ScriptSubsystem.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/script/include/ScriptSubsystem.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -18,7 +18,6 @@
 #define __ScriptSubsystem_H__
 
 #include &quot;ScriptPrerequisites.h&quot;
-#include &quot;OgreSingleton.h&quot;
 
 namespace rl 
 {

Modified: rl/trunk/engine/script/src/EntityNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -17,7 +17,6 @@
 
 #include &quot;EntityNodeProcessor.h&quot;
 
-#include &lt;OgreNewt.h&gt;
 #include &lt;xercesc/dom/DOM.hpp&gt;
 
 #include &quot;CoreSubsystem.h&quot;

Deleted: rl/trunk/engine/script/src/UnifiedFactory.cpp
===================================================================
--- rl/trunk/engine/script/src/UnifiedFactory.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/script/src/UnifiedFactory.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -1,12 +0,0 @@
-
-#include &quot;stdinc.h&quot;
-
-#include &quot;..\include\UnifiedFactory.h&quot;
-
-UnifiedFactory::UnifiedFactory(void)
-{
-}
-
-UnifiedFactory::~UnifiedFactory(void)
-{
-}

Modified: rl/trunk/engine/ui/include/CombatGui.h
===================================================================
--- rl/trunk/engine/ui/include/CombatGui.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/ui/include/CombatGui.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -20,7 +20,6 @@
 #include &quot;UiPrerequisites.h&quot;
 
 #include &quot;CameraObject.h&quot;
-#include &quot;OgreRectangle.h&quot;
 #include &quot;Combat.h&quot;
 #include &quot;CombatWindow.h&quot;
 #include &quot;GameLoggerWindow.h&quot;

Modified: rl/trunk/engine/ui/include/ControlState.h
===================================================================
--- rl/trunk/engine/ui/include/ControlState.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/ui/include/ControlState.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -1,92 +1,97 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __CharacterController_H__
-#define __CharacterController_H__
-
-#include &quot;UiPrerequisites.h&quot;
-#include &quot;GameTask.h&quot;
-
-#include &lt;OgreNewt.h&gt;
-
-#include &lt;OISMouse.h&gt;
-#include &lt;OISKeyboard.h&gt;
-
-#include &lt;SaveGameManager.h&gt;
-
-namespace rl {
-
-    class Actor;
-	class CommandMapper;
-	class Creature;
-    class Person;
-
-    /**
-     * This class handles character control via user input.
-     */
-    class _RlUiExport ControlState// : public OIS::KeyListener, public OIS::MouseListener
-    {
-	public:
-        static const Ogre::String PROPERTY_CHARACTERID;
-
-        /**
-         *  @throw NullPointerException if camera or character is NULL.
-         *  @throw InvalidArgumentException if character is not placed in the scene.
-         */
-        ControlState(CommandMapper* commandMapper, Actor* camera, Person* character,
-            ControlStateType type);
-		virtual ~ControlState()= 0;
-
-        virtual void pause() = 0;
-        virtual void resume() = 0;
-
-        virtual void run(Ogre::Real elapsedTime) = 0;
-
-        virtual bool mousePressed(const OIS::MouseEvent&amp; evt, OIS::MouseButtonID id, bool handled); // if handled is true, we should not handle the event!
-        virtual bool mouseReleased(const OIS::MouseEvent&amp; evt, OIS::MouseButtonID id, bool handled);
-        virtual bool mouseMoved(const OIS::MouseEvent&amp; evt, bool handled);
-        virtual bool keyPressed(const OIS::KeyEvent&amp; evt, bool handled);
-        virtual bool keyReleased(const OIS::KeyEvent&amp; evt, bool handled);
-
-        const CommandMapper* getCommandMapper() const {return mCommandMapper;}
-        ControlStateType getType() const { return mType;}
-
-        static bool startAction(const CeGuiString&amp; actionName, Creature* character = NULL);
-        
-        bool refetchCharacter();
-	protected:
-
-        /// returns wether cegui currently uses the mouse
-        bool isMouseUsedByCegui() const;
-
-        Person* mCharacter;
-        int mCharacterId;
-
-        Actor* mCameraActor;
-        Actor* mCharacterActor;
-
-        OgreNewt::Body* mCamBody;
-        OgreNewt::Body* mCharBody;
-
-		CommandMapper* mCommandMapper;
-
-        ControlStateType mType;
-
-    private:
-        MessagePump::ScopedConnection mMessageType_GameObjectsLoaded_Handler;
-    };
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __CharacterController_H__
+#define __CharacterController_H__
+
+#include &quot;UiPrerequisites.h&quot;
+
+#ifdef __APPLE__
+#   include &lt;OgreNewt/OgreNewt.h&gt;
+#   include &lt;OIS/OISMouse.h&gt;
+#   include &lt;OIS/OISKeyboard.h&gt;
+#else
+#   include &lt;OgreNewt.h&gt;
+#   include &lt;OISMouse.h&gt;
+#   include &lt;OISKeyboard.h&gt;
+#endif
+
+#include &quot;GameTask.h&quot;
+#include &quot;SaveGameManager.h&quot;
+
+namespace rl {
+
+    class Actor;
+	class CommandMapper;
+	class Creature;
+    class Person;
+
+    /**
+     * This class handles character control via user input.
+     */
+    class _RlUiExport ControlState// : public OIS::KeyListener, public OIS::MouseListener
+    {
+	public:
+        static const Ogre::String PROPERTY_CHARACTERID;
+
+        /**
+         *  @throw NullPointerException if camera or character is NULL.
+         *  @throw InvalidArgumentException if character is not placed in the scene.
+         */
+        ControlState(CommandMapper* commandMapper, Actor* camera, Person* character,
+            ControlStateType type);
+		virtual ~ControlState()= 0;
+
+        virtual void pause() = 0;
+        virtual void resume() = 0;
+
+        virtual void run(Ogre::Real elapsedTime) = 0;
+
+        virtual bool mousePressed(const OIS::MouseEvent&amp; evt, OIS::MouseButtonID id, bool handled); // if handled is true, we should not handle the event!
+        virtual bool mouseReleased(const OIS::MouseEvent&amp; evt, OIS::MouseButtonID id, bool handled);
+        virtual bool mouseMoved(const OIS::MouseEvent&amp; evt, bool handled);
+        virtual bool keyPressed(const OIS::KeyEvent&amp; evt, bool handled);
+        virtual bool keyReleased(const OIS::KeyEvent&amp; evt, bool handled);
+
+        const CommandMapper* getCommandMapper() const {return mCommandMapper;}
+        ControlStateType getType() const { return mType;}
+
+        static bool startAction(const CeGuiString&amp; actionName, Creature* character = NULL);
+        
+        bool refetchCharacter();
+	protected:
+
+        /// returns wether cegui currently uses the mouse
+        bool isMouseUsedByCegui() const;
+
+        Person* mCharacter;
+        int mCharacterId;
+
+        Actor* mCameraActor;
+        Actor* mCharacterActor;
+
+        OgreNewt::Body* mCamBody;
+        OgreNewt::Body* mCharBody;
+
+		CommandMapper* mCommandMapper;
+
+        ControlStateType mType;
+
+    private:
+        MessagePump::ScopedConnection mMessageType_GameObjectsLoaded_Handler;
+    };
+}
+#endif

Modified: rl/trunk/engine/ui/include/FreeflightControlState.h
===================================================================
--- rl/trunk/engine/ui/include/FreeflightControlState.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/ui/include/FreeflightControlState.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -1,78 +1,83 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#ifndef __FreeFlightCharacterController_H__
-#define __FreeFlightCharacterController_H__
-
-#include &quot;UiPrerequisites.h&quot;
-#include &quot;ControlState.h&quot;
-#include &quot;PhysicsController.h&quot;
-#include &quot;PhysicsGenericContactCallback.h&quot;
-#include &lt;OgreNewt.h&gt;
-
-namespace rl {
-
-	/**
-	* This class provides a no-clip free fly controller.
-	*/
-	class _RlUiExport FreeflightControlState : 
-        public ControlState,
-        public PhysicsController,
-        public PhysicsGenericContactCallback
-	{
-	public:
-		/**
-		*  @throw NullPointerException if camera or character is NULL.
-		*  @throw InvalidArgumentException if character is not placed in the scene.
-		*/
-		FreeflightControlState(CommandMapper* cmdMapper, Actor* camera, Person* character);
-		virtual ~FreeflightControlState();
-
-        virtual void pause();
-        virtual void resume();
-
-		virtual void run(Ogre::Real elapsedTime);
-
-        virtual bool keyPressed(const OIS::KeyEvent&amp; evt, bool handled);
-        virtual bool keyReleased(const OIS::KeyEvent&amp; evt, bool handled);
-
-	    void toggleCameraCollision();
-	    void resetCamera();
-
-        /// This is the OgreNewt contact process callback for the combination
-        /// Character &lt;-&gt; Level
-        int userProcess();
-
-        /// Newton force and torque callback
-        void OnApplyForceAndTorque(PhysicalThing* thing);
-
-	private:		
-		int mCurrentMovementState;
-
-		Ogre::Real mMovementSpeed;
-		std::pair&lt;Ogre::Real, Ogre::Real&gt; mSpeedRange;
-		Ogre::Real mSpeedIncrement;
-		Ogre::Real mRotationSpeed;
-        Ogre::Vector3 mDesiredVelocity;
-        Ogre::Radian mYaw;
-        Ogre::Radian mPitch;
-        bool mCollisionsEnabled;
-        Ogre::Real mMouseSensitivity;
-        bool mInvertedMouse;
-        std::pair&lt;Ogre::Degree, Ogre::Degree&gt; mPitchRange;
-	};
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __FreeFlightCharacterController_H__
+#define __FreeFlightCharacterController_H__
+
+#include &quot;UiPrerequisites.h&quot;
+#include &quot;ControlState.h&quot;
+#include &quot;PhysicsController.h&quot;
+#include &quot;PhysicsGenericContactCallback.h&quot;
+
+#ifdef __APPLE__
+#   include &lt;OgreNewt/OgreNewt.h&gt;
+#else
+#   include &lt;OgreNewt.h&gt;
+#endif
+
+namespace rl {
+
+	/**
+	* This class provides a no-clip free fly controller.
+	*/
+	class _RlUiExport FreeflightControlState : 
+        public ControlState,
+        public PhysicsController,
+        public PhysicsGenericContactCallback
+	{
+	public:
+		/**
+		*  @throw NullPointerException if camera or character is NULL.
+		*  @throw InvalidArgumentException if character is not placed in the scene.
+		*/
+		FreeflightControlState(CommandMapper* cmdMapper, Actor* camera, Person* character);
+		virtual ~FreeflightControlState();
+
+        virtual void pause();
+        virtual void resume();
+
+		virtual void run(Ogre::Real elapsedTime);
+
+        virtual bool keyPressed(const OIS::KeyEvent&amp; evt, bool handled);
+        virtual bool keyReleased(const OIS::KeyEvent&amp; evt, bool handled);
+
+	    void toggleCameraCollision();
+	    void resetCamera();
+
+        /// This is the OgreNewt contact process callback for the combination
+        /// Character &lt;-&gt; Level
+        int userProcess();
+
+        /// Newton force and torque callback
+        void OnApplyForceAndTorque(PhysicalThing* thing);
+
+	private:		
+		int mCurrentMovementState;
+
+		Ogre::Real mMovementSpeed;
+		std::pair&lt;Ogre::Real, Ogre::Real&gt; mSpeedRange;
+		Ogre::Real mSpeedIncrement;
+		Ogre::Real mRotationSpeed;
+        Ogre::Vector3 mDesiredVelocity;
+        Ogre::Radian mYaw;
+        Ogre::Radian mPitch;
+        bool mCollisionsEnabled;
+        Ogre::Real mMouseSensitivity;
+        bool mInvertedMouse;
+        std::pair&lt;Ogre::Degree, Ogre::Degree&gt; mPitchRange;
+	};
+}
+#endif

Modified: rl/trunk/engine/ui/include/InputManager.h
===================================================================
--- rl/trunk/engine/ui/include/InputManager.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/ui/include/InputManager.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -19,9 +19,15 @@
 
 #include &quot;UiPrerequisites.h&quot;
 
-#include &lt;OISMouse.h&gt;
-#include &lt;OISKeyboard.h&gt;
-#include &lt;OISJoyStick.h&gt;
+#ifdef __APPLE__
+#   include &lt;OIS/OISMouse.h&gt;
+#   include &lt;OIS/OISKeyboard.h&gt;
+#   include &lt;OIS/OISJoyStick.h&gt;
+#else
+#   include &lt;OISMouse.h&gt;
+#   include &lt;OISKeyboard.h&gt;
+#   include &lt;OISJoyStick.h&gt;
+#endif
 
 #include &lt;stack&gt;
 

Modified: rl/trunk/engine/ui/include/WindowFactory.h
===================================================================
--- rl/trunk/engine/ui/include/WindowFactory.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/ui/include/WindowFactory.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -22,10 +22,7 @@
 #include &quot;FixRubyHeaders.h&quot;        // die Makros sind hier vor Ruby schon definiert
 #include &lt;ruby.h&gt;
 #include &quot;FixRubyHeaders.h&quot;
-#undef min
 
-#include &lt;CEGUIVector.h&gt;
-
 namespace rl {
 
     class Actor;

Modified: rl/trunk/engine/ui/include/WindowManager.h
===================================================================
--- rl/trunk/engine/ui/include/WindowManager.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/ui/include/WindowManager.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -19,12 +19,6 @@
 
 #include &quot;UiPrerequisites.h&quot;
 
-#include &quot;FixRubyHeaders.h&quot;		// die Makros sind hier vor Ruby schon definiert
-#include &lt;ruby.h&gt;
-#include &quot;FixRubyHeaders.h&quot;
-
-#include &lt;CEGUIVector.h&gt;
-
 namespace rl {
 
 	class AbstractWindow;

Modified: rl/trunk/engine/ui/src/CombatWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatWindow.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/ui/src/CombatWindow.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -37,7 +37,7 @@
     {
 		int width = 0, height = 0;
 		Window* w = CEGUI::WindowManager::getSingleton().loadWindowLayout(&quot;buttons/attack.xml&quot;);
-		Size size = w-&gt;getPixelSize();
+        CEGUI::Size size = w-&gt;getPixelSize();
 		height = std::max((int) size.d_height, height);
 		width += (int) size.d_width + mButtonPadding;
 		CEGUI::WindowManager::getSingleton().destroyWindow(w);

Modified: rl/trunk/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogControlState.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/ui/src/DialogControlState.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -46,7 +46,11 @@
 #include &quot;WindowManager.h&quot;
 #include &quot;World.h&quot;
 
-#include &lt;OgreNewt.h&gt;
+#ifdef __APPLE__
+#   include &lt;OgreNewt/OgreNewt.h&gt;
+#else
+#   include &lt;OgreNewt.h&gt;
+#endif
 
 using namespace Ogre;
 

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -1,652 +1,656 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;InputManager.h&quot;
-
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
-#include &lt;OISInputManager.h&gt;
-
-#include &quot;Exception.h&quot;
-
-#include &quot;XmlProcessor.h&quot;
-
-#include &quot;AbstractWindow.h&quot;
-#include &quot;Action.h&quot;
-#include &quot;ActionManager.h&quot;
-#include &quot;Actor.h&quot;
-#include &quot;ActorManager.h&quot;
-#include &quot;AiMessages.h&quot;
-#include &quot;ControlState.h&quot;
-#include &quot;CombatControlState.h&quot;
-#include &quot;CombatManager.h&quot;
-#include &quot;CommandMapper.h&quot;
-#include &quot;ConfigurationManager.h&quot;
-#include &quot;Console.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;CutsceneControlState.h&quot;
-#include &quot;DebugWindow.h&quot;
-#include &quot;DialogControlState.h&quot;
-#include &quot;FreeflightControlState.h&quot;
-#include &quot;GameLoop.h&quot;
-#include &quot;GameObject.h&quot;
-#include &quot;Job.h&quot;
-#include &quot;JobScheduler.h&quot;
-#include &quot;MovementControlState.h&quot;
-#include &quot;RubyInterpreter.h&quot;
-#include &quot;UiSubsystem.h&quot;
-#include &quot;WindowFactory.h&quot;
-#include &quot;WindowManager.h&quot;
-
-using namespace Ogre;
-using namespace OIS;
-using CEGUI::System;
-using namespace std;
-
-template&lt;&gt; rl::InputManager* Singleton&lt;rl::InputManager&gt;::ms_Singleton = 0;
-
-namespace rl {
-
-    InputManager::InputManager(Ogre::RenderWindow* win) 
-      : GameTask(false),
-        mKeyMapNormal(),
-        mKeyMapShift(),
-        mKeyMapAlt(),
-        mKeyNames(),
-        mCommandMapper(NULL),
-        mInputManager(NULL)
-    {
-        initializeOis(win);
-
-        loadKeyMapping(ConfigurationManager::getSingleton().getKeymap());
-        LOG_MESSAGE2(Logger::UI, &quot;Keymap geladen&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);
-
-        mCommandMapper = new CommandMapper();
-
-        GameLoop::getSingleton().addTask(this, GameLoop::TG_INPUT);
-    }
-
-    InputManager::~InputManager()
-    {
-        clearControlStates();
-
-        GameLoop::getSingleton().removeTask(this);
-        if( mInputManager )
-        {
-            mInputManager-&gt;destroyInputObject( mMouse );
-            mInputManager-&gt;destroyInputObject( mKeyboard );
-            OIS::InputManager::destroyInputSystem(mInputManager);
-            mInputManager = NULL;
-        }
-    }
-
-    void InputManager::initializeOis(RenderWindow* win)
-    {
-        // BEGIN INPUT INITIALIZATION
-        LOG_DEBUG(Logger::UI, &quot;Initializing input manager.&quot;);
-
-        OIS::ParamList pl;
-        size_t windowHnd = 0;
-        LOG_DEBUG(Logger::UI, &quot;Initializing input manager: Render window parameters&quot;);
-        win-&gt;getCustomAttribute(&quot;WINDOW&quot;, &amp;windowHnd);
-
-        #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-            pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL_EXCLUSIVE&quot;)));
-            pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL_FOREGROUND&quot;)));
-        #elif OGRE_PLATFORM == OGRE_PLATFORM_LINUX &amp; defined DEBUG
-            pl.insert(std::make_pair(std::string(&quot;x11_mouse_grab&quot;), std::string(&quot;false&quot;)));
-            pl.insert(std::make_pair(std::string(&quot;x11_keyboard_grab&quot;), std::string(&quot;false&quot;)));
-        #endif
-
-        std::ostringstream windowHndStr;
-        windowHndStr &lt;&lt; windowHnd;
-        pl.insert(std::make_pair(std::string(&quot;WINDOW&quot;), windowHndStr.str()));
-
-        LOG_DEBUG(Logger::UI, &quot;Initializing input manager: Create input manager&quot;);
-        mInputManager = OIS::InputManager::createInputSystem(pl);
-        LOG_DEBUG(Logger::UI, &quot;Initializing input manager: Create Keyboard input.&quot;);
-        mKeyboard = static_cast&lt;OIS::Keyboard*&gt;(mInputManager-&gt;createInputObject(OIS::OISKeyboard, true));
-        mKeyboard-&gt;setTextTranslation(OIS::Keyboard::Unicode);
-        mKeyboard-&gt;setEventCallback(this);
-        LOG_DEBUG(Logger::UI, &quot;Initializing input manager: Create Mouse Input.&quot;);
-        mMouse = static_cast&lt;OIS::Mouse*&gt;(mInputManager-&gt;createInputObject(OIS::OISMouse, true));
-        mMouse-&gt;setEventCallback(this);
-
-        LOG_DEBUG(Logger::UI, &quot;Initializing input manager: Set mouse paremeters.&quot;);
-        unsigned int width, height, depth;
-        int left, top;
-        win-&gt;getMetrics(width, height, depth, left, top);
-        mMouse-&gt;getMouseState().width = width;
-        mMouse-&gt;getMouseState().height = height;
-
-        MessagePump::getSingleton().addMessageHandler&lt;MessageType_DialogStarted&gt;(
-            boost::bind(&amp;InputManager::startDialog, this, _1));
-
-        LOG_DEBUG(Logger::UI, &quot;Done initializing input manager.&quot;);
-    }
-
-    void InputManager::run(Ogre::Real elapsedTime)
-    {
-        mMouse-&gt;capture();
-        mKeyboard-&gt;capture();
-
-		System::getSingleton().injectTimePulse(elapsedTime);
-
-        // delete finished control states
-        for (ControlStateVector::iterator it = mFinishedControlStates.begin();
-            it != mFinishedControlStates.end(); ++it)
-        {
-            delete *it;
-        }
-        mFinishedControlStates.clear();
-
-        if (!mControlStates.empty())
-        {
-            mControlStates.top()-&gt;run(elapsedTime);
-        }
-    }
-
-    bool InputManager::isMouseButtonDown( OIS::MouseButtonID buttonID )
-    {
-        OIS::MouseState ms = mMouse-&gt;getMouseState();
-        return ms.buttonDown( buttonID );
-    }
-
-    bool InputManager::isKeyDown( OIS::KeyCode key )
-    {
-        return mKeyboard-&gt;isKeyDown(key);
-    }
-
-    Ogre::Real InputManager::getMouseRelativeX() const
-    {
-        return (float)mMouse-&gt;getMouseState().X.rel;
-    }
-
-    Ogre::Real InputManager::getMouseRelativeY() const
-    {
-        return (float)mMouse-&gt;getMouseState().Y.rel;
-    }
-
-    Ogre::Real InputManager::getMouseRelativeZ() const
-    {
-        return (float)mMouse-&gt;getMouseState().Z.rel;
-    }
-
-    CeGuiString InputManager::getKeyName(int combinedKeyCode)
-    {
-        int scancode, syskeys;
-        CommandMapper::decodeKey(combinedKeyCode, &amp;scancode, &amp;syskeys);
-        return getKeyName(scancode, syskeys);
-    }
-
-    CeGuiString InputManager::getKeyName(int scancode, int syskeys)
-    {
-        CeGuiString name = mKeyNames.find(scancode)-&gt;second;
-        if (syskeys &amp; ALT_MASK)
-            name = &quot;Alt+&quot;+name;
-        if (syskeys &amp; CTRL_MASK)
-            name = &quot;Ctrl+&quot;+name;
-        if (syskeys &amp; SHIFT_MASK)
-            name = &quot;Shift+&quot;+name;
-        if (syskeys &amp; SUPER_MASK)
-            name = &quot;Super+&quot;+name;
-        return name;
-    }
-
-    int InputManager::getScanCode(const CeGuiString&amp; name)
-    {
-        for(KeyNameMap::iterator it = mKeyNames.begin(); it != mKeyNames.end(); it++)
-        {
-            if ((*it).second == name)
-                return (*it).first;
-        }
-
-        Ogre::String msg = Ogre::String(&quot;Key &quot;)+ name.c_str()+&quot; not found.&quot;;
-        Throw(IllegalArgumentException, msg);
-    }
-
-    int InputManager::getSystemCode(const CeGuiString&amp; name)
-    {
-        if (name == &quot;Alt&quot;)
-        {
-            return ALT_MASK;
-        }
-        else if (name == &quot;Ctrl&quot;)
-        {
-            return CTRL_MASK;
-        }
-        else if (name == &quot;Shift&quot;)
-        {
-            return SHIFT_MASK;
-        }
-        else if (name == &quot;Super&quot;)
-        {
-            return SUPER_MASK;
-        }
-        return 0;
-    }
-
-    int InputManager::getModifierCode() const
-    {
-        int rval = 0;
-
-        if (mKeyboard-&gt;isModifierDown(OIS::Keyboard::Alt)) rval |= ALT_MASK;
-        if (mKeyboard-&gt;isModifierDown(OIS::Keyboard::Ctrl)) rval |= CTRL_MASK;
-        if (mKeyboard-&gt;isModifierDown(OIS::Keyboard::Shift)) rval |= SHIFT_MASK;
-
-        return rval;
-    }
-
-    void InputManager::loadKeyMapping(const Ogre::String&amp; filename)
-    {
-        using namespace XERCES_CPP_NAMESPACE;
-        using XERCES_CPP_NAMESPACE::DOMDocument;
-        using std::make_pair;
-
-        initializeXml();
-
-        DOMDocument* doc = loadDocument(filename);
-        DOMElement* dataDocumentContent = doc-&gt;getDocumentElement();
-
-        DOMNodeList* keymaps
-            = dataDocumentContent-&gt;getElementsByTagName(AutoXMLCh(&quot;Key&quot;).data());
-        for (unsigned int idx = 0; idx &lt; keymaps-&gt;getLength(); idx++)
-        {
-            DOMElement* key = static_cast&lt;DOMElement*&gt;(keymaps-&gt;item(idx));
-            int keycode = getAttributeValueAsInteger(key, &quot;KeyCode&quot;);
-
-            CeGuiString s;
-            s = getAttributeValueAsString(key, &quot;NormalChar&quot;);
-            if (!s.empty())
-            {
-                mKeyMapNormal.insert(make_pair(keycode, s[0]));
-            }
-
-            s = getAttributeValueAsString(key, &quot;AltChar&quot;);
-            if (!s.empty())
-            {
-                mKeyMapAlt.insert(make_pair(keycode, s[0]));
-            }
-
-            s = getAttributeValueAsString(key, &quot;ShiftChar&quot;);
-            if (!s.empty())
-            {
-                mKeyMapShift.insert(make_pair(keycode, s[0]));
-            }
-
-            s = getAttributeValueAsString(key, &quot;KeyDescription&quot;);
-            mKeyNames.insert(make_pair(keycode, s));
-        }
-
-        doc-&gt;release();
-        shutdownXml();
-    }
-
-    const CEGUI::utf8&amp; InputManager::getKeyChar(int scancode, int modifiers) const
-    {
-        static const CEGUI::utf8 NO_CHAR = 0;
-
-        const KeyCharMap* charmap = NULL;
-
-        if (modifiers == 0)
-        {
-            charmap = &mKeyMapNormal;
-        }
-        else if (modifiers == ALT_MASK)
-        {
-            charmap = &mKeyMapAlt;
-        }
-        else if (modifiers == SHIFT_MASK)
-        {
-            charmap = &mKeyMapShift;
-        }
-
-        if (charmap != NULL)
-        {
-            KeyCharMap::const_iterator charIt = charmap-&gt;find(scancode);
-            if (charIt != charmap-&gt;end())
-            {
-                return (*charIt).second;
-            }
-        }
-
-        return NO_CHAR;
-    }
-
-    const Ogre::String&amp; InputManager::getName() const
-    {
-        static Ogre::String NAME = &quot;InputManager&quot;;
-
-        return NAME;
-    }
-
-    void InputManager::linkKeyToRubyCommand(const CeGuiString &amp;keyStr, const CeGuiString &amp;command)
-    {
-        std::ostringstream ss;
-
-        ss &lt;&lt; &quot;InputManager::linkKeyToRubyCommand called: &quot;;
-        int key = getScanCode(keyStr);
-        if( command.length() == 0 ) // delete
-        {
-            KeyCommandMap::iterator it = mKeyRubyCommand.find(key);
-            ss &lt;&lt; &quot;Requesting to delete link from Key '&quot; &lt;&lt; keyStr &lt;&lt; &quot;'... &quot;;
-            if( it != mKeyRubyCommand.end() )
-            {
-                ss &lt;&lt; &quot;Link to command '&quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;' deleted.&quot;;
-                mKeyRubyCommand.erase(it);
-            }
-        }
-        else
-        {
-            KeyCommandMap::iterator it = mKeyRubyCommand.find(key);
-            if( it == mKeyRubyCommand.end() )
-            {
-                ss &lt;&lt; &quot;New linking Key '&quot;;
-                mKeyRubyCommand.insert(make_pair(key, command));
-            }
-            else
-            {
-                ss &lt;&lt; &quot;Setting link from key '&quot;;
-                it-&gt;second = command;
-            }
-            ss &lt;&lt; keyStr &lt;&lt; &quot;' to command '&quot; &lt;&lt; command &lt;&lt; &quot;'.&quot;;
-
-        }
-
-        LOG_MESSAGE(Logger::UI, ss.str());
-    }
-
-    void InputManager::setControlState(ControlStateType controlStateType)
-    {
-        while (!mControlStates.empty())
-        {
-            popControlState();
-        }
-        pushControlState(controlStateType);
-    }
-
-    void InputManager::pushControlState(ControlStateType controlStateType)
-    {
-        Actor* camera = ActorManager::getSingleton().getActor(&quot;DefaultCamera&quot;);
-        Person* character = UiSubsystem::getSingleton().getActiveCharacter();
-
-        ControlState* controller = NULL;
-        switch (controlStateType)
-        {
-        case CST_CUTSCENE:
-            controller = new CutsceneControlState(mCommandMapper, camera);
-            break;
-        case CST_MOVEMENT:
-            controller = new MovementControlState(mCommandMapper, camera, character);
-            break;
-        case CST_FREEFLIGHT:
-            controller = new FreeflightControlState(mCommandMapper, camera, character);
-            break;
-        case CST_DIALOG:
-            controller = new DialogControlState(mCommandMapper, camera, character);
-            break;
-        case CST_COMBAT:
-            {
-                Combat* combat = CombatManager::getSingleton().startCombat();
-                controller = new CombatControlState(mCommandMapper, camera, character, combat);
-            }
-            break;
-        default:
-            Throw(IllegalStateException, &quot;Unknown controller type.&quot;);
-        }
-
-        if (!mControlStates.empty())
-        {
-            mControlStates.top()-&gt;pause();
-        }
-
-        //mKeyboard-&gt;setEventCallback(controller);
-        //mMouse-&gt;setEventCallback(controller);
-
-        mControlStates.push(controller);
-        mControlStates.top()-&gt;resume();
-    }
-
-    void InputManager::popControlState()
-    {
-        ControlState* controller = mControlStates.top();
-        mControlStates.pop();
-        controller-&gt;pause();
-        mFinishedControlStates.push_back(controller);
-
-        if (!mControlStates.empty())
-        {
-            ControlState* newController = mControlStates.top();
-            //mKeyboard-&gt;setEventCallback(newController);
-            //mMouse-&gt;setEventCallback(newController);
-            newController-&gt;resume();
-        }
-        else
-        {
-            //mKeyboard-&gt;setEventCallback(NULL);
-            //mMouse-&gt;setEventCallback(NULL);
-        }
-    }
-
-    void InputManager::clearControlStates()
-    {
-        while (!mControlStates.empty())
-        {
-            popControlState();
-        }
-    }
-
-    ControlState* InputManager::getControlState() const
-    {
-        if (!mControlStates.empty())
-        {
-            return mControlStates.top();
-        }
-        else
-        {
-            return NULL;
-        }
-    }
-
-    bool InputManager::startDialog(Dialog* dialog)
-    {
-        pushControlState(CST_DIALOG);
-        dynamic_cast&lt;DialogControlState*&gt;(mControlStates.top())-&gt;start(dialog);
-        return true;
-    }
-
-    bool InputManager::mousePressed(const OIS::MouseEvent&amp; evt, OIS::MouseButtonID id)
-    {
-        bool retval = false;
-        if( WindowManager::getSingleton().getWindowInputMask() &amp; AbstractWindow::WIT_MOUSE_INPUT )
-        {
-            if( CEGUI::System::getSingleton().injectMouseButtonDown(
-                static_cast&lt;CEGUI::MouseButton&gt;(id)) )
-                retval = true;
-        }
-
-        if( !mControlStates.empty() )
-            if( mControlStates.top()-&gt;mousePressed(evt, id, retval) )
-                retval = true;
-        return true;
-        //return retval;
-    }
-
-    bool InputManager::mouseReleased(const OIS::MouseEvent&amp; evt, OIS::MouseButtonID id)
-    {
-        bool retval = false;
-        if( WindowManager::getSingleton().getWindowInputMask() &amp; AbstractWindow::WIT_MOUSE_INPUT )
-        {
-            if( CEGUI::System::getSingleton().injectMouseButtonUp(
-                static_cast&lt;CEGUI::MouseButton&gt;(id)) )
-                retval = true;
-        }
-
-        if( !mControlStates.empty() )
-            if( mControlStates.top()-&gt;mouseReleased(evt, id, retval) )
-                retval = true;
-        return true;
-        //return retval;
-    }
-
-    bool InputManager::mouseMoved(const OIS::MouseEvent&amp; evt)
-    {
-        bool retval = false;
-        if( WindowManager::getSingleton().getWindowInputMask() &amp; AbstractWindow::WIT_MOUSE_INPUT )
-        {
-            if( CEGUI::System::getSingleton().injectMouseMove(
-                evt.state.X.rel, evt.state.Y.rel ) )
-                retval = true;
-        }
-
-        if( !mControlStates.empty() )
-            if( mControlStates.top()-&gt;mouseMoved(evt, retval) )
-                retval = true;
-        return true;
-        //return retval;
-    }
-
-    // job definition for key repeating
-    // this job is created when a key was pressed and the processing window wants the key to be repeated
-    class KeyRepeatJob : public Job
-    {
-    public:
-        static void createKeyRepeatJob(AbstractWindow* window, OIS::KeyCode key)
-        {
-            // nur neu anlegen, wenns noch nicht existiert!
-            if( mKeyJobMap.find(key) == mKeyJobMap.end() )
-            {
-                KeyRepeatJob *job = new KeyRepeatJob(window, key);
-                JobScheduler::getSingleton().addJob(job, JobScheduler::JP_NORMAL, 0.5);
-            }
-        }
-        bool execute(Ogre::Real t)
-        {
-            bool handled = false;
-            rl::Time time = TimeSourceManager::getSingleton().getTimeSource(TimeSource::REALTIME_CONTINUOUS)-&gt;getClock();
-            if ( WindowManager::getSingleton().getActiveWindow() == mWindow &amp;&amp; // perhaps window was deleted!!
-                InputManager::getSingleton().isKeyDown(OIS::KeyCode(mKey)) )
-            {
-                if ( time - mLastTime &gt; 50*mCount )
-                {
-                    if( CEGUI::System::getSingleton().injectKeyDown(mKey) )
-                        handled = true;
-                    else
-                    {
-                        static const CEGUI::utf8 NO_CHAR = 0;
-                        if( InputManager::getSingleton().getKeyChar(mKey, InputManager::getSingleton().getModifierCode()) != NO_CHAR )
-                        {
-                            if( CEGUI::System::getSingleton().injectChar(InputManager::getSingleton().getKeyChar(mKey, InputManager::getSingleton().getModifierCode())) )
-                                handled = true;
-                        }
-                    }
-                    if( CEGUI::System::getSingleton().injectKeyUp(mKey) )
-                        handled = true;
-
-                    mLastTime = time;
-                }
-
-                return false;
-            }
-
-            mKeyJobMap.erase(mKey);
-            if( mCount &gt; 0 )
-                mCount--;
-            return true;
-        }
-    private:
-        rl::Time mLastTime;
-        AbstractWindow* mWindow;
-        OIS::KeyCode mKey;
-        typedef std::map&lt;OIS::KeyCode, KeyRepeatJob*&gt; KeyJobMap;
-        static KeyJobMap mKeyJobMap;
-        static int mCount;
-
-
-        KeyRepeatJob(AbstractWindow* window, OIS::KeyCode key) :
-          Job(false, true),
-          mWindow(window),
-          mKey(key),
-          mLastTime(0)
-        {
-            mKeyJobMap[key] = this;
-            mCount++;
-        }
-    };
-    KeyRepeatJob::KeyJobMap KeyRepeatJob::mKeyJobMap;
-    int KeyRepeatJob::mCount = 0;
-
-    bool InputManager::keyPressed(const OIS::KeyEvent&amp; evt)
-    {
-        bool retval = false;
-        if( WindowManager::getSingleton().getWindowInputMask() &amp; AbstractWindow::WIT_KEYBOARD_INPUT )
-        {
-            AbstractWindow *activeWin = WindowManager::getSingleton().getActiveWindow();
-            if( activeWin != NULL )
-            {
-                if( activeWin-&gt;wantsKeyToRepeat(evt.key) )
-                {
-                    KeyRepeatJob::createKeyRepeatJob(activeWin, evt.key);
-                }
-            }
-
-            if( CEGUI::System::getSingleton().injectKeyDown( evt.key ) )
-                retval = true;
-            else
-            {
-                static const CEGUI::utf8 NO_CHAR = 0;
-                if( getKeyChar(evt.key, getModifierCode()) != NO_CHAR )
-                {
-                    if( CEGUI::System::getSingleton().injectChar(getKeyChar(evt.key, getModifierCode())) )
-                        retval = true;
-                }
-            }
-        }
-
-        if( !mControlStates.empty() )
-            if( mControlStates.top()-&gt;keyPressed(evt, retval) )
-                retval = true;
-
-        if( !retval )
-        {
-            KeyCommandMap::iterator it = mKeyRubyCommand.find(evt.key);
-            if( it != mKeyRubyCommand.end() )
-                CoreSubsystem::getSingleton().getRubyInterpreter()-&gt;execute(it-&gt;second.c_str());
-                
-        }
-
-        return true;
-        //return retval;
-    }
-
-    bool InputManager::keyReleased(const OIS::KeyEvent&amp; evt)
-    {
-        bool retval = false;
-        if( WindowManager::getSingleton().getWindowInputMask() &amp; AbstractWindow::WIT_KEYBOARD_INPUT )
-        {
-            if( CEGUI::System::getSingleton().injectKeyUp( evt.key ) )
-                retval = true;
-        }
-
-        if( !mControlStates.empty() )
-            if( mControlStates.top()-&gt;keyReleased(evt, retval) )
-                retval = true;
-        return true;
-        //return false;
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;InputManager.h&quot;
+
+#include &lt;xercesc/dom/DOM.hpp&gt;
+
+#ifdef __APPLE__
+#   include &lt;OIS/OISInputManager.h&gt;
+#else
+#   include &lt;OISInputManager.h&gt;
+#endif
+
+#include &quot;Exception.h&quot;
+
+#include &quot;XmlProcessor.h&quot;
+
+#include &quot;AbstractWindow.h&quot;
+#include &quot;Action.h&quot;
+#include &quot;ActionManager.h&quot;
+#include &quot;Actor.h&quot;
+#include &quot;ActorManager.h&quot;
+#include &quot;AiMessages.h&quot;
+#include &quot;ControlState.h&quot;
+#include &quot;CombatControlState.h&quot;
+#include &quot;CombatManager.h&quot;
+#include &quot;CommandMapper.h&quot;
+#include &quot;ConfigurationManager.h&quot;
+#include &quot;Console.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;CutsceneControlState.h&quot;
+#include &quot;DebugWindow.h&quot;
+#include &quot;DialogControlState.h&quot;
+#include &quot;FreeflightControlState.h&quot;
+#include &quot;GameLoop.h&quot;
+#include &quot;GameObject.h&quot;
+#include &quot;Job.h&quot;
+#include &quot;JobScheduler.h&quot;
+#include &quot;MovementControlState.h&quot;
+#include &quot;RubyInterpreter.h&quot;
+#include &quot;UiSubsystem.h&quot;
+#include &quot;WindowFactory.h&quot;
+#include &quot;WindowManager.h&quot;
+
+using namespace Ogre;
+using namespace OIS;
+using CEGUI::System;
+using namespace std;
+
+template&lt;&gt; rl::InputManager* Singleton&lt;rl::InputManager&gt;::ms_Singleton = 0;
+
+namespace rl {
+
+    InputManager::InputManager(Ogre::RenderWindow* win) 
+      : GameTask(false),
+        mKeyMapNormal(),
+        mKeyMapShift(),
+        mKeyMapAlt(),
+        mKeyNames(),
+        mCommandMapper(NULL),
+        mInputManager(NULL)
+    {
+        initializeOis(win);
+
+        loadKeyMapping(ConfigurationManager::getSingleton().getKeymap());
+        LOG_MESSAGE2(Logger::UI, &quot;Keymap geladen&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);
+
+        mCommandMapper = new CommandMapper();
+
+        GameLoop::getSingleton().addTask(this, GameLoop::TG_INPUT);
+    }
+
+    InputManager::~InputManager()
+    {
+        clearControlStates();
+
+        GameLoop::getSingleton().removeTask(this);
+        if( mInputManager )
+        {
+            mInputManager-&gt;destroyInputObject( mMouse );
+            mInputManager-&gt;destroyInputObject( mKeyboard );
+            OIS::InputManager::destroyInputSystem(mInputManager);
+            mInputManager = NULL;
+        }
+    }
+
+    void InputManager::initializeOis(RenderWindow* win)
+    {
+        // BEGIN INPUT INITIALIZATION
+        LOG_DEBUG(Logger::UI, &quot;Initializing input manager.&quot;);
+
+        OIS::ParamList pl;
+        size_t windowHnd = 0;
+        LOG_DEBUG(Logger::UI, &quot;Initializing input manager: Render window parameters&quot;);
+        win-&gt;getCustomAttribute(&quot;WINDOW&quot;, &amp;windowHnd);
+
+        #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+            pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL_EXCLUSIVE&quot;)));
+            pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL_FOREGROUND&quot;)));
+        #elif OGRE_PLATFORM == OGRE_PLATFORM_LINUX &amp; defined DEBUG
+            pl.insert(std::make_pair(std::string(&quot;x11_mouse_grab&quot;), std::string(&quot;false&quot;)));
+            pl.insert(std::make_pair(std::string(&quot;x11_keyboard_grab&quot;), std::string(&quot;false&quot;)));
+        #endif
+
+        std::ostringstream windowHndStr;
+        windowHndStr &lt;&lt; windowHnd;
+        pl.insert(std::make_pair(std::string(&quot;WINDOW&quot;), windowHndStr.str()));
+
+        LOG_DEBUG(Logger::UI, &quot;Initializing input manager: Create input manager&quot;);
+        mInputManager = OIS::InputManager::createInputSystem(pl);
+        LOG_DEBUG(Logger::UI, &quot;Initializing input manager: Create Keyboard input.&quot;);
+        mKeyboard = static_cast&lt;OIS::Keyboard*&gt;(mInputManager-&gt;createInputObject(OIS::OISKeyboard, true));
+        mKeyboard-&gt;setTextTranslation(OIS::Keyboard::Unicode);
+        mKeyboard-&gt;setEventCallback(this);
+        LOG_DEBUG(Logger::UI, &quot;Initializing input manager: Create Mouse Input.&quot;);
+        mMouse = static_cast&lt;OIS::Mouse*&gt;(mInputManager-&gt;createInputObject(OIS::OISMouse, true));
+        mMouse-&gt;setEventCallback(this);
+
+        LOG_DEBUG(Logger::UI, &quot;Initializing input manager: Set mouse paremeters.&quot;);
+        unsigned int width, height, depth;
+        int left, top;
+        win-&gt;getMetrics(width, height, depth, left, top);
+        mMouse-&gt;getMouseState().width = width;
+        mMouse-&gt;getMouseState().height = height;
+
+        MessagePump::getSingleton().addMessageHandler&lt;MessageType_DialogStarted&gt;(
+            boost::bind(&amp;InputManager::startDialog, this, _1));
+
+        LOG_DEBUG(Logger::UI, &quot;Done initializing input manager.&quot;);
+    }
+
+    void InputManager::run(Ogre::Real elapsedTime)
+    {
+        mMouse-&gt;capture();
+        mKeyboard-&gt;capture();
+
+		System::getSingleton().injectTimePulse(elapsedTime);
+
+        // delete finished control states
+        for (ControlStateVector::iterator it = mFinishedControlStates.begin();
+            it != mFinishedControlStates.end(); ++it)
+        {
+            delete *it;
+        }
+        mFinishedControlStates.clear();
+
+        if (!mControlStates.empty())
+        {
+            mControlStates.top()-&gt;run(elapsedTime);
+        }
+    }
+
+    bool InputManager::isMouseButtonDown( OIS::MouseButtonID buttonID )
+    {
+        OIS::MouseState ms = mMouse-&gt;getMouseState();
+        return ms.buttonDown( buttonID );
+    }
+
+    bool InputManager::isKeyDown( OIS::KeyCode key )
+    {
+        return mKeyboard-&gt;isKeyDown(key);
+    }
+
+    Ogre::Real InputManager::getMouseRelativeX() const
+    {
+        return (float)mMouse-&gt;getMouseState().X.rel;
+    }
+
+    Ogre::Real InputManager::getMouseRelativeY() const
+    {
+        return (float)mMouse-&gt;getMouseState().Y.rel;
+    }
+
+    Ogre::Real InputManager::getMouseRelativeZ() const
+    {
+        return (float)mMouse-&gt;getMouseState().Z.rel;
+    }
+
+    CeGuiString InputManager::getKeyName(int combinedKeyCode)
+    {
+        int scancode, syskeys;
+        CommandMapper::decodeKey(combinedKeyCode, &amp;scancode, &amp;syskeys);
+        return getKeyName(scancode, syskeys);
+    }
+
+    CeGuiString InputManager::getKeyName(int scancode, int syskeys)
+    {
+        CeGuiString name = mKeyNames.find(scancode)-&gt;second;
+        if (syskeys &amp; ALT_MASK)
+            name = &quot;Alt+&quot;+name;
+        if (syskeys &amp; CTRL_MASK)
+            name = &quot;Ctrl+&quot;+name;
+        if (syskeys &amp; SHIFT_MASK)
+            name = &quot;Shift+&quot;+name;
+        if (syskeys &amp; SUPER_MASK)
+            name = &quot;Super+&quot;+name;
+        return name;
+    }
+
+    int InputManager::getScanCode(const CeGuiString&amp; name)
+    {
+        for(KeyNameMap::iterator it = mKeyNames.begin(); it != mKeyNames.end(); it++)
+        {
+            if ((*it).second == name)
+                return (*it).first;
+        }
+
+        Ogre::String msg = Ogre::String(&quot;Key &quot;)+ name.c_str()+&quot; not found.&quot;;
+        Throw(IllegalArgumentException, msg);
+    }
+
+    int InputManager::getSystemCode(const CeGuiString&amp; name)
+    {
+        if (name == &quot;Alt&quot;)
+        {
+            return ALT_MASK;
+        }
+        else if (name == &quot;Ctrl&quot;)
+        {
+            return CTRL_MASK;
+        }
+        else if (name == &quot;Shift&quot;)
+        {
+            return SHIFT_MASK;
+        }
+        else if (name == &quot;Super&quot;)
+        {
+            return SUPER_MASK;
+        }
+        return 0;
+    }
+
+    int InputManager::getModifierCode() const
+    {
+        int rval = 0;
+
+        if (mKeyboard-&gt;isModifierDown(OIS::Keyboard::Alt)) rval |= ALT_MASK;
+        if (mKeyboard-&gt;isModifierDown(OIS::Keyboard::Ctrl)) rval |= CTRL_MASK;
+        if (mKeyboard-&gt;isModifierDown(OIS::Keyboard::Shift)) rval |= SHIFT_MASK;
+
+        return rval;
+    }
+
+    void InputManager::loadKeyMapping(const Ogre::String&amp; filename)
+    {
+        using namespace XERCES_CPP_NAMESPACE;
+        using XERCES_CPP_NAMESPACE::DOMDocument;
+        using std::make_pair;
+
+        initializeXml();
+
+        DOMDocument* doc = loadDocument(filename);
+        DOMElement* dataDocumentContent = doc-&gt;getDocumentElement();
+
+        DOMNodeList* keymaps
+            = dataDocumentContent-&gt;getElementsByTagName(AutoXMLCh(&quot;Key&quot;).data());
+        for (unsigned int idx = 0; idx &lt; keymaps-&gt;getLength(); idx++)
+        {
+            DOMElement* key = static_cast&lt;DOMElement*&gt;(keymaps-&gt;item(idx));
+            int keycode = getAttributeValueAsInteger(key, &quot;KeyCode&quot;);
+
+            CeGuiString s;
+            s = getAttributeValueAsString(key, &quot;NormalChar&quot;);
+            if (!s.empty())
+            {
+                mKeyMapNormal.insert(make_pair(keycode, s[0]));
+            }
+
+            s = getAttributeValueAsString(key, &quot;AltChar&quot;);
+            if (!s.empty())
+            {
+                mKeyMapAlt.insert(make_pair(keycode, s[0]));
+            }
+
+            s = getAttributeValueAsString(key, &quot;ShiftChar&quot;);
+            if (!s.empty())
+            {
+                mKeyMapShift.insert(make_pair(keycode, s[0]));
+            }
+
+            s = getAttributeValueAsString(key, &quot;KeyDescription&quot;);
+            mKeyNames.insert(make_pair(keycode, s));
+        }
+
+        doc-&gt;release();
+        shutdownXml();
+    }
+
+    const CEGUI::utf8&amp; InputManager::getKeyChar(int scancode, int modifiers) const
+    {
+        static const CEGUI::utf8 NO_CHAR = 0;
+
+        const KeyCharMap* charmap = NULL;
+
+        if (modifiers == 0)
+        {
+            charmap = &mKeyMapNormal;
+        }
+        else if (modifiers == ALT_MASK)
+        {
+            charmap = &mKeyMapAlt;
+        }
+        else if (modifiers == SHIFT_MASK)
+        {
+            charmap = &mKeyMapShift;
+        }
+
+        if (charmap != NULL)
+        {
+            KeyCharMap::const_iterator charIt = charmap-&gt;find(scancode);
+            if (charIt != charmap-&gt;end())
+            {
+                return (*charIt).second;
+            }
+        }
+
+        return NO_CHAR;
+    }
+
+    const Ogre::String&amp; InputManager::getName() const
+    {
+        static Ogre::String NAME = &quot;InputManager&quot;;
+
+        return NAME;
+    }
+
+    void InputManager::linkKeyToRubyCommand(const CeGuiString &amp;keyStr, const CeGuiString &amp;command)
+    {
+        std::ostringstream ss;
+
+        ss &lt;&lt; &quot;InputManager::linkKeyToRubyCommand called: &quot;;
+        int key = getScanCode(keyStr);
+        if( command.length() == 0 ) // delete
+        {
+            KeyCommandMap::iterator it = mKeyRubyCommand.find(key);
+            ss &lt;&lt; &quot;Requesting to delete link from Key '&quot; &lt;&lt; keyStr &lt;&lt; &quot;'... &quot;;
+            if( it != mKeyRubyCommand.end() )
+            {
+                ss &lt;&lt; &quot;Link to command '&quot; &lt;&lt; it-&gt;second &lt;&lt; &quot;' deleted.&quot;;
+                mKeyRubyCommand.erase(it);
+            }
+        }
+        else
+        {
+            KeyCommandMap::iterator it = mKeyRubyCommand.find(key);
+            if( it == mKeyRubyCommand.end() )
+            {
+                ss &lt;&lt; &quot;New linking Key '&quot;;
+                mKeyRubyCommand.insert(make_pair(key, command));
+            }
+            else
+            {
+                ss &lt;&lt; &quot;Setting link from key '&quot;;
+                it-&gt;second = command;
+            }
+            ss &lt;&lt; keyStr &lt;&lt; &quot;' to command '&quot; &lt;&lt; command &lt;&lt; &quot;'.&quot;;
+
+        }
+
+        LOG_MESSAGE(Logger::UI, ss.str());
+    }
+
+    void InputManager::setControlState(ControlStateType controlStateType)
+    {
+        while (!mControlStates.empty())
+        {
+            popControlState();
+        }
+        pushControlState(controlStateType);
+    }
+
+    void InputManager::pushControlState(ControlStateType controlStateType)
+    {
+        Actor* camera = ActorManager::getSingleton().getActor(&quot;DefaultCamera&quot;);
+        Person* character = UiSubsystem::getSingleton().getActiveCharacter();
+
+        ControlState* controller = NULL;
+        switch (controlStateType)
+        {
+        case CST_CUTSCENE:
+            controller = new CutsceneControlState(mCommandMapper, camera);
+            break;
+        case CST_MOVEMENT:
+            controller = new MovementControlState(mCommandMapper, camera, character);
+            break;
+        case CST_FREEFLIGHT:
+            controller = new FreeflightControlState(mCommandMapper, camera, character);
+            break;
+        case CST_DIALOG:
+            controller = new DialogControlState(mCommandMapper, camera, character);
+            break;
+        case CST_COMBAT:
+            {
+                Combat* combat = CombatManager::getSingleton().startCombat();
+                controller = new CombatControlState(mCommandMapper, camera, character, combat);
+            }
+            break;
+        default:
+            Throw(IllegalStateException, &quot;Unknown controller type.&quot;);
+        }
+
+        if (!mControlStates.empty())
+        {
+            mControlStates.top()-&gt;pause();
+        }
+
+        //mKeyboard-&gt;setEventCallback(controller);
+        //mMouse-&gt;setEventCallback(controller);
+
+        mControlStates.push(controller);
+        mControlStates.top()-&gt;resume();
+    }
+
+    void InputManager::popControlState()
+    {
+        ControlState* controller = mControlStates.top();
+        mControlStates.pop();
+        controller-&gt;pause();
+        mFinishedControlStates.push_back(controller);
+
+        if (!mControlStates.empty())
+        {
+            ControlState* newController = mControlStates.top();
+            //mKeyboard-&gt;setEventCallback(newController);
+            //mMouse-&gt;setEventCallback(newController);
+            newController-&gt;resume();
+        }
+        else
+        {
+            //mKeyboard-&gt;setEventCallback(NULL);
+            //mMouse-&gt;setEventCallback(NULL);
+        }
+    }
+
+    void InputManager::clearControlStates()
+    {
+        while (!mControlStates.empty())
+        {
+            popControlState();
+        }
+    }
+
+    ControlState* InputManager::getControlState() const
+    {
+        if (!mControlStates.empty())
+        {
+            return mControlStates.top();
+        }
+        else
+        {
+            return NULL;
+        }
+    }
+
+    bool InputManager::startDialog(Dialog* dialog)
+    {
+        pushControlState(CST_DIALOG);
+        dynamic_cast&lt;DialogControlState*&gt;(mControlStates.top())-&gt;start(dialog);
+        return true;
+    }
+
+    bool InputManager::mousePressed(const OIS::MouseEvent&amp; evt, OIS::MouseButtonID id)
+    {
+        bool retval = false;
+        if( WindowManager::getSingleton().getWindowInputMask() &amp; AbstractWindow::WIT_MOUSE_INPUT )
+        {
+            if( CEGUI::System::getSingleton().injectMouseButtonDown(
+                static_cast&lt;CEGUI::MouseButton&gt;(id)) )
+                retval = true;
+        }
+
+        if( !mControlStates.empty() )
+            if( mControlStates.top()-&gt;mousePressed(evt, id, retval) )
+                retval = true;
+        return true;
+        //return retval;
+    }
+
+    bool InputManager::mouseReleased(const OIS::MouseEvent&amp; evt, OIS::MouseButtonID id)
+    {
+        bool retval = false;
+        if( WindowManager::getSingleton().getWindowInputMask() &amp; AbstractWindow::WIT_MOUSE_INPUT )
+        {
+            if( CEGUI::System::getSingleton().injectMouseButtonUp(
+                static_cast&lt;CEGUI::MouseButton&gt;(id)) )
+                retval = true;
+        }
+
+        if( !mControlStates.empty() )
+            if( mControlStates.top()-&gt;mouseReleased(evt, id, retval) )
+                retval = true;
+        return true;
+        //return retval;
+    }
+
+    bool InputManager::mouseMoved(const OIS::MouseEvent&amp; evt)
+    {
+        bool retval = false;
+        if( WindowManager::getSingleton().getWindowInputMask() &amp; AbstractWindow::WIT_MOUSE_INPUT )
+        {
+            if( CEGUI::System::getSingleton().injectMouseMove(
+                evt.state.X.rel, evt.state.Y.rel ) )
+                retval = true;
+        }
+
+        if( !mControlStates.empty() )
+            if( mControlStates.top()-&gt;mouseMoved(evt, retval) )
+                retval = true;
+        return true;
+        //return retval;
+    }
+
+    // job definition for key repeating
+    // this job is created when a key was pressed and the processing window wants the key to be repeated
+    class KeyRepeatJob : public Job
+    {
+    public:
+        static void createKeyRepeatJob(AbstractWindow* window, OIS::KeyCode key)
+        {
+            // nur neu anlegen, wenns noch nicht existiert!
+            if( mKeyJobMap.find(key) == mKeyJobMap.end() )
+            {
+                KeyRepeatJob *job = new KeyRepeatJob(window, key);
+                JobScheduler::getSingleton().addJob(job, JobScheduler::JP_NORMAL, 0.5);
+            }
+        }
+        bool execute(Ogre::Real t)
+        {
+            bool handled = false;
+            rl::Time time = TimeSourceManager::getSingleton().getTimeSource(TimeSource::REALTIME_CONTINUOUS)-&gt;getClock();
+            if ( WindowManager::getSingleton().getActiveWindow() == mWindow &amp;&amp; // perhaps window was deleted!!
+                InputManager::getSingleton().isKeyDown(OIS::KeyCode(mKey)) )
+            {
+                if ( time - mLastTime &gt; 50*mCount )
+                {
+                    if( CEGUI::System::getSingleton().injectKeyDown(mKey) )
+                        handled = true;
+                    else
+                    {
+                        static const CEGUI::utf8 NO_CHAR = 0;
+                        if( InputManager::getSingleton().getKeyChar(mKey, InputManager::getSingleton().getModifierCode()) != NO_CHAR )
+                        {
+                            if( CEGUI::System::getSingleton().injectChar(InputManager::getSingleton().getKeyChar(mKey, InputManager::getSingleton().getModifierCode())) )
+                                handled = true;
+                        }
+                    }
+                    if( CEGUI::System::getSingleton().injectKeyUp(mKey) )
+                        handled = true;
+
+                    mLastTime = time;
+                }
+
+                return false;
+            }
+
+            mKeyJobMap.erase(mKey);
+            if( mCount &gt; 0 )
+                mCount--;
+            return true;
+        }
+    private:
+        rl::Time mLastTime;
+        AbstractWindow* mWindow;
+        OIS::KeyCode mKey;
+        typedef std::map&lt;OIS::KeyCode, KeyRepeatJob*&gt; KeyJobMap;
+        static KeyJobMap mKeyJobMap;
+        static int mCount;
+
+
+        KeyRepeatJob(AbstractWindow* window, OIS::KeyCode key) :
+          Job(false, true),
+          mWindow(window),
+          mKey(key),
+          mLastTime(0)
+        {
+            mKeyJobMap[key] = this;
+            mCount++;
+        }
+    };
+    KeyRepeatJob::KeyJobMap KeyRepeatJob::mKeyJobMap;
+    int KeyRepeatJob::mCount = 0;
+
+    bool InputManager::keyPressed(const OIS::KeyEvent&amp; evt)
+    {
+        bool retval = false;
+        if( WindowManager::getSingleton().getWindowInputMask() &amp; AbstractWindow::WIT_KEYBOARD_INPUT )
+        {
+            AbstractWindow *activeWin = WindowManager::getSingleton().getActiveWindow();
+            if( activeWin != NULL )
+            {
+                if( activeWin-&gt;wantsKeyToRepeat(evt.key) )
+                {
+                    KeyRepeatJob::createKeyRepeatJob(activeWin, evt.key);
+                }
+            }
+
+            if( CEGUI::System::getSingleton().injectKeyDown( evt.key ) )
+                retval = true;
+            else
+            {
+                static const CEGUI::utf8 NO_CHAR = 0;
+                if( getKeyChar(evt.key, getModifierCode()) != NO_CHAR )
+                {
+                    if( CEGUI::System::getSingleton().injectChar(getKeyChar(evt.key, getModifierCode())) )
+                        retval = true;
+                }
+            }
+        }
+
+        if( !mControlStates.empty() )
+            if( mControlStates.top()-&gt;keyPressed(evt, retval) )
+                retval = true;
+
+        if( !retval )
+        {
+            KeyCommandMap::iterator it = mKeyRubyCommand.find(evt.key);
+            if( it != mKeyRubyCommand.end() )
+                CoreSubsystem::getSingleton().getRubyInterpreter()-&gt;execute(it-&gt;second.c_str());
+                
+        }
+
+        return true;
+        //return retval;
+    }
+
+    bool InputManager::keyReleased(const OIS::KeyEvent&amp; evt)
+    {
+        bool retval = false;
+        if( WindowManager::getSingleton().getWindowInputMask() &amp; AbstractWindow::WIT_KEYBOARD_INPUT )
+        {
+            if( CEGUI::System::getSingleton().injectKeyUp( evt.key ) )
+                retval = true;
+        }
+
+        if( !mControlStates.empty() )
+            if( mControlStates.top()-&gt;keyReleased(evt, retval) )
+                retval = true;
+        return true;
+        //return false;
+    }
+
+}

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -1,691 +1,691 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;InventoryWindow.h&quot;
-
-#include &lt;boost/bind.hpp&gt;
-#include &lt;CEGUIImageset.h&gt;
-#include &lt;CEGUIImagesetManager.h&gt;
-#include &lt;CEGUIWindowManager.h&gt;
-#include &lt;elements/CEGUIFrameWindow.h&gt;
-
-#include &quot;Actor.h&quot;
-#include &quot;ActorManager.h&quot;
-#include &quot;CameraObject.h&quot;
-#include &quot;Container.h&quot;
-#include &quot;ContainerContentWindow.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;ControlState.h&quot;
-#include &quot;CommandMapper.h&quot;
-#include &quot;InputManager.h&quot;
-#include &quot;Inventory.h&quot;
-#include &quot;Item.h&quot;
-#include &quot;ItemDescriptionDragContainer.h&quot;
-#include &quot;ItemIconDragContainer.h&quot;
-#include &quot;Selector.h&quot;
-#include &quot;WindowFactory.h&quot;
-
-using namespace CEGUI;
-using namespace Ogre;
-using namespace std;
-
-namespace rl {
-
-	const Ogre::String InventoryWindow::SLOTNAME = &quot;slotname&quot;;
-
-    InventoryWindow::InventoryWindow(const Ogre::String&amp; inventoryWindow, Inventory* inventory)
-        : AbstractWindow(inventoryWindow, AbstractWindow::WIT_MOUSE_INPUT | AbstractWindow::WIT_KEYBOARD_INPUT), mShowAllWorldItems(false)
-    {
-        mInventory = inventory;
-
-        //mSquareSize = ...;
-		mWorldBackground = getWindow(&quot;InventoryWindow/Background&quot;);
-        CEGUI::Window* invWnd = getWindow(&quot;InventoryWindow&quot;);
-        invWnd-&gt;subscribeEvent(FrameWindow::EventCloseClicked,
-			boost::bind(&amp;InventoryWindow::destroyWindow, this));
-        mWorldBackground-&gt;moveToBack();
-        mWorldBackground-&gt;setZOrderingEnabled(false);
-        invWnd-&gt;setMaxSize(invWnd-&gt;getSize());
-        invWnd-&gt;setMinSize(invWnd-&gt;getSize());
-
-        createSlotWindows(inventory);
-        initInventoryWindow(inventory);
-
-		mMouseSelector = new RaySelector(QUERYFLAG_ITEM, true);
-    }
-
-    InventoryWindow::~InventoryWindow()
-    {
-		mWorldBackground-&gt;removeAllEvents();
-		delete mMouseSelector;
-        WindowFactory::getSingleton().notifyInventoryWindowDestroyed();
-    }
-
-    void InventoryWindow::createSlotWindows(Inventory* inventory)
-    {
-        std::map&lt;CeGuiString, Window*&gt; slotsInWindowDefinition;
-
-        Window* slotWindowParent = getWindow(&quot;InventoryWindow/Slots&quot;);
-
-        for (size_t idx = 0; idx &lt; slotWindowParent-&gt;getChildCount(); idx++)
-        {
-            Window* curWnd = slotWindowParent-&gt;getChildAtIdx(idx);
-            CeGuiString curWndName = curWnd-&gt;getName();
-            if (curWndName.find(&quot;InventoryWindow/Slots/&quot;) != CeGuiString::npos)
-            {
-                CeGuiString slotname =
-                    curWndName.substr(
-                        curWndName.find(&quot;InventoryWindow/Slots/&quot;) + 22);
-                slotsInWindowDefinition[slotname] = curWnd;
-                curWnd-&gt;setTooltipText(slotname);
-            }
-            else
-            {
-                LOG_DEBUG(Logger::UI, &quot;Not a slot: &quot;+curWndName);
-            }
-        }
-
-        Inventory::SlotMap slots = inventory-&gt;getAllSlots();
-        for (Inventory::SlotMap::const_iterator it = slots.begin(); it != slots.end(); it++)
-        {
-            CeGuiString slotName = (*it).first;
-            std::map&lt;CeGuiString, Window*&gt;::iterator
-                slotInWindowFile = slotsInWindowDefinition.find(slotName);
-
-            if (slotInWindowFile != slotsInWindowDefinition.end())
-            {
-                mSlotWindows[slotName] = (*slotInWindowFile).second;
-				mSlotWindows[slotName]-&gt;setUserString(SLOTNAME, slotName);
-                slotsInWindowDefinition.erase(slotInWindowFile);
-                LOG_DEBUG(Logger::UI, &quot;Found slot &quot;+slotName);
-            }
-            else
-            {
-                LOG_DEBUG(Logger::UI, &quot;Not found slot &quot;+slotName);
-                ///@todo Create tab
-                // mSlotWindows.push_back();
-            }
-        }
-
-		///@todo deactivate all remaining elements of slotsInWindowDefinition
-    }
-
-    void InventoryWindow::initInventoryWindow(Inventory* inventory)
-    {
-        for (std::map&lt;CeGuiString, Window*&gt;::iterator it = mSlotWindows.begin(); it != mSlotWindows.end(); it++)
-        {
-            CeGuiString slotName = (*it).first;
-            Item* item = inventory-&gt;getItem(slotName);
-			Window* slotWindow = (*it).second;
-			slotWindow-&gt;setDragDropTarget(true);
-			slotWindow-&gt;subscribeEvent(Window::EventDragDropItemDropped,
-				boost::bind(&amp;InventoryWindow::handleItemDroppedOnSlot, this, _1));
-            slotWindow-&gt;subscribeEvent(Window::EventDragDropItemEnters,
-                boost::bind(&amp;InventoryWindow::handleItemEntersSlot, this, _1));
-            slotWindow-&gt;subscribeEvent(Window::EventDragDropItemLeaves,
-                boost::bind(&amp;InventoryWindow::handleItemLeavesSlot, this, _1));
-
-            if (item != NULL)
-            {
-                LOG_MESSAGE(Logger::UI, slotName + &quot; - &quot; + item-&gt;getDescription());
-				Window* itemWindow = createItemDragContainer(item, false, slotName);
-				if (itemWindow != NULL)
-				{
-					slotWindow-&gt;addChildWindow(itemWindow);
-				}
-            }
-        }
-
-		mWorldBackground-&gt;setDragDropTarget(true);
-		mWorldBackground-&gt;subscribeEvent(Window::EventDragDropItemDropped,
-			boost::bind(&amp;InventoryWindow::handleItemDroppedOnWorld, this, _1));
-		mWorldBackground-&gt;subscribeEvent(Window::EventMouseMove,
-			boost::bind(&amp;InventoryWindow::handleMouseMovedInWorld, this, _1));
-
-        // be sure we get all key-events:
-        Window* invWnd = getWindow(&quot;InventoryWindow&quot;);
-        //invWnd-&gt;setDistributesCapturedInputs(false);
-		invWnd-&gt;subscribeEvent(Window::EventKeyDown,
-			boost::bind(&amp;InventoryWindow::handleKeys, this, _1, true));
-		invWnd-&gt;subscribeEvent(Window::EventKeyUp,
-			boost::bind(&amp;InventoryWindow::handleKeys, this, _1, false));
-        //mWorldBackground-&gt;setDistributesCapturedInputs(false);
-		mWorldBackground-&gt;subscribeEvent(Window::EventKeyDown,
-			boost::bind(&amp;InventoryWindow::handleKeys, this, _1, true));
-		mWorldBackground-&gt;subscribeEvent(Window::EventKeyUp,
-			boost::bind(&amp;InventoryWindow::handleKeys, this, _1, false));
-        invWnd-&gt;activate();
-    }
-
-    ItemDragContainer* InventoryWindow::getItemDragContainer(const Item* item, bool description)
-    {
-		CeGuiString dragContainerName = getDragContainerNameFromItem(item, description);
-		ItemDragContainer* itemhandler = NULL;
-
-		DndContainerMap::iterator iter = mWorldDragContainers.find(dragContainerName);
-        if( iter != mWorldDragContainers.end() )
-        {
-            return iter-&gt;second;
-        }
-		iter = mSlotDragContainers.find(dragContainerName);
-        if( iter != mSlotDragContainers.end() )
-        {
-            return iter-&gt;second;
-        }
-
-        return NULL;
-    }
-
-    CeGuiString InventoryWindow::getDragContainerNameFromItem(const Item* item, bool description)
-    {
-		CeGuiString dragContainerName =
-			mWindow-&gt;getName() +  &quot;/item/&quot;
-			+ Ogre::StringConverter::toString(item-&gt;getId())+&quot;_DragContainer&quot;+
-			(description?&quot;_D&quot;:&quot;_I&quot;);
-        return dragContainerName;
-    }
-
-	ItemDragContainer* InventoryWindow::createItemDragContainer(
-		Item* item, bool showdescription, const CeGuiString&amp; slotName)
-	{
-        CeGuiString dragContainerName = getDragContainerNameFromItem(item, showdescription);
-		ItemDragContainer* itemhandler = NULL;
-
-		DndContainerMap::iterator itW = mWorldDragContainers.find(dragContainerName);
-		DndContainerMap::iterator itS = mSlotDragContainers.find(dragContainerName);
-		if (itW != mWorldDragContainers.end() || itS != mSlotDragContainers.end())
-		{
-			return NULL;
-		}
-		else
-		{
-			if (showdescription)
-				itemhandler = new ItemDescriptionDragContainer(item, dragContainerName);
-			else
-            {
-				itemhandler = new ItemIconDragContainer(item, dragContainerName);
-                itemhandler-&gt;setTooltipText(item-&gt;getName());
-            }
-
-			if (slotName != &quot;&quot;)
-			{
-				itemhandler-&gt;setItemParent(mInventory, slotName);
-				mSlotDragContainers[dragContainerName] = itemhandler;
-			}
-			else
-			{
-				mWorldDragContainers[dragContainerName] = itemhandler;
-			}
-
-            itemhandler-&gt;setDestroyListener(this);
-
-  			itemhandler-&gt;setRiseOnClickEnabled(true);
-			itemhandler-&gt;setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
-            itemhandler-&gt;subscribeEvent(DragContainer::EventDragStarted,
-                boost::bind(&amp;rl::InventoryWindow::handleItemDragStarted, this, item, showdescription));
-            itemhandler-&gt;subscribeEvent(DragContainer::EventDragEnded,
-                boost::bind(&amp;InventoryWindow::handleItemDragEnded, this, item, showdescription));
-		}
-
-		return itemhandler;
-	}
-
-    bool InventoryWindow::handleItemDragEnded(const Item* item, bool showdescription)
-    {
-        showPossibleSlots(NULL);
-
-        if( showdescription &amp;&amp; !mShowAllWorldItems) // this is a world item
-        {
-            // fade out and destroy
-            ItemDragContainer* cont = getItemDragContainer(item, showdescription);
-            if( cont )
-                cont-&gt;fadeOutAndHide(2.0f);
-        }
-
-        return true;
-    }
-
-    bool InventoryWindow::handleItemDragStarted(const Item* item, bool showdescription)
-    {
-        showPossibleSlots(item);
-
-        if( showdescription &amp;&amp; !mShowAllWorldItems) // this is a world item
-        {
-            // stop fade out and destroy
-            ItemDragContainer* cont = getItemDragContainer(item, showdescription);
-            if( cont )
-                cont-&gt;stopFadeOut();
-        }
-
-        return true;
-    }
-
-	bool InventoryWindow::handleItemDroppedOnSlot(const EventArgs&amp; evt)
-	{
-		const DragDropEventArgs&amp; evtArgs = static_cast&lt;const DragDropEventArgs&amp;&gt;(evt);
-
-		if (evtArgs.dragDropItem-&gt;testClassName(&quot;ItemDragContainer&quot;))
-		{
-			ItemDragContainer* dragcont = static_cast&lt;ItemDragContainer*&gt;(
-				evtArgs.dragDropItem);
-			Item* item = dragcont-&gt;getItem();
-			CeGuiString targetSlot = evtArgs.window-&gt;getUserString(SLOTNAME);
-
-			if (mInventory-&gt;canHold(item, targetSlot))
-			{
-				if (dragcont-&gt;getItemParentContainer() != NULL)
-				{
-					dragcont-&gt;getParent()-&gt;removeChildWindow(dragcont);
-				}
-				else if (dragcont-&gt;getItemParentSlot() != &quot;&quot;)
-				{
-					dragcont-&gt;getParent()-&gt;removeChildWindow(dragcont);
-				}
-
-				ItemDragContainer* newCont = createItemDragContainer(item, false, targetSlot);
-
-				if (newCont)
-				{
-                    dragcont-&gt;destroyWindow();
-				}
-				else
-				{
-					newCont = dragcont;
-				}
-
-                CEGUI::Window* slotWindow = mSlotWindows[targetSlot];
-
-				mInventory-&gt;hold(item, targetSlot);
-
-				slotWindow-&gt;addChildWindow(newCont);
-				newCont-&gt;setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
-				newCont-&gt;setItemParent(mInventory, targetSlot);
-
-                showPossibleSlots(NULL);
-				return true;
-			}
-			else
-			{
-                showPossibleSlots(NULL);
-				return false;
-			}
-		}
-
-        handleItemLeavesSlot(evt);
-		return false;
-	}
-
-    bool InventoryWindow::handleItemEntersSlot(const CEGUI::EventArgs&amp; evt)
-    {
-		const DragDropEventArgs&amp; evtArgs = static_cast&lt;const DragDropEventArgs&amp;&gt;(evt);
-
-		if (evtArgs.dragDropItem-&gt;testClassName(&quot;ItemDragContainer&quot;))
-		{
-			ItemDragContainer* dragcont = static_cast&lt;ItemDragContainer*&gt;(
-				evtArgs.dragDropItem);
-			Item* item = dragcont-&gt;getItem();
-			CeGuiString targetSlot = evtArgs.window-&gt;getUserString(SLOTNAME);
-            CEGUI::Window* slotWindow = mSlotWindows[targetSlot];
-
-
-            if( mInventory-&gt;canReady(item, targetSlot) )
-            {
-                //slotWindow-&gt;setProperty(&quot;ContainerColour&quot;, 
-                //    slotWindow-&gt;getProperty(&quot;ContainerColour_DropReady&quot;));
-            }
-            else if( mInventory-&gt;canHold(item, targetSlot) )
-            {
-                //slotWindow-&gt;setProperty(&quot;ContainerColour&quot;, 
-                //    slotWindow-&gt;getProperty(&quot;ContainerColour_DropPossible&quot;));
-            }
-            else
-            {
-                slotWindow-&gt;setProperty(&quot;ContainerColour&quot;, 
-                    slotWindow-&gt;getProperty(&quot;ContainerColour_DropImpossible&quot;));
-            }
-
-
-            return true;
-        }
-        return false;
-    }
-
-    bool InventoryWindow::handleItemLeavesSlot(const CEGUI::EventArgs&amp; evt)
-    {
-		const DragDropEventArgs&amp; evtArgs = static_cast&lt;const DragDropEventArgs&amp;&gt;(evt);
-
-		if (evtArgs.dragDropItem-&gt;testClassName(&quot;ItemDragContainer&quot;))
-		{
-			ItemDragContainer* dragcont = static_cast&lt;ItemDragContainer*&gt;(
-				evtArgs.dragDropItem);
-			Item* item = dragcont-&gt;getItem();
-			CeGuiString targetSlot = evtArgs.window-&gt;getUserString(SLOTNAME);
-            CEGUI::Window* slotWindow = mSlotWindows[targetSlot];
-
-
-            if( mInventory-&gt;canReady(item, targetSlot) )
-            {
-                //slotWindow-&gt;setProperty(&quot;ContainerColour&quot;, 
-                //    slotWindow-&gt;getProperty(&quot;ContainerColour_Standard&quot;));
-            }
-            else if( mInventory-&gt;canHold(item, targetSlot) )
-            {
-                //slotWindow-&gt;setProperty(&quot;ContainerColour&quot;, 
-                //    slotWindow-&gt;getProperty(&quot;ContainerColour_Standard&quot;));
-            }
-            else
-            {
-                slotWindow-&gt;setProperty(&quot;ContainerColour&quot;, 
-                    slotWindow-&gt;getProperty(&quot;ContainerColour_Standard&quot;));
-            }
-
-
-            return true;
-        }
-        return false;
-    }
-
-	bool InventoryWindow::handleItemDroppedOnWorld(const EventArgs&amp; evt)
-	{
-		const DragDropEventArgs&amp; evtArgs = static_cast&lt;const DragDropEventArgs&amp;&gt;(evt);
-		if (evtArgs.dragDropItem-&gt;testClassName(&quot;ItemDragContainer&quot;))
-		{
-			ItemDragContainer* dragcont = static_cast&lt;ItemDragContainer*&gt;(
-				evtArgs.dragDropItem);
-			Item* item = dragcont-&gt;getItem();
-			Ogre::Vector3 targetPosWindow(
-				dragcont-&gt;getPixelRect().d_left / getRoot()-&gt;getPixelSize().d_width,
-				dragcont-&gt;getPixelRect().d_top / getRoot()-&gt;getPixelSize().d_height,
-				-1);
-
-
-            dragcont-&gt;destroyWindow();
-
-			Ogre::Vector3 targetPosWorldSpace =
-				mInventory-&gt;getOwner()-&gt;getPosition()
-				+ mInventory-&gt;getOwner()-&gt;getOrientation()
-				* targetPosWindow;
-            item-&gt;removeOldState();
-			item-&gt;setState(GOS_IN_SCENE);
-			item-&gt;setPosition(targetPosWorldSpace);
-
-			LOG_DEBUG(Logger::UI,
-				&quot;Dropped item &quot;+item-&gt;getName()
-				+&quot; to position &quot;+Ogre::StringConverter::toString(targetPosWorldSpace));
-
-			return true;
-
-		}
-		return false;
-	}
-
-	bool InventoryWindow::handleMouseMovedInWorld(const EventArgs&amp; evt)
-	{
-        if( mShowAllWorldItems )
-            return true;
-
-		const MouseEventArgs&amp; mevt = static_cast&lt;const MouseEventArgs&amp;&gt;(evt);
-
-		Actor* cameraActor = ActorManager::getSingleton().getActor(&quot;DefaultCamera&quot;);
-		CameraObject* camera = static_cast&lt;CameraObject*&gt;(cameraActor-&gt;getControlledObject());
-
-		CEGUI::Point mousePos = mevt.position;
-		mousePos.d_x /= getRoot()-&gt;getPixelSize().d_width;
-		mousePos.d_y /= getRoot()-&gt;getPixelSize().d_height;
-		Ogre::Ray camToWorld = camera-&gt;getCameraToViewportRay(
-			mousePos.d_x, mousePos.d_y);
-		Ogre::Vector3 rayStart = camera-&gt;getCamera()-&gt;getWorldPosition();
-		Ogre::Vector3 rayDir = camera-&gt;getDirectionFromScreenPosition(
-			mousePos.d_x, mousePos.d_y);
-
-		mMouseSelector-&gt;setRay(camToWorld.getOrigin(), camToWorld.getPoint(3));
-		mMouseSelector-&gt;updateSelection();
-		Selector::GameObjectVector objs = mMouseSelector-&gt;getAllSelectedObjects();
-
-		///@todo select, ...
-		if (!objs.empty())
-		{
-			LOG_MESSAGE(Logger::UI,
-				&quot;Selected &quot;+Ogre::StringConverter::toString(objs.size())+&quot; items.&quot;);
-			for (Selector::GameObjectVector::const_iterator it = objs.begin();
-				it != objs.end(); ++it)
-			{
-                if( !mInventory-&gt;getOwner()-&gt;canReachItem(static_cast&lt;Item*&gt;(*it)) )
-                    continue;
-
-                ItemDragContainer* cont = getItemDragContainer(static_cast&lt;Item*&gt;(*it), true);
-
-                if( !cont )
-                {
-					cont = createItemDragContainer(static_cast&lt;Item*&gt;(*it), true);
-                    mWorldBackground-&gt;addChildWindow(cont);
-                }
-				if (cont)
-				{
-					Ogre::Rectangle aabb = getCeGuiRectFromWorldAABB(camera,
-							(*it)-&gt;getActor()-&gt;_getSceneNode()-&gt;_getWorldAABB());
-					UVector2 posCont = UVector2(
-							UDim((aabb.left+aabb.right)/2.0, 0),
-							UDim((aabb.top+aabb.bottom)/2.0, 0));
-					posCont -= cont-&gt;getSize() / UVector2(UDim(2, 2), UDim(2, 2));
-					cont-&gt;setPosition(posCont);
-					cont-&gt;setVisible(true);
-
-                    cont-&gt;fadeOutAndHide(2.0f);
-				}
-			}
-		}
-
-		return true;
-	}
-
-	bool InventoryWindow::handleKeys(const CEGUI::EventArgs &amp;evt, bool down)
-	{
-		const KeyEventArgs&amp; kevt = static_cast&lt;const KeyEventArgs&amp;&gt;(evt);
-
-        ///@todo das hier ueberpruefen!
-        CeGuiString action = 
-            InputManager::getSingleton().getControlState()
-                -&gt;getCommandMapper()-&gt;getControlStateAction(
-                kevt.scancode,
-                InputManager::getSingleton().getControlState()-&gt;getType()
-                );
-        if( action == &quot;&quot; )
-        {
-            action = InputManager::getSingleton().getControlState()
-                        -&gt;getCommandMapper()-&gt;getGlobalAction(kevt.scancode);
-        }
-        if( action == &quot;inventoryshowworldobjects&quot; )  // we only handle this action here
-		{
-			if (down)
-			{
-                mShowAllWorldItems = true;
-
-				Actor* cameraActor = ActorManager::getSingleton().getActor(&quot;DefaultCamera&quot;);
-				CameraObject* camera = static_cast&lt;CameraObject*&gt;(cameraActor-&gt;getControlledObject());
-
-				HalfSphereSelector sel(QUERYFLAG_ITEM);
-				sel.setPosition(cameraActor-&gt;getWorldPosition());
-				sel.setOrientation(cameraActor-&gt;getWorldOrientation());
-				sel.setRadius(10.0);
-
-				sel.updateSelection();
-				Selector::GameObjectVector v = sel.getAllSelectedObjects();
-				for (Selector::GameObjectVector::iterator
-					it = v.begin(); it != v.end(); ++it)
-				{
-                    if( !mInventory-&gt;getOwner()-&gt;canReachItem(static_cast&lt;Item*&gt;(*it)) )
-                        continue;
-
-                    ItemDragContainer* cont = getItemDragContainer(static_cast&lt;Item*&gt;(*it), true);
-
-                    if( !cont )
-                    {
-					    cont = createItemDragContainer(static_cast&lt;Item*&gt;(*it), true);
-                        mWorldBackground-&gt;addChildWindow(cont);
-                    }
-				    if (cont)
-				    {
-					    Ogre::Rectangle aabb = getCeGuiRectFromWorldAABB(camera,
-							    (*it)-&gt;getActor()-&gt;_getSceneNode()-&gt;_getWorldAABB());
-					    UVector2 posCont = UVector2(
-							    UDim((aabb.left+aabb.right)/2.0, 0),
-							    UDim((aabb.top+aabb.bottom)/2.0, 0));
-					    posCont -= cont-&gt;getSize() / UVector2(UDim(2, 2), UDim(2, 2));
-					    cont-&gt;setPosition(posCont);
-					    cont-&gt;setVisible(true);
-                        cont-&gt;moveToFront();
-                        cont-&gt;stopFadeOut();
-				    }
-				}
-			}
-			else
-			{
-                mShowAllWorldItems = false;
-                DndContainerMap::iterator iter = mWorldDragContainers.begin();
-                for( ; iter != mWorldDragContainers.end(); iter++ )
-                {
-                    iter-&gt;second-&gt;fadeOutAndHide(0.0f);
-                }
-			}
-
-			return true;
-		}
-
-		return false;
-	}
-
-	Ogre::Rectangle InventoryWindow::getCeGuiRectFromWorldAABB(
-		CameraObject* camera,
-        const AxisAlignedBox&amp; aabb) const
-    {
-        // Initialise each to the value of the opposite side, so that min/max work smoothly.
-        Real left = 1.0f, bottom = 1.0f, right = -1.0f, top = -1.0f;
-
-        // Determine screen pos of all corners and widen the rect if needed
-		const Ogre::Vector3* corners = aabb.getAllCorners();
-        for (size_t i = 0; i &lt; 8; ++i)
-        {
-			Ogre::Vector3 screenSpacePos = camera-&gt;getPointOnCeGuiScreen(corners[i]);
-            if (screenSpacePos.z &gt; 0) continue; // Behind camera
-
-            left   = std::min(left,   screenSpacePos.x);
-            right  = std::max(right,  screenSpacePos.x);
-            bottom = std::min(bottom, screenSpacePos.y);
-            top    = std::max(top,    screenSpacePos.y);
-        }
-
-        Ogre::Rectangle rval = {left,top, right, bottom};
-        return rval;
-    }
-
-    void InventoryWindow::showContainerContent(Container* container)
-    {
-        ContainerMap::iterator iter = mOpenContainerMap.find(container);
-        if( iter == mOpenContainerMap.end() )
-        {
-            ContainerContentWindow* wnd = new ContainerContentWindow(container, this);
-            mOpenContainerMap.insert(make_pair(container, wnd));
-            mWorldBackground-&gt;addChildWindow(wnd-&gt;getWindow());
-            wnd-&gt;setVisible(true);
-        }
-        else
-        {
-            iter-&gt;second-&gt;setVisible(true);
-            iter-&gt;second-&gt;getWindow()-&gt;moveToFront();
-        }
-    }
-
-    void InventoryWindow::setVisible(bool visible, bool destroyAfterHide)
-    {
-        if( !visible &amp;&amp; destroyAfterHide )
-        {
-            ContainerMap::iterator iter = mOpenContainerMap.begin();
-            for( ; iter != mOpenContainerMap.end(); iter++)
-            {
-                if( iter-&gt;second != NULL )
-                {
-                    iter-&gt;second-&gt;setVisible(false, true, true); // if we call notifyInventoryWindow here, the iterator isn't valid any more!
-                }
-            }
-            mOpenContainerMap.erase(mOpenContainerMap.begin(), mOpenContainerMap.end());
-        }
-
-        AbstractWindow::setVisible(visible, destroyAfterHide);
-    }
-
-    void InventoryWindow::notifyContainerContentWindowClosed(Container* container)
-    {
-        ContainerMap::iterator iter = mOpenContainerMap.find(container);
-        if( iter != mOpenContainerMap.end() )
-        {
-            mOpenContainerMap.erase(iter);
-        }
-    }
-
-    bool InventoryWindow::showPossibleSlots(const Item* item)
-    {
-        SlotWindowMap::iterator iter = mSlotWindows.begin();
-
-        for( ; iter != mSlotWindows.end(); iter++ )
-        {
-            if( item )
-            {
-                if( mInventory-&gt;canReady(item, iter-&gt;first) )
-                {
-                    iter-&gt;second-&gt;setProperty(&quot;ContainerColour&quot;, 
-                        iter-&gt;second-&gt;getProperty(&quot;ContainerColour_DropReady&quot;));
-                    continue;
-                }
-                else if( mInventory-&gt;canHold(item, iter-&gt;first) )
-                {
-                    iter-&gt;second-&gt;setProperty(&quot;ContainerColour&quot;, 
-                        iter-&gt;second-&gt;getProperty(&quot;ContainerColour_DropPossible&quot;));
-                    continue;
-                }
-            }
-            iter-&gt;second-&gt;setProperty(&quot;ContainerColour&quot;, 
-                iter-&gt;second-&gt;getProperty(&quot;ContainerColour_Standard&quot;));
-        }
-        return true;
-    }
-
-    void InventoryWindow::notifyItemDragContainerDestroyed(ItemDragContainer* cont)
-    {
-        DndContainerMap::iterator iter = mWorldDragContainers.begin();
-        for( ; iter != mWorldDragContainers.end(); iter++)
-        {
-            if( iter-&gt;second == cont )
-            {
-                mWorldDragContainers.erase(iter);
-                return;
-            }
-        }
-
-        iter = mSlotDragContainers.begin();
-        for( ; iter != mSlotDragContainers.end(); iter++)
-        {
-            if( iter-&gt;second == cont )
-            {
-                mSlotDragContainers.erase(iter);
-                return;
-            }
-        }
-
-        LOG_ERROR(Logger::UI, &quot;Could not find ItemDragContainer in InventoryWindow::notifyItemDragContainerDestroyed!&quot;);
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;InventoryWindow.h&quot;
+
+#include &lt;boost/bind.hpp&gt;
+#include &lt;CEGUIImageset.h&gt;
+#include &lt;CEGUIImagesetManager.h&gt;
+#include &lt;CEGUIWindowManager.h&gt;
+#include &lt;elements/CEGUIFrameWindow.h&gt;
+
+#include &quot;Actor.h&quot;
+#include &quot;ActorManager.h&quot;
+#include &quot;CameraObject.h&quot;
+#include &quot;Container.h&quot;
+#include &quot;ContainerContentWindow.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;ControlState.h&quot;
+#include &quot;CommandMapper.h&quot;
+#include &quot;InputManager.h&quot;
+#include &quot;Inventory.h&quot;
+#include &quot;Item.h&quot;
+#include &quot;ItemDescriptionDragContainer.h&quot;
+#include &quot;ItemIconDragContainer.h&quot;
+#include &quot;Selector.h&quot;
+#include &quot;WindowFactory.h&quot;
+
+using namespace CEGUI;
+using namespace Ogre;
+using namespace std;
+
+namespace rl {
+
+	const Ogre::String InventoryWindow::SLOTNAME = &quot;slotname&quot;;
+
+    InventoryWindow::InventoryWindow(const Ogre::String&amp; inventoryWindow, Inventory* inventory)
+        : AbstractWindow(inventoryWindow, AbstractWindow::WIT_MOUSE_INPUT | AbstractWindow::WIT_KEYBOARD_INPUT), mShowAllWorldItems(false)
+    {
+        mInventory = inventory;
+
+        //mSquareSize = ...;
+		mWorldBackground = getWindow(&quot;InventoryWindow/Background&quot;);
+        CEGUI::Window* invWnd = getWindow(&quot;InventoryWindow&quot;);
+        invWnd-&gt;subscribeEvent(FrameWindow::EventCloseClicked,
+			boost::bind(&amp;InventoryWindow::destroyWindow, this));
+        mWorldBackground-&gt;moveToBack();
+        mWorldBackground-&gt;setZOrderingEnabled(false);
+        invWnd-&gt;setMaxSize(invWnd-&gt;getSize());
+        invWnd-&gt;setMinSize(invWnd-&gt;getSize());
+
+        createSlotWindows(inventory);
+        initInventoryWindow(inventory);
+
+		mMouseSelector = new RaySelector(QUERYFLAG_ITEM, true);
+    }
+
+    InventoryWindow::~InventoryWindow()
+    {
+		mWorldBackground-&gt;removeAllEvents();
+		delete mMouseSelector;
+        WindowFactory::getSingleton().notifyInventoryWindowDestroyed();
+    }
+
+    void InventoryWindow::createSlotWindows(Inventory* inventory)
+    {
+        std::map&lt;CeGuiString, Window*&gt; slotsInWindowDefinition;
+
+        Window* slotWindowParent = getWindow(&quot;InventoryWindow/Slots&quot;);
+
+        for (size_t idx = 0; idx &lt; slotWindowParent-&gt;getChildCount(); idx++)
+        {
+            Window* curWnd = slotWindowParent-&gt;getChildAtIdx(idx);
+            CeGuiString curWndName = curWnd-&gt;getName();
+            if (curWndName.find(&quot;InventoryWindow/Slots/&quot;) != CeGuiString::npos)
+            {
+                CeGuiString slotname =
+                    curWndName.substr(
+                        curWndName.find(&quot;InventoryWindow/Slots/&quot;) + 22);
+                slotsInWindowDefinition[slotname] = curWnd;
+                curWnd-&gt;setTooltipText(slotname);
+            }
+            else
+            {
+                LOG_DEBUG(Logger::UI, &quot;Not a slot: &quot;+curWndName);
+            }
+        }
+
+        Inventory::SlotMap slots = inventory-&gt;getAllSlots();
+        for (Inventory::SlotMap::const_iterator it = slots.begin(); it != slots.end(); it++)
+        {
+            CeGuiString slotName = (*it).first;
+            std::map&lt;CeGuiString, Window*&gt;::iterator
+                slotInWindowFile = slotsInWindowDefinition.find(slotName);
+
+            if (slotInWindowFile != slotsInWindowDefinition.end())
+            {
+                mSlotWindows[slotName] = (*slotInWindowFile).second;
+				mSlotWindows[slotName]-&gt;setUserString(SLOTNAME, slotName);
+                slotsInWindowDefinition.erase(slotInWindowFile);
+                LOG_DEBUG(Logger::UI, &quot;Found slot &quot;+slotName);
+            }
+            else
+            {
+                LOG_DEBUG(Logger::UI, &quot;Not found slot &quot;+slotName);
+                ///@todo Create tab
+                // mSlotWindows.push_back();
+            }
+        }
+
+		///@todo deactivate all remaining elements of slotsInWindowDefinition
+    }
+
+    void InventoryWindow::initInventoryWindow(Inventory* inventory)
+    {
+        for (std::map&lt;CeGuiString, Window*&gt;::iterator it = mSlotWindows.begin(); it != mSlotWindows.end(); it++)
+        {
+            CeGuiString slotName = (*it).first;
+            Item* item = inventory-&gt;getItem(slotName);
+			Window* slotWindow = (*it).second;
+			//slotWindow-&gt;setDragDropTarget(true);
+			slotWindow-&gt;subscribeEvent(Window::EventDragDropItemDropped,
+				boost::bind(&amp;InventoryWindow::handleItemDroppedOnSlot, this, _1));
+            slotWindow-&gt;subscribeEvent(Window::EventDragDropItemEnters,
+                boost::bind(&amp;InventoryWindow::handleItemEntersSlot, this, _1));
+            slotWindow-&gt;subscribeEvent(Window::EventDragDropItemLeaves,
+                boost::bind(&amp;InventoryWindow::handleItemLeavesSlot, this, _1));
+
+            if (item != NULL)
+            {
+                LOG_MESSAGE(Logger::UI, slotName + &quot; - &quot; + item-&gt;getDescription());
+				Window* itemWindow = createItemDragContainer(item, false, slotName);
+				if (itemWindow != NULL)
+				{
+					slotWindow-&gt;addChildWindow(itemWindow);
+				}
+            }
+        }
+
+		//mWorldBackground-&gt;setDragDropTarget(true);
+		mWorldBackground-&gt;subscribeEvent(Window::EventDragDropItemDropped,
+			boost::bind(&amp;InventoryWindow::handleItemDroppedOnWorld, this, _1));
+		mWorldBackground-&gt;subscribeEvent(Window::EventMouseMove,
+			boost::bind(&amp;InventoryWindow::handleMouseMovedInWorld, this, _1));
+
+        // be sure we get all key-events:
+        Window* invWnd = getWindow(&quot;InventoryWindow&quot;);
+        //invWnd-&gt;setDistributesCapturedInputs(false);
+		invWnd-&gt;subscribeEvent(Window::EventKeyDown,
+			boost::bind(&amp;InventoryWindow::handleKeys, this, _1, true));
+		invWnd-&gt;subscribeEvent(Window::EventKeyUp,
+			boost::bind(&amp;InventoryWindow::handleKeys, this, _1, false));
+        //mWorldBackground-&gt;setDistributesCapturedInputs(false);
+		mWorldBackground-&gt;subscribeEvent(Window::EventKeyDown,
+			boost::bind(&amp;InventoryWindow::handleKeys, this, _1, true));
+		mWorldBackground-&gt;subscribeEvent(Window::EventKeyUp,
+			boost::bind(&amp;InventoryWindow::handleKeys, this, _1, false));
+        invWnd-&gt;activate();
+    }
+
+    ItemDragContainer* InventoryWindow::getItemDragContainer(const Item* item, bool description)
+    {
+		CeGuiString dragContainerName = getDragContainerNameFromItem(item, description);
+		ItemDragContainer* itemhandler = NULL;
+
+		DndContainerMap::iterator iter = mWorldDragContainers.find(dragContainerName);
+        if( iter != mWorldDragContainers.end() )
+        {
+            return iter-&gt;second;
+        }
+		iter = mSlotDragContainers.find(dragContainerName);
+        if( iter != mSlotDragContainers.end() )
+        {
+            return iter-&gt;second;
+        }
+
+        return NULL;
+    }
+
+    CeGuiString InventoryWindow::getDragContainerNameFromItem(const Item* item, bool description)
+    {
+		CeGuiString dragContainerName =
+			mWindow-&gt;getName() +  &quot;/item/&quot;
+			+ Ogre::StringConverter::toString(item-&gt;getId())+&quot;_DragContainer&quot;+
+			(description?&quot;_D&quot;:&quot;_I&quot;);
+        return dragContainerName;
+    }
+
+	ItemDragContainer* InventoryWindow::createItemDragContainer(
+		Item* item, bool showdescription, const CeGuiString&amp; slotName)
+	{
+        CeGuiString dragContainerName = getDragContainerNameFromItem(item, showdescription);
+		ItemDragContainer* itemhandler = NULL;
+
+		DndContainerMap::iterator itW = mWorldDragContainers.find(dragContainerName);
+		DndContainerMap::iterator itS = mSlotDragContainers.find(dragContainerName);
+		if (itW != mWorldDragContainers.end() || itS != mSlotDragContainers.end())
+		{
+			return NULL;
+		}
+		else
+		{
+			if (showdescription)
+				itemhandler = new ItemDescriptionDragContainer(item, dragContainerName);
+			else
+            {
+				itemhandler = new ItemIconDragContainer(item, dragContainerName);
+                itemhandler-&gt;setTooltipText(item-&gt;getName());
+            }
+
+			if (slotName != &quot;&quot;)
+			{
+				itemhandler-&gt;setItemParent(mInventory, slotName);
+				mSlotDragContainers[dragContainerName] = itemhandler;
+			}
+			else
+			{
+				mWorldDragContainers[dragContainerName] = itemhandler;
+			}
+
+            itemhandler-&gt;setDestroyListener(this);
+
+  			itemhandler-&gt;setRiseOnClickEnabled(true);
+			itemhandler-&gt;setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
+            itemhandler-&gt;subscribeEvent(DragContainer::EventDragStarted,
+                boost::bind(&amp;rl::InventoryWindow::handleItemDragStarted, this, item, showdescription));
+            itemhandler-&gt;subscribeEvent(DragContainer::EventDragEnded,
+                boost::bind(&amp;InventoryWindow::handleItemDragEnded, this, item, showdescription));
+		}
+
+		return itemhandler;
+	}
+
+    bool InventoryWindow::handleItemDragEnded(const Item* item, bool showdescription)
+    {
+        showPossibleSlots(NULL);
+
+        if( showdescription &amp;&amp; !mShowAllWorldItems) // this is a world item
+        {
+            // fade out and destroy
+            ItemDragContainer* cont = getItemDragContainer(item, showdescription);
+            if( cont )
+                cont-&gt;fadeOutAndHide(2.0f);
+        }
+
+        return true;
+    }
+
+    bool InventoryWindow::handleItemDragStarted(const Item* item, bool showdescription)
+    {
+        showPossibleSlots(item);
+
+        if( showdescription &amp;&amp; !mShowAllWorldItems) // this is a world item
+        {
+            // stop fade out and destroy
+            ItemDragContainer* cont = getItemDragContainer(item, showdescription);
+            if( cont )
+                cont-&gt;stopFadeOut();
+        }
+
+        return true;
+    }
+
+	bool InventoryWindow::handleItemDroppedOnSlot(const EventArgs&amp; evt)
+	{
+		const DragDropEventArgs&amp; evtArgs = static_cast&lt;const DragDropEventArgs&amp;&gt;(evt);
+
+		if (evtArgs.dragDropItem-&gt;testClassName(&quot;ItemDragContainer&quot;))
+		{
+			ItemDragContainer* dragcont = static_cast&lt;ItemDragContainer*&gt;(
+				evtArgs.dragDropItem);
+			Item* item = dragcont-&gt;getItem();
+			CeGuiString targetSlot = evtArgs.window-&gt;getUserString(SLOTNAME);
+
+			if (mInventory-&gt;canHold(item, targetSlot))
+			{
+				if (dragcont-&gt;getItemParentContainer() != NULL)
+				{
+					dragcont-&gt;getParent()-&gt;removeChildWindow(dragcont);
+				}
+				else if (dragcont-&gt;getItemParentSlot() != &quot;&quot;)
+				{
+					dragcont-&gt;getParent()-&gt;removeChildWindow(dragcont);
+				}
+
+				ItemDragContainer* newCont = createItemDragContainer(item, false, targetSlot);
+
+				if (newCont)
+				{
+                    dragcont-&gt;destroyWindow();
+				}
+				else
+				{
+					newCont = dragcont;
+				}
+
+                CEGUI::Window* slotWindow = mSlotWindows[targetSlot];
+
+				mInventory-&gt;hold(item, targetSlot);
+
+				slotWindow-&gt;addChildWindow(newCont);
+				newCont-&gt;setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
+				newCont-&gt;setItemParent(mInventory, targetSlot);
+
+                showPossibleSlots(NULL);
+				return true;
+			}
+			else
+			{
+                showPossibleSlots(NULL);
+				return false;
+			}
+		}
+
+        handleItemLeavesSlot(evt);
+		return false;
+	}
+
+    bool InventoryWindow::handleItemEntersSlot(const CEGUI::EventArgs&amp; evt)
+    {
+		const DragDropEventArgs&amp; evtArgs = static_cast&lt;const DragDropEventArgs&amp;&gt;(evt);
+
+		if (evtArgs.dragDropItem-&gt;testClassName(&quot;ItemDragContainer&quot;))
+		{
+			ItemDragContainer* dragcont = static_cast&lt;ItemDragContainer*&gt;(
+				evtArgs.dragDropItem);
+			Item* item = dragcont-&gt;getItem();
+			CeGuiString targetSlot = evtArgs.window-&gt;getUserString(SLOTNAME);
+            CEGUI::Window* slotWindow = mSlotWindows[targetSlot];
+
+
+            if( mInventory-&gt;canReady(item, targetSlot) )
+            {
+                //slotWindow-&gt;setProperty(&quot;ContainerColour&quot;, 
+                //    slotWindow-&gt;getProperty(&quot;ContainerColour_DropReady&quot;));
+            }
+            else if( mInventory-&gt;canHold(item, targetSlot) )
+            {
+                //slotWindow-&gt;setProperty(&quot;ContainerColour&quot;, 
+                //    slotWindow-&gt;getProperty(&quot;ContainerColour_DropPossible&quot;));
+            }
+            else
+            {
+                slotWindow-&gt;setProperty(&quot;ContainerColour&quot;, 
+                    slotWindow-&gt;getProperty(&quot;ContainerColour_DropImpossible&quot;));
+            }
+
+
+            return true;
+        }
+        return false;
+    }
+
+    bool InventoryWindow::handleItemLeavesSlot(const CEGUI::EventArgs&amp; evt)
+    {
+		const DragDropEventArgs&amp; evtArgs = static_cast&lt;const DragDropEventArgs&amp;&gt;(evt);
+
+		if (evtArgs.dragDropItem-&gt;testClassName(&quot;ItemDragContainer&quot;))
+		{
+			ItemDragContainer* dragcont = static_cast&lt;ItemDragContainer*&gt;(
+				evtArgs.dragDropItem);
+			Item* item = dragcont-&gt;getItem();
+			CeGuiString targetSlot = evtArgs.window-&gt;getUserString(SLOTNAME);
+            CEGUI::Window* slotWindow = mSlotWindows[targetSlot];
+
+
+            if( mInventory-&gt;canReady(item, targetSlot) )
+            {
+                //slotWindow-&gt;setProperty(&quot;ContainerColour&quot;, 
+                //    slotWindow-&gt;getProperty(&quot;ContainerColour_Standard&quot;));
+            }
+            else if( mInventory-&gt;canHold(item, targetSlot) )
+            {
+                //slotWindow-&gt;setProperty(&quot;ContainerColour&quot;, 
+                //    slotWindow-&gt;getProperty(&quot;ContainerColour_Standard&quot;));
+            }
+            else
+            {
+                slotWindow-&gt;setProperty(&quot;ContainerColour&quot;, 
+                    slotWindow-&gt;getProperty(&quot;ContainerColour_Standard&quot;));
+            }
+
+
+            return true;
+        }
+        return false;
+    }
+
+	bool InventoryWindow::handleItemDroppedOnWorld(const EventArgs&amp; evt)
+	{
+		const DragDropEventArgs&amp; evtArgs = static_cast&lt;const DragDropEventArgs&amp;&gt;(evt);
+		if (evtArgs.dragDropItem-&gt;testClassName(&quot;ItemDragContainer&quot;))
+		{
+			ItemDragContainer* dragcont = static_cast&lt;ItemDragContainer*&gt;(
+				evtArgs.dragDropItem);
+			Item* item = dragcont-&gt;getItem();
+			Ogre::Vector3 targetPosWindow(
+				dragcont-&gt;getPixelRect().d_left / getRoot()-&gt;getPixelSize().d_width,
+				dragcont-&gt;getPixelRect().d_top / getRoot()-&gt;getPixelSize().d_height,
+				-1);
+
+
+            dragcont-&gt;destroyWindow();
+
+			Ogre::Vector3 targetPosWorldSpace =
+				mInventory-&gt;getOwner()-&gt;getPosition()
+				+ mInventory-&gt;getOwner()-&gt;getOrientation()
+				* targetPosWindow;
+            item-&gt;removeOldState();
+			item-&gt;setState(GOS_IN_SCENE);
+			item-&gt;setPosition(targetPosWorldSpace);
+
+			LOG_DEBUG(Logger::UI,
+				&quot;Dropped item &quot;+item-&gt;getName()
+				+&quot; to position &quot;+Ogre::StringConverter::toString(targetPosWorldSpace));
+
+			return true;
+
+		}
+		return false;
+	}
+
+	bool InventoryWindow::handleMouseMovedInWorld(const EventArgs&amp; evt)
+	{
+        if( mShowAllWorldItems )
+            return true;
+
+		const MouseEventArgs&amp; mevt = static_cast&lt;const MouseEventArgs&amp;&gt;(evt);
+
+		Actor* cameraActor = ActorManager::getSingleton().getActor(&quot;DefaultCamera&quot;);
+		CameraObject* camera = static_cast&lt;CameraObject*&gt;(cameraActor-&gt;getControlledObject());
+
+		CEGUI::Point mousePos = mevt.position;
+		mousePos.d_x /= getRoot()-&gt;getPixelSize().d_width;
+		mousePos.d_y /= getRoot()-&gt;getPixelSize().d_height;
+		Ogre::Ray camToWorld = camera-&gt;getCameraToViewportRay(
+			mousePos.d_x, mousePos.d_y);
+		Ogre::Vector3 rayStart = camera-&gt;getCamera()-&gt;getWorldPosition();
+		Ogre::Vector3 rayDir = camera-&gt;getDirectionFromScreenPosition(
+			mousePos.d_x, mousePos.d_y);
+
+		mMouseSelector-&gt;setRay(camToWorld.getOrigin(), camToWorld.getPoint(3));
+		mMouseSelector-&gt;updateSelection();
+		Selector::GameObjectVector objs = mMouseSelector-&gt;getAllSelectedObjects();
+
+		///@todo select, ...
+		if (!objs.empty())
+		{
+			LOG_MESSAGE(Logger::UI,
+				&quot;Selected &quot;+Ogre::StringConverter::toString(objs.size())+&quot; items.&quot;);
+			for (Selector::GameObjectVector::const_iterator it = objs.begin();
+				it != objs.end(); ++it)
+			{
+                if( !mInventory-&gt;getOwner()-&gt;canReachItem(static_cast&lt;Item*&gt;(*it)) )
+                    continue;
+
+                ItemDragContainer* cont = getItemDragContainer(static_cast&lt;Item*&gt;(*it), true);
+
+                if( !cont )
+                {
+					cont = createItemDragContainer(static_cast&lt;Item*&gt;(*it), true);
+                    mWorldBackground-&gt;addChildWindow(cont);
+                }
+				if (cont)
+				{
+					Ogre::Rectangle aabb = getCeGuiRectFromWorldAABB(camera,
+							(*it)-&gt;getActor()-&gt;_getSceneNode()-&gt;_getWorldAABB());
+					UVector2 posCont = UVector2(
+							UDim((aabb.left+aabb.right)/2.0, 0),
+							UDim((aabb.top+aabb.bottom)/2.0, 0));
+					posCont -= cont-&gt;getSize() / UVector2(UDim(2, 2), UDim(2, 2));
+					cont-&gt;setPosition(posCont);
+					cont-&gt;setVisible(true);
+
+                    cont-&gt;fadeOutAndHide(2.0f);
+				}
+			}
+		}
+
+		return true;
+	}
+
+	bool InventoryWindow::handleKeys(const CEGUI::EventArgs &amp;evt, bool down)
+	{
+		const KeyEventArgs&amp; kevt = static_cast&lt;const KeyEventArgs&amp;&gt;(evt);
+
+        ///@todo das hier ueberpruefen!
+        CeGuiString action = 
+            InputManager::getSingleton().getControlState()
+                -&gt;getCommandMapper()-&gt;getControlStateAction(
+                kevt.scancode,
+                InputManager::getSingleton().getControlState()-&gt;getType()
+                );
+        if( action == &quot;&quot; )
+        {
+            action = InputManager::getSingleton().getControlState()
+                        -&gt;getCommandMapper()-&gt;getGlobalAction(kevt.scancode);
+        }
+        if( action == &quot;inventoryshowworldobjects&quot; )  // we only handle this action here
+		{
+			if (down)
+			{
+                mShowAllWorldItems = true;
+
+				Actor* cameraActor = ActorManager::getSingleton().getActor(&quot;DefaultCamera&quot;);
+				CameraObject* camera = static_cast&lt;CameraObject*&gt;(cameraActor-&gt;getControlledObject());
+
+				HalfSphereSelector sel(QUERYFLAG_ITEM);
+				sel.setPosition(cameraActor-&gt;getWorldPosition());
+				sel.setOrientation(cameraActor-&gt;getWorldOrientation());
+				sel.setRadius(10.0);
+
+				sel.updateSelection();
+				Selector::GameObjectVector v = sel.getAllSelectedObjects();
+				for (Selector::GameObjectVector::iterator
+					it = v.begin(); it != v.end(); ++it)
+				{
+                    if( !mInventory-&gt;getOwner()-&gt;canReachItem(static_cast&lt;Item*&gt;(*it)) )
+                        continue;
+
+                    ItemDragContainer* cont = getItemDragContainer(static_cast&lt;Item*&gt;(*it), true);
+
+                    if( !cont )
+                    {
+					    cont = createItemDragContainer(static_cast&lt;Item*&gt;(*it), true);
+                        mWorldBackground-&gt;addChildWindow(cont);
+                    }
+				    if (cont)
+				    {
+					    Ogre::Rectangle aabb = getCeGuiRectFromWorldAABB(camera,
+							    (*it)-&gt;getActor()-&gt;_getSceneNode()-&gt;_getWorldAABB());
+					    UVector2 posCont = UVector2(
+							    UDim((aabb.left+aabb.right)/2.0, 0),
+							    UDim((aabb.top+aabb.bottom)/2.0, 0));
+					    posCont -= cont-&gt;getSize() / UVector2(UDim(2, 2), UDim(2, 2));
+					    cont-&gt;setPosition(posCont);
+					    cont-&gt;setVisible(true);
+                        cont-&gt;moveToFront();
+                        cont-&gt;stopFadeOut();
+				    }
+				}
+			}
+			else
+			{
+                mShowAllWorldItems = false;
+                DndContainerMap::iterator iter = mWorldDragContainers.begin();
+                for( ; iter != mWorldDragContainers.end(); iter++ )
+                {
+                    iter-&gt;second-&gt;fadeOutAndHide(0.0f);
+                }
+			}
+
+			return true;
+		}
+
+		return false;
+	}
+
+	Ogre::Rectangle InventoryWindow::getCeGuiRectFromWorldAABB(
+		CameraObject* camera,
+        const AxisAlignedBox&amp; aabb) const
+    {
+        // Initialise each to the value of the opposite side, so that min/max work smoothly.
+        Real left = 1.0f, bottom = 1.0f, right = -1.0f, top = -1.0f;
+
+        // Determine screen pos of all corners and widen the rect if needed
+		const Ogre::Vector3* corners = aabb.getAllCorners();
+        for (size_t i = 0; i &lt; 8; ++i)
+        {
+			Ogre::Vector3 screenSpacePos = camera-&gt;getPointOnCeGuiScreen(corners[i]);
+            if (screenSpacePos.z &gt; 0) continue; // Behind camera
+
+            left   = std::min(left,   screenSpacePos.x);
+            right  = std::max(right,  screenSpacePos.x);
+            bottom = std::min(bottom, screenSpacePos.y);
+            top    = std::max(top,    screenSpacePos.y);
+        }
+
+        Ogre::Rectangle rval = {left,top, right, bottom};
+        return rval;
+    }
+
+    void InventoryWindow::showContainerContent(Container* container)
+    {
+        ContainerMap::iterator iter = mOpenContainerMap.find(container);
+        if( iter == mOpenContainerMap.end() )
+        {
+            ContainerContentWindow* wnd = new ContainerContentWindow(container, this);
+            mOpenContainerMap.insert(make_pair(container, wnd));
+            mWorldBackground-&gt;addChildWindow(wnd-&gt;getWindow());
+            wnd-&gt;setVisible(true);
+        }
+        else
+        {
+            iter-&gt;second-&gt;setVisible(true);
+            iter-&gt;second-&gt;getWindow()-&gt;moveToFront();
+        }
+    }
+
+    void InventoryWindow::setVisible(bool visible, bool destroyAfterHide)
+    {
+        if( !visible &amp;&amp; destroyAfterHide )
+        {
+            ContainerMap::iterator iter = mOpenContainerMap.begin();
+            for( ; iter != mOpenContainerMap.end(); iter++)
+            {
+                if( iter-&gt;second != NULL )
+                {
+                    iter-&gt;second-&gt;setVisible(false, true, true); // if we call notifyInventoryWindow here, the iterator isn't valid any more!
+                }
+            }
+            mOpenContainerMap.erase(mOpenContainerMap.begin(), mOpenContainerMap.end());
+        }
+
+        AbstractWindow::setVisible(visible, destroyAfterHide);
+    }
+
+    void InventoryWindow::notifyContainerContentWindowClosed(Container* container)
+    {
+        ContainerMap::iterator iter = mOpenContainerMap.find(container);
+        if( iter != mOpenContainerMap.end() )
+        {
+            mOpenContainerMap.erase(iter);
+        }
+    }
+
+    bool InventoryWindow::showPossibleSlots(const Item* item)
+    {
+        SlotWindowMap::iterator iter = mSlotWindows.begin();
+
+        for( ; iter != mSlotWindows.end(); iter++ )
+        {
+            if( item )
+            {
+                if( mInventory-&gt;canReady(item, iter-&gt;first) )
+                {
+                    iter-&gt;second-&gt;setProperty(&quot;ContainerColour&quot;, 
+                        iter-&gt;second-&gt;getProperty(&quot;ContainerColour_DropReady&quot;));
+                    continue;
+                }
+                else if( mInventory-&gt;canHold(item, iter-&gt;first) )
+                {
+                    iter-&gt;second-&gt;setProperty(&quot;ContainerColour&quot;, 
+                        iter-&gt;second-&gt;getProperty(&quot;ContainerColour_DropPossible&quot;));
+                    continue;
+                }
+            }
+            iter-&gt;second-&gt;setProperty(&quot;ContainerColour&quot;, 
+                iter-&gt;second-&gt;getProperty(&quot;ContainerColour_Standard&quot;));
+        }
+        return true;
+    }
+
+    void InventoryWindow::notifyItemDragContainerDestroyed(ItemDragContainer* cont)
+    {
+        DndContainerMap::iterator iter = mWorldDragContainers.begin();
+        for( ; iter != mWorldDragContainers.end(); iter++)
+        {
+            if( iter-&gt;second == cont )
+            {
+                mWorldDragContainers.erase(iter);
+                return;
+            }
+        }
+
+        iter = mSlotDragContainers.begin();
+        for( ; iter != mSlotDragContainers.end(); iter++)
+        {
+            if( iter-&gt;second == cont )
+            {
+                mSlotDragContainers.erase(iter);
+                return;
+            }
+        }
+
+        LOG_ERROR(Logger::UI, &quot;Could not find ItemDragContainer in InventoryWindow::notifyItemDragContainerDestroyed!&quot;);
+    }
+}

Modified: rl/trunk/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ui/src/UiSubsystem.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/engine/ui/src/UiSubsystem.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -1,237 +1,242 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;UiSubsystem.h&quot;
-
-#include &lt;CEGUISystem.h&gt;
-#include &lt;CEGUIWindow.h&gt;
-#include &lt;CEGUIWindowManager.h&gt;
-#include &lt;OgreCEGUIRenderer.h&gt;
-
-#include &quot;Actor.h&quot;
-#include &quot;AiMessages.h&quot;
-#include &quot;CeGuiHelper.h&quot;
-#include &quot;ConfigurationManager.h&quot;
-#include &quot;CoreMessages.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;ControlState.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;GameLoop.h&quot;
-#include &quot;InputManager.h&quot;
-#include &quot;Logger.h&quot;
-#include &quot;Person.h&quot;
-#include &quot;ScriptWrapper.h&quot;
-#include &quot;SoundManager.h&quot;
-#include &quot;WindowFactory.h&quot;
-#include &quot;WindowManager.h&quot;
-#include &quot;GameObjectManager.h&quot;
-
-using namespace Ogre;
-template&lt;&gt; rl::UiSubsystem* Singleton&lt;rl::UiSubsystem&gt;::ms_Singleton = 0;
-
-namespace rl {
-    const char* UiSubsystem::CEGUI_ROOT = &quot;RootWindow&quot;;
-
-    UiSubsystem::UiSubsystem() :
-        mCharacter(NULL),
-        mInputManager(NULL),
-        mWindowFactory(NULL),
-        mWindowManager(NULL),
-        mGuiRenderer(NULL),
-        mGuiResourceProvider(NULL),
-        mGuiSystem(NULL)
-    {
-        mSceneClearingConnection =
-            MessagePump::getSingleton().addMessageHandler&lt;MessageType_SceneClearing&gt;(
-			    boost::bind(&amp;UiSubsystem::onBeforeClearScene, this));
-        mGameObjectsLoadedConnection =
-            MessagePump::getSingleton().addMessageHandler&lt;MessageType&lt;RLMSG_SAVEGAME_GOS_LOADED&gt; &gt;(
-                boost::bind(&amp;UiSubsystem::onGameObjectsLoaded, this));
-        mBeforeLoadingGameObjectsConnection = 
-            MessagePump::getSingleton().addMessageHandler&lt;MessageType&lt;RLMSG_SAVEGAME_LOADING&gt; &gt;(
-                boost::bind(&amp;UiSubsystem::onBeforeGameObjectsLoaded, this));
-        mWindowFactory = new WindowFactory();
-    }
-
-    UiSubsystem::~UiSubsystem()
-    {
-        delete mWindowFactory;
-        delete mWindowManager;
-
-        delete mInputManager;
-
-        delete mGuiSystem;
-        delete mGuiRenderer;
-    }
-
-    void UiSubsystem::initializeSubsystem()
-    {
-        using namespace CEGUI;
-
-        LOG_MESSAGE2(Logger::UI,
-            &quot;Initialisiere UI&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);
-        World* world = CoreSubsystem::getSingleton().getWorld();
-        SceneManager* sceneMgr = world-&gt;getSceneManager();
-
-        LOG_MESSAGE2(Logger::UI,
-            &quot;Initializing CEGUI Renderer.&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);
-        mGuiRenderer = new OgreCEGUIRenderer(CoreSubsystem::getSingleton().getRenderWindow(),
-            Ogre::RENDER_QUEUE_OVERLAY, false, 3000, sceneMgr);
-
-        LOG_MESSAGE2(Logger::UI,
-            &quot;Initializing CEGUI System.&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);
-        mGuiResourceProvider = mGuiRenderer-&gt;createResourceProvider();
-        CEGUI::System::setDefaultXMLParserName(&quot;XercesParser&quot;);
-        mGuiSystem = new System(mGuiRenderer, mGuiResourceProvider,
-            NULL, NULL, (utf8*)&quot;cegui.config&quot;, ConfigurationManager::getSingleton().getCeguiLogFile());
-        CEGUI::Logger::getSingleton().setLoggingLevel(
-            rl::Logger::getSingleton().getCeGuiLogDetail());
-        LOG_MESSAGE2(Logger::UI,
-            &quot;CEGUI System initialized.&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);
-
-        // load scheme and set up defaults
-        ///@todo Hier sollte was Lookunabhaengiges rein!!! FIXME TODO BUG!
-        System::getSingleton().setDefaultMouseCursor((utf8*)&quot;RastullahLook-Images&quot;,
-            (utf8*)&quot;MouseArrow&quot;);
-        LOG_MESSAGE2(Logger::UI, &quot;Mouse arrow loaded.&quot;,
-            &quot;UiSubsystem::initializeUiSubsystem&quot;);
-        Window* sheet = CEGUI::WindowManager::getSingleton().createWindow((utf8*)&quot;DefaultGUISheet&quot;,
-            (utf8*)CEGUI_ROOT);
-        LOG_MESSAGE2(Logger::UI, &quot;CEGUI Root Window created.&quot;,
-            &quot;UiSubsystem::initializeUiSubsystem&quot;);
-        sheet-&gt;setSize(
-            CeGuiHelper::asAbsolute(CEGUI::Vector2(
-                CoreSubsystem::getSingleton().getRenderWindow()-&gt;getWidth(),
-                CoreSubsystem::getSingleton().getRenderWindow()-&gt;getHeight())));
-        sheet-&gt;setPosition(CeGuiHelper::asAbsolute(CEGUI::Point(0, 0)));
-        System::getSingleton().setGUISheet(sheet);
-        sheet-&gt;setZOrderingEnabled(true);
-        sheet-&gt;moveToBack();
-        System::getSingleton().setDefaultTooltip(&quot;RastullahLook/Tooltip&quot;);
-        LOG_MESSAGE2(Logger::UI, &quot;CEGUI initialized.&quot;,
-            &quot;UiSubsystem::initializeUiSubsystem&quot;);
-
-        mWindowManager = new WindowManager();
-
-        //Initializing InputManager
-        mInputManager = new InputManager(CoreSubsystem::getSingleton().getRenderWindow());
-        LOG_MESSAGE2(Logger::UI, &quot;InputManager started.&quot;,
-            &quot;UiSubsystem::initializeUiSubsystem&quot;);
-
-        mWindowFactory-&gt;initialize();
-    }
-
-
-    CEGUI::OgreCEGUIRenderer* UiSubsystem::getGUIRenderer()
-    {
-        return mGuiRenderer;
-    }
-
-    Person* UiSubsystem::getActiveCharacter() const
-    {
-        return mCharacter;
-    }
-
-    void UiSubsystem::setActiveCharacter(Person* person)
-    {
-        // Ensure we have a sound listener
-        if (SoundManager::getSingleton().getListenerActor() == NULL)
-        {
-            SoundManager::getSingleton().createListenerActor();
-        }
-
-        // Nur wenn es sich veraendert hat
-        if( person != mCharacter )
-        {
-            if( mCharacter != NULL )
-            {
-                ScriptWrapper::getSingleton().disowned( mCharacter );
-                mCharacter-&gt;getActor()-&gt;detach(SoundManager::getSingleton().getListenerActor());
-                mCharacter-&gt;setQueryFlags(mCharacter-&gt;getQueryFlags() &amp; (~QUERYFLAG_PLAYER));
-            }
-
-            if (person == NULL)
-            {
-                mCharacter = NULL;
-                mInputManager-&gt;clearControlStates();
-            }
-            else
-            {
-                ScriptWrapper::getSingleton().owned( person );
-                mCharacter = person;
-                mCharacter-&gt;addQueryFlag(QUERYFLAG_PLAYER);
-
-                mWindowFactory-&gt;setActiveCharacter(person);
-
-                mCharacter-&gt;getActor()-&gt;attach(SoundManager::getSingleton().getListenerActor());
-                LOG_MESSAGE(Logger::UI, &quot;SoundListener attached.&quot;);
-
-                // Reset control stack for the new Character and set to movement.
-                mInputManager-&gt;setControlState(CST_MOVEMENT);
-            }
-        }
-    }
-
-    bool UiSubsystem::onBeforeClearScene()
-    {
-        setActiveCharacter(NULL);
-        // Remove control states here too, in case that there has not yet been a
-        // person set active.
-        mInputManager-&gt;clearControlStates();
-
-        return true;
-    }
-
-    bool UiSubsystem::onGameObjectsLoaded()
-    {
-        if(mCharacterId != -1)
-        {
-            Person* person = static_cast&lt;Person*&gt;(GameObjectManager::getSingleton().getGameObject(mCharacterId));
-
-            ScriptWrapper::getSingleton().owned( person );
-            mCharacter = person;
-
-            mWindowFactory-&gt;setActiveCharacter(person);
-
-            mCharacter-&gt;getActor()-&gt;attach(SoundManager::getSingleton().getListenerActor());
-            LOG_MESSAGE(Logger::UI, &quot;SoundListener attached.&quot;);
-
-            // Reset control stack for the new Character and set to movement.
-            //mInputManager-&gt;setControlState(CST_MOVEMENT);
-        }
-        return false;
-    }
-
-    bool UiSubsystem::onBeforeGameObjectsLoaded()
-    {
-        LOG_MESSAGE(Logger::UI, &quot;UiSubsystem::onBeforeGameObjectsLoaded()&quot;);
-        if(mCharacter)
-        {
-            ScriptWrapper::getSingleton().disowned( mCharacter );
-            mCharacter-&gt;getActor()-&gt;detach(SoundManager::getSingleton().getListenerActor());
-
-            mWindowFactory-&gt;setActiveCharacter(NULL);
-
-            mCharacterId = mCharacter-&gt;getId();
-        }
-        else
-            mCharacterId = -1;
-
-        //mInputManager-&gt;clearControlStates();
-        return false;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;UiSubsystem.h&quot;
+
+#include &lt;CEGUISystem.h&gt;
+#include &lt;CEGUIWindow.h&gt;
+#include &lt;CEGUIWindowManager.h&gt;
+
+#ifdef __APPLE__
+#   include &lt;OgreCEGUIRenderer/OgreCEGUIRenderer.h&gt;
+#else
+#   include &lt;OgreCEGUIRenderer.h&gt;
+#endif
+
+#include &quot;Actor.h&quot;
+#include &quot;AiMessages.h&quot;
+#include &quot;CeGuiHelper.h&quot;
+#include &quot;ConfigurationManager.h&quot;
+#include &quot;CoreMessages.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;ControlState.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;GameLoop.h&quot;
+#include &quot;InputManager.h&quot;
+#include &quot;Logger.h&quot;
+#include &quot;Person.h&quot;
+#include &quot;ScriptWrapper.h&quot;
+#include &quot;SoundManager.h&quot;
+#include &quot;WindowFactory.h&quot;
+#include &quot;WindowManager.h&quot;
+#include &quot;GameObjectManager.h&quot;
+
+using namespace Ogre;
+template&lt;&gt; rl::UiSubsystem* Singleton&lt;rl::UiSubsystem&gt;::ms_Singleton = 0;
+
+namespace rl {
+    const char* UiSubsystem::CEGUI_ROOT = &quot;RootWindow&quot;;
+
+    UiSubsystem::UiSubsystem() :
+        mCharacter(NULL),
+        mInputManager(NULL),
+        mWindowFactory(NULL),
+        mWindowManager(NULL),
+        mGuiRenderer(NULL),
+        mGuiResourceProvider(NULL),
+        mGuiSystem(NULL)
+    {
+        mSceneClearingConnection =
+            MessagePump::getSingleton().addMessageHandler&lt;MessageType_SceneClearing&gt;(
+			    boost::bind(&amp;UiSubsystem::onBeforeClearScene, this));
+        mGameObjectsLoadedConnection =
+            MessagePump::getSingleton().addMessageHandler&lt;MessageType&lt;RLMSG_SAVEGAME_GOS_LOADED&gt; &gt;(
+                boost::bind(&amp;UiSubsystem::onGameObjectsLoaded, this));
+        mBeforeLoadingGameObjectsConnection = 
+            MessagePump::getSingleton().addMessageHandler&lt;MessageType&lt;RLMSG_SAVEGAME_LOADING&gt; &gt;(
+                boost::bind(&amp;UiSubsystem::onBeforeGameObjectsLoaded, this));
+        mWindowFactory = new WindowFactory();
+    }
+
+    UiSubsystem::~UiSubsystem()
+    {
+        delete mWindowFactory;
+        delete mWindowManager;
+
+        delete mInputManager;
+
+        delete mGuiSystem;
+        delete mGuiRenderer;
+    }
+
+    void UiSubsystem::initializeSubsystem()
+    {
+        using namespace CEGUI;
+
+        LOG_MESSAGE2(Logger::UI,
+            &quot;Initialisiere UI&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);
+        World* world = CoreSubsystem::getSingleton().getWorld();
+        SceneManager* sceneMgr = world-&gt;getSceneManager();
+
+        LOG_MESSAGE2(Logger::UI,
+            &quot;Initializing CEGUI Renderer.&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);
+        mGuiRenderer = new OgreCEGUIRenderer(CoreSubsystem::getSingleton().getRenderWindow(),
+            Ogre::RENDER_QUEUE_OVERLAY, false, 3000, sceneMgr);
+
+        LOG_MESSAGE2(Logger::UI,
+            &quot;Initializing CEGUI System.&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);
+        mGuiResourceProvider = mGuiRenderer-&gt;createResourceProvider();
+        //CEGUI::System::setDefaultXMLParserName(&quot;XercesParser&quot;);
+        mGuiSystem = new System(mGuiRenderer, mGuiResourceProvider,
+            NULL, NULL, (utf8*)&quot;cegui.config&quot;, ConfigurationManager::getSingleton().getCeguiLogFile());
+        CEGUI::Logger::getSingleton().setLoggingLevel(
+            rl::Logger::getSingleton().getCeGuiLogDetail());
+        LOG_MESSAGE2(Logger::UI,
+            &quot;CEGUI System initialized.&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);
+
+        // load scheme and set up defaults
+        ///@todo Hier sollte was Lookunabhaengiges rein!!! FIXME TODO BUG!
+        System::getSingleton().setDefaultMouseCursor((utf8*)&quot;RastullahLook-Images&quot;,
+            (utf8*)&quot;MouseArrow&quot;);
+        LOG_MESSAGE2(Logger::UI, &quot;Mouse arrow loaded.&quot;,
+            &quot;UiSubsystem::initializeUiSubsystem&quot;);
+        Window* sheet = CEGUI::WindowManager::getSingleton().createWindow((utf8*)&quot;DefaultGUISheet&quot;,
+            (utf8*)CEGUI_ROOT);
+        LOG_MESSAGE2(Logger::UI, &quot;CEGUI Root Window created.&quot;,
+            &quot;UiSubsystem::initializeUiSubsystem&quot;);
+        sheet-&gt;setSize(
+            CeGuiHelper::asAbsolute(CEGUI::Vector2(
+                CoreSubsystem::getSingleton().getRenderWindow()-&gt;getWidth(),
+                CoreSubsystem::getSingleton().getRenderWindow()-&gt;getHeight())));
+        sheet-&gt;setPosition(CeGuiHelper::asAbsolute(CEGUI::Point(0, 0)));
+        System::getSingleton().setGUISheet(sheet);
+        sheet-&gt;setZOrderingEnabled(true);
+        sheet-&gt;moveToBack();
+        System::getSingleton().setDefaultTooltip(&quot;RastullahLook/Tooltip&quot;);
+        LOG_MESSAGE2(Logger::UI, &quot;CEGUI initialized.&quot;,
+            &quot;UiSubsystem::initializeUiSubsystem&quot;);
+
+        mWindowManager = new WindowManager();
+
+        //Initializing InputManager
+        mInputManager = new InputManager(CoreSubsystem::getSingleton().getRenderWindow());
+        LOG_MESSAGE2(Logger::UI, &quot;InputManager started.&quot;,
+            &quot;UiSubsystem::initializeUiSubsystem&quot;);
+
+        mWindowFactory-&gt;initialize();
+    }
+
+
+    CEGUI::OgreCEGUIRenderer* UiSubsystem::getGUIRenderer()
+    {
+        return mGuiRenderer;
+    }
+
+    Person* UiSubsystem::getActiveCharacter() const
+    {
+        return mCharacter;
+    }
+
+    void UiSubsystem::setActiveCharacter(Person* person)
+    {
+        // Ensure we have a sound listener
+        if (SoundManager::getSingleton().getListenerActor() == NULL)
+        {
+            SoundManager::getSingleton().createListenerActor();
+        }
+
+        // Nur wenn es sich veraendert hat
+        if( person != mCharacter )
+        {
+            if( mCharacter != NULL )
+            {
+                ScriptWrapper::getSingleton().disowned( mCharacter );
+                mCharacter-&gt;getActor()-&gt;detach(SoundManager::getSingleton().getListenerActor());
+                mCharacter-&gt;setQueryFlags(mCharacter-&gt;getQueryFlags() &amp; (~QUERYFLAG_PLAYER));
+            }
+
+            if (person == NULL)
+            {
+                mCharacter = NULL;
+                mInputManager-&gt;clearControlStates();
+            }
+            else
+            {
+                ScriptWrapper::getSingleton().owned( person );
+                mCharacter = person;
+                mCharacter-&gt;addQueryFlag(QUERYFLAG_PLAYER);
+
+                mWindowFactory-&gt;setActiveCharacter(person);
+
+                mCharacter-&gt;getActor()-&gt;attach(SoundManager::getSingleton().getListenerActor());
+                LOG_MESSAGE(Logger::UI, &quot;SoundListener attached.&quot;);
+
+                // Reset control stack for the new Character and set to movement.
+                mInputManager-&gt;setControlState(CST_MOVEMENT);
+            }
+        }
+    }
+
+    bool UiSubsystem::onBeforeClearScene()
+    {
+        setActiveCharacter(NULL);
+        // Remove control states here too, in case that there has not yet been a
+        // person set active.
+        mInputManager-&gt;clearControlStates();
+
+        return true;
+    }
+
+    bool UiSubsystem::onGameObjectsLoaded()
+    {
+        if(mCharacterId != -1)
+        {
+            Person* person = static_cast&lt;Person*&gt;(GameObjectManager::getSingleton().getGameObject(mCharacterId));
+
+            ScriptWrapper::getSingleton().owned( person );
+            mCharacter = person;
+
+            mWindowFactory-&gt;setActiveCharacter(person);
+
+            mCharacter-&gt;getActor()-&gt;attach(SoundManager::getSingleton().getListenerActor());
+            LOG_MESSAGE(Logger::UI, &quot;SoundListener attached.&quot;);
+
+            // Reset control stack for the new Character and set to movement.
+            //mInputManager-&gt;setControlState(CST_MOVEMENT);
+        }
+        return false;
+    }
+
+    bool UiSubsystem::onBeforeGameObjectsLoaded()
+    {
+        LOG_MESSAGE(Logger::UI, &quot;UiSubsystem::onBeforeGameObjectsLoaded()&quot;);
+        if(mCharacter)
+        {
+            ScriptWrapper::getSingleton().disowned( mCharacter );
+            mCharacter-&gt;getActor()-&gt;detach(SoundManager::getSingleton().getListenerActor());
+
+            mWindowFactory-&gt;setActiveCharacter(NULL);
+
+            mCharacterId = mCharacter-&gt;getId();
+        }
+        else
+            mCharacterId = -1;
+
+        //mInputManager-&gt;clearControlStates();
+        return false;
+    }
+}

Modified: rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h
===================================================================
--- rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -1,172 +1,164 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#ifndef _FMODDRIVER_H_
-#define _FMODDRIVER_H_
-
-#include &quot;Fmod4DriverPrerequisites.h&quot;
-
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-    #include &lt;fmod.hpp&gt;
-    #include &lt;fmod_errors.h&gt;
-#else
-    #include &lt;fmodex/fmod.hpp&gt;
-    #include &lt;fmodex/fmod_errors.h&gt;
-#endif
-
-#include &quot;SoundDriver.h&quot;
-
-namespace rl
-{
-
-    typedef std::map&lt;Ogre::String, StringList&gt; DriverMap;
-
-    #define CHECK_FMOD4_ERRORS(fmod4_errorcode)\
-    {\
-        if (fmod4_errorcode != FMOD_OK)\
-        {\
-            Throw(rl::RuntimeException,\
-                &quot;FMOD error #&quot;\
-                + StringConverter::toString(fmod4_errorcode)\
-                + &quot; &quot;\
-                + FMOD_ErrorString(fmod4_errorcode));\
-        }\
-    }
-
-    class Fmod4Sound;
-
-    /** Diese Klasse ist der Treiber, der OpenAL zur
-     * Ausgabe benutzt.
-     */
-    class _RlFmod4DriverExport Fmod4Driver : public rl::SoundDriver
-    {
-    public:
-        /// Der Treibername
-        static Ogre::String NAME;
-        /// Der Konstruktor
-        Fmod4Driver(Ogre::ResourceManager* soundResourceManager);
-        /// Der Destruktor
-        virtual ~Fmod4Driver();
-        /// Ist der Treiber angeschaltet?
-        virtual bool isDriverAvailable();
-        /// Initialisiere den Treiber.
-        virtual bool initialize();
-        /// Deinitialisiere den Treiber.
-        virtual void shutdown();
-        /// Der Name des Treibers
-        virtual Ogre::String getName() const;
-        /// Ist ein Ogre plugin
-        virtual bool isDriverPlugin() { return true; }
-        /// Update-Aufgaben erledigen
-        virtual void update();
-        /// Einen Soundlistener erzeugen
-        virtual ListenerMovable *createListener(const Ogre::String &amp;name);
-
-        virtual void setMasterVolume(const Ogre::Real&amp; vol);
-
-        /**
-         * Returns the current sound driver settings as a key-value list
-         *
-         * @return key-value list of sound options
-         */
-        virtual Ogre::NameValuePairList getSettings() const;
-
-        /**
-         * Sets certain options for the sound driver, like volume settings for
-         * sound effects and music.
-         *
-         * @param settings key-value list of settings
-         */
-        virtual void applySettings(const Ogre::NameValuePairList&amp; settings);
-
-        /**
-         * Sets an eax preset, the preset is defined by a string
-         * @retval true if successfull
-        */
-        virtual bool setEaxPreset(const Ogre::String&amp; name);
-
-        /// Setzt den Faktor f, mit der die Lautst&#65533;rke nach der Formel 1/(f*Entfernung) abnimmt
-        virtual void setRolloffFactor(const Ogre::Real&amp;);
-        virtual const Ogre::Real getRolloffFactor();
-
-        /// Datensammlung zurueckgeben
-        const DriverMap&amp; getDriverData() const;
-
-        FMOD::System* _getFmodSystem();
-        void _registerChannel(FMOD::Channel* channel, Fmod4Sound* sound);
-        
-    protected:
-        virtual Sound* createSoundImpl(SoundResourcePtr res, SoundType type);
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#ifndef _FMODDRIVER_H_
+#define _FMODDRIVER_H_
+
+#include &quot;Fmod4DriverPrerequisites.h&quot;
+
+#include &quot;SoundDriver.h&quot;
+
+namespace rl
+{
+
+    typedef std::map&lt;Ogre::String, StringList&gt; DriverMap;
+
+    #define CHECK_FMOD4_ERRORS(fmod4_errorcode)\
+    {\
+        if (fmod4_errorcode != FMOD_OK)\
+        {\
+            Throw(rl::RuntimeException,\
+                &quot;FMOD error #&quot;\
+                + StringConverter::toString(fmod4_errorcode)\
+                + &quot; &quot;\
+                + FMOD_ErrorString(fmod4_errorcode));\
+        }\
+    }
+
+    class Fmod4Sound;
+
+    /** Diese Klasse ist der Treiber, der OpenAL zur
+     * Ausgabe benutzt.
+     */
+    class _RlFmod4DriverExport Fmod4Driver : public rl::SoundDriver
+    {
+    public:
+        /// Der Treibername
+        static Ogre::String NAME;
+        /// Der Konstruktor
+        Fmod4Driver(Ogre::ResourceManager* soundResourceManager);
+        /// Der Destruktor
+        virtual ~Fmod4Driver();
+        /// Ist der Treiber angeschaltet?
+        virtual bool isDriverAvailable();
+        /// Initialisiere den Treiber.
+        virtual bool initialize();
+        /// Deinitialisiere den Treiber.
+        virtual void shutdown();
+        /// Der Name des Treibers
+        virtual Ogre::String getName() const;
+        /// Ist ein Ogre plugin
+        virtual bool isDriverPlugin() { return true; }
+        /// Update-Aufgaben erledigen
+        virtual void update();
+        /// Einen Soundlistener erzeugen
+        virtual ListenerMovable *createListener(const Ogre::String &amp;name);
+
+        virtual void setMasterVolume(const Ogre::Real&amp; vol);
+
+        /**
+         * Returns the current sound driver settings as a key-value list
+         *
+         * @return key-value list of sound options
+         */
+        virtual Ogre::NameValuePairList getSettings() const;
+
+        /**
+         * Sets certain options for the sound driver, like volume settings for
+         * sound effects and music.
+         *
+         * @param settings key-value list of settings
+         */
+        virtual void applySettings(const Ogre::NameValuePairList&amp; settings);
+
+        /**
+         * Sets an eax preset, the preset is defined by a string
+         * @retval true if successfull
+        */
+        virtual bool setEaxPreset(const Ogre::String&amp; name);
+
+        /// Setzt den Faktor f, mit der die Lautst&#65533;rke nach der Formel 1/(f*Entfernung) abnimmt
+        virtual void setRolloffFactor(const Ogre::Real&amp;);
+        virtual const Ogre::Real getRolloffFactor();
+
+        /// Datensammlung zurueckgeben
+        const DriverMap&amp; getDriverData() const;
+
+        FMOD::System* _getFmodSystem();
+        void _registerChannel(FMOD::Channel* channel, Fmod4Sound* sound);
+        
+    protected:
+        virtual Sound* createSoundImpl(SoundResourcePtr res, SoundType type);
         virtual SoundStitching* createSoundStitchingImpl(unsigned int numSlots, const CeGuiString&amp; name);
-
-    private:
-
-        typedef std::map&lt;FMOD::Channel*, Fmod4Sound*&gt; ChannelSoundMap;
-
-        static FMOD_RESULT F_CALLBACK open(
-            const char *  name,
-            int  unicode,
-            unsigned int *  filesize,
-            void **  handle,
-            void **  userdata
-        );
-
-        static FMOD_RESULT F_CALLBACK close(
-            void *  handle,
-            void *  userdata
-        );
-
-        static FMOD_RESULT F_CALLBACK read(
-            void *  handle,
-            void *  buffer,
-            unsigned int  sizebytes,
-            unsigned int *  bytesread,
-            void *  userdata
-        );
-
-        static FMOD_RESULT F_CALLBACK seek(
-            void *  handle,
-            unsigned int  pos,
-            void *  userdata
-        );
-
-        static FMOD_RESULT F_CALLBACK channelCallback(
-            FMOD_CHANNEL* channel,
-            FMOD_CHANNEL_CALLBACKTYPE type,
-            int command,
-            unsigned int commanddata1,
-            unsigned int commanddata2
-        );
-
-        typedef std::map&lt;const Ogre::String, FMOD_REVERB_PROPERTIES&gt; EaxPresetMap;
-        EaxPresetMap mEaxPresetMap;
-
-        void initializeEaxPresetMap();
-
-        /// Log driver config data
-        virtual void printData() const;
-        void printDriverInfo(int driver) const;
-
-        // Wir merken uns die Konfiguration von Fmod4
-        DriverMap mDriverData;
-        /// Stores sounds that are automatically destroyed after having been played.
-        ChannelSoundMap mChannelSoundMap;
-        FMOD::System* mFmod4System;
-        FMOD::ChannelGroup* mMasterChannelGroup;
-
-    };
-}
-
-#endif /*FMODDRIVER_H_*/
+
+    private:
+
+        typedef std::map&lt;FMOD::Channel*, Fmod4Sound*&gt; ChannelSoundMap;
+
+        static FMOD_RESULT F_CALLBACK open(
+            const char *  name,
+            int  unicode,
+            unsigned int *  filesize,
+            void **  handle,
+            void **  userdata
+        );
+
+        static FMOD_RESULT F_CALLBACK close(
+            void *  handle,
+            void *  userdata
+        );
+
+        static FMOD_RESULT F_CALLBACK read(
+            void *  handle,
+            void *  buffer,
+            unsigned int  sizebytes,
+            unsigned int *  bytesread,
+            void *  userdata
+        );
+
+        static FMOD_RESULT F_CALLBACK seek(
+            void *  handle,
+            unsigned int  pos,
+            void *  userdata
+        );
+
+        static FMOD_RESULT F_CALLBACK channelCallback(
+            FMOD_CHANNEL* channel,
+            FMOD_CHANNEL_CALLBACKTYPE type,
+            int command,
+            unsigned int commanddata1,
+            unsigned int commanddata2
+        );
+
+        typedef std::map&lt;const Ogre::String, FMOD_REVERB_PROPERTIES&gt; EaxPresetMap;
+        EaxPresetMap mEaxPresetMap;
+
+        void initializeEaxPresetMap();
+
+        /// Log driver config data
+        virtual void printData() const;
+        void printDriverInfo(int driver) const;
+
+        // Wir merken uns die Konfiguration von Fmod4
+        DriverMap mDriverData;
+        /// Stores sounds that are automatically destroyed after having been played.
+        ChannelSoundMap mChannelSoundMap;
+        FMOD::System* mFmod4System;
+        FMOD::ChannelGroup* mMasterChannelGroup;
+
+    };
+}
+
+#endif /*FMODDRIVER_H_*/

Modified: rl/trunk/plugins/fmod4driver/include/Fmod4DriverPrerequisites.h
===================================================================
--- rl/trunk/plugins/fmod4driver/include/Fmod4DriverPrerequisites.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/plugins/fmod4driver/include/Fmod4DriverPrerequisites.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -30,6 +30,14 @@
 #   define _RlFmod4DriverExport
 #endif
 
+#if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
+#   include &lt;fmodex/fmod.hpp&gt;
+#   include &lt;fmodex/fmod_errors.h&gt;
+#else
+#   include &lt;fmod.hpp&gt;
+#   include &lt;fmod_errors.h&gt;
+#endif
+
 #   undef min
 #   pragma warning (push)
 #   pragma warning (disable : 4267)

Modified: rl/trunk/plugins/fmod4driver/include/Fmod4Listener.h
===================================================================
--- rl/trunk/plugins/fmod4driver/include/Fmod4Listener.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/plugins/fmod4driver/include/Fmod4Listener.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -19,12 +19,6 @@
 #include &quot;Fmod4DriverPrerequisites.h&quot;
 #include &quot;ListenerMovable.h&quot;
 
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-    #include &lt;fmod.hpp&gt;
-#else
-    #include &lt;fmodex/fmod.hpp&gt;
-#endif
-
 namespace rl {
     
    /** Diese Klasse dient der Interkation mit Ogre3d und Fmod4

Modified: rl/trunk/plugins/fmod4driver/include/Fmod4Sound.h
===================================================================
--- rl/trunk/plugins/fmod4driver/include/Fmod4Sound.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/plugins/fmod4driver/include/Fmod4Sound.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -21,12 +21,6 @@
 #include &quot;Sound.h&quot;
 #include &quot;SoundDriver.h&quot;
 
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-    #include &lt;fmod.hpp&gt;
-#else
-    #include &lt;fmodex/fmod.hpp&gt;
-#endif
-
 namespace rl {
 
     class Fmod4Driver;

Modified: rl/trunk/plugins/fmod4driver/include/Fmod4SoundStitching.h
===================================================================
--- rl/trunk/plugins/fmod4driver/include/Fmod4SoundStitching.h	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/plugins/fmod4driver/include/Fmod4SoundStitching.h	2008-03-18 21:18:05 UTC (rev 4298)
@@ -21,12 +21,6 @@
 #include &quot;SoundStitching.h&quot;
 #include &quot;SoundDriver.h&quot;
 
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-    #include &lt;fmod.hpp&gt;
-#else
-    #include &lt;fmodex/fmod.hpp&gt;
-#endif
-
 namespace rl {
 
     class Fmod4Driver;

Modified: rl/trunk/plugins/fmod4driver/src/Fmod4ConfigComponent.cpp
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4ConfigComponent.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4ConfigComponent.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -16,13 +16,7 @@
 #include &quot;Fmod4ConfigComponent.h&quot;
 
 #include &lt;boost/bind.hpp&gt;
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-    #include &lt;fmod.h&gt;
-#else
-    #include &lt;fmodex/fmod.h&gt;
-#endif
 
-
 #include &quot;Exception.h&quot;
 #include &quot;Fmod4Driver.h&quot;
 #include &quot;SoundDriver.h&quot;

Modified: rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -117,13 +117,13 @@
         return sound;
     }
 
-
-    SoundStitching *Fmod4Driver::createSoundStitchingImpl(unsigned int numSlots, const CeGuiString&amp; name)
-    {
-         SoundStitching* soundstitching = new Fmod4SoundStitching(numSlots, name, this);
-         return soundstitching;
-    }
 
+    SoundStitching *Fmod4Driver::createSoundStitchingImpl(unsigned int numSlots, const CeGuiString&amp; name)
+    {
+         SoundStitching* soundstitching = new Fmod4SoundStitching(numSlots, name, this);
+         return soundstitching;
+    }
+
     ListenerMovable *Fmod4Driver::createListener(const Ogre::String &amp;name)
     {
         return new Fmod4Listener(name, mFmod4System);
@@ -234,7 +234,7 @@
         mFmod4System-&gt;getDriver(&amp;curdriver);
 
         char name[128];
-        mFmod4System-&gt;getDriverName(driver, name, 127);
+        mFmod4System-&gt;getDriverInfo(driver, name, 127, NULL);
 
         FMOD_CAPS caps;
         int minfreq, maxfreq;

Modified: rl/trunk/plugins/fmod4driver/src/Fmod4Sound.cpp
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4Sound.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4Sound.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -20,7 +20,6 @@
 #include &quot;SoundResource.h&quot;
 
 using namespace Ogre;
-using namespace boost;
 
 namespace rl {
 

Modified: rl/trunk/plugins/fmod4driver/src/Fmod4SoundStitching.cpp
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4SoundStitching.cpp	2008-03-18 18:57:00 UTC (rev 4297)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4SoundStitching.cpp	2008-03-18 21:18:05 UTC (rev 4298)
@@ -20,7 +20,6 @@
 #include &quot;SoundResource.h&quot;
 
 using namespace Ogre;
-using namespace boost;
 
 namespace rl {
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001368.html">[Dsa-hl-svn] r4297 - rl/trunk/engine/core/src
</A></li>
	<LI>Next message: <A HREF="001370.html">[Dsa-hl-svn] r4299 - rl/trunk/engine/script/swig
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1369">[ date ]</a>
              <a href="thread.html#1369">[ thread ]</a>
              <a href="subject.html#1369">[ subject ]</a>
              <a href="author.html#1369">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
