<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4096 - in dependencies/opensteer: include/OpenSteer	macosx/OpenSteer.xcodeproj src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-March/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4096%20-%20in%20dependencies/opensteer%3A%20include/OpenSteer%0A%09macosx/OpenSteer.xcodeproj%20src&In-Reply-To=%3C200803031031.m23AVsYL014168%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001166.html">
   <LINK REL="Next"  HREF="001168.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4096 - in dependencies/opensteer: include/OpenSteer	macosx/OpenSteer.xcodeproj src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4096%20-%20in%20dependencies/opensteer%3A%20include/OpenSteer%0A%09macosx/OpenSteer.xcodeproj%20src&In-Reply-To=%3C200803031031.m23AVsYL014168%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4096 - in dependencies/opensteer: include/OpenSteer	macosx/OpenSteer.xcodeproj src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Mon Mar  3 11:31:54 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001166.html">[Dsa-hl-svn] r4095 - in dependencies/OgreNewt:	Mac/OgreNewt.xcodeproj include/OgreNewt src
</A></li>
        <LI>Next message: <A HREF="001168.html">[Dsa-hl-svn] r4097 - modules/common/scripts/jobs	rl/trunk/engine/core rl/trunk/engine/core/include	rl/trunk/engine/core/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1167">[ date ]</a>
              <a href="thread.html#1167">[ thread ]</a>
              <a href="subject.html#1167">[ subject ]</a>
              <a href="author.html#1167">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2008-03-03 11:31:51 +0100 (Mon, 03 Mar 2008)
New Revision: 4096

Modified:
   dependencies/opensteer/include/OpenSteer/Vec3.h
   dependencies/opensteer/macosx/OpenSteer.xcodeproj/project.pbxproj
   dependencies/opensteer/src/PolylineSegmentedPathwaySegmentRadii.cpp
Log:
some fixes for MacOS X compile

Modified: dependencies/opensteer/include/OpenSteer/Vec3.h
===================================================================
--- dependencies/opensteer/include/OpenSteer/Vec3.h	2008-03-03 10:30:11 UTC (rev 4095)
+++ dependencies/opensteer/include/OpenSteer/Vec3.h	2008-03-03 10:31:51 UTC (rev 4096)
@@ -1,284 +1,288 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the &quot;Software&quot;),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-// Vector3: OpenSteer's generic type for 3d vectors
-//
-// This file defines the class Vector3, which is used throughout OpenSteer to
-// manipulate 3d geometric data.  It includes standard vector operations (like
-// vector addition, subtraction, scale, dot, cross...) and more idiosyncratic
-// utility functions.
-//
-// When integrating OpenSteer into a preexisting 3d application, it may be
-// important to use the 3d vector type of that application.  In that case Vector3
-// can be changed to inherit from the preexisting application' vector type and
-// to match the interface used by OpenSteer to the interface provided by the
-// preexisting 3d vector type.
-//
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 03-26-03 cwr: created to replace for Hiranabe-san's execellent but larger
-//               vecmath package (<A HREF="http://objectclub.esm.co.jp/vecmath/">http://objectclub.esm.co.jp/vecmath/</A>)
-//
-// ----------------------------------------------------------------------------
-
-
-#ifndef OPENSTEER_Vector3_H
-#define OPENSTEER_Vector3_H
-
-
-#include &quot;OpenSteer/Utilities.h&quot;  // for interpolate, etc.
-#include &lt;OgreVector3.h&gt;
-
-using Ogre::Vector3;
-
-namespace OpenSteer {
-
-    // ----------------------------------------------------------------------------
-    class Vec3Utils
-    {
-    public:
-        // return component of vector parallel to a unit basis vector
-        // (IMPORTANT NOTE: assumes &quot;basis&quot; has unit magnitude (length==1))
-
-        static Vector3 parallelComponent (const Vector3&amp; vector, const Vector3&amp; unitBasis)
-        {
-            const float projection = vector.dotProduct(unitBasis);
-            return unitBasis * projection;
-        }
-
-        // return component of vector perpendicular to a unit basis vector
-        // (IMPORTANT NOTE: assumes &quot;basis&quot; has unit magnitude (length==1))
-
-        static Vector3 perpendicularComponent (const Vector3&amp; vector, const Vector3&amp; unitBasis)
-        {
-            return vector - parallelComponent(vector, unitBasis);
-        }
-
-        // clamps the length of a given vector to maxLength.  If the vector is
-        // shorter its value is returned unaltered, if the vector is longer
-        // the value returned has length of maxLength and is paralle to the
-        // original input.
-
-        static Vector3 truncateLength (const Vector3&amp; vector, const float maxLength)
-        {
-            const float vecLength = vector.length();
-            if (vecLength &lt;= maxLength)
-                return vector;
-            else
-                return vector * (maxLength / vecLength);
-        }
-
-        // forces a 3d position onto the XZ (aka y=0) plane
-
-        static Vector3 setYtoZero (const Vector3&amp; vector)
-        {
-            return Vector3 (vector.x, 0, vector.z);
-        }
-
-        // rotate this vector about the global Y (up) axis by the given angle
-
-        static Vector3 rotateAboutGlobalY (const Vector3&amp; vector, float angle)
-        {
-            const float s = sinXXX (angle);
-            const float c = cosXXX (angle);
-            return Vector3 ((vector.x * c) + (vector.z * s),
-                         (vector.y),
-                         (vector.z * c) - (vector.x * s));
-        }
-
-        // version for caching sin/cos computation
-        static Vector3 rotateAboutGlobalY (const Vector3&amp; vector, float angle, float&amp; sin, float&amp; cos)
-        {
-            // is both are zero, they have not be initialized yet
-            if (sin==0 &amp;&amp; cos==0)
-            {
-                sin = sinXXX (angle);
-                cos = cosXXX (angle);
-            }
-            return Vector3 ((vector.x * cos) + (vector.z * sin),
-                         (vector.y),
-                         (vector.z * cos) - (vector.x * sin));
-        }
-
-        // if this position is outside sphere, push it back in by one diameter
-
-        static Vector3 sphericalWrapAround (const Vector3&amp; vector, const Vector3&amp; center, float radius)
-        {
-            const Vector3 offset = vector - center;
-            const float r = offset.length();
-            if (r &gt; radius)
-                return vector + ((offset/r) * radius * -2);
-            else
-                return vector;
-        }
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // scalar times vector product (&quot;float * Vector3&quot;)
-
-
-    inline Vector3 operator* (float s, const Vector3&amp; v) {return v*s;}
-
-
-	// return cross product a x b
-	inline Vector3 crossProduct(const Vector3&amp; a, const Vector3&amp; b)
-	{
-		Vector3 result((a.y * b.z) - (a.z * b.y),
-					(a.z * b.x) - (a.x * b.z),
-					(a.x * b.y) - (a.y * b.x));
-		return result;
-	}
-
-    // ----------------------------------------------------------------------------
-    // Returns a position randomly distributed inside a sphere of unit radius
-    // centered at the origin.  Orientation will be random and length will range
-    // between 0 and 1
-
-
-    Vector3 RandomVectorInUnitRadiusSphere (void);
-
-
-    // ----------------------------------------------------------------------------
-    // Returns a position randomly distributed on a disk of unit radius
-    // on the XZ (Y=0) plane, centered at the origin.  Orientation will be
-    // random and length will range between 0 and 1
-
-
-    Vector3 randomVectorOnUnitRadiusXZDisk (void);
-
-
-    // ----------------------------------------------------------------------------
-    // Returns a position randomly distributed on the surface of a sphere
-    // of unit radius centered at the origin.  Orientation will be random
-    // and length will be 1
-
-
-    inline Vector3 RandomUnitVector (void)
-    {
-        return RandomVectorInUnitRadiusSphere().normalisedCopy();
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // Returns a position randomly distributed on a circle of unit radius
-    // on the XZ (Y=0) plane, centered at the origin.  Orientation will be
-    // random and length will be 1
-
-
-    inline Vector3 RandomUnitVectorOnXZPlane (void)
-    {
-        return Vec3Utils::setYtoZero(RandomVectorInUnitRadiusSphere()).normalisedCopy();
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // used by limitMaxDeviationAngle / limitMinDeviationAngle below
-
-
-    Vector3 vecLimitDeviationAngleUtility (const bool insideOrOutside,
-                                        const Vector3&amp; source,
-                                        const float cosineOfConeAngle,
-                                        const Vector3&amp; basis);
-
-
-    // ----------------------------------------------------------------------------
-    // Enforce an upper bound on the angle by which a given arbitrary vector
-    // diviates from a given reference direction (specified by a unit basis
-    // vector).  The effect is to clip the &quot;source&quot; vector to be inside a cone
-    // defined by the basis and an angle.
-
-
-    inline Vector3 limitMaxDeviationAngle (const Vector3&amp; source,
-                                        const float cosineOfConeAngle,
-                                        const Vector3&amp; basis)
-    {
-        return vecLimitDeviationAngleUtility (true, // force source INSIDE cone
-                                              source,
-                                              cosineOfConeAngle,
-                                              basis);
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // Enforce a lower bound on the angle by which a given arbitrary vector
-    // diviates from a given reference direction (specified by a unit basis
-    // vector).  The effect is to clip the &quot;source&quot; vector to be outside a cone
-    // defined by the basis and an angle.
-
-
-    inline Vector3 limitMinDeviationAngle (const Vector3&amp; source,
-                                        const float cosineOfConeAngle,
-                                        const Vector3&amp; basis)
-    {    
-        return vecLimitDeviationAngleUtility (false, // force source OUTSIDE cone
-                                              source,
-                                              cosineOfConeAngle,
-                                              basis);
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // Returns the distance between a point and a line.  The line is defined in
-    // terms of a point on the line (&quot;lineOrigin&quot;) and a UNIT vector parallel to
-    // the line (&quot;lineUnitTangent&quot;)
-
-
-    inline float distanceFromLine (const Vector3&amp; point,
-                                   const Vector3&amp; lineOrigin,
-                                   const Vector3&amp; lineUnitTangent)
-    {
-        const Vector3 offset = point - lineOrigin;
-        const Vector3 perp = Vec3Utils::perpendicularComponent(offset, lineUnitTangent);
-        return perp.length();
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // given a vector, return a vector perpendicular to it (note that this
-    // arbitrarily selects one of the infinitude of perpendicular vectors)
-
-
-    Vector3 findPerpendicularIn3d (const Vector3&amp; direction);
-
-
-    // ----------------------------------------------------------------------------
-    // candidates for global utility functions
-    //
-    // dot
-    // cross
-    // length
-    // distance
-    // normalized
-
-    
-} // namespace OpenSteer
-    
-
-// ----------------------------------------------------------------------------
-#endif // OPENSTEER_Vector3_H
+// ----------------------------------------------------------------------------
+//
+//
+// OpenSteer -- Steering Behaviors for Autonomous Characters
+//
+// Copyright (c) 2002-2005, Sony Computer Entertainment America
+// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+//
+// Permission is hereby granted, free of charge, to any person obtaining a
+// copy of this software and associated documentation files (the &quot;Software&quot;),
+// to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense,
+// and/or sell copies of the Software, and to permit persons to whom the
+// Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+//
+//
+// ----------------------------------------------------------------------------
+//
+// Vector3: OpenSteer's generic type for 3d vectors
+//
+// This file defines the class Vector3, which is used throughout OpenSteer to
+// manipulate 3d geometric data.  It includes standard vector operations (like
+// vector addition, subtraction, scale, dot, cross...) and more idiosyncratic
+// utility functions.
+//
+// When integrating OpenSteer into a preexisting 3d application, it may be
+// important to use the 3d vector type of that application.  In that case Vector3
+// can be changed to inherit from the preexisting application' vector type and
+// to match the interface used by OpenSteer to the interface provided by the
+// preexisting 3d vector type.
+//
+// 10-04-04 bk:  put everything into the OpenSteer namespace
+// 03-26-03 cwr: created to replace for Hiranabe-san's execellent but larger
+//               vecmath package (<A HREF="http://objectclub.esm.co.jp/vecmath/">http://objectclub.esm.co.jp/vecmath/</A>)
+//
+// ----------------------------------------------------------------------------
+
+
+#ifndef OPENSTEER_Vector3_H
+#define OPENSTEER_Vector3_H
+
+
+#include &quot;OpenSteer/Utilities.h&quot;  // for interpolate, etc.
+#ifdef __APPLE__
+    #include &lt;Ogre/Ogre.h&gt;
+#else
+    #include &lt;Ogre.h&gt;
+#endif
+
+using Ogre::Vector3;
+
+namespace OpenSteer {
+
+    // ----------------------------------------------------------------------------
+    class Vec3Utils
+    {
+    public:
+        // return component of vector parallel to a unit basis vector
+        // (IMPORTANT NOTE: assumes &quot;basis&quot; has unit magnitude (length==1))
+
+        static Vector3 parallelComponent (const Vector3&amp; vector, const Vector3&amp; unitBasis)
+        {
+            const float projection = vector.dotProduct(unitBasis);
+            return unitBasis * projection;
+        }
+
+        // return component of vector perpendicular to a unit basis vector
+        // (IMPORTANT NOTE: assumes &quot;basis&quot; has unit magnitude (length==1))
+
+        static Vector3 perpendicularComponent (const Vector3&amp; vector, const Vector3&amp; unitBasis)
+        {
+            return vector - parallelComponent(vector, unitBasis);
+        }
+
+        // clamps the length of a given vector to maxLength.  If the vector is
+        // shorter its value is returned unaltered, if the vector is longer
+        // the value returned has length of maxLength and is paralle to the
+        // original input.
+
+        static Vector3 truncateLength (const Vector3&amp; vector, const float maxLength)
+        {
+            const float vecLength = vector.length();
+            if (vecLength &lt;= maxLength)
+                return vector;
+            else
+                return vector * (maxLength / vecLength);
+        }
+
+        // forces a 3d position onto the XZ (aka y=0) plane
+
+        static Vector3 setYtoZero (const Vector3&amp; vector)
+        {
+            return Vector3 (vector.x, 0, vector.z);
+        }
+
+        // rotate this vector about the global Y (up) axis by the given angle
+
+        static Vector3 rotateAboutGlobalY (const Vector3&amp; vector, float angle)
+        {
+            const float s = sinXXX (angle);
+            const float c = cosXXX (angle);
+            return Vector3 ((vector.x * c) + (vector.z * s),
+                         (vector.y),
+                         (vector.z * c) - (vector.x * s));
+        }
+
+        // version for caching sin/cos computation
+        static Vector3 rotateAboutGlobalY (const Vector3&amp; vector, float angle, float&amp; sin, float&amp; cos)
+        {
+            // is both are zero, they have not be initialized yet
+            if (sin==0 &amp;&amp; cos==0)
+            {
+                sin = sinXXX (angle);
+                cos = cosXXX (angle);
+            }
+            return Vector3 ((vector.x * cos) + (vector.z * sin),
+                         (vector.y),
+                         (vector.z * cos) - (vector.x * sin));
+        }
+
+        // if this position is outside sphere, push it back in by one diameter
+
+        static Vector3 sphericalWrapAround (const Vector3&amp; vector, const Vector3&amp; center, float radius)
+        {
+            const Vector3 offset = vector - center;
+            const float r = offset.length();
+            if (r &gt; radius)
+                return vector + ((offset/r) * radius * -2);
+            else
+                return vector;
+        }
+    };
+
+
+    // ----------------------------------------------------------------------------
+    // scalar times vector product (&quot;float * Vector3&quot;)
+
+
+    inline Vector3 operator* (float s, const Vector3&amp; v) {return v*s;}
+
+
+	// return cross product a x b
+	inline Vector3 crossProduct(const Vector3&amp; a, const Vector3&amp; b)
+	{
+		Vector3 result((a.y * b.z) - (a.z * b.y),
+					(a.z * b.x) - (a.x * b.z),
+					(a.x * b.y) - (a.y * b.x));
+		return result;
+	}
+
+    // ----------------------------------------------------------------------------
+    // Returns a position randomly distributed inside a sphere of unit radius
+    // centered at the origin.  Orientation will be random and length will range
+    // between 0 and 1
+
+
+    Vector3 RandomVectorInUnitRadiusSphere (void);
+
+
+    // ----------------------------------------------------------------------------
+    // Returns a position randomly distributed on a disk of unit radius
+    // on the XZ (Y=0) plane, centered at the origin.  Orientation will be
+    // random and length will range between 0 and 1
+
+
+    Vector3 randomVectorOnUnitRadiusXZDisk (void);
+
+
+    // ----------------------------------------------------------------------------
+    // Returns a position randomly distributed on the surface of a sphere
+    // of unit radius centered at the origin.  Orientation will be random
+    // and length will be 1
+
+
+    inline Vector3 RandomUnitVector (void)
+    {
+        return RandomVectorInUnitRadiusSphere().normalisedCopy();
+    }
+
+
+    // ----------------------------------------------------------------------------
+    // Returns a position randomly distributed on a circle of unit radius
+    // on the XZ (Y=0) plane, centered at the origin.  Orientation will be
+    // random and length will be 1
+
+
+    inline Vector3 RandomUnitVectorOnXZPlane (void)
+    {
+        return Vec3Utils::setYtoZero(RandomVectorInUnitRadiusSphere()).normalisedCopy();
+    }
+
+
+    // ----------------------------------------------------------------------------
+    // used by limitMaxDeviationAngle / limitMinDeviationAngle below
+
+
+    Vector3 vecLimitDeviationAngleUtility (const bool insideOrOutside,
+                                        const Vector3&amp; source,
+                                        const float cosineOfConeAngle,
+                                        const Vector3&amp; basis);
+
+
+    // ----------------------------------------------------------------------------
+    // Enforce an upper bound on the angle by which a given arbitrary vector
+    // diviates from a given reference direction (specified by a unit basis
+    // vector).  The effect is to clip the &quot;source&quot; vector to be inside a cone
+    // defined by the basis and an angle.
+
+
+    inline Vector3 limitMaxDeviationAngle (const Vector3&amp; source,
+                                        const float cosineOfConeAngle,
+                                        const Vector3&amp; basis)
+    {
+        return vecLimitDeviationAngleUtility (true, // force source INSIDE cone
+                                              source,
+                                              cosineOfConeAngle,
+                                              basis);
+    }
+
+
+    // ----------------------------------------------------------------------------
+    // Enforce a lower bound on the angle by which a given arbitrary vector
+    // diviates from a given reference direction (specified by a unit basis
+    // vector).  The effect is to clip the &quot;source&quot; vector to be outside a cone
+    // defined by the basis and an angle.
+
+
+    inline Vector3 limitMinDeviationAngle (const Vector3&amp; source,
+                                        const float cosineOfConeAngle,
+                                        const Vector3&amp; basis)
+    {    
+        return vecLimitDeviationAngleUtility (false, // force source OUTSIDE cone
+                                              source,
+                                              cosineOfConeAngle,
+                                              basis);
+    }
+
+
+    // ----------------------------------------------------------------------------
+    // Returns the distance between a point and a line.  The line is defined in
+    // terms of a point on the line (&quot;lineOrigin&quot;) and a UNIT vector parallel to
+    // the line (&quot;lineUnitTangent&quot;)
+
+
+    inline float distanceFromLine (const Vector3&amp; point,
+                                   const Vector3&amp; lineOrigin,
+                                   const Vector3&amp; lineUnitTangent)
+    {
+        const Vector3 offset = point - lineOrigin;
+        const Vector3 perp = Vec3Utils::perpendicularComponent(offset, lineUnitTangent);
+        return perp.length();
+    }
+
+
+    // ----------------------------------------------------------------------------
+    // given a vector, return a vector perpendicular to it (note that this
+    // arbitrarily selects one of the infinitude of perpendicular vectors)
+
+
+    Vector3 findPerpendicularIn3d (const Vector3&amp; direction);
+
+
+    // ----------------------------------------------------------------------------
+    // candidates for global utility functions
+    //
+    // dot
+    // cross
+    // length
+    // distance
+    // normalized
+
+    
+} // namespace OpenSteer
+    
+
+// ----------------------------------------------------------------------------
+#endif // OPENSTEER_Vector3_H

Modified: dependencies/opensteer/macosx/OpenSteer.xcodeproj/project.pbxproj
===================================================================
--- dependencies/opensteer/macosx/OpenSteer.xcodeproj/project.pbxproj	2008-03-03 10:30:11 UTC (rev 4095)
+++ dependencies/opensteer/macosx/OpenSteer.xcodeproj/project.pbxproj	2008-03-03 10:31:51 UTC (rev 4096)
@@ -78,6 +78,8 @@
 		4425B4800B7B76740067899D /* PolylineSegmentedPathwaySingleRadiusTest.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4425B47C0B7B76740067899D /* PolylineSegmentedPathwaySingleRadiusTest.cpp */; };
 		4425B4810B7B76740067899D /* SharedPointerTest.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4425B47D0B7B76740067899D /* SharedPointerTest.cpp */; };
 		4425B4820B7B76740067899D /* TestMain.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4425B47E0B7B76740067899D /* TestMain.cpp */; };
+		48B770E90D57A418000A3B97 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 483999EB0D5495EE00B27496 /* Ogre.framework */; };
+		48B770EA0D57A41B000A3B97 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 483999EB0D5495EE00B27496 /* Ogre.framework */; };
 		8D11072A0486CEB800E47090 /* MainMenu.nib in Resources */ = {isa = PBXBuildFile; fileRef = 29B97318FDCFA39411CA2CEA /* MainMenu.nib */; };
 		8D11072B0486CEB800E47090 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = 089C165CFE840E0CC02AAC07 /* InfoPlist.strings */; };
 /* End PBXBuildFile section */
@@ -159,11 +161,12 @@
 		4425B47C0B7B76740067899D /* PolylineSegmentedPathwaySingleRadiusTest.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PolylineSegmentedPathwaySingleRadiusTest.cpp; path = ../test/PolylineSegmentedPathwaySingleRadiusTest.cpp; sourceTree = SOURCE_ROOT; };
 		4425B47D0B7B76740067899D /* SharedPointerTest.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SharedPointerTest.cpp; path = ../test/SharedPointerTest.cpp; sourceTree = SOURCE_ROOT; };
 		4425B47E0B7B76740067899D /* TestMain.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TestMain.cpp; path = ../test/TestMain.cpp; sourceTree = SOURCE_ROOT; };
+		483999EB0D5495EE00B27496 /* Ogre.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Ogre.framework; path = /Library/Frameworks/Ogre.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		841E3BFC0736BF4400E3AD2C /* Obstacle.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = Obstacle.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		84AD12AD070E221100559513 /* OpenSteerDemo.h */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.c.h; path = OpenSteerDemo.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		84AD12B1070E224000559513 /* OpenSteerDemo.cpp */ = {isa = PBXFileReference; fileEncoding = 30; lastKnownFileType = sourcecode.cpp.cpp; path = OpenSteerDemo.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		8D1107310486CEB800E47090 /* OpenSteerDemo-Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xml; path = &quot;OpenSteerDemo-Info.plist&quot;; sourceTree = &quot;&lt;group&gt;&quot;; };
-		8D1107320486CEB800E47090 /* OpenSteerDemo.app */ = {isa = PBXFileReference; includeInIndex = 0; lastKnownFileType = wrapper.application; path = OpenSteerDemo.app; sourceTree = BUILT_PRODUCTS_DIR; };
+		8D1107320486CEB800E47090 /* OpenSteerDemo.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = OpenSteerDemo.app; sourceTree = BUILT_PRODUCTS_DIR; };
 /* End PBXFileReference section */
 
 /* Begin PBXFrameworksBuildPhase section */
@@ -179,6 +182,14 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		48B770DF0D57A377000A3B97 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				48B770E90D57A418000A3B97 /* Ogre.framework in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 		8D11072E0486CEB800E47090 /* Frameworks */ = {
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
@@ -186,6 +197,7 @@
 				4425B41F0B7B681A0067899D /* OpenSteer.framework in Frameworks */,
 				32FFF49306E90A9F00E1D8A3 /* GLUT.framework in Frameworks */,
 				32FFF49406E90A9F00E1D8A3 /* OpenGL.framework in Frameworks */,
+				48B770EA0D57A41B000A3B97 /* Ogre.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -230,6 +242,7 @@
 		29B97323FDCFA39411CA2CEA /* Frameworks */ = {
 			isa = PBXGroup;
 			children = (
+				483999EB0D5495EE00B27496 /* Ogre.framework */,
 				4425B41C0B7B67F90067899D /* Carbon.framework */,
 				3224E47808435D8C00C13D97 /* libcppunit-1.10.2.0.0.dylib */,
 				32FFF49106E90A9F00E1D8A3 /* GLUT.framework */,
@@ -429,6 +442,7 @@
 			buildPhases = (
 				4425B3E10B7B61DB0067899D /* Headers */,
 				4425B3E30B7B61DB0067899D /* Sources */,
+				48B770DF0D57A377000A3B97 /* Frameworks */,
 			);
 			buildRules = (
 			);
@@ -463,9 +477,11 @@
 		29B97313FDCFA39411CA2CEA /* Project object */ = {
 			isa = PBXProject;
 			buildConfigurationList = 3219D30B0855BC5800EB7908 /* Build configuration list for PBXProject &quot;OpenSteer&quot; */;
+			compatibilityVersion = &quot;Xcode 2.4&quot;;
 			hasScannedForEncodings = 1;
 			mainGroup = 29B97314FDCFA39411CA2CEA /* opensteer */;
 			projectDirPath = &quot;&quot;;
+			projectRoot = &quot;&quot;;
 			targets = (
 				4425B3E50B7B61DB0067899D /* OpenSteer Framework */,
 				8D1107260486CEB800E47090 /* OpenSteerDemo */,
@@ -755,6 +771,7 @@
 					ppc,
 					i386,
 				);
+				FRAMEWORK_SEARCH_PATHS = &quot;&quot;;
 				FRAMEWORK_VERSION = 0.8;
 				GCC_ENABLE_FIX_AND_CONTINUE = NO;
 				GCC_MODEL_TUNING = G4;
@@ -849,10 +866,7 @@
 		4425B3E90B7B61DB0067899D /* Development */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
-				ARCHS = (
-					ppc,
-					i386,
-				);
+				ARCHS = i386;
 				COPY_PHASE_STRIP = NO;
 				DYLIB_COMPATIBILITY_VERSION = 2;
 				DYLIB_CURRENT_VERSION = 2;
@@ -871,7 +885,10 @@
 				HEADER_SEARCH_PATHS = ../include;
 				INFOPLIST_FILE = Info.plist;
 				INSTALL_PATH = &quot;$(HOME)/Library/Frameworks&quot;;
-				OTHER_LDFLAGS = &quot;&quot;;
+				OTHER_LDFLAGS = (
+					&quot;-framework&quot;,
+					Ogre,
+				);
 				PREBINDING = NO;
 				PRODUCT_NAME = OpenSteer;
 				USER_HEADER_SEARCH_PATHS = ../include;

Modified: dependencies/opensteer/src/PolylineSegmentedPathwaySegmentRadii.cpp
===================================================================
--- dependencies/opensteer/src/PolylineSegmentedPathwaySegmentRadii.cpp	2008-03-03 10:30:11 UTC (rev 4095)
+++ dependencies/opensteer/src/PolylineSegmentedPathwaySegmentRadii.cpp	2008-03-03 10:31:51 UTC (rev 4096)
@@ -1,390 +1,390 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
- */
-#include &quot;OpenSteer/PolylineSegmentedPathwaySegmentRadii.h&quot;
-
-
-// Include std::swap, std::copy, std::find_if
-#include &lt;algorithm&gt;
-
-// Include std::less, std::bind2nd
-#include &lt;functional&gt;
-
-
-// Include OpenSteer::mapPointToPathway, OpenSteer::mapDistanceToPointOnPathCenterLine
-#include &quot;OpenSteer/QueryPathAlike.h&quot;
-
-// Include OpenSteer::PointToPathMapping, OpenSteer::PathDistanceToPointMapping, OpenSteer::PointToPathDistanceMapping
-#include &quot;OpenSteer/QueryPathAlikeMappings.h&quot;
-
-// Include OpenSteer::HasSegmentRadii
-#include &quot;OpenSteer/QueryPathAlikeUtilities.h&quot;
-
-// Include OpenSteer::shrinkToFit
-#include &quot;OpenSteer/Utilities.h&quot;
-
-// Include OpenSteer::size_t
-#include &quot;OpenSteer/StandardTypes.h&quot;
-
-// Include OPENSTEER_UNUSED_PARAMETER
-#include &quot;OpenSteer/UnusedParameter.h&quot;
-
-
-namespace {
-    
-    typedef OpenSteer::size_t size_type;
-    
-    /**
-     * Calculates the number of radii needed for the given path alike.
-     * Comparable to calculating the number of segments based on the number
-     * of points and if the pathway is closed or not.
-     */
-    size_type radiiCount( size_type numOfPoints, bool closedCycle ) {
-        return numOfPoints - ( closedCycle ? 0 : 1 );
-    }
-    
-    
-    
-    /**
-     * Returns @c true if all radii in the range @a first to @a last (excluding
-     * @a last) are greater or equal to @c 0, @c false otherwise.
-     */
-    template&lt; typename Iterator &gt;
-        bool allRadiiNonNegative( Iterator first, Iterator last ) {
-            return std::find_if( first, last, std::bind2nd( std::less&lt; float &gt;(), 0.0f ) ) == last;
-        }
-    
-    /**
-     * Returns @c true if all radii are greater or equal to @c 0, @c false
-     * otherwise.
-     */
-    bool allRadiiNonNegative( std::vector&lt; float &gt; const&amp; radii ) {
-        return allRadiiNonNegative( radii.begin(), radii.end() );
-    }
-    
-
-    
-    
-} // namespace anonymous 
-
-
-
-
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::PolylineSegmentedPathwaySegmentRadii()
-    : path_(), segmentRadii_( 0 )
-{
-    
-}
-
-
-
-
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::PolylineSegmentedPathwaySegmentRadii( size_type numOfPoints,
-                                                                                       Vec3 const points[],
-                                                                                       float const radii[],
-                                                                                       bool closedCycle )
-    : path_( numOfPoints, points, closedCycle ), segmentRadii_( radii, radii + radiiCount( numOfPoints, closedCycle ) )
-{
-    assert( allRadiiNonNegative( segmentRadii_ ) &amp;&amp; &quot;All radii must be positive or zero.&quot; );
-}
-
-
-
-
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::PolylineSegmentedPathwaySegmentRadii( PolylineSegmentedPathwaySegmentRadii const&amp; other )
-    : SegmentedPathway( other ), path_( other.path_ ), segmentRadii_( other.segmentRadii_ )
-{
-    assert( allRadiiNonNegative( segmentRadii_ ) &amp;&amp; &quot;All radii must be positive or zero.&quot; );    
-}
-
-
-
-
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::~PolylineSegmentedPathwaySegmentRadii()
-{
-    // Nothing to do.
-}
-
-
-
-
-
-OpenSteer::PolylineSegmentedPathwaySegmentRadii&amp; 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::operator=( PolylineSegmentedPathwaySegmentRadii other )
-{
-    swap( other );
-    return *this;
-}
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::swap( PolylineSegmentedPathwaySegmentRadii&amp; other )
-{
-    path_.swap( other.path_ );
-    segmentRadii_.swap( other.segmentRadii_ );
-}
-
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::movePoints( size_type startIndex,
-                                                             size_type numOfPoints,
-                                                             Vec3 const points[] )
-{
-    path_.movePoints( startIndex, numOfPoints, points );
-}
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::setPathway( size_type numOfPoints,
-                                                             Vec3 const points[],
-                                                             float const radii[],
-                                                             bool closedCycle )
-{
-    assert( allRadiiNonNegative( radii, radii + radiiCount( numOfPoints, closedCycle ) ) &amp;&amp; &quot;All radii must be positive or zero.&quot; );
-    path_.setPath( numOfPoints, points, closedCycle );
-    segmentRadii_.assign( radii, radii + radiiCount( numOfPoints, closedCycle ) );
-    shrinkToFit( segmentRadii_ );
-    
-}
-
-
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::segmentRadius( size_type segmentIndex ) const
-{
-    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
-    return segmentRadii_[ segmentIndex ];
-}
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::setSegmentRadius( size_type segmentIndex, float r )
-{
-    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
-    assert( 0.0f &lt;= r &amp;&amp; &quot;No negative radii allowed.&quot; );
-    
-    segmentRadii_[ segmentIndex ] = r;
-}
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::setSegmentRadii( size_type startIndex,
-                                                                  size_type numOfRadii,
-                                                                  float const radii[] )
-{
-    assert( startIndex &lt; segmentCount() &amp;&amp; &quot;startIndex out of range.&quot; );
-    assert( startIndex + numOfRadii &lt;= segmentCount() &amp;&amp; &quot;Too many radii to set.&quot; );
-    assert( allRadiiNonNegative( radii, radii + numOfRadii ) &amp;&amp; &quot;All radii must be positive or zero.&quot; );
-    
-    std::copy( radii, radii + numOfRadii, segmentRadii_.begin() + startIndex );
-}
-
-
-
-bool
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::isValid() const 
-{
-    return pointCount() &gt; 1;
-}
-
-
-
-OpenSteer::Vec3 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapPointToPath (const Vec3&amp; point,
-                                                                 Vec3&amp; tangent,
-                                                                 float&amp; outside) const
-{
-    PointToPathMapping mapping;
-    mapPointToPathAlike( *this, point, mapping );
-    tangent = mapping.tangent;
-    outside = mapping.distancePointToPath;
-    return mapping.pointOnPathCenterLine;    
-}
-
-
-
-OpenSteer::Vec3 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapPathDistanceToPoint (float pathDistance) const
-{
-    PathDistanceToPointMapping mapping;
-    mapDistanceToPathAlike( *this, pathDistance, mapping );
-    return mapping.pointOnPathCenterLine;    
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapPointToPathDistance (const Vec3&amp; point) const
-{
-    PointToPathDistanceMapping mapping;
-    mapPointToPathAlike( *this, point, mapping );
-    return mapping.distanceOnPath;    
-}
-
-
-
-bool 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::isCyclic() const
-{
-    return path_.isCyclic();
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::length() const
-{
-    return path_.length();
-}
-
-
-
-OpenSteer::SegmentedPathway::size_type 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::pointCount() const 
-{
-    return path_.pointCount();
-}
-
-
-
-OpenSteer::Vec3 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::point( size_type pointIndex ) const
-{
-    return path_.point( pointIndex );
-}
-
-
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::size_type 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::segmentCount() const
-{
-    return path_.segmentCount();
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::segmentLength( size_type segmentIndex ) const
-{
-    return path_.segmentLength( segmentIndex );
-}
-
-
-
-OpenSteer::Vec3 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::segmentStart( size_type segmentIndex ) const
-{
-    return path_.segmentStart( segmentIndex );
-}
-
-
-
-OpenSteer::Vec3 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::segmentEnd( size_type segmentIndex ) const
-{
-    return path_.segmentEnd( segmentIndex );
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapPointToSegmentDistance( size_type segmentIndex, 
-                                                                            Vec3 const&amp; point ) const
-{
-    return path_.mapPointToSegmentDistance( segmentIndex, point );
-}
-
-
-
-OpenSteer::Vec3 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapSegmentDistanceToPoint( size_type segmentIndex, 
-                                                                            float segmentDistance ) const
-{
-    return path_.mapSegmentDistanceToPoint( segmentIndex, segmentDistance );
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapSegmentDistanceToRadius( size_type segmentIndex, 
-                                                                             float distanceOnSegment ) const
-{
-    OPENSTEER_UNUSED_PARAMETER(distanceOnSegment);
-    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
-    return segmentRadii_[ segmentIndex ];
-}
-
-
-
-OpenSteer::Vec3 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapSegmentDistanceToTangent( size_type segmentIndex, 
-                                                                              float segmentDistance ) const
-{
-    return path_.mapSegmentDistanceToTangent( segmentIndex, segmentDistance );
-}
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
-                                                                                               float distance,
-                                                                                               Vec3&amp; pointOnPath,
-                                                                                               Vec3&amp; tangent,
-                                                                                               float&amp; radius ) const
-{
-    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
-    path_.mapDistanceToSegmentPointAndTangent( segmentIndex, distance, pointOnPath, tangent );
-    radius = segmentRadii_[ segmentIndex ];
-}
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
-                                                                                                       Vec3 const&amp; point,
-                                                                                                       float&amp; distance,
-                                                                                                       Vec3&amp; pointOnPath,
-                                                                                                       Vec3&amp; tangent,
-                                                                                                       float&amp; radius) const
-{
-    path_.mapPointToSegmentDistanceAndPointAndTangent( segmentIndex, point, distance, pointOnPath, tangent );
-    radius = segmentRadii_[ segmentIndex ];
-}
-
-
+/**
+ * OpenSteer -- Steering Behaviors for Autonomous Characters
+ *
+ * Copyright (c) 2002-2005, Sony Computer Entertainment America
+ * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the &quot;Software&quot;),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ *
+ * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
+ */
+#include &quot;OpenSteer/PolylineSegmentedPathwaySegmentRadii.h&quot;
+
+
+// Include std::swap, std::copy, std::find_if
+#include &lt;algorithm&gt;
+
+// Include std::less, std::bind2nd
+#include &lt;functional&gt;
+
+
+// Include OpenSteer::mapPointToPathway, OpenSteer::mapDistanceToPointOnPathCenterLine
+#include &quot;OpenSteer/QueryPathAlike.h&quot;
+
+// Include OpenSteer::PointToPathMapping, OpenSteer::PathDistanceToPointMapping, OpenSteer::PointToPathDistanceMapping
+#include &quot;OpenSteer/QueryPathAlikeMappings.h&quot;
+
+// Include OpenSteer::HasSegmentRadii
+#include &quot;OpenSteer/QueryPathAlikeUtilities.h&quot;
+
+// Include OpenSteer::shrinkToFit
+#include &quot;OpenSteer/Utilities.h&quot;
+
+// Include OpenSteer::size_t
+#include &quot;OpenSteer/StandardTypes.h&quot;
+
+// Include OPENSTEER_UNUSED_PARAMETER
+#include &quot;OpenSteer/UnusedParameter.h&quot;
+
+
+namespace {
+    
+    typedef OpenSteer::size_t size_type;
+    
+    /**
+     * Calculates the number of radii needed for the given path alike.
+     * Comparable to calculating the number of segments based on the number
+     * of points and if the pathway is closed or not.
+     */
+    size_type radiiCount( size_type numOfPoints, bool closedCycle ) {
+        return numOfPoints - ( closedCycle ? 0 : 1 );
+    }
+    
+    
+    
+    /**
+     * Returns @c true if all radii in the range @a first to @a last (excluding
+     * @a last) are greater or equal to @c 0, @c false otherwise.
+     */
+    template&lt; typename Iterator &gt;
+        bool allRadiiNonNegative( Iterator first, Iterator last ) {
+            return std::find_if( first, last, std::bind2nd( std::less&lt; float &gt;(), 0.0f ) ) == last;
+        }
+    
+    /**
+     * Returns @c true if all radii are greater or equal to @c 0, @c false
+     * otherwise.
+     */
+    bool allRadiiNonNegative( std::vector&lt; float &gt; const&amp; radii ) {
+        return allRadiiNonNegative( radii.begin(), radii.end() );
+    }
+    
+
+    
+    
+} // namespace anonymous 
+
+
+
+
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::PolylineSegmentedPathwaySegmentRadii()
+    : path_(), segmentRadii_( 0 )
+{
+    
+}
+
+
+
+
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::PolylineSegmentedPathwaySegmentRadii( size_type numOfPoints,
+                                                                                       Ogre::Vector3 const points[],
+                                                                                       float const radii[],
+                                                                                       bool closedCycle )
+    : path_( numOfPoints, points, closedCycle ), segmentRadii_( radii, radii + radiiCount( numOfPoints, closedCycle ) )
+{
+    assert( allRadiiNonNegative( segmentRadii_ ) &amp;&amp; &quot;All radii must be positive or zero.&quot; );
+}
+
+
+
+
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::PolylineSegmentedPathwaySegmentRadii( PolylineSegmentedPathwaySegmentRadii const&amp; other )
+    : SegmentedPathway( other ), path_( other.path_ ), segmentRadii_( other.segmentRadii_ )
+{
+    assert( allRadiiNonNegative( segmentRadii_ ) &amp;&amp; &quot;All radii must be positive or zero.&quot; );    
+}
+
+
+
+
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::~PolylineSegmentedPathwaySegmentRadii()
+{
+    // Nothing to do.
+}
+
+
+
+
+
+OpenSteer::PolylineSegmentedPathwaySegmentRadii&amp; 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::operator=( PolylineSegmentedPathwaySegmentRadii other )
+{
+    swap( other );
+    return *this;
+}
+
+
+
+
+void 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::swap( PolylineSegmentedPathwaySegmentRadii&amp; other )
+{
+    path_.swap( other.path_ );
+    segmentRadii_.swap( other.segmentRadii_ );
+}
+
+
+
+
+
+void 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::movePoints( size_type startIndex,
+                                                             size_type numOfPoints,
+                                                             Ogre::Vector3 const points[] )
+{
+    path_.movePoints( startIndex, numOfPoints, points );
+}
+
+
+
+
+void 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::setPathway( size_type numOfPoints,
+                                                             Ogre::Vector3 const points[],
+                                                             float const radii[],
+                                                             bool closedCycle )
+{
+    assert( allRadiiNonNegative( radii, radii + radiiCount( numOfPoints, closedCycle ) ) &amp;&amp; &quot;All radii must be positive or zero.&quot; );
+    path_.setPath( numOfPoints, points, closedCycle );
+    segmentRadii_.assign( radii, radii + radiiCount( numOfPoints, closedCycle ) );
+    shrinkToFit( segmentRadii_ );
+    
+}
+
+
+
+
+
+float 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::segmentRadius( size_type segmentIndex ) const
+{
+    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
+    return segmentRadii_[ segmentIndex ];
+}
+
+
+
+void 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::setSegmentRadius( size_type segmentIndex, float r )
+{
+    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
+    assert( 0.0f &lt;= r &amp;&amp; &quot;No negative radii allowed.&quot; );
+    
+    segmentRadii_[ segmentIndex ] = r;
+}
+
+
+
+void 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::setSegmentRadii( size_type startIndex,
+                                                                  size_type numOfRadii,
+                                                                  float const radii[] )
+{
+    assert( startIndex &lt; segmentCount() &amp;&amp; &quot;startIndex out of range.&quot; );
+    assert( startIndex + numOfRadii &lt;= segmentCount() &amp;&amp; &quot;Too many radii to set.&quot; );
+    assert( allRadiiNonNegative( radii, radii + numOfRadii ) &amp;&amp; &quot;All radii must be positive or zero.&quot; );
+    
+    std::copy( radii, radii + numOfRadii, segmentRadii_.begin() + startIndex );
+}
+
+
+
+bool
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::isValid() const 
+{
+    return pointCount() &gt; 1;
+}
+
+
+
+Ogre::Vector3 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapPointToPath (const Ogre::Vector3&amp; point,
+                                                                 Ogre::Vector3&amp; tangent,
+                                                                 float&amp; outside) const
+{
+    PointToPathMapping mapping;
+    mapPointToPathAlike( *this, point, mapping );
+    tangent = mapping.tangent;
+    outside = mapping.distancePointToPath;
+    return mapping.pointOnPathCenterLine;    
+}
+
+
+
+Ogre::Vector3 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapPathDistanceToPoint (float pathDistance) const
+{
+    PathDistanceToPointMapping mapping;
+    mapDistanceToPathAlike( *this, pathDistance, mapping );
+    return mapping.pointOnPathCenterLine;    
+}
+
+
+
+float 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapPointToPathDistance (const Ogre::Vector3&amp; point) const
+{
+    PointToPathDistanceMapping mapping;
+    mapPointToPathAlike( *this, point, mapping );
+    return mapping.distanceOnPath;    
+}
+
+
+
+bool 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::isCyclic() const
+{
+    return path_.isCyclic();
+}
+
+
+
+float 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::length() const
+{
+    return path_.length();
+}
+
+
+
+OpenSteer::SegmentedPathway::size_type 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::pointCount() const 
+{
+    return path_.pointCount();
+}
+
+
+
+Ogre::Vector3 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::point( size_type pointIndex ) const
+{
+    return path_.point( pointIndex );
+}
+
+
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::size_type 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::segmentCount() const
+{
+    return path_.segmentCount();
+}
+
+
+
+float 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::segmentLength( size_type segmentIndex ) const
+{
+    return path_.segmentLength( segmentIndex );
+}
+
+
+
+Ogre::Vector3 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::segmentStart( size_type segmentIndex ) const
+{
+    return path_.segmentStart( segmentIndex );
+}
+
+
+
+Ogre::Vector3 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::segmentEnd( size_type segmentIndex ) const
+{
+    return path_.segmentEnd( segmentIndex );
+}
+
+
+
+float 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapPointToSegmentDistance( size_type segmentIndex, 
+                                                                            Ogre::Vector3 const&amp; point ) const
+{
+    return path_.mapPointToSegmentDistance( segmentIndex, point );
+}
+
+
+
+Ogre::Vector3 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapSegmentDistanceToPoint( size_type segmentIndex, 
+                                                                            float segmentDistance ) const
+{
+    return path_.mapSegmentDistanceToPoint( segmentIndex, segmentDistance );
+}
+
+
+
+float 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapSegmentDistanceToRadius( size_type segmentIndex, 
+                                                                             float distanceOnSegment ) const
+{
+    OPENSTEER_UNUSED_PARAMETER(distanceOnSegment);
+    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
+    return segmentRadii_[ segmentIndex ];
+}
+
+
+
+Ogre::Vector3 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapSegmentDistanceToTangent( size_type segmentIndex, 
+                                                                              float segmentDistance ) const
+{
+    return path_.mapSegmentDistanceToTangent( segmentIndex, segmentDistance );
+}
+
+
+
+
+void 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
+                                                                                               float distance,
+                                                                                               Ogre::Vector3&amp; pointOnPath,
+                                                                                               Ogre::Vector3&amp; tangent,
+                                                                                               float&amp; radius ) const
+{
+    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
+    path_.mapDistanceToSegmentPointAndTangent( segmentIndex, distance, pointOnPath, tangent );
+    radius = segmentRadii_[ segmentIndex ];
+}
+
+
+
+
+void 
+OpenSteer::PolylineSegmentedPathwaySegmentRadii::mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
+                                                                                                       Ogre::Vector3 const&amp; point,
+                                                                                                       float&amp; distance,
+                                                                                                       Ogre::Vector3&amp; pointOnPath,
+                                                                                                       Ogre::Vector3&amp; tangent,
+                                                                                                       float&amp; radius) const
+{
+    path_.mapPointToSegmentDistanceAndPointAndTangent( segmentIndex, point, distance, pointOnPath, tangent );
+    radius = segmentRadii_[ segmentIndex ];
+}
+
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001166.html">[Dsa-hl-svn] r4095 - in dependencies/OgreNewt:	Mac/OgreNewt.xcodeproj include/OgreNewt src
</A></li>
	<LI>Next message: <A HREF="001168.html">[Dsa-hl-svn] r4097 - modules/common/scripts/jobs	rl/trunk/engine/core rl/trunk/engine/core/include	rl/trunk/engine/core/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1167">[ date ]</a>
              <a href="thread.html#1167">[ thread ]</a>
              <a href="subject.html#1167">[ subject ]</a>
              <a href="author.html#1167">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
