<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4301 - in rl/trunk/engine: ai/include ai/src	common/include common/src core/include core/src rules/include	rules/src script/include script/src script/swig ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-March/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4301%20-%20in%20rl/trunk/engine%3A%20ai/include%20ai/src%0A%09common/include%20common/src%20core/include%20core/src%20rules/include%0A%09rules/src%20script/include%20script/src%20script/swig%20ui/src&In-Reply-To=%3C200803201941.m2KJfag7011503%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001371.html">
   <LINK REL="Next"  HREF="001373.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4301 - in rl/trunk/engine: ai/include ai/src	common/include common/src core/include core/src rules/include	rules/src script/include script/src script/swig ui/src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4301%20-%20in%20rl/trunk/engine%3A%20ai/include%20ai/src%0A%09common/include%20common/src%20core/include%20core/src%20rules/include%0A%09rules/src%20script/include%20script/src%20script/swig%20ui/src&In-Reply-To=%3C200803201941.m2KJfag7011503%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4301 - in rl/trunk/engine: ai/include ai/src	common/include common/src core/include core/src rules/include	rules/src script/include script/src script/swig ui/src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Thu Mar 20 20:41:36 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001371.html">[Dsa-hl-svn] r4300 - in rl/trunk: Mac/Rastullah.xcodeproj	engine/script/swig
</A></li>
        <LI>Next message: <A HREF="001373.html">[Dsa-hl-svn] r4302 - in rl/trunk/engine/core: include src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1372">[ date ]</a>
              <a href="thread.html#1372">[ thread ]</a>
              <a href="subject.html#1372">[ subject ]</a>
              <a href="author.html#1372">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2008-03-20 20:41:24 +0100 (Thu, 20 Mar 2008)
New Revision: 4301

Modified:
   rl/trunk/engine/ai/include/DialogManager.h
   rl/trunk/engine/ai/include/WayPointGraph.h
   rl/trunk/engine/ai/src/DialogManager.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/ai/src/WayPointGraph.cpp
   rl/trunk/engine/common/include/XmlPropertyWriter.h
   rl/trunk/engine/common/src/XmlPropertyWriter.cpp
   rl/trunk/engine/core/include/ContentModule.h
   rl/trunk/engine/core/include/CoreMessages.h
   rl/trunk/engine/core/include/JobScheduler.h
   rl/trunk/engine/core/include/SaveGameManager.h
   rl/trunk/engine/core/include/TimeSource.h
   rl/trunk/engine/core/include/ZoneManager.h
   rl/trunk/engine/core/src/Actor.cpp
   rl/trunk/engine/core/src/ContentModule.cpp
   rl/trunk/engine/core/src/JobScheduler.cpp
   rl/trunk/engine/core/src/SaveGameFileReader.cpp
   rl/trunk/engine/core/src/SaveGameManager.cpp
   rl/trunk/engine/core/src/TimeSource.cpp
   rl/trunk/engine/core/src/ZoneManager.cpp
   rl/trunk/engine/rules/include/CreatureControllerManager.h
   rl/trunk/engine/rules/include/GameObjectManager.h
   rl/trunk/engine/rules/include/GlobalProperties.h
   rl/trunk/engine/rules/include/QuestBook.h
   rl/trunk/engine/rules/include/RulesMessages.h
   rl/trunk/engine/rules/src/CreatureController.cpp
   rl/trunk/engine/rules/src/GameObjectManager.cpp
   rl/trunk/engine/rules/src/GlobalProperties.cpp
   rl/trunk/engine/rules/src/QuestBook.cpp
   rl/trunk/engine/script/include/TriggerFactory.h
   rl/trunk/engine/script/src/TriggerFactory.cpp
   rl/trunk/engine/script/swig/RlAi.swig
   rl/trunk/engine/ui/src/ControlState.cpp
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
Separate SaveGameData and SaveGameManager

Modified: rl/trunk/engine/ai/include/DialogManager.h
===================================================================
--- rl/trunk/engine/ai/include/DialogManager.h	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/ai/include/DialogManager.h	2008-03-20 19:41:24 UTC (rev 4301)
@@ -21,7 +21,7 @@
 #include &lt;xercesc/dom/DOMElement.hpp&gt;
 
 #include &quot;Properties.h&quot;
-#include &quot;SaveGameManager.h&quot;
+#include &quot;SaveGameData.h&quot;
 #include &quot;XmlProcessor.h&quot;
 
 namespace rl

Modified: rl/trunk/engine/ai/include/WayPointGraph.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointGraph.h	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/ai/include/WayPointGraph.h	2008-03-20 19:41:24 UTC (rev 4301)
@@ -72,37 +72,6 @@
 		 */
 		void addDirectedConnection(WayPointNode* wp1, const WayPointNode* wp2);
 
-
-		/** loads the Waypoints from a file.
-		 * The Load functionality uses the module path querying of the
-		 * configuration module in oder to fetch the module directory path.
-		 * @param filename of the file to load.
-		 */
-		void loadBinary(const Ogre::String&amp; filename);
-
-		/** saves the Waypoints to a file.
-		 * Structure of the file is as follows:
-		 * Header\n
-		 * numberOfWaypoints\n
-		 * waypoint0.x waypoint0.y waypoint0.z waypoint0.type waypoint1.x ...\n
-		 * numberOfConnections connectionindex1 connectionindex2 ...\n
-		 * ...
-		 * \n
-		 * \n
-		 * 
-		 * As you can see the waypoint coordinates are written consecutivily on one line
-		 * and the connections of one waypoint to the others are written per waypoint on one line.
-		 * The first number gives the number of connections and the rest are the indices of the
-		 * waypoints the connections have to be made to. That index given by the order of the
-		 * the list of WayPoints in the file. It starts with 0.
-		 * If the line is just contains a 0 for numberOfConnections that means that the
-		 * waypoint has got not other waypoints to connect to (very unlikely).
-		 * The file is terminated either with end of file or two newlines.
-		 *
-		 * @param filename of the file to save to.
-		 */
-		void saveBinary(const Ogre::String&amp; filename) const;
-
         /** loads the Waypoints from an xml file.
 		 * The Load functionality uses the module path querying of the
 		 * configuration module in oder to fetch the module directory path.

Modified: rl/trunk/engine/ai/src/DialogManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogManager.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/ai/src/DialogManager.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -31,6 +31,7 @@
 #include &quot;GameObjectManager.h&quot;
 #include &quot;XmlPropertyReader.h&quot;
 #include &quot;ConfigurationManager.h&quot;
+#include &quot;SaveGameManager.h&quot;
 
 using namespace Ogre;
 using namespace XERCES_CPP_NAMESPACE;

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -28,6 +28,7 @@
 #include &quot;CreatureController.h&quot;
 #include &quot;PhysicalThing.h&quot;
 #include &quot;GameObjectManager.h&quot;
+#include &quot;RulesMessages.h&quot;
 
 using namespace Ogre;
 using namespace OpenSteer;

Modified: rl/trunk/engine/ai/src/WayPointGraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraph.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/ai/src/WayPointGraph.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -95,158 +95,6 @@
 	mChanged = true;
 }
 
-void WayPointGraph::loadBinary(const Ogre::String&amp; filename)
-{
-	// fetch modules directory
-	Ogre::String modulespath(
-		ConfigurationManager::getSingleton().getModulesRootDirectory());
-	Ogre::String fullfilename(modulespath + &quot;/&quot; + filename);
-
-	// check if the file exists
-	if (! boost::filesystem::exists(boost::filesystem::path(fullfilename)) )
-		Throw(FileNotFoundException, fullfilename);
-
-	std::ifstream input(fullfilename.c_str(), ios::binary);
-
-	if (input.fail())
-		Throw(Error, filename+&quot;: couldn't open&quot;);
-	if (input.eof())
-		Throw(Error, filename+&quot;: premature end of file&quot;);
-
-	std::string MagicHeader;
-	input &gt;&gt; MagicHeader;
-	if (MagicHeader != &quot;RLWayPointGraph&quot;)
-		Throw(WrongFormatException, filename);
-
-	if (input.eof())
-		Throw(Error, filename+&quot;: premature end of file&quot;);
-
-	char line[20];
-	input.getline(line, sizeof(line));
-
-	WayPointNodeList::size_type numberOfNodes;
-	input.read((char *) &amp;numberOfNodes, sizeof(numberOfNodes));
-
-	//read the rest of the line (lineend)
-	input.getline(line, sizeof(line));
-
-	// read in the points
-	Vector3 Position;
-	WayPointNode::WayPointNodeType type;
-	unsigned int count = 0;
-	while (!input.eof() &amp;&amp; count &lt; numberOfNodes)
-	{
-		input.read((char *) &amp;Position, sizeof(Position));
-		if (input.eof())
-			Throw(Error, filename+&quot;: fileend while reading waypoints&quot;);
-		input.read((char *) &amp;type, sizeof(type));
-		if (input.eof())
-			Throw(Error, filename+&quot;: fileend while reading waypoints&quot;);
-		rawAddWayPoint(Position, type);
-		count++;
-	}
-	if (count != numberOfNodes)
-		Throw(Error, filename+&quot;: didn't find as many WayPoints as expected.&quot;);
-
-	// should be needed to read newline at end of waypoint line, but actually it's
-	// not necessary (enabling it breaks the loading of the connections)
-	//input.getline(line, sizeof(line));
-
-	WayPointNode* FromNode;
-	WayPointNode* ToNode;
-	WayPointNode::WayPointWeightNodeList::size_type nrOfConnections;
-	unsigned int index;
-
-	// read in the connections
-	count=0;
-	while (!input.eof() &amp;&amp; count &lt; numberOfNodes)
-	{
-		input.read((char *) &amp;nrOfConnections, sizeof(nrOfConnections));
-		if (input.eof())
-			Throw(Error, filename+&quot;: fileend while reading connections&quot;);
-
-		for (unsigned int concount = 0; concount &lt; nrOfConnections; concount++) {
-			input.read((char *) &amp;index, sizeof(index));
-			FromNode = mNodeList[count];
-			ToNode = mNodeList[index];
-			FromNode-&gt;addNeighbour(ToNode);
-		}
-		count++;
-		input.getline(line, sizeof(line));
-	}
-	if (count != numberOfNodes)
-		Throw(Error, filename+&quot;: couldn't read expeced number of connections&quot;);
-
-	input.close();
-	mChanged = true;
-}
-
-void WayPointGraph::saveBinary(const Ogre::String&amp; filename) const
-{
-	unsigned int count;
-	WayPointNodeList::const_iterator it;
-	std::map&lt;const WayPointNode*, unsigned int&gt; IndexList;
-
-	// fetch modules directory
-	Ogre::String modulespath(
-		ConfigurationManager::getSingleton().getModulesRootDirectory());
-	Ogre::String fullfilename(modulespath + &quot;/&quot; + filename);
-
-	std::ofstream output(fullfilename.c_str(), std::ios::binary);
-	// opening file for write failed
-	if (output.fail())
-		Throw (Error,filename + &quot;couldn't open for writing&quot;);
-
-	// write file magic header
-	output &lt;&lt; &quot;RLWayPointGraph&quot; &lt;&lt; endl;
-	// write number of waypoints
-	WayPointNodeList::size_type numberOfNodes = mNodeList.size();
-	output.write((char *) &amp;numberOfNodes, sizeof(numberOfNodes));
-	output &lt;&lt; endl;
-
-	// save the full list of points
-	// and construct an index map for the nodes
-	count = 0;
-	Vector3 Position;
-	WayPointNode::WayPointNodeType type;
-	for (it = mNodeList.begin(); it != mNodeList.end(); it++)
-	{
-		// write waypoint to file
-		Position = (*it)-&gt;getPosition();
-		type = (*it)-&gt;getType();
-		output.write((char *) &amp;Position, sizeof(Position));
-		output.write((char *) &amp;type, sizeof(type));
-		// add waypoint pointer to the list with it's index
-		IndexList.insert(pair&lt;WayPointNode*, unsigned int&gt;((*it),count));
-		count++;
-	}
-	// additionally terminate list with newline
-	cout &lt;&lt; endl;
-
-	// save the index-index pairs for the connections between the nodes
-	count = 0;
-	for (it = mNodeList.begin(); it != mNodeList.end(); it++)
-	{
-		const WayPointNode::WayPointWeightNodeList subnodes = (*it)-&gt;getNeighbours();
-		WayPointNode::WayPointWeightNodeList::size_type subnodessize = subnodes.size();
-		WayPointNode::WayPointWeightNodeList::const_iterator nit;
-		std::map&lt;const WayPointNode*, unsigned int&gt;::iterator itIndex;
-
-		output.write((char *) &amp;(subnodessize), sizeof(subnodessize));
-		// iteratte through the neighbours
-		for (nit = subnodes.begin(); nit != subnodes.end(); nit++)
-		{
-			itIndex = IndexList.find( (*nit).second );
-			output.write((char *) &amp;((*itIndex).second), sizeof((*itIndex).second));
-		}
-		// terminate connection list for one node
-		output &lt;&lt; endl;
-
-		count++;
-	}
-	output.close();
-}
-
 void WayPointGraph::load(const Ogre::String&amp; filename, const Ogre::String&amp; resourceGroup)
 {
     using namespace XERCES_CPP_NAMESPACE;

Modified: rl/trunk/engine/common/include/XmlPropertyWriter.h
===================================================================
--- rl/trunk/engine/common/include/XmlPropertyWriter.h	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/common/include/XmlPropertyWriter.h	2008-03-20 19:41:24 UTC (rev 4301)
@@ -1,67 +1,67 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#ifndef __PropertyWriter_H__
-#define __PropertyWriter_H__
-
-#include &quot;CommonPrerequisites.h&quot;
-
-#include &lt;xercesc/dom/DOM.hpp&gt;
-#include &lt;xercesc/dom/DOMAttr.hpp&gt;
-#include &lt;xercesc/dom/DOMElement.hpp&gt;
-
-#include &quot;Property.h&quot;
-#include &quot;XmlProcessor.h&quot;
-
-namespace rl 
-{
-    class Property;
-    class PropertyRecord;
-
-    typedef std::pair&lt;Ogre::String, Property&gt; PropertyEntry;
-
-    class _RlCommonExport XmlPropertyWriter
-        : public XmlProcessor
-    {
-    public:
-        XmlPropertyWriter();
-        virtual ~XmlPropertyWriter();
-
-        XERCES_CPP_NAMESPACE::DOMDocument* getDocument();
-
-        std::vector&lt;PropertyRecord*&gt; getPropertyRecords();
-        void setPropertyRecords(std::vector&lt;PropertyRecord*&gt; sets);
-        void addPropertyRecord(PropertyRecord* set);
-
-        XERCES_CPP_NAMESPACE::DOMElement* processProperty(XERCES_CPP_NAMESPACE::DOMElement* parent, PropertyEntry entry);
-        XERCES_CPP_NAMESPACE::DOMElement* processPropertyRecord(XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name, PropertyRecord set);
-        XERCES_CPP_NAMESPACE::DOMElement* processPropertyArray(XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name, PropertyArray vector);
-        XERCES_CPP_NAMESPACE::DOMElement* processPropertyMap(XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name, PropertyMap map);
-
-        void writeEachPropertyToElem(XERCES_CPP_NAMESPACE::DOMElement* parent, const PropertyMap &amp;map);
-    protected:
-        std::vector&lt;PropertyRecord*&gt; mPropertyRecords;
-
-        XERCES_CPP_NAMESPACE::DOMDocument* mDocument;
-        XERCES_CPP_NAMESPACE::DOMImplementation* mImplementation;
-        XERCES_CPP_NAMESPACE::DOMWriter* mWriter;
-        XERCES_CPP_NAMESPACE::XMLFormatTarget* mTarget;
-
-        Property getProperty(const Ogre::String&amp; key, const CeGuiString&amp; value);
-    };
-} // namespace rl
-
-#endif //__PropertyWriter_H__
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __PropertyWriter_H__
+#define __PropertyWriter_H__
+
+#include &quot;CommonPrerequisites.h&quot;
+
+#include &lt;xercesc/dom/DOM.hpp&gt;
+#include &lt;xercesc/dom/DOMAttr.hpp&gt;
+#include &lt;xercesc/dom/DOMElement.hpp&gt;
+
+#include &quot;Property.h&quot;
+#include &quot;XmlProcessor.h&quot;
+
+namespace rl 
+{
+    class Property;
+    class PropertyRecord;
+
+    typedef std::pair&lt;Ogre::String, Property&gt; PropertyEntry;
+
+    class _RlCommonExport XmlPropertyWriter
+        : public XmlProcessor
+    {
+    public:
+        XmlPropertyWriter();
+        virtual ~XmlPropertyWriter();
+
+        XERCES_CPP_NAMESPACE::DOMDocument* getDocument();
+
+        std::vector&lt;PropertyRecord*&gt; getPropertyRecords();
+        void setPropertyRecords(std::vector&lt;PropertyRecord*&gt; sets);
+        void addPropertyRecord(PropertyRecord* set);
+
+        XERCES_CPP_NAMESPACE::DOMElement* processProperty(XERCES_CPP_NAMESPACE::DOMElement* parent, PropertyEntry entry);
+        XERCES_CPP_NAMESPACE::DOMElement* processPropertyRecord(XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name, PropertyRecord set);
+        XERCES_CPP_NAMESPACE::DOMElement* processPropertyArray(XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name, PropertyArray vector);
+        XERCES_CPP_NAMESPACE::DOMElement* processPropertyMap(XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name, PropertyMap map);
+
+        void writeEachPropertyToElem(XERCES_CPP_NAMESPACE::DOMElement* parent, const PropertyMap &amp;map);
+    protected:
+        std::vector&lt;PropertyRecord*&gt; mPropertyRecords;
+
+        XERCES_CPP_NAMESPACE::DOMDocument* mDocument;
+        XERCES_CPP_NAMESPACE::DOMImplementation* mImplementation;
+        XERCES_CPP_NAMESPACE::DOMWriter* mWriter;
+        XERCES_CPP_NAMESPACE::XMLFormatTarget* mTarget;
+
+        Property getProperty(const Ogre::String&amp; key, const CeGuiString&amp; value);
+    };
+} // namespace rl
+
+#endif //__PropertyWriter_H__

Modified: rl/trunk/engine/common/src/XmlPropertyWriter.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlPropertyWriter.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/common/src/XmlPropertyWriter.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -1,145 +1,145 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;XmlProcessor.h&quot;
-
-#include &quot;Properties.h&quot;
-#include &quot;XmlPropertyWriter.h&quot;
-
-#include &lt;CEGUIPropertyHelper.h&gt;
-
-
-using namespace XERCES_CPP_NAMESPACE;
-using namespace Ogre;
-
-namespace rl {
-
-    XmlPropertyWriter::XmlPropertyWriter()
-    {
-    }
-
-    XmlPropertyWriter::~XmlPropertyWriter()
-    {
-    }
-
-    DOMDocument* XmlPropertyWriter::getDocument()
-    {
-        return mDocument;
-    }
-
-    void XmlPropertyWriter::setPropertyRecords(std::vector&lt;PropertyRecord*&gt; sets)
-    {
-        mPropertyRecords = sets;
-    }
-
-    void XmlPropertyWriter::addPropertyRecord(PropertyRecord* set)
-    {
-        mPropertyRecords.push_back(set);
-    }
-
-    DOMElement* XmlPropertyWriter::processProperty(DOMElement* parent, PropertyEntry entry)
-    {
-        DOMElement* element = NULL;
-        if(!entry.second.isEmpty())
-        {
-            if(entry.second.isArray())
-            {
-                element = this-&gt;processPropertyArray(parent, entry.first.c_str(), entry.second.toArray());
-            }
-            else if(entry.second.isMap())
-            {
-                element = this-&gt;processPropertyMap(parent, entry.first.c_str(), entry.second.toMap());
-            }
-            else
-            {
-                element = appendChildElement(mDocument, parent, &quot;property&quot;);
-                if(!entry.first.empty())
-                    setAttribute(element, &quot;name&quot;, entry.first.c_str());
-
-                //Ogre::String typeName = entry.second.getTypeName();
-                Ogre::String name = entry.second.getName();
-                Ogre::StringUtil::toUpperCase(name);
-                setAttributeValueAsString(element, &quot;type&quot;, name);
-
-                if(entry.second.isBool())
-                    setAttributeValueAsBool(element, &quot;data&quot;, entry.second.toBool());
-                else if(entry.second.isInt())
-                    setAttributeValueAsInteger(element, &quot;data&quot;, entry.second.toInt());
-                else if(entry.second.isIntPair())
-                    setAttributeValueAsIntegerPair(element, &quot;data&quot;, entry.second.toIntPair());
-                else if(entry.second.isIntTriple())
-                    setAttributeValueAsIntegerTriple(element, &quot;data&quot;, entry.second.toIntTriple());
-                else if(entry.second.isQuaternion())
-                    setAttributeValueAsQuaternion(element, &quot;data&quot;, entry.second.toQuaternion());
-                else if(entry.second.isReal())
-                    setAttributeValueAsReal(element, &quot;data&quot;, entry.second.toReal());
-                else if(entry.second.isString())
-                    setAttributeValueAsString(element, &quot;data&quot;, entry.second.toString());
-                else if(entry.second.isVector3())
-                    setAttributeValueAsVector3(element, &quot;data&quot;, entry.second.toVector3());
-            }
-        }
-        return element;
-    }
-
-    DOMElement* XmlPropertyWriter::processPropertyRecord(DOMElement* parent, const char* const name, PropertyRecord set)
-    {
-        PropertyMap map = set.toPropertyMap();
-
-        return processPropertyMap(parent, name, map);
-    }
-
-    DOMElement* XmlPropertyWriter::processPropertyArray(DOMElement *parent, const char *const name, PropertyArray vector)
-    {
-        DOMElement* element = appendChildElement(mDocument, parent, &quot;property&quot;);
-        if(name[0] != '\0')
-            setAttribute(element, &quot;name&quot;, name);
-        setAttribute(element, &quot;type&quot;, &quot;ARRAY&quot;);
-
-        PropertyArray::iterator iter;
-        for(iter = vector.begin(); iter != vector.end(); iter++)
-        {
-            processProperty(element, PropertyEntry(Ogre::String(),*iter));
-        }
-        return element;
-    }
-
-    DOMElement* XmlPropertyWriter::processPropertyMap(DOMElement *parent, const char *const name, PropertyMap map)
-    {
-        DOMElement* element = appendChildElement(mDocument, parent, &quot;property&quot;);
-        if(name[0] != '\0')
-            setAttribute(element, &quot;name&quot;, name);
-        setAttribute(element, &quot;type&quot;, &quot;MAP&quot;);
-
-        PropertyMap::iterator iter;
-        for(iter = map.begin(); iter != map.end(); iter++)
-        {
-            processProperty(element, PropertyEntry(iter-&gt;first.c_str(), iter-&gt;second));
-        }
-        return element;
-    }
-
-    void XmlPropertyWriter::writeEachPropertyToElem(DOMElement* parent, const rl::PropertyMap &amp;map)
-    {
-        PropertyMap::const_iterator it_properties;
-        for(it_properties = map.begin(); it_properties != map.end(); it_properties++)
-        {
-            this-&gt;processProperty(parent, PropertyEntry(it_properties-&gt;first.c_str(), it_properties-&gt;second));
-        }
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;XmlProcessor.h&quot;
+
+#include &quot;Properties.h&quot;
+#include &quot;XmlPropertyWriter.h&quot;
+
+#include &lt;CEGUIPropertyHelper.h&gt;
+
+
+using namespace XERCES_CPP_NAMESPACE;
+using namespace Ogre;
+
+namespace rl {
+
+    XmlPropertyWriter::XmlPropertyWriter()
+    {
+    }
+
+    XmlPropertyWriter::~XmlPropertyWriter()
+    {
+    }
+
+    DOMDocument* XmlPropertyWriter::getDocument()
+    {
+        return mDocument;
+    }
+
+    void XmlPropertyWriter::setPropertyRecords(std::vector&lt;PropertyRecord*&gt; sets)
+    {
+        mPropertyRecords = sets;
+    }
+
+    void XmlPropertyWriter::addPropertyRecord(PropertyRecord* set)
+    {
+        mPropertyRecords.push_back(set);
+    }
+
+    DOMElement* XmlPropertyWriter::processProperty(DOMElement* parent, PropertyEntry entry)
+    {
+        DOMElement* element = NULL;
+        if(!entry.second.isEmpty())
+        {
+            if(entry.second.isArray())
+            {
+                element = this-&gt;processPropertyArray(parent, entry.first.c_str(), entry.second.toArray());
+            }
+            else if(entry.second.isMap())
+            {
+                element = this-&gt;processPropertyMap(parent, entry.first.c_str(), entry.second.toMap());
+            }
+            else
+            {
+                element = appendChildElement(mDocument, parent, &quot;property&quot;);
+                if(!entry.first.empty())
+                    setAttribute(element, &quot;name&quot;, entry.first.c_str());
+
+                //Ogre::String typeName = entry.second.getTypeName();
+                Ogre::String name = entry.second.getName();
+                Ogre::StringUtil::toUpperCase(name);
+                setAttributeValueAsString(element, &quot;type&quot;, name);
+
+                if(entry.second.isBool())
+                    setAttributeValueAsBool(element, &quot;data&quot;, entry.second.toBool());
+                else if(entry.second.isInt())
+                    setAttributeValueAsInteger(element, &quot;data&quot;, entry.second.toInt());
+                else if(entry.second.isIntPair())
+                    setAttributeValueAsIntegerPair(element, &quot;data&quot;, entry.second.toIntPair());
+                else if(entry.second.isIntTriple())
+                    setAttributeValueAsIntegerTriple(element, &quot;data&quot;, entry.second.toIntTriple());
+                else if(entry.second.isQuaternion())
+                    setAttributeValueAsQuaternion(element, &quot;data&quot;, entry.second.toQuaternion());
+                else if(entry.second.isReal())
+                    setAttributeValueAsReal(element, &quot;data&quot;, entry.second.toReal());
+                else if(entry.second.isString())
+                    setAttributeValueAsString(element, &quot;data&quot;, entry.second.toString());
+                else if(entry.second.isVector3())
+                    setAttributeValueAsVector3(element, &quot;data&quot;, entry.second.toVector3());
+            }
+        }
+        return element;
+    }
+
+    DOMElement* XmlPropertyWriter::processPropertyRecord(DOMElement* parent, const char* const name, PropertyRecord set)
+    {
+        PropertyMap map = set.toPropertyMap();
+
+        return processPropertyMap(parent, name, map);
+    }
+
+    DOMElement* XmlPropertyWriter::processPropertyArray(DOMElement *parent, const char *const name, PropertyArray vector)
+    {
+        DOMElement* element = appendChildElement(mDocument, parent, &quot;property&quot;);
+        if(name[0] != '\0')
+            setAttribute(element, &quot;name&quot;, name);
+        setAttribute(element, &quot;type&quot;, &quot;ARRAY&quot;);
+
+        PropertyArray::iterator iter;
+        for(iter = vector.begin(); iter != vector.end(); iter++)
+        {
+            processProperty(element, PropertyEntry(Ogre::String(),*iter));
+        }
+        return element;
+    }
+
+    DOMElement* XmlPropertyWriter::processPropertyMap(DOMElement *parent, const char *const name, PropertyMap map)
+    {
+        DOMElement* element = appendChildElement(mDocument, parent, &quot;property&quot;);
+        if(name[0] != '\0')
+            setAttribute(element, &quot;name&quot;, name);
+        setAttribute(element, &quot;type&quot;, &quot;MAP&quot;);
+
+        PropertyMap::iterator iter;
+        for(iter = map.begin(); iter != map.end(); iter++)
+        {
+            processProperty(element, PropertyEntry(iter-&gt;first.c_str(), iter-&gt;second));
+        }
+        return element;
+    }
+
+    void XmlPropertyWriter::writeEachPropertyToElem(DOMElement* parent, const rl::PropertyMap &amp;map)
+    {
+        PropertyMap::const_iterator it_properties;
+        for(it_properties = map.begin(); it_properties != map.end(); it_properties++)
+        {
+            this-&gt;processProperty(parent, PropertyEntry(it_properties-&gt;first.c_str(), it_properties-&gt;second));
+        }
+    }
+}

Modified: rl/trunk/engine/core/include/ContentModule.h
===================================================================
--- rl/trunk/engine/core/include/ContentModule.h	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/core/include/ContentModule.h	2008-03-20 19:41:24 UTC (rev 4301)
@@ -18,7 +18,7 @@
 #define __ContentModule_H__
 
 #include &quot;CorePrerequisites.h&quot;
-#include &quot;SaveGameManager.h&quot;
+#include &quot;SaveGameData.h&quot;
 #include &quot;ContentLoader.h&quot;
 
 namespace rl

Modified: rl/trunk/engine/core/include/CoreMessages.h
===================================================================
--- rl/trunk/engine/core/include/CoreMessages.h	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/core/include/CoreMessages.h	2008-03-20 19:41:24 UTC (rev 4301)
@@ -1,66 +1,84 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#ifndef __Rl_CoreMessages_H__
-#define __Rl_CoreMessages_H__
-
-#include &quot;CorePrerequisites.h&quot;
-#include &quot;MessageType.h&quot;
-
-namespace rl
-{
-    class BaseAnimation;
-
-    enum CoreMessageTypeIds
-    {
-        // World //
-        // Mask
-        RLMSG_SCENE_EVENTS = 0x01000100,
-        // Events
-        RLMSG_SCENE_LOADED = 0x01000101,
-        RLMSG_SCENE_CLEARING = 0x01000102,
-
-        // Animations //
-        // Mask
-        RLMSG_ANIMATION_EVENTS = 0x01000200,
-        // Events
-        RLMSG_ANIMATION_PAUSED = 0x01000201,
-        RLMSG_ANIMATION_UNPAUSED = 0x01000202,
-        RLMSG_ANIMATION_FINISHED = 0x01000203,
-        RLMSG_ANIMATION_FRAMEREACHED = 0x01000204,
-    };
-
-    /// Message sent right after a scene has been loaded.
-    typedef MessageType&lt;RLMSG_SCENE_LOADED&gt; MessageType_SceneLoaded;
-
-    /// Message sent just before a scene will be cleared.
-    typedef MessageType&lt;RLMSG_SCENE_CLEARING&gt; MessageType_SceneClearing;
-
-    /// Message sent when an animation has been paused.
-    typedef MessageType&lt;RLMSG_ANIMATION_PAUSED, BaseAnimation*&gt; MessageType_AnimationPaused;
-
-    /// Message sent when an animation has been unpaused.
-    typedef MessageType&lt;RLMSG_ANIMATION_UNPAUSED, BaseAnimation*&gt; MessageType_AnimationUnpaused;
-
-    /// Message sent when an animation is finished.
-    typedef MessageType&lt;RLMSG_ANIMATION_FINISHED, BaseAnimation*&gt; MessageType_AnimationFinished;
-
-    /// Message sent when an animation has been paused.
-    /// Real param is the frame time reached
-    typedef MessageType&lt;RLMSG_ANIMATION_FRAMEREACHED, BaseAnimation*, Ogre::Real&gt;
-        MessageType_AnimationFrameReached;
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __Rl_CoreMessages_H__
+#define __Rl_CoreMessages_H__
+
+#include &quot;CorePrerequisites.h&quot;
+#include &quot;MessageType.h&quot;
+
+namespace rl
+{
+    class BaseAnimation;
+
+    enum CoreMessageTypeIds
+    {
+        // World //
+        // Mask
+        RLMSG_SCENE_EVENTS =            0x01000100,
+        // Events
+        RLMSG_SCENE_LOADED =            0x01000101,
+        RLMSG_SCENE_CLEARING =          0x01000102,
+
+        // Animations //
+        // Mask
+        RLMSG_ANIMATION_EVENTS =        0x01000200,
+        // Events
+        RLMSG_ANIMATION_PAUSED =        0x01000201,
+        RLMSG_ANIMATION_UNPAUSED =      0x01000202,
+        RLMSG_ANIMATION_FINISHED =      0x01000203,
+        RLMSG_ANIMATION_FRAMEREACHED =  0x01000204,
+
+        //Mask
+        RLMSG_SAVEGAME_EVENTS     =     0x01000300,
+        //Events    
+        RLMSG_SAVEGAME_LOADED     =     0x01000301,
+        RLMSG_SAVEGAME_SAVED      =     0x01000302,
+        RLMSG_SAVEGAME_LOADING    =     0x01000303,
+        RLMSG_SAVEGAME_SAVING     =     0x01000304,
+        RLMSG_SAVEGAME_GOS_LOADED =     0x01000311       
+    };
+
+    /// Message sent right after a scene has been loaded.
+    typedef MessageType&lt;RLMSG_SCENE_LOADED&gt; MessageType_SceneLoaded;
+
+    /// Message sent just before a scene will be cleared.
+    typedef MessageType&lt;RLMSG_SCENE_CLEARING&gt; MessageType_SceneClearing;
+
+    /// Message sent when an animation has been paused.
+    typedef MessageType&lt;RLMSG_ANIMATION_PAUSED, BaseAnimation*&gt; MessageType_AnimationPaused;
+
+    /// Message sent when an animation has been unpaused.
+    typedef MessageType&lt;RLMSG_ANIMATION_UNPAUSED, BaseAnimation*&gt; MessageType_AnimationUnpaused;
+
+    /// Message sent when an animation is finished.
+    typedef MessageType&lt;RLMSG_ANIMATION_FINISHED, BaseAnimation*&gt; MessageType_AnimationFinished;
+
+    /// Message sent when an animation has been paused.
+    /// Real param is the frame time reached
+    typedef MessageType&lt;RLMSG_ANIMATION_FRAMEREACHED, BaseAnimation*, Ogre::Real&gt;
+        MessageType_AnimationFrameReached;
+
+    typedef MessageType&lt;RLMSG_SAVEGAME_LOADED&gt; MessageType_SaveGameLoaded;
+    
+    typedef MessageType&lt;RLMSG_SAVEGAME_SAVED&gt; MessageType_SaveGameSaved;
+    
+    typedef MessageType&lt;RLMSG_SAVEGAME_LOADING&gt; MessageType_SaveGameLoading;
+    
+    typedef MessageType&lt;RLMSG_SAVEGAME_SAVING&gt; MessageType_SaveGameSaving;
+    
+}
+#endif

Modified: rl/trunk/engine/core/include/JobScheduler.h
===================================================================
--- rl/trunk/engine/core/include/JobScheduler.h	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/core/include/JobScheduler.h	2008-03-20 19:41:24 UTC (rev 4301)
@@ -23,7 +23,7 @@
 #include &lt;functional&gt;
 
 #include &quot;GameTask.h&quot;
-#include &quot;SaveGameManager.h&quot;
+#include &quot;SaveGameData.h&quot;
 #include &quot;TimeSource.h&quot;
 
 namespace rl

Modified: rl/trunk/engine/core/include/SaveGameManager.h
===================================================================
--- rl/trunk/engine/core/include/SaveGameManager.h	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/core/include/SaveGameManager.h	2008-03-20 19:41:24 UTC (rev 4301)
@@ -1,106 +1,77 @@
-/* 
- * (C) 2003-2008. Team Pantheon. www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here:
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm">http://www.jpaulmorrison.com/fbp/artistic2.htm</A>
- */
-#ifndef _SaveGameManager_H_
-#define _SaveGameManager_H_
-
-#include &quot;CorePrerequisites.h&quot;
-#include &quot;SaveGameFileWriter.h&quot;
-#include &quot;SaveGameFileReader.h&quot;
-#include &quot;SaveGameFile.h&quot;
-#include &quot;MessagePump.h&quot;
-
-#include &lt;XmlPropertyWriter.h&gt;
-#include &lt;XmlPropertyReader.h&gt;
-
-//#include &lt;multimap&gt;
-
-namespace rl
-{
-    enum SaveGameMessageTypeIds
-    {
-        //Mask
-        RLMSG_SAVEGAME_EVENTS     = 0x0300000,
-        //Events
-        RLMSG_SAVEGAME_LOADED     = 0x0300001,
-        RLMSG_SAVEGAME_SAVED      = 0x0300002,
-        RLMSG_SAVEGAME_LOADING    = 0x0300003,
-        RLMSG_SAVEGAME_SAVING     = 0x0300004,
-        RLMSG_SAVEGAME_GOS_LOADED = 0x0300011       
-    };
-
-    typedef MessageType&lt;RLMSG_SAVEGAME_LOADED&gt; MessageType_SaveGameLoaded;
-
-    typedef MessageType&lt;RLMSG_SAVEGAME_SAVED&gt; MessageType_SaveGameSaved;
-
-    typedef MessageType&lt;RLMSG_SAVEGAME_LOADING&gt; MessageType_SaveGameLoading;
-
-    typedef MessageType&lt;RLMSG_SAVEGAME_SAVING&gt; MessageType_SaveGameSaving;
-
-    class _RlCoreExport SaveGameData
-    {
-    public:
-        SaveGameData();
-        virtual ~SaveGameData();
-        virtual CeGuiString getXmlNodeIdentifier() const = 0;
-        virtual void writeData(SaveGameFileWriter* writer) = 0;
-        virtual void readData(SaveGameFileReader* reader) = 0;
-        /// defines the loading/saving order higher priority are saved last and loaded first
-        virtual int getPriority() const = 0;
-    };
-
-    typedef std::multimap&lt;int,SaveGameData*&gt; SaveGameDataOrderMap;
-
-    typedef std::map&lt;int, SaveGameFile*&gt; SaveGameEntryMap;
-
-    class _RlCoreExport SaveGameManager : public Ogre::Singleton&lt;SaveGameManager&gt;, public Ogre::ScriptLoader
-    {
-    public:
-        SaveGameManager(void);
-        virtual ~SaveGameManager(void);    
-
-        SaveGameEntryMap listSaveGames(void);
-        SaveGameEntryMap listSaveGames(const CeGuiString &amp;moduleId);
-        void saveSaveGameFile(const CeGuiString &amp;name);
-        void loadSaveGameFile(const CeGuiString &amp;name, const CeGuiString&amp; moduleID);
-        void loadSaveGameFile(int id);
-        void deleteSaveGameFile(const CeGuiString &amp;name, const CeGuiString &amp;moduleId);
-        void deleteSaveGameFile(int id);
-        bool SaveGameFileExists(const CeGuiString &amp;name, const CeGuiString &amp;moduleId);
-        SaveGameFile* getSaveGameFile(const CeGuiString &amp;name, const CeGuiString &amp;moduleId);
-        SaveGameFile* getSaveGameFile(int id);
-        int getSaveGameId(const CeGuiString &amp;name, const CeGuiString &amp;moduleId);
-
-        virtual const Ogre::StringVector&amp;  getScriptPatterns(void) const;
-        virtual void parseScript(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName);
-        virtual Ogre::Real getLoadingOrder(void) const;
-
-        void registerSaveGameData(SaveGameData* data);
-        void unregisterSaveGameData(SaveGameData* data);
-
-        int getHighestSaveGameNumber();
-    protected:
-        void freeSaveGameMap();
-
-        Ogre::StringVector mScriptPatterns;
-        SaveGameEntryMap mSaveGames;
-
-        SaveGameDataOrderMap mSaveGameDataOrderMap;
-
-        int mHighestSaveGameNumber;
-    };
-}
-
-#endif
+/* 
+ * (C) 2003-2008. Team Pantheon. www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here:
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm">http://www.jpaulmorrison.com/fbp/artistic2.htm</A>
+ */
+#ifndef _SaveGameManager_H_
+#define _SaveGameManager_H_
+
+#include &quot;CorePrerequisites.h&quot;
+#include &quot;SaveGameFileWriter.h&quot;
+#include &quot;SaveGameFileReader.h&quot;
+#include &quot;SaveGameFile.h&quot;
+#include &quot;MessagePump.h&quot;
+
+#include &lt;XmlPropertyWriter.h&gt;
+#include &lt;XmlPropertyReader.h&gt;
+
+//#include &lt;multimap&gt;
+
+namespace rl
+{
+
+    class SaveGameData;
+
+    typedef std::multimap&lt;int,SaveGameData*&gt; SaveGameDataOrderMap;
+
+    typedef std::map&lt;int, SaveGameFile*&gt; SaveGameEntryMap;
+
+    class _RlCoreExport SaveGameManager : public Ogre::Singleton&lt;SaveGameManager&gt;, public Ogre::ScriptLoader
+    {
+    public:
+        SaveGameManager(void);
+        virtual ~SaveGameManager(void);    
+
+        SaveGameEntryMap listSaveGames(void);
+        SaveGameEntryMap listSaveGames(const CeGuiString &amp;moduleId);
+        void saveSaveGameFile(const CeGuiString &amp;name);
+        void loadSaveGameFile(const CeGuiString &amp;name, const CeGuiString&amp; moduleID);
+        void loadSaveGameFile(int id);
+        void deleteSaveGameFile(const CeGuiString &amp;name, const CeGuiString &amp;moduleId);
+        void deleteSaveGameFile(int id);
+        bool SaveGameFileExists(const CeGuiString &amp;name, const CeGuiString &amp;moduleId);
+        SaveGameFile* getSaveGameFile(const CeGuiString &amp;name, const CeGuiString &amp;moduleId);
+        SaveGameFile* getSaveGameFile(int id);
+        int getSaveGameId(const CeGuiString &amp;name, const CeGuiString &amp;moduleId);
+
+        virtual const Ogre::StringVector&amp;  getScriptPatterns(void) const;
+        virtual void parseScript(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName);
+        virtual Ogre::Real getLoadingOrder(void) const;
+
+        void registerSaveGameData(SaveGameData* data);
+        void unregisterSaveGameData(SaveGameData* data);
+
+        int getHighestSaveGameNumber();
+    protected:
+        void freeSaveGameMap();
+
+        Ogre::StringVector mScriptPatterns;
+        SaveGameEntryMap mSaveGames;
+
+        SaveGameDataOrderMap mSaveGameDataOrderMap;
+
+        int mHighestSaveGameNumber;
+    };
+}
+
+#endif

Modified: rl/trunk/engine/core/include/TimeSource.h
===================================================================
--- rl/trunk/engine/core/include/TimeSource.h	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/core/include/TimeSource.h	2008-03-20 19:41:24 UTC (rev 4301)
@@ -22,7 +22,7 @@
 
 #include &quot;GameTask.h&quot;
 
-#include &quot;SaveGameManager.h&quot;
+#include &quot;SaveGameData.h&quot;
 
 namespace rl
 {

Modified: rl/trunk/engine/core/include/ZoneManager.h
===================================================================
--- rl/trunk/engine/core/include/ZoneManager.h	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/core/include/ZoneManager.h	2008-03-20 19:41:24 UTC (rev 4301)
@@ -1,147 +1,148 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#ifndef __ZoneManager_H__
-#define __ZoneManager_H__
-
-#include &quot;CorePrerequisites.h&quot;
-#include &quot;CoreDefines.h&quot;
-#include &quot;GameAreaListener.h&quot;
-#include &quot;GameTask.h&quot;
-#include &quot;SaveGameManager.h&quot;
-
-namespace rl
-{
-    class Zone;
-    class Sound;
-
-    class _RlCoreExport ZoneManager : 
-        public Ogre::Singleton&lt;ZoneManager&gt;,
-        public GameAreaListener,
-        public GameTask, // for deferred deletion of zones
-        public SaveGameData // for saving/loading zones
-	{
-	public:
-		ZoneManager();
-		~ZoneManager();
-
-        Zone* createZone(const Ogre::String&amp; name, bool needsToBeSaved);
-        /// only marks the zone for deferred deletion
-        void destroyZone(const Ogre::String&amp; name);
-        void destroyAllZones();
-        /// Adds a new area to the zone
-        void addAreaToZone(const Ogre::String&amp; name, 
-            Ogre::AxisAlignedBox aabb, GeometryType geom,
-            Ogre::Vector3 position, Ogre::Vector3 offset, Ogre::Quaternion orientation,
-            Ogre::Real transitionDistance,
-            unsigned long queryflags);
-        void addAreaToZone(const Ogre::String&amp; name, 
-            Ogre::Vector3 size, GeometryType geom,
-            Ogre::Vector3 position, Ogre::Vector3 offset, Ogre::Quaternion orientation,
-            Ogre::Real transitionDistance,
-            unsigned long queryflags)
-        {
-            addAreaToZone(
-                name, Ogre::AxisAlignedBox(- 0.5 * size, 0.5 *size ), geom, position, offset, orientation,
-                transitionDistance, queryflags);
-        }
-        /// subtracts an area from the zone (it must ly in another area in this zone, else the beaviour is not defined)
-        void subtractAreaFromZone(const Ogre::String&amp; name, 
-            Ogre::AxisAlignedBox aabb, GeometryType geom,
-            Ogre::Vector3 position, Ogre::Vector3 offset, Ogre::Quaternion orientation,
-            Ogre::Real transitionDistance,
-            unsigned long queryflags);
-        void subtractAreaFromZone(const Ogre::String&amp; name, 
-            Ogre::Vector3 size, GeometryType geom,
-            Ogre::Vector3 position, Ogre::Vector3 offset, Ogre::Quaternion orientation,
-            Ogre::Real transitionDistance,
-            unsigned long queryflags)
-        {
-            subtractAreaFromZone(
-                name, Ogre::AxisAlignedBox(- 0.5 * size, 0.5 *size ), geom, position, offset, orientation,
-                transitionDistance, queryflags);
-        }
-        /// Adds a new mesh area to the zone
-        void addMeshAreaToZone(const Ogre::String&amp; name,
-            const Ogre::String&amp; meshname, GeometryType geom,
-            Ogre::Vector3 position,
-            Ogre::Vector3 scale, Ogre::Vector3 offset, Ogre::Quaternion orientation,
-            Ogre::Real transitionDistance,
-            unsigned long queryflags);
-        /// subtracts a mesh-area from the zone (it must ly in another area in this zone, else the beaviour is not defined)
-        void subtractMeshAreaFromZone(const Ogre::String&amp; name,
-            const Ogre::String&amp; meshname, GeometryType geom,
-            Ogre::Vector3 position,
-            Ogre::Vector3 scale, Ogre::Vector3 offset, Ogre::Quaternion orientation,
-            Ogre::Real transitionDistance,
-            unsigned long queryflags);
-		Zone* getDefaultZone();
-		Zone* getZone(const Ogre::String&amp; name);
-        Zone* getZone(long id);
-
-        /// asks wether this zone is currently activated
-        bool isZoneActive(const Zone* zone) const;
-
-        /*
-         * asks if the actor is currently in the specified Zone (expensive function!)
-         * the querymask of the actor doesn't need to fit the mask of the zone.
-         * this function probably isn't very accurate, it may only use the distance!
-        */
-        bool isInZone(Zone* zone, Actor *actor);
-
-		void areaLeft(GameAreaEvent* gae);
-	    void areaEntered(GameAreaEvent* gae);
-
-        /// only needed if the lights/etc of the active zone changed
-        void update();
-
-        /// inherited from gametask, deletes zones marked for deletion
-        void run(Ogre::Real elapsedTime);
-        /// inherited from gametask
-        const Ogre::String&amp; getName() const;
-
-        typedef std::map&lt;const Ogre::String, Zone*&gt; ZoneMap;
-        const ZoneMap &amp;getAllZones() const {return mZones;}
-
-
-        /// Override from SaveGameData
-        /// Manages saving and loading from the SaveGameFile
-
-        virtual CeGuiString getXmlNodeIdentifier() const;
-        virtual void writeData(SaveGameFileWriter* writer);
-        virtual void readData(SaveGameFileReader* reader);
-        virtual int getPriority() const;  // zones must be loaded before triggers!
-	private:
-		ZoneMap mZones;
-        std::map&lt;long, Zone*&gt; mZonesIdMap;
-		std::list&lt;Zone*&gt; mActiveZones;
-        typedef std::map&lt;const Ogre::String, Sound*&gt; SoundMap;
-        SoundMap mActiveSounds;
-		Zone* mDefaultZone;
-        long mNextZoneId;
-        std::list&lt;Zone*&gt; mZonesToDelete;
-
-		void switchLights();
-		void switchSounds();
-        void switchEaxSettings();
-        void zoneEntered(Zone * zone);
-        void zoneLeft(Zone * zone);
-        
-        void doDestroyZone(Zone *zone);
-        void parseAreaProperties(const Ogre::String&amp; zoneName, const PropertyRecord &amp;properties); // adds an area created from properties to the zone
-	};
-}
-
-#endif // __ZoneManager_H__
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#ifndef __ZoneManager_H__
+#define __ZoneManager_H__
+
+#include &quot;CorePrerequisites.h&quot;
+#include &quot;CoreDefines.h&quot;
+#include &quot;GameAreaListener.h&quot;
+#include &quot;GameTask.h&quot;
+#include &quot;Properties.h&quot;
+#include &quot;SaveGameData.h&quot;
+
+namespace rl
+{
+    class Zone;
+    class Sound;
+
+    class _RlCoreExport ZoneManager : 
+        public Ogre::Singleton&lt;ZoneManager&gt;,
+        public GameAreaListener,
+        public GameTask, // for deferred deletion of zones
+        public SaveGameData // for saving/loading zones
+	{
+	public:
+		ZoneManager();
+		~ZoneManager();
+
+        Zone* createZone(const Ogre::String&amp; name, bool needsToBeSaved);
+        /// only marks the zone for deferred deletion
+        void destroyZone(const Ogre::String&amp; name);
+        void destroyAllZones();
+        /// Adds a new area to the zone
+        void addAreaToZone(const Ogre::String&amp; name, 
+            Ogre::AxisAlignedBox aabb, GeometryType geom,
+            Ogre::Vector3 position, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+            Ogre::Real transitionDistance,
+            unsigned long queryflags);
+        void addAreaToZone(const Ogre::String&amp; name, 
+            Ogre::Vector3 size, GeometryType geom,
+            Ogre::Vector3 position, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+            Ogre::Real transitionDistance,
+            unsigned long queryflags)
+        {
+            addAreaToZone(
+                name, Ogre::AxisAlignedBox(- 0.5 * size, 0.5 *size ), geom, position, offset, orientation,
+                transitionDistance, queryflags);
+        }
+        /// subtracts an area from the zone (it must ly in another area in this zone, else the beaviour is not defined)
+        void subtractAreaFromZone(const Ogre::String&amp; name, 
+            Ogre::AxisAlignedBox aabb, GeometryType geom,
+            Ogre::Vector3 position, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+            Ogre::Real transitionDistance,
+            unsigned long queryflags);
+        void subtractAreaFromZone(const Ogre::String&amp; name, 
+            Ogre::Vector3 size, GeometryType geom,
+            Ogre::Vector3 position, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+            Ogre::Real transitionDistance,
+            unsigned long queryflags)
+        {
+            subtractAreaFromZone(
+                name, Ogre::AxisAlignedBox(- 0.5 * size, 0.5 *size ), geom, position, offset, orientation,
+                transitionDistance, queryflags);
+        }
+        /// Adds a new mesh area to the zone
+        void addMeshAreaToZone(const Ogre::String&amp; name,
+            const Ogre::String&amp; meshname, GeometryType geom,
+            Ogre::Vector3 position,
+            Ogre::Vector3 scale, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+            Ogre::Real transitionDistance,
+            unsigned long queryflags);
+        /// subtracts a mesh-area from the zone (it must ly in another area in this zone, else the beaviour is not defined)
+        void subtractMeshAreaFromZone(const Ogre::String&amp; name,
+            const Ogre::String&amp; meshname, GeometryType geom,
+            Ogre::Vector3 position,
+            Ogre::Vector3 scale, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+            Ogre::Real transitionDistance,
+            unsigned long queryflags);
+		Zone* getDefaultZone();
+		Zone* getZone(const Ogre::String&amp; name);
+        Zone* getZone(long id);
+
+        /// asks wether this zone is currently activated
+        bool isZoneActive(const Zone* zone) const;
+
+        /*
+         * asks if the actor is currently in the specified Zone (expensive function!)
+         * the querymask of the actor doesn't need to fit the mask of the zone.
+         * this function probably isn't very accurate, it may only use the distance!
+        */
+        bool isInZone(Zone* zone, Actor *actor);
+
+		void areaLeft(GameAreaEvent* gae);
+	    void areaEntered(GameAreaEvent* gae);
+
+        /// only needed if the lights/etc of the active zone changed
+        void update();
+
+        /// inherited from gametask, deletes zones marked for deletion
+        void run(Ogre::Real elapsedTime);
+        /// inherited from gametask
+        const Ogre::String&amp; getName() const;
+
+        typedef std::map&lt;const Ogre::String, Zone*&gt; ZoneMap;
+        const ZoneMap &amp;getAllZones() const {return mZones;}
+
+
+        /// Override from SaveGameData
+        /// Manages saving and loading from the SaveGameFile
+
+        virtual CeGuiString getXmlNodeIdentifier() const;
+        virtual void writeData(SaveGameFileWriter* writer);
+        virtual void readData(SaveGameFileReader* reader);
+        virtual int getPriority() const;  // zones must be loaded before triggers!
+	private:
+		ZoneMap mZones;
+        std::map&lt;long, Zone*&gt; mZonesIdMap;
+		std::list&lt;Zone*&gt; mActiveZones;
+        typedef std::map&lt;const Ogre::String, Sound*&gt; SoundMap;
+        SoundMap mActiveSounds;
+		Zone* mDefaultZone;
+        long mNextZoneId;
+        std::list&lt;Zone*&gt; mZonesToDelete;
+
+		void switchLights();
+		void switchSounds();
+        void switchEaxSettings();
+        void zoneEntered(Zone * zone);
+        void zoneLeft(Zone * zone);
+        
+        void doDestroyZone(Zone *zone);
+        void parseAreaProperties(const Ogre::String&amp; zoneName, const PropertyRecord &amp;properties); // adds an area created from properties to the zone
+	};
+}
+
+#endif // __ZoneManager_H__

Modified: rl/trunk/engine/core/src/Actor.cpp
===================================================================
--- rl/trunk/engine/core/src/Actor.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/core/src/Actor.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -189,7 +189,7 @@
             mActorControlledObject-&gt;getMovableObject()-&gt;setQueryFlags( flags );
         else
         {
-            if( flags != NULL )
+            if( flags != 0 )
                 LOG_ERROR(Logger::CORE, &quot;Queryflags could not be set, because ActorControlledObject was NULL&quot;);
         }
     }

Modified: rl/trunk/engine/core/src/ContentModule.cpp
===================================================================
--- rl/trunk/engine/core/src/ContentModule.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/core/src/ContentModule.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -1,209 +1,210 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;ContentModule.h&quot;
-
-
-#include &quot;ConfigurationManager.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;RubyInterpreter.h&quot;
-#include &quot;SoundManager.h&quot;
-#include &quot;World.h&quot;
-
-using namespace Ogre;
-
-namespace rl
-{
-    ContentModule::ContentModule(const Ogre::String&amp; id, const CeGuiString&amp; name, bool common, long minimumEngineVersion)
-    :    mId(id),
-        mName(name),
-        mCommon(common),
-        mMinimumEngineVersion(minimumEngineVersion),
-        mLoaded(false)
-    {
-    }
-
-    ContentModule::~ContentModule()
-    {
-    }
-
-    const Ogre::String ContentModule::getInitFile(const Ogre::String&amp; moduleId)
-    {
-        return getDirectory(moduleId) + &quot;/scripts/moduleconfig.rb&quot;;
-    }
-
-    const Ogre::String ContentModule::getDirectory(const Ogre::String&amp; moduleId)
-    {
-        return ConfigurationManager::getSingleton().
-                getModulesRootDirectory() + &quot;/&quot; + moduleId;
-    }
-
-    const Ogre::String ContentModule::getDirectory() const
-    {
-        return ContentModule::getDirectory(mId);
-    }
-
-    const CeGuiString&amp; ContentModule::getName() const
-    {
-        return mName;
-    }
-
-    const Ogre::String&amp; ContentModule::getId() const
-    {
-        return mId;
-    }
-
-    long ContentModule::getMinimumEngineVersion() const
-    {
-        return mMinimumEngineVersion;
-    }
-
-    bool ContentModule::isCommon() const
-    {
-        return mCommon;
-    }
-
-    void ContentModule::initializeTextures() const
-    {
-        Ogre::String resourceGroup = getId();
-
-        StringVector texLocations = getTextureLocations();
-        for(StringVector::iterator iter = texLocations.begin();
-            iter != texLocations.end();
-            iter++)
-        {
-            Ogre::String location = *iter;
-            if (location.find(&quot;.zip&quot;) != Ogre::String::npos)
-            {
-                ResourceGroupManager::getSingleton().addResourceLocation(
-                    getDirectory() + &quot;/materials/&quot; + location, Ogre::String(&quot;Zip&quot;), resourceGroup);
-            }
-            else
-            {
-                ResourceGroupManager::getSingleton().addResourceLocation(
-                    getDirectory() + &quot;/materials/&quot; + location, &quot;FileSystem&quot;, resourceGroup);
-            }
-        }
-
-        addSearchPath(getDirectory()+&quot;/materials&quot;, resourceGroup);
-    }
-
-    void ContentModule::initialize()
-    {
-        SaveGameManager::getSingleton().registerSaveGameData(this);
-
-        Ogre::String moduleDir = getDirectory();
-
-        Ogre::String resourceGroup = getId();
-
-        addSearchPath(moduleDir + &quot;/conf&quot;, resourceGroup);
-        addSearchPath(moduleDir + &quot;/dsa&quot;, resourceGroup);
-        addSearchPath(moduleDir + &quot;/maps&quot;, resourceGroup);
-        addSearchPath(moduleDir + &quot;/models&quot;, resourceGroup);
-           StringVector modelLoc = getModelLocations();
-        for (StringVector::iterator it = modelLoc.begin(); it != modelLoc.end(); ++it)
-        {
-            addSearchPath(moduleDir + &quot;/models/&quot;+*it, resourceGroup);
-        }
-
-        addSearchPath(moduleDir + &quot;/sound&quot;, resourceGroup); ///@todo ueber Verzeichnisnamen nachdenken
-        StringVector soundLoc = getSoundLocations();
-        for (StringVector::iterator it = soundLoc.begin(); it != soundLoc.end(); ++it)
-        {
-            addSearchPath(moduleDir + &quot;/sound/&quot;+*it, resourceGroup);
-        }
-
-        addSearchPath(moduleDir + &quot;/gui&quot;, resourceGroup);
-        addSearchPath(moduleDir + &quot;/gui/fonts&quot;, resourceGroup);
-        addSearchPath(moduleDir + &quot;/gui/imagesets&quot;, resourceGroup);
-        addSearchPath(moduleDir + &quot;/gui/schemes&quot;, resourceGroup);
-        addSearchPath(moduleDir + &quot;/gui/windows&quot;, resourceGroup);
-        addSearchPath(moduleDir + &quot;/gui/windows/buttons&quot;, resourceGroup);
-        addSearchPath(moduleDir + &quot;/dialogs&quot;, resourceGroup);
-        addSearchPath(moduleDir + &quot;/quests&quot;, resourceGroup);
-
-        RubyInterpreter* interpreter = CoreSubsystem::getSingleton().getRubyInterpreter();
-        if (interpreter != NULL)
-        {
-            interpreter-&gt;addSearchPath(moduleDir + &quot;/scripts&quot;);
-            interpreter-&gt;addSearchPath(moduleDir + &quot;/scripts/maps&quot;);
-        }
-
-        mLoaded = true;
-    }
-
-    void ContentModule::addSearchPath(const Ogre::String&amp; path, const Ogre::String&amp; resourceGroup) const
-    {
-        try
-        {
-            ResourceGroupManager::getSingleton().addResourceLocation(path,
-                &quot;FileSystem&quot;, resourceGroup);
-        }
-        catch(...)
-        {
-            // and forget
-        }
-    }
-
-    void ContentModule::precreateMeshes() const
-    {
-        StringVectorPtr meshes = ResourceGroupManager::getSingleton()
-            .findResourceNames(getId(), &quot;*.mesh&quot;);
-
-        for (size_t i = 0; i &lt; meshes-&gt;size(); ++i)
-        {
-            ResourcePtr res = MeshManager::getSingleton().getByName((*meshes)[i]);
-            if (res.isNull())
-            {
-                MeshPtr mesh = MeshManager::getSingleton().create((*meshes)[i],
-                    getId());
-            }
-        }
-    }
-
-    void ContentModule::unload()
-    {
-        SaveGameManager::getSingleton().unregisterSaveGameData(this);
-        //TODO: unloadModule
-        CoreSubsystem::getSingleton().getWorld()-&gt;clearScene();
-        mLoaded = false;
-    }
-
-    bool ContentModule::isLoaded() const
-    {
-        return mLoaded;
-    }
-
-    CeGuiString ContentModule::getXmlNodeIdentifier() const
-    {
-        return &quot;ContentModule&quot;;
-    }
-
-    void ContentModule::writeData(SaveGameFileWriter* writer)
-    {
-    }
-
-    void ContentModule::readData(SaveGameFileReader* reader)
-    {
-    }
-
-    /// defines the loading/saving order higher priority are saved last and loaded first
-    int ContentModule::getPriority() const
-    {
-        return 10;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;ContentModule.h&quot;
+
+
+#include &quot;ConfigurationManager.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;RubyInterpreter.h&quot;
+#include &quot;SaveGameManager.h&quot;
+#include &quot;SoundManager.h&quot;
+#include &quot;World.h&quot;
+
+using namespace Ogre;
+
+namespace rl
+{
+    ContentModule::ContentModule(const Ogre::String&amp; id, const CeGuiString&amp; name, bool common, long minimumEngineVersion)
+    :    mId(id),
+        mName(name),
+        mCommon(common),
+        mMinimumEngineVersion(minimumEngineVersion),
+        mLoaded(false)
+    {
+    }
+
+    ContentModule::~ContentModule()
+    {
+    }
+
+    const Ogre::String ContentModule::getInitFile(const Ogre::String&amp; moduleId)
+    {
+        return getDirectory(moduleId) + &quot;/scripts/moduleconfig.rb&quot;;
+    }
+
+    const Ogre::String ContentModule::getDirectory(const Ogre::String&amp; moduleId)
+    {
+        return ConfigurationManager::getSingleton().
+                getModulesRootDirectory() + &quot;/&quot; + moduleId;
+    }
+
+    const Ogre::String ContentModule::getDirectory() const
+    {
+        return ContentModule::getDirectory(mId);
+    }
+
+    const CeGuiString&amp; ContentModule::getName() const
+    {
+        return mName;
+    }
+
+    const Ogre::String&amp; ContentModule::getId() const
+    {
+        return mId;
+    }
+
+    long ContentModule::getMinimumEngineVersion() const
+    {
+        return mMinimumEngineVersion;
+    }
+
+    bool ContentModule::isCommon() const
+    {
+        return mCommon;
+    }
+
+    void ContentModule::initializeTextures() const
+    {
+        Ogre::String resourceGroup = getId();
+
+        StringVector texLocations = getTextureLocations();
+        for(StringVector::iterator iter = texLocations.begin();
+            iter != texLocations.end();
+            iter++)
+        {
+            Ogre::String location = *iter;
+            if (location.find(&quot;.zip&quot;) != Ogre::String::npos)
+            {
+                ResourceGroupManager::getSingleton().addResourceLocation(
+                    getDirectory() + &quot;/materials/&quot; + location, Ogre::String(&quot;Zip&quot;), resourceGroup);
+            }
+            else
+            {
+                ResourceGroupManager::getSingleton().addResourceLocation(
+                    getDirectory() + &quot;/materials/&quot; + location, &quot;FileSystem&quot;, resourceGroup);
+            }
+        }
+
+        addSearchPath(getDirectory()+&quot;/materials&quot;, resourceGroup);
+    }
+
+    void ContentModule::initialize()
+    {
+        SaveGameManager::getSingleton().registerSaveGameData(this);
+
+        Ogre::String moduleDir = getDirectory();
+
+        Ogre::String resourceGroup = getId();
+
+        addSearchPath(moduleDir + &quot;/conf&quot;, resourceGroup);
+        addSearchPath(moduleDir + &quot;/dsa&quot;, resourceGroup);
+        addSearchPath(moduleDir + &quot;/maps&quot;, resourceGroup);
+        addSearchPath(moduleDir + &quot;/models&quot;, resourceGroup);
+           StringVector modelLoc = getModelLocations();
+        for (StringVector::iterator it = modelLoc.begin(); it != modelLoc.end(); ++it)
+        {
+            addSearchPath(moduleDir + &quot;/models/&quot;+*it, resourceGroup);
+        }
+
+        addSearchPath(moduleDir + &quot;/sound&quot;, resourceGroup); ///@todo ueber Verzeichnisnamen nachdenken
+        StringVector soundLoc = getSoundLocations();
+        for (StringVector::iterator it = soundLoc.begin(); it != soundLoc.end(); ++it)
+        {
+            addSearchPath(moduleDir + &quot;/sound/&quot;+*it, resourceGroup);
+        }
+
+        addSearchPath(moduleDir + &quot;/gui&quot;, resourceGroup);
+        addSearchPath(moduleDir + &quot;/gui/fonts&quot;, resourceGroup);
+        addSearchPath(moduleDir + &quot;/gui/imagesets&quot;, resourceGroup);
+        addSearchPath(moduleDir + &quot;/gui/schemes&quot;, resourceGroup);
+        addSearchPath(moduleDir + &quot;/gui/windows&quot;, resourceGroup);
+        addSearchPath(moduleDir + &quot;/gui/windows/buttons&quot;, resourceGroup);
+        addSearchPath(moduleDir + &quot;/dialogs&quot;, resourceGroup);
+        addSearchPath(moduleDir + &quot;/quests&quot;, resourceGroup);
+
+        RubyInterpreter* interpreter = CoreSubsystem::getSingleton().getRubyInterpreter();
+        if (interpreter != NULL)
+        {
+            interpreter-&gt;addSearchPath(moduleDir + &quot;/scripts&quot;);
+            interpreter-&gt;addSearchPath(moduleDir + &quot;/scripts/maps&quot;);
+        }
+
+        mLoaded = true;
+    }
+
+    void ContentModule::addSearchPath(const Ogre::String&amp; path, const Ogre::String&amp; resourceGroup) const
+    {
+        try
+        {
+            ResourceGroupManager::getSingleton().addResourceLocation(path,
+                &quot;FileSystem&quot;, resourceGroup);
+        }
+        catch(...)
+        {
+            // and forget
+        }
+    }
+
+    void ContentModule::precreateMeshes() const
+    {
+        StringVectorPtr meshes = ResourceGroupManager::getSingleton()
+            .findResourceNames(getId(), &quot;*.mesh&quot;);
+
+        for (size_t i = 0; i &lt; meshes-&gt;size(); ++i)
+        {
+            ResourcePtr res = MeshManager::getSingleton().getByName((*meshes)[i]);
+            if (res.isNull())
+            {
+                MeshPtr mesh = MeshManager::getSingleton().create((*meshes)[i],
+                    getId());
+            }
+        }
+    }
+
+    void ContentModule::unload()
+    {
+        SaveGameManager::getSingleton().unregisterSaveGameData(this);
+        //TODO: unloadModule
+        CoreSubsystem::getSingleton().getWorld()-&gt;clearScene();
+        mLoaded = false;
+    }
+
+    bool ContentModule::isLoaded() const
+    {
+        return mLoaded;
+    }
+
+    CeGuiString ContentModule::getXmlNodeIdentifier() const
+    {
+        return &quot;ContentModule&quot;;
+    }
+
+    void ContentModule::writeData(SaveGameFileWriter* writer)
+    {
+    }
+
+    void ContentModule::readData(SaveGameFileReader* reader)
+    {
+    }
+
+    /// defines the loading/saving order higher priority are saved last and loaded first
+    int ContentModule::getPriority() const
+    {
+        return 10;
+    }
+}

Modified: rl/trunk/engine/core/src/JobScheduler.cpp
===================================================================
--- rl/trunk/engine/core/src/JobScheduler.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/core/src/JobScheduler.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -20,6 +20,7 @@
 #include &quot;JobListener.h&quot;
 #include &quot;GameLoop.h&quot;
 #include &quot;TimeSource.h&quot;
+#include &quot;SaveGameManager.h&quot;
 
 using namespace Ogre;
 

Modified: rl/trunk/engine/core/src/SaveGameFileReader.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveGameFileReader.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/core/src/SaveGameFileReader.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -1,113 +1,113 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#include &quot;stdinc.h&quot;
-
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
-#include &quot;SaveGameFileReader.h&quot;
-
-#include &quot;SaveGameManager.h&quot;
-
-#include &quot;CoreSubsystem.h&quot;
-
-using namespace XERCES_CPP_NAMESPACE;
-
-namespace rl
-{
-    SaveGameFileReader::SaveGameFileReader()
-    {
-    }
-
-    void SaveGameFileReader::parseSaveGameFile(SaveGameFile* file, const SaveGameDataOrderMap &amp;map)
-    {
-        initializeXml();
-
-        mDocument = loadDocument(file-&gt;getDataStream());
-
-        int version = getAttributeValueAsInteger(mDocument-&gt;getDocumentElement(), &quot;Engineversion&quot;);
-        if(version &gt;= CoreSubsystem::getSingleton().getEngineBuildNumber())
-            LOG_MESSAGE(Logger::CORE, &quot;Loading save game: Engine version is ok&quot;);
-        else
-            LOG_ERROR(Logger::CORE, &quot;Loading save game: Save game version is newer then engine version! Loading save game could crash&quot;);
-
-        for(SaveGameDataOrderMap::const_reverse_iterator data_iter = map.rbegin(); data_iter != map.rend(); data_iter++)
-        {
-            data_iter-&gt;second-&gt;readData(this);
-        }
-
-
-        mDocument-&gt;release();
-
-        file-&gt;closeDataStream(); //make the save game writable
-
-        mDocument = NULL;
-
-        shutdownXml();
-    }
-
-    void SaveGameFileReader::parseSaveGameFileHeader(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName, SaveGameFile* file)
-    {
-        initializeXml();
-
-        if(stream-&gt;size())
-        {
-            DOMDocument* doc = loadDocument(stream);
-
-             DOMNodeList* headerDefsXml = doc-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(&quot;header&quot;).data());
-             if(headerDefsXml-&gt;getLength())
-             {
-                 DOMElement* elem = static_cast&lt;DOMElement*&gt;(headerDefsXml-&gt;item(0));
-                 /*DOMNodeList* headerDefChildren = elem-&gt;getChildNodes();
-                 for(XMLSize_t childIdx = 0; childIdx &lt; headerDefChildren-&gt;getLength(); childIdx++)
-                 {
-                     DOMNode* curChild = headerDefChildren-&gt;item(childIdx);
-                     if (curChild-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-                     {
-                         PropertyEntry entry = processProperty(static_cast&lt;DOMElement*&gt;(curChild));
-                         if(entry.first != &quot;&quot;)
-                         {
-                            file-&gt;setProperty(entry.first, entry.second);
-                         }
-                     }
-                 }*/
-                 PropertyRecord set = getPropertiesAsRecord(elem);
-                 file-&gt;setProperties(&amp;set);
-             }
-        }
-
-        shutdownXml();
-    }
-
-    PropertyRecord SaveGameFileReader::getAllPropertiesAsRecord(SaveGameData* data)
-    {
-        PropertyRecord properties;
-
-        initializeXml();
-
-        DOMNodeList* rootNodeList = getDocument()-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(data-&gt;getXmlNodeIdentifier().c_str()).data());
-
-        if (rootNodeList-&gt;getLength())
-        {
-            DOMNode* xmlPropElem = rootNodeList-&gt;item(0);
-            properties = getPropertiesAsRecord(static_cast&lt;DOMElement*&gt;(xmlPropElem));
-        }
-
-        shutdownXml();
-
-        return properties;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#include &quot;stdinc.h&quot;
+
+#include &lt;xercesc/dom/DOM.hpp&gt;
+
+#include &quot;SaveGameFileReader.h&quot;
+#include &quot;SaveGameManager.h&quot;
+#include &quot;SaveGameData.h&quot;
+
+#include &quot;CoreSubsystem.h&quot;
+
+using namespace XERCES_CPP_NAMESPACE;
+
+namespace rl
+{
+    SaveGameFileReader::SaveGameFileReader()
+    {
+    }
+
+    void SaveGameFileReader::parseSaveGameFile(SaveGameFile* file, const SaveGameDataOrderMap &amp;map)
+    {
+        initializeXml();
+
+        mDocument = loadDocument(file-&gt;getDataStream());
+
+        int version = getAttributeValueAsInteger(mDocument-&gt;getDocumentElement(), &quot;Engineversion&quot;);
+        if(version &gt;= CoreSubsystem::getSingleton().getEngineBuildNumber())
+            LOG_MESSAGE(Logger::CORE, &quot;Loading save game: Engine version is ok&quot;);
+        else
+            LOG_ERROR(Logger::CORE, &quot;Loading save game: Save game version is newer then engine version! Loading save game could crash&quot;);
+
+        for(SaveGameDataOrderMap::const_reverse_iterator data_iter = map.rbegin(); data_iter != map.rend(); data_iter++)
+        {
+            data_iter-&gt;second-&gt;readData(this);
+        }
+
+
+        mDocument-&gt;release();
+
+        file-&gt;closeDataStream(); //make the save game writable
+
+        mDocument = NULL;
+
+        shutdownXml();
+    }
+
+    void SaveGameFileReader::parseSaveGameFileHeader(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName, SaveGameFile* file)
+    {
+        initializeXml();
+
+        if(stream-&gt;size())
+        {
+            DOMDocument* doc = loadDocument(stream);
+
+             DOMNodeList* headerDefsXml = doc-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(&quot;header&quot;).data());
+             if(headerDefsXml-&gt;getLength())
+             {
+                 DOMElement* elem = static_cast&lt;DOMElement*&gt;(headerDefsXml-&gt;item(0));
+                 /*DOMNodeList* headerDefChildren = elem-&gt;getChildNodes();
+                 for(XMLSize_t childIdx = 0; childIdx &lt; headerDefChildren-&gt;getLength(); childIdx++)
+                 {
+                     DOMNode* curChild = headerDefChildren-&gt;item(childIdx);
+                     if (curChild-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+                     {
+                         PropertyEntry entry = processProperty(static_cast&lt;DOMElement*&gt;(curChild));
+                         if(entry.first != &quot;&quot;)
+                         {
+                            file-&gt;setProperty(entry.first, entry.second);
+                         }
+                     }
+                 }*/
+                 PropertyRecord set = getPropertiesAsRecord(elem);
+                 file-&gt;setProperties(&amp;set);
+             }
+        }
+
+        shutdownXml();
+    }
+
+    PropertyRecord SaveGameFileReader::getAllPropertiesAsRecord(SaveGameData* data)
+    {
+        PropertyRecord properties;
+
+        initializeXml();
+
+        DOMNodeList* rootNodeList = getDocument()-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(data-&gt;getXmlNodeIdentifier().c_str()).data());
+
+        if (rootNodeList-&gt;getLength())
+        {
+            DOMNode* xmlPropElem = rootNodeList-&gt;item(0);
+            properties = getPropertiesAsRecord(static_cast&lt;DOMElement*&gt;(xmlPropElem));
+        }
+
+        shutdownXml();
+
+        return properties;
+    }
+}

Modified: rl/trunk/engine/core/src/SaveGameManager.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveGameManager.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/core/src/SaveGameManager.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -18,11 +18,12 @@
 
 #include &quot;SaveGameManager.h&quot;
 
-#include &lt;CoreSubsystem.h&gt;
-#include &lt;ContentModule.h&gt;
-#include &lt;ConfigurationManager.h&gt;
+#include &quot;CoreMessages.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;ContentModule.h&quot;
+#include &quot;ConfigurationManager.h&quot;
 
-#include &lt;XmlProcessor.h&gt;
+#include &quot;XmlProcessor.h&quot;
 
 #include &lt;xercesc/dom/DOM.hpp&gt;
 #include &lt;xercesc/framework/LocalFileFormatTarget.hpp&gt;

Modified: rl/trunk/engine/core/src/TimeSource.cpp
===================================================================
--- rl/trunk/engine/core/src/TimeSource.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/core/src/TimeSource.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -19,6 +19,7 @@
 #include &quot;TimeSource.h&quot;
 
 #include &quot;GameLoop.h&quot;
+#include &quot;SaveGameManager.h&quot;
 
 template&lt;&gt; rl::TimeSourceManager* Ogre::Singleton&lt;rl::TimeSourceManager&gt;::ms_Singleton = 0;
 

Modified: rl/trunk/engine/core/src/ZoneManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ZoneManager.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/core/src/ZoneManager.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -23,6 +23,7 @@
 #include &quot;GameEventManager.h&quot;
 #include &quot;Zone.h&quot;
 #include &quot;World.h&quot;
+#include &quot;SaveGameManager.h&quot;
 #include &quot;ScriptWrapper.h&quot;
 #include &quot;Sound.h&quot;
 #include &quot;SoundManager.h&quot;

Modified: rl/trunk/engine/rules/include/CreatureControllerManager.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureControllerManager.h	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/rules/include/CreatureControllerManager.h	2008-03-20 19:41:24 UTC (rev 4301)
@@ -21,7 +21,7 @@
 #include &quot;RulesPrerequisites.h&quot;
 #include &quot;GameTask.h&quot;
 #include &quot;PhysicsGenericContactCallback.h&quot;
-#include &lt;SaveGameManager.h&gt;
+#include &quot;SaveGameData.h&quot;
 #include &lt;vector&gt;
 #include &lt;map&gt;
 

Modified: rl/trunk/engine/rules/include/GameObjectManager.h
===================================================================
--- rl/trunk/engine/rules/include/GameObjectManager.h	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/rules/include/GameObjectManager.h	2008-03-20 19:41:24 UTC (rev 4301)
@@ -1,107 +1,107 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#ifndef __GAMEOBJECTMANAGER_H__
-#define __GAMEOBJECTMANAGER_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-#include &quot;GameObjectStateListener.h&quot;
-
-#include &lt;SaveGameManager.h&gt;
-
-#include &lt;map&gt;
-
-namespace rl
-{
-    class GameObject;
-	class Property;
-    class PropertyRecord;
-
-    typedef MessageType&lt;RLMSG_SAVEGAME_GOS_LOADED&gt; MessageType_GameObjectsLoaded;
-
-    class _RlRulesExport GameObjectFactory
-    {
-    public:
-        GameObjectFactory();
-
-        GameObject* createGameObject(const Ogre::String&amp; classname, unsigned int id);
-        virtual GameObject* createRubyGameObject(const Ogre::String&amp; classname, unsigned int id) = 0;
-    };
-
-    class _RlRulesExport GameObjectManager : 
-        public Ogre::Singleton&lt;GameObjectManager&gt;,
-        public GameObjectStateListener,
-        public Ogre::ScriptLoader,
-        public SaveGameData
-    {
-    public:
-        GameObjectManager();
-        ~GameObjectManager();
-
-        GameObject* getGameObject(unsigned int id) const;
-        GameObject* createGameObject(const Ogre::String&amp; classId, unsigned int id = 0);
-		
-        void deleteGameObject(unsigned int id);
-        void deleteGameObject(GameObject* obj);
-        void deleteAllGameObjects();
-
-        GameObject* createGameObjectFromProperty(const Property&amp; goProp);
-		Property toProperty(const GameObject* const co) const;
-        std::list&lt;GameObject*&gt; getAllGameObjects() const;
-        void setGameObjectFactory(GameObjectFactory* gof);
-        void loadProperties(const Ogre::String&amp; module);
-
-        virtual const Ogre::StringVector&amp; getScriptPatterns() const;
-        virtual Ogre::Real getLoadingOrder() const;
-        virtual void parseScript(Ogre::DataStreamPtr&amp; stream, const Ogre::String&amp; groupName);
-
-        /// Override from GameObjectStateListener.
-        /// Used to propagate to global GameObjectStateListeners.
-        virtual void gameObjectStateChanged(GameObject* go, GameObjectState oldState,
-            GameObjectState newState);
-
-        void registerGameObjectStateListener(GameObjectStateListener* listener);
-        void unregisterGameObjectStateListener(GameObjectStateListener* listener);
-        void unregisterAllGameObjectStateListener();
-
-        /// Override from SaveGameData
-        /// Manages saving and loading from the SaveGameFile
-
-        virtual CeGuiString getXmlNodeIdentifier() const;
-        virtual void writeData(SaveGameFileWriter* writer);
-        virtual void readData(SaveGameFileReader* reader);
-        virtual int getPriority() const;
-    private:
-        typedef std::map&lt;const Ogre::String, PropertyRecord*&gt; ClassPropertyMap;
-        typedef std::set&lt;GameObjectStateListener*&gt; GameObjectStateListenerSet;
-
-        Ogre::StringVector mScriptPatterns;
-
-        std::map&lt;unsigned int, GameObject*&gt; mGameObjects;
-        ClassPropertyMap mClassProperties;
-        unsigned int mGeneratedId;
-        GameObjectFactory* mGameObjectFactory;
-        GameObjectStateListenerSet mGameObjectStateListeners;
-
-        unsigned int generateId();
-        PropertyRecord* getClassProperties(const Ogre::String&amp; classId) const;
-        void applyProperties(GameObject* go, PropertyRecord* ps) const;
-
-        PropertyMap getPropertyMapDifference(PropertyMap map1, PropertyMap map2);
-    };
-}
-
-#endif //__GAMEOBJECTMANAGER_H__
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __GAMEOBJECTMANAGER_H__
+#define __GAMEOBJECTMANAGER_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+#include &quot;GameObjectStateListener.h&quot;
+
+#include &quot;Property.h&quot;
+#include &quot;SaveGameData.h&quot;
+
+#include &lt;map&gt;
+
+namespace rl
+{
+    class GameObject;
+	class Property;
+    class PropertyRecord;
+
+
+    class _RlRulesExport GameObjectFactory
+    {
+    public:
+        GameObjectFactory();
+
+        GameObject* createGameObject(const Ogre::String&amp; classname, unsigned int id);
+        virtual GameObject* createRubyGameObject(const Ogre::String&amp; classname, unsigned int id) = 0;
+    };
+
+    class _RlRulesExport GameObjectManager : 
+        public Ogre::Singleton&lt;GameObjectManager&gt;,
+        public GameObjectStateListener,
+        public Ogre::ScriptLoader,
+        public SaveGameData
+    {
+    public:
+        GameObjectManager();
+        ~GameObjectManager();
+
+        GameObject* getGameObject(unsigned int id) const;
+        GameObject* createGameObject(const Ogre::String&amp; classId, unsigned int id = 0);
+		
+        void deleteGameObject(unsigned int id);
+        void deleteGameObject(GameObject* obj);
+        void deleteAllGameObjects();
+
+        GameObject* createGameObjectFromProperty(const Property&amp; goProp);
+		Property toProperty(const GameObject* const co) const;
+        std::list&lt;GameObject*&gt; getAllGameObjects() const;
+        void setGameObjectFactory(GameObjectFactory* gof);
+        void loadProperties(const Ogre::String&amp; module);
+
+        virtual const Ogre::StringVector&amp; getScriptPatterns() const;
+        virtual Ogre::Real getLoadingOrder() const;
+        virtual void parseScript(Ogre::DataStreamPtr&amp; stream, const Ogre::String&amp; groupName);
+
+        /// Override from GameObjectStateListener.
+        /// Used to propagate to global GameObjectStateListeners.
+        virtual void gameObjectStateChanged(GameObject* go, GameObjectState oldState,
+            GameObjectState newState);
+
+        void registerGameObjectStateListener(GameObjectStateListener* listener);
+        void unregisterGameObjectStateListener(GameObjectStateListener* listener);
+        void unregisterAllGameObjectStateListener();
+
+        /// Override from SaveGameData
+        /// Manages saving and loading from the SaveGameFile
+
+        virtual CeGuiString getXmlNodeIdentifier() const;
+        virtual void writeData(SaveGameFileWriter* writer);
+        virtual void readData(SaveGameFileReader* reader);
+        virtual int getPriority() const;
+    private:
+        typedef std::map&lt;const Ogre::String, PropertyRecord*&gt; ClassPropertyMap;
+        typedef std::set&lt;GameObjectStateListener*&gt; GameObjectStateListenerSet;
+
+        Ogre::StringVector mScriptPatterns;
+
+        std::map&lt;unsigned int, GameObject*&gt; mGameObjects;
+        ClassPropertyMap mClassProperties;
+        unsigned int mGeneratedId;
+        GameObjectFactory* mGameObjectFactory;
+        GameObjectStateListenerSet mGameObjectStateListeners;
+
+        unsigned int generateId();
+        PropertyRecord* getClassProperties(const Ogre::String&amp; classId) const;
+        void applyProperties(GameObject* go, PropertyRecord* ps) const;
+
+        PropertyMap getPropertyMapDifference(PropertyMap map1, PropertyMap map2);
+    };
+}
+
+#endif //__GAMEOBJECTMANAGER_H__

Modified: rl/trunk/engine/rules/include/GlobalProperties.h
===================================================================
--- rl/trunk/engine/rules/include/GlobalProperties.h	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/rules/include/GlobalProperties.h	2008-03-20 19:41:24 UTC (rev 4301)
@@ -1,56 +1,56 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __GLOBALPROPERTIES_H__
-#define __GLOBALPROPERTIES_H__
-
-#include &lt;Properties.h&gt;
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &lt;SaveGameManager.h&gt;
-
-namespace rl
-{
-    class _RlRulesExport GlobalProperties 
-        : public PropertyHolder, 
-        public Ogre::Singleton&lt;GlobalProperties&gt;, 
-        public SaveGameData
-    {
-    public:
-        /** Default Constructor */
-        GlobalProperties();
-        /** Default Deconstructor */
-        virtual ~GlobalProperties();
-
-        /// Overrides from PropertyHolder
-        virtual const Property getProperty(const CeGuiString&amp; key) const;
-        virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
-        virtual PropertyKeys getAllPropertyKeys() const;
-        bool hasProperty(const Ogre::String&amp; key) const;
-
-        /// Overrides from SaveGameData
-        /// Manages saving and loading from the SaveGameFile
-        virtual CeGuiString getXmlNodeIdentifier() const;
-        virtual void writeData(SaveGameFileWriter* writer);
-        virtual void readData(SaveGameFileReader* reader);
-        virtual int getPriority() const;
-    protected:
-        PropertyRecord* mProperties;
-    };
-}
-
-#endif
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __GLOBALPROPERTIES_H__
+#define __GLOBALPROPERTIES_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &quot;Properties.h&quot;
+#include &quot;SaveGameData.h&quot;
+
+namespace rl
+{
+    class _RlRulesExport GlobalProperties 
+        : public PropertyHolder, 
+        public Ogre::Singleton&lt;GlobalProperties&gt;, 
+        public SaveGameData
+    {
+    public:
+        /** Default Constructor */
+        GlobalProperties();
+        /** Default Deconstructor */
+        virtual ~GlobalProperties();
+
+        /// Overrides from PropertyHolder
+        virtual const Property getProperty(const CeGuiString&amp; key) const;
+        virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
+        virtual PropertyKeys getAllPropertyKeys() const;
+        bool hasProperty(const Ogre::String&amp; key) const;
+
+        /// Overrides from SaveGameData
+        /// Manages saving and loading from the SaveGameFile
+        virtual CeGuiString getXmlNodeIdentifier() const;
+        virtual void writeData(SaveGameFileWriter* writer);
+        virtual void readData(SaveGameFileReader* reader);
+        virtual int getPriority() const;
+    protected:
+        PropertyRecord* mProperties;
+    };
+}
+
+#endif
+

Modified: rl/trunk/engine/rules/include/QuestBook.h
===================================================================
--- rl/trunk/engine/rules/include/QuestBook.h	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/rules/include/QuestBook.h	2008-03-20 19:41:24 UTC (rev 4301)
@@ -1,119 +1,119 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __QUESTBOOK_H__
-#define __QUESTBOOK_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &quot;EventSource.h&quot;
-#include &quot;EventCaster.h&quot;
-
-#include &quot;JournalEntry.h&quot;
-
-#include &quot;Quest.h&quot;
-#include &quot;QuestEvent.h&quot;
-#include &quot;QuestListener.h&quot;
-
-#include &lt;SaveGameManager.h&gt;
-
-#include &lt;vector&gt;
-
-namespace rl {
-
-///@todo Rename this class to reflect scope changes.
-class _RlRulesExport QuestBook : 
-    public Ogre::ScriptLoader,
-    public EventSource, 
-    public PropertyHolder, 
-    public SaveGameData,
-    public XmlProcessor
-{
-public:
-    static const Ogre::String PROPERTY_QUESTS;
-    static const Ogre::String PROPERTY_JOURNAL;
-
-	QuestBook();
-	~QuestBook();
-
-	/**
-	 * Sucht einen Quest anhand einer ID
-	 * @return der Quest
-	 */
-	Quest* getQuest(const CeGuiString id) const;
-
-	QuestVector getTopLevelQuests() const;
-
-	/**
-	 * Fuegt einen Quest hinzu
-	 * @param quest der Qubquest
-	 */
-	void addQuest(Quest* quest);
-
-    /**
-     *  Adds a journal entry to the quest book.
-     */
-    void addJournalEntry(JournalEntry* entry);
-    void addJournalEntry(CeGuiString caption, CeGuiString text);
-
-    unsigned int getNumJournalEntries() const;
-
-    JournalEntry* getJournalEntry(unsigned int index) const;
-
-	void addQuestListener(QuestListener* listener);
-	void removeQuestListener(QuestListener* listener);
-
-    void _fireQuestBookChanged(Quest* quest, int reason);
-
-    virtual const Property getProperty(const CeGuiString&amp; key) const;
-    PropertyArray getQuestsProperty(const Quest* rootQuest) const;
-    virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
-    void setQuestsProperty(PropertyArray array, Quest* rootQuest);
-    virtual PropertyKeys getAllPropertyKeys() const;
-
-    /// Override from SaveGameData
-    /// Manages saving and loading from the SaveGameFile
-
-    virtual CeGuiString getXmlNodeIdentifier() const;
-    virtual void writeData(SaveGameFileWriter* writer);
-    virtual void readData(SaveGameFileReader* reader);
-    virtual int getPriority() const;
-
-    //loading quests from xml
-    virtual const Ogre::StringVector &amp;getScriptPatterns(void) const;
-    virtual void parseScript(Ogre::DataStreamPtr &amp;,const Ogre::String &amp;);
-    virtual Ogre::Real getLoadingOrder(void) const;
-private:
-    Ogre::StringVector mScriptPatterns;
-
-	Quest* getQuest(Quest* parent, const CeGuiString id) const;
-    void clear();
-    void createRoot();
-    QuestVector getAllQuests() const;
-
-	Quest* mRootQuest;
-    std::vector&lt;JournalEntry*&gt; mJournalEntries;
-	EventCaster&lt;QuestEvent&gt; mQuestEventCaster;
-	EventCaster&lt;JournalEvent&gt; mJournalEventCaster;
-
-    void fireJournalChanged(JournalEntry* entry, int reason);
-
-    //loading quests from xml
-    virtual Quest* processQuest(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, Quest* parent);
-};
-
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __QUESTBOOK_H__
+#define __QUESTBOOK_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &quot;EventSource.h&quot;
+#include &quot;EventCaster.h&quot;
+
+#include &quot;JournalEntry.h&quot;
+
+#include &quot;Quest.h&quot;
+#include &quot;QuestEvent.h&quot;
+#include &quot;QuestListener.h&quot;
+#include &quot;SaveGameData.h&quot;
+#include &quot;XmlProcessor.h&quot;
+
+#include &lt;vector&gt;
+
+namespace rl {
+
+///@todo Rename this class to reflect scope changes.
+class _RlRulesExport QuestBook : 
+    public Ogre::ScriptLoader,
+    public EventSource, 
+    public PropertyHolder, 
+    public SaveGameData,
+    public XmlProcessor
+{
+public:
+    static const Ogre::String PROPERTY_QUESTS;
+    static const Ogre::String PROPERTY_JOURNAL;
+
+	QuestBook();
+	~QuestBook();
+
+	/**
+	 * Sucht einen Quest anhand einer ID
+	 * @return der Quest
+	 */
+	Quest* getQuest(const CeGuiString id) const;
+
+	QuestVector getTopLevelQuests() const;
+
+	/**
+	 * Fuegt einen Quest hinzu
+	 * @param quest der Qubquest
+	 */
+	void addQuest(Quest* quest);
+
+    /**
+     *  Adds a journal entry to the quest book.
+     */
+    void addJournalEntry(JournalEntry* entry);
+    void addJournalEntry(CeGuiString caption, CeGuiString text);
+
+    unsigned int getNumJournalEntries() const;
+
+    JournalEntry* getJournalEntry(unsigned int index) const;
+
+	void addQuestListener(QuestListener* listener);
+	void removeQuestListener(QuestListener* listener);
+
+    void _fireQuestBookChanged(Quest* quest, int reason);
+
+    virtual const Property getProperty(const CeGuiString&amp; key) const;
+    PropertyArray getQuestsProperty(const Quest* rootQuest) const;
+    virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
+    void setQuestsProperty(PropertyArray array, Quest* rootQuest);
+    virtual PropertyKeys getAllPropertyKeys() const;
+
+    /// Override from SaveGameData
+    /// Manages saving and loading from the SaveGameFile
+
+    virtual CeGuiString getXmlNodeIdentifier() const;
+    virtual void writeData(SaveGameFileWriter* writer);
+    virtual void readData(SaveGameFileReader* reader);
+    virtual int getPriority() const;
+
+    //loading quests from xml
+    virtual const Ogre::StringVector &amp;getScriptPatterns(void) const;
+    virtual void parseScript(Ogre::DataStreamPtr &amp;,const Ogre::String &amp;);
+    virtual Ogre::Real getLoadingOrder(void) const;
+private:
+    Ogre::StringVector mScriptPatterns;
+
+	Quest* getQuest(Quest* parent, const CeGuiString id) const;
+    void clear();
+    void createRoot();
+    QuestVector getAllQuests() const;
+
+	Quest* mRootQuest;
+    std::vector&lt;JournalEntry*&gt; mJournalEntries;
+	EventCaster&lt;QuestEvent&gt; mQuestEventCaster;
+	EventCaster&lt;JournalEvent&gt; mJournalEventCaster;
+
+    void fireJournalChanged(JournalEntry* entry, int reason);
+
+    //loading quests from xml
+    virtual Quest* processQuest(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, Quest* parent);
+};
+
+}
+#endif

Modified: rl/trunk/engine/rules/include/RulesMessages.h
===================================================================
--- rl/trunk/engine/rules/include/RulesMessages.h	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/rules/include/RulesMessages.h	2008-03-20 19:41:24 UTC (rev 4301)
@@ -1,66 +1,70 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#ifndef __Rl_RulesMessages_H__
-#define __Rl_RulesMessages_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &quot;MessageType.h&quot;
-#include &quot;RulesConstants.h&quot;
-
-namespace rl
-{
-	class Combatant;
-	class Creature;
-
-	/// 0x03xxxxxx as mask for rules messages
-    enum RulesMessageTypeIds
-    {
-        // Game event log //
-        // Mask
-        RLMSG_GAMEEVENTLOG_EVENTS = 0x03000100,
-        // Events
-        RLMSG_GAMEEVENTLOG_EVENT_ADDED = 0x03000101,
-
-		// Combat
-		// Mask
-		RLMSG_COMBAT_EVENTS = 0x03000200,
-		// Events
-		RLMSG_COMBAT_OPPONENT_ENTERED = 0x03000201,
-		RLMSG_COMBAT_OPPONENT_LEFT = 0x03000202,
-
-		// Game object related events
-        // Mask
-        RLMSG_GAMEOBJECT_EVENTS = 0x03000300,
-        // Events
-        RLMSG_CREATURE_LIFESTATE_CHANGED = 0x03000301
-    };
-
-    /// Message sent right after a new game log event has been added.
-	typedef MessageType&lt;RLMSG_GAMEEVENTLOG_EVENT_ADDED, GameEventType, CeGuiString&gt;
-		MessageType_GameEventLog_EventAdded;
-
-	typedef MessageType&lt;RLMSG_COMBAT_OPPONENT_ENTERED, Combatant*&gt;
-		MessageType_CombatOpponentEntered;
-
-	typedef MessageType&lt;RLMSG_COMBAT_OPPONENT_LEFT, Combatant*&gt;
-		MessageType_CombatOpponentLeft;
-
-	typedef MessageType&lt;RLMSG_CREATURE_LIFESTATE_CHANGED, Creature*, LifeState&gt;
-		MessageType_CreatureLifeStateChanged;
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#ifndef __Rl_RulesMessages_H__
+#define __Rl_RulesMessages_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+
+#include &quot;MessageType.h&quot;
+#include &quot;RulesConstants.h&quot;
+#include &quot;CoreMessages.h&quot;
+
+namespace rl
+{
+	class Combatant;
+	class Creature;
+
+	/// 0x03xxxxxx as mask for rules messages
+    enum RulesMessageTypeIds
+    {
+        // Game event log //
+        // Mask
+        RLMSG_GAMEEVENTLOG_EVENTS = 0x03000100,
+        // Events
+        RLMSG_GAMEEVENTLOG_EVENT_ADDED = 0x03000101,
+
+		// Combat
+		// Mask
+		RLMSG_COMBAT_EVENTS = 0x03000200,
+		// Events
+		RLMSG_COMBAT_OPPONENT_ENTERED = 0x03000201,
+		RLMSG_COMBAT_OPPONENT_LEFT = 0x03000202,
+
+		// Game object related events
+        // Mask
+        RLMSG_GAMEOBJECT_EVENTS = 0x03000300,
+        // Events
+        RLMSG_CREATURE_LIFESTATE_CHANGED = 0x03000301
+    };
+
+    /// Message sent right after a new game log event has been added.
+	typedef MessageType&lt;RLMSG_GAMEEVENTLOG_EVENT_ADDED, GameEventType, CeGuiString&gt;
+		MessageType_GameEventLog_EventAdded;
+
+	typedef MessageType&lt;RLMSG_COMBAT_OPPONENT_ENTERED, Combatant*&gt;
+		MessageType_CombatOpponentEntered;
+
+	typedef MessageType&lt;RLMSG_COMBAT_OPPONENT_LEFT, Combatant*&gt;
+		MessageType_CombatOpponentLeft;
+
+	typedef MessageType&lt;RLMSG_CREATURE_LIFESTATE_CHANGED, Creature*, LifeState&gt;
+		MessageType_CreatureLifeStateChanged;
+    
+    typedef MessageType&lt;RLMSG_SAVEGAME_GOS_LOADED&gt; MessageType_GameObjectsLoaded;
+
+}
+#endif

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -27,10 +27,10 @@
 #include &quot;TimeSource.h&quot;
 #include &quot;GameObjectManager.h&quot;
 #include &quot;PhysicsMaterialRaycast.h&quot;
+#include &quot;RulesMessages.h&quot;
 
 
 
-
 using namespace Ogre;
 using namespace std;
 
@@ -1385,9 +1385,9 @@
                 Vector3 vel = body-&gt;getVelocity();
 
                 force.y = mass*( mLinearSpringK*diff.y - mLinearDampingK*vel.y );
-std::ostringstream oss;
-oss &lt;&lt; &quot;Testing Step-Recognition: Step force: &quot; &lt;&lt; force.y;
-LOG_MESSAGE(Logger::RULES, oss.str());
+                std::ostringstream oss;
+                oss &lt;&lt; &quot;Testing Step-Recognition: Step force: &quot; &lt;&lt; force.y;
+                LOG_MESSAGE(Logger::RULES, oss.str());
             }
         }
         virtual bool run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)
@@ -1438,9 +1438,9 @@
                             // found a step
                             mMoveToNextTarget = true;
                             mNextTarget = start + globalDir*raylen*foundDistance + 0.1 * globalDir;
-std::ostringstream oss;
-oss &lt;&lt; &quot;Testing Step-Recognition: Next Step: &quot; &lt;&lt; mNextTarget;
-LOG_MESSAGE(Logger::RULES, oss.str());
+                            std::ostringstream oss;
+                            oss &lt;&lt; &quot;Testing Step-Recognition: Next Step: &quot; &lt;&lt; mNextTarget;
+                            LOG_MESSAGE(Logger::RULES, oss.str());
                             break;
                         }
                     }
@@ -1471,7 +1471,7 @@
                 if( globalDir == Vector3::ZERO )
                 {
                     mMoveToNextTarget = false;
-LOG_MESSAGE(Logger::RULES, &quot;Testing Step-Recognition: Step direction null&quot;);
+                    LOG_MESSAGE(Logger::RULES, &quot;Testing Step-Recognition: Step direction null&quot;);
                     return false;
                 }
 
@@ -1479,7 +1479,7 @@
                 if( diffToTarget.squaredLength() &lt; 0.01 )
                 {
                     mMoveToNextTarget = false;
-LOG_MESSAGE(Logger::RULES, &quot;Testing Step-Recognition: Step reached&quot;);
+                    LOG_MESSAGE(Logger::RULES, &quot;Testing Step-Recognition: Step reached&quot;);
                     return false;
                 }
 
@@ -1487,7 +1487,7 @@
                 if( !diffToTarget.directionEquals(globalDir, Degree(5)) )
                 {
                     mMoveToNextTarget = false;
-LOG_MESSAGE(Logger::RULES, &quot;Testing Step-Recognition: Step direction wrong&quot;);
+                    LOG_MESSAGE(Logger::RULES, &quot;Testing Step-Recognition: Step direction wrong&quot;);
                     return false;
                 }
             }
@@ -1515,43 +1515,6 @@
     };
 
 
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
     CreatureController::CreatureController(Creature *creature) :
         mCreature(creature),
         mAbstractLocation(AL_AIRBORNE),

Modified: rl/trunk/engine/rules/src/GameObjectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObjectManager.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/rules/src/GameObjectManager.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -1,400 +1,402 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;GameObjectManager.h&quot;
-
-#include &lt;CEGUIPropertyHelper.h&gt;
-
-#include &quot;Armor.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;Container.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;GameObject.h&quot;
-#include &quot;Item.h&quot;
-#include &quot;Person.h&quot;
-#include &quot;Properties.h&quot;
-#include &quot;XmlPropertyReader.h&quot;
-#include &quot;Property.h&quot;
-#include &quot;RubyInterpreter.h&quot;
-#include &quot;Weapon.h&quot;
-
-template&lt;&gt; rl::GameObjectManager*
-    Ogre::Singleton&lt;rl::GameObjectManager&gt;::ms_Singleton = NULL;
-
-namespace rl
-{
-    GameObjectManager::GameObjectManager()
-        : mGameObjectFactory(NULL)
-    {
-        mGeneratedId = 1&lt;&lt;16;
-        mGameObjects.clear();
-
-        mScriptPatterns.push_back(&quot;*.gof&quot;);
-        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
-        SaveGameManager::getSingleton().registerSaveGameData(this);
-    }
-
-    GameObjectManager::~GameObjectManager()
-    {
-        SaveGameManager::getSingleton().unregisterSaveGameData(this);
-        unregisterAllGameObjectStateListener();
-        deleteAllGameObjects();
-    }
-
-    const Ogre::StringVector&amp; GameObjectManager::getScriptPatterns() const
-    {
-        return mScriptPatterns;
-    }
-
-    Ogre::Real GameObjectManager::getLoadingOrder() const
-    {
-        return 1500.0;
-    }
-
-    void GameObjectManager::parseScript(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName)
-    {
-        XmlPropertyReader* propReader = new XmlPropertyReader();
-        propReader-&gt;parseGameObjectFile(stream, groupName);
-        std::vector&lt;PropertyRecord*&gt; psset = propReader-&gt;getPropertyRecords();
-        for(std::vector&lt;PropertyRecord*&gt;::iterator it = psset.begin(); it != psset.end(); it++)
-        {
-            PropertyRecord* curPs = *it;
-            Ogre::String classId = curPs-&gt;getProperty(GameObject::PROPERTY_CLASS_ID).toString().c_str();
-            mClassProperties[classId] = curPs;
-        }
-        delete propReader;
-
-    }
-
-    GameObject* GameObjectManager::getGameObject(unsigned int id) const
-    {
-        std::map&lt;unsigned int, GameObject*&gt;::const_iterator it
-                = mGameObjects.find(id);
-
-        if (it != mGameObjects.end())
-        {
-            return (*it).second;
-        }
-
-        return NULL;
-    }
-
-    std::list&lt;GameObject*&gt; GameObjectManager::getAllGameObjects() const
-    {
-        std::list&lt;GameObject*&gt; gos;
-        std::map&lt;unsigned int, GameObject*&gt;::const_iterator it;
-
-        //
-        //    Run through all GOs and put them into the list
-        //
-        for( it=mGameObjects.begin(); it!=mGameObjects.end(); ++it )
-        {
-            gos.push_back(it-&gt;second);
-        }
-
-        return gos;
-    }
-
-    unsigned int GameObjectManager::generateId()
-    {
-        return mGeneratedId++;
-    }
-
-    GameObject* GameObjectManager::createGameObject(
-        const Ogre::String&amp; classId, unsigned int id)
-    {
-		LOG_MESSAGE(&quot;GameObjectManager&quot;, &quot;Create/Get GameObject of type &quot; + classId
-			+ &quot; #&quot; + Ogre::StringConverter::toString((int)id));
-        unsigned int goId;
-
-        if (id != GameObject::NO_OBJECT_ID)
-        {
-            GameObject* goInMap = getGameObject(id);
-
-            if (goInMap != NULL)
-            {
-                return goInMap;
-            }
-            else
-            {
-                goId = id;
-            }
-        }
-        else
-        {
-            goId = generateId();
-        }
-
-        PropertyRecord* ps = getClassProperties(classId);
-        Ogre::String classname =  ps-&gt;getProperty(GameObject::PROPERTY_BASE_CLASS).toString().c_str();
-
-        GameObject* go = mGameObjectFactory
-            -&gt;createGameObject(
-                classname,
-                goId);
-        if (go)
-        {
-            go-&gt;setClassId(classId);
-            applyProperties(go, ps);
-            mGameObjects[goId] = go;
-        }
-        return go;
-    }
-
-    void GameObjectManager::deleteGameObject(unsigned int id)
-    {
-        if(mGameObjects.find(id) != mGameObjects.end())
-        {
-            GameObject* go = mGameObjects[id];
-            mGameObjects.erase(id);
-            delete go;
-        }
-    }
-
-    void GameObjectManager::deleteGameObject(GameObject* obj)
-    {
-        deleteGameObject(obj-&gt;getId());
-    }
-
-    void GameObjectManager::deleteAllGameObjects()
-    {
-        while(!mGameObjects.empty())
-        {
-            GameObject *go = mGameObjects.begin()-&gt;second;
-            delete go;
-            mGameObjects.erase(mGameObjects.begin());
-        }
-    }
-
-    void GameObjectManager::applyProperties(GameObject* go, PropertyRecord* ps) const
-    {
-        if (ps-&gt;hasProperty(GameObject::PROPERTY_INHERITS))
-        {
-            PropertyRecord* superClassProps = 
-                getClassProperties(ps-&gt;getProperty(GameObject::PROPERTY_INHERITS).toString().c_str());
-            applyProperties(go, superClassProps);
-        }
-        go-&gt;setProperties(ps);
-    }
-
-	GameObject* GameObjectManager::createGameObjectFromProperty(const Property&amp; goProp)
-	{
-		CeGuiString serializedString = goProp.toString();
-
-		CeGuiString::size_type posDivider = serializedString.find(&quot;|&quot;);
-
-		if (posDivider != CeGuiString::npos)
-		{
-			Ogre::String classId(serializedString.substr(0, posDivider).c_str());
-			unsigned int goid = CEGUI::PropertyHelper::stringToUint(serializedString.substr(posDivider+1));
-			return createGameObject(classId, goid);
-		}
-
-		return NULL;
-	}
-
-	Property GameObjectManager::toProperty(const GameObject* const go) const
-	{
-		return Property(go-&gt;getClassId() + &quot;|&quot; + CEGUI::PropertyHelper::uintToString(go-&gt;getId()));
-	}
-
-    PropertyRecord* GameObjectManager::getClassProperties(const Ogre::String&amp; classId) const
-    {
-        ClassPropertyMap::const_iterator it = mClassProperties.find(classId);
-        if (it == mClassProperties.end())
-        {
-            Throw(rl::Exception, &quot;No properties found for classId &quot;+classId);
-        }
-        return (*it).second;
-    }
-
-    void GameObjectManager::setGameObjectFactory(GameObjectFactory* gof)
-    {
-        mGameObjectFactory = gof;
-    }
-
-    void GameObjectManager::gameObjectStateChanged(GameObject* go, GameObjectState oldState,
-        GameObjectState newState)
-    {
-        for (GameObjectStateListenerSet::iterator it = mGameObjectStateListeners.begin();
-            it != mGameObjectStateListeners.end(); ++it)
-        {
-            (*it)-&gt;gameObjectStateChanged(go, oldState, newState);
-        }
-    }
-
-    void GameObjectManager::registerGameObjectStateListener(GameObjectStateListener* listener)
-    {
-        mGameObjectStateListeners.insert(listener);
-    }
-
-    void GameObjectManager::unregisterGameObjectStateListener(GameObjectStateListener* listener)
-    {
-        mGameObjectStateListeners.erase(listener);
-    }
-
-    void GameObjectManager::unregisterAllGameObjectStateListener()
-    {
-        for(std::set&lt;GameObjectStateListener*&gt;::iterator itr = mGameObjectStateListeners.begin();
-            itr != mGameObjectStateListeners.end();)
-        {
-            mGameObjectStateListeners.erase(itr++);
-        }
-        
-    }
-
-    GameObjectFactory::GameObjectFactory()
-    {
-    }
-
-    GameObject* GameObjectFactory::createGameObject(const Ogre::String&amp; classname, unsigned int id)
-    {
-        if (classname == GameObject::CLASS_NAME)
-        {
-            return new GameObject(id);
-        }
-        else if (classname == Creature::CLASS_NAME)
-        {
-            return new Creature(id);
-        }
-        else if (classname == Person::CLASS_NAME)
-        {
-            return new Person(id);
-        }
-        else if (classname == Weapon::CLASS_NAME)
-        {
-            return new Weapon(id);
-        }
-        else if (classname == Armor::CLASS_NAME)
-        {
-            return new Armor(id);
-        }
-        else if (classname == Container::CLASS_NAME)
-        {
-            return new Container(id);
-        }
-        else if (classname == Item::CLASS_NAME)
-        {
-            return new Item(id);
-        }
-
-        return createRubyGameObject(classname, id);
-    }
-
-    CeGuiString GameObjectManager::getXmlNodeIdentifier() const
-    {
-        return &quot;gameobjects&quot;;
-    }
-
-    using namespace XERCES_CPP_NAMESPACE;
-    
-    void GameObjectManager::writeData(SaveGameFileWriter *writer)
-    {
-        LOG_MESSAGE(Logger::RULES, &quot;Saving Game Objects&quot;);
-        DOMElement* gameobjects = writer-&gt;appendChildElement(writer-&gt;getDocument(), writer-&gt;getDocument()-&gt;getDocumentElement(), getXmlNodeIdentifier().c_str());
-
-        std::list&lt;GameObject*&gt; gos = getAllGameObjects();
-
-		for(std::list&lt;GameObject*&gt;::const_iterator it_gameobjects = gos.begin(); it_gameobjects != gos.end(); it_gameobjects++)
-        {
-            DOMElement* gameobject = writer-&gt;appendChildElement(writer-&gt;getDocument(), gameobjects, &quot;gameobject&quot;);
-            writer-&gt;setAttributeValueAsInteger(gameobject, &quot;ID&quot;, (*it_gameobjects)-&gt;getId());
-            writer-&gt;setAttributeValueAsString(gameobject, &quot;ClassID&quot;, (*it_gameobjects)-&gt;getClassId());
-            writer-&gt;setAttributeValueAsInteger(gameobject, &quot;State&quot;, (int)(*it_gameobjects)-&gt;getState());
-            writer-&gt;setAttributeValueAsInteger(gameobject, &quot;QueryFlags&quot;, (int)(*it_gameobjects)-&gt;getQueryFlags());
-
-            PropertyMap actualMap = (*it_gameobjects)-&gt;getAllProperties()-&gt;toPropertyMap();
-
-            writer-&gt;writeEachPropertyToElem(gameobject, (*it_gameobjects)-&gt;getAllProperties()-&gt;getDifference(getClassProperties((*it_gameobjects)-&gt;getClassId()))-&gt;toPropertyMap());
-            //writer-&gt;writeEachPropertyToElem(gameobject, getPropertyMapDifference(actualMap, getClassProperties((*it_gameobjects)-&gt;getClassId())-&gt;toPropertyMap()));
-        } 
-    }
-
-    void GameObjectManager::readData(SaveGameFileReader *reader)
-    {
-        deleteAllGameObjects();
-
-        reader-&gt;initializeXml();
-
-        DOMNodeList* rootNodeList = reader-&gt;getDocument()-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
-
-        if(rootNodeList-&gt;getLength())
-        {
-            DOMNodeList* xmlGameObjects = static_cast&lt;DOMElement*&gt;(rootNodeList-&gt;item(0))-&gt;getElementsByTagName(AutoXMLCh(&quot;gameobject&quot;).data()); //there should be only one &quot;gameobjects&quot; node
-            if(xmlGameObjects-&gt;getLength())
-            {
-                for(XMLSize_t childIdx = 0; childIdx &lt; xmlGameObjects-&gt;getLength(); childIdx++)
-                {
-                    DOMNode* xmlGameObject = xmlGameObjects-&gt;item(childIdx);
-                    if(xmlGameObject-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-                    {
-                        int ID = reader-&gt;getAttributeValueAsInteger(static_cast&lt;DOMElement*&gt;(xmlGameObject), &quot;ID&quot;);
-                        Ogre::String classID = reader-&gt;getAttributeValueAsStdString(static_cast&lt;DOMElement*&gt;(xmlGameObject), &quot;ClassID&quot;);
-                        GameObjectState state = (GameObjectState)reader-&gt;getAttributeValueAsInteger(static_cast&lt;DOMElement*&gt;(xmlGameObject), &quot;State&quot;);
-                        int flags = reader-&gt;getAttributeValueAsInteger(static_cast&lt;DOMElement*&gt;(xmlGameObject), &quot;QueryFlags&quot;);
-                        PropertyRecord properties = reader-&gt;getPropertiesAsRecord(static_cast&lt;DOMElement*&gt;(xmlGameObject));
-
-                        GameObject* object = NULL;
-                        if(getGameObject(ID) == NULL)
-                            object = createGameObject(classID, ID);
-                        else
-                            object = getGameObject(ID);
-                        
-                        applyProperties(object, &amp;properties);
-                        // Placing the actor a a little bit higher in the scene. The actor will fall onto ground.
-                        // Avoiding problems with the physics, because the character the creature is transfixed to ground
-                        if(state == GOS_IN_SCENE)
-                        {
-                            object-&gt;setProperty(GameObject::PROPERTY_POSITION, 
-	                            Property(object-&gt;getProperty(GameObject::PROPERTY_POSITION).toVector3() + Ogre::Vector3(0.0f,0.01f,0.0f)));
-                        }
-                        object-&gt;setState(state);
-                        object-&gt;setQueryFlags(flags);
-                    }
-                }
-            }
-        } 
-
-        MessagePump::getSingleton().sendMessage&lt;MessageType_GameObjectsLoaded&gt;();
-
-        reader-&gt;shutdownXml();
-    }
-
-    int GameObjectManager::getPriority() const
-    {
-        return 100;
-    }
-
-    PropertyMap GameObjectManager::getPropertyMapDifference(PropertyMap map1, PropertyMap map2)
-    {
-        PropertyRecord pr;
-
-        if(!map1.empty() &amp;&amp; !map2.empty())
-        {
-            for(PropertyMap::const_iterator iter = map1.begin(); iter != map1.end(); ++iter)
-            {
-                if(map2.find(iter-&gt;first) == map2.end())
-                    pr.setProperty(iter-&gt;first.c_str(), iter-&gt;second);
-                else if(map2.find(iter-&gt;first)-&gt;second != iter-&gt;second)
-                    pr.setProperty(iter-&gt;first.c_str(), iter-&gt;second);
-            }
-        }
-
-        return pr.toPropertyMap();
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;GameObjectManager.h&quot;
+
+#include &lt;CEGUIPropertyHelper.h&gt;
+
+#include &quot;Armor.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;Container.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;GameObject.h&quot;
+#include &quot;Item.h&quot;
+#include &quot;Person.h&quot;
+#include &quot;Properties.h&quot;
+#include &quot;Property.h&quot;
+#include &quot;RulesMessages.h&quot;
+#include &quot;RubyInterpreter.h&quot;
+#include &quot;SaveGameManager.h&quot;
+#include &quot;Weapon.h&quot;
+#include &quot;XmlPropertyReader.h&quot;
+
+template&lt;&gt; rl::GameObjectManager*
+    Ogre::Singleton&lt;rl::GameObjectManager&gt;::ms_Singleton = NULL;
+
+namespace rl
+{
+    GameObjectManager::GameObjectManager()
+        : mGameObjectFactory(NULL)
+    {
+        mGeneratedId = 1&lt;&lt;16;
+        mGameObjects.clear();
+
+        mScriptPatterns.push_back(&quot;*.gof&quot;);
+        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
+        SaveGameManager::getSingleton().registerSaveGameData(this);
+    }
+
+    GameObjectManager::~GameObjectManager()
+    {
+        SaveGameManager::getSingleton().unregisterSaveGameData(this);
+        unregisterAllGameObjectStateListener();
+        deleteAllGameObjects();
+    }
+
+    const Ogre::StringVector&amp; GameObjectManager::getScriptPatterns() const
+    {
+        return mScriptPatterns;
+    }
+
+    Ogre::Real GameObjectManager::getLoadingOrder() const
+    {
+        return 1500.0;
+    }
+
+    void GameObjectManager::parseScript(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName)
+    {
+        XmlPropertyReader* propReader = new XmlPropertyReader();
+        propReader-&gt;parseGameObjectFile(stream, groupName);
+        std::vector&lt;PropertyRecord*&gt; psset = propReader-&gt;getPropertyRecords();
+        for(std::vector&lt;PropertyRecord*&gt;::iterator it = psset.begin(); it != psset.end(); it++)
+        {
+            PropertyRecord* curPs = *it;
+            Ogre::String classId = curPs-&gt;getProperty(GameObject::PROPERTY_CLASS_ID).toString().c_str();
+            mClassProperties[classId] = curPs;
+        }
+        delete propReader;
+
+    }
+
+    GameObject* GameObjectManager::getGameObject(unsigned int id) const
+    {
+        std::map&lt;unsigned int, GameObject*&gt;::const_iterator it
+                = mGameObjects.find(id);
+
+        if (it != mGameObjects.end())
+        {
+            return (*it).second;
+        }
+
+        return NULL;
+    }
+
+    std::list&lt;GameObject*&gt; GameObjectManager::getAllGameObjects() const
+    {
+        std::list&lt;GameObject*&gt; gos;
+        std::map&lt;unsigned int, GameObject*&gt;::const_iterator it;
+
+        //
+        //    Run through all GOs and put them into the list
+        //
+        for( it=mGameObjects.begin(); it!=mGameObjects.end(); ++it )
+        {
+            gos.push_back(it-&gt;second);
+        }
+
+        return gos;
+    }
+
+    unsigned int GameObjectManager::generateId()
+    {
+        return mGeneratedId++;
+    }
+
+    GameObject* GameObjectManager::createGameObject(
+        const Ogre::String&amp; classId, unsigned int id)
+    {
+		LOG_MESSAGE(&quot;GameObjectManager&quot;, &quot;Create/Get GameObject of type &quot; + classId
+			+ &quot; #&quot; + Ogre::StringConverter::toString((int)id));
+        unsigned int goId;
+
+        if (id != GameObject::NO_OBJECT_ID)
+        {
+            GameObject* goInMap = getGameObject(id);
+
+            if (goInMap != NULL)
+            {
+                return goInMap;
+            }
+            else
+            {
+                goId = id;
+            }
+        }
+        else
+        {
+            goId = generateId();
+        }
+
+        PropertyRecord* ps = getClassProperties(classId);
+        Ogre::String classname =  ps-&gt;getProperty(GameObject::PROPERTY_BASE_CLASS).toString().c_str();
+
+        GameObject* go = mGameObjectFactory
+            -&gt;createGameObject(
+                classname,
+                goId);
+        if (go)
+        {
+            go-&gt;setClassId(classId);
+            applyProperties(go, ps);
+            mGameObjects[goId] = go;
+        }
+        return go;
+    }
+
+    void GameObjectManager::deleteGameObject(unsigned int id)
+    {
+        if(mGameObjects.find(id) != mGameObjects.end())
+        {
+            GameObject* go = mGameObjects[id];
+            mGameObjects.erase(id);
+            delete go;
+        }
+    }
+
+    void GameObjectManager::deleteGameObject(GameObject* obj)
+    {
+        deleteGameObject(obj-&gt;getId());
+    }
+
+    void GameObjectManager::deleteAllGameObjects()
+    {
+        while(!mGameObjects.empty())
+        {
+            GameObject *go = mGameObjects.begin()-&gt;second;
+            delete go;
+            mGameObjects.erase(mGameObjects.begin());
+        }
+    }
+
+    void GameObjectManager::applyProperties(GameObject* go, PropertyRecord* ps) const
+    {
+        if (ps-&gt;hasProperty(GameObject::PROPERTY_INHERITS))
+        {
+            PropertyRecord* superClassProps = 
+                getClassProperties(ps-&gt;getProperty(GameObject::PROPERTY_INHERITS).toString().c_str());
+            applyProperties(go, superClassProps);
+        }
+        go-&gt;setProperties(ps);
+    }
+
+	GameObject* GameObjectManager::createGameObjectFromProperty(const Property&amp; goProp)
+	{
+		CeGuiString serializedString = goProp.toString();
+
+		CeGuiString::size_type posDivider = serializedString.find(&quot;|&quot;);
+
+		if (posDivider != CeGuiString::npos)
+		{
+			Ogre::String classId(serializedString.substr(0, posDivider).c_str());
+			unsigned int goid = CEGUI::PropertyHelper::stringToUint(serializedString.substr(posDivider+1));
+			return createGameObject(classId, goid);
+		}
+
+		return NULL;
+	}
+
+	Property GameObjectManager::toProperty(const GameObject* const go) const
+	{
+		return Property(go-&gt;getClassId() + &quot;|&quot; + CEGUI::PropertyHelper::uintToString(go-&gt;getId()));
+	}
+
+    PropertyRecord* GameObjectManager::getClassProperties(const Ogre::String&amp; classId) const
+    {
+        ClassPropertyMap::const_iterator it = mClassProperties.find(classId);
+        if (it == mClassProperties.end())
+        {
+            Throw(rl::Exception, &quot;No properties found for classId &quot;+classId);
+        }
+        return (*it).second;
+    }
+
+    void GameObjectManager::setGameObjectFactory(GameObjectFactory* gof)
+    {
+        mGameObjectFactory = gof;
+    }
+
+    void GameObjectManager::gameObjectStateChanged(GameObject* go, GameObjectState oldState,
+        GameObjectState newState)
+    {
+        for (GameObjectStateListenerSet::iterator it = mGameObjectStateListeners.begin();
+            it != mGameObjectStateListeners.end(); ++it)
+        {
+            (*it)-&gt;gameObjectStateChanged(go, oldState, newState);
+        }
+    }
+
+    void GameObjectManager::registerGameObjectStateListener(GameObjectStateListener* listener)
+    {
+        mGameObjectStateListeners.insert(listener);
+    }
+
+    void GameObjectManager::unregisterGameObjectStateListener(GameObjectStateListener* listener)
+    {
+        mGameObjectStateListeners.erase(listener);
+    }
+
+    void GameObjectManager::unregisterAllGameObjectStateListener()
+    {
+        for(std::set&lt;GameObjectStateListener*&gt;::iterator itr = mGameObjectStateListeners.begin();
+            itr != mGameObjectStateListeners.end();)
+        {
+            mGameObjectStateListeners.erase(itr++);
+        }
+        
+    }
+
+    GameObjectFactory::GameObjectFactory()
+    {
+    }
+
+    GameObject* GameObjectFactory::createGameObject(const Ogre::String&amp; classname, unsigned int id)
+    {
+        if (classname == GameObject::CLASS_NAME)
+        {
+            return new GameObject(id);
+        }
+        else if (classname == Creature::CLASS_NAME)
+        {
+            return new Creature(id);
+        }
+        else if (classname == Person::CLASS_NAME)
+        {
+            return new Person(id);
+        }
+        else if (classname == Weapon::CLASS_NAME)
+        {
+            return new Weapon(id);
+        }
+        else if (classname == Armor::CLASS_NAME)
+        {
+            return new Armor(id);
+        }
+        else if (classname == Container::CLASS_NAME)
+        {
+            return new Container(id);
+        }
+        else if (classname == Item::CLASS_NAME)
+        {
+            return new Item(id);
+        }
+
+        return createRubyGameObject(classname, id);
+    }
+
+    CeGuiString GameObjectManager::getXmlNodeIdentifier() const
+    {
+        return &quot;gameobjects&quot;;
+    }
+
+    using namespace XERCES_CPP_NAMESPACE;
+    
+    void GameObjectManager::writeData(SaveGameFileWriter *writer)
+    {
+        LOG_MESSAGE(Logger::RULES, &quot;Saving Game Objects&quot;);
+        DOMElement* gameobjects = writer-&gt;appendChildElement(writer-&gt;getDocument(), writer-&gt;getDocument()-&gt;getDocumentElement(), getXmlNodeIdentifier().c_str());
+
+        std::list&lt;GameObject*&gt; gos = getAllGameObjects();
+
+		for(std::list&lt;GameObject*&gt;::const_iterator it_gameobjects = gos.begin(); it_gameobjects != gos.end(); it_gameobjects++)
+        {
+            DOMElement* gameobject = writer-&gt;appendChildElement(writer-&gt;getDocument(), gameobjects, &quot;gameobject&quot;);
+            writer-&gt;setAttributeValueAsInteger(gameobject, &quot;ID&quot;, (*it_gameobjects)-&gt;getId());
+            writer-&gt;setAttributeValueAsString(gameobject, &quot;ClassID&quot;, (*it_gameobjects)-&gt;getClassId());
+            writer-&gt;setAttributeValueAsInteger(gameobject, &quot;State&quot;, (int)(*it_gameobjects)-&gt;getState());
+            writer-&gt;setAttributeValueAsInteger(gameobject, &quot;QueryFlags&quot;, (int)(*it_gameobjects)-&gt;getQueryFlags());
+
+            PropertyMap actualMap = (*it_gameobjects)-&gt;getAllProperties()-&gt;toPropertyMap();
+
+            writer-&gt;writeEachPropertyToElem(gameobject, (*it_gameobjects)-&gt;getAllProperties()-&gt;getDifference(getClassProperties((*it_gameobjects)-&gt;getClassId()))-&gt;toPropertyMap());
+            //writer-&gt;writeEachPropertyToElem(gameobject, getPropertyMapDifference(actualMap, getClassProperties((*it_gameobjects)-&gt;getClassId())-&gt;toPropertyMap()));
+        } 
+    }
+
+    void GameObjectManager::readData(SaveGameFileReader *reader)
+    {
+        deleteAllGameObjects();
+
+        reader-&gt;initializeXml();
+
+        DOMNodeList* rootNodeList = reader-&gt;getDocument()-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
+
+        if(rootNodeList-&gt;getLength())
+        {
+            DOMNodeList* xmlGameObjects = static_cast&lt;DOMElement*&gt;(rootNodeList-&gt;item(0))-&gt;getElementsByTagName(AutoXMLCh(&quot;gameobject&quot;).data()); //there should be only one &quot;gameobjects&quot; node
+            if(xmlGameObjects-&gt;getLength())
+            {
+                for(XMLSize_t childIdx = 0; childIdx &lt; xmlGameObjects-&gt;getLength(); childIdx++)
+                {
+                    DOMNode* xmlGameObject = xmlGameObjects-&gt;item(childIdx);
+                    if(xmlGameObject-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+                    {
+                        int ID = reader-&gt;getAttributeValueAsInteger(static_cast&lt;DOMElement*&gt;(xmlGameObject), &quot;ID&quot;);
+                        Ogre::String classID = reader-&gt;getAttributeValueAsStdString(static_cast&lt;DOMElement*&gt;(xmlGameObject), &quot;ClassID&quot;);
+                        GameObjectState state = (GameObjectState)reader-&gt;getAttributeValueAsInteger(static_cast&lt;DOMElement*&gt;(xmlGameObject), &quot;State&quot;);
+                        int flags = reader-&gt;getAttributeValueAsInteger(static_cast&lt;DOMElement*&gt;(xmlGameObject), &quot;QueryFlags&quot;);
+                        PropertyRecord properties = reader-&gt;getPropertiesAsRecord(static_cast&lt;DOMElement*&gt;(xmlGameObject));
+
+                        GameObject* object = NULL;
+                        if(getGameObject(ID) == NULL)
+                            object = createGameObject(classID, ID);
+                        else
+                            object = getGameObject(ID);
+                        
+                        applyProperties(object, &amp;properties);
+                        // Placing the actor a a little bit higher in the scene. The actor will fall onto ground.
+                        // Avoiding problems with the physics, because the character the creature is transfixed to ground
+                        if(state == GOS_IN_SCENE)
+                        {
+                            object-&gt;setProperty(GameObject::PROPERTY_POSITION, 
+	                            Property(object-&gt;getProperty(GameObject::PROPERTY_POSITION).toVector3() + Ogre::Vector3(0.0f,0.01f,0.0f)));
+                        }
+                        object-&gt;setState(state);
+                        object-&gt;setQueryFlags(flags);
+                    }
+                }
+            }
+        } 
+
+        MessagePump::getSingleton().sendMessage&lt;MessageType_GameObjectsLoaded&gt;();
+
+        reader-&gt;shutdownXml();
+    }
+
+    int GameObjectManager::getPriority() const
+    {
+        return 100;
+    }
+
+    PropertyMap GameObjectManager::getPropertyMapDifference(PropertyMap map1, PropertyMap map2)
+    {
+        PropertyRecord pr;
+
+        if(!map1.empty() &amp;&amp; !map2.empty())
+        {
+            for(PropertyMap::const_iterator iter = map1.begin(); iter != map1.end(); ++iter)
+            {
+                if(map2.find(iter-&gt;first) == map2.end())
+                    pr.setProperty(iter-&gt;first.c_str(), iter-&gt;second);
+                else if(map2.find(iter-&gt;first)-&gt;second != iter-&gt;second)
+                    pr.setProperty(iter-&gt;first.c_str(), iter-&gt;second);
+            }
+        }
+
+        return pr.toPropertyMap();
+    }
+}

Modified: rl/trunk/engine/rules/src/GlobalProperties.cpp
===================================================================
--- rl/trunk/engine/rules/src/GlobalProperties.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/rules/src/GlobalProperties.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -17,6 +17,7 @@
 #include &quot;stdinc.h&quot; //precompiled header
 
 #include &quot;GlobalProperties.h&quot;
+#include &quot;SaveGameManager.h&quot;
 
 template&lt;&gt; rl::GlobalProperties* Ogre::Singleton&lt;rl::GlobalProperties&gt;::ms_Singleton = 0;
 

Modified: rl/trunk/engine/rules/src/QuestBook.cpp
===================================================================
--- rl/trunk/engine/rules/src/QuestBook.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/rules/src/QuestBook.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -19,6 +19,7 @@
 #include &quot;Quest.h&quot;
 #include &quot;Exception.h&quot;
 #include &quot;ScriptWrapper.h&quot;
+#include &quot;SaveGameManager.h&quot;
 
 using namespace std;
 using namespace XERCES_CPP_NAMESPACE;

Modified: rl/trunk/engine/script/include/TriggerFactory.h
===================================================================
--- rl/trunk/engine/script/include/TriggerFactory.h	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/script/include/TriggerFactory.h	2008-03-20 19:41:24 UTC (rev 4301)
@@ -16,9 +16,10 @@
 #ifndef __TriggerFactory_H__
 #define __TriggerFactory_H__
 
-#include &quot;SaveGameManager.h&quot;
 #include &quot;ScriptPrerequisites.h&quot;
 
+#include &quot;SaveGameData.h&quot;
+
 namespace rl 
 {
 	class Trigger;

Modified: rl/trunk/engine/script/src/TriggerFactory.cpp
===================================================================
--- rl/trunk/engine/script/src/TriggerFactory.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/script/src/TriggerFactory.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -15,8 +15,10 @@
  */
 #include &quot;stdinc.h&quot; //precompiled header
 
+#include &quot;TriggerFactory.h&quot;
+
+#include &quot;SaveGameManager.h&quot;
 #include &quot;ScriptWrapper.h&quot;
-#include &quot;TriggerFactory.h&quot;
 #include &quot;Trigger.h&quot;
 #include &quot;ZoneManager.h&quot;
 #include &quot;Zone.h&quot;

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/script/swig/RlAi.swig	2008-03-20 19:41:24 UTC (rev 4301)
@@ -235,7 +235,6 @@
 		void addConnection(rl::WayPointNode* wp1, rl::WayPointNode* wp2);
 		void addDirectedConnection(rl::WayPointNode* wp1, const rl::WayPointNode* wp2);
 		void load(const Ogre::String&amp; filename);
-		void saveBinary(const Ogre::String&amp; filename) const;
 		const rl::WayPointNode* getNearestWayPoint(const Ogre::Vector3&amp; position) const;
 		const rl::WayPointNode* getWayPointAt(unsigned int index) const;
 	};

Modified: rl/trunk/engine/ui/src/ControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/ControlState.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/ui/src/ControlState.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -31,6 +31,7 @@
 #include &quot;InputManager.h&quot;
 #include &quot;Person.h&quot;
 #include &quot;PhysicalThing.h&quot;
+#include &quot;RulesMessages.h&quot;
 #include &quot;WindowManager.h&quot;
 #include &quot;World.h&quot;
 

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2008-03-18 21:23:45 UTC (rev 4300)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2008-03-20 19:41:24 UTC (rev 4301)
@@ -40,6 +40,7 @@
 #include &quot;PhysicsManager.h&quot;
 #include &quot;PhysicsMaterialRaycast.h&quot;
 #include &quot;PhysicalThing.h&quot;
+#include &quot;RulesMessages.h&quot;
 #include &quot;World.h&quot;
 #include &quot;LineSetPrimitive.h&quot;
 #include &quot;WindowFactory.h&quot;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001371.html">[Dsa-hl-svn] r4300 - in rl/trunk: Mac/Rastullah.xcodeproj	engine/script/swig
</A></li>
	<LI>Next message: <A HREF="001373.html">[Dsa-hl-svn] r4302 - in rl/trunk/engine/core: include src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1372">[ date ]</a>
              <a href="thread.html#1372">[ thread ]</a>
              <a href="subject.html#1372">[ subject ]</a>
              <a href="author.html#1372">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
