<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4893 - in rl/branches/persistence2:	editors/Lockenwickler editors/Lockenwickler/src engine/ai/src	engine/core/include engine/core/src engine/rules/src	engine/script/src engine/ui/include engine/ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4893%20-%20in%20rl/branches/persistence2%3A%0A%09editors/Lockenwickler%20editors/Lockenwickler/src%20engine/ai/src%0A%09engine/core/include%20engine/core/src%20engine/rules/src%0A%09engine/script/src%20engine/ui/include%20engine/ui/src&In-Reply-To=%3C200904111035.n3BAZXXn007955%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001949.html">
   <LINK REL="Next"  HREF="001951.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4893 - in rl/branches/persistence2:	editors/Lockenwickler editors/Lockenwickler/src engine/ai/src	engine/core/include engine/core/src engine/rules/src	engine/script/src engine/ui/include engine/ui/src</H1>
    <B>timm at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4893%20-%20in%20rl/branches/persistence2%3A%0A%09editors/Lockenwickler%20editors/Lockenwickler/src%20engine/ai/src%0A%09engine/core/include%20engine/core/src%20engine/rules/src%0A%09engine/script/src%20engine/ui/include%20engine/ui/src&In-Reply-To=%3C200904111035.n3BAZXXn007955%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4893 - in rl/branches/persistence2:	editors/Lockenwickler editors/Lockenwickler/src engine/ai/src	engine/core/include engine/core/src engine/rules/src	engine/script/src engine/ui/include engine/ui/src">timm at mail.berlios.de
       </A><BR>
    <I>Sat Apr 11 12:35:33 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001949.html">[Dsa-hl-svn] r4892 - in rl/trunk/editors/Lockenwickler: . src
</A></li>
        <LI>Next message: <A HREF="001951.html">[Dsa-hl-svn] r4894 - rl/branches/persistence2/engine/common/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1950">[ date ]</a>
              <a href="thread.html#1950">[ thread ]</a>
              <a href="subject.html#1950">[ subject ]</a>
              <a href="author.html#1950">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: timm
Date: 2009-04-11 12:34:44 +0200 (Sat, 11 Apr 2009)
New Revision: 4893

Added:
   rl/branches/persistence2/editors/Lockenwickler/src/GOGenericEditor.py
Modified:
   rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p
   rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py
   rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py
   rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py
   rl/branches/persistence2/editors/Lockenwickler/src/ZoneManager.py
   rl/branches/persistence2/engine/ai/src/PhysicalObstacle.cpp
   rl/branches/persistence2/engine/core/include/PhysicalThing.h
   rl/branches/persistence2/engine/core/include/PhysicsManager.h
   rl/branches/persistence2/engine/core/include/PhysicsMaterialRaycast.h
   rl/branches/persistence2/engine/core/include/PhysicsRagDoll.h
   rl/branches/persistence2/engine/core/src/GameAreaTypes.cpp
   rl/branches/persistence2/engine/core/src/GameEventManager.cpp
   rl/branches/persistence2/engine/core/src/PhysicalThing.cpp
   rl/branches/persistence2/engine/core/src/PhysicsGenericContactCallback.cpp
   rl/branches/persistence2/engine/core/src/PhysicsManager.cpp
   rl/branches/persistence2/engine/core/src/PhysicsMaterialRaycast.cpp
   rl/branches/persistence2/engine/core/src/PhysicsRagDoll.cpp
   rl/branches/persistence2/engine/core/src/SceneQuery.cpp
   rl/branches/persistence2/engine/rules/src/CreatureController.cpp
   rl/branches/persistence2/engine/rules/src/CreatureControllerManager.cpp
   rl/branches/persistence2/engine/rules/src/SelectionHelper.cpp
   rl/branches/persistence2/engine/script/src/EntityNodeProcessor.cpp
   rl/branches/persistence2/engine/script/src/PlaneNodeProcessor.cpp
   rl/branches/persistence2/engine/ui/include/MovementControlState.h
   rl/branches/persistence2/engine/ui/src/CombatControlState.cpp
   rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp
   rl/branches/persistence2/engine/ui/src/MovementControlState.cpp
Log:
- merged trunk

Modified: rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p	2009-04-11 10:34:44 UTC (rev 4893)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;!DOCTYPE Project SYSTEM &quot;Project-4.6.dtd&quot;&gt;
 &lt;!-- eric4 project file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2009-03-21, 13:56:34 --&gt;
+&lt;!-- Saved: 2009-04-10, 16:03:00 --&gt;
 &lt;!-- Copyright (C) 2009 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
 &lt;Project version=&quot;4.6&quot;&gt;
   &lt;Language&gt;en&lt;/Language&gt;
@@ -40,6 +40,7 @@
     &lt;Source&gt;src/MaterialSelectionDialog.py&lt;/Source&gt;
     &lt;Source&gt;src/DepthBuffer.py&lt;/Source&gt;
     &lt;Source&gt;src/ZoneManager.py&lt;/Source&gt;
+    &lt;Source&gt;src/GOGenericEditor.py&lt;/Source&gt;
   &lt;/Sources&gt;
   &lt;Forms&gt;
     &lt;Form&gt;ui files/GOPropertyEditorDialogINT.ui&lt;/Form&gt;

Copied: rl/branches/persistence2/editors/Lockenwickler/src/GOGenericEditor.py (from rev 4892, rl/trunk/editors/Lockenwickler/src/GOGenericEditor.py)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py	2009-04-11 10:34:44 UTC (rev 4893)
@@ -27,6 +27,7 @@
 
 from GOStringEditor import *
 from GOIntEditor import *
+from GOGenericEditor import *
 
 class GOCStringProperty():
     def __init__(self, name, data):
@@ -117,9 +118,17 @@
     def getType(self):
         return &quot;MAP&quot;
 
+
+
 # gameObjectClass is the id of the class itself
 # since a game object can be ingame more than once there is also a id for those
-class GameObjectRepresentation(og.UserDefinedObject):
+class GameObjectRepresentation(og.UserDefinedObject):     
+    class PropertieRepresentation():
+        def __init__(self, name = &quot;&quot;, type = &quot;STRING&quot;, data = &quot;&quot;):
+            self.name = name
+            self.type = type
+            self.data = data
+
     def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
         og.UserDefinedObject.__init__(self)
         self.inWorldId = inWorldId
@@ -127,7 +136,34 @@
         self.node = node
         self.meshFile = meshFile
         self.state = &quot;IN_SCENE&quot;
-
+        self.propertieDict = {}
+    
+    def addProperty(self, repeat = False):
+        if not repeat:
+            self.editor = GOGenericEditor(&quot;&quot;, &quot;STRING&quot;, &quot;&quot;, QApplication.focusWidget())
+            
+        if self.editor.exec_():
+            rep = GameObjectRepresentation.PropertieRepresentation()
+            rep.name = str(self.editor.nameEditBox.text())
+            rep.type = str(self.editor.typeDropBox.currentText())
+            
+            if rep.type == &quot;STRING&quot; or rep.type == &quot;BOOL&quot; or rep.type == &quot;REAL&quot; or rep.type == &quot;INT&quot;:
+                rep.data = str(self.editor.dataEditBox.text())
+            
+            if rep.name in self.propertieDict:
+                reply = QMessageBox.question(QApplication.focusWidget(), &quot;Warning&quot;, &quot;Replace the existing property?&quot; , QMessageBox.Yes|QMessageBox.No|QMessageBox.Cancel)
+                if reply == QMessageBox.Cancel:
+                    return
+                elif reply == QMessageBox.Yes:
+                    self.propertieDict[rep.name] = rep
+                elif reply == QMessageBox.No:
+                    self.addProperty(True)
+            else:
+                self.propertieDict[rep.name] = rep
+                
+    def editProperty(self, description):
+        return
+    
     def getType(self):
         return &quot;GAME_OBJECT_REPRESENTATION&quot;
 
@@ -177,7 +213,6 @@
         else:
             return self.meshFile
 
-
     def createProperty(self, property):
         if property.get(&quot;type&quot;) == &quot;STRING&quot;:
             name = property.get(&quot;name&quot;)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py	2009-04-11 10:34:44 UTC (rev 4893)
@@ -30,6 +30,7 @@
         super(GoTreeWidget, self).__init__(parent)
         self.setDragEnabled(True)
         self.setAnimated(True)
+        self.setAlternatingRowColors(True)
         
     def startDrag(self,  dropActions):
         data = QByteArray()
@@ -101,7 +102,6 @@
 
     def updateObjectList(self,  objectsDict):
         for key in objectsDict:
-            changeColor = True
             file = objectsDict[key]
             fileItem = QTreeWidgetItem(self.treeWidget)
             fileItem.setText(0, str(key))
@@ -111,22 +111,12 @@
                 goItem = QTreeWidgetItem(fileItem)
                 self.addItemToDict(go, goItem)
                 goItem.setIcon(0, QIcon(&quot;media/icons/agt_games.png&quot;))
-                if changeColor:
-                    goItem.setBackgroundColor(0, QColor(&quot;lightGray&quot;))
-                    goItem.setBackgroundColor(1, QColor(&quot;lightGray&quot;))
-                    goItem.setBackgroundColor(2, QColor(&quot;lightGray&quot;))
                 goItem.setText(0, str(go.classid))
                 goItem.setText(1, str(go.baseclass))
-                changeColor = not changeColor
 
-                changeColor2 = False
                 for prop in go.properties:
                     item1 = QTreeWidgetItem(goItem) #the property item, needs to be created regardless the type
                     self.addItemToDict(prop, item1)
-                    if changeColor:
-                        item1.setBackgroundColor(0, QColor(&quot;lightGray&quot;))
-                        item1.setBackgroundColor(1, QColor(&quot;lightGray&quot;))
-                        item1.setBackgroundColor(2, QColor(&quot;lightGray&quot;))
                     item1.setIcon(0, QIcon(&quot;media/icons/agt_multimedia.png&quot;))
                     item1.setText(0, str(prop.name))
                     item1.setText(1, prop.getType())
@@ -137,5 +127,4 @@
                     else:
                         item1.setText(2, unicode(prop.data))
 
-                    changeColor2 = not changeColor
 

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-11 10:34:44 UTC (rev 4893)
@@ -35,7 +35,7 @@
             i += 1
 
 class ExplorerOptionsDlg(QDialog):
-    def __init__(self, lights, gameObjects, entities, zones, parent = None):
+    def __init__(self, lights, gameObjects, entities, zones, zonelights, parent = None):
         super(ExplorerOptionsDlg, self).__init__(parent)
         
         buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
@@ -57,6 +57,10 @@
         self.zonesCheckBox.setChecked(zones)        
         layout.addWidget(self.zonesCheckBox)
         
+        self.zoneslightsCheckBox = QCheckBox(&quot;Show Zonelights&quot;)
+        self.zoneslightsCheckBox.setChecked(zonelights)        
+        layout.addWidget(self.zoneslightsCheckBox)
+        
         layout.addWidget(buttonBox)
         layout.setContentsMargins(2, 2, 2, 2)
         self.setLayout(layout)
@@ -83,9 +87,13 @@
     def __init__(self, parent = None):
         super(ModuleTreeWidget, self).__init__(parent)
         
+        self.moduleManager = None
         self.setContextMenuPolicy(Qt.CustomContextMenu)        
         self.connect(self, SIGNAL(&quot;customContextMenuRequested(const QPoint &amp;)&quot;), self.doMenu)
-
+        
+        self.setDragEnabled(True)
+        self.setAcceptDrops(True)
+        
         self.onMenuCallback = None
         self.setAnimated(True)
 
@@ -98,7 +106,78 @@
     def doMenu(self, point):
         self.onMenuCallback(point)
 
+    def startDrag(self, lvi):
+        relMousePos = self.mapFromGlobal(QPoint(QCursor.pos().x(), QCursor.pos().y() - self.header().height()))
+        item = self.itemAt(relMousePos)
+        if item is not None and not str(item.data(0, Qt.UserRole).toString()).startswith(&quot;light_&quot;) and not item.data(0, Qt.UserRole).toInt()[0] == ModuleExplorer.LIGHT_IN_ZONE:
+            return
+        
+        data = QByteArray()
+        stream = QDataStream(data,  QIODevice.WriteOnly)
+        stream &lt;&lt; self.currentItem().text(0)
+        mimeData = QMimeData()
+        mimeData.setData(&quot;application/light&quot;, data)
+        drag = QDrag(self)
+        drag.setMimeData(mimeData)
+        drag.start(Qt.CopyAction)
+
+    def dragEnterEvent(self, event):
+        print &quot;enter&quot;
+        if event.mimeData().hasFormat(&quot;application/light&quot;):
+            event.accept()
+            
+            items = self.selectedItems()
+            
+            if items[0].data(0, Qt.UserRole).toInt()[0] == ModuleExplorer.LIGHT_IN_ZONE:
+                zone = self.zoneManager.getZone(str(items[0].parent().parent().text(0)).replace(&quot;Zone: &quot;, &quot;&quot;))
+                zone.lightList.remove(str(items[0].text(0)))
+                
+                items[0].parent().removeChild(items[0])
+                
+    def dragMoveEvent (self, event):
+        relMousePos = self.mapFromGlobal(QPoint(QCursor.pos().x(), QCursor.pos().y() - self.header().height()))
+        item = self.itemAt(relMousePos)
+        if item is not None and str(item.text(0)).startswith(&quot;Zone: &quot;):
+            event.accept()
+        else:
+            event.ignore()
+            
+
+    def dropEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/light&quot;):
+            data = event.mimeData().data(&quot;application/light&quot;)
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream &gt;&gt; text
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        
+            relMousePos = self.mapFromGlobal(QPoint(QCursor.pos().x(), QCursor.pos().y() - self.header().height()))
+            item = self.itemAt(relMousePos)
+            str(item.data(0, Qt.UserRole).toString())
+            
+            items = self.findItems(&quot;Lights&quot;, Qt.MatchFixedString | Qt.MatchRecursive)
+            for iitem in items:
+                if iitem.parent() is item:
+                    zoneName = str(item.text(0)).replace(&quot;Zone: &quot;, &quot;&quot;)
+                    zone = self.zoneManager.getZone(zoneName)
+                    
+                    for light in zone.lightList:
+                        if str(light) == str(text):
+                            print &quot;Zone \&quot;&quot; + zoneName + &quot;\&quot; already has Light \&quot;&quot; + str(light) + &quot;\&quot; attached!&quot;
+                            return
+                    
+                    zone.lightList.append(text)
+                    child = QTreeWidgetItem(iitem)
+                    child.setText(0, text)
+                    child.setData(0, Qt.UserRole, QVariant(ModuleExplorer.LIGHT_IN_ZONE))
+
+
+
 class ModuleExplorer(QWidget):
+    LIGHT_IN_ZONE = 99
+    
     def __init__(self, parent=None):
         QWidget.__init__(self, parent)
         self.sceneTreeView = ModuleTreeWidget()
@@ -125,6 +204,7 @@
         self.onMenuPoint = None
         
         self.showLights = True
+        self.showZoneLights = True
         self.showGameObjects = True
         self.showEntities = True
         self.showZones = True
@@ -174,6 +254,13 @@
         if self.selectionChangedCallback is None:
             return
 
+        #get all selected items
+        selItems = self.sceneTreeView.selectedItems()
+        if len(selItems) == 1:
+            if str(selItems[0].parent().text(0)) == &quot;Lights&quot; and str(selItems[0].parent().parent().text(0)).startswith(&quot;Zone: &quot;):
+                return
+        
+        
         nodeNames = {}
         
         # get all maps and add them as a key to the dictionary
@@ -188,15 +275,14 @@
         for item in items:
             nodeNames[str(item.text(0))] = []
         
-        #get all selected items
-        items = self.sceneTreeView.selectedItems()
+
         
         #end remove all the things from the list we actually don't want to be selected
-        for item in items:
+        for item in selItems:
             if str(item.text(0)).startswith(&quot;Scene: &quot;) or str(item.text(0)).startswith(&quot;Map: &quot;) or str(item.text(0)).startswith(&quot;Zone: &quot;):
                 items.remove(item)
         
-        for item in items:
+        for item in selItems:
             parentName =  str(item.text(0))
                         
             name = str(item.data(0, Qt.UserRole).toString())
@@ -286,7 +372,7 @@
             menu.exec_(QCursor().pos())
     
     def onOptions(self):
-        dlg = ExplorerOptionsDlg(self.showLights, self.showGameObjects, self.showEntities, self.showZones, self)
+        dlg = ExplorerOptionsDlg(self.showLights, self.showGameObjects, self.showEntities, self.showZones, self.showZoneLights, self)
         if dlg.exec_():
             self.showLights = dlg.lightCheckBox.isChecked()
             self.showGameObjects = dlg.gameObjectsCheckBox.isChecked()
@@ -328,7 +414,10 @@
     
     def onDelete(self):
         print &quot;delete&quot;
-        
+
+    def keyPressEvent(self, event):
+        print &quot;key!!!!!!!!!!!!!!&quot;
+    
     def paintLastSelectedMapBlue(self):
         print self.lastSelectedMap
         for item in self.mapItems:
@@ -352,6 +441,7 @@
         self.mapSelectedCallback(sceneName, mapName)
         
     def updateView(self):
+        self.disconnect(self.sceneTreeView, SIGNAL(&quot;itemSelectionChanged ()&quot;), self.onSelectionChanged)
         self.mapItems = []
         self.sceneTreeView.clear()
         
@@ -363,7 +453,8 @@
                 self.parseMap(m, sceneRootItem)
         
         self.paintLastSelectedMapBlue()
-
+        self.connect(self.sceneTreeView, SIGNAL(&quot;itemSelectionChanged ()&quot;), self.onSelectionChanged)
+        
     def parseMap(self, map, sceneRootItem):
         childItem =  QTreeWidgetItem(sceneRootItem)
         self.mapItems.append(childItem)
@@ -434,13 +525,23 @@
                 childItem2.setText(0, &quot;Area &quot; + str(area.id))
                 childItem2.setData(0, Qt.UserRole, QVariant(area.areaNode.getName()))
                 i += 1
+             
+            if self.showZoneLights:
+                lightsItem = QTreeWidgetItem(childItem)
+                lightsItem.setText(0, &quot;Lights&quot;)
                 
+                for lightName in zone.lightList:
+                    childItem2 = QTreeWidgetItem(lightsItem)
+                    childItem2.setText(0, lightName)
+                    childItem2.setData(0, Qt.UserRole, QVariant(ModuleExplorer.LIGHT_IN_ZONE))
+                    
     def setCurrentModule(self, module):
         self.module = module
         self.updateView()
 
     def setModuleManager(self, moduleManager):
         self.moduleManager = moduleManager
+        self.sceneTreeView.zoneManager = self.moduleManager.zoneManager
         
     def setMapSelectedCallback(self, callback):
         self.mapSelectedCallback = callback

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py	2009-04-11 10:34:44 UTC (rev 4893)
@@ -1,1356 +1,1392 @@
- #################################################
-# This source file is part of Rastullahs Lockenwickler.
-# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
-
-import sys
-import codecs
-import glob
-import os
-from os.path import isfile,  join
-
-import xml.etree.cElementTree as xml
-
-import ctypes
-import ogre.renderer.OGRE as og
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from SelectionBuffer import *
-from DepthBuffer import *
-from MovePivot import *
-from GameObjectClassManager import *
-from MyRaySceneQueryListener import *
-from ZoneManager import ZoneManager
-
-
-# get the light out of a light node
-def extractLight(node):
-        i = 0
-        num = node.numAttachedObjects()
-        while i &lt; node.numAttachedObjects():
-            c = node.getAttachedObject(i)
-            tp = str(type(c))
-            if tp == &quot;&lt;class 'ogre.renderer.OGRE._ogre_.Light'&gt;&quot;:
-                return c
-            
-            i += 1
-
-# make the xml file more pretty
-def indent(elem, level=0):
-    i = &quot;\n&quot; + level*&quot;  &quot;
-    
-    if len(elem):
-        if not elem.text or not elem.text.strip():
-            elem.text = i + &quot;  &quot;
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-        for elem in elem:
-            indent(elem, level+1)
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-    else:
-        if level and (not elem.tail or not elem.tail.strip()):
-            elem.tail = i
-
-# creates unique names for new entities
-def createUniqueEntityName(sceneManager, name = None):
-    n = &quot;&quot;
-    if name is None:
-        n = &quot;dropMesh&quot; + str(ModuleManager.dropCount)
-    else:
-        n = name
-        
-    while sceneManager.hasEntity(n):
-        n = &quot;dropMesh&quot; + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-    return n
-        
-def printVector3(vec):
-    print str(vec.x) + &quot;;&quot; + str(vec.y) + &quot;;&quot; + str(vec.z)
-    
-class EntityCustomOptions(og.UserDefinedObject):
-    def __init__(self, receivesShadow = True, staticgeometrygroup = 0, physicsproxytype = &quot;none&quot;, renderingdistance = &quot;20000&quot;):
-        og.UserDefinedObject.__init__(self)
-        self.receivesShadow = receivesShadow
-        self.staticgeometrygroup = staticgeometrygroup
-        self.physicsproxytype = physicsproxytype
-        self.renderingdistance = renderingdistance
-        self.materialName = &quot;NotChanged&quot;
-        
-        ModuleManager.entityCustomOptionsDict.append(self)
-        
-    def copy(self):
-            return EntityCustomOptions(self.receivesShadow, self.staticgeometrygroup, self.physicsproxytype, self.renderingdistance)
-        
-    def getType(self):
-            return &quot;EntityCustomOptions&quot;
-
-class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyMap = False):
-        self.pathToMapFile = pathToFile
-        
-        mapName = pathToFile.replace(&quot;\\&quot;, &quot;/&quot;)
-        mapName = mapName.split(&quot;/&quot;)
-        mapName = mapName[len(mapName) - 1].split(&quot;.&quot;)
-        mapName = mapName[len(mapName) - 3]
-        self.mapName = mapName
-        self.mapFileName = self.mapName + &quot;.rlmap.xml&quot;
-        
-        self.sceneManager = sceneManager
-        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-        self.zoneManager = zoneManager
-        self.isHidden = False
-        
-        self.zoneList = []
-        
-        if not emptyMap:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-
-            if root.attrib[&quot;formatVersion&quot;] == &quot;0.4.0&quot;:
-                self.parseMapNodes(root.find(&quot;nodes&quot;))
-                self.parseMapZones(root.find(&quot;zones&quot;))
-            else:
-                print pathToFile + &quot; has wrong format version. It needs to be 0.4.0&quot;
-                return
-
-    def hide(self):
-        try:
-            self.sceneManager.getRootSceneNode().removeChild(self.mapNode)
-        except:
-            print &quot;Error: map is already hidden!&quot;
-            return
-        
-        self.isHidden = True
-        
-    def show(self):
-        try:
-            self.sceneManager.getRootSceneNode().addChild(self.mapNode)
-        except:
-            print &quot;Error: map is already shown!&quot;
-            return
-        
-        self.isHidden = False
-    
-    def parseMapZones(self, zonesElement):
-        self.zoneManager.parseZonesFromXml(zonesElement, self)
-    
-    def parseMapNodes(self, nodeElement):
-        nodes = nodeElement.getiterator(&quot;gameobject&quot;)
-        self.createGameObjects(nodes)
-        
-        nodes = nodeElement.getiterator(&quot;entity&quot;)
-        self.createEntites(nodes)
-
-        nodes = nodeElement.getiterator(&quot;light&quot;)
-        self.createLights(nodes)
-
-        nodes = nodeElement.getiterator(&quot;sound&quot;)
-        self.createSound(nodes)
-
-        nodes = nodeElement.getiterator(&quot;particlesystem&quot;)
-        self.createParticleSystems(nodes)
-
-    def createEntites(self, entityNodes):
-        for nodes in entityNodes:
-            entityName = nodes.attrib[&quot;name&quot;]
-            
-            if entityName.startswith(&quot;dropMesh&quot;):
-                num = int(entityName.replace(&quot;dropMesh&quot;,  &quot;&quot;))
-                if ModuleManager.dropCount &lt; num:
-                    ModuleManager.dropCount = num
-                elif ModuleManager.dropCount &lt; num:
-                    ModuleManager.dropCount = num + 1
-                    
-            meshFile = nodes.attrib[&quot;meshfile&quot;]
-            
-            eco = EntityCustomOptions()
-            
-            try:
-                if nodes.attrib[&quot;receivesShadow&quot;] == &quot;False&quot; or nodes.attrib[&quot;receivesShadow&quot;] == &quot;false&quot;:
-                    eco.receivesShadow = &quot;False&quot;
-            except:
-                pass
-            try:
-                eco.staticgeometrygroup = int(nodes.attrib[&quot;staticgeometrygroup&quot;])
-            except:
-                pass
-            try:
-                eco.physicsproxy = nodes.attrib[&quot;physicsproxy&quot;]
-            except:
-                pass
-            try:
-                eco.renderingdistance = float(nodes.attrib[&quot;renderingdistance&quot;])
-            except:
-                pass
-            try:
-                eco.renderingdistance
-                nodes.attrib[&quot;materialName&quot;]
-            except:
-                pass
-                
-            nodePosition = None
-            nodeScale = None
-            qw = qx = qy = qz = None
-
-            transformations = nodes.getiterator()
-            for t in transformations:
-                if t.tag == &quot;position&quot;:
-                    posx = float(t.attrib[&quot;x&quot;])
-                    posy = float(t.attrib[&quot;y&quot;])
-                    posz = float(t.attrib[&quot;z&quot;])
-                    nodePosition = og.Vector3(posx, posy, posz)
-                elif t.tag == &quot;rotation&quot;:
-                    qw = float(t.attrib[&quot;qw&quot;])
-                    qx = float(t.attrib[&quot;qx&quot;])
-                    qy = float(t.attrib[&quot;qy&quot;])
-                    qz = float(t.attrib[&quot;qz&quot;])
-                elif t.tag == &quot;scale&quot;:
-                    scalex = float(t.attrib[&quot;x&quot;])
-                    scaley = float(t.attrib[&quot;y&quot;])
-                    scalez = float(t.attrib[&quot;z&quot;])
-                    nodeScale = og.Vector3(scalex, scaley, scalez)
-
-            try:
-                e = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager,  entityName), meshFile)
-            except:
-                print &quot;Warning: Meshfile &quot; + meshFile + &quot; could not be found.&quot;
-                return
-
-            e.setUserObject(eco)
-            n = self.mapNode.createChild(&quot;entity_&quot; + entityName + &quot;_node&quot;)
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            n.setOrientation(qw, qx, qy, qz)
-            n.setScale(nodeScale)
-
-    def createLights(self, lightNodes):
-        for l in lightNodes:
-            lightName = l.attrib[&quot;name&quot;]
-            lightType = l.attrib[&quot;type&quot;]
-            lightVisible = bool(l.attrib[&quot;visible&quot;])
-            castShadows = bool(l.attrib[&quot;castShadows&quot;])
-            lightPosition = None
-            lightDirection = None
-            colourDiffuse = None
-            colourSpecular = None
-            lightAttenuationRange = None
-            lightAttenuationConstant= None
-            lightAttenuationLinear = None
-            lightAttenuationQuadratic = None
-            spotlightinner = None
-            spotlightouter = None
-            falloff = None 
-                
-            transformations = l.getiterator()
-            for t in transformations:
-                if t.tag == &quot;position&quot;:
-                    x = float(t.attrib[&quot;x&quot;])
-                    y = float(t.attrib[&quot;y&quot;])
-                    z = float(t.attrib[&quot;z&quot;])
-                    lightPosition = og.Vector3(x, y, z)
-                elif t.tag == &quot;colourDiffuse&quot;:
-                    r = float(t.attrib[&quot;r&quot;])
-                    g = float(t.attrib[&quot;g&quot;])
-                    b= float(t.attrib[&quot;b&quot;])
-                    colourDiffuse = og.ColourValue(r, g, b)
-                elif t.tag == &quot;colourSpecular&quot;:
-                    r = float(t.attrib[&quot;r&quot;])
-                    g = float(t.attrib[&quot;g&quot;])
-                    b= float(t.attrib[&quot;b&quot;])
-                    colourSpecular = og.ColourValue(r, g, b)
-                elif t.tag == &quot;lightAttenuation&quot;:
-                    lightAttenuationRange = float(t.attrib[&quot;range&quot;])
-                    lightAttenuationConstant= float(t.attrib[&quot;constant&quot;])
-                    lightAttenuationLinear = float(t.attrib[&quot;linear&quot;])
-                    lightAttenuationQuadric  = float(t.attrib[&quot;quadratic&quot;])
-                elif t.tag == &quot;spotlightrange&quot;:
-                    spotlightinner = float(t.attrib[&quot;inner&quot;])
-                    spotlightouter = float(t.attrib[&quot;outer&quot;])
-                    falloff = float(t.attrib[&quot;falloff&quot;])
-                    
-            light = self.sceneManager.createLight(lightName)
-            
-            if lightType == &quot;point&quot;:
-                light.setType(og.Light.LT_POINT)            
-            elif lightType == &quot;spot&quot;:
-                light.setType(og.Light.LT_SPOTLIGHT)
-            elif lightType == &quot;directional&quot;:
-                light.setType(og.Light.LT_DIRECTIONAL)
-            
-            light.setVisible(lightVisible)
-            light.setCastShadows(castShadows)
-            if lightAttenuationRange is not None and lightAttenuationConstant is not None and lightAttenuationLinear is not None and lightAttenuationQuadric is not None:
-                light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadric)
-            if colourDiffuse:
-                light.setDiffuseColour(colourDiffuse)
-            if colourSpecular:
-                light.setSpecularColour(colourSpecular)
-            if spotlightinner and spotlightouter and spotlightouter: 
-                light.setSpotlightRange(spotlightinner, spotlightouter, falloff)
-            
-            e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
-            n = self.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
-            n.attachObject(light)
-            n.attachObject(e)
-            if lightPosition:
-                n.setPosition(lightPosition)
-            
-    def createSound(self, soundNodes):
-        #raise NotImplementedError
-        return
-
-    def createGameObjects(self, gameObjectNodes):
-        for g in gameObjectNodes:
-            classid = g.attrib[&quot;class&quot;]
-            
-            id = int(g.attrib[&quot;id&quot;])
-            if ModuleManager.dropCount &lt; id:
-                ModuleManager.dropCount = id
-            elif ModuleManager.dropCount &lt; id:
-                ModuleManager.dropCount = id + 1
-                
-            state = g.attrib[&quot;state&quot;]
-            nodePosition = None
-            nodeRotation = None
-
-            transformations = g.getiterator()
-            for t in transformations:
-                if t.tag == &quot;position&quot;:
-                    x = float(t.attrib[&quot;x&quot;])
-                    y = float(t.attrib[&quot;y&quot;])
-                    z = float(t.attrib[&quot;z&quot;])
-                    nodePosition = og.Vector3(x, y, z)
-                elif t.tag == &quot;rotation&quot;:
-                    qw = float(t.attrib[&quot;qw&quot;])
-                    qx = float(t.attrib[&quot;qx&quot;])
-                    qy = float(t.attrib[&quot;qy&quot;])
-                    qz = float(t.attrib[&quot;qz&quot;])
-                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
-
-            go = self.gocManager.getGameObjectWithClassId(classid)
-            if go is not None:
-                meshFile = go.getMeshFileName()
-                
-                ent = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-                dropNode = self.mapNode.createChild(&quot;gameobject_&quot; + &quot;dropNode&quot; + str(id))
-                dropNode.attachObject(ent)
-
-                if nodePosition:
-                    dropNode.setPosition(nodePosition)
-                if nodeRotation:
-                    dropNode.setOrientation(nodeRotation)
-
-                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
-                self.gocManager.addGameObjectRepresentation(go)
-                go.inWorldId = id
-                go.state = state
-                ent.setUserObject(go)
-
-
-    def createParticleSystems(self, particleNodes):
-        #raise NotImplementedError
-        return
-        
-    def save(self):
-        root = xml.Element(&quot;rastullahmap&quot;)
-        root.attrib[&quot;formatVersion&quot;] = &quot;0.4.0&quot;
-        
-        nodesElem = xml.SubElement(root, &quot;nodes&quot;)
-        
-        i = 0
-        while i &lt; self.mapNode.numChildren():
-            n = self.mapNode.getChild(i)
-            if n.numAttachedObjects() &gt; 0:
-                if n.name.startswith(&quot;entity_&quot;):
-                    entElem = xml.SubElement(nodesElem, &quot;entity&quot;)
-                    entElem.attrib[&quot;name&quot;] = n.getAttachedObject(0).getName()
-                    print &quot;Saving Entity: &quot; + n.getAttachedObject(0).getName()
-                    entElem.attrib[&quot;meshfile&quot;] = n.getAttachedObject(0).getMesh().getName()
-   
-                    entElem.attrib[&quot;receivesShadow&quot;] = str(n.getAttachedObject(0).getUserObject().receivesShadow).lower()
-                    entElem.attrib[&quot;staticgeometrygroup&quot;] = str(n.getAttachedObject(0).getUserObject().staticgeometrygroup)
-                    entElem.attrib[&quot;physicsproxytype&quot;] = str(n.getAttachedObject(0).getUserObject().physicsproxytype)
-                    entElem.attrib[&quot;renderingdistance&quot;] = str(n.getAttachedObject(0).getUserObject().renderingdistance)
-                    
-                    posElem = xml.SubElement(entElem, &quot;position&quot;)
-                    posElem.attrib[&quot;x&quot;] = str(n.getPosition().x)
-                    posElem.attrib[&quot;y&quot;] = str(n.getPosition().y)
-                    posElem.attrib[&quot;z&quot;] = str(n.getPosition().z)
-                    
-                    rotElem = xml.SubElement(entElem, &quot;rotation&quot;)
-                    rotElem.attrib[&quot;qw&quot;] = str(n.getOrientation().w)
-                    rotElem.attrib[&quot;qx&quot;] = str(n.getOrientation().x)
-                    rotElem.attrib[&quot;qy&quot;] = str(n.getOrientation().y)
-                    rotElem.attrib[&quot;qz&quot;] = str(n.getOrientation().z)
-                    
-                    scaleElem = xml.SubElement(entElem, &quot;scale&quot;)
-                    scaleElem.attrib[&quot;x&quot;] = str(n.getScale().x)
-                    scaleElem.attrib[&quot;y&quot;] = str(n.getScale().y)
-                    scaleElem.attrib[&quot;z&quot;] = str(n.getScale().z)
-                    
-                elif n.name.startswith(&quot;gameobject_&quot;):
-                    goElem = xml.SubElement(nodesElem, &quot;gameobject&quot;)
-                    mname = n.name
-                    print &quot;Saving GOID: &quot; + str(n.getAttachedObject(0).getUserObject().inWorldId)
-                    goElem.attrib[&quot;class&quot;] = str(n.getAttachedObject(0).getUserObject().gocName)
-                    goElem.attrib[&quot;state&quot;] = str(n.getAttachedObject(0).getUserObject().state)
-                    goElem.attrib[&quot;id&quot;] = str(n.getAttachedObject(0).getUserObject().inWorldId)
-                    
-                    posElem = xml.SubElement(goElem, &quot;position&quot;)
-                    posElem.attrib[&quot;x&quot;] = str(n.getPosition().x)
-                    posElem.attrib[&quot;y&quot;] = str(n.getPosition().y)
-                    posElem.attrib[&quot;z&quot;] = str(n.getPosition().z)
-                    
-                    rotElem = xml.SubElement(goElem, &quot;rotation&quot;)
-                    rotElem.attrib[&quot;qw&quot;] = str(n.getOrientation().w)
-                    rotElem.attrib[&quot;qx&quot;] = str(n.getOrientation().x)
-                    rotElem.attrib[&quot;qy&quot;] = str(n.getOrientation().y)
-                    rotElem.attrib[&quot;qz&quot;] = str(n.getOrientation().z)
-                    
-                elif n.name.startswith(&quot;light_&quot;):
-                    light = extractLight(n)
-                    lightName = light.getName()
-                    print &quot;Saving Light: &quot; + lightName
-                    lightType = light.getType()
-                    isVisible = &quot;true&quot;
-                    if not light.getVisible():
-                        isVisible = &quot;false&quot;
-                    
-                    castShadows = &quot;false&quot;
-                    if light.getCastShadows():
-                        castShadows = &quot;true&quot;
-                    
-                    if lightType == og.Light.LT_POINT:
-                        lightType = &quot;point&quot;
-                    elif lightType == og.Light.LT_SPOTLIGHT:
-                        lightType = &quot;spot&quot;
-                    elif lightType == og.Light.LT_DIRECTIONAL:
-                        lightType = &quot;directional&quot;
-                    
-                    
-                    lightElem = xml.SubElement(nodesElem, &quot;light&quot;)
-                    lightElem.attrib[&quot;name&quot;] = lightName
-                    lightElem.attrib[&quot;type&quot;] = lightType
-                    lightElem.attrib[&quot;visible&quot;] = isVisible
-                    lightElem.attrib[&quot;castShadows&quot;] = castShadows
-                    
-                    if lightType == &quot;point&quot; or lightType == &quot;spot&quot;:
-                        posElem = xml.SubElement(lightElem, &quot;position&quot;)
-                        posElem.attrib[&quot;x&quot;] = str(n.getPosition().x)
-                        posElem.attrib[&quot;y&quot;] = str(n.getPosition().y)
-                        posElem.attrib[&quot;z&quot;] = str(n.getPosition().z)
-                    
-                    colDiffuseElem = xml.SubElement(lightElem, &quot;colourDiffuse&quot;)
-                    colDiffuseElem.attrib[&quot;r&quot;] = str(light.getDiffuseColour().r)
-                    colDiffuseElem.attrib[&quot;g&quot;] = str(light.getDiffuseColour().g)
-                    colDiffuseElem.attrib[&quot;b&quot;] = str(light.getDiffuseColour().b)
-
-                    colSpecularElem = xml.SubElement(lightElem, &quot;colourSpecular&quot;)
-                    colSpecularElem.attrib[&quot;r&quot;] = str(light.getSpecularColour().r)
-                    colSpecularElem.attrib[&quot;g&quot;] = str(light.getSpecularColour().g)
-                    colSpecularElem.attrib[&quot;b&quot;] = str(light.getSpecularColour().b)
-                    
-                    lightAttenuationElem = xml.SubElement(lightElem, &quot;lightAttenuation&quot;)
-                    lightAttenuationElem.attrib[&quot;range&quot;] = str(light.getAttenuationRange())
-                    lightAttenuationElem.attrib[&quot;constant&quot;] = str(light.getAttenuationConstant())
-                    lightAttenuationElem.attrib[&quot;linear&quot;] = str(light.getAttenuationLinear())
-                    lightAttenuationElem.attrib[&quot;quadratic&quot;] = str(light.getAttenuationQuadric())
-                    
-                    if lightType == &quot;spot&quot;:
-                        spotligthRangeElem = xml.SubElement(lightElem, &quot;spotlightrange&quot;)
-                        spotligthRangeElem.attrib[&quot;inner&quot;] = str(light.getSpotlightInnerAngle().valueDegrees())
-                        spotligthRangeElem.attrib[&quot;outer&quot;] = str(light.getSpotlightOuterAngle().valueDegrees())
-                        spotligthRangeElem.attrib[&quot;falloff&quot;] = str(light.getSpotlightFalloff())
-                        
-                    if lightType == &quot;spot&quot; or lightType == &quot;directional&quot;:
-                        directionElem = xml.SubElement(lightElem, &quot;direction&quot;)
-                        dir = og.Vector3()
-                        n.getOrientation().ToAxes(dir)
-                        directionElem.attrib[&quot;x&quot;] = str(dir.x)
-                        directionElem.attrib[&quot;y&quot;] = str(dir.y)
-                        directionElem.attrib[&quot;z&quot;] = str(dir.z)
-                        
-            i = i+1
-            
-        self.zoneManager.saveZonesToXml(root, self)
-        indent(root)
-        xml.ElementTree(root).write(self.pathToMapFile)
-
-# caused a linux crash
-#        iter = self.mapNode.getChildIterator()
-#        while iter.hasMoreElements():
-#            name = iter.getNext().getName()
-#            print name
-
-class Scene():
-    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyScene = False, sceneName = &quot;NewScene&quot;):
-        self.moduleRoot = moduleroot
-        self.pathToFile = pathToFile
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gocManager
-        self.zoneManager = zoneManager
-        self.mapFiles = [] # a list in case the module has more than one map file
-        mappaths = []
-        self.name = sceneName
-
-        
-        if not emptyScene:
-            xmlTree = xml.parse(pathToFile)
-            root = xmlTree.getroot()
-            self.name = root.attrib[&quot;name&quot;]
-        
-            maps = root.getiterator(&quot;map&quot;)
-            for m in maps:
-                mappaths.append(join(self.moduleRoot, join(&quot;maps&quot;, m.attrib[&quot;file&quot;])))
-                
-            for m in mappaths:
-                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
-            
-    def addMap(self, name):
-        path = join(self.moduleRoot, join(&quot;maps&quot;, name + &quot;.rlmap.xml&quot;))
-        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True))
-        
-    def save(self):
-        root = xml.Element(&quot;scene&quot;)
-        root.attrib[&quot;name&quot;] = self.name
-        
-        for m in self.mapFiles:
-            sub = xml.SubElement(root, &quot;map&quot;)
-            sub.attrib[&quot;file&quot;] = m.mapFileName
-            m.save()
-
-        indent(root)
-        xml.ElementTree(root).write(self.pathToFile)
-
-class Module():
-    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager, zoneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.gocManager = gameObjectManager
-        self.zoneManager = zoneManager
-        
-        self.name = name
-        self.moduleRoot = join(modulePath, name)
-        self.__isCommon = False
-
-        self.hasDependencies = False
-        self.moduleDependencies = []
-
-        self.modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
-
-        self.gofFiles = [] # gof File list
-
-        self.scenes =[]
-
-        self.isLoaded = False
-        
-        self.playerStart = None
-        
-    def addScene(self, name):
-        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, (&quot;maps/&quot; + name + &quot;.rlscene&quot;)), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True, name))
-    
-    def addMapToScene(self, sceneName, mapName):
-        for scene in self.scenes:
-            if scene.name == sceneName:
-                scene.addMap(mapName)
-                return
-        
-        print &quot;ERROR: could not find scene: &quot; + sceneName
-        
-    
-    def isCommon(self):
-        if isfile(self.modConfig): # is the modconfig existing?
-            f = codecs.open(self.modConfig, 'r', 'utf-8')
-        else:
-            print (&quot;Module.isCommon() Error: couldn't find module config&quot;)
-            return
-        isDependencieLine = False
-        for i, line in enumerate(f):
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith(&quot;super(&quot;):
-                split = lStripped.split(&quot;,&quot;)
-                if split[2].strip() == unicode(&quot;true&quot;):
-                    self.__isCommon = True
-                    return True
-
-
-            elif isDependencieLine:
-                if lStripped == &quot;end&quot;:
-                    isDependencieLine = False
-                else:
-                    self.hasDependencies = True
-                    pl = lStripped.split('&quot;')
-                    i = 1
-                    while i &lt; 100: 
-                        try:
-                            self.moduleDependencies.append(pl[i])
-                            i += 2
-                        except IndexError, e:
-                            break
-
-            elif lStripped == &quot;def getDependencies()&quot;:
-                isDependencieLine = True
-
-        return False
-
-    def load(self):
-        if self.isLoaded:
-            return
-        
-        self.isLoaded = True
-        self.modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
-        if isfile(self.modConfig): # is the modconfig existing?
-            f = codecs.open(self.modConfig, 'r', 'utf-8')
-        else:
-            print (&quot;Module.load: Error: couldn't find module config&quot;)
-            return
-
-        for line in f:
-            lStripped = line.strip() #strip the whitespace away, not needed here
-            if lStripped.startswith(&quot;hero = $GOM.getGameObject(&quot;):
-                try:
-                    self.playerStart = int(line.split(&quot;(&quot;)[1].split(&quot;)&quot;)[0])
-                except ValueError, e:
-                    print self.modConfig + &quot; ValueError: &quot; + str(e)
-                    self.playerStart = None
-                    continue
-                    
-        self.setResourcePaths()
-        
-        try:
-            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-        except og.OgreException, e:
-            print e
-        
-        
-        cmd = join(self.moduleRoot, &quot;dsa/*.gof&quot;)
-        self.gofFiles = glob.glob(cmd)
-        self.gocManager.parseGOFFiles(self.gofFiles)
-
-        if not self.isCommon():
-            cmd = join(self.moduleRoot, &quot;maps/*.rlscene&quot;)
-            sceneFile = glob.glob(cmd)
-            self.loadScenes(sceneFile)
-                
-    def loadScenes(self, sceneFiles):
-        for s in sceneFiles:
-            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
-
-    def save(self):
-        for s in self.scenes:
-            s.save()
-            
-        self.saveModuleConfig()
-
-    def saveModuleConfig(self):
-        if self.playerStart is not None:
-            f = open(self.modConfig, &quot;r&quot;)
-            
-            newconfig = &quot;&quot;
-            for line in f:
-                if line.startswith(&quot;       hero = $GOM.getGameObject(&quot;):
-                    newconfig += &quot;       hero = $GOM.getGameObject(&quot; + str(self.playerStart) + &quot;);\n&quot;
-                else:
-                    newconfig += line
-            f.close()
-            
-            f = open(self.modConfig, &quot;w&quot;)
-            f.write(newconfig)
-            f.close()
-
-    def setResourcePaths(self, recurseFolder = &quot;&quot;):
-        if recurseFolder == &quot;&quot;:
-            rootFolder = self.moduleRoot
-        else:
-            rootFolder = join(self.moduleRoot, recurseFolder)
-
-        for file in os.listdir(rootFolder):
-            curFile = join(rootFolder, file)
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            elif os.path.isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, &quot;FileSystem&quot;, self.name, False)
-                self.setResourcePaths(curFile)
-            elif os.path.isfile(curFile):
-                continue
-                
-    def getMap(self, mapName, sceneName = None):
-        if sceneName is not None:
-            for s in self.scenes:
-                if s.name == sceneName:
-                    for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-        else:
-            for s in self.scenes:
-                for m in s.mapFiles:
-                        if m.mapName == mapName:
-                            return m
-
-class ProgressBarThread(QThread):
-    def __init__(self, min, max, moduleName):
-        QThread.__init__(self)
-        self.progress = QProgressDialog(&quot;Loading &quot; + moduleName, &quot;Abort Loading&quot;, min, max, None);
-        self.progress.setWindowModality(Qt.WindowModal)
-
-    def setProgress(self, progress, labelText):
-        self.progress.setLabelText(labelText)
-        self.progress.setValue(progress)
-        
-    def run(self):
-        self.progress.show()
-        self.exec_()
-
-        
-class ModuleManager():
-    dropCount = 0
-    entityCustomOptionsDict = []
-    
-    def __init__(self,  ogreRoot,  sceneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.modelSelectionDialog = None
-        self.materialSelectionDialog = None
-
-        self.moduleCfgPath = &quot;&quot;
-
-        self.gocManager = GameObjectClassManager()
-        
-
-        self.mainModule = None
-        self.mainModuledependencieList =[]
-        self.moduleList = []
-        self.userSelectionList = []
-        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
-        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-        self.currentMap = None
-        self.moduleExplorer = None
-
-        self.lastRay = None
-        self.rayLine = None
-
-        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
-        self.pivot = None
-        self.movingPivot = False
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.dropNode = None
-        self.dropEntity = None
-        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
-        self.dropMat = None
-        
-        self.moduleConfigIsParsed = False
-
-        self.selectionBuffer = None
-        self.depthBuffer = None
-        self.propertyWindow = None
-    
-        self.oneClickEntityPlacement = False
-        
-        self.onContextMenuCallback = None
-        self.contextMenuClickPosition = None
-        self.contextMenuRay = None
-        
-        self.playerStartGameObjectId = None
-        
-        self.entityCustomOptionsDict = []
-        
-        self.raySceneQueryListener = MyRaySceneQueryListener()
-        
-        self.zoneManager = ZoneManager(self.sceneManager)
-        
-    def resetParsedModuleConfig(self):
-        self.moduleConfigIsParsed = False
-        self.moduleList = []
-
-    def parseModuleConfig(self):
-        if self.moduleConfigIsParsed:
-            return
-
-        import codecs
-        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
-
-        for line in f:
-            if line.startswith('#'):
-                continue
-
-            if line.startswith('module='):
-                splines = line.split('=')
-                str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace(&quot;/modules.cfg&quot;,  &quot;&quot;), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
-
-        self.moduleConfigIsParsed = True
-
-    def moduleExists(self, name):
-        lowerA = str(name).lower()
-        
-        for m in self.moduleList:
-            lowerB = m.name.lower()
-            if lowerA == lowerB:
-                return True
-        
-        return False
-
-    def openLoadModuleDialog(self):
-        self.moduleFolder = str(self.moduleCfgPath.replace(&quot;modules.cfg&quot;, &quot;&quot;))
-
-        self.parseModuleConfig()
-
-        dlg = QDialog(QApplication.focusWidget())
-        list = QListWidget()
-        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
-        dlg.connect(btnBox, SIGNAL(&quot;accepted()&quot;), dlg.accept)
-        dlg.connect(btnBox, SIGNAL(&quot;rejected()&quot;), dlg.reject)
-
-        for m in self.moduleList:
-            if not m.isCommon():
-                list.addItem(m.name)
-
-        layout = QVBoxLayout()
-        layout.addWidget(list)
-        layout.addWidget(btnBox)
-        dlg.setLayout(layout)
-        if dlg.exec_():
-            self.loadModule(str(list.currentItem().text()))
-
-    # I'm sorry for this
-    def loadModule(self, moduleName):
-        t = og.Timer()
-        
-#        self.progress = ProgressBarThread(0, 8, moduleName)
-#        self.progress.start()
-        
-        for m in self.moduleList:
-            if m.name == moduleName:
-                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
-                    for moduleDependencie in m.moduleDependencies:
-                        for m2 in self.moduleList:
-                            if m2.name == moduleDependencie:
-#                                self.progress.setProgress(2, &quot;Loading Dependencie: &quot; + moduleDependencie)
-                                m2.load()
-                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
-                                self.materialSelectionDialog.scanDirForMaterials(m2.moduleRoot)
-                                self.mainModuledependencieList.append(m2)
-
-#                self.progress.setProgress(4, &quot;Loading &quot; + moduleName)
-                m.load()
-#                self.progress.setProgress(6, &quot;Scan for models...&quot;)
-                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
-#                self.progress.setProgress(8, &quot;Scan for materials&quot;)
-                self.materialSelectionDialog.scanDirForMaterials(m.moduleRoot)
-                self.mainModule = m
-                self.moduleExplorer.setCurrentModule(m)
-
-        if self.selectionBuffer is None:
-            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget(&quot;OgreMainWin&quot;), self, self.zoneManager)
-
-#        if self.depthBuffer is None:
-#            self.depthBuffer = DepthBuffer(self.sceneManager, self.ogreRoot.getRenderTarget(&quot;OgreMainWin&quot;))
-
-
-#        self.progress.quit()
-        print &quot;Time to load module: &quot; + str(t.getMilliseconds() / 1000.0) + &quot; seconds&quot;
-        del t
-
-    def addSceneToModule(self, name):
-        if self.mainModule is not None:
-            self.mainModule.addScene(name)
-
-    def addMapToScene(self, sceneName, mapName):
-        if self.mainModule is not None:
-            self.mainModule.addMapToScene(sceneName, mapName)
-
-    def setModuleExplorer(self, moduleExplorer):
-        self.moduleExplorer = moduleExplorer
-        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
-        self.moduleExplorer.setSelectionChangedCallback(self.selectionChangedCallback)
-        self.moduleExplorer.setModuleManager(self)
-    
-    def setPropertyWindow(self, propertyWin):
-        self.propertyWindow = propertyWin
-    
-    def selectionChangedCallback(self, items):
-        self.resetSelection()
-        self.userSelectionList = self.selectionBuffer.manualSelectObjects(items)
-        
-    def selectMapCallback(self, sceneName, mapName):
-        self.currentMap = self.mainModule.getMap(mapName, sceneName)
-        self.zoneManager.currentMap = self.currentMap
-        if self.currentMap is None:
-            print &quot;Don't forget to select a map&quot;
-
-        
-    # called when a click into Main Ogre Window occurs
-    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
-        if self.oneClickEntityPlacement:
-            if self.modelSelectionDialog.listWidget.currentItem() is not None:
-                meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
-                self.startDropModelAction(meshFile, ray)
-                self.moduleExplorer.updateView()
-                return
-            else:
-                print &quot;Warning: OneClickEntityPlacement still runing on without any selected mesh!&quot;
-                return
-                
-        #self.depthBuffer.onSelectionClick(screenX, screenY)
-        
-        so = None
-        if self.selectionBuffer is not None:
-            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        
-        if so is not None:
-            if not so.isPivot:                
-                if not controlDown and not shiftDown:
-                    self.resetSelection()
-                    so.setSelected(True)
-                    self.userSelectionList.append(so)
-                    self.propertyWindow.showProperties(so)
-                    self.moduleExplorer.deselectAll()
-                    self.moduleExplorer.selectItem(so, True)
-                    self.updatePivots()
-                elif controlDown and not shiftDown:
-                    so.setSelected(True)
-
-                    for soFromList in self.userSelectionList:
-                        if soFromList == so:
-                            return # object already selected
-
-                    self.userSelectionList.append(so)
-                    self.propertyWindow.showProperties(so)
-                    self.moduleExplorer.selectItem(so, True)
-                    self.updatePivots()
-
-
-                elif not controlDown and shiftDown:
-                    for selo in self.userSelectionList:
-                        if so == selo:
-                            so.setSelected(False)
-                            self.userSelectionList.remove(selo)
-                            self.moduleExplorer.selectItem(selo, False)
-                    self.updatePivots()
-                
-            else:
-                #so.entity is the pivot direction that was clicked
-                self.pivot.startTransforming(so.entity,  self.userSelectionList)
-        else:
-            self.resetSelection() # click in empty space, deselect everything
-            self.moduleExplorer.selectItems(None)
-            self.propertyWindow.clear()
-            if self.pivot is not None:
-                self.pivot.hide()
-
-#        if self.rayLine == None:
-#            self.rayLine = self.sceneManager.createManualObject(&quot;rayLine&quot;)
-#            self.rayLine.setDynamic(True)
-#            self.sceneManager.getRootSceneNode().createChildSceneNode(&quot;raynode&quot;).attachObject(self.rayLine)
-#
-#            self.rayLine.begin(&quot;BaseWhiteNoLighting&quot;, og.RenderOperation.OT_LINE_STRIP)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-#
-#        else:
-#            self.rayLine.beginUpdate(0)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-
-    def deleteObjects(self):
-        if len(self.userSelectionList) &lt; 1:
-            return
-
-        self.pivot.hide()
-
-        for so in self.userSelectionList:
-            node = so.entity.getParentNode()
-            if node.getName().startswith(&quot;area_&quot;):
-                self.zoneManager.deleteArea(so.entity.getUserObject())
-                continue
-            elif node.getName().startswith(&quot;light_&quot;):
-                light = extractLight(node)
-                self.sceneManager.destroyLight(light)
-                
-            node.detachAllObjects()
-            self.sceneManager.destroySceneNode(node)
-            self.sceneManager.destroyEntity(so.entity)
-            del so
-
-        self.userSelectionList = []
-
-    def copyObjects(self):
-        if len(self.userSelectionList) &lt; 1 or self.currentMap is None:
-            print &quot;Warning: No map selected!&quot;
-            return
-
-        newSelectionList = []
-
-        for so in self.userSelectionList:
-            if so.entity.getUserObject() is not None:
-                if str(so.entity.getParentNode().getName()).startswith(&quot;gameobject_&quot;):
-                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
-                    meshFile = go.getMeshFileName()
-
-                    if go is not None:
-                        newEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-                        newNode = self.currentMap.mapNode.createChild(&quot;gameobject_dropNode&quot; + str(ModuleManager.dropCount))
-                        newNode.attachObject(newEntity)
-                        newNode.setPosition(so.entity.getParentNode().getPosition())
-
-                        newGO = GameObjectRepresentation(ModuleManager.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
-                        self.gocManager.addGameObjectRepresentation(newGO)
-                        newEntity.setUserObject(newGO)
-
-                        newSO = SelectionObject(newEntity)
-                        newSO.setSelected(True)
-                        newSelectionList.append(newSO)
-                        ModuleManager.dropCount += 1
-                elif str(so.entity.getParentNode().getName()).startswith(&quot;entity_&quot;):
-                    nodeName = &quot;entity_dropNode&quot; + str(ModuleManager.dropCount)
-                    newNode = self.currentMap.mapNode.createChild(nodeName)
-
-                    entityName = createUniqueEntityName(self.sceneManager)
-                    newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
-
-                    eco = so.entity.getUserObject().copy()
-                    newEntity.setUserObject(eco)
-
-                    newNode.attachObject(newEntity)
-                    newNode.setPosition(so.entity.getParentNode().getPosition())
-                    newNode.setOrientation(so.entity.getParentNode().getOrientation())
-                    newNode.setScale(so.entity.getParentNode().getScale())
-
-                    newSO = SelectionObject(newEntity)
-                    newSO.setSelected(True)
-                    newSelectionList.append(newSO)
-                    ModuleManager.dropCount += 1
-                elif str(so.entity.getParentNode().getName()).startswith(&quot;light_&quot;):
-                    print &quot;Can't copy lights yet :)&quot;
-
-        self.resetSelection()
-        self.userSelectionList = newSelectionList
-
-    def cutObjects(self):
-        if len(self.userSelectionList) &lt; 1:
-            return
-
-        self.cutList = []
-        for so in self.userSelectionList:
-            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
-            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
-            # set the &quot;point of gravity&quot; of all the cutted nodes to world origin at 0,0,0
-            # so we only have to translate them to their new destination when they get pasted
-            # the position of the pivot point is considered as the center of gravity
-            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
-            self.cutList.append(so)
-        self.resetSelection()
-
-    def pasteObjects(self,  ray):
-        if len(self.cutList) &lt; 1:
-            return
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            i=0
-            while i &lt; len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
-                i = i+1
-        else:
-            i=0
-            while i &lt; len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
-                i = i+1
-        self.cutList = []
-
-    def leftMouseUp(self):
-        if self.pivot is not None and self.pivot.isTransforming:
-            self.propertyWindow.updateProperties()
-            self.moduleExplorer.updateView()
-            self.pivot.stopTransforming()
-
-    def resetSelection(self):
-        if self.userSelectionList is not None:
-            for so in self.userSelectionList:
-                so.setSelected(False)
-
-        self.userSelectionList = []
-
-    def updatePivots(self):
-        newPivotPosition = og.Vector3(0, 0, 0)
-
-        for so in self.userSelectionList:
-            newPivotPosition += so.entity.getParentNode().getPosition()
-        if self.pivot is not None:
-            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
-
-    def unload(self,  saveOnUnload=True):
-        pass
-
-    def save(self):
-        self.mainModule.save()
-
-    def startDropGameObjectAction(self, classid, ray):
-        if self.currentMap is None:
-            print &quot;No map selected!&quot;
-            return
-            
-        go = self.gocManager.getGameObjectWithClassId(classid)
-
-        if go is not None:
-            meshFile = go.getMeshFileName()
-            dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
-            dropNode = self.currentMap.mapNode.createChild(&quot;gameobject_dropNode&quot; + str(ModuleManager.dropCount))
-            dropNode.attachObject(dropEntity)
-
-            result = og.Math.intersects(ray, self.dropCollisionPlane)
-            if result.first == True:
-                dropNode.setPosition(ray.getPoint(result.second))
-            else:
-                dropNode.setPosition(ray.getPoint(50))
-
-            self.dropGO = GameObjectRepresentation(ModuleManager.dropCount, classid, dropNode, meshFile)
-            self.gocManager.addGameObjectRepresentation(self.dropGO)
-            dropEntity.setUserObject(self.dropGO)
-
-        ModuleManager.dropCount += 1
-
-    def moveDropGameObjectAction(self, ray):
-        if self.currentMap is None:
-            return
-        
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropGO.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropGO.setPosition(ray.getPoint(50))
-
-    def finishDropGameObjectAction(self, ray):
-        self.moduleExplorer.updateView()
-        self.dropGO = None
-        return
-
-    def startDropModelAction(self, meshFile, ray):
-        if self.currentMap is None:
-            print &quot;No map selected!&quot;
-            return
-            
-        self.dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), meshFile)
-        
-        eco = EntityCustomOptions()
-        self.dropEntity.setUserObject(eco)
-        
-        self.dropNode = self.currentMap.mapNode.createChild(&quot;entity_dropNode&quot; + str(ModuleManager.dropCount))
-        self.dropNode.attachObject(self.dropEntity)
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-        ModuleManager.dropCount += 1
-
-    def moveDropModelAction(self, ray):
-        if self.currentMap is None:
-            return
-            
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-    
-    def finishDropModelAction(self, ray):
-        self.moduleExplorer.updateView()
-        return
-
-    def startDropMaterialAction(self, text):
-        self.dropMat = text
-        
-    def moveDropMaterialAction(self, event):
-        return
-
-    def finishDropMaterialAction(self, screenX, screenY):
-        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        if so is not None:
-            if not so.entity.getNumSubEntities() &gt; 1:
-                so.entity.setMaterialName(self.dropMat)
-                so.entity.getUserObject().materialName = self.dropMat
-            else:
-                i = 0
-                text = &quot;Warning this Entity has more than one SubEntities with the folloing materials: \n\n&quot;
-                while i &lt; so.entity.getNumSubEntities():
-                    text += &quot;SubMesh&quot; + str(i) + &quot;:  &quot; + so.entity.getSubEntity(i).getMaterialName() + &quot;\n&quot;
-                    i += 1
-                
-                text += &quot;\n Replace the materials?&quot;
-                reply = QMessageBox.question(None, &quot;Warning: multiple materials&quot;,  text,  QMessageBox.Yes|QMessageBox.No)
-                if reply == QMessageBox.Cancel:
-                    return
-                if reply == QMessageBox.Yes:
-                    so.entity.setMaterialName(self.dropMat)
-                    so.entity.getUserObject().materialName = self.dropMat
-        
-    def setOneClickEntityPlacement(self, state):
-        self.oneClickEntityPlacement = state
-    
-    def createLight(self, name):
-        pos = og.Vector3()
-        
-        query = self.sceneManager.createRayQuery(self.contextMenuRay)
-        query.ray = self.contextMenuRay
-        query.setSortByDistance(True)
-        query.execute(self.raySceneQueryListener)
-        if self.raySceneQueryListener.dist &lt; 100000:
-            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
-            self.raySceneQueryListener.dist = 100000
-            
-        light = None
-        if not self.sceneManager.hasLight(name):
-            light = self.sceneManager.createLight(name)
-            
-        return light,  pos
-        
-    def addPointLight(self):
-        if self.currentMap is None:
-            print &quot;No map selected!&quot;
-            return
-            
-        lightName = &quot;pointLight&quot; + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-        light, pos = self.createLight(lightName)
-        printVector3(pos)
-        
-        if not light:
-            print &quot;Error while creating light&quot;
-            return
-            
-        light.setType(og.Light.LT_POINT)
-        
-        e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
-        n = self.currentMap.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
-        n.attachObject(light)
-        n.attachObject(e)
-        n.setPosition(pos)
-        self.moduleExplorer.updateView()
-        
-    def addSpotLight(self):
-        if self.currentMap is None:
-            print &quot;No map selected!&quot;
-            return
-            
-        lightName = &quot;spotLight&quot; + str(ModuleManager.dropCount)
-        ModuleManager.dropCount += 1
-        
-        light, pos = self.createLight(lightName)
-        printVector3(pos)
-        
-        if not light:
-            print &quot;Error while creating light&quot;
-            return
-            
-        light.setType(og.Light.LT_SPOTLIGHT)
-        
-        e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
-        n = self.currentMap.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
-        n.attachObject(light)
-        n.attachObject(e)
-        n.setPosition(pos)
-        self.moduleExplorer.updateView()
-        
-    def addZoneToMap(self, name):
-        self.zoneManager.createZone(name)
-        self.moduleExplorer.updateView()
-        
-    def setPlayerStart(self):
-        self.mainModule.playerStart = str(self.playerStartGameObjectId)
-        print &quot;setting Player Start to &quot; + str(self.playerStartGameObjectId)
-    
-    def onContextMenu(self, screenX, screenY, ray):
-        menus = []
-        actions = []
-        pla = self.createAction(&quot;Pointlight&quot;, self.addPointLight, None, &quot;idea.png&quot;)
-        pls = self.createAction(&quot;Spotlight&quot;, self.addSpotLight, None, &quot;idea.png&quot;)
-        
-        lightMenu = QMenu(&quot;Add Light&quot;)
-        lightMenu.addAction(pla)
-        lightMenu.addAction(pls)
-        menus.append(lightMenu)
-        
-        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
-        self.contextMenuClickPosition = og.Vector2(screenX, screenY)
-        self.contextMenuRay = ray
-        
-        pos = og.Vector3()
-        query = self.sceneManager.createRayQuery(self.contextMenuRay)
-        query.ray = self.contextMenuRay
-        query.setSortByDistance(True)
-        query.execute(self.raySceneQueryListener)
-        if self.raySceneQueryListener.dist &lt; 100000:
-            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
-            self.raySceneQueryListener.dist = 100000
-        
-        if so is not None:
-            self.zoneManager.entityUnderMouse = so.entity
-        
-        self.zoneManager.newAreaPosition = pos
-        menus.append(self.zoneManager.getZoneMenu())
-
-        if so is not None and so.entity.getParentNode().getName().startswith(&quot;gameobject_&quot;):
-            actions.append(self.createAction(&quot;Set Player Starterpoint&quot;, self.setPlayerStart))
-            self.playerStartGameObjectId = so.entity.getUserObject().inWorldId
-            
-                
-            
-        if self.onContextMenuCallback is not None:
-            self.onContextMenuCallback(actions,  menus)
-
-    def setContextMenuCallback(self, callback):
-        self.onContextMenuCallback = callback
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
-        action = QAction(text, None)
-        if icon is not None:
-            action.setIcon(QIcon(&quot;media/icons/%s&quot; % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            QWidget.connect(action, SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import sys
+import codecs
+import glob
+import os
+from os.path import isfile,  join
+
+import xml.etree.cElementTree as xml
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from SelectionBuffer import *
+from DepthBuffer import *
+from MovePivot import *
+from GameObjectClassManager import *
+from MyRaySceneQueryListener import *
+from ZoneManager import ZoneManager
+
+
+# get the light out of a light node
+def extractLight(node):
+        i = 0
+        num = node.numAttachedObjects()
+        while i &lt; node.numAttachedObjects():
+            c = node.getAttachedObject(i)
+            tp = str(type(c))
+            if tp == &quot;&lt;class 'ogre.renderer.OGRE._ogre_.Light'&gt;&quot;:
+                return c
+            
+            i += 1
+
+# make the xml file more pretty
+def indent(elem, level=0):
+    i = &quot;\n&quot; + level*&quot;  &quot;
+    
+    if len(elem):
+        if not elem.text or not elem.text.strip():
+            elem.text = i + &quot;  &quot;
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+        for elem in elem:
+            indent(elem, level+1)
+        if not elem.tail or not elem.tail.strip():
+            elem.tail = i
+    else:
+        if level and (not elem.tail or not elem.tail.strip()):
+            elem.tail = i
+
+# creates unique names for new entities
+def createUniqueEntityName(sceneManager, name = None):
+    n = &quot;&quot;
+    if name is None:
+        n = &quot;dropMesh&quot; + str(ModuleManager.dropCount)
+    else:
+        n = name
+        
+    while sceneManager.hasEntity(n):
+        n = &quot;dropMesh&quot; + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+    return n
+        
+def printVector3(vec):
+    print str(vec.x) + &quot;;&quot; + str(vec.y) + &quot;;&quot; + str(vec.z)
+    
+class EntityCustomOptions(og.UserDefinedObject):
+    def __init__(self, receivesShadow = True, staticgeometrygroup = 0, physicsproxytype = &quot;none&quot;, renderingdistance = &quot;20000&quot;):
+        og.UserDefinedObject.__init__(self)
+        self.receivesShadow = receivesShadow
+        self.staticgeometrygroup = staticgeometrygroup
+        self.physicsproxytype = physicsproxytype
+        self.renderingdistance = renderingdistance
+        self.materialName = &quot;NotChanged&quot;
+        
+        ModuleManager.entityCustomOptionsDict.append(self)
+        
+    def copy(self):
+            return EntityCustomOptions(self.receivesShadow, self.staticgeometrygroup, self.physicsproxytype, self.renderingdistance)
+        
+    def getType(self):
+            return &quot;EntityCustomOptions&quot;
+
+class Map():
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyMap = False):
+        self.pathToMapFile = pathToFile
+        
+        mapName = pathToFile.replace(&quot;\\&quot;, &quot;/&quot;)
+        mapName = mapName.split(&quot;/&quot;)
+        mapName = mapName[len(mapName) - 1].split(&quot;.&quot;)
+        mapName = mapName[len(mapName) - 3]
+        self.mapName = mapName
+        self.mapFileName = self.mapName + &quot;.rlmap.xml&quot;
+        
+        self.sceneManager = sceneManager
+        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        self.zoneManager = zoneManager
+        self.isHidden = False
+        
+        self.zoneList = []
+        
+        if not emptyMap:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+
+            if root.attrib[&quot;formatVersion&quot;] == &quot;0.4.0&quot;:
+                self.parseMapNodes(root.find(&quot;nodes&quot;))
+                self.parseMapZones(root.find(&quot;zones&quot;))
+            else:
+                print pathToFile + &quot; has wrong format version. It needs to be 0.4.0&quot;
+                return
+
+    def hide(self):
+        try:
+            self.sceneManager.getRootSceneNode().removeChild(self.mapNode)
+        except:
+            print &quot;Error: map is already hidden!&quot;
+            return
+        
+        self.isHidden = True
+        
+    def show(self):
+        try:
+            self.sceneManager.getRootSceneNode().addChild(self.mapNode)
+        except:
+            print &quot;Error: map is already shown!&quot;
+            return
+        
+        self.isHidden = False
+    
+    def parseMapZones(self, zonesElement):
+        self.zoneManager.parseZonesFromXml(zonesElement, self)
+    
+    def parseMapNodes(self, nodeElement):
+        nodes = nodeElement.getiterator(&quot;gameobject&quot;)
+        self.createGameObjects(nodes)
+        
+        nodes = nodeElement.getiterator(&quot;entity&quot;)
+        self.createEntites(nodes)
+
+        nodes = nodeElement.getiterator(&quot;light&quot;)
+        self.createLights(nodes)
+
+        nodes = nodeElement.getiterator(&quot;sound&quot;)
+        self.createSound(nodes)
+
+        nodes = nodeElement.getiterator(&quot;particlesystem&quot;)
+        self.createParticleSystems(nodes)
+
+    def createEntites(self, entityNodes):
+        for nodes in entityNodes:
+            entityName = nodes.attrib[&quot;name&quot;]
+            
+            if entityName.startswith(&quot;dropMesh&quot;):
+                num = int(entityName.replace(&quot;dropMesh&quot;,  &quot;&quot;))
+                if ModuleManager.dropCount &lt; num:
+                    ModuleManager.dropCount = num
+                elif ModuleManager.dropCount &lt; num:
+                    ModuleManager.dropCount = num + 1
+                    
+            meshFile = nodes.attrib[&quot;meshfile&quot;]
+            
+            eco = EntityCustomOptions()
+            
+            try:
+                if nodes.attrib[&quot;receivesShadow&quot;] == &quot;False&quot; or nodes.attrib[&quot;receivesShadow&quot;] == &quot;false&quot;:
+                    eco.receivesShadow = &quot;False&quot;
+            except:
+                pass
+            try:
+                eco.staticgeometrygroup = int(nodes.attrib[&quot;staticgeometrygroup&quot;])
+            except:
+                pass
+            try:
+                eco.physicsproxy = nodes.attrib[&quot;physicsproxy&quot;]
+            except:
+                pass
+            try:
+                eco.renderingdistance = float(nodes.attrib[&quot;renderingdistance&quot;])
+            except:
+                pass
+            try:
+                eco.renderingdistance
+                nodes.attrib[&quot;materialName&quot;]
+            except:
+                pass
+                
+            nodePosition = None
+            nodeScale = None
+            qw = qx = qy = qz = None
+
+            transformations = nodes.getiterator()
+            for t in transformations:
+                if t.tag == &quot;position&quot;:
+                    posx = float(t.attrib[&quot;x&quot;])
+                    posy = float(t.attrib[&quot;y&quot;])
+                    posz = float(t.attrib[&quot;z&quot;])
+                    nodePosition = og.Vector3(posx, posy, posz)
+                elif t.tag == &quot;rotation&quot;:
+                    qw = float(t.attrib[&quot;qw&quot;])
+                    qx = float(t.attrib[&quot;qx&quot;])
+                    qy = float(t.attrib[&quot;qy&quot;])
+                    qz = float(t.attrib[&quot;qz&quot;])
+                elif t.tag == &quot;scale&quot;:
+                    scalex = float(t.attrib[&quot;x&quot;])
+                    scaley = float(t.attrib[&quot;y&quot;])
+                    scalez = float(t.attrib[&quot;z&quot;])
+                    nodeScale = og.Vector3(scalex, scaley, scalez)
+
+            try:
+                e = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager,  entityName), meshFile)
+            except:
+                print &quot;Warning: Meshfile &quot; + meshFile + &quot; could not be found.&quot;
+                return
+
+            e.setUserObject(eco)
+            n = self.mapNode.createChild(&quot;entity_&quot; + entityName + &quot;_node&quot;)
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            n.setOrientation(qw, qx, qy, qz)
+            n.setScale(nodeScale)
+
+    def createLights(self, lightNodes):
+        for l in lightNodes:
+            lightName = l.attrib[&quot;name&quot;]
+            lightType = l.attrib[&quot;type&quot;]
+            lightVisible = bool(l.attrib[&quot;visible&quot;])
+            castShadows = bool(l.attrib[&quot;castShadows&quot;])
+            lightPosition = None
+            lightDirection = None
+            colourDiffuse = None
+            colourSpecular = None
+            lightAttenuationRange = None
+            lightAttenuationConstant= None
+            lightAttenuationLinear = None
+            lightAttenuationQuadratic = None
+            spotlightinner = None
+            spotlightouter = None
+            falloff = None 
+                
+            transformations = l.getiterator()
+            for t in transformations:
+                if t.tag == &quot;position&quot;:
+                    x = float(t.attrib[&quot;x&quot;])
+                    y = float(t.attrib[&quot;y&quot;])
+                    z = float(t.attrib[&quot;z&quot;])
+                    lightPosition = og.Vector3(x, y, z)
+                elif t.tag == &quot;colourDiffuse&quot;:
+                    r = float(t.attrib[&quot;r&quot;])
+                    g = float(t.attrib[&quot;g&quot;])
+                    b= float(t.attrib[&quot;b&quot;])
+                    colourDiffuse = og.ColourValue(r, g, b)
+                elif t.tag == &quot;colourSpecular&quot;:
+                    r = float(t.attrib[&quot;r&quot;])
+                    g = float(t.attrib[&quot;g&quot;])
+                    b= float(t.attrib[&quot;b&quot;])
+                    colourSpecular = og.ColourValue(r, g, b)
+                elif t.tag == &quot;lightAttenuation&quot;:
+                    lightAttenuationRange = float(t.attrib[&quot;range&quot;])
+                    lightAttenuationConstant= float(t.attrib[&quot;constant&quot;])
+                    lightAttenuationLinear = float(t.attrib[&quot;linear&quot;])
+                    lightAttenuationQuadric  = float(t.attrib[&quot;quadratic&quot;])
+                elif t.tag == &quot;spotlightrange&quot;:
+                    spotlightinner = float(t.attrib[&quot;inner&quot;])
+                    spotlightouter = float(t.attrib[&quot;outer&quot;])
+                    falloff = float(t.attrib[&quot;falloff&quot;])
+                    
+            light = self.sceneManager.createLight(lightName)
+            
+            if lightType == &quot;point&quot;:
+                light.setType(og.Light.LT_POINT)            
+            elif lightType == &quot;spot&quot;:
+                light.setType(og.Light.LT_SPOTLIGHT)
+            elif lightType == &quot;directional&quot;:
+                light.setType(og.Light.LT_DIRECTIONAL)
+            
+            light.setVisible(lightVisible)
+            light.setCastShadows(castShadows)
+            if lightAttenuationRange is not None and lightAttenuationConstant is not None and lightAttenuationLinear is not None and lightAttenuationQuadric is not None:
+                light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadric)
+            if colourDiffuse:
+                light.setDiffuseColour(colourDiffuse)
+            if colourSpecular:
+                light.setSpecularColour(colourSpecular)
+            if spotlightinner and spotlightouter and spotlightouter: 
+                light.setSpotlightRange(spotlightinner, spotlightouter, falloff)
+            
+            e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
+            n = self.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
+            n.attachObject(light)
+            n.attachObject(e)
+            if lightPosition:
+                n.setPosition(lightPosition)
+            
+    def createSound(self, soundNodes):
+        #raise NotImplementedError
+        return
+
+    def createGameObjects(self, gameObjectNodes):
+        for g in gameObjectNodes:
+            classid = g.attrib[&quot;class&quot;]
+            
+            id = int(g.attrib[&quot;id&quot;])
+            if ModuleManager.dropCount &lt; id:
+                ModuleManager.dropCount = id
+            elif ModuleManager.dropCount &lt; id:
+                ModuleManager.dropCount = id + 1
+                
+            state = g.attrib[&quot;state&quot;]
+            nodePosition = None
+            nodeRotation = None
+            properties = {}
+            
+            transformations = g.getiterator()
+            for t in transformations:
+                if t.tag == &quot;position&quot;:
+                    x = float(t.attrib[&quot;x&quot;])
+                    y = float(t.attrib[&quot;y&quot;])
+                    z = float(t.attrib[&quot;z&quot;])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == &quot;rotation&quot;:
+                    qw = float(t.attrib[&quot;qw&quot;])
+                    qx = float(t.attrib[&quot;qx&quot;])
+                    qy = float(t.attrib[&quot;qy&quot;])
+                    qz = float(t.attrib[&quot;qz&quot;])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+                elif t.tag == &quot;property&quot;:
+                    name = t.attrib[&quot;name&quot;]
+                    type = t.attrib[&quot;type&quot;]
+                    data = t.attrib[&quot;data&quot;]
+                    properties[name] = GameObjectRepresentation.PropertieRepresentation(name, type, data)
+
+            go = self.gocManager.getGameObjectWithClassId(classid)
+            if go is not None:
+                meshFile = go.getMeshFileName()
+                
+                ent = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+                dropNode = self.mapNode.createChild(&quot;gameobject_&quot; + &quot;dropNode&quot; + str(id))
+                dropNode.attachObject(ent)
+
+                if nodePosition:
+                    dropNode.setPosition(nodePosition)
+                if nodeRotation:
+                    dropNode.setOrientation(nodeRotation)
+
+                go = GameObjectRepresentation(id, classid, dropNode, meshFile)
+                self.gocManager.addGameObjectRepresentation(go)
+                go.inWorldId = id
+                go.state = state
+                go.propertieDict = properties
+                ent.setUserObject(go)
+
+
+    def createParticleSystems(self, particleNodes):
+        #raise NotImplementedError
+        return
+        
+    def save(self):
+        root = xml.Element(&quot;rastullahmap&quot;)
+        root.attrib[&quot;formatVersion&quot;] = &quot;0.4.0&quot;
+        
+        nodesElem = xml.SubElement(root, &quot;nodes&quot;)
+        
+        i = 0
+        while i &lt; self.mapNode.numChildren():
+            n = self.mapNode.getChild(i)
+            if n.numAttachedObjects() &gt; 0:
+                if n.name.startswith(&quot;entity_&quot;):
+                    entElem = xml.SubElement(nodesElem, &quot;entity&quot;)
+                    entElem.attrib[&quot;name&quot;] = n.getAttachedObject(0).getName()
+                    entName = n.getAttachedObject(0).getName()
+                    #print &quot;Saving Entity: &quot; + n.getAttachedObject(0).getName()
+                    entElem.attrib[&quot;meshfile&quot;] = n.getAttachedObject(0).getMesh().getName()
+   
+                    entElem.attrib[&quot;receivesShadow&quot;] = str(n.getAttachedObject(0).getUserObject().receivesShadow).lower()
+                    entElem.attrib[&quot;staticgeometrygroup&quot;] = str(n.getAttachedObject(0).getUserObject().staticgeometrygroup)
+                    entElem.attrib[&quot;physicsproxytype&quot;] = str(n.getAttachedObject(0).getUserObject().physicsproxytype)
+                    entElem.attrib[&quot;renderingdistance&quot;] = str(n.getAttachedObject(0).getUserObject().renderingdistance)
+                    
+                    posElem = xml.SubElement(entElem, &quot;position&quot;)
+                    posElem.attrib[&quot;x&quot;] = str(n.getPosition().x)
+                    posElem.attrib[&quot;y&quot;] = str(n.getPosition().y)
+                    posElem.attrib[&quot;z&quot;] = str(n.getPosition().z)
+                    
+                    rotElem = xml.SubElement(entElem, &quot;rotation&quot;)
+                    rotElem.attrib[&quot;qw&quot;] = str(n.getOrientation().w)
+                    rotElem.attrib[&quot;qx&quot;] = str(n.getOrientation().x)
+                    rotElem.attrib[&quot;qy&quot;] = str(n.getOrientation().y)
+                    rotElem.attrib[&quot;qz&quot;] = str(n.getOrientation().z)
+                    
+                    scaleElem = xml.SubElement(entElem, &quot;scale&quot;)
+                    scaleElem.attrib[&quot;x&quot;] = str(n.getScale().x)
+                    scaleElem.attrib[&quot;y&quot;] = str(n.getScale().y)
+                    scaleElem.attrib[&quot;z&quot;] = str(n.getScale().z)
+                    
+                elif n.name.startswith(&quot;gameobject_&quot;):
+                    goElem = xml.SubElement(nodesElem, &quot;gameobject&quot;)
+                    mname = n.name
+                    #print &quot;Saving GOID: &quot; + str(n.getAttachedObject(0).getUserObject().inWorldId)
+                    goElem.attrib[&quot;class&quot;] = str(n.getAttachedObject(0).getUserObject().gocName)
+                    goElem.attrib[&quot;state&quot;] = str(n.getAttachedObject(0).getUserObject().state)
+                    goElem.attrib[&quot;id&quot;] = str(n.getAttachedObject(0).getUserObject().inWorldId)
+                    
+                    posElem = xml.SubElement(goElem, &quot;position&quot;)
+                    posElem.attrib[&quot;x&quot;] = str(n.getPosition().x)
+                    posElem.attrib[&quot;y&quot;] = str(n.getPosition().y)
+                    posElem.attrib[&quot;z&quot;] = str(n.getPosition().z)
+                    
+                    rotElem = xml.SubElement(goElem, &quot;rotation&quot;)
+                    rotElem.attrib[&quot;qw&quot;] = str(n.getOrientation().w)
+                    rotElem.attrib[&quot;qx&quot;] = str(n.getOrientation().x)
+                    rotElem.attrib[&quot;qy&quot;] = str(n.getOrientation().y)
+                    rotElem.attrib[&quot;qz&quot;] = str(n.getOrientation().z)
+                    
+                    dict = n.getAttachedObject(0).getUserObject().propertieDict
+                    for key in dict:
+                        prop = dict[key]
+                        rotElem = xml.SubElement(goElem, &quot;property&quot;)
+                        rotElem.attrib[&quot;name&quot;] = prop.name
+                        rotElem.attrib[&quot;type&quot;] = prop.type
+                        rotElem.attrib[&quot;data&quot;] = prop.data
+
+                    
+                elif n.name.startswith(&quot;light_&quot;):
+                    light = extractLight(n)
+                    lightName = light.getName()
+                    #print &quot;Saving Light: &quot; + lightName
+                    lightType = light.getType()
+                    isVisible = &quot;true&quot;
+                    if not light.getVisible():
+                        isVisible = &quot;false&quot;
+                    
+                    castShadows = &quot;false&quot;
+                    if light.getCastShadows():
+                        castShadows = &quot;true&quot;
+                    
+                    if lightType == og.Light.LT_POINT:
+                        lightType = &quot;point&quot;
+                    elif lightType == og.Light.LT_SPOTLIGHT:
+                        lightType = &quot;spot&quot;
+                    elif lightType == og.Light.LT_DIRECTIONAL:
+                        lightType = &quot;directional&quot;
+                    
+                    
+                    lightElem = xml.SubElement(nodesElem, &quot;light&quot;)
+                    lightElem.attrib[&quot;name&quot;] = lightName
+                    lightElem.attrib[&quot;type&quot;] = lightType
+                    lightElem.attrib[&quot;visible&quot;] = isVisible
+                    lightElem.attrib[&quot;castShadows&quot;] = castShadows
+                    
+                    if lightType == &quot;point&quot; or lightType == &quot;spot&quot;:
+                        posElem = xml.SubElement(lightElem, &quot;position&quot;)
+                        posElem.attrib[&quot;x&quot;] = str(n.getPosition().x)
+                        posElem.attrib[&quot;y&quot;] = str(n.getPosition().y)
+                        posElem.attrib[&quot;z&quot;] = str(n.getPosition().z)
+                    
+                    colDiffuseElem = xml.SubElement(lightElem, &quot;colourDiffuse&quot;)
+                    colDiffuseElem.attrib[&quot;r&quot;] = str(light.getDiffuseColour().r)
+                    colDiffuseElem.attrib[&quot;g&quot;] = str(light.getDiffuseColour().g)
+                    colDiffuseElem.attrib[&quot;b&quot;] = str(light.getDiffuseColour().b)
+
+                    colSpecularElem = xml.SubElement(lightElem, &quot;colourSpecular&quot;)
+                    colSpecularElem.attrib[&quot;r&quot;] = str(light.getSpecularColour().r)
+                    colSpecularElem.attrib[&quot;g&quot;] = str(light.getSpecularColour().g)
+                    colSpecularElem.attrib[&quot;b&quot;] = str(light.getSpecularColour().b)
+                    
+                    lightAttenuationElem = xml.SubElement(lightElem, &quot;lightAttenuation&quot;)
+                    lightAttenuationElem.attrib[&quot;range&quot;] = str(light.getAttenuationRange())
+                    lightAttenuationElem.attrib[&quot;constant&quot;] = str(light.getAttenuationConstant())
+                    lightAttenuationElem.attrib[&quot;linear&quot;] = str(light.getAttenuationLinear())
+                    lightAttenuationElem.attrib[&quot;quadratic&quot;] = str(light.getAttenuationQuadric())
+                    
+                    if lightType == &quot;spot&quot;:
+                        spotligthRangeElem = xml.SubElement(lightElem, &quot;spotlightrange&quot;)
+                        spotligthRangeElem.attrib[&quot;inner&quot;] = str(light.getSpotlightInnerAngle().valueDegrees())
+                        spotligthRangeElem.attrib[&quot;outer&quot;] = str(light.getSpotlightOuterAngle().valueDegrees())
+                        spotligthRangeElem.attrib[&quot;falloff&quot;] = str(light.getSpotlightFalloff())
+                        
+                    if lightType == &quot;spot&quot; or lightType == &quot;directional&quot;:
+                        directionElem = xml.SubElement(lightElem, &quot;direction&quot;)
+                        dir = og.Vector3()
+                        n.getOrientation().ToAxes(dir)
+                        directionElem.attrib[&quot;x&quot;] = str(dir.x)
+                        directionElem.attrib[&quot;y&quot;] = str(dir.y)
+                        directionElem.attrib[&quot;z&quot;] = str(dir.z)
+                        
+            i = i+1
+            
+        self.zoneManager.saveZonesToXml(root, self)
+        indent(root)
+        xml.ElementTree(root).write(self.pathToMapFile)
+
+# caused a linux crash
+#        iter = self.mapNode.getChildIterator()
+#        while iter.hasMoreElements():
+#            name = iter.getNext().getName()
+#            print name
+
+class Scene():
+    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyScene = False, sceneName = &quot;NewScene&quot;):
+        self.moduleRoot = moduleroot
+        self.pathToFile = pathToFile
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gocManager
+        self.zoneManager = zoneManager
+        self.mapFiles = [] # a list in case the module has more than one map file
+        mappaths = []
+        self.name = sceneName
+
+        
+        if not emptyScene:
+            xmlTree = xml.parse(pathToFile)
+            root = xmlTree.getroot()
+            self.name = root.attrib[&quot;name&quot;]
+        
+            maps = root.getiterator(&quot;map&quot;)
+            for m in maps:
+                mappaths.append(join(self.moduleRoot, join(&quot;maps&quot;, m.attrib[&quot;file&quot;])))
+                
+            for m in mappaths:
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
+            
+    def addMap(self, name):
+        path = join(self.moduleRoot, join(&quot;maps&quot;, name + &quot;.rlmap.xml&quot;))
+        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True))
+        
+    def save(self):
+        root = xml.Element(&quot;scene&quot;)
+        root.attrib[&quot;name&quot;] = self.name
+        
+        for m in self.mapFiles:
+            sub = xml.SubElement(root, &quot;map&quot;)
+            sub.attrib[&quot;file&quot;] = m.mapFileName
+            m.save()
+
+        indent(root)
+        xml.ElementTree(root).write(self.pathToFile)
+
+class Module():
+    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager, zoneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.gocManager = gameObjectManager
+        self.zoneManager = zoneManager
+        
+        self.name = name
+        self.moduleRoot = join(modulePath, name)
+        self.__isCommon = False
+
+        self.hasDependencies = False
+        self.moduleDependencies = []
+
+        self.modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
+
+        self.gofFiles = [] # gof File list
+
+        self.scenes =[]
+
+        self.isLoaded = False
+        
+        self.playerStart = None
+        
+    def addScene(self, name):
+        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, (&quot;maps/&quot; + name + &quot;.rlscene&quot;)), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True, name))
+    
+    def addMapToScene(self, sceneName, mapName):
+        for scene in self.scenes:
+            if scene.name == sceneName:
+                scene.addMap(mapName)
+                return
+        
+        print &quot;ERROR: could not find scene: &quot; + sceneName
+        
+    
+    def isCommon(self):
+        if isfile(self.modConfig): # is the modconfig existing?
+            f = codecs.open(self.modConfig, 'r', 'utf-8')
+        else:
+            print (&quot;Module.isCommon() Error: couldn't find module config&quot;)
+            return
+        isDependencieLine = False
+        for i, line in enumerate(f):
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith(&quot;super(&quot;):
+                split = lStripped.split(&quot;,&quot;)
+                if split[2].strip() == unicode(&quot;true&quot;):
+                    self.__isCommon = True
+                    return True
+
+
+            elif isDependencieLine:
+                if lStripped == &quot;end&quot;:
+                    isDependencieLine = False
+                else:
+                    self.hasDependencies = True
+                    pl = lStripped.split('&quot;')
+                    i = 1
+                    while i &lt; 100: 
+                        try:
+                            self.moduleDependencies.append(pl[i])
+                            i += 2
+                        except IndexError, e:
+                            break
+
+            elif lStripped == &quot;def getDependencies()&quot;:
+                isDependencieLine = True
+
+        return False
+
+    def load(self):
+        if self.isLoaded:
+            return
+        
+        self.isLoaded = True
+        self.modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
+        if isfile(self.modConfig): # is the modconfig existing?
+            f = codecs.open(self.modConfig, 'r', 'utf-8')
+        else:
+            print (&quot;Module.load: Error: couldn't find module config&quot;)
+            return
+
+        for line in f:
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith(&quot;hero = $GOM.getGameObject(&quot;):
+                try:
+                    self.playerStart = int(line.split(&quot;(&quot;)[1].split(&quot;)&quot;)[0])
+                except ValueError, e:
+                    print self.modConfig + &quot; ValueError: &quot; + str(e)
+                    self.playerStart = None
+                    continue
+                    
+        self.setResourcePaths()
+        
+        try:
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+        except og.OgreException, e:
+            print e
+        
+        
+        cmd = join(self.moduleRoot, &quot;dsa/*.gof&quot;)
+        self.gofFiles = glob.glob(cmd)
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
+        if not self.isCommon():
+            cmd = join(self.moduleRoot, &quot;maps/*.rlscene&quot;)
+            sceneFile = glob.glob(cmd)
+            self.loadScenes(sceneFile)
+                
+    def loadScenes(self, sceneFiles):
+        for s in sceneFiles:
+            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
+
+    def save(self):
+        for s in self.scenes:
+            s.save()
+            
+        self.saveModuleConfig()
+
+    def saveModuleConfig(self):
+        if self.playerStart is not None:
+            f = open(self.modConfig, &quot;r&quot;)
+            
+            newconfig = &quot;&quot;
+            for line in f:
+                if line.startswith(&quot;       hero = $GOM.getGameObject(&quot;):
+                    newconfig += &quot;       hero = $GOM.getGameObject(&quot; + str(self.playerStart) + &quot;);\n&quot;
+                else:
+                    newconfig += line
+            f.close()
+            
+            f = open(self.modConfig, &quot;w&quot;)
+            f.write(newconfig)
+            f.close()
+
+    def setResourcePaths(self, recurseFolder = &quot;&quot;):
+        if recurseFolder == &quot;&quot;:
+            rootFolder = self.moduleRoot
+        else:
+            rootFolder = join(self.moduleRoot, recurseFolder)
+
+        for file in os.listdir(rootFolder):
+            curFile = join(rootFolder, file)
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            elif os.path.isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, &quot;FileSystem&quot;, self.name, False)
+                self.setResourcePaths(curFile)
+            elif os.path.isfile(curFile):
+                continue
+                
+    def getMap(self, mapName, sceneName = None):
+        if sceneName is not None:
+            for s in self.scenes:
+                if s.name == sceneName:
+                    for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+        else:
+            for s in self.scenes:
+                for m in s.mapFiles:
+                        if m.mapName == mapName:
+                            return m
+
+class ProgressBarThread(QThread):
+    def __init__(self, min, max, moduleName):
+        QThread.__init__(self)
+        self.progress = QProgressDialog(&quot;Loading &quot; + moduleName, &quot;Abort Loading&quot;, min, max, None);
+        self.progress.setWindowModality(Qt.WindowModal)
+
+    def setProgress(self, progress, labelText):
+        self.progress.setLabelText(labelText)
+        self.progress.setValue(progress)
+        
+    def run(self):
+        self.progress.show()
+        self.exec_()
+
+        
+class ModuleManager():
+    dropCount = 0
+    entityCustomOptionsDict = []
+    
+    def __init__(self,  ogreRoot,  sceneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.modelSelectionDialog = None
+        self.materialSelectionDialog = None
+
+        self.moduleCfgPath = &quot;&quot;
+
+        self.gocManager = GameObjectClassManager()
+        
+
+        self.mainModule = None
+        self.mainModuledependencieList =[]
+        self.moduleList = []
+        self.userSelectionList = []
+        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
+        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
+        self.currentMap = None
+        self.moduleExplorer = None
+
+        self.lastRay = None
+        self.rayLine = None
+
+        # pivot is initialzed and set in the Lockenwickler.setUpOgre function
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.dropNode = None
+        self.dropEntity = None
+        self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
+        self.dropMat = None
+        
+        self.moduleConfigIsParsed = False
+
+        self.selectionBuffer = None
+        self.depthBuffer = None
+        self.propertyWindow = None
+    
+        self.oneClickEntityPlacement = False
+        
+        self.onContextMenuCallback = None
+        self.contextMenuClickPosition = None
+        self.contextMenuRay = None
+        
+        self.playerStartGameObjectId = None
+        
+        self.entityCustomOptionsDict = []
+        
+        self.raySceneQueryListener = MyRaySceneQueryListener()
+        
+        self.zoneManager = ZoneManager(self.sceneManager)
+        
+    def resetParsedModuleConfig(self):
+        self.moduleConfigIsParsed = False
+        self.moduleList = []
+
+    def parseModuleConfig(self):
+        if self.moduleConfigIsParsed:
+            return
+
+        import codecs
+        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
+
+        for line in f:
+            if line.startswith('#'):
+                continue
+
+            if line.startswith('module='):
+                splines = line.split('=')
+                str = splines[1].rstrip().rstrip()
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace(&quot;/modules.cfg&quot;,  &quot;&quot;), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
+
+        self.moduleConfigIsParsed = True
+
+    def moduleExists(self, name):
+        lowerA = str(name).lower()
+        
+        for m in self.moduleList:
+            lowerB = m.name.lower()
+            if lowerA == lowerB:
+                return True
+        
+        return False
+
+    def openLoadModuleDialog(self):
+        self.moduleFolder = str(self.moduleCfgPath.replace(&quot;modules.cfg&quot;, &quot;&quot;))
+
+        self.parseModuleConfig()
+
+        dlg = QDialog(QApplication.focusWidget())
+        list = QListWidget()
+        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        dlg.connect(btnBox, SIGNAL(&quot;accepted()&quot;), dlg.accept)
+        dlg.connect(btnBox, SIGNAL(&quot;rejected()&quot;), dlg.reject)
+
+        for m in self.moduleList:
+            if not m.isCommon():
+                list.addItem(m.name)
+
+        layout = QVBoxLayout()
+        layout.addWidget(list)
+        layout.addWidget(btnBox)
+        dlg.setLayout(layout)
+        if dlg.exec_():
+            self.loadModule(str(list.currentItem().text()))
+
+    # I'm sorry for this
+    def loadModule(self, moduleName):
+        t = og.Timer()
+        
+#        self.progress = ProgressBarThread(0, 8, moduleName)
+#        self.progress.start()
+        
+        for m in self.moduleList:
+            if m.name == moduleName:
+                if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
+                    for moduleDependencie in m.moduleDependencies:
+                        for m2 in self.moduleList:
+                            if m2.name == moduleDependencie:
+#                                self.progress.setProgress(2, &quot;Loading Dependencie: &quot; + moduleDependencie)
+                                m2.load()
+                                self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
+                                self.materialSelectionDialog.scanDirForMaterials(m2.moduleRoot)
+                                self.mainModuledependencieList.append(m2)
+
+#                self.progress.setProgress(4, &quot;Loading &quot; + moduleName)
+                m.load()
+#                self.progress.setProgress(6, &quot;Scan for models...&quot;)
+                self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
+#                self.progress.setProgress(8, &quot;Scan for materials&quot;)
+                self.materialSelectionDialog.scanDirForMaterials(m.moduleRoot)
+                self.mainModule = m
+                self.moduleExplorer.setCurrentModule(m)
+
+        if self.selectionBuffer is None:
+            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget(&quot;OgreMainWin&quot;), self, self.zoneManager)
+
+#        if self.depthBuffer is None:
+#            self.depthBuffer = DepthBuffer(self.sceneManager, self.ogreRoot.getRenderTarget(&quot;OgreMainWin&quot;))
+
+
+#        self.progress.quit()
+        print &quot;Time to load module: &quot; + str(t.getMilliseconds() / 1000.0) + &quot; seconds&quot;
+        del t
+
+    def addSceneToModule(self, name):
+        if self.mainModule is not None:
+            self.mainModule.addScene(name)
+
+    def addMapToScene(self, sceneName, mapName):
+        if self.mainModule is not None:
+            self.mainModule.addMapToScene(sceneName, mapName)
+
+    def setModuleExplorer(self, moduleExplorer):
+        self.moduleExplorer = moduleExplorer
+        self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
+        self.moduleExplorer.setSelectionChangedCallback(self.selectionChangedCallback)
+        self.moduleExplorer.setModuleManager(self)
+    
+    def setPropertyWindow(self, propertyWin):
+        self.propertyWindow = propertyWin
+    
+    def selectionChangedCallback(self, items):
+        self.resetSelection()
+        self.userSelectionList = self.selectionBuffer.manualSelectObjects(items)
+        
+        print len(self.userSelectionList)
+        
+        if len(self.userSelectionList) &gt; 1:
+            self.propertyWindow.clear()
+        elif len(self.userSelectionList) &gt; 0 and len(self.userSelectionList) &lt; 2:
+            self.propertyWindow.showProperties(self.userSelectionList[0])
+        else:
+            return
+            
+        self.updatePivots()
+        
+    def selectMapCallback(self, sceneName, mapName):
+        self.currentMap = self.mainModule.getMap(mapName, sceneName)
+        self.zoneManager.currentMap = self.currentMap
+        if self.currentMap is None:
+            print &quot;Don't forget to select a map&quot;
+
+        
+    # called when a click into Main Ogre Window occurs
+    def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
+        if self.oneClickEntityPlacement:
+            if self.modelSelectionDialog.listWidget.currentItem() is not None:
+                meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
+                self.startDropModelAction(meshFile, ray)
+                self.moduleExplorer.updateView()
+                return
+            else:
+                print &quot;Warning: OneClickEntityPlacement still runing on without any selected mesh!&quot;
+                return
+                
+        #self.depthBuffer.onSelectionClick(screenX, screenY)
+        
+        so = None
+        if self.selectionBuffer is not None:
+            so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        
+        if so is not None:
+            if not so.isPivot:                
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.propertyWindow.showProperties(so)
+                    self.moduleExplorer.deselectAll()
+                    self.moduleExplorer.selectItem(so, True)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+
+                    for soFromList in self.userSelectionList:
+                        if soFromList == so:
+                            return # object already selected
+
+                    self.userSelectionList.append(so)
+                    self.propertyWindow.showProperties(so)
+                    self.moduleExplorer.selectItem(so, True)
+                    self.updatePivots()
+
+
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so == selo:
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                            self.moduleExplorer.selectItem(selo, False)
+                    self.updatePivots()
+                
+            else:
+                #so.entity is the pivot direction that was clicked
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            self.resetSelection() # click in empty space, deselect everything
+            self.moduleExplorer.selectItems(None)
+            self.propertyWindow.clear()
+            if self.pivot is not None:
+                self.pivot.hide()
+
+#        if self.rayLine == None:
+#            self.rayLine = self.sceneManager.createManualObject(&quot;rayLine&quot;)
+#            self.rayLine.setDynamic(True)
+#            self.sceneManager.getRootSceneNode().createChildSceneNode(&quot;raynode&quot;).attachObject(self.rayLine)
+#
+#            self.rayLine.begin(&quot;BaseWhiteNoLighting&quot;, og.RenderOperation.OT_LINE_STRIP)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+#
+#        else:
+#            self.rayLine.beginUpdate(0)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+
+    def deleteObjects(self):
+        if len(self.userSelectionList) &lt; 1:
+            return
+
+        self.pivot.hide()
+
+        for so in self.userSelectionList:
+            node = so.entity.getParentNode()
+            if node.getName().startswith(&quot;area_&quot;):
+                self.zoneManager.deleteArea(so.entity.getUserObject())
+                continue
+            elif node.getName().startswith(&quot;light_&quot;):
+                light = extractLight(node)
+                self.sceneManager.destroyLight(light)
+                
+            node.detachAllObjects()
+            self.sceneManager.destroySceneNode(node)
+            self.sceneManager.destroyEntity(so.entity)
+            del so
+        
+        self.userSelectionList = []
+        self.moduleExplorer.updateView()
+        
+    def copyObjects(self):
+        if len(self.userSelectionList) &lt; 1 or self.currentMap is None:
+            print &quot;Warning: No map selected!&quot;
+            return
+
+        self.newSelectionList = []
+
+        for so in self.userSelectionList:
+            if so.entity.getUserObject() is not None:
+                if str(so.entity.getParentNode().getName()).startswith(&quot;gameobject_&quot;):
+                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
+                    meshFile = go.getMeshFileName()
+
+                    if go is not None:
+                        newEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+                        newNode = self.currentMap.mapNode.createChild(&quot;gameobject_dropNode&quot; + str(ModuleManager.dropCount))
+                        newNode.attachObject(newEntity)
+                        newNode.setPosition(so.entity.getParentNode().getPosition())
+
+                        newGO = GameObjectRepresentation(ModuleManager.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
+                        self.gocManager.addGameObjectRepresentation(newGO)
+                        newEntity.setUserObject(newGO)
+
+                        newSO = SelectionObject(newEntity)
+                        newSO.setSelected(True)
+                        self.newSelectionList.append(newSO)
+                        ModuleManager.dropCount += 1
+                elif str(so.entity.getParentNode().getName()).startswith(&quot;entity_&quot;):
+                    nodeName = &quot;entity_dropNode&quot; + str(ModuleManager.dropCount)
+                    newNode = self.currentMap.mapNode.createChild(nodeName)
+
+                    entityName = createUniqueEntityName(self.sceneManager)
+                    newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+
+                    eco = so.entity.getUserObject().copy()
+                    newEntity.setUserObject(eco)
+
+                    newNode.attachObject(newEntity)
+                    newNode.setPosition(so.entity.getParentNode().getPosition())
+                    newNode.setOrientation(so.entity.getParentNode().getOrientation())
+                    newNode.setScale(so.entity.getParentNode().getScale())
+
+                    newSO = SelectionObject(newEntity)
+                    newSO.setSelected(True)
+                    self.newSelectionList.append(newSO)
+                    ModuleManager.dropCount += 1
+                elif str(so.entity.getParentNode().getName()).startswith(&quot;light_&quot;):
+                    print &quot;Can't copy lights yet :)&quot;
+
+        self.resetSelection()
+        self.userSelectionList = self.newSelectionList
+        self.moduleExplorer.updateView()
+        for so in self.userSelectionList:
+            self.moduleExplorer.selectItem(so, True)
+        self.updatePivots()
+
+        
+    def cutObjects(self):
+        if len(self.userSelectionList) &lt; 1:
+            return
+
+        self.cutList = []
+        for so in self.userSelectionList:
+            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
+            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
+            # set the &quot;point of gravity&quot; of all the cutted nodes to world origin at 0,0,0
+            # so we only have to translate them to their new destination when they get pasted
+            # the position of the pivot point is considered as the center of gravity
+            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
+            self.cutList.append(so)
+        self.resetSelection()
+        self.moduleExplorer.updateView()
+        
+    def pasteObjects(self,  ray):
+        if len(self.cutList) &lt; 1:
+            return
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            i=0
+            while i &lt; len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
+                i = i+1
+        else:
+            i=0
+            while i &lt; len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
+                i = i+1
+        self.cutList = []
+        self.moduleExplorer.updateView()
+        
+    def leftMouseUp(self):
+        if self.pivot is not None and self.pivot.isTransforming:
+            self.propertyWindow.updateProperties()
+            self.pivot.stopTransforming()
+
+    def resetSelection(self):
+        if self.userSelectionList is not None:
+            for so in self.userSelectionList:
+                so.setSelected(False)
+
+        self.userSelectionList = []
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+        if self.pivot is not None and len(self.userSelectionList) &gt; 0:
+            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
+    def unload(self,  saveOnUnload=True):
+        pass
+
+    def save(self):
+        self.mainModule.save()
+
+    def startDropGameObjectAction(self, classid, ray):
+        if self.currentMap is None:
+            print &quot;No map selected!&quot;
+            return
+            
+        go = self.gocManager.getGameObjectWithClassId(classid)
+
+        if go is not None:
+            meshFile = go.getMeshFileName()
+            dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+            dropNode = self.currentMap.mapNode.createChild(&quot;gameobject_dropNode&quot; + str(ModuleManager.dropCount))
+            dropNode.attachObject(dropEntity)
+
+            result = og.Math.intersects(ray, self.dropCollisionPlane)
+            if result.first == True:
+                dropNode.setPosition(ray.getPoint(result.second))
+            else:
+                dropNode.setPosition(ray.getPoint(50))
+
+            self.dropGO = GameObjectRepresentation(ModuleManager.dropCount, classid, dropNode, meshFile)
+            self.gocManager.addGameObjectRepresentation(self.dropGO)
+            dropEntity.setUserObject(self.dropGO)
+
+        ModuleManager.dropCount += 1
+
+    def moveDropGameObjectAction(self, ray):
+        if self.currentMap is None:
+            return
+        
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropGO.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropGO.setPosition(ray.getPoint(50))
+
+    def finishDropGameObjectAction(self, ray):
+        self.moduleExplorer.updateView()
+        self.dropGO = None
+        return
+
+    def startDropModelAction(self, meshFile, ray):
+        if self.currentMap is None:
+            print &quot;No map selected!&quot;
+            return
+            
+        self.dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), meshFile)
+        
+        eco = EntityCustomOptions()
+        self.dropEntity.setUserObject(eco)
+        
+        self.dropNode = self.currentMap.mapNode.createChild(&quot;entity_dropNode&quot; + str(ModuleManager.dropCount))
+        self.dropNode.attachObject(self.dropEntity)
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+        ModuleManager.dropCount += 1
+
+    def moveDropModelAction(self, ray):
+        if self.currentMap is None:
+            return
+            
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+    
+    def finishDropModelAction(self, ray):
+        self.moduleExplorer.updateView()
+        return
+
+    def startDropMaterialAction(self, text):
+        self.dropMat = text
+        
+    def moveDropMaterialAction(self, event):
+        return
+
+    def finishDropMaterialAction(self, screenX, screenY):
+        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        if so is not None:
+            if not so.entity.getNumSubEntities() &gt; 1:
+                so.entity.setMaterialName(self.dropMat)
+                so.entity.getUserObject().materialName = self.dropMat
+            else:
+                i = 0
+                text = &quot;Warning this Entity has more than one SubEntities with the folloing materials: \n\n&quot;
+                while i &lt; so.entity.getNumSubEntities():
+                    text += &quot;SubMesh&quot; + str(i) + &quot;:  &quot; + so.entity.getSubEntity(i).getMaterialName() + &quot;\n&quot;
+                    i += 1
+                
+                text += &quot;\n Replace the materials?&quot;
+                reply = QMessageBox.question(None, &quot;Warning: multiple materials&quot;,  text,  QMessageBox.Yes|QMessageBox.No)
+                if reply == QMessageBox.Cancel:
+                    return
+                if reply == QMessageBox.Yes:
+                    so.entity.setMaterialName(self.dropMat)
+                    so.entity.getUserObject().materialName = self.dropMat
+        
+    def setOneClickEntityPlacement(self, state):
+        self.oneClickEntityPlacement = state
+    
+    def createLight(self, name):
+        pos = og.Vector3()
+        
+        query = self.sceneManager.createRayQuery(self.contextMenuRay)
+        query.ray = self.contextMenuRay
+        query.setSortByDistance(True)
+        query.execute(self.raySceneQueryListener)
+        if self.raySceneQueryListener.dist &lt; 100000:
+            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
+            self.raySceneQueryListener.dist = 100000
+            
+        light = None
+        if not self.sceneManager.hasLight(name):
+            light = self.sceneManager.createLight(name)
+            
+        return light,  pos
+        
+    def addPointLight(self):
+        if self.currentMap is None:
+            print &quot;No map selected!&quot;
+            return
+            
+        lightName = &quot;pointLight&quot; + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+        light, pos = self.createLight(lightName)
+        printVector3(pos)
+        
+        if not light:
+            print &quot;Error while creating light&quot;
+            return
+            
+        light.setType(og.Light.LT_POINT)
+        
+        e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
+        n = self.currentMap.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
+        n.attachObject(light)
+        n.attachObject(e)
+        n.setPosition(pos)
+        self.moduleExplorer.updateView()
+        
+    def addSpotLight(self):
+        if self.currentMap is None:
+            print &quot;No map selected!&quot;
+            return
+            
+        lightName = &quot;spotLight&quot; + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+        light, pos = self.createLight(lightName)
+        printVector3(pos)
+        
+        if not light:
+            print &quot;Error while creating light&quot;
+            return
+            
+        light.setType(og.Light.LT_SPOTLIGHT)
+        
+        e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
+        n = self.currentMap.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
+        n.attachObject(light)
+        n.attachObject(e)
+        n.setPosition(pos)
+        self.moduleExplorer.updateView()
+        
+    def addZoneToMap(self, name):
+        self.zoneManager.createZone(name)
+        self.moduleExplorer.updateView()
+        
+    def setPlayerStart(self):
+        self.mainModule.playerStart = str(self.playerStartGameObjectId)
+        print &quot;setting Player Start to &quot; + str(self.playerStartGameObjectId)
+    
+    def onContextMenu(self, screenX, screenY, ray):
+        menus = []
+        actions = []
+        pla = self.createAction(&quot;Pointlight&quot;, self.addPointLight, None, &quot;idea.png&quot;)
+        pls = self.createAction(&quot;Spotlight&quot;, self.addSpotLight, None, &quot;idea.png&quot;)
+        
+        lightMenu = QMenu(&quot;Add Light&quot;)
+        lightMenu.addAction(pla)
+        lightMenu.addAction(pls)
+        menus.append(lightMenu)
+        
+        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        self.contextMenuClickPosition = og.Vector2(screenX, screenY)
+        self.contextMenuRay = ray
+        
+        pos = og.Vector3()
+        query = self.sceneManager.createRayQuery(self.contextMenuRay)
+        query.ray = self.contextMenuRay
+        query.setSortByDistance(True)
+        query.execute(self.raySceneQueryListener)
+        if self.raySceneQueryListener.dist &lt; 100000:
+            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
+            self.raySceneQueryListener.dist = 100000
+        
+        if so is not None:
+            self.zoneManager.entityUnderMouse = so.entity
+        
+        self.zoneManager.newAreaPosition = pos
+        menus.append(self.zoneManager.getZoneMenu())
+
+        if so is not None and so.entity.getParentNode().getName().startswith(&quot;gameobject_&quot;):
+            actions.append(self.createAction(&quot;Set Player Starterpoint&quot;, self.setPlayerStart))
+            actions.append(self.createAction(&quot;Add Property&quot;, so.entity.getUserObject().addProperty))
+            self.playerStartGameObjectId = so.entity.getUserObject().inWorldId
+            
+                
+            
+        if self.onContextMenuCallback is not None:
+            self.onContextMenuCallback(actions,  menus)
+
+    def setContextMenuCallback(self, callback):
+        self.onContextMenuCallback = callback
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
+        action = QAction(text, None)
+        if icon is not None:
+            action.setIcon(QIcon(&quot;media/icons/%s&quot; % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            QWidget.connect(action, SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-04-11 10:34:44 UTC (rev 4893)
@@ -22,6 +22,7 @@
 
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *
+from GOGenericEditor import *
 
 import ogre.renderer.OGRE as og
 
@@ -113,9 +114,9 @@
     def getValue(self):
         return str(self.combo.currentText())
     
-class ObjectPropertyWin(QDialog):
+class ObjectPropertyWin(QWidget):
     def __init__(self, sceneManager, gocManager, parent=None):
-        super(QDialog, self).__init__(parent)
+        super(QWidget, self).__init__(parent)
         self.setupUi()
         self.sceneManager = sceneManager
         self.valueBeforeEdit = None
@@ -199,7 +200,7 @@
     def onItemChanged(self, item, column):
         if self.valueBeforeEdit is not None and self.valueBeforeEdit != item.text(column):
             parent = item.parent()
-            if parent is None: # handle properties that don't expand here (pos, rot, scale etc)
+            if parent is None: # handle properties that don't expand here
                 if item.text(0) == &quot;Name&quot;:
                     if self.node.getName().startswith(&quot;entity_&quot;):
                         if not self.sceneManager.hasEntity(str(item.text(column))):
@@ -274,6 +275,51 @@
                     
                     self.node.getAttachedObject(0).getUserObject().renderingdistance = val
             else:
+                parentOfParent = parent.parent() 
+                if parentOfParent is not None and str(parentOfParent.text(0)).startswith(&quot;Properties&quot;):
+                    propertiesDict = self.node.getAttachedObject(0).getUserObject().propertieDict
+                    prop = propertiesDict[str(parent.text(1))]
+                    self.disconnect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;), self.onItemChanged)
+                    
+                    if item.text(0) == &quot;Name&quot;:
+                        del propertiesDict[self.valueBeforeEdit]
+                        prop.name = str(item.text(1))
+                        propertiesDict[prop.name] = prop
+
+                        parent.setText(1, prop.name)
+
+                        
+                    elif item.text(0) == &quot;Data&quot; and prop.type == &quot;STRING&quot;:
+                        prop.data = str(item.text(1))
+                        
+                    elif item.text(0) == &quot;Data&quot; and prop.type == &quot;INT&quot;:
+                        val = None
+                        
+                        try:
+                            val = int(item.text(1))
+                        except ValueError, e:
+                            item.setText(column, self.valueBeforeEdit)
+                            print &quot;ValueError: &quot; + str(e)
+                            return
+                        
+                        prop.data = str(val)
+                    elif item.text(0) == &quot;Data&quot; and prop.type == &quot;REAL&quot;:
+                        val = None
+                        
+                        try:
+                            val = float(item.text(1))
+                        except ValueError, e:
+                            item.setText(column, self.valueBeforeEdit)
+                            print &quot;ValueError: &quot; + str(e)
+                            return
+
+                        prop.data = str(val)
+                        
+                    self.connect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;), self.onItemChanged)
+                    return
+                    
+                
+                
                 val = None
                 try:
                     val = float(item.text(1))
@@ -375,12 +421,37 @@
             item = QTreeWidgetItem(self.treeWidget)
             item.setText(0, &quot;State&quot;)
             n = str(self.node.getAttachedObject(0).getUserObject().state)
-            item.setText(1, n)            
-            
+            item.setText(1, n)
+                
             self.parsePosition(self.node)
             self.parseOrientation(self.node)
-            self.parseScale(self.node)
+            self.parseScale(self.node)            
             
+            
+            propDict = self.node.getAttachedObject(0).getUserObject().propertieDict
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Properties&quot;)
+            item.setText(1, str(len(propDict)))
+            
+            for key in propDict:
+                propParent = QTreeWidgetItem(item)
+                propParent.setText(0,  &quot;Name&quot;)
+                propParent.setText(1,  propDict[key].name)
+                
+                propItem = QTreeWidgetItem(propParent)
+                propItem.setText(0,  &quot;Name&quot;)
+                propItem.setText(1,  propDict[key].name)
+                propItem.setFlags(propItem.flags() | Qt.ItemIsEditable)
+                
+                propItem = QTreeWidgetItem(propParent)
+                propItem.setText(0,  &quot;Type&quot;)
+                propItem.setText(1,  propDict[key].type)
+                
+                propItem = QTreeWidgetItem(propParent)
+                propItem.setText(0,  &quot;Data&quot;)
+                propItem.setText(1,  propDict[key].data)
+                propItem.setFlags(propItem.flags() | Qt.ItemIsEditable)
+            
         elif name.startswith(&quot;light_&quot;):
             item = QTreeWidgetItem(self.treeWidget)
             light = ModuleManager.extractLight(self.node)
@@ -414,6 +485,7 @@
             self.parseDiffuseColor(self.node)
             self.parseSpecularColor(self.node)
             self.parseLightAttenuation(self.node)
+            
         elif name.startswith(&quot;area_&quot;):
             area = so.entity.getUserObject()
             item = QTreeWidgetItem(self.treeWidget)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ZoneManager.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ZoneManager.py	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ZoneManager.py	2009-04-11 10:34:44 UTC (rev 4893)
@@ -1,363 +1,363 @@
-#################################################
-# This source file is part of Rastullahs Lockenwickler.
-# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-#
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 2 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
- #################################################
-
-import functools
-import xml.etree.cElementTree as xml
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
- 
-import ogre.renderer.OGRE as og
- 
-from ModuleExplorer import NameInputDlg
- 
-#                &lt;zone name=&quot;Testzone&quot;&gt;
-#                        &lt;area type=&quot;sphere&quot;&gt;
-#                                &lt;position x=&quot;-10&quot; y=&quot;0&quot; z=&quot;-5&quot;/&gt;
-#                                &lt;scale x=&quot;6&quot; y=&quot;6&quot; z=&quot;6&quot;/&gt;
-#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
-#                        &lt;/area&gt;
-#                        &lt;area type=&quot;mesh&quot; meshfile=&quot;arc_UnbHaus_07.mesh&quot;&gt;
-#                                &lt;position x=&quot;25&quot; y=&quot;0&quot; z=&quot;-50&quot;/&gt;
-#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
-#                        &lt;/area&gt;
-#                        &lt;area type=&quot;sphere&quot; subtract=&quot;true&quot;&gt;
-#                                &lt;position x=&quot;-11&quot; y=&quot;0&quot; z=&quot;-4&quot;/&gt;
-#                                &lt;scale x=&quot;2&quot; y=&quot;2&quot; z=&quot;2&quot;/&gt;
-#                        &lt;/area&gt;
-#                        &lt;light name=&quot;red pointlight&quot;/&gt;
-#                        &lt;light name=&quot;green spotlight&quot;/&gt;
-#                        &lt;sound name=&quot;ruchin001.ogg&quot;/&gt;
-#                        &lt;trigger name=&quot;test&quot; classname=&quot;TestTrigger&quot;&gt;
-#                                &lt;property name=&quot;message&quot; type=&quot;STRING&quot; data=&quot;You triggered the dooms day device!&quot; /&gt;
-#                        &lt;/trigger&gt;
-#                &lt;/zone&gt;
- 
-class Area(og.UserDefinedObject):
-    def __init__(self,sceneManager, type, parentZone, id, position, orientation, scale, meshFile = None, transitiondistance = &quot;0.5&quot;, subtract = False):
-        og.UserDefinedObject.__init__(self)
-        self.type = type
-        self.parentZone = parentZone
-        if not parentZone:
-           raise Exception(&quot;No parentZone&quot;)
-
-        self.id = id # editor internal id for entity and node creation
-        self.areaNode = parentZone.zoneNode.createChildSceneNode(&quot;area_&quot; + parentZone.name + &quot; &quot; + str(id))
-        self.meshFile = meshFile
-        self.areaEntity = None
-        self.transitiondistance = transitiondistance
-        self.__subtract = subtract
-        self.sceneManager = sceneManager
-        
-        if type == &quot;box&quot;:
-            self.areaEntity = self.sceneManager.createEntity(&quot;area_&quot; + parentZone.name + str(id) + &quot;_entity&quot;, &quot;UniCube.mesh&quot;)
-        elif type == &quot;sphere&quot;:
-            self.areaEntity = self.sceneManager.createEntity(&quot;area_&quot; + parentZone.name + str(id) + &quot;_entity&quot;, &quot;UniSphere.mesh&quot;)        
-        elif type == &quot;ellipsoid&quot;:
-            print &quot;not yet&quot;
-        elif type == &quot;capsule&quot;:
-            print &quot;not yet&quot;
-        elif type == &quot;pyramid&quot;:
-            print &quot;not yet&quot;
-        elif type == &quot;mesh&quot;:
-            try:
-                self.areaEntity = sceneManager.createEntity(&quot;area_&quot; + parentZone.name + str(id) + &quot;_entity&quot;, self.meshFile)
-            except:
-                print &quot;Mesh &quot; + self.meshFile + &quot; not found!&quot;
-                return None
-                
-        self.areaEntity.setMaterialName(&quot;Lockenwickler_Area&quot;)
-        if self.__subtract:
-            self.areaEntity.setMaterialName(&quot;Lockenwickler_Area_Subtract&quot;)
-            
-        self.areaEntity.setUserObject(self)
-        self.areaNode.attachObject(self.areaEntity)
-        self.areaNode.setPosition(position)
-        if orientation is not None:
-            self.areaNode.setOrientation(orientation.w, orientation.x, orientation.y, orientation.z)
-        if scale is not None:
-            self.areaNode.setScale(scale)
-    
-    def __del__(self):
-        self.areaNode.detachAllObjects()
-        self.areaNode.getParent().removeAndDestroyChild(self.areaNode.getName())
-        self.sceneManager.destroyEntity(self.areaEntity.getName())
-    
-    def getsubtract(self):
-        return self.__subtract
-        
-    def setsubtract(self, val):
-        if not val:
-            self.areaEntity.setMaterialName(&quot;Lockenwickler_Area&quot;)
-        else:
-            self.areaEntity.setMaterialName(&quot;Lockenwickler_Area_Subtract&quot;)
-        
-        self.__subtract = val
-        
-    subtract = property(getsubtract, setsubtract)
-    
-class Zone():
-    def __init__(self,sceneManager, map, name):
-        self.map = map
-        self.name = name
-        self.areaList = []
-        self.lightList = []
-        self.soundList = []
-        self.triggerList = []
-        self.areaCounter = 0
-        self.sceneManager = sceneManager
-        self.isHidden = False
-        
-        self.zoneNode =  self.sceneManager.getRootSceneNode().createChildSceneNode(&quot;zone_&quot; + name + &quot;_node&quot;)
-        
-    def addArea(self, type, position, orientation, scale, meshFile = None):
-        area = Area(self.sceneManager, type, self, self.areaCounter, position, orientation, scale, meshFile)
-        if area is not None:
-            self.areaList.append(area)
-            self.areaCounter = self.areaCounter + 1
-    
-    def deleteArea(self, area):
-        for a in self.areaList:
-            if a.id == area.id:
-                self.areaList.remove(a)
-                del a
-    
-    def hide(self):
-        self.sceneManager.getRootSceneNode().removeChild(self.zoneNode)
-        self.isHidden = True
-    
-    def show(self):
-        self.sceneManager.getRootSceneNode().addChild(self.zoneNode)
-        self.isHidden = False
-        
-        
-class ZoneManager():
-    def __init__(self, sceneManager):
-        self.currentMap = None
-        self.zoneList = []
-        self.menuList = []
-        self.entityUnderMouse = None
-        self.newAreaPosition = None
-        self.sceneManager = sceneManager
-        
-    def createZone(self, name):
-        if self.currentMap == None:
-            print &quot;No map selected!&quot;
-            return
-            
-        z = Zone(self.sceneManager, self.currentMap, name)
-        self.zoneList.append(z)
-        self.currentMap.zoneList.append(z)
-        return z
-        
-    def parseZonesFromXml(self, zoneXmlNode, map):
-        if zoneXmlNode is None:
-            return
-        
-        self.currentMap = map
-        
-        zoneNodes = zoneXmlNode.getiterator(&quot;zone&quot;)
-        for zone in zoneNodes:
-            zoneName = zone.attrib[&quot;name&quot;]
-            z = self.createZone(zoneName)
-            
-            areaNodes = zone.getiterator(&quot;area&quot;)
-            for area in areaNodes:
-                type = area.attrib[&quot;type&quot;]
-                meshFile = None
-                if type == &quot;mesh&quot;:
-                    meshFile = area.attrib[&quot;meshfile&quot;]
-                
-                pos = og.Vector3()
-                qw = qx = qy = qz = 0
-                scale = None
-                hasRotation = False
-                
-                transformations = area.getiterator()
-                for t in transformations:
-                    if t.tag == &quot;position&quot;:
-                        posx = float(t.attrib[&quot;x&quot;])
-                        posy = float(t.attrib[&quot;y&quot;])
-                        posz = float(t.attrib[&quot;z&quot;])
-                        pos = og.Vector3(posx, posy, posz)
-                    elif t.tag == &quot;rotation&quot;:
-                        qw = float(t.attrib[&quot;qw&quot;])
-                        qx = float(t.attrib[&quot;qx&quot;])
-                        qy = float(t.attrib[&quot;qy&quot;])
-                        qz = float(t.attrib[&quot;qz&quot;])
-                        hasRotation = True
-                    elif type == &quot;mesh&quot; and t.tag == &quot;scale&quot;:
-                        scalex = float(t.attrib[&quot;x&quot;])
-                        scaley = float(t.attrib[&quot;y&quot;])
-                        scalez = float(t.attrib[&quot;z&quot;])
-                        scale = og.Vector3(scalex, scaley, scalez)
-                    elif t.tag == &quot;size&quot;:
-                        scalex = float(t.attrib[&quot;x&quot;])
-                        scaley = float(t.attrib[&quot;y&quot;])
-                        scalez = float(t.attrib[&quot;z&quot;])
-                        scale = og.Vector3(scalex, scaley, scalez)
-                
-                rot = None
-                if hasRotation:
-                    rot = og.Quaternion(qw, qx, qy, qz)
-                    
-                z.addArea(type, pos, rot, scale, meshFile)
-            
-            
-            lightNodes = zone.getiterator(&quot;light&quot;)
-            for light in lightNodes:
-                name = light.attrib[&quot;name&quot;]
-                z.lightList.append(name)
-                
-            soundNodes = zone.getiterator(&quot;sound&quot;)
-            for sound in soundNodes:
-                name = sound.attrib[&quot;name&quot;]
-                z.soundList.append(name)
-            
-
-    def saveZonesToXml(self, root, map):
-        if len(map.zoneList) == 0:
-            return
-        
-        rootZonesElem = xml.SubElement(root, &quot;zones&quot;)
-        for zone in map.zoneList:
-            zoneElem = xml.SubElement(rootZonesElem, &quot;zone&quot;)
-            zoneElem.attrib[&quot;name&quot;] = zone.name
-            
-            for area in zone.areaList:
-                areaElem = xml.SubElement(zoneElem, &quot;area&quot;)
-                areaElem.attrib[&quot;type&quot;] = area.type
-                print &quot;Saving Zone: &quot; + zone.name + &quot; - Area &quot; + str(area.id)
-                if area.type == &quot;mesh&quot; and area.meshFile is not None:
-                    areaElem.attrib[&quot;meshfile&quot;] = area.meshFile
-                    
-                posElem = xml.SubElement(areaElem, &quot;position&quot;)
-                posElem.attrib[&quot;x&quot;] = str(area.areaNode.getPosition().x)
-                posElem.attrib[&quot;y&quot;] = str(area.areaNode.getPosition().y)
-                posElem.attrib[&quot;z&quot;] = str(area.areaNode.getPosition().z)
-                
-                rotElem = xml.SubElement(areaElem, &quot;rotation&quot;)
-                rotElem.attrib[&quot;qw&quot;] = str(area.areaNode.getOrientation().w)
-                rotElem.attrib[&quot;qx&quot;] = str(area.areaNode.getOrientation().x)
-                rotElem.attrib[&quot;qy&quot;] = str(area.areaNode.getOrientation().y)
-                rotElem.attrib[&quot;qz&quot;] = str(area.areaNode.getOrientation().z)
-                
-                scaleElem = None
-                if area.type == &quot;mesh&quot;:
-                    scaleElem = xml.SubElement(areaElem, &quot;scale&quot;)
-                else:
-                    scaleElem = xml.SubElement(areaElem, &quot;size&quot;)
-
-                scaleElem.attrib[&quot;x&quot;] = str(area.areaNode.getScale().x)
-                scaleElem.attrib[&quot;y&quot;] = str(area.areaNode.getScale().y)
-                scaleElem.attrib[&quot;z&quot;] = str(area.areaNode.getScale().z)
-                
-            for lightName in zone.lightList:
-                lightElem = xml.SubElement(zoneElem, &quot;light&quot;)
-                lightElem.attrib[&quot;name&quot;] = lightName
-            
-            for soundName in zone.soundList:
-                soundElem = xml.SubElement(zoneElem, &quot;sound&quot;)
-                soundElem.attrib[&quot;name&quot;] = soundName
-                
-    def deleteArea(self, area):
-        for z in self.zoneList:
-            for a in z.areaList:
-                if a.id == area.id:
-                    z.deleteArea(area)
-    
-    def getZoneMenu(self):
-        self.menuList = []
-        menu = QMenu(&quot;Add Area&quot;)
-        
-        for zone in self.zoneList:
-            m = QMenu(zone.name)
-            self.menuList.append(m)
-            menu.addMenu(m)
-            
-            boxAction = self.createAction(&quot;box&quot;, functools.partial(self.onZoneNameTriggered, zone, &quot;box&quot;))
-            self.menuList.append(boxAction)
-            m.addAction(boxAction)
-            
-            sphereAction = self.createAction(&quot;sphere&quot;, functools.partial(self.onZoneNameTriggered, zone, &quot;sphere&quot;))
-            self.menuList.append(sphereAction)
-            m.addAction(sphereAction)
-            
-            ellipsoidAction = self.createAction(&quot;ellipsoid&quot;, functools.partial(self.onZoneNameTriggered, zone, &quot;ellipsoid&quot;))
-            self.menuList.append(ellipsoidAction)
-            m.addAction(ellipsoidAction)
-            
-            capsuleAction = self.createAction(&quot;capsule&quot;, functools.partial(self.onZoneNameTriggered, zone, &quot;capsule&quot;))
-            self.menuList.append(capsuleAction)
-            m.addAction(capsuleAction)
-            
-            pyramidAction = self.createAction(&quot;pyramid&quot;, functools.partial(self.onZoneNameTriggered, zone, &quot;pyramid&quot;))
-            self.menuList.append(pyramidAction)
-            m.addAction(pyramidAction)
-            
-            meshAction = self.createAction(&quot;mesh&quot;, functools.partial(self.onZoneNameTriggered, zone, &quot;mesh&quot;))
-            self.menuList.append(meshAction)
-            m.addAction(meshAction)
-            
-        return menu
-        
-    def onZoneNameTriggered(self, zone, type):
-        if self.newAreaPosition is not None:
-            if type == &quot;box&quot;:
-                zone.addArea(&quot;box&quot;, self.newAreaPosition, None, None)
-            elif type == &quot;sphere&quot;:
-                zone.addArea(&quot;sphere&quot;, self.newAreaPosition, None, None)
-            elif type == &quot;mesh&quot;:
-                dlg = NameInputDlg(QApplication.focusWidget())
-                resName = &quot;&quot;
-                if dlg.exec_():
-                    resName = str(dlg.nameInput.text())
-
-                zone.addArea(&quot;mesh&quot;, self.newAreaPosition, None, None, resName)
-                
-    def getZone(self, name):
-        for zone in self.zoneList:
-            if zone.name == name:
-                return zone
-        
-    def getZoneList(self):
-        list = []
-        for zone in self.zoneList:
-            list.append(zone.name)
-            
-        return list
-        
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
-        action = QAction(text, None)
-        if icon is not None:
-            action.setIcon(QIcon(&quot;media/icons/%s&quot; % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            QWidget.connect(action, SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
-        
-        
-        
+#################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import functools
+import xml.etree.cElementTree as xml
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+ 
+import ogre.renderer.OGRE as og
+ 
+from ModuleExplorer import NameInputDlg
+ 
+#                &lt;zone name=&quot;Testzone&quot;&gt;
+#                        &lt;area type=&quot;sphere&quot;&gt;
+#                                &lt;position x=&quot;-10&quot; y=&quot;0&quot; z=&quot;-5&quot;/&gt;
+#                                &lt;scale x=&quot;6&quot; y=&quot;6&quot; z=&quot;6&quot;/&gt;
+#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
+#                        &lt;/area&gt;
+#                        &lt;area type=&quot;mesh&quot; meshfile=&quot;arc_UnbHaus_07.mesh&quot;&gt;
+#                                &lt;position x=&quot;25&quot; y=&quot;0&quot; z=&quot;-50&quot;/&gt;
+#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
+#                        &lt;/area&gt;
+#                        &lt;area type=&quot;sphere&quot; subtract=&quot;true&quot;&gt;
+#                                &lt;position x=&quot;-11&quot; y=&quot;0&quot; z=&quot;-4&quot;/&gt;
+#                                &lt;scale x=&quot;2&quot; y=&quot;2&quot; z=&quot;2&quot;/&gt;
+#                        &lt;/area&gt;
+#                        &lt;light name=&quot;red pointlight&quot;/&gt;
+#                        &lt;light name=&quot;green spotlight&quot;/&gt;
+#                        &lt;sound name=&quot;ruchin001.ogg&quot;/&gt;
+#                        &lt;trigger name=&quot;test&quot; classname=&quot;TestTrigger&quot;&gt;
+#                                &lt;property name=&quot;message&quot; type=&quot;STRING&quot; data=&quot;You triggered the dooms day device!&quot; /&gt;
+#                        &lt;/trigger&gt;
+#                &lt;/zone&gt;
+ 
+class Area(og.UserDefinedObject):
+    def __init__(self,sceneManager, type, parentZone, id, position, orientation, scale, meshFile = None, transitiondistance = &quot;0.5&quot;, subtract = False):
+        og.UserDefinedObject.__init__(self)
+        self.type = type
+        self.parentZone = parentZone
+        if not parentZone:
+           raise Exception(&quot;No parentZone&quot;)
+
+        self.id = id # editor internal id for entity and node creation
+        self.areaNode = parentZone.zoneNode.createChildSceneNode(&quot;area_&quot; + parentZone.name + &quot; &quot; + str(id))
+        self.meshFile = meshFile
+        self.areaEntity = None
+        self.transitiondistance = transitiondistance
+        self.__subtract = subtract
+        self.sceneManager = sceneManager
+        
+        if type == &quot;box&quot;:
+            self.areaEntity = self.sceneManager.createEntity(&quot;area_&quot; + parentZone.name + str(id) + &quot;_entity&quot;, &quot;UniCube.mesh&quot;)
+        elif type == &quot;sphere&quot;:
+            self.areaEntity = self.sceneManager.createEntity(&quot;area_&quot; + parentZone.name + str(id) + &quot;_entity&quot;, &quot;UniSphere.mesh&quot;)        
+        elif type == &quot;ellipsoid&quot;:
+            print &quot;not yet&quot;
+        elif type == &quot;capsule&quot;:
+            print &quot;not yet&quot;
+        elif type == &quot;pyramid&quot;:
+            print &quot;not yet&quot;
+        elif type == &quot;mesh&quot;:
+            try:
+                self.areaEntity = sceneManager.createEntity(&quot;area_&quot; + parentZone.name + str(id) + &quot;_entity&quot;, self.meshFile)
+            except:
+                print &quot;Mesh &quot; + self.meshFile + &quot; not found!&quot;
+                return None
+                
+        self.areaEntity.setMaterialName(&quot;Lockenwickler_Area&quot;)
+        if self.__subtract:
+            self.areaEntity.setMaterialName(&quot;Lockenwickler_Area_Subtract&quot;)
+            
+        self.areaEntity.setUserObject(self)
+        self.areaNode.attachObject(self.areaEntity)
+        self.areaNode.setPosition(position)
+        if orientation is not None:
+            self.areaNode.setOrientation(orientation.w, orientation.x, orientation.y, orientation.z)
+        if scale is not None:
+            self.areaNode.setScale(scale)
+    
+    def __del__(self):
+        self.areaNode.detachAllObjects()
+        self.areaNode.getParent().removeAndDestroyChild(self.areaNode.getName())
+        self.sceneManager.destroyEntity(self.areaEntity.getName())
+    
+    def getsubtract(self):
+        return self.__subtract
+        
+    def setsubtract(self, val):
+        if not val:
+            self.areaEntity.setMaterialName(&quot;Lockenwickler_Area&quot;)
+        else:
+            self.areaEntity.setMaterialName(&quot;Lockenwickler_Area_Subtract&quot;)
+        
+        self.__subtract = val
+        
+    subtract = property(getsubtract, setsubtract)
+    
+class Zone():
+    def __init__(self,sceneManager, map, name):
+        self.map = map
+        self.name = name
+        self.areaList = []
+        self.lightList = []
+        self.soundList = []
+        self.triggerList = []
+        self.areaCounter = 0
+        self.sceneManager = sceneManager
+        self.isHidden = False
+        
+        self.zoneNode =  self.sceneManager.getRootSceneNode().createChildSceneNode(&quot;zone_&quot; + name + &quot;_node&quot;)
+        
+    def addArea(self, type, position, orientation, scale, meshFile = None):
+        area = Area(self.sceneManager, type, self, self.areaCounter, position, orientation, scale, meshFile)
+        if area is not None:
+            self.areaList.append(area)
+            self.areaCounter = self.areaCounter + 1
+    
+    def deleteArea(self, area):
+        for a in self.areaList:
+            if a.id == area.id:
+                self.areaList.remove(a)
+                del a
+    
+    def hide(self):
+        self.sceneManager.getRootSceneNode().removeChild(self.zoneNode)
+        self.isHidden = True
+    
+    def show(self):
+        self.sceneManager.getRootSceneNode().addChild(self.zoneNode)
+        self.isHidden = False
+        
+        
+class ZoneManager():
+    def __init__(self, sceneManager):
+        self.currentMap = None
+        self.zoneList = []
+        self.menuList = []
+        self.entityUnderMouse = None
+        self.newAreaPosition = None
+        self.sceneManager = sceneManager
+        
+    def createZone(self, name):
+        if self.currentMap == None:
+            print &quot;No map selected!&quot;
+            return
+            
+        z = Zone(self.sceneManager, self.currentMap, name)
+        self.zoneList.append(z)
+        self.currentMap.zoneList.append(z)
+        return z
+        
+    def parseZonesFromXml(self, zoneXmlNode, map):
+        if zoneXmlNode is None:
+            return
+        
+        self.currentMap = map
+        
+        zoneNodes = zoneXmlNode.getiterator(&quot;zone&quot;)
+        for zone in zoneNodes:
+            zoneName = zone.attrib[&quot;name&quot;]
+            z = self.createZone(zoneName)
+            
+            areaNodes = zone.getiterator(&quot;area&quot;)
+            for area in areaNodes:
+                type = area.attrib[&quot;type&quot;]
+                meshFile = None
+                if type == &quot;mesh&quot;:
+                    meshFile = area.attrib[&quot;meshfile&quot;]
+                
+                pos = og.Vector3()
+                qw = qx = qy = qz = 0
+                scale = None
+                hasRotation = False
+                
+                transformations = area.getiterator()
+                for t in transformations:
+                    if t.tag == &quot;position&quot;:
+                        posx = float(t.attrib[&quot;x&quot;])
+                        posy = float(t.attrib[&quot;y&quot;])
+                        posz = float(t.attrib[&quot;z&quot;])
+                        pos = og.Vector3(posx, posy, posz)
+                    elif t.tag == &quot;rotation&quot;:
+                        qw = float(t.attrib[&quot;qw&quot;])
+                        qx = float(t.attrib[&quot;qx&quot;])
+                        qy = float(t.attrib[&quot;qy&quot;])
+                        qz = float(t.attrib[&quot;qz&quot;])
+                        hasRotation = True
+                    elif type == &quot;mesh&quot; and t.tag == &quot;scale&quot;:
+                        scalex = float(t.attrib[&quot;x&quot;])
+                        scaley = float(t.attrib[&quot;y&quot;])
+                        scalez = float(t.attrib[&quot;z&quot;])
+                        scale = og.Vector3(scalex, scaley, scalez)
+                    elif t.tag == &quot;size&quot;:
+                        scalex = float(t.attrib[&quot;x&quot;])
+                        scaley = float(t.attrib[&quot;y&quot;])
+                        scalez = float(t.attrib[&quot;z&quot;])
+                        scale = og.Vector3(scalex, scaley, scalez)
+                
+                rot = None
+                if hasRotation:
+                    rot = og.Quaternion(qw, qx, qy, qz)
+                    
+                z.addArea(type, pos, rot, scale, meshFile)
+            
+            
+            lightNodes = zone.getiterator(&quot;light&quot;)
+            for light in lightNodes:
+                name = light.attrib[&quot;name&quot;]
+                z.lightList.append(name)
+                
+            soundNodes = zone.getiterator(&quot;sound&quot;)
+            for sound in soundNodes:
+                name = sound.attrib[&quot;name&quot;]
+                z.soundList.append(name)
+            
+
+    def saveZonesToXml(self, root, map):
+        if len(map.zoneList) == 0:
+            return
+        
+        rootZonesElem = xml.SubElement(root, &quot;zones&quot;)
+        for zone in map.zoneList:
+            zoneElem = xml.SubElement(rootZonesElem, &quot;zone&quot;)
+            zoneElem.attrib[&quot;name&quot;] = zone.name
+            
+            for area in zone.areaList:
+                areaElem = xml.SubElement(zoneElem, &quot;area&quot;)
+                areaElem.attrib[&quot;type&quot;] = area.type
+                #print &quot;Saving Zone: &quot; + zone.name + &quot; - Area &quot; + str(area.id)
+                if area.type == &quot;mesh&quot; and area.meshFile is not None:
+                    areaElem.attrib[&quot;meshfile&quot;] = area.meshFile
+                    
+                posElem = xml.SubElement(areaElem, &quot;position&quot;)
+                posElem.attrib[&quot;x&quot;] = str(area.areaNode.getPosition().x)
+                posElem.attrib[&quot;y&quot;] = str(area.areaNode.getPosition().y)
+                posElem.attrib[&quot;z&quot;] = str(area.areaNode.getPosition().z)
+                
+                rotElem = xml.SubElement(areaElem, &quot;rotation&quot;)
+                rotElem.attrib[&quot;qw&quot;] = str(area.areaNode.getOrientation().w)
+                rotElem.attrib[&quot;qx&quot;] = str(area.areaNode.getOrientation().x)
+                rotElem.attrib[&quot;qy&quot;] = str(area.areaNode.getOrientation().y)
+                rotElem.attrib[&quot;qz&quot;] = str(area.areaNode.getOrientation().z)
+                
+                scaleElem = None
+                if area.type == &quot;mesh&quot;:
+                    scaleElem = xml.SubElement(areaElem, &quot;scale&quot;)
+                else:
+                    scaleElem = xml.SubElement(areaElem, &quot;size&quot;)
+
+                scaleElem.attrib[&quot;x&quot;] = str(area.areaNode.getScale().x)
+                scaleElem.attrib[&quot;y&quot;] = str(area.areaNode.getScale().y)
+                scaleElem.attrib[&quot;z&quot;] = str(area.areaNode.getScale().z)
+                
+            for lightName in zone.lightList:
+                lightElem = xml.SubElement(zoneElem, &quot;light&quot;)
+                lightElem.attrib[&quot;name&quot;] = lightName
+            
+            for soundName in zone.soundList:
+                soundElem = xml.SubElement(zoneElem, &quot;sound&quot;)
+                soundElem.attrib[&quot;name&quot;] = soundName
+                
+    def deleteArea(self, area):
+        for z in self.zoneList:
+            for a in z.areaList:
+                if a.id == area.id:
+                    z.deleteArea(area)
+    
+    def getZoneMenu(self):
+        self.menuList = []
+        menu = QMenu(&quot;Add Area&quot;)
+        
+        for zone in self.zoneList:
+            m = QMenu(zone.name)
+            self.menuList.append(m)
+            menu.addMenu(m)
+            
+            boxAction = self.createAction(&quot;box&quot;, functools.partial(self.onZoneNameTriggered, zone, &quot;box&quot;))
+            self.menuList.append(boxAction)
+            m.addAction(boxAction)
+            
+            sphereAction = self.createAction(&quot;sphere&quot;, functools.partial(self.onZoneNameTriggered, zone, &quot;sphere&quot;))
+            self.menuList.append(sphereAction)
+            m.addAction(sphereAction)
+            
+            ellipsoidAction = self.createAction(&quot;ellipsoid&quot;, functools.partial(self.onZoneNameTriggered, zone, &quot;ellipsoid&quot;))
+            self.menuList.append(ellipsoidAction)
+            m.addAction(ellipsoidAction)
+            
+            capsuleAction = self.createAction(&quot;capsule&quot;, functools.partial(self.onZoneNameTriggered, zone, &quot;capsule&quot;))
+            self.menuList.append(capsuleAction)
+            m.addAction(capsuleAction)
+            
+            pyramidAction = self.createAction(&quot;pyramid&quot;, functools.partial(self.onZoneNameTriggered, zone, &quot;pyramid&quot;))
+            self.menuList.append(pyramidAction)
+            m.addAction(pyramidAction)
+            
+            meshAction = self.createAction(&quot;mesh&quot;, functools.partial(self.onZoneNameTriggered, zone, &quot;mesh&quot;))
+            self.menuList.append(meshAction)
+            m.addAction(meshAction)
+            
+        return menu
+        
+    def onZoneNameTriggered(self, zone, type):
+        if self.newAreaPosition is not None:
+            if type == &quot;box&quot;:
+                zone.addArea(&quot;box&quot;, self.newAreaPosition, None, None)
+            elif type == &quot;sphere&quot;:
+                zone.addArea(&quot;sphere&quot;, self.newAreaPosition, None, None)
+            elif type == &quot;mesh&quot;:
+                dlg = NameInputDlg(QApplication.focusWidget())
+                resName = &quot;&quot;
+                if dlg.exec_():
+                    resName = str(dlg.nameInput.text())
+
+                zone.addArea(&quot;mesh&quot;, self.newAreaPosition, None, None, resName)
+                
+    def getZone(self, name):
+        for zone in self.zoneList:
+            if zone.name == name:
+                return zone
+        
+    def getZoneList(self):
+        list = []
+        for zone in self.zoneList:
+            list.append(zone.name)
+            
+        return list
+        
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
+        action = QAction(text, None)
+        if icon is not None:
+            action.setIcon(QIcon(&quot;media/icons/%s&quot; % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            QWidget.connect(action, SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+        
+        
+        

Modified: rl/branches/persistence2/engine/ai/src/PhysicalObstacle.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/PhysicalObstacle.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/ai/src/PhysicalObstacle.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -70,7 +70,7 @@
         Quaternion orientation;
         body-&gt;getPositionOrientation(position, orientation);
 
-    	const OgreNewt::Collision* collision = body-&gt;getCollision();
+    	const OgreNewt::CollisionPtr collision = body-&gt;getCollision();
     	RlAssert(collision, &quot;Body has no collision!&quot;);
     	AxisAlignedBox box = collision-&gt;getAABB();
     	Ogre::Vector3 dims = box.getMaximum() - box.getMinimum();

Modified: rl/branches/persistence2/engine/core/include/PhysicalThing.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicalThing.h	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/include/PhysicalThing.h	2009-04-11 10:34:44 UTC (rev 4893)
@@ -226,7 +226,7 @@
 		GeometryType getGeometryType() const;
 		void setBody(OgreNewt::Body* body);
 
-        OgreNewt::CollisionPtr createCollision(PhysicalObject* po, Ogre::Vector3&amp; inertia) const;
+        OgreNewt::CollisionPtr createCollision(PhysicalObject* po, Ogre::Vector3&amp; inertia, Ogre::Vector3&amp; centerOfMass) const;
 
         //! the ragdoll, if this thing is controlled by a ragdoll
         PhysicsRagDoll* mRagDoll;

Modified: rl/branches/persistence2/engine/core/include/PhysicsManager.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicsManager.h	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/include/PhysicsManager.h	2009-04-11 10:34:44 UTC (rev 4893)
@@ -222,6 +222,9 @@
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
+		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
+         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
+         *                the new collision is not added to the cache
 		*/
 		OgreNewt::CollisionPtr createCollision(
 			Ogre::Entity* entity,
@@ -230,7 +233,9 @@
 			Ogre::Vector3* offset = NULL,
 			Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL,
+            bool nocache = false);
 
         /** creates a collision primitive for OgreNewt.
 		 * The collision primitive created has got a basic orientation which can be influenced by
@@ -248,6 +253,9 @@
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
+		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
+         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
+         *                the new collision is not added to the cache
 		*/
         OgreNewt::CollisionPtr createCollision(
             const Ogre::String&amp; name,
@@ -256,7 +264,9 @@
             Ogre::Vector3* offset = NULL,
 			Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL,
+            bool nocache = false);
 
         /** Makes the collision primitive generation available to non mesh objects.
          * Non mesh objects need collision objects too. Therefore they can
@@ -292,7 +302,11 @@
         struct CollisionInUse
         {
         public:
-            CollisionInUse() : colPtr(NULL), geomType(GT_NONE) {}
+            CollisionInUse() :
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+                colPtr(NULL),
+#endif
+                geomType(GT_NONE) {}
             GeometryType geomType;  //! primitive type
             OgreNewt::CollisionPtr colPtr;          //! the collision primitve
         };
@@ -378,13 +392,13 @@
     {
     public:
         /** checks if the specified size is ok for OgreNewt
-         * @param size to check
+         * @param aabb check the aabb's size
          */
-        bool checkSize(const Ogre::Vector3&amp; size) const;
+        bool checkSize(const Ogre::AxisAlignedBox&amp; aabb) const;
         /** corrects the specified size if it is not ok for OgreNewt
-         * @param size to correct
+         * @param aabb correct the aabb's size
          */
-        void correctSize(Ogre::Vector3&amp; size);
+        void correctSize(Ogre::AxisAlignedBox&amp; aabb);
         /** calculates the Inertia for the given primitive type
          */
         //Ogre::Vector3 calculateIntertia(const Ogre::Real&amp; Mass, Ogre::Vector3* inertiaCoefficients);
@@ -401,13 +415,15 @@
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
+		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
 		*/
         OgreNewt::CollisionPtr createCollisionFromEntity(Ogre::Entity* entity,
             const GeometryType&amp; geomType,
             Ogre::Vector3* offset = NULL, 
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real Mass = 0,
-            Ogre::Vector3* inertiaCoefficients = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
 
         /** creates a collision primitive for OgreNewt from an AABB box.
 		 * The collision primitive created has got a basic orientation which can be influenced by
@@ -423,13 +439,15 @@
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
+		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
 		*/
         OgreNewt::CollisionPtr createCollisionFromAABB(const Ogre::AxisAlignedBox aabb,
             const GeometryType&amp; geomType,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real Mass = 0,
-            Ogre::Vector3* inertiaCoefficients = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
     protected:
         /** creates a box collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
@@ -438,12 +456,14 @@
          * @param orientation when not null, specifies the euler angle of orientation.
          * @param mass gives the mass for inertia calculation.
          * @param inertia when not null, an inertia is calculated and passed back.
+         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
         OgreNewt::CollisionPtr createBox(const Ogre::AxisAlignedBox&amp; aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
         /** creates a pyramid collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
@@ -451,12 +471,14 @@
          * @param orientation when not null, specifies the euler angle of orientation.
          * @param mass gives the mass for inertia calculation.
          * @param inertia when not null, an inertia is calculated and passed back.
+         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
         OgreNewt::CollisionPtr createPyramid(const Ogre::AxisAlignedBox&amp; aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
         /** creates a sphere collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
@@ -464,12 +486,14 @@
          * @param orientation when not null, specifies the euler angle of orientation.
          * @param mass gives the mass for inertia calculation.
          * @param inertia when not null, an inertia is calculated and passed back.
+         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
         OgreNewt::CollisionPtr createSphere(const Ogre::AxisAlignedBox&amp; aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
         /** creates a ellipsoid collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
@@ -477,12 +501,14 @@
          * @param orientation when not null, specifies the euler angle of orientation.
          * @param mass gives the mass for inertia calculation.
          * @param inertia when not null, an inertia is calculated and passed back.
+         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
         OgreNewt::CollisionPtr createEllipsoid(const Ogre::AxisAlignedBox&amp; aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
         /** creates a capsule collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
@@ -490,12 +516,14 @@
          * @param orientation when not null, specifies the euler angle of orientation.
          * @param mass gives the mass for inertia calculation.
          * @param inertia when not null, an inertia is calculated and passed back.
+         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
         OgreNewt::CollisionPtr createCapsule(const Ogre::AxisAlignedBox&amp; aabb,
             Ogre::Vector3* offset = NULL,
             Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL);
+            Ogre::Vector3* inertia = NULL,
+            Ogre::Vector3* centerOfMass = NULL);
     };
 }
 

Modified: rl/branches/persistence2/engine/core/include/PhysicsMaterialRaycast.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicsMaterialRaycast.h	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/include/PhysicsMaterialRaycast.h	2009-04-11 10:34:44 UTC (rev 4893)
@@ -111,7 +111,7 @@
         * @param invertmat if &quot;true&quot;, the ray finds all collisions, which do NOT have the material-id &quot;material&quot;
         */
         ConvexcastInfo execute(OgreNewt::World* world, const OgreNewt::MaterialID* material,
-            const OgreNewt::Collision *col, const Ogre::Vector3&amp; startpt, const Ogre::Quaternion &amp;ori,
+            const OgreNewt::ConvexCollisionPtr&amp; col, const Ogre::Vector3&amp; startpt, const Ogre::Quaternion &amp;ori,
             const Ogre::Vector3&amp; endpt, bool invertmat = false);
         
         /** executes the Convexcast
@@ -125,7 +125,7 @@
         * @param invertmat if &quot;true&quot;, the ray finds all collisions, which do NOT have the material-id &quot;material&quot;
         */
         ConvexcastInfo execute(OgreNewt::World* world, const MaterialVector* materials,
-            const OgreNewt::Collision *col, const Ogre::Vector3&amp; startpt, const Ogre::Quaternion &amp;ori,
+            const OgreNewt::ConvexCollisionPtr&amp; col, const Ogre::Vector3&amp; startpt, const Ogre::Quaternion &amp;ori,
             const Ogre::Vector3&amp; endpt, bool invertmat = false);
 
 

Modified: rl/branches/persistence2/engine/core/include/PhysicsRagDoll.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicsRagDoll.h	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/include/PhysicsRagDoll.h	2009-04-11 10:34:44 UTC (rev 4893)
@@ -112,7 +112,7 @@
 
 	private:
         //! create a convexhull from a mesh
-		OgreNewt::ConvexCollision* _makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight );
+		OgreNewt::ConvexCollisionPtr _makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight );
 
 		//! the ragdoll to that this bone belongs
 		PhysicsRagDoll* mDoll;

Modified: rl/branches/persistence2/engine/core/src/GameAreaTypes.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/GameAreaTypes.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/src/GameAreaTypes.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -244,8 +244,15 @@
             col);
         mBody-&gt;setMaterialGroupID(
             PhysicsManager::getSingleton().getMaterialID(&quot;gamearea&quot;));
+#ifndef OGRENEWT_USE_OGRE_ANY
         mBody-&gt;setUserData(NULL);
-        ((OgreNewt::ConvexCollision*)col)-&gt;setAsTriggerVolume(true);
+#endif
+
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+        boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(col)-&gt;setAsTriggerVolume(true);
+#else
+        dynamic_cast&lt;OgreNewt::ConvexCollisionPtr&gt;(col)-&gt;setAsTriggerVolume(true);
+#endif
     }
 
     GameSimpleCollisionAreaType::GameSimpleCollisionAreaType(
@@ -262,8 +269,15 @@
             col);
         mBody-&gt;setMaterialGroupID(
             PhysicsManager::getSingleton().getMaterialID(&quot;gamearea&quot;));
+#ifndef OGRENEWT_USE_OGRE_ANY
         mBody-&gt;setUserData(NULL);
-        ((OgreNewt::ConvexCollision*)col)-&gt;setAsTriggerVolume(true);
+#endif
+
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+        boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(col)-&gt;setAsTriggerVolume(true);
+#else
+        dynamic_cast&lt;OgreNewt::ConvexCollisionPtr&gt;(col)-&gt;setAsTriggerVolume(true);
+#endif
     }
 
 }

Modified: rl/branches/persistence2/engine/core/src/GameEventManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/GameEventManager.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/src/GameEventManager.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -308,6 +308,10 @@
 
     Actor* GameEventManager::bodyToActor(OgreNewt::Body* body)
     {
+#ifdef OGRENEWT_USE_OGRE_ANY
+        return Ogre::any_cast&lt;Actor*&gt;(body-&gt;getUserData());
+#else
         return static_cast&lt;Actor*&gt;(body-&gt;getUserData());
+#endif
     }
 }

Modified: rl/branches/persistence2/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicalThing.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/src/PhysicalThing.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -28,7 +28,6 @@
 
 using namespace Ogre;
 using namespace OgreNewt;
-using namespace OgreNewt::CollisionPrimitives;
 
 namespace rl
 {
@@ -128,7 +127,11 @@
 	void PhysicalThing::setBody(OgreNewt::Body* body)
     {
         mBody = body;
-		mBody-&gt;setUserData(mActor);
+#ifdef OGRENEWT_USE_OGRE_ANY
+		mBody-&gt;setUserData( Ogre::Any(mActor) );
+#else
+        mBody-&gt;setUserData( mActor );
+#endif
     }
 
     void PhysicalThing::_update()
@@ -155,7 +158,13 @@
     {
         mActor = actor;
 		if (mBody != NULL)
-			mBody-&gt;setUserData(actor);
+        {
+#ifdef OGRENEWT_USE_OGRE_ANY
+    		mBody-&gt;setUserData( Ogre::Any(mActor) );
+#else
+            mBody-&gt;setUserData( mActor );
+#endif
+        }
     }
 
     void PhysicalThing::_attachToSceneNode(Ogre::SceneNode* node)
@@ -239,8 +248,12 @@
         if( mBody &amp;&amp; !mRagDoll )
         {
             Vector3 inertia;
-            mBody-&gt;getMassMatrix(mMass, inertia);
+            Real oldMass;
+            mBody-&gt;getMassMatrix(oldMass, inertia);
             mMass = mass;
+            if( oldMass &gt; 0 )
+                inertia = inertia/oldMass*mass;
+                
             mBody-&gt;setMassMatrix(mass, inertia);
         }
         mMass = mass;
@@ -268,10 +281,25 @@
             &quot;PhysicalThing::updateCollisionHull: PhysicalThing must not be controlled by a RagDoll in order to update its collision hull.&quot;);
 
 
+        
         Vector3 position;
         Quaternion orientation;
         mBody-&gt;getPositionOrientation(position, orientation);
+        CollisionPtr collision = PhysicsManager::getSingleton().createCollision(
+                entity,
+                mGeometryType,
+                &quot;&quot;,
+                NULL,
+                NULL,
+                0, NULL, NULL,
+                true); // don't cache
+        if( collision )
+        {
+            mBody-&gt;setCollision(collision);
+            mBody-&gt;setPositionOrientation(position, orientation);
+        }
 
+/*
 		if (mGeometryType == GT_CONVEXHULL)
 		{
 			Matrix4 transform = node-&gt;_getFullTransform().inverse();
@@ -324,18 +352,19 @@
 					vbuffer-&gt;unlock();
 				}
 			}
-	        CollisionPtr collision(new ConvexHull(PhysicsManager::getSingleton()._getNewtonWorld(),
+	        CollisionPtr collision(new CollisionPrimitives::ConvexHull(PhysicsManager::getSingleton()._getNewtonWorld(),
 			    &amp;vertices[0], vertices.size()));
 		    mBody-&gt;setCollision(collision);
 		}
 		else if (mGeometryType == GT_MESH)
 		{
-	        CollisionPtr collision(new TreeCollision(
+	        CollisionPtr collision(new CollisionPrimitives::TreeCollision(
 				PhysicsManager::getSingleton()._getNewtonWorld(), entity, true));
 		    mBody-&gt;setCollision(collision);
 		}
 
         mBody-&gt;setPositionOrientation(position, orientation);
+*/
     }
 
     void PhysicalThing::freeze()
@@ -443,8 +472,8 @@
                 &quot;PhysicalThing::createPhysicsProxy: cannot create physics proxy while the PhysicalThing is controlled by a RagDoll!&quot;);
 		if (!mBody)
 		{
-            Vector3 inertia;
-            OgreNewt::CollisionPtr coll = createCollision(mPhysicalObject, inertia);
+            Vector3 inertia, centerOfMass;
+            OgreNewt::CollisionPtr coll = createCollision(mPhysicalObject, inertia, centerOfMass);
 
 			OgreNewt::Body* body = new OgreNewt::Body(
                 PhysicsManager::getSingleton()._getNewtonWorld(), coll);
@@ -454,6 +483,7 @@
 			if (mass &gt; 0.0 &amp;&amp; mGeometryType != GT_MESH)
             {
                 body-&gt;setMassMatrix(mass, inertia);
+                body-&gt;setCenterOfMass(centerOfMass);
             }
 
 			body-&gt;setCustomForceAndTorqueCallback(PhysicsManager::genericForceCallback);
@@ -469,7 +499,7 @@
         }
 	}
 
-    OgreNewt::CollisionPtr PhysicalThing::createCollision(PhysicalObject* po, Vector3&amp; inertia) const
+    OgreNewt::CollisionPtr PhysicalThing::createCollision(PhysicalObject* po, Vector3&amp; inertia, Vector3&amp; centerOfMass) const
     {
         OgreNewt::CollisionPtr coll;
 
@@ -488,7 +518,8 @@
                 NULL,
                 NULL,
                 mMass,
-                &amp;inertia);
+                &amp;inertia,
+                &amp;centerOfMass);
         }
         else
         {
@@ -499,7 +530,8 @@
                 NULL,
                 NULL,
                 mMass,
-                &amp;inertia);
+                &amp;inertia,
+                &amp;centerOfMass);
         }
 
         return coll;
@@ -511,13 +543,14 @@
         {
             mPoseCollisions.clear();
 
-            Vector3 inertia;
+            Vector3 inertia, centerOfMass;
 
             // update the collision
-		    mBody-&gt;setCollision(createCollision(mPhysicalObject, inertia));
+		    mBody-&gt;setCollision(createCollision(mPhysicalObject, inertia, centerOfMass));
 		    if (mMass &gt; 0.0 &amp;&amp; mGeometryType != GT_MESH)
             {
                 mBody-&gt;setMassMatrix(mMass, inertia);
+                mBody-&gt;setCenterOfMass(centerOfMass);
             }
         }
     }

Modified: rl/branches/persistence2/engine/core/src/PhysicsGenericContactCallback.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicsGenericContactCallback.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/src/PhysicsGenericContactCallback.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -29,8 +29,30 @@
     {
         userProcess(contactJoint, timestep, threadid);
 
-        Actor* a1 = static_cast&lt;Actor*&gt;(contactJoint.getBody0()-&gt;getUserData());
-        Actor* a2 = static_cast&lt;Actor*&gt;(contactJoint.getBody1()-&gt;getUserData());
+        Actor* a1 = NULL;
+        Actor* a2 = NULL;
+
+#ifdef OGRENEWT_USE_OGRE_ANY
+        try
+        {
+            a1 = Ogre::any_cast&lt;Actor*&gt;(contactJoint.getBody0()-&gt;getUserData());
+        }
+        catch(...)
+        {
+            LOG_WARNING(Logger::CORE, &quot;Found collision with a OgreNewt::Body that doesn't have an Actor as UserData in PhysicsGenericContactCallback::contactsProcess&quot;);
+        }
+        try
+        {
+            a2 = Ogre::any_cast&lt;Actor*&gt;(contactJoint.getBody1()-&gt;getUserData());
+        }
+        catch(...)
+        {
+            LOG_WARNING(Logger::CORE, &quot;Found collision with a OgreNewt::Body that doesn't have an Actor as UserData in PhysicsGenericContactCallback::contactsProcess&quot;);
+        }
+#else
+        a1 = static_cast&lt;Actor*&gt;(contactJoint.getBody0()-&gt;getUserData());
+        a2 = static_cast&lt;Actor*&gt;(contactJoint.getBody1()-&gt;getUserData());
+#endif
         if (a1 &amp;&amp; a1-&gt;getPhysicalThing()-&gt;getContactListener())
         {
             a1-&gt;getPhysicalThing()-&gt;getContactListener()-&gt;

Modified: rl/branches/persistence2/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicsManager.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/src/PhysicsManager.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -36,7 +36,7 @@
 
 namespace rl
 {
-    const Ogre::Real PhysicsManager::NEWTON_GRID_WIDTH = 0.01;
+    const Ogre::Real PhysicsManager::NEWTON_GRID_WIDTH = 0.02;
 
 	LQTBodies::LQTBodies(int maxData, int maxDepth, float looseness,
 		const Ogre::Vector2&amp; tlc, const Ogre::Vector2&amp; brc, float mWidth)
@@ -326,7 +326,10 @@
         
 
         // try one compound collision for the entity if there are several collisions
-        OgreNewt::CollisionPtr collision(NULL);
+        OgreNewt::CollisionPtr collision;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        collision = NULL;
+#endif
         switch( collisions.size() )
         {
             case 0:
@@ -335,7 +338,7 @@
                 collision = collisions[0];
                 break;
             default:
-                collision = new OgreNewt::CollisionPrimitives::CompoundCollision(mWorld, collisions);
+                collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::CompoundCollision(mWorld, collisions));
                 break;
         }
 
@@ -403,17 +406,28 @@
     void PhysicsManager::genericForceCallback(OgreNewt::Body* body, float timestep, int)
     {
         // apply saved forces in the PhysicalThing
-        PhysicalThing* thing =
-            static_cast&lt;Actor*&gt;(body-&gt;getUserData())-&gt;getPhysicalThing();
+        PhysicalThing* thing;
 
+#ifdef OGRENEWT_USE_OGRE_ANY
+        thing = Ogre::any_cast&lt;Actor*&gt;(body-&gt;getUserData())-&gt;getPhysicalThing();
+#else
+        thing = static_cast&lt;Actor*&gt;(body-&gt;getUserData())-&gt;getPhysicalThing();
+#endif
+
         thing-&gt;onApplyForceAndTorque(timestep);
     }
 
     void PhysicsManager::controlledForceCallback(OgreNewt::Body* body, float timestep, int)
     {
-        PhysicalThing* thing =
-            static_cast&lt;Actor*&gt;(body-&gt;getUserData())-&gt;getPhysicalThing();
+        PhysicalThing* thing;
 
+#ifdef OGRENEWT_USE_OGRE_ANY
+        thing = Ogre::any_cast&lt;Actor*&gt;(body-&gt;getUserData())-&gt;getPhysicalThing();
+#else
+        thing = static_cast&lt;Actor*&gt;(body-&gt;getUserData())-&gt;getPhysicalThing();
+#endif
+
+
         if (thing-&gt;getPhysicsController())
         {
             thing-&gt;getPhysicsController()-&gt;OnApplyForceAndTorque(thing, timestep);
@@ -507,7 +521,8 @@
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
         Ogre::Entity* entity, const GeometryType&amp; geomType,
 		const Ogre::String animName, Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia)
+        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
+        Ogre::Vector3* centerOfMass, bool nocache)
     {
         // problem here is that a mesh can have different animations with
         // different extents. Therefore we add the animName to the meshname
@@ -516,6 +531,9 @@
 
         // result value
         CollisionPtr rval;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        rval = NULL;
+#endif
 
         // check if there is a collision primitiv for the specified mesh object
         CollisionInUse &amp;usedcol (mCollisionPrimitives[collisionName]);
@@ -534,70 +552,6 @@
                 // found it
                 rval = usedcol.colPtr;
 
-
-                if( inertia )
-                {
-
-                    // we must set inertia here, the calling function doesn't know we are not creating a new collision
-                    switch(usedcol.geomType)
-                    {
-                    case GT_BOX: // from createBox
-                    case GT_CAPSULE: // from createCapsule
-                    case GT_CONVEXHULL: // from createCollisionFromEntity
-                    case GT_ELLIPSOID: // from createEllipsoid
-                    case GT_PYRAMID: // createPyramid
-                    case GT_SPHERE:
-                    case GT_MESH:
-                    case GT_NONE:
-                        *inertia = Ogre::Vector3::ZERO;
-                        break;
-                    }
-/*
-                    Ogre::AxisAlignedBox aabb(entity-&gt;getBoundingBox());
-                    Vector3 size( aabb.getSize() );
-                    switch(usedcol.geomType)
-                    {
-                    case GT_BOX: // from createBox
-                        *inertia = OgreNewt::MomentOfInertia::CalcBoxSolid(mass, aabb.getSize());
-                        break;
-                    case GT_CAPSULE: // from createCapsule
-                        {
-                            double radius = std::max(size.x, size.z) / 2.0;
-                            double sradius = radius*radius;
-                            *inertia = Vector3(sradius, size.y*size.y, sradius) * mass;
-                        }
-                        break;
-                    case GT_CONVEXHULL: // from createCollisionFromEntity
-				        *inertia = Vector3(
-				        size.x*size.x/6.0f,
-				        size.y*size.y/6.0f,
-			            size.z*size.z/6.0f) * mass;
-                        break;
-                    case GT_ELLIPSOID: // from createEllipsoid
-                        {
-                            Vector3 s(size/2.0);
-                            s.x = std::max(s.x, s.z);
-                            s.z = s.x;
-                            *inertia = Vector3(s.x*s.x, s.y*s.y, s.z*s.z) * mass;
-                        }
-                        break;
-                    case GT_MESH:
-                    case GT_NONE:
-                        *inertia = Ogre::Vector3::ZERO;
-                        break;
-                    case GT_PYRAMID: // createPyramid
-                        *inertia = Ogre::Vector3(size.x,size.y/2.0f, size.z) * mass;
-                        break;
-                    case GT_SPHERE:
-                        {
-                            double radius = std::max(size.x, std::max(size.y, size.z)) / 2.0;
-                            //*inertia = OgreNewt::MomentOfInertia::CalcSphereSolid(Mass,radius);
-                            *inertia = mass * Vector3(radius*radius, radius*radius, radius*radius);
-                        }
-                        break;
-                    }
-*/
-                }
             }
         }
 
@@ -605,7 +559,7 @@
         {
             // if there is none, then create a new collision object
             rval = mPhysicsCollisionFactory-&gt;createCollisionFromEntity(
-                entity, geomType, offset, orientation, mass, inertia );
+                entity, geomType, offset, orientation, mass, inertia, centerOfMass );
 
             usedcol.geomType = geomType;
             usedcol.colPtr = rval;
@@ -617,10 +571,14 @@
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
         const Ogre::String&amp; name, const Ogre::AxisAlignedBox&amp; aabb,
         const GeometryType&amp; geomType, Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia)
+        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
+        Ogre::Vector3* centerOfMass, bool nocache)
     {
         // result value
         CollisionPtr rval;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        rval = NULL;
+#endif
 
         // check if there is a collision primitiv for the specified mesh object
         CollisionInUse &amp;usedcol (mCollisionPrimitives[name]);
@@ -645,7 +603,7 @@
         {
             // if there is none, then create a new collision object
             rval = mPhysicsCollisionFactory-&gt;createCollisionFromAABB(
-                aabb, geomType, offset, orientation, mass, inertia );
+                aabb, geomType, offset, orientation, mass, inertia, centerOfMass );
 
             usedcol.geomType = geomType;
             usedcol.colPtr = rval;
@@ -699,8 +657,9 @@
 		return typestr;
 	}
 
-    bool PhysicsCollisionFactory::checkSize(const Ogre::Vector3&amp; size) const
+    bool PhysicsCollisionFactory::checkSize(const Ogre::AxisAlignedBox&amp; aabb) const
     {
+        Ogre::Vector3 size = aabb.getSize();
         if( size.x &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
             size.y &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
             size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH )
@@ -708,8 +667,9 @@
         return true;
     }
 
-    void PhysicsCollisionFactory::correctSize(Ogre::Vector3&amp; size)
+    void PhysicsCollisionFactory::correctSize(Ogre::AxisAlignedBox&amp; aabb)
     {
+        Ogre::Vector3 size = aabb.getSize();
         // correct size, log warning and fail back to box
         if (size.x &lt; PhysicsManager::NEWTON_GRID_WIDTH)
             size.x = PhysicsManager::NEWTON_GRID_WIDTH;
@@ -718,6 +678,9 @@
         if (size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH)
             size.z = PhysicsManager::NEWTON_GRID_WIDTH;
         LOG_MESSAGE(Logger::CORE, &quot;Correcting collision primitiv size&quot;);
+        Ogre::Vector3 center = aabb.getCenter();
+        aabb.setMaximum(center + 0.5*size);
+        aabb.setMinimum(center - 0.5*size);
     }
 
     /*
@@ -727,25 +690,28 @@
     }
     */
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(const Ogre::AxisAlignedBox aabb,
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(const Ogre::AxisAlignedBox passedAabb,
         const GeometryType&amp; geomType,
         Ogre::Vector3* offset,
         Ogre::Quaternion* orientation,
         const Ogre::Real Mass,
-        Ogre::Vector3* inertia)
+        Ogre::Vector3* inertia,
+        Ogre::Vector3* centerOfMass)
     {
-        // size of the mesh
-        Vector3 size( aabb.getSize() );
+        Ogre::AxisAlignedBox aabb(passedAabb);
         // type for the collision primitiv (can change internally here)
         bool forceBox (false);
 
         // result value
         CollisionPtr rval;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        rval = NULL;
+#endif
 
         // size check (if object is too small, it falls back to a box primitiv
-        if (checkSize(size) == false )
+        if (checkSize(aabb) == false )
         {
-            correctSize(size);
+            correctSize(aabb);
             LOG_MESSAGE(Logger::CORE,
                 &quot; AABB is too small, using 'box' instead of primitiv '&quot; +
                 PhysicsManager::convertGeometryTypeToString(geomType));
@@ -772,23 +738,23 @@
 	    */
 		if (geomType == GT_BOX || forceBox == true)
         {
-			rval = createBox(aabb, offset, orientation, Mass, inertia);
+			rval = createBox(aabb, offset, orientation, Mass, inertia, centerOfMass);
         }
         else if (geomType == GT_PYRAMID)
         {
-            rval = createPyramid(aabb, offset, orientation, Mass, inertia);
+            rval = createPyramid(aabb, offset, orientation, Mass, inertia, centerOfMass);
         }
         else if (geomType == GT_SPHERE)
         {
-			rval = createSphere(aabb, offset, orientation, Mass, inertia);
+			rval = createSphere(aabb, offset, orientation, Mass, inertia, centerOfMass);
         }
         else if (geomType == GT_ELLIPSOID)
         {
-            rval = createEllipsoid(aabb, offset, orientation, Mass, inertia);
+            rval = createEllipsoid(aabb, offset, orientation, Mass, inertia, centerOfMass);
         }
 		else if (geomType == GT_CAPSULE)
 		{
-			rval = createCapsule(aabb, offset, orientation, Mass, inertia);
+			rval = createCapsule(aabb, offset, orientation, Mass, inertia, centerOfMass);
 		}
         return rval;
     }
@@ -797,23 +763,25 @@
         const GeometryType&amp; geomType,
         Ogre::Vector3* offset,
         Ogre::Quaternion* orientation,
-        const Ogre::Real Mass,
-        Ogre::Vector3* inertia)
+        const Ogre::Real mass,
+        Ogre::Vector3* inertia,
+        Ogre::Vector3* centerOfMass)
     {
         // bounding box of the mesh
-        const Ogre::AxisAlignedBox aabb(entity-&gt;getBoundingBox());
-        // size of the mesh
-        Vector3 size( aabb.getSize() );
+        Ogre::AxisAlignedBox aabb(entity-&gt;getBoundingBox());
         // type for the collision primitiv (can change internally here)
         bool forceBox (false);
 
         // result value
         CollisionPtr rval;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+        rval = NULL;
+#endif
 
         // size check (if object is too small, it falls back to a box primitiv
-        if (checkSize(size) == false )
+        if (checkSize(aabb) == false )
         {
-            correctSize(size);
+            correctSize(aabb);
             LOG_MESSAGE(Logger::CORE, &quot; Entity '&quot;+entity-&gt;getName()+
                 &quot;' is too small, using 'box' instead of primitiv '&quot;+
                 PhysicsManager::convertGeometryTypeToString(geomType));
@@ -829,23 +797,23 @@
 	    */
 		if (geomType == GT_BOX || forceBox == true)
         {
-			rval = createBox(aabb, offset, orientation, Mass, inertia);
+			rval = createBox(aabb, offset, orientation, mass, inertia, centerOfMass);
         }
         else if (geomType == GT_PYRAMID)
         {
-            rval = createPyramid(aabb, offset, orientation, Mass, inertia);
+            rval = createPyramid(aabb, offset, orientation, mass, inertia, centerOfMass);
         }
         else if (geomType == GT_SPHERE)
         {
-			rval = createSphere(aabb, offset, orientation, Mass, inertia);
+			rval = createSphere(aabb, offset, orientation, mass, inertia, centerOfMass);
         }
         else if (geomType == GT_ELLIPSOID)
         {
-            rval = createEllipsoid(aabb, offset, orientation, Mass, inertia);
+            rval = createEllipsoid(aabb, offset, orientation, mass, inertia, centerOfMass);
         }
 		else if (geomType == GT_CAPSULE)
 		{
-			rval = createCapsule(aabb, offset, orientation, Mass, inertia);
+			rval = createCapsule(aabb, offset, orientation, mass, inertia, centerOfMass);
 		}
         else if (geomType == GT_CONVEXHULL)
         {
@@ -865,17 +833,26 @@
                 PhysicsManager::getSingleton()._getNewtonWorld(),
 				entity, /*entity-&gt;hasSkeleton(),*/ *orientation, *offset));
 
-			if (inertia != NULL)
-			{
-                            Vector3 inert_offs=Vector3::ZERO;
-                            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
-                            *inertia *= Mass;
-			}
+            if (inertia != NULL || centerOfMass != NULL )
+            {
+                Vector3 temp_inertia, temp_centerOfMass;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+                boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+                dynamic_cast&lt;OgreNewt::ConvexCollisionPtr&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
+                if( inertia != NULL )
+                    *inertia = temp_inertia*mass;
+                if( centerOfMass != NULL )
+                    *centerOfMass = temp_centerOfMass;
+            }
         }
         else if (geomType == GT_MESH)
         {
             if (inertia != NULL)
                 *inertia = Ogre::Vector3::ZERO;
+            if (centerOfMass != NULL)
+                *centerOfMass = Ogre::Vector3::ZERO;
 
             rval = CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
                 PhysicsManager::getSingleton()._getNewtonWorld(),
@@ -906,7 +883,8 @@
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
             const Ogre::Real mass,
-            Ogre::Vector3* inertia)
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass)
     {
         // offset of the collision primitiv
         Ogre::Vector3 object_offset( aabb.getCenter() );
@@ -923,11 +901,20 @@
         OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             aabb.getSize(), *orientation, *offset));
-        if (inertia)
+
+
+        if (inertia != NULL || centerOfMass != NULL )
         {
-            Vector3 inert_offs=Vector3::ZERO;
-            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
-            *inertia *= mass;
+            Vector3 temp_inertia, temp_centerOfMass;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+            dynamic_cast&lt;OgreNewt::ConvexCollisionPtr&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
+            if( inertia )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass )
+                *centerOfMass = temp_centerOfMass;
         }
 
         return rval;
@@ -937,7 +924,8 @@
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
             const Ogre::Real mass,
-            Ogre::Vector3* inertia)
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass)
     {
         Ogre::Vector3 size = aabb.getSize();
         // positional offset of the collision primitiv
@@ -954,13 +942,22 @@
         OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             size, *orientation, *offset));
-        if (inertia)
+
+
+        if (inertia != NULL || centerOfMass != NULL )
         {
-            Vector3 inert_offs=Vector3::ZERO;
-            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
-            *inertia *= mass;
+            Vector3 temp_inertia, temp_centerOfMass;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+            dynamic_cast&lt;OgreNewt::ConvexCollisionPtr&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
+            if( inertia )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass )
+                *centerOfMass = temp_centerOfMass;
         }
-
+ 
         return rval;
     }
 
@@ -968,7 +965,8 @@
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
             const Ogre::Real mass,
-            Ogre::Vector3* inertia)
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass)
     {
         Ogre::Vector3 size = aabb.getSize();
         // calculate the maximum radius needed to include 'everything'
@@ -989,12 +987,22 @@
         OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             Vector3(radius, radius, radius), *orientation, *offset));
-        if (inertia)
+ 
+
+        if (inertia != NULL || centerOfMass != NULL )
         {
-            Vector3 inert_offs=Vector3::ZERO;
-            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
-            *inertia *= mass;
+            Vector3 temp_inertia, temp_centerOfMass;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+            dynamic_cast&lt;OgreNewt::ConvexCollisionPtr&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
+            if( inertia )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass )
+                *centerOfMass = temp_centerOfMass;
         }
+ 
         return rval;
     }
 
@@ -1002,7 +1010,8 @@
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
             const Ogre::Real mass,
-            Ogre::Vector3* inertia)
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass)
     {
         Ogre::Vector3 size = aabb.getSize();
         // set the size x/z values to the maximum
@@ -1025,13 +1034,21 @@
             PhysicsManager::getSingleton()._getNewtonWorld(),
             s, *orientation, *offset));
 
-        if (inertia)
+
+        if (inertia != NULL || centerOfMass != NULL )
         {
-            Vector3 inert_offs=Vector3::ZERO;
-            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
-            *inertia *= mass;
+            Vector3 temp_inertia, temp_centerOfMass;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+            dynamic_cast&lt;OgreNewt::ConvexCollisionPtr&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
+            if( inertia )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass )
+                *centerOfMass = temp_centerOfMass;
         }
-
+ 
         return rval;
     }
 
@@ -1039,7 +1056,8 @@
             Ogre::Vector3* offset,
             Ogre::Quaternion* orientation,
             const Ogre::Real mass,
-            Ogre::Vector3* inertia)
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass)
     {
         Ogre::Vector3 size = aabb.getSize();
         // positional offset of the collision primitiv
@@ -1060,16 +1078,26 @@
 
         // an capsule primitiv has got its coordinate system at its center, so shift it with radius
         // additionally it is x axis aligned, so rotate it 90 degrees around z axis
-        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Capsule(
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Capsule(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             radius, height, *orientation, *offset));
 
-        if (inertia)
+
+        if (inertia != NULL || centerOfMass != NULL )
         {
-            Vector3 inert_offs=Vector3::ZERO;
-            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
-            *inertia *= mass;
+            Vector3 temp_inertia, temp_centerOfMass;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#else
+            dynamic_cast&lt;OgreNewt::ConvexCollisionPtr&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+#endif
+            if( inertia )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass )
+                *centerOfMass = temp_centerOfMass;
         }
+ 
+ 
         return rval;
     }
 }

Modified: rl/branches/persistence2/engine/core/src/PhysicsMaterialRaycast.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicsMaterialRaycast.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/src/PhysicsMaterialRaycast.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -186,7 +186,7 @@
     }
 
     ConvexcastInfo PhysicsMaterialConvexcast::execute(OgreNewt::World* world, const OgreNewt::MaterialID* material,
-                        const OgreNewt::Collision *col, const Vector3&amp; startpt, const Quaternion &amp;ori,
+                        const OgreNewt::ConvexCollisionPtr&amp; col, const Vector3&amp; startpt, const Quaternion &amp;ori,
                         const Vector3&amp; endpt, bool invertmat)
     {
         mMaterialVector = NULL;
@@ -201,7 +201,7 @@
     }
 
     ConvexcastInfo PhysicsMaterialConvexcast::execute(OgreNewt::World* world, const MaterialVector* materials,
-                        const OgreNewt::Collision *col, const Vector3&amp; startpt, const Quaternion &amp;ori,
+                        const OgreNewt::ConvexCollisionPtr&amp; col, const Vector3&amp; startpt, const Quaternion &amp;ori,
                         const Vector3&amp; endpt, bool invertmat)
     {
         mMaterialVector = materials;

Modified: rl/branches/persistence2/engine/core/src/PhysicsRagDoll.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicsRagDoll.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/src/PhysicsRagDoll.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -35,7 +35,11 @@
 	mParent = parent;
 	mOgreBone = ogreBone;
 
-	OgreNewt::ConvexCollision* col = NULL;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+	OgreNewt::ConvexCollisionPtr col;
+#else
+	OgreNewt::ConvexCollisionPtr col = NULL;
+#endif
 
 	// in the case of the cylindrical primitives, they need to be rotated to align the main axis with the direction vector.
 	Ogre::Quaternion orient = Ogre::Quaternion::IDENTITY;
@@ -59,23 +63,23 @@
 	switch (shape)
 	{
 	case PhysicsRagDoll::RagBone::BS_BOX:
-		col = new OgreNewt::CollisionPrimitives::Box( world, size );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CAPSULE:
-		col = new OgreNewt::CollisionPrimitives::Capsule( world, size.y, size.x, orient, pos );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Capsule( world, size.y, size.x, orient, pos ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CONE:
-		col = new OgreNewt::CollisionPrimitives::Cone( world, size.y, size.x, orient, pos );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cone( world, size.y, size.x, orient, pos ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CYLINDER:
-		col = new OgreNewt::CollisionPrimitives::Cylinder( world, size.y, size.x, orient, pos );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder( world, size.y, size.x, orient, pos ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_ELLIPSOID:
-		col = new OgreNewt::CollisionPrimitives::Ellipsoid( world, size );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( world, size ));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CONVEXHULL:
@@ -83,7 +87,7 @@
 		break;
 
 	default:
-		col = new OgreNewt::CollisionPrimitives::Box( world, size );
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size ));
 		break;
 	}
 
@@ -91,12 +95,16 @@
     {
         if( col-&gt;getNewtonCollision() == NULL )
         {
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+            col.reset();
+#else
             delete col;
             col = NULL;
+#endif
         }
     }
 
-    if( col == NULL )
+    if( !col )
     {
         LOG_WARNING(Logger::CORE, &quot; error creating collision for '&quot; + ogreBone-&gt;getName() + &quot;', still continuing.&quot;);
         mBody = NULL;
@@ -104,7 +112,11 @@
     else
     {
     	mBody = new OgreNewt::Body( world, col );
+#ifdef OGRENEWT_USE_OGRE_ANY
+        mBody-&gt;setUserData( Ogre::Any(parentActor) );
+#else
 	    mBody-&gt;setUserData( parentActor );
+#endif
     	mBody-&gt;setStandardForceCallback();
         const OgreNewt::MaterialID* ragdollMat = PhysicsManager::getSingleton().createMaterialID(&quot;default&quot;);
         mBody-&gt;setMaterialGroupID(ragdollMat);
@@ -134,7 +146,11 @@
 
 void PhysicsRagDoll::RagBone::_hingeCallback( OgreNewt::BasicJoints::Hinge* me )
 {
-	PhysicsRagDoll::RagBone* bone = (PhysicsRagDoll::RagBone*)me-&gt;getUserData();
+#ifdef OGRENEWT_USE_OGRE_ANY
+    PhysicsRagDoll::RagBone* bone = Ogre::any_cast&lt;PhysicsRagDoll::RagBone*&gt;(me-&gt;getUserData());
+#else
+    PhysicsRagDoll::RagBone* bone = static_cast&lt;PhysicsRagDoll::RagBone*&gt;(me-&gt;getUserData());
+#endif
 
 	Ogre::Degree angle = me-&gt;getJointAngle();
 	Ogre::Degree lim1( bone-&gt;getLimit1() );
@@ -155,7 +171,7 @@
 }
 
 
-OgreNewt::ConvexCollision* PhysicsRagDoll::RagBone::_makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight )
+OgreNewt::ConvexCollisionPtr PhysicsRagDoll::RagBone::_makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight )
 {
 	std::vector&lt; Ogre::Vector3 &gt; vertexVector;
 
@@ -245,9 +261,13 @@
 	}
 
 	//////////////////////////////////////////////////////////////////////////////////
-    OgreNewt::ConvexCollision* col = NULL;
+#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
+    OgreNewt::ConvexCollisionPtr col;
+#else
+    OgreNewt::ConvexCollisionPtr col = NULL;
+#endif
     if( numVerts &gt; 0 )
-    	col = new OgreNewt::CollisionPrimitives::ConvexHull( world, verts, numVerts );
+    	col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull( world, verts, numVerts ));
 
 	delete []verts;
 
@@ -444,7 +464,11 @@
 	case PhysicsRagDoll::JT_HINGE:
 		joint = new OgreNewt::BasicJoints::Hinge( world, child-&gt;getBody(), parent-&gt;getBody(), pos, pin );
 		((OgreNewt::BasicJoints::Hinge*)joint)-&gt;setCallback( RagBone::_hingeCallback );
+#ifdef OGRENEWT_USE_OGRE_ANY
+		joint-&gt;setUserData( Ogre::Any(child) );
+#else
 		joint-&gt;setUserData( child );
+#endif
 		child-&gt;setLimits( limit1, limit2 );
 		break;
 	}
@@ -454,7 +478,11 @@
 
 void PhysicsRagDoll::_placementCallback( OgreNewt::Body* me, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos, int threadindex )
 {
+#ifdef OGRENEWT_USE_OGRE_ANY
+    Actor* parentActor = Ogre::any_cast&lt;Actor*&gt;(me-&gt;getUserData());
+#else
     Actor* parentActor = static_cast&lt;Actor*&gt;(me-&gt;getUserData());
+#endif
 	PhysicsRagDoll* doll = parentActor-&gt;getPhysicalThing()-&gt;getRagDoll();
     PhysicsRagDoll::RagBoneMapIterator it = doll-&gt;mRagBonesMap.find(me);
     if( it == doll-&gt;mRagBonesMap.end() )

Modified: rl/branches/persistence2/engine/core/src/SceneQuery.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/SceneQuery.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/core/src/SceneQuery.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -116,7 +116,11 @@
                 if (mLevelOcclusion &amp;&amp; (body-&gt;getMaterialGroupID() == levelId)) break;
 
                 // Add actor to this body to the result
+#ifdef OGRENEWT_USE_OGRE_ANY
+                Actor* actor = Ogre::any_cast&lt;Actor*&gt;(body-&gt;getUserData());
+#else
                 Actor* actor = static_cast&lt;Actor*&gt;(body-&gt;getUserData());
+#endif
                 if (actor != NULL) mResult.push_back(actor);
             }
         }

Modified: rl/branches/persistence2/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/CreatureController.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/rules/src/CreatureController.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -80,8 +80,8 @@
 
         mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;setPhysicsController(this);
 
-//        mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;setAngularDamping(0*Vector3::UNIT_SCALE);
-        mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;setContinuousCollisionMode(1);
+        //mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;setAngularDamping(0*Vector3::UNIT_SCALE);
+        //mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;setContinuousCollisionMode(1);
 
 
         std::pair&lt;MovementType, AbstractMovement*&gt; movementPair;
@@ -407,11 +407,12 @@
 
         Vector3 charPos;
         Quaternion charOri;
-        mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getPositionOrientation(charPos, charOri);
+        OgreNewt::Body* charBody = mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
+        charBody-&gt;getPositionOrientation(charPos, charOri);
         bool isFloorCollision(false);
 
-        AxisAlignedBox CharAab = mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getCollision()-&gt;getAABB();
-        Real charHeight = CharAab.getMaximum().y - CharAab.getMinimum().y;
+        AxisAlignedBox charAab = charBody-&gt;getCollision()-&gt;getAABB();
+        Real charHeight = charAab.getMaximum().y - charAab.getMinimum().y;
         Real stepHeight = point.y - charPos.y;
 
         if( stepHeight &lt; charHeight/2 )
@@ -426,6 +427,17 @@
                 mLastFloorContact = time;
             }
         }
+
+        // set contact direction to point to the center of mass
+        contact.setNormalDirection((charPos + charBody-&gt;getCenterOfMass() - point).normalisedCopy());
+        contact.setNormalAcceleration(0);
+        // no friction
+        contact.setFrictionState(0,0);
+        contact.setFrictionState(0,1);
+        contact.setTangentAcceleration(0,0);
+        contact.setTangentAcceleration(0,1);
+
+
 /*
 //        setContactNormalDirection(((Vector3::UNIT_Y.dotProduct(point-charPos)*Vector3::UNIT_Y + charPos) - point).normalisedCopy());
         setContactNormalDirection(point - (charPos + charHeight/2));
@@ -434,8 +446,8 @@
         setContactFrictionState(0,1);
         setContactTangentAcceleration(0, 0);
         setContactTangentAcceleration(0, 1);
+*/
 
-*/
 //std::ostringstream oss;
 //Vector3 vec1, vec2;
 //oss &lt;&lt; &quot; Collision: Point: &quot; &lt;&lt; point-charPos;
@@ -448,10 +460,10 @@
 //oss &lt;&lt; &quot;  \t Tangent-Directions: &quot; &lt;&lt; vec1 &lt;&lt; &quot; &quot; &lt;&lt; vec2;
 //LOG_MESSAGE(Logger::RULES, oss.str());
 
-        contact.rotateTangentDirections(/*charOri*mDirection + */Vector3::UNIT_Y);
-        contact.setFrictionState(1,0);
-        contact.setFrictionState(0,1);
-
+//        contact.rotateTangentDirections(/*charOri*mDirection + */Vector3::UNIT_Y);
+//        contact.setFrictionState(0,0);
+//        contact.setFrictionState(0,1);
+/*
         if( stepHeight &lt; 0.4 )
         {
             if(stepHeight &gt; 0.01f) // experimantal value, 
@@ -485,6 +497,7 @@
                 //setContactFrictionState(0,1);
             }
         }
+*/
 }
 
         if(mMovement != NULL)

Modified: rl/branches/persistence2/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/CreatureControllerManager.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/rules/src/CreatureControllerManager.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -166,7 +166,11 @@
 
     void CreatureControllerManager::userProcess(OgreNewt::ContactJoint &amp;contactJoint, Real timestep, int threadid)
     {
+#ifdef OGRENEWT_USE_OGRE_ANY
+        Actor *actor = Ogre::any_cast&lt;Actor*&gt;(contactJoint.getBody0()-&gt;getUserData());
+#else
         Actor *actor = static_cast&lt;Actor*&gt;(contactJoint.getBody0()-&gt;getUserData());
+#endif
         if( actor != NULL )
         {
             ControllerMap::const_iterator it = mControllers.find(static_cast&lt;Creature*&gt;(actor-&gt;getGameObject()));
@@ -178,7 +182,11 @@
         }
 
         // if the controlled body is the second body...
-        actor = static_cast&lt;Actor*&gt;(contactJoint.getBody1()-&gt;getUserData());
+#ifdef OGRENEWT_USE_OGRE_ANY
+        actor = Ogre::any_cast&lt;Actor*&gt;(contactJoint.getBody0()-&gt;getUserData());
+#else
+        actor = static_cast&lt;Actor*&gt;(contactJoint.getBody0()-&gt;getUserData());
+#endif
         if( actor != NULL )
         {
             ControllerMap::const_iterator it = mControllers.find(static_cast&lt;Creature*&gt;(actor-&gt;getGameObject()));

Modified: rl/branches/persistence2/engine/rules/src/SelectionHelper.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/SelectionHelper.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/rules/src/SelectionHelper.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -84,7 +84,11 @@
             OgreNewt::Body* body = info.mBody;
             if (body != NULL)
             {
+#ifdef OGRENEWT_USE_OGRE_ANY
+                Actor* hitActor = Ogre::any_cast&lt;Actor*&gt;(body-&gt;getUserData());
+#else
                 Actor* hitActor = static_cast&lt;Actor*&gt;(body-&gt;getUserData());
+#endif
                 isVisible = hitActor == actor2 || hitActor == actor1;
                 if (!isVisible) break;
             }

Modified: rl/branches/persistence2/engine/script/src/EntityNodeProcessor.cpp
===================================================================
--- rl/branches/persistence2/engine/script/src/EntityNodeProcessor.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/script/src/EntityNodeProcessor.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -43,13 +43,13 @@
 
         Ogre::String entName = getAttributeValueAsStdString(nodeElem, &quot;name&quot;);
 
-        LOG_DEBUG(Logger::RULES,
+        LOG_DEBUG(Logger::SCRIPT,
             &quot;Processing entity node &quot;
                 + entName);
 
         if (!hasAttribute(nodeElem, &quot;meshfile&quot;))
         {
-            LOG_ERROR(Logger::RULES, &quot;Entity node defines no meshfile attribute&quot;);
+            LOG_ERROR(Logger::SCRIPT, &quot;Entity node defines no meshfile attribute&quot;);
             return false;
         }
 
@@ -73,7 +73,7 @@
         }
         else
         {
-            LOG_WARNING(Logger::RULES, &quot;No position given for entity, used (0,0,0)&quot;);
+            LOG_WARNING(Logger::SCRIPT, &quot;No position given for entity, used (0,0,0)&quot;);
         }
 
         DOMElement* oriElem = getChildNamed(nodeElem, &quot;rotation&quot;);
@@ -83,7 +83,7 @@
         }
         else
         {
-            LOG_WARNING(Logger::RULES, &quot;No orientation given for entity, used Identity&quot;);
+            LOG_WARNING(Logger::SCRIPT, &quot;No orientation given for entity, used Identity&quot;);
         }
 
         ///@todo static geometry groups
@@ -108,11 +108,11 @@
             newEnt = CoreSubsystem::getSingleton().getWorld()
                         -&gt;getSceneManager()-&gt;createEntity(entName, meshFile);
 
-            LOG_DEBUG(Logger::RULES, &quot; Loaded meshfile &quot;+meshFile);
+            LOG_DEBUG(Logger::SCRIPT, &quot; Loaded meshfile &quot;+meshFile);
         }
         catch(...)
         {
-	        LOG_ERROR(Logger::RULES, &quot; Entity '&quot;+meshFile+&quot;' mit dem Namen '&quot;+entName+&quot;' konnte nicht geladen werden.&quot;);
+	        LOG_ERROR(Logger::SCRIPT, &quot; Entity '&quot;+meshFile+&quot;' mit dem Namen '&quot;+entName+&quot;' konnte nicht geladen werden.&quot;);
             return false;
         }
 
@@ -141,6 +141,62 @@
 
     void EntityNodeProcessor::createCollision(Entity* entity, Ogre::String meshName, DOMElement* physicsProxyElem)
 	{
+        Ogre::String physicsProxyTypeAsString;
+        if (physicsProxyElem == NULL || !hasAttribute(physicsProxyElem, &quot;type&quot;))
+        {
+            physicsProxyTypeAsString = &quot;auto&quot;;
+        }
+        else
+        {
+            physicsProxyTypeAsString = getAttributeValueAsStdString(physicsProxyElem, &quot;type&quot;);
+        }
+
+
+
+        if (physicsProxyTypeAsString == &quot;custom&quot;)
+        {
+            ///@todo create physics proxy from custom collision primitives which are defined in children elements of &lt;code&gt;physicsProxyElem&lt;code&gt;
+        }
+        else if (physicsProxyTypeAsString == &quot;none&quot;)
+        {
+            LOG_DEBUG(Logger::SCRIPT, &quot;No physics proxy for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
+        }
+        else
+        {
+            GeometryType physicsProxyType = PhysicsManager::getSingleton().convertStringToGeometryType(physicsProxyTypeAsString);
+            if( physicsProxyType == GT_NONE )
+            {
+                // auto -&gt; mesh
+                if (physicsProxyTypeAsString == &quot;auto&quot;)
+                    physicsProxyType = GT_MESH;
+                
+                if (physicsProxyTypeAsString == &quot;custom&quot;)
+                {
+                    ///@todo create physics proxy from custom collision primitives which are defined in children elements of &lt;code&gt;physicsProxyElem&lt;code&gt;
+                    LOG_WARNING(Logger::SCRIPT, &quot;Physics proxy type 'custom' is not yet implemented.&quot;);
+                }
+                else if ( physicsProxyType != GT_NONE )
+                {
+                    OgreNewt::CollisionPtr collision = PhysicsManager::getSingleton().createCollision(entity, physicsProxyType);
+                    if (collision)
+                    {
+                        LOG_DEBUG(Logger::SCRIPT, &quot;Created physics proxy type '&quot; + physicsProxyTypeAsString + &quot;' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
+                        std::vector&lt;OgreNewt::CollisionPtr&gt; collisionVector;
+                        collisionVector.push_back(collision);
+                        PhysicsManager::getSingleton().addLevelGeometry(entity, collisionVector);
+                    }
+                }
+                else
+                {
+                    LOG_ERROR(Logger::SCRIPT,
+                            &quot;Physics proxy type '&quot; + physicsProxyTypeAsString + &quot;' of entity '&quot;+entity-&gt;getName()+&quot;' is unknown.&quot;);
+                    return;
+                }
+            }
+
+                
+        }
+/*
         std::vector&lt;OgreNewt::CollisionPtr&gt; collisions;
 
         Ogre::String physicsProxyType;
@@ -164,7 +220,7 @@
         }
         else if (physicsProxyType == &quot;none&quot;)
         {
-            LOG_DEBUG(Logger::RULES, &quot;No physics proxy for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
+            LOG_DEBUG(Logger::SCRIPT, &quot;No physics proxy for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
         }
         else
         {
@@ -185,7 +241,7 @@
                 if (size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH)
                     size.z = PhysicsManager::NEWTON_GRID_WIDTH;
 
-                LOG_MESSAGE(Logger::RULES, &quot;Entity '&quot;+entity-&gt;getName()+&quot;' is planar, using 'box' as instead of '&quot;+physicsProxyType+&quot;'.&quot;);
+                LOG_MESSAGE(Logger::SCRIPT, &quot;Entity '&quot;+entity-&gt;getName()+&quot;' is planar, using 'box' as instead of '&quot;+physicsProxyType+&quot;'.&quot;);
                 forceBox = true;
             }
             const Quaternion orientation(0,0,0,0);// = parentNode-&gt;getOrientation();
@@ -199,7 +255,7 @@
                 (!forceBox)) // sicherheitshalber
             {
                 collision = aucol.ColPtr;
-                LOG_DEBUG(Logger::RULES, &quot; Reused physical body for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
+                LOG_DEBUG(Logger::SCRIPT, &quot; Reused physical body for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
             }
             else
             {
@@ -207,13 +263,13 @@
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
                                      thisWorld, size, orientation, pos));
-                    LOG_DEBUG(Logger::RULES, &quot;Created physics proxy type 'box' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
+                    LOG_DEBUG(Logger::SCRIPT, &quot;Created physics proxy type 'box' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
                 }
                 else if (physicsProxyType == &quot;pyramid&quot;)
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Pyramid(
                                     thisWorld, size, orientation, pos));
-                    LOG_DEBUG(Logger::RULES, &quot;Created physics proxy type 'pyramid' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
+                    LOG_DEBUG(Logger::SCRIPT, &quot;Created physics proxy type 'pyramid' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
                 }
                 else if (physicsProxyType == &quot;sphere&quot;)
                 {
@@ -221,7 +277,7 @@
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
                                     thisWorld, Vector3(radius, radius, radius),
                                     orientation, pos));
-                    LOG_DEBUG(Logger::RULES, &quot;Created physics proxy type 'sphere' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
+                    LOG_DEBUG(Logger::SCRIPT, &quot;Created physics proxy type 'sphere' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
                 }
                 else if (physicsProxyType == &quot;ellipsoid&quot;)
                 {
@@ -232,7 +288,7 @@
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
                                     thisWorld, s,
                                     orientation, pos));
-                    LOG_DEBUG(Logger::RULES, &quot;Created physics proxy type 'ellipsoid' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
+                    LOG_DEBUG(Logger::SCRIPT, &quot;Created physics proxy type 'ellipsoid' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
                 }
                 else if (physicsProxyType == &quot;capsule&quot;)
                 {
@@ -244,24 +300,24 @@
                                     radius,
                                     height,
                                     orientation, pos));
-                    LOG_DEBUG(Logger::RULES, &quot;Created physics proxy type 'capsule' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
+                    LOG_DEBUG(Logger::SCRIPT, &quot;Created physics proxy type 'capsule' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
                 }
                 else if (physicsProxyType == &quot;convexhull&quot;)
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
                                     thisWorld,
                                     entity));
-                    LOG_DEBUG(Logger::RULES, &quot;Created physics proxy type 'convexhull' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
+                    LOG_DEBUG(Logger::SCRIPT, &quot;Created physics proxy type 'convexhull' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
                 }
                 else if (physicsProxyType == &quot;mesh&quot; || physicsProxyType == &quot;auto&quot;)
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
                                     thisWorld, entity, true));
-                    LOG_DEBUG(Logger::RULES, &quot;Created physics proxy type 'mesh' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
+                    LOG_DEBUG(Logger::SCRIPT, &quot;Created physics proxy type 'mesh' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
                 }
                 else
                 {
-                    LOG_ERROR(Logger::RULES,
+                    LOG_ERROR(Logger::SCRIPT,
                         &quot;Physics proxy type '&quot;+physicsProxyType+&quot;' of entity '&quot;+entity-&gt;getName()+&quot;' is unknown.&quot;);
                     return;
                 }
@@ -282,9 +338,10 @@
         if (collisions.size() &gt; 0)
         {
             PhysicsManager::getSingleton().addLevelGeometry(entity, collisions);
-            LOG_DEBUG(Logger::RULES, &quot; Entity '&quot;+entity-&gt;getName()+&quot;' in levelGeometry geladen&quot;);
+            LOG_DEBUG(Logger::SCRIPT, &quot; Entity '&quot;+entity-&gt;getName()+&quot;' in levelGeometry geladen&quot;);
         }
-	}
+*/
+    }
 
 	void EntityNodeProcessor::processAnimation(Ogre::Entity* entity, DOMElement *animationElem)
 	{

Modified: rl/branches/persistence2/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/branches/persistence2/engine/script/src/PlaneNodeProcessor.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/script/src/PlaneNodeProcessor.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -148,7 +148,8 @@
 			const Quaternion orientation(0,0,0,0);// = parentNode-&gt;getOrientation();
 			const Ogre::Vector3 pos = aab.getMinimum() * parentNode-&gt;getScale() + (size/2.0);
 
-			collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(world, size, orientation, pos));
+			//collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(world, size, orientation, pos));
+            collision = PhysicsManager::getSingleton().createCollision(entity, GT_BOX, &quot;&quot;, NULL, NULL, 0, NULL, NULL, true);
 
 			if ( collision != NULL )
 			{

Modified: rl/branches/persistence2/engine/ui/include/MovementControlState.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/MovementControlState.h	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/ui/include/MovementControlState.h	2009-04-11 10:34:44 UTC (rev 4893)
@@ -126,7 +126,7 @@
 
         PhysicsMaterialRaycast* mRaycast;
         PhysicsMaterialConvexcast * mConvexcast;
-        OgreNewt::Collision *mCameraCastCollision;
+        OgreNewt::ConvexCollisionPtr mCameraCastCollision;
         HalfSphereSelector mSelector;
         HalfSphereSelector mCombatSelector;
 

Modified: rl/branches/persistence2/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/CombatControlState.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/ui/src/CombatControlState.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -110,7 +110,6 @@
         PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;));
         mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
         mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(this);
-        mCameraActor-&gt;getPhysicalThing()-&gt;setUpConstraint(Vector3::ZERO);
         
         // We also handle cam&lt;-&gt;level, cam&lt;-&gt;default cam&lt;-&gt;char collision from now on
         OgreNewt::MaterialPair* mat_pair = NULL;

Modified: rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -63,11 +63,12 @@
     void FreeflightControlState::pause()
     {
 		mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
-		//mCharacterActor-&gt;getPhysicalThing()-&gt;unfreeze();
+		mCharacterActor-&gt;getPhysicalThing()-&gt;unfreeze();
+
+// for testing the OgreNewt player controller
 //        delete mOgreNewtPlayerController;
 
         mOgreNewtPlayerController = NULL;
-        mCharacterActor-&gt;getPhysicalThing()-&gt;setUpConstraint();
         mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
 
         // Char&lt;-&gt;Level collision back to default
@@ -86,8 +87,9 @@
     void FreeflightControlState::resume()
     {
         mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
-		//mCharacterActor-&gt;getPhysicalThing()-&gt;freeze();
-        mCharacterActor-&gt;getPhysicalThing()-&gt;clearUpConstraint();
+		mCharacterActor-&gt;getPhysicalThing()-&gt;freeze();
+
+// for testing the OgreNewt player controller
 //        mOgreNewtPlayerController = new OgreNewt::PlayerController(mCharBody);
 
         resetCamera();
@@ -352,8 +354,11 @@
             Vector3 currentVel = body-&gt;getVelocity();
             Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep();
             Vector3 force = mass*(orientation * mDesiredVelocity - currentVel) / delay;
-if( mCollisionsEnabled )
-    force = mass*(- currentVel) / delay;
+
+// for testing the OgreNewt player controller
+//if( mCollisionsEnabled )
+//    force = mass*(- currentVel) / delay;
+
             body-&gt;setForce(force);
         }
     }

Modified: rl/branches/persistence2/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/MovementControlState.cpp	2009-04-10 14:05:26 UTC (rev 4892)
+++ rl/branches/persistence2/engine/ui/src/MovementControlState.cpp	2009-04-11 10:34:44 UTC (rev 4893)
@@ -87,7 +87,9 @@
         mViewMode(VM_THIRD_PERSON),
         mRaycast(new PhysicsMaterialRaycast()),
         mConvexcast(new PhysicsMaterialConvexcast()),
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
         mCameraCastCollision(NULL),
+#endif
         mSelector(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager()),
         mCombatSelector(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager(),
             QUERYFLAG_CREATURE),
@@ -158,7 +160,7 @@
             }
         }
         //! TODO: remove this workaround (newton-bug: &quot;spheres don't cast&quot;!)
-        mCameraCastCollision = new OgreNewt::CollisionPrimitives::ConvexHull(mCamBody-&gt;getWorld(), verts, 80);
+        mCameraCastCollision = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(mCamBody-&gt;getWorld(), verts, 80));
         //mCameraCastCollision = new OgreNewt::CollisionPrimitives::Ellipsoid(mCamBody-&gt;getWorld(), Vector3::UNIT_SCALE * camRadius);
     }
 
@@ -171,7 +173,9 @@
         mSelector.setFilter(NULL);
         delete mRaycast;
         delete mConvexcast;
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
         delete mCameraCastCollision;
+#endif
 
         if (DebugWindow::getSingletonPtr())
         {
@@ -240,7 +244,6 @@
             PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;));
         mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
         mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(this);
-        mCameraActor-&gt;getPhysicalThing()-&gt;setUpConstraint(Vector3::ZERO);
 
         // We also handle cam&lt;-&gt;level, cam&lt;-&gt;default cam&lt;-&gt;char collision from now on
         OgreNewt::MaterialPair* mat_pair = NULL;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001949.html">[Dsa-hl-svn] r4892 - in rl/trunk/editors/Lockenwickler: . src
</A></li>
	<LI>Next message: <A HREF="001951.html">[Dsa-hl-svn] r4894 - rl/branches/persistence2/engine/common/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1950">[ date ]</a>
              <a href="thread.html#1950">[ thread ]</a>
              <a href="subject.html#1950">[ subject ]</a>
              <a href="author.html#1950">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
