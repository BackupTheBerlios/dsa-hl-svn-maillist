<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4879 - in rl/branches/persistence2: .	Mac/Rastullah.xcodeproj editors/Lockenwickler	editors/Lockenwickler/_eric4project editors/Lockenwickler/src	editors/Lockenwickler/src/media	editors/Lockenwickler/src/media/icons engine/ai	engine/ai/include engine/ai/include/OpenSteer engine/ai/src	engine/ai/src/OpenSteer engine/common engine/common/include	engine/common/src engine/core engine/core/include	engine/core/src engine/rules engine/rules/include	engine/rules/src engine/script engine/script/swig	engine/startup engine/ui engine/ui/include engine/ui/src	tests tests/dialogtests tools
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4879%20-%20in%20rl/branches/persistence2%3A%20.%0A%09Mac/Rastullah.xcodeproj%20editors/Lockenwickler%0A%09editors/Lockenwickler/_eric4project%20editors/Lockenwickler/src%0A%09editors/Lockenwickler/src/media%0A%09editors/Lockenwickler/src/media/icons%20engine/ai%0A%09engine/ai/include%20engine/ai/include/OpenSteer%20engine/ai/src%0A%09engine/ai/src/OpenSteer%20engine/common%20engine/common/include%0A%09engine/common/src%20engine/core%20engine/core/include%0A%09engine/core/src%20engine/rules%20engine/rules/include%0A%09engine/rules/src%20engine/script%20engine/script/swig%0A%09engine/startup%20engine/ui%20engine/ui/include%20engine/ui/src%0A%09tests%20tests/dialogtests%20tools&In-Reply-To=%3C200904012009.n31K9t2J003448%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001935.html">
   <LINK REL="Next"  HREF="001937.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4879 - in rl/branches/persistence2: .	Mac/Rastullah.xcodeproj editors/Lockenwickler	editors/Lockenwickler/_eric4project editors/Lockenwickler/src	editors/Lockenwickler/src/media	editors/Lockenwickler/src/media/icons engine/ai	engine/ai/include engine/ai/include/OpenSteer engine/ai/src	engine/ai/src/OpenSteer engine/common engine/common/include	engine/common/src engine/core engine/core/include	engine/core/src engine/rules engine/rules/include	engine/rules/src engine/script engine/script/swig	engine/startup engine/ui engine/ui/include engine/ui/src	tests tests/dialogtests tools</H1>
    <B>timm at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4879%20-%20in%20rl/branches/persistence2%3A%20.%0A%09Mac/Rastullah.xcodeproj%20editors/Lockenwickler%0A%09editors/Lockenwickler/_eric4project%20editors/Lockenwickler/src%0A%09editors/Lockenwickler/src/media%0A%09editors/Lockenwickler/src/media/icons%20engine/ai%0A%09engine/ai/include%20engine/ai/include/OpenSteer%20engine/ai/src%0A%09engine/ai/src/OpenSteer%20engine/common%20engine/common/include%0A%09engine/common/src%20engine/core%20engine/core/include%0A%09engine/core/src%20engine/rules%20engine/rules/include%0A%09engine/rules/src%20engine/script%20engine/script/swig%0A%09engine/startup%20engine/ui%20engine/ui/include%20engine/ui/src%0A%09tests%20tests/dialogtests%20tools&In-Reply-To=%3C200904012009.n31K9t2J003448%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4879 - in rl/branches/persistence2: .	Mac/Rastullah.xcodeproj editors/Lockenwickler	editors/Lockenwickler/_eric4project editors/Lockenwickler/src	editors/Lockenwickler/src/media	editors/Lockenwickler/src/media/icons engine/ai	engine/ai/include engine/ai/include/OpenSteer engine/ai/src	engine/ai/src/OpenSteer engine/common engine/common/include	engine/common/src engine/core engine/core/include	engine/core/src engine/rules engine/rules/include	engine/rules/src engine/script engine/script/swig	engine/startup engine/ui engine/ui/include engine/ui/src	tests tests/dialogtests tools">timm at mail.berlios.de
       </A><BR>
    <I>Wed Apr  1 22:09:55 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001935.html">[Dsa-hl-svn] r4878 - in rl/trunk/engine: ai/src core script/src
</A></li>
        <LI>Next message: <A HREF="001937.html">[Dsa-hl-svn] r4880 - content/textures
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1936">[ date ]</a>
              <a href="thread.html#1936">[ thread ]</a>
              <a href="subject.html#1936">[ subject ]</a>
              <a href="author.html#1936">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: timm
Date: 2009-04-01 22:08:44 +0200 (Wed, 01 Apr 2009)
New Revision: 4879

Added:
   rl/branches/persistence2/Rastullah2008.sln
   rl/branches/persistence2/editors/Lockenwickler/src/DepthBuffer.py
   rl/branches/persistence2/editors/Lockenwickler/src/ZoneManager.py
   rl/branches/persistence2/editors/Lockenwickler/src/media/depthmap.frag
   rl/branches/persistence2/editors/Lockenwickler/src/media/icons/14_layer_invisible.png
   rl/branches/persistence2/editors/Lockenwickler/src/media/icons/14_layer_visible.png
   rl/branches/persistence2/editors/Lockenwickler/src/media/icons/dissociatecell.png
   rl/branches/persistence2/engine/ai/RlAI2008.vcproj
   rl/branches/persistence2/engine/ai/include/OpenSteer/
   rl/branches/persistence2/engine/ai/include/OpenSteer/AbstractVehicle.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Color.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/LocalSpace.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Obstacle.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Path.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Pathway.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPath.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Proximity.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlike.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPath.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPathway.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/StandardTypes.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/SteerLibrary.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/UnusedParameter.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Utilities.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3Utilities.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/lq.h
   rl/branches/persistence2/engine/ai/src/OpenSteer/
   rl/branches/persistence2/engine/ai/src/OpenSteer/Color.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/Obstacle.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/Path.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/Pathway.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPath.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPathway.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/Vec3.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/lq.c
   rl/branches/persistence2/engine/common/RlCommon2008.vcproj
   rl/branches/persistence2/engine/core/RlCore2008.vcproj
   rl/branches/persistence2/engine/core/include/PhysicsRagDoll.h
   rl/branches/persistence2/engine/core/src/PhysicsRagDoll.cpp
   rl/branches/persistence2/engine/rules/RlRules2008.vcproj
   rl/branches/persistence2/engine/script/RlScript2008.vcproj
   rl/branches/persistence2/engine/script/swig/TypeRlGameObjectList.swig
   rl/branches/persistence2/engine/startup/RlStartup2008.vcproj
   rl/branches/persistence2/engine/ui/RlUI2008.vcproj
   rl/branches/persistence2/tests/dialogtests/
   rl/branches/persistence2/tests/dialogtests/Debug/
   rl/branches/persistence2/tests/dialogtests/Release/
   rl/branches/persistence2/tests/dialogtests/RlDialogTests.vcproj
   rl/branches/persistence2/tests/dialogtests/TestDialog.cpp
Removed:
   rl/branches/persistence2/editors/Lockenwickler/src/CodeDump.py
   rl/branches/persistence2/engine/ai/include/OpenSteer/AbstractVehicle.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Color.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/LocalSpace.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Obstacle.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Path.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Pathway.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPath.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Proximity.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlike.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPath.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPathway.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/StandardTypes.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/SteerLibrary.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/UnusedParameter.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Utilities.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3Utilities.h
   rl/branches/persistence2/engine/ai/include/OpenSteer/lq.h
   rl/branches/persistence2/engine/ai/src/OpenSteer/Color.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/Obstacle.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/Path.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/Pathway.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPath.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPathway.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/Vec3.cpp
   rl/branches/persistence2/engine/ai/src/OpenSteer/lq.c
   rl/branches/persistence2/tests/RlDialogTests/
   rl/branches/persistence2/tests/dialogtests/Debug/
   rl/branches/persistence2/tests/dialogtests/Release/
   rl/branches/persistence2/tests/dialogtests/RlDialogTests.vcproj
   rl/branches/persistence2/tests/dialogtests/TestDialog.cpp
Modified:
   rl/branches/persistence2/
   rl/branches/persistence2/CMakeLists.txt
   rl/branches/persistence2/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p
   rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
   rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
   rl/branches/persistence2/editors/Lockenwickler/src/ConsoleWindow.py
   rl/branches/persistence2/editors/Lockenwickler/src/GOIntEditor.py
   rl/branches/persistence2/editors/Lockenwickler/src/GOStringEditor.py
   rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py
   rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassManager.py
   rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py
   rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py
   rl/branches/persistence2/editors/Lockenwickler/src/MaterialSelectionDialog.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py
   rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py
   rl/branches/persistence2/editors/Lockenwickler/src/MovePivot.py
   rl/branches/persistence2/editors/Lockenwickler/src/MyRaySceneQueryListener.py
   rl/branches/persistence2/editors/Lockenwickler/src/NewModuleWizard.py
   rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyModel.py
   rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py
   rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py
   rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py
   rl/branches/persistence2/editors/Lockenwickler/src/Plugins-linux.cfg
   rl/branches/persistence2/editors/Lockenwickler/src/Plugins-windows.cfg
   rl/branches/persistence2/editors/Lockenwickler/src/Plugins.cfg
   rl/branches/persistence2/editors/Lockenwickler/src/PreferencesDialog.py
   rl/branches/persistence2/editors/Lockenwickler/src/Property.py
   rl/branches/persistence2/editors/Lockenwickler/src/PythonOgreConfig.py
   rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py
   rl/branches/persistence2/editors/Lockenwickler/src/Ui_NewModuleWizard.py
   rl/branches/persistence2/editors/Lockenwickler/src/media/Pivot_Point.material
   rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColorVP.glsl
   rl/branches/persistence2/editors/Lockenwickler/src/media/UniCube.mesh
   rl/branches/persistence2/editors/Lockenwickler/src/setup.py
   rl/branches/persistence2/editors/Lockenwickler/src/ui_ConsoleWindow.py
   rl/branches/persistence2/engine/ai/CMakeLists.txt
   rl/branches/persistence2/engine/ai/RlAI2005.vcproj
   rl/branches/persistence2/engine/ai/include/AgentCombatState.h
   rl/branches/persistence2/engine/ai/include/AgentDialogState.h
   rl/branches/persistence2/engine/ai/include/DialogElement.h
   rl/branches/persistence2/engine/ai/include/DialogLoaderImpl.h
   rl/branches/persistence2/engine/ai/include/DialogOption.h
   rl/branches/persistence2/engine/ai/include/DialogResponse.h
   rl/branches/persistence2/engine/ai/include/SteeringVehicle.h
   rl/branches/persistence2/engine/ai/src/AgentCombatState.cpp
   rl/branches/persistence2/engine/ai/src/AgentDialogState.cpp
   rl/branches/persistence2/engine/ai/src/DialogLoaderImpl.cpp
   rl/branches/persistence2/engine/ai/src/DialogOption.cpp
   rl/branches/persistence2/engine/ai/src/DialogResponse.cpp
   rl/branches/persistence2/engine/ai/src/SteeringVehicle.cpp
   rl/branches/persistence2/engine/common/include/FixRubyHeaders.h
   rl/branches/persistence2/engine/common/src/ConfigFile.cpp
   rl/branches/persistence2/engine/core/CMakeLists.txt
   rl/branches/persistence2/engine/core/RlCore2005.vcproj
   rl/branches/persistence2/engine/core/include/PhysicalThing.h
   rl/branches/persistence2/engine/core/include/PhysicsManager.h
   rl/branches/persistence2/engine/core/src/Actor.cpp
   rl/branches/persistence2/engine/core/src/ActorManager.cpp
   rl/branches/persistence2/engine/core/src/AnimationManager.cpp
   rl/branches/persistence2/engine/core/src/ConfigurationManager.cpp
   rl/branches/persistence2/engine/core/src/PhysicalThing.cpp
   rl/branches/persistence2/engine/core/src/PhysicsManager.cpp
   rl/branches/persistence2/engine/rules/CMakeLists.txt
   rl/branches/persistence2/engine/rules/RlRules2005.vcproj
   rl/branches/persistence2/engine/rules/include/Creature.h
   rl/branches/persistence2/engine/rules/include/GameObject.h
   rl/branches/persistence2/engine/rules/include/GoToJob.h
   rl/branches/persistence2/engine/rules/include/Selector.h
   rl/branches/persistence2/engine/rules/src/FetchItemJob.cpp
   rl/branches/persistence2/engine/rules/src/GoToJob.cpp
   rl/branches/persistence2/engine/rules/src/Selector.cpp
   rl/branches/persistence2/engine/script/CMakeLists.txt
   rl/branches/persistence2/engine/script/RlScript2005.vcproj
   rl/branches/persistence2/engine/script/swig/RlAi.swig
   rl/branches/persistence2/engine/script/swig/RlCore.swig
   rl/branches/persistence2/engine/script/swig/RlExports.i
   rl/branches/persistence2/engine/script/swig/RlRules.swig
   rl/branches/persistence2/engine/script/swig/TypeDynamicDirector.swig
   rl/branches/persistence2/engine/script/swig/TypeMaps.i
   rl/branches/persistence2/engine/startup/CMakeLists.txt
   rl/branches/persistence2/engine/startup/RlStartup2005.vcproj
   rl/branches/persistence2/engine/ui/CMakeLists.txt
   rl/branches/persistence2/engine/ui/RlUI2005.vcproj
   rl/branches/persistence2/engine/ui/include/DialogControlState.h
   rl/branches/persistence2/engine/ui/include/DialogController.h
   rl/branches/persistence2/engine/ui/src/CombatControlState.cpp
   rl/branches/persistence2/engine/ui/src/DialogControlState.cpp
   rl/branches/persistence2/engine/ui/src/DialogController.cpp
   rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp
   rl/branches/persistence2/engine/ui/src/InputManager.cpp
   rl/branches/persistence2/engine/ui/src/InventoryWindow.cpp
   rl/branches/persistence2/engine/ui/src/MainMenuWindow.cpp
   rl/branches/persistence2/engine/ui/src/MovementControlState.cpp
   rl/branches/persistence2/tools/copy_dependencies.bat
Log:
merged from trunk and made it compile


Property changes on: rl/branches/persistence2
___________________________________________________________________
Name: svn:ignore
   + logs
*.ncb
*.suo
rl_dist
*.obj
*.exp
*.lib
*.dll
*.idb
*.pdb
*.htm
*.ilk
*.asm
configure
dependencies
*.in
*.cfg
*.conf
configure
*.log
depcomp
config.guess
config.sub
ltmain.sh
rl.conf
Makefile
test
mkinstalldirs
config.status
rastullah.cfg
libtool
autom4te.cache
missing
*.m4
install-sh
_dependencies
depsources
doc
compile
.cproject
.dep.inc


Modified: rl/branches/persistence2/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/CMakeLists.txt	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/CMakeLists.txt	2009-04-01 20:08:44 UTC (rev 4879)
@@ -70,7 +70,6 @@
 FIND_PACKAGE(CEGUIOGRE 1.6 REQUIRED)
 FIND_PACKAGE(FMODEx REQUIRED)
 FIND_PACKAGE(OgreNewt 2.0 REQUIRED)
-FIND_PACKAGE(OpenSteer REQUIRED)
 FIND_PACKAGE(MeshMagick 0.5 REQUIRED)
 FIND_PACKAGE(Ruby REQUIRED)
 FIND_PACKAGE(Boost 1.34 REQUIRED filesystem)
@@ -81,8 +80,8 @@
 ENDIF(NOT SWIG_DIR MATCHES -rl$)
 
 # Compile settings for build types
-SET(CMAKE_CXX_FLAGS_DEBUG &quot;-O0 -g -DDEBUG&quot;)
-SET(CMAKE_CXX_FLAGS_RELWITHDEBINFO &quot;-O2 -g -DDEBUG&quot;)
+SET(CMAKE_CXX_FLAGS_DEBUG &quot;-O0 -g -D_DEBUG&quot;)
+SET(CMAKE_CXX_FLAGS_RELWITHDEBINFO &quot;-O2 -g -D_DEBUG&quot;)
 
 # Path options
 SET(BINDIR &quot;bin&quot; CACHE STRING &quot;Where to install binaries&quot;)

Modified: rl/branches/persistence2/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/branches/persistence2/Mac/Rastullah.xcodeproj/project.pbxproj	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/Mac/Rastullah.xcodeproj/project.pbxproj	2009-04-01 20:08:44 UTC (rev 4879)
@@ -429,6 +429,8 @@
 		44D8147A0BF7B62F00534175 /* Trigger.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814750BF7B62F00534175 /* Trigger.h */; };
 		44D8147B0BF7B62F00534175 /* Zone.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814760BF7B62F00534175 /* Zone.h */; };
 		44D8147C0BF7B62F00534175 /* ZoneManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814770BF7B62F00534175 /* ZoneManager.h */; };
+		483373810F65EBF4005979BF /* DialogController.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 483373800F65EBF4005979BF /* DialogController.cpp */; };
+		483373830F65EC01005979BF /* DialogController.h in Headers */ = {isa = PBXBuildFile; fileRef = 483373820F65EC01005979BF /* DialogController.h */; };
 		483646990D83D13700912FEC /* ContentLoader.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646960D83D13700912FEC /* ContentLoader.h */; };
 		4836469A0D83D13700912FEC /* SoundStitching.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646970D83D13700912FEC /* SoundStitching.h */; };
 		4836469B0D83D13700912FEC /* StartAnimationJob.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646980D83D13700912FEC /* StartAnimationJob.h */; };
@@ -1285,6 +1287,9 @@
 		44D814750BF7B62F00534175 /* Trigger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Trigger.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		44D814760BF7B62F00534175 /* Zone.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Zone.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		44D814770BF7B62F00534175 /* ZoneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZoneManager.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483373800F65EBF4005979BF /* DialogController.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DialogController.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483373820F65EC01005979BF /* DialogController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DialogController.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		483374130F6D275A005979BF /* TypeRlGameObjectList.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = TypeRlGameObjectList.swig; path = script/swig/TypeRlGameObjectList.swig; sourceTree = &quot;&lt;group&gt;&quot;; };
 		483646960D83D13700912FEC /* ContentLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ContentLoader.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		483646970D83D13700912FEC /* SoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundStitching.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		483646980D83D13700912FEC /* StartAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StartAnimationJob.h; sourceTree = &quot;&lt;group&gt;&quot;; };
@@ -1943,6 +1948,7 @@
 				48389BFB0D8677EE00AFAB66 /* TypeOgreVector3.swig */,
 				48389BFC0D8677EE00AFAB66 /* TypeRlCeGuiString.swig */,
 				48389BFD0D8677EE00AFAB66 /* TypeRlCeGuiStringVector.swig */,
+				483374130F6D275A005979BF /* TypeRlGameObjectList.swig */,
 				48389BFE0D8677EE00AFAB66 /* TypeRlProperty.swig */,
 				48389BFF0D8677EE00AFAB66 /* TypeRlPropertyKeys.swig */,
 				48389C000D8677EE00AFAB66 /* TypeStdPairIntInt.swig */,
@@ -2293,6 +2299,7 @@
 		48EFE0880E8B6822007EB7F8 /* Headers */ = {
 			isa = PBXGroup;
 			children = (
+				483373820F65EC01005979BF /* DialogController.h */,
 				48B006C60ECAC097008141C2 /* windows */,
 				444EAD010BD0E58C00C6D4A0 /* CeGuiHelper.h */,
 				4404DA850C48D037007B4657 /* stdinc.h */,
@@ -2320,6 +2327,7 @@
 		48EFE0890E8B6900007EB7F8 /* Source */ = {
 			isa = PBXGroup;
 			children = (
+				483373800F65EBF4005979BF /* DialogController.cpp */,
 				48B006C30ECABFB0008141C2 /* windows */,
 				444EACCC0BD0E57100C6D4A0 /* UiSubsystem.cpp */,
 				444EACCD0BD0E57100C6D4A0 /* WindowFactory.cpp */,
@@ -2823,6 +2831,7 @@
 				48389B9D0D86743900AFAB66 /* UiMessages.h in Headers */,
 				487029C70E80DCEA00B66388 /* GameOverWindow.h in Headers */,
 				48B006C80ECAC11D008141C2 /* CharacterSelectionWindow.h in Headers */,
+				483373830F65EC01005979BF /* DialogController.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3102,7 +3111,7 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 			shellPath = /bin/sh;
-			shellScript = &quot;pwd\ncd ../engine/script/swig\n/usr/local/bin/swig -ruby -minherit -c++ -Fmicrosoft -addextern RlExports.i&quot;;
+			shellScript = &quot;pwd\ncd ../engine/script/swig\n/usr/local/bin/swig -ruby -minherit -c++ -w473 -Fstandard -addextern RlExports.i&quot;;
 		};
 		48CA78BF0F221DD700F8E471 /* ShellScript */ = {
 			isa = PBXShellScriptBuildPhase;
@@ -3422,6 +3431,7 @@
 				48389B950D86741F00AFAB66 /* stdinc.cpp in Sources */,
 				487029C90E80DCF900B66388 /* GameOverWindow.cpp in Sources */,
 				48B006C50ECAC05F008141C2 /* CharacterSelectionWindow.cpp in Sources */,
+				483373810F65EBF4005979BF /* DialogController.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};

Copied: rl/branches/persistence2/Rastullah2008.sln (from rev 4878, rl/trunk/Rastullah2008.sln)

Modified: rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/Lockenwickler.e4p	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,181 +1,182 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
-&lt;!DOCTYPE Project SYSTEM &quot;Project-4.6.dtd&quot;&gt;
-&lt;!-- eric4 project file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2009-03-01, 22:49:19 --&gt;
-&lt;!-- Copyright (C) 2009 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
-&lt;Project version=&quot;4.6&quot;&gt;
-  &lt;Language&gt;en&lt;/Language&gt;
-  &lt;ProgLanguage mixed=&quot;0&quot;&gt;Python&lt;/ProgLanguage&gt;
-  &lt;ProjectType&gt;Qt4&lt;/ProjectType&gt;
-  &lt;Description&gt;Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.&lt;/Description&gt;
-  &lt;Version&gt;0.1&lt;/Version&gt;
-  &lt;Author&gt;Stefan Stammberger&lt;/Author&gt;
-  &lt;Email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A>&lt;/Email&gt;
-  &lt;Sources&gt;
-    &lt;Source&gt;src/Lockenwickler.py&lt;/Source&gt;
-    &lt;Source&gt;src/ConsoleWindow.py&lt;/Source&gt;
-    &lt;Source&gt;src/ModelSelectionDialog.py&lt;/Source&gt;
-    &lt;Source&gt;src/ModuleManager.py&lt;/Source&gt;
-    &lt;Source&gt;src/MovePivot.py&lt;/Source&gt;
-    &lt;Source&gt;src/ObjectPropertyWin.py&lt;/Source&gt;
-    &lt;Source&gt;src/OgreMainWindow.py&lt;/Source&gt;
-    &lt;Source&gt;src/OgreWidget.py&lt;/Source&gt;
-    &lt;Source&gt;src/PreferencesDialog.py&lt;/Source&gt;
-    &lt;Source&gt;src/PythonOgreConfig.py&lt;/Source&gt;
-    &lt;Source&gt;src/ui_ConsoleWindow.py&lt;/Source&gt;
-    &lt;Source&gt;src/Property.py&lt;/Source&gt;
-    &lt;Source&gt;src/ViewportGrid.py&lt;/Source&gt;
-    &lt;Source&gt;src/ObjectPropertyModel.py&lt;/Source&gt;
-    &lt;Source&gt;src/GameObjectClass.py&lt;/Source&gt;
-    &lt;Source&gt;src/GameObjectClassManager.py&lt;/Source&gt;
-    &lt;Source&gt;src/setup.py&lt;/Source&gt;
-    &lt;Source&gt;src/GameObjectClassView.py&lt;/Source&gt;
-    &lt;Source&gt;src/MyRaySceneQueryListener.py&lt;/Source&gt;
-    &lt;Source&gt;src/GOStringEditor.py&lt;/Source&gt;
-    &lt;Source&gt;src/GOIntEditor.py&lt;/Source&gt;
-    &lt;Source&gt;src/CodeDump.py&lt;/Source&gt;
-    &lt;Source&gt;src/NewModuleWizard.py&lt;/Source&gt;
-    &lt;Source&gt;src/Ui_NewModuleWizard.py&lt;/Source&gt;
-    &lt;Source&gt;src/ModuleExplorer.py&lt;/Source&gt;
-    &lt;Source&gt;src/SelectionBuffer.py&lt;/Source&gt;
-    &lt;Source&gt;src/MaterialSelectionDialog.py&lt;/Source&gt;
-  &lt;/Sources&gt;
-  &lt;Forms&gt;
-    &lt;Form&gt;ui files/GOPropertyEditorDialogINT.ui&lt;/Form&gt;
-    &lt;Form&gt;ui files/GOPropertyEditorDialogSTRING.ui&lt;/Form&gt;
-    &lt;Form&gt;ui files/NewModuleWizard.ui&lt;/Form&gt;
-  &lt;/Forms&gt;
-  &lt;Translations&gt;
-  &lt;/Translations&gt;
-  &lt;Resources&gt;
-  &lt;/Resources&gt;
-  &lt;Interfaces&gt;
-  &lt;/Interfaces&gt;
-  &lt;Others&gt;
-  &lt;/Others&gt;
-  &lt;MainScript&gt;src/Lockenwickler.py&lt;/MainScript&gt;
-  &lt;Vcs&gt;
-    &lt;VcsType&gt;None&lt;/VcsType&gt;
-    &lt;VcsOptions&gt;
-      &lt;dict&gt;
-        &lt;key&gt;
-          &lt;string&gt;add&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;checkout&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;commit&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;diff&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;export&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;global&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;history&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;log&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;remove&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;status&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;tag&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-        &lt;key&gt;
-          &lt;string&gt;update&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;list&gt;
-            &lt;string&gt;&lt;/string&gt;
-          &lt;/list&gt;
-        &lt;/value&gt;
-      &lt;/dict&gt;
-    &lt;/VcsOptions&gt;
-    &lt;VcsOtherData&gt;
-      &lt;dict&gt;
-        &lt;key&gt;
-          &lt;string&gt;standardLayout&lt;/string&gt;
-        &lt;/key&gt;
-        &lt;value&gt;
-          &lt;bool&gt;True&lt;/bool&gt;
-        &lt;/value&gt;
-      &lt;/dict&gt;
-    &lt;/VcsOtherData&gt;
-  &lt;/Vcs&gt;
-  &lt;FiletypeAssociations&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.ui&quot; type=&quot;FORMS&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.idl&quot; type=&quot;INTERFACES&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.qm&quot; type=&quot;TRANSLATIONS&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.ptl&quot; type=&quot;SOURCES&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.pyw&quot; type=&quot;SOURCES&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.ui.h&quot; type=&quot;FORMS&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.ts&quot; type=&quot;TRANSLATIONS&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.py&quot; type=&quot;SOURCES&quot; /&gt;
-    &lt;FiletypeAssociation pattern=&quot;*.qrc&quot; type=&quot;RESOURCES&quot; /&gt;
-  &lt;/FiletypeAssociations&gt;
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;!DOCTYPE Project SYSTEM &quot;Project-4.6.dtd&quot;&gt;
+&lt;!-- eric4 project file for project Lockenwickler --&gt;
+&lt;!-- Saved: 2009-03-21, 13:56:34 --&gt;
+&lt;!-- Copyright (C) 2009 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
+&lt;Project version=&quot;4.6&quot;&gt;
+  &lt;Language&gt;en&lt;/Language&gt;
+  &lt;ProgLanguage mixed=&quot;0&quot;&gt;Python&lt;/ProgLanguage&gt;
+  &lt;ProjectType&gt;Qt4&lt;/ProjectType&gt;
+  &lt;Description&gt;Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.&lt;/Description&gt;
+  &lt;Version&gt;0.1&lt;/Version&gt;
+  &lt;Author&gt;Stefan Stammberger&lt;/Author&gt;
+  &lt;Email&gt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A>&lt;/Email&gt;
+  &lt;Sources&gt;
+    &lt;Source&gt;src/Lockenwickler.py&lt;/Source&gt;
+    &lt;Source&gt;src/ConsoleWindow.py&lt;/Source&gt;
+    &lt;Source&gt;src/ModelSelectionDialog.py&lt;/Source&gt;
+    &lt;Source&gt;src/ModuleManager.py&lt;/Source&gt;
+    &lt;Source&gt;src/MovePivot.py&lt;/Source&gt;
+    &lt;Source&gt;src/ObjectPropertyWin.py&lt;/Source&gt;
+    &lt;Source&gt;src/OgreMainWindow.py&lt;/Source&gt;
+    &lt;Source&gt;src/OgreWidget.py&lt;/Source&gt;
+    &lt;Source&gt;src/PreferencesDialog.py&lt;/Source&gt;
+    &lt;Source&gt;src/PythonOgreConfig.py&lt;/Source&gt;
+    &lt;Source&gt;src/ui_ConsoleWindow.py&lt;/Source&gt;
+    &lt;Source&gt;src/Property.py&lt;/Source&gt;
+    &lt;Source&gt;src/ViewportGrid.py&lt;/Source&gt;
+    &lt;Source&gt;src/ObjectPropertyModel.py&lt;/Source&gt;
+    &lt;Source&gt;src/GameObjectClass.py&lt;/Source&gt;
+    &lt;Source&gt;src/GameObjectClassManager.py&lt;/Source&gt;
+    &lt;Source&gt;src/setup.py&lt;/Source&gt;
+    &lt;Source&gt;src/GameObjectClassView.py&lt;/Source&gt;
+    &lt;Source&gt;src/MyRaySceneQueryListener.py&lt;/Source&gt;
+    &lt;Source&gt;src/GOStringEditor.py&lt;/Source&gt;
+    &lt;Source&gt;src/GOIntEditor.py&lt;/Source&gt;
+    &lt;Source&gt;src/NewModuleWizard.py&lt;/Source&gt;
+    &lt;Source&gt;src/Ui_NewModuleWizard.py&lt;/Source&gt;
+    &lt;Source&gt;src/ModuleExplorer.py&lt;/Source&gt;
+    &lt;Source&gt;src/SelectionBuffer.py&lt;/Source&gt;
+    &lt;Source&gt;src/MaterialSelectionDialog.py&lt;/Source&gt;
+    &lt;Source&gt;src/DepthBuffer.py&lt;/Source&gt;
+    &lt;Source&gt;src/ZoneManager.py&lt;/Source&gt;
+  &lt;/Sources&gt;
+  &lt;Forms&gt;
+    &lt;Form&gt;ui files/GOPropertyEditorDialogINT.ui&lt;/Form&gt;
+    &lt;Form&gt;ui files/GOPropertyEditorDialogSTRING.ui&lt;/Form&gt;
+    &lt;Form&gt;ui files/NewModuleWizard.ui&lt;/Form&gt;
+  &lt;/Forms&gt;
+  &lt;Translations&gt;
+  &lt;/Translations&gt;
+  &lt;Resources&gt;
+  &lt;/Resources&gt;
+  &lt;Interfaces&gt;
+  &lt;/Interfaces&gt;
+  &lt;Others&gt;
+  &lt;/Others&gt;
+  &lt;MainScript&gt;src/Lockenwickler.py&lt;/MainScript&gt;
+  &lt;Vcs&gt;
+    &lt;VcsType&gt;Subversion&lt;/VcsType&gt;
+    &lt;VcsOptions&gt;
+      &lt;dict&gt;
+        &lt;key&gt;
+          &lt;string&gt;add&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;checkout&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;commit&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;diff&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;export&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;global&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;history&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;log&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;remove&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;status&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;tag&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+        &lt;key&gt;
+          &lt;string&gt;update&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;list&gt;
+            &lt;string&gt;&lt;/string&gt;
+          &lt;/list&gt;
+        &lt;/value&gt;
+      &lt;/dict&gt;
+    &lt;/VcsOptions&gt;
+    &lt;VcsOtherData&gt;
+      &lt;dict&gt;
+        &lt;key&gt;
+          &lt;string&gt;standardLayout&lt;/string&gt;
+        &lt;/key&gt;
+        &lt;value&gt;
+          &lt;bool&gt;True&lt;/bool&gt;
+        &lt;/value&gt;
+      &lt;/dict&gt;
+    &lt;/VcsOtherData&gt;
+  &lt;/Vcs&gt;
+  &lt;FiletypeAssociations&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.ui&quot; type=&quot;FORMS&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.idl&quot; type=&quot;INTERFACES&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.qm&quot; type=&quot;TRANSLATIONS&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.ptl&quot; type=&quot;SOURCES&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.pyw&quot; type=&quot;SOURCES&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.ui.h&quot; type=&quot;FORMS&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.ts&quot; type=&quot;TRANSLATIONS&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.py&quot; type=&quot;SOURCES&quot; /&gt;
+    &lt;FiletypeAssociation pattern=&quot;*.qrc&quot; type=&quot;RESOURCES&quot; /&gt;
+  &lt;/FiletypeAssociations&gt;
 &lt;/Project&gt;
\ No newline at end of file

Modified: rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4q	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;!DOCTYPE UserProject SYSTEM &quot;UserProject-4.0.dtd&quot;&gt;
 &lt;!-- eric4 user project file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2009-03-01, 22:49:19 --&gt;
+&lt;!-- Saved: 2009-03-20, 23:25:33 --&gt;
 &lt;!-- Copyright (C) 2009 Stefan Stammberger, <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">sstammberger at web.de</A> --&gt;
 &lt;UserProject version=&quot;4.0&quot;&gt;
 &lt;/UserProject&gt;
\ No newline at end of file

Modified: rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/_eric4project/Lockenwickler.e4t	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,7 +1,7 @@
 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;!DOCTYPE Tasks SYSTEM &quot;Tasks-4.2.dtd&quot;&gt;
 &lt;!-- eric4 tasks file for project Lockenwickler --&gt;
-&lt;!-- Saved: 2009-03-01, 22:49:19 --&gt;
+&lt;!-- Saved: 2009-03-20, 23:25:33 --&gt;
 &lt;Tasks version=&quot;4.2&quot;&gt;
   &lt;Task priority=&quot;1&quot; completed=&quot;False&quot; bugfix=&quot;False&quot;&gt;
     &lt;Summary&gt;TODO: not implemented yet&lt;/Summary&gt;
@@ -24,10 +24,10 @@
   &lt;Task priority=&quot;1&quot; completed=&quot;False&quot; bugfix=&quot;False&quot;&gt;
     &lt;Summary&gt;TODO: implement save here&lt;/Summary&gt;
     &lt;Description&gt;&lt;/Description&gt;
-    &lt;Created&gt;2009-03-01, 21:50:14&lt;/Created&gt;
+    &lt;Created&gt;2009-03-20, 23:24:53&lt;/Created&gt;
     &lt;Resource&gt;
       &lt;Filename&gt;src/Lockenwickler.py&lt;/Filename&gt;
-      &lt;Linenumber&gt;458&lt;/Linenumber&gt;
+      &lt;Linenumber&gt;519&lt;/Linenumber&gt;
     &lt;/Resource&gt;
   &lt;/Task&gt;
 &lt;/Tasks&gt;
\ No newline at end of file

Deleted: rl/branches/persistence2/editors/Lockenwickler/src/CodeDump.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/CodeDump.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/CodeDump.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,86 +0,0 @@
-    #THIS IS A GENERAL CODE DUMB FOR DEPRECATED CODE
-
-
-    # parses the moduleconfig.rb and searches for all loader.loadmap(&quot; statements in the ruby script
-    # and parses them too
-
-class old():
-
-
-
-    def setResourcePaths(self, path, moduleName):
-        for file in os.listdir(path):
-            curFile = path + &quot;/&quot; + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, &quot;FileSystem&quot;, moduleName, False)
-                self.setResourcePaths(curFile, moduleName)
-                continue
-            if isfile(curFile):
-                pass
-
-
-
-    def load(self,  moduleName,  mapFiles,  gofFiles):
-        self.moduleName = moduleName
-        self.mapFiles = mapFiles
-        self.gofFiles = gofFiles
-
-        self.gocManager.parseGOFFiles(self.gofFiles)
-
-        for a in self.mapFiles:
-            doc = xml.parse(a)
-            node = doc.getElementsByTagName(&quot;entity&quot;)
-            if node != None:
-                self.parseSceneNodes(node)
-
-        self.pivot = Pivot(self.sceneManager)
-        self.pivot.hide()
-
-    def parseSceneNodes(self,  nodeList):
-        for ent in nodeList:
-            entityName = ent.attributes[&quot;name&quot;].nodeValue # get the name of the ent
-            meshFile = ent.attributes[&quot;meshfile&quot;].nodeValue # meshfile
-            nodePosition = None
-            nodeRotation = None
-            nodeScale = None
-
-            for cn in ent.childNodes:
-                if cn.nodeType == cn.ELEMENT_NODE:
-                    if cn.localName == &quot;position&quot;:
-                        px = float(cn.attributes[&quot;x&quot;].nodeValue)
-                        py = float(cn.attributes[&quot;y&quot;].nodeValue)
-                        pz = float(cn.attributes[&quot;z&quot;].nodeValue)
-                        nodePosition = og.Vector3(px, py, pz)
-                        continue
-
-                    if cn.localName == &quot;rotation&quot;:
-                        qw = float(cn.attributes[&quot;qw&quot;].nodeValue)
-                        qx = float(cn.attributes[&quot;qx&quot;].nodeValue)
-                        qy = float(cn.attributes[&quot;qy&quot;].nodeValue)
-                        qz = float(cn.attributes[&quot;qz&quot;].nodeValue)
-                        nodeRotation = og.Quaternion(qw,  qx, qy, qz)
-                        continue
-
-                    if cn.localName == &quot;scale&quot;:
-                        px = float(cn.attributes[&quot;x&quot;].nodeValue)
-                        py = float(cn.attributes[&quot;y&quot;].nodeValue)
-                        pz = float(cn.attributes[&quot;z&quot;].nodeValue)
-                        nodeScale = og.Vector3(px, py, pz)
-                        continue
-
-            try:
-                e = self.sceneManager.createEntity(entityName, meshFile)
-            except:
-                print &quot;Warning: Meshfile &quot; + meshFile + &quot; could not be found.&quot;
-                return
-
-            n = self.sceneManager.getRootSceneNode().createChild(entityName + &quot;_node&quot;)
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            #n.setOrientation(nodeRotation)
-            n.setScale(nodeScale)
-
-        pass

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ConsoleWindow.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ConsoleWindow.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ConsoleWindow.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 import sys

Copied: rl/branches/persistence2/editors/Lockenwickler/src/DepthBuffer.py (from rev 4878, rl/trunk/editors/Lockenwickler/src/DepthBuffer.py)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/GOIntEditor.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/GOIntEditor.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/GOIntEditor.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,4 +1,21 @@
-# -*- coding: utf-8 -*-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 &quot;&quot;&quot;
 Module implementing GOIntEditor.

Modified: rl/branches/persistence2/editors/Lockenwickler/src/GOStringEditor.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/GOStringEditor.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/GOStringEditor.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,5 +1,21 @@
-# -*- coding: utf-8 -*-
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 &quot;&quot;&quot;
 Module implementing GOStringEditor.
 &quot;&quot;&quot;

Modified: rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClass.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,209 +1,210 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-#from elementtree.ElementTree import *
-from xml.etree.cElementTree import *
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-import ogre.renderer.OGRE as og
-
-from GOStringEditor import *
-from GOIntEditor import *
-
-class GOCStringProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;STRING&quot;
-
-    def openEditor(self, row, parent = None):
-        dlg = GOStringEditor(parent)
-        dlg.nameEdit.setText(self.name)
-        dlg.dataEdit.setText(self.data)
-        result = dlg.exec_()
-        if result:
-            self.name = dlg.nameEdit.text()
-            self.data = dlg.dataEdit.toPlainText()
-
-        return result
-
-class GOCRealProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;REAL&quot;
-
-    def openEditor(self, row, parent = None):
-        dlg = GOStringEditor(parent)
-        dlg.nameEdit.setText(self.name)
-        dlg.dataEdit.setText(self.data)
-        result = dlg.exec_()
-        if result:
-            self.name = dlg.nameEdit.text()
-            self.data = dlg.dataEdit.toPlainText()
-
-        return result
-
-class GOCBoolProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;BOOL&quot;
-
-class GOCIntProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;INT&quot;
-
-    def openEditor(self, row, parent = None):
-        dlg = GOIntEditor(parent)
-        dlg.nameEdit.setText(self.name)
-        dlg.dataEdit.setText(self.data)
-        result = dlg.exec_()
-        if result:
-            self.name = dlg.nameEdit.text()
-            self.data = dlg.dataEdit.toPlainText()
-
-        return result
-
-class GOCIntPairProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;INTPAIR&quot;
-
-class GOCIntTripleProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return &quot;INTTRIPPLE&quot;
-
-class GOCMapProperty():
-    def __init__(self, name):
-        self.name = name
-        self.childProperties = []
-
-    def getType(self):
-        return &quot;MAP&quot;
-
-# gameObjectClass is the id of the class itself
-# since a game object can be ingame more than once there is also a id for those
-class GameObjectRepresentation(og.UserDefinedObject):
-    def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
-        og.UserDefinedObject.__init__(self)
-        self.inWorldId = inWorldId
-        self.gocName = gameObjectClass
-        self.node = node
-        self.meshFile = meshFile
-        self.state = &quot;IN_SCENE&quot;
-
-    def getType(self):
-        return &quot;GAME_OBJECT_REPRESENTATION&quot;
-
-    def setPosition(self, pos):
-        self.node.setPosition(pos)
-
-
-class GameObjectClass():
-    def __init__(self,  parentElement):
-        self.classid = parentElement.get(&quot;classid&quot;)
-        self.baseclass = parentElement.get(&quot;baseclass&quot;)
-
-        self.meshFile = None
-
-        self.properties = []
-
-        for property in parentElement:#.getiterator(&quot;property&quot;):
-            if property.get(&quot;type&quot;) == &quot;ARRAY&quot;:
-                pass
-            elif property.get(&quot;type&quot;) == &quot;MAP&quot;:
-                self.properties.append(self.createPropertyMap(property))
-            else:
-                self.properties.append(self.createProperty(property))
-
-    def getType(self):
-        return &quot;GAME_OBJECT&quot;
-
-    def createPropertyMap(self, property):
-        propMap = GOCMapProperty(property.get(&quot;name&quot;))
-        for subProperty in property:
-            if subProperty.get(&quot;type&quot;) == &quot;MAP&quot;:
-                propMap.childProperties.append(self.createPropertyMap(property))
-            else:
-                for subProperty1 in property:
-                    propMap.childProperties.append(self.createProperty(subProperty1))
-
-        return propMap
-
-    def getMeshFileName(self):
-        if self.meshFile is None:
-            for prop in self.properties:
-                if prop.getType() == &quot;STRING&quot;:
-                    if prop.name == &quot;meshfile&quot;:
-                        self.meshFile = prop.data
-                        return self.meshFile
-            return None
-        else:
-            return self.meshFile
-
-
-    def createProperty(self, property):
-        if property.get(&quot;type&quot;) == &quot;STRING&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCStringProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;REAL&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCRealProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;BOOL&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCBoolProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;INT&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCIntProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;INTPAIR&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCIntPairProperty(name, data)
-        elif property.get(&quot;type&quot;) == &quot;INTTRIPLE&quot;:
-            name = property.get(&quot;name&quot;)
-            data = property.get(&quot;data&quot;)
-            return GOCIntTripleProperty(name, data)
-        else:
-            print property.get(&quot;type&quot;)
-
-
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+#from elementtree.ElementTree import *
+from xml.etree.cElementTree import *
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+import ogre.renderer.OGRE as og
+
+from GOStringEditor import *
+from GOIntEditor import *
+
+class GOCStringProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;STRING&quot;
+
+    def openEditor(self, row, parent = None):
+        dlg = GOStringEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCRealProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;REAL&quot;
+
+    def openEditor(self, row, parent = None):
+        dlg = GOStringEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCBoolProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;BOOL&quot;
+
+class GOCIntProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;INT&quot;
+
+    def openEditor(self, row, parent = None):
+        dlg = GOIntEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCIntPairProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;INTPAIR&quot;
+
+class GOCIntTripleProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return &quot;INTTRIPPLE&quot;
+
+class GOCMapProperty():
+    def __init__(self, name):
+        self.name = name
+        self.childProperties = []
+
+    def getType(self):
+        return &quot;MAP&quot;
+
+# gameObjectClass is the id of the class itself
+# since a game object can be ingame more than once there is also a id for those
+class GameObjectRepresentation(og.UserDefinedObject):
+    def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
+        og.UserDefinedObject.__init__(self)
+        self.inWorldId = inWorldId
+        self.gocName = str(gameObjectClass)
+        self.node = node
+        self.meshFile = meshFile
+        self.state = &quot;IN_SCENE&quot;
+
+    def getType(self):
+        return &quot;GAME_OBJECT_REPRESENTATION&quot;
+
+    def setPosition(self, pos):
+        self.node.setPosition(pos)
+
+
+class GameObjectClass():
+    def __init__(self,  parentElement):
+        self.classid = parentElement.get(&quot;classid&quot;)
+        self.baseclass = parentElement.get(&quot;baseclass&quot;)
+
+        self.meshFile = None
+
+        self.properties = []
+
+        for property in parentElement:#.getiterator(&quot;property&quot;):
+            if property.get(&quot;type&quot;) == &quot;ARRAY&quot;:
+                pass
+            elif property.get(&quot;type&quot;) == &quot;MAP&quot;:
+                self.properties.append(self.createPropertyMap(property))
+            else:
+                self.properties.append(self.createProperty(property))
+
+    def getType(self):
+        return &quot;GAME_OBJECT&quot;
+
+    def createPropertyMap(self, property):
+        propMap = GOCMapProperty(property.get(&quot;name&quot;))
+        for subProperty in property:
+            if subProperty.get(&quot;type&quot;) == &quot;MAP&quot;:
+                propMap.childProperties.append(self.createPropertyMap(property))
+            else:
+                for subProperty1 in property:
+                    propMap.childProperties.append(self.createProperty(subProperty1))
+
+        return propMap
+
+    def getMeshFileName(self):
+        if self.meshFile is None:
+            for prop in self.properties:
+                if prop.getType() == &quot;STRING&quot;:
+                    if prop.name == &quot;meshfile&quot;:
+                        self.meshFile = prop.data
+                        return self.meshFile
+            return None
+        else:
+            return self.meshFile
+
+
+    def createProperty(self, property):
+        if property.get(&quot;type&quot;) == &quot;STRING&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCStringProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;REAL&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCRealProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;BOOL&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCBoolProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;INT&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCIntProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;INTPAIR&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCIntPairProperty(name, data)
+        elif property.get(&quot;type&quot;) == &quot;INTTRIPLE&quot;:
+            name = property.get(&quot;name&quot;)
+            data = property.get(&quot;data&quot;)
+            return GOCIntTripleProperty(name, data)
+        else:
+            print property.get(&quot;type&quot;)
+
+
+

Modified: rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassManager.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassManager.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassManager.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,53 +1,69 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-#from elementtree.ElementTree import parse
-from xml.etree.cElementTree import parse
-
-from GameObjectClass import *
-
-class GameObjectClassManager():
-    def __init__(self):
-        self.fileDict = {}
-        self.callback = None
-
-    def parseGOFFiles(self, filePaths):
-        for filePath in filePaths:
-            tree = parse(filePath)
-            gocList = []
-            for parent in tree.getiterator(&quot;gameobjectclass&quot;): # return all allements with the &quot;gameobjectclass&quot; tag
-                go = GameObjectClass(parent)
-                gocList.append(go)
-
-            self.fileDict[filePath] = gocList
-
-        if self.callback is not None:
-            self.callback(self.fileDict)
-
-    def getGameObjectWithClassId(self, id):
-        for key in self.fileDict:
-            for go in self.fileDict[key]:
-                if go.classid == id:
-                    return go
-
-        return None
-
-        # whenever a gameobject changes outside of the view, the view has to update itself wth the new values
-    def setGameObjectsViewUpdateCallback(self, callback):
-        self.callback = callback
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+#from elementtree.ElementTree import parse
+from xml.etree.cElementTree import parse
+
+from GameObjectClass import *
+
+class GameObjectClassManager():
+    def __init__(self):
+        self.fileDict = {}
+        self.callback = None
+
+        # we need to hold a reference to the game object representaions ourself
+        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
+        # and deletes the object
+        self.gameObjectRepresentationDict = []
+
+    def inWorldIdExists(self, id):
+        for rep in self.gameObjectRepresentationDict:
+            if str(rep.inWorldId) == str(id):
+                return True
+        
+        return False
+
+    def addGameObjectRepresentation(self, gocRep):
+        self.gameObjectRepresentationDict.append(gocRep)
+
+    def parseGOFFiles(self, filePaths):
+        for filePath in filePaths:
+            tree = parse(filePath)
+            gocList = []
+            for parent in tree.getiterator(&quot;gameobjectclass&quot;): # return all allements with the &quot;gameobjectclass&quot; tag
+                go = GameObjectClass(parent)
+                gocList.append(go)
+
+            self.fileDict[filePath] = gocList
+
+        if self.callback is not None:
+            self.callback(self.fileDict)
+
+    def getGameObjectWithClassId(self, id):
+        for key in self.fileDict:
+            for go in self.fileDict[key]:
+                if go.classid == id:
+                    return go
+
+        return None
+
+        # whenever a gameobject changes outside of the view, the view has to update itself wth the new values
+    def setGameObjectsViewUpdateCallback(self, callback):
+        self.callback = callback
+

Modified: rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/GameObjectClassView.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 from PyQt4.QtCore import *

Modified: rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/Lockenwickler.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,501 +1,551 @@
- #################################################
- #################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-sys.path.insert(0,'..')
-import PythonOgreConfig
-
-from random import randint
-
-from PyQt4 import QtGui, QtCore
-from PreferencesDialog import *
-from ObjectPropertyWin import *
-from ModelSelectionDialog import *
-from MaterialSelectionDialog import *
-from GameObjectClassView import *
-from ConsoleWindow import *
-from ModuleManager import *
-from ModuleExplorer import *
-from NewModuleWizard import *
-from PivotRenderQueueListener import *
-
-import OgreMainWindow
-import ogre.renderer.OGRE as og
-
-class Lockenwickler(QtGui.QMainWindow):
-    def __init__(self, parent=None):
-        QtGui.QWidget.__init__(self, parent)
-
-#        pixmap = QPixmap(&quot;media/icons/lockenwickler_provisorium.png&quot;)
-#        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
-#        splash.setMask(pixmap.mask())
-#        splash.showMessage(&quot;Starting...&quot;)
-#        splash.show()
-
-        self.setupUi()
-
-        self.consoleWindow = ConsoleWindow(False,  self)
-
-        self.setupOgre()
-
-        self.prefDialog = PreferencesDialog(self)
-        self.objectPropertyWin = ObjectPropertyWin(self.OgreMainWinSceneMgr, self)
-        self.moduleExplorerWin = ModuleExplorer(self)
-        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
-        self.materialSelectionDialog = MaterialSelectionDialog(self.ogreRoot, self)
-        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
-        self.moduleManager.materialSelectionDialog = self.materialSelectionDialog
-
-        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
-
-        self.createDockWindows()
-
-        self.mainTimer = QtCore.QTimer(self)
-        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL(&quot;timeout()&quot;), self.update)
-        self.mainTimer.start(5)
-
-        settings = QtCore.QSettings()
-        self.restoreGeometry(settings.value(&quot;MainWindow/Geometry&quot;).toByteArray())
-        self.restoreState(settings.value(&quot;MainWindow/DockWindows&quot;).toByteArray())
-        if not self.prefDialog.setCfgPath(settings.value(&quot;Preferences/moduleCfgPath&quot;).toString()):
-            self.prefDialog.show()
-            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
-        else:
-            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
-        
-        self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
-        self.moduleManager.setPropertyWindow(self.objectPropertyWin)
-        
-        self.setWindowIcon(QIcon(&quot;media/icons/lockenwickler_provisorium_small.png&quot;))
-        self.setWindowTitle(&quot;Rastullahs Lockenwickler&quot;)
-        
-        self.editorSetupFinished = False
-        
-#        splash.finish(self)
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
-        action = QtGui.QAction(text, self)
-        if icon is not None:
-            action.setIcon(QtGui.QIcon(&quot;media/icons/%s&quot; % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            self.connect(action, QtCore.SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
-
-    def addActions(self, target, actions):
-        for act in actions:
-            if act is None:
-               target.addSeparator()
-            else:
-                target.addAction(act)
-
-    def setupUi(self):
-        self.setObjectName(&quot;MainWindow&quot;)
-
-        self.centralwidget = QtGui.QWidget(self)
-        self.centralwidget.setObjectName(&quot;centralwidget&quot;)
-
-        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
-        self.hboxlayout.setObjectName(&quot;hboxlayout&quot;)
-
-        self.gridlayout = QtGui.QGridLayout()
-        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
-        self.menubar = QtGui.QMenuBar(self)
-        self.menubar.setObjectName(&quot;menubar&quot;)
-
-        self.menuFile = QtGui.QMenu(self.menubar)
-        self.menuFile.setObjectName(&quot;menuFile&quot;)
-
-        self.menuEdit = QtGui.QMenu(self.menubar)
-        self.menuEdit.setObjectName(&quot;menuEdit&quot;)
-
-        self.menuView = QtGui.QMenu(self.menubar)
-        self.menuView.setObjectName(&quot;menuView&quot;)
-        self.setMenuBar(self.menubar)
-
-
-        self.statusbar = QtGui.QStatusBar(self)
-        self.statusbar.setObjectName(&quot;statusbar&quot;)
-        self.setStatusBar(self.statusbar)
-
-#####################################
-        self.actionNeu =self.createAction(&quot;&amp;New Module&quot;,  self.actionNewSlot,  QKeySequence.New,  &quot;filenew.png&quot;,  &quot;New Module&quot;)
-        self.actionNeu.setObjectName(&quot;actionNeu&quot;)
-
-        self.actionOpen = self.createAction(&quot;&amp;Open Module&quot;,  self.actionOpenSlot,  QKeySequence.Open,  &quot;fileopen.png&quot;,  &quot;Open Module&quot;)
-        self.actionOpen.setObjectName(&quot;actionOpen&quot;)
-        
-        self.actionSave = self.createAction(&quot;&amp;Save&quot;,  self.actionSaveSlot,  QKeySequence.Save,  &quot;filesave.png&quot;,  &quot;Save Module&quot;)
-        self.actionSave.setObjectName(&quot;actionSave&quot;)
-
-        self.actionClose = self.createAction(&quot;Quit&quot;,  self.actionQuitSlot,  &quot;Alt + Q&quot;,  &quot;exit.png&quot;,  &quot;Quit&quot;)
-        self.actionClose.setObjectName(&quot;actionQuit&quot;)
-#####################################
-
-
-#####################################
-        self.actionDelete = self.createAction(&quot;Delete&quot;,  self.actionDeleteSlot,  QKeySequence.Delete,  &quot;editdelete.png&quot;,  &quot;Delete&quot;)
-        self.actionDelete.setObjectName(&quot;actionDelete&quot;)
-
-        self.actionCopy = self.createAction(&quot;Copy&quot;,  self.actionCopySlot,  QKeySequence.Copy,  &quot;editcopy.png&quot;,  &quot;Copy&quot;)
-        self.actionCopy.setObjectName(&quot;actionCopy&quot;)
-
-        self.actionCut = self.createAction(&quot;Cut&quot;,  self.actionCutSlot,  QKeySequence.Cut,  &quot;editcut.png&quot;,  &quot;Cut&quot;)
-        self.actionCut.setObjectName(&quot;actionCut&quot;)
-
-        self.actionPaste = self.createAction(&quot;Paste&quot;,  self.actionPasteSlot,  QKeySequence.Paste,  &quot;editpaste.png&quot;,  &quot;Paste&quot;)
-        self.actionPaste.setObjectName(&quot;actionPaste&quot;)
-
-        self.actionSelect = self.createAction(&quot;&amp;Select&quot;,  self.actionSelectSlot,  &quot;Space&quot;,  &quot;cursor.png&quot;,  &quot;Move selected object&quot;)
-        self.actionSelect.setObjectName(&quot;actionSelect&quot;)
-
-        self.actionMove = self.createAction(&quot;&amp;Move&quot;,  self.actionMoveSlot,  &quot;g&quot;,  &quot;move.png&quot;,  &quot;Move selected object&quot;)
-        self.actionMove.setObjectName(&quot;actionMove&quot;)
-
-        self.actionRotate = self.createAction(&quot;&amp;Rotate&quot;,  self.actionRotateSlot,  &quot;r&quot;,  &quot;rotate.png&quot;,  &quot;Rotate selected object&quot;)
-        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
-
-        self.actionScale = self.createAction(&quot;&amp;Scale&quot;,  self.actionScaleSlot,  &quot;x&quot;,  &quot;resizecol.png&quot;,  &quot;Scale selected object&quot;)
-        self.actionScale.setObjectName(&quot;actionScale&quot;)
-
-        self.actionOneClickEntityPlacement = self.createAction(&quot;&amp;OneClickEntityPlacement&quot;,  self.actionOneClickEntityPlacementSlot,  &quot;&quot;,  &quot;resizecol.png&quot;,  &quot;Add an Entity just by a click&quot;)
-        self.actionOneClickEntityPlacement.setObjectName(&quot;actionOneClickEntityPlacement&quot;)
-        self.actionOneClickEntityPlacement.setCheckable(True)
-
-#####################################
-#####################################
-        self.actionSceneExplorer = self.createAction(&quot;&amp;Scene Exlporer&quot;,  self.toggleModuleExplorer,  &quot;Alt + E&quot;,  &quot;view_tree.png&quot;,  &quot;Module Explorer&quot;,  False)
-        self.actionSceneExplorer.setObjectName(&quot;actionSceneExplorer&quot;)
-        
-        self.actionPreferences = self.createAction(&quot;&amp;Preferences&quot;,  self.togglePreferencesWindow,  &quot;Alt + P&quot;,  &quot;configure.png&quot;,  &quot;Lockenwickler Preferences&quot;,  False)
-        self.actionPreferences.setObjectName(&quot;actionPreferences&quot;)
-
-        self.actionProperty_Window = self.createAction(&quot;Pr&amp;operty Window&quot;,  self.togglePropertyWindow,  &quot;Alt + P&quot;,  &quot;unsortedlist1.png&quot;,  &quot;Property Window&quot;)
-        self.actionProperty_Window.setObjectName(&quot;actionProperty_Window&quot;)
-
-        self.actionObject_Selection = self.createAction(&quot;&amp;Model Preview Window&quot;,  self.toggleModelPreviewWindow,  &quot;Alt + O&quot;,  &quot;tux.png&quot;,  &quot;Model Preview&quot;)
-        self.actionObject_Selection.setObjectName(&quot;actionObject_Selection&quot;)
-        
-        self.actionMaterial_Selection = self.createAction(&quot;Material &amp;Preview Window&quot;,  self.toggleMaterialPreviewWindow,  &quot;Alt + M&quot;,  &quot;colors.png&quot;,  &quot;Material Preview&quot;)
-        self.actionMaterial_Selection.setObjectName(&quot;actionMaterial_Selection&quot;)
-
-        self.actionGameObjectClass_Selection = self.createAction(&quot;&amp;Game Object Class Preview Window&quot;,  self.toggleGameObjectViewWindow,  &quot;Alt + G&quot;,  &quot;multirow.png&quot;,  &quot;GameObjectClass Preview&quot;)
-        self.actionGameObjectClass_Selection.setObjectName(&quot;actionObject_Selection&quot;)
-
-        self.actionConsole_Window = self.createAction(&quot;&amp;Console Window&quot;,  self.toggleConsoleWindow,  &quot;Alt + C&quot;,  &quot;console.png&quot;,  &quot;Console Window&quot;)
-        self.actionConsole_Window.setObjectName(&quot;actionConsole_Window&quot;)
-
-#####################################
-#####################################
-
-
-        self.menuFile.addAction(self.actionNeu)
-        self.menuFile.addAction(self.actionOpen)
-        self.menuFile.addAction(self.actionSave)
-        self.menuFile.addAction(self.actionClose)
-
-        self.menuEdit.addAction(self.actionSelect)
-        self.menuEdit.addAction(self.actionMove)
-        self.menuEdit.addAction(self.actionRotate)
-        self.menuEdit.addAction(self.actionScale)
-        self.menuEdit.addSeparator()
-        self.menuEdit.addAction(self.actionDelete)
-        self.menuEdit.addAction(self.actionCopy)
-        self.menuEdit.addAction(self.actionCut)
-        self.menuEdit.addAction(self.actionPaste)
-        self.menuEdit.addSeparator()
-        self.menuEdit.addAction(self.actionOneClickEntityPlacement)
-        
-
-        self.menuView.addAction(self.actionSceneExplorer)
-        self.menuView.addAction(self.actionPreferences)
-        self.menuView.addAction(self.actionProperty_Window)
-        self.menuView.addAction(self.actionObject_Selection)
-        self.menuView.addAction(self.actionMaterial_Selection)
-        self.menuView.addAction(self.actionGameObjectClass_Selection)
-        self.menuView.addAction(self.actionConsole_Window)
-        self.menubar.addAction(self.menuFile.menuAction())
-        self.menubar.addAction(self.menuEdit.menuAction())
-        self.menubar.addAction(self.menuView.menuAction())
-
-        self.retranslateUi()
-        QtCore.QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.setWindowTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.menuFile.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;File&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.menuEdit.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Edit&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.menuView.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;View&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionNeu.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;New Module&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionMove.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Move&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionRotate.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Rotate&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionSceneExplorer.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Module Explorer&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionPreferences.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Preferences&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionProperty_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Property Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionObject_Selection.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Object Selection&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionClose.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Quit&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.actionConsole_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Console Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
-
-    def setupOgre(self, pluginCfgPath=&quot;./Plugins.cfg&quot;, ogreCfgPath=&quot;./ogre.cfg&quot;, logPath=&quot;./ogre.log&quot;):
-        if platform.system() == &quot;Windows&quot;:
-            pluginCfgPath=&quot;./Plugins-windows.cfg&quot;
-        else:
-            pluginCfgPath=&quot;./Plugins-linux.cfg&quot;
-
-        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
-        self.ogreRoot = root
-
-        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
-            sys.exit('Quit from Config Dialog')
-
-        root.initialise(False)
-
-        self.pivotRenderQueueListener = PivotRenderQueueListener()
-        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, &quot;OgreMainWinSceneMgr&quot;)
-        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
-        self.OgreMainWinSceneMgr.addRenderQueueListener(self.pivotRenderQueueListener)
-
-        self.moduleName = &quot;&quot;
-        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
-
-        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
-        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
-        self.hboxlayout.addLayout(self.gridlayout)
-        self.setCentralWidget(self.centralwidget)
-        
-        oglog = og.LogManager.getSingleton().getDefaultLog()
-        oglog.addListener(self.consoleWindow.lockenLog)
-
-    def finishEditorSetup(self):
-        if not self.editorSetupFinished:
-            og.ResourceGroupManager.getSingleton().addResourceLocation(&quot;./media&quot;, &quot;FileSystem&quot;, &quot;General&quot;, False)
-            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-            self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
-            self.moduleManager.pivot.hide()
-            self.editorSetupFinished = True
-        
-    def update(self):
-        self.ogreRoot.renderOneFrame()
-        if platform.system() == &quot;Linux&quot;:
-            self.ogreMainWindow.updateRenderWindow()
-            self.modelSelectionDialog.updateRenderWindow()
-            self.materialSelectionDialog.updateRenderWindow()
-
-    def actionOpenSlot(self):
-        self.finishEditorSetup()
-        self.moduleManager.openLoadModuleDialog()
-
-    def actionNewSlot(self):
-        newModuleWiz = NewModuleWizard(self.moduleManager, self)
-        newModuleWiz.exec_()
-        return
-        
-    def actionSaveSlot(self):
-        self.moduleManager.save()
-        
-    def actionQuitSlot(self):
-        self.close()
-
-    def actionDeleteSlot(self):
-        self.moduleManager.deleteObjects()
-
-    def actionCopySlot(self):
-        self.moduleManager.copyObjects()
-
-    def actionCutSlot(self):
-        self.moduleManager.cutObjects()
-
-    def actionPasteSlot(self):
-        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
-
-    def actionSelectSlot(self):
-        self.moduleManager.pivot.hide()
-
-    def actionMoveSlot(self):
-        self.moduleManager.pivot.setMoveMode()
-
-    def actionRotateSlot(self):
-        self.moduleManager.pivot.setRotateMode()
-
-    def actionScaleSlot(self):
-        self.moduleManager.pivot.setScaleMode()
-
-    def actionOneClickEntityPlacementSlot(self):
-        self.moduleManager.setOneClickEntityPlacement(self.actionOneClickEntityPlacement.isChecked())
-
-    def togglePreferencesWindow(self):
-        if self.prefDialog.isHidden():
-            self.prefDialog.show()
-        else:
-            self.prefDialog.hide()
-
-    def toggleModelPreviewWindow(self):
-        if self.modelSelectionDock.isHidden():
-            self.modelSelectionDock.show()
-        else:
-            self.modelSelectionDock.hide()
-    
-    def toggleMaterialPreviewWindow(self):
-        if self.materialSelectionDock.isHidden():
-            self.materialSelectionDock.show()
-        else:
-            self.materialSelectionDock.hide()
-
-    def toggleGameObjectViewWindow(self):
-        if self.gameObjectClassViewDock.isHidden():
-            self.gameObjectClassViewDock.show()
-        else:
-            self.gameObjectClassViewDock.hide()
-
-    def toggleModuleExplorer(self):
-        if self.moduleExplorerDock.isHidden():
-            self.moduleExplorerDock.show()
-        else:
-            self.moduleExplorerDock.hide()
-
-    def togglePropertyWindow(self):
-        if self.propertyDock.isHidden():
-            self.propertyDock.show()
-        else:
-            self.propertyDock.hide()
-
-    def toggleConsoleWindow(self):
-        if self.consoleDock.isHidden():
-            self.consoleDock.show()
-        else:
-            self.consoleDock.hide()
-
-    def createDockWindows(self):
-        self.propertyDock = QtGui.QDockWidget(self.tr(&quot;Properties&quot;), self)
-        self.propertyDock.setObjectName(&quot;PropertyDockWindow&quot;)
-        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.propertyDock.setWidget(self.objectPropertyWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
-
-        self.modelSelectionDock = QtGui.QDockWidget(self.tr(&quot;Models&quot;), self)
-        self.modelSelectionDock.setObjectName(&quot;ModelSelectionDockWindow&quot;)
-        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
-        
-        self.materialSelectionDock = QtGui.QDockWidget(self.tr(&quot;Materials&quot;), self)
-        self.materialSelectionDock.setObjectName(&quot;MaterialSelectionDockWindow&quot;)
-        self.materialSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.materialSelectionDock.setWidget(self.materialSelectionDialog)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.materialSelectionDock)
-
-        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr(&quot;GameObjectClasses&quot;), self)
-        self.gameObjectClassViewDock.setObjectName(&quot;GameObjectClassView&quot;)
-        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
-
-        self.moduleExplorerDock = QtGui.QDockWidget(self.tr(&quot;Module Explorer&quot;), self)
-        self.moduleExplorerDock.setObjectName(&quot;ModuleExplorerDockWindow&quot;)
-        self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
-
-        self.consoleDock = QtGui.QDockWidget(self.tr(&quot;Console&quot;), self)
-        self.consoleDock.setObjectName(&quot;ConsoleDockWindow&quot;)
-        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
-        self.consoleDock.setWidget(self.consoleWindow)
-        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
-
-        self.fileToolBar = self.addToolBar(&quot;File Toolbar&quot;)
-        self.fileToolBar.setObjectName(&quot;FileToolBar&quot;)
-        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.fileToolBar.addAction(self.actionNeu)
-        self.fileToolBar.addAction(self.actionOpen)
-        self.fileToolBar.addAction(self.actionSave)
-        self.fileToolBar.addAction(self.actionClose)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
-
-        self.moveToolBar = self.addToolBar(&quot;Transformation Bar&quot;)
-        self.moveToolBar.setObjectName(&quot;TransformationBar&quot;)
-        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.moveToolBar.addAction(self.actionSelect)
-        self.moveToolBar.addAction(self.actionMove)
-        self.moveToolBar.addAction(self.actionRotate)
-        self.moveToolBar.addAction(self.actionScale)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
-
-    def keyPressEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreMainWindow.keyPressEvent(event)
-
-    def keyReleaseEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreMainWindow.keyReleaseEvent(event)
-        pass
-
-    def connectActionButtons(self):
-        pass
-
-    def saveOnClose(self):
-        reply = QtGui.QMessageBox.question(self,  &quot;Rastullahs Lockenwickler - Unsaved Chages&quot;,  &quot;Save unsaved changes?&quot;,  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
-        if reply == QtGui.QMessageBox.Cancel:
-            return False
-        if reply == QtGui.QMessageBox.Yes:
-            print&quot;&quot;
-            #TODO: implement save here
-        return True
-
-    def closeEvent(self,  event):
-        if self.saveOnClose():
-            settings = QtCore.QSettings()
-            settings.setValue(&quot;Preferences/moduleCfgPath&quot;, QtCore.QVariant(self.prefDialog.lineEdit.text()))
-            settings.setValue(&quot;MainWindow/Geometry&quot;,  QtCore.QVariant(self.saveGeometry()))
-            settings.setValue(&quot;MainWIndow/DockWindows&quot;,  QtCore.QVariant(self.saveState()))
-        else:
-            event.ignore()
-
-if __name__ == &quot;__main__&quot;:
-#    # Import Psyco if available
-#    try:
-##        import psyco
-##        psyco.full(0.02)
-#        #psyco.log()
-#        #psyco.profile()
-#    except ImportError:
-#        pass
-    
-    app = QtGui.QApplication(sys.argv)
-    app.setOrganizationName(&quot;Team Pantheon&quot;)
-    app.setOrganizationDomain(&quot;rastullahs-lockenpracht.de/team&quot;)
-    app.setApplicationName(&quot;Lockenwickler&quot;)
-
-    form = Lockenwickler()
-    form.show()
-
-    sys.exit(app.exec_())
-
+#################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import os
+import sys
+import platform
+import subprocess
+
+sys.path.insert(0,'..')
+import PythonOgreConfig
+
+from random import randint
+
+from PyQt4 import QtGui, QtCore
+from PreferencesDialog import *
+from ObjectPropertyWin import *
+from ModelSelectionDialog import *
+from MaterialSelectionDialog import *
+from GameObjectClassView import *
+from ConsoleWindow import *
+from ModuleManager import ModuleManager
+from ModuleExplorer import *
+from NewModuleWizard import *
+from MovePivot import *
+from PivotRenderQueueListener import *
+
+import OgreMainWindow
+import ogre.renderer.OGRE as og
+
+class Lockenwickler(QtGui.QMainWindow):
+    def __init__(self, parent=None):
+        QtGui.QWidget.__init__(self, parent)
+
+#        pixmap = QPixmap(&quot;media/icons/lockenwickler_provisorium.png&quot;)
+#        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
+#        splash.setMask(pixmap.mask())
+#        splash.showMessage(&quot;Starting...&quot;)
+#        splash.show() 
+
+        self.setupUi()
+
+        self.consoleWindow = ConsoleWindow(False,  self)
+
+        self.setupOgre()
+
+        self.prefDialog = PreferencesDialog(self)
+        self.objectPropertyWin = ObjectPropertyWin(self.OgreMainWinSceneMgr, self.gocManager, self)
+        self.moduleExplorerWin = ModuleExplorer(self)
+        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        self.materialSelectionDialog = MaterialSelectionDialog(self.ogreRoot, self)
+        self.moduleManager.modelSelectionDialog = self.modelSelectionDialog
+        self.moduleManager.materialSelectionDialog = self.materialSelectionDialog
+
+        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
+
+        self.createDockWindows()
+
+        self.mainTimer = QtCore.QTimer(self)
+        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL(&quot;timeout()&quot;), self.update)
+        self.mainTimer.start(5)
+
+        settings = QtCore.QSettings()
+        self.restoreGeometry(settings.value(&quot;MainWindow/Geometry&quot;).toByteArray())
+        self.restoreState(settings.value(&quot;MainWindow/DockWindows&quot;).toByteArray())
+        if not self.prefDialog.setCfgPath(settings.value(&quot;Preferences/moduleCfgPath&quot;).toString()):
+            self.prefDialog.show()
+            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        else:
+            self.moduleManager.moduleCfgPath = self.prefDialog.moduleCfgPath
+        
+        self.moduleManager.setModuleExplorer(self.moduleExplorerWin)
+        self.moduleManager.setPropertyWindow(self.objectPropertyWin)
+        self.moduleManager.setContextMenuCallback(self.onContextMenuCallback)
+        
+        self.setWindowIcon(QIcon(&quot;media/icons/lockenwickler_provisorium_small.png&quot;))
+        self.setWindowTitle(&quot;Rastullahs Lockenwickler&quot;)
+        
+        self.editorSetupFinished = False
+        
+#        splash.finish(self)
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
+        action = QtGui.QAction(text, self)
+        if icon is not None:
+            action.setIcon(QtGui.QIcon(&quot;media/icons/%s&quot; % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            self.connect(action, QtCore.SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+
+    def addActions(self, target, actions):
+        for act in actions:
+            if act is None:
+               target.addSeparator()
+            else:
+                target.addAction(act)
+
+    def setupUi(self):
+        self.setObjectName(&quot;MainWindow&quot;)
+
+        self.centralwidget = QtGui.QWidget(self)
+        self.centralwidget.setObjectName(&quot;centralwidget&quot;)
+
+        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
+        self.hboxlayout.setContentsMargins(0, 0, 0, 0)
+        self.hboxlayout.setObjectName(&quot;hboxlayout&quot;)
+
+        self.gridlayout = QtGui.QGridLayout()
+        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
+        self.gridlayout.setContentsMargins(0, 0, 0, 0)
+        
+        self.menubar = QtGui.QMenuBar(self)
+        self.menubar.setObjectName(&quot;menubar&quot;)
+
+        self.menuFile = QtGui.QMenu(self.menubar)
+        self.menuFile.setObjectName(&quot;menuFile&quot;)
+
+        self.menuEdit = QtGui.QMenu(self.menubar)
+        self.menuEdit.setObjectName(&quot;menuEdit&quot;)
+
+        self.menuView = QtGui.QMenu(self.menubar)
+        self.menuView.setObjectName(&quot;menuView&quot;)
+        self.setMenuBar(self.menubar)
+
+
+        self.statusbar = QtGui.QStatusBar(self)
+        self.statusbar.setObjectName(&quot;statusbar&quot;)
+        self.setStatusBar(self.statusbar)
+
+#####################################
+        self.actionNeu =self.createAction(&quot;&amp;New Module&quot;,  self.actionNewSlot,  QKeySequence.New,  &quot;filenew.png&quot;,  &quot;New Module&quot;)
+        self.actionNeu.setObjectName(&quot;actionNeu&quot;)
+
+        self.actionOpen = self.createAction(&quot;&amp;Open Module&quot;,  self.actionOpenSlot,  QKeySequence.Open,  &quot;fileopen.png&quot;,  &quot;Open Module&quot;)
+        self.actionOpen.setObjectName(&quot;actionOpen&quot;)
+        
+        self.actionSave = self.createAction(&quot;&amp;Save&quot;,  self.actionSaveSlot,  QKeySequence.Save,  &quot;filesave.png&quot;,  &quot;Save Module&quot;)
+        self.actionSave.setObjectName(&quot;actionSave&quot;)
+        
+        self.actionRunModule = self.createAction(&quot;&amp;Save and Run&quot;,  self.actionRunModuleSlot,  &quot;Alt+R&quot;,  &quot;fileexport.png&quot;,  &quot;Save And Run Module&quot;)
+        self.actionRunModule.setObjectName(&quot;actionRunModule&quot;)
+
+        self.actionClose = self.createAction(&quot;Quit&quot;,  self.actionQuitSlot,  &quot;Alt+Q&quot;,  &quot;exit.png&quot;,  &quot;Quit&quot;)
+        self.actionClose.setObjectName(&quot;actionQuit&quot;)
+#####################################
+
+
+#####################################
+        self.actionDelete = self.createAction(&quot;Delete&quot;,  self.actionDeleteSlot,  QKeySequence.Delete,  &quot;editdelete.png&quot;,  &quot;Delete&quot;)
+        self.actionDelete.setObjectName(&quot;actionDelete&quot;)
+
+        self.actionCopy = self.createAction(&quot;Copy&quot;,  self.actionCopySlot,  QKeySequence.Copy,  &quot;editcopy.png&quot;,  &quot;Copy&quot;)
+        self.actionCopy.setObjectName(&quot;actionCopy&quot;)
+
+        self.actionCut = self.createAction(&quot;Cut&quot;,  self.actionCutSlot,  QKeySequence.Cut,  &quot;editcut.png&quot;,  &quot;Cut&quot;)
+        self.actionCut.setObjectName(&quot;actionCut&quot;)
+
+        self.actionPaste = self.createAction(&quot;Paste&quot;,  self.actionPasteSlot,  QKeySequence.Paste,  &quot;editpaste.png&quot;,  &quot;Paste&quot;)
+        self.actionPaste.setObjectName(&quot;actionPaste&quot;)
+
+        self.actionSelect = self.createAction(&quot;&amp;Select&quot;,  self.actionSelectSlot,  &quot;Space&quot;,  &quot;cursor.png&quot;,  &quot;Move selected object&quot;)
+        self.actionSelect.setObjectName(&quot;actionSelect&quot;)
+
+        self.actionMove = self.createAction(&quot;&amp;Move&quot;,  self.actionMoveSlot,  &quot;g&quot;,  &quot;move.png&quot;,  &quot;Move selected object&quot;)
+        self.actionMove.setObjectName(&quot;actionMove&quot;)
+
+        self.actionRotate = self.createAction(&quot;&amp;Rotate&quot;,  self.actionRotateSlot,  &quot;r&quot;,  &quot;rotate.png&quot;,  &quot;Rotate selected object&quot;)
+        self.actionRotate.setObjectName(&quot;actionRotate&quot;)
+
+        self.actionScale = self.createAction(&quot;&amp;Scale&quot;,  self.actionScaleSlot,  &quot;x&quot;,  &quot;resizecol.png&quot;,  &quot;Scale selected object&quot;)
+        self.actionScale.setObjectName(&quot;actionScale&quot;)
+
+        self.actionOneClickEntityPlacement = self.createAction(&quot;&amp;OneClickEntityPlacement&quot;,  self.actionOneClickEntityPlacementSlot,  &quot;&quot;,  &quot;resizecol.png&quot;,  &quot;Add an Entity just by a click&quot;)
+        self.actionOneClickEntityPlacement.setObjectName(&quot;actionOneClickEntityPlacement&quot;)
+        self.actionOneClickEntityPlacement.setCheckable(True)
+
+#####################################
+#####################################
+        self.actionSceneExplorer = self.createAction(&quot;&amp;Scene Exlporer&quot;,  self.toggleModuleExplorer,  &quot;Alt+E&quot;,  &quot;view_tree.png&quot;,  &quot;Module Explorer&quot;,  False)
+        self.actionSceneExplorer.setObjectName(&quot;actionSceneExplorer&quot;)
+        
+        self.actionPreferences = self.createAction(&quot;&amp;Preferences&quot;,  self.togglePreferencesWindow,  &quot;Alt+P&quot;,  &quot;configure.png&quot;,  &quot;Lockenwickler Preferences&quot;,  False)
+        self.actionPreferences.setObjectName(&quot;actionPreferences&quot;)
+
+        self.actionProperty_Window = self.createAction(&quot;Pr&amp;operty Window&quot;,  self.togglePropertyWindow,  &quot;Alt+P&quot;,  &quot;unsortedlist1.png&quot;,  &quot;Property Window&quot;)
+        self.actionProperty_Window.setObjectName(&quot;actionProperty_Window&quot;)
+
+        self.actionObject_Selection = self.createAction(&quot;&amp;Model Preview Window&quot;,  self.toggleModelPreviewWindow,  &quot;Alt+O&quot;,  &quot;tux.png&quot;,  &quot;Model Preview&quot;)
+        self.actionObject_Selection.setObjectName(&quot;actionObject_Selection&quot;)
+        
+        self.actionMaterial_Selection = self.createAction(&quot;Material &amp;Preview Window&quot;,  self.toggleMaterialPreviewWindow,  &quot;Alt+M&quot;,  &quot;colors.png&quot;,  &quot;Material Preview&quot;)
+        self.actionMaterial_Selection.setObjectName(&quot;actionMaterial_Selection&quot;)
+
+        self.actionGameObjectClass_Selection = self.createAction(&quot;&amp;Game Object Class Preview Window&quot;,  self.toggleGameObjectViewWindow,  &quot;Ctrl+G&quot;,  &quot;multirow.png&quot;,  &quot;GameObjectClass Preview&quot;)
+        self.actionGameObjectClass_Selection.setObjectName(&quot;actionObject_Selection&quot;)
+
+        self.actionConsole_Window = self.createAction(&quot;&amp;Console Window&quot;,  self.toggleConsoleWindow,  &quot;Alt+C&quot;,  &quot;console.png&quot;,  &quot;Console Window&quot;)
+        self.actionConsole_Window.setObjectName(&quot;actionConsole_Window&quot;)
+        
+        self.actionToggleViewportGrid = self.createAction(&quot;&amp;Toggle Grid&quot;,  self.toggleViewportGrid,  &quot;Alt+G&quot;,  &quot;console.png&quot;,  &quot;Toggle Viewport Grid&quot;)
+        self.actionToggleViewportGrid.setObjectName(&quot;actionToggleViewportGrid&quot;)
+
+#####################################
+#####################################
+
+
+        self.menuFile.addAction(self.actionNeu)
+        self.menuFile.addAction(self.actionOpen)
+        self.menuFile.addAction(self.actionSave)
+        self.menuFile.addAction(self.actionRunModule)
+        self.menuFile.addAction(self.actionClose)
+
+        self.menuEdit.addAction(self.actionSelect)
+        self.menuEdit.addAction(self.actionMove)
+        self.menuEdit.addAction(self.actionRotate)
+        self.menuEdit.addAction(self.actionScale)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionDelete)
+        self.menuEdit.addAction(self.actionCopy)
+        self.menuEdit.addAction(self.actionCut)
+        self.menuEdit.addAction(self.actionPaste)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionOneClickEntityPlacement)
+        
+
+        self.menuView.addAction(self.actionSceneExplorer)
+        self.menuView.addAction(self.actionPreferences)
+        self.menuView.addAction(self.actionProperty_Window)
+        self.menuView.addAction(self.actionObject_Selection)
+        self.menuView.addAction(self.actionMaterial_Selection)
+        self.menuView.addAction(self.actionGameObjectClass_Selection)
+        self.menuView.addAction(self.actionConsole_Window)
+        self.menuView.addAction(self.actionToggleViewportGrid)
+        
+        self.menubar.addAction(self.menuFile.menuAction())
+        self.menubar.addAction(self.menuEdit.menuAction())
+        self.menubar.addAction(self.menuView.menuAction())
+
+        self.retranslateUi()
+        QtCore.QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.setWindowTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;MainWindow&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.menuFile.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;File&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.menuEdit.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Edit&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.menuView.setTitle(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;View&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionNeu.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;New Module&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionMove.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Move&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionRotate.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Rotate&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionSceneExplorer.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Module Explorer&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionPreferences.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Preferences&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionProperty_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Property Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionObject_Selection.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Object Selection&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionClose.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Quit&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.actionConsole_Window.setText(QtGui.QApplication.translate(&quot;MainWindow&quot;, &quot;Console Window&quot;, None, QtGui.QApplication.UnicodeUTF8))
+
+    def setupOgre(self, pluginCfgPath=&quot;./Plugins.cfg&quot;, ogreCfgPath=&quot;./ogre.cfg&quot;, logPath=&quot;./ogre.log&quot;):
+        if platform.system() == &quot;Windows&quot;:
+            pluginCfgPath=&quot;./Plugins-windows.cfg&quot;
+        else:
+            pluginCfgPath=&quot;./Plugins-linux.cfg&quot;
+
+        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
+        self.ogreRoot = root
+
+        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
+            sys.exit('Quit from Config Dialog')
+
+        root.initialise(False)
+
+        self.pivotRenderQueueListener = PivotRenderQueueListener()
+        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, &quot;OgreMainWinSceneMgr&quot;)
+        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
+        self.OgreMainWinSceneMgr.addRenderQueueListener(self.pivotRenderQueueListener)
+        
+        self.moduleName = &quot;&quot;
+        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
+        self.gocManager = self.moduleManager.gocManager
+        
+        self.ogreMainWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
+        self.gridlayout.addWidget(self.ogreMainWindow,0,0,1,1)
+        self.hboxlayout.addLayout(self.gridlayout)
+        self.setCentralWidget(self.centralwidget)
+        
+        oglog = og.LogManager.getSingleton().getDefaultLog()
+        oglog.addListener(self.consoleWindow.lockenLog)
+
+    def finishEditorSetup(self):
+        if not self.editorSetupFinished:
+            og.ResourceGroupManager.getSingleton().addResourceLocation(&quot;./media&quot;, &quot;FileSystem&quot;, &quot;General&quot;, False)
+            og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+            self.moduleManager.pivot = Pivot(self.OgreMainWinSceneMgr)
+            self.moduleManager.pivot.hide()
+            self.editorSetupFinished = True
+        
+    def update(self):
+        self.ogreRoot.renderOneFrame()
+        if platform.system() == &quot;Linux&quot;:
+            self.ogreMainWindow.updateRenderWindow()
+            self.modelSelectionDialog.updateRenderWindow()
+            self.materialSelectionDialog.updateRenderWindow()
+
+    def actionOpenSlot(self):
+        self.finishEditorSetup()
+        self.moduleManager.openLoadModuleDialog()
+
+    def actionNewSlot(self):
+        newModuleWiz = NewModuleWizard(self.moduleManager, self)
+        newModuleWiz.exec_()
+        return
+        
+    def actionSaveSlot(self):
+        self.moduleManager.save()
+        
+    def actionRunModuleSlot(self):
+        self.moduleManager.save()
+        if platform.system() == &quot;Windows&quot;:
+            workingDir = self.prefDialog.moduleCfgPath.replace(&quot;/modules/modules.cfg&quot;, &quot;&quot;)
+            executable = os.path.join(workingDir, &quot;Rastullah.exe&quot;)
+            executable = executable.replace(&quot;/&quot;,  &quot;\\&quot;)
+            if os.path.isfile(executable):
+                subprocess.Popen([executable, &quot;--module&quot;, self.moduleManager.mainModule.name], 0, None, None, None, None, None, False, False, workingDir)
+
+        
+    def actionQuitSlot(self):
+        self.close()
+
+    def actionDeleteSlot(self):
+        self.moduleManager.deleteObjects()
+
+    def actionCopySlot(self):
+        self.moduleManager.copyObjects()
+
+    def actionCutSlot(self):
+        self.moduleManager.cutObjects()
+
+    def actionPasteSlot(self):
+        self.moduleManager.pasteObjects(self.ogreMainWindow.getCameraToViewportRay())
+
+    def actionSelectSlot(self):
+        self.moduleManager.pivot.hide()
+
+    def actionMoveSlot(self):
+        self.moduleManager.pivot.setMoveMode()
+
+    def actionRotateSlot(self):
+        self.moduleManager.pivot.setRotateMode()
+
+    def actionScaleSlot(self):
+        self.moduleManager.pivot.setScaleMode()
+
+    def actionOneClickEntityPlacementSlot(self):
+        self.moduleManager.setOneClickEntityPlacement(self.actionOneClickEntityPlacement.isChecked())
+
+    def togglePreferencesWindow(self):
+        if self.prefDialog.isHidden():
+            self.prefDialog.show()
+        else:
+            self.prefDialog.hide()
+
+    def toggleModelPreviewWindow(self):
+        if self.modelSelectionDock.isHidden():
+            self.modelSelectionDock.show()
+        else:
+            self.modelSelectionDock.hide()
+    
+    def toggleMaterialPreviewWindow(self):
+        if self.materialSelectionDock.isHidden():
+            self.materialSelectionDock.show()
+        else:
+            self.materialSelectionDock.hide()
+
+    def toggleGameObjectViewWindow(self):
+        if self.gameObjectClassViewDock.isHidden():
+            self.gameObjectClassViewDock.show()
+        else:
+            self.gameObjectClassViewDock.hide()
+
+    def toggleModuleExplorer(self):
+        if self.moduleExplorerDock.isHidden():
+            self.moduleExplorerDock.show()
+        else:
+            self.moduleExplorerDock.hide()
+
+    def togglePropertyWindow(self):
+        if self.propertyDock.isHidden():
+            self.propertyDock.show()
+        else:
+            self.propertyDock.hide()
+
+    def toggleConsoleWindow(self):
+        if self.consoleDock.isHidden():
+            self.consoleDock.show()
+        else:
+            self.consoleDock.hide()
+
+    def toggleViewportGrid(self):
+        self.ogreMainWindow.toggleViewportGrid()
+
+    def createDockWindows(self):
+        self.modelSelectionDock = QtGui.QDockWidget(self.tr(&quot;Models&quot;), self)
+        self.modelSelectionDock.setObjectName(&quot;ModelSelectionDockWindow&quot;)
+        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
+        
+        self.materialSelectionDock = QtGui.QDockWidget(self.tr(&quot;Materials&quot;), self)
+        self.materialSelectionDock.setObjectName(&quot;MaterialSelectionDockWindow&quot;)
+        self.materialSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.materialSelectionDock.setWidget(self.materialSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.materialSelectionDock)
+        self.tabifyDockWidget(self.modelSelectionDock, self.materialSelectionDock)
+        
+        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr(&quot;GameObjectClasses&quot;), self)
+        self.gameObjectClassViewDock.setObjectName(&quot;GameObjectClassView&quot;)
+        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)        
+        self.tabifyDockWidget(self.modelSelectionDock, self.gameObjectClassViewDock)
+        
+        self.propertyDock = QtGui.QDockWidget(self.tr(&quot;Properties&quot;), self)
+        self.propertyDock.setObjectName(&quot;PropertyDockWindow&quot;)
+        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.propertyDock.setWidget(self.objectPropertyWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
+
+        self.moduleExplorerDock = QtGui.QDockWidget(self.tr(&quot;Module Explorer&quot;), self)
+        self.moduleExplorerDock.setObjectName(&quot;ModuleExplorerDockWindow&quot;)
+        self.moduleExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.moduleExplorerDock.setWidget(self.moduleExplorerWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.moduleExplorerDock)
+        self.tabifyDockWidget(self.moduleExplorerDock, self.propertyDock)
+        
+        self.consoleDock = QtGui.QDockWidget(self.tr(&quot;Console&quot;), self)
+        self.consoleDock.setObjectName(&quot;ConsoleDockWindow&quot;)
+        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
+        self.consoleDock.setWidget(self.consoleWindow)
+        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
+
+        self.fileToolBar = self.addToolBar(&quot;File Toolbar&quot;)
+        self.fileToolBar.setObjectName(&quot;FileToolBar&quot;)
+        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.fileToolBar.addAction(self.actionNeu)
+        self.fileToolBar.addAction(self.actionOpen)
+        self.fileToolBar.addAction(self.actionSave)
+        self.fileToolBar.addAction(self.actionRunModule)
+        self.fileToolBar.addAction(self.actionClose)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
+
+        self.moveToolBar = self.addToolBar(&quot;Transformation Bar&quot;)
+        self.moveToolBar.setObjectName(&quot;TransformationBar&quot;)
+        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.moveToolBar.addAction(self.actionSelect)
+        self.moveToolBar.addAction(self.actionMove)
+        self.moveToolBar.addAction(self.actionRotate)
+        self.moveToolBar.addAction(self.actionScale)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
+
+    def keyPressEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreMainWindow.keyPressEvent(event)
+
+    def keyReleaseEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreMainWindow.keyReleaseEvent(event)
+        pass
+
+    def onContextMenuCallback(self, actions, menus):
+        menu = QMenu(&quot;My Menu!!&quot;)
+        menu.addAction(self.actionDelete)
+        menu.addAction(self.actionCopy)
+        menu.addAction(self.actionCut)
+        menu.addAction(self.actionPaste)
+        menu.addSeparator()
+        
+        for m in menus:
+            menu.addMenu(m)
+        for a in actions:
+            menu.addAction(a)
+
+        menu.exec_(QCursor.pos())
+
+    def connectActionButtons(self):
+        pass
+
+    def saveOnClose(self):
+#        reply = QtGui.QMessageBox.question(self,  &quot;Rastullahs Lockenwickler - Unsaved Chages&quot;,  &quot;Save unsaved changes?&quot;,  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
+#        if reply == QtGui.QMessageBox.Cancel:
+#            return False
+#        if reply == QtGui.QMessageBox.Yes:
+#            print&quot;&quot;
+#            #TODO: implement save here
+        return True
+
+    def closeEvent(self,  event):
+        if self.saveOnClose():
+            settings = QtCore.QSettings()
+            settings.setValue(&quot;Preferences/moduleCfgPath&quot;, QtCore.QVariant(self.prefDialog.lineEdit.text()))
+            settings.setValue(&quot;MainWindow/Geometry&quot;,  QtCore.QVariant(self.saveGeometry()))
+            settings.setValue(&quot;MainWIndow/DockWindows&quot;,  QtCore.QVariant(self.saveState()))
+            
+            #self.ogreRoot.shutdown()
+        else:
+            event.ignore()
+
+if __name__ == &quot;__main__&quot;:
+#    # Import Psyco if available
+#    try:
+#        import psyco
+#        psyco.full(0.02)
+#        #psyco.log()
+#        #psyco.profile()
+#    except ImportError:
+#        pass
+    
+    app = QtGui.QApplication(sys.argv)
+    app.setOrganizationName(&quot;Team Pantheon&quot;)
+    app.setOrganizationDomain(&quot;rastullahs-lockenpracht.de/team&quot;)
+    app.setApplicationName(&quot;Lockenwickler&quot;)
+
+    form = Lockenwickler()
+    form.show()
+
+    app.exec_()
+    
+    sys.exit(0)
+

Modified: rl/branches/persistence2/editors/Lockenwickler/src/MaterialSelectionDialog.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/MaterialSelectionDialog.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/MaterialSelectionDialog.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,185 +1,187 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import os
-from os.path import isdir
-from os.path import isfile
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# The drag events are processed in ObgreMainWindow.py
-
-class MaterialListWidget(QListWidget):
-    def __init__(self,  parent):
-        super(MaterialListWidget, self).__init__(parent)
-        self.setDragEnabled(True)
-
-    def startDrag(self,  dropActions):
-        data = QByteArray()
-        stream = QDataStream(data,  QIODevice.WriteOnly)
-        stream &lt;&lt; self.currentItem().text()
-        mimeData = QMimeData()
-        mimeData.setData(&quot;application/x-material&quot;, data)
-        drag = QDrag(self)
-        drag.setMimeData(mimeData)
-        drag.start(Qt.CopyAction)
-
-class MaterialSelectionDialog(QDialog):
-    def __init__(self, ogreRoot, parent=None):
-        QDialog.__init__(self, parent)
-        self.ogreRoot = ogreRoot
-
-        self.setupUi()
-
-        self.connect(self.materialSearchBox, SIGNAL(&quot;textChanged(QString)&quot;),
-                               self.updateMaterialList)
-
-        self.connect(self.listWidget, SIGNAL(&quot;itemSelectionChanged ()&quot;),
-                               self.setPreviewedMaterial)
-
-        self.materialList = []
-
-        self.ogreMaterialPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
-
-        self.node = self.ogreMaterialPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
-        self.ent = None
-        self.nodeScale = og.Vector3(1,1,1)
-
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-
-
-    def setupUi(self):
-        self.setObjectName(&quot;materialPreviewDialog&quot;)
-        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(self)
-        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
-        self.materialSearchBox = QLineEdit(self)
-        self.materialSearchBox.setObjectName(&quot;materialSearchBox&quot;)
-        self.gridlayout.addWidget(self.materialSearchBox,0,0,1,1)
-
-        self.splitter = QSplitter(self)
-        self.splitter.setOrientation(Qt.Vertical)
-        self.splitter.setObjectName(&quot;splitter&quot;)
-
-        self.listWidget = MaterialListWidget(self.splitter)
-        self.listWidget.setObjectName(&quot;listWidget&quot;)
-
-        self.ogreMaterialPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,&quot;ogreMaterialPrevWindowSceneMgr&quot;)
-        self.ogreMaterialPrevWindow = OgreWidget.OgreWidget(&quot;MaterialPrevWin&quot;, self.ogreRoot, self.ogreMaterialPrevWindowSceneMgr, &quot;MaterialPrevCam&quot;,
-                                                         self.splitter)
-        self.ogreMaterialPrevWindow.setBackgroundColor(og.ColourValue(1.0, 1.0, 1.0, 1.0))
-        self.ogreMaterialPrevWindow.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)                                                 
-        
-        
-        self.ogreMaterialPrevWindow.setMinimumSize(QSize(200,200))
-        self.ogreMaterialPrevWindow.setObjectName(&quot;materialPreviewWindow&quot;)
-        self.gridlayout.addWidget(self.splitter,1,0,1,1)
-
-        self.retranslateUi()
-
-    def ogreViewportCreatedCallback(self):
-        self.ogreMaterialPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
-        
-    def retranslateUi(self):
-        self.setWindowTitle(QApplication.translate(&quot;materialPreviewDialog&quot;, &quot;Dialog&quot;, None, QApplication.UnicodeUTF8))
-
-    def setPreviewedMaterial(self):
-        if self.ent == None:
-            self.ent = self.ogreMaterialPrevWindowSceneMgr.createEntity(&quot;MaterialPrevEntity9993944&quot;, &quot;UniCube.mesh&quot;)
-            self.nodeScale = og.Vector3(1,1,1)
-
-            self.node.attachObject(self.ent)
-            self.node.setScale(og.Vector3(6,6,6))
-        self.ent.setMaterialName(str(self.listWidget.currentItem().text()))
-
-    def scanDirForMaterials(self, dir):
-        for file in os.listdir(dir):
-            curFile = dir + &quot;/&quot; + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if isdir(curFile):
-                self.scanDirForMaterials(curFile)
-                continue
-            if isfile(curFile):
-                if file.endswith(&quot;.material&quot;):
-                    f = open(curFile, &quot;r&quot;)
-                    for line in f:
-                        if line.startswith(&quot;material &quot;):
-                            l = line.replace(&quot;material &quot;, &quot;&quot;).lstrip().rstrip()
-                            l2 = l.split(&quot;:&quot;)
-                            self.materialList.append(l2[0])
-                            self.listWidget.addItem(l2[0])
-                        
-                    f.close()
-        self.listWidget.sortItems()
-
-    def updateMaterialList(self, text):
-        self.listWidget.clear()
-        for material in self.materialList:
-            if material.find(text) != -1:
-               self.listWidget.addItem(material)
-
-        self.listWidget.sortItems()
-
-    def eventFilter(self, obj, event):
-        if event.type() == 5:
-            self.startDrag()
-            event.accept()
-            return True
-
-        return False
-
-    def event(self, event):
-        if event.type() == 31: # scroll wheel turned
-            if event.delta() &lt; 0:
-                self.ogreMaterialPrevWindow.zoomCamera(-5)
-            else:
-                self.ogreMaterialPrevWindow.zoomCamera( 5)
-            return True
-
-        if event.type() == 5: #mouse moved while button down
-            rotX = (event.globalX() - self.lastMousePosX) * 0.01
-            rotY = (event.globalY() - self.lastMousePosY) * 0.01
-
-            if rotX &lt; 0.1 and rotY &lt; 0.1: # first click, don't do anything at all here
-                self.ogreMaterialPrevWindow.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-            return True
-
-        if event.type() == 3: # mouse released
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-            return True
-
-        return False
-
-    def updateRenderWindow(self):
-        self.ogreMaterialPrevWindow.update()
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+
+import sys
+import os
+from os.path import isdir
+from os.path import isfile
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# The drag events are processed in ObgreMainWindow.py
+
+class MaterialListWidget(QListWidget):
+    def __init__(self,  parent):
+        super(MaterialListWidget, self).__init__(parent)
+        self.setDragEnabled(True)
+
+    def startDrag(self,  dropActions):
+        data = QByteArray()
+        stream = QDataStream(data,  QIODevice.WriteOnly)
+        stream &lt;&lt; self.currentItem().text()
+        mimeData = QMimeData()
+        mimeData.setData(&quot;application/x-material&quot;, data)
+        drag = QDrag(self)
+        drag.setMimeData(mimeData)
+        drag.start(Qt.CopyAction)
+
+class MaterialSelectionDialog(QDialog):
+    def __init__(self, ogreRoot, parent=None):
+        QDialog.__init__(self, parent)
+        self.ogreRoot = ogreRoot
+
+        self.setupUi()
+
+        self.connect(self.materialSearchBox, SIGNAL(&quot;textChanged(QString)&quot;),
+                               self.updateMaterialList)
+
+        self.connect(self.listWidget, SIGNAL(&quot;itemSelectionChanged ()&quot;),
+                               self.setPreviewedMaterial)
+
+        self.materialList = []
+
+        self.ogreMaterialPrevWindow.setBackgroundColor(og.ColourValue(0,1,0))
+
+        self.node = self.ogreMaterialPrevWindowSceneMgr.getRootSceneNode().createChildSceneNode()
+        self.ent = None
+        self.nodeScale = og.Vector3(1,1,1)
+
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+
+
+    def setupUi(self):
+        self.setObjectName(&quot;materialPreviewDialog&quot;)
+        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(self)
+        self.gridlayout.setObjectName(&quot;materialSelectionLayout&quot;)
+        self.gridlayout.setContentsMargins(2, 2, 2, 2)
+        
+        self.materialSearchBox = QLineEdit(self)
+        self.materialSearchBox.setObjectName(&quot;materialSearchBox&quot;)
+        self.gridlayout.addWidget(self.materialSearchBox,0,0,1,1)
+
+        self.splitter = QSplitter(self)
+        self.splitter.setOrientation(Qt.Vertical)
+        self.splitter.setObjectName(&quot;splitter&quot;)
+
+        self.listWidget = MaterialListWidget(self.splitter)
+        self.listWidget.setObjectName(&quot;listWidget&quot;)
+
+        self.ogreMaterialPrevWindowSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC,&quot;ogreMaterialPrevWindowSceneMgr&quot;)
+        self.ogreMaterialPrevWindow = OgreWidget.OgreWidget(&quot;MaterialPrevWin&quot;, self.ogreRoot, self.ogreMaterialPrevWindowSceneMgr, &quot;MaterialPrevCam&quot;,
+                                                         self.splitter)
+        self.ogreMaterialPrevWindow.setBackgroundColor(og.ColourValue(1.0, 1.0, 1.0, 1.0))
+        self.ogreMaterialPrevWindow.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)                                                 
+        
+        
+        self.ogreMaterialPrevWindow.setMinimumSize(QSize(200,200))
+        self.ogreMaterialPrevWindow.setObjectName(&quot;materialPreviewWindow&quot;)
+        self.gridlayout.addWidget(self.splitter,1,0,1,1)
+
+        self.retranslateUi()
+
+    def ogreViewportCreatedCallback(self):
+        self.ogreMaterialPrevWindow.renderWindow.getViewport(0).setOverlaysEnabled(False)
+        
+    def retranslateUi(self):
+        self.setWindowTitle(QApplication.translate(&quot;materialPreviewDialog&quot;, &quot;Dialog&quot;, None, QApplication.UnicodeUTF8))
+
+    def setPreviewedMaterial(self):
+        if self.ent == None:
+            self.ent = self.ogreMaterialPrevWindowSceneMgr.createEntity(&quot;MaterialPrevEntity9993944&quot;, &quot;UniCube.mesh&quot;)
+            self.nodeScale = og.Vector3(1,1,1)
+
+            self.node.attachObject(self.ent)
+            self.node.setScale(og.Vector3(6,6,6))
+        self.ent.setMaterialName(str(self.listWidget.currentItem().text()))
+
+    def scanDirForMaterials(self, dir):
+        for file in os.listdir(dir):
+            curFile = dir + &quot;/&quot; + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if isdir(curFile):
+                self.scanDirForMaterials(curFile)
+                continue
+            if isfile(curFile):
+                if file.endswith(&quot;.material&quot;):
+                    f = open(curFile, &quot;r&quot;)
+                    for line in f:
+                        if line.startswith(&quot;material &quot;):
+                            l = line.replace(&quot;material &quot;, &quot;&quot;).lstrip().rstrip()
+                            l2 = l.split(&quot;:&quot;)
+                            self.materialList.append(l2[0])
+                            self.listWidget.addItem(l2[0])
+                        
+                    f.close()
+        self.listWidget.sortItems()
+
+    def updateMaterialList(self, text):
+        self.listWidget.clear()
+        for material in self.materialList:
+            if material.find(text) != -1:
+               self.listWidget.addItem(material)
+
+        self.listWidget.sortItems()
+
+    def eventFilter(self, obj, event):
+        if event.type() == 5:
+            self.startDrag()
+            event.accept()
+            return True
+
+        return False
+
+    def event(self, event):
+        if event.type() == 31: # scroll wheel turned
+            if event.delta() &lt; 0:
+                self.ogreMaterialPrevWindow.zoomCamera(-5)
+            else:
+                self.ogreMaterialPrevWindow.zoomCamera( 5)
+            return True
+
+        if event.type() == 5: #mouse moved while button down
+            rotX = (event.globalX() - self.lastMousePosX) * 0.01
+            rotY = (event.globalY() - self.lastMousePosY) * 0.01
+
+            if rotX &lt; 0.1 and rotY &lt; 0.1: # first click, don't do anything at all here
+                self.ogreMaterialPrevWindow.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+            return True
+
+        if event.type() == 3: # mouse released
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+            return True
+
+        return False
+
+    def updateRenderWindow(self):
+        self.ogreMaterialPrevWindow.update()

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModelSelectionDialog.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 import sys
@@ -73,10 +74,11 @@
 
     def setupUi(self):
         self.setObjectName(&quot;modelPreviewDialog&quot;)
-        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
+        self.resize(QSize(QRect(0,0,272,450).size()).expandedTo(self.minimumSizeHint()))
 
         self.gridlayout = QGridLayout(self)
         self.gridlayout.setObjectName(&quot;gridlayout&quot;)
+        self.gridlayout.setContentsMargins(2, 2, 2, 2)
 
         self.modelSearchBox = QLineEdit(self)
         self.modelSearchBox.setObjectName(&quot;modelSearchBox&quot;)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModuleExplorer.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,27 +1,69 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
-#dienstag 24.03 15.50
 import sys
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *
 import ogre.renderer.OGRE as og
 
+# get the light out of a light node
+def extractLight(node):
+        i = 0
+        num = node.numAttachedObjects()
+        while i &lt; node.numAttachedObjects():
+            c = node.getAttachedObject(i)
+            tp = str(type(c))
+            if tp == &quot;&lt;class 'ogre.renderer.OGRE._ogre_.Light'&gt;&quot;:
+                return c
+            
+            i += 1
+
+class ExplorerOptionsDlg(QDialog):
+    def __init__(self, lights, gameObjects, entities, zones, parent = None):
+        super(ExplorerOptionsDlg, self).__init__(parent)
+        
+        buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        layout = QVBoxLayout()
+        
+        self.lightCheckBox = QCheckBox(&quot;Show Lights&quot;)
+        self.lightCheckBox.setChecked(lights)        
+        layout.addWidget(self.lightCheckBox)
+        
+        self.gameObjectsCheckBox = QCheckBox(&quot;Show Game-Objects&quot;)
+        self.gameObjectsCheckBox.setChecked(gameObjects)        
+        layout.addWidget(self.gameObjectsCheckBox)
+        
+        self.entitiesCheckBox = QCheckBox(&quot;Show Entities&quot;)
+        self.entitiesCheckBox.setChecked(entities)        
+        layout.addWidget(self.entitiesCheckBox)
+        
+        self.zonesCheckBox = QCheckBox(&quot;Show Zones&quot;)
+        self.zonesCheckBox.setChecked(zones)        
+        layout.addWidget(self.zonesCheckBox)
+        
+        layout.addWidget(buttonBox)
+        layout.setContentsMargins(2, 2, 2, 2)
+        self.setLayout(layout)
+        
+        self.connect(buttonBox, SIGNAL(&quot;accepted()&quot;), self, SLOT(&quot;accept()&quot;))        
+        self.connect(buttonBox, SIGNAL(&quot;rejected()&quot;), self, SLOT(&quot;reject()&quot;))
+
 class NameInputDlg(QDialog):
     def __init__(self, parent = None):
         super(NameInputDlg, self).__init__(parent)
@@ -31,12 +73,12 @@
         layout = QVBoxLayout()
         layout.addWidget(self.nameInput)
         layout.addWidget(buttonBox)
+        layout.setContentsMargins(2, 2, 2, 2)
         self.setLayout(layout)
         
         self.connect(buttonBox, SIGNAL(&quot;accepted()&quot;), self, SLOT(&quot;accept()&quot;))        
         self.connect(buttonBox, SIGNAL(&quot;rejected()&quot;), self, SLOT(&quot;reject()&quot;))
         
-        
 class ModuleTreeWidget(QTreeWidget):
     def __init__(self, parent = None):
         super(ModuleTreeWidget, self).__init__(parent)
@@ -47,17 +89,14 @@
         self.onMenuCallback = None
         self.setAnimated(True)
 
-#        clearAction= QAction(&quot;Clear Window&quot;,  self)
-#        self.consoleWindow.textEdit.addAction(clearAction)
-#        self.consoleWindow.textEdit.setContextMenuPolicy(Qt.ActionsContextMenu)
-#        clearAction.setShortcut(&quot;Ctrl + R&quot;)
-#        self.connect(clearAction, SIGNAL(&quot;triggered()&quot;), self.consoleWindow.textEdit.clear)
-
+        self.setHeaderLabels([&quot;Structure&quot;, &quot;Visibility&quot;])
+        self.setSelectionMode(QAbstractItemView.ExtendedSelection)
+        
     def setMenuCallback(self, callback):
         self.onMenuCallback = callback
         
     def doMenu(self, point):
-        self.onMenuCallback(self.mapToGlobal(point))
+        self.onMenuCallback(point)
 
 class ModuleExplorer(QWidget):
     def __init__(self, parent=None):
@@ -66,41 +105,144 @@
         
         self.sceneTreeView.setMenuCallback(self.onMenu)
         self.connect(self.sceneTreeView, SIGNAL(&quot;itemClicked (QTreeWidgetItem *,int)&quot;), self.onClick)
-        
+        self.connect(self.sceneTreeView, SIGNAL(&quot;itemSelectionChanged ()&quot;), self.onSelectionChanged)
+
         vBoxLayout = QVBoxLayout()
         vBoxLayout.addWidget(self.sceneTreeView)
+        vBoxLayout.setContentsMargins(0, 0, 0, 0)
+        
+        self.setLayout(vBoxLayout)
+        self.resize(QSize(QRect(0,0,272,450).size()).expandedTo(self.minimumSizeHint()))
 
-        self.setLayout(vBoxLayout)
-        
         self.nodeDict = {}
         
         self.moduleManager = None
         self.mapSelectedCallback = None
+        self.selectionChangedCallback = None
+        self.mapItems = []
         
         self.lastSelectedMap = None
+        self.onMenuPoint = None
         
+        self.showLights = True
+        self.showGameObjects = True
+        self.showEntities = True
+        self.showZones = True
+
+    def selectItems(self, selectedItems):
+        self.disconnect(self.sceneTreeView, SIGNAL(&quot;itemSelectionChanged ()&quot;), self.onSelectionChanged)
+        self.deselectAll()
+        
+        if selectedItems is None:
+            return
+        
+        for so in selectedItems:
+            nodeName = so.entity.getParentNode().getName()
+            items = self.sceneTreeView.findItems(nodeName, Qt.MatchFixedString | Qt.MatchRecursive)
+            for item in items:
+                self.sceneTreeView.setItemSelected(item, True)
+        self.connect(self.sceneTreeView, SIGNAL(&quot;itemSelectionChanged ()&quot;), self.onSelectionChanged)
+    
+    def selectItem(self, so, select):
+        self.disconnect(self.sceneTreeView, SIGNAL(&quot;itemSelectionChanged ()&quot;), self.onSelectionChanged)
+        nodeName = so.entity.getParentNode().getName()
+       
+        items = None
+        
+        if nodeName.startswith(&quot;light_&quot;) and self.showLights: 
+            items = self.sceneTreeView.findItems(extractLight(so.entity.getParentNode()).getName(), Qt.MatchFixedString | Qt.MatchRecursive)    
+        elif nodeName.startswith(&quot;gameobject_&quot;) and self.showGameObjects:
+            go = so.entity.getUserObject()
+            items = self.sceneTreeView.findItems(go.gocName + &quot; id:&quot; + str(go.inWorldId), Qt.MatchFixedString | Qt.MatchRecursive)    
+        elif nodeName.startswith(&quot;entity_&quot;) and self.showEntities:
+            items = self.sceneTreeView.findItems(so.entityName, Qt.MatchFixedString | Qt.MatchRecursive)    
+        elif nodeName.startswith(&quot;area_&quot;) and self.showZones:
+            area = so.entity.getUserObject()
+            items = self.sceneTreeView.findItems(&quot;Area &quot; + str(area.id), Qt.MatchFixedString | Qt.MatchRecursive)    
+        
+        if select and items is not None:
+            for item in items:
+                self.sceneTreeView.setItemSelected(item, True)
+                self.sceneTreeView.expandItem(item)
+        else:
+            if items is not None:
+                for item in items:
+                    self.sceneTreeView.setItemSelected(item, False)
+        self.connect(self.sceneTreeView, SIGNAL(&quot;itemSelectionChanged ()&quot;), self.onSelectionChanged)
+        
+    def onSelectionChanged(self):
+        if self.selectionChangedCallback is None:
+            return
+
+        nodeNames = {}
+        
+        # get all maps and add them as a key to the dictionary
+        # append a empty list to that key
+        items = self.sceneTreeView.findItems(&quot;Map: &quot;, Qt.MatchStartsWith | Qt.MatchCaseSensitive | Qt.MatchRecursive)
+        for item in items:
+            nodeNames[str(item.text(0))] = []
+            
+        # get all zones and add them as a key to the dictionary
+        # append a empty list to that key            
+        items = self.sceneTreeView.findItems(&quot;Zone: &quot;, Qt.MatchStartsWith | Qt.MatchCaseSensitive | Qt.MatchRecursive)
+        for item in items:
+            nodeNames[str(item.text(0))] = []
+        
+        #get all selected items
+        items = self.sceneTreeView.selectedItems()
+        
+        #end remove all the things from the list we actually don't want to be selected
+        for item in items:
+            if str(item.text(0)).startswith(&quot;Scene: &quot;) or str(item.text(0)).startswith(&quot;Map: &quot;) or str(item.text(0)).startswith(&quot;Zone: &quot;):
+                items.remove(item)
+        
+        for item in items:
+            parentName =  str(item.text(0))
+                        
+            name = str(item.data(0, Qt.UserRole).toString())
+            if len &gt; 0:
+                nodeNames[str(item.parent().text(0))].append(name)
+                
+        self.selectionChangedCallback(nodeNames)
+
+    def deselectAll(self):
+        self.disconnect(self.sceneTreeView, SIGNAL(&quot;itemSelectionChanged ()&quot;), self.onSelectionChanged)
+        
+        for item in self.sceneTreeView.selectedItems():
+            self.sceneTreeView.setItemSelected(item, False)
+            
+        self.connect(self.sceneTreeView, SIGNAL(&quot;itemSelectionChanged ()&quot;), self.onSelectionChanged)
+
     def onClick(self, item, column):
         if self.mapSelectedCallback is None:
             return
         
         name = str(item.text(0))
         if name.startswith(&quot;Map: &quot;):
-            self.mapSelectedCallback(str(item.parent().text(0)).replace(&quot;Scene: &quot;, &quot;&quot;), name.replace(&quot;Map: &quot;, &quot;&quot;))
-            self.lastSelectedMap = name
-        elif name.startswith(&quot;Scene: &quot;):
-            if item.childCount &gt; 0:
-                self.mapSelectedCallback(name.replace(&quot;Scene: &quot;, &quot;&quot;), None)
-                return
-            self.mapSelectedCallback(name.replace(&quot;Scene: &quot;, &quot;&quot;), str(item.child(0).text(0)).replace(&quot;Map: &quot;, &quot;&quot;))
-            self.lastSelectedMap = name
-        else:
-            self.mapSelectedCallback(str(item.parent().parent().text(0)).replace(&quot;Scene: &quot;, &quot;&quot;), str(item.parent().text(0)).replace(&quot;Map: &quot;, &quot;&quot;))
-            self.lastSelectedMap = name
+            if column == 1:
+                if self.module.getMap(name.replace(&quot;Map: &quot;, &quot;&quot;)).isHidden:
+                    item.setIcon(1 , QIcon(&quot;media/icons/14_layer_visible.png&quot;))
+                    self.module.getMap(name.replace(&quot;Map: &quot;, &quot;&quot;)).show()
+                else:
+                    item.setIcon(1 , QIcon(&quot;media/icons/14_layer_invisible.png&quot;))
+                    self.module.getMap(name.replace(&quot;Map: &quot;, &quot;&quot;)).hide()
             
-
-        
+        elif name.startswith(&quot;Zone: &quot;):
+            if self.moduleManager and column == 1:
+                if self.moduleManager.zoneManager.getZone(name.replace(&quot;Zone: &quot;, &quot;&quot;)).isHidden:
+                    item.setIcon(1 , QIcon(&quot;media/icons/14_layer_visible.png&quot;))
+                    self.moduleManager.zoneManager.getZone(name.replace(&quot;Zone: &quot;, &quot;&quot;)).show()
+                else:
+                    item.setIcon(1 , QIcon(&quot;media/icons/14_layer_invisible.png&quot;))
+                    self.moduleManager.zoneManager.getZone(name.replace(&quot;Zone: &quot;, &quot;&quot;)).hide()
+            
     def onMenu(self, point):
         if self.moduleManager is not None:
+            index = self.sceneTreeView.indexAt(point)
+            if not index.isValid():
+                return
+            self.onMenuPoint = point
+            
             menu = QMenu(self)
             
             newSceneAction= QAction(&quot;New Scene&quot;,  self)
@@ -111,12 +253,58 @@
                 newMapAction= QAction(&quot;New Map&quot;,  self)
                 menu.addAction(newMapAction)
                 self.connect(newMapAction, SIGNAL(&quot;triggered()&quot;), self.onNewMap)
-
+            elif self.sceneTreeView.currentItem() is not None and str(self.sceneTreeView.currentItem().text(0)).startswith(&quot;Map:&quot;):
+                item = self.sceneTreeView.itemAt(point)
+                self.onClick(item, None)
+                
+                hideMapAction = QAction(&quot;Hide&quot;,  self)
+                menu.addAction(hideMapAction)
+                self.connect(hideMapAction, SIGNAL(&quot;triggered()&quot;), self.onHideMap)
+                revealMapAction = QAction(&quot;Show&quot;,  self)
+                menu.addAction(revealMapAction)
+                self.connect(revealMapAction, SIGNAL(&quot;triggered()&quot;), self.onShowMap)
+                setActiveMapAction = QAction(&quot;Set Active&quot;,  self)
+                menu.addAction(setActiveMapAction)
+                self.connect(setActiveMapAction, SIGNAL(&quot;triggered()&quot;), self.onSetActiveMap)
+                
             deleteAction= QAction(&quot;Delete&quot;,  self)
             menu.addAction(deleteAction)
             self.connect(deleteAction, SIGNAL(&quot;triggered()&quot;), self.onDelete)
+                
+            if self.sceneTreeView.currentItem() is not None and str(self.sceneTreeView.currentItem().text(0)).startswith(&quot;Map:&quot;):
+                menu.addSeparator()
+                
+                newZoneAction = QAction(&quot;New Zone&quot;,  self)
+                menu.addAction(newZoneAction)
+                self.connect(newZoneAction, SIGNAL(&quot;triggered()&quot;), self.onNewZone)
             
-            menu.exec_(point)
+            menu.addSeparator()
+            optionsAction= QAction(&quot;Open Explorer Options&quot;,  self)
+            menu.addAction(optionsAction)
+            self.connect(optionsAction, SIGNAL(&quot;triggered()&quot;), self.onOptions)
+            
+            menu.exec_(QCursor().pos())
+    
+    def onOptions(self):
+        dlg = ExplorerOptionsDlg(self.showLights, self.showGameObjects, self.showEntities, self.showZones, self)
+        if dlg.exec_():
+            self.showLights = dlg.lightCheckBox.isChecked()
+            self.showGameObjects = dlg.gameObjectsCheckBox.isChecked()
+            self.showEntities = dlg.entitiesCheckBox.isChecked()
+            self.showZones = dlg.zonesCheckBox.isChecked()
+            self.updateView()
+            
+    def onHideMap(self):
+        if self.module:
+            item = self.sceneTreeView.itemAt(self.onMenuPoint)
+            item.setIcon(1 , QIcon(&quot;media/icons/14_layer_invisible.png&quot;))
+            self.module.getMap(self.lastSelectedMap.replace(&quot;Map: &quot;, &quot;&quot;)).hide()   
+            
+    def onShowMap(self):
+        if self.module:
+            item = self.sceneTreeView.itemAt(self.onMenuPoint)
+            item.setIcon(1, QIcon(&quot;media/icons/14_layer_visible.png&quot;))
+            self.module.getMap(self.lastSelectedMap.replace(&quot;Map: &quot;, &quot;&quot;)).show()
       
     def onNewScene(self):
         dlg = NameInputDlg(self)
@@ -131,11 +319,40 @@
             sceneName = str(self.sceneTreeView.currentItem().text(0)).replace(&quot;Scene: &quot;, &quot;&quot;)
             self.moduleManager.addMapToScene(sceneName, str(dlg.nameInput.text()))
             self.updateView()
-        
+    
+    def onNewZone(self):
+        dlg = NameInputDlg(self)
+        if dlg.exec_():
+            self.moduleManager.addZoneToMap(str(dlg.nameInput.text()))
+            self.updateView()
+    
     def onDelete(self):
         print &quot;delete&quot;
-      
+        
+    def paintLastSelectedMapBlue(self):
+        print self.lastSelectedMap
+        for item in self.mapItems:
+            if str(item.text(0)) == self.lastSelectedMap:
+                brush = item.foreground(0)
+                brush.setColor(QColor(&quot;blue&quot;))
+                item.setForeground(0, brush)
+                item.setIcon(0, QIcon(&quot;media/icons/2rightarrow.png&quot;))
+            else:
+                brush = item.foreground(0)
+                brush.setColor(QColor(&quot;black&quot;))
+                item.setForeground(0, brush)
+                item.setIcon(0, QIcon())
+                
+    def onSetActiveMap(self):
+        item = self.sceneTreeView.currentItem()
+        self.lastSelectedMap = str(item.text(0))
+        self.paintLastSelectedMapBlue()
+        sceneName = str(item.parent().text(0).replace(&quot;Scene: &quot;, &quot;&quot;))
+        mapName = str(item.text(0).replace(&quot;Map: &quot;, &quot;&quot;))
+        self.mapSelectedCallback(sceneName, mapName)
+        
     def updateView(self):
+        self.mapItems = []
         self.sceneTreeView.clear()
         
         for s in self.module.scenes:
@@ -144,22 +361,56 @@
             
             for m in s.mapFiles:
                 self.parseMap(m, sceneRootItem)
+        
+        self.paintLastSelectedMapBlue()
 
-
     def parseMap(self, map, sceneRootItem):
         childItem =  QTreeWidgetItem(sceneRootItem)
+        self.mapItems.append(childItem)
+        sceneRootItem.setExpanded(True)
         mn = &quot;Map: &quot; + map.mapName
+        
+        childItem.setIcon(1 , QIcon(&quot;media/icons/14_layer_visible.png&quot;))
+        if map.isHidden:
+            childItem.setIcon(1 , QIcon(&quot;media/icons/14_layer_invisible.png&quot;))
+        
         childItem.setText(0, mn)
         if mn == self.lastSelectedMap:
             childItem.setSelected(True)
-            childItem.parent().setExpanded(True)
-        
+            childItem.setExpanded(True)
+            
+        if self.showZones:
+            self.parseZone(map, childItem)
+            
         i = 0
-        while i &lt; map.mapNode.numChildren():
-            childItem2 = QTreeWidgetItem(childItem) 
-            childItem2.setText(0, map.mapNode.getChild(i).getName())
+        while i &lt; map.mapNode.numChildren(): 
+            if map.mapNode.getChild(i).getName().startswith(&quot;light_&quot;) and self.showLights:
+                childItem2 = QTreeWidgetItem(childItem) 
+                childItem2.setData(0, Qt.UserRole, QVariant(map.mapNode.getChild(i).getName()))
+                childItem2.setText(0, extractLight(map.mapNode.getChild(i)).getName()) 
+            elif map.mapNode.getChild(i).getName().startswith(&quot;gameobject_&quot;) and self.showGameObjects:
+                childItem2 = QTreeWidgetItem(childItem) 
+                go = map.mapNode.getChild(i).getAttachedObject(0).getUserObject()
+                childItem2.setData(0, Qt.UserRole, QVariant(map.mapNode.getChild(i).getName()))
+                childItem2.setText(0, go.gocName + &quot; id:&quot; + str(go.inWorldId)) 
+            elif map.mapNode.getChild(i).getName().startswith(&quot;entity_&quot;) and self.showEntities:
+                childItem2 = QTreeWidgetItem(childItem) 
+                childItem2.setData(0, Qt.UserRole, QVariant(map.mapNode.getChild(i).getName()))
+                childItem2.setText(0, map.mapNode.getChild(i).getAttachedObject(0).getName()) 
             i = i+1
 
+        
+#            thetype = None
+#            try:
+#                thetype = str(type(map.mapNode.getChild(i).getAttachedObject(0)))
+#            except:
+#                i = i+1
+#                continue
+#                
+#            childItem3 = QTreeWidgetItem(childItem2) 
+#            childItem3.setText(0, thetype)
+#            i = i+1
+            
 
 # this crashed in linux
 #        iter = map.mapNode.getChildIterator()
@@ -169,7 +420,21 @@
 #            if  val is not None:
 #                childItem2.setText(0, val.getName())
 
-        
+    def parseZone(self, map, parentItem):
+        for zone in map.zoneList:
+            childItem = QTreeWidgetItem(parentItem) 
+            childItem.setText(0, &quot;Zone: &quot; + zone.name)
+            childItem.setData(0, Qt.UserRole, QVariant(zone.zoneNode.getName()))
+            childItem.setIcon(0, QIcon(&quot;media/icons/dissociatecell.png&quot;))
+            childItem.setIcon(1, QIcon(&quot;media/icons/14_layer_visible.png&quot;))
+            
+            i = 0
+            for area in zone.areaList:
+                childItem2 = QTreeWidgetItem(childItem)
+                childItem2.setText(0, &quot;Area &quot; + str(area.id))
+                childItem2.setData(0, Qt.UserRole, QVariant(area.areaNode.getName()))
+                i += 1
+                
     def setCurrentModule(self, module):
         self.module = module
         self.updateView()
@@ -179,3 +444,6 @@
         
     def setMapSelectedCallback(self, callback):
         self.mapSelectedCallback = callback
+
+    def setSelectionChangedCallback(self, callback):
+        self.selectionChangedCallback = callback

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ModuleManager.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 import sys
 import codecs
@@ -31,33 +32,25 @@
 from PyQt4.QtGui import *
 
 from SelectionBuffer import *
+from DepthBuffer import *
 from MovePivot import *
 from GameObjectClassManager import *
+from MyRaySceneQueryListener import *
+from ZoneManager import ZoneManager
 
 
-#                &lt;zone name=&quot;Testzone&quot;&gt;
-#                        &lt;area type=&quot;sphere&quot;&gt;
-#                                &lt;position x=&quot;-10&quot; y=&quot;0&quot; z=&quot;-5&quot;/&gt;
-#                                &lt;scale x=&quot;6&quot; y=&quot;6&quot; z=&quot;6&quot;/&gt;
-#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
-#                        &lt;/area&gt;
-#                        &lt;area type=&quot;mesh&quot; meshfile=&quot;arc_UnbHaus_07.mesh&quot;&gt;
-#                                &lt;position x=&quot;25&quot; y=&quot;0&quot; z=&quot;-50&quot;/&gt;
-#                                &lt;transition_distance&gt;0.5&lt;/transition_distance&gt;
-#                        &lt;/area&gt;
-#                        &lt;area type=&quot;sphere&quot; subtract=&quot;true&quot;&gt;
-#                                &lt;position x=&quot;-11&quot; y=&quot;0&quot; z=&quot;-4&quot;/&gt;
-#                                &lt;scale x=&quot;2&quot; y=&quot;2&quot; z=&quot;2&quot;/&gt;
-#                        &lt;/area&gt;
-#                        &lt;light name=&quot;red pointlight&quot;/&gt;
-#                        &lt;light name=&quot;green spotlight&quot;/&gt;
-#                        &lt;sound name=&quot;ruchin001.ogg&quot;/&gt;
-#                        &lt;trigger name=&quot;test&quot; classname=&quot;TestTrigger&quot;&gt;
-#                                &lt;property name=&quot;message&quot; type=&quot;STRING&quot; data=&quot;You triggered the dooms day device!&quot; /&gt;
-#                        &lt;/trigger&gt;
-#                &lt;/zone&gt;
+# get the light out of a light node
+def extractLight(node):
+        i = 0
+        num = node.numAttachedObjects()
+        while i &lt; node.numAttachedObjects():
+            c = node.getAttachedObject(i)
+            tp = str(type(c))
+            if tp == &quot;&lt;class 'ogre.renderer.OGRE._ogre_.Light'&gt;&quot;:
+                return c
+            
+            i += 1
 
-
 # make the xml file more pretty
 def indent(elem, level=0):
     i = &quot;\n&quot; + level*&quot;  &quot;
@@ -75,8 +68,42 @@
         if level and (not elem.tail or not elem.tail.strip()):
             elem.tail = i
 
+# creates unique names for new entities
+def createUniqueEntityName(sceneManager, name = None):
+    n = &quot;&quot;
+    if name is None:
+        n = &quot;dropMesh&quot; + str(ModuleManager.dropCount)
+    else:
+        n = name
+        
+    while sceneManager.hasEntity(n):
+        n = &quot;dropMesh&quot; + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+    return n
+        
+def printVector3(vec):
+    print str(vec.x) + &quot;;&quot; + str(vec.y) + &quot;;&quot; + str(vec.z)
+    
+class EntityCustomOptions(og.UserDefinedObject):
+    def __init__(self, receivesShadow = True, staticgeometrygroup = 0, physicsproxytype = &quot;none&quot;, renderingdistance = &quot;20000&quot;):
+        og.UserDefinedObject.__init__(self)
+        self.receivesShadow = receivesShadow
+        self.staticgeometrygroup = staticgeometrygroup
+        self.physicsproxytype = physicsproxytype
+        self.renderingdistance = renderingdistance
+        self.materialName = &quot;NotChanged&quot;
+        
+        ModuleManager.entityCustomOptionsDict.append(self)
+        
+    def copy(self):
+            return EntityCustomOptions(self.receivesShadow, self.staticgeometrygroup, self.physicsproxytype, self.renderingdistance)
+        
+    def getType(self):
+            return &quot;EntityCustomOptions&quot;
+
 class Map():
-    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, emptyMap = False):
+    def __init__(self, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyMap = False):
         self.pathToMapFile = pathToFile
         
         mapName = pathToFile.replace(&quot;\\&quot;, &quot;/&quot;)
@@ -90,21 +117,48 @@
         self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
         self.ogreRoot = ogreRoot
         self.gocManager = gocManager
-
+        self.zoneManager = zoneManager
+        self.isHidden = False
+        
+        self.zoneList = []
+        
         if not emptyMap:
             xmlTree = xml.parse(pathToFile)
             root = xmlTree.getroot()
 
             if root.attrib[&quot;formatVersion&quot;] == &quot;0.4.0&quot;:
                 self.parseMapNodes(root.find(&quot;nodes&quot;))
-                #self.parseMapZones(root.find(&quot;zones&quot;))
+                self.parseMapZones(root.find(&quot;zones&quot;))
             else:
                 print pathToFile + &quot; has wrong format version. It needs to be 0.4.0&quot;
                 return
 
+    def hide(self):
+        try:
+            self.sceneManager.getRootSceneNode().removeChild(self.mapNode)
+        except:
+            print &quot;Error: map is already hidden!&quot;
+            return
+        
+        self.isHidden = True
+        
+    def show(self):
+        try:
+            self.sceneManager.getRootSceneNode().addChild(self.mapNode)
+        except:
+            print &quot;Error: map is already shown!&quot;
+            return
+        
+        self.isHidden = False
+    
+    def parseMapZones(self, zonesElement):
+        self.zoneManager.parseZonesFromXml(zonesElement, self)
+    
     def parseMapNodes(self, nodeElement):
+        nodes = nodeElement.getiterator(&quot;gameobject&quot;)
+        self.createGameObjects(nodes)
+        
         nodes = nodeElement.getiterator(&quot;entity&quot;)
-        
         self.createEntites(nodes)
 
         nodes = nodeElement.getiterator(&quot;light&quot;)
@@ -113,9 +167,6 @@
         nodes = nodeElement.getiterator(&quot;sound&quot;)
         self.createSound(nodes)
 
-        nodes = nodeElement.getiterator(&quot;gameobject&quot;)
-        self.createGameObjects(nodes)
-
         nodes = nodeElement.getiterator(&quot;particlesystem&quot;)
         self.createParticleSystems(nodes)
 
@@ -127,8 +178,36 @@
                 num = int(entityName.replace(&quot;dropMesh&quot;,  &quot;&quot;))
                 if ModuleManager.dropCount &lt; num:
                     ModuleManager.dropCount = num
+                elif ModuleManager.dropCount &lt; num:
+                    ModuleManager.dropCount = num + 1
                     
             meshFile = nodes.attrib[&quot;meshfile&quot;]
+            
+            eco = EntityCustomOptions()
+            
+            try:
+                if nodes.attrib[&quot;receivesShadow&quot;] == &quot;False&quot; or nodes.attrib[&quot;receivesShadow&quot;] == &quot;false&quot;:
+                    eco.receivesShadow = &quot;False&quot;
+            except:
+                pass
+            try:
+                eco.staticgeometrygroup = int(nodes.attrib[&quot;staticgeometrygroup&quot;])
+            except:
+                pass
+            try:
+                eco.physicsproxy = nodes.attrib[&quot;physicsproxy&quot;]
+            except:
+                pass
+            try:
+                eco.renderingdistance = float(nodes.attrib[&quot;renderingdistance&quot;])
+            except:
+                pass
+            try:
+                eco.renderingdistance
+                nodes.attrib[&quot;materialName&quot;]
+            except:
+                pass
+                
             nodePosition = None
             nodeScale = None
             qw = qx = qy = qz = None
@@ -152,11 +231,12 @@
                     nodeScale = og.Vector3(scalex, scaley, scalez)
 
             try:
-                e = self.sceneManager.createEntity(entityName, meshFile)
+                e = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager,  entityName), meshFile)
             except:
                 print &quot;Warning: Meshfile &quot; + meshFile + &quot; could not be found.&quot;
-                continue
+                return
 
+            e.setUserObject(eco)
             n = self.mapNode.createChild(&quot;entity_&quot; + entityName + &quot;_node&quot;)
             n.attachObject(e)
             n.setPosition(nodePosition)
@@ -170,13 +250,17 @@
             lightVisible = bool(l.attrib[&quot;visible&quot;])
             castShadows = bool(l.attrib[&quot;castShadows&quot;])
             lightPosition = None
+            lightDirection = None
             colourDiffuse = None
             colourSpecular = None
             lightAttenuationRange = None
             lightAttenuationConstant= None
             lightAttenuationLinear = None
             lightAttenuationQuadratic = None
-
+            spotlightinner = None
+            spotlightouter = None
+            falloff = None 
+                
             transformations = l.getiterator()
             for t in transformations:
                 if t.tag == &quot;position&quot;:
@@ -198,25 +282,38 @@
                     lightAttenuationRange = float(t.attrib[&quot;range&quot;])
                     lightAttenuationConstant= float(t.attrib[&quot;constant&quot;])
                     lightAttenuationLinear = float(t.attrib[&quot;linear&quot;])
-                    lightAttenuationQuadratic = float(t.attrib[&quot;quadratic&quot;])
+                    lightAttenuationQuadric  = float(t.attrib[&quot;quadratic&quot;])
+                elif t.tag == &quot;spotlightrange&quot;:
+                    spotlightinner = float(t.attrib[&quot;inner&quot;])
+                    spotlightouter = float(t.attrib[&quot;outer&quot;])
+                    falloff = float(t.attrib[&quot;falloff&quot;])
+                    
+            light = self.sceneManager.createLight(lightName)
             
-
-            light = self.sceneManager.createLight(lightName)
+            if lightType == &quot;point&quot;:
+                light.setType(og.Light.LT_POINT)            
+            elif lightType == &quot;spot&quot;:
+                light.setType(og.Light.LT_SPOTLIGHT)
+            elif lightType == &quot;directional&quot;:
+                light.setType(og.Light.LT_DIRECTIONAL)
+            
             light.setVisible(lightVisible)
             light.setCastShadows(castShadows)
-            light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadratic)
-            light.setDiffuseColour(colourDiffuse)
-            light.setSpecularColour(colourSpecular)
+            if lightAttenuationRange is not None and lightAttenuationConstant is not None and lightAttenuationLinear is not None and lightAttenuationQuadric is not None:
+                light.setAttenuation(lightAttenuationRange, lightAttenuationConstant, lightAttenuationLinear, lightAttenuationQuadric)
+            if colourDiffuse:
+                light.setDiffuseColour(colourDiffuse)
+            if colourSpecular:
+                light.setSpecularColour(colourSpecular)
+            if spotlightinner and spotlightouter and spotlightouter: 
+                light.setSpotlightRange(spotlightinner, spotlightouter, falloff)
             
-            if lightType == &quot;point&quot;:
-                light.setType(og.Light.LT_POINT)
-            
             e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
             n = self.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
+            n.attachObject(light)
             n.attachObject(e)
-            n.attachObject(light)
-            n.setPosition(lightPosition)
-
+            if lightPosition:
+                n.setPosition(lightPosition)
             
     def createSound(self, soundNodes):
         #raise NotImplementedError
@@ -225,11 +322,16 @@
     def createGameObjects(self, gameObjectNodes):
         for g in gameObjectNodes:
             classid = g.attrib[&quot;class&quot;]
+            
             id = int(g.attrib[&quot;id&quot;])
+            if ModuleManager.dropCount &lt; id:
+                ModuleManager.dropCount = id
+            elif ModuleManager.dropCount &lt; id:
+                ModuleManager.dropCount = id + 1
+                
             state = g.attrib[&quot;state&quot;]
             nodePosition = None
             nodeRotation = None
-            nodeScale = None
 
             transformations = g.getiterator()
             for t in transformations:
@@ -244,16 +346,12 @@
                     qy = float(t.attrib[&quot;qy&quot;])
                     qz = float(t.attrib[&quot;qz&quot;])
                     nodeRotation = og.Quaternion(qw, qx, qy, qz)
-                elif t.tag == &quot;scale&quot;:
-                    x = float(t.attrib[&quot;x&quot;])
-                    y = float(t.attrib[&quot;y&quot;])
-                    z = float(t.attrib[&quot;z&quot;])
-                    nodeScale = og.Vector3(x, y, z)
 
             go = self.gocManager.getGameObjectWithClassId(classid)
             if go is not None:
                 meshFile = go.getMeshFileName()
-                ent = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(id), str(meshFile))
+                
+                ent = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
                 dropNode = self.mapNode.createChild(&quot;gameobject_&quot; + &quot;dropNode&quot; + str(id))
                 dropNode.attachObject(ent)
 
@@ -261,11 +359,11 @@
                     dropNode.setPosition(nodePosition)
                 if nodeRotation:
                     dropNode.setOrientation(nodeRotation)
-                if nodeScale:
-                    dropNode.setScale(nodeScale)
 
                 go = GameObjectRepresentation(id, classid, dropNode, meshFile)
+                self.gocManager.addGameObjectRepresentation(go)
                 go.inWorldId = id
+                go.state = state
                 ent.setUserObject(go)
 
 
@@ -286,7 +384,13 @@
                 if n.name.startswith(&quot;entity_&quot;):
                     entElem = xml.SubElement(nodesElem, &quot;entity&quot;)
                     entElem.attrib[&quot;name&quot;] = n.getAttachedObject(0).getName()
+                    print &quot;Saving Entity: &quot; + n.getAttachedObject(0).getName()
                     entElem.attrib[&quot;meshfile&quot;] = n.getAttachedObject(0).getMesh().getName()
+   
+                    entElem.attrib[&quot;receivesShadow&quot;] = str(n.getAttachedObject(0).getUserObject().receivesShadow).lower()
+                    entElem.attrib[&quot;staticgeometrygroup&quot;] = str(n.getAttachedObject(0).getUserObject().staticgeometrygroup)
+                    entElem.attrib[&quot;physicsproxytype&quot;] = str(n.getAttachedObject(0).getUserObject().physicsproxytype)
+                    entElem.attrib[&quot;renderingdistance&quot;] = str(n.getAttachedObject(0).getUserObject().renderingdistance)
                     
                     posElem = xml.SubElement(entElem, &quot;position&quot;)
                     posElem.attrib[&quot;x&quot;] = str(n.getPosition().x)
@@ -303,11 +407,95 @@
                     scaleElem.attrib[&quot;x&quot;] = str(n.getScale().x)
                     scaleElem.attrib[&quot;y&quot;] = str(n.getScale().y)
                     scaleElem.attrib[&quot;z&quot;] = str(n.getScale().z)
-                
+                    
+                elif n.name.startswith(&quot;gameobject_&quot;):
+                    goElem = xml.SubElement(nodesElem, &quot;gameobject&quot;)
+                    mname = n.name
+                    print &quot;Saving GOID: &quot; + str(n.getAttachedObject(0).getUserObject().inWorldId)
+                    goElem.attrib[&quot;class&quot;] = str(n.getAttachedObject(0).getUserObject().gocName)
+                    goElem.attrib[&quot;state&quot;] = str(n.getAttachedObject(0).getUserObject().state)
+                    goElem.attrib[&quot;id&quot;] = str(n.getAttachedObject(0).getUserObject().inWorldId)
+                    
+                    posElem = xml.SubElement(goElem, &quot;position&quot;)
+                    posElem.attrib[&quot;x&quot;] = str(n.getPosition().x)
+                    posElem.attrib[&quot;y&quot;] = str(n.getPosition().y)
+                    posElem.attrib[&quot;z&quot;] = str(n.getPosition().z)
+                    
+                    rotElem = xml.SubElement(goElem, &quot;rotation&quot;)
+                    rotElem.attrib[&quot;qw&quot;] = str(n.getOrientation().w)
+                    rotElem.attrib[&quot;qx&quot;] = str(n.getOrientation().x)
+                    rotElem.attrib[&quot;qy&quot;] = str(n.getOrientation().y)
+                    rotElem.attrib[&quot;qz&quot;] = str(n.getOrientation().z)
+                    
+                elif n.name.startswith(&quot;light_&quot;):
+                    light = extractLight(n)
+                    lightName = light.getName()
+                    print &quot;Saving Light: &quot; + lightName
+                    lightType = light.getType()
+                    isVisible = &quot;true&quot;
+                    if not light.getVisible():
+                        isVisible = &quot;false&quot;
+                    
+                    castShadows = &quot;false&quot;
+                    if light.getCastShadows():
+                        castShadows = &quot;true&quot;
+                    
+                    if lightType == og.Light.LT_POINT:
+                        lightType = &quot;point&quot;
+                    elif lightType == og.Light.LT_SPOTLIGHT:
+                        lightType = &quot;spot&quot;
+                    elif lightType == og.Light.LT_DIRECTIONAL:
+                        lightType = &quot;directional&quot;
+                    
+                    
+                    lightElem = xml.SubElement(nodesElem, &quot;light&quot;)
+                    lightElem.attrib[&quot;name&quot;] = lightName
+                    lightElem.attrib[&quot;type&quot;] = lightType
+                    lightElem.attrib[&quot;visible&quot;] = isVisible
+                    lightElem.attrib[&quot;castShadows&quot;] = castShadows
+                    
+                    if lightType == &quot;point&quot; or lightType == &quot;spot&quot;:
+                        posElem = xml.SubElement(lightElem, &quot;position&quot;)
+                        posElem.attrib[&quot;x&quot;] = str(n.getPosition().x)
+                        posElem.attrib[&quot;y&quot;] = str(n.getPosition().y)
+                        posElem.attrib[&quot;z&quot;] = str(n.getPosition().z)
+                    
+                    colDiffuseElem = xml.SubElement(lightElem, &quot;colourDiffuse&quot;)
+                    colDiffuseElem.attrib[&quot;r&quot;] = str(light.getDiffuseColour().r)
+                    colDiffuseElem.attrib[&quot;g&quot;] = str(light.getDiffuseColour().g)
+                    colDiffuseElem.attrib[&quot;b&quot;] = str(light.getDiffuseColour().b)
+
+                    colSpecularElem = xml.SubElement(lightElem, &quot;colourSpecular&quot;)
+                    colSpecularElem.attrib[&quot;r&quot;] = str(light.getSpecularColour().r)
+                    colSpecularElem.attrib[&quot;g&quot;] = str(light.getSpecularColour().g)
+                    colSpecularElem.attrib[&quot;b&quot;] = str(light.getSpecularColour().b)
+                    
+                    lightAttenuationElem = xml.SubElement(lightElem, &quot;lightAttenuation&quot;)
+                    lightAttenuationElem.attrib[&quot;range&quot;] = str(light.getAttenuationRange())
+                    lightAttenuationElem.attrib[&quot;constant&quot;] = str(light.getAttenuationConstant())
+                    lightAttenuationElem.attrib[&quot;linear&quot;] = str(light.getAttenuationLinear())
+                    lightAttenuationElem.attrib[&quot;quadratic&quot;] = str(light.getAttenuationQuadric())
+                    
+                    if lightType == &quot;spot&quot;:
+                        spotligthRangeElem = xml.SubElement(lightElem, &quot;spotlightrange&quot;)
+                        spotligthRangeElem.attrib[&quot;inner&quot;] = str(light.getSpotlightInnerAngle().valueDegrees())
+                        spotligthRangeElem.attrib[&quot;outer&quot;] = str(light.getSpotlightOuterAngle().valueDegrees())
+                        spotligthRangeElem.attrib[&quot;falloff&quot;] = str(light.getSpotlightFalloff())
+                        
+                    if lightType == &quot;spot&quot; or lightType == &quot;directional&quot;:
+                        directionElem = xml.SubElement(lightElem, &quot;direction&quot;)
+                        dir = og.Vector3()
+                        n.getOrientation().ToAxes(dir)
+                        directionElem.attrib[&quot;x&quot;] = str(dir.x)
+                        directionElem.attrib[&quot;y&quot;] = str(dir.y)
+                        directionElem.attrib[&quot;z&quot;] = str(dir.z)
+                        
             i = i+1
             
+        self.zoneManager.saveZonesToXml(root, self)
         indent(root)
         xml.ElementTree(root).write(self.pathToMapFile)
+
 # caused a linux crash
 #        iter = self.mapNode.getChildIterator()
 #        while iter.hasMoreElements():
@@ -315,12 +503,13 @@
 #            print name
 
 class Scene():
-    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, emptyScene = False, sceneName = &quot;NewScene&quot;):
+    def __init__(self, moduleroot, pathToFile, sceneManager, ogreRoot, gocManager, zoneManager, emptyScene = False, sceneName = &quot;NewScene&quot;):
         self.moduleRoot = moduleroot
         self.pathToFile = pathToFile
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
         self.gocManager = gocManager
+        self.zoneManager = zoneManager
         self.mapFiles = [] # a list in case the module has more than one map file
         mappaths = []
         self.name = sceneName
@@ -336,11 +525,11 @@
                 mappaths.append(join(self.moduleRoot, join(&quot;maps&quot;, m.attrib[&quot;file&quot;])))
                 
             for m in mappaths:
-                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager))
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
             
     def addMap(self, name):
         path = join(self.moduleRoot, join(&quot;maps&quot;, name + &quot;.rlmap.xml&quot;))
-        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, True))
+        self.mapFiles.append(Map(path, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True))
         
     def save(self):
         root = xml.Element(&quot;scene&quot;)
@@ -354,13 +543,12 @@
         indent(root)
         xml.ElementTree(root).write(self.pathToFile)
 
-
-
 class Module():
-    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager):
+    def __init__(self,name, modulePath, sceneManager, ogreRoot, gameObjectManager, zoneManager):
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
         self.gocManager = gameObjectManager
+        self.zoneManager = zoneManager
         
         self.name = name
         self.moduleRoot = join(modulePath, name)
@@ -369,15 +557,18 @@
         self.hasDependencies = False
         self.moduleDependencies = []
 
+        self.modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
 
         self.gofFiles = [] # gof File list
 
         self.scenes =[]
 
         self.isLoaded = False
-
+        
+        self.playerStart = None
+        
     def addScene(self, name):
-        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, (&quot;maps/&quot; + name + &quot;.rlscene&quot;)), self.sceneManager, self.ogreRoot, self.gocManager, True, name))
+        self.scenes.append(Scene(self.moduleRoot, join(self.moduleRoot, (&quot;maps/&quot; + name + &quot;.rlscene&quot;)), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager, True, name))
     
     def addMapToScene(self, sceneName, mapName):
         for scene in self.scenes:
@@ -389,9 +580,8 @@
         
     
     def isCommon(self):
-        modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
+        if isfile(self.modConfig): # is the modconfig existing?
+            f = codecs.open(self.modConfig, 'r', 'utf-8')
         else:
             print (&quot;Module.isCommon() Error: couldn't find module config&quot;)
             return
@@ -410,7 +600,14 @@
                     isDependencieLine = False
                 else:
                     self.hasDependencies = True
-                    self.moduleDependencies.append(lStripped.split('&quot;')[1])
+                    pl = lStripped.split('&quot;')
+                    i = 1
+                    while i &lt; 100: 
+                        try:
+                            self.moduleDependencies.append(pl[i])
+                            i += 2
+                        except IndexError, e:
+                            break
 
             elif lStripped == &quot;def getDependencies()&quot;:
                 isDependencieLine = True
@@ -420,18 +617,25 @@
     def load(self):
         if self.isLoaded:
             return
-
+        
         self.isLoaded = True
-        modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
+        self.modConfig = join(self.moduleRoot,  &quot;scripts/moduleconfig.rb&quot;)
+        if isfile(self.modConfig): # is the modconfig existing?
+            f = codecs.open(self.modConfig, 'r', 'utf-8')
         else:
             print (&quot;Module.load: Error: couldn't find module config&quot;)
             return
 
-        #for i, line in enumerate(f):
-            #lStripped = line.strip() #strip the whitespace away, not needed here
-
+        for line in f:
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith(&quot;hero = $GOM.getGameObject(&quot;):
+                try:
+                    self.playerStart = int(line.split(&quot;(&quot;)[1].split(&quot;)&quot;)[0])
+                except ValueError, e:
+                    print self.modConfig + &quot; ValueError: &quot; + str(e)
+                    self.playerStart = None
+                    continue
+                    
         self.setResourcePaths()
         
         try:
@@ -448,16 +652,33 @@
             cmd = join(self.moduleRoot, &quot;maps/*.rlscene&quot;)
             sceneFile = glob.glob(cmd)
             self.loadScenes(sceneFile)
-            
-        
+                
     def loadScenes(self, sceneFiles):
         for s in sceneFiles:
-            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager))
+            self.scenes.append(Scene(self.moduleRoot, s, self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
 
     def save(self):
         for s in self.scenes:
             s.save()
+            
+        self.saveModuleConfig()
 
+    def saveModuleConfig(self):
+        if self.playerStart is not None:
+            f = open(self.modConfig, &quot;r&quot;)
+            
+            newconfig = &quot;&quot;
+            for line in f:
+                if line.startswith(&quot;       hero = $GOM.getGameObject(&quot;):
+                    newconfig += &quot;       hero = $GOM.getGameObject(&quot; + str(self.playerStart) + &quot;);\n&quot;
+                else:
+                    newconfig += line
+            f.close()
+            
+            f = open(self.modConfig, &quot;w&quot;)
+            f.write(newconfig)
+            f.close()
+
     def setResourcePaths(self, recurseFolder = &quot;&quot;):
         if recurseFolder == &quot;&quot;:
             rootFolder = self.moduleRoot
@@ -466,8 +687,6 @@
 
         for file in os.listdir(rootFolder):
             curFile = join(rootFolder, file)
-            if file == &quot;WindyGrass.program&quot;:
-                print &quot;yes!&quot;
 
             if file.startswith('.'): #ignore dot files (hidden)
                 continue
@@ -489,10 +708,26 @@
                 for m in s.mapFiles:
                         if m.mapName == mapName:
                             return m
-                            
+
+class ProgressBarThread(QThread):
+    def __init__(self, min, max, moduleName):
+        QThread.__init__(self)
+        self.progress = QProgressDialog(&quot;Loading &quot; + moduleName, &quot;Abort Loading&quot;, min, max, None);
+        self.progress.setWindowModality(Qt.WindowModal)
+
+    def setProgress(self, progress, labelText):
+        self.progress.setLabelText(labelText)
+        self.progress.setValue(progress)
+        
+    def run(self):
+        self.progress.show()
+        self.exec_()
+
+        
 class ModuleManager():
     dropCount = 0
-        
+    entityCustomOptionsDict = []
+    
     def __init__(self,  ogreRoot,  sceneManager):
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
@@ -503,10 +738,6 @@
 
         self.gocManager = GameObjectClassManager()
         
-        # we need to hold a reference to the game object representaions ourself
-        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
-        # and deletes the object
-        self.gameObjectRepresentationDict = []
 
         self.mainModule = None
         self.mainModuledependencieList =[]
@@ -528,20 +759,31 @@
         self.middleMouseDown = False
         self.rightMouseDown = False
 
-       
         self.dropNode = None
         self.dropEntity = None
         self.dropCollisionPlane = og.Plane(og.Vector3().UNIT_Y, og.Vector3().ZERO)
         self.dropMat = None
         
-        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
         self.moduleConfigIsParsed = False
 
         self.selectionBuffer = None
+        self.depthBuffer = None
         self.propertyWindow = None
     
         self.oneClickEntityPlacement = False
-    
+        
+        self.onContextMenuCallback = None
+        self.contextMenuClickPosition = None
+        self.contextMenuRay = None
+        
+        self.playerStartGameObjectId = None
+        
+        self.entityCustomOptionsDict = []
+        
+        self.raySceneQueryListener = MyRaySceneQueryListener()
+        
+        self.zoneManager = ZoneManager(self.sceneManager)
+        
     def resetParsedModuleConfig(self):
         self.moduleConfigIsParsed = False
         self.moduleList = []
@@ -560,7 +802,7 @@
             if line.startswith('module='):
                 splines = line.split('=')
                 str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace(&quot;/modules.cfg&quot;,  &quot;&quot;), self.sceneManager, self.ogreRoot, self.gocManager))
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace(&quot;/modules.cfg&quot;,  &quot;&quot;), self.sceneManager, self.ogreRoot, self.gocManager, self.zoneManager))
 
         self.moduleConfigIsParsed = True
 
@@ -579,7 +821,7 @@
 
         self.parseModuleConfig()
 
-        dlg = QDialog()
+        dlg = QDialog(QApplication.focusWidget())
         list = QListWidget()
         btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
         dlg.connect(btnBox, SIGNAL(&quot;accepted()&quot;), dlg.accept)
@@ -598,40 +840,43 @@
 
     # I'm sorry for this
     def loadModule(self, moduleName):
+        t = og.Timer()
+        
+#        self.progress = ProgressBarThread(0, 8, moduleName)
+#        self.progress.start()
+        
         for m in self.moduleList:
             if m.name == moduleName:
                 if m.hasDependencies: # load modules on wich the main module depends before the main module is loaded
                     for moduleDependencie in m.moduleDependencies:
                         for m2 in self.moduleList:
                             if m2.name == moduleDependencie:
+#                                self.progress.setProgress(2, &quot;Loading Dependencie: &quot; + moduleDependencie)
                                 m2.load()
                                 self.modelSelectionDialog.scanDirForModels(m2.moduleRoot)
                                 self.materialSelectionDialog.scanDirForMaterials(m2.moduleRoot)
                                 self.mainModuledependencieList.append(m2)
 
+#                self.progress.setProgress(4, &quot;Loading &quot; + moduleName)
                 m.load()
+#                self.progress.setProgress(6, &quot;Scan for models...&quot;)
                 self.modelSelectionDialog.scanDirForModels(m.moduleRoot)
+#                self.progress.setProgress(8, &quot;Scan for materials&quot;)
                 self.materialSelectionDialog.scanDirForMaterials(m.moduleRoot)
                 self.mainModule = m
                 self.moduleExplorer.setCurrentModule(m)
-                
-        self.moduleExplorer.updateView()
-        ModuleManager.dropCount += 1
-#        n = self.sceneManager.getRootSceneNode().createChildSceneNode()
-#        e = self.sceneManager.createEntity(&quot;west342wt346t&quot;,  &quot;UniCube.mesh&quot;)
-#        e.setMaterialName(&quot;PlainColorGLSL&quot;)
-#        e.getSubEntity(0).setCustomParameter(1, og.Vector4(0.0, 0.0, 1.0, 1.0))
-#
-#        e2 = self.sceneManager.createEntity(&quot;west342wt34635t&quot;,  &quot;UniSphere.mesh&quot;)
-#        e2.setMaterialName(&quot;PlainColor&quot;)
-#        e2.getSubEntity(0).setCustomParameter(1, og.Vector4(0, 1, 0, 1))
-#        n.attachObject(e)
-#        n.attachObject(e2)
-#        n.setScale(og.Vector3(10, 5, 20))
-        
+
         if self.selectionBuffer is None:
-            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget(&quot;OgreMainWin&quot;))
+            self.selectionBuffer = SelectionBuffer(self.sceneManager, self.ogreRoot.getRenderTarget(&quot;OgreMainWin&quot;), self, self.zoneManager)
 
+#        if self.depthBuffer is None:
+#            self.depthBuffer = DepthBuffer(self.sceneManager, self.ogreRoot.getRenderTarget(&quot;OgreMainWin&quot;))
+
+
+#        self.progress.quit()
+        print &quot;Time to load module: &quot; + str(t.getMilliseconds() / 1000.0) + &quot; seconds&quot;
+        del t
+
     def addSceneToModule(self, name):
         if self.mainModule is not None:
             self.mainModule.addScene(name)
@@ -643,36 +888,50 @@
     def setModuleExplorer(self, moduleExplorer):
         self.moduleExplorer = moduleExplorer
         self.moduleExplorer.setMapSelectedCallback(self.selectMapCallback)
+        self.moduleExplorer.setSelectionChangedCallback(self.selectionChangedCallback)
         self.moduleExplorer.setModuleManager(self)
     
     def setPropertyWindow(self, propertyWin):
         self.propertyWindow = propertyWin
+    
+    def selectionChangedCallback(self, items):
+        self.resetSelection()
+        self.userSelectionList = self.selectionBuffer.manualSelectObjects(items)
         
     def selectMapCallback(self, sceneName, mapName):
         self.currentMap = self.mainModule.getMap(mapName, sceneName)
+        self.zoneManager.currentMap = self.currentMap
         if self.currentMap is None:
-            QMessageBox.warning(None, &quot;Don't forget to select a map&quot;, &quot;You won't be happy without a map!&quot;)
+            print &quot;Don't forget to select a map&quot;
 
         
     # called when a click into Main Ogre Window occurs
     def selectionClick(self, screenX, screenY, ray,  controlDown=False,  shiftDown=False):
         if self.oneClickEntityPlacement:
-            meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
-            self.startDropModelAction(meshFile, ray)
-            return
-            
+            if self.modelSelectionDialog.listWidget.currentItem() is not None:
+                meshFile = str(self.modelSelectionDialog.listWidget.currentItem().text())
+                self.startDropModelAction(meshFile, ray)
+                self.moduleExplorer.updateView()
+                return
+            else:
+                print &quot;Warning: OneClickEntityPlacement still runing on without any selected mesh!&quot;
+                return
+                
+        #self.depthBuffer.onSelectionClick(screenX, screenY)
+        
         so = None
         if self.selectionBuffer is not None:
             so = self.selectionBuffer.onSelectionClick(screenX, screenY)
         
         if so is not None:
-            if not so.isPivot:
-                self.propertyWindow.showProperties(so)
-                
+            if not so.isPivot:                
                 if not controlDown and not shiftDown:
                     self.resetSelection()
                     so.setSelected(True)
                     self.userSelectionList.append(so)
+                    self.propertyWindow.showProperties(so)
+                    self.moduleExplorer.deselectAll()
+                    self.moduleExplorer.selectItem(so, True)
                     self.updatePivots()
                 elif controlDown and not shiftDown:
                     so.setSelected(True)
@@ -682,6 +941,8 @@
                             return # object already selected
 
                     self.userSelectionList.append(so)
+                    self.propertyWindow.showProperties(so)
+                    self.moduleExplorer.selectItem(so, True)
                     self.updatePivots()
 
 
@@ -690,12 +951,16 @@
                         if so == selo:
                             so.setSelected(False)
                             self.userSelectionList.remove(selo)
+                            self.moduleExplorer.selectItem(selo, False)
                     self.updatePivots()
+                
             else:
                 #so.entity is the pivot direction that was clicked
                 self.pivot.startTransforming(so.entity,  self.userSelectionList)
         else:
             self.resetSelection() # click in empty space, deselect everything
+            self.moduleExplorer.selectItems(None)
+            self.propertyWindow.clear()
             if self.pivot is not None:
                 self.pivot.hide()
 
@@ -727,6 +992,13 @@
 
         for so in self.userSelectionList:
             node = so.entity.getParentNode()
+            if node.getName().startswith(&quot;area_&quot;):
+                self.zoneManager.deleteArea(so.entity.getUserObject())
+                continue
+            elif node.getName().startswith(&quot;light_&quot;):
+                light = extractLight(node)
+                self.sceneManager.destroyLight(light)
+                
             node.detachAllObjects()
             self.sceneManager.destroySceneNode(node)
             self.sceneManager.destroyEntity(so.entity)
@@ -734,68 +1006,55 @@
 
         self.userSelectionList = []
 
-    def incrementNameSuffixNumber(self, name):
-        newName = &quot;&quot;
-        split = name.split(&quot;_&quot;)
-        lastPart = len(split)-1
-        newName = name.rstrip(split[lastPart])
-        newName = newName + str(self.numerOfCopys)
-
-#        if split[lastPart].isdigit() and not split[lastPart].startswith(&quot;0&quot;):
-#            num = int(split[lastPart])
-#            num = num + 1
-#            newName = name.rstrip(split[lastPart])
-#            newName = newName + str(num)
-#        else:
-#            newName = name + &quot;_1&quot;
-
-        self.numerOfCopys = self.numerOfCopys + 1
-        return newName
-
     def copyObjects(self):
-        if len(self.userSelectionList) &lt; 1:
+        if len(self.userSelectionList) &lt; 1 or self.currentMap is None:
+            print &quot;Warning: No map selected!&quot;
             return
 
         newSelectionList = []
 
         for so in self.userSelectionList:
             if so.entity.getUserObject() is not None:
-                if so.entity.getUserObject().getType() == &quot;GAME_OBJECT_REPRESENTATION&quot;:
+                if str(so.entity.getParentNode().getName()).startswith(&quot;gameobject_&quot;):
                     go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
                     meshFile = go.getMeshFileName()
 
                     if go is not None:
-                        newEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(ModuleManager.dropCount), str(meshFile))
-                        newNode = self.currentMap.mapNode.createChild(&quot;gameObject_dropNode&quot; + str(ModuleManager.dropCount))
+                        newEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
+                        newNode = self.currentMap.mapNode.createChild(&quot;gameobject_dropNode&quot; + str(ModuleManager.dropCount))
                         newNode.attachObject(newEntity)
                         newNode.setPosition(so.entity.getParentNode().getPosition())
 
                         newGO = GameObjectRepresentation(ModuleManager.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
-                        self.gameObjectRepresentationDict.append(newGO)
+                        self.gocManager.addGameObjectRepresentation(newGO)
                         newEntity.setUserObject(newGO)
-                        newGO.setPosition(og.Vector3(0, 0, 0))
 
-                        newSO = SelectionObject(newEntity, so.distance)
+                        newSO = SelectionObject(newEntity)
                         newSO.setSelected(True)
                         newSelectionList.append(newSO)
                         ModuleManager.dropCount += 1
-            else:
-                nodeName = &quot;entity_dropNode&quot; + str(ModuleManager.dropCount)
-                newNode = self.currentMap.mapNode.createChild(nodeName)
+                elif str(so.entity.getParentNode().getName()).startswith(&quot;entity_&quot;):
+                    nodeName = &quot;entity_dropNode&quot; + str(ModuleManager.dropCount)
+                    newNode = self.currentMap.mapNode.createChild(nodeName)
 
-                entityName = &quot;dropMesh&quot; + str(ModuleManager.dropCount)
-                newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+                    entityName = createUniqueEntityName(self.sceneManager)
+                    newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
 
-                newNode.attachObject(newEntity)
-                newNode.setPosition(so.entity.getParentNode().getPosition())
-                newNode.setOrientation(so.entity.getParentNode().getOrientation())
-                newNode.setScale(so.entity.getParentNode().getScale())
+                    eco = so.entity.getUserObject().copy()
+                    newEntity.setUserObject(eco)
 
-                newSO = SelectionObject(newEntity)
-                newSO.setSelected(True)
-                newSelectionList.append(newSO)
-                ModuleManager.dropCount += 1
+                    newNode.attachObject(newEntity)
+                    newNode.setPosition(so.entity.getParentNode().getPosition())
+                    newNode.setOrientation(so.entity.getParentNode().getOrientation())
+                    newNode.setScale(so.entity.getParentNode().getScale())
 
+                    newSO = SelectionObject(newEntity)
+                    newSO.setSelected(True)
+                    newSelectionList.append(newSO)
+                    ModuleManager.dropCount += 1
+                elif str(so.entity.getParentNode().getName()).startswith(&quot;light_&quot;):
+                    print &quot;Can't copy lights yet :)&quot;
+
         self.resetSelection()
         self.userSelectionList = newSelectionList
 
@@ -840,8 +1099,9 @@
             self.pivot.stopTransforming()
 
     def resetSelection(self):
-        for so in self.userSelectionList:
-            so.setSelected(False)
+        if self.userSelectionList is not None:
+            for so in self.userSelectionList:
+                so.setSelected(False)
 
         self.userSelectionList = []
 
@@ -860,11 +1120,15 @@
         self.mainModule.save()
 
     def startDropGameObjectAction(self, classid, ray):
+        if self.currentMap is None:
+            print &quot;No map selected!&quot;
+            return
+            
         go = self.gocManager.getGameObjectWithClassId(classid)
 
         if go is not None:
             meshFile = go.getMeshFileName()
-            dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(ModuleManager.dropCount), str(meshFile))
+            dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), str(meshFile))
             dropNode = self.currentMap.mapNode.createChild(&quot;gameobject_dropNode&quot; + str(ModuleManager.dropCount))
             dropNode.attachObject(dropEntity)
 
@@ -875,11 +1139,15 @@
                 dropNode.setPosition(ray.getPoint(50))
 
             self.dropGO = GameObjectRepresentation(ModuleManager.dropCount, classid, dropNode, meshFile)
+            self.gocManager.addGameObjectRepresentation(self.dropGO)
             dropEntity.setUserObject(self.dropGO)
 
         ModuleManager.dropCount += 1
 
     def moveDropGameObjectAction(self, ray):
+        if self.currentMap is None:
+            return
+        
         result = og.Math.intersects(ray, self.dropCollisionPlane)
         if result.first == True:
             self.dropGO.setPosition(ray.getPoint(result.second))
@@ -887,6 +1155,8 @@
             self.dropGO.setPosition(ray.getPoint(50))
 
     def finishDropGameObjectAction(self, ray):
+        self.moduleExplorer.updateView()
+        self.dropGO = None
         return
 
     def startDropModelAction(self, meshFile, ray):
@@ -894,8 +1164,11 @@
             print &quot;No map selected!&quot;
             return
             
-        self.dropEntity = self.sceneManager.createEntity(&quot;dropMesh&quot; + str(ModuleManager.dropCount), meshFile)
-
+        self.dropEntity = self.sceneManager.createEntity(createUniqueEntityName(self.sceneManager), meshFile)
+        
+        eco = EntityCustomOptions()
+        self.dropEntity.setUserObject(eco)
+        
         self.dropNode = self.currentMap.mapNode.createChild(&quot;entity_dropNode&quot; + str(ModuleManager.dropCount))
         self.dropNode.attachObject(self.dropEntity)
 
@@ -918,6 +1191,7 @@
             self.dropNode.setPosition(ray.getPoint(50))
     
     def finishDropModelAction(self, ray):
+        self.moduleExplorer.updateView()
         return
 
     def startDropMaterialAction(self, text):
@@ -931,6 +1205,7 @@
         if so is not None:
             if not so.entity.getNumSubEntities() &gt; 1:
                 so.entity.setMaterialName(self.dropMat)
+                so.entity.getUserObject().materialName = self.dropMat
             else:
                 i = 0
                 text = &quot;Warning this Entity has more than one SubEntities with the folloing materials: \n\n&quot;
@@ -944,6 +1219,138 @@
                     return
                 if reply == QMessageBox.Yes:
                     so.entity.setMaterialName(self.dropMat)
+                    so.entity.getUserObject().materialName = self.dropMat
         
     def setOneClickEntityPlacement(self, state):
         self.oneClickEntityPlacement = state
+    
+    def createLight(self, name):
+        pos = og.Vector3()
+        
+        query = self.sceneManager.createRayQuery(self.contextMenuRay)
+        query.ray = self.contextMenuRay
+        query.setSortByDistance(True)
+        query.execute(self.raySceneQueryListener)
+        if self.raySceneQueryListener.dist &lt; 100000:
+            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
+            self.raySceneQueryListener.dist = 100000
+            
+        light = None
+        if not self.sceneManager.hasLight(name):
+            light = self.sceneManager.createLight(name)
+            
+        return light,  pos
+        
+    def addPointLight(self):
+        if self.currentMap is None:
+            print &quot;No map selected!&quot;
+            return
+            
+        lightName = &quot;pointLight&quot; + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+        light, pos = self.createLight(lightName)
+        printVector3(pos)
+        
+        if not light:
+            print &quot;Error while creating light&quot;
+            return
+            
+        light.setType(og.Light.LT_POINT)
+        
+        e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
+        n = self.currentMap.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
+        n.attachObject(light)
+        n.attachObject(e)
+        n.setPosition(pos)
+        self.moduleExplorer.updateView()
+        
+    def addSpotLight(self):
+        if self.currentMap is None:
+            print &quot;No map selected!&quot;
+            return
+            
+        lightName = &quot;spotLight&quot; + str(ModuleManager.dropCount)
+        ModuleManager.dropCount += 1
+        
+        light, pos = self.createLight(lightName)
+        printVector3(pos)
+        
+        if not light:
+            print &quot;Error while creating light&quot;
+            return
+            
+        light.setType(og.Light.LT_SPOTLIGHT)
+        
+        e = self.sceneManager.createEntity(lightName + &quot;_ent&quot;, &quot;lightbulp.mesh&quot;)
+        n = self.currentMap.mapNode.createChild(&quot;light_&quot; + lightName + &quot;_node&quot;)
+        n.attachObject(light)
+        n.attachObject(e)
+        n.setPosition(pos)
+        self.moduleExplorer.updateView()
+        
+    def addZoneToMap(self, name):
+        self.zoneManager.createZone(name)
+        self.moduleExplorer.updateView()
+        
+    def setPlayerStart(self):
+        self.mainModule.playerStart = str(self.playerStartGameObjectId)
+        print &quot;setting Player Start to &quot; + str(self.playerStartGameObjectId)
+    
+    def onContextMenu(self, screenX, screenY, ray):
+        menus = []
+        actions = []
+        pla = self.createAction(&quot;Pointlight&quot;, self.addPointLight, None, &quot;idea.png&quot;)
+        pls = self.createAction(&quot;Spotlight&quot;, self.addSpotLight, None, &quot;idea.png&quot;)
+        
+        lightMenu = QMenu(&quot;Add Light&quot;)
+        lightMenu.addAction(pla)
+        lightMenu.addAction(pls)
+        menus.append(lightMenu)
+        
+        so = self.selectionBuffer.onSelectionClick(screenX, screenY)
+        self.contextMenuClickPosition = og.Vector2(screenX, screenY)
+        self.contextMenuRay = ray
+        
+        pos = og.Vector3()
+        query = self.sceneManager.createRayQuery(self.contextMenuRay)
+        query.ray = self.contextMenuRay
+        query.setSortByDistance(True)
+        query.execute(self.raySceneQueryListener)
+        if self.raySceneQueryListener.dist &lt; 100000:
+            pos = self.contextMenuRay.getPoint(self.raySceneQueryListener.dist)
+            self.raySceneQueryListener.dist = 100000
+        
+        if so is not None:
+            self.zoneManager.entityUnderMouse = so.entity
+        
+        self.zoneManager.newAreaPosition = pos
+        menus.append(self.zoneManager.getZoneMenu())
+
+        if so is not None and so.entity.getParentNode().getName().startswith(&quot;gameobject_&quot;):
+            actions.append(self.createAction(&quot;Set Player Starterpoint&quot;, self.setPlayerStart))
+            self.playerStartGameObjectId = so.entity.getUserObject().inWorldId
+            
+                
+            
+        if self.onContextMenuCallback is not None:
+            self.onContextMenuCallback(actions,  menus)
+
+    def setContextMenuCallback(self, callback):
+        self.onContextMenuCallback = callback
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal=&quot;triggered()&quot;):
+        action = QAction(text, None)
+        if icon is not None:
+            action.setIcon(QIcon(&quot;media/icons/%s&quot; % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            QWidget.connect(action, SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action

Modified: rl/branches/persistence2/editors/Lockenwickler/src/MovePivot.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/MovePivot.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/MovePivot.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,239 +1,254 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import ogre.renderer.OGRE as og
-
-class Pivot():
-    def __init__(self,  sceneManager):
-        self.sceneManager = sceneManager
-        self.camera = self.sceneManager.getCamera(&quot;MainCam&quot;)
-
-        self.mode = None
-        self.isHidden = True
-
-        self.meshManager = og.MeshManager.getSingleton ()
-
-        self.pivotNode = sceneManager.getRootSceneNode().createChildSceneNode(&quot;pivotNode&quot;)
-
-        self.__createMovePivot()
-        self.__createRotatePivot()
-        self.__createScalePivot()
-        self.hide()
-        self.setMoveMode()
-
-        self.moveDirection = None
-        self.isTransforming = False
-        self.selectionList = None
-
-    def __createMovePivot(self):
-        self.xMoveEntity = self.sceneManager.createEntity(&quot;EditorXArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
-        self.xMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
-        self.xMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.xMoveNode = self.pivotNode.createChildSceneNode()
-        self.xMoveNode.attachObject(self.xMoveEntity)
-        self.xMoveNode.translate(og.Vector3(2, 0, 0))
-        self.xMoveNode.rotate(og.Vector3().UNIT_Y,  og.Degree(90))
-        
-        self.yMoveEntity = self.sceneManager.createEntity(&quot;EditorYArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
-        self.yMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
-        self.yMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.yMoveNode = self.pivotNode.createChildSceneNode()
-        self.yMoveNode.attachObject(self.yMoveEntity)
-        self.yMoveNode.translate(og.Vector3(0, 2, 0))
-        self.yMoveNode.rotate(og.Vector3().UNIT_X,  og.Degree(-90))
-
-
-        self.zMoveEntity = self.sceneManager.createEntity(&quot;EditorZArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
-        self.zMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_Z&quot;)
-        self.zMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.zMoveNode = self.pivotNode.createChildSceneNode()
-        self.zMoveNode.attachObject(self.zMoveEntity)
-        self.zMoveNode.translate(og.Vector3(0, 0, 2))
-
-
-    def __createRotatePivot(self):
-        self.xRotateEntity = self.sceneManager.createEntity(&quot;EditorXRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
-        self.xRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
-        self.xRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.xRotateNode = self.pivotNode.createChildSceneNode()
-        self.xRotateNode.attachObject(self.xRotateEntity)
-        #self.xRotateNode.translate(0, 0, -5)
-        self.xRotateNode.rotate(og.Vector3().UNIT_Y,  og.Degree(90))
-
-        self.yRotateEntity = self.sceneManager.createEntity(&quot;EditorYRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
-        self.yRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
-        self.yRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.yRotateNode = self.pivotNode.createChildSceneNode()
-        self.yRotateNode.attachObject(self.yRotateEntity)
-        #self.yRotateNode.translate(0, 0, -10)
-        self.yRotateNode.rotate(og.Vector3().UNIT_X,  og.Degree(90))
-
-        self.zRotateEntity = self.sceneManager.createEntity(&quot;EditorZRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
-        self.zRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_Z&quot;)
-        self.zRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.zRotateNode = self.pivotNode.createChildSceneNode()
-        self.zRotateNode.attachObject(self.zRotateEntity)
-
-
-    def __createScalePivot(self):
-        self.xScaleEntity = self.sceneManager.createEntity(&quot;EditorXScaler&quot;,  &quot;Pivot_Arrow.mesh&quot;)
-        self.xScaleEntity.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
-        self.xScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.xScaleNode = self.pivotNode.createChildSceneNode()
-        self.xScaleNode.attachObject(self.xScaleEntity)
-        self.xScaleNode.translate(og.Vector3(2, 0, 0))
-        self.xScaleNode.rotate(og.Vector3().UNIT_Y,  og.Degree(90))
-        
-        self.yScaleEntity = self.sceneManager.createEntity(&quot;EditorYScaler&quot;,  &quot;Pivot_Arrow.mesh&quot;)
-        self.yScaleEntity.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
-        self.yScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.yScaleNode = self.pivotNode.createChildSceneNode()
-        self.yScaleNode.attachObject(self.yScaleEntity)
-        self.yScaleNode.translate(og.Vector3(0, 2, 0))
-        self.yScaleNode.rotate(og.Vector3().UNIT_X,  og.Degree(-90))
-
-
-        self.zScaleEntity = self.sceneManager.createEntity(&quot;EditorZScaler&quot;,  &quot;Pivot_Arrow.mesh&quot;)
-        self.zScaleEntity.setMaterialName(&quot;Lockenwickler_Pivot_Z&quot;)
-        self.zScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
-        self.zScaleNode = self.pivotNode.createChildSceneNode()
-        self.zScaleNode.attachObject(self.zScaleEntity)
-        self.zScaleNode.translate(og.Vector3(0, 0, 2))
-
-    def setPosition(self,  pos):
-        self.pivotNode.setPosition(pos)
-
-    def getPosition(self):
-        return self.pivotNode.getPosition()
-
-    def startTransforming(self, dirEntity, soList):
-        self.moveDirection = dirEntity.getName()
-        self.selectionList = soList
-        self.isTransforming = True
-        pass
-
-    def stopTransforming(self):
-        self.isTransforming = False
-        pass
-
-    def hide(self):
-        self.pivotNode.removeAllChildren()
-        self.isHidden = True
-
-    def show(self):
-        self.hide()
-        if self.mode == 1:
-            self.pivotNode.addChild(self.xMoveNode)
-            self.pivotNode.addChild(self.yMoveNode)
-            self.pivotNode.addChild(self.zMoveNode)
-        elif self.mode == 2:
-            self.pivotNode.addChild(self.xRotateNode)
-            self.pivotNode.addChild(self.yRotateNode)
-            self.pivotNode.addChild(self.zRotateNode)
-        elif self.mode == 3:
-            return
-        self.isHidden = False
-
-    def setMoveMode(self):
-        self.hide()
-        self.mode = 1
-        self.pivotNode.addChild(self.xMoveNode)
-        self.pivotNode.addChild(self.yMoveNode)
-        self.pivotNode.addChild(self.zMoveNode)
-    
-    def setRotateMode(self):
-        self.hide()
-        self.mode = 2
-        self.pivotNode.addChild(self.xRotateNode)
-        self.pivotNode.addChild(self.yRotateNode)
-        self.pivotNode.addChild(self.zRotateNode)
-    
-    def setScaleMode(self):
-        self.hide()
-        self.mode = 3
-        self.pivotNode.addChild(self.xScaleNode)
-        self.pivotNode.addChild(self.yScaleNode)
-        self.pivotNode.addChild(self.zScaleNode)
-        
-    def onMouseMoved(self, globalX, globalY, incX, incY):
-        # move mode
-        if self.isTransforming:
-            if self.mode == 1:
-                transFactor = 0.1
-                transVec = og.Vector3()
-                if self.moveDirection == &quot;EditorXArrow&quot;:
-                    transVec = og.Vector3(-incX, 0.0 , 0.0)
-                elif self.moveDirection == &quot;EditorYArrow&quot;:
-                    transVec = og.Vector3(0.0, -incY, 0.0)
-                elif self.moveDirection == &quot;EditorZArrow&quot;:
-                    transVec = og.Vector3(0.0, 0.0, incX)
-
-                transVec = transVec * transFactor
-                for so in self.selectionList:
-                    so.entity.getParentNode().translate(transVec)
-                    
-                self.pivotNode.translate(transVec)
-
-            # rotate mode
-            elif self.mode == 2:
-                rotValue = (incX + incY) * 0.05
-
-                if self.moveDirection == &quot;EditorXRotator&quot;:
-                    for so in self.selectionList:
-                        so.entity.getParentNode().pitch(rotValue)
-                if self.moveDirection == &quot;EditorYRotator&quot;:
-                    for so in self.selectionList:
-                        so.entity.getParentNode().yaw(rotValue)
-                if self.moveDirection == &quot;EditorZRotator&quot;:
-                    for so in self.selectionList:
-                        so.entity.getParentNode().roll(rotValue)
-            
-            # scale mode
-            elif self.mode == 3:
-                scaleFactor = 0.3
-                if self.moveDirection == &quot;EditorXScaler&quot;:
-                    for so in self.selectionList:
-                        scale = so.entity.getParentNode().getScale() + og.Vector3(incX * scaleFactor, 0, 0)
-                        so.entity.getParentNode().setScale(scale)
-                if self.moveDirection == &quot;EditorYScaler&quot;:
-                    for so in self.selectionList:
-                        scale = so.entity.getParentNode().getScale() + og.Vector3(0, incY * scaleFactor, 0)
-                        so.entity.getParentNode().setScale(scale)
-                if self.moveDirection == &quot;EditorZScaler&quot;:
-                    for so in self.selectionList:
-                        scale = so.entity.getParentNode().getScale() + og.Vector3(0, 0, incX * scaleFactor)
-                        so.entity.getParentNode().setScale(scale)
-        
-        self.update()
-
-    def update(self):
-        vSize = og.Vector3(1.0,1.0,1.0)
-        vScale = og.Vector3(1.0,1.0,1.0)
-
-        dist = (self.camera.getDerivedPosition() - self.pivotNode._getDerivedPosition()).length()
-        vScale *= dist / 90.0
-
-        self.pivotNode.setScale(vScale.x * vSize.x,vScale.y * vSize.y,vScale.z * vSize.z)
-        #print vScale.x * vSize.x,vScale.y * vSize.y,vScale.z * vSize.z
-#        if not self.isHidden:
-#            dist = self.camera.getPosition().distance(self.pivotNode.getPosition())
-#            self.pivotNode.setScale(og.Vector3(0.5,  0.5,  0.5) * (dist / 30))
-
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+
+import sys
+import ogre.renderer.OGRE as og
+
+class Pivot():
+    def __init__(self,  sceneManager):
+        self.sceneManager = sceneManager
+        self.camera = self.sceneManager.getCamera(&quot;MainCam&quot;)
+
+        self.mode = None
+        self.isHidden = True
+
+        self.meshManager = og.MeshManager.getSingleton ()
+
+        self.pivotNode = sceneManager.getRootSceneNode().createChildSceneNode(&quot;pivotNode&quot;)
+
+        self.__createMovePivot()
+        self.__createRotatePivot()
+        self.__createScalePivot()
+        self.hide()
+        self.setMoveMode()
+
+        self.moveDirection = None
+        self.isTransforming = False
+        self.selectionList = None
+
+    def __createMovePivot(self):
+        self.xMoveEntity = self.sceneManager.createEntity(&quot;EditorXArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
+        self.xMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
+        self.xMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.xMoveNode = self.pivotNode.createChildSceneNode()
+        self.xMoveNode.attachObject(self.xMoveEntity)
+        self.xMoveNode.translate(og.Vector3(2, 0, 0))
+        self.xMoveNode.rotate(og.Vector3().UNIT_Y,  og.Degree(90))
+        
+        self.yMoveEntity = self.sceneManager.createEntity(&quot;EditorYArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
+        self.yMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
+        self.yMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.yMoveNode = self.pivotNode.createChildSceneNode()
+        self.yMoveNode.attachObject(self.yMoveEntity)
+        self.yMoveNode.translate(og.Vector3(0, 2, 0))
+        self.yMoveNode.rotate(og.Vector3().UNIT_X,  og.Degree(-90))
+
+
+        self.zMoveEntity = self.sceneManager.createEntity(&quot;EditorZArrow&quot;,  &quot;Pivot_Arrow.mesh&quot;)
+        self.zMoveEntity.setMaterialName(&quot;Lockenwickler_Pivot_Z&quot;)
+        self.zMoveEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.zMoveNode = self.pivotNode.createChildSceneNode()
+        self.zMoveNode.attachObject(self.zMoveEntity)
+        self.zMoveNode.translate(og.Vector3(0, 0, 2))
+
+
+    def __createRotatePivot(self):
+        self.xRotateEntity = self.sceneManager.createEntity(&quot;EditorXRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
+        self.xRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
+        self.xRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.xRotateNode = self.pivotNode.createChildSceneNode()
+        self.xRotateNode.attachObject(self.xRotateEntity)
+        #self.xRotateNode.translate(0, 0, -5)
+        self.xRotateNode.rotate(og.Vector3().UNIT_Y,  og.Degree(90))
+
+        self.yRotateEntity = self.sceneManager.createEntity(&quot;EditorYRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
+        self.yRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
+        self.yRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.yRotateNode = self.pivotNode.createChildSceneNode()
+        self.yRotateNode.attachObject(self.yRotateEntity)
+        #self.yRotateNode.translate(0, 0, -10)
+        self.yRotateNode.rotate(og.Vector3().UNIT_X,  og.Degree(90))
+
+        self.zRotateEntity = self.sceneManager.createEntity(&quot;EditorZRotator&quot;,  &quot;Rotate_Torus.mesh&quot;)
+        self.zRotateEntity.setMaterialName(&quot;Lockenwickler_Pivot_Z&quot;)
+        self.zRotateEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.zRotateNode = self.pivotNode.createChildSceneNode()
+        self.zRotateNode.attachObject(self.zRotateEntity)
+
+
+    def __createScalePivot(self):
+        self.xScaleEntity = self.sceneManager.createEntity(&quot;EditorXScaler&quot;,  &quot;Pivot_Arrow.mesh&quot;)
+        self.xScaleEntity.setMaterialName(&quot;Lockenwickler_Pivot_X&quot;)
+        self.xScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.xScaleNode = self.pivotNode.createChildSceneNode()
+        self.xScaleNode.attachObject(self.xScaleEntity)
+        self.xScaleNode.translate(og.Vector3(2, 0, 0))
+        self.xScaleNode.rotate(og.Vector3().UNIT_Y,  og.Degree(90))
+        
+        self.yScaleEntity = self.sceneManager.createEntity(&quot;EditorYScaler&quot;,  &quot;Pivot_Arrow.mesh&quot;)
+        self.yScaleEntity.setMaterialName(&quot;Lockenwickler_Pivot_Y&quot;)
+        self.yScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.yScaleNode = self.pivotNode.createChildSceneNode()
+        self.yScaleNode.attachObject(self.yScaleEntity)
+        self.yScaleNode.translate(og.Vector3(0, 2, 0))
+        self.yScaleNode.rotate(og.Vector3().UNIT_X,  og.Degree(-90))
+
+
+        self.zScaleEntity = self.sceneManager.createEntity(&quot;EditorZScaler&quot;,  &quot;Pivot_Arrow.mesh&quot;)
+        self.zScaleEntity.setMaterialName(&quot;Lockenwickler_Pivot_Z&quot;)
+        self.zScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.zScaleNode = self.pivotNode.createChildSceneNode()
+        self.zScaleNode.attachObject(self.zScaleEntity)
+        self.zScaleNode.translate(og.Vector3(0, 0, 2))
+        
+        self.uniScaleEntity = self.sceneManager.createEntity(&quot;UniScaler&quot;,  &quot;UniCube.mesh&quot;)
+        self.uniScaleEntity.setMaterialName(&quot;Lockenwickler_FreeMover&quot;)
+        self.uniScaleEntity.setRenderQueueGroup(og.RENDER_QUEUE_OVERLAY - 1)
+        self.uniScaleNode = self.pivotNode.createChildSceneNode()
+        self.uniScaleNode.attachObject(self.uniScaleEntity)
+
+    def setPosition(self,  pos):
+        self.pivotNode.setPosition(pos)
+
+    def getPosition(self):
+        return self.pivotNode.getPosition()
+
+    def startTransforming(self, dirEntity, soList):
+        self.moveDirection = dirEntity.getName()
+        self.selectionList = soList
+        self.isTransforming = True
+
+    def stopTransforming(self):
+        self.isTransforming = False
+
+    def hide(self):
+        self.pivotNode.removeAllChildren()
+        self.isHidden = True
+
+    def show(self):
+        self.hide()
+        if self.mode == 1:
+            self.pivotNode.addChild(self.xMoveNode)
+            self.pivotNode.addChild(self.yMoveNode)
+            self.pivotNode.addChild(self.zMoveNode)
+        elif self.mode == 2:
+            self.pivotNode.addChild(self.xRotateNode)
+            self.pivotNode.addChild(self.yRotateNode)
+            self.pivotNode.addChild(self.zRotateNode)
+        elif self.mode == 3:
+            self.pivotNode.addChild(self.xScaleNode)
+            self.pivotNode.addChild(self.yScaleNode)
+            self.pivotNode.addChild(self.zScaleNode)
+            self.pivotNode.addChild(self.uniScaleNode)
+        self.isHidden = False
+
+    def setMoveMode(self):
+        self.hide()
+        self.mode = 1
+        self.pivotNode.addChild(self.xMoveNode)
+        self.pivotNode.addChild(self.yMoveNode)
+        self.pivotNode.addChild(self.zMoveNode)
+    
+    def setRotateMode(self):
+        self.hide()
+        self.mode = 2
+        self.pivotNode.addChild(self.xRotateNode)
+        self.pivotNode.addChild(self.yRotateNode)
+        self.pivotNode.addChild(self.zRotateNode)
+    
+    def setScaleMode(self):
+        self.hide()
+        self.mode = 3
+        self.pivotNode.addChild(self.xScaleNode)
+        self.pivotNode.addChild(self.yScaleNode)
+        self.pivotNode.addChild(self.zScaleNode)
+        self.pivotNode.addChild(self.uniScaleNode)
+        
+    def onMouseMoved(self, globalX, globalY, incX, incY):
+        # move mode
+        if self.isTransforming:
+            if self.mode == 1:
+                transFactor = 0.1
+                transVec = og.Vector3()
+                if self.moveDirection == &quot;EditorXArrow&quot;:
+                    transVec = og.Vector3(-incX, 0.0 , 0.0)
+                elif self.moveDirection == &quot;EditorYArrow&quot;:
+                    transVec = og.Vector3(0.0, -incY, 0.0)
+                elif self.moveDirection == &quot;EditorZArrow&quot;:
+                    transVec = og.Vector3(0.0, 0.0, incX)
+
+                transVec = transVec * transFactor
+                for so in self.selectionList:
+                    so.entity.getParentNode().translate(transVec)
+                    
+                self.pivotNode.translate(transVec)
+
+            # rotate mode
+            elif self.mode == 2:
+                rotValue = (incX + incY) * 0.05
+
+                if self.moveDirection == &quot;EditorXRotator&quot;:
+                    for so in self.selectionList:
+                        so.entity.getParentNode().pitch(rotValue)
+                if self.moveDirection == &quot;EditorYRotator&quot;:
+                    for so in self.selectionList:
+                        so.entity.getParentNode().yaw(rotValue)
+                if self.moveDirection == &quot;EditorZRotator&quot;:
+                    for so in self.selectionList:
+                        so.entity.getParentNode().roll(rotValue)
+            
+            # scale mode
+            elif self.mode == 3:
+                scaleFactor = 0.3
+                if self.moveDirection == &quot;EditorXScaler&quot;:
+                    for so in self.selectionList:
+                        scale = so.entity.getParentNode().getScale() + og.Vector3(incX * scaleFactor, 0, 0)
+                        so.entity.getParentNode().setScale(scale)
+                if self.moveDirection == &quot;EditorYScaler&quot;:
+                    for so in self.selectionList:
+                        scale = so.entity.getParentNode().getScale() + og.Vector3(0, incY * scaleFactor, 0)
+                        so.entity.getParentNode().setScale(scale)
+                if self.moveDirection == &quot;EditorZScaler&quot;:
+                    for so in self.selectionList:
+                        scale = so.entity.getParentNode().getScale() + og.Vector3(0, 0, incX * scaleFactor)
+                        so.entity.getParentNode().setScale(scale)
+                if self.moveDirection == &quot;UniScaler&quot;:
+                    for so in self.selectionList:
+                        val = incY / 6.0
+                        print val
+                        scale = so.entity.getParentNode().getScale() + og.Vector3(val * scaleFactor, val * scaleFactor, val * scaleFactor)
+                        so.entity.getParentNode().setScale(scale)
+        
+        self.update()
+
+    def update(self):
+        vSize = og.Vector3(1.0,1.0,1.0)
+        vScale = og.Vector3(1.0,1.0,1.0)
+
+        dist = (self.camera.getDerivedPosition() - self.pivotNode._getDerivedPosition()).length()
+        vScale *= dist / 90.0
+
+        self.pivotNode.setScale(vScale.x * vSize.x,vScale.y * vSize.y,vScale.z * vSize.z)
+        #print vScale.x * vSize.x,vScale.y * vSize.y,vScale.z * vSize.z
+#        if not self.isHidden:
+#            dist = self.camera.getPosition().distance(self.pivotNode.getPosition())
+#            self.pivotNode.setScale(og.Vector3(0.5,  0.5,  0.5) * (dist / 30))
+
+

Modified: rl/branches/persistence2/editors/Lockenwickler/src/MyRaySceneQueryListener.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,347 +1,44 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-import ctypes
-import ogre.renderer.OGRE as og
-import ogre.physics.OgreNewt as on
-
-# a class to store information about a object that got selected
-class SelectionObject():
-    def __init__(self,  entity,  distance):
-        self.entityName = entity.getName()
-        self.entity = entity #the selected entity
-        self.distance = distance # the distance from camera at the time of selection
-        self.isPivot = False
-
-#        if self.entity.getUserObject() is not None:
-#            self.isGameObject = True
-#        else:
-#            self.isGameObject = False
-
-    #if True this instance will show its bounding box else it will hide it
-    def setSelected(self,  selected):
-        if selected == True:
-            self.entity.getParentNode().showBoundingBox(True)
-        else:
-            self.entity.getParentNode().showBoundingBox(False)
-
-    def __eq__(self, other):
-        return self.entity.getName() == other.entity.getName()
-
-    def __ne__(self, other):
-        return self.entity.getName() != other.entity.getName()
-
-class MyRaySceneQueryListener ( og.RaySceneQueryListener ):
-    def __init__( self ):
-        super ( MyRaySceneQueryListener, self ).__init__()
-        self.previouseSelection = None
-        self.selectionList = []
-        self.previousSelected = -1
-        self.currentSelected = -1
-
-        self.mNormalList = []
-        self.mVertexList = []
-        self.mIndexList = []
-
-        self.currentRay = None
-        self.lastRay = None
-
-        self.World = on.World()
-        self.World.setWorldSize(og.Vector3(-1000000, -1000000, -1000000), og.Vector3(1000000, 1000000, 1000000))
-
-    def __del__(self):
-        del self.World
-
-    # sort algorithm for the selection list
-    def sortCompareImp(self,  x,  y):
-        if x.distance &gt; y.distance:
-            return 1
-        elif x.distance == y.distance:
-            return 0
-        else: # x&lt;y
-            return -1
-
-    def queryResult ( self, entity, distance ):
-        #print &quot;dbg: &quot; + entity.getName()
-        if distance == 0.0: #camera is in the bounding box, ignore this selection
-            return True
-        elif entity.getName() == &quot;OgreMainWin::0::ViewportGrid&quot;:
-            return True
-        elif entity.getName() == &quot;rayLine&quot;:
-            return True
-        elif entity.isVisible() and entity.getName() == &quot;EditorXArrow&quot;:
-            so = SelectionObject(entity,  distance)
-            so.isPivot = True
-            self.selectionList.append(so)
-            return False
-        elif entity.isVisible() and entity.getName() == &quot;EditorYArrow&quot;:
-            so = SelectionObject(entity,  distance)
-            so.isPivot = True
-            self.selectionList.append(so)
-            return False
-        elif entity.isVisible() and entity.getName() == &quot;EditorZArrow&quot;:
-            so = SelectionObject(entity,  distance)
-            so.isPivot = True
-            self.selectionList.append(so)
-            return False
-        elif entity.isVisible() and entity.getName() == &quot;EditorFreeMover&quot;:
-            return True
-        elif entity.getName() == &quot;EditorXRotator&quot; or entity.getName() == &quot;EditorYRotator&quot; or entity.getName() == &quot;EditorZRotator&quot;:
-            if entity.isVisible() and self.rayCastToPolygonLevelOnSingleMesh(self.currentRay,  entity):
-                so = SelectionObject(entity,  distance)
-                so.isPivot = True
-                self.selectionList.append(so)
-                return False
-            else:
-                return True
-        else:
-            so = SelectionObject(entity,  distance)
-            self.selectionList.append(so)
-
-        self.selectionList.sort(self.sortCompareImp)
-
-        return True
-
-    def reset(self):
-        self.previousSelected = -1
-        self.currentSelected = -1
-        del self.selectionList[:]
-        #self.selectionList = []
-
-    def rayCastToPolygonLevel(self,  ray):
-        self.lastRay = ray
-
-        for so in self.selectionList:
-            if so.isPivot:
-                return so
-
-        if len(self.selectionList) &gt;= 1:
-            for so in self.selectionList:
-                if self.rayCastToPolygonLevelOnSingleMesh(ray,  so.entity):
-                    return so
-
-
-    def rayCastToPolygonLevelOnSingleMesh(self,  ray,  entity):
-        col = on.TreeCollision(self.World, entity.getParentNode(), False)
-        bod = on.Body(self.World, col)
-
-
-        start = ray.getOrigin()
-        end = ray.getPoint(10000)
-
-        retNorm = og.Vector3(0.0, 0.0, 0.0)
-
-        val = on.CollisionRayCast(col, start, end, retNorm)
-#        print val
-#
-#        print retNorm.x
-#        print retNorm.y
-#        print retNorm.z
-        del col
-        self.World.destroyAllBodies()
-        
-        if retNorm.x != 0.0 or retNorm.y != 0.0 or retNorm.z != 0.0:
-#           print &quot;yes&quot;
-           return True
-        else:
-#            print &quot;no&quot;
-            return False
-           
-        
-        
-
-#    def iterateEntityUnderMouse(self):
-#        self.previousSelected = self.currentSelected
-#        if len(self.selectionList) &gt;= self.currentSelected: # would mean we are out of bounds
-#            self.selectionList[self.currentSelected].setSelected(False)
-#
-#        self.currentSelected += 1
-#
-#        if len(self.selectionList) == self.currentSelected: # means we are out of bounds and reached the end of the list, reset it to zero
-#            self.currentSelected = 0
-#
-#        if len(self.selectionList) &gt;= self.currentSelected: # would mean we are out of bounds
-#            #print str(self.selectionList[self.currentSelected].distance) + &quot; &quot;  + self.selectionList[self.currentSelected].entity.getName()
-#            if self.rayCastToPolygonLevelOnCurrentSelection():
-#                self.selectionList[self.currentSelected].setSelected(True)
-#                return self.selectionList[self.currentSelected]
-
-
-#    def getMeshInformation(self,  entity):
-#        numVertices = 0
-#        numIndices = 0
-#        useSharedVertices = False
-#
-#        if not entity:
-#            return False
-#
-#        pMesh = entity.getMesh()
-#
-#        position =    entity.getParentNode()._getDerivedPosition()
-#        orient = entity.getParentNode()._getDerivedOrientation()
-#        scale =  entity.getParentNode().getScale()
-#
-#        for i in range ( pMesh.getNumSubMeshes() ):
-#            pSubMesh = pMesh.getSubMesh(i)
-#            if pSubMesh.useSharedVertices:
-#                useSharedVertices = True
-#            else:
-#                numVertices += pSubMesh.vertexData.vertexCount
-#            numIndices += pSubMesh.indexData.indexCount
-#
-#        if useSharedVertices:
-#            numVertices += pMesh.sharedVertexData.vertexCount
-#
-#            storageclass = ctypes.c_float * 3
-#            test=storageclass(0.0,  0.0,  0.0)
-##         mVertexList = new Point[numVertices];
-##         mIndexList = new unsigned int[numIndices];
-#
-#        self.mVertexList = []
-#        self.mIndexList = []
-#
-#        ## Count the number of vertices and incides so we can Set them
-#        indexCount = 0
-#        vertListCount = 0
-#
-#        if useSharedVertices:
-#            ## Real* pVertices (x, y, z order x numVertices)
-#            elem = pMesh.sharedVertexData.vertexDeclaration.findElementBySemantic(og.VES_POSITION)
-#
-#            if not elem:
-#                ogre.Except(Exception.ERR_ITEM_NOT_FOUND, &quot;Can't find position elements in the &quot;
-#                    &quot;mesh to be written!&quot;, &quot;MeshSerializerImpl.writeGeometry&quot;)
-#
-#            vbuf = pMesh.sharedVertexData.vertexBufferBinding.getBuffer(elem.getSource())
-#
-#            ## need space for the 3 verticies
-#            storageclass = ctypes.c_float * 3
-#            test=storageclass(0.0,  0.0,  0.0)
-#
-#            for j in range ( pMesh.sharedVertexData.vertexCount ):
-#                vbuf.readData(j * vbuf.getVertexSize(), 3 * ctype.sizeof(ctype.c_float), ctype.addressof(test))
-#                pt = og.Vector3(test[0], test[1], test[2])
-#                self.mVertexList.append( (orient * (pt * scale)) + position )
-#                vertListCount+=1
-#
-#        for i in range ( pMesh.getNumSubMeshes() ):
-#            pSubMesh = pMesh.getSubMesh(i)
-#            if not pSubMesh.useSharedVertices:
-#                ## Real* pVertices (x, y, z order x numVertices)
-#                elem = pSubMesh.vertexData.vertexDeclaration.findElementBySemantic(og.VES_POSITION)
-#
-#                if not elem:
-#                    og.Except(Exception.ERR_ITEM_NOT_FOUND, &quot;Can't find position elements in the &quot;
-#                        &quot;mesh to be written!&quot;, &quot;MeshSerializerImpl.writeGeometry&quot;)
-#
-#                vbuf = pSubMesh.vertexData.vertexBufferBinding.getBuffer(elem.getSource())
-#
-#                ## need space for the verticies
-#                storageclass = ctypes.c_float * (pSubMesh.vertexData.vertexCount * 6)
-#                test=storageclass(0.0)
-#
-#                vbuf.readData(0, pSubMesh.vertexData.vertexCount * 6 * ctypes.sizeof(ctypes.c_float), ctypes.addressof(test))
-#
-#                for j in range ( 0,  pSubMesh.vertexData.vertexCount * 6,  6):
-#                    #print j
-#                    pt = og.Vector3(test[j], test[j+1], test[j+2])
-#                    self.mVertexList.append( (orient * (pt * scale)) + position )
-#                    vertListCount += 1
-#
-#            ibuf = pSubMesh.indexData.indexBuffer
-#            ## need space for the verticies
-#            storageclass = ctypes.c_ushort * pSubMesh.indexData.indexCount
-#            test2=storageclass()
-#
-#
-#            ibuf.readData(0, ibuf.getSizeInBytes(), ctypes.addressof(test2))
-#            for j in range ( pSubMesh.indexData.indexCount ):
-#                self.mIndexList.append (test2[j])   # unsigned short
-#                indexCount += 1
-#
-#            ih = 0
-#            for blah in self.mVertexList:
-#                #print str(ih) + &quot;: &quot;  +  str(blah)
-#                ih += 1
-#
-#    def rayCastToPolygonLevel(self,  ray):
-#        self.lastRay = ray
-#
-#        for so in self.selectionList:
-#            if so.isPivot:
-#                return so
-#
-#        if len(self.selectionList) &gt;= 1:
-#            for so in self.selectionList:
-#                if self.rayCastToPolygonLevelOnSingleMesh(ray,  so.entity):
-#                    return so
-#
-#
-#    def rayCastToPolygonLevelOnSingleMesh(self,  ray,  entity):
-#        self.getMeshInformation(entity)
-#        name = entity.getName()
-#        print &quot;dbg: &quot; + name
-#
-#        temp = []
-#        for vec in self.mVertexList:
-#            temp.append(vec.x)
-#            temp.append(vec.y)
-#            temp.append(vec.z)
-#
-#        globalPosition = entity.getParentNode()._getDerivedPosition()
-#        globalOrientation = entity.getParentNode()._getDerivedOrientation()
-#
-#
-#        i = 0
-#        while i &lt;= (len(self.mIndexList) - 3):
-#            verta = globalPosition + self.mVertexList[self.mIndexList[i]]
-#            vertb = globalPosition + self.mVertexList[self.mIndexList[i+1]]
-#            vertc = globalPosition + self.mVertexList[self.mIndexList[i+2]]
-#
-#            verta = globalOrientation * verta
-#            vertb = globalOrientation * vertb
-#            vertc = globalOrientation * vertc
-#            normal = og.Math.calculateBasicFaceNormal(verta, vertb, vertc)
-#
-#            result = og.Math.intersects(ray, verta, vertb, vertc, True, True)
-#            #result = og.Math.intersects(ray, globalPosition + self.mVertexList[self.mIndexList[i]], globalPosition + self.mVertexList[self.mIndexList[i+1]],
-#            #                                                                                                                                              globalPosition + self.mVertexList[self.mIndexList[i+2]], normal,  True, True)
-#
-#            if result.first:
-#                #print &quot;dbg: Treffer!!!!!!!!!&quot;
-#                return True
-#
-#            i += 3
-#
-#        return False
-#
-#    def rayCastToPolygonLevelOnCurrentSelection(self):
-#        if len(self.selectionList) &gt;= 1:
-#            self.getMeshInformation(self.selectionList[self.currentSelected].entity)
-#
-#            i = 0
-#            while i &lt;= (len(self.mIndexList) - 3):
-#                globalPosition = self.selectionList[self.currentSelected].entity.getParentNode().getPosition()
-#                result = og.Math.intersects(self.lastRay, globalPosition + self.mVertexList[self.mIndexList[i]], globalPosition + self.mVertexList[self.mIndexList[i+1]],
-#                                                                                                                                                          globalPosition + self.mVertexList[self.mIndexList[i+2]], True, True)
-#
-#                if result.first:
-#                   return True
-#
-#                i += 3
-#            return False
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+class MyRaySceneQueryListener ( og.RaySceneQueryListener ):
+    def __init__( self ):
+        super ( MyRaySceneQueryListener, self ).__init__()
+        self.dist = 100000
+        
+    # sort algorithm for the selection list
+    def sortCompareImp(self,  x,  y):
+        if x.distance &gt; y.distance:
+            return 1
+        elif x.distance == y.distance:
+            return 0
+        else: # x&lt;y
+            return -1
+
+    def queryResult ( self, entity, distance ):
+#        if distance == 0.0: #camera is in the bounding box, ignore this selection
+#            return True
+        
+        if self.dist &gt; distance:
+            self.dist = distance
+
+        return True

Modified: rl/branches/persistence2/editors/Lockenwickler/src/NewModuleWizard.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/NewModuleWizard.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/NewModuleWizard.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,5 +1,21 @@
-# -*- coding: utf-8 -*-
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 &quot;&quot;&quot;
 Module implementing NewModuleWizard.
 &quot;&quot;&quot;
@@ -119,25 +135,50 @@
         f.write(&quot;    def getDependencies()\n&quot;)
         f.write(&quot;       return [&quot; + str(mdeps) + &quot;];\n&quot;)
         f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def getTextureLocation()\n&quot;)
+        f.write(&quot;    def getTextureLocations()\n&quot;)
         f.write(&quot;       return [\&quot;textures\&quot;];\n&quot;)
         f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def getModelLocation()\n&quot;)
+        f.write(&quot;    def getModelLocations()\n&quot;)
         f.write(&quot;       return [\&quot;models\&quot;];\n&quot;)
         f.write(&quot;    end\n\n&quot;)
-        f.write(&quot;    def getSoundLocation()\n&quot;)
+        f.write(&quot;    def getSoundLocations()\n&quot;)
         f.write(&quot;       return [\&quot;sound\&quot;];\n&quot;)
         f.write(&quot;    end\n\n&quot;)
         f.write(&quot;    def start()\n&quot;)
-        f.write(sdeps)
-        f.write(&quot;\n\n       SceneManager.getSingleton().loadScene(\&quot;&quot; + self.sceneNameLineEdit.text() + &quot;\&quot;);\n&quot;)
-        f.write(&quot;       $World = $CORE.getWorld();\n&quot;)
+        f.write(sdeps + &quot;\n&quot;)
+        f.write(&quot;       require 'player.rb'\n&quot;)
+        f.write(&quot;       require 'mckhero.rb'\n&quot;)
+        f.write(&quot;       $PM.setEnabled(true);\n\n&quot;)
+        f.write(&quot;\n\n       SceneManager.getSingleton().loadScene(\&quot;&quot; + self.sceneNameLineEdit.text() + &quot;\&quot;);\n\n&quot;)
+        f.write(&quot;       hero = $GOM.getGameObject(XXXXXX);\n&quot;)
+        f.write(&quot;       PlayerSettings.preparePlayer(hero)\n&quot;)
+        f.write(&quot;       PartyManager.getSingleton().setActiveCharacter(hero)\n\n&quot;)
         f.write(&quot;    end\n&quot;)
         f.write(&quot;end\n\n&quot;)
-
         f.write(&quot;CoreSubsystem.getSingleton().registerModule(&quot; + mname.capitalize() + &quot;Module.new());\n&quot;)
         f.close()
         
+        
+        
+        p = os.path.join(modulePath, &quot;maps&quot;)
+        p = os.path.join(p, str(self.sceneNameLineEdit.text()) + &quot;.rlscene&quot;)
+        
+        f = open(p, &quot;w&quot;)
+        f.write(&quot;&lt;scene name=\&quot;&quot; + str(self.sceneNameLineEdit.text()) + &quot;\&quot;&gt;\n&quot;)
+        f.write(&quot;    &lt;map file=\&quot;&quot; + str(self.mapNameLineEdit.text()) + &quot;.rlmap.xml\&quot;&quot; +  &quot;/&gt;\n&quot;)
+        f.write(&quot;&lt;/scene&gt;\n&quot;)
+        f.close()
+        
+        p = os.path.join(modulePath, &quot;maps&quot;)
+        p = os.path.join(p, str(self.mapNameLineEdit.text()) + &quot;.rlmap.xml&quot;)
+        
+        f = open(p, &quot;w&quot;)
+        f.write(&quot;&lt;rastullahmap formatVersion=\&quot;0.4.0\&quot;&gt;\n&quot;)
+        f.write(&quot;    &lt;nodes&gt;\n&quot;)
+        f.write(&quot;    &lt;/nodes&gt;\n&quot;)
+        f.write(&quot;&lt;/rastullahmap&gt;\n&quot;)
+        f.close()
+        
         self.moduleManager.resetParsedModuleConfig()
         self.moduleManager.openLoadModuleDialog()
         

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyModel.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyModel.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyModel.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 import sys
 

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ObjectPropertyWin.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 import sys
@@ -22,14 +23,103 @@
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *
 
+import ogre.renderer.OGRE as og
+
 from Property import *
+import ModuleManager
 
+class BoolEditor(QDialog):
+    def __init__(self, currentSelectedText, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setGeometry(QCursor.pos().x(), QCursor.pos().y(), 100, 30)
+        
+        layout = QVBoxLayout()
+        layout.setContentsMargins(0, 0, 0, 0)
+        
+        currentSelected = False
+        if currentSelectedText == &quot;True&quot; or currentSelectedText == &quot;true&quot;:
+            currentSelected = True
+        
+        self.combo = QComboBox()
+        self.combo.addItem(&quot;True&quot;)
+        self.combo.addItem(&quot;False&quot;)
+        
+        if not currentSelected:
+            self.combo.setCurrentIndex(1)
+        
+        layout.addWidget(self.combo)
+        self.setLayout(layout)
+        
+        self.connect(self.combo, SIGNAL(&quot;currentIndexChanged ( const QString &amp;)&quot;), self.accept)
+    
+    def getValue(self):
+        ret = True
+        if str(self.combo.currentText()) == &quot;False&quot;:
+            ret = False
+        
+        return ret
+    
+class GameObjectStateEditor(QDialog):
+    def __init__(self, currentSelectedText, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setGeometry(QCursor.pos().x(), QCursor.pos().y(), 100, 30)
+        
+        layout = QVBoxLayout()
+        layout.setContentsMargins(0, 0, 0, 0)
+        
+        self.combo = QComboBox()
+        self.combo.addItem(&quot;IN_SCENE&quot;)
+        self.combo.addItem(&quot;LOADED&quot;)
+        self.combo.addItem(&quot;HELD&quot;)
+        self.combo.addItem(&quot;IN_POSSESSION&quot;)
+        self.combo.addItem(&quot;READIED&quot;)
+
+        self.combo.setCurrentIndex(self.combo.findText(currentSelectedText))
+        
+
+        layout.addWidget(self.combo)
+        self.setLayout(layout)
+        
+        self.connect(self.combo, SIGNAL(&quot;currentIndexChanged ( const QString &amp;)&quot;), self.accept)
+    
+    def getValue(self):
+        return str(self.combo.currentText())
+        
+class EntityPhysicsProxyEditor(QDialog):
+    def __init__(self, currentSelectedText, parent=None):
+        super(QDialog, self).__init__(parent)
+        self.setGeometry(QCursor.pos().x(), QCursor.pos().y(), 100, 30)
+        
+        layout = QVBoxLayout()
+        layout.setContentsMargins(0, 0, 0, 0)
+        
+        self.combo = QComboBox()
+        self.combo.addItem(&quot;none&quot;)
+        self.combo.addItem(&quot;box&quot;)
+        self.combo.addItem(&quot;sphere&quot;)
+        self.combo.addItem(&quot;ellipsoid&quot;)
+        self.combo.addItem(&quot;pyramid&quot;)
+        self.combo.addItem(&quot;mesh&quot;)
+        self.combo.addItem(&quot;convexhull&quot;)
+        self.combo.addItem(&quot;custom - Not supported by editor yet!&quot;)
+
+        self.combo.setCurrentIndex(self.combo.findText(currentSelectedText))
+        
+        layout.addWidget(self.combo)
+        self.setLayout(layout)
+        
+        self.connect(self.combo, SIGNAL(&quot;currentIndexChanged ( const QString &amp;)&quot;), self.accept)
+    
+    def getValue(self):
+        return str(self.combo.currentText())
+    
 class ObjectPropertyWin(QDialog):
-    def __init__(self, sceneManager, parent=None):
+    def __init__(self, sceneManager, gocManager, parent=None):
         super(QDialog, self).__init__(parent)
         self.setupUi()
         self.sceneManager = sceneManager
         self.valueBeforeEdit = None
+        self.gocManager = gocManager
         
         self.connect(self.treeWidget, SIGNAL(&quot;itemDoubleClicked (QTreeWidgetItem *,int)&quot;),
                                self.onItemClicked)
@@ -58,27 +148,131 @@
 
     def onItemClicked(self, item, column):
         if column == 1:
-            self.valueBeforeEdit = item.text(column)
-            self.treeWidget.editItem(item, column)
+            self.valueBeforeEdit = str(item.text(column))
+            
+            if item.text(0) == &quot;State&quot;:
+                ed = GameObjectStateEditor(item.text(column), self)
+                ed.exec_()
+                item.setText(column, ed.getValue())
+                self.node.getAttachedObject(0).getUserObject().state = ed.getValue()
+                
+            elif item.text(0) == &quot;Receives Shadows&quot;:
+                bedit = BoolEditor(item.text(column), self)
+                bedit.exec_()
+                item.setText(column, bedit.getValue())
+                self.node.getAttachedObject(0).getUserObject().receivesShadow = str(bedit.getValue())
+            elif item.text(0) == &quot;Physics Proxy Type&quot;:
+                bedit = EntityPhysicsProxyEditor(item.text(column), self)
+                bedit.exec_()
+                item.setText(column, bedit.getValue())
+                self.node.getAttachedObject(0).getUserObject().physicsproxytype = bedit.getValue()
+            elif item.text(0) == &quot;Visibility&quot;:
+                bedit = BoolEditor(item.text(column), self)
+                bedit.exec_()
+                item.setText(column, str(bedit.getValue()))
+                ModuleManager.extractLight(self.node).setVisible(bedit.getValue())
+            elif item.text(0) == &quot;CastShadows&quot;:
+                bedit = BoolEditor(item.text(column), self)
+                bedit.exec_()
+                item.setText(column, str(bedit.getValue()))
+                ModuleManager.extractLight(self.node).setCastShadows(bedit.getValue())
+            elif item.text(0) == &quot;Diffuse Color&quot;:
+                min = 1.0 / 255.0
+                col = ModuleManager.extractLight(self.node).getDiffuseColour()
+                newColor = QColorDialog.getColor(QColor(col.r * 255, col.g * 255, col.g * 255), self)
+                ModuleManager.extractLight(self.node).setDiffuseColour(og.ColourValue(min * newColor.red(), min * newColor.green(), min * newColor.blue()))
+                self.showProperties(self.so)
+            elif item.text(0) == &quot;Specular Color&quot;:
+                min = 1.0 / 255.0
+                col = ModuleManager.extractLight(self.node).getSpecularColour()
+                newColor = QColorDialog.getColor(QColor(col.r * 255, col.g * 255, col.g * 255), self)
+                ModuleManager.extractLight(self.node).setSpecularColour(og.ColourValue(min * newColor.red(), min * newColor.green(), min * newColor.blue()))
+                self.showProperties(self.so)
+            elif item.text(0) == &quot;Subtract&quot;:
+                bedit = BoolEditor(item.text(column), self)
+                bedit.exec_()
+                item.setText(column, str(bedit.getValue()))
+                self.so.entity.getUserObject().subtract = bedit.getValue()                    
+            else:
+                self.treeWidget.editItem(item, column)
 
     def onItemChanged(self, item, column):
         if self.valueBeforeEdit is not None and self.valueBeforeEdit != item.text(column):
             parent = item.parent()
-            if parent is None:
+            if parent is None: # handle properties that don't expand here (pos, rot, scale etc)
                 if item.text(0) == &quot;Name&quot;:
-                    if not self.sceneManager.hasEntity(str(item.text(column))):
-                        newEnt = self.node.getAttachedObject(0).clone(str(item.text(column)))
-                        oldEnt = self.node.getAttachedObject(0)
-                        self.node.detachObject(oldEnt)
-                        self.sceneManager.destroyEntity(oldEnt)
-                        self.node.attachObject(newEnt)
+                    if self.node.getName().startswith(&quot;entity_&quot;):
+                        if not self.sceneManager.hasEntity(str(item.text(column))):
+                            newEnt = self.node.getAttachedObject(0).clone(str(item.text(column)))
+                            oldEnt = self.node.getAttachedObject(0)
+                            self.node.detachObject(oldEnt)
+                            self.sceneManager.destroyEntity(oldEnt)
+                            self.node.attachObject(newEnt)
+                            
+                            # update the selection object since it still has references to the deleted entity
+                            self.so.entity = newEnt
+                            self.so.entityName = newEnt.getName()
+                        else:
+                            item.setText(column, self.valueBeforeEdit)
+                            print &quot;Error: Name already exists!&quot;
+
+                    elif self.node.getName().startswith(&quot;light_&quot;):
+                        if not self.sceneManager.hasLight(str(item.text(column))):
+                            newLight = self.sceneManager.createLight(str(item.text(column)))
+                            oldLight = ModuleManager.extractLight(self.node)
+                            self.node.detachObject(oldLight)
+                            self.node.attachObject(newLight)
+                            newLight.setType(oldLight.getType())
+                            newLight.setVisibilityFlags(newLight.getVisibilityFlags())
+                            newLight.setCastShadows(oldLight.getCastShadows())
+                            newLight.setDiffuseColour(oldLight.getDiffuseColour())
+                            newLight.setSpecularColour(oldLight.getSpecularColour())
+                            newLight.setAttenuation(oldLight.getAttenuationRange(), oldLight.getAttenuationConstant(), oldLight.getAttenuationLinear(), oldLight.getAttenuationQuadric())
+                            if newLight.getType() == og.Light.LT_SPOTLIGHT:
+                                newLight.setSpotlightRange(oldLight.getSpotlightInnerAngle(), oldLight.getSpotlightOuterAngle(), oldLight.getSpotlightFalloff())
+                            if newLight.getType() == og.Light.LT_SPOTLIGHT or newLight.getType() == og.Light.LT_DIRECTIONAL:
+                                newLight.setDirection(oldLight.getDirection())
+                                
+                            self.sceneManager.destroyLight(oldLight)
+                        else:
+                            item.setText(column, self.valueBeforeEdit)
+                            print &quot;Error: Name already exists!&quot;
+
+                elif item.text(0) == &quot;Zone Name&quot;:
+                    self.node.getAttachedObject(0).getUserObject().parentZone.name = str(item.text(column))
                         
-                        # update the selection object since it still has references to the deleted entity
-                        self.so.entity = newEnt
-                        self.so.entityName = newEnt.getName()
+                elif item.text(0) == &quot;GameObject Id&quot;:
+                    if not self.gocManager.inWorldIdExists(str(item.text(column))):
+                        val = None
+                        try:
+                            val = int(item.text(1))
+                        except ValueError, e:
+                            item.setText(column, self.valueBeforeEdit)
+                            print &quot;ValueError: &quot; + str(e)
+                            return
+                            
+                        self.node.getAttachedObject(0).getUserObject().inWorldId = str(val)
                     else:
                         item.setText(column, self.valueBeforeEdit)
-                        print &quot;Error: Name already exists!&quot;
+                        print &quot;Error: Id exists already!&quot;
+                elif item.text(0) == &quot;Static Geometry Group&quot;:                        
+                    val = None
+                    try:
+                        val = int(item.text(1))
+                    except ValueError, e:
+                        item.setText(column, self.valueBeforeEdit)
+                        print &quot;ValueError: &quot; + str(e)
+                        return
+                elif item.text(0) == &quot;Rendering Distance&quot;:                        
+                    val = None
+                    try:
+                        val = float(item.text(1))
+                    except ValueError, e:
+                        item.setText(column, self.valueBeforeEdit)
+                        print &quot;ValueError: &quot; + str(e)
+                        return
+                    
+                    self.node.getAttachedObject(0).getUserObject().renderingdistance = val
             else:
                 val = None
                 try:
@@ -111,6 +305,24 @@
                         self.node.setScale(self.node.getScale().x, val, self.node.getScale().z)
                     elif item.text(0) == &quot;Z&quot;:
                         self.node.setScale(self.node.getScale().x, self.node.getScale().y, val)
+                elif parent.text(0) == &quot;Attenuation&quot;:
+                    light = ModuleManager.extractLight(self.node)
+                    if item.text(0) == &quot;range&quot;:
+                        light.setAttenuation(val, light.getAttenuationConstant(), light.getAttenuationLinear(), light.getAttenuationQuadric())
+                    elif item.text(0) == &quot;constant&quot;:
+                        light.setAttenuation(light.getAttenuationRange(), val, light.getAttenuationLinear(), light.getAttenuationQuadric())
+                    elif item.text(0) == &quot;linear&quot;:
+                        light.setAttenuation(light.getAttenuationRange(), light.getAttenuationConstant(), val, light.getAttenuationQuadric())
+                    elif item.text(0) == &quot;quadratic&quot;:
+                        light.setAttenuation(light.getAttenuationRange(), light.getAttenuationConstant(), light.getAttenuationLinear(), val)
+                elif parent.text(0) == &quot;Spotlightrange&quot;:
+                    light = ModuleManager.extractLight(self.node)
+                    if item.text(0) == &quot;inner&quot;:
+                        light.setSpotlightInnerAngle(og.Degree(val))
+                    elif item.text(0) == &quot;outer&quot;:
+                        light.setSpotlightOuterAngle(og.Degree(val))
+                    elif item.text(0) == &quot;falloff&quot;:                      
+                      light.setSpotlightFalloff(val)
                         
     def showProperties(self, so):
         # onItemChanged should only be called when the user changes values not when they change by code
@@ -141,17 +353,155 @@
                 it.setText(1, self.node.getAttachedObject(0).getSubEntity(i).getMaterialName())
                 i += 1
                 
+                        
+            self.parsePosition(self.node)
+            self.parseOrientation(self.node)
+            self.parseScale(self.node)
+            self.parseEntityOptions(self.node)
             
-            #item.setFlags(item.flags() | Qt.ItemIsEditable)
+        elif name.startswith(&quot;gameobject_&quot;):
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;ClassName&quot;)
+            n = str(self.node.getAttachedObject(0).getUserObject().gocName)
+            item.setText(1, n)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
             
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;GameObject Id&quot;)
+            n = str(self.node.getAttachedObject(0).getUserObject().inWorldId)
+            item.setText(1, n)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;State&quot;)
+            n = str(self.node.getAttachedObject(0).getUserObject().state)
+            item.setText(1, n)            
+            
             self.parsePosition(self.node)
             self.parseOrientation(self.node)
             self.parseScale(self.node)
             
+        elif name.startswith(&quot;light_&quot;):
+            item = QTreeWidgetItem(self.treeWidget)
+            light = ModuleManager.extractLight(self.node)
+            n = light.getName()
+            item.setText(0, &quot;Name&quot;)
+            item.setText(1, n)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Type&quot;)
+            if light.getType() == og.Light.LT_POINT:
+                item.setText(1, &quot;point&quot;)
+            elif light.getType() == og.Light.LT_SPOTLIGHT:
+                item.setText(1, &quot;spot&quot;)
+            elif light.getType() == og.Light.LT_DIRECTIONAL:
+                item.setText(1, &quot;directional&quot;)
+
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Visibility&quot;)
+            item.setText(1, str(light.getVisible()))
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;CastShadows&quot;)
+            item.setText(1, str(light.getCastShadows()))
+            
+            if light.getType() == og.Light.LT_POINT or light.getType() == og.Light.LT_SPOTLIGHT:
+                self.parsePosition(self.node)
+            if light.getType() == og.Light.LT_SPOTLIGHT:
+                self.parseSpotLightProperties(self.node)
+                
+            self.parseDiffuseColor(self.node)
+            self.parseSpecularColor(self.node)
+            self.parseLightAttenuation(self.node)
+        elif name.startswith(&quot;area_&quot;):
+            area = so.entity.getUserObject()
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Zone Name&quot;)
+            item.setText(1, area.parentZone.name)
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Type&quot;)
+            item.setText(1, area.type)
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Dbg Area Id:&quot;)
+            item.setText(1, str(area.id))
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Dbg Area Entity Name:&quot;)
+            item.setText(1, area.areaEntity.getName())
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Subtract&quot;)
+            item.setText(1, str(area.subtract))
+            
+            self.parsePosition(area.areaNode)
+            self.parseOrientation(area.areaNode)
+            self.parseScale(area.areaNode)
+            
         self.connect(self.treeWidget, SIGNAL(&quot;itemChanged (QTreeWidgetItem *,int)&quot;),
                        self.onItemChanged)
                        
-                       
+    
+    def parseDiffuseColor(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Diffuse Color&quot;)
+        color = ModuleManager.extractLight(self.node).getDiffuseColour()
+        item.setText(1, str(int(255 * color.r)) + &quot;; &quot; + str(int(255 * color.g)) + &quot;; &quot; + str(int(255 * color.b)))
+        
+    def parseSpecularColor(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Specular Color&quot;)
+        color = ModuleManager.extractLight(self.node).getSpecularColour()
+        item.setText(1, str(int(255 * color.r)) + &quot;; &quot; + str(int(255 * color.g)) + &quot;; &quot; + str(int(255 * color.b)))
+        
+    def parseLightAttenuation(self, node):
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Attenuation&quot;)
+        light = ModuleManager.extractLight(self.node)
+        
+        range = QTreeWidgetItem(item)
+        range.setText(0, &quot;range&quot;)
+        range.setText(1, str(light.getAttenuationRange()))
+        range.setFlags(range.flags() | Qt.ItemIsEditable)
+        
+        constant = QTreeWidgetItem(item)
+        constant.setText(0, &quot;constant&quot;)
+        constant.setText(1,  str(light.getAttenuationConstant()))
+        constant.setFlags(constant.flags() | Qt.ItemIsEditable)
+        
+        linear = QTreeWidgetItem(item)
+        linear.setText(0, &quot;linear&quot;)
+        linear.setText(1, str(light.getAttenuationLinear()))
+        linear.setFlags(linear.flags() | Qt.ItemIsEditable)
+        
+        quadratic = QTreeWidgetItem(item)
+        quadratic.setText(0, &quot;quadratic&quot;)
+        quadratic.setText(1, str(light.getAttenuationQuadric()))
+        quadratic.setFlags(quadratic.flags() | Qt.ItemIsEditable)
+    
+    def parseSpotLightProperties(self,  node):
+        light = ModuleManager.extractLight(self.node)
+        item = QTreeWidgetItem(self.treeWidget)
+        item.setText(0, &quot;Spotlightrange&quot;)
+
+        inner = QTreeWidgetItem(item)
+        inner.setText(0, &quot;inner&quot;)
+        inner.setText(1, str(light.getSpotlightInnerAngle().valueDegrees()))
+        inner.setFlags(inner.flags() | Qt.ItemIsEditable)
+        
+        outer = QTreeWidgetItem(item)
+        outer.setText(0, &quot;outer&quot;)
+        outer.setText(1, str(light.getSpotlightOuterAngle().valueDegrees()))
+        outer.setFlags(outer.flags() | Qt.ItemIsEditable)
+        
+        falloff = QTreeWidgetItem(item)
+        falloff.setText(0, &quot;falloff&quot;)
+        falloff.setText(1, str(light.getSpotlightFalloff()))
+        falloff.setFlags(falloff.flags() | Qt.ItemIsEditable)
+
     def parsePosition(self, node):
         item = QTreeWidgetItem(self.treeWidget)
         item.setText(0, &quot;Position&quot;)
@@ -217,7 +567,31 @@
         itemZ.setText(1, str(node.getScale().z))
         itemZ.setFlags(itemZ.flags() | Qt.ItemIsEditable)
         
+    def parseEntityOptions(self, node):
+        uo = node.getAttachedObject(0).getUserObject()
+
+        if uo is not None:
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Receives Shadows&quot;)
+            item.setText(1, str(uo.receivesShadow))
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Static Geometry Group&quot;)
+            item.setText(1, str(uo.staticgeometrygroup))
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Physics Proxy Type&quot;)
+            item.setText(1, str(uo.physicsproxytype))  
+            
+            item = QTreeWidgetItem(self.treeWidget)
+            item.setText(0, &quot;Rendering Distance&quot;)
+            item.setText(1, str(uo.renderingdistance))
+            item.setFlags(item.flags() | Qt.ItemIsEditable)
+            
     def updateProperties(self):
         if self.so is not None:
             self.showProperties(self.so)
-            
+    
+    def clear(self):
+        self.treeWidget.clear()

Modified: rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/OgreMainWindow.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,348 +1,351 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-from PyQt4.QtGui import *
-from PyQt4.QtCore import *
-
-from ViewportGrid import *
-
-import OgreWidget
-import ogre.renderer.OGRE as og
-
-# this class is the heart of the 3d part
-# it manages the two ogre render windows and recieves events from the windows through the event filter
-class OgreMainWindow(QWidget):
-    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
-        QWidget.__init__(self, parent)
-        self.moduleManager = moduleManager
-        self.ogreRoot = ogreRoot
-        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
-
-        self.ogreWidget = None
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.mDollyCamera = False
-
-        self.moveCamForward = False
-        self.moveCamBackward = False
-        self.strafeCamLeft = False
-        self.strafeCamRight = False
-
-        self.camUpdateTimer = QTimer(self)
-        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL(&quot;timeout()&quot;), self.updateCamera)
-
-        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
-        
-        self.setupUi(self)
-
-    def setupUi(self, Form):
-        Form.setObjectName(&quot;Form&quot;)
-        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
-
-        self.gridlayout = QGridLayout(Form)
-        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
-        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
-        self.splitterV = QSplitter(Form)
-
-        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
-        self.splitterV.setSizePolicy(sizePolicy)
-        self.splitterV.setOrientation(Qt.Vertical)
-        self.splitterV.setObjectName(&quot;splitter&quot;)
-
-        # create the preferences buttons and connect the signals
-        self.ogreWindowOptions = QToolButton(self)
-        QObject.connect(self.ogreWindowOptions, SIGNAL(&quot;clicked()&quot;),
-                                    self.onPreferencesButton)
-        self.ogreWindowOptions.hide()
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Minimum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWindowOptions.sizePolicy().hasHeightForWidth())
-        self.ogreWindowOptions.setSizePolicy(sizePolicy)
-        self.ogreWindowOptions.setObjectName(&quot;ogreWindowPreferences&quot;)
-        self.splitterV.addWidget(self.ogreWindowOptions)
-
-        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
-
-        ##################################
-        self.ogreWidget = OgreWidget.OgreWidget(&quot;OgreMainWin&quot;, self.ogreRoot, self.OgreMainWinSceneMgr, &quot;MainCam&quot;, self.splitterV,  0)
-        self.ogreWidget.setMinimumSize(QSize(250,250))
-
-        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
-        self.ogreWidget.setSizePolicy(sizePolicy)
-        self.ogreWidget.setObjectName(&quot;ogreWidget&quot;)
-        self.splitterV.addWidget(self.ogreWidget)
-        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
-        ####################################
-
-        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
-
-        # register the eventfilters for the render windows
-        # this is needed to catch mouse enter and mouse leave events for these windows
-        self.ogreWidget.installEventFilter(self)
-        self.ogreWidget.setAcceptDrops(True)
-        self.lastMousePosX = 0
-        self.lastMousePosY = 0
-
-        self.retranslateUi(Form)
-        QMetaObject.connectSlotsByName(Form)
-        
-        self.ogreWidget.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)
-        
-    def ogreViewportCreatedCallback(self):
-        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
-        self.viewportGrid.enable()
-        
-    def retranslateUi(self, Form):
-        Form.setWindowTitle(QApplication.translate(&quot;Form&quot;, &quot;Form&quot;, None, QApplication.UnicodeUTF8))
-        self.ogreWindowOptions.setText(QApplication.translate(&quot;Form&quot;, &quot;...&quot;, None, QApplication.UnicodeUTF8))
-
-    def onPreferencesButton(self):
-        self.splitterH.setOrientation(Qt.Vertical)
-
-    def keyPressEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = True
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = True
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = True
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= True
-
-    def keyReleaseEvent(self,  event):
-        if event.key() == Qt.Key_W:
-            self.moveCamForward = False
-        elif event.key() == Qt.Key_S:
-            self.moveCamBackward = False
-        elif event.key() == Qt.Key_A:
-            self.strafeCamLeft = False
-        elif event.key() == Qt.Key_D:
-            self.strafeCamRight= False
-
-    def eventFilter(self, obj, event):
-        if event.type() == 2:
-            self.ogreWidget.setFocus()
-            if event.button() == 1: # left mouse button is pressed
-                self.leftMouseDown = True
-                self.moduleManager.leftMouseDown = True
-
-                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
-                    self.mDollyCamera = True
-                else:
-                    self.calculateSelectionRay(event)
-
-            elif event.button() == 2: # right mouse button is pressed
-                self.rightMouseDown = True
-                self.moduleManager.rightMouseDown = True
-
-            elif event.button() == 4: # middle mouse button is pressed
-                self.middleMouseDown = True
-                self.moduleManager.middleMouseDown = True
-
-            self.camUpdateTimer.start(15)
-
-        elif event.type() == 3:
-            if event.button() == 1: # left mouse button is released
-                self.leftMouseDown = False
-                self.moduleManager.leftMouseDown = False
-                self.moduleManager.leftMouseUp()
-
-                if self.mDollyCamera == True: #if we dolly the camera set it to false
-                    self.mDollyCamera = False
-
-            elif event.button() == 2: # right mouse button is released
-                self.rightMouseDown = False
-                self.moduleManager.rightMouseDown = False
-            elif event.button() == 4: # middle mouse button is released
-                self.middleMouseDown = False
-                self.moduleManager.middleMouseDown = False
-
-            if not self.rightMouseDown:
-                self.mDollyCamera = False
-                self.camUpdateTimer.stop()
-
-            self.lastMousePosX = 0
-            self.lastMousePosY = 0
-
-        elif event.type() == 5: #mouse moved while button down
-            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosX = event.globalX()
-            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
-                self.lastMousePosY = event.globalY()
-
-            incX =  (event.globalX() - self.lastMousePosX)
-            incY =  (event.globalY() - self.lastMousePosY)
-
-            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
-                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
-
-            rotX = incX * 0.01
-            rotY = incY * 0.01
-
-            if self.mDollyCamera:
-                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
-            elif self.rightMouseDown:
-                obj.orbitCamera(-rotX,  rotY)
-
-            self.lastMousePosX = event.globalX()
-            self.lastMousePosY = event.globalY()
-
-        if event.type() == 60: #drag enter
-            self.dragEnterEvent(event)
-        if event.type() == 61: #drag move
-            self.dragMoveEvent(event)
-#        if event.type() == 62:
-#            self.finishDropEvent(event)
-        if event.type() == 63:
-            self.finishDropEvent(event)
-
-        return False
-
-    def dragEnterEvent(self, event):
-        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
-            data = event.mimeData().data(&quot;application/x-static_model&quot;)
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream &gt;&gt; text
-
-            self.moduleManager.startDropModelAction(str(text), self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-
-        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
-            data = event.mimeData().data(&quot;application/x-game_object&quot;)
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream &gt;&gt; text
-
-            self.moduleManager.startDropGameObjectAction(str(text), self.getCameraToViewportRay()) #start the model draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-        elif event.mimeData().hasFormat(&quot;application/x-material&quot;):
-            data = event.mimeData().data(&quot;application/x-material&quot;)
-            stream = QDataStream(data, QIODevice.ReadOnly)
-            text = QString()
-            stream &gt;&gt; text
-
-            self.moduleManager.startDropMaterialAction(str(text)) #start the material draging
-
-            event.setDropAction(Qt.CopyAction)
-            event.accept()
-        else:
-            event.ignore()
-
-
-    def dragMoveEvent(self, event):
-        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
-            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
-            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
-            event.accept()
-        elif event.mimeData().hasFormat(&quot;application/x-material&quot;):
-            self.moduleManager.moveDropMaterialAction(event) #move it with the mouse
-            event.accept()
-        else:
-            event.ignore()
-
-    def finishDropEvent(self, event):
-        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
-            self.moduleManager.finishDropModelAction(self.getCameraToViewportRay())
-            event.accept()
-        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
-            self.moduleManager.finishDropGameObjectAction(self.getCameraToViewportRay()) 
-            event.accept()
-        elif event.mimeData().hasFormat(&quot;application/x-material&quot;):
-            relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
-            self.moduleManager.finishDropMaterialAction(relMousePos.x(), relMousePos.y()) 
-            event.accept()
-        else:
-            event.ignore()
-
-    def getCameraToViewportRay(self):
-        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
-
-        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
-
-        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
-
-    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
-    def calculateSelectionRay(self,  event):
-        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
-
-#        if self.lastSelectionClick != None:
-#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
-#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
-#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
-#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
-#                return
-
-        self.lastSelectionClick = relMousePos
-        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
-        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
-
-        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
-
-        if event.modifiers() == Qt.ControlModifier:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
-        elif event.modifiers() == Qt.ShiftModifier:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
-        else:
-            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
-
-    def getWidth():
-        return self.ogreWidget.getWidth()
-        
-    def getHeight():
-        return self.ogreWidget.getHeight()
-
-    def updateCamera(self):        
-        if self.moveCamForward:
-            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
-        if self.moveCamBackward:
-            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
-        if self.strafeCamLeft:
-            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
-        if self.strafeCamRight:
-            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
-        
-        if self.moduleManager.pivot:
-            self.moduleManager.pivot.update()
-            
-    def updateRenderWindow(self):
-        self.ogreWidget.update()
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+
+import os
+import sys
+import platform
+
+from PyQt4.QtGui import *
+from PyQt4.QtCore import *
+
+from ViewportGrid import *
+
+import OgreWidget
+import ogre.renderer.OGRE as og
+
+# this class is the heart of the 3d part
+# it manages the two ogre render windows and recieves events from the windows through the event filter
+class OgreMainWindow(QWidget):
+    def __init__(self, moduleManager,  ogreRoot, OgreMainWinSceneMgr,  parent):
+        QWidget.__init__(self, parent)
+        self.moduleManager = moduleManager
+        self.ogreRoot = ogreRoot
+        self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
+
+        self.ogreWidget = None
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.mDollyCamera = False
+
+        self.moveCamForward = False
+        self.moveCamBackward = False
+        self.strafeCamLeft = False
+        self.strafeCamRight = False
+
+        self.camUpdateTimer = QTimer(self)
+        self.camUpdateTimer.connect(self.camUpdateTimer, SIGNAL(&quot;timeout()&quot;), self.updateCamera)
+
+        self.lastSelectionClick = None # Qpoint wich saves the last selection click mouse position
+        
+        self.setupUi(self)
+
+    def setupUi(self, Form):
+        Form.setObjectName(&quot;Form&quot;)
+        Form.resize(QSize(QRect(0,0,935,843).size()).expandedTo(Form.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(Form)
+        self.gridlayout.setContentsMargins(0, 2, 0, 0)
+        self.gridlayout.setObjectName(&quot;gridlayout&quot;)
+
+        # create the vertical splitter ( contains the preferences buttons and the horizontal splitter with the two render windows )
+        self.splitterV = QSplitter(Form)
+
+        sizePolicy = QSizePolicy(QSizePolicy.MinimumExpanding,QSizePolicy.MinimumExpanding)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.splitterV.sizePolicy().hasHeightForWidth())
+        self.splitterV.setSizePolicy(sizePolicy)
+        self.splitterV.setOrientation(Qt.Vertical)
+        self.splitterV.setObjectName(&quot;splitter&quot;)
+
+        # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
+
+        ##################################
+        self.ogreWidget = OgreWidget.OgreWidget(&quot;OgreMainWin&quot;, self.ogreRoot, self.OgreMainWinSceneMgr, &quot;MainCam&quot;, self.splitterV,  0)
+        self.ogreWidget.setMinimumSize(QSize(250,250))
+
+        sizePolicy = QSizePolicy(QSizePolicy.Maximum,QSizePolicy.Maximum)
+        sizePolicy.setHorizontalStretch(0)
+        sizePolicy.setVerticalStretch(0)
+        sizePolicy.setHeightForWidth(self.ogreWidget.sizePolicy().hasHeightForWidth())
+        self.ogreWidget.setSizePolicy(sizePolicy)
+        self.ogreWidget.setObjectName(&quot;ogreWidget&quot;)
+        self.splitterV.addWidget(self.ogreWidget)
+        self.ogreWidget.setBackgroundColor(og.ColourValue(0, 1, 1))
+        ####################################
+
+        self.gridlayout.addWidget(self.splitterV,0,0,1,1)
+
+        # register the eventfilters for the render windows
+        # this is needed to catch mouse enter and mouse leave events for these windows
+        self.ogreWidget.installEventFilter(self)
+        self.ogreWidget.setAcceptDrops(True)
+        self.lastMousePosX = 0
+        self.lastMousePosY = 0
+
+        self.retranslateUi(Form)
+        QMetaObject.connectSlotsByName(Form)
+        
+        self.ogreWidget.setOgreViewportCreatedCallback(self.ogreViewportCreatedCallback)
+        
+    def ogreViewportCreatedCallback(self):
+        self.viewportGrid = ViewportGrid(self.OgreMainWinSceneMgr, self.ogreWidget.viewport)
+        self.viewportGrid.enable()
+        
+    def retranslateUi(self, Form):
+        Form.setWindowTitle(QApplication.translate(&quot;Form&quot;, &quot;Form&quot;, None, QApplication.UnicodeUTF8))
+
+    def keyPressEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = True
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = True
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = True
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= True
+
+    def keyReleaseEvent(self,  event):
+        if event.key() == Qt.Key_W:
+            self.moveCamForward = False
+        elif event.key() == Qt.Key_S:
+            self.moveCamBackward = False
+        elif event.key() == Qt.Key_A:
+            self.strafeCamLeft = False
+        elif event.key() == Qt.Key_D:
+            self.strafeCamRight= False
+
+    def eventFilter(self, obj, event):
+        if event.type() == 2:
+            self.ogreWidget.setFocus()
+            if event.button() == 1: # left mouse button is pressed
+                self.leftMouseDown = True
+                self.moduleManager.leftMouseDown = True
+
+                if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
+                    self.mDollyCamera = True
+                else:
+                    self.calculateSelectionRay(event)
+
+            elif event.button() == 2: # right mouse button is pressed
+                self.rightMouseDown = True
+                self.moduleManager.rightMouseDown = True
+                QTimer.singleShot(50, self.onContextMenuTimer)
+
+            elif event.button() == 4: # middle mouse button is pressed
+                self.middleMouseDown = True
+                self.moduleManager.middleMouseDown = True
+
+            self.camUpdateTimer.start(15)
+
+        elif event.type() == 3:
+            if event.button() == 1: # left mouse button is released
+                self.leftMouseDown = False
+                self.moduleManager.leftMouseDown = False
+                self.moduleManager.leftMouseUp()
+
+                if self.mDollyCamera == True: #if we dolly the camera set it to false
+                    self.mDollyCamera = False
+
+            elif event.button() == 2: # right mouse button is released
+                self.rightMouseDown = False
+                self.moduleManager.rightMouseDown = False
+                
+            elif event.button() == 4: # middle mouse button is released
+                self.middleMouseDown = False
+                self.moduleManager.middleMouseDown = False
+
+            if not self.rightMouseDown:
+                self.mDollyCamera = False
+                self.camUpdateTimer.stop()
+
+            self.lastMousePosX = 0
+            self.lastMousePosY = 0
+
+        elif event.type() == 5: #mouse moved while button down
+            if self.lastMousePosX == 0: # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosX = event.globalX()
+            if self.lastMousePosY == 0:# check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
+                self.lastMousePosY = event.globalY()
+
+            incX =  (event.globalX() - self.lastMousePosX)
+            incY =  (event.globalY() - self.lastMousePosY)
+
+            if self.moduleManager.pivot is not None and  self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
+                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
+
+            rotX = incX * 0.01
+            rotY = incY * 0.01
+
+            if self.mDollyCamera:
+                obj.dollyCamera(og.Vector3(rotX, -rotY,  0) * 3)
+            elif self.rightMouseDown:
+                obj.orbitCamera(-rotX,  rotY)
+
+            self.lastMousePosX = event.globalX()
+            self.lastMousePosY = event.globalY()
+
+        if event.type() == 60: #drag enter
+            self.dragEnterEvent(event)
+        if event.type() == 61: #drag move
+            self.dragMoveEvent(event)
+#        if event.type() == 62:
+#            self.finishDropEvent(event)
+        if event.type() == 63:
+            self.finishDropEvent(event)
+
+        return False
+
+    def dragEnterEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
+            data = event.mimeData().data(&quot;application/x-static_model&quot;)
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream &gt;&gt; text
+
+            self.moduleManager.startDropModelAction(str(text), self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+
+        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
+            data = event.mimeData().data(&quot;application/x-game_object&quot;)
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream &gt;&gt; text
+
+            self.moduleManager.startDropGameObjectAction(str(text), self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-material&quot;):
+            data = event.mimeData().data(&quot;application/x-material&quot;)
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream &gt;&gt; text
+
+            self.moduleManager.startDropMaterialAction(str(text)) #start the material draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
+        else:
+            event.ignore()
+
+
+    def dragMoveEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
+            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
+            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-material&quot;):
+            self.moduleManager.moveDropMaterialAction(event) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
+
+    def finishDropEvent(self, event):
+        if event.mimeData().hasFormat(&quot;application/x-static_model&quot;):
+            self.moduleManager.finishDropModelAction(self.getCameraToViewportRay())
+            event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-game_object&quot;):
+            self.moduleManager.finishDropGameObjectAction(self.getCameraToViewportRay()) 
+            event.accept()
+        elif event.mimeData().hasFormat(&quot;application/x-material&quot;):
+            relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
+            self.moduleManager.finishDropMaterialAction(relMousePos.x(), relMousePos.y()) 
+            event.accept()
+        else:
+            event.ignore()
+
+    def getCameraToViewportRay(self):
+        relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos())
+
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        return self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+    #calculates the the selection ray and notifies the ModuleManager that something is about to be selected
+    def calculateSelectionRay(self,  event):
+        relMousePos = self.ogreWidget.mapFromGlobal(QPoint(event.globalX(),  event.globalY())) # get the mose position relative to the ogre window
+
+#        if self.lastSelectionClick != None:
+#            if self.lastSelectionClick.x() == relMousePos.x() and self.lastSelectionClick.y() == relMousePos.y(): # mouse didn't move
+#                # we don't initiate a new selection based on bounding boxes here, we just iterate through the list generated last time a selection was made
+#                # this is based on how far the distance of the object is from the camera (as returned by ogre)
+#                self.moduleManager.iterateEntityUnderMouse() # don't select something new, switch through the currently selected models
+#                return
+
+        self.lastSelectionClick = relMousePos
+        screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+        screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+
+        mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+        if event.modifiers() == Qt.ControlModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  True,  False)
+        elif event.modifiers() == Qt.ShiftModifier:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay,  False,  True)
+        else:
+            self.moduleManager.selectionClick(relMousePos.x(), relMousePos.y(), mouseRay)
+
+    def getWidth():
+        return self.ogreWidget.getWidth()
+        
+    def getHeight():
+        return self.ogreWidget.getHeight()
+
+    def updateCamera(self):        
+        if self.moveCamForward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0,-0.2))
+        if self.moveCamBackward:
+            self.ogreWidget.dollyCamera(og.Vector3( 0, 0, 0.2))
+        if self.strafeCamLeft:
+            self.ogreWidget.dollyCamera(og.Vector3(-0.2, 0 , 0))
+        if self.strafeCamRight:
+            self.ogreWidget.dollyCamera(og.Vector3( 0.2, 0, 0))
+        
+        if self.moduleManager.pivot:
+            self.moduleManager.pivot.update()
+            
+    def updateRenderWindow(self):
+        self.ogreWidget.update()
+        
+    def onContextMenuTimer(self):
+        if not self.rightMouseDown:
+            relMousePos = self.ogreWidget.mapFromGlobal(QCursor.pos()) # get the mose position relative to the ogre window
+            
+            screenX = relMousePos.x()/float(self.ogreWidget.viewport.getActualWidth())
+            screenY = relMousePos.y()/float(self.ogreWidget.viewport.getActualHeight())
+            mouseRay = self.ogreWidget.getCamera().getCameraToViewportRay(screenX, screenY)
+
+            self.moduleManager.onContextMenu(relMousePos.x(), relMousePos.y(), mouseRay)
+            
+    def toggleViewportGrid(self):
+        if self.viewportGrid.isEnabled():
+            self.viewportGrid.disable()
+        else:
+            self.viewportGrid.enable()
+        

Modified: rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/OgreWidget.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,164 +1,163 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import platform
-import os
-
-from PyQt4 import QtGui
-import ogre.renderer.OGRE as og
-
-class OgreWidget(QtGui.QWidget):
-    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
-        QtGui.QWidget.__init__(self, parent)
-        self.painted = False
-        self.renderWindowName = renderWindowName
-        self.parent = parent
-        self.ogreRoot = ogreRoot
-        self.sceneManager = sceneManager
-        self.cameraName = cameraName
-        self.camDistFromFocusNode = camDistFromFocusNode
-        self.initOgreWindow(renderWindowName,cameraName)
-        self.resizeEventListener = []
-        self.ogreViewportCreatedCallback = None
-        self.renderWindow = None
-
-    def initOgreWindow(self, renderWindowName, cameraName):
-        self.renderParameters = og.NameValuePairList()
-        
-
-        if platform.system() == &quot;Windows&quot; or platform.system() == &quot;MAC&quot;:
-            hwnd = int(self.winId())
-            self.renderParameters['externalWindowHandle'] = str(hwnd)
-        else:
-            win = str(int(self.winId()))
-            self.renderParameters['parentWindowHandle'] = win
-
-#        else:
-#            import sip
-#            info = self.x11Info()
-#            disp =  str(sip.unwrapinstance(info.display()))
-#            scr = str(info.screen())
-#            win = str(int(self.winId()))
-#            winHandle = disp + ':' + scr + ':' + win
-#            
-#            self.renderParameters['parentWindowHandle'] = win
-
-
-    def setBackgroundColor(self, colorValue):
-        if self.painted:
-            self.viewport.BackgroundColour = colorValue
-        else:
-            self.backGroundColor = colorValue
-
-    def setOgreViewportCreatedCallback(self, callback):
-        self.ogreViewportCreatedCallback = callback
-    
-    def paintEvent(self, event):
-        if not self.painted:
-            renderWindow = self.ogreRoot.createRenderWindow(self.renderWindowName, self.width(), self.height(),
-                                                False, self.renderParameters)
-
-            renderWindow.active = True
-            self.renderWindow = renderWindow
-            
-            self.camera = self.sceneManager.createCamera(self.cameraName)
-            self.camera.NearClipDistance = 0.1
-
-            # Create focus node (camera always points at this)
-            self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
-            self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-            # camera node is offset a ways along the Z axis of focus node
-            self.camNode = self.camFocusNode.createChildSceneNode()
-            # fix yaw on this one too for when we manipulate it directly
-            self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
-            self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
-            self.camNode.attachObject(self.camera)
-            
-            self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
-            self.viewport.setClearEveryFrame(True)
-            self.viewport.BackgroundColour = self.backGroundColor
-            
-            if self.ogreViewportCreatedCallback:
-                self.ogreViewportCreatedCallback()
-            
-            self.painted = True
-        
-    def resizeEvent(self, event):
-        if self.renderWindow:
-            self.renderWindow.resize(event.size().width(), event.size().height())
-            self.renderWindow.windowMovedOrResized()
-
-            if platform.system() == &quot;Linux&quot;:
-                self.viewport._updateDimensions() # shouldn't actually be needed but it doesn't work without it on linux
-
-            self.renderWindow.update(True)
-            self.ogreRoot.renderOneFrame()
-
-            if self.camera:
-                self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
-                
-        for listener in self.resizeEventListener:
-            listener(event.size().width(), event.size().height())
-
-    def addResizeEventListener(self, listener):
-        self.resizeEventListener.append(listener)
-
-    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
-        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
-
-    def getCamera(self):
-        assert(self.camera)
-        return self.camera
-    
-    def getWidth():
-        return self.renderWindow.getActualWidth()
-        
-    def getHeight():
-        return self.renderWindow.getActualHeight()
-    
-    #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
-    def orbitCamera( self, horz, vert):
-        #orbit around focus node
-        #yaw around world Y, pitch around local
-        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
-        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
-
-    #void ViewOgreWindow::zoomCamera(float zoom)
-    def zoomCamera(self, zoom):
-        #in perspective mode, zoom by altering camera orbit distance from focus
-        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
-        #make sure we don't go into -Z or even beyond clip distance to focus
-        pos = self.camNode.getPosition()
-        if pos.z &lt; self.camera.getNearClipDistance():
-            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
-
-    #Ogre::Vector3&amp; trans
-    def dollyCamera(self,  trans):
-        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
-
-    #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
-    def panCamera( self, horz, vert):
-        self.camNode.yaw(horz, og.Node.TS_WORLD)
-        self.camNode.pitch(vert, og.Node.TS_LOCAL)
-        
-    def update(self):
-        if self.renderWindow is not None:
-            self.renderWindow.update(True)
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+
+import sys
+import platform
+import os
+
+from PyQt4 import QtGui
+import ogre.renderer.OGRE as og
+
+class OgreWidget(QtGui.QWidget):
+    def __init__(self, renderWindowName, ogreRoot, sceneManager, cameraName, parent,  camDistFromFocusNode=100):
+        QtGui.QWidget.__init__(self, parent)
+        self.painted = False
+        self.renderWindowName = renderWindowName
+        self.parent = parent
+        self.ogreRoot = ogreRoot
+        self.sceneManager = sceneManager
+        self.cameraName = cameraName
+        self.camDistFromFocusNode = camDistFromFocusNode
+        self.initOgreWindow(renderWindowName,cameraName)
+        self.resizeEventListener = []
+        self.ogreViewportCreatedCallback = None
+        self.renderWindow = None
+
+    def initOgreWindow(self, renderWindowName, cameraName):
+        self.renderParameters = og.NameValuePairList()
+        
+
+        if platform.system() == &quot;Windows&quot; or platform.system() == &quot;MAC&quot;:
+            hwnd = int(self.winId())
+            self.renderParameters['externalWindowHandle'] = str(hwnd)
+        else:
+            win = str(int(self.winId()))
+            self.renderParameters['parentWindowHandle'] = win
+
+#        else:
+#            import sip
+#            info = self.x11Info()
+#            disp =  str(sip.unwrapinstance(info.display()))
+#            scr = str(info.screen())
+#            win = str(int(self.winId()))
+#            winHandle = disp + ':' + scr + ':' + win
+#            
+#            self.renderParameters['parentWindowHandle'] = win
+
+
+    def setBackgroundColor(self, colorValue):
+        if self.painted:
+            self.viewport.BackgroundColour = colorValue
+        else:
+            self.backGroundColor = colorValue
+
+    def setOgreViewportCreatedCallback(self, callback):
+        self.ogreViewportCreatedCallback = callback
+    
+    def paintEvent(self, event):
+        if not self.painted:
+            renderWindow = self.ogreRoot.createRenderWindow(self.renderWindowName, self.width(), self.height(),
+                                                False, self.renderParameters)
+
+            renderWindow.active = True
+            self.renderWindow = renderWindow
+            
+            self.camera = self.sceneManager.createCamera(self.cameraName)
+            self.camera.NearClipDistance = 0.5
+
+            # Create focus node (camera always points at this)
+            self.camFocusNode = self.sceneManager.getRootSceneNode().createChildSceneNode()
+            self.camFocusNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            # camera node is offset a ways along the Z axis of focus node
+            self.camNode = self.camFocusNode.createChildSceneNode()
+            # fix yaw on this one too for when we manipulate it directly
+            self.camNode.setFixedYawAxis(True, og.Vector3().UNIT_Y)
+            self.camNode.setPosition(0, 0, self.camDistFromFocusNode)
+            self.camNode.attachObject(self.camera)
+            
+            self.viewport = self.renderWindow.addViewport(self.camera, 0, 0.0, 0.0, 1.0, 1.0)
+            self.viewport.setClearEveryFrame(True)
+            self.viewport.BackgroundColour = self.backGroundColor
+            
+            if self.ogreViewportCreatedCallback:
+                self.ogreViewportCreatedCallback()
+            
+            self.painted = True
+        
+    def resizeEvent(self, event):
+        if self.renderWindow:
+            self.renderWindow.resize(event.size().width(), event.size().height())
+            self.renderWindow.windowMovedOrResized()
+            self.viewport.update()
+
+            self.renderWindow.update(True)
+            self.ogreRoot.renderOneFrame()
+            
+            if self.camera:
+                self.camera.setAspectRatio(float(event.size().width()) / float(event.size().height()));
+                
+        for listener in self.resizeEventListener:
+            listener(event.size().width(), event.size().height())
+
+    def addResizeEventListener(self, listener):
+        self.resizeEventListener.append(listener)
+
+    def addOgreResourceLocation(self, location, locType, resGroup, recursive=False):
+        og.ResourceGroupManager.getSingleton().addResourceLocation(location, locType, resGroup, recursive)
+
+    def getCamera(self):
+        assert(self.camera)
+        return self.camera
+    
+    def getWidth():
+        return self.renderWindow.getActualWidth()
+        
+    def getHeight():
+        return self.renderWindow.getActualHeight()
+    
+    #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
+    def orbitCamera( self, horz, vert):
+        #orbit around focus node
+        #yaw around world Y, pitch around local
+        self.camFocusNode.yaw(horz, og.Node.TS_WORLD)
+        self.camFocusNode.pitch(-vert, og.Node.TS_LOCAL)
+
+    #void ViewOgreWindow::zoomCamera(float zoom)
+    def zoomCamera(self, zoom):
+        #in perspective mode, zoom by altering camera orbit distance from focus
+        self.camNode.translate(0, 0, -zoom * 2, og.Node.TS_LOCAL)
+        #make sure we don't go into -Z or even beyond clip distance to focus
+        pos = self.camNode.getPosition()
+        if pos.z &lt; self.camera.getNearClipDistance():
+            self.camNode.setPosition(pos.x, pos.y, self.camera.getNearClipDistance())
+
+    #Ogre::Vector3&amp; trans
+    def dollyCamera(self,  trans):
+        self.camFocusNode.translate(trans, og.Node.TS_LOCAL)
+
+    #(const Ogre::Radian&amp; horz, const Ogre::Radian&amp; vert)
+    def panCamera( self, horz, vert):
+        self.camNode.yaw(horz, og.Node.TS_WORLD)
+        self.camNode.pitch(vert, og.Node.TS_LOCAL)
+        
+    def update(self):
+        if self.renderWindow is not None:
+            self.renderWindow.update(True)
+

Modified: rl/branches/persistence2/editors/Lockenwickler/src/Plugins-linux.cfg
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/Plugins-linux.cfg	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/Plugins-linux.cfg	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,13 +1,13 @@
 # Defines plugins to load
 
 # Define plugin folder
-PluginFolder=/home/fusion/development/root/usr/lib/OGRE/
+PluginFolder=/home/fusion/development/root/usr/lib/OGRE
 #PluginFolder=/usr/lib/OGRE
 
 # default plugins installed with the libogre14 package
 Plugin=RenderSystem_GL.so
 Plugin=Plugin_ParticleFX.so
 Plugin=Plugin_OctreeSceneManager.so
-#Plugin=Plugin_CgProgramManager
+Plugin=Plugin_CgProgramManager
 
 

Modified: rl/branches/persistence2/editors/Lockenwickler/src/Plugins-windows.cfg
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/Plugins-windows.cfg	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/Plugins-windows.cfg	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,7 +1,7 @@
 # Defines plugins to load
 
 # Define plugin folder
-PluginFolder=./plugins
+PluginFolder=../../../../PythonOgre/plugins
 
 # Define plugins
 Plugin=RenderSystem_Direct3D9

Modified: rl/branches/persistence2/editors/Lockenwickler/src/Plugins.cfg
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/Plugins.cfg	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/Plugins.cfg	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,7 +1,7 @@
 # Defines plugins to load
 
 # Define plugin folder
-PluginFolder=./plugins
+PluginFolder=../../../../PythonOgre/plugins
 
 # Define plugins
 Plugin=RenderSystem_Direct3D9

Modified: rl/branches/persistence2/editors/Lockenwickler/src/PreferencesDialog.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/PreferencesDialog.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/PreferencesDialog.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 import sys
@@ -63,7 +64,7 @@
 
     def openModulConfigSelector(self):
         dialog = QFileDialog(self)
-        self.moduleCfgPath = str(dialog.getOpenFileName(self, &quot;Select modules.cfg&quot;, &quot;/home/stefan/blubb/rl_modules/modules/&quot;, &quot;modules.cfg (*.cfg)&quot;))
+        self.moduleCfgPath = str(dialog.getOpenFileName(self, &quot;Select modules.cfg&quot;, &quot;/home/melven/rastullah/rl_dist/modules/&quot;, &quot;modules.cfg (*.cfg)&quot;))
         self.modulePath = self.moduleCfgPath.replace(&quot;modules.cfg&quot;, &quot;&quot;)
 
         from os.path import isfile

Modified: rl/branches/persistence2/editors/Lockenwickler/src/Property.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/Property.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/Property.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 from PyQt4.QtCore import *
 from PyQt4.QtGui import *

Modified: rl/branches/persistence2/editors/Lockenwickler/src/PythonOgreConfig.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/PythonOgreConfig.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/PythonOgreConfig.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,20 +1,21 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 
 #

Modified: rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/SelectionBuffer.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,252 +1,317 @@
-import ctypes as ctypes
-import random
-import platform
-
-import ogre.renderer.OGRE as og
-
-
-# a class to store information about a object that got selected
-class SelectionObject():
-    def __init__(self,  entity):
-        self.entityName = entity.getName()
-        self.entity = entity #the selected entity
-        self.isPivot = False
-
-#        if self.entity.getUserObject() is not None:
-#            self.isGameObject = True
-#        else:
-#            self.isGameObject = False
-
-    #if True this instance will show its bounding box else it will hide it
-    def setSelected(self,  selected):
-        if selected == True:
-            self.entity.getParentNode().showBoundingBox(True)
-        else:
-            self.entity.getParentNode().showBoundingBox(False)
-
-    def __eq__(self, other):
-        return self.entity.getName() == other.entity.getName()
-
-    def __ne__(self, other):
-        return self.entity.getName() != other.entity.getName()
-
-# class to handle material switching without having to modify scene materials individually
-class MaterialSwitcher( og.MaterialManager.Listener ):
-    def __init__(self):
-        og.MaterialManager.Listener.__init__(self)
-      
-        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
-        self.currentColorAsVector3 = og.Vector3()
-
-        self.lastEntity = &quot;&quot;
-        self.lastTechnique = None
- 
-
-        if platform.system() == &quot;Windows&quot;:
-            self.lastTechnique = og.MaterialManager.getSingleton().load(&quot;PlainColor&quot;, og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
-        else:
-            self.lastTechnique = og.MaterialManager.getSingleton().load(&quot;PlainColorGLSL&quot;, og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
-        
-        self.colorDict = {}
-       
-    # takes into account that one Entity can have multiple SubEntities
-    def handleSchemeNotFound(self, index, name, material, lod, subEntity):
-
-        temp = str(type(subEntity))
-        if temp == &quot;&lt;class 'ogre.renderer.OGRE._ogre_.SubEntity'&gt;&quot;:
-            if self.lastEntity == subEntity.getParent().getName():
-                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
-                #print str(subEntity.getParent().getRenderQueueGroup())
-                return self.lastTechnique
-            else:
-                self.randomizeColor()
-                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
-                
-                self.lastEntity = subEntity.getParent().getName()
-                self.colorDict[self.lastEntity] = self.currentColorAsVector3
-                return self.lastTechnique
-        
-
-    def randomizeColor(self):
-        r = random.randrange(1, 255)
-        g = random.randrange(1, 255)
-        b = random.randrange(1, 255)
-        self.currentColorAsVector3 = og.Vector3(r, g, b)
-        var = 1.0 / 255.0
-
-        self.currentColor = og.ColourValue(r * var, g * var, b * var)
-
-        #print str(int(self.currentColor.r * 255)) + &quot; &quot; + str(int(255 * self.currentColor.g)) + &quot; &quot; + str(int(255 * self.currentColor.b))
-    
-    def reset(self):
-        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
-        self.lastEntity = &quot;&quot;
-        
-# We need this attached to the depth target, otherwise we get problems with the compositor
-# MaterialManager.Listener should NOT be running all the time - rather only when we're
-# specifically rendering the target that needs it
-class SelectionRenderListener(og.RenderTargetListener):
-    def __init__(self, materialListener):
-        og.RenderTargetListener.__init__(self)
-        self.materialListener = materialListener
- 
-    def preRenderTargetUpdate(self, evt):
-        og.MaterialManager.getSingleton().addListener( self.materialListener )
- 
-    def postRenderTargetUpdate(self, evt):
-        og.MaterialManager.getSingleton().removeListener( self.materialListener )
-
-        
-class SelectionBuffer():
-    def __init__(self, sceneManager,  renderTarget):
-        self.sceneMgr = sceneManager
-        self.camera = sceneManager.getCamera(&quot;MainCam&quot;)
-
-        self.renderTarget = renderTarget
-        
-        # This is the material listener - Note: it is controlled by a seperate
-        # RenderTargetListener, not applied globally to all targets
-        self.materialSwitchListener = MaterialSwitcher()
-        
-        self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
-        
-        width = self.renderTarget.getWidth()
-        height = self.renderTarget.getHeight()
-        
-        self.texture = og.TextureManager.getSingleton().createManual(&quot;SelectionPassTex&quot;, 
-                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
-                                                                    og.TEX_TYPE_2D, 
-                                                                    width, 
-                                                                    height, 
-                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
-                                                                    
-        self.renderTexture = self.texture.getBuffer().getRenderTarget()
-        self.renderTexture.setAutoUpdated(False)
-        self.renderTexture.setPriority(0)                                                         
-        self.renderTexture.addViewport( self.camera )
-        self.renderTexture.getViewport(0).setOverlaysEnabled(False)
-        self.renderTexture.getViewport(0).setClearEveryFrame(True)
-        self.renderTexture.addListener( self.selectionTargetListener )
-        self.renderTexture.getViewport(0).setMaterialScheme(&quot;aa&quot;)
-        
-#        self.createRTTOverlays()
-
-    def update(self):
-        self.updateBufferSize()
-        
-        self.renderTexture.update()        
-        self.materialSwitchListener.reset()
-        
-        pixelBuffer = self.texture.getBuffer()
-        bufferSize = pixelBuffer.getSizeInBytes()
-        #buffersize2 = self.renderTexture.getWidth()*self.renderTexture.getHeight()*4
-        
-        storageclass = ctypes.c_uint8 * (bufferSize)
-        self.buffer = storageclass()
-        
-        VoidPointer = og.CastVoidPtr(ctypes.addressof(self.buffer))
-
-        self.pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
-        self.renderTexture.copyContentsToMemory(self.pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
-
-#        i = 0
-#        
-#        while i &lt; len(self.buffer):
-#            #print str(self.buffer[i + 2]) + &quot; &quot; + str(self.buffer[i+1]) + &quot; &quot; + str(self.buffer[i])
-#            
-#            i += 4
-    
-    def updateBufferSize(self):
-        width = self.renderTarget.getWidth()
-        height = self.renderTarget.getHeight()
-        needsSizeUpdate = False
-        
-        if width is not self.renderTexture.getWidth():
-            needsSizeUpdate = True
-        if height is not self.renderTexture.getHeight():
-            needsSizeUpdate = True            
-        
-        if needsSizeUpdate:
-            og.TextureManager.getSingleton().unload(&quot;SelectionPassTex&quot;)
-            
-            self.texture = og.TextureManager.getSingleton().createManual(&quot;SelectionPassTex&quot;, 
-                                                            og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
-                                                            og.TEX_TYPE_2D, 
-                                                            width, 
-                                                            height, 
-                                                            0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
-                                                                    
-            self.renderTexture = self.texture.getBuffer().getRenderTarget()
-            self.renderTexture.setAutoUpdated(False)
-            self.renderTexture.setPriority(0)                                                         
-            self.renderTexture.addViewport( self.camera )
-            self.renderTexture.getViewport(0).setOverlaysEnabled(False)
-            self.renderTexture.getViewport(0).setClearEveryFrame(True)
-            self.renderTexture.addListener( self.selectionTargetListener )
-            self.renderTexture.getViewport(0).setMaterialScheme(&quot;aa&quot;)
-        else:
-            return
-            
-    def onSelectionClick(self, x, y):
-        self.update()
-        
-        posInStream = (self.pBox.getWidth() * y - 1)*4
-        posInStream += x*4
-        
-        colVec = og.Vector3(self.buffer[posInStream + 2], self.buffer[posInStream+1], self.buffer[posInStream])
-        
-        for key in self.materialSwitchListener.colorDict:
-            if self.materialSwitchListener.colorDict[key] == colVec:
-                if key == &quot;OgreMainWin::0::ViewportGrid&quot;:
-                    return None
-                elif key == &quot;rayLine&quot;:
-                    return None
-                elif key == &quot;EditorXArrow&quot;:
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == &quot;EditorYArrow&quot;:
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == &quot;EditorZArrow&quot;:
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                elif key == &quot;EditorXRotator&quot; or key == &quot;EditorYRotator&quot; or key == &quot;EditorZRotator&quot;:
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                elif key == &quot;EditorXScaler&quot; or key == &quot;EditorYScaler&quot; or key == &quot;EditorZScaler&quot;:
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    so.isPivot = True
-                    return so
-                else:
-                    so = SelectionObject(self.sceneMgr.getEntity(key))
-                    return so
-
-        return None
-        
-    def createRTTOverlays(self):
-        baseWhite = og.MaterialManager.getSingletonPtr().getByName(&quot;Lockenwickler_Pivot_X&quot;)
-        SelectionBufferTexture = baseWhite.clone(&quot;SelectionDebugMaterial&quot;)
-        textureUnit = SelectionBufferTexture.getTechnique(0).getPass(0).createTextureUnitState()
- 
-        textureUnit.setTextureName(&quot;SelectionPassTex&quot;)
- 
- 
-        overlayManager = og.OverlayManager.getSingleton()
-        # Create an overlay
-        self.mDebugOverlay = overlayManager.create(&quot;OverlayName&quot;)
- 
-        # Create a panel
-        panel = overlayManager.createOverlayElement(&quot;Panel&quot;, &quot;PanelName0&quot;)
-        panel.setMetricsMode(og.GMM_PIXELS)
-        panel.setPosition(10, 10)
-        panel.setDimensions(400, 280)
-        panel.setMaterialName(&quot;SelectionDebugMaterial&quot;) 
-        self.mDebugOverlay.add2D(panel)
- 
-        self.mDebugOverlay.show()
-
-
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+import ctypes as ctypes
+import random
+import platform
+
+import ogre.renderer.OGRE as og
+
+# get the light out of a light node
+def extractLight(node):
+        i = 0
+        num = node.numAttachedObjects()
+        while i &lt; node.numAttachedObjects():
+            c = node.getAttachedObject(i)
+            tp = str(type(c))
+            if tp == &quot;&lt;class 'ogre.renderer.OGRE._ogre_.Light'&gt;&quot;:
+                return c
+            i += 1
+            
+# get the light out of a light node
+def extractEntity(node):
+        i = 0
+        num = node.numAttachedObjects()
+        while i &lt; node.numAttachedObjects():
+            c = node.getAttachedObject(i)
+            tp = str(type(c))
+            if tp == &quot;&lt;class 'ogre.renderer.OGRE._ogre_.Entity'&gt;&quot;:
+                return c
+            i += 1
+
+# a class to store information about a object that got selected
+class SelectionObject():
+    def __init__(self,  entity):
+        self.entityName = entity.getName()
+        self.entity = entity #the selected entity
+        self.isPivot = False
+
+
+
+    #if True this instance will show its bounding box else it will hide it
+    def setSelected(self,  selected):
+        if selected == True:
+            self.entity.getParentNode().showBoundingBox(True)
+        else:
+            self.entity.getParentNode().showBoundingBox(False)
+
+    def __eq__(self, other):
+        return self.entity.getName() == other.entity.getName()
+
+    def __ne__(self, other):
+        return self.entity.getName() != other.entity.getName()
+
+# class to handle material switching without having to modify scene materials individually
+class MaterialSwitcher( og.MaterialManager.Listener ):
+    def __init__(self):
+        og.MaterialManager.Listener.__init__(self)
+      
+        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.currentColorAsVector3 = og.Vector3()
+
+        self.lastEntity = &quot;&quot;
+        self.lastTechnique = None
+ 
+
+        if platform.system() == &quot;Windows&quot;:
+            self.lastTechnique = og.MaterialManager.getSingleton().load(&quot;PlainColor&quot;, og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
+        else:
+            self.lastTechnique = og.MaterialManager.getSingleton().load(&quot;PlainColorGLSL&quot;, og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME).getTechnique(0)
+        
+        self.colorDict = {}
+       
+    # takes into account that one Entity can have multiple SubEntities
+    def handleSchemeNotFound(self, index, name, material, lod, subEntity):
+
+        temp = str(type(subEntity))
+        if temp == &quot;&lt;class 'ogre.renderer.OGRE._ogre_.SubEntity'&gt;&quot;:
+            if self.lastEntity == subEntity.getParent().getName():
+                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                #print str(subEntity.getParent().getRenderQueueGroup())
+                return self.lastTechnique
+            else:
+                self.randomizeColor()
+                subEntity.setCustomParameter(1, og.Vector4(self.currentColor.r, self.currentColor.g, self.currentColor.b, 1.0))
+                
+                self.lastEntity = subEntity.getParent().getName()
+                self.colorDict[self.lastEntity] = self.currentColorAsVector3
+                return self.lastTechnique
+        
+
+    def randomizeColor(self):
+        r = random.randrange(1, 255)
+        g = random.randrange(1, 255)
+        b = random.randrange(1, 255)
+        self.currentColorAsVector3 = og.Vector3(r, g, b)
+        var = 1.0 / 255.0
+
+        self.currentColor = og.ColourValue(r * var, g * var, b * var)
+
+        #print str(int(self.currentColor.r * 255)) + &quot; &quot; + str(int(255 * self.currentColor.g)) + &quot; &quot; + str(int(255 * self.currentColor.b))
+    
+    def reset(self):
+        self.currentColor = og.ColourValue(0.0, 0.0, 0.0)
+        self.lastEntity = &quot;&quot;
+        
+# We need this attached to the depth target, otherwise we get problems with the compositor
+# MaterialManager.Listener should NOT be running all the time - rather only when we're
+# specifically rendering the target that needs it
+class SelectionRenderListener(og.RenderTargetListener):
+    def __init__(self, materialListener):
+        og.RenderTargetListener.__init__(self)
+        self.materialListener = materialListener
+ 
+    def preRenderTargetUpdate(self, evt):
+        og.MaterialManager.getSingleton().addListener( self.materialListener )
+ 
+    def postRenderTargetUpdate(self, evt):
+        og.MaterialManager.getSingleton().removeListener( self.materialListener )
+
+        
+class SelectionBuffer():
+    def __init__(self, sceneManager,  renderTarget, moduleManager, zoneManager):
+        self.sceneMgr = sceneManager
+        self.camera = sceneManager.getCamera(&quot;MainCam&quot;)
+        self.moduleManager = moduleManager
+        self.zoneManager = zoneManager
+        
+        self.renderTarget = renderTarget
+        
+        # This is the material listener - Note: it is controlled by a seperate
+        # RenderTargetListener, not applied globally to all targets
+        self.materialSwitchListener = MaterialSwitcher()
+        
+        self.selectionTargetListener = SelectionRenderListener( self.materialSwitchListener )
+        
+        width = self.renderTarget.getWidth()
+        height = self.renderTarget.getHeight()
+        
+        self.texture = og.TextureManager.getSingleton().createManual(&quot;SelectionPassTex&quot;, 
+                                                                    og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+                                                                    og.TEX_TYPE_2D, 
+                                                                    width, 
+                                                                    height, 
+                                                                    0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+        self.renderTexture = self.texture.getBuffer().getRenderTarget()
+        self.renderTexture.setAutoUpdated(False)
+        self.renderTexture.setPriority(0)                                                         
+        self.renderTexture.addViewport( self.camera )
+        self.renderTexture.getViewport(0).setOverlaysEnabled(False)
+        self.renderTexture.getViewport(0).setClearEveryFrame(True)
+        self.renderTexture.addListener( self.selectionTargetListener )
+        self.renderTexture.getViewport(0).setMaterialScheme(&quot;aa&quot;)
+        
+#        self.createRTTOverlays()
+
+    def update(self):
+        self.updateBufferSize()
+        
+        self.renderTexture.update()        
+        self.materialSwitchListener.reset()
+        
+        pixelBuffer = self.texture.getBuffer()
+        bufferSize = pixelBuffer.getSizeInBytes()
+        #buffersize2 = self.renderTexture.getWidth()*self.renderTexture.getHeight()*4
+        
+        storageclass = ctypes.c_uint8 * (bufferSize)
+        self.buffer = storageclass()
+        
+        VoidPointer = og.CastVoidPtr(ctypes.addressof(self.buffer))
+
+        self.pBox = og.PixelBox(pixelBuffer.getWidth(), pixelBuffer.getHeight(),pixelBuffer.getDepth(), pixelBuffer.getFormat(), VoidPointer)
+        self.renderTexture.copyContentsToMemory(self.pBox, og.RenderTarget.FrameBuffer.FB_FRONT)
+
+#        i = 0
+#        
+#        while i &lt; len(self.buffer):
+#            #print str(self.buffer[i + 2]) + &quot; &quot; + str(self.buffer[i+1]) + &quot; &quot; + str(self.buffer[i])
+#            
+#            i += 4
+    
+    def updateBufferSize(self):
+        width = self.renderTarget.getWidth()
+        height = self.renderTarget.getHeight()
+        needsSizeUpdate = False
+        
+        if width is not self.renderTexture.getWidth():
+            needsSizeUpdate = True
+        if height is not self.renderTexture.getHeight():
+            needsSizeUpdate = True            
+        
+        if needsSizeUpdate:
+            og.TextureManager.getSingleton().unload(&quot;SelectionPassTex&quot;)
+            
+            self.texture = og.TextureManager.getSingleton().createManual(&quot;SelectionPassTex&quot;, 
+                                                            og.ResourceGroupManager.DEFAULT_RESOURCE_GROUP_NAME, 
+                                                            og.TEX_TYPE_2D, 
+                                                            width, 
+                                                            height, 
+                                                            0, og.PixelFormat.PF_R8G8B8, og.TU_RENDERTARGET)
+                                                                    
+            self.renderTexture = self.texture.getBuffer().getRenderTarget()
+            self.renderTexture.setAutoUpdated(False)
+            self.renderTexture.setPriority(0)                                                         
+            self.renderTexture.addViewport( self.camera )
+            self.renderTexture.getViewport(0).setOverlaysEnabled(False)
+            self.renderTexture.getViewport(0).setClearEveryFrame(True)
+            self.renderTexture.addListener( self.selectionTargetListener )
+            self.renderTexture.getViewport(0).setMaterialScheme(&quot;aa&quot;)
+        else:
+            return
+            
+    def onSelectionClick(self, x, y):
+        self.update()
+        
+        posInStream = (self.pBox.getWidth() * y - 1)*4
+        posInStream += x*4
+        
+        colVec = og.Vector3(self.buffer[posInStream + 2], self.buffer[posInStream+1], self.buffer[posInStream])
+        
+        for key in self.materialSwitchListener.colorDict:
+            if self.materialSwitchListener.colorDict[key] == colVec:
+                if key == &quot;OgreMainWin::0::ViewportGrid&quot;:
+                    return None
+                elif key == &quot;rayLine&quot;:
+                    return None
+                elif key == &quot;EditorXArrow&quot;:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == &quot;EditorYArrow&quot;:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == &quot;EditorZArrow&quot;:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == &quot;EditorXRotator&quot; or key == &quot;EditorYRotator&quot; or key == &quot;EditorZRotator&quot;:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                elif key == &quot;EditorXScaler&quot; or key == &quot;EditorYScaler&quot; or key == &quot;EditorZScaler&quot; or key == &quot;UniScaler&quot;:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    so.isPivot = True
+                    return so
+                else:
+                    so = SelectionObject(self.sceneMgr.getEntity(key))
+                    return so
+
+        return None
+        
+    def manualSelectObjects(self, itemNodes):
+        items = []
+        for key in itemNodes:
+            parentNode = None
+            if key.startswith(&quot;Map: &quot;):
+                parentNode = self.moduleManager.mainModule.getMap(key.replace(&quot;Map: &quot;, &quot;&quot;)).mapNode
+                for nodeName in itemNodes[key]:                    
+                    n = parentNode.getChild(nodeName).getAttachedObject(0)
+                    if parentNode.getChild(nodeName).getName().startswith(&quot;light_&quot;):
+                        n = extractEntity(parentNode.getChild(nodeName))
+                        
+                    so = SelectionObject(n)
+                    so.setSelected(True)
+                    items.append(so)
+            elif key.startswith(&quot;Zone: &quot;):
+                parentNode = self.zoneManager.getZone(key.replace(&quot;Zone: &quot;, &quot;&quot;)).zoneNode
+                for nodeName in itemNodes[key]:
+                    obj = parentNode.getChild(nodeName).getAttachedObject(0)
+                    so = SelectionObject(obj)
+                    so.setSelected(True)
+                    items.append(so)
+        
+        return items
+        
+        
+    def createRTTOverlays(self):
+        baseWhite = og.MaterialManager.getSingletonPtr().getByName(&quot;Lockenwickler_Pivot_X&quot;)
+        SelectionBufferTexture = baseWhite.clone(&quot;SelectionDebugMaterial&quot;)
+        textureUnit = SelectionBufferTexture.getTechnique(0).getPass(0).createTextureUnitState()
+ 
+        textureUnit.setTextureName(&quot;SelectionPassTex&quot;)
+ 
+ 
+        overlayManager = og.OverlayManager.getSingleton()
+        # Create an overlay
+        self.mDebugOverlay = overlayManager.create(&quot;OverlayName&quot;)
+ 
+        # Create a panel
+        panel = overlayManager.createOverlayElement(&quot;Panel&quot;, &quot;PanelName0&quot;)
+        panel.setMetricsMode(og.GMM_PIXELS)
+        panel.setPosition(10, 10)
+        panel.setDimensions(400, 280)
+        panel.setMaterialName(&quot;SelectionDebugMaterial&quot;) 
+        self.mDebugOverlay.add2D(panel)
+ 
+        self.mDebugOverlay.show()
+
+
+

Modified: rl/branches/persistence2/editors/Lockenwickler/src/Ui_NewModuleWizard.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/Ui_NewModuleWizard.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/Ui_NewModuleWizard.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,100 +1,118 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file '/home/stefan/Lockenwickler/ui files/NewModuleWizard.ui'
-#
-# Created: Sun Nov  9 14:15:16 2008
-#      by: PyQt4 UI code generator 4.4.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
-
-class Ui_Dialog(object):
-    def setupUi(self, Dialog):
-        Dialog.setObjectName(&quot;Dialog&quot;)
-        Dialog.resize(675, 703)
-        self.gridLayout_3 = QtGui.QGridLayout(Dialog)
-        self.gridLayout_3.setObjectName(&quot;gridLayout_3&quot;)
-        self.label = QtGui.QLabel(Dialog)
-        self.label.setObjectName(&quot;label&quot;)
-        self.gridLayout_3.addWidget(self.label, 0, 0, 1, 1)
-        self.moduleNameLineEdit = QtGui.QLineEdit(Dialog)
-        self.moduleNameLineEdit.setObjectName(&quot;moduleNameLineEdit&quot;)
-        self.gridLayout_3.addWidget(self.moduleNameLineEdit, 0, 1, 1, 1)
-        self.label_2 = QtGui.QLabel(Dialog)
-        self.label_2.setObjectName(&quot;label_2&quot;)
-        self.gridLayout_3.addWidget(self.label_2, 1, 0, 1, 1)
-        self.sceneNameLineEdit = QtGui.QLineEdit(Dialog)
-        self.sceneNameLineEdit.setEnabled(False)
-        self.sceneNameLineEdit.setObjectName(&quot;sceneNameLineEdit&quot;)
-        self.gridLayout_3.addWidget(self.sceneNameLineEdit, 1, 1, 1, 1)
-        self.label_3 = QtGui.QLabel(Dialog)
-        self.label_3.setObjectName(&quot;label_3&quot;)
-        self.gridLayout_3.addWidget(self.label_3, 2, 0, 1, 1)
-        self.mapNameLineEdit = QtGui.QLineEdit(Dialog)
-        self.mapNameLineEdit.setEnabled(False)
-        self.mapNameLineEdit.setObjectName(&quot;mapNameLineEdit&quot;)
-        self.gridLayout_3.addWidget(self.mapNameLineEdit, 2, 1, 1, 1)
-        self.groupBox = QtGui.QGroupBox(Dialog)
-        self.groupBox.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
-        self.groupBox.setObjectName(&quot;groupBox&quot;)
-        self.gridLayout_2 = QtGui.QGridLayout(self.groupBox)
-        self.gridLayout_2.setObjectName(&quot;gridLayout_2&quot;)
-        self.moduleDependenciesList = QtGui.QListWidget(self.groupBox)
-        self.moduleDependenciesList.setEnabled(False)
-        self.moduleDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
-        self.moduleDependenciesList.setObjectName(&quot;moduleDependenciesList&quot;)
-        self.gridLayout_2.addWidget(self.moduleDependenciesList, 1, 0, 1, 1)
-        self.gridLayout_3.addWidget(self.groupBox, 3, 0, 1, 2)
-        self.groupBox_2 = QtGui.QGroupBox(Dialog)
-        self.groupBox_2.setObjectName(&quot;groupBox_2&quot;)
-        self.gridLayout = QtGui.QGridLayout(self.groupBox_2)
-        self.gridLayout.setObjectName(&quot;gridLayout&quot;)
-        self.scriptDependenciesList = QtGui.QListWidget(self.groupBox_2)
-        self.scriptDependenciesList.setEnabled(False)
-        self.scriptDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
-        self.scriptDependenciesList.setObjectName(&quot;scriptDependenciesList&quot;)
-        self.gridLayout.addWidget(self.scriptDependenciesList, 0, 0, 1, 1)
-        self.gridLayout_3.addWidget(self.groupBox_2, 4, 0, 1, 2)
-        self.hboxlayout = QtGui.QHBoxLayout()
-        self.hboxlayout.setSpacing(6)
-        self.hboxlayout.setMargin(0)
-        self.hboxlayout.setObjectName(&quot;hboxlayout&quot;)
-        spacerItem = QtGui.QSpacerItem(131, 31, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
-        self.hboxlayout.addItem(spacerItem)
-        self.okButton = QtGui.QPushButton(Dialog)
-        self.okButton.setEnabled(False)
-        self.okButton.setObjectName(&quot;okButton&quot;)
-        self.hboxlayout.addWidget(self.okButton)
-        self.cancelButton = QtGui.QPushButton(Dialog)
-        self.cancelButton.setObjectName(&quot;cancelButton&quot;)
-        self.hboxlayout.addWidget(self.cancelButton)
-        self.gridLayout_3.addLayout(self.hboxlayout, 5, 0, 1, 2)
-
-        self.retranslateUi(Dialog)
-        QtCore.QObject.connect(self.okButton, QtCore.SIGNAL(&quot;clicked()&quot;), Dialog.accept)
-        QtCore.QObject.connect(self.cancelButton, QtCore.SIGNAL(&quot;clicked()&quot;), Dialog.reject)
-        QtCore.QMetaObject.connectSlotsByName(Dialog)
-
-    def retranslateUi(self, Dialog):
-        Dialog.setWindowTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Dialog&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.label.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 1: Module Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.label_2.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 2: Scene Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.label_3.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 3: Map Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.groupBox.setTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 4: Module Dependencies&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.moduleDependenciesList.setToolTip(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Modules the new module will depend on&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.groupBox_2.setTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 5: Script Dependencies&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.scriptDependenciesList.setToolTip(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Modules the new module will depend on&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.okButton.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;&amp;OK&quot;, None, QtGui.QApplication.UnicodeUTF8))
-        self.cancelButton.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;&amp;Cancel&quot;, None, QtGui.QApplication.UnicodeUTF8))
-
-
-if __name__ == &quot;__main__&quot;:
-    import sys
-    app = QtGui.QApplication(sys.argv)
-    Dialog = QtGui.QDialog()
-    ui = Ui_Dialog()
-    ui.setupUi(Dialog)
-    Dialog.show()
-    sys.exit(app.exec_())
-
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+ 
+ 
+# Form implementation generated from reading ui file '/home/stefan/Lockenwickler/ui files/NewModuleWizard.ui'
+#
+# Created: Sun Nov  9 14:15:16 2008
+#      by: PyQt4 UI code generator 4.4.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_Dialog(object):
+    def setupUi(self, Dialog):
+        Dialog.setObjectName(&quot;Dialog&quot;)
+        Dialog.resize(675, 703)
+        self.gridLayout_3 = QtGui.QGridLayout(Dialog)
+        self.gridLayout_3.setObjectName(&quot;gridLayout_3&quot;)
+        self.label = QtGui.QLabel(Dialog)
+        self.label.setObjectName(&quot;label&quot;)
+        self.gridLayout_3.addWidget(self.label, 0, 0, 1, 1)
+        self.moduleNameLineEdit = QtGui.QLineEdit(Dialog)
+        self.moduleNameLineEdit.setObjectName(&quot;moduleNameLineEdit&quot;)
+        self.gridLayout_3.addWidget(self.moduleNameLineEdit, 0, 1, 1, 1)
+        self.label_2 = QtGui.QLabel(Dialog)
+        self.label_2.setObjectName(&quot;label_2&quot;)
+        self.gridLayout_3.addWidget(self.label_2, 1, 0, 1, 1)
+        self.sceneNameLineEdit = QtGui.QLineEdit(Dialog)
+        self.sceneNameLineEdit.setEnabled(False)
+        self.sceneNameLineEdit.setObjectName(&quot;sceneNameLineEdit&quot;)
+        self.gridLayout_3.addWidget(self.sceneNameLineEdit, 1, 1, 1, 1)
+        self.label_3 = QtGui.QLabel(Dialog)
+        self.label_3.setObjectName(&quot;label_3&quot;)
+        self.gridLayout_3.addWidget(self.label_3, 2, 0, 1, 1)
+        self.mapNameLineEdit = QtGui.QLineEdit(Dialog)
+        self.mapNameLineEdit.setEnabled(False)
+        self.mapNameLineEdit.setObjectName(&quot;mapNameLineEdit&quot;)
+        self.gridLayout_3.addWidget(self.mapNameLineEdit, 2, 1, 1, 1)
+        self.groupBox = QtGui.QGroupBox(Dialog)
+        self.groupBox.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
+        self.groupBox.setObjectName(&quot;groupBox&quot;)
+        self.gridLayout_2 = QtGui.QGridLayout(self.groupBox)
+        self.gridLayout_2.setObjectName(&quot;gridLayout_2&quot;)
+        self.moduleDependenciesList = QtGui.QListWidget(self.groupBox)
+        self.moduleDependenciesList.setEnabled(False)
+        self.moduleDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
+        self.moduleDependenciesList.setObjectName(&quot;moduleDependenciesList&quot;)
+        self.gridLayout_2.addWidget(self.moduleDependenciesList, 1, 0, 1, 1)
+        self.gridLayout_3.addWidget(self.groupBox, 3, 0, 1, 2)
+        self.groupBox_2 = QtGui.QGroupBox(Dialog)
+        self.groupBox_2.setObjectName(&quot;groupBox_2&quot;)
+        self.gridLayout = QtGui.QGridLayout(self.groupBox_2)
+        self.gridLayout.setObjectName(&quot;gridLayout&quot;)
+        self.scriptDependenciesList = QtGui.QListWidget(self.groupBox_2)
+        self.scriptDependenciesList.setEnabled(False)
+        self.scriptDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
+        self.scriptDependenciesList.setObjectName(&quot;scriptDependenciesList&quot;)
+        self.gridLayout.addWidget(self.scriptDependenciesList, 0, 0, 1, 1)
+        self.gridLayout_3.addWidget(self.groupBox_2, 4, 0, 1, 2)
+        self.hboxlayout = QtGui.QHBoxLayout()
+        self.hboxlayout.setSpacing(6)
+        self.hboxlayout.setMargin(0)
+        self.hboxlayout.setObjectName(&quot;hboxlayout&quot;)
+        spacerItem = QtGui.QSpacerItem(131, 31, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
+        self.hboxlayout.addItem(spacerItem)
+        self.okButton = QtGui.QPushButton(Dialog)
+        self.okButton.setEnabled(False)
+        self.okButton.setObjectName(&quot;okButton&quot;)
+        self.hboxlayout.addWidget(self.okButton)
+        self.cancelButton = QtGui.QPushButton(Dialog)
+        self.cancelButton.setObjectName(&quot;cancelButton&quot;)
+        self.hboxlayout.addWidget(self.cancelButton)
+        self.gridLayout_3.addLayout(self.hboxlayout, 5, 0, 1, 2)
+
+        self.retranslateUi(Dialog)
+        QtCore.QObject.connect(self.okButton, QtCore.SIGNAL(&quot;clicked()&quot;), Dialog.accept)
+        QtCore.QObject.connect(self.cancelButton, QtCore.SIGNAL(&quot;clicked()&quot;), Dialog.reject)
+        QtCore.QMetaObject.connectSlotsByName(Dialog)
+
+    def retranslateUi(self, Dialog):
+        Dialog.setWindowTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Dialog&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.label.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 1: Module Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.label_2.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 2: Scene Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.label_3.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 3: Map Name&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.groupBox.setTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 4: Module Dependencies&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.moduleDependenciesList.setToolTip(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Modules the new module will depend on&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.groupBox_2.setTitle(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Step 5: Script Dependencies&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.scriptDependenciesList.setToolTip(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;Modules the new module will depend on&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.okButton.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;&amp;OK&quot;, None, QtGui.QApplication.UnicodeUTF8))
+        self.cancelButton.setText(QtGui.QApplication.translate(&quot;Dialog&quot;, &quot;&amp;Cancel&quot;, None, QtGui.QApplication.UnicodeUTF8))
+
+
+if __name__ == &quot;__main__&quot;:
+    import sys
+    app = QtGui.QApplication(sys.argv)
+    Dialog = QtGui.QDialog()
+    ui = Ui_Dialog()
+    ui.setupUi(Dialog)
+    Dialog.show()
+    sys.exit(app.exec_())
+

Copied: rl/branches/persistence2/editors/Lockenwickler/src/ZoneManager.py (from rev 4878, rl/trunk/editors/Lockenwickler/src/ZoneManager.py)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/media/Pivot_Point.material
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/media/Pivot_Point.material	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/media/Pivot_Point.material	2009-04-01 20:08:44 UTC (rev 4879)
@@ -94,6 +94,31 @@
 	}
 }
 
+material Lockenwickler_Area_Subtract
+{
+	technique
+	{
+                pass
+		{
+                        depth_write off
+                        scene_blend alpha_blend
+                        
+			ambient 0.0 0.0 1.0 0.2
+			diffuse 0.0 0.0 1.0 0.2
+			emissive 0.0 0.0 1.0 0.2
+		}
+
+		pass
+		{
+                        polygon_mode wireframe
+
+			ambient 0.0 0.0 1.0 1.0
+			diffuse 0.0 0.0 1.0 1.0
+			emissive 0.0 0.0 1.0 1.0
+		}
+	}
+}
+
 vertex_program PlainColor_VS cg
 {
 	source PlainColor.cg
@@ -164,10 +189,34 @@
 			vertex_program_ref PlainColorGLSL_VP	
 			{
 			}
-			
+				
 			fragment_program_ref PlainColorGLSL_FP
 			{
 			}
 		}
 	}
 }
+
+fragment_program FragmentDepthMap glsl
+{
+	source depthmap.frag
+}
+
+material DepthMap
+{
+	technique
+	{
+		pass
+		{
+			vertex_program_ref PlainColorGLSL_VP	
+			{
+			}
+
+			fragment_program_ref FragmentDepthMap
+			{
+				param_named_auto fNear near_clip_distance
+				param_named_auto fFar far_clip_distance
+			}
+		}
+	}
+}

Modified: rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColorVP.glsl
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColorVP.glsl	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/media/PlainColorVP.glsl	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,5 +1,8 @@
+varying float depth;
+
 void main()
 {
+	depth = (gl_ModelViewMatrix * gl_Vertex).z;
 	gl_Position = ftransform();
 }
 

Modified: rl/branches/persistence2/editors/Lockenwickler/src/media/UniCube.mesh
===================================================================
(Binary files differ)

Copied: rl/branches/persistence2/editors/Lockenwickler/src/media/depthmap.frag (from rev 4878, rl/trunk/editors/Lockenwickler/src/media/depthmap.frag)

Copied: rl/branches/persistence2/editors/Lockenwickler/src/media/icons/14_layer_invisible.png (from rev 4878, rl/trunk/editors/Lockenwickler/src/media/icons/14_layer_invisible.png)

Copied: rl/branches/persistence2/editors/Lockenwickler/src/media/icons/14_layer_visible.png (from rev 4878, rl/trunk/editors/Lockenwickler/src/media/icons/14_layer_visible.png)

Copied: rl/branches/persistence2/editors/Lockenwickler/src/media/icons/dissociatecell.png (from rev 4878, rl/trunk/editors/Lockenwickler/src/media/icons/dissociatecell.png)

Modified: rl/branches/persistence2/editors/Lockenwickler/src/setup.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/setup.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/setup.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,4 +1,23 @@
-from distutils.core import setup
-import py2exe
-
-setup(windows=[&quot;Lockenwickler.py&quot;], options={&quot;py2exe&quot; : {&quot;includes&quot; : [&quot;sip&quot;, &quot;PyQt4._qt&quot;]}})
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
+
+from distutils.core import setup
+import py2exe
+
+setup(windows=[&quot;Lockenwickler.py&quot;], options={&quot;py2exe&quot; : {&quot;includes&quot; : [&quot;sip&quot;, &quot;PyQt4._qt&quot;]}})

Modified: rl/branches/persistence2/editors/Lockenwickler/src/ui_ConsoleWindow.py
===================================================================
--- rl/branches/persistence2/editors/Lockenwickler/src/ui_ConsoleWindow.py	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/editors/Lockenwickler/src/ui_ConsoleWindow.py	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,11 +1,21 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'console_window.ui'
+ #################################################
+# This source file is part of Rastullahs Lockenwickler.
+# Copyright (C) 2003-2009 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
 #
-# Created: Mon May 12 15:09:24 2008
-#      by: PyQt4 UI code generator 4.3.3
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
 #
-# WARNING! All changes made in this file will be lost!
+# This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
+ #################################################
 
 from PyQt4 import QtCore, QtGui
 
@@ -16,7 +26,8 @@
 
         self.gridlayout = QtGui.QGridLayout(ConsoleWindow)
         self.gridlayout.setObjectName(&quot;gridlayout&quot;)
-
+        self.gridlayout.setContentsMargins(0, 0, 0, 0)
+        
         self.textEdit = QtGui.QTextEdit(ConsoleWindow)
         self.textEdit.setObjectName(&quot;textEdit&quot;)
         self.gridlayout.addWidget(self.textEdit,0,0,1,1)

Modified: rl/branches/persistence2/engine/ai/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/ai/CMakeLists.txt	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/CMakeLists.txt	2009-04-01 20:08:44 UTC (rev 4879)
@@ -6,7 +6,8 @@
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIRS}
-${OPENSTEER_INCLUDE_DIR})
+${OPENSTEER_INCLUDE_DIR}
+${XERCESC_INCLUDE_DIR})
 
 SET(RlAi_LIB_SRCS
 src/Agent.cpp
@@ -43,7 +44,17 @@
 src/WalkPathBehaviour.cpp
 src/WayPointNode.cpp
 src/WayPointGraph.cpp
-src/WayPointGraphManager.cpp)
+src/WayPointGraphManager.cpp
+src/OpenSteer/Color.cpp
+src/OpenSteer/lq.c
+src/OpenSteer/Obstacle.cpp
+src/OpenSteer/Path.cpp
+src/OpenSteer/Pathway.cpp
+src/OpenSteer/PolylineSegmentedPath.cpp
+src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp
+src/OpenSteer/SegmentedPath.cpp
+src/OpenSteer/SegmentedPathway.cpp
+src/OpenSteer/Vec3.cpp)
 
 ADD_LIBRARY(RlAi SHARED ${RlAi_LIB_SRCS})
 

Modified: rl/branches/persistence2/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/ai/RlAI2005.vcproj	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/RlAI2005.vcproj	2009-04-01 20:08:44 UTC (rev 4879)
@@ -41,7 +41,7 @@
 				Name=&quot;VCCLCompilerTool&quot;
 				AdditionalOptions=&quot;-Zm146&quot;
 				Optimization=&quot;0&quot;
-				AdditionalIncludeDirectories=&quot;.\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt_ngt\inc;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK2\sdk\;..\..\dependencies\ois\includes;..\..\dependencies\xerces\include;..\..\dependencies\ogrenew\Dependencies\include&quot;
+				AdditionalIncludeDirectories=&quot;.\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\inc;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\xerces\include&quot;
 				PreprocessorDefinitions=&quot;WITH_FMOD3;_WINDOWS;_DEBUG;WIN32;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH&quot;
 				MinimalRebuild=&quot;true&quot;
 				BasicRuntimeChecks=&quot;3&quot;
@@ -76,7 +76,7 @@
 				AdditionalDependencies=&quot;OgreMain_d.lib OgreNewt_d.lib CEGUIBase_d.lib opensteerd.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib xerces-c_2D.lib&quot;
 				OutputFile=&quot;$(OutDir)/RlAI.dll&quot;
 				LinkIncremental=&quot;2&quot;
-				AdditionalLibraryDirectories=&quot;&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;..\..\dependencies\ogrenewt_ngt\lib\;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK2\sdk\x32\dll_vs7;..\..\dependencies\xerces\lib&quot;
+				AdditionalLibraryDirectories=&quot;&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;..\..\dependencies\ogrenewt\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7;..\..\dependencies\xerces\lib&quot;
 				GenerateDebugInformation=&quot;true&quot;
 				AssemblyDebug=&quot;1&quot;
 				ProgramDatabaseFile=&quot;$(OutDir)/RlAI.pdb&quot;
@@ -141,7 +141,7 @@
 				Optimization=&quot;3&quot;
 				EnableIntrinsicFunctions=&quot;true&quot;
 				FavorSizeOrSpeed=&quot;1&quot;
-				AdditionalIncludeDirectories=&quot;.\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt_ngt\inc;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\xerces\include&quot;
+				AdditionalIncludeDirectories=&quot;.\include;.\include\predicates;..\common\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\inc;..\..\dependencies\cegui_mk2\include;..\..\dependencies\opensteer\include;..\..\dependencies\boost\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\xerces\include&quot;
 				PreprocessorDefinitions=&quot;WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLAI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH&quot;
 				RuntimeLibrary=&quot;2&quot;
 				UsePrecompiledHeader=&quot;2&quot;
@@ -164,7 +164,7 @@
 				AdditionalDependencies=&quot;OgreMain.lib OgreNewt.lib CEGUIBase.lib opensteer.lib RlCommon.lib RlCore.lib RlRules.lib Newton.lib xerces-c_2.lib&quot;
 				OutputFile=&quot;$(OutDir)/RlAI.dll&quot;
 				LinkIncremental=&quot;1&quot;
-				AdditionalLibraryDirectories=&quot;&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\xerces\lib&quot;
+				AdditionalLibraryDirectories=&quot;&quot;..\common\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib\;..\..\dependencies\ogrenewt\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\opensteer\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7;..\..\dependencies\xerces\lib&quot;
 				GenerateDebugInformation=&quot;false&quot;
 				SubSystem=&quot;2&quot;
 				OptimizeReferences=&quot;2&quot;

Copied: rl/branches/persistence2/engine/ai/RlAI2008.vcproj (from rev 4878, rl/trunk/engine/ai/RlAI2008.vcproj)

Modified: rl/branches/persistence2/engine/ai/include/AgentCombatState.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/AgentCombatState.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/AgentCombatState.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -54,3 +54,4 @@
 	};
 }
 #endif
+

Modified: rl/branches/persistence2/engine/ai/include/AgentDialogState.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/AgentDialogState.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/AgentDialogState.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,45 +1,47 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __RlAI_AgentDialogState_H__
-#define __RlAI_AgentDialogState_H__
-
-#include &quot;AgentState.h&quot;
-
-namespace rl
-{
-    class Dialog;
-
-    class _RlAiExport AgentDialogState :
-        public AgentState
-    {
-    public:
-        AgentDialogState(Agent* agent);
-        ~AgentDialogState();
-
-        virtual void update(const Ogre::Real elapsedTime);
-        void setDialogPartner(Agent* partner);
-        void setDialog(Dialog* dialog);
-
-    private:
-        Agent* mPartner;
-        Dialog* mDialog;
-        bool mTalking;
-    };
-
-}
-
-#endif // __RlAI_AgentDialogState_H__
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __RlAI_AgentDialogState_H__
+#define __RlAI_AgentDialogState_H__
+
+#include &quot;AgentState.h&quot;
+
+#include &lt;list&gt;
+
+namespace rl
+{
+    class Dialog;
+
+    class _RlAiExport AgentDialogState :
+        public AgentState
+    {
+    public:
+        AgentDialogState(Agent* agent);
+        ~AgentDialogState();
+
+        virtual void update(const Ogre::Real elapsedTime);
+        void addDialogPartner(Agent* partner);
+        void setDialog(Dialog* dialog);
+
+    private:
+        std::list&lt;Agent*&gt; mPartners;
+        Dialog* mDialog;
+        bool mTalking;
+    };
+
+}
+
+#endif // __RlAI_AgentDialogState_H__

Modified: rl/branches/persistence2/engine/ai/include/DialogElement.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/DialogElement.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/DialogElement.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -32,8 +32,8 @@
         const CeGuiString&amp; getId() const;
         void addParagraph(DialogParagraph* paragraph);
         virtual std::list&lt;DialogParagraph*&gt; getParagraphs(Dialog* dialog);
-		virtual bool isSelection() const;
-		const CeGuiString&amp; getPerson() const;
+        virtual bool isSelection() const;
+        const CeGuiString&amp; getPerson() const;
 
     protected:
         DialogElement(const CeGuiString&amp; id, const CeGuiString&amp; person = &quot;&quot;);
@@ -51,8 +51,8 @@
     class DialogSelection : public DialogElementType
     {
     public:
-        DialogSelection(const CeGuiString&amp; id)
-            : DialogElementType(id, false), mVariable(NULL)
+        DialogSelection(const CeGuiString&amp; id, const CeGuiString&amp; person)
+            : DialogElementType(id, person), mVariable(NULL)
         {
         }
 
@@ -97,11 +97,11 @@
 
         DialogElementType* getSelectedElement(Dialog* dialog) const
         {
-			// Recalculate switch variable on start, keep for whole switch evaluation
-			if (mVariable)
-			{
-				mVariable-&gt;invalidate();
-			}
+            // Recalculate switch variable on start, keep for whole switch evaluation
+            if (mVariable)
+            {
+                    mVariable-&gt;invalidate();
+            }
 
             for (typename CondElemMap::const_iterator it = mElements.begin(); it != mElements.end(); ++it)
             {
@@ -116,10 +116,10 @@
             return NULL;
         }
 
-		virtual bool isSelection() const
-		{
-			return true;
-		}
+        virtual bool isSelection() const
+        {
+            return true;
+        }
 
     private:
         typedef std::vector&lt;std::pair&lt;DialogCondition*, DialogElementType*&gt; &gt; CondElemMap;

Modified: rl/branches/persistence2/engine/ai/include/DialogLoaderImpl.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/DialogLoaderImpl.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/DialogLoaderImpl.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,12 +1,18 @@
-/*
- *  DialogLoaderImpl.h
- *  Rastullah
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
  *
- *  Created by Sascha Kolewa on 04.12.08.
- *  Copyright 2008 __MyCompanyName__. All rights reserved.
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
  *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
  */
-
 #include &quot;AiPrerequisites.h&quot;
 
 #include &lt;list&gt;
@@ -41,16 +47,16 @@
         {
         public:
             DialogParticipant(const CeGuiString&amp; personId,
-                    int goId, const CeGuiString&amp; goClass, const CeGuiString&amp; name);
+                    const CeGuiString &amp;goId, const CeGuiString&amp; goClass, const CeGuiString&amp; name);
 
             bool isMatching(Creature* go) const;
             const CeGuiString&amp; getPersonId() const;
 
         private:
-            const CeGuiString&amp; mPersonId;
-            int mGoId;
-            const CeGuiString&amp; mGoClass;
-            const CeGuiString&amp; mName;
+            const CeGuiString mPersonId;
+            CeGuiString mGoId;
+            const CeGuiString mGoClass;
+            const CeGuiString mName;
         };
 
         class DialogPrototype

Modified: rl/branches/persistence2/engine/ai/include/DialogOption.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/DialogOption.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/DialogOption.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -33,7 +33,7 @@
     class _RlAiExport DialogOption : public DialogElement
     {
     public:
-        DialogOption(const CeGuiString&amp; id, bool isAutoSelected);
+        DialogOption(const CeGuiString&amp; id, const CeGuiString&amp; person, bool autoSelected = false);
         ~DialogOption();
 
         const CeGuiString&amp; getLabel() const;
@@ -46,6 +46,7 @@
         virtual const CeGuiString&amp; getConditionVariableType();
         virtual bool isConditional();
 
+        void setAutoSelected(bool autoSelected);
         bool isAutoSelected() const;
         bool isAvailable(Dialog* dialog) const;
 
@@ -56,7 +57,7 @@
         DialogResponse* mResponse;
         DialogCondition* mPrecondition;
         CeGuiString mLabel;
-        bool mIsAutoSelected;
+        bool mAutoSelected;
     };
 
     typedef DialogSelection&lt;DialogOption&gt; DialogOptionSelection;

Modified: rl/branches/persistence2/engine/ai/include/DialogResponse.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/DialogResponse.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/DialogResponse.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -36,7 +36,7 @@
         typedef std::vector&lt;DialogOption*&gt; Options;
         typedef std::vector&lt;DialogImplication*&gt; Implications;
 
-        DialogResponse(const CeGuiString&amp; id, int npcId = 0);
+        DialogResponse(const CeGuiString&amp; id, const CeGuiString&amp; person);
         virtual ~DialogResponse();
 
         void addOption(DialogOption* option);
@@ -52,13 +52,12 @@
     private:
         Options mOptions;
         Implications mEffects;
-        int mNpcId;
     };
 
     class DialogResponseSelection : public DialogSelection&lt;DialogResponse&gt;
     {
     public:
-        DialogResponseSelection(const CeGuiString&amp; id);
+        DialogResponseSelection(const CeGuiString&amp; id, const CeGuiString&amp; person);
         virtual const Options&amp; getOptions(Dialog* dialog) const;
     };
 

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer (from rev 4878, rl/trunk/engine/ai/include/OpenSteer)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/AbstractVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/AbstractVehicle.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/AbstractVehicle.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,107 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the &quot;Software&quot;),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// AbstractVehicle: pure virtual base class for generic steerable vehicles
-//
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 01-30-03 cwr: created 
-//
-//
-// ----------------------------------------------------------------------------
-
-#ifndef OPENSTEER_ABSTRACTVEHICLE_H
-#define OPENSTEER_ABSTRACTVEHICLE_H
-
-
-#include &quot;OpenSteer/LocalSpace.h&quot;
-
-
-// STL vector containers
-#include &lt;vector&gt;
-
-
-// ----------------------------------------------------------------------------
-
-namespace OpenSteer {
-
-    class AbstractVehicle : public AbstractLocalSpace 
-    {
-    public:
-        virtual ~AbstractVehicle() { /* Nothing to do. */ }
-        
-        // mass (defaults to unity so acceleration=force)
-        virtual float getMass (void) const = 0;
-        virtual float setMass (float) = 0;
-
-        // size of bounding sphere, for obstacle avoidance, etc.
-        virtual float getRadius (void) const = 0;
-        virtual float setRadius (float) = 0;
-
-        // velocity of vehicle
-        virtual Vector3 getVelocity (void) const = 0;
-
-        // speed of vehicle  (may be faster than taking magnitude of velocity)
-        virtual float getSpeed (void) const = 0;
-        virtual float setSpeed (float) = 0;
-
-        // groups of (pointers to) abstract vehicles, and iterators over them
-        typedef std::vector&lt;AbstractVehicle*&gt; group;
-        typedef group::const_iterator iterator;    
-
-        // predict position of this vehicle at some time in the future
-        // (assumes velocity remains constant)
-        virtual Vector3 predictFuturePosition (const float predictionTime) const = 0;
-
-        // ----------------------------------------------------------------------
-        // XXX this vehicle-model-specific functionality functionality seems out
-        // XXX of place on the abstract base class, but for now it is expedient
-
-        // the maximum steering force this vehicle can apply
-        virtual float getMaxForce (void) const = 0;
-        virtual float setMaxForce (float) = 0;
-
-        // the maximum speed this vehicle is allowed to move
-        virtual float getMaxSpeed (void) const = 0;
-        virtual float setMaxSpeed (float) = 0;
-
-		// dp - added to support heterogeneous flocks
-		virtual void update(const float currentTime, const float elapsedTime) = 0;
-    };
-
-
-    // more convenient short names for AbstractVehicle group and iterator
-    typedef AbstractVehicle::group AVGroup;
-    typedef AbstractVehicle::iterator AVIterator;
-
-} // namespace OpenSteer
-
-
-// ----------------------------------------------------------------------------
-#endif // OPENSTEER_ABSTRACTVEHICLE_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/AbstractVehicle.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/AbstractVehicle.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/Color.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Color.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/Color.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,153 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the &quot;Software&quot;),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// Color class and predefined colors.
-//
-// May 05, 2005 bk:  created 
-//
-//
-// ----------------------------------------------------------------------------
-
-
-#ifndef OPENSTEER_COLOR_H
-#define OPENSTEER_COLOR_H
-
-#include &quot;OpenSteer/Vec3.h&quot;
-
-
-namespace OpenSteer {
-    
-    class Color {
-    public:
-        Color();
-        explicit Color( float greyValue );
-        Color( float rValue, float gValue, float bValue, float aValue = 1.0f );
-        explicit Color( Vector3 const&amp; vector );
-        
-        float r() const;
-        float g() const;
-        float b() const;
-        float a() const;
-        
-        void setR( float value );
-        void setG( float value );
-        void setB( float value );
-		void setA( float value );
-        void set( float rValue, float gValue, float bValue, float aValue = 1.0f );
-        
-        Vector3 convertToVec3() const;
-    
-		// this is necessary so that graphics API's such as DirectX
-		// requiring a pointer to colors can do their conversion
-		// without a lot of copying.
-		float const*const colorFloatArray() const { return &amp;r_; }
-
-        Color&amp; operator+=( Color const&amp; other );
-        
-        /**
-         * @todo What happens if color components become negative?
-         */
-        Color&amp; operator-=( Color const&amp; other );
-        
-        /**
-         * @todo What happens if color components become negative?
-         */
-        Color&amp; operator*=( float factor );
-        
-        /**
-         * @todo What happens if color components become negative?
-         */
-        Color&amp; operator/=( float factor );
-        
-        
-    private:
-        float r_;
-        float g_;
-        float b_;
-		 float a_;	// provided for API's which require four components        
-    }; // class Color
-    
-    
-    Color operator+( Color const&amp; lhs, Color const&amp; rhs );
-    
-    /**
-     * @todo What happens if color components become negative?
-     */
-    Color operator-( Color const&amp; lhs, Color const&amp; rhs );
-    
-    /**
-     * @todo What happens if color components become negative?
-     */
-    Color operator*( Color const&amp; lhs, float rhs );
-    
-    /**
-     * @todo What happens if color components become negative?
-     */
-    Color operator*( float lhs, Color const&amp; rhs );
-    
-    /**
-     * @todo What happens if color components become negative?
-     */
-    Color operator/( Color const&amp; lhs, float rhs );
-    
-    
-    Color grayColor( float value );
-    
-    extern Color const gBlack;
-    extern Color const gWhite; 
-    extern Color const gRed; 
-    extern Color const gGreen;
-    extern Color const gBlue;
-    extern Color const gYellow;
-    extern Color const gCyan;
-    extern Color const gMagenta;
-    extern Color const gOrange;
-    extern Color const gDarkRed;
-    extern Color const gDarkGreen;
-    extern Color const gDarkBlue;
-    extern Color const gDarkYellow;
-    extern Color const gDarkCyan;
-    extern Color const gDarkMagenta;
-    extern Color const gDarkOrange;
-    
-    extern Color const gGray10;
-    extern Color const gGray20;
-    extern Color const gGray30;
-    extern Color const gGray40;
-    extern Color const gGray50;
-    extern Color const gGray60;
-    extern Color const gGray70;
-    extern Color const gGray80;
-    extern Color const gGray90;
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_COLOR_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/Color.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/Color.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/LocalSpace.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/LocalSpace.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/LocalSpace.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,360 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the &quot;Software&quot;),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// LocalSpace: a local coordinate system for 3d space
-//
-// Provide functionality such as transforming from local space to global
-// space and vice versa.  Also regenerates a valid space from a perturbed
-// &quot;forward vector&quot; which is the basis of abnstract vehicle turning.
-//
-// These are comparable to a 4x4 homogeneous transformation matrix where the
-// 3x3 (R) portion is constrained to be a pure rotation (no shear or scale).
-// The rows of the 3x3 R matrix are the basis vectors of the space.  They are
-// all constrained to be mutually perpendicular and of unit length.  The top
-// (&quot;x&quot;) row is called &quot;side&quot;, the middle (&quot;y&quot;) row is called &quot;up&quot; and the
-// bottom (&quot;z&quot;) row is called forward.  The translation vector is called
-// &quot;position&quot;.  Finally the &quot;homogeneous column&quot; is always [0 0 0 1].
-//
-//     [ R R R  0 ]      [ Sx Sy Sz  0 ]
-//     [ R R R  0 ]      [ Ux Uy Uz  0 ]
-//     [ R R R  0 ]  -&gt;  [ Fx Fy Fz  0 ]
-//     [          ]      [             ]
-//     [ T T T  1 ]      [ Tx Ty Tz  1 ]
-//
-// This file defines three classes:
-//   AbstractLocalSpace:  pure virtual interface
-//   LocalSpaceMixin:     mixin to layer LocalSpace functionality on any base
-//   LocalSpace:          a concrete object (can be instantiated)
-//
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 06-05-02 cwr: created 
-//
-//
-// ----------------------------------------------------------------------------
-
-
-#ifndef OPENSTEER_LOCALSPACE_H
-#define OPENSTEER_LOCALSPACE_H
-
-
-#include &quot;OpenSteer/Vec3.h&quot;
-
-
-// ----------------------------------------------------------------------------
-
-
-namespace OpenSteer {
-
-
-    class AbstractLocalSpace
-    {
-    public:
-        virtual ~AbstractLocalSpace() { /* Nothing to do. */ }
-        
-
-        // accessors (get and set) for side, up, forward and position
-        virtual Vector3 getSide (void) const = 0;
-        virtual Vector3 setSide (Vector3 s) = 0;
-        virtual Vector3 getUp (void) const = 0;
-        virtual Vector3 setUp (Vector3 u) = 0;
-        virtual Vector3 getForward (void) const = 0;
-        virtual Vector3 setForward (Vector3 f) = 0;
-        virtual Vector3 getPosition (void) const = 0;
-        virtual Vector3 setPosition (Vector3 p) = 0;
-
-        // use right-(or left-)handed coordinate space
-        virtual bool isRightHanded(void) const = 0;
-
-        // reset transform to identity
-        virtual void resetLocalSpace (void) = 0;
-
-        // transform a direction in global space to its equivalent in local space
-        virtual Vector3 localizeDirection (const Vector3&amp; globalDirection) const = 0;
-
-        // transform a point in global space to its equivalent in local space
-        virtual Vector3 localizePosition (const Vector3&amp; globalPosition) const = 0;
-
-        // transform a point in local space to its equivalent in global space
-        virtual Vector3 globalizePosition (const Vector3&amp; localPosition) const = 0;
-
-        // transform a direction in local space to its equivalent in global space
-        virtual Vector3 globalizeDirection (const Vector3&amp; localDirection) const = 0;
-
-        // set &quot;side&quot; basis vector to normalized cross product of forward and up
-        virtual void setUnitSideFromForwardAndUp (void) = 0;
-
-        // regenerate the orthonormal basis vectors given a new forward
-        // (which is expected to have unit length)
-        virtual void regenerateOrthonormalBasisUF (const Vector3&amp; newUnitForward) = 0;
-
-        // for when the new forward is NOT of unit length
-        virtual void regenerateOrthonormalBasis (const Vector3&amp; newForward) = 0;
-
-        // for supplying both a new forward and and new up
-        virtual void regenerateOrthonormalBasis (const Vector3&amp; newForward,
-                                                 const Vector3&amp; newUp) = 0;
-
-        // rotate 90 degrees in the direction implied by isRightHanded()
-        virtual Vector3 localRotateForwardToSide (const Vector3&amp; v) const = 0;
-        virtual Vector3 globalRotateForwardToSide (const Vector3&amp; globalForward) const=0;
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // LocalSpaceMixin is a mixin layer, a class template with a paramterized base
-    // class.  Allows &quot;LocalSpace-ness&quot; to be layered on any class.
-
-
-    template &lt;class Super&gt;
-    class LocalSpaceMixin : public Super
-    {
-        // transformation as three orthonormal unit basis vectors and the
-        // origin of the local space.  These correspond to the &quot;rows&quot; of
-        // a 3x4 transformation matrix with [0 0 0 1] as the final column
-
-    private:
-
-        Vector3 _side;     //    side-pointing unit basis vector
-        Vector3 _up;       //  upward-pointing unit basis vector
-        Vector3 _forward;  // forward-pointing unit basis vector
-        Vector3 _position; // origin of local space
-
-    public:
-
-        // accessors (get and set) for side, up, forward and position
-        Vector3 getSide     (void) const {return _side;}
-        Vector3 getUp       (void) const {return _up;}
-        Vector3 getForward  (void) const {return _forward;}
-        Vector3 getPosition (void) const {return _position;}
-        Vector3 setSide     (Vector3 s) {return _side = s;}
-        Vector3 setUp       (Vector3 u) {return _up = u;}
-        Vector3 setForward  (Vector3 f) {return _forward = f;}
-        Vector3 setPosition (Vector3 p) {return _position = p;}
-        Vector3 setSide     (float x, float y, float z){return _side = Vector3(x,y,z);}
-        Vector3 setUp       (float x, float y, float z){return _up = Vector3(x,y,z);}
-        Vector3 setForward  (float x, float y, float z){return _forward = Vector3(x,y,z);}
-        Vector3 setPosition (float x, float y, float z){return _position = Vector3(x,y,z);}
-
-
-        // ------------------------------------------------------------------------
-        // Global compile-time switch to control handedness/chirality: should
-        // LocalSpace use a left- or right-handed coordinate system?  This can be
-        // overloaded in derived types (e.g. vehicles) to change handedness.
-
-        bool isRightHanded(void) const {return true;}
-
-
-        // ------------------------------------------------------------------------
-        // constructors
-
-
-        LocalSpaceMixin (void)
-        {
-            resetLocalSpace ();
-        };
-
-        LocalSpaceMixin (const Vector3&amp; Side,
-                         const Vector3&amp; Up,
-                         const Vector3&amp; Forward,
-                         const Vector3&amp; Position)
-            : _side( Side ), _up( Up ), _forward( Forward ), _position( Position ) {}
-
-
-        LocalSpaceMixin (const Vector3&amp; Up,
-                         const Vector3&amp; Forward,
-                         const Vector3&amp; Position)
-            : _side(), _up( Up ), _forward( Forward ), _position( Position )
-        {
-            setUnitSideFromForwardAndUp();
-        }
-
-        
-        virtual ~LocalSpaceMixin() { /* Nothing to do. */ }
-        
-
-        // ------------------------------------------------------------------------
-        // reset transform: set local space to its identity state, equivalent to a
-        // 4x4 homogeneous transform like this:
-        //
-        //     [ X 0 0 0 ]
-        //     [ 0 1 0 0 ]
-        //     [ 0 0 1 0 ]
-        //     [ 0 0 0 1 ]
-        //
-        // where X is 1 for a left-handed system and -1 for a right-handed system.
-
-        void resetLocalSpace (void)
-        {
-            _forward = Vector3(0, 0, 1);
-            _side = localRotateForwardToSide (_forward);
-            _up = Vector3(0, 1, 0);
-            _position = Vector3(0, 0, 0);
-        };
-
-
-        // ------------------------------------------------------------------------
-        // transform a direction in global space to its equivalent in local space
-
-
-        Vector3 localizeDirection (const Vector3&amp; globalDirection) const
-        {
-            // dot offset with local basis vectors to obtain local coordiantes
-            return Vector3 (globalDirection.dotProduct(_side),
-                         globalDirection.dotProduct(_up),
-                         globalDirection.dotProduct(_forward));
-        };
-
-
-        // ------------------------------------------------------------------------
-        // transform a point in global space to its equivalent in local space
-
-
-        Vector3 localizePosition (const Vector3&amp; globalPosition) const
-        {
-            // global offset from local origin
-            Vector3 globalOffset = globalPosition - _position;
-
-            // dot offset with local basis vectors to obtain local coordiantes
-            return localizeDirection (globalOffset);
-        };
-
-
-        // ------------------------------------------------------------------------
-        // transform a point in local space to its equivalent in global space
-
-
-        Vector3 globalizePosition (const Vector3&amp; localPosition) const
-        {
-            return _position + globalizeDirection (localPosition);
-        };
-
-
-        // ------------------------------------------------------------------------
-        // transform a direction in local space to its equivalent in global space
-
-
-        Vector3 globalizeDirection (const Vector3&amp; localDirection) const
-        {
-            return ((_side    * localDirection.x) +
-                    (_up      * localDirection.y) +
-                    (_forward * localDirection.z));
-        };
-
-
-        // ------------------------------------------------------------------------
-        // set &quot;side&quot; basis vector to normalized cross product of forward and up
-
-
-        void setUnitSideFromForwardAndUp (void)
-        {
-            // derive new unit side basis vector from forward and up
-            if (isRightHanded())
-                _side = _forward.crossProduct(_up);
-            else
-                _side = _up.crossProduct(_forward);
-            _side = _side.normalisedCopy();
-        }
-
-
-        // ------------------------------------------------------------------------
-        // regenerate the orthonormal basis vectors given a new forward
-        // (which is expected to have unit length)
-
-
-        void regenerateOrthonormalBasisUF (const Vector3&amp; newUnitForward)
-        {
-            _forward = newUnitForward;
-
-            // derive new side basis vector from NEW forward and OLD up
-            setUnitSideFromForwardAndUp();
-
-            // derive new Up basis vector from new Side and new Forward
-            // (should have unit length since Side and Forward are
-            // perpendicular and unit length)
-            if (isRightHanded())
-                _up = _side.crossProduct(_forward);
-            else
-                _up = _forward.crossProduct(_side);
-        }
-
-
-        // for when the new forward is NOT know to have unit length
-
-        void regenerateOrthonormalBasis (const Vector3&amp; newForward)
-        {
-            regenerateOrthonormalBasisUF (newForward.normalisedCopy());
-        }
-
-
-        // for supplying both a new forward and and new up
-
-        void regenerateOrthonormalBasis (const Vector3&amp; newForward,
-                                         const Vector3&amp; newUp)
-        {
-            _up = newUp;
-            regenerateOrthonormalBasis (newForward.normalisedCopy());
-        }
-
-
-        // ------------------------------------------------------------------------
-        // rotate, in the canonical direction, a vector pointing in the
-        // &quot;forward&quot; (+Z) direction to the &quot;side&quot; (+/-X) direction
-
-
-        Vector3 localRotateForwardToSide (const Vector3&amp; v) const
-        {
-            return Vector3 (isRightHanded() ? -v.z : +v.z,
-                         v.y,
-                         v.x);
-        }
-
-        // not currently used, just added for completeness
-
-        Vector3 globalRotateForwardToSide (const Vector3&amp; globalForward) const
-        {
-            const Vector3 localForward = localizeDirection (globalForward);
-            const Vector3 localSide = localRotateForwardToSide (localForward);
-            return globalizeDirection (localSide);
-        }
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // Concrete LocalSpace class, and a global constant for the identity transform
-
-
-    typedef LocalSpaceMixin&lt;AbstractLocalSpace&gt; LocalSpace;
-
-    const LocalSpace gGlobalSpace;
-
-} // namespace OpenSteer
-
-// ----------------------------------------------------------------------------
-#endif // OPENSTEER_LOCALSPACE_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/LocalSpace.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/LocalSpace.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/Obstacle.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Obstacle.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/Obstacle.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,306 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the &quot;Software&quot;),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// Obstacles for use with obstacle avoidance
-//
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 09-05-02 cwr: created
-//
-//
-// ----------------------------------------------------------------------------
-
-
-#ifndef OPENSTEER_OBSTACLE_H
-#define OPENSTEER_OBSTACLE_H
-
-
-#include &quot;OpenSteer/Vec3.h&quot;
-#include &quot;OpenSteer/LocalSpace.h&quot;
-#include &quot;OpenSteer/AbstractVehicle.h&quot;
-
-
-namespace OpenSteer {
-
-    
-    // Forward declaration.
-    class Color;
-    
-
-    // ----------------------------------------------------------------------------
-    // AbstractObstacle: a pure virtual base class for an abstract shape in
-    // space, to be used with obstacle avoidance.  (Oops, its not &quot;pure&quot; since
-    // I added a concrete method to PathIntersection 11-04-04 -cwr).
-
-
-    class AbstractObstacle
-    {
-    public:
-
-        virtual ~AbstractObstacle() { /* Nothing to do. */ }
-        
-        
-        // compute steering for a vehicle to avoid this obstacle, if needed
-        virtual Vector3 steerToAvoid (const AbstractVehicle&amp; v,
-                                   const float minTimeToCollision) const = 0;
-
-        // PathIntersection object: used internally to analyze and store
-        // information about intersections of vehicle paths and obstacles.
-        class PathIntersection
-        {
-        public:
-            bool intersect; // was an intersection found?
-            float distance; // how far was intersection point from vehicle?
-            Vector3 surfacePoint; // position of intersection
-            Vector3 surfaceNormal; // unit normal at point of intersection
-            Vector3 steerHint; // where to steer away from intersection
-            bool vehicleOutside; // is the vehicle outside the obstacle?
-            const AbstractObstacle* obstacle; // obstacle the path intersects
-
-            // determine steering based on path intersection tests
-            Vector3 steerToAvoidIfNeeded (const AbstractVehicle&amp; vehicle,
-                                       const float minTimeToCollision) const;
-
-        };
-
-        // find first intersection of a vehicle's path with this obstacle
-        // (this must be specialized for each new obstacle shape class)
-        virtual void
-        findIntersectionWithVehiclePath (const AbstractVehicle&amp; vehicle,
-                                         PathIntersection&amp; pi)
-            const
-            = 0 ;
-
-        // virtual function for drawing -- normally does nothing, can be
-        // specialized by derived types to provide graphics for obstacles
-        virtual void draw (const bool filled,
-                           const Color&amp; color,
-                           const Vector3&amp; viewpoint)
-            const
-            = 0 ;
-
-        // seenFrom (eversion): does this obstacle contrain vehicle to stay
-        // inside it or outside it (or both)?  &quot;Inside&quot; describes a clear space
-        // within a solid (for example, the interior of a room inside its
-        // walls). &quot;Ouitside&quot; describes a solid chunk in the midst of clear
-        // space.
-        enum seenFromState {outside, inside, both};
-        virtual seenFromState seenFrom (void) const = 0;
-        virtual void setSeenFrom (seenFromState s) = 0;
-    };
-
-
-    // an STL vector of AbstractObstacle pointers and an iterator for it:
-    typedef std::vector&lt;AbstractObstacle*&gt; ObstacleGroup;
-    typedef ObstacleGroup::const_iterator ObstacleIterator;
-
-
-    // ----------------------------------------------------------------------------
-    // Obstacle is a utility base class providing some shared functionality
-
-
-    class Obstacle : public AbstractObstacle
-    {
-    public:
-
-        Obstacle (void) : _seenFrom (outside) {}
-
-        virtual ~Obstacle() { /* Nothing to do. */ }
-        
-        // compute steering for a vehicle to avoid this obstacle, if needed 
-        Vector3 steerToAvoid (const AbstractVehicle&amp; v,
-                           const float minTimeToCollision)
-            const;
-
-        // static method to apply steerToAvoid to nearest obstacle in an
-        // ObstacleGroup
-        static Vector3 steerToAvoidObstacles (const AbstractVehicle&amp; vehicle,
-                                           const float minTimeToCollision,
-                                           const ObstacleGroup&amp; obstacles);
-
-        // static method to find first vehicle path intersection in an
-        // ObstacleGroup
-        static void
-        firstPathIntersectionWithObstacleGroup (const AbstractVehicle&amp; vehicle,
-                                                const ObstacleGroup&amp; obstacles,
-                                                PathIntersection&amp; nearest,
-                                                PathIntersection&amp; next);
-
-        // default do-nothing draw function (derived class can overload this)
-        void draw (const bool, const Color&amp;, const Vector3&amp;) const {}
-
-        seenFromState seenFrom (void) const {return _seenFrom;}
-        void setSeenFrom (seenFromState s) {_seenFrom = s;}
-    private:
-        seenFromState _seenFrom;
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // SphereObstacle a simple ball-shaped obstacle
-
-
-    class SphereObstacle : public Obstacle
-    {
-    public:
-        float radius;
-        Vector3 center;
-
-        // constructors
-        SphereObstacle (float r, Vector3 c) : radius(r), center (c) {}
-        SphereObstacle (void) : radius(1), center (Vector3::ZERO) {}
-
-        virtual ~SphereObstacle() { /* Nothing to do. */ }
-        
-        // find first intersection of a vehicle's path with this obstacle
-        void findIntersectionWithVehiclePath (const AbstractVehicle&amp; vehicle,
-                                              PathIntersection&amp; pi)
-            const;
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // LocalSpaceObstacle: a mixture of LocalSpace and Obstacle methods
-
-
-     typedef LocalSpaceMixin&lt;Obstacle&gt; LocalSpaceObstacle;
-
-
-    // ----------------------------------------------------------------------------
-    // BoxObstacle: a box-shaped (cuboid) obstacle of a given height, width,
-    // depth, position and orientation.  The box is centered on and aligned
-    // with a local space.
-
-
-    class BoxObstacle : public LocalSpaceObstacle
-    {
-    public:
-        float width;  // width  of box centered on local X (side)    axis
-        float height; // height of box centered on local Y (up)      axis
-        float depth;  // depth  of box centered on local Z (forward) axis
-
-        // constructors
-        BoxObstacle (float w, float h, float d) : width(w), height(h), depth(d) {}
-        BoxObstacle (void) :  width(1.0f), height(1.0f), depth(1.0f) {}
-
-        virtual ~BoxObstacle() { /* Nothing to do. */ }
-        
-        
-        // find first intersection of a vehicle's path with this obstacle
-        void findIntersectionWithVehiclePath (const AbstractVehicle&amp; vehicle,
-                                              PathIntersection&amp; pi)
-            const;
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // PlaneObstacle: a planar obstacle of a given position and orientation.
-    // The plane is defined as the XY (aka side/up) plane of a local space.
-    // The +Z (forward) half-space is considered &quot;outside&quot; the obstacle.  
-    //
-    // This is also the base class for several other obstacles which represent
-    // 2d shapes (rectangle, triangle, ...) arbitarily oriented and positioned
-    // in 2d space.  They specialize this class via xyPointInsideShape which
-    // tests if a given point on the XZ plane is inside the obstacle's shape.
-
-
-    class PlaneObstacle : public LocalSpaceObstacle
-    {
-    public:
-        // constructors
-        PlaneObstacle (void) {}
-        PlaneObstacle (const Vector3&amp; s,
-                       const Vector3&amp; u,
-                       const Vector3&amp; f,
-                       const Vector3&amp; p)
-        : LocalSpaceObstacle( s, u, f, p )
-        {
-            /*
-            setSide (s);
-            setUp (u);
-            setForward (f);
-            setPosition (p);
-             */
-        }
-
-        // find first intersection of a vehicle's path with this obstacle
-        void findIntersectionWithVehiclePath (const AbstractVehicle&amp; vehicle,
-                                              PathIntersection&amp; pi)
-            const;
-
-        // determines if a given point on XY plane is inside obstacle shape
-        virtual bool xyPointInsideShape (const Vector3&amp; /*point*/,
-                                         float /*radius*/) const
-        {
-            return true; // always true for PlaneObstacle
-        }
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // RectangleObstacle: a rectangular obstacle of a given height, width,
-    // position and orientation.  It is a rectangle centered on the XY (aka
-    // side/up) plane of a local space.
-
-
-    class RectangleObstacle : public PlaneObstacle
-    {
-    public:
-        float width;  // width  of rectangle centered on local X (side) axis
-        float height; // height of rectangle centered on local Y (up)   axis
-
-        // constructors
-        RectangleObstacle (float w, float h) : width(w), height(h) {}
-        RectangleObstacle (void) :  width(1.0f), height(1.0f) {}
-        RectangleObstacle (float w, float h, const Vector3&amp; s,
-                           const Vector3&amp; u, const Vector3&amp; f, const Vector3&amp; p,
-                           seenFromState sf) 
-            : PlaneObstacle( s, u, f, p ), width(w), height(h)
-        {
-            /*
-            setSide (s);
-            setUp (u);
-            setForward (f);
-            setPosition (p);
-             */
-            setSeenFrom (sf);
-        }
-        
-        virtual ~RectangleObstacle() { /* Nothing to do. */ }
-
-        // determines if a given point on XY plane is inside obstacle shape
-        bool xyPointInsideShape (const Vector3&amp; point, float radius) const;
-    };
-
-
-} // namespace OpenSteer
-    
-    
-// ----------------------------------------------------------------------------
-#endif // OPENSTEER_OBSTACLE_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/Obstacle.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/Obstacle.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/Path.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Path.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/Path.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,106 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original authors: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * Abstract interface for paths.
- */
-#ifndef OPENSTEER_PATH_H
-#define OPENSTEER_PATH_H
-
-
-#include &quot;OpenSteer/Vec3.h&quot;
-
-
-namespace OpenSteer {
-
-    
-    /**
-     * Path in space that might be cyclic.
-     *
-     * Paths are infinitesimal thin.
-     */
-    class Path {
-    public:
-        
-        
-        virtual ~Path() = 0;
-        
-        
-        /**
-         * Returns @c true if the path is valid, @c false otherwise.
-         */
-        virtual bool isValid() const = 0;
-        
-        /**
-         * Given an arbitrary point (&quot;A&quot;), returns the nearest point (&quot;P&quot;) on
-		 * this path center line.  Also returns, via output arguments, the path
-         * tangent at P and a measure of how far A is outside the Pathway's 
-         * &quot;tube&quot;.  Note that a negative distance indicates A is inside the 
-         * Pathway.
-         *
-         * If @c isValid is @c false the behavior is undefined.
-         */
-		virtual Vector3 mapPointToPath (const Vector3&amp; point,
-                                     Vector3&amp; tangent,
-                                     float&amp; outside) const = 0;
-        
-		/**
-         * Given a distance along the path, convert it to a point on the path.
-         * If @c isValid is @c false the behavior is undefined.
-         */
-		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const = 0;
-        
-		/**
-         * Given an arbitrary point, convert it to a distance along the path.
-         * If @c isValid is @c false the behavior is undefined.
-         */
-		virtual float mapPointToPathDistance (const Vector3&amp; point) const = 0;
-        
-        /**
-         * Returns @c true f the path is closed, otherwise @c false.
-         */
-        virtual bool isCyclic() const = 0;
-        
-        /**
-         * Returns the length of the path.
-         */
-        virtual float length() const = 0;
-        
-    protected:
-        /**
-         * Protected to disable assigning instances of different inherited 
-         * classes to each other.
-         *
-         * @todo Should this be added or not? Have to read a bit...
-         */
-        // Path&amp; operator=( Path const&amp; );
-        
-    }; // class Path
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_PATH_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/Path.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/Path.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/Pathway.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Pathway.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/Pathway.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,100 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * Abstract base class for pathways - paths with associated radii.
- */
-#ifndef OPENSTEER_PATHWAY_H
-#define OPENSTEER_PATHWAY_H
-
-#include &quot;OpenSteer/Vec3.h&quot;
-
-namespace OpenSteer {
-    
-    
-    /**
-     * Pure virtual base class representing an abstract pathway in space.
-     * Could be used for example in path following.
-     */
-    class Pathway {
-    public:
-        virtual ~Pathway() = 0;
-        
-        /**
-         * Returns @c true if the path is valid, @c false otherwise.
-         */
-        virtual bool isValid() const = 0;
-        
-        /**
-         * Given an arbitrary point (&quot;A&quot;), returns the nearest point (&quot;P&quot;) on
-		 * this path center line.  Also returns, via output arguments, the path
-         * tangent at P and a measure of how far A is outside the Pathway's 
-         * &quot;tube&quot;.  Note that a negative distance indicates A is inside the 
-         * Pathway.
-         *
-         * If @c isValid is @c false the behavior is undefined.
-         */
-		virtual Vector3 mapPointToPath (const Vector3&amp; point,
-                                     Vector3&amp; tangent,
-                                     float&amp; outside) const = 0;
-        
-		/**
-         * Given a distance along the path, convert it to a point on the path.
-         * If @c isValid is @c false the behavior is undefined.
-         */
-		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const = 0;
-        
-		/**
-         * Given an arbitrary point, convert it to a distance along the path.
-         * If @c isValid is @c false the behavior is undefined.
-         */
-		virtual float mapPointToPathDistance (const Vector3&amp; point) const = 0;
-        
-        /**
-         * Returns @c true f the path is closed, otherwise @c false.
-         */
-        virtual bool isCyclic() const = 0;
-        
-        /**
-         * Returns the length of the path.
-         */
-        virtual float length() const = 0;
-        
-    protected:
-        /**
-         * Protected to disable assigning instances of different inherited 
-         * classes to each other.
-         *
-         * @todo Should this be added or not? Have to read a bit...
-         */
-        // Pathway&amp; operator=( Pathway const&amp; );    
-        
-    }; // class Pathway
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_PATHWAY_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/Pathway.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/Pathway.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPath.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/PolylineSegmentedPath.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPath.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,234 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
- *
- * Segmented path build of polylines.
- */
-#ifndef OPENSTEER_POLYLINESEGMENTEDPATH_H
-#define OPENSTEER_POLYLINESEGMENTEDPATH_H
-
-// Include std::vector
-#include &lt;vector&gt;
-
-
-
-// Include OpenSteer::SegmentedPath
-#include &quot;OpenSteer/SegmentedPath.h&quot;
-
-// Include OpenSteer::PointToPathAlikeBaseDataExtractionPolicy
-#include &quot;OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h&quot;
-
-// Include Vector3
-#include &quot;OpenSteer/Vec3.h&quot;
-
-// Include OpenSteer::distance
-#include &quot;OpenSteer/Vec3Utilities.h&quot;
-
-
-
-namespace OpenSteer {
-    
-    
-    /**
-     * Segmented path build by polylines. The last point of the path might be 
-     * connected to the first point building a closed cycle.
-     *
-     * 
-     */
-    class PolylineSegmentedPath : public SegmentedPath {
-    public:
-        typedef std::vector&lt; Vector3 &gt; PathPoints;
-        /**
-         * Constructs an invalid path. Behavior of most member functions is
-         * undefined if a path has less than two distinct points.
-         */
-        PolylineSegmentedPath();
-        
-        /**
-         * Constructs a new path.
-         *
-         * @param numOfPoints Number of points. Must be at least two.
-         * @param newPoints As many points as indicated by @a numOfPoints. Two
-         *                  adjacent points mustn't be identical and the first
-         *                  the last point mustn't be identical.
-         * @param closedCycle If @c true the first point of @a newPoints is
-         *                    copied to the end of the path to represent the 
-         *                    cycle closing segment.
-         */
-        PolylineSegmentedPath( size_type numOfPoints,
-                               Vector3 const newPoints[],
-                               bool closedCycle );
-
-        PolylineSegmentedPath( const PathPoints&amp; newPoints,
-                               bool closedCycle );
-        
-        PolylineSegmentedPath( PolylineSegmentedPath const&amp; other );
-        
-        virtual ~PolylineSegmentedPath();
-        
-        PolylineSegmentedPath&amp; operator=( PolylineSegmentedPath other );
-        
-        void swap( PolylineSegmentedPath&amp; other );
-        
-        
-        /**
-         * Replaces all path information by the given ones.
-         *
-         * @param numOfPoints Number of points. Must be at least two.
-         * @param newPoints As many points as indicated by @a numOfPoints. Two
-         *                  adjacent points mustn't be identical and the first
-         *                  the last point mustn't be identical.
-         * @param closedCycle If @c true the first point of @a newPoints is
-         *                    copied to the end of the path to represent the 
-         *                    cycle closing segment.
-         */
-        void setPath( size_type numOfPoints,
-                      Vector3 const newPoints[],
-                      bool closedCycle );
-
-        void setPath( const PathPoints&amp; newPoints, bool closedCycle);
-        /**
-         * Replaces @a numOfPoints points starting at @a startIndex.
-         *
-         * In the resulting sequence of points there mustn't be two adjacent 
-         * ones that are equal. The first and last point mustn't be identical,
-         * too.
-         *
-         * If the first point is changed and the path is cyclic the duplication
-         * of the first point at the end of the sequence representing the
-         * path closing segment is updated automatically.
-         *
-         * @param startIndex First point to be moved or replaced.
-         * @param numOfPoints Number of points to move or replace. 
-         *                    &lt;code&gt; numOfPoints + startIndex &lt;/code&gt; must be
-         *                    lesser or equal to @c pointCount.
-         * @param newPoints Moved points to replace the old ones.
-         */
-        void movePoints( size_type startIndex,
-                         size_type numOfPoints,
-                         Vector3 const newPoints[]);
-        
-        
-        
-        virtual bool isValid() const;
-        virtual Vector3 mapPointToPath (const Vector3&amp; point,
-                                     Vector3&amp; tangent,
-                                     float&amp; outside) const;
-		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const;
-		virtual float mapPointToPathDistance (const Vector3&amp; point) const;
-        virtual bool isCyclic() const;
-        virtual float length() const;
-        
-        
-        virtual size_type pointCount() const;
-        virtual Vector3 point( size_type pointIndex ) const;        
-        
-        
-        virtual size_type segmentCount() const;
-        virtual float segmentLength( size_type segmentIndex ) const;
-        virtual Vector3 segmentStart( size_type segmentIndex ) const;
-        virtual Vector3 segmentEnd( size_type segmentIndex ) const;
-        virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vector3 const&amp; point ) const;
-        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
-                                                float segmentDistance ) const;
-        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
-                                                  float segmentDistance ) const;
-        
-        virtual void mapDistanceToSegmentPointAndTangent( size_type segmentIndex,
-                                                          float distance,
-                                                          Vector3&amp; pointOnPath,
-                                                          Vector3&amp; tangent ) const;
-        
-        virtual void mapPointToSegmentDistanceAndPointAndTangent( size_type segmentIndex,
-                                                                  Vector3 const&amp; point,
-                                                                  float&amp; distance,
-                                                                  Vector3&amp; pointOnPath,
-                                                                  Vector3&amp; tangent ) const;
-        
-    private:
-        std::vector&lt; Vector3 &gt; points_;
-        std::vector&lt; Vector3 &gt; segmentTangents_;
-        std::vector&lt; float &gt; segmentLengths_;
-        bool closedCycle_;
-    }; // class PolylineSegmentedPath
-    
-    
-    /**
-     * Swaps the content of @a lhs and @a rhs.
-     */
-    inline void swap( PolylineSegmentedPath&amp; lhs, PolylineSegmentedPath&amp; rhs ) {
-        lhs.swap( rhs );
-    }
-    
-    
-    /**
-     * Extracts the base data of @c PolylineSegmentedPath.
-     */
-    template&lt;&gt;
-    class PointToPathAlikeBaseDataExtractionPolicy&lt; PolylineSegmentedPath &gt; {
-    public:
-        
-        static void extract( PolylineSegmentedPath const&amp; pathAlike,
-                             PolylineSegmentedPath::size_type segmentIndex,
-                             Vector3 const&amp; point, 
-                             float&amp; segmentDistance, 
-                             float&amp;, 
-                             float&amp; distancePointToPath, 
-                             Vector3&amp; pointOnPathCenterLine, 
-                             Vector3&amp; tangent ) {
-            pathAlike.mapPointToSegmentDistanceAndPointAndTangent( segmentIndex, point, segmentDistance, pointOnPathCenterLine, tangent );
-            distancePointToPath = distance( point, pointOnPathCenterLine );
-        }
-        
-    }; // class PointToPathAlikeBaseDataExtractionPolicy
-    
-    /**
-     * Extracts the base data of @c PolylineSegmentedPath.
-     */
-    template&lt;&gt;
-    class DistanceToPathAlikeBaseDataExtractionPolicy&lt; PolylineSegmentedPath &gt; {
-    public:
-        static void extract( PolylineSegmentedPath const&amp; pathAlike,
-                             PolylineSegmentedPath::size_type segmentIndex,
-                             float segmentDistance, 
-                             Vector3&amp; pointOnPathCenterLine, 
-                             Vector3&amp; tangent, 
-                             float&amp;  )  {
-            pathAlike.mapDistanceToSegmentPointAndTangent( segmentIndex, segmentDistance, pointOnPathCenterLine, tangent );     
-        }
-        
-        
-    }; // DistanceToPathAlikeBaseDataExtractionPolicy
-    
-    
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_POLYLINESEGMENTEDPATH_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPath.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/PolylineSegmentedPath.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,228 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
- *
- * Segmented pathway build of polylines. The whole path has one associated 
- * radius.
- */
-#ifndef OPENSTEER_POLYLINESEGMENTEDPATHWAYSINGLERADIUS_H
-#define OPENSTEER_POLYLINESEGMENTEDPATHWAYSINGLERADIUS_H
-
-// Include OpenSteer::SegmentedPathway
-#include &quot;OpenSteer/SegmentedPathway.h&quot;
-
-// Include OpenSteer::PolylineSegmentedPath
-#include &quot;OpenSteer/PolylineSegmentedPath.h&quot;
-
-// Include OpenSteer::PointToPathAlikeBaseDataExtractionPolicy
-#include &quot;OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h&quot;
-
-// Include Vector3
-#include &quot;OpenSteer/Vec3.h&quot;
-
-// Include OpenSteer::distance
-#include &quot;OpenSteer/Vec3Utilities.h&quot;
-
-
-
-namespace OpenSteer {
-    
-    /**
-     * Segmented pathway build by polylines with a single radius for the whole
-     * pathway.
-     */
-    class PolylineSegmentedPathwaySingleRadius : public SegmentedPathway {
-    public:
-        PolylineSegmentedPathwaySingleRadius();
-        explicit PolylineSegmentedPathwaySingleRadius( float r );
-        PolylineSegmentedPathwaySingleRadius( size_type numOfPoints,
-                                              Vector3 const points[],
-                                              float r,
-                                              bool closeCycle );
-        PolylineSegmentedPathwaySingleRadius( const PolylineSegmentedPath::PathPoints&amp; points,
-                                              float r,
-                                              bool closeCycle );
-        PolylineSegmentedPathwaySingleRadius( PolylineSegmentedPathwaySingleRadius const&amp; other );
-        virtual ~PolylineSegmentedPathwaySingleRadius();
-        PolylineSegmentedPathwaySingleRadius&amp; operator=( PolylineSegmentedPathwaySingleRadius other );
-        
-        /**
-         * Swaps the content with @a other.
-         */
-        void swap( PolylineSegmentedPathwaySingleRadius&amp; other );
-        
-        /**
-         * Replaces @a numOfPoints points starting at @a startIndex.
-         *
-         * In the resulting sequence of points there mustn't be two adjacent 
-         * ones that are equal. The first and last point mustn't be identical,
-         * too.
-         *
-         * If the first point is changed and the path is cyclic the duplication
-         * of the first point at the end of the sequence representing the
-         * path closing segment is updated automatically.
-         *
-         * @param startIndex First point to be moved or replaced.
-         * @param numOfPoints Number of points to move or replace. 
-         *                    &lt;code&gt; numOfPoints + startIndex &lt;/code&gt; must be
-         *                    lesser or equal to @c pointCount.
-         * @param newPointValues Moved points to replace the old ones.
-         */
-        void movePoints( size_type startIndex,
-                         size_type numOfPoints,
-                         Vector3 const newPointValues[] );
-        /**
-         * Replaces the pathway information completely.
-         *
-         * If @a closedCycle is @c true then the pathway has @a numOfPoints
-         * segments and the first point is duplicated and added as the last
-         * point to represent the end point of the segment closing the pathway
-         * cycle. If @a closedCycle is false the pathway has 
-         * &lt;code&gt;numOfPoints - 1&lt;/code&gt; segments.
-         *
-         * @param numOfPoints Number of points defining the pathway.
-         * @param points The actual points.
-         * @param r Radius of the whole pathway.
-         * @param closedCycle @c true if the pathway is cyclic, @a false 
-         *        otherwise.
-         */
-        void setPathway( size_type numOfPoints,
-                         Vector3 const points[],
-                         float r,
-                         bool closedCycle );
-        
-        /**
-         * Sets the radius of the whole pathway to @a r.
-         */
-        void setRadius( float r );
-        
-        /**
-         * Returns the pathway radius.
-         */
-        float radius() const;
-        
-        
-        virtual bool isValid() const;
-		virtual Vector3 mapPointToPath (const Vector3&amp; point,
-                                     Vector3&amp; tangent,
-                                     float&amp; outside) const;
-		virtual Vector3 mapPathDistanceToPoint (float pathDistance) const;
-		virtual float mapPointToPathDistance (const Vector3&amp; point) const;
-        virtual bool isCyclic() const;
-        virtual float length() const;
-        
-        
-        virtual size_type pointCount() const;
-        virtual Vector3 point( size_type pointIndex ) const;
-        
-        
-        virtual size_type segmentCount() const;
-        virtual float segmentLength( size_type segmentIndex ) const;
-        virtual Vector3 segmentStart( size_type segmentIndex ) const;
-        virtual Vector3 segmentEnd( size_type segmentIndex ) const;
-        virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vector3 const&amp; point ) const;
-        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
-                                                float segmentDistance ) const;
-        virtual float mapSegmentDistanceToRadius( size_type segmentIndex, 
-                                                 float distanceOnSegment ) const;
-        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
-                                                  float segmentDistance ) const;
-        
-        virtual void mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
-                                                                   float segmentDistance,
-                                                                   Vector3&amp; pointOnPath,
-                                                                   Vector3&amp; tangent,
-                                                                   float&amp; radius ) const;
-        
-        virtual void mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
-                                                                           Vector3 const&amp; point,
-                                                                           float&amp; distance,
-                                                                           Vector3&amp; pointOnPath,
-                                                                           Vector3&amp; tangent,
-                                                                           float&amp; radius) const;
-         
-    private:
-        PolylineSegmentedPath path_;
-        float radius_;
-    }; // class PolylineSegmentedPathwaySingleRadius
-    
-    
-    /**
-     * Swaps the content of @a lhs and @a rhs.
-     */
-    inline void swap( PolylineSegmentedPathwaySingleRadius&amp; lhs, 
-               PolylineSegmentedPathwaySingleRadius&amp; rhs ) {
-        lhs.swap( rhs );
-    }
-    
-    
-    /**
-     * Extracts the base data of @c PolylineSegmentedPathwaySingleRadius.
-     */
-    template&lt;&gt;
-    class PointToPathAlikeBaseDataExtractionPolicy&lt; PolylineSegmentedPathwaySingleRadius &gt; {
-    public:
-            
-        static void extract( PolylineSegmentedPathwaySingleRadius const&amp; pathAlike,
-                             PolylineSegmentedPathwaySingleRadius::size_type segmentIndex,
-                             Vector3 const&amp; point, 
-                             float&amp; segmentDistance, 
-                             float&amp; radius, 
-                             float&amp; distancePointToPath, 
-                             Vector3&amp; pointOnPathCenterLine, 
-                             Vector3&amp; tangent ) {
-            pathAlike.mapPointToSegmentDistanceAndPointAndTangentAndRadius( segmentIndex, point, segmentDistance, pointOnPathCenterLine, tangent, radius );
-            distancePointToPath = distance( point, pointOnPathCenterLine ) - radius;
-        }
-            
-    }; // class PointToPathAlikeBaseDataExtractionPolicy
-    
-    
-    /**
-     * Extracts the base data of @c PolylineSegmentedPathwaySingleRadius.
-     */
-    template&lt;&gt;
-    class DistanceToPathAlikeBaseDataExtractionPolicy&lt; PolylineSegmentedPathwaySingleRadius &gt; {
-    public:
-        static void extract( PolylineSegmentedPathwaySingleRadius const&amp; pathAlike,
-                             PolylineSegmentedPathwaySingleRadius::size_type segmentIndex,
-                             float segmentDistance, 
-                             Vector3&amp; pointOnPathCenterLine, 
-                             Vector3&amp; tangent, 
-                             float&amp; radius )  {
-            pathAlike.mapDistanceToSegmentPointAndTangentAndRadius( segmentIndex, segmentDistance, pointOnPathCenterLine, tangent, radius );     
-        }
-        
-        
-    }; // DistanceToPathAlikeBaseDataExtractionPolicy 
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_POLYLINESEGMENTEDPATHWAYSINGLERADIUS_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/PolylineSegmentedPathwaySingleRadius.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/Proximity.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Proximity.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/Proximity.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,337 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the &quot;Software&quot;),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// Proximity 
-//
-// Data structures for accelerating proximity/locality/neighborhood queries
-//
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 06-20-01 cwr: created
-//
-//
-// ----------------------------------------------------------------------------
-
-
-#ifndef OPENSTEER_PROXIMITY_H
-#define OPENSTEER_PROXIMITY_H
-
-
-#include &lt;algorithm&gt;
-#include &lt;vector&gt;
-#include &quot;OpenSteer/Vec3.h&quot;
-#include &quot;OpenSteer/lq.h&quot;   // XXX temp?
-
-
-namespace OpenSteer {
-
-
-    // ----------------------------------------------------------------------------
-    // &quot;tokens&quot; are the objects manipulated by the spatial database
-
-
-    template &lt;class ContentType&gt;
-    class AbstractTokenForProximityDatabase
-    {
-    public:
-
-        virtual ~AbstractTokenForProximityDatabase () {}
-
-        // the client object calls this each time its position changes
-        virtual void updateForNewPosition (const Vector3&amp; position) = 0;
-
-        // find all neighbors within the given sphere (as center and radius)
-        virtual void findNeighbors (const Vector3&amp; center,
-                                    const float radius,
-                                    std::vector&lt;ContentType&gt;&amp; results) = 0;
-
-#ifndef NO_LQ_BIN_STATS
-        // only meaningful for LQProximityDatabase, provide dummy default
-        virtual void getBinPopulationStats (int&amp; min, int&amp; max, float&amp; average)
-        {min=max=0; average=0.0;}
-#endif // NO_LQ_BIN_STATS
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // abstract type for all kinds of proximity databases
-
-
-    template &lt;class ContentType&gt;
-    class AbstractProximityDatabase
-    {
-    public:
-
-        // type for the &quot;tokens&quot; manipulated by this spatial database
-        typedef AbstractTokenForProximityDatabase&lt;ContentType&gt; tokenType;
-
-        
-        virtual ~AbstractProximityDatabase() { /* Nothing to do? */ }
-        
-        // allocate a token to represent a given client object in this database
-        virtual tokenType* allocateToken (ContentType parentObject) = 0;
-
-        // insert
-        // XXX maybe this should return an iterator?
-        // XXX see <A HREF="http://www.sgi.com/tech/stl/set.html">http://www.sgi.com/tech/stl/set.html</A>
-        // virtual void insert (const ContentType&amp; x) = 0;
-
-        // XXX name?
-        // returns the number of tokens in the proximity database
-        virtual int getPopulation (void) = 0;
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // This is the &quot;brute force&quot; O(n^2) approach implemented in terms of the
-    // AbstractProximityDatabase protocol so it can be compared directly to other
-    // approaches.  (e.g. the Boids plugin allows switching at runtime.)
-
-
-    template &lt;class ContentType&gt;
-    class BruteForceProximityDatabase
-        : public AbstractProximityDatabase&lt;ContentType&gt;
-    {
-    public:
-
-        // constructor
-        BruteForceProximityDatabase (void)
-        {
-        }
-
-        // destructor
-        virtual ~BruteForceProximityDatabase ()
-        {
-        }
-
-        // &quot;token&quot; to represent objects stored in the database
-        class tokenType : public AbstractTokenForProximityDatabase&lt;ContentType&gt;
-        {
-        public:
-
-            // constructor
-            tokenType (ContentType parentObject, BruteForceProximityDatabase&amp; pd)
-            {
-                // store pointer to our associated database and the object this
-                // token represents, and store this token on the database's vector
-                bfpd = &pd;
-                object = parentObject;
-                bfpd-&gt;group.push_back (this);
-            }
-
-            // destructor
-            virtual ~tokenType ()
-            {
-                // remove this token from the database's vector
-                bfpd-&gt;group.erase (std::find (bfpd-&gt;group.begin(),
-                                              bfpd-&gt;group.end(),
-                                              this));
-            }
-
-            // the client object calls this each time its position changes
-            void updateForNewPosition (const Vector3&amp; newPosition)
-            {
-                position = newPosition;
-            }
-
-            // find all neighbors within the given sphere (as center and radius)
-            void findNeighbors (const Vector3&amp; center,
-                                const float radius,
-                                std::vector&lt;ContentType&gt;&amp; results)
-            {
-                // loop over all tokens
-                const float r2 = radius * radius;
-                for (tokenIterator i = bfpd-&gt;group.begin();
-                     i != bfpd-&gt;group.end();
-                     i++)
-                {
-                    const Vector3 offset = center - (**i).position;
-                    const float d2 = offset.squaredLength();
-
-                    // push onto result vector when within given radius
-                    if (d2 &lt; r2) results.push_back ((**i).object);
-                }
-            }
-
-        private:
-            BruteForceProximityDatabase* bfpd;
-            ContentType object;
-            Vector3 position;
-        };
-
-        typedef std::vector&lt;tokenType*&gt; tokenVector;
-        typedef typename tokenVector::const_iterator tokenIterator;    
-
-        // allocate a token to represent a given client object in this database
-        tokenType* allocateToken (ContentType parentObject)
-        {
-            return new tokenType (parentObject, *this);
-        }
-
-        // return the number of tokens currently in the database
-        int getPopulation (void)
-        {
-            return (int) group.size();
-        }
-        
-    private:
-        // STL vector containing all tokens in database
-        tokenVector group;
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // A AbstractProximityDatabase-style wrapper for the LQ bin lattice system
-
-
-    template &lt;class ContentType&gt;
-    class LQProximityDatabase : public AbstractProximityDatabase&lt;ContentType&gt;
-    {
-    public:
-
-        // constructor
-        LQProximityDatabase (const Vector3&amp; center,
-                             const Vector3&amp; dimensions,
-                             const Vector3&amp; divisions)
-        {
-            const Vector3 halfsize (dimensions * 0.5f);
-            const Vector3 origin (center - halfsize);
-
-            lq = lqCreateDatabase (origin.x, origin.y, origin.z, 
-                                   dimensions.x, dimensions.y, dimensions.z,  
-                                   (int) round (divisions.x),
-                                   (int) round (divisions.y),
-                                   (int) round (divisions.z));
-        }
-
-        // destructor
-        virtual ~LQProximityDatabase ()
-        {
-            lqDeleteDatabase (lq);
-            lq = NULL;
-        }
-
-        // &quot;token&quot; to represent objects stored in the database
-        class tokenType : public AbstractTokenForProximityDatabase&lt;ContentType&gt;
-        {
-        public:
-
-            // constructor
-            tokenType (ContentType parentObject, LQProximityDatabase&amp; lqsd)
-            {
-                lqInitClientProxy (&amp;proxy, parentObject);
-                lq = lqsd.lq;
-            }
-
-            // destructor
-            virtual ~tokenType (void)
-            {
-                lqRemoveFromBin (&amp;proxy);
-            }
-
-            // the client object calls this each time its position changes
-            void updateForNewPosition (const Vector3&amp; p)
-            {
-                lqUpdateForNewLocation (lq, &amp;proxy, p.x, p.y, p.z);
-            }
-
-            // find all neighbors within the given sphere (as center and radius)
-            void findNeighbors (const Vector3&amp; center,
-                                const float radius,
-                                std::vector&lt;ContentType&gt;&amp; results)
-            {
-                lqMapOverAllObjectsInLocality (lq, 
-                                               center.x, center.y, center.z,
-                                               radius,
-                                               perNeighborCallBackFunction,
-                                               (void*)&amp;results);
-            }
-
-            // called by LQ for each clientObject in the specified neighborhood:
-            // push that clientObject onto the ContentType vector in void*
-            // clientQueryState
-            // (parameter names commented out to prevent compiler warning from &quot;-W&quot;)
-            static void perNeighborCallBackFunction  (void* clientObject,
-                                                      float /*distanceSquared*/,
-                                                      void* clientQueryState)
-            {
-                typedef std::vector&lt;ContentType&gt; ctv;
-                ctv&amp; results = *((ctv*) clientQueryState);
-                results.push_back ((ContentType) clientObject);
-            }
-
-#ifndef NO_LQ_BIN_STATS
-            // Get statistics about bin populations: min, max and
-            // average of non-empty bins.
-            void getBinPopulationStats (int&amp; min, int&amp; max, float&amp; average)
-            {
-                lqGetBinPopulationStats (lq, &amp;min, &amp;max, &amp;average);
-            }
-#endif // NO_LQ_BIN_STATS
-
-        private:
-            lqClientProxy proxy;
-            lqDB* lq;
-        };
-
-
-        // allocate a token to represent a given client object in this database
-        tokenType* allocateToken (ContentType parentObject)
-        {
-            return new tokenType (parentObject, *this);
-        }
-
-        // count the number of tokens currently in the database
-        int getPopulation (void)
-        {
-            int count = 0;
-            lqMapOverAllObjects (lq, counterCallBackFunction, &amp;count);
-            return count;
-        }
-        
-        // (parameter names commented out to prevent compiler warning from &quot;-W&quot;)
-        static void counterCallBackFunction  (void* /*clientObject*/,
-                                              float /*distanceSquared*/,
-                                              void* clientQueryState)
-        {
-            int&amp; counter = *(int*)clientQueryState;
-            counter++;
-        }
-
-
-    private:
-        lqDB* lq;
-    };
-
-} // namespace OpenSteer
-
-
-
-// ----------------------------------------------------------------------------
-#endif // OPENSTEER_PROXIMITY_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/Proximity.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/Proximity.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlike.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/QueryPathAlike.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlike.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,229 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
- *
- * Functionality to map points or distances to path alikes and to extract
- * the assocaited information.
- */
-#ifndef OPENSTEER_QUERYPATHALIKE_H
-#define OPENSTEER_QUERYPATHALIKE_H
-
-
-// Include std::numeric_limits&lt; float &gt;::max
-#include &lt;limits&gt;
-
-
-
-// Include Vector3
-#include &quot;OpenSteer/Vec3.h&quot;
-
-// Include OpenSteer::distance
-#include &quot;OpenSteer/Vec3Utilities.h&quot;
-
-// Include OpenSteer::clamp, OpenSteer::modulo
-#include &quot;OpenSteer/Utilities.h&quot;
-
-// Include OpenSteer::PointToPathAlikeBaseDataExtractionPolicy, OpenSteer::DistanceToPathAlikeBaseDataExtractionPolicy
-#include &quot;OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h&quot;
-
-#ifdef _MSC_VER
-#undef min
-#undef max
-#endif
-
-
-namespace OpenSteer {
-
-    /**
-     * Provides functionality to map points or distances to path alikes and
-     * to extract associated information.
-     */
-    template&lt; class PathAlike, class Mapping, class BaseDataExtractionPolicy = PointToPathAlikeBaseDataExtractionPolicy&lt; PathAlike &gt; &gt;
-    class PointToPathAlikeMapping {
-    public:
-        
-        /**
-         * Maps @a queryPoint to a path alike @a pathAlike and returns the  
-         * queried data in @a mapping.
-         *
-         * @c Mapping must provide the following member functions to
-         * set queried values. Member functions might be empty if the specific 
-         * data isn't needed. A good compiler should optimize the
-         * empty member function calls and the associated calculations for its
-         * parameters away.
-         *
-         * &lt;code&gt; void setPointOnPathCenterLine( Vector3 const&amp; ) &lt;/code&gt;
-         * &lt;code&gt; void setPointOnPathBoundary( Vector3 const&amp; ) &lt;/code&gt;
-         * &lt;code&gt; void setRadius( float ) &lt;/code&gt;
-         * &lt;code&gt; void setTangent( Vector3 const&amp; ) &lt;/code&gt;
-         * &lt;code&gt; void setSegmentIndex( typename SegmentedPathAlike::size_type ) &lt;/code&gt;
-         * &lt;code&gt; void setDistancePointToPath( float ) &lt;/code&gt;
-         * &lt;code&gt; void setDistancePointToPathCenterLine( float ) &lt;/code&gt;
-         * &lt;code&gt; void setDistanceOnPath( float ) &lt;/code&gt;
-         * &lt;code&gt; void setDistanceOnSegment( float ) &lt;/code&gt;
-         *
-         * To query for the distance on the path the two following member functions
-         * of @c Mapping must be provided too:
-         *
-         * &lt;code&gt; void setDistanceOnPathFlag( float ) &lt;/code&gt; and
-         * &lt;code&gt; float distanceOnPathFlag() const &lt;/code&gt;.
-         *
-         * If the distance along the path shouldn't be extracted empty 
-         * versions of these member functions are possible.
-         *
-         * @c QueryPathAlikeUtilities.h provides some base classes to inherit
-         * from to automatically get some of the functionality described above.
-         */
-        static void map( PathAlike const&amp; pathAlike, Vector3 const&amp; queryPoint, Mapping&amp; mapping ) {
-            float minDistancePointToPath = std::numeric_limits&lt; float &gt;::max();
-            mapping.setDistanceOnPathFlag( 0.0f );
-            
-            typedef typename PathAlike::size_type size_type;
-            size_type const segmentCount = pathAlike.segmentCount();
-            for ( size_type segmentIndex = 0; segmentIndex &lt; segmentCount; ++segmentIndex ) {
-                
-                float segmentDistance = 0.0f;
-                float radius = 0.0f;
-                float distancePointToPath = 0.0f;
-                Vector3 pointOnPathCenterLine( 0.0f, 0.0f, 0.0f );
-                Vector3 tangent( 0.0f, 0.0f, 0.0f );
-                
-                BaseDataExtractionPolicy::extract( pathAlike, segmentIndex, queryPoint, segmentDistance, radius, distancePointToPath, pointOnPathCenterLine, tangent );
-                
-                if ( distancePointToPath &lt; minDistancePointToPath ) {
-                    minDistancePointToPath = distancePointToPath;
-                    mapping.setPointOnPathCenterLine( pointOnPathCenterLine );
-                    mapping.setPointOnPathBoundary( pointOnPathCenterLine + ( ( queryPoint - pointOnPathCenterLine ).normalisedCopy() * radius ) );
-                    mapping.setRadius( radius );
-                    mapping.setTangent( tangent );
-                    mapping.setSegmentIndex( segmentIndex );
-                    mapping.setDistancePointToPath( distancePointToPath );
-                    mapping.setDistancePointToPathCenterLine( distancePointToPath + radius );
-                    mapping.setDistanceOnPath( mapping.distanceOnPathFlag() + segmentDistance );
-                    mapping.setDistanceOnSegment( segmentDistance );
-                }
-                
-                mapping.setDistanceOnPathFlag( mapping.distanceOnPathFlag() + pathAlike.segmentLength( segmentIndex ) );
-            }
-        }
-        
-    }; // class PointToPathAlikeMapping
-    
-    /**
-     * Maps @a point to @a pathAlike and returns the data extracted in 
-     * @a mapping.
-     *
-     * See @c MapPointToPathAlike::map for further information.
-     */
-    template&lt; class PathAlike, class Mapping &gt;
-    void mapPointToPathAlike( PathAlike const&amp; pathAlike, Vector3 const&amp; point, Mapping&amp; mapping ) {
-        PointToPathAlikeMapping&lt; PathAlike, Mapping &gt;::map( pathAlike, point, mapping );
-    }
-    
-        
-    
-    /**
-     * Provides functionality to map distances to path alikes and to extract
-     * the associated data.
-     */
-    template&lt; class PathAlike, class Mapping, class BaseDataExtractionPolicy = DistanceToPathAlikeBaseDataExtractionPolicy&lt; PathAlike &gt; &gt; 
-    class DistanceToPathAlikeMapping {
-    public:
-    
-        /**
-         * Maps @a distanceOnPath to a path alike @a pathAlike and returns the 
-         * queried data in @a mapping.
-         *
-         * @c Mapping must provide the following member functions 
-         * to set queried values. Member functions might be empty if the  
-         * specific data isn't needed. A good compiler should optimize the
-         * empty member function calls and the associated calculations for its
-         * parameters away.
-         *
-         * &lt;code&gt; void setPointOnPathCenterLine( Vector3 const&amp; ) &lt;/code&gt;
-         * &lt;code&gt; void setRadius( float ) &lt;/code&gt;
-         * &lt;code&gt; void setTangent( Vector3 const&amp; ) &lt;/code&gt;
-         * &lt;code&gt; void setSegmentIndex( typename SegmentedPathAlike::size_type ) &lt;/code&gt;
-         * &lt;code&gt; void setDistanceOnPath( float ) &lt;/code&gt;
-         * &lt;code&gt; void setDistanceOnSegment( float ) &lt;/code&gt;
-         */
-        static void map( PathAlike const&amp; pathAlike, float distanceOnPath, Mapping&amp; mapping ) {
-            float const pathLength = pathAlike.length();
-            
-            // Modify @c distanceOnPath to applicable values.
-            if ( pathAlike.isCyclic() ) {
-                distanceOnPath = modulo( distanceOnPath, pathLength );       
-            }
-            distanceOnPath = clamp( distanceOnPath, 0.0f, pathLength );
-            
-            // Which path alike segment is reached by @c distanceOnPath?
-            float remainingDistance = distanceOnPath;
-            typedef typename PathAlike::size_type size_type;
-            size_type segmentIndex = 0;        
-            size_type const maxSegmentIndex = pathAlike.segmentCount() - 1;
-            while( ( segmentIndex &lt; maxSegmentIndex ) &amp;&amp; 
-                   ( remainingDistance &gt; pathAlike.segmentLength( segmentIndex ) ) ) {
-                remainingDistance -= pathAlike.segmentLength( segmentIndex );
-                ++segmentIndex;
-            }
-            
-            // Extract the path related data associated with the segment reached
-            // by @c distanceOnPath.
-            Vector3 pointOnPathCenterLine( 0.0f, 0.0f, 0.0f );
-            Vector3 tangent( 0.0f, 0.0f, 0.0f );
-            float radius = 0.0f;
-            BaseDataExtractionPolicy::extract( pathAlike, segmentIndex, remainingDistance, pointOnPathCenterLine, tangent, radius );
-            
-            // Store the extracted data in @c mapping to return it to the caller.
-            mapping.setPointOnPathCenterLine( pointOnPathCenterLine );
-            mapping.setRadius( radius );
-            mapping.setTangent( tangent );
-            mapping.setSegmentIndex( segmentIndex );
-            mapping.setDistanceOnPath( distanceOnPath );
-            mapping.setDistanceOnSegment( remainingDistance );            
-        }
-        
-    }; // class DistanceToPathAlikeMapping
-    
-    
-    
-    /**
-     * Maps @a distance to @a pathAlike and stores the data queried in
-     * @a mapping.
-     *
-     * See @c DistanceToPathAlikeMapping::map for further information.
-     */
-    template&lt; class PathAlike, class Mapping &gt;
-    void mapDistanceToPathAlike( PathAlike const&amp; pathAlike, float distance, Mapping&amp; mapping ) {
-        DistanceToPathAlikeMapping&lt; PathAlike, Mapping &gt;::map( pathAlike, distance, mapping );
-    }
-    
-    
-} // namespace OpenSteer
-
-#endif // OPENSTEER_QUERYPATHALIKE_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlike.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/QueryPathAlike.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,71 +0,0 @@
-/**
-* OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
- *
- * Declarations of policies used by @c OpenSteer::mapPointToPathAlike and
- * @c OpenSteer::mapDistanceToPathAlike to extract informations of path alikes.
- */
-#ifndef OPENSTEER_QUERYPATHALIKEBASEDATAEXTRACTIONPOLICY_H
-#define OPENSTEER_QUERYPATHALIKEBASEDATAEXTRACTIONPOLICY_H
-
-namespace OpenSteer {
-    
-    /**
-     * Extracts the base data like the segment distance, the radius, the
-     * distance of the query point to the path alike, the point on the path
-     * alike center line and the tangent at that point.
-     *
-     * Specialize it for the path alike to use and provide a static member
-     * function with the following signature:
-     *
-     * &lt;code&gt;static void extract( PathAlike const&amp; pathAlike, typename PathAlike::size_type segmentIndex, Vector3 const&amp; point, float&amp; segmentDistance, float&amp; radius, float&amp; distancePointToPath, Vector3&amp; pointOnPathCenterLine, Vector3&amp; tangent )&lt;/code&gt;
-     *
-     * @attention Be aware of the references that are passed in.
-     */
-    template&lt; class PathAlike &gt;
-    class PointToPathAlikeBaseDataExtractionPolicy;
-    
-    
-    /**
-     * Extracts the base data like the radius, the point on the path
-     * alike center line and the tangent at that point.
-     *
-     * Specialize it for the path alike to use and provide a static member
-     * function with the following signature:
-     *
-     * &lt;code&gt;static void extract( PathAlike const&amp; pathAlike, typename PathAlike::size_type segmentIndex, float segmentDistance, Vector3&amp; pointOnPathCenterLine, Vector3&amp; tangent, float&amp; radius )&lt;/code&gt;
-     *
-     * @attention Be aware of the references that are passed in.
-     */    
-    template&lt; class PathAlike &gt;
-    class DistanceToPathAlikeBaseDataExtractionPolicy;
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_QUERYPATHALIKEBASEDATAEXTRACTIONPOLICY_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeBaseDataExtractionPolicies.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,144 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
- *
- * Predefined mappings used by @c OpenSteer::mapPointToPathAlike and 
- * @c OpenSteer::mapDistanceToPathAlike used by implementations of segmented
- * paths and pathways.
- */
-#ifndef OPENSTEER_QUERYPATHALIKEMAPPINGS_H
-#define OPENSTEER_QUERYPATHALIKEMAPPINGS_H
-
-
-// Include OpenSteer::HasNoRadius, OpenSteer::ExtractPathDistance, OpenSteer::DontExtractPathDistance
-#include &quot;OpenSteer/QueryPathAlikeUtilities.h&quot;
-
-// Include Vector3
-#include &quot;OpenSteer/Vec3.h&quot;
-
-// Include OpenSteer::size_t
-#include &quot;OpenSteer/StandardTypes.h&quot;
-
-
-
-namespace OpenSteer {
-    
-    /**
-     * Stores the point on a pathway boundary, the tangent at the associated
-     * path center line and the distance of a query point to the point on the 
-     * path boundary - used by @c OpenSteer::mapPointToPathAlike.
-     */
-    class PointToPathMapping 
-        : public DontExtractPathDistance {
-        
-    public:
-        PointToPathMapping() : pointOnPathCenterLine( 0.0f, 0.0f, 0.0f ), tangent( 0.0f, 0.0f, 0.0f ), distancePointToPath( 0.0f ) {}
-            
-        void setPointOnPathCenterLine( Vector3 const&amp; point ) {
-            pointOnPathCenterLine = point;
-        }
-        void setPointOnPathBoundary( Vector3 const&amp; ) {
-            // pointOnPathBoundary = point;
-        }
-        void setRadius( float ) {}
-        void setTangent( Vector3 const&amp; t) {
-            tangent = t;
-        }
-        void setSegmentIndex( size_t ) {}
-        void setDistancePointToPath( float distance ) {
-            distancePointToPath = distance;
-        }
-        void setDistancePointToPathCenterLine( float ) {}
-        void setDistanceOnPath( float ) {}
-        void setDistanceOnSegment( float ) {}
-            
-        Vector3 pointOnPathCenterLine;
-        // Vector3 pointOnPathBoundary; 
-        Vector3 tangent;
-        float distancePointToPath;
-            
-            
-    }; // class PointToPathMapping
-    
-    
-    /**
-     * Stores the point on a path center line for a given distance from the
-     * start of the path - used by @c OpenSteer::mapDistanceToPathAlike.
-     */
-    class PathDistanceToPointMapping 
-        :  public DontExtractPathDistance {
-            
-    public:
-        
-        void setPointOnPathCenterLine( Vector3 const&amp; vec ){
-            pointOnPathCenterLine = vec;
-        }
-        void setRadius( float ) {}
-        void setTangent( Vector3 const&amp; ){}
-        void setSegmentIndex( size_t ){}
-        void setDistanceOnPath( float ){}
-        void setDistanceOnSegment( float ){}
-            
-            
-        Vector3 pointOnPathCenterLine; 
-            
-            
-    }; // class PathDistanceToPointMapping
-    
-    
-    
-    /**
-     * Stores the distance of from the start of a path to a point on the 
-     * center line of the path - used by @c OpenSteer::mapPointToPathAlike.
-     */
-    class PointToPathDistanceMapping
-        : public ExtractPathDistance {
-    public:
-        PointToPathDistanceMapping() : distanceOnPath( 0.0f ) {}
-            
-        void setPointOnPathCenterLine( Vector3 const&amp; ) {}
-        void setPointOnPathBoundary( Vector3 const&amp;  ) {}
-        void setRadius( float ) {}
-        void setTangent( Vector3 const&amp; ) {}
-        void setSegmentIndex( size_t ) {}
-        void setDistancePointToPath( float  ) {}
-        void setDistancePointToPathCenterLine( float ) {}
-        void setDistanceOnPath( float distance ) {
-            distanceOnPath = distance;
-        }
-        void setDistanceOnSegment( float ) {}
-            
-        float distanceOnPath;
-    }; // class PointToPathDistanceMapping
-    
-    
-} // namespace OpenSteer
-
-
-
-#endif // OPENSTEER_QUERYPATHALIKEMAPPINGS_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeMappings.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,102 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
- *
- * Collection of helper classes to inherit from to create mappings as used by  
- * @c OpenSteer::mapDistanceToPathAlike and 
- * @c OpenSteer::mapPointToPathAlike.
- */
-
-#ifndef OPENSTEER_QUERYPATHALIKEUTILITIES_H
-#define OPENSTEER_QUERYPATHALIKEUTILITIES_H
-
-
-namespace OpenSteer {
-
-    /**
-     * Inherit from it to create a mapping class used by 
-     * @c OpenSteer::mapDistanceToPathAlike and 
-     * @c OpenSteer::mapPointToPathAlike that calculates and extracts the
-     * distance along the path alike.
-     */    
-    class ExtractPathDistance {
-    public:
-        void setDistanceOnPathFlag( float distance ) {
-            distanceOnPathFlag_ = distance;
-        }
-        
-        
-        float distanceOnPathFlag() const {
-            return distanceOnPathFlag_;
-        }
-        
-    protected:
-        ExtractPathDistance() : distanceOnPathFlag_( 0.0f ) {
-            // Nothing to do.
-        }
-        
-        explicit ExtractPathDistance( float distance ) : distanceOnPathFlag_( distance ) {
-            // Nothing to do.
-        }
-        
-        ~ExtractPathDistance() {
-            // Nothing to do.
-        }
-        
-    private:
-        float distanceOnPathFlag_;
-    }; // class ExtractPathDistance
-    
-    
-    /**
-     * Inherit from it to create a mapping class used by 
-     * @c OpenSteer::mapDistanceToPathAlike and 
-     * @c OpenSteer::mapPointToPathAlike that shouldn't calculate and extract the
-     * distance along the path alike.
-     */
-    class DontExtractPathDistance {
-    public:
-        void setDistanceOnPathFlag( float ) {
-            // Nothing to do.
-        }
-        
-        float distanceOnPathFlag() const {
-            return 0.0f;
-        };
-        
-    protected:
-        ~DontExtractPathDistance() {
-            // Nothing to do.
-        }
-    }; // class DontExtractPathDistance
-    
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_QUERYPATHALIKEUTILITIES_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/QueryPathAlikeUtilities.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPath.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/SegmentedPath.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPath.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,157 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
- *
- * Abstract segmented path class for paths build of segments between waypoints.
- */
-#ifndef OPENSTEER_SEGMENTEDPATH_H
-#define OPENSTEER_SEGMENTEDPATH_H
-
-// Include OpenSteer::Path
-#include &quot;OpenSteer/Path.h&quot;
-
-// Include OpenSteer::size_t
-#include &quot;OpenSteer/StandardTypes.h&quot;
-
-namespace OpenSteer {
-    
-    /**
-     * Path build by segments between points on the path.
-     */
-    class SegmentedPath : public Path {
-    public:
-        typedef size_t size_type;
-        
-        virtual ~SegmentedPath() = 0;
-        
-        
-        /**
-         * Returns the number of points defining the segments.
-         *
-         * This also includes the duplicated first point if the path is cyclic.
-         */
-        virtual size_type pointCount() const = 0;
-        
-        /**
-         * Returns the point @a pointIndex.
-         *
-         * If the path is cyclic also the last point that is the duplicated
-         * first one is accessible.
-         */
-        virtual Vector3 point( size_type pointIndex ) const = 0;
-        
-        
-        
-        /**
-         * Returns the number of segments that build the pathway.
-         */
-        virtual size_type segmentCount() const = 0;
-        
-        /**
-         * Returns the length of segment @a segmentIndex.
-         */
-        virtual float segmentLength( size_type segmentIndex ) const = 0;
-        
-        /**
-         * Returns the start point of the segment @a segmentIndex.
-         */
-        virtual Vector3 segmentStart( size_type segmentIndex ) const = 0;
-        
-        /**
-         * Returns the end point of segment @a segmentIndex.
-         */
-        virtual Vector3 segmentEnd( size_type segmentIndex ) const = 0;
-        
-        
-        /**
-         * Maps @a point to the nearest point on the center line of segment
-         * @a segmentIndex and returns the distance from the segment start to 
-         * this point.
-         */
-        virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vector3 const&amp; point ) const = 0;
-        
-        
-        /**
-         * Maps @a segmentDistance to the center line of segment @a segmentIndex
-         * and returns the reached point.
-         *
-         * If @a segmentDistance is greater or smaller than the segment length
-         * is is clamped to @c 0.0f or @c segmentLength().
-         */
-        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
-                                                float segmentDistance ) const = 0;
-        
-        /**
-         * Maps @a segmentDistance to the centerline of the segment 
-         * @a segmentIndex and returns the tangent of the pathway at the reached
-         * point.
-         *
-         * If @a segmentDistance is greater or smaller than the segment length
-         * is is clamped to @c 0.0f or @c segmentLength().
-         */
-        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
-                                                  float segmentDistance ) const = 0;
-        
-        
-        /**
-         * Combines @c mapSegmentDistanceToPoint and 
-         * @c mapSegmentDistanceToTangent.
-         */
-        virtual void mapDistanceToSegmentPointAndTangent( size_type segmentIndex,
-                                                          float distance,
-                                                          Vector3&amp; pointOnPath,
-                                                          Vector3&amp; tangent ) const = 0;
-        
-        
-        /**
-         * Combines @c mapPointToSegmentDistance, @c mapSegmentDistanceToPoint, 
-         * and @c mapSegmentDistanceToTangent.
-         */
-        virtual void mapPointToSegmentDistanceAndPointAndTangent( size_type segmentIndex,
-                                                                  Vector3 const&amp; point,
-                                                                  float&amp; distance,
-                                                                  Vector3&amp; pointOnPath,
-                                                                  Vector3&amp; tangent ) const = 0;
-
-    protected:
-        /**
-         * Protected to disable assigning instances of different inherited 
-         * classes to each other.
-         *
-         * @todo Should this be added or not? Have to read a bit...
-         */
-        // SegmentedPath&amp; operator=( SegmentedPath const&amp; );
-        
-    }; // class SegmentedPath
-    
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_SEGMENTEDPATH_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPath.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/SegmentedPath.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPathway.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/SegmentedPathway.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPathway.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,173 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
- *
- * Abstract pathway build of segments between waypoints.
- */
-#ifndef OPENSTEER_SEGMENTEDPATHWAY_H
-#define OPENSTEER_SEGMENTEDPATHWAY_H
-
-
-// Include OpenSteer::Pathway
-#include &quot;OpenSteer/Pathway.h&quot;
-
-// Include OpenSteer::size_t
-#include &quot;OpenSteer/StandardTypes.h&quot;
-
-
-namespace OpenSteer {
-
-    /**
-     * Path defined by path segments.
-     *
-     * Look at @c QueryPathAlikes.h for functionality to query paths and
-     * pathways for information not provided here.
-     */
-    class SegmentedPathway: public Pathway {
-    public:
-        typedef size_t size_type;
-        
-        
-        virtual ~SegmentedPathway() = 0;
-        
-        /**
-         * Returns the number of points defining the segments.
-         *
-         * This also includes the duplicated first point if the path is cyclic.
-         */
-        virtual size_type pointCount() const = 0;
-        
-        /**
-         * Returns the point @a pointIndex.
-         *
-         * If the path is cyclic also the last point that is the duplicated
-         * first one is accessible.
-         */
-        virtual Vector3 point( size_type pointIndex ) const = 0;
-        
-        
-        /**
-         * Returns the number of segments that build the pathway.
-         */
-        virtual size_type segmentCount() const = 0;
-        
-        /**
-         * Returns the length of segment @a segmentIndex.
-         */
-        virtual float segmentLength( size_type segmentIndex ) const = 0;
-        
-        /**
-         * Returns the start point of the segment @a segmentIndex.
-         */
-        virtual Vector3 segmentStart( size_type segmentIndex ) const = 0;
-        
-        /**
-         * Returns the end point of segment @a segmentIndex.
-         */
-        virtual Vector3 segmentEnd( size_type segmentIndex ) const = 0;
-        
-        
-        
-        /**
-         * Maps @a point to the nearest point on the center line of segment
-         * @a segmentIndex and returns the distance from the segment start to 
-         * this point.
-         */
-        virtual float mapPointToSegmentDistance( size_type segmentIndex, 
-                                                 Vector3 const&amp; point ) const = 0;
-        
-        
-        /**
-         * Maps @a segmentDistance to the center line of segment @a segmentIndex
-         * and returns the reached point.
-         *
-         * If @a segmentDistance is greater or smaller than the segment length
-         * is is clamped to @c 0.0f or @c segmentLength().
-         */
-        virtual Vector3 mapSegmentDistanceToPoint( size_type segmentIndex, 
-                                                float segmentDistance ) const = 0;
-        
-        /**
-         * Maps @a segmentDistance to the center line of segment @a segmentIndex
-         * and returns the radius at the reached point.
-         *
-         * If @a segmentDistance is greater or smaller than the segment length
-         * is is clamped to @c 0.0f or @c segmentLength().
-         */
-        virtual float mapSegmentDistanceToRadius( size_type segmentIndex, 
-                                                 float distanceOnSegment ) const = 0;
-        
-        /**
-         * Maps @a segmentDistance to the centerline of the segment 
-         * @a segmentIndex and returns the tangent of the pathway at the reached
-         * point.
-         *
-         * If @a segmentDistance is greater or smaller than the segment length
-         * is is clamped to @c 0.0f or @c segmentLength().
-         */
-        virtual Vector3 mapSegmentDistanceToTangent( size_type segmentIndex, 
-                                                  float segmentDistance ) const = 0;
-        
-        /**
-         * Combines @c mapSegmentDistanceToPoint and 
-         * @c mapSegmentDistanceToTangent and @c mapSegmentDistanceToRadius.
-         */
-        virtual void mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
-                                                                   float segmentDistance,
-                                                                   Vector3&amp; pointOnPath,
-                                                                   Vector3&amp; tangent,
-                                                                   float&amp; radius ) const = 0;        
-        
-        /**
-         * Combines @c mapPointToSegmentDistance, @c mapSegmentDistanceToPoint,
-         * @c mapSegmentDistanceToRadius, and @c mapSegmentDistanceToTangent.
-         */
-        virtual void mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
-                                                                           Vector3 const&amp; point,
-                                                                           float&amp; distance,
-                                                                           Vector3&amp; pointOnPath,
-                                                                           Vector3&amp; tangent,
-                                                                           float&amp; radius) const = 0;
-        
-       
-    protected:
-        /**
-         * Protected to disable assigning instances of different inherited 
-         * classes to each other.
-         *
-         * @todo Should this be added or not? Have to read a bit...
-         */
-        // SegmentedPathway&amp; operator=( SegmentedPathway const&amp; );    
-    }; // class SegmentedPathway
-    
-    
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_SEGMENTEDPATHWAY_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/SegmentedPathway.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/SegmentedPathway.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/StandardTypes.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/StandardTypes.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/StandardTypes.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,46 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original authors: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @file
- *
- * Primitive standard types.
- */
-#ifndef OPENSTEER_STANDARDTYPES_H
-#define OPENSTEER_STANDARDTYPES_H
-
-// Include std::size_t, std::ptrdiff_t
-#include &lt;cstddef&gt;
-
-
-namespace OpenSteer {
-    
-    
-    typedef std::size_t size_t;
-    typedef std::ptrdiff_t ptrdiff_t;
-    
-} // namespace OpenSteer
-
-
-#endif // OPENSTEER_STANDARDTYPES_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/StandardTypes.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/StandardTypes.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/SteerLibrary.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/SteerLibrary.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/SteerLibrary.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,1076 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the &quot;Software&quot;),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// SteerLibraryMixin
-//
-// This mixin (class with templated superclass) adds the &quot;steering library&quot;
-// functionality to a given base class.  SteerLibraryMixin assumes its base
-// class supports the AbstractVehicle interface.
-//
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 02-06-03 cwr: create mixin (from &quot;SteerMass&quot;)
-// 06-03-02 cwr: removed TS dependencies
-// 11-21-01 cwr: created
-//
-//
-// ----------------------------------------------------------------------------
-
-
-#ifndef OPENSTEER_STEERLIBRARY_H
-#define OPENSTEER_STEERLIBRARY_H
-
-
-#include &quot;OpenSteer/AbstractVehicle.h&quot;
-#include &quot;OpenSteer/Pathway.h&quot;
-#include &quot;OpenSteer/Obstacle.h&quot;
-#include &quot;OpenSteer/Utilities.h&quot;
-
-// Include OpenSteer::Color, OpenSteer::gBlack, ...
-#include &quot;Color.h&quot;
-
-namespace OpenSteer {
-
-    // ----------------------------------------------------------------------------
-
-
-    template &lt;class Super&gt;
-    class SteerLibraryMixin : public Super
-    {
-    public:
-        using Super::getVelocity;
-        using Super::getMaxSpeed;
-        using Super::getSpeed;
-        using Super::getRadius;
-        using Super::getMaxForce;
-        using Super::getForward;
-        using Super::getPosition;
-        using Super::getSide;
-        using Super::getUp;
-        using Super::predictFuturePosition;
-        
-    public:
-
-        // Constructor: initializes state
-        SteerLibraryMixin ()
-        {
-            // set inital state
-            reset ();
-        }
-
-        // reset state
-        void reset (void)
-        {
-            // initial state of wander behavior
-            WanderSide = 0;
-            WanderUp = 0;
-
-            // default to non-gaudyPursuitAnnotation
-            gaudyPursuitAnnotation = false;
-        }
-
-        // -------------------------------------------------- steering behaviors
-
-        // Wander behavior
-        float WanderSide;
-        float WanderUp;
-        Vector3 steerForWander (float dt);
-
-        // Seek behavior
-        Vector3 steerForSeek (const Vector3&amp; target);
-
-        // Flee behavior
-        Vector3 steerForFlee (const Vector3&amp; target);
-
-        // xxx proposed, experimental new seek/flee [cwr 9-16-02]
-        Vector3 xxxsteerForFlee (const Vector3&amp; target);
-        Vector3 xxxsteerForSeek (const Vector3&amp; target);
-
-        // Path Following behaviors
-        Vector3 steerToFollowPath (const int direction,
-                                const float predictionTime,
-                                Pathway&amp; path);
-        Vector3 steerToStayOnPath (const float predictionTime, Pathway&amp; path);
-
-        // ------------------------------------------------------------------------
-        // Obstacle Avoidance behavior
-        //
-        // Returns a steering force to avoid a given obstacle.  The purely
-        // lateral steering force will turn our vehicle towards a silhouette edge
-        // of the obstacle.  Avoidance is required when (1) the obstacle
-        // intersects the vehicle's current path, (2) it is in front of the
-        // vehicle, and (3) is within minTimeToCollision seconds of travel at the
-        // vehicle's current velocity.  Returns a zero vector value (Vector3::ZERO)
-        // when no avoidance is required.
-
-
-        Vector3 steerToAvoidObstacle (const float minTimeToCollision,
-                                   const Obstacle&amp; obstacle);
-
-
-        // avoids all obstacles in an ObstacleGroup
-
-        Vector3 steerToAvoidObstacles (const float minTimeToCollision,
-                                    const ObstacleGroup&amp; obstacles);
-
-
-        // ------------------------------------------------------------------------
-        // Unaligned collision avoidance behavior: avoid colliding with other
-        // nearby vehicles moving in unconstrained directions.  Determine which
-        // (if any) other other vehicle we would collide with first, then steers
-        // to avoid the site of that potential collision.  Returns a steering
-        // force vector, which is zero length if there is no impending collision.
-
-
-        Vector3 steerToAvoidNeighbors (const float minTimeToCollision,
-                                    const AVGroup&amp; others);
-
-
-        // Given two vehicles, based on their current positions and velocities,
-        // determine the time until nearest approach
-        float predictNearestApproachTime (AbstractVehicle&amp; otherVehicle);
-
-        // Given the time until nearest approach (predictNearestApproachTime)
-        // determine position of each vehicle at that time, and the distance
-        // between them
-        float computeNearestApproachPositions (AbstractVehicle&amp; otherVehicle,
-                                               float time);
-
-
-        /// XXX globals only for the sake of graphical annotation
-        Vector3 hisPositionAtNearestApproach;
-        Vector3 ourPositionAtNearestApproach;
-
-
-        // ------------------------------------------------------------------------
-        // avoidance of &quot;close neighbors&quot; -- used only by steerToAvoidNeighbors
-        //
-        // XXX  Does a hard steer away from any other agent who comes withing a
-        // XXX  critical distance.  Ideally this should be replaced with a call
-        // XXX  to steerForSeparation.
-
-
-        Vector3 steerToAvoidCloseNeighbors (const float minSeparationDistance,
-                                         const AVGroup&amp; others);
-
-
-        // ------------------------------------------------------------------------
-        // used by boid behaviors
-
-
-        bool inBoidNeighborhood (const AbstractVehicle&amp; otherVehicle,
-                                 const float minDistance,
-                                 const float maxDistance,
-                                 const float cosMaxAngle);
-
-
-        // ------------------------------------------------------------------------
-        // Separation behavior -- determines the direction away from nearby boids
-
-
-        Vector3 steerForSeparation (const float maxDistance,
-                                 const float cosMaxAngle,
-                                 const AVGroup&amp; flock);
-
-
-        // ------------------------------------------------------------------------
-        // Alignment behavior
-
-        Vector3 steerForAlignment (const float maxDistance,
-                                const float cosMaxAngle,
-                                const AVGroup&amp; flock);
-
-
-        // ------------------------------------------------------------------------
-        // Cohesion behavior
-
-
-        Vector3 steerForCohesion (const float maxDistance,
-                               const float cosMaxAngle,
-                               const AVGroup&amp; flock);
-
-
-        // ------------------------------------------------------------------------
-        // pursuit of another vehicle (&amp; version with ceiling on prediction time)
-
-
-        Vector3 steerForPursuit (const AbstractVehicle&amp; quarry);
-
-        Vector3 steerForPursuit (const AbstractVehicle&amp; quarry,
-                              const float maxPredictionTime);
-
-        // for annotation
-        bool gaudyPursuitAnnotation;
-
-
-        // ------------------------------------------------------------------------
-        // evasion of another vehicle
-
-
-        Vector3 steerForEvasion (const AbstractVehicle&amp; menace,
-                              const float maxPredictionTime);
-
-
-        // ------------------------------------------------------------------------
-        // tries to maintain a given speed, returns a maxForce-clipped steering
-        // force along the forward/backward axis
-
-
-        Vector3 steerForTargetSpeed (const float targetSpeed);
-
-
-        // ----------------------------------------------------------- utilities
-        // XXX these belong somewhere besides the steering library
-        // XXX above AbstractVehicle, below SimpleVehicle
-        // XXX (&quot;utility vehicle&quot;?)
-
-        // xxx cwr experimental 9-9-02 -- names OK?
-        bool isAhead (const Vector3&amp; target) const {return isAhead (target, 0.707f);};
-        bool isAside (const Vector3&amp; target) const {return isAside (target, 0.707f);};
-        bool isBehind (const Vector3&amp; target) const {return isBehind (target, -0.707f);};
-
-        bool isAhead (const Vector3&amp; target, float cosThreshold) const
-        {
-            const Vector3 targetDirection = (target - getPosition()).normalisedCopy();
-            return getForward().dotProduct(targetDirection) &gt; cosThreshold;
-        };
-        bool isAside (const Vector3&amp; target, float cosThreshold) const
-        {
-            const Vector3 targetDirection = (target - getPosition()).normalisedCopy();
-            const float dp = getForward().dotProduct(targetDirection);
-            return (dp &lt; cosThreshold) &amp;&amp; (dp &gt; -cosThreshold);
-        };
-        bool isBehind (const Vector3&amp; target, float cosThreshold) const
-        {
-            const Vector3 targetDirection = (target - getPosition()).normalisedCopy();
-            return getForward().dotProduct(targetDirection) &lt; cosThreshold;
-        };
-
-
-        // ------------------------------------------------ graphical annotation
-        // (parameter names commented out to prevent compiler warning from &quot;-W&quot;)
-
-
-        // called when steerToAvoidObstacles decides steering is required
-        // (default action is to do nothing, layered classes can overload it)
-        virtual void annotateAvoidObstacle (const float /*minDistanceToCollision*/)
-        {
-        }
-
-        // called when steerToFollowPath decides steering is required
-        // (default action is to do nothing, layered classes can overload it)
-        virtual void annotatePathFollowing (const Vector3&amp; /*future*/,
-                                            const Vector3&amp; /*onPath*/,
-                                            const Vector3&amp; /*target*/,
-                                            const float /*outside*/)
-        {
-        }
-
-        // called when steerToAvoidCloseNeighbors decides steering is required
-        // (default action is to do nothing, layered classes can overload it)
-        virtual void annotateAvoidCloseNeighbor (const AbstractVehicle&amp; /*other*/,
-                                                 const float /*additionalDistance*/)
-        {
-        }
-
-        // called when steerToAvoidNeighbors decides steering is required
-        // (default action is to do nothing, layered classes can overload it)
-        virtual void annotateAvoidNeighbor (const AbstractVehicle&amp; /*threat*/,
-                                            const float /*steer*/,
-                                            const Vector3&amp; /*ourFuture*/,
-                                            const Vector3&amp; /*threatFuture*/)
-        {
-        }
-    };
-
-    
-} // namespace OpenSteer
-
-// ----------------------------------------------------------------------------
-
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerForWander (float dt)
-{
-    // random walk WanderSide and WanderUp between -1 and +1
-    const float speed = 12.0f * dt; // maybe this (12) should be an argument?
-    WanderSide = scalarRandomWalk (WanderSide, speed, -1, +1);
-    WanderUp   = scalarRandomWalk (WanderUp,   speed, -1, +1);
-
-    // return a pure lateral steering vector: (+/-Side) + (+/-Up)
-    return (getSide() * WanderSide) + (getUp() * WanderUp);
-}
-
-
-// ----------------------------------------------------------------------------
-// Seek behavior
-
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerForSeek (const Vector3&amp; target)
-{
-    const Vector3 desiredVelocity = target - getPosition();
-    return desiredVelocity - getVelocity();
-}
-
-
-// ----------------------------------------------------------------------------
-// Flee behavior
-
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerForFlee (const Vector3&amp; target)
-{
-    const Vector3 desiredVelocity = getPosition() - target;
-    return desiredVelocity - getVelocity();
-}
-
-
-// ----------------------------------------------------------------------------
-// xxx proposed, experimental new seek/flee [cwr 9-16-02]
-
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-xxxsteerForFlee (const Vector3&amp; target)
-{
-//  const Vector3 offset = position - target;
-    const Vector3 offset = getPosition() - target;
-    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, getMaxSpeed()); //xxxnew
-    return desiredVelocity - getVelocity();
-}
-
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-xxxsteerForSeek (const Vector3&amp; target)
-{
-//  const Vector3 offset = target - position;
-    const Vector3 offset = target - getPosition();
-    const Vector3 desiredVelocity = Vec3Utils::truncateLength(offset, getMaxSpeed()); //xxxnew
-    return desiredVelocity - getVelocity();
-}
-
-
-// ----------------------------------------------------------------------------
-// Path Following behaviors
-
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerToStayOnPath (const float predictionTime, Pathway&amp; path)
-{
-    // predict our future position
-    const Vector3 futurePosition = predictFuturePosition (predictionTime);
-
-    // find the point on the path nearest the predicted future position
-    Vector3 tangent;
-    float outside;
-    const Vector3 onPath = path.mapPointToPath (futurePosition,
-                                             tangent,     // output argument
-                                             outside);    // output argument
-
-    if (outside &lt; 0)
-    {
-        // our predicted future position was in the path,
-        // return zero steering.
-        return Vector3::ZERO;
-    }
-    else
-    {
-        // our predicted future position was outside the path, need to
-        // steer towards it.  Use onPath projection of futurePosition
-        // as seek target
-        annotatePathFollowing (futurePosition, onPath, onPath, outside);
-        return steerForSeek (onPath);
-    }
-}
-
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerToFollowPath (const int direction,
-                   const float predictionTime,
-                   Pathway&amp; path)
-{
-    // our goal will be offset from our path distance by this amount
-    const float pathDistanceOffset = direction * predictionTime * getSpeed();
-
-    // predict our future position
-    const Vector3 futurePosition = predictFuturePosition (predictionTime);
-
-    // measure distance along path of our current and predicted positions
-    const float nowPathDistance =
-        path.mapPointToPathDistance (getPosition());
-    const float futurePathDistance =
-        path.mapPointToPathDistance (futurePosition);
-
-    // are we facing in the correction direction?
-    const bool rightway = ((pathDistanceOffset &gt; 0) ?
-                           (nowPathDistance &lt; futurePathDistance) :
-                           (nowPathDistance &gt; futurePathDistance));
-
-    // find the point on the path nearest the predicted future position
-    // XXX need to improve calling sequence, maybe change to return a
-    // XXX special path-defined object which includes two Vec3s and a 
-    // XXX bool (onPath,tangent (ignored), withinPath)
-    Vector3 tangent;
-    float outside;
-    const Vector3 onPath = path.mapPointToPath (futurePosition,
-                                             // output arguments:
-                                             tangent,
-                                             outside);
-
-    // no steering is required if (a) our future position is inside
-    // the path tube and (b) we are facing in the correct direction
-    if ((outside &lt; 0) &amp;&amp; rightway)
-    {
-        // all is well, return zero steering
-        return Vector3::ZERO;
-    }
-    else
-    {
-        // otherwise we need to steer towards a target point obtained
-        // by adding pathDistanceOffset to our current path position
-
-        float const targetPathDistance = nowPathDistance + pathDistanceOffset;
-        Vector3 const target = path.mapPathDistanceToPoint (targetPathDistance);
-
-        annotatePathFollowing (futurePosition, onPath, target, outside);
-
-        // return steering to seek target on path
-        return steerForSeek (target);
-    }
-}
-
-
-// ----------------------------------------------------------------------------
-// Obstacle Avoidance behavior
-//
-// Returns a steering force to avoid a given obstacle.  The purely lateral
-// steering force will turn our vehicle towards a silhouette edge of the
-// obstacle.  Avoidance is required when (1) the obstacle intersects the
-// vehicle's current path, (2) it is in front of the vehicle, and (3) is
-// within minTimeToCollision seconds of travel at the vehicle's current
-// velocity.  Returns a zero vector value (Vector3::ZERO) when no avoidance is
-// required.
-//
-// XXX The current (4-23-03) scheme is to dump all the work on the various
-// XXX Obstacle classes, making them provide a &quot;steer vehicle to avoid me&quot;
-// XXX method.  This may well change.
-//
-// XXX 9-12-03: this routine is probably obsolete: its name is too close to
-// XXX the new steerToAvoidObstacles and the arguments are reversed
-// XXX (perhaps there should be another version of steerToAvoidObstacles
-// XXX whose second arg is &quot;const Obstacle&amp; obstacle&quot; just in case we want
-// XXX to avoid a non-grouped obstacle)
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerToAvoidObstacle (const float minTimeToCollision,
-                      const Obstacle&amp; obstacle)
-{
-    const Vector3 avoidance = obstacle.steerToAvoid (*this, minTimeToCollision);
-
-    // XXX more annotation modularity problems (assumes spherical obstacle)
-    if (avoidance != Vector3::ZERO)
-        annotateAvoidObstacle (minTimeToCollision * getSpeed());
-
-    return avoidance;
-}
-
-
-// this version avoids all of the obstacles in an ObstacleGroup
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerToAvoidObstacles (const float minTimeToCollision,
-                       const ObstacleGroup&amp; obstacles)
-{
-    const Vector3 avoidance = Obstacle::steerToAvoidObstacles (*this,
-                                                            minTimeToCollision,
-                                                            obstacles);
-
-    // XXX more annotation modularity problems (assumes spherical obstacle)
-    if (avoidance != Vector3::ZERO)
-        annotateAvoidObstacle (minTimeToCollision * getSpeed());
-
-    return avoidance;
-}
-
-
-// ----------------------------------------------------------------------------
-// Unaligned collision avoidance behavior: avoid colliding with other nearby
-// vehicles moving in unconstrained directions.  Determine which (if any)
-// other other vehicle we would collide with first, then steers to avoid the
-// site of that potential collision.  Returns a steering force vector, which
-// is zero length if there is no impending collision.
-
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerToAvoidNeighbors (const float minTimeToCollision,
-                       const AVGroup&amp; others)
-{
-    // first priority is to prevent immediate interpenetration
-    const Vector3 separation = steerToAvoidCloseNeighbors (0, others);
-    if (separation != Vector3::ZERO) return separation;
-
-    // otherwise, go on to consider potential future collisions
-    float steer = 0;
-    AbstractVehicle* threat = NULL;
-
-    // Time (in seconds) until the most immediate collision threat found
-    // so far.  Initial value is a threshold: don't look more than this
-    // many frames into the future.
-    float minTime = minTimeToCollision;
-
-    // xxx solely for annotation
-    Vector3 xxxThreatPositionAtNearestApproach;
-    Vector3 xxxOurPositionAtNearestApproach;
-
-    // for each of the other vehicles, determine which (if any)
-    // pose the most immediate threat of collision.
-    for (AVIterator i = others.begin(); i != others.end(); i++)
-    {
-        AbstractVehicle&amp; other = **i;
-        if (&amp;other != this)
-        {	
-            // avoid when future positions are this close (or less)
-            const float collisionDangerThreshold = getRadius() * 2;
-
-            // predicted time until nearest approach of &quot;this&quot; and &quot;other&quot;
-            const float time = predictNearestApproachTime (other);
-
-            // If the time is in the future, sooner than any other
-            // threatened collision...
-            if ((time &gt;= 0) &amp;&amp; (time &lt; minTime))
-            {
-                // if the two will be close enough to collide,
-                // make a note of it
-                if (computeNearestApproachPositions (other, time)
-                    &lt; collisionDangerThreshold)
-                {
-                    minTime = time;
-                    threat = &other;
-                    xxxThreatPositionAtNearestApproach
-                        = hisPositionAtNearestApproach;
-                    xxxOurPositionAtNearestApproach
-                        = ourPositionAtNearestApproach;
-                }
-            }
-        }
-    }
-
-    // if a potential collision was found, compute steering to avoid
-    if (threat != NULL)
-    {
-        // parallel: +1, perpendicular: 0, anti-parallel: -1
-        float parallelness = getForward().dotProduct(threat-&gt;getForward());
-        float angle = 0.707f;
-
-        if (parallelness &lt; -angle)
-        {
-            // anti-parallel &quot;head on&quot; paths:
-            // steer away from future threat position
-            Vector3 offset = xxxThreatPositionAtNearestApproach - getPosition();
-            float sideDot = offset.dotProduct(getSide());
-            steer = (sideDot &gt; 0) ? -1.0f : 1.0f;
-        }
-        else
-        {
-            if (parallelness &gt; angle)
-            {
-                // parallel paths: steer away from threat
-                Vector3 offset = threat-&gt;getPosition() - getPosition();
-                float sideDot = offset.dotProduct(getSide());
-                steer = (sideDot &gt; 0) ? -1.0f : 1.0f;
-            }
-            else
-            {
-                // perpendicular paths: steer behind threat
-                // (only the slower of the two does this)
-                if (threat-&gt;getSpeed() &lt;= getSpeed())
-                {
-                    float sideDot = getSide().dotProduct(threat-&gt;getVelocity());
-                    steer = (sideDot &gt; 0) ? -1.0f : 1.0f;
-                }
-            }
-        }
-
-        annotateAvoidNeighbor (*threat,
-                               steer,
-                               xxxOurPositionAtNearestApproach,
-                               xxxThreatPositionAtNearestApproach);
-    }
-
-    return getSide() * steer;
-}
-
-
-
-// Given two vehicles, based on their current positions and velocities,
-// determine the time until nearest approach
-//
-// XXX should this return zero if they are already in contact?
-
-template&lt;class Super&gt;
-float
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-predictNearestApproachTime (AbstractVehicle&amp; otherVehicle)
-{
-    // imagine we are at the origin with no velocity,
-    // compute the relative velocity of the other vehicle
-    const Vector3 myVelocity = getVelocity();
-    const Vector3 otherVelocity = otherVehicle.getVelocity();
-    const Vector3 relVelocity = otherVelocity - myVelocity;
-    const float relSpeed = relVelocity.length();
-
-    // for parallel paths, the vehicles will always be at the same distance,
-    // so return 0 (aka &quot;now&quot;) since &quot;there is no time like the present&quot;
-    if (relSpeed == 0) return 0;
-
-    // Now consider the path of the other vehicle in this relative
-    // space, a line defined by the relative position and velocity.
-    // The distance from the origin (our vehicle) to that line is
-    // the nearest approach.
-
-    // Take the unit tangent along the other vehicle's path
-    const Vector3 relTangent = relVelocity / relSpeed;
-
-    // find distance from its path to origin (compute offset from
-    // other to us, find length of projection onto path)
-    const Vector3 relPosition = getPosition() - otherVehicle.getPosition();
-    const float projection = relTangent.dotProduct(relPosition);
-
-    return projection / relSpeed;
-}
-
-
-// Given the time until nearest approach (predictNearestApproachTime)
-// determine position of each vehicle at that time, and the distance
-// between them
-
-
-template&lt;class Super&gt;
-float
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-computeNearestApproachPositions (AbstractVehicle&amp; otherVehicle,
-                                 float time)
-{
-    const Vector3    myTravel =       getForward() *       getSpeed() * time;
-    const Vector3 otherTravel = otherVehicle.getForward() * otherVehicle.getSpeed () * time;
-
-    const Vector3    myFinal =       getPosition() +    myTravel;
-    const Vector3 otherFinal = otherVehicle.getPosition() + otherTravel;
-
-    // xxx for annotation
-    ourPositionAtNearestApproach = myFinal;
-    hisPositionAtNearestApproach = otherFinal;
-
-    return myFinal.distance(otherFinal);
-}
-
-
-
-// ----------------------------------------------------------------------------
-// avoidance of &quot;close neighbors&quot; -- used only by steerToAvoidNeighbors
-//
-// XXX  Does a hard steer away from any other agent who comes withing a
-// XXX  critical distance.  Ideally this should be replaced with a call
-// XXX  to steerForSeparation.
-
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerToAvoidCloseNeighbors (const float minSeparationDistance,
-                            const AVGroup&amp; others)
-{
-    // for each of the other vehicles...
-    for (AVIterator i = others.begin(); i != others.end(); i++)    
-    {
-        AbstractVehicle&amp; other = **i;
-        if (&amp;other != this)
-        {
-            const float sumOfRadii = getRadius() + other.getRadius();
-            const float minCenterToCenter = minSeparationDistance + sumOfRadii;
-            const Vector3 offset = other.getPosition() - getPosition();
-            const float currentDistance = offset.length();
-
-            if (currentDistance &lt; minCenterToCenter)
-            {
-                annotateAvoidCloseNeighbor (other, minSeparationDistance);
-                return Vec3Utils::perpendicularComponent(-offset, getForward());
-            }
-        }
-    }
-
-    // otherwise return zero
-    return Vector3::ZERO;
-}
-
-
-// ----------------------------------------------------------------------------
-// used by boid behaviors: is a given vehicle within this boid's neighborhood?
-
-
-template&lt;class Super&gt;
-bool
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-inBoidNeighborhood (const AbstractVehicle&amp; otherVehicle,
-                    const float minDistance,
-                    const float maxDistance,
-                    const float cosMaxAngle)
-{
-    if (&amp;otherVehicle == this)
-    {
-        return false;
-    }
-    else
-    {
-        const Vector3 offset = otherVehicle.getPosition() - getPosition();
-        const float distanceSquared = offset.squaredLength();
-
-        // definitely in neighborhood if inside minDistance sphere
-        if (distanceSquared &lt; (minDistance * minDistance))
-        {
-            return true;
-        }
-        else
-        {
-            // definitely not in neighborhood if outside maxDistance sphere
-            if (distanceSquared &gt; (maxDistance * maxDistance))
-            {
-                return false;
-            }
-            else
-            {
-                // otherwise, test angular offset from forward axis
-                const Vector3 unitOffset = offset / sqrt (distanceSquared);
-                const float forwardness = getForward().dotProduct(unitOffset);
-                return forwardness &gt; cosMaxAngle;
-            }
-        }
-    }
-}
-
-
-// ----------------------------------------------------------------------------
-// Separation behavior: steer away from neighbors
-
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerForSeparation (const float maxDistance,
-                    const float cosMaxAngle,
-                    const AVGroup&amp; flock)
-{
-    // steering accumulator and count of neighbors, both initially zero
-    Vector3 steering;
-    int neighbors = 0;
-
-    // for each of the other vehicles...
-    AVIterator flockEndIter = flock.end();
-    for (AVIterator otherVehicle = flock.begin(); otherVehicle != flockEndIter; ++otherVehicle )
-    {
-        if (inBoidNeighborhood (**otherVehicle, getRadius()*3, maxDistance, cosMaxAngle))
-        {
-            // add in steering contribution
-            // (opposite of the offset direction, divided once by distance
-            // to normalize, divided another time to get 1/d falloff)
-            const Vector3 offset = (**otherVehicle).getPosition() - getPosition();
-            const float distanceSquared = offset.dotProduct(offset);
-            steering += (offset / -distanceSquared);
-
-            // count neighbors
-            ++neighbors;
-        }
-    }
-
-    // divide by neighbors, then normalize to pure direction
-    // bk: Why dividing if you normalize afterwards?
-    //     As long as normilization tests for @c 0 we can just call normalize
-    //     and safe the branching if.
-    /*
-    if (neighbors &gt; 0) {
-        steering /= neighbors;
-        steering = steering.normalisedCopy();
-    }
-    */
-    steering = steering.normalisedCopy();
-    
-    return steering;
-}
-
-
-// ----------------------------------------------------------------------------
-// Alignment behavior: steer to head in same direction as neighbors
-
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerForAlignment (const float maxDistance,
-                   const float cosMaxAngle,
-                   const AVGroup&amp; flock)
-{
-    // steering accumulator and count of neighbors, both initially zero
-    Vector3 steering;
-    int neighbors = 0;
-
-    // for each of the other vehicles...
-    for (AVIterator otherVehicle = flock.begin(); otherVehicle != flock.end(); otherVehicle++)
-    {
-        if (inBoidNeighborhood (**otherVehicle, getRadius()*3, maxDistance, cosMaxAngle))
-        {
-            // accumulate sum of neighbor's heading
-            steering += (**otherVehicle).getForward();
-
-            // count neighbors
-            neighbors++;
-        }
-    }
-
-    // divide by neighbors, subtract off current heading to get error-
-    // correcting direction, then normalize to pure direction
-    if (neighbors &gt; 0) steering = ((steering / (float)neighbors) - getForward()).normalisedCopy();
-
-    return steering;
-}
-
-
-// ----------------------------------------------------------------------------
-// Cohesion behavior: to to move toward center of neighbors
-
-
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerForCohesion (const float maxDistance,
-                  const float cosMaxAngle,
-                  const AVGroup&amp; flock)
-{
-    // steering accumulator and count of neighbors, both initially zero
-    Vector3 steering;
-    int neighbors = 0;
-
-    // for each of the other vehicles...
-    for (AVIterator otherVehicle = flock.begin(); otherVehicle != flock.end(); otherVehicle++)
-    {
-        if (inBoidNeighborhood (**otherVehicle, getRadius()*3, maxDistance, cosMaxAngle))
-        {
-            // accumulate sum of neighbor's positions
-            steering += (**otherVehicle).getPosition();
-
-            // count neighbors
-            neighbors++;
-        }
-    }
-
-    // divide by neighbors, subtract off current position to get error-
-    // correcting direction, then normalize to pure direction
-    if (neighbors &gt; 0) steering = ((steering / (float)neighbors) - getPosition()).normalisedCopy();
-
-    return steering;
-}
-
-
-// ----------------------------------------------------------------------------
-// pursuit of another vehicle (&amp; version with ceiling on prediction time)
-
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerForPursuit (const AbstractVehicle&amp; quarry)
-{
-    return steerForPursuit (quarry, FLT_MAX);
-}
-
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerForPursuit (const AbstractVehicle&amp; quarry,
-                 const float maxPredictionTime)
-{
-    // offset from this to quarry, that distance, unit vector toward quarry
-    const Vector3 offset = quarry.getPosition() - getPosition();
-    const float distance = offset.length ();
-    const Vector3 unitOffset = offset / distance;
-
-    // how parallel are the paths of &quot;this&quot; and the quarry
-    // (1 means parallel, 0 is pependicular, -1 is anti-parallel)
-    const float parallelness = getForward().dotProduct(quarry.getForward());
-
-    // how &quot;forward&quot; is the direction to the quarry
-    // (1 means dead ahead, 0 is directly to the side, -1 is straight back)
-    const float forwardness = getForward().dotProduct(unitOffset);
-
-    const float directTravelTime = distance / getSpeed();
-    const int f = intervalComparison (forwardness,  -0.707f, 0.707f);
-    const int p = intervalComparison (parallelness, -0.707f, 0.707f);
-
-    float timeFactor = 0; // to be filled in below
-    Color color;           // to be filled in below (xxx just for debugging)
-
-    // Break the pursuit into nine cases, the cross product of the
-    // quarry being [ahead, aside, or behind] us and heading
-    // [parallel, perpendicular, or anti-parallel] to us.
-    switch (f)
-    {
-    case +1:
-        switch (p)
-        {
-        case +1:          // ahead, parallel
-            timeFactor = 4;
-            color = gBlack;
-            break;
-        case 0:           // ahead, perpendicular
-            timeFactor = 1.8f;
-            color = gGray50;
-            break;
-        case -1:          // ahead, anti-parallel
-            timeFactor = 0.85f;
-            color = gWhite;
-            break;
-        }
-        break;
-    case 0:
-        switch (p)
-        {
-        case +1:          // aside, parallel
-            timeFactor = 1;
-            color = gRed;
-            break;
-        case 0:           // aside, perpendicular
-            timeFactor = 0.8f;
-            color = gYellow;
-            break;
-        case -1:          // aside, anti-parallel
-            timeFactor = 4;
-            color = gGreen;
-            break;
-        }
-        break;
-    case -1:
-        switch (p)
-        {
-        case +1:          // behind, parallel
-            timeFactor = 0.5f;
-            color= gCyan;
-            break;
-        case 0:           // behind, perpendicular
-            timeFactor = 2;
-            color= gBlue;
-            break;
-        case -1:          // behind, anti-parallel
-            timeFactor = 2;
-            color = gMagenta;
-            break;
-        }
-        break;
-    }
-
-    // estimated time until intercept of quarry
-    const float et = directTravelTime * timeFactor;
-
-    // xxx experiment, if kept, this limit should be an argument
-    const float etl = (et &gt; maxPredictionTime) ? maxPredictionTime : et;
-
-    // estimated position of quarry at intercept
-    const Vector3 target = quarry.predictFuturePosition (etl);
-
-    // annotation
-/*    annotationLine (getPosition(),
-                    target,
-                    gaudyPursuitAnnotation ? color : gGray40);
-*/
-    return steerForSeek (target);
-}
-
-// ----------------------------------------------------------------------------
-// evasion of another vehicle
-
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerForEvasion (const AbstractVehicle&amp; menace,
-                 const float maxPredictionTime)
-{
-    // offset from this to menace, that distance, unit vector toward menace
-    const Vector3 offset = menace.getPosition() - getPosition();
-    const float distance = offset.length ();
-
-    const float roughTime = distance / menace.getSpeed();
-    const float predictionTime = ((roughTime &gt; maxPredictionTime) ?
-                                  maxPredictionTime :
-                                  roughTime);
-
-    const Vector3 target = menace.predictFuturePosition(predictionTime);
-
-    return steerForFlee(target);
-}
-
-
-// ----------------------------------------------------------------------------
-// tries to maintain a given speed, returns a maxForce-clipped steering
-// force along the forward/backward axis
-
-
-template&lt;class Super&gt;
-Vector3
-OpenSteer::SteerLibraryMixin&lt;Super&gt;::
-steerForTargetSpeed (const float targetSpeed)
-{
-    const float mf = getMaxForce();
-    const float speedError = targetSpeed - getSpeed();
-    return getForward() * clip (speedError, -mf, +mf);
-}
-
-
-// ----------------------------------------------------------------------------
-#endif // OPENSTEER_STEERLIBRARY_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/SteerLibrary.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/SteerLibrary.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/UnusedParameter.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/UnusedParameter.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/UnusedParameter.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,47 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the &quot;Software&quot;),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// Macro to surpress warnings that parameters aren't used.
-//
-// May 09, 2005 bk:  created 
-//
-//
-// ----------------------------------------------------------------------------
-
-#ifndef OPENSTEER_UNUSEDPARAMETER_H
-#define OPENSTEER_UNUSEDPARAMETER_H
-
-/**
- * Macro to surpress warning that parameters aren't used.
- */
-#define OPENSTEER_UNUSED_PARAMETER(expr) (void)expr
-
-
-#endif // OPENSTEER_UNUSEDPARAMETER_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/UnusedParameter.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/UnusedParameter.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/Utilities.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Utilities.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/Utilities.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,514 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the &quot;Software&quot;),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// Utilities for OpenSteering
-//
-// 08-06-05 bk:  added functions to clamp values to a certain value range, to 
-//               compare values using a tolerance, and so on.
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 07-09-02 cwr: created 
-//
-//
-// ----------------------------------------------------------------------------
-
-
-#ifndef OPENSTEER_UTILITIES_H
-#define OPENSTEER_UTILITIES_H
-
-
-#include &lt;iostream&gt;  // for ostream, &lt;&lt;, etc.
-#include &lt;cstdlib&gt;   // for rand, etc.
-#include &lt;cfloat&gt;    // for FLT_MAX, etc.
-#include &lt;cmath&gt;     // for sqrt, etc.
-#include &lt;vector&gt;    // for std::vector
-#include &lt;cassert&gt;   // for assert
-#include &lt;limits&gt;    // for numeric_limits
-
-// ----------------------------------------------------------------------------
-// For the sake of Windows, apparently this is a &quot;Linux/Unix thing&quot;
-
-
-#ifndef OPENSTEER_M_PI
-#define OPENSTEER_M_PI 3.14159265358979323846f
-#endif
-
-#ifdef _MSC_VER
-#undef min
-#undef max
-#endif
-
-
-namespace OpenSteer {
-
-    // ----------------------------------------------------------------------------
-    // Generic interpolation
-
-
-    template&lt;class T&gt; inline T interpolate (float alpha, const T&amp; x0, const T&amp; x1)
-    {
-        return x0 + ((x1 - x0) * alpha);
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // Random number utilities
-
-
-    // Returns a float randomly distributed between 0 and 1
-
-    inline float frandom01 (void)
-    {
-        return (((float) rand ()) / ((float) RAND_MAX));
-    }
-
-
-    // Returns a float randomly distributed between lowerBound and upperBound
-
-    inline float frandom2 (float lowerBound, float upperBound)
-    {
-        return lowerBound + (frandom01 () * (upperBound - lowerBound));
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // Constrain a given value (x) to be between two (ordered) bounds: min
-    // and max.  Returns x if it is between the bounds, otherwise returns
-    // the nearer bound.
-
-
-    inline float clip (const float x, const float min, const float max)
-    {
-        if (x &lt; min) return min;
-        if (x &gt; max) return max;
-        return x;
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // remap a value specified relative to a pair of bounding values
-    // to the corresponding value relative to another pair of bounds.
-    // Inspired by (dyna:remap-interval y y0 y1 z0 z1)
-
-
-    inline float remapInterval (float x,
-                                float in0, float in1,
-                                float out0, float out1)
-    {
-        // uninterpolate: what is x relative to the interval in0:in1?
-        float relative = (x - in0) / (in1 - in0);
-
-        // now interpolate between output interval based on relative x
-        return interpolate (relative, out0, out1);
-    }
-
-
-    // Like remapInterval but the result is clipped to remain between
-    // out0 and out1
-
-
-    inline float remapIntervalClip (float x,
-                                    float in0, float in1,
-                                    float out0, float out1)
-    {
-        // uninterpolate: what is x relative to the interval in0:in1?
-        float relative = (x - in0) / (in1 - in0);
-
-        // now interpolate between output interval based on relative x
-        return interpolate (clip (relative, 0, 1), out0, out1);
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // classify a value relative to the interval between two bounds:
-    //     returns -1 when below the lower bound
-    //     returns  0 when between the bounds (inside the interval)
-    //     returns +1 when above the upper bound
-
-
-    inline int intervalComparison (float x, float lowerBound, float upperBound)
-    {
-        if (x &lt; lowerBound) return -1;
-        if (x &gt; upperBound) return +1;
-        return 0;
-    }
-
-
-
-    // ----------------------------------------------------------------------------
-
-
-    inline float scalarRandomWalk (const float initial, 
-                                   const float walkspeed,
-                                   const float min,
-                                   const float max)
-    {
-        const float next = initial + (((frandom01() * 2) - 1) * walkspeed);
-        if (next &lt; min) return min;
-        if (next &gt; max) return max;
-        return next;
-    }
-
-
-    // ----------------------------------------------------------------------------
-
-
-    inline float square (float x)
-    {
-        return x * x;
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // for debugging: prints one line with a given C expression, an equals sign,
-    // and the value of the expression.  For example &quot;angle = 35.6&quot;
-
-
-    #define debugPrint(e) (std::cout &lt;&lt; #e&quot; = &quot; &lt;&lt; (e) &lt;&lt; std::endl &lt;&lt; std::flush)
-
-
-    // ----------------------------------------------------------------------------
-    // blends new values into an accumulator to produce a smoothed time series
-    //
-    // Modifies its third argument, a reference to the float accumulator holding
-    // the &quot;smoothed time series.&quot;
-    //
-    // The first argument (smoothRate) is typically made proportional to &quot;dt&quot; the
-    // simulation time step.  If smoothRate is 0 the accumulator will not change,
-    // if smoothRate is 1 the accumulator will be set to the new value with no
-    // smoothing.  Useful values are &quot;near zero&quot;.
-    //
-    // Usage:
-    //         blendIntoAccumulator (dt * 0.4f, currentFPS, smoothedFPS);
-
-
-    template&lt;class T&gt;
-    inline void blendIntoAccumulator (const float smoothRate,
-                                      const T&amp; newValue,
-                                      T&amp; smoothedAccumulator)
-    {
-        smoothedAccumulator = interpolate (clip (smoothRate, 0, 1),
-                                           smoothedAccumulator,
-                                           newValue);
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // given a new Angle and an old angle, adjust the new for angle wraparound (the
-    // 0-&gt;360 flip), returning a value equivalent to newAngle, but closest in
-    // absolute value to oldAngle.  For radians fullCircle = OPENSTEER_M_PI*2, for degrees
-    // fullCircle = 360.  Based on code in stuart/bird/fish demo's camera.cc
-    //
-    // (not currently used)
-
-    /*
-      inline float distance1D (const float a, const float b)
-      {
-          const float d = a - b;
-          return (d &gt; 0) ? d : -d;
-      }
-
-
-      float adjustForAngleWraparound (float newAngle,
-                                      float oldAngle,
-                                      float fullCircle)
-      {
-          // adjust newAngle for angle wraparound: consider its current value (a)
-          // as well as the angle 2pi larger (b) and 2pi smaller (c).  Select the
-          // one closer (magnitude of difference) to the current value of oldAngle.
-          const float a = newAngle;
-          const float b = newAngle + fullCircle;
-          const float c = newAngle - fullCircle;
-          const float ad = distance1D (a, oldAngle);
-          const float bd = distance1D (b, oldAngle);
-          const float cd = distance1D (c, oldAngle);
-
-          if ((bd &lt; ad) &amp;&amp; (bd &lt; cd)) return b;
-          if ((cd &lt; ad) &amp;&amp; (cd &lt; bd)) return c;
-          return a;
-      }
-    */
-
-
-    // ----------------------------------------------------------------------------
-    // Functions to encapsulate cross-platform differences for several &lt;cmath&gt;
-    // functions.  Specifically, the C++ standard says that these functions are
-    // in the std namespace (std::sqrt, etc.)  Apparently the MS VC6 compiler (or
-    // its header files) do not implement this correctly and the function names
-    // are in the global namespace.  We hope these -XXX versions are a temporary
-    // expedient, to be removed later.
-
-
-    #ifdef _WIN32
-
-    inline float floorXXX (float x)          {return ::floor (x);}
-    inline float  sqrtXXX (float x)          {return ::sqrt (x);}
-    inline float   sinXXX (float x)          {return ::sin (x);}
-    inline float   cosXXX (float x)          {return ::cos (x);}
-    inline float   absXXX (float x)          {return ::abs (x);}
-    inline int     absXXX (int x)            {return ::abs (x);}
-    inline float   maxXXX (float x, float y) {if (x &gt; y) return x; else return y;}
-    inline float   minXXX (float x, float y) {if (x &lt; y) return x; else return y;}
-
-    #else
-
-    inline float floorXXX (float x)          {return std::floor (x);}
-    inline float  sqrtXXX (float x)          {return std::sqrt (x);}
-    inline float   sinXXX (float x)          {return std::sin (x);}
-    inline float   cosXXX (float x)          {return std::cos (x);}
-    inline float   absXXX (float x)          {return std::abs (x);}
-    inline int     absXXX (int x)            {return std::abs (x);}
-    inline float   maxXXX (float x, float y) {return std::max (x, y);}
-    inline float   minXXX (float x, float y) {return std::min (x, y);}
-
-    #endif
-
-
-    // ----------------------------------------------------------------------------
-    // round (x)  &quot;round off&quot; x to the nearest integer (as a float value)
-    //
-    // This is a Gnu-sanctioned(?) post-ANSI-Standard(?) extension (as in
-    // <A HREF="http://www.opengroup.org/onlinepubs/007904975/basedefs/math.h.html">http://www.opengroup.org/onlinepubs/007904975/basedefs/math.h.html</A>)
-    // which may not be present in all C++ environments.  It is defined in
-    // math.h headers in Linux and Mac OS X, but apparently not in Win32:
-
-
-    #ifdef _WIN32
-
-    inline float round (float x)
-    {
-      if (x &lt; 0)
-          return -floorXXX (0.5f - x);
-      else
-          return  floorXXX (0.5f + x);
-    }
-
-    #else 
-    
-    inline float round( float x )
-    {
-        return ::round( x );
-    }
-    
-    #endif
-
-    
-    /**
-     * Returns @a valueToClamp clamped to the range @a minValue - @a maxValue.
-     */
-    template&lt; typename T &gt;
-    T
-    clamp( T const&amp; valueToClamp, T const&amp; minValue, T const&amp; maxValue) {
-        assert( minValue &lt;= maxValue &amp;&amp; &quot;minValue must be lesser or equal to maxValue.&quot;  );
-        
-        if ( valueToClamp &lt; minValue ) {
-            return minValue;
-        } else if ( valueToClamp &gt; maxValue ) {
-            return maxValue;
-        }
-        
-        return valueToClamp;
-    }
-    
-    
-    /**
-     * Returns the floating point remainder of the division of @a x by @a y.
-     * If @a y is @c 0 the behavior is undefined.
-     */
-    inline float modulo( float x, float y ) {
-        assert( 0.0f != y &amp;&amp; &quot;Division by zero.&quot; );
-        return std::fmod( x, y );
-    }
-    
-    /**
-     * Returns the floating point remainder of the division of @a x by @a y.
-     * If @a y is @c 0 the behavior is undefined.
-     */
-    inline double modulo( double x, double y ) {
-        assert( 0.0 != y &amp;&amp; &quot;Division by zero.&quot; );
-        return std::fmod( x, y );
-    }    
-    
-    /**
-     * Returns the floating point remainder of the division of @a x by @a y.
-     * If @a y is @c 0 the behavior is undefined.
-     */
-    inline long double modulo( long double x, long double y ) {
-        assert( 0.0 != y &amp;&amp; &quot;Division by zero.&quot; );
-        return std::fmod( x, y );
-    }
-    
-    /**
-     * Returns the floating point remainder of the division of @a x by @a y.
-     * If @a y is @c 0 the behavior is undefined.
-     */
-    inline short modulo( short x, short y ) {
-        assert( 0 != y &amp;&amp; &quot;Division by zero.&quot; );
-        return x % y;
-    }
-    
-    /**
-     * Returns the floating point remainder of the division of @a x by @a y.
-     * If @a y is @c 0 the behavior is undefined.
-     */
-    inline int modulo( int x, int y ) {
-        assert( 0 != y &amp;&amp; &quot;Division by zero.&quot; );
-        return x % y;
-    }
-    
-    /**
-     * Returns the floating point remainder of the division of @a x by @a y.
-     * If @a y is @c 0 the behavior is undefined.
-     */
-    inline long modulo( long x, long y ) {
-        assert( 0 != y &amp;&amp; &quot;Division by zero.&quot; );
-        return x % y;
-    }
-    
-    
-    /**
-     * Returns &lt;code&gt;value&lt;/code&gt; if &lt;code&gt;value &gt;= 0 &lt;/code&gt;, otherwise
-     * &lt;code&gt;-value&lt;/code&gt;.
-     */
-    template&lt; typename T &gt;
-    T abs( T const&amp; value ) {
-        return absXXX( value );
-    }
-    
-    /**
-     * Returns the maximum of the three values @a v0, @a v1, and @a v2.
-     *
-     * @todo Write a unit test.
-     */
-    template&lt; typename T &gt;
-    T
-    max( T const&amp; v0, T const&amp; v1, T const&amp; v2 ) {
-        return maxXXX( v0, maxXXX( v1, v2 ) );
-    }
-    
-    
-    /**
-     * Returns the minimum of the three values @a v0, @a v1, and @a v2.
-     *
-     * @todo Write a unit test.
-     */
-    template&lt; typename T &gt;
-    T
-    min( T const&amp; v0, T const&amp; v1, T const&amp; v2 ) {
-        return minXXX( v0, minXXX( v1, v2 ) );
-    }
-    
-    
-    /**
-     * Compares the absolute value of @a v with @a tolerance.
-     *
-     * See Christer Ericson, Real-Time Collision Detection, Morgan Kaufmann, 
-     * 2005, pp. 441--443.
-     *
-     * @todo Write a unit test.
-     */
-    template&lt; typename T &gt;
-    bool
-    isZero( T const&amp; v, T const&amp; tolerance = std::numeric_limits&lt; T &gt;::epsilon() ) {
-        return abs( v ) &lt;= tolerance;
-    }
-    
-    
-    /**
-     * Compares @a lhs with @a rhs given a specific @a tolerance.
-     *
-     * @attention Adapt @a tolerance to the range of values of @a lhs and 
-     * @a rhs.
-     * See Christer Ericson, Real-Time Collision Detection, Morgan Kaufmann, 
-     * 2005, pp. 441--443.
-     *
-     * @return &lt;code&gt;abs( lhs - rhs ) &lt;= tolerance&lt;/code&gt;
-     *
-     * @todo Write a unit test.
-     */
-    template&lt; typename T &gt;
-    bool
-    equalsAbsolute( T const&amp; lhs, T const&amp; rhs, T const&amp; tolerance = std::numeric_limits&lt; T &gt;::epsilon()  ) {
-        return isZero( lhs - rhs, tolerance );
-    }
-    
-    
-    /**
-     * Compares @a lhs with @a rhs given a specific @a tolerance taking the 
-     * range of values into account.
-     *
-     * See Christer Ericson, Real-Time Collision Detection, Morgan Kaufmann, 
-     * 2005, pp. 441--443.
-     *
-     * @return &lt;code&gt;abs( lhs - rhs ) &lt;= tolerance * max( abs( lhs ), abs( rhs ), 1 )&lt;/code&gt;
-     *
-     * @todo Write a unit test.
-     */
-    template&lt; typename T &gt;
-    bool
-    equalsRelative( T const&amp; lhs, T const&amp; rhs, T const&amp; tolerance = std::numeric_limits&lt; T &gt;::epsilon()  ) {
-        return isZero( lhs - rhs, tolerance * max( abs( lhs ), abs( rhs ), T( 1 ) ) );
-    }
-    
-    
-    /**
-     * Approximately compares @a lhs with @a rhs given a specific @a tolerance  
-     * taking the range of values into account.
-     *
-     * See Christer Ericson, Real-Time Collision Detection, Morgan Kaufmann, 
-     * 2005, pp. 441--443.
-     *
-     * @return &lt;code&gt;abs( lhs - rhs ) &lt;= tolerance * ( abs( lhs ) + abs( rhs ) + 1 )&lt;/code&gt;
-     *
-     * @todo Write a unit test.
-     */
-    template&lt; typename T &gt;
-    bool
-    equalsRelativeApproximately( T const&amp; lhs, T const&amp; rhs, T const&amp; tolerance = std::numeric_limits&lt; T &gt;::epsilon()  ) {
-        return isZero( lhs - rhs, tolerance * ( abs( lhs ) + abs( rhs ) + T( 1 ) ) );
-    }    
-    
-    
-    /**
-     * Shrinks the capacity of a std::vector to fit its content.
-     *
-     * See Scott Meyer, Effective STL, Addison-Wesley, 2001, pp. 77--79.
-     */
-    template&lt; typename T &gt;
-    void shrinkToFit( std::vector&lt; T &gt;&amp; v ) {
-        std::vector&lt; T &gt;( v ).swap( v );
-    }
-    
-
-    
-} // namespace OpenSteer
-    
-    
-// ----------------------------------------------------------------------------
-#endif // OPENSTEER_UTILITIES_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/Utilities.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/Utilities.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Vec3.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,289 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the &quot;Software&quot;),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-// Vector3: OpenSteer's generic type for 3d vectors
-//
-// This file defines the class Vector3, which is used throughout OpenSteer to
-// manipulate 3d geometric data.  It includes standard vector operations (like
-// vector addition, subtraction, scale, dot, cross...) and more idiosyncratic
-// utility functions.
-//
-// When integrating OpenSteer into a preexisting 3d application, it may be
-// important to use the 3d vector type of that application.  In that case Vector3
-// can be changed to inherit from the preexisting application' vector type and
-// to match the interface used by OpenSteer to the interface provided by the
-// preexisting 3d vector type.
-//
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 03-26-03 cwr: created to replace for Hiranabe-san's execellent but larger
-//               vecmath package (<A HREF="http://objectclub.esm.co.jp/vecmath/">http://objectclub.esm.co.jp/vecmath/</A>)
-//
-// ----------------------------------------------------------------------------
-
-
-#ifndef OPENSTEER_Vector3_H
-#define OPENSTEER_Vector3_H
-
-
-#include &quot;OpenSteer/Utilities.h&quot;  // for interpolate, etc.
-#ifdef __APPLE__
-	#include &lt;Carbon/Carbon.h&gt;
-    #include &lt;Ogre/Ogre.h&gt;
-#else
-    #include &lt;Ogre.h&gt;
-#endif
-
-using Ogre::Vector3;
-
-namespace OpenSteer {
-
-    // ----------------------------------------------------------------------------
-    class Vec3Utils
-    {
-    public:
-        // return component of vector parallel to a unit basis vector
-        // (IMPORTANT NOTE: assumes &quot;basis&quot; has unit magnitude (length==1))
-
-        static Vector3 parallelComponent (const Vector3&amp; vector, const Vector3&amp; unitBasis)
-        {
-            const float projection = vector.dotProduct(unitBasis);
-            return unitBasis * projection;
-        }
-
-        // return component of vector perpendicular to a unit basis vector
-        // (IMPORTANT NOTE: assumes &quot;basis&quot; has unit magnitude (length==1))
-
-        static Vector3 perpendicularComponent (const Vector3&amp; vector, const Vector3&amp; unitBasis)
-        {
-            return vector - parallelComponent(vector, unitBasis);
-        }
-
-        // clamps the length of a given vector to maxLength.  If the vector is
-        // shorter its value is returned unaltered, if the vector is longer
-        // the value returned has length of maxLength and is paralle to the
-        // original input.
-
-        static Vector3 truncateLength (const Vector3&amp; vector, const float maxLength)
-        {
-            const float vecLength = vector.length();
-            if (vecLength &lt;= maxLength)
-                return vector;
-            else
-                return vector * (maxLength / vecLength);
-        }
-
-        // forces a 3d position onto the XZ (aka y=0) plane
-
-        static Vector3 setYtoZero (const Vector3&amp; vector)
-        {
-            return Vector3 (vector.x, 0, vector.z);
-        }
-
-        // rotate this vector about the global Y (up) axis by the given angle
-
-        static Vector3 rotateAboutGlobalY (const Vector3&amp; vector, float angle)
-        {
-            const float s = sinXXX (angle);
-            const float c = cosXXX (angle);
-            return Vector3 ((vector.x * c) + (vector.z * s),
-                         (vector.y),
-                         (vector.z * c) - (vector.x * s));
-        }
-
-        // version for caching sin/cos computation
-        static Vector3 rotateAboutGlobalY (const Vector3&amp; vector, float angle, float&amp; sin, float&amp; cos)
-        {
-            // is both are zero, they have not be initialized yet
-            if (sin==0 &amp;&amp; cos==0)
-            {
-                sin = sinXXX (angle);
-                cos = cosXXX (angle);
-            }
-            return Vector3 ((vector.x * cos) + (vector.z * sin),
-                         (vector.y),
-                         (vector.z * cos) - (vector.x * sin));
-        }
-
-        // if this position is outside sphere, push it back in by one diameter
-
-        static Vector3 sphericalWrapAround (const Vector3&amp; vector, const Vector3&amp; center, float radius)
-        {
-            const Vector3 offset = vector - center;
-            const float r = offset.length();
-            if (r &gt; radius)
-                return vector + ((offset/r) * radius * -2);
-            else
-                return vector;
-        }
-    };
-
-
-    // ----------------------------------------------------------------------------
-    // scalar times vector product (&quot;float * Vector3&quot;)
-
-
-    inline Vector3 operator* (float s, const Vector3&amp; v) {return v*s;}
-
-
-	// return cross product a x b
-	inline Vector3 crossProduct(const Vector3&amp; a, const Vector3&amp; b)
-	{
-		Vector3 result((a.y * b.z) - (a.z * b.y),
-					(a.z * b.x) - (a.x * b.z),
-					(a.x * b.y) - (a.y * b.x));
-		return result;
-	}
-
-    // ----------------------------------------------------------------------------
-    // Returns a position randomly distributed inside a sphere of unit radius
-    // centered at the origin.  Orientation will be random and length will range
-    // between 0 and 1
-
-
-    Vector3 RandomVectorInUnitRadiusSphere (void);
-
-
-    // ----------------------------------------------------------------------------
-    // Returns a position randomly distributed on a disk of unit radius
-    // on the XZ (Y=0) plane, centered at the origin.  Orientation will be
-    // random and length will range between 0 and 1
-
-
-    Vector3 randomVectorOnUnitRadiusXZDisk (void);
-
-
-    // ----------------------------------------------------------------------------
-    // Returns a position randomly distributed on the surface of a sphere
-    // of unit radius centered at the origin.  Orientation will be random
-    // and length will be 1
-
-
-    inline Vector3 RandomUnitVector (void)
-    {
-        return RandomVectorInUnitRadiusSphere().normalisedCopy();
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // Returns a position randomly distributed on a circle of unit radius
-    // on the XZ (Y=0) plane, centered at the origin.  Orientation will be
-    // random and length will be 1
-
-
-    inline Vector3 RandomUnitVectorOnXZPlane (void)
-    {
-        return Vec3Utils::setYtoZero(RandomVectorInUnitRadiusSphere()).normalisedCopy();
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // used by limitMaxDeviationAngle / limitMinDeviationAngle below
-
-
-    Vector3 vecLimitDeviationAngleUtility (const bool insideOrOutside,
-                                        const Vector3&amp; source,
-                                        const float cosineOfConeAngle,
-                                        const Vector3&amp; basis);
-
-
-    // ----------------------------------------------------------------------------
-    // Enforce an upper bound on the angle by which a given arbitrary vector
-    // diviates from a given reference direction (specified by a unit basis
-    // vector).  The effect is to clip the &quot;source&quot; vector to be inside a cone
-    // defined by the basis and an angle.
-
-
-    inline Vector3 limitMaxDeviationAngle (const Vector3&amp; source,
-                                        const float cosineOfConeAngle,
-                                        const Vector3&amp; basis)
-    {
-        return vecLimitDeviationAngleUtility (true, // force source INSIDE cone
-                                              source,
-                                              cosineOfConeAngle,
-                                              basis);
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // Enforce a lower bound on the angle by which a given arbitrary vector
-    // diviates from a given reference direction (specified by a unit basis
-    // vector).  The effect is to clip the &quot;source&quot; vector to be outside a cone
-    // defined by the basis and an angle.
-
-
-    inline Vector3 limitMinDeviationAngle (const Vector3&amp; source,
-                                        const float cosineOfConeAngle,
-                                        const Vector3&amp; basis)
-    {    
-        return vecLimitDeviationAngleUtility (false, // force source OUTSIDE cone
-                                              source,
-                                              cosineOfConeAngle,
-                                              basis);
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // Returns the distance between a point and a line.  The line is defined in
-    // terms of a point on the line (&quot;lineOrigin&quot;) and a UNIT vector parallel to
-    // the line (&quot;lineUnitTangent&quot;)
-
-
-    inline float distanceFromLine (const Vector3&amp; point,
-                                   const Vector3&amp; lineOrigin,
-                                   const Vector3&amp; lineUnitTangent)
-    {
-        const Vector3 offset = point - lineOrigin;
-        const Vector3 perp = Vec3Utils::perpendicularComponent(offset, lineUnitTangent);
-        return perp.length();
-    }
-
-
-    // ----------------------------------------------------------------------------
-    // given a vector, return a vector perpendicular to it (note that this
-    // arbitrarily selects one of the infinitude of perpendicular vectors)
-
-
-    Vector3 findPerpendicularIn3d (const Vector3&amp; direction);
-
-
-    // ----------------------------------------------------------------------------
-    // candidates for global utility functions
-    //
-    // dot
-    // cross
-    // length
-    // distance
-    // normalized
-
-    
-} // namespace OpenSteer
-    
-
-// ----------------------------------------------------------------------------
-#endif // OPENSTEER_Vector3_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/Vec3.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3Utilities.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/Vec3Utilities.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3Utilities.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,96 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the &quot;Software&quot;),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-// Utilities to work with Vector3.
-//
-// 05-12-05 bk:  Created based on code of PolylinePathway.
-//
-// ----------------------------------------------------------------------------
-
-#ifndef OPENSTEER_VEC3UTILITIES_H
-#define OPENSTEER_VEC3UTILITIES_H
-
-
-// Include Vector3
-#include &quot;OpenSteer/Vec3.h&quot;
-
-// Include OpenSteer::size_t
-#include &quot;OpenSteer/StandardTypes.h&quot;
-
-// Include OpenSteer::equalsRelative
-#include &quot;OpenSteer/Utilities.h&quot;
-
-
-
-namespace OpenSteer {
-
-    /**
-     * Returns the nearest point on the segment @a segmentPoint0 to 
-     * @a segmentPoint1 from @a point.
-     */
-    Vector3  nearestPointOnSegment( const Vector3&amp; point,
-                                            const Vector3&amp; segmentPoint0,
-                                            const Vector3&amp; segmentPoint1 );
-    
-    /**
-     * Computes minimum distance from @a point to the line segment defined by
-     * @a segmentPoint0 and @a segmentPoint1.
-     */
-    float pointToSegmentDistance( const Vector3&amp; point,
-                                  const Vector3&amp; segmentPoint0,
-                                  const Vector3&amp; segmentPoint1);
-        
-    /**
-     * Retuns distance between @a a and @a b.
-     */
-    inline float distance (const Vector3&amp; a, const Vector3&amp; b) {
-        return (a-b).length();
-    } 
-    
-    
-    /**
-     * Elementwise relative tolerance comparison of @a lhs and @a rhs taking
-     * the range of the elements into account.
-     *
-     * See Christer Ericson, Real-Time Collision Detection, Morgan Kaufmann, 
-     * 2005, pp. 441--443.
-     *
-     * @todo Rewrite using the stl or providing an own range based function.
-     */
-    inline
-    bool
-    equalsRelative( Vector3 const&amp; lhs, 
-                     Vector3 const&amp; rhs, 
-                     float const&amp; tolerance = std::numeric_limits&lt; float &gt;::epsilon()  ) {
-        return equalsRelative( lhs.x, rhs.x, tolerance ) &amp;&amp; equalsRelative( lhs.y, rhs.y ) &amp;&amp; equalsRelative( lhs.z, rhs.z );
-    }
-    
-} // namespace OpenSteer
-
-#endif // OPENSTEER_VEC3UTILITIES_H

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/Vec3Utilities.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/Vec3Utilities.h)

Deleted: rl/branches/persistence2/engine/ai/include/OpenSteer/lq.h
===================================================================
--- rl/trunk/engine/ai/include/OpenSteer/lq.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/OpenSteer/lq.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,323 +0,0 @@
-/*
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the &quot;Software&quot;),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-// ----------------------------------------------------------------------------
-*/
-
-/* ------------------------------------------------------------------ */
-/*                                                                    */
-/*                   Locality Query (LQ) Facility                     */
-/*                                                                    */
-/* ------------------------------------------------------------------ */
-/*
-
-    This utility is a spatial database which stores objects each of
-    which is associated with a 3d point (a location in a 3d space).
-    The points serve as the &quot;search key&quot; for the associated object.
-    It is intended to efficiently answer &quot;sphere inclusion&quot; queries,
-    also known as range queries: basically questions like:
-
-        Which objects are within a radius R of the location L?
-
-    In this context, &quot;efficiently&quot; means significantly faster than the
-    naive, brute force O(n) testing of all known points.  Additionally
-    it is assumed that the objects move along unpredictable paths, so
-    that extensive preprocessing (for example, constructing a Delaunay
-    triangulation of the point set) may not be practical.
-
-    The implementation is a &quot;bin lattice&quot;: a 3d rectangular array of
-    brick-shaped (rectangular parallelepipeds) regions of space.  Each
-    region is represented by a pointer to a (possibly empty) doubly-
-    linked list of objects.  All of these sub-bricks are the same
-    size.  All bricks are aligned with the global coordinate axes.
-
-    Terminology used here: the region of space associated with a bin
-    is called a sub-brick.  The collection of all sub-bricks is called
-    the super-brick.  The super-brick should be specified to surround
-    the region of space in which (almost) all the key-points will
-    exist.  If key-points move outside the super-brick everything will
-    continue to work, but without the speed advantage provided by the
-    spatial subdivision.  For more details about how to specify the
-    super-brick's position, size and subdivisions see lqCreateDatabase
-    below.
-
-    Overview of usage: an application using this facility would first
-    create a database with lqCreateDatabase.  For each client object
-    the application wants to put in the database it creates a
-    lqClientProxy and initializes it with lqInitClientProxy.  When a
-    client object moves, the application calls lqUpdateForNewLocation.
-    To perform a query lqMapOverAllObjectsInLocality is passed an
-    application-supplied call-back function to be applied to all
-    client objects in the locality.  See lqCallBackFunction below for
-    more detail.  The lqFindNearestNeighborWithinRadius function can
-    be used to find a single nearest neighbor using the database.
-
-    Note that &quot;locality query&quot; is also known as neighborhood query,
-    neighborhood search, near neighbor search, and range query.  For
-    additional information on this and related topics see:
-    <A HREF="http://www.red3d.com/cwr/boids/ips.html">http://www.red3d.com/cwr/boids/ips.html</A>
-
-    For some description and illustrations of this database in use,
-    see this paper: <A HREF="http://www.red3d.com/cwr/papers/2000/pip.html">http://www.red3d.com/cwr/papers/2000/pip.html</A>
-
-*/
-
-#ifndef	_lq_h
-#define	_lq_h
-
-#ifdef __cplusplus
-extern &quot;C&quot;
-{
-#endif
-
-
-/* ------------------------------------------------------------------ */
-/*                                                                    */
-/*                       Data types use by LQ                         */
-/*                                                                    */
-/* ------------------------------------------------------------------ */
-/* This structure represents the spatial database.  Typically one of
-   these would be created (by a call to lqCreateDatabase) for a given
-   application.  */
-
-
-typedef struct lqInternalDB lqDB;
-
-
-/* ------------------------------------------------------------------ */
-/* This structure is a proxy for (and contains a pointer to) a client
-   (application) object in the spatial database.  One of these exists
-   for each client object.  This might be included within the
-   structure of a client object, or could be allocated separately.  */
-
-
-typedef struct lqClientProxy
-{
-    /* previous object in this bin, or NULL */
-    struct lqClientProxy*  prev;
-
-    /* next object in this bin, or NULL */
-    struct lqClientProxy*  next;
-
-    /* bin ID (pointer to pointer to bin contents list) */
-    struct lqClientProxy** bin;
-
-    /* pointer to client object */
-    void* object;
-
-    /* the object's location (&quot;key point&quot;) used for spatial sorting */
-    float x;
-    float y;
-    float z;
-} lqClientProxy;
-
-
-/* ------------------------------------------------------------------ */
-/*                                                                    */
-/*                            Basic API                               */
-/*                                                                    */
-/* ------------------------------------------------------------------ */
-/* Allocate and initialize an LQ database, returns a pointer to it.
-   The application needs to call this before using the LQ facility.
-   The nine parameters define the properties of the &quot;super-brick&quot;:
-      (1) origin: coordinates of one corner of the super-brick, its
-          minimum x, y and z extent.
-      (2) size: the width, height and depth of the super-brick.
-      (3) the number of subdivisions (sub-bricks) along each axis.
-   This routine also allocates the bin array, and initialize its
-   contents. */
-
-
-lqDB* lqCreateDatabase (float originx, float originy, float originz,
-			float sizex,   float sizey,   float sizez,
-			int   divx,    int   divy,    int   divz);
-
-
-/* ------------------------------------------------------------------ */
-/* Deallocates the LQ database */
-
-
-void lqDeleteDatabase (lqDB*);
-
-
-/* ------------------------------------------------------------------ */
-/* The application needs to call this once on each lqClientProxy at
-   setup time to initialize its list pointers and associate the proxy
-   with its client object. */ 
-
-
-void lqInitClientProxy (lqClientProxy* proxy, void* clientObject);
-
-
-/* ------------------------------------------------------------------ */
-/* Call for each client object every time its location changes.  For
-   example, in an animation application, this would be called each
-   frame for every moving object.  */
-
-
-void lqUpdateForNewLocation (lqDB* lq, 
-			     lqClientProxy* object, 
-			     float x, float y, float z);
-
-
-/* ------------------------------------------------------------------ */
-/* Apply an application-specific function to all objects in a certain
-   locality.  The locality is specified as a sphere with a given
-   center and radius.  All objects whose location (key-point) is
-   within this sphere are identified and the function is applied to
-   them.  The application-supplied function takes three arguments:
-
-     (1) a void* pointer to an lqClientProxy's &quot;object&quot;.
-     (2) the square of the distance from the center of the search
-         locality sphere (x,y,z) to object's key-point.
-     (3) a void* pointer to the caller-supplied &quot;client query state&quot;
-         object -- typically NULL, but can be used to store state
-         between calls to the lqCallBackFunction.
-
-   This routine uses the LQ database to quickly reject any objects in
-   bins which do not overlap with the sphere of interest.  Incremental
-   calculation of index values is used to efficiently traverse the
-   bins of interest. */
-
-
-/* type for a pointer to a function used to map over client objects */
-typedef void (* lqCallBackFunction)  (void* clientObject,
-				      float distanceSquared,
-				      void* clientQueryState);
-
-
-void lqMapOverAllObjectsInLocality (lqDB* lq, 
-				    float x, float y, float z,
-				    float radius,
-				    lqCallBackFunction func,
-				    void* clientQueryState);
-
-
-/* ------------------------------------------------------------------ */
-/*                                                                    */
-/*                            Other API                               */
-/*                                                                    */
-/* ------------------------------------------------------------------ */
-/* Search the database to find the object whose key-point is nearest
-   to a given location yet within a given radius.  That is, it finds
-   the object (if any) within a given search sphere which is nearest
-   to the sphere's center.  The ignoreObject argument can be used to
-   exclude an object from consideration (or it can be NULL).  This is
-   useful when looking for the nearest neighbor of an object in the
-   database, since otherwise it would be its own nearest neighbor.
-   The function returns a void* pointer to the nearest object, or
-   NULL if none is found.  */
-
-
-void* lqFindNearestNeighborWithinRadius (lqDB* lq, 
-					 float x, float y, float z,
-					 float radius,
-					 void* ignoreObject);
-
-
-/* ------------------------------------------------------------------ */
-/* Adds a given client object to a given bin, linking it into the bin
-   contents list. */
-
-
-void lqAddToBin (lqClientProxy* object, lqClientProxy** bin);
-
-
-/* ------------------------------------------------------------------ */
-/* Removes a given client object from its current bin, unlinking it
-   from the bin contents list. */
-
-
-void lqRemoveFromBin (lqClientProxy* object);
-
-
-/* ------------------------------------------------------------------ */
-/* Given an LQ database object and the nine basic parameters: fill in
-   the object's slots, allocate the bin array, and initialize its
-   contents.  Normally the application does NOT call this directly, it
-   is called by lqCreateDatabase.  */
-
-
-void lqInitDatabase (lqDB* lq,
-		     float originx, float originy, float originz,
-		     float sizex, float sizey, float sizez,
-		     int divx, int divy, int divz);
-
-
-/* ------------------------------------------------------------------ */
-/* Find the bin ID for a location in space.  The location is given in
-   terms of its XYZ coordinates.  The bin ID is a pointer to a pointer
-   to the bin contents list.  */
-
-
-lqClientProxy** lqBinForLocation (lqDB* lq, float x, float y, float z);
-
-
-/* ------------------------------------------------------------------ */
-/* Apply a user-supplied function to all objects in the database,
-   regardless of locality (cf lqMapOverAllObjectsInLocality) */
-
-
-void lqMapOverAllObjects (lqDB* lq, 
-			  lqCallBackFunction func,
-			  void* clientQueryState);
-
-
-/* ------------------------------------------------------------------ */
-/* Removes (all proxies for) all objects from all bins */
-
-
-void lqRemoveAllObjects (lqDB* lq);
-
-
-/* ------------------------------------------------------------------ */
-/* Get statistics about bin populations: min, max and average of
-   non-empty bins. */
-
-
-#ifndef NO_LQ_BIN_STATS
-void lqGetBinPopulationStats (lqDB* lq,
-                              int* min,
-                              int* max,
-                              float* average);
-#endif /* NO_LQ_BIN_STATS */
-
-/* ------------------------------------------------------------------ */
-
-
-#ifndef	NULL
-#define NULL 0
-#endif
-
-
-/* ------------------------------------------------------------------ */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* _lq_h */

Copied: rl/branches/persistence2/engine/ai/include/OpenSteer/lq.h (from rev 4878, rl/trunk/engine/ai/include/OpenSteer/lq.h)

Modified: rl/branches/persistence2/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/branches/persistence2/engine/ai/include/SteeringVehicle.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/include/SteeringVehicle.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -131,6 +131,12 @@
 		 */
 		bool isAhead(Agent* agent, const float threshold);
 
+		/** tests if the specified position is within the threshold.
+		 * @param agent Agent to test against
+		 * @param threshold specifies maximum distance
+		 */
+		bool isAhead(const Vector3&amp; position, const float threshold);
+
 		/** tests if collision will happen within specified timeframe
 		 * @param minTimeToCollision minimum time to next collision
 		 */

Modified: rl/branches/persistence2/engine/ai/src/AgentCombatState.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/AgentCombatState.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/AgentCombatState.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -21,6 +21,7 @@
 #include &quot;CombatManager.h&quot;
 #include &quot;Creature.h&quot;
 #include &quot;CreatureControllerManager.h&quot;
+#include &quot;CreatureWalkPathJob.h&quot;
 
 namespace rl
 {
@@ -77,7 +78,8 @@
 
 	void AgentCombatState::update(const float elapsedTime)
     {
-        mAgent-&gt;updateVehicle(0, elapsedTime);
+        // we don't use the vehicle (combat uses GoToJob, the vehicle would change the movement and reset the animation!)
+        //mAgent-&gt;updateVehicle(0, elapsedTime);
     }
 
     class DistanceComparator
@@ -123,3 +125,4 @@
         return pos + 10 * oppositeDirection;
     }
 }
+

Modified: rl/branches/persistence2/engine/ai/src/AgentDialogState.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/AgentDialogState.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/AgentDialogState.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,83 +1,94 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#include &quot;stdinc.h&quot;
-#include &quot;AgentDialogState.h&quot;
-
-#include &quot;Agent.h&quot;
-#include &quot;AiMessages.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;CreatureController.h&quot;
-#include &quot;CreatureControllerManager.h&quot;
-#include &quot;MessagePump.h&quot;
-
-using namespace Ogre;
-
-namespace rl
-{
-
-    AgentDialogState::AgentDialogState(Agent* agent)
-        : AgentState(agent),
-        mPartner(NULL),
-        mTalking(false)
-    {
-    }
-
-    AgentDialogState::~AgentDialogState()
-    {
-    }
-
-    void AgentDialogState::setDialogPartner(Agent* partner)
-    {
-        mPartner = partner;
-    }
-
-    void AgentDialogState::setDialog(Dialog* dialog)
-    {
-        mDialog = dialog;
-    }
-
-    void AgentDialogState::update(const Ogre::Real elapsedTime)
-    {
-        CreatureController* ctrl = 
-                CreatureControllerManager::getSingleton().getCreatureController(
-                    mAgent-&gt;getControlledCreature());
-
-        if (mAgent-&gt;getPosition().squaredDistance(mPartner-&gt;getPosition()) &gt; 1.5
-            || !mAgent-&gt;isAhead(mPartner, 0.95))
-        {		
-            mAgent-&gt;addForce(mAgent-&gt;calcSeek(mPartner-&gt;getPosition()));
-            mAgent-&gt;updateVehicle(0, elapsedTime);
-        }
-		else
-        {
-			if (!mTalking)
-            {
-                mAgent-&gt;reset();
-                ctrl-&gt;setMovement(
-                    CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
-
-                ctrl-&gt;setAnimation(&quot;reden&quot;);
-				mTalking = true;
-
-                MessagePump::getSingleton().sendMessage&lt;MessageType_DialogStarted&gt;(mDialog);
-                
-                mAgent-&gt;popState();
-            }			
-        }
-
-    }
-} // namespace rl
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#include &quot;stdinc.h&quot;
+#include &quot;AgentDialogState.h&quot;
+
+#include &quot;Agent.h&quot;
+#include &quot;AiMessages.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;CreatureController.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
+#include &quot;MessagePump.h&quot;
+
+using namespace Ogre;
+
+namespace rl
+{
+
+    AgentDialogState::AgentDialogState(Agent* agent)
+        : AgentState(agent),
+        mTalking(false),
+        mDialog(NULL)
+    {
+    }
+
+    AgentDialogState::~AgentDialogState()
+    {
+    }
+
+    void AgentDialogState::addDialogPartner(Agent* partner)
+    {
+        mPartners.push_back(partner);
+    }
+
+    void AgentDialogState::setDialog(Dialog* dialog)
+    {
+        mDialog = dialog;
+    }
+
+    void AgentDialogState::update(const Ogre::Real elapsedTime)
+    {
+        CreatureController* ctrl = 
+                CreatureControllerManager::getSingleton().getCreatureController(
+                    mAgent-&gt;getControlledCreature());
+
+        Vector3 partnerPos(Vector3::ZERO);
+        if (!mPartners.empty())
+        {
+            for (std::list&lt;Agent*&gt;::iterator it = mPartners.begin(), end = mPartners.end(); it != end; ++it)
+            {
+                partnerPos += (*it)-&gt;getPosition();
+            }
+            partnerPos /= mPartners.size();
+        }
+
+        if (!mPartners.empty() &amp;&amp;
+            (mAgent-&gt;getPosition().squaredDistance(partnerPos) &gt; 1.5
+            || !mAgent-&gt;isAhead(partnerPos, 0.95)))
+        {		
+            mAgent-&gt;addForce(mAgent-&gt;calcSeek(partnerPos));
+            mAgent-&gt;updateVehicle(0, elapsedTime);
+        }
+		else
+        {
+			if (!mTalking &amp;&amp; mDialog)
+            {
+                mAgent-&gt;reset();
+                ctrl-&gt;setMovement(
+                    CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
+
+                ctrl-&gt;setAnimation(&quot;reden&quot;);
+				mTalking = true;
+
+                MessagePump::getSingleton().sendMessage&lt;MessageType_DialogStarted&gt;(mDialog);
+                
+                mAgent-&gt;popState();
+            }			
+        }
+
+    }
+} // namespace rl

Modified: rl/branches/persistence2/engine/ai/src/DialogLoaderImpl.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/DialogLoaderImpl.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/DialogLoaderImpl.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,15 +1,28 @@
-/*
- *  DialogLoaderImpl.cpp
- *  Rastullah
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
  *
- *  Created by Sascha Kolewa on 04.12.08.
- *  Copyright 2008 __MyCompanyName__. All rights reserved.
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
  *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
  */
 #include &quot;stdinc.h&quot;
 
 #include &lt;xercesc/dom/DOM.hpp&gt;
 
+#ifdef __APPLE__
+#   include &lt;CEGUI/CEGUIPropertyHelper.h&gt;
+#else
+#   include &lt;CEGUIPropertyHelper.h&gt;
+#endif
+
 #include &quot;DialogLoaderImpl.h&quot;
 
 #include &quot;ConfigurationManager.h&quot;
@@ -154,17 +167,22 @@
             }
             CeGuiString id = getAttributeValueAsString(dialogElemXml, &quot;id&quot;);
             CeGuiString text = getValueAsString(dialogElemXml);
+            CeGuiString person = &quot;&quot;;
+            if (hasAttribute(dialogElemXml, &quot;person&quot;))
+            {
+                person = getAttributeValueAsString(dialogElemXml, &quot;person&quot;);
+            }
 
             if (hasNodeName(dialogElemXml, &quot;switchoption&quot;))
             {
-                DialogOption* option = new DialogSelection&lt;DialogOption&gt;(id);
+                DialogOption* option = new DialogSelection&lt;DialogOption&gt;(id, person);
                 option-&gt;setLabel(text);
                 dialogPrototype-&gt;addOption(option);
             }
             else if (hasNodeName(dialogElemXml, &quot;option&quot;))
             {
                 bool isAutoSelected = getAttributeValueAsBool(dialogElemXml, &quot;autoSelect&quot;);
-                DialogOption* option = new DialogOption(id, isAutoSelected);
+                DialogOption* option = new DialogOption(id, person, isAutoSelected);
                 if (hasAttribute(dialogElemXml, &quot;label&quot;))
                 {
                     option-&gt;setLabel(getAttributeValueAsString(dialogElemXml, &quot;label&quot;));
@@ -177,11 +195,11 @@
             }
             else if (hasNodeName(dialogElemXml, &quot;response&quot;))
             {
-                dialogPrototype-&gt;addResponse(new DialogResponse(id));
+                dialogPrototype-&gt;addResponse(new DialogResponse(id, person));
             }
             else if (hasNodeName(dialogElemXml, &quot;switchresponse&quot;))
             {
-                dialogPrototype-&gt;addResponse(new DialogResponseSelection(id));
+                dialogPrototype-&gt;addResponse(new DialogResponseSelection(id, person));
             }
         }
 
@@ -331,6 +349,7 @@
         {
             option = processSwitchOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype);
         }
+
         return option;
     }
 
@@ -500,11 +519,16 @@
     DialogParagraph* DialogLoaderImpl::processParagraph(DOMElement* paragraphXml)
     {
         Ogre::String voicefile = &quot;&quot;;
+        CeGuiString person = &quot;&quot;;
         if (hasAttribute(paragraphXml, &quot;voicefile&quot;))
         {
             voicefile = getAttributeValueAsStdString(paragraphXml, &quot;voicefile&quot;);
         }
-        return new DialogParagraph(getValueAsString(paragraphXml), voicefile);
+        if (hasAttribute(paragraphXml, &quot;person&quot;))
+        {
+            person = getAttributeValueAsString(paragraphXml, &quot;person&quot;);
+        }
+        return new DialogParagraph(getValueAsString(paragraphXml), person, voicefile);
     }
 
     DialogCondition* DialogLoaderImpl::processCase(DOMElement *caseXml)
@@ -612,7 +636,7 @@
 
                 if (!isInParty)
                 {
-                    dialog-&gt;addParticipant(&quot;nsc&quot;, curCr);
+                    dialog-&gt;addParticipant(&quot;npc&quot;, curCr);
                     found1stNpc = true;
                 }
             }
@@ -653,7 +677,7 @@
         mParticipantFilter.push_back(participant);
     }
 
-    DialogLoaderImpl::DialogParticipant::DialogParticipant(const CeGuiString&amp; personId, int goId,
+    DialogLoaderImpl::DialogParticipant::DialogParticipant(const CeGuiString&amp; personId, const CeGuiString &amp;goId,
             const CeGuiString&amp; goClass, const CeGuiString&amp; name)
         : mPersonId(personId), mGoId(goId), mGoClass(goClass), mName(name)
     {
@@ -666,7 +690,7 @@
 
     bool DialogLoaderImpl::DialogParticipant::isMatching(Creature* creature) const
     {
-        return (mGoId == -1 || creature-&gt;getId() == mGoId)
+        return (mGoId == &quot;&quot; || creature-&gt;getId() == mGoId)
             &amp;&amp; (mGoClass.empty() || creature-&gt;getClassId() == mGoClass)
             &amp;&amp; (mName.empty() || creature-&gt;getName() == mName);
     }
@@ -816,7 +840,7 @@
     DialogLoaderImpl::DialogParticipant* DialogLoaderImpl::processPerson(DOMElement* personXml)
     {
         CeGuiString personId(&quot;&quot;), goClass(&quot;&quot;), name(&quot;&quot;);
-        int goId = -1;
+        CeGuiString goId;
 
         if (hasAttribute(personXml, &quot;id&quot;))
         {
@@ -827,13 +851,13 @@
             LOG_ERROR(&quot;DialogLoader&quot;, &quot;person node without id found&quot;);
         }
 
-        if (hasAttribute(personXml, &quot;goId&quot;))
+        if (hasAttribute(personXml, &quot;goid&quot;))
         {
-            goId = getAttributeValueAsInteger(personXml, &quot;goId&quot;);
+            goId = getAttributeValueAsString(personXml, &quot;goid&quot;);
         }
-        if (hasAttribute(personXml, &quot;goClass&quot;))
+        if (hasAttribute(personXml, &quot;goclass&quot;))
         {
-            goClass = getAttributeValueAsString(personXml, &quot;goClass&quot;);
+            goClass = getAttributeValueAsString(personXml, &quot;goclass&quot;);
         }
         if (hasAttribute(personXml, &quot;name&quot;))
         {

Modified: rl/branches/persistence2/engine/ai/src/DialogOption.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/DialogOption.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/DialogOption.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -22,8 +22,8 @@
 namespace rl
 {
 
-    DialogOption::DialogOption(const CeGuiString&amp; id, bool isAutoSelected)
-    : DialogElement(id), mPrecondition(NULL), mResponse(NULL), mLabel(&quot;&quot;), mIsAutoSelected(isAutoSelected)
+    DialogOption::DialogOption(const CeGuiString&amp; id, const CeGuiString&amp; person, bool autoSelected)
+    : DialogElement(id, person), mPrecondition(NULL), mResponse(NULL), mLabel(&quot;&quot;), mAutoSelected(autoSelected)
     {
     }
 
@@ -59,9 +59,14 @@
         return (mPrecondition != NULL);
     }
 
+    void DialogOption::setAutoSelected(bool autoSelected)
+    {
+        mAutoSelected = autoSelected;
+    }
+
     bool DialogOption::isAutoSelected() const
     {
-        return mIsAutoSelected;
+        return mAutoSelected;
     }
 
     bool DialogOption::isAvailable(Dialog* dialog) const

Modified: rl/branches/persistence2/engine/ai/src/DialogResponse.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/DialogResponse.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/DialogResponse.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -23,8 +23,8 @@
 
 namespace rl
 {
-	DialogResponse::DialogResponse(const CeGuiString&amp; id, int npcId)
-        : DialogElement(id), mNpcId(npcId)
+	DialogResponse::DialogResponse(const CeGuiString&amp; id, const CeGuiString&amp; person)
+        : DialogElement(id, person)
     {
     }
 
@@ -83,8 +83,8 @@
         return PERSON;
     }
 
-    DialogResponseSelection::DialogResponseSelection(const CeGuiString&amp; id)
-        : DialogSelection&lt;DialogResponse&gt;(id)
+    DialogResponseSelection::DialogResponseSelection(const CeGuiString&amp; id, const CeGuiString&amp; person)
+        : DialogSelection&lt;DialogResponse&gt;(id, person)
     {
     }
 

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer (from rev 4878, rl/trunk/engine/ai/src/OpenSteer)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/Color.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/Color.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/Color.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,262 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the &quot;Software&quot;),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-
-#include &quot;OpenSteer/Color.h&quot;
-
-// Include Vector3
-#include &quot;OpenSteer/Vec3.h&quot;
-
-// Include assert
-#include &lt;cassert&gt;
-
-
-OpenSteer::Color::Color()
-    : r_(1.0f), g_(1.0f), b_(1.0f), a_ (1.0f)
-{
-    
-}
-
-
-OpenSteer::Color::Color( float greyValue )
-    : r_( greyValue ), g_( greyValue ), b_( greyValue ), a_ (1.0f)
-{
-    
-}
-
-
-OpenSteer::Color::Color( float rValue, float gValue, float bValue, float aValue )
-    : r_( rValue ), g_( gValue ), b_( bValue ), a_( aValue )
-{
-    
-}
-
-
-OpenSteer::Color::Color( Vector3 const&amp; vector )
-    : r_( vector.x ), g_( vector.y ), b_( vector.z ), a_ (1.0f)
-{
-    
-}
-
-
-
-float 
-OpenSteer::Color::r() const
-{
-    return r_;
-}
-
-
-float 
-OpenSteer::Color::g() const
-{
-    return g_;
-}
-
-
-float 
-OpenSteer::Color::b() const
-{
-    return b_;
-}
-
-
-float 
-OpenSteer::Color::a() const
-{
-    return a_;
-}
-
-
-
-void 
-OpenSteer::Color::setR( float value )
-{
-    r_ = value;
-}
-
-
-void 
-OpenSteer::Color::setG( float value )
-{
-    g_ = value;
-}
-
-
-void 
-OpenSteer::Color::setB( float value )
-{
-    b_ = value;
-}
-
-void 
-OpenSteer::Color::setA( float value )
-{
-	a_ = value;
-}
-
-void
-OpenSteer::Color::set( float rValue, float gValue, float bValue, float aValue )
-{
-    r_ = rValue;
-    g_ = gValue;
-    b_ = bValue;
-	a_ = aValue;
-}
-
-
-Vector3 
-OpenSteer::Color::convertToVec3() const
-{
-    return Vector3( r_, g_, b_ );
-}
-
-
-OpenSteer::Color&amp; 
-OpenSteer::Color::operator+=( Color const&amp; other )
-{
-    r_ += other.r_;
-    g_ += other.g_;
-    b_ += other.b_;
-    return *this;
-}
-
-
-OpenSteer::Color&amp; 
-OpenSteer::Color::operator-=( Color const&amp; other )
-{
-    r_ -= other.r_;
-    g_ -= other.g_;
-    b_ -= other.b_;
-    return *this;    
-}
-
-
-OpenSteer::Color&amp; 
-OpenSteer::Color::operator*=( float factor )
-{
-    r_ *= factor;
-    g_ *= factor;
-    b_ *= factor;
-    return *this;    
-}
-
-
-OpenSteer::Color&amp; 
-OpenSteer::Color::operator/=( float factor )
-{
-    assert( 0.0f != factor &amp;&amp; &quot;Division by zero.&quot; );
-    return operator*=( 1.0f / factor );
-}
-
-
-
-
-
-
-OpenSteer::Color 
-OpenSteer::grayColor( float value )
-{
-    return Color( value );
-}
-
-
-
-OpenSteer::Color 
-OpenSteer::operator+( Color const&amp; lhs, Color const&amp; rhs )
-{
-    Color result( lhs );
-    return result += rhs;
-}
-
-
-OpenSteer::Color 
-OpenSteer::operator-( Color const&amp; lhs, Color const&amp; rhs )
-{
-    Color result( lhs );
-    return result -= rhs;    
-}
-
-
-OpenSteer::Color 
-OpenSteer::operator*( Color const&amp; lhs, float rhs )
-{
-    Color result( lhs );
-    return result *= rhs;
-}
-
-
-OpenSteer::Color 
-OpenSteer::operator*( float lhs, Color const&amp; rhs )
-{
-    return operator*( rhs, lhs );
-}
-
-
-OpenSteer::Color 
-OpenSteer::operator/( Color const&amp; lhs, float rhs )
-{
-    Color result( lhs );
-    return result /= rhs;
-}
-
-
-
-
-
-
-
-OpenSteer::Color const OpenSteer::gBlack(0.0f, 0.0f, 0.0f);
-OpenSteer::Color const OpenSteer::gWhite(1.0f, 1.0f, 1.0f);
-
-OpenSteer::Color const OpenSteer::gRed(1.0f, 0.0f, 0.0f); 
-OpenSteer::Color const OpenSteer::gGreen(0.0f, 1.0f, 0.0f);
-OpenSteer::Color const OpenSteer::gBlue(0.0f, 0.0f, 1.0f);
-OpenSteer::Color const OpenSteer::gYellow(1.0f, 1.0f, 0.0f);
-OpenSteer::Color const OpenSteer::gCyan(0.0f, 1.0f, 1.0f);
-OpenSteer::Color const OpenSteer::gMagenta(1.0f, 0.0f, 1.0f);
-OpenSteer::Color const OpenSteer::gOrange(1.0f, 0.5f, 0.0f);
-
-OpenSteer::Color const OpenSteer::gDarkRed(0.5f, 0.0f, 0.0f);
-OpenSteer::Color const OpenSteer::gDarkGreen(0.0f, 0.5f, 0.0f);
-OpenSteer::Color const OpenSteer::gDarkBlue(0.0f, 0.0f, 0.5f);
-OpenSteer::Color const OpenSteer::gDarkYellow(0.5f, 0.5f, 0.0f);
-OpenSteer::Color const OpenSteer::gDarkCyan(0.0f, 0.5f, 0.5f);
-OpenSteer::Color const OpenSteer::gDarkMagenta(0.5f, 0.0f, 0.5f);
-OpenSteer::Color const OpenSteer::gDarkOrange(0.5f, 0.25f, 0.0f);
-
-OpenSteer::Color const OpenSteer::gGray10(0.1f);
-OpenSteer::Color const OpenSteer::gGray20(0.2f);
-OpenSteer::Color const OpenSteer::gGray30(0.3f);
-OpenSteer::Color const OpenSteer::gGray40(0.4f);
-OpenSteer::Color const OpenSteer::gGray50(0.5f);
-OpenSteer::Color const OpenSteer::gGray60(0.6f);
-OpenSteer::Color const OpenSteer::gGray70(0.7f);
-OpenSteer::Color const OpenSteer::gGray80(0.8f);
-OpenSteer::Color const OpenSteer::gGray90(0.9f);
-

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/Color.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/Color.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/Obstacle.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/Obstacle.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/Obstacle.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,347 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2004, Sony Computer Entertainment America
-// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the &quot;Software&quot;),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer Obstacle classes
-// 
-// 10-28-04 cwr: split off from Obstacle.h 
-//
-//
-// ----------------------------------------------------------------------------
-
-
-#include &quot;OpenSteer/Obstacle.h&quot;
-
-
-// ----------------------------------------------------------------------------
-// Obstacle
-// compute steering for a vehicle to avoid this obstacle, if needed 
-
-
-Vector3 
-OpenSteer::Obstacle::steerToAvoid (const AbstractVehicle&amp; vehicle,
-                                   const float minTimeToCollision) const
-{
-    // find nearest intersection with this obstacle along vehicle's path
-    PathIntersection pi;
-    findIntersectionWithVehiclePath (vehicle, pi);
-
-    // return steering for vehicle to avoid intersection, or zero if non found
-    return pi.steerToAvoidIfNeeded (vehicle, minTimeToCollision);
-}
-
-
-// ----------------------------------------------------------------------------
-// Obstacle
-// static method to apply steerToAvoid to nearest obstacle in an ObstacleGroup
-
-
-Vector3
-OpenSteer::Obstacle::
-steerToAvoidObstacles (const AbstractVehicle&amp; vehicle,
-                       const float minTimeToCollision,
-                       const ObstacleGroup&amp; obstacles)
-{
-    PathIntersection nearest, next;
-
-    // test all obstacles in group for an intersection with the vehicle's
-    // future path, select the one whose point of intersection is nearest
-    firstPathIntersectionWithObstacleGroup (vehicle, obstacles, nearest, next);
-
-    // if nearby intersection found, steer away from it, otherwise no steering
-    return nearest.steerToAvoidIfNeeded (vehicle, minTimeToCollision);
-}
-
-
-// ----------------------------------------------------------------------------
-// Obstacle
-// static method to find first vehicle path intersection in an ObstacleGroup
-//
-// returns its results in the PathIntersection argument &quot;nearest&quot;,
-// &quot;next&quot; is used to store internal state.
-
-
-void
-OpenSteer::Obstacle::
-firstPathIntersectionWithObstacleGroup (const AbstractVehicle&amp; vehicle,
-                                        const ObstacleGroup&amp; obstacles,
-                                        PathIntersection&amp; nearest,
-                                        PathIntersection&amp; next)
-{
-    // test all obstacles in group for an intersection with the vehicle's
-    // future path, select the one whose point of intersection is nearest
-    next.intersect = false;
-    nearest.intersect = false;
-    ObstacleIterator o;
-    for (o = obstacles.begin(); o != obstacles.end(); o++)
-    {
-        // find nearest point (if any) where vehicle path intersects obstacle
-        // o, storing the results in PathIntersection object &quot;next&quot;
-        (**o).findIntersectionWithVehiclePath (vehicle, next);
-
-        // if this is the first intersection found, or it is the nearest found
-        // so far, store it in PathIntersection object &quot;nearest&quot;
-        const bool firstFound = !nearest.intersect;
-        const bool nearestFound = (next.intersect &amp;&amp;
-                                   (next.distance &lt; nearest.distance));
-        if (firstFound || nearestFound) nearest = next;
-    }
-}
-
-
-// ----------------------------------------------------------------------------
-// PathIntersection
-// determine steering once path intersections have been found
-
-
-Vector3 
-OpenSteer::Obstacle::PathIntersection::
-steerToAvoidIfNeeded (const AbstractVehicle&amp; vehicle,
-                      const float minTimeToCollision) const
-{
-    // if nearby intersection found, steer away from it, otherwise no steering
-    const float minDistanceToCollision = minTimeToCollision * vehicle.getSpeed();
-    if (intersect &amp;&amp; (distance &lt; minDistanceToCollision))
-    {
-        // compute avoidance steering force: take the component of
-        // steerHint which is lateral (perpendicular to vehicle's
-        // forward direction), set its length to vehicle's maxForce
-        Vector3 lateral = Vec3Utils::perpendicularComponent(steerHint, vehicle.getForward());
-        return lateral.normalisedCopy() * vehicle.getMaxForce();
-    }
-    else
-    {
-        return Vector3::ZERO;
-    }
-}
-
-
-// ----------------------------------------------------------------------------
-// SphereObstacle
-// find first intersection of a vehicle's path with this obstacle
-
-
-void 
-OpenSteer::
-SphereObstacle::
-findIntersectionWithVehiclePath (const AbstractVehicle&amp; vehicle,
-                                 PathIntersection&amp; pi) const
-{
-    // This routine is based on the Paul Bourke's derivation in:
-    //   Intersection of a Line and a Sphere (or circle)
-    //   <A HREF="http://www.swin.edu.au/astronomy/pbourke/geometry/sphereline/">http://www.swin.edu.au/astronomy/pbourke/geometry/sphereline/</A>
-    // But the computation is done in the vehicle's local space, so
-    // the line in question is the Z (Forward) axis of the space which
-    // simplifies some of the calculations.
-
-    float b, c, d, p, q, s;
-    Vector3 lc;
-
-    // initialize pathIntersection object to &quot;no intersection found&quot;
-    pi.intersect = false;
-
-    // find sphere's &quot;local center&quot; (lc) in the vehicle's coordinate space
-    lc = vehicle.localizePosition (center);
-
-    // compute line-sphere intersection parameters
-    const float r = radius + vehicle.getRadius();
-    b = -2 * lc.z;
-    c = square (lc.x) + square (lc.y) + square (lc.z) - square (r);
-    d = (b * b) - (4 * c);
-
-    // when the path does not intersect the sphere
-    if (d &lt; 0) return;
-
-    // otherwise, the path intersects the sphere in two points with
-    // parametric coordinates of &quot;p&quot; and &quot;q&quot;.  (If &quot;d&quot; is zero the two
-    // points are coincident, the path is tangent)
-    s = sqrtXXX (d);
-    p = (-b + s) / 2;
-    q = (-b - s) / 2;
-
-    // both intersections are behind us, so no potential collisions
-    if ((p &lt; 0) &amp;&amp; (q &lt; 0)) return; 
-
-    // at least one intersection is in front, so intersects our forward
-    // path
-    pi.intersect = true;
-    pi.obstacle = this;
-    pi.distance =
-        ((p &gt; 0) &amp;&amp; (q &gt; 0)) ?
-        // both intersections are in front of us, find nearest one
-        ((p &lt; q) ? p : q) :
-        // otherwise one is ahead and one is behind: we are INSIDE obstacle
-        (seenFrom () == outside ?
-         // inside a solid obstacle, so distance to obstacle is zero
-         0.0f :
-         // hollow obstacle (or &quot;both&quot;), pick point that is in front
-         ((p &gt; 0) ? p : q));
-    pi.surfacePoint =
-        vehicle.getPosition() + (vehicle.getForward() * pi.distance);
-    pi.surfaceNormal = (pi.surfacePoint-center).normalisedCopy();
-    // hmm, note that this was actually determined already in pi.distance calc
-    pi.vehicleOutside = lc.length () &gt; radius;
-    switch (seenFrom ())
-    {
-    case outside:
-        pi.steerHint = pi.surfaceNormal;
-        break;
-    case inside:
-        pi.steerHint = -pi.surfaceNormal;
-        break;
-    case both:
-        pi.steerHint = pi.surfaceNormal * (pi.vehicleOutside ? 1.0f : -1.0f);
-        break;
-    }
-}
-
-
-// ----------------------------------------------------------------------------
-// BoxObstacle
-// find first intersection of a vehicle's path with this obstacle
-
-
-void 
-OpenSteer::
-BoxObstacle::
-findIntersectionWithVehiclePath (const AbstractVehicle&amp; vehicle,
-                                 PathIntersection&amp; pi) const
-{
-    // abbreviations
-    const float w = width; // dimensions
-    const float h = height;
-    const float d = depth;
-    const Vector3 s = getSide(); // local space
-    const Vector3 u = getUp();
-    const Vector3 f = getForward();
-    const Vector3 p = getPosition();
-    const Vector3 hw = s * (0.5f * width); // offsets for face centers
-    const Vector3 hh = u * (0.5f * height);
-    const Vector3 hd = f * (0.5f * depth);
-    const seenFromState sf = seenFrom ();
-
-    // the box's six rectangular faces
-    RectangleObstacle r1 (w, h,  s,  u,  f, p + hd, sf); // front
-    RectangleObstacle r2 (w, h, -s,  u, -f, p - hd, sf); // back
-    RectangleObstacle r3 (d, h, -f,  u,  s, p + hw, sf); // side
-    RectangleObstacle r4 (d, h,  f,  u, -s, p - hw, sf); // other side
-    RectangleObstacle r5 (w, d,  s, -f,  u, p + hh, sf); // top
-    RectangleObstacle r6 (w, d, -s, -f, -u, p - hh, sf); // bottom
-
-    // group the six RectangleObstacle faces together
-    ObstacleGroup faces;
-    faces.push_back (&amp;r1);
-    faces.push_back (&amp;r2);
-    faces.push_back (&amp;r3);
-    faces.push_back (&amp;r4);
-    faces.push_back (&amp;r5);
-    faces.push_back (&amp;r6);
-
-    // find first intersection of vehicle path with group of six faces
-    PathIntersection next;
-    firstPathIntersectionWithObstacleGroup (vehicle, faces, pi, next);
-
-    // when intersection found, adjust PathIntersection for the box case
-    if (pi.intersect)
-    {
-        pi.obstacle = this;
-        pi.steerHint = ((pi.surfacePoint - getPosition()).normalisedCopy() *
-                        (pi.vehicleOutside ? 1.0f : -1.0f));
-    }
-}
-
-
-// ----------------------------------------------------------------------------
-// PlaneObstacle
-// find first intersection of a vehicle's path with this obstacle
-
-
-void 
-OpenSteer::
-PlaneObstacle::
-findIntersectionWithVehiclePath (const AbstractVehicle&amp; vehicle,
-                                 PathIntersection&amp; pi) const
-{
-    // initialize pathIntersection object to &quot;no intersection found&quot;
-    pi.intersect = false;
-
-    const Vector3 lp =  localizePosition (vehicle.getPosition());
-    const Vector3 ld = localizeDirection (vehicle.getForward());
-
-    // no obstacle intersection if path is parallel to XY (side/up) plane
-    if (ld.dotProduct(Vector3::NEGATIVE_UNIT_Z) == 0.0f) return;
-
-    // no obstacle intersection if vehicle is heading away from the XY plane
-    if ((lp.z &gt; 0.0f) &amp;&amp; (ld.z &gt; 0.0f)) return;
-    if ((lp.z &lt; 0.0f) &amp;&amp; (ld.z &lt; 0.0f)) return;
-
-    // no obstacle intersection if obstacle &quot;not seen&quot; from vehicle's side
-    if ((seenFrom () == outside) &amp;&amp; (lp.z &lt; 0.0f)) return;
-    if ((seenFrom () == inside)  &amp;&amp; (lp.z &gt; 0.0f)) return;
-
-    // find intersection of path with rectangle's plane (XY plane)
-    const float ix = lp.x - (ld.x * lp.z / ld.z);
-    const float iy = lp.y - (ld.y * lp.z / ld.z);
-    const Vector3 planeIntersection (ix, iy, 0.0f);
-
-    // no obstacle intersection if plane intersection is outside 2d shape
-    if (!xyPointInsideShape (planeIntersection, vehicle.getRadius())) return;
-
-    // otherwise, the vehicle path DOES intersect this rectangle
-    const Vector3 localXYradial = planeIntersection.normalisedCopy();
-    const Vector3 radial = globalizeDirection (localXYradial);
-    const float sideSign = (lp.z &gt; 0.0f) ? +1.0f : -1.0f;
-    const Vector3 opposingNormal = getForward() * sideSign;
-    pi.intersect = true;
-    pi.obstacle = this;
-    pi.distance = (lp - planeIntersection).length ();
-    pi.steerHint = opposingNormal + radial; // should have &quot;toward edge&quot; term?
-    pi.surfacePoint = globalizePosition (planeIntersection);
-    pi.surfaceNormal = opposingNormal;
-    pi.vehicleOutside = lp.z &gt; 0.0f;
-}
-
-
-// ----------------------------------------------------------------------------
-// RectangleObstacle
-// determines if a given point on XY plane is inside obstacle shape
-
-
-bool 
-OpenSteer::
-RectangleObstacle::
-xyPointInsideShape (const Vector3&amp; point, float radius) const
-{
-    const float w = radius + (width * 0.5f);
-    const float h = radius + (height * 0.5f);
-    return !((point.x &gt;  w) || (point.x &lt; -w) || (point.y &gt;  h) || (point.y &lt; -h));
-}
-
-
-// ----------------------------------------------------------------------------

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/Obstacle.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/Obstacle.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/Path.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/Path.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/Path.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,40 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
- */
-#include &quot;OpenSteer/Path.h&quot;
-
-OpenSteer::Path::~Path()
-{
-    // Nothing to do.
-}
-
-/*
-OpenSteer::Path&amp; OpenSteer::Path::operator=( Path const&amp; )
-{
-    return *this;
-}
-*/

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/Path.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/Path.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/Pathway.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/Pathway.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/Pathway.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,40 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
- */
-#include &quot;OpenSteer/Pathway.h&quot;
-
-OpenSteer::Pathway::~Pathway()
-{
-    // Nothing to do.
-}
-
-/*
-OpenSteer::Pathway&amp; OpenSteer::Pathway::operator=( Pathway const&amp; )
-{
-    return *this;
-}
-*/

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/Pathway.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/Pathway.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,556 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
- */
-#include &quot;OpenSteer/PolylineSegmentedPath.h&quot;
-
-// Include std::accumulate
-#include &lt;numeric&gt;
-
-// Include std::swap, std::adjacent_find
-#include &lt;algorithm&gt;
-
-// Include assert
-#include &lt;cassert&gt;
-
-
-
-// Include Vector3
-#include &quot;OpenSteer/Vec3.h&quot;
-
-// Include OpenSteer::mapPointToPathway, OpenSteer::mapDistanceToPointOnPathCenterLine
-#include &quot;OpenSteer/QueryPathAlike.h&quot;
-
-// Include OpenSteer::PointToPathMapping, OpenSteer::PathDistanceToPointMapping, OpenSteer::PointToPathDistanceMapping
-#include &quot;OpenSteer/QueryPathAlikeMappings.h&quot;
-
-// Include OpenSteer::HasNoRadius
-#include &quot;OpenSteer/QueryPathAlikeUtilities.h&quot;
-
-// Include OpenSteer::clamp, OpenSteer::shrinkToFit
-#include &quot;OpenSteer/Utilities.h&quot;
-
-
-
-namespace {
-    
-    typedef OpenSteer::SegmentedPath::size_type size_type;
-    typedef std::vector&lt; Vector3 &gt; Vec3Container;
-    typedef std::vector&lt; float &gt; FloatContainer;
-    
-    /**
-     * Recalculates the segment tangent and length for segment @a segmentIndex.
-     *
-     * @attention @a segmentTangents and @a segmentLengths must have the right
-     *            size.
-     */
-    void
-    updateSegmentTangentAndLength( size_type segmentIndex,
-                                   Vec3Container const&amp; points , 
-                                   Vec3Container&amp; segmentTangents, 
-                                   FloatContainer&amp; segmentLengths ) 
-    {
-        assert( ( ( segmentIndex + 1 ) &lt; points.size() ) &amp;&amp; 
-                &quot;Not enough points for segment segmentIndex.&quot; );
-        assert( segmentIndex &lt; segmentTangents.size() &amp;&amp;
-                &quot;segmentIndex out of range.&quot; );
-        assert( segmentTangents.size() == segmentLengths.size() &amp;&amp; &quot;segmentTangents and segmentLengths must have the same size.&quot; );
-        
-        Vector3 tangent = points[ segmentIndex + 1 ] - points[ segmentIndex ];
-        float const length = tangent.length();
-        assert( ! OpenSteer::isZero( length ) &amp;&amp; 
-                &quot;Segments must have lengths greater than 0.&quot; );
-        
-        tangent /= length;
-        
-        segmentTangents[ segmentIndex ] = tangent;
-        segmentLengths[ segmentIndex] = length;        
-    }
-    
-    
-    /**
-     * Helper function to calucate the segment tangent and lengths
-     * in the given range.
-     *
-     * @param points points defining the path.
-     * @param segmentTangents container to store the calculated segment 
-     *                        tangents. Must have the right size.
-     * @param segmentLengths container to store the calculated segment lengths.
-     *                       Must have the right size.
-     * @param firstChangedPointIndex the first point that changed. Segments have 
-     *        to be updated starting with it.
-     * @param numOfPoints number of points that changed beginning with 
-     *        @a startIndex.
-     * @param isCyclic Is the path cyclic or not.
-     *
-     */
-    void 
-    updateTangentsAndLengths( Vec3Container const&amp; points , 
-                              Vec3Container&amp; segmentTangents, 
-                              FloatContainer&amp; segmentLengths, 
-                              size_type firstChangedPointIndex, 
-                              size_type numOfPoints,
-                              bool isCyclic )
-    {
-        assert( 0 &lt; numOfPoints &amp;&amp; &quot;Only call if points have really changed.&quot; );
-        assert( 1 &lt; points.size() &amp;&amp; &quot;Two points are needed for a segment.&quot; );
-        assert( points.size() == segmentTangents.size() + 1 &amp;&amp; 
-                &quot;Two points are needed for one segment, therefore there must be one segment less than points.&quot; );
-        assert( segmentTangents.size() == segmentLengths.size() &amp;&amp; &quot;segmentTangents and segmentLengths must have the same size.&quot; );
-        // Other assertions aren't tested because the function should only be
-        // called by other functions that guarantee correctness of the 
-        // parameters.
-        
-        
-        // The segment with end point @a firstChangedPointIndex has also 
-        // changed. Beware from range underflow by subtraction.      
-        size_type firstSegmentIndex = firstChangedPointIndex;
-        if ( 0 &lt; firstSegmentIndex ) {
-            firstSegmentIndex -= 1;
-        }
-        
-        // The last segment to update has the last changed point as its start
-        // point. This only holds true if the last changed point isn't the last
-        // point.
-        // lastSegmentIndex is one greater than the real last segment to update
-        // like the last iterators in the stl.
-        size_type lastSegmentIndex = firstChangedPointIndex + numOfPoints;
-        lastSegmentIndex = OpenSteer::clamp( lastSegmentIndex, static_cast&lt; size_t &gt;( 0 ), segmentTangents.size() );
-        
-        for ( size_type i = firstSegmentIndex; i &lt; lastSegmentIndex; ++i ) {
-            updateSegmentTangentAndLength( i, points, segmentTangents, segmentLengths );
-        }
-        
-        // If path is cyclic and the first point changed and the cycle closing
-        // segment hasn't been updated update it now.
-        if ( isCyclic &amp;&amp; 
-             ( 0 == firstSegmentIndex ) &amp;&amp; 
-             ! ( lastSegmentIndex == segmentTangents.size() ) ) {
-            
-            updateSegmentTangentAndLength( segmentTangents.size() - 1, 
-                                           points, 
-                                           segmentTangents, 
-                                           segmentLengths );
-        }
-        
-    }
-    
-    
-    /**
-     * Checks that no adjacent points are equal. Checks the first and last
-     * point if the path is cyclic, too.
-     */
-    template&lt; typename Iterator &gt;
-    bool adjacentPathPointsDifferent( Iterator first, Iterator last, bool closedCycle  ) {
-        
-        assert( last - first &gt; 1 &amp;&amp; &quot;A path needs at least two waypoints.&quot; );
-        
-        if ( last != std::adjacent_find( first, last ) ) {
-            return false;
-        }
-    
-        if ( closedCycle ) {
-            Iterator before_last( first );
-            std::advance( before_last, last - first - 1  );
-            
-            return *first == *before_last;
-        }
-        
-        return true;
-    }
-    
-    
-        
-} // anonymous namespace
-
-
-
-
-
-
-
-OpenSteer::PolylineSegmentedPath::PolylineSegmentedPath()
-    : points_( 0 ), segmentTangents_( 0 ), segmentLengths_( 0 ), closedCycle_( false )
-{
-    
-}
-
-
-OpenSteer::PolylineSegmentedPath::PolylineSegmentedPath( size_type numOfPoints,
-                                                         Vector3 const newPoints[],
-                                                         bool closedCycle )
-    : points_( 0 ), segmentTangents_( 0 ), segmentLengths_( 0 ), closedCycle_( closedCycle )
-{
-        setPath( numOfPoints, newPoints, closedCycle );
-}
-
-OpenSteer::PolylineSegmentedPath::PolylineSegmentedPath( const PathPoints&amp; newPoints,
-                                                         bool closedCycle )
-    : points_( 0 ), segmentTangents_( 0 ), segmentLengths_( 0 ), closedCycle_( closedCycle )
-{
-        setPath( newPoints, closedCycle );
-}
-
-OpenSteer::PolylineSegmentedPath::PolylineSegmentedPath( PolylineSegmentedPath const&amp; other )
-    : SegmentedPath( other ), points_( other.points_ ), segmentTangents_( other.segmentTangents_ ), segmentLengths_( other.segmentLengths_ ), closedCycle_( other.closedCycle_ )
-{
-    // Nothing to do.
-}
-
-
-
-OpenSteer::PolylineSegmentedPath::~PolylineSegmentedPath()
-{
-    // Nothing to do.
-}
-
-
-
-OpenSteer::PolylineSegmentedPath&amp; 
-OpenSteer::PolylineSegmentedPath::operator=( PolylineSegmentedPath other )
-{
-    swap( other ); 
-    return *this;
-}
-
-
-
-void 
-OpenSteer::PolylineSegmentedPath::swap( PolylineSegmentedPath&amp; other )
-{
-    points_.swap( other.points_ );
-    segmentTangents_.swap( other.segmentTangents_ );
-    segmentLengths_.swap( other.segmentLengths_ );
-    std::swap( closedCycle_, other.closedCycle_ );
-}
-
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPath::setPath( size_type numOfPoints,
-                                           Vector3 const newPoints[],
-                                           bool closedCycle )
-{
-    assert( 1 &lt; numOfPoints &amp;&amp; &quot;Path must have at least two distinct points.&quot; );
-    // While testing say that no cyclus is used because the first point hasn't 
-    // been copied to the back.
-    assert( adjacentPathPointsDifferent( newPoints, newPoints + numOfPoints, false ) &amp;&amp; &quot;Adjacent path points must be different.&quot; );
-    
-    closedCycle_ = closedCycle;
-    
-    size_type numberOfPoints = numOfPoints;
-    if ( closedCycle_ ) {
-        ++numberOfPoints;
-    }
-    
-    points_.reserve( numberOfPoints );
-    segmentTangents_.resize( numberOfPoints - 1 );
-    segmentLengths_.resize( numberOfPoints - 1 );
-    
-    points_.assign( newPoints, newPoints + numOfPoints );
-    
-    if ( closedCycle_ ) {
-        points_.push_back( points_[ 0 ] );
-    }
-    
-    updateTangentsAndLengths( points_ , 
-                              segmentTangents_, 
-                              segmentLengths_, 
-                              0, 
-                              numOfPoints,
-                              closedCycle_ );
-    
-    shrinkToFit( points_ );
-    shrinkToFit( segmentTangents_ );
-    shrinkToFit( segmentLengths_ );
-}
-
-void 
-OpenSteer::PolylineSegmentedPath::setPath( const PathPoints&amp; newPoints,
-                                           bool closedCycle )
-{
-    size_type numberOfPoints = newPoints.size();
-    assert( 1 &lt; numberOfPoints &amp;&amp; &quot;Path must have at least two distinct points.&quot; );
-    // While testing say that no cyclus is used because the first point hasn't 
-    // been copied to the back.
-    assert( adjacentPathPointsDifferent( newPoints.begin(), newPoints.end(), false ) &amp;&amp; &quot;Adjacent path points must be different.&quot; );
-    
-    closedCycle_ = closedCycle;
-    
-    
-    if ( closedCycle_ ) {
-        ++numberOfPoints;
-    }
-    
-    points_ = newPoints;
-    segmentTangents_.resize( numberOfPoints - 1 );
-    segmentLengths_.resize( numberOfPoints - 1 );
-    
-    if ( closedCycle_ ) {
-        points_.push_back( points_[ 0 ] );
-    }
-    
-    updateTangentsAndLengths( points_ , 
-                              segmentTangents_, 
-                              segmentLengths_, 
-                              0, 
-                              numberOfPoints,
-                              closedCycle_ );
-    
-    shrinkToFit( points_ );
-    shrinkToFit( segmentTangents_ );
-    shrinkToFit( segmentLengths_ );
-}
-
-
-void 
-OpenSteer::PolylineSegmentedPath::movePoints( size_type startIndex,
-                                              size_type numOfPoints,
-                                              Vector3 const newPoints[] )
-{
-    assert( ( startIndex &lt; ( pointCount() - ( isCyclic() ? 1 : 0 ) ) ) &amp;&amp; 
-            &quot;startIndex must be inside index range.&quot; );
-    assert( ( ( startIndex + numOfPoints ) &lt;= ( pointCount() - ( isCyclic() ? 1 : 0 ) ) ) &amp;&amp; 
-            &quot;The max. index of a point to set must be inside the index range.&quot; ); 
-    
-    // Update the point positions.
-    // @todo Remove this line size_type const pathPointCount = pointCount();
-    for ( size_type i = 0; i &lt; numOfPoints; ++i ) {
-        points_[ startIndex + i ] = newPoints[ i ];
-    }
-    
-    // If the first point is changed and the path is cyclic also change the
-    // last point, which is just a copy of the first point.
-    if ( isCyclic() &amp;&amp; ( 0 == startIndex ) ) {
-        points_.back() = points_.front();
-    }
-    
-    // Recalculate the tangents and lengths.
-    updateTangentsAndLengths( points_, 
-                              segmentTangents_, 
-                              segmentLengths_, 
-                              startIndex, 
-                              numOfPoints, 
-                              isCyclic() );
-    
-    
-    assert( adjacentPathPointsDifferent( points_.begin(), points_.end(), isCyclic() ) &amp;&amp; &quot;Adjacent path points must be different.&quot; );
-}
-
-
-bool
-OpenSteer::PolylineSegmentedPath::isValid() const 
-{
-    return pointCount() &gt; 1;
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPath::mapPointToPath (const Vector3&amp; point,
-                                                  Vector3&amp; tangent,
-                                                  float&amp; outside) const
-{
-    PointToPathMapping mapping;
-    mapPointToPathAlike( *this, point, mapping );
-    tangent = mapping.tangent;
-    outside = mapping.distancePointToPath;
-    return mapping.pointOnPathCenterLine;
-}
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPath::mapPathDistanceToPoint (float pathDistance) const
-{
-    PathDistanceToPointMapping mapping;
-    mapDistanceToPathAlike( *this, pathDistance, mapping );
-    return mapping.pointOnPathCenterLine;
-}
-
-
-float 
-OpenSteer::PolylineSegmentedPath::mapPointToPathDistance (const Vector3&amp; point) const
-{
-    PointToPathDistanceMapping mapping;
-    mapPointToPathAlike( *this, point, mapping );
-    return mapping.distanceOnPath;
-}
-
-
-bool 
-OpenSteer::PolylineSegmentedPath::isCyclic() const
-{
-    return closedCycle_;
-}
-
-
-float 
-OpenSteer::PolylineSegmentedPath::length() const
-{
-    return std::accumulate( segmentLengths_.begin(), segmentLengths_.end(), 0.0f );
-}
-
-
-OpenSteer::SegmentedPath::size_type 
-OpenSteer::PolylineSegmentedPath::pointCount() const
-{
-    return points_.size();
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPath::point( size_type pointIndex ) const
-{
-    assert( pointIndex &lt; pointCount() &amp;&amp; &quot;pointIndex out of range.&quot; );
-    return points_[ pointIndex ];
-}
-
-
-
-
-OpenSteer::PolylineSegmentedPath::size_type 
-OpenSteer::PolylineSegmentedPath::segmentCount() const
-{
-    return segmentTangents_.size();
-}
-
-
-float 
-OpenSteer::PolylineSegmentedPath::segmentLength( size_type segmentIndex ) const
-{
-    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
-    return segmentLengths_[ segmentIndex ];
-}
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPath::segmentStart( size_type segmentIndex ) const
-{
-    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
-    assert( segmentIndex &lt; pointCount() &amp;&amp; &quot;The max. index of a point must be inside range.&quot; );
-    return points_[ segmentIndex ];
-}
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPath::segmentEnd( size_type segmentIndex ) const
-{
-    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex out of range.&quot; );
-    assert( segmentIndex + 1&lt; pointCount() &amp;&amp; &quot;The max. index of a point must be inside range.&quot; );
-
-    return points_[ segmentIndex + 1 ];
-}
-
-
-float 
-OpenSteer::PolylineSegmentedPath::mapPointToSegmentDistance( size_type segmentIndex, 
-                                                             Vector3 const&amp; point ) const
-{
-    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex is out of range.&quot; );
-    
-    Vector3 const segmentStartToPoint( point - points_[ segmentIndex ] );
-    float const distance = segmentStartToPoint.dotProduct( segmentTangents_[ segmentIndex ] );
-    
-    return clamp( distance, 0.0f, segmentLengths_[ segmentIndex ] );
-}
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPath::mapSegmentDistanceToPoint( size_type segmentIndex, 
-                                                             float segmentDistance ) const
-{
-    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex is out of range.&quot; );
-    
-    float const segmentLength = segmentLengths_[ segmentIndex ];
-    /*
-     * bk: remove behavior that treats negative numbers as distances beginning 
-     * from the end of the segment
-    if ( 0.0f &gt; segmentDistance ) {
-        segmentDistance += segmentLength;
-    }
-    */
-    segmentDistance = clamp( segmentDistance, 0.0f, segmentLength );
-    
-    return segmentTangents_[ segmentIndex ] * segmentDistance + points_[ segmentIndex ];
-}
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPath::mapSegmentDistanceToTangent( size_type segmentIndex, 
-                                                               float ) const
-{
-    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex is out of range.&quot; );
-    return segmentTangents_[ segmentIndex ];
-}
-
-
-void 
-OpenSteer::PolylineSegmentedPath::mapDistanceToSegmentPointAndTangent( size_type segmentIndex,
-                                                                       float segmentDistance,
-                                                                       Vector3&amp; pointOnPath,
-                                                                       Vector3&amp; tangent ) const
-{
-    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex is out of range.&quot; );
-    
-    float const segmentLength = segmentLengths_[ segmentIndex ];
-    
-    /* 
-     * bk: remove behavior that treats negative numbers as distances beginning 
-     * from the end of the segment
-    if ( 0.0f &gt; segmentDistance ) {
-        segmentDistance += segmentLength;
-    }
-    */
-    segmentDistance = clamp( segmentDistance, 0.0f, segmentLength );
-    
-    pointOnPath = segmentTangents_[ segmentIndex ] * segmentDistance + points_[ segmentIndex ];
-    tangent = segmentTangents_[ segmentIndex ];
-}
-
-
-void 
-OpenSteer::PolylineSegmentedPath::mapPointToSegmentDistanceAndPointAndTangent( size_type segmentIndex,
-                                                                               Vector3 const&amp; point,
-                                                                               float&amp; distance,
-                                                                               Vector3&amp; pointOnPath,
-                                                                               Vector3&amp; tangent ) const
-{
-    assert( segmentIndex &lt; segmentCount() &amp;&amp; &quot;segmentIndex is out of range.&quot; );
-    
-    Vector3 const segmentStartPoint = points_[ segmentIndex ];
-    Vector3 const segmentStartToPoint( point - segmentStartPoint );
-    tangent = segmentTangents_[ segmentIndex ];
-    distance = segmentStartToPoint.dotProduct( tangent );
-    distance =  clamp( distance, 0.0f, segmentLengths_[ segmentIndex ] );
-    pointOnPath = tangent * distance + segmentStartPoint;
-}
-
-
-
-

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/PolylineSegmentedPath.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,327 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
- */
-#include &quot;OpenSteer/PolylineSegmentedPathwaySingleRadius.h&quot;
-
-
-// Include std::swap
-#include &lt;algorithm&gt;
-
-
-// Include OpenSteer::mapPointToPathway, OpenSteer::mapDistanceToPointOnPathCenterLine
-#include &quot;OpenSteer/QueryPathAlike.h&quot;
-
-// Include OpenSteer::PointToPathMapping, OpenSteer::PathDistanceToPointMapping, OpenSteer::PointToPathDistanceMapping
-#include &quot;OpenSteer/QueryPathAlikeMappings.h&quot;
-
-// Include OpenSteer::HasSingleRadius
-#include &quot;OpenSteer/QueryPathAlikeUtilities.h&quot;
-
-// Include OPENSTEER_UNUSED_PARAMETER
-#include &quot;OpenSteer/UnusedParameter.h&quot;
-
-
-OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius()
-    : path_(), radius_ ( 0.0f )
-{
-    
-}
-
-
-
-OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius( float r )
-    : path_(), radius_( r )
-{
-    
-}
-
-
-
-OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius( size_type numOfPoints,
-                                                                                       Vector3 const points[],
-                                                                                       float r,
-                                                                                       bool closeCycle )
-    : path_( numOfPoints, points, closeCycle ), radius_( r )
-{
-    
-}
-
-OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius( const PolylineSegmentedPath::PathPoints&amp; points,
-                                                                                       float r,
-                                                                                       bool closeCycle )
-    : path_( points, closeCycle ), radius_( r )
-{
-    
-}
-
-
-OpenSteer::PolylineSegmentedPathwaySingleRadius::PolylineSegmentedPathwaySingleRadius( PolylineSegmentedPathwaySingleRadius const&amp; other )
-    : SegmentedPathway( other ), path_( other.path_ ), radius_( other.radius_ )
-{
-    
-}
-
-
-
-OpenSteer::PolylineSegmentedPathwaySingleRadius::~PolylineSegmentedPathwaySingleRadius()
-{
-    // Nothing to do.
-}
-
-
-
-OpenSteer::PolylineSegmentedPathwaySingleRadius&amp; 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::operator=( PolylineSegmentedPathwaySingleRadius other )
-{
-    swap( other );
-    return *this;
-}
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::swap( PolylineSegmentedPathwaySingleRadius&amp; other )
-{
-    path_.swap( other.path_ );
-    std::swap( radius_, other.radius_ );
-}
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::movePoints( size_type startIndex,
-                                                             size_type numOfPoints,
-                                                             Vector3 const newPointValues[] )
-{
-    path_.movePoints( startIndex, numOfPoints, newPointValues );
-}
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::setPathway( size_type numOfPoints,
-                                                             Vector3 const points[],
-                                                             float r,
-                                                             bool closedCycle )
-{
-    path_.setPath( numOfPoints, points, closedCycle );
-    setRadius( r );
-}
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::setRadius( float r )
-{
-    radius_ = r;
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::radius() const
-{
-    return radius_;
-}
-
-
-
-bool
-OpenSteer::PolylineSegmentedPathwaySingleRadius::isValid() const 
-{
-    return pointCount() &gt; 1;
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToPath (const Vector3&amp; point,
-                                                                 Vector3&amp; tangent,
-                                                                 float&amp; outside) const
-{
-    PointToPathMapping mapping;
-    mapPointToPathAlike( *this, point, mapping );
-    tangent = mapping.tangent;
-    outside = mapping.distancePointToPath;
-    return mapping.pointOnPathCenterLine;
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPathDistanceToPoint (float pathDistance) const
-{
-    PathDistanceToPointMapping mapping;
-    mapDistanceToPathAlike( *this, pathDistance, mapping );
-    return mapping.pointOnPathCenterLine;
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToPathDistance (const Vector3&amp; point) const
-{
-    PointToPathDistanceMapping mapping;
-    mapPointToPathAlike( *this, point, mapping );
-    return mapping.distanceOnPath;
-}
-
-
-
-bool 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::isCyclic() const
-{
-    return path_.isCyclic();
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::length() const
-{
-    return path_.length();
-}
-
-
-
-OpenSteer::SegmentedPathway::size_type 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::pointCount() const 
-{
-    return path_.pointCount();
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::point( size_type pointIndex ) const
-{
-    return path_.point( pointIndex );
-}
-
-
-
-
-OpenSteer::PolylineSegmentedPathwaySingleRadius::size_type 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::segmentCount() const
-{
-    return path_.segmentCount();
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::segmentLength( size_type segmentIndex ) const
-{
-    return path_.segmentLength( segmentIndex );
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::segmentStart( size_type segmentIndex ) const
-{
-    return path_.segmentStart( segmentIndex );
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::segmentEnd( size_type segmentIndex ) const
-{
-    return path_.segmentEnd( segmentIndex );
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToSegmentDistance( size_type segmentIndex, 
-                                                                            Vector3 const&amp; point ) const
-{
-    return path_.mapPointToSegmentDistance( segmentIndex, point );
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapSegmentDistanceToPoint( size_type segmentIndex, 
-                                                                            float segmentDistance ) const
-{
-    return path_.mapSegmentDistanceToPoint( segmentIndex, segmentDistance );
-}
-
-
-
-float 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapSegmentDistanceToRadius( size_type segmentIndex, 
-                                                                             float distanceOnSegment ) const
-{
-    OPENSTEER_UNUSED_PARAMETER(segmentIndex);
-    OPENSTEER_UNUSED_PARAMETER(distanceOnSegment);
-    return radius_;
-}
-
-
-
-Vector3 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapSegmentDistanceToTangent( size_type segmentIndex, 
-                                                                              float segmentDistance ) const
-{
-    return path_.mapSegmentDistanceToTangent( segmentIndex, segmentDistance );
-}
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapDistanceToSegmentPointAndTangentAndRadius( size_type segmentIndex,
-                                                                                               float distance,
-                                                                                               Vector3&amp; pointOnPath,
-                                                                                               Vector3&amp; tangent,
-                                                                                               float&amp; radius ) const
-{
-    path_.mapDistanceToSegmentPointAndTangent( segmentIndex, distance, pointOnPath, tangent );
-    radius = radius_;
-}
-
-
-
-
-void 
-OpenSteer::PolylineSegmentedPathwaySingleRadius::mapPointToSegmentDistanceAndPointAndTangentAndRadius( size_type segmentIndex,
-                                                                                              Vector3 const&amp; point,
-                                                                                              float&amp; distance,
-                                                                                              Vector3&amp; pointOnPath,
-                                                                                              Vector3&amp; tangent,
-                                                                                              float&amp; radius) const
-{
-    path_.mapPointToSegmentDistanceAndPointAndTangent( segmentIndex, point, distance, pointOnPath, tangent );
-    radius = radius_;
-}
-
-

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/PolylineSegmentedPathwaySingleRadius.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPath.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/SegmentedPath.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPath.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,40 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
- */
-#include &quot;OpenSteer/SegmentedPath.h&quot;
-
-OpenSteer::SegmentedPath::~SegmentedPath()
-{
-    // Nothing to do.
-}
-
-/*
-OpenSteer::SegmentedPath&amp; OpenSteer::SegmentedPath::operator=( SegmentedPath const&amp; )
-{
-    return *this;
-}
-*/

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPath.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/SegmentedPath.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPathway.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/SegmentedPathway.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPathway.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,40 +0,0 @@
-/**
- * OpenSteer -- Steering Behaviors for Autonomous Characters
- *
- * Copyright (c) 2002-2005, Sony Computer Entertainment America
- * Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the &quot;Software&quot;),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
- * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
- * DEALINGS IN THE SOFTWARE.
- *
- *
- * @author Bjoern Knafla &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">bknafla at uni-kassel.de</A>&gt;
- */
-#include &quot;OpenSteer/SegmentedPathway.h&quot;
-
-OpenSteer::SegmentedPathway::~SegmentedPathway()
-{
-    // Nothing to do.
-}
-
-/*
-OpenSteer::SegmentedPathway&amp; OpenSteer::SegmentedPathway::operator=( SegmentedPathway const&amp; )
-{
-    return *this;
-}
-*/

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/SegmentedPathway.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/SegmentedPathway.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/Vec3.cpp
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/Vec3.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/Vec3.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,192 +0,0 @@
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the &quot;Software&quot;),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-//
-// ----------------------------------------------------------------------------
-//
-//
-// Vector3: OpenSteer's generic type for 3d vectors
-//
-// This file defines the class Vector3, which is used throughout OpenSteer to
-// manipulate 3d geometric data.  It includes standard vector operations (like
-// vector addition, subtraction, scale, dot, cross...) and more idiosyncratic
-// utility functions.
-//
-// When integrating OpenSteer into a preexisting 3d application, it may be
-// important to use the 3d vector type of that application.  In that case Vector3
-// can be changed to inherit from the preexisting application' vector type and
-// to match the interface used by OpenSteer to the interface provided by the
-// preexisting 3d vector type.
-//
-// 10-04-04 bk:  put everything into the OpenSteer namespace
-// 03-26-03 cwr: created to replace for Hiranabe-san's execellent but larger
-//               vecmath package (<A HREF="http://objectclub.esm.co.jp/vecmath/">http://objectclub.esm.co.jp/vecmath/</A>)
-//
-//
-// ----------------------------------------------------------------------------
-
-
-#include &quot;OpenSteer/Vec3.h&quot;
-
-
-Vector3 
-OpenSteer::RandomVectorInUnitRadiusSphere (void)
-{
-    Vector3 v;
-
-    do
-    {
-        v.x = (frandom01()*2) - 1;
-        v.y = (frandom01()*2) - 1;
-        v.z = (frandom01()*2) - 1;
-    }
-    while (v.length() &gt;= 1);
-
-    return v;
-}
-
-
-// ----------------------------------------------------------------------------
-// Returns a position randomly distributed on a disk of unit radius
-// on the XZ (Y=0) plane, centered at the origin.  Orientation will be
-// random and length will range between 0 and 1
-
-
-Vector3 
-OpenSteer::randomVectorOnUnitRadiusXZDisk (void)
-{
-    Vector3 v;
-
-    do
-    {
-        v.x = (frandom01()*2) - 1;
-        v.y = 0;
-        v.z = (frandom01()*2) - 1;
-    }
-    while (v.length() &gt;= 1);
-
-    return v;
-}
-
-
-// ----------------------------------------------------------------------------
-// Does a &quot;ceiling&quot; or &quot;floor&quot; operation on the angle by which a given vector
-// deviates from a given reference basis vector.  Consider a cone with &quot;basis&quot;
-// as its axis and slope of &quot;cosineOfConeAngle&quot;.  The first argument controls
-// whether the &quot;source&quot; vector is forced to remain inside or outside of this
-// cone.  Called by vecLimitMaxDeviationAngle and vecLimitMinDeviationAngle.
-
-
-Vector3 
-OpenSteer::vecLimitDeviationAngleUtility (const bool insideOrOutside,
-                                          const Vector3&amp; source,
-                                          const float cosineOfConeAngle,
-                                          const Vector3&amp; basis)
-{
-    // immediately return zero length input vectors
-    float sourceLength = source.length();
-    if (sourceLength == 0) return source;
-
-    // measure the angular diviation of &quot;source&quot; from &quot;basis&quot;
-    const Vector3 direction = source / sourceLength;
-    float cosineOfSourceAngle = direction.dotProduct(basis);
-
-    // Simply return &quot;source&quot; if it already meets the angle criteria.
-    // (note: we hope this top &quot;if&quot; gets compiled out since the flag
-    // is a constant when the function is inlined into its caller)
-    if (insideOrOutside)
-    {
-	// source vector is already inside the cone, just return it
-	if (cosineOfSourceAngle &gt;= cosineOfConeAngle) return source;
-    }
-    else
-    {
-	// source vector is already outside the cone, just return it
-	if (cosineOfSourceAngle &lt;= cosineOfConeAngle) return source;
-    }
-
-    // find the portion of &quot;source&quot; that is perpendicular to &quot;basis&quot;
-    const Vector3 perp = Vec3Utils::perpendicularComponent(source, basis);
-
-    // normalize that perpendicular
-    const Vector3 unitPerp = perp.normalisedCopy();
-
-    // construct a new vector whose length equals the source vector,
-    // and lies on the intersection of a plane (formed the source and
-    // basis vectors) and a cone (whose axis is &quot;basis&quot; and whose
-    // angle corresponds to cosineOfConeAngle)
-    float perpDist = sqrtXXX (1 - (cosineOfConeAngle * cosineOfConeAngle));
-    const Vector3 c0 = basis * cosineOfConeAngle;
-    const Vector3 c1 = unitPerp * perpDist;
-    return (c0 + c1) * sourceLength;
-}
-
-
-// ----------------------------------------------------------------------------
-// given a vector, return a vector perpendicular to it.  arbitrarily selects
-// one of the infinitely many perpendicular vectors.  a zero vector maps to
-// itself, otherwise length is irrelevant (empirically, output length seems to
-// remain within 20% of input length).
-
-
-Vector3 
-OpenSteer::findPerpendicularIn3d (const Vector3&amp; direction)
-{
-    // to be filled in:
-    Vector3 quasiPerp;  // a direction which is &quot;almost perpendicular&quot;
-    Vector3 result;     // the computed perpendicular to be returned
-
-    // three mutually perpendicular basis vectors
-    const Vector3 i (1, 0, 0);
-    const Vector3 j (0, 1, 0);
-    const Vector3 k (0, 0, 1);
-
-    // measure the projection of &quot;direction&quot; onto each of the axes
-    const float id = i.dotProduct(direction);
-    const float jd = j.dotProduct(direction);
-    const float kd = k.dotProduct(direction);
-
-    // set quasiPerp to the basis which is least parallel to &quot;direction&quot;
-    if ((id &lt;= jd) &amp;&amp; (id &lt;= kd))
-    {
-        quasiPerp = i;               // projection onto i was the smallest
-    }
-    else
-    {
-        if ((jd &lt;= id) &amp;&amp; (jd &lt;= kd))
-            quasiPerp = j;           // projection onto j was the smallest
-        else
-            quasiPerp = k;           // projection onto k was the smallest
-    }
-
-    // return the cross product (direction x quasiPerp)
-    // which is guaranteed to be perpendicular to both of them
-    result = crossProduct(direction, quasiPerp);
-    return result;
-}
-
-
-// ----------------------------------------------------------------------------

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/Vec3.cpp (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/Vec3.cpp)

Deleted: rl/branches/persistence2/engine/ai/src/OpenSteer/lq.c
===================================================================
--- rl/trunk/engine/ai/src/OpenSteer/lq.c	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/OpenSteer/lq.c	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,712 +0,0 @@
-/*
-// ----------------------------------------------------------------------------
-//
-//
-// OpenSteer -- Steering Behaviors for Autonomous Characters
-//
-// Copyright (c) 2002-2005, Sony Computer Entertainment America
-// Original author: Craig Reynolds &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">craig_reynolds at playstation.sony.com</A>&gt;
-//
-// Permission is hereby granted, free of charge, to any person obtaining a
-// copy of this software and associated documentation files (the &quot;Software&quot;),
-// to deal in the Software without restriction, including without limitation
-// the rights to use, copy, modify, merge, publish, distribute, sublicense,
-// and/or sell copies of the Software, and to permit persons to whom the
-// Software is furnished to do so, subject to the following conditions:
-//
-// The above copyright notice and this permission notice shall be included in
-// all copies or substantial portions of the Software.
-//
-// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
-// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-// DEALINGS IN THE SOFTWARE.
-//
-// ----------------------------------------------------------------------------
-*/
-/* ------------------------------------------------------------------ */
-/*                                                                    */
-/* Locality Query facility                                            */
-/*                                                                    */
-/* (by Craig Reynolds, see lq.h file for documentation)               */
-/*                                                                    */
-/*  5-17-99: created                                                  */
-/*  5-20-99: found elusive &quot;allocate 0 bins&quot; bug                      */
-/*  5-28-99: lqMapOverAllObjectsInLocality: clipped, incremental      */
-/*  6- 7-99: clean up, split off annotation stuff into debuglq.c      */
-/*  6- 8-99: tried screening by sum of coords (&quot;first mean&quot;?) but     */
-/*           it was slightly slower, moved unused code to debuglq     */
-/* 10-19-99: Change lqClientObject, lqObject from: &quot;struct x {};&quot; to  */
-/*           &quot;typedef struct x {} x;&quot; for EE compiler.                */
-/* 12- 2-00: Make lqObject &quot;private&quot; using lqInternalDB.              */
-/* 12- 5-00: Rename lqObject to lqDB, lqClientObject to lqClientProxy */
-/* 12- 6-00: Change lqCallBackFunction from arglist of (void*) to:    */
-/*           (void* clientObject, float distanceSquared, void*        */
-/*           clientQueryState).  Add void* clientQueryState arg to    */
-/*           lqMapOverAllObjectsInLocality and its helper functions   */
-/*           lqMapOverAllObjectsInLocalityClipped and                 */
-/*           lqMapOverAllOutsideObjects. Change macro                 */
-/*           lqTraverseBinClientObjectList to invoke callback         */
-/*           function with three arguments, add &quot;state&quot; to its        */
-/*           arglist.  Remove extern lqDistanceSquared.               */
-/* 12- 7-00: Rename lqInitClientObject to lqInitClientProxy, make     */
-/*           &quot;func&quot; be an argument to lqTraverseBinClientObjectList,  */
-/*           add comments.                                            */
-/* 12- 8-00: Add lqFindNearestNeighborWithinRadius and related        */
-/*           definitions: lqFindNearestHelper lqFindNearestState      */
-/*           Add lqMapOverAllObjects and lqRemoveAllObjects (plus:    */
-/*           lqMapOverAllObjectsInBin and lqRemoveAllObjectsInBin)    */
-/*                                                                    */
-/* ------------------------------------------------------------------ */
-
-
-#include &lt;stdlib.h&gt;
-#include &lt;float.h&gt;
-#include &lt;limits.h&gt; /* for INT_MAX */
-#include &quot;OpenSteer/lq.h&quot;
-
-/* for debugging and graphical annotation (normally unused) */
-#ifdef BOIDS_LQ_DEBUG
-#include &quot;OpenSteer/debuglq.c&quot;
-#endif
-
-#ifndef WIN32
-#define USUSED_PARAM __attribute__ ((unused))
-#else
-#define USUSED_PARAM
-#endif
-
-
-/* ------------------------------------------------------------------ */
-/* This structure represents the spatial database.  Typically one of
-   these would be created, by a call to lqCreateDatabase, for a given
-   application.  */
-
-
-typedef struct lqInternalDB
-{
-
-    /* the origin is the super-brick corner minimum coordinates */
-    float originx, originy, originz;
-
-    /* length of the edges of the super-brick */
-    float sizex, sizey, sizez;
-
-    /* number of sub-brick divisions in each direction */
-    int divx, divy, divz;
-
-    /* pointer to an array of pointers, one for each bin */
-    lqClientProxy** bins;
-
-    /* extra bin for &quot;everything else&quot; (points outside super-brick) */
-    lqClientProxy* other;
-
-} lqInternalDB;
-
-
-/* ------------------------------------------------------------------ */
-/* Allocate and initialize an LQ database, return a pointer to it.
-   The application needs to call this before using the LQ facility.
-   The nine parameters define the properties of the &quot;super-brick&quot;:
-      (1) origin: coordinates of one corner of the super-brick, its
-          minimum x, y and z extent.
-      (2) size: the width, height and depth of the super-brick.
-      (3) the number of subdivisions (sub-bricks) along each axis.
-   This routine also allocates the bin array, and initialize its
-   contents. */
-
-
-lqInternalDB* lqCreateDatabase (float originx, float originy, float originz,
-				float sizex, float sizey, float sizez,
-				int divx, int divy, int divz)
-{
-    lqInternalDB* lq = ((lqInternalDB*) malloc (sizeof (lqInternalDB)));
-
-    lqInitDatabase (lq,
-		    originx, originy, originz,
-		    sizex, sizey, sizez,
-		    divx, divy, divz);
-    return lq;
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Deallocate the memory used by the LQ database */
-
-
-void lqDeleteDatabase(lqDB* lq)
-{
-    free (lq-&gt;bins);
-    free (lq);
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Given an LQ database object and the nine basic parameters: fill in
-   the object's slots, allocate the bin array, and initialize its
-   contents. */
-
-
-void lqInitDatabase (lqInternalDB* lq,
-		     float originx, float originy, float originz,
-		     float sizex, float sizey, float sizez,
-		     int divx, int divy, int divz)
-{
-    lq-&gt;originx = originx;
-    lq-&gt;originy = originy;
-    lq-&gt;originz = originz;
-    lq-&gt;sizex = sizex;
-    lq-&gt;sizey = sizey;
-    lq-&gt;sizez = sizez;
-    lq-&gt;divx = divx;
-    lq-&gt;divy = divy;
-    lq-&gt;divz = divz;
-    {
-	int i;
-	int bincount = divx * divy * divz;
-	int arraysize = sizeof (lqClientProxy*) * bincount;
-	lq-&gt;bins = (lqClientProxy**) malloc (arraysize);
-	for (i=0; i&lt;bincount; i++) lq-&gt;bins[i] = NULL;
-    }
-    lq-&gt;other = NULL;
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Determine index into linear bin array given 3D bin indices */
-
-
-#define lqBinCoordsToBinIndex(lq, ix, iy, iz) \
-    ((ix * (lq)-&gt;divy * (lq)-&gt;divz) + (iy * (lq)-&gt;divz) + iz)
-
-
-/* ------------------------------------------------------------------ */
-/* Find the bin ID for a location in space.  The location is given in
-   terms of its XYZ coordinates.  The bin ID is a pointer to a pointer
-   to the bin contents list.  */
-
-
-lqClientProxy** lqBinForLocation (lqInternalDB* lq, 
-				  float x, float y, float z)
-{
-    int i, ix, iy, iz;
-
-    /* if point outside super-brick, return the &quot;other&quot; bin */
-    if (x &lt; lq-&gt;originx)              return &amp;(lq-&gt;other);
-    if (y &lt; lq-&gt;originy)              return &amp;(lq-&gt;other);
-    if (z &lt; lq-&gt;originz)              return &amp;(lq-&gt;other);
-    if (x &gt;= lq-&gt;originx + lq-&gt;sizex) return &amp;(lq-&gt;other);
-    if (y &gt;= lq-&gt;originy + lq-&gt;sizey) return &amp;(lq-&gt;other);
-    if (z &gt;= lq-&gt;originz + lq-&gt;sizez) return &amp;(lq-&gt;other);
-
-    /* if point inside super-brick, compute the bin coordinates */
-    ix = (int) (((x - lq-&gt;originx) / lq-&gt;sizex) * lq-&gt;divx);
-    iy = (int) (((y - lq-&gt;originy) / lq-&gt;sizey) * lq-&gt;divy);
-    iz = (int) (((z - lq-&gt;originz) / lq-&gt;sizez) * lq-&gt;divz);
-
-    /* convert to linear bin number */
-    i = lqBinCoordsToBinIndex (lq, ix, iy, iz);
-
-    /* return pointer to that bin */
-    return &amp;(lq-&gt;bins[i]);
-}
-
-
-/* ------------------------------------------------------------------ */
-/* The application needs to call this once on each lqClientProxy at
-   setup time to initialize its list pointers and associate the proxy
-   with its client object. */ 
-
-
-void lqInitClientProxy (lqClientProxy* proxy, void* clientObject)
-{
-    proxy-&gt;prev   = NULL;
-    proxy-&gt;next   = NULL;
-    proxy-&gt;bin    = NULL;
-    proxy-&gt;object = clientObject;
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Adds a given client object to a given bin, linking it into the bin
-   contents list. */
-
-
-void lqAddToBin (lqClientProxy* object, lqClientProxy** bin)
-{
-    /* if bin is currently empty */    
-    if (*bin == NULL)
-    {
-	object-&gt;prev = NULL;
-	object-&gt;next = NULL;
-	*bin = object;
-    }
-    else
-    {
-	object-&gt;prev = NULL;
-	object-&gt;next = *bin;
-	(*bin)-&gt;prev = object;
-	*bin = object;
-    }
-
-    /* record bin ID in proxy object */
-    object-&gt;bin = bin;
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Removes a given client object from its current bin, unlinking it
-   from the bin contents list. */
-
-
-void lqRemoveFromBin (lqClientProxy* object)
-{
-    /* adjust pointers if object is currently in a bin */
-    if (object-&gt;bin != NULL)
-    {
-	/* If this object is at the head of the list, move the bin
-	   pointer to the next item in the list (might be NULL). */
-	if (*(object-&gt;bin) == object) *(object-&gt;bin) = object-&gt;next;
-
-	/* If there is a prev object, link its &quot;next&quot; pointer to the
-	   object after this one. */
-	if (object-&gt;prev != NULL) object-&gt;prev-&gt;next = object-&gt;next;
-
-	/* If there is a next object, link its &quot;prev&quot; pointer to the
-	   object before this one. */
-	if (object-&gt;next != NULL) object-&gt;next-&gt;prev = object-&gt;prev;
-    }
-
-    /* Null out prev, next and bin pointers of this object. */
-    object-&gt;prev = NULL;
-    object-&gt;next = NULL;
-    object-&gt;bin = NULL;
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Call for each client object every time its location changes.  For
-   example, in an animation application, this would be called each
-   frame for every moving object.  */
-
-
-void lqUpdateForNewLocation  (lqInternalDB* lq, 
-			      lqClientProxy* object, 
-			      float x, float y, float z)
-{
-    /* find bin for new location */
-    lqClientProxy** newBin = lqBinForLocation (lq, x, y, z);
-
-    /* store location in client object, for future reference */
-    object-&gt;x = x;
-    object-&gt;y = y;
-    object-&gt;z = z;
-
-    /* has object moved into a new bin? */
-    if (newBin != object-&gt;bin)
-    {
-	lqRemoveFromBin (object);
- 	lqAddToBin (object, newBin);
-    }
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Given a bin's list of client proxies, traverse the list and invoke
-   the given lqCallBackFunction on each object that falls within the
-   search radius.  */
-
-
-#define lqTraverseBinClientObjectList(co, radiusSquared, func, state) \
-    while (co != NULL)                                                \
-    {                                                                 \
-	/* compute distance (squared) from this client   */           \
-	/* object to given locality sphere's centerpoint */           \
-	float dx = x - co-&gt;x;                                         \
-	float dy = y - co-&gt;y;                                         \
-	float dz = z - co-&gt;z;                                         \
-	float distanceSquared = (dx * dx) + (dy * dy) + (dz * dz);    \
-                                                                      \
-	/* apply function if client object within sphere */           \
-	if (distanceSquared &lt; radiusSquared)                          \
-	    (*func) (co-&gt;object, distanceSquared, state);             \
-                                                                      \
-	/* consider next client object in bin list */                 \
-	co = co-&gt;next;                                                \
-    }
-
-
-/* ------------------------------------------------------------------ */
-/* This subroutine of lqMapOverAllObjectsInLocality efficiently
-   traverses of subset of bins specified by max and min bin
-   coordinates. */
-
-void lqMapOverAllObjectsInLocalityClipped (lqInternalDB* lq, 
-                                           float x, float y, float z,
-                                           float radius,
-                                           lqCallBackFunction func,
-                                           void* clientQueryState,
-                                           int minBinX,
-                                           int minBinY, 
-                                           int minBinZ,
-                                           int maxBinX,
-                                           int maxBinY,
-                                           int maxBinZ);
-
-void lqMapOverAllObjectsInLocalityClipped (lqInternalDB* lq, 
-					   float x, float y, float z,
-					   float radius,
-					   lqCallBackFunction func,
-					   void* clientQueryState,
-					   int minBinX,
-					   int minBinY, 
-					   int minBinZ,
-					   int maxBinX,
-					   int maxBinY,
-					   int maxBinZ)
-{
-    int i, j, k;
-    int iindex, jindex, kindex;
-    int slab = lq-&gt;divy * lq-&gt;divz;
-    int row = lq-&gt;divz;
-    int istart = minBinX * slab;
-    int jstart = minBinY * row;
-    int kstart = minBinZ;
-    lqClientProxy* co;
-    lqClientProxy** bin;
-    float radiusSquared = radius * radius;
-
-#ifdef BOIDS_LQ_DEBUG
-    if (lqAnnoteEnable) drawBallGL (x, y, z, radius);
-#endif
-
-    /* loop for x bins across diameter of sphere */
-    iindex = istart;
-    for (i = minBinX; i &lt;= maxBinX; i++)
-    {
-	/* loop for y bins across diameter of sphere */
-	jindex = jstart;
-	for (j = minBinY; j &lt;= maxBinY; j++)
-	{
-	    /* loop for z bins across diameter of sphere */
-	    kindex = kstart;
-	    for (k = minBinZ; k &lt;= maxBinZ; k++)
-	    {
-		/* get current bin's client object list */
-		bin = &amp;lq-&gt;bins[iindex + jindex + kindex];
-		co = *bin;
-
-#ifdef BOIDS_LQ_DEBUG
-		if (lqAnnoteEnable) drawBin (lq, bin);
-#endif
-		/* traverse current bin's client object list */
-		lqTraverseBinClientObjectList (co,
-					       radiusSquared,
-					       func,
-					       clientQueryState);
-		kindex += 1;
-	    }
-	    jindex += row;
-	}
-	iindex += slab;
-    }
-}
-
-
-/* ------------------------------------------------------------------ */
-/* If the query region (sphere) extends outside of the &quot;super-brick&quot;
-   we need to check for objects in the catch-all &quot;other&quot; bin which
-   holds any object which are not inside the regular sub-bricks  */
-
-void lqMapOverAllOutsideObjects (lqInternalDB* lq, 
-                                 float x, float y, float z,
-                                 float radius,
-                                 lqCallBackFunction func,
-                                 void* clientQueryState);
-
-void lqMapOverAllOutsideObjects (lqInternalDB* lq, 
-				 float x, float y, float z,
-				 float radius,
-				 lqCallBackFunction func,
-				 void* clientQueryState)
-{
-    lqClientProxy* co = lq-&gt;other;
-    float radiusSquared = radius * radius;
-
-    /* traverse the &quot;other&quot; bin's client object list */
-    lqTraverseBinClientObjectList (co,
-				   radiusSquared,
-				   func,
-				   clientQueryState);
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Apply an application-specific function to all objects in a certain
-   locality.  The locality is specified as a sphere with a given
-   center and radius.  All objects whose location (key-point) is
-   within this sphere are identified and the function is applied to
-   them.  The application-supplied function takes three arguments:
-
-     (1) a void* pointer to an lqClientProxy's &quot;object&quot;.
-     (2) the square of the distance from the center of the search
-         locality sphere (x,y,z) to object's key-point.
-     (3) a void* pointer to the caller-supplied &quot;client query state&quot;
-         object -- typically NULL, but can be used to store state
-         between calls to the lqCallBackFunction.
-
-   This routine uses the LQ database to quickly reject any objects in
-   bins which do not overlap with the sphere of interest.  Incremental
-   calculation of index values is used to efficiently traverse the
-   bins of interest. */
-
-
-void lqMapOverAllObjectsInLocality (lqInternalDB* lq, 
-				    float x, float y, float z,
-				    float radius,
-				    lqCallBackFunction func,
-				    void* clientQueryState)
-{
-    int partlyOut = 0;
-    int completelyOutside = 
-	(((x + radius) &lt; lq-&gt;originx) ||
-	 ((y + radius) &lt; lq-&gt;originy) ||
-	 ((z + radius) &lt; lq-&gt;originz) ||
-	 ((x - radius) &gt;= lq-&gt;originx + lq-&gt;sizex) ||
-	 ((y - radius) &gt;= lq-&gt;originy + lq-&gt;sizey) ||
-	 ((z - radius) &gt;= lq-&gt;originz + lq-&gt;sizez));
-    int minBinX, minBinY, minBinZ, maxBinX, maxBinY, maxBinZ;
-
-    /* is the sphere completely outside the &quot;super brick&quot;? */
-    if (completelyOutside)
-    {
-	lqMapOverAllOutsideObjects (lq, x, y, z, radius, func,
-				    clientQueryState);
-	return;
-    }
-
-    /* compute min and max bin coordinates for each dimension */
-    minBinX = (int) ((((x - radius) - lq-&gt;originx) / lq-&gt;sizex) * lq-&gt;divx);
-    minBinY = (int) ((((y - radius) - lq-&gt;originy) / lq-&gt;sizey) * lq-&gt;divy);
-    minBinZ = (int) ((((z - radius) - lq-&gt;originz) / lq-&gt;sizez) * lq-&gt;divz);
-    maxBinX = (int) ((((x + radius) - lq-&gt;originx) / lq-&gt;sizex) * lq-&gt;divx);
-    maxBinY = (int) ((((y + radius) - lq-&gt;originy) / lq-&gt;sizey) * lq-&gt;divy);
-    maxBinZ = (int) ((((z + radius) - lq-&gt;originz) / lq-&gt;sizez) * lq-&gt;divz);
-
-    /* clip bin coordinates */
-    if (minBinX &lt; 0)         {partlyOut = 1; minBinX = 0;}
-    if (minBinY &lt; 0)         {partlyOut = 1; minBinY = 0;}
-    if (minBinZ &lt; 0)         {partlyOut = 1; minBinZ = 0;}
-    if (maxBinX &gt;= lq-&gt;divx) {partlyOut = 1; maxBinX = lq-&gt;divx - 1;}
-    if (maxBinY &gt;= lq-&gt;divy) {partlyOut = 1; maxBinY = lq-&gt;divy - 1;}
-    if (maxBinZ &gt;= lq-&gt;divz) {partlyOut = 1; maxBinZ = lq-&gt;divz - 1;}
-
-    /* map function over outside objects if necessary (if clipped) */
-    if (partlyOut) 
-	lqMapOverAllOutsideObjects (lq, x, y, z, radius, func,
-				    clientQueryState);
-    
-    /* map function over objects in bins */
-    lqMapOverAllObjectsInLocalityClipped (lq,
-					  x, y, z,
-					  radius,
-					  func,
-					  clientQueryState,
-					  minBinX, minBinY, minBinZ,
-					  maxBinX, maxBinY, maxBinZ);
-}
-
-
-/* ------------------------------------------------------------------ */
-/* internal helper function */
-
-
-typedef struct lqFindNearestState
-{
-    void* ignoreObject;
-    void* nearestObject;
-    float minDistanceSquared;
-
-} lqFindNearestState;
-
-
-void lqFindNearestHelper (void* clientObject,
-                          float distanceSquared,
-                          void* clientQueryState);
-
-void lqFindNearestHelper (void* clientObject,
-			  float distanceSquared,
-			  void* clientQueryState)
-{
-    lqFindNearestState* fns = (lqFindNearestState*) clientQueryState;
-
-    /* do nothing if this is the &quot;ignoreObject&quot; */
-    if (fns-&gt;ignoreObject != clientObject)
-    {
-	/* record this object if it is the nearest one so far */
-	if (fns-&gt;minDistanceSquared &gt; distanceSquared)
-	{
-	    fns-&gt;nearestObject = clientObject;
-	    fns-&gt;minDistanceSquared = distanceSquared;
-	}
-    }
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Search the database to find the object whose key-point is nearest
-   to a given location yet within a given radius.  That is, it finds
-   the object (if any) within a given search sphere which is nearest
-   to the sphere's center.  The ignoreObject argument can be used to
-   exclude an object from consideration (or it can be NULL).  This is
-   useful when looking for the nearest neighbor of an object in the
-   database, since otherwise it would be its own nearest neighbor.
-   The function returns a void* pointer to the nearest object, or
-   NULL if none is found.  */
-
-
-void* lqFindNearestNeighborWithinRadius (lqInternalDB* lq, 
-					 float x, float y, float z,
-					 float radius,
-					 void* ignoreObject)
-{
-    /* initialize search state */
-    lqFindNearestState lqFNS;
-    lqFNS.nearestObject = NULL;
-    lqFNS.ignoreObject = ignoreObject;
-    lqFNS.minDistanceSquared = FLT_MAX;
-
-    /* map search helper function over all objects within radius */
-    lqMapOverAllObjectsInLocality (lq, 
-				   x, y, z,
-				   radius,
-				   lqFindNearestHelper,
-				   &amp;lqFNS);
-
-    /* return nearest object found, if any */
-    return lqFNS.nearestObject;
-}
-
-
-/* ------------------------------------------------------------------ */
-/* internal helper function */
-
-void lqMapOverAllObjectsInBin (lqClientProxy* binProxyList, 
-                               lqCallBackFunction func,
-                               void* clientQueryState);
-
-void lqMapOverAllObjectsInBin (lqClientProxy* binProxyList, 
-			       lqCallBackFunction func,
-			       void* clientQueryState)
-{
-    /* walk down proxy list, applying call-back function to each one */
-    while (binProxyList != NULL)
-    {
-	(*func) (binProxyList-&gt;object, 0, clientQueryState);
-	binProxyList = binProxyList-&gt;next;
-    }
-}
-
-
-/* ------------------------------------------------------------------ */
-/* Apply a user-supplied function to all objects in the database,
-   regardless of locality (cf lqMapOverAllObjectsInLocality) */
-
-void lqMapOverAllObjects (lqInternalDB* lq, 
-			  lqCallBackFunction func,
-			  void* clientQueryState)
-{
-    int i;
-    int bincount = lq-&gt;divx * lq-&gt;divy * lq-&gt;divz;
-    for (i=0; i&lt;bincount; i++)
-    {
-	lqMapOverAllObjectsInBin (lq-&gt;bins[i], func, clientQueryState);
-    }
-    lqMapOverAllObjectsInBin (lq-&gt;other, func, clientQueryState);
-}
-
-/* ------------------------------------------------------------------ */
-/* looks at all bins (except &quot;other&quot;) finding the min and max bin
-   populations and the average of NON-EMPTY bin populations.  (The
-   average over all bins is a constant (population/bincount))  */
-
-#ifndef NO_LQ_BIN_STATS
-
-void lqgbpsCounter (void* clientObject    USUSED_PARAM,
-                    float distanceSquared USUSED_PARAM,
-                    void* clientQueryState);
-
-void lqgbpsCounter (void* clientObject    USUSED_PARAM,
-                    float distanceSquared USUSED_PARAM,
-                    void* clientQueryState)
-{
-    (*(int*)clientQueryState)++;
-}
-
-void lqGetBinPopulationStats (lqInternalDB* lq,
-                              int* min,
-                              int* max,
-                              float* average)
-{
-    int minPop = INT_MAX;
-    int maxPop = 0;
-    int totalCount = 0;
-    int nonEmptyBinCount = 0;
-    int bincount = lq-&gt;divx * lq-&gt;divy * lq-&gt;divz;
-    int i;
-
-    for (i=0; i&lt;bincount; i++)
-    {
-        /* clear the counter */
-        int objectCount = 0;
-
-        /* apply counting function to each object in bin[i] */
-	lqMapOverAllObjectsInBin (lq-&gt;bins[i], lqgbpsCounter, &amp;objectCount);
-
-        /* collect data: max and min population, count objects and non-empty bins */
-        if (objectCount &gt; 0)
-        {
-            nonEmptyBinCount++;
-            if (maxPop &lt; objectCount) maxPop = objectCount;
-            if (minPop &gt; objectCount) minPop = objectCount;
-            totalCount += objectCount;
-        }
-    }
-
-    /* set return values */
-    *min = minPop;
-    *max = maxPop;
-    *average = ((float) totalCount) / ((float) nonEmptyBinCount);
-}
-
-#endif /* NO_LQ_BIN_STATS */
-
-
-/* ------------------------------------------------------------------ */
-/* internal helper function */
-
-
-#define lqRemoveAllObjectsInBin(bin) \
-    while ((bin) != NULL) lqRemoveFromBin ((bin));
-
-
-/* ------------------------------------------------------------------ */
-/* Removes (all proxies for) all objects from all bins */
-
-
-void lqRemoveAllObjects (lqInternalDB* lq)
-{
-    int i;
-    int bincount = lq-&gt;divx * lq-&gt;divy * lq-&gt;divz;
-    for (i=0; i&lt;bincount; i++)
-    {
-	lqRemoveAllObjectsInBin (lq-&gt;bins[i]);
-    }
-    lqRemoveAllObjectsInBin (lq-&gt;other);
-}
-
-
-/* ------------------------------------------------------------------ */

Copied: rl/branches/persistence2/engine/ai/src/OpenSteer/lq.c (from rev 4878, rl/trunk/engine/ai/src/OpenSteer/lq.c)

Modified: rl/branches/persistence2/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/branches/persistence2/engine/ai/src/SteeringVehicle.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ai/src/SteeringVehicle.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,346 +1,357 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright(C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot;
-
-#include &quot;SteeringVehicle.h&quot;
-
-#include &quot;AbstractMovement.h&quot;
-#include &quot;AiSubsystem.h&quot;
-#include &quot;AiWorld.h&quot; 
-#include &quot;Agent.h&quot;
-#include &quot;Actor.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;CreatureController.h&quot;
-#include &quot;CreatureControllerManager.h&quot;
-#include &quot;MeshObject.h&quot;
-#include &quot;CreatureController.h&quot;
-#include &quot;PhysicalThing.h&quot;
-#include &quot;GameObjectManager.h&quot;
-#include &quot;RulesMessages.h&quot;
-
-using namespace Ogre;
-using namespace OpenSteer;
-
-namespace rl {
-
-SteeringVehicle::SteeringVehicle(Creature* creature)
-	: _maxForce(1.0f),
-      _maxSpeed(1.0f),
-      mSpeed(1.0f),
-	  mCurrentForce(Vector3::ZERO), 
-	  mCurrentVelocity(Vector3::ZERO),
-	  mForwardVector(Vector3::NEGATIVE_UNIT_Z),
-      mCreatureId(creature-&gt;getId()),
-      mController(NULL),
-      mDebugSteer(Vector3::ZERO),
-      mDebugWander(Vector3::ZERO),
-      mDebugAvoidObstacles(Vector3::ZERO)
-{
-    setCreature(creature);
-	initialize();
-
-    mController = CreatureControllerManager::getSingleton().getCreatureController(
-        mCreature);
-    mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler&lt;MessageType_GameObjectsLoaded&gt;(
-                boost::bind(&amp;SteeringVehicle::refetchCreature, this));
-}
-
-SteeringVehicle::~SteeringVehicle()
-{
-}
-
-void SteeringVehicle::resetLocalSpace()
-{
-	setForward(mForwardVector);
-	setSide(localRotateForwardToSide(getForward()));
-    setUp(Vector3::UNIT_Y);
-	Vector3 pos = mCreature-&gt;getPosition();
-	setPosition(pos);
-	Vector3 src = mCreature-&gt;getOrientation()*Vector3::NEGATIVE_UNIT_Z;
-
-    // regenerate local space(by default: align vehicle's forward axis with
-    // new velocity, but this behavior may be overridden by derived classes.)
-	regenerateOrthonormalBasisUF(src);
-}
-
-void SteeringVehicle::initialize()
-{
-    // reset LocalSpace state
-	resetLocalSpace();
-	
-    // reset SteerLibraryMixin state
-	SimpleVehicle_2::reset();
-
-	setMaxForce(1.0f);   // steering force is clipped to this magnitude
-	setMaxSpeed(1.0f);   // velocity is clipped to this magnitude
-}
-
-
-void SteeringVehicle::addForce(const Ogre::Vector3&amp; force)
-{
-	mCurrentForce += force;
-}
-
-void SteeringVehicle::update(const float currentTime, const float elapsedTime)
-{
-    SimpleVehicle::update(currentTime, elapsedTime);
-
-    Vector3 pos = mCreature-&gt;getPosition();
-	setPosition(pos);
-    
-    OgreNewt::Body* body = mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
-    //  Get the velocity vector
-	mCurrentVelocity = body-&gt;getVelocity();
-	//  enforce speed limit
-	//  newVelocity = newVelocity.truncateLength(maxSpeed());
-	//  update speed
-	setSpeed(mCurrentVelocity.length());
-	Vector3 newVelocity(mCurrentVelocity);
-
-    //  regenerate local space(by default: align vehicle's forward axis with
-    //  new velocity, but this behavior may be overridden by derived classes.)
-    // use future orientation or not??
-    Quaternion orientation(mController-&gt;getYaw(), Ogre::Vector3::UNIT_Y);
-    Vector3 newUnitForward = orientation*Vector3::NEGATIVE_UNIT_Z;
-    regenerateOrthonormalBasisUF(newUnitForward);
-
-    // only process if mMovingCreature not NULL
-    if (mController == NULL || mCreature-&gt;getQueryFlags() &amp; QUERYFLAG_PLAYER)
-    {
-        mCurrentForce = Vector3::ZERO;
-        return;
-    }
-    
-    // calculate the result of the force    
-    Vector3 result = mCurrentForce;// + mCurrentVelocity;
-    
-    mDebugSteer = mCurrentForce;
-
-    // @todo remove this
-    if (mCreature-&gt;getAu() &lt;= 6)
-        mCreature-&gt;modifyAu(20,true);
-
-    AbstractMovement* mov_drehen = mController-&gt;getMovementFromId(CreatureController::MT_DREHEN);
-    Real vel_drehen(0);
-    Radian max_drehen = Degree(0);
-    if (mov_drehen-&gt;calculateBaseVelocity(vel_drehen))
-    {
-        max_drehen = Degree(vel_drehen * 360 * elapsedTime);
-    }
-
-    Ogre::Quaternion future_orientation(mController-&gt;getYaw(), Ogre::Vector3::UNIT_Y);
-    Ogre::Vector3 creatureDirection = future_orientation * Ogre::Vector3::NEGATIVE_UNIT_Z;
-    Radian yaw(0);
-    creatureDirection.y = result.y = 0;
-    yaw = creatureDirection.getRotationTo(result, Ogre::Vector3::UNIT_Y).getYaw();
-    if (yaw &gt; Radian(0) &amp;&amp; yaw &gt; max_drehen)
-        yaw = max_drehen;
-    if (yaw &lt; Radian(0) &amp;&amp; yaw &lt; -max_drehen)
-        yaw = -max_drehen;
-
-    Ogre::Vector3 direction(Ogre::Vector3::ZERO);
-    Ogre::Vector3 rotation(0,yaw.valueRadians(),0);
-    CreatureController::MovementType movement = CreatureController::MT_STEHEN;
-    if (result != Ogre::Vector3::ZERO)
-    {
-        direction.z = -1;
-        movement = CreatureController::MT_GEHEN;
-    }
-
-    mController-&gt;setMovement(movement, direction, rotation);
-    LOG_DEBUG(Logger::AI, &quot;SteeringVehicle: mController-&gt;setMovement &quot; + 
-        Ogre::StringConverter::toString(movement) + &quot;, &quot;
-        + Ogre::StringConverter::toString(direction) + &quot;, &quot;
-        + Ogre::StringConverter::toString(rotation));
-
-	mCurrentForce = Ogre::Vector3::ZERO;
-}
-
-Vector3 SteeringVehicle::calcWander(const float elapsedTime)
-{
-	Vector3 steering = mForwardVector;
-	
-    steering += Vec3Utils::setYtoZero(steerForWander(elapsedTime/12.0f));
-
-    mDebugWander = steering;
-	return steering;
-}
-
-Vector3 SteeringVehicle::calcSeek(const Vector3&amp; target)
-{
-	Vector3 steering = Vec3Utils::setYtoZero(steerForSeek(target));
-	return steering;
-}
-
-Vector3 SteeringVehicle::calcFlee(const Vector3&amp; target)
-{
-	Vector3 steering = Vec3Utils::setYtoZero(steerForFlee(target));
-	return steering;
-}
-
-Vector3 SteeringVehicle::calcPursuit(Agent* agent)
-{
-    Vector3 dir = Vec3Utils::setYtoZero(steerForPursuit(*agent));
-	return dir;
-}
-
-Vector3 SteeringVehicle::calcAvoidObstacles(const float minTimeToCollision)
-{
-    ObstacleGroup obstacles = getObstacles();
-    Vector3 steering = Vec3Utils::setYtoZero(steerToAvoidObstacles(minTimeToCollision, obstacles));
-    mDebugAvoidObstacles = steering;
-	return steering;
-}
-
-Vector3 SteeringVehicle::calcAvoidNeighbors(const float minTimeToCollision)
-{
-    const float maxRadius = minTimeToCollision * getMaxSpeed() * 2;
-	Vector3 steering = Vec3Utils::setYtoZero(steerToAvoidNeighbors(minTimeToCollision, getNeighbors(maxRadius)));
-	return steering;
-}
-		
-Vector3 SteeringVehicle::calcSteerTargetSpeed(const float targetSpeed)
-{
-	return Vector3();
-}
-
-bool SteeringVehicle::isAhead(Agent* agent, const float threshold)
-{
-    Vector3 target = agent-&gt;getControlledCreature()-&gt;getPosition();
-	//target.y = position.y;
-	return SimpleVehicle_2::isAhead(target, threshold);
-}
-
-bool SteeringVehicle::needAvoidance(const float minTimeToCollision)
-{
-	Vector3 rVal = calcAvoidNeighbors(minTimeToCollision) + calcAvoidObstacles(minTimeToCollision);
-	if (rVal == Vector3::ZERO)
-	{
-		return false;
-	}
-	return true;
-}
-
-AVGroup SteeringVehicle::getNeighbors(const float maxRadius) const
-{
-	AVGroup neighbors;
-    //std::vector&lt;SimpleVehicle*&gt; neighbors;
-    if(mProximityToken != NULL)
-    {
-        mProximityToken-&gt;findNeighbors(getPosition(), maxRadius, neighbors);
-    }
-	//AgentManager::VehicleList list = AgentManager::getSingleton().getNeighbors(NULL);
-	//AgentManager::VehicleList::const_iterator itr = list.begin();
-	//for(; itr != list.end(); ++itr)
-	//{
-	//	if ((*itr) != this)
-	//	{
-	//		group.push_back((*itr));
-	//	}
-	//}
-	return neighbors;
-}
-
-float SteeringVehicle::calcDistance(const Vector3&amp; vec1, const Vector3&amp; vec2)
-{
-	Vector3 vec = vec1-vec2;
-	return vec.length();
-}
-/*
-Vector3 SteeringVehicle::getPosition()
-{
-	return mCreature-&gt;getPosition();
-}
-*/
-
-
-const ObstacleGroup&amp; SteeringVehicle::getObstacles() const
-{
-	return AiSubsystem::getSingleton().getWorld()-&gt;getSteeringObstacles();
-}
-/*
-Vector3 SteeringVehicle::predictFuturePosition(const float predictionTime) const
-{
-	//return position() +(velocity() * predictionTime);
-	return getVelocity() * predictionTime;
-}
-*/
-Vector3 SteeringVehicle::adjustRawSteeringForce(const Vector3&amp; force)
-{
-    const float maxAdjustedSpeed = 0.2f * getMaxSpeed();
-
-    if ((getSpeed() &gt; maxAdjustedSpeed) ||(force == Vector3::ZERO))
-    {
-        return force;
-    }
-    else
-    {
-        const float range = getSpeed() / maxAdjustedSpeed;
-        // const float cosine = interpolate(pow(range, 6), 1.0f, -1.0f);
-        // const float cosine = interpolate(pow(range, 10), 1.0f, -1.0f);
-        // const float cosine = interpolate(pow(range, 20), 1.0f, -1.0f);
-        // const float cosine = interpolate(pow(range, 100), 1.0f, -1.0f);
-        // const float cosine = interpolate(pow(range, 50), 1.0f, -1.0f);
-        const float cosine = interpolate(pow(range, 20), 1.0f, -1.0f);
-        return limitMaxDeviationAngle(force, cosine, getForward());
-    }
-}
-
-// methods from debugvisualisable
-DebugVisualisableFlag SteeringVehicle::getFlag() const
-{
-    return DVF_BOT;
-}
-
-void SteeringVehicle::updatePrimitive()
-{
-    if (mSceneNode-&gt;getParent() == NULL)
-    {
-        mCreature-&gt;getActor()-&gt;_getSceneNode()-&gt;addChild(mSceneNode);
-    }
-
-    LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
-    lineSet-&gt;clear();
-    
-    if (mDebugSteer != Vector3::ZERO)
-    {
-        lineSet-&gt;addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugSteer.normalisedCopy()*0.5, ColourValue::Black);
-        mDebugSteer = Vector3::ZERO;
-    }
-    if (mDebugWander != Vector3::ZERO)
-    {
-        lineSet-&gt;addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugWander.normalisedCopy()*0.5, ColourValue::Green);
-        mDebugWander = Vector3::ZERO;
-    }
-    if (mDebugAvoidObstacles != Vector3::ZERO)
-    {
-        lineSet-&gt;addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugAvoidObstacles.normalisedCopy()*0.5, ColourValue::Red);
-        mDebugAvoidObstacles = Vector3::ZERO;
-    }
-}
-
-void SteeringVehicle::doCreatePrimitive()
-{
-    mPrimitive = new LineSetPrimitive();
-}
-
-bool SteeringVehicle::refetchCreature()
-{
-    mCreature = static_cast&lt;Creature*&gt;(GameObjectManager::getSingleton().getGameObject(mCreatureId));
-    return false;
-}
-
-} // namespace rl
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright(C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;SteeringVehicle.h&quot;
+
+#include &quot;AbstractMovement.h&quot;
+#include &quot;AiSubsystem.h&quot;
+#include &quot;AiWorld.h&quot; 
+#include &quot;Agent.h&quot;
+#include &quot;Actor.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;CreatureController.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
+#include &quot;MeshObject.h&quot;
+#include &quot;CreatureController.h&quot;
+#include &quot;PhysicalThing.h&quot;
+#include &quot;GameObjectManager.h&quot;
+#include &quot;RulesMessages.h&quot;
+
+using namespace Ogre;
+using namespace OpenSteer;
+
+namespace rl {
+
+SteeringVehicle::SteeringVehicle(Creature* creature)
+	: _maxForce(1.0f),
+      _maxSpeed(1.0f),
+      mSpeed(1.0f),
+	  mCurrentForce(Vector3::ZERO), 
+	  mCurrentVelocity(Vector3::ZERO),
+	  mForwardVector(Vector3::NEGATIVE_UNIT_Z),
+      mCreatureId(creature-&gt;getId()),
+      mController(NULL),
+      mDebugSteer(Vector3::ZERO),
+      mDebugWander(Vector3::ZERO),
+      mDebugAvoidObstacles(Vector3::ZERO)
+{
+    setCreature(creature);
+	initialize();
+
+    mController = CreatureControllerManager::getSingleton().getCreatureController(
+        mCreature);
+    std::ostringstream oss;
+    oss &lt;&lt; &quot; Creature '&quot; &lt;&lt; mCreature-&gt;getName() &lt;&lt; &quot;' controlled by SteeringVehicle.&quot;;
+    LOG_DEBUG(Logger::RULES, oss.str());
+    mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler&lt;MessageType_GameObjectsLoaded&gt;(
+                boost::bind(&amp;SteeringVehicle::refetchCreature, this));
+}
+
+SteeringVehicle::~SteeringVehicle()
+{
+    std::ostringstream oss;
+    oss &lt;&lt; &quot; Creature '&quot; &lt;&lt; mCreature-&gt;getName() &lt;&lt; &quot;' not controlled by SteeringVehicle any more.&quot;;
+    LOG_DEBUG(Logger::RULES, oss.str());
+}
+
+void SteeringVehicle::resetLocalSpace()
+{
+	setForward(mForwardVector);
+	setSide(localRotateForwardToSide(getForward()));
+    setUp(Vector3::UNIT_Y);
+	Vector3 pos = mCreature-&gt;getPosition();
+	setPosition(pos);
+	Vector3 src = mCreature-&gt;getOrientation()*Vector3::NEGATIVE_UNIT_Z;
+
+    // regenerate local space(by default: align vehicle's forward axis with
+    // new velocity, but this behavior may be overridden by derived classes.)
+	regenerateOrthonormalBasisUF(src);
+}
+
+void SteeringVehicle::initialize()
+{
+    // reset LocalSpace state
+	resetLocalSpace();
+	
+    // reset SteerLibraryMixin state
+	SimpleVehicle_2::reset();
+
+	setMaxForce(1.0f);   // steering force is clipped to this magnitude
+	setMaxSpeed(1.0f);   // velocity is clipped to this magnitude
+}
+
+
+void SteeringVehicle::addForce(const Ogre::Vector3&amp; force)
+{
+	mCurrentForce += force;
+}
+
+void SteeringVehicle::update(const float currentTime, const float elapsedTime)
+{
+    SimpleVehicle::update(currentTime, elapsedTime);
+
+    Vector3 pos = mCreature-&gt;getPosition();
+	setPosition(pos);
+    
+    OgreNewt::Body* body = mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody();
+    //  Get the velocity vector
+	mCurrentVelocity = body-&gt;getVelocity();
+	//  enforce speed limit
+	//  newVelocity = newVelocity.truncateLength(maxSpeed());
+	//  update speed
+	setSpeed(mCurrentVelocity.length());
+	Vector3 newVelocity(mCurrentVelocity);
+
+    //  regenerate local space(by default: align vehicle's forward axis with
+    //  new velocity, but this behavior may be overridden by derived classes.)
+    // use future orientation or not??
+    Quaternion orientation(mController-&gt;getYaw(), Ogre::Vector3::UNIT_Y);
+    Vector3 newUnitForward = orientation*Vector3::NEGATIVE_UNIT_Z;
+    regenerateOrthonormalBasisUF(newUnitForward);
+
+    // only process if mMovingCreature not NULL
+    if (mController == NULL || mCreature-&gt;getQueryFlags() &amp; QUERYFLAG_PLAYER)
+    {
+        mCurrentForce = Vector3::ZERO;
+        return;
+    }
+    
+    // calculate the result of the force    
+    Vector3 result = mCurrentForce;// + mCurrentVelocity;
+    
+    mDebugSteer = mCurrentForce;
+
+    // @todo remove this
+    if (mCreature-&gt;getAu() &lt;= 6)
+        mCreature-&gt;modifyAu(20,true);
+
+    AbstractMovement* mov_drehen = mController-&gt;getMovementFromId(CreatureController::MT_DREHEN);
+    Real vel_drehen(0);
+    Radian max_drehen = Degree(0);
+    if (mov_drehen-&gt;calculateBaseVelocity(vel_drehen))
+    {
+        max_drehen = Degree(vel_drehen * 360 * elapsedTime);
+    }
+
+    Ogre::Quaternion future_orientation(mController-&gt;getYaw(), Ogre::Vector3::UNIT_Y);
+    Ogre::Vector3 creatureDirection = future_orientation * Ogre::Vector3::NEGATIVE_UNIT_Z;
+    Radian yaw(0);
+    creatureDirection.y = result.y = 0;
+    yaw = creatureDirection.getRotationTo(result, Ogre::Vector3::UNIT_Y).getYaw();
+    if (yaw &gt; Radian(0) &amp;&amp; yaw &gt; max_drehen)
+        yaw = max_drehen;
+    if (yaw &lt; Radian(0) &amp;&amp; yaw &lt; -max_drehen)
+        yaw = -max_drehen;
+
+    Ogre::Vector3 direction(Ogre::Vector3::ZERO);
+    Ogre::Vector3 rotation(0,yaw.valueRadians(),0);
+    CreatureController::MovementType movement = CreatureController::MT_STEHEN;
+    if (result != Ogre::Vector3::ZERO)
+    {
+        direction.z = -1;
+        movement = CreatureController::MT_GEHEN;
+    }
+
+    mController-&gt;setMovement(movement, direction, rotation);
+    LOG_DEBUG(Logger::AI, &quot;SteeringVehicle: mController-&gt;setMovement &quot; + 
+        Ogre::StringConverter::toString(movement) + &quot;, &quot;
+        + Ogre::StringConverter::toString(direction) + &quot;, &quot;
+        + Ogre::StringConverter::toString(rotation));
+
+	mCurrentForce = Ogre::Vector3::ZERO;
+}
+
+Vector3 SteeringVehicle::calcWander(const float elapsedTime)
+{
+	Vector3 steering = mForwardVector;
+	
+    steering += Vec3Utils::setYtoZero(steerForWander(elapsedTime/12.0f));
+
+    mDebugWander = steering;
+	return steering;
+}
+
+Vector3 SteeringVehicle::calcSeek(const Vector3&amp; target)
+{
+	Vector3 steering = Vec3Utils::setYtoZero(steerForSeek(target));
+	return steering;
+}
+
+Vector3 SteeringVehicle::calcFlee(const Vector3&amp; target)
+{
+	Vector3 steering = Vec3Utils::setYtoZero(steerForFlee(target));
+	return steering;
+}
+
+Vector3 SteeringVehicle::calcPursuit(Agent* agent)
+{
+    Vector3 dir = Vec3Utils::setYtoZero(steerForPursuit(*agent));
+	return dir;
+}
+
+Vector3 SteeringVehicle::calcAvoidObstacles(const float minTimeToCollision)
+{
+    ObstacleGroup obstacles = getObstacles();
+    Vector3 steering = Vec3Utils::setYtoZero(steerToAvoidObstacles(minTimeToCollision, obstacles));
+    mDebugAvoidObstacles = steering;
+	return steering;
+}
+
+Vector3 SteeringVehicle::calcAvoidNeighbors(const float minTimeToCollision)
+{
+    const float maxRadius = minTimeToCollision * getMaxSpeed() * 2;
+	Vector3 steering = Vec3Utils::setYtoZero(steerToAvoidNeighbors(minTimeToCollision, getNeighbors(maxRadius)));
+	return steering;
+}
+		
+Vector3 SteeringVehicle::calcSteerTargetSpeed(const float targetSpeed)
+{
+	return Vector3();
+}
+
+bool SteeringVehicle::isAhead(Agent* agent, const float threshold)
+{
+    Vector3 target = agent-&gt;getControlledCreature()-&gt;getPosition();
+    //target.y = position.y;
+    return SimpleVehicle_2::isAhead(target, threshold);
+}
+
+bool SteeringVehicle::isAhead(const Vector3&amp; position, const float threshold)
+{
+    return SimpleVehicle_2::isAhead(position, threshold);
+}
+
+bool SteeringVehicle::needAvoidance(const float minTimeToCollision)
+{
+	Vector3 rVal = calcAvoidNeighbors(minTimeToCollision) + calcAvoidObstacles(minTimeToCollision);
+	if (rVal == Vector3::ZERO)
+	{
+		return false;
+	}
+	return true;
+}
+
+AVGroup SteeringVehicle::getNeighbors(const float maxRadius) const
+{
+	AVGroup neighbors;
+    //std::vector&lt;SimpleVehicle*&gt; neighbors;
+    if(mProximityToken != NULL)
+    {
+        mProximityToken-&gt;findNeighbors(getPosition(), maxRadius, neighbors);
+    }
+	//AgentManager::VehicleList list = AgentManager::getSingleton().getNeighbors(NULL);
+	//AgentManager::VehicleList::const_iterator itr = list.begin();
+	//for(; itr != list.end(); ++itr)
+	//{
+	//	if ((*itr) != this)
+	//	{
+	//		group.push_back((*itr));
+	//	}
+	//}
+	return neighbors;
+}
+
+float SteeringVehicle::calcDistance(const Vector3&amp; vec1, const Vector3&amp; vec2)
+{
+	Vector3 vec = vec1-vec2;
+	return vec.length();
+}
+/*
+Vector3 SteeringVehicle::getPosition()
+{
+	return mCreature-&gt;getPosition();
+}
+*/
+
+
+const ObstacleGroup&amp; SteeringVehicle::getObstacles() const
+{
+	return AiSubsystem::getSingleton().getWorld()-&gt;getSteeringObstacles();
+}
+/*
+Vector3 SteeringVehicle::predictFuturePosition(const float predictionTime) const
+{
+	//return position() +(velocity() * predictionTime);
+	return getVelocity() * predictionTime;
+}
+*/
+Vector3 SteeringVehicle::adjustRawSteeringForce(const Vector3&amp; force)
+{
+    const float maxAdjustedSpeed = 0.2f * getMaxSpeed();
+
+    if ((getSpeed() &gt; maxAdjustedSpeed) ||(force == Vector3::ZERO))
+    {
+        return force;
+    }
+    else
+    {
+        const float range = getSpeed() / maxAdjustedSpeed;
+        // const float cosine = interpolate(pow(range, 6), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 10), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 20), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 100), 1.0f, -1.0f);
+        // const float cosine = interpolate(pow(range, 50), 1.0f, -1.0f);
+        const float cosine = interpolate(pow(range, 20), 1.0f, -1.0f);
+        return limitMaxDeviationAngle(force, cosine, getForward());
+    }
+}
+
+// methods from debugvisualisable
+DebugVisualisableFlag SteeringVehicle::getFlag() const
+{
+    return DVF_BOT;
+}
+
+void SteeringVehicle::updatePrimitive()
+{
+    if (mSceneNode-&gt;getParent() == NULL)
+    {
+        mCreature-&gt;getActor()-&gt;_getSceneNode()-&gt;addChild(mSceneNode);
+    }
+
+    LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
+    lineSet-&gt;clear();
+    
+    if (mDebugSteer != Vector3::ZERO)
+    {
+        lineSet-&gt;addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugSteer.normalisedCopy()*0.5, ColourValue::Black);
+        mDebugSteer = Vector3::ZERO;
+    }
+    if (mDebugWander != Vector3::ZERO)
+    {
+        lineSet-&gt;addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugWander.normalisedCopy()*0.5, ColourValue::Green);
+        mDebugWander = Vector3::ZERO;
+    }
+    if (mDebugAvoidObstacles != Vector3::ZERO)
+    {
+        lineSet-&gt;addLine(Vector3::UNIT_Y*2, Vector3::UNIT_Y*2 + mDebugAvoidObstacles.normalisedCopy()*0.5, ColourValue::Red);
+        mDebugAvoidObstacles = Vector3::ZERO;
+    }
+}
+
+void SteeringVehicle::doCreatePrimitive()
+{
+    mPrimitive = new LineSetPrimitive();
+}
+
+bool SteeringVehicle::refetchCreature()
+{
+    mCreature = static_cast&lt;Creature*&gt;(GameObjectManager::getSingleton().getGameObject(mCreatureId));
+    return false;
+}
+
+} // namespace rl

Copied: rl/branches/persistence2/engine/common/RlCommon2008.vcproj (from rev 4878, rl/trunk/engine/common/RlCommon2008.vcproj)

Modified: rl/branches/persistence2/engine/common/include/FixRubyHeaders.h
===================================================================
--- rl/branches/persistence2/engine/common/include/FixRubyHeaders.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/common/include/FixRubyHeaders.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -34,6 +34,7 @@
 #undef write
 #undef max
 #undef min
+#undef check
 
 #undef PACKAGE_VERSION
 #undef PACKAGE_STRING

Modified: rl/branches/persistence2/engine/common/src/ConfigFile.cpp
===================================================================
--- rl/branches/persistence2/engine/common/src/ConfigFile.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/common/src/ConfigFile.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -19,6 +19,12 @@
 #include &quot;ConfigFile.h&quot;
 #include &quot;Exception.h&quot;
 
+#ifdef __APPLE__
+#include &lt;Ogre/OgreMemoryAllocatorConfig.h&gt;
+#else
+#include &lt;OgreMemoryAllocatorConfig.h&gt;
+#endif
+
 using namespace Ogre;
 using namespace std;
 
@@ -92,7 +98,7 @@
     void ConfigFile::addSection(const Ogre::String&amp; section, const Ogre::NameValuePairList&amp; settings)
     {
         // Create new section
-        mSettings[section] = new SettingsMultiMap();
+        mSettings[section] = OGRE_NEW_T(SettingsMultiMap, MEMCATEGORY_GENERAL);
         // Insert values from the settings list
         mSettings[section]-&gt;insert(settings.begin(), settings.end());
     }

Modified: rl/branches/persistence2/engine/core/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/core/CMakeLists.txt	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/CMakeLists.txt	2009-04-01 20:08:44 UTC (rev 4879)
@@ -3,6 +3,7 @@
 ${CMAKE_CURRENT_SOURCE_DIR}/include/fmod4driver
 ${CMAKE_CURRENT_SOURCE_DIR}/include/nulldriver
 ${RL_COMMON_INCLUDE_DIR}
+${XERCESC_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR}
@@ -52,6 +53,7 @@
 src/PhysicsGenericContactCallback.cpp
 src/PhysicsManager.cpp
 src/PhysicsMaterialRaycast.cpp
+src/PhysicsRagDoll.cpp
 src/PlayAnimationJob.cpp
 src/PlaySoundJob.cpp
 src/PolynomicSoundFadeFunctor.cpp

Modified: rl/branches/persistence2/engine/core/RlCore2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/core/RlCore2005.vcproj	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/RlCore2005.vcproj	2009-04-01 20:08:44 UTC (rev 4879)
@@ -48,7 +48,7 @@
 				Name=&quot;VCCLCompilerTool&quot;
 				AdditionalOptions=&quot;-Zm130&quot;
 				Optimization=&quot;0&quot;
-				AdditionalIncludeDirectories=&quot;.\include;.\include\nulldriver;.\include\fmod4driver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt_ngt\inc;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK2\sdk\;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\meshmagick\include;..\..\dependencies\FMOD4\api\inc&quot;
+				AdditionalIncludeDirectories=&quot;.\include;.\include\nulldriver;.\include\fmod4driver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\inc;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\meshmagick\include;..\..\dependencies\FMOD4\api\inc&quot;
 				PreprocessorDefinitions=&quot;WITH_FMOD3;_WINDOWS,_DEBUG,WIN32,RLCORE_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH&quot;
 				MinimalRebuild=&quot;true&quot;
 				BasicRuntimeChecks=&quot;3&quot;
@@ -90,7 +90,7 @@
 				OutputFile=&quot;./lib/$(ConfigurationName)/RlCore.dll&quot;
 				LinkIncremental=&quot;2&quot;
 				SuppressStartupBanner=&quot;true&quot;
-				AdditionalLibraryDirectories=&quot;&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\ogrenewt_ngt\lib\;..\..\dependencies\NewtonSDK2\sdk\x32\dll_vs7;..\..\dependencies\meshmagick\lib;..\..\dependencies\FMOD4\api\lib&quot;
+				AdditionalLibraryDirectories=&quot;&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\ogrenewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7;..\..\dependencies\meshmagick\lib;..\..\dependencies\FMOD4\api\lib&quot;
 				IgnoreDefaultLibraryNames=&quot;&quot;
 				TypeLibraryFile=&quot;$(OutDir)\RlCore.lib&quot;
 				GenerateDebugInformation=&quot;true&quot;
@@ -163,7 +163,7 @@
 				Optimization=&quot;3&quot;
 				EnableIntrinsicFunctions=&quot;true&quot;
 				FavorSizeOrSpeed=&quot;1&quot;
-				AdditionalIncludeDirectories=&quot;.\include;.\include\nulldriver;.\include\fmod4driver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\include\OgreNewt;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\meshmagick\include;..\..\dependencies\FMOD4\api\inc&quot;
+				AdditionalIncludeDirectories=&quot;.\include;.\include\nulldriver;.\include\fmod4driver;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\OgreNewt\inc;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\meshmagick\include;..\..\dependencies\FMOD4\api\inc&quot;
 				PreprocessorDefinitions=&quot;WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLCORE_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH&quot;
 				StringPooling=&quot;false&quot;
 				ExceptionHandling=&quot;1&quot;
@@ -202,7 +202,7 @@
 				OutputFile=&quot;./lib/$(ConfigurationName)/RlCore.dll&quot;
 				LinkIncremental=&quot;1&quot;
 				SuppressStartupBanner=&quot;true&quot;
-				AdditionalLibraryDirectories=&quot;&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;&quot;..\..\dependencies\ogrenewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\meshmagick\lib;..\..\dependencies\FMOD4\api\lib&quot;
+				AdditionalLibraryDirectories=&quot;&quot;..\common\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\ogrenewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7;..\..\dependencies\meshmagick\lib;..\..\dependencies\FMOD4\api\lib&quot;
 				TypeLibraryFile=&quot;$(OutDir)\RlCore.lib&quot;
 				ProgramDatabaseFile=&quot;&quot;
 				SubSystem=&quot;2&quot;
@@ -544,6 +544,10 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\include\PhysicsRagDoll.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\include\PlayAnimationJob.h&quot;
 				&gt;
 			&lt;/File&gt;
@@ -893,6 +897,10 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\src\PhysicsRagDoll.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\src\PlayAnimationJob.cpp&quot;
 				&gt;
 			&lt;/File&gt;

Copied: rl/branches/persistence2/engine/core/RlCore2008.vcproj (from rev 4878, rl/trunk/engine/core/RlCore2008.vcproj)

Modified: rl/branches/persistence2/engine/core/include/PhysicalThing.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicalThing.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/include/PhysicalThing.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -31,6 +31,7 @@
 
 	class Actor;
 	class MeshObject;
+    class PhysicsRagDoll;
 
 	/** PhysicalThing contains the physical representation of an ActorControlledObject.
 	 * It utilizes a default collision primitiv derived from the default mesh, but it
@@ -129,7 +130,7 @@
         Ogre::Real getMass() const;
         void setMass(Ogre::Real mass);
 
-		void createPhysicsProxy(Ogre::SceneNode* node);
+		void createPhysicsProxy();
         void updatePhysicsProxy();
 		void destroyPhysicsProxy();
 
@@ -172,13 +173,20 @@
          */
         const OgreNewt::MaterialID* getMaterialID() const;
 
+        //! retrieve the ragdoll
+        PhysicsRagDoll* getRagDoll() { return mRagDoll; }
+
+        //! create a RagDoll, it is destroyed with
+        void createPhysicsProxy_RagDoll();
+
+/*
     protected:
 		void prepareUserControl(OgreNewt::MaterialID* material);
         void unprepareUserControl();
-
+*/
     private:
         Actor* mActor;
-		//! The newton body object this physical thing works with
+		//! The newton body object this physical thing works with, if it has a ragdoll, this is the main-body!
         OgreNewt::Body* mBody;
 		//! an upjoint to keep the body from falling over
         OgreNewt::BasicJoints::UpVector* mUpVectorJoint;
@@ -197,7 +205,7 @@
 
 		//! typedefinition for easing variable declaration
         typedef std::map&lt;Ogre::String, OgreNewt::CollisionPtr&gt; CollisionMap;
-		//! ??
+		//! Cache for collisions created by fitToPose
         CollisionMap mPoseCollisions;
 
 		//! the objects mass
@@ -219,6 +227,9 @@
 		void setBody(OgreNewt::Body* body);
 
         OgreNewt::CollisionPtr createCollision(PhysicalObject* po, Ogre::Vector3&amp; inertia) const;
+
+        //! the ragdoll, if this thing is controlled by a ragdoll
+        PhysicsRagDoll* mRagDoll;
 	};
 }
 

Modified: rl/branches/persistence2/engine/core/include/PhysicsManager.h
===================================================================
--- rl/branches/persistence2/engine/core/include/PhysicsManager.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/include/PhysicsManager.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -110,8 +110,13 @@
 		/**
 		 * Erschafft den entg&#252;ltigen Physikproxy
 		 */
-		void createPhysicsProxy(PhysicalThing* pt, Ogre::SceneNode* node);
+		void createPhysicsProxy(PhysicalThing* pt);
 
+        /**
+         * Creates a ragdoll as physics proxy
+         */
+        void createPhysicsProxy_RagDoll(PhysicalThing* pt);
+
 		/**
 		 * Removes the physics proxy
 		 * @param pt the physics proxy wrapper; is not deleted
@@ -364,7 +369,7 @@
         PhysicsGenericContactCallback* mGenericCallback;
 
 #ifdef _DEBUG
-        static void _CDECL PhysicsManager::newtonPerBodyLogProperties( const NewtonBody* body );
+        void logBodyProperties( const OgreNewt::Body* body );
 #endif
 
     };

Copied: rl/branches/persistence2/engine/core/include/PhysicsRagDoll.h (from rev 4878, rl/trunk/engine/core/include/PhysicsRagDoll.h)

Modified: rl/branches/persistence2/engine/core/src/Actor.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/Actor.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/src/Actor.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -125,6 +125,8 @@
     void Actor::setPhysicalThing( PhysicalThing* pt )
     {
         mPhysicalThing = pt;
+        if( mPhysicalThing != NULL )
+            mPhysicalThing-&gt;_setActor(this);
     }
 
     Ogre::Real Actor::getRenderingDistance() const
@@ -815,7 +817,7 @@
         // Physikverkn&#252;pfung anpassen
         if (mPhysicalThing &amp;&amp; mActorControlledObject)
         {
-            PhysicsManager::getSingleton().createPhysicsProxy(mPhysicalThing, mSceneNode);
+            PhysicsManager::getSingleton().createPhysicsProxy(mPhysicalThing);
 
             // Knochen angegeben und handelt sich um ein Mesh
             if( physicsBone.length() &gt; 0 &amp;&amp; mActorControlledObject-&gt;isMeshObject())

Modified: rl/branches/persistence2/engine/core/src/ActorManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/ActorManager.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/src/ActorManager.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -296,7 +296,7 @@
             PhysicalThing* pt = PhysicsManager::getSingleton()
                 .createPhysicalThing(GT_SPHERE, co,
                 0.001f, true);
-            PhysicsManager::getSingleton().createPhysicsProxy(pt, NULL);
+            PhysicsManager::getSingleton().createPhysicsProxy(pt);
             pt-&gt;_getBody()-&gt;setMaterialGroupID(
                 PhysicsManager::getSingleton().createMaterialID(&quot;camera&quot;));
             actor = new Actor(uniquename, co, pt);

Modified: rl/branches/persistence2/engine/core/src/AnimationManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/AnimationManager.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/src/AnimationManager.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -331,7 +331,9 @@
            AnimationManager::stopAnimation(anim);
            ScriptWrapper::getSingleton().deleted( anim );
            delete anim;
-           mFadeAnimSet.erase(it++);
+           FadeAnimSet::iterator toDelete = it;
+           it++;
+           mFadeAnimSet.erase(toDelete);
         }
         else
             ++it;

Modified: rl/branches/persistence2/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/ConfigurationManager.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/src/ConfigurationManager.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -325,7 +325,7 @@
 
     void ConfigurationManager::saveConfig() const
     {
-        ConfigFile* cfgfile = new ConfigFile();
+        ConfigFile* cfgfile = OGRE_NEW ConfigFile();
 
         for (SectionMap::const_iterator it = mSettings.begin(); it != mSettings.end(); ++it)
         {
@@ -338,7 +338,7 @@
         cfgfile-&gt;save(Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/&quot; + mRastullahCfgFile);
 #       endif
 
-        delete cfgfile;
+        OGRE_DELETE cfgfile;
     }
 
     Logger::LogLevel ConfigurationManager::getLogLevel() const

Modified: rl/branches/persistence2/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicalThing.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/src/PhysicalThing.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -24,6 +24,7 @@
 #include &quot;MathUtil.h&quot;
 #include &quot;MeshObject.h&quot;
 #include &quot;PhysicalObject.h&quot;
+#include &quot;PhysicsRagDoll.h&quot;
 
 using namespace Ogre;
 using namespace OgreNewt;
@@ -46,15 +47,14 @@
 		mPhysicalObject(po),
 		mMass(mass),
 		mHullModifier(hullModifier),
-        mPhysicsController(NULL)
+        mPhysicsController(NULL),
+        mRagDoll(NULL)
 	{
 	}
 
     PhysicalThing::~PhysicalThing()
 	{
-                mPoseCollisions.clear();
-		delete mBody;
-		mBody = NULL;
+        destroyPhysicsProxy();
     }
 
     Ogre::Vector3 PhysicalThing::getPosition() const
@@ -75,7 +75,10 @@
         Quaternion quat;
         Vector3 oldPos;
         mBody-&gt;getPositionOrientation(oldPos, quat);
-        mBody-&gt;setPositionOrientation(pos, quat);
+        if( mRagDoll )
+            mRagDoll-&gt;setPositionOrientation(pos, quat);
+        else
+            mBody-&gt;setPositionOrientation(pos, quat);
     }
 
     Ogre::Quaternion PhysicalThing::getOrientation() const
@@ -96,7 +99,10 @@
         Quaternion oldOrientation;
         Vector3 pos;
         mBody-&gt;getPositionOrientation(pos, oldOrientation);
-        mBody-&gt;setPositionOrientation(pos, orientation);
+        if( mRagDoll )
+            mRagDoll-&gt;setPositionOrientation(pos, orientation);
+        else
+            mBody-&gt;setPositionOrientation(pos, orientation);
     }
 
     void PhysicalThing::setVelocity(const Vector3&amp; vel)
@@ -129,9 +135,18 @@
     {
 		if (mBody &amp;&amp; mActor)
 		{
-			mBody-&gt;setPositionOrientation(
-				mActor-&gt;_getSceneNode()-&gt;_getDerivedPosition(),
-				mActor-&gt;_getSceneNode()-&gt;_getDerivedOrientation());
+            if( mRagDoll )
+            {
+                mRagDoll-&gt;setPositionOrientation(
+		    		mActor-&gt;_getSceneNode()-&gt;_getDerivedPosition(),
+				    mActor-&gt;_getSceneNode()-&gt;_getDerivedOrientation());
+            }
+            else
+            {
+			    mBody-&gt;setPositionOrientation(
+		    		mActor-&gt;_getSceneNode()-&gt;_getDerivedPosition(),
+				    mActor-&gt;_getSceneNode()-&gt;_getDerivedOrientation());
+            }
 			mActor-&gt;_update(Actor::UF_ALL &amp; ~Actor::UF_PHYSICAL_THING);
 		}
     }
@@ -145,7 +160,10 @@
 
     void PhysicalThing::_attachToSceneNode(Ogre::SceneNode* node)
     {
-        mBody-&gt;attachNode(node);
+        if( mRagDoll )
+            mRagDoll-&gt;setSceneNode( node );
+        else
+            mBody-&gt;attachNode(node);
     }
 
     void PhysicalThing::_attachToBone(MeshObject* object, const std::string&amp; boneName )
@@ -162,6 +180,9 @@
 
     void PhysicalThing::setUpConstraint(const Vector3&amp; upVector)
     {
+        RlAssert(!mRagDoll,
+           &quot;PhysicalThing::setUpConstraint: using UpConstraint not possible while a RagDoll controls this PhysicalThing!&quot;);
+
         if (!mUpVectorJoint)
         {
             mUpVectorJoint = new OgreNewt::BasicJoints::UpVector(
@@ -185,8 +206,11 @@
 
     void PhysicalThing::clearUpConstraint()
     {
-        delete mUpVectorJoint;
-        mUpVectorJoint = NULL;
+        if( mUpVectorJoint )
+        {
+            delete mUpVectorJoint;
+            mUpVectorJoint = NULL;
+        }
     }
 
     void PhysicalThing::onApplyForceAndTorque(float timestep)
@@ -210,10 +234,16 @@
 
     void PhysicalThing::setMass(Ogre::Real mass)
     {
-        Vector3 inertia;
-        mBody-&gt;getMassMatrix(mMass, inertia);
+        // effect on ragdoll?
+
+        if( mBody &amp;&amp; !mRagDoll )
+        {
+            Vector3 inertia;
+            mBody-&gt;getMassMatrix(mMass, inertia);
+            mMass = mass;
+            mBody-&gt;setMassMatrix(mass, inertia);
+        }
         mMass = mass;
-        mBody-&gt;setMassMatrix(mass, inertia);
     }
 
     void PhysicalThing::setGravityOverride(bool override, const Vector3&amp; gravity)
@@ -233,7 +263,9 @@
         entity-&gt;_updateAnimation();
         Node* node = entity-&gt;getParentNode();
         RlAssert(node,
-            &quot;Actor has to be placed in the scene in order to update its collision hull.&quot;);
+            &quot;PhysicalThing::updateCollisionHull: Actor has to be placed in the scene in order to update its collision hull.&quot;);
+        RlAssert(!mRagDoll,
+            &quot;PhysicalThing::updateCollisionHull: PhysicalThing must not be controlled by a RagDoll in order to update its collision hull.&quot;);
 
 
         Vector3 position;
@@ -328,6 +360,9 @@
 
     void PhysicalThing::fitToPose(const Ogre::String&amp; animName)
     {
+        if( mRagDoll )
+            Throw(IllegalArgumentException, &quot;PhysicalThing::fitToPose cannot be used while the PhysicalThing is controlled by a RagDoll!&quot;);
+
 		CollisionPtr coll;
 
         if (mPhysicalObject-&gt;isMeshObject())
@@ -385,12 +420,27 @@
 
 	void PhysicalThing::destroyPhysicsProxy()
 	{
-		delete mBody;
-		mBody = NULL;
+        setPhysicsController(NULL);
+        clearUpConstraint();
+        mPoseCollisions.clear();
+        if( mRagDoll )
+        {
+            delete mRagDoll;
+            mRagDoll = NULL;
+            mBody = NULL;
+        }
+        else if( mBody )
+        {
+		    delete mBody;
+		    mBody = NULL;
+        }
+
 	}
 
-    void PhysicalThing::createPhysicsProxy(SceneNode* node)
+    void PhysicalThing::createPhysicsProxy()
 	{
+        RlAssert( !mRagDoll,
+                &quot;PhysicalThing::createPhysicsProxy: cannot create physics proxy while the PhysicalThing is controlled by a RagDoll!&quot;);
 		if (!mBody)
 		{
             Vector3 inertia;
@@ -409,6 +459,13 @@
 			body-&gt;setCustomForceAndTorqueCallback(PhysicsManager::genericForceCallback);
 
             setBody(body);
+
+            if( mActor )
+            {
+                if( mActor-&gt;_getSceneNode() )
+                    _attachToSceneNode(mActor-&gt;_getSceneNode());
+
+            }
         }
 	}
 
@@ -450,7 +507,7 @@
 
     void PhysicalThing::updatePhysicsProxy()
     {
-        if (mBody)
+        if (mBody &amp;&amp; !mRagDoll)
         {
             mPoseCollisions.clear();
 
@@ -498,7 +555,10 @@
 
     void PhysicalThing::setMaterialID(const OgreNewt::MaterialID* materialid)
     {
-        mBody-&gt;setMaterialGroupID(materialid);
+        if( mRagDoll )
+            mRagDoll-&gt;setMaterialID(materialid);
+        else
+            mBody-&gt;setMaterialGroupID(materialid);
     }
 
     const OgreNewt::MaterialID* PhysicalThing::getMaterialID() const
@@ -506,4 +566,37 @@
         return mBody-&gt;getMaterialGroupID();
     }
 
+
+    void PhysicalThing::createPhysicsProxy_RagDoll()
+    {
+        if(!mRagDoll)
+        {
+            if( mBody )
+            {
+                Throw(OperationNotSupportedException, &quot;PhysicalThing::createPhysicsProxy_RagDoll: there is already a body connected to this PhysicalThing!&quot;);
+            }
+
+
+
+            if( !mPhysicalObject-&gt;isMeshObject() )
+                Throw(IllegalArgumentException, &quot;PhysicalThing::createPhysicsProxy_RagDoll needs a Mesh-Actor as argument!&quot;);
+            MeshObject* meshObj = static_cast&lt;MeshObject*&gt;(mPhysicalObject);
+
+            String ragdollRes = meshObj-&gt;getMeshName();
+            ragdollRes = ragdollRes.substr(0,ragdollRes.find(&quot;.mesh&quot;)) + &quot;_ragdoll.xml&quot;;
+            mRagDoll = new PhysicsRagDoll(ragdollRes, mActor);
+            mBody = NULL;
+            if( mRagDoll-&gt;getRootBone() )
+                mBody = mRagDoll-&gt;getRootBone()-&gt;getBody();
+
+            if( !mBody )
+            {
+                delete mRagDoll;
+                mRagDoll = NULL;
+                Throw(NullPointerException, &quot;Error creating the ragdoll!&quot;);
+            }
+        }
+    }
+
 }
+

Modified: rl/branches/persistence2/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/branches/persistence2/engine/core/src/PhysicsManager.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/core/src/PhysicsManager.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -171,13 +171,10 @@
             if( mDebugMode )
             {
                 LOG_DEBUG(Logger::CORE, &quot;\tNewtonBodyLog: &amp;Body  Position  Orientation  Velocity  &quot;\
-                    &quot;Omega  Force  Torque  NewtonBodyGetSleepState  NewtonBodyGetAutoFreeze  &quot;\
-                    &quot;NewtonBodyGetContinuousCollisionMode  ( invMass  invIxx  invIyy  invIzz )&quot;);
+                    &quot;Omega  Force  Torque NewtonBodyGetContinuousCollisionMode mass inertia&quot;);
                 if( Logger::getSingleton().getLogDetail() &lt;= Logger::LL_DEBUG )
-                for( const NewtonBody* body = NewtonWorldGetFirstBody(mWorld-&gt;getNewtonWorld());
-                     body != NULL;
-                     body = NewtonWorldGetNextBody(mWorld-&gt;getNewtonWorld(), body)  )
-                    newtonPerBodyLogProperties(body);
+                for( OgreNewt::Body* body = mWorld-&gt;getFirstBody(); body != NULL; body = body-&gt;getNext() )
+                    logBodyProperties(body);
             }
 #endif
         }
@@ -193,12 +190,9 @@
             if( mDebugMode )
             {
                 LOG_DEBUG(Logger::CORE, &quot;\tNewtonBodyLog: &amp;Body  Position  Orientation  Velocity  &quot;\
-                    &quot;Omega  Force  Torque  NewtonBodyGetSleepState  NewtonBodyGetAutoFreeze  &quot;\
-                    &quot;NewtonBodyGetContinuousCollisionMode  ( invMass  invIxx  invIyy  invIzz )&quot;);
-                for( const NewtonBody* body = NewtonWorldGetFirstBody(mWorld-&gt;getNewtonWorld());
-                     body != NULL;
-                     body = NewtonWorldGetNextBody(mWorld-&gt;getNewtonWorld(), body)  )
-                    newtonPerBodyLogProperties(body);
+                    &quot;Omega  Force  Torque NewtonBodyGetContinuousCollisionMode mass inertia&quot;);
+                for( OgreNewt::Body* body = mWorld-&gt;getFirstBody(); body != NULL; body = body-&gt;getNext() )
+                    logBodyProperties(body);
             }
 #endif
         }
@@ -215,28 +209,22 @@
     }
 
 #ifdef _DEBUG
-    void _CDECL PhysicsManager::newtonPerBodyLogProperties( const NewtonBody* body )
+    void PhysicsManager::logBodyProperties( const OgreNewt::Body* body )
     {
         std::ostringstream oss;
         Quaternion orient;
         Vector3 pos;
-        float matrix[16];
-        NewtonBodyGetMatrix(body,matrix);
-        OgreNewt::Converters::MatrixToQuatPos(matrix,orient,pos);
-        Vector3 force;
-        NewtonBodyGetForce(body, &amp;force.x);
-        Vector3 torque;
-        NewtonBodyGetTorque(body, &amp;torque.x);
-        Vector3 omega;
-        NewtonBodyGetOmega(body, &amp;omega.x);
-        Vector3 velocity;
-        NewtonBodyGetVelocity(body, &amp;velocity.x);
-        Vector3 invMass, invIxx, invIyy, invIzz;
-        NewtonBodyGetInvMass(body, &amp;invMass.x, &amp;invIxx.x, &amp;invIyy.x, &amp;invIzz.x);
+        body-&gt;getPositionOrientation(pos, orient);
+        Vector3 force = body-&gt;getForce();
+        Vector3 torque = body-&gt;getTorque();
+        Vector3 omega = body-&gt;getOmega();
+        Vector3 velocity = body-&gt;getVelocity();
+        Vector3 inertia;
+        Real mass;
+        body-&gt;getMassMatrix(mass, inertia);
         oss &lt;&lt; &quot;\tNewtonBodyLog: &quot; &lt;&lt; body &lt;&lt; &quot;  &quot; &lt;&lt; pos &lt;&lt; &quot;  &quot; &lt;&lt; orient &lt;&lt; &quot;  &quot; &lt;&lt; velocity &lt;&lt; &quot;  &quot;
-            &lt;&lt; omega &lt;&lt; &quot;  &quot; &lt;&lt; force &lt;&lt; &quot;  &quot; &lt;&lt; torque &lt;&lt; &quot;  &quot; &lt;&lt; NewtonBodyGetSleepState(body)
-            &lt;&lt; &quot;  &quot; &lt;&lt; NewtonBodyGetAutoSleep(body) &lt;&lt; &quot;  &quot; &lt;&lt; NewtonBodyGetContinuousCollisionMode(body) &lt;&lt; &quot;  ( &quot;
-            &lt;&lt; invMass &lt;&lt; &quot;  &quot; &lt;&lt; invIxx &lt;&lt; &quot;  &quot; &lt;&lt; invIyy &lt;&lt; &quot;  &quot; &lt;&lt; invIzz &lt;&lt; &quot; )&quot;;
+            &lt;&lt; omega &lt;&lt; &quot;  &quot; &lt;&lt; force &lt;&lt; &quot;  &quot; &lt;&lt; torque &lt;&lt; &quot; &quot; &lt;&lt; body-&gt;getContinuousCollisionMode()
+            &lt;&lt; mass &lt;&lt; &quot;  &quot; &lt;&lt; inertia;
         LOG_DEBUG(Logger::CORE, oss.str());
     }
 #endif
@@ -378,12 +366,18 @@
         mWorld-&gt;setWorldSize(mWorldAABB);
     }
 
-	void PhysicsManager::createPhysicsProxy(PhysicalThing* pt, SceneNode* node)
+	void PhysicsManager::createPhysicsProxy(PhysicalThing* pt)
 	{
-		pt-&gt;createPhysicsProxy(node);
+		pt-&gt;createPhysicsProxy();
 		mPhysicalThings.push_back(pt);
 	}
 
+    void PhysicsManager::createPhysicsProxy_RagDoll(PhysicalThing* pt)
+    {
+        pt-&gt;createPhysicsProxy_RagDoll();
+        mPhysicalThings.push_back(pt);
+    }
+
 	void PhysicsManager::destroyPhysicsProxy(PhysicalThing* pt)
 	{
         vector&lt;PhysicalThing*&gt;::iterator it = find(mPhysicalThings.begin(),
@@ -553,12 +547,6 @@
                     case GT_ELLIPSOID: // from createEllipsoid
                     case GT_PYRAMID: // createPyramid
                     case GT_SPHERE:
-                        {
-                            Vector3 inert_offs=Vector3::ZERO;
-                            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
-                            *inertia *= mass;
-                        }
-                        break;
                     case GT_MESH:
                     case GT_NONE:
                         *inertia = Ogre::Vector3::ZERO;

Copied: rl/branches/persistence2/engine/core/src/PhysicsRagDoll.cpp (from rev 4878, rl/trunk/engine/core/src/PhysicsRagDoll.cpp)

Modified: rl/branches/persistence2/engine/rules/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/rules/CMakeLists.txt	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/CMakeLists.txt	2009-04-01 20:08:44 UTC (rev 4879)
@@ -2,6 +2,7 @@
 ${CMAKE_CURRENT_SOURCE_DIR}/include
 ${RL_COMMON_INCLUDE_DIR}
 ${RL_CORE_INCLUDE_DIR}
+${XERCESC_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR})

Modified: rl/branches/persistence2/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/rules/RlRules2005.vcproj	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/RlRules2005.vcproj	2009-04-01 20:08:44 UTC (rev 4879)
@@ -42,7 +42,7 @@
 				Name=&quot;VCCLCompilerTool&quot;
 				AdditionalOptions=&quot;-Zm130&quot;
 				Optimization=&quot;0&quot;
-				AdditionalIncludeDirectories=&quot;.\include;..\core\include;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\OgreNewt_ngt\inc;..\..\dependencies\NewtonSDK2\sdk&quot;
+				AdditionalIncludeDirectories=&quot;.\include;..\core\include;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\OgreNewt\inc;..\..\dependencies\NewtonSDK\sdk&quot;
 				PreprocessorDefinitions=&quot;WIN32;_DEBUG;_WINDOWS;RLRULES_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH&quot;
 				MinimalRebuild=&quot;true&quot;
 				BasicRuntimeChecks=&quot;3&quot;
@@ -72,7 +72,7 @@
 				AdditionalDependencies=&quot;msvcrt-ruby18.lib xerces-c_2D.lib OgreMain_d.lib CEGUIBase_d.lib RlCore.lib OgreNewt_d.lib Newton.lib&quot;
 				OutputFile=&quot;$(OutDir)/RlRules.dll&quot;
 				LinkIncremental=&quot;2&quot;
-				AdditionalLibraryDirectories=&quot;&quot;..\core\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK2\sdk\x32\dll_vs7;..\..\dependencies\OgreNewt_ngt\lib&quot;
+				AdditionalLibraryDirectories=&quot;&quot;..\core\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7;..\..\dependencies\OgreNewt\lib&quot;
 				GenerateDebugInformation=&quot;true&quot;
 				AssemblyDebug=&quot;1&quot;
 				ProgramDatabaseFile=&quot;$(OutDir)/RlRules.pdb&quot;
@@ -134,7 +134,7 @@
 			&lt;Tool
 				Name=&quot;VCCLCompilerTool&quot;
 				AdditionalOptions=&quot;-Zm130&quot;
-				AdditionalIncludeDirectories=&quot;.\include;..\core\include;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk&quot;
+				AdditionalIncludeDirectories=&quot;.\include;..\core\include;..\common\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\OgreNewt\inc;..\..\dependencies\NewtonSDK\sdk&quot;
 				PreprocessorDefinitions=&quot;WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;RLRULES_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH&quot;
 				RuntimeLibrary=&quot;2&quot;
 				RuntimeTypeInfo=&quot;true&quot;
@@ -160,7 +160,7 @@
 				AdditionalDependencies=&quot;msvcrt-ruby18.lib OgreMain.lib xerces-c_2.lib CEGUIBase.lib RlCore.lib OgreNewt.lib Newton.lib&quot;
 				OutputFile=&quot;$(OutDir)/RlRules.dll&quot;
 				LinkIncremental=&quot;1&quot;
-				AdditionalLibraryDirectories=&quot;&quot;..\core\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll&quot;
+				AdditionalLibraryDirectories=&quot;&quot;..\core\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\xerces\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7&quot;
 				GenerateDebugInformation=&quot;false&quot;
 				SubSystem=&quot;2&quot;
 				OptimizeReferences=&quot;2&quot;

Copied: rl/branches/persistence2/engine/rules/RlRules2008.vcproj (from rev 4878, rl/trunk/engine/rules/RlRules2008.vcproj)

Modified: rl/branches/persistence2/engine/rules/include/Creature.h
===================================================================
--- rl/branches/persistence2/engine/rules/include/Creature.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/include/Creature.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -873,5 +873,7 @@
              **/
             void setStatus(int&amp; statusVariable, bool value, const Ogre::String&amp; errorMessage);
     };
+    
+    typedef std::list&lt;Creature*&gt; CreatureList;
 }
 #endif //__CREATURE_H__

Modified: rl/branches/persistence2/engine/rules/include/GameObject.h
===================================================================
--- rl/branches/persistence2/engine/rules/include/GameObject.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/include/GameObject.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -19,6 +19,8 @@
 
 #include &quot;RulesPrerequisites.h&quot;
 
+#include &lt;list&gt;
+
 #include &quot;Action.h&quot;
 #include &quot;Actor.h&quot;
 #include &quot;SaveAble.h&quot;
@@ -247,6 +249,8 @@
         ActionOptionVector::iterator findAction(ActionOptionVector::iterator
             begin, ActionOptionVector::iterator end, const Action* action);    
     };
+    
+    typedef std::list&lt;GameObject*&gt; GameObjectList;
 }
 
 #endif

Modified: rl/branches/persistence2/engine/rules/include/GoToJob.h
===================================================================
--- rl/branches/persistence2/engine/rules/include/GoToJob.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/include/GoToJob.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -21,6 +21,7 @@
 #include &quot;Creature.h&quot;
 #include &quot;CreatureController.h&quot;
 #include &quot;Job.h&quot;
+#include &quot;CreatureController.h&quot;
 
 namespace rl
 {
@@ -32,8 +33,12 @@
     public:
 
 		GoToJob(const CeGuiString &amp;id, Creature* actor, const Ogre::Vector3&amp; targetPos,
-			Ogre::Real maxDistance, Ogre::Real duration);
-		GoToJob(const CeGuiString &amp;id, Creature* actor, GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
+			Ogre::Real maxDistance, Ogre::Real duration,
+            CreatureController::MovementType movementType_moving = CreatureController::MT_RENNEN,
+            CreatureController::MovementType movementType_idle = CreatureController::MT_STEHEN);
+		GoToJob(const CeGuiString &amp;id, Creature* actor, GameObject* target, Ogre::Real maxDistance, Ogre::Real duration,
+            CreatureController::MovementType movementType_moving = CreatureController::MT_RENNEN,
+            CreatureController::MovementType movementType_idle = CreatureController::MT_STEHEN);
         virtual ~GoToJob();
 
         virtual bool execute(Ogre::Real time);
@@ -44,6 +49,7 @@
 		Ogre::Vector3 mTargetPos;
 		Ogre::Real mMaxDistance;
 		Ogre::Real mTimeLeft;
+        CreatureController::MovementType mMovementType_moving, mMovementType_idle;
     };
 }
 

Modified: rl/branches/persistence2/engine/rules/include/Selector.h
===================================================================
--- rl/branches/persistence2/engine/rules/include/Selector.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/include/Selector.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,156 +1,191 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __RL_SELECTOR_H__
-#define __RL_SELECTOR_H__
-
-#include &quot;RulesPrerequisites.h&quot;
-#include &quot;SceneQuery.h&quot;
-#include &quot;GameObject.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;LineSetPrimitive.h&quot;
-#include &quot;DebugVisualisable.h&quot;
-
-namespace rl {
-
-    class _RlRulesExport SelectionFilter
-    {
-    public:
-        virtual ~SelectionFilter() {}
-        /// Return true, if the GameObject passes the filter, false else.
-        virtual bool pass(GameObject*) const = 0;
-    };
-
-    class _RlRulesExport CreatureSelectionFilter : public SelectionFilter
-    {
-    public:
-        CreatureSelectionFilter();
-
-        void setAlignmentMask(unsigned int);
-
-        /// Return true, if the GameObject is a Creature with properties as set in the filter.
-        virtual bool pass(GameObject*) const;
-    private:
-        /// Only have alignment here. Can be mademore generic, if needed later on.
-        unsigned int mAlignment;
-    };
-
-    class _RlRulesExport InSceneSelectionFilter : public SelectionFilter
-    {
-    public:
-        InSceneSelectionFilter();
-
-        /// Return true, if the GameObject is in scene with properties as set in the filter.
-        virtual bool pass(GameObject*) const;
-    };
-
-    /// Superclass for all Selectors in RL.
-    /// Selectors provide a way to query for GameObjects in a game.
-    /// Either in the scene, or inventory, or anywhere else.
-    class _RlRulesExport Selector : public DebugVisualisable
-    {
-    public:
-        typedef std::vector&lt;GameObject*&gt; GameObjectVector;
-
-        Selector(unsigned long mask = 0xffffffff);
-        virtual ~Selector();
-        virtual void updateSelection();
-
-        void setSelectionMask(unsigned long mask);
-        unsigned long getSelectionMask() const;
-
-        /// Set an additional filter to narrow down selection. Set NULL, to unset filtering.
-        void setFilter(SelectionFilter*);
-        SelectionFilter* getFilter() const;
-
-        GameObject* getFirstSelectedObject() const;
-        const GameObjectVector&amp; getAllSelectedObjects() const;
-		unsigned int getSelectionCount() const;
-
-    protected:
-        GameObjectVector mSelection;
-        unsigned long mSelectionMask;
-        SelectionFilter* mFilter;
-
-        virtual const ActorVector&amp; doExecuteQuery() = 0;
-        /// Apply the filter if set, or just return true, if no selection filter is set.
-        virtual bool filter(GameObject*);
-    };
-
-
-    /// A Selector that selects all unoccluded GameObject the ray hits.
-    class _RlRulesExport RaySelector : public Selector
-    {
-    public:
-        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
-		~RaySelector();
-
-        void setRay(const Ogre::Vector3&amp; start, const Ogre::Vector3&amp; end);
-
-        // Overrides from DebugVisualisable
-
-        virtual DebugVisualisableFlag getFlag() const;
-        virtual void updatePrimitive();
-
-    protected:
-        RaySceneQuery* mQuery;
-
-        virtual const ActorVector&amp; doExecuteQuery();
-        virtual void doCreatePrimitive();
-    };
-
-    /// Selects this GameObject within a half sphere pointing to -Z,
-    /// that has the smallest angle difference to the -Z-Axis.
-    class _RlRulesExport HalfSphereSelector : public Selector
-    {
-    public:
-        HalfSphereSelector(Ogre::SceneManager* smgr, unsigned long mask = 0xffffffff);
-		HalfSphereSelector(unsigned long mask = 0xffffffff);
-
-        virtual void updateSelection();
-
-        void setRadius(Ogre::Real radius);
-
-        void setPosition(const Ogre::Vector3&amp; pos);
-
-        void setOrientation(const Ogre::Quaternion&amp; ori);
-
-        /// Instead of using transform set with setPosition/Orientation, use the
-        /// GameObject's transform. Set to NULL to disable tracking.
-        void track(GameObject* go);
-
-        /// If check is true, visibility is checked from the POV of the GameObject reference
-        /// This is currently done by casting a ray from the GameObject to the candidate GOs
-        void setCheckVisibility(bool check, GameObject* reference = NULL);
-
-        // Overrides from DebugVisualisable
-
-        virtual DebugVisualisableFlag getFlag() const;
-        virtual void updatePrimitive();
-
-    protected:
-        HalfSphereSceneQuery mQuery;
-        bool mCheckVisibility;
-        GameObject* mLoSReferenceGo;
-        GameObject* mTrackedGo;
-
-        virtual const ActorVector&amp; doExecuteQuery();
-
-        virtual void doCreatePrimitive();
-    };
-}
-#endif
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __RL_SELECTOR_H__
+#define __RL_SELECTOR_H__
+
+#include &quot;RulesPrerequisites.h&quot;
+#include &quot;SceneQuery.h&quot;
+#include &quot;GameObject.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;LineSetPrimitive.h&quot;
+#include &quot;DebugVisualisable.h&quot;
+
+namespace rl {
+
+    class _RlRulesExport SelectionFilter
+    {
+    public:
+        virtual ~SelectionFilter() {}
+        /// Return true, if the GameObject passes the filter, false else.
+        virtual bool pass(GameObject*) const = 0;
+    };
+
+    class _RlRulesExport CreatureSelectionFilter : public SelectionFilter
+    {
+    public:
+        CreatureSelectionFilter();
+
+        void setAlignmentMask(unsigned int);
+
+        /// Return true, if the GameObject is a Creature with properties as set in the filter.
+        virtual bool pass(GameObject*) const;
+    private:
+        /// Only have alignment here. Can be mademore generic, if needed later on.
+        unsigned int mAlignment;
+    };
+
+    class _RlRulesExport InSceneSelectionFilter : public SelectionFilter
+    {
+    public:
+        InSceneSelectionFilter();
+
+        /// Return true, if the GameObject is in scene with properties as set in the filter.
+        virtual bool pass(GameObject*) const;
+    };
+
+    /// Superclass for all Selectors in RL.
+    /// Selectors provide a way to query for GameObjects in a game.
+    /// Either in the scene, or inventory, or anywhere else.
+    class _RlRulesExport Selector : public DebugVisualisable
+    {
+    public:
+        Selector(unsigned long mask = 0xffffffff);
+        virtual ~Selector();
+        virtual void updateSelection();
+
+        void setSelectionMask(unsigned long mask);
+        unsigned long getSelectionMask() const;
+
+        /// Set an additional filter to narrow down selection. Set NULL, to unset filtering.
+        void setFilter(SelectionFilter*);
+        SelectionFilter* getFilter() const;
+
+        GameObject* getFirstSelectedObject() const;
+        const GameObjectList&amp; getAllSelectedObjects() const;
+		unsigned int getSelectionCount() const;
+
+    protected:
+        GameObjectList mSelection;
+        unsigned long mSelectionMask;
+        SelectionFilter* mFilter;
+
+        virtual const ActorVector&amp; doExecuteQuery() = 0;
+        /// Apply the filter if set, or just return true, if no selection filter is set.
+        virtual bool filter(GameObject*);
+    };
+
+
+    /// A Selector that selects all unoccluded GameObject the ray hits.
+    class _RlRulesExport RaySelector : public Selector
+    {
+    public:
+        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
+		~RaySelector();
+
+        void setRay(const Ogre::Vector3&amp; start, const Ogre::Vector3&amp; end);
+
+        // Overrides from DebugVisualisable
+
+        virtual DebugVisualisableFlag getFlag() const;
+        virtual void updatePrimitive();
+
+    protected:
+        RaySceneQuery* mQuery;
+
+        virtual const ActorVector&amp; doExecuteQuery();
+        virtual void doCreatePrimitive();
+    };
+
+    /// Selects this GameObject within a half sphere pointing to -Z,
+    /// that has the smallest angle difference to the -Z-Axis.
+    class _RlRulesExport HalfSphereSelector : public Selector
+    {
+    public:
+        HalfSphereSelector(Ogre::SceneManager* smgr, unsigned long mask = 0xffffffff);
+		HalfSphereSelector(unsigned long mask = 0xffffffff);
+
+        virtual void updateSelection();
+
+        void setRadius(Ogre::Real radius);
+
+        void setPosition(const Ogre::Vector3&amp; pos);
+
+        void setOrientation(const Ogre::Quaternion&amp; ori);
+
+        /// Instead of using transform set with setPosition/Orientation, use the
+        /// GameObject's transform. Set to NULL to disable tracking.
+        void track(GameObject* go);
+
+        /// If check is true, visibility is checked from the POV of the GameObject reference
+        /// This is currently done by casting a ray from the GameObject to the candidate GOs
+        void setCheckVisibility(bool check, GameObject* reference = NULL);
+
+        // Overrides from DebugVisualisable
+
+        virtual DebugVisualisableFlag getFlag() const;
+        virtual void updatePrimitive();
+
+    protected:
+        HalfSphereSceneQuery mQuery;
+        bool mCheckVisibility;
+        GameObject* mLoSReferenceGo;
+        GameObject* mTrackedGo;
+
+        virtual const ActorVector&amp; doExecuteQuery();
+
+        virtual void doCreatePrimitive();
+    };
+
+    /// Selects this GameObject within a sphere .
+    class _RlRulesExport SphereSelector : public Selector
+    {
+    public:
+        SphereSelector(Ogre::SceneManager* smgr, unsigned long mask = 0xffffffff);
+	SphereSelector(unsigned long mask = 0xffffffff);
+
+        virtual void updateSelection();
+
+        void setRadius(Ogre::Real radius);
+
+        void setPosition(const Ogre::Vector3&amp; pos);
+
+        /// Instead of using transform set with setPosition/Orientation, use the
+        /// GameObject's transform. Set to NULL to disable tracking.
+        void track(GameObject* go);
+
+        /// If check is true, visibility is checked from the POV of the GameObject reference
+        /// This is currently done by casting a ray from the GameObject to the candidate GOs
+        void setCheckVisibility(bool check, GameObject* reference = NULL);
+
+        // Overrides from DebugVisualisable
+
+        virtual DebugVisualisableFlag getFlag() const;
+        virtual void updatePrimitive();
+
+    protected:
+        SphereSceneQuery mQuery;
+        bool mCheckVisibility;
+        GameObject* mLoSReferenceGo;
+        GameObject* mTrackedGo;
+
+        virtual const ActorVector&amp; doExecuteQuery();
+
+        virtual void doCreatePrimitive();
+    };
+}
+#endif
+

Modified: rl/branches/persistence2/engine/rules/src/FetchItemJob.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/FetchItemJob.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/src/FetchItemJob.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -113,17 +113,29 @@
 		}
         else 
         {
-            // Hard set orientation.
-            /// @todo Use CreatureController properly to turn smoothly
+		
             Vector3 pos = mActor-&gt;getCreature()-&gt;getPosition();
             pos.y = 0;
             targetPos.y = 0;
-            mActor-&gt;getCreature()-&gt;setOrientation(Vector3::NEGATIVE_UNIT_Z.getRotationTo(targetPos - pos));
-            mActor-&gt;setMovement(CreatureController::MT_LAUFEN, Vector3::NEGATIVE_UNIT_Z, Vector3::ZERO);
-            
+            Degree realYawDiff = (mActor-&gt;getCreature()-&gt;getOrientation()*Vector3::NEGATIVE_UNIT_Z).getRotationTo(targetPos - pos).getYaw();
+            Vector3 rotation = Vector3::ZERO;
+            Quaternion currentOri(mActor-&gt;getYaw(), Vector3::UNIT_Y);
+            rotation.y = (currentOri*Vector3::NEGATIVE_UNIT_Z).getRotationTo(targetPos - pos).getYaw().valueRadians();
+
+            // old code for rotation:
+            //mActor-&gt;getCreature()-&gt;setOrientation(Vector3::NEGATIVE_UNIT_Z.getRotationTo(targetPos - pos));
+    
+            // first rotate, then move, is this the &quot;desired&quot; behaviour?
+            if( realYawDiff &gt; Degree(5) || realYawDiff &lt; Degree(-5) )
+                mActor-&gt;setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, rotation);
+            else
+                mActor-&gt;setMovement(CreatureController::MT_LAUFEN, Vector3::NEGATIVE_UNIT_Z, rotation);
+
+    
             mTimeLeft  -= time;
             return false;            
         }
 
 	}
 }
+

Modified: rl/branches/persistence2/engine/rules/src/GoToJob.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/GoToJob.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/src/GoToJob.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -18,6 +18,7 @@
 
 #include &quot;GoToJob.h&quot;
 
+#include &quot;Creature.h&quot;
 #include &quot;CreatureControllerManager.h&quot;
 #include &quot;MathUtil.h&quot;
 
@@ -25,24 +26,30 @@
 
 namespace rl
 {
-	GoToJob::GoToJob(const CeGuiString &amp;id, Creature* actor, const Vector3&amp; targetPos, Real maxDistance, Real duration)
+	GoToJob::GoToJob(const CeGuiString &amp;id, Creature* actor, const Vector3&amp; targetPos, Real maxDistance, Real duration, CreatureController::MovementType movementType_moving,
+            CreatureController::MovementType movementType_idle)
 		: Job(id, false, true, TimeSource::REALTIME_INTERRUPTABLE),
 		  mActor(NULL),
 		  mTarget(NULL),
 		  mTargetPos(targetPos),
 		  mMaxDistance(maxDistance),
-		  mTimeLeft(duration)
+		  mTimeLeft(duration),
+          mMovementType_moving(movementType_moving),
+          mMovementType_idle(movementType_idle)
 	{
 		mActor = CreatureControllerManager::getSingleton().getCreatureController(actor);
 	}
 
-	GoToJob::GoToJob(const CeGuiString &amp;id, Creature* actor, GameObject* target, Real maxDistance, Real duration)
+	GoToJob::GoToJob(const CeGuiString&amp; id, Creature* actor, GameObject* target, Real maxDistance, Real duration, CreatureController::MovementType movementType_moving,
+            CreatureController::MovementType movementType_idle)
 		: Job(id, false, true, TimeSource::REALTIME_INTERRUPTABLE),
 		  mActor(NULL),
 		  mTarget(target),
 		  mTargetPos(Vector3::ZERO),
 		  mMaxDistance(maxDistance),
-		  mTimeLeft(duration)
+		  mTimeLeft(duration),
+          mMovementType_moving(movementType_moving),
+          mMovementType_idle(movementType_idle)
 	{
 		mActor = CreatureControllerManager::getSingleton().getCreatureController(actor);
 	}
@@ -57,7 +64,7 @@
 		if (mTimeLeft &lt; 0)
 		{
 			// Stay put where ever we are.
-			mActor-&gt;setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
+			mActor-&gt;setMovement(mMovementType_idle, Vector3::ZERO, Vector3::ZERO);
 			return true;
 		}
         
@@ -79,20 +86,31 @@
 		if (distance &lt; mMaxDistance)
 		{
 			// Stay put where ever we are.
-			mActor-&gt;setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
+			mActor-&gt;setMovement(mMovementType_idle, Vector3::ZERO, Vector3::ZERO);
 			return true;
 		}
 
-		// Hard set orientation.
-		/// @todo Use CreatureController properly to turn smoothly
+
 		Vector3 pos = mActor-&gt;getCreature()-&gt;getPosition();
 		pos.y = 0;
 		Vector3 targetPos = mTargetPos;
 		targetPos.y = 0;
-		mActor-&gt;getCreature()-&gt;setOrientation(Vector3::NEGATIVE_UNIT_Z.getRotationTo(targetPos - pos));
-		mActor-&gt;setMovement(CreatureController::MT_LAUFEN, Vector3::NEGATIVE_UNIT_Z, Vector3::ZERO);
+        Degree realYawDiff = (mActor-&gt;getCreature()-&gt;getOrientation()*Vector3::NEGATIVE_UNIT_Z).getRotationTo(targetPos - pos).getYaw();
+        Vector3 rotation = Vector3::ZERO;
+        Quaternion currentOri(mActor-&gt;getYaw(), Vector3::UNIT_Y);
+        rotation.y = (currentOri*Vector3::NEGATIVE_UNIT_Z).getRotationTo(targetPos - pos).getYaw().valueRadians();
 
+        // old code for rotation:
+		//mActor-&gt;getCreature()-&gt;setOrientation(Vector3::NEGATIVE_UNIT_Z.getRotationTo(targetPos - pos));
+        
+        // first rotate, then move, is this the &quot;desired&quot; behaviour?
+        if( realYawDiff &gt; Degree(5) || realYawDiff &lt; Degree(-5) )
+            mActor-&gt;setMovement(mMovementType_idle, Vector3::ZERO, rotation);
+        else
+    		mActor-&gt;setMovement(mMovementType_moving, Vector3::NEGATIVE_UNIT_Z, rotation);
+
 		mTimeLeft  -= time;
 		return false;
 	}
 }
+

Modified: rl/branches/persistence2/engine/rules/src/Selector.cpp
===================================================================
--- rl/branches/persistence2/engine/rules/src/Selector.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/rules/src/Selector.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,304 +1,422 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;Selector.h&quot;
-#include &quot;SelectionHelper.h&quot;
-
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;PhysicsManager.h&quot;
-#include &quot;World.h&quot;
-
-using namespace Ogre;
-
-namespace rl
-{
-    CreatureSelectionFilter::CreatureSelectionFilter()
-        : mAlignment(Creature::ALIGNMENT_ALLY |
-                     Creature::ALIGNMENT_NEUTRAL |
-                     Creature::ALIGNMENT_ENEMY)
-    {
-    }
-
-    void CreatureSelectionFilter::setAlignmentMask(unsigned int mask)
-    {
-        mAlignment = mask;
-    }
-
-    bool CreatureSelectionFilter::pass(GameObject* go) const
-    {
-        Creature* creature = dynamic_cast&lt;Creature*&gt;(go);
-        if (creature != NULL)
-        {
-            return (mAlignment &amp; creature-&gt;getAlignment()) != 0;
-        }
-        return false;
-    }
-
-    InSceneSelectionFilter::InSceneSelectionFilter()
-    {
-    }
-
-    bool InSceneSelectionFilter::pass(GameObject* go) const
-    {
-        if (go-&gt;getState() == GOS_IN_SCENE)
-        {
-            return true;
-        }
-        return false;
-    }
-
-    Selector::Selector(unsigned long mask)
-		: DebugVisualisable(), mSelection(), mSelectionMask(mask), mFilter(NULL)
-    {
-    }
-
-    Selector::~Selector()
-    {
-    }
-
-    void Selector::setFilter(SelectionFilter* filter)
-    {
-        mFilter = filter;
-    }
-
-    SelectionFilter* Selector::getFilter() const
-    {
-        return mFilter;
-    }
-
-    void Selector::setSelectionMask(unsigned long mask)
-    {
-        mSelectionMask = mask;
-    }
-
-    unsigned long Selector::getSelectionMask() const
-    {
-        return mSelectionMask;
-    }
-
-    GameObject* Selector::getFirstSelectedObject() const
-    {
-        return mSelection.empty() ? NULL : mSelection[0];
-    }
-
-    const Selector::GameObjectVector&amp; Selector::getAllSelectedObjects() const
-    {
-        return mSelection;
-    }
-
-	unsigned int Selector::getSelectionCount() const
-	{
-		return mSelection.size();
-	}
-
-    void Selector::updateSelection()
-    {
-        // Remove old selection
-        mSelection.clear();
-
-        // Do the query, results are in proper order
-        const ActorVector&amp; actors = doExecuteQuery();
-
-        // Set selection to first result with a GameObject attached.
-        for (ActorVector::const_iterator it = actors.begin(), end = actors.end();
-            it != end; ++it)
-        {
-            Actor* actor = *it;
-            GameObject* go = static_cast&lt;GameObject*&gt;(actor-&gt;getGameObject());
-            if (go != NULL &amp;&amp; (go-&gt;getQueryFlags() &amp; mSelectionMask) &amp;&amp; filter(go))
-            {
-                mSelection.push_back(go);
-            }
-        }
-    }
-
-    bool Selector::filter(GameObject* go)
-    {
-        return mFilter == NULL || mFilter-&gt;pass(go);
-    }
-
-    //------------------------------------------------------------------------
-
-    RaySelector::RaySelector(unsigned long mask, bool useOgreQuery)
-        : Selector(mask)
-    {
-		if (useOgreQuery)
-		{
-			mQuery = new OgreRaySceneQuery(mask);
-		}
-		else
-		{
-			mQuery = new RaySceneQuery(mask);
-		}
-    }
-
-    void RaySelector::setRay(const Ogre::Vector3&amp; start, const Ogre::Vector3&amp; end)
-    {
-        mQuery-&gt;setRay(start, end);
-    }
-
-    // Overrides from DebugVisualisable
-    DebugVisualisableFlag RaySelector::getFlag() const
-    {
-        return DVF_CONTROL;
-    }
-
-    void RaySelector::updatePrimitive()
-    {
-        LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
-        lineSet-&gt;clear();
-        lineSet-&gt;addLine(mQuery-&gt;getRayStart(), mQuery-&gt;getRayEnd(), ColourValue::Red);
-    }
-
-    const ActorVector&amp; RaySelector::doExecuteQuery()
-    {
-        return mQuery-&gt;execute();
-    }
-
-    void RaySelector::doCreatePrimitive()
-    {
-        mPrimitive = new LineSetPrimitive();
-    }
-
-	RaySelector::~RaySelector()
-	{
-		delete mQuery;
-	}
-
-    //////////////////////////////////////////////////////////////////////////
-
-    HalfSphereSelector::HalfSphereSelector(Ogre::SceneManager* smgr,
-        unsigned long mask)
-        : Selector(mask),
-          mQuery(smgr, mask),
-          mCheckVisibility(false),
-          mLoSReferenceGo(NULL),
-		  mTrackedGo(NULL)
-    {
-    }
-
-    HalfSphereSelector::HalfSphereSelector(unsigned long mask)
-        : Selector(mask),
-		  mQuery(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager(), mask),
-          mCheckVisibility(false),
-          mLoSReferenceGo(NULL),
-		  mTrackedGo(NULL)
-    {
-    }
-
-    void HalfSphereSelector::updateSelection()
-    {
-        // Remove old selection
-        mSelection.clear();
-
-        // Auto tracking enabled?
-        if (mTrackedGo != NULL)
-        {
-            // If not in scene, then we're done
-            if ((mTrackedGo-&gt;getState() &amp; GOS_IN_SCENE) == 0)
-            {
-                return;
-            }
-
-            // Set query transform according to position and orientation of tracked GO.
-            setPosition(mTrackedGo-&gt;getPosition());
-            setOrientation(mTrackedGo-&gt;getOrientation());
-        }
-
-        // Do the query, results are in proper order
-        const ActorVector&amp; actors = doExecuteQuery();
-
-        // Set selection to first result with a GameObject attached.
-        for (ActorVector::const_iterator it = actors.begin(), end = actors.end();
-            it != end; ++it)
-        {
-            Actor* actor = *it;
-            GameObject* go = static_cast&lt;GameObject*&gt;(actor-&gt;getGameObject());
-            if (go != NULL &amp;&amp; (go-&gt;getQueryFlags() &amp; mSelectionMask))
-            {
-                // Is this GO seen when we need it to be seen?
-                if (mCheckVisibility &amp;&amp; mLoSReferenceGo &amp;&amp;
-                    !SelectionHelper::checkLineOfSight(mLoSReferenceGo, go))
-                {
-                    // Nope, check next.
-                    continue;
-                }
-                else if (filter(go))
-                {
-                    // Ok, LoS either not needed or given.
-                    mSelection.push_back(go);
-                }
-            }
-        }
-    }
-
-    void HalfSphereSelector::updatePrimitive()
-    {
-        LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
-        lineSet-&gt;clear();
-
-        Vector3 pos = mQuery.getPosition();
-        Quaternion ori = mQuery.getOrientation();
-        Real radius = mQuery.getRadius();
-
-        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::UNIT_X), ColourValue::Red);
-        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::UNIT_Y), ColourValue::Green);
-        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::NEGATIVE_UNIT_Z),
-            ColourValue::Blue);
-    }
-
-    void HalfSphereSelector::setRadius(Ogre::Real radius)
-    {
-        mQuery.setRadius(radius);
-    }
-
-    void HalfSphereSelector::setPosition(const Ogre::Vector3&amp; pos)
-    {
-        mQuery.setPosition(pos);
-    }
-
-    void HalfSphereSelector::setOrientation(const Ogre::Quaternion&amp; ori)
-    {
-        mQuery.setOrientation(ori);
-    }
-
-    void HalfSphereSelector::setCheckVisibility(bool check, GameObject* reference)
-    {
-        mCheckVisibility = check;
-        mLoSReferenceGo = reference;
-    }
-
-    void HalfSphereSelector::track(GameObject* go)
-    {
-        mTrackedGo = go;
-    }
-
-    DebugVisualisableFlag HalfSphereSelector::getFlag() const
-    {
-        return DVF_CONTROL;
-    }
-
-    const ActorVector&amp; HalfSphereSelector::doExecuteQuery()
-    {
-        return mQuery.execute();
-    }
-
-    void HalfSphereSelector::doCreatePrimitive()
-    {
-        mPrimitive = new LineSetPrimitive();
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;Selector.h&quot;
+#include &quot;SelectionHelper.h&quot;
+
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;PhysicsManager.h&quot;
+#include &quot;World.h&quot;
+
+using namespace Ogre;
+
+namespace rl
+{
+    CreatureSelectionFilter::CreatureSelectionFilter()
+        : mAlignment(Creature::ALIGNMENT_ALLY |
+                     Creature::ALIGNMENT_NEUTRAL |
+                     Creature::ALIGNMENT_ENEMY)
+    {
+    }
+
+    void CreatureSelectionFilter::setAlignmentMask(unsigned int mask)
+    {
+        mAlignment = mask;
+    }
+
+    bool CreatureSelectionFilter::pass(GameObject* go) const
+    {
+        Creature* creature = dynamic_cast&lt;Creature*&gt;(go);
+        if (creature != NULL)
+        {
+            return (mAlignment &amp; creature-&gt;getAlignment()) != 0;
+        }
+        return false;
+    }
+
+    InSceneSelectionFilter::InSceneSelectionFilter()
+    {
+    }
+
+    bool InSceneSelectionFilter::pass(GameObject* go) const
+    {
+        if (go-&gt;getState() == GOS_IN_SCENE)
+        {
+            return true;
+        }
+        return false;
+    }
+
+    Selector::Selector(unsigned long mask)
+		: DebugVisualisable(), mSelection(), mSelectionMask(mask), mFilter(NULL)
+    {
+    }
+
+    Selector::~Selector()
+    {
+    }
+
+    void Selector::setFilter(SelectionFilter* filter)
+    {
+        mFilter = filter;
+    }
+
+    SelectionFilter* Selector::getFilter() const
+    {
+        return mFilter;
+    }
+
+    void Selector::setSelectionMask(unsigned long mask)
+    {
+        mSelectionMask = mask;
+    }
+
+    unsigned long Selector::getSelectionMask() const
+    {
+        return mSelectionMask;
+    }
+
+    GameObject* Selector::getFirstSelectedObject() const
+    {
+        return mSelection.empty() ? NULL : *mSelection.begin();
+    }
+
+    const GameObjectList&amp; Selector::getAllSelectedObjects() const
+    {
+        return mSelection;
+    }
+
+	unsigned int Selector::getSelectionCount() const
+	{
+		return mSelection.size();
+	}
+
+    void Selector::updateSelection()
+    {
+        // Remove old selection
+        mSelection.clear();
+
+        // Do the query, results are in proper order
+        const ActorVector&amp; actors = doExecuteQuery();
+
+        // Set selection to first result with a GameObject attached.
+        for (ActorVector::const_iterator it = actors.begin(), end = actors.end();
+            it != end; ++it)
+        {
+            Actor* actor = *it;
+            GameObject* go = static_cast&lt;GameObject*&gt;(actor-&gt;getGameObject());
+            if (go != NULL &amp;&amp; (go-&gt;getQueryFlags() &amp; mSelectionMask) &amp;&amp; filter(go))
+            {
+                mSelection.push_back(go);
+            }
+        }
+    }
+
+    bool Selector::filter(GameObject* go)
+    {
+        return mFilter == NULL || mFilter-&gt;pass(go);
+    }
+
+    //------------------------------------------------------------------------
+
+    RaySelector::RaySelector(unsigned long mask, bool useOgreQuery)
+        : Selector(mask)
+    {
+		if (useOgreQuery)
+		{
+			mQuery = new OgreRaySceneQuery(mask);
+		}
+		else
+		{
+			mQuery = new RaySceneQuery(mask);
+		}
+    }
+
+    void RaySelector::setRay(const Ogre::Vector3&amp; start, const Ogre::Vector3&amp; end)
+    {
+        mQuery-&gt;setRay(start, end);
+    }
+
+    // Overrides from DebugVisualisable
+    DebugVisualisableFlag RaySelector::getFlag() const
+    {
+        return DVF_CONTROL;
+    }
+
+    void RaySelector::updatePrimitive()
+    {
+        LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
+        lineSet-&gt;clear();
+        lineSet-&gt;addLine(mQuery-&gt;getRayStart(), mQuery-&gt;getRayEnd(), ColourValue::Red);
+    }
+
+    const ActorVector&amp; RaySelector::doExecuteQuery()
+    {
+        return mQuery-&gt;execute();
+    }
+
+    void RaySelector::doCreatePrimitive()
+    {
+        mPrimitive = new LineSetPrimitive();
+    }
+
+	RaySelector::~RaySelector()
+	{
+		delete mQuery;
+	}
+
+    //////////////////////////////////////////////////////////////////////////
+
+    HalfSphereSelector::HalfSphereSelector(Ogre::SceneManager* smgr,
+        unsigned long mask)
+        : Selector(mask),
+          mQuery(smgr, mask),
+          mCheckVisibility(false),
+          mLoSReferenceGo(NULL),
+		  mTrackedGo(NULL)
+    {
+    }
+
+    HalfSphereSelector::HalfSphereSelector(unsigned long mask)
+        : Selector(mask),
+		  mQuery(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager(), mask),
+          mCheckVisibility(false),
+          mLoSReferenceGo(NULL),
+		  mTrackedGo(NULL)
+    {
+    }
+
+    void HalfSphereSelector::updateSelection()
+    {
+        // Remove old selection
+        mSelection.clear();
+
+        // Auto tracking enabled?
+        if (mTrackedGo != NULL)
+        {
+            // If not in scene, then we're done
+            if ((mTrackedGo-&gt;getState() &amp; GOS_IN_SCENE) == 0)
+            {
+                return;
+            }
+
+            // Set query transform according to position and orientation of tracked GO.
+            setPosition(mTrackedGo-&gt;getPosition());
+            setOrientation(mTrackedGo-&gt;getOrientation());
+        }
+
+        // Do the query, results are in proper order
+        const ActorVector&amp; actors = doExecuteQuery();
+
+        // Set selection to first result with a GameObject attached.
+        for (ActorVector::const_iterator it = actors.begin(), end = actors.end();
+            it != end; ++it)
+        {
+            Actor* actor = *it;
+            GameObject* go = static_cast&lt;GameObject*&gt;(actor-&gt;getGameObject());
+            if (go != NULL &amp;&amp; (go-&gt;getQueryFlags() &amp; mSelectionMask))
+            {
+                // Is this GO seen when we need it to be seen?
+                if (mCheckVisibility &amp;&amp; mLoSReferenceGo &amp;&amp;
+                    !SelectionHelper::checkLineOfSight(mLoSReferenceGo, go))
+                {
+                    // Nope, check next.
+                    continue;
+                }
+                else if (filter(go))
+                {
+                    // Ok, LoS either not needed or given.
+                    mSelection.push_back(go);
+                }
+            }
+        }
+    }
+
+    void HalfSphereSelector::updatePrimitive()
+    {
+        LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
+        lineSet-&gt;clear();
+
+        Vector3 pos = mQuery.getPosition();
+        Quaternion ori = mQuery.getOrientation();
+        Real radius = mQuery.getRadius();
+
+        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::UNIT_X), ColourValue::Red);
+        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::UNIT_Y), ColourValue::Green);
+        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::NEGATIVE_UNIT_Z),
+            ColourValue::Blue);
+    }
+
+    void HalfSphereSelector::setRadius(Ogre::Real radius)
+    {
+        mQuery.setRadius(radius);
+    }
+
+    void HalfSphereSelector::setPosition(const Ogre::Vector3&amp; pos)
+    {
+        mQuery.setPosition(pos);
+    }
+
+    void HalfSphereSelector::setOrientation(const Ogre::Quaternion&amp; ori)
+    {
+        mQuery.setOrientation(ori);
+    }
+
+    void HalfSphereSelector::setCheckVisibility(bool check, GameObject* reference)
+    {
+        mCheckVisibility = check;
+        mLoSReferenceGo = reference;
+    }
+
+    void HalfSphereSelector::track(GameObject* go)
+    {
+        mTrackedGo = go;
+    }
+
+    DebugVisualisableFlag HalfSphereSelector::getFlag() const
+    {
+        return DVF_CONTROL;
+    }
+
+    const ActorVector&amp; HalfSphereSelector::doExecuteQuery()
+    {
+        return mQuery.execute();
+    }
+
+    void HalfSphereSelector::doCreatePrimitive()
+    {
+        mPrimitive = new LineSetPrimitive();
+    }
+
+    //////////////////////////////////////////////////////////////////////////
+
+    SphereSelector::SphereSelector(Ogre::SceneManager* smgr,
+        unsigned long mask)
+        : Selector(mask),
+          mQuery(smgr, mask),
+          mCheckVisibility(false),
+          mLoSReferenceGo(NULL),
+		  mTrackedGo(NULL)
+    {
+    }
+
+    SphereSelector::SphereSelector(unsigned long mask)
+        : Selector(mask),
+		  mQuery(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager(), mask),
+          mCheckVisibility(false),
+          mLoSReferenceGo(NULL),
+		  mTrackedGo(NULL)
+    {
+    }
+
+    void SphereSelector::updateSelection()
+    {
+        // Remove old selection
+        mSelection.clear();
+
+        // Auto tracking enabled?
+        if (mTrackedGo != NULL)
+        {
+            // If not in scene, then we're done
+            if (!(mTrackedGo-&gt;getState() &amp; GOS_IN_SCENE))
+            {
+                return;
+            }
+
+            // Set query transform according to position and orientation of tracked GO.
+            setPosition(mTrackedGo-&gt;getPosition());
+        }
+
+        // Do the query, results are in proper order
+        const ActorVector&amp; actors = doExecuteQuery();
+
+        // Set selection to first result with a GameObject attached.
+        for (ActorVector::const_iterator it = actors.begin(), end = actors.end();
+            it != end; ++it)
+        {
+            Actor* actor = *it;
+            GameObject* go = static_cast&lt;GameObject*&gt;(actor-&gt;getGameObject());
+            if (go != NULL &amp;&amp; (go-&gt;getQueryFlags() &amp; mSelectionMask))
+            {
+                // Is this GO seen when we need it to be seen?
+                if (mCheckVisibility &amp;&amp; mLoSReferenceGo &amp;&amp;
+                    !SelectionHelper::checkLineOfSight(mLoSReferenceGo, go))
+                {
+                    // Nope, check next.
+                    continue;
+                }
+                else if (filter(go))
+                {
+                    // Ok, LoS either not needed or given.
+                    mSelection.push_back(go);
+                }
+            }
+        }
+    }
+
+    void SphereSelector::updatePrimitive()
+    {
+        LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
+        lineSet-&gt;clear();
+
+        Vector3 pos = mQuery.getPosition();
+        Quaternion ori = mQuery.getOrientation();
+        Real radius = mQuery.getRadius();
+
+        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::UNIT_X), ColourValue::Red);
+        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::UNIT_Y), ColourValue::Green);
+        lineSet-&gt;addLine(pos, pos + radius * (ori * Vector3::NEGATIVE_UNIT_Z),
+            ColourValue::Blue);
+    }
+
+    void SphereSelector::setRadius(Ogre::Real radius)
+    {
+        mQuery.setRadius(radius);
+    }
+
+    void SphereSelector::setPosition(const Ogre::Vector3&amp; pos)
+    {
+        mQuery.setPosition(pos);
+    }
+
+    void SphereSelector::setCheckVisibility(bool check, GameObject* reference)
+    {
+        mCheckVisibility = check;
+        mLoSReferenceGo = reference;
+    }
+
+    void SphereSelector::track(GameObject* go)
+    {
+        mTrackedGo = go;
+    }
+
+    DebugVisualisableFlag SphereSelector::getFlag() const
+    {
+        return DVF_CONTROL;
+    }
+
+    const ActorVector&amp; SphereSelector::doExecuteQuery()
+    {
+        return mQuery.execute();
+    }
+
+    void SphereSelector::doCreatePrimitive()
+    {
+        mPrimitive = new LineSetPrimitive();
+    }
+
+}

Modified: rl/branches/persistence2/engine/script/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/script/CMakeLists.txt	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/script/CMakeLists.txt	2009-04-01 20:08:44 UTC (rev 4879)
@@ -8,6 +8,7 @@
 ${RL_RULES_INCLUDE_DIR}
 ${RL_AI_INCLUDE_DIR}
 ${RL_UI_INCLUDE_DIR}
+${XERCESC_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR}

Modified: rl/branches/persistence2/engine/script/RlScript2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/script/RlScript2005.vcproj	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/script/RlScript2005.vcproj	2009-04-01 20:08:44 UTC (rev 4879)
@@ -39,9 +39,9 @@
 			/&gt;
 			&lt;Tool
 				Name=&quot;VCCLCompilerTool&quot;
-				AdditionalOptions=&quot;-Zm130&quot;
+				AdditionalOptions=&quot;-Zm144&quot;
 				Optimization=&quot;0&quot;
-				AdditionalIncludeDirectories=&quot;.\include;..\common\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\OgreNewt_ngt\inc;..\..\dependencies\NewtonSDK2\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\opensteer\include;..\..\dependencies\ois\includes&quot;
+				AdditionalIncludeDirectories=&quot;.\include;..\common\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\OgreNewt\inc;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\opensteer\include;..\..\dependencies\ois\includes&quot;
 				PreprocessorDefinitions=&quot;WITH_FMOD3;WIN32;_DEBUG;_WINDOWS;_USRDLL;RLSCRIPT_EXPORTS;_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES;RL_USE_PCH&quot;
 				MinimalRebuild=&quot;true&quot;
 				BasicRuntimeChecks=&quot;3&quot;
@@ -69,7 +69,7 @@
 				AdditionalDependencies=&quot;RlCore.lib RlAi.lib RlUi.lib RlRules.lib OgreMain_d.lib msvcrt-ruby18.lib CEGUIBase_d.lib xerces-c_2D.lib OgreNewt_d.lib Newton.lib&quot;
 				OutputFile=&quot;$(OutDir)/RlScript.dll&quot;
 				LinkIncremental=&quot;2&quot;
-				AdditionalLibraryDirectories=&quot;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt_ngt\lib;..\..\dependencies\NewtonSDK2\sdk\x32\dll_vs7&quot;
+				AdditionalLibraryDirectories=&quot;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7&quot;
 				GenerateDebugInformation=&quot;true&quot;
 				AssemblyDebug=&quot;1&quot;
 				ProgramDatabaseFile=&quot;$(OutDir)/RlScript.pdb&quot;
@@ -131,7 +131,7 @@
 			&lt;Tool
 				Name=&quot;VCCLCompilerTool&quot;
 				AdditionalOptions=&quot;-Zm130&quot;
-				AdditionalIncludeDirectories=&quot;.\include;..\common\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\opensteer\include;..\..\dependencies\ois\includes&quot;
+				AdditionalIncludeDirectories=&quot;.\include;..\common\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\OgreNewt\inc;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\opensteer\include;..\..\dependencies\ois\includes&quot;
 				PreprocessorDefinitions=&quot;WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_USRDLL;RLSCRIPT_EXPORTS;_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES;RL_USE_PCH&quot;
 				RuntimeLibrary=&quot;2&quot;
 				RuntimeTypeInfo=&quot;true&quot;
@@ -155,7 +155,7 @@
 				AdditionalDependencies=&quot;RlCore.lib RlAi.lib RlUi.lib RlRules.lib OgreMain.lib msvcrt-ruby18.lib CEGUIBase.lib xerces-c_2.lib OgreNewt.lib Newton.lib&quot;
 				OutputFile=&quot;$(OutDir)/RlScript.dll&quot;
 				LinkIncremental=&quot;1&quot;
-				AdditionalLibraryDirectories=&quot;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll&quot;
+				AdditionalLibraryDirectories=&quot;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\ui\lib\$(ConfigurationName)&quot;;&quot;..\ai\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7&quot;
 				GenerateDebugInformation=&quot;false&quot;
 				SubSystem=&quot;2&quot;
 				OptimizeReferences=&quot;2&quot;

Copied: rl/branches/persistence2/engine/script/RlScript2008.vcproj (from rev 4878, rl/trunk/engine/script/RlScript2008.vcproj)

Modified: rl/branches/persistence2/engine/script/swig/RlAi.swig
===================================================================
--- rl/branches/persistence2/engine/script/swig/RlAi.swig	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/script/swig/RlAi.swig	2009-04-01 20:08:44 UTC (rev 4879)
@@ -83,7 +83,7 @@
     class AgentDialogState : public rl::AgentState
     {
     public:
-        void setDialogPartner(rl::Agent* partner);
+        void addDialogPartner(rl::Agent* partner);
         void setDialog(rl::Dialog* dialog);
     private:
         AgentDialogState(rl::Agent* agent);
@@ -302,7 +302,7 @@
     public:
         static rl::DialogManager&amp; getSingleton();
         rl::Dialog* createDialog(const Ogre::String&amp; name, rl::Creature* npc);
-        rl::Dialog* createDialog(const Ogre::String&amp; name, const std::list&lt;rl::Creature*&gt;&amp; npcs);
+        rl::Dialog* createDialog(const Ogre::String&amp; name, rl::CreatureList&amp; npcs);
     private:
         DialogManager();
     };

Modified: rl/branches/persistence2/engine/script/swig/RlCore.swig
===================================================================
--- rl/branches/persistence2/engine/script/swig/RlCore.swig	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/script/swig/RlCore.swig	2009-04-01 20:08:44 UTC (rev 4879)
@@ -702,6 +702,12 @@
 
     void removeAndDestroyPhysicalThing(PhysicalThing* thing);
 
+    void createPhysicsProxy(PhysicalThing* pt);
+
+    void createPhysicsProxy_RagDoll(PhysicalThing* pt);
+
+    void destroyPhysicsProxy(PhysicalThing* pt);
+
     // Global Settings
     void setGravity(Ogre::Real x, Ogre::Real y, Ogre::Real z);
     Ogre::Vector3 getGravity() const;

Modified: rl/branches/persistence2/engine/script/swig/RlExports.i
===================================================================
--- rl/branches/persistence2/engine/script/swig/RlExports.i	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/script/swig/RlExports.i	2009-04-01 20:08:44 UTC (rev 4879)
@@ -197,13 +197,17 @@
 // da dies in allen erzeugten Exceptionhandlern auftritt
 %{
 #pragma warning( disable : 4101 )									
+#include &quot;FixRubyHeaders.h&quot;
 %}
 
 // Include bodies
 
 %include &quot;RlCommon.swig&quot;
 %include &quot;RlCore.swig&quot;
+%include &quot;RlUi.swig&quot;
 %include &quot;RlRules.swig&quot;
-%include &quot;RlUi.swig&quot;
 %include &quot;RlAi.swig&quot;
+%{
+    #include &quot;FixRubyHeaders.h&quot;
+%}
 %include &quot;RlScript.swig&quot;

Modified: rl/branches/persistence2/engine/script/swig/RlRules.swig
===================================================================
--- rl/branches/persistence2/engine/script/swig/RlRules.swig	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/script/swig/RlRules.swig	2009-04-01 20:08:44 UTC (rev 4879)
@@ -119,7 +119,7 @@
         GameObjectFactory();
         virtual ~GameObjectFactory();
     };
-
+    
     class GameObjectManager
     {
     public:
@@ -127,6 +127,7 @@
         rl::GameObject* createGameObject(const Ogre::String&amp; classId, const rl::CeGuiString &amp;id = &quot;&quot;);
         rl::GameObject* getGameObject(const rl::CeGuiString id) const;
         void setGameObjectFactory(rl::GameObjectFactory* gof);
+        rl::GameObjectList getAllGameObjects();
 
     private:
         GameObjectManager();
@@ -874,7 +875,7 @@
         unsigned long getSelectionMask() const;
 
         GameObject* getFirstSelectedObject() const;
-		const std::vector&lt;GameObject*&gt;&amp; getAllSelectedObjects() const;
+		const rl::GameObjectList&amp; getAllSelectedObjects() const;
 		unsigned int getSelectionCount() const;
 
 		virtual void updatePrimitive() = 0;
@@ -901,6 +902,16 @@
         void setOrientation(const Ogre::Quaternion&amp; ori);
 		virtual void updatePrimitive();
 	};
+
+    /// Selects GameObjects within a sphere.
+    class SphereSelector : public Selector
+    {
+    public:
+        SphereSelector(unsigned long mask = 0xffffffff);
+	    void setRadius(Ogre::Real radius);
+        void setPosition(const Ogre::Vector3&amp; pos);
+		virtual void updatePrimitive();
+    };
     
     class PartyManager
     {

Modified: rl/branches/persistence2/engine/script/swig/TypeDynamicDirector.swig
===================================================================
--- rl/branches/persistence2/engine/script/swig/TypeDynamicDirector.swig	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/script/swig/TypeDynamicDirector.swig	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,90 +1,90 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-/* Typemaps for all Dynamic or Director Types
- * These typemaps ensure no C++ object 
- * will have links to more than one Ruby objecz
- * 
- */
-
-%{
-static VALUE getInScriptObject( void* ptr, swig_type_info *type )
-{
-    VALUE val = SWIG_RubyInstanceFor( ptr );
-	
-	// Es gab das SkriptObjekt noch nicht
-	if( NIL_P(val) ) 
-		return SWIG_NewPointerObj(ptr, type, 0);			
-	else	
-		return val;
-}
-%}
-
-/// @todo unbenutzt???
-// Actor* getActor oder andere OUTPUT Parameter
-%typemap(out) SWIGTYPE*
-&quot;   $result = getInScriptObject((void *) $1, $1_descriptor );&quot; 
-
-%{
-static VALUE getDirectorInScriptObject( Swig::Director * dir, void* ptr, swig_type_info *type )
-{
-    // Auf Director testen
-    if ( dir ) 
-        return dir-&gt;swig_get_self();
-
-	return getInScriptObject( ptr, type );
-}
-%}
-
-/// @todo unbenutzt???
-// doWithActor( Actor* ) oder andere Director-Methoden Parameter
-%typemap(directorin) SWIGTYPE*
-&quot;   $input = getDirectorInScriptObject(dynamic_cast&lt; Swig::Director * &gt;($1), (void *)$1, $1_descriptor);&quot; 
-
-%{
-static VALUE getOutScriptObject( void* ptr, swig_type_info *type )
-{
-	VALUE val = SWIG_RubyInstanceFor( ptr );
-	
-	// Es gab das SkriptObjekt noch nicht
-	if (NIL_P(val))
-	{
-		// Dynamic Cast ausfhren
-		swig_type_info *ty = SWIG_TypeDynamicCast(type, &amp;ptr);
-		return SWIG_NewPointerObj( ptr, ty, 0);		
-	}
-	else	
-		return val;
-}
-%}
-
-// Animation* getActor oder andere OUTPUT Parameter f&#252;r DYNAMICs
-%typemap(out) SWIGTYPE* DYNAMIC, SWIGTYPE&amp; DYNAMIC
-&quot;   $result = getOutScriptObject((void *) $1, $1_descriptor );&quot;
-
-%{
-static VALUE getDirectorOutScriptObject( Swig::Director * dir, void* ptr, swig_type_info *type )
-{
-	if (dir) 
-        return dir-&gt;swig_get_self();        	
-
-	return getOutScriptObject( ptr, type );
-}
-%}
-
-// doWithAnimation( Animation* ) oder andere Director-Methoden Parameter fr DYNAMICs
-%typemap(directorin) SWIGTYPE* DYNAMIC, SWIGTYPE&amp; DYNAMIC
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+/* Typemaps for all Dynamic or Director Types
+ * These typemaps ensure no C++ object 
+ * will have links to more than one Ruby objecz
+ * 
+ */
+
+%{
+static VALUE getInScriptObject( void* ptr, swig_type_info *type )
+{
+    VALUE val = SWIG_RubyInstanceFor( ptr );
+	
+	// Es gab das SkriptObjekt noch nicht
+	if( NIL_P(val) ) 
+		return SWIG_NewPointerObj(ptr, type, 0);			
+	else	
+		return val;
+}
+%}
+
+/// @todo unbenutzt???
+// Actor* getActor oder andere OUTPUT Parameter
+%typemap(out) SWIGTYPE*
+&quot;   $result = getInScriptObject((void *) $1, $1_descriptor );&quot; 
+
+%{
+static VALUE getDirectorInScriptObject( Swig::Director * dir, void* ptr, swig_type_info *type )
+{
+    // Auf Director testen
+    if ( dir ) 
+        return dir-&gt;swig_get_self();
+
+	return getInScriptObject( ptr, type );
+}
+%}
+
+/// @todo unbenutzt???
+// doWithActor( Actor* ) oder andere Director-Methoden Parameter
+%typemap(directorin) SWIGTYPE*
+&quot;   $input = getDirectorInScriptObject(dynamic_cast&lt; Swig::Director * &gt;($1), (void *)$1, $1_descriptor);&quot; 
+
+%{
+static VALUE getOutScriptObject( void* ptr, swig_type_info *type )
+{
+	VALUE val = SWIG_RubyInstanceFor( ptr );
+	
+	// Es gab das SkriptObjekt noch nicht
+	if (NIL_P(val))
+	{
+		// Dynamic Cast ausfhren
+		swig_type_info *ty = SWIG_TypeDynamicCast(type, &amp;ptr);
+		return SWIG_NewPointerObj( ptr, ty, 0);		
+	}
+	else	
+		return val;
+}
+%}
+
+// Animation* getActor oder andere OUTPUT Parameter f&#194;&#184;r DYNAMICs
+%typemap(out) SWIGTYPE* DYNAMIC, SWIGTYPE&amp; DYNAMIC
+&quot;   $result = getOutScriptObject((void *) $1, $1_descriptor );&quot;
+
+%{
+static VALUE getDirectorOutScriptObject( Swig::Director * dir, void* ptr, swig_type_info *type )
+{
+	if (dir) 
+        return dir-&gt;swig_get_self();        	
+
+	return getOutScriptObject( ptr, type );
+}
+%}
+
+// doWithAnimation( Animation* ) oder andere Director-Methoden Parameter fr DYNAMICs
+%typemap(directorin) SWIGTYPE* DYNAMIC, SWIGTYPE&amp; DYNAMIC
 &quot;   $input = getDirectorOutScriptObject(dynamic_cast&lt; Swig::Director * &gt;($1), (void *) $1, $1_descriptor );&quot; 
\ No newline at end of file

Modified: rl/branches/persistence2/engine/script/swig/TypeMaps.i
===================================================================
--- rl/branches/persistence2/engine/script/swig/TypeMaps.i	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/script/swig/TypeMaps.i	2009-04-01 20:08:44 UTC (rev 4879)
@@ -17,6 +17,7 @@
 #ifndef __RL_DYNAMICCAST_I__
 #define __RL_DYNAMICCAST_I__
 
+%include &quot;TypeDynamicDirector.swig&quot;
 %include &quot;TypeOgreColourValue.swig&quot;
 %include &quot;TypeOgreQuaternion.swig&quot;
 %include &quot;TypeOgreRadian.swig&quot;
@@ -26,9 +27,9 @@
 %include &quot;TypeOgreVector3.swig&quot;
 %include &quot;TypeRlCeGuiString.swig&quot;
 %include &quot;TypeRlCeGuiStringVector.swig&quot;
+%include &quot;TypeRlGameObjectList.swig&quot;
 %include &quot;TypeRlProperty.swig&quot;
 %include &quot;TypeRlPropertyKeys.swig&quot;
 %include &quot;TypeStdPairIntInt.swig&quot;
-%include &quot;TypeDynamicDirector.swig&quot;
 
 #endif

Copied: rl/branches/persistence2/engine/script/swig/TypeRlGameObjectList.swig (from rev 4878, rl/trunk/engine/script/swig/TypeRlGameObjectList.swig)

Modified: rl/branches/persistence2/engine/startup/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/startup/CMakeLists.txt	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/startup/CMakeLists.txt	2009-04-01 20:08:44 UTC (rev 4879)
@@ -5,6 +5,7 @@
 ${RL_AI_INCLUDE_DIR}
 ${RL_UI_INCLUDE_DIR}
 ${RL_SCRIPT_INCLUDE_DIR}
+${XERCESC_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR}
@@ -17,4 +18,4 @@
 
 TARGET_LINK_LIBRARIES(rastullah RlCommon RlCore RlRules RlAi RlUi RlScript)
 
-INSTALL(TARGETS rastullah RUNTIME DESTINATION ${CMAKE_INSTALL_PREFIX}/${BINDIR})
\ No newline at end of file
+INSTALL(TARGETS rastullah RUNTIME DESTINATION ${CMAKE_INSTALL_PREFIX}/${BINDIR})

Modified: rl/branches/persistence2/engine/startup/RlStartup2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/startup/RlStartup2005.vcproj	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/startup/RlStartup2005.vcproj	2009-04-01 20:08:44 UTC (rev 4879)
@@ -41,7 +41,7 @@
 			&lt;Tool
 				Name=&quot;VCCLCompilerTool&quot;
 				Optimization=&quot;0&quot;
-				AdditionalIncludeDirectories=&quot;.\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;..\common\include;..\script\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\ois\includes&quot;
+				AdditionalIncludeDirectories=&quot;.\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;..\common\include;..\script\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\OgreNewt\inc;..\..\dependencies\NewtonSDK\sdk;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\ois\includes&quot;
 				PreprocessorDefinitions=&quot;WIN32;_DEBUG;_WINDOWS;_CRT_SECURE_NO_DEPRECATE&quot;
 				MinimalRebuild=&quot;true&quot;
 				BasicRuntimeChecks=&quot;3&quot;
@@ -131,7 +131,7 @@
 				Optimization=&quot;2&quot;
 				InlineFunctionExpansion=&quot;1&quot;
 				OmitFramePointers=&quot;true&quot;
-				AdditionalIncludeDirectories=&quot;.\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;..\common\include;..\script\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\ois\includes&quot;
+				AdditionalIncludeDirectories=&quot;.\include;..\core\include;..\dialog\include;..\rules\include;..\ai\include;..\ui\include;..\common\include;..\script\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\xerces\include;..\..\dependencies\boost\include;..\..\dependencies\OgreNewt\inc;..\..\dependencies\NewtonSDK\sdk;..\..\dependencies\ogrenew\dependencies\include;..\..\dependencies\ois\includes&quot;
 				PreprocessorDefinitions=&quot;WIN32;NDEBUG;_WINDOWS;_CRT_SECURE_NO_DEPRECATE&quot;
 				StringPooling=&quot;true&quot;
 				RuntimeLibrary=&quot;2&quot;

Copied: rl/branches/persistence2/engine/startup/RlStartup2008.vcproj (from rev 4878, rl/trunk/engine/startup/RlStartup2008.vcproj)

Modified: rl/branches/persistence2/engine/ui/CMakeLists.txt
===================================================================
--- rl/branches/persistence2/engine/ui/CMakeLists.txt	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/CMakeLists.txt	2009-04-01 20:08:44 UTC (rev 4879)
@@ -4,6 +4,7 @@
 ${RL_CORE_INCLUDE_DIR}
 ${RL_RULES_INCLUDE_DIR}
 ${RL_AI_INCLUDE_DIR}
+${XERCESC_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${OIS_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}

Modified: rl/branches/persistence2/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/branches/persistence2/engine/ui/RlUI2005.vcproj	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/RlUI2005.vcproj	2009-04-01 20:08:44 UTC (rev 4879)
@@ -46,9 +46,9 @@
 			/&gt;
 			&lt;Tool
 				Name=&quot;VCCLCompilerTool&quot;
-				AdditionalOptions=&quot;-Zm140&quot;
+				AdditionalOptions=&quot;-Zm144&quot;
 				Optimization=&quot;0&quot;
-				AdditionalIncludeDirectories=&quot;.\include;..\common\include;..\ai\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt_ngt\inc;..\..\dependencies\NewtonSDK2\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes&quot;
+				AdditionalIncludeDirectories=&quot;.\include;..\common\include;..\ai\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\inc;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes&quot;
 				PreprocessorDefinitions=&quot;WITH_FMOD3;_WINDOWS,_DEBUG,WIN32,RLUI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH&quot;
 				MinimalRebuild=&quot;true&quot;
 				BasicRuntimeChecks=&quot;3&quot;
@@ -90,7 +90,7 @@
 				OutputFile=&quot;$(OutDir)/RlUI.dll&quot;
 				LinkIncremental=&quot;2&quot;
 				SuppressStartupBanner=&quot;true&quot;
-				AdditionalLibraryDirectories=&quot;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt_ngt\lib;..\..\dependencies\NewtonSDK2\sdk\x32\dll_vs7;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;&quot;
+				AdditionalLibraryDirectories=&quot;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;&quot;
 				IgnoreDefaultLibraryNames=&quot;&quot;
 				GenerateDebugInformation=&quot;true&quot;
 				AssemblyDebug=&quot;1&quot;
@@ -162,7 +162,7 @@
 				Optimization=&quot;3&quot;
 				EnableIntrinsicFunctions=&quot;true&quot;
 				FavorSizeOrSpeed=&quot;1&quot;
-				AdditionalIncludeDirectories=&quot;.\include;..\common\include;..\ai\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes&quot;
+				AdditionalIncludeDirectories=&quot;.\include;..\common\include;..\ai\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\inc;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes&quot;
 				PreprocessorDefinitions=&quot;WITH_FMOD3;NDEBUG,_WINDOWS,WIN32,RLUI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH&quot;
 				StringPooling=&quot;false&quot;
 				ExceptionHandling=&quot;1&quot;
@@ -199,7 +199,7 @@
 				OutputFile=&quot;$(OutDir)/RlUI.dll&quot;
 				LinkIncremental=&quot;1&quot;
 				SuppressStartupBanner=&quot;true&quot;
-				AdditionalLibraryDirectories=&quot;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;&quot;..\..\dependencies\OgreNewt\lib\$(ConfigurationName)&quot;;..\..\dependencies\NewtonSDK\sdk\dll;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;&quot;
+				AdditionalLibraryDirectories=&quot;&quot;..\core\lib\$(ConfigurationName)&quot;;&quot;..\rules\lib\$(ConfigurationName)&quot;;&quot;..\uicomponents\lib\$(ConfigurationName)&quot;;..\..\dependencies\ogrenew\lib;..\..\dependencies\ruby\lib;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\xerces\lib;..\..\dependencies\OgreNewt\lib;..\..\dependencies\NewtonSDK\sdk\x32\dll_vs7;..\..\dependencies\ois\dll;&quot;..\..\dependencies\ogrenew\lib\$(ConfigurationName)&quot;&quot;
 				ProgramDatabaseFile=&quot;&quot;
 				SubSystem=&quot;2&quot;
 			/&gt;
@@ -369,6 +369,10 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\include\DialogController.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\include\DialogControlState.h&quot;
 				&gt;
 			&lt;/File&gt;
@@ -602,6 +606,10 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\src\DialogController.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\src\DialogControlState.cpp&quot;
 				&gt;
 			&lt;/File&gt;

Copied: rl/branches/persistence2/engine/ui/RlUI2008.vcproj (from rev 4878, rl/trunk/engine/ui/RlUI2008.vcproj)

Modified: rl/branches/persistence2/engine/ui/include/DialogControlState.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/DialogControlState.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/include/DialogControlState.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,100 +1,91 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __DialogCharacterController_H__
-#define __DialogCharacterController_H__
-
-#include &quot;UiPrerequisites.h&quot;
-#include &quot;DialogController.h&quot;
-
-namespace rl {
-
-	class Actor;
-    class Creature;
-	class Dialog;
-    class DialogElement;
-	class DialogWindow;
-	class GameLoggerWindow;
-	class MeshAnimation;
-	class SoundObject;
-	class SubtitleWindow;
-
-	/** Diese Klasse
-	  *
-	  */
-	class _RlUiExport DialogControlState : public DialogController
-	{
-	public:
-        enum DialogMode
-		{
-            // Frontperspektive auf Augenh&#239;&#191;&#189;he, ausgehend von der Mitte zwischen den Redenden
-			DM_FRONT = 1,
-		};
-
-
-		/**
-		*  @throw NullPointerException if camera or character is NULL.
-		*  @throw InvalidArgumentException if character is not placed in the scene.
-		*/
-		DialogControlState(CommandMapper* cmdMapper, Actor* camera, Creature* character);
-		/// Dtor
-		virtual ~DialogControlState();
-
-        virtual void pause();
-        virtual void resume();
-
-		/// @override
-		virtual void run(Ogre::Real elapsedTime);
-
-		void start(Dialog* dialog);
-
-		/// Antwort eines der Dialogf&#239;&#191;&#189;hrenden
-		void response(Actor* actor, const CeGuiString&amp; text, const Ogre::String&amp; soundFile = &quot;&quot;);
-
-		bool handleDialogSelectOption(DialogOption* option);
-		virtual void handleDialogEnd();
-		bool requestDialogClose();
-	    virtual bool textFinished();
-
-	private:
-        enum DialogState
-        {
-            CHOOSING_OPTION = 1,
-            TALKING_PARTNER_CHARACTER,
-            TALKING_PLAYER_CHARACTER,
-            CLOSING_DIALOG
-        };
-
-		/// Die Zielkameraposition in lokalen Koordinaten
-		Ogre::Vector3 mTargetCameraPosition;
-		/// Die ben&#239;&#191;&#189;tigte lokale Drehung der Kamera
-		Ogre::Vector3 mTargetCameraDirection;
-
-
-        /// Die Art der Kamerapositionierung
-        DialogMode mDialogMode;
-
-        DialogState mDialogState;
-
-
-		DialogWindow* mDialogWindow;
-
-        virtual void recalculateDialogCamera(Creature* speaker, std::list&lt;Creature*&gt; listeners);
-
-        void showOptions(const std::list&lt;DialogOption*&gt;&amp; options);
-	};
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __DialogCharacterController_H__
+#define __DialogCharacterController_H__
+
+#include &quot;UiPrerequisites.h&quot;
+#include &quot;DialogController.h&quot;
+
+namespace rl {
+
+	class Actor;
+    class Creature;
+	class Dialog;
+    class DialogElement;
+	class DialogWindow;
+	class GameLoggerWindow;
+	class MeshAnimation;
+	class SoundObject;
+	class SubtitleWindow;
+
+	/** Diese Klasse
+	  *
+	  */
+	class _RlUiExport DialogControlState : public DialogController
+	{
+	public:
+        enum DialogMode
+		{
+            // Frontperspektive auf Augenh&#239;&#191;&#189;he, ausgehend von der Mitte zwischen den Redenden
+			DM_FRONT = 1,
+		};
+
+
+		/**
+		*  @throw NullPointerException if camera or character is NULL.
+		*  @throw InvalidArgumentException if character is not placed in the scene.
+		*/
+		DialogControlState(CommandMapper* cmdMapper, Actor* camera, Creature* character);
+		/// Dtor
+		virtual ~DialogControlState();
+
+        virtual void pause();
+        virtual void resume();
+
+		/// @override
+		virtual void run(Ogre::Real elapsedTime);
+
+		void start(Dialog* dialog);
+
+		/// Antwort eines der Dialogf&#239;&#191;&#189;hrenden
+		void response(Actor* actor, const CeGuiString&amp; text, const Ogre::String&amp; soundFile = &quot;&quot;);
+
+		bool handleDialogSelectOption(DialogOption* option);
+		virtual void handleDialogEnd();
+		bool requestDialogClose();
+	    virtual bool textFinished();
+
+	private:
+		/// Die Zielkameraposition in lokalen Koordinaten
+		Ogre::Vector3 mTargetCameraPosition;
+		/// Die ben&#239;&#191;&#189;tigte lokale Drehung der Kamera
+		Ogre::Vector3 mTargetCameraDirection;
+
+
+        /// Die Art der Kamerapositionierung
+        DialogMode mDialogMode;
+
+
+
+		DialogWindow* mDialogWindow;
+
+        virtual void recalculateDialogCamera(Creature* speaker, std::list&lt;Creature*&gt; listeners);
+
+        void showOptions(const std::list&lt;DialogOption*&gt;&amp; options);
+	};
+}
+#endif

Modified: rl/branches/persistence2/engine/ui/include/DialogController.h
===================================================================
--- rl/branches/persistence2/engine/ui/include/DialogController.h	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/include/DialogController.h	2009-04-01 20:08:44 UTC (rev 4879)
@@ -34,6 +34,16 @@
         virtual bool mouseReleased(const OIS::MouseEvent&amp; evt, OIS::MouseButtonID id, bool handled);
 
     protected:
+        
+        enum DialogState
+        {
+            DS_UNKNOWN = 1,
+            DS_CHOOSING_OPTION,
+            DS_SHOWING_OPTION,
+            DS_SHOWING_RESPONSE,
+            DS_CLOSING_DIALOG
+        };
+        
         DialogController(CommandMapper* commandMapper, Actor* camera, Creature* character,
                 ControlStateType type);
         virtual ~DialogController();
@@ -71,6 +81,7 @@
         Dialog* mDialog;
         GameLoggerWindow* mGameLogger;
         CeGuiString mCurrentResponseText;
+        DialogState mDialogState;
 
         float getShowTextLength(const CeGuiString&amp; text) const;
         void processTextVariables(CeGuiString&amp; text);

Modified: rl/branches/persistence2/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/CombatControlState.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/src/CombatControlState.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,608 +1,608 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot;
-
-#include &quot;CombatControlState.h&quot;
-
-#include &quot;Actor.h&quot;
-#include &quot;CameraObject.h&quot;
-#include &quot;Combat.h&quot;
-#include &quot;CombatGui.h&quot;
-#include &quot;CombatManager.h&quot;
-#include &quot;CommandMapper.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;CreatureController.h&quot;
-#include &quot;CreatureControllerManager.h&quot;
-#include &quot;InputManager.h&quot;
-#include &quot;MeshObject.h&quot;
-#include &quot;PhysicalThing.h&quot;
-#include &quot;RulesMessages.h&quot;
-#include &quot;Selector.h&quot;
-#include &quot;UiMessages.h&quot;
-#include &quot;World.h&quot;
-
-using namespace Ogre;
-
-namespace rl {
-    CombatControlState::CombatControlState(CommandMapper* cmdMapper,
-        Actor* camera, Creature* character)
-        : ControlState(cmdMapper, camera, character, CST_COMBAT),
-          Combatant(CombatManager::getSingleton().startCombat(),
-			CreatureControllerManager::getSingleton().getCreatureController(character)),
-		  mAttackedOpponent(NULL),
-		  mParriedOpponent(NULL),
-          mCombatManager(CombatManager::getSingletonPtr()),
-		  mCombatGui(NULL),
-          mEnemySelector(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager(),
-            QUERYFLAG_CREATURE),
-          mCamera(NULL),
-		  mState(ROUND_EXECUTION),
-          mCameraYaw(0),
-          mCameraPitch(60), // the same value as in resetCamera
-          mMovementState(0),
-          mCameraLinearSpringK(100.0f),
-          mCameraLinearDampingK(Math::NEG_INFINITY),
-          mViewMode(VM_COMBAT_CENTERED),
-          mCameraFocusedCombatant(NULL),
-          mCameraTransitionLookAtActive(false),
-          mCameraTransitionPositionActive(false),
-          mCameraMaxDistance(30.0f),
-          mCameraCombatCenteredMinDistance(5.0f),
-          mCameraThirdPersonMinDistance(1.0f),
-          mCameraSwitchDist(30.0f),
-          mCameraSwitchTransitionDist(0.8f)
-    {
-        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
-        filter-&gt;setAlignmentMask(Creature::ALIGNMENT_ENEMY);
-        mEnemySelector.setFilter(filter);
-
-        // Message handlers
-		mCombatIoAttackOpponentConnection =
-            MessagePump::getSingleton().addMessageHandler&lt;MessageType_CombatIoAttackOpponent&gt;(
-			    boost::bind(&amp;CombatControlState::userRequestAttackOpponent, this, _1));
-		mCombatIoParryOpponentConnection =
-            MessagePump::getSingleton().addMessageHandler&lt;MessageType_CombatIoParryOpponent&gt;(
-			    boost::bind(&amp;CombatControlState::userRequestParryOpponent, this, _1));
-		mCombatIoEndTurnRequestedConnection =
-            MessagePump::getSingleton().addMessageHandler&lt;MessageType_CombatIoEndTurnRequested&gt;(
-			    boost::bind(&amp;CombatControlState::userRequestEndTurn, this));
-		mEnemyLeftCombatConnection =
-            MessagePump::getSingleton().addMessageHandler&lt;MessageType_CombatOpponentLeft&gt;(
-			    boost::bind(&amp;CombatControlState::enemyLeftCombat, this, _1));
-		mCombatEndConnection =
-            MessagePump::getSingleton().addMessageHandler&lt;MessageType_CombatEnded&gt;(
-			    boost::bind(&amp;CombatControlState::combatEnded, this, _1));
-
-        mCamera = static_cast&lt;CameraObject*&gt;(mCameraActor-&gt;getControlledObject());
-		mCombatGui = new CombatGui(mCombat, mCamera);
-
-
-        // calculate camera spring-damping system coefficients
-        Real relationCoefficient = 0.8f;
-        mCameraLinearDampingK = relationCoefficient * 2.0 * Math::Sqrt(mCameraLinearSpringK);
-    }
-
-	CombatControlState::~CombatControlState()
-    {
-		delete mCombatGui;
-        delete mEnemySelector.getFilter();
-		CombatManager::getSingleton().stopCombat();
-    }
-
-    void CombatControlState::resume()
-    {
-        // control camera
-        mCameraActor-&gt;getPhysicalThing()-&gt;setMaterialID(
-        PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;));
-        mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
-        mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(this);
-        mCameraActor-&gt;getPhysicalThing()-&gt;setUpConstraint(Vector3::ZERO);
-        
-        // We also handle cam&lt;-&gt;level, cam&lt;-&gt;default cam&lt;-&gt;char collision from now on
-        OgreNewt::MaterialPair* mat_pair = NULL;
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;));
-        mat_pair-&gt;setContactCallback(this);
-        mat_pair-&gt;setDefaultCollidable(1);
-        mat_pair-&gt;setDefaultFriction(0,0);
-        mat_pair-&gt;setDefaultFriction(0,1);
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
-        mat_pair-&gt;setContactCallback(this);
-        mat_pair-&gt;setDefaultCollidable(1);
-        mat_pair-&gt;setDefaultFriction(0,0);
-        mat_pair-&gt;setDefaultFriction(0,1);
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
-        mat_pair-&gt;setContactCallback(this);
-        mat_pair-&gt;setDefaultCollidable(1);
-        mat_pair-&gt;setDefaultFriction(0,0);
-        mat_pair-&gt;setDefaultFriction(0,1);
-
-       
-
-
-        ///\todo Richtig machen, nur tempor&#228;r Ani hier setzen.
-        static_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject())
-            -&gt;startAnimation(&quot;kampf_schwerter_idle&quot;);
-
-        // Set reference to character
-        mEnemySelector.setCheckVisibility(true, mCharacter);
-        mEnemySelector.track(mCharacter);
-        mEnemySelector.setRadius(10.0);
-
-        mEnemySelector.updateSelection();
-        const Selector::GameObjectVector&amp; enemies = mEnemySelector.getAllSelectedObjects();
-        if (!enemies.empty())
-        {
-            for (size_t i = 0; i &lt; enemies.size(); ++i)
-            {
-                mCombat-&gt;addOpponent(static_cast&lt;Creature*&gt;(enemies[i]));
-            }
-        }
-        else
-        {
-            // Oops. Nothing to fight. Pop self.
-            InputManager::getSingleton().popControlState();
-            return;
-        }
-
-		mCombatGui-&gt;show();
-
-        // We want to play too..
-        mCombat-&gt;addAlly(this);
-
-        mCombat-&gt;start();
-
-        // reset camera
-        //resetCamera(); // if you don't call this here, the camera should smoothly move to the new position -&gt; looks nicer
-        // perhaps this should be handled differently!
-        mMovementState = 0;
-        // calculate some buffered values, so they are initialized:
-        mCameraTransitionPositionActive = false;
-        mCameraTransitionLookAtActive = false;
-        mCameraFocusedCombatant = this;
-        mCameraYaw = Degree(0);
-        mCameraPitch = Degree(50);
-        mCameraDistance = 30.0f; // only used for third-person
-        mCombatCenter = calculateCombatCenterPosition();
-        mCombatRadius = calculateCombatRadius(mCombatCenter);
-        calculateOptimalCameraPositionAndLookAt();
- 
-        // update CombatGui
-        mCombatGui-&gt;update();
-    }
-
-    void CombatControlState::pause()
-    {
-        mCombatGui-&gt;hide();
-
-
-        // stop controlling camera actor
-        mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
-        mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
-        // cam&lt;-&gt;Level collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;));
-        // cam&lt;-&gt;Default collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
-
-        static_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject())-&gt;stopAllAnimations();
-
-        mCombat-&gt;pause();
-    }
-
-    bool CombatControlState::keyPressed(const OIS::KeyEvent&amp; evt, bool handled)
-    {
-        bool retval = false;
-        if( !handled )
-        {
-            int movement = mCommandMapper-&gt;getMovement(evt.key);
-            mMovementState |= movement;
-            
-            if( movement != MOVE_NONE )
-                retval = true;
-        }
-
-        if( ControlState::keyPressed(evt, handled || retval) )
-            retval = true;
-
-        return retval;
-    }
-     
-    bool CombatControlState::keyReleased(const OIS::KeyEvent&amp; evt, bool handled)
-    {
-        bool retval = false;
-        int movement = mCommandMapper-&gt;getMovement(evt.key);
-        if( movement != MOVE_NONE )
-        {
-            mMovementState &amp;= (~movement);
-            retval = true;
-        }
-
-        if( ControlState::keyReleased(evt, handled || retval) )
-            retval = true;
-        return retval;
-    }
-
-    void CombatControlState::run(Ogre::Real elapsedTime)
-    {
-        // updateCameraLookAt should be called before mCombatGui-&gt;update()!
-
-        // update camera look-at position
-        updateCameraLookAt(elapsedTime);
-
-
-        // update CombatGui
-        mCombatGui-&gt;update();
-
-
-        // slow down rotational movement, when radius grows
-        if( mMovementState &amp; MOVE_RIGHT )
-            mCameraYaw += Degree( 360.0/2.0 * elapsedTime / Math::Sqrt(mCameraDistance) );
-        if( mMovementState &amp; MOVE_LEFT )
-            mCameraYaw -= Degree( 360.0/2.0 * elapsedTime / Math::Sqrt(mCameraDistance) );
-        if( mMovementState &amp; MOVE_FORWARD )
-            mCameraDistance -= 5 * elapsedTime;
-        if( mMovementState &amp; MOVE_BACKWARD )
-            mCameraDistance += 5 * elapsedTime;
-
-        mCameraDistance = std::max( mCameraDistance, mCameraThirdPersonMinDistance);
-        mCameraDistance = std::min( mCameraDistance, mCameraMaxDistance);
-
-        // switch view mode smoothly if nearer:
-        if( mViewMode == VM_COMBAT_CENTERED )
-        {
-            if( mMovementState &amp; MOVE_FORWARD )
-            {
-                mViewMode = VM_THIRD_PERSON;
-            }
-        }
-        else // VM_THIRD_PERSON
-        {
-            if( mCameraDistance &gt;= mCameraSwitchDist - 0.05f &amp;&amp; mMovementState &amp; MOVE_BACKWARD )
-            {
-                mViewMode = VM_COMBAT_CENTERED;
-            }
-        }
-    }
-
-    void CombatControlState::resetCamera(void)
-    {
-        mCombatCenter = calculateCombatCenterPosition();
-        mCombatRadius = calculateCombatRadius(mCombatCenter);
-        mCameraTransitionPositionActive = false;
-        mCameraTransitionLookAtActive = false;
-        mCameraYaw = Degree(0);
-        mCameraPitch = Degree(50);
-        if( mViewMode == VM_THIRD_PERSON )
-            mCameraDistance = 2.0f; // only used for third-person
-        calculateOptimalCameraPositionAndLookAt();
-        mCameraActor-&gt;setPosition(mCameraOptPos);
-        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
-        cameraNode-&gt;lookAt(mCameraLookAt, Node::TS_WORLD);
-    }
-
-    void CombatControlState::updateCameraLookAt(Real elapsedTime)
-    {
-        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
-        cameraNode-&gt;lookAt(mCameraLookAt, Node::TS_WORLD);
-    }
-
-    Vector3 CombatControlState::calculateCombatCenterPosition()
-    {
-        // get the center of all persons (allies and opponents)
-        int n = 0;
-        Vector3 pos = Vector3::ZERO;
-
-        const Combat::CombatantSet &amp;allies (mCombat-&gt;getAllPlayerAllies() );
-        for(Combat::CombatantSet::const_iterator it = allies.begin(); it != allies.end(); it++)
-        {
-            pos += (*it)-&gt;getCreature()-&gt;getPosition();
-            n++;
-        }
-
-        const Combat::CombatantSet &amp;opponents (mCombat-&gt;getAllPlayerOpponents());
-        for(Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); it++)
-        {
-            pos += (*it)-&gt;getCreature()-&gt;getPosition();
-            n++;
-        }
-
-        if( n &gt; 0 )
-            pos /= n;
-        else
-        {
-            pos = mCharacter-&gt;getPosition();
-        }
-
-        return pos;
-    }
-
-    Real CombatControlState::calculateCombatRadius(Vector3 center)
-    {
-        // get the greatest distance from center from all persons
-        Real distance = 0;
-        const Combat::CombatantSet &amp;allies (mCombat-&gt;getAllPlayerAllies() );
-        for(Combat::CombatantSet::const_iterator it = allies.begin(); it != allies.end(); it++)
-        {
-            distance = std::max( ( (*it)-&gt;getCreature()-&gt;getPosition() - center ).length(), distance );
-        }
-        const Combat::CombatantSet &amp;opponents = mCombat-&gt;getAllPlayerOpponents();
-        for(Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); it++)
-        {
-            distance = std::max( ( (*it)-&gt;getCreature()-&gt;getPosition() - center ).length(), distance );
-        }
-        return distance;
-    }
-    
-    void CombatControlState::calculateOptimalCameraPositionAndLookAt()
-    {
-        // some variables:
-        Vector3 playerPos = mCharacter-&gt;getPosition();
-        mCombatCenter = calculateCombatCenterPosition();
-        mCombatRadius = calculateCombatRadius(mCombatCenter);
-
-
-
-        // calculate camera-distance for VM_COMBAT_CENTERED (needed for third-person view, too)
-        Real combatCenteredDistance = mCombatRadius + 2; // this is camera-distance from center projected to the plane!
-            
-        // put camera on the line player-center far enough to see all persons
-        // if player is &quot;exactly&quot; in the center, use player orientation as fallback orientation
-        // + rotation from mCameraYaw
-        Vector3 diff = playerPos - mCombatCenter;
-        diff.y = 0;
-        Quaternion combatCenteredCamYaw;
-        combatCenteredCamYaw.FromAngleAxis(mCameraYaw, Vector3::UNIT_Y);
-        if( diff.squaredLength() &lt; 0.01 )
-        {
-            diff = mCharacterActor-&gt;getOrientation()*Vector3::UNIT_Z;
-        }
-        diff.y = 0;
-        diff.normalise();
-        diff = combatCenteredCamYaw*diff;
-        diff.y = Math::Tan(mCameraPitch.valueRadians());
-
-        Real cosPitch = Math::Cos(mCameraPitch.valueRadians());
-        combatCenteredDistance = std::max( combatCenteredDistance,  mCameraCombatCenteredMinDistance*cosPitch );
-        combatCenteredDistance = std::min( combatCenteredDistance,  mCameraMaxDistance*cosPitch );
- 
-
-
-
-
-        // TODO
-        // Bewegung wirkt zu eckig... evt hilft es lookat und position separat zu berechnen
-        // und dabei das lookat schneller auf den anvisierten combatant zu setzen...
-        // ideal scheint mir eine &quot;runde&quot; bewegung, a la kamerafahrt!
-
-
-        Vector3 center;
-        Vector3 dist;
-        if( mViewMode == VM_THIRD_PERSON &amp;&amp; mCameraFocusedCombatant )
-        {
-            center = mCameraFocusedCombatant-&gt;getPosition();
-            // if mCameraDistance is near the one needed for combatCentered,
-            // interpolate the center (between center of third-person-view
-            // and center of combat-centered-view)
-            Real interpolateDist = std::max(0.0f, combatCenteredDistance - mCameraDistance*cosPitch) / cosPitch;
-            if( interpolateDist &lt;  mCameraSwitchTransitionDist*mCameraSwitchDist )
-            {
-                center += (mCombatCenter - center)*(1 - interpolateDist/(mCameraSwitchTransitionDist*mCameraSwitchDist));
-            }
-            dist = mCameraDistance*cosPitch;
-        }
-        else // assume VM_COMBAT_CENTERED
-        {
-            center = mCombatCenter;
-            // update camera-distance variable
-            mCameraDistance = (combatCenteredDistance*diff).length();
-            dist = combatCenteredDistance;
-        }
-
-        mCameraSwitchDist = (combatCenteredDistance*diff).length();
-        mCameraOptPos = center + dist*diff;
-        mCameraLookAt = center + 1.4*Vector3::UNIT_Y;
-    }
-
-    void CombatControlState::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
-    {
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody-&gt;getPositionOrientation(camPos, camOri);
-
-        calculateOptimalCameraPositionAndLookAt();
-
-        // handle transition
-        if( mCameraTransitionPositionActive )
-        {
-            Vector3 diff = mCameraOptPos - mCameraTransitionPosition;
-            Real dist = diff.length();
-            Vector3 dir = diff/dist;
-            mCameraTransitionPosition += dir*std::min(dist, 0.5f*timestep);
-            if( (mCameraTransitionPosition - mCameraOptPos).squaredLength() &lt; 0.02 )
-                mCameraTransitionPositionActive = false;
-            mCameraOptPos = mCameraTransitionPosition;
-        }
-        if( mCameraTransitionLookAtActive )
-        {
-            Vector3 diff = mCameraLookAt - mCameraTransitionLookAt;
-            Real dist = diff.length();
-            Vector3 dir = diff/dist;
-            mCameraTransitionLookAt += dir * std::min(dist,0.5f*timestep);
-            if( (mCameraLookAt-mCameraTransitionLookAt).squaredLength() &lt; 0.02 )
-                mCameraTransitionLookAtActive = false;
-            mCameraLookAt = mCameraTransitionLookAt;
-        }
-
-
-        Vector3 diff = camPos - mCameraOptPos;
-        Vector3 cameraVelocity;
-        cameraVelocity = mCamBody-&gt;getVelocity();
-        // spring velocity
-        Vector3 springAcc = -mCameraLinearSpringK*diff - mCameraLinearDampingK * cameraVelocity;
-                                            
-        // get the camera mass
-        Real mass;
-        Vector3 inertia;
-        mCamBody-&gt;getMassMatrix(mass, inertia);
-                                                
-        mCamBody-&gt;setForce(springAcc * mass);
-    }
-
-    void CombatControlState::setViewMode(ViewMode mode)
-    {
-        if(mode != mViewMode)
-        {
-            mViewMode = mode;
-            mCameraTransitionPosition = mCameraActor-&gt;getPosition();
-            mCameraTransitionLookAt = mCameraLookAt;
-            mCameraTransitionLookAtActive = true;
-            mCameraTransitionPositionActive = true;
-        }
-    }
-
-    void CombatControlState::toggleViewMode()
-    {
-        if( mViewMode == VM_COMBAT_CENTERED )
-            setViewMode(VM_THIRD_PERSON);
-        else
-            setViewMode(VM_COMBAT_CENTERED);
-    }
-
-    CombatControlState::ViewMode CombatControlState::getViewMode()
-    {
-        return mViewMode;
-    }
-
-    void CombatControlState::setCameraFocusedCombatant(Combatant* combatant)
-    {
-        if( combatant != mCameraFocusedCombatant )
-        {
-            if( mViewMode == VM_THIRD_PERSON )
-            {
-                mCameraTransitionPosition = mCameraActor-&gt;getPosition();
-                mCameraTransitionLookAt = mCameraLookAt;
-                mCameraTransitionLookAtActive = true;
-                mCameraTransitionPositionActive = true;
-            }
-        }
-        mCameraFocusedCombatant = combatant;
-    }
-
-    int CombatControlState::onAABBOverlap(OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex)
-    {
-        // TODO handle camera collisions here
-        return 0;
-    }
-   
-    void CombatControlState::userProcess(OgreNewt::ContactJoint &amp;contactJoint, Ogre::Real timestep, int threadIndex)
-    {
-        // TODO handle camera collisions here
-    }
-
-    Ogre::String CombatControlState::getCombatantTypeName() const
-    {
-        return &quot;CombatControlState&quot;;
-    }
-
-    void CombatControlState::requestCombatantAction()
-    {
-        // Change state to allow user to choose actions for next round.
-		mState = REQUEST_USER_INPUT;
-		mCombatGui-&gt;enableUserInput(true);
-    }
-
-	bool CombatControlState::userRequestAttackOpponent(Combatant* opponent)
-	{
-		mAttackedOpponent = opponent;
-		return true;
-	}
-
-	bool CombatControlState::userRequestParryOpponent(Combatant* opponent)
-	{
-		mParriedOpponent = opponent;
-		return true;
-	}
-
-	bool CombatControlState::userRequestEndTurn()
-	{
-		// Only handle, if we accept user input now.
-		if (mState != REQUEST_USER_INPUT)
-		{
-			return true;
-		}
-
-		// Do we want to attack someone?
-		if (mAttackedOpponent)
-		{
-			// Are we in weapon range to opponent
-			if (mCombat-&gt;canAttack(this, mAttackedOpponent))
-			{
-				// Ok, we can attack
-				mCombat-&gt;registerAttacke(this, mAttackedOpponent);
-			}
-			else
-			{
-				// We can't attack from here, so go to opponent.
-				mCombat-&gt;registerFolgen(this, mAttackedOpponent);
-			}
-		}
-		if (mParriedOpponent)
-		{
-			mCombat-&gt;registerParade(this);
-		}
-
-		mCombat-&gt;registerCombatantRoundDone(this);
-
-		mState = ROUND_EXECUTION;
-
-		return true;
-	}
-
-	bool CombatControlState::enemyLeftCombat(Combatant* opponent)
-	{
-		// Make sure we don't have any dangling pointers on invalid Combatants.
-
-		if (opponent == mAttackedOpponent)
-		{
-			mAttackedOpponent = NULL;
-		}
-		if (opponent == mParriedOpponent)
-		{
-			mParriedOpponent = NULL;
-		}
-		return true;
-	}
-
-    bool CombatControlState::combatEnded(bool alliesWon)
-    {
-        ///@todo some feedback, Abenteuerpunkte, anything? 
-        InputManager::getSingleton().popControlState();
-        return true;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot;
+
+#include &quot;CombatControlState.h&quot;
+
+#include &quot;Actor.h&quot;
+#include &quot;CameraObject.h&quot;
+#include &quot;Combat.h&quot;
+#include &quot;CombatGui.h&quot;
+#include &quot;CombatManager.h&quot;
+#include &quot;CommandMapper.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;CreatureController.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
+#include &quot;InputManager.h&quot;
+#include &quot;MeshObject.h&quot;
+#include &quot;PhysicalThing.h&quot;
+#include &quot;RulesMessages.h&quot;
+#include &quot;Selector.h&quot;
+#include &quot;UiMessages.h&quot;
+#include &quot;World.h&quot;
+
+using namespace Ogre;
+
+namespace rl {
+    CombatControlState::CombatControlState(CommandMapper* cmdMapper,
+        Actor* camera, Creature* character)
+        : ControlState(cmdMapper, camera, character, CST_COMBAT),
+          Combatant(CombatManager::getSingleton().startCombat(),
+			CreatureControllerManager::getSingleton().getCreatureController(character)),
+		  mAttackedOpponent(NULL),
+		  mParriedOpponent(NULL),
+          mCombatManager(CombatManager::getSingletonPtr()),
+		  mCombatGui(NULL),
+          mEnemySelector(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager(),
+            QUERYFLAG_CREATURE),
+          mCamera(NULL),
+		  mState(ROUND_EXECUTION),
+          mCameraYaw(0),
+          mCameraPitch(60), // the same value as in resetCamera
+          mMovementState(0),
+          mCameraLinearSpringK(100.0f),
+          mCameraLinearDampingK(Math::NEG_INFINITY),
+          mViewMode(VM_COMBAT_CENTERED),
+          mCameraFocusedCombatant(NULL),
+          mCameraTransitionLookAtActive(false),
+          mCameraTransitionPositionActive(false),
+          mCameraMaxDistance(30.0f),
+          mCameraCombatCenteredMinDistance(5.0f),
+          mCameraThirdPersonMinDistance(1.0f),
+          mCameraSwitchDist(30.0f),
+          mCameraSwitchTransitionDist(0.8f)
+    {
+        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
+        filter-&gt;setAlignmentMask(Creature::ALIGNMENT_ENEMY);
+        mEnemySelector.setFilter(filter);
+
+        // Message handlers
+		mCombatIoAttackOpponentConnection =
+            MessagePump::getSingleton().addMessageHandler&lt;MessageType_CombatIoAttackOpponent&gt;(
+			    boost::bind(&amp;CombatControlState::userRequestAttackOpponent, this, _1));
+		mCombatIoParryOpponentConnection =
+            MessagePump::getSingleton().addMessageHandler&lt;MessageType_CombatIoParryOpponent&gt;(
+			    boost::bind(&amp;CombatControlState::userRequestParryOpponent, this, _1));
+		mCombatIoEndTurnRequestedConnection =
+            MessagePump::getSingleton().addMessageHandler&lt;MessageType_CombatIoEndTurnRequested&gt;(
+			    boost::bind(&amp;CombatControlState::userRequestEndTurn, this));
+		mEnemyLeftCombatConnection =
+            MessagePump::getSingleton().addMessageHandler&lt;MessageType_CombatOpponentLeft&gt;(
+			    boost::bind(&amp;CombatControlState::enemyLeftCombat, this, _1));
+		mCombatEndConnection =
+            MessagePump::getSingleton().addMessageHandler&lt;MessageType_CombatEnded&gt;(
+			    boost::bind(&amp;CombatControlState::combatEnded, this, _1));
+
+        mCamera = static_cast&lt;CameraObject*&gt;(mCameraActor-&gt;getControlledObject());
+		mCombatGui = new CombatGui(mCombat, mCamera);
+
+
+        // calculate camera spring-damping system coefficients
+        Real relationCoefficient = 0.8f;
+        mCameraLinearDampingK = relationCoefficient * 2.0 * Math::Sqrt(mCameraLinearSpringK);
+    }
+
+	CombatControlState::~CombatControlState()
+    {
+		delete mCombatGui;
+        delete mEnemySelector.getFilter();
+		CombatManager::getSingleton().stopCombat();
+    }
+
+    void CombatControlState::resume()
+    {
+        // control camera
+        mCameraActor-&gt;getPhysicalThing()-&gt;setMaterialID(
+        PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;));
+        mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
+        mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(this);
+        mCameraActor-&gt;getPhysicalThing()-&gt;setUpConstraint(Vector3::ZERO);
+        
+        // We also handle cam&lt;-&gt;level, cam&lt;-&gt;default cam&lt;-&gt;char collision from now on
+        OgreNewt::MaterialPair* mat_pair = NULL;
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;));
+        mat_pair-&gt;setContactCallback(this);
+        mat_pair-&gt;setDefaultCollidable(1);
+        mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair-&gt;setDefaultFriction(0,1);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
+        mat_pair-&gt;setContactCallback(this);
+        mat_pair-&gt;setDefaultCollidable(1);
+        mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair-&gt;setDefaultFriction(0,1);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
+        mat_pair-&gt;setContactCallback(this);
+        mat_pair-&gt;setDefaultCollidable(1);
+        mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair-&gt;setDefaultFriction(0,1);
+
+       
+
+
+        ///\todo Richtig machen, nur tempor&#226;&#128;&#176;r Ani hier setzen.
+        static_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject())
+            -&gt;startAnimation(&quot;kampf_schwerter_idle&quot;);
+
+        // Set reference to character
+        mEnemySelector.setCheckVisibility(true, mCharacter);
+        mEnemySelector.track(mCharacter);
+        mEnemySelector.setRadius(10.0);
+
+        mEnemySelector.updateSelection();
+        const GameObjectList&amp; enemies = mEnemySelector.getAllSelectedObjects();
+        if (!enemies.empty())
+        {
+            for (GameObjectList::const_iterator it = enemies.begin(); it != enemies.end(); ++it)
+            {
+                mCombat-&gt;addOpponent(static_cast&lt;Creature*&gt;(*it));
+            }
+        }
+        else
+        {
+            // Oops. Nothing to fight. Pop self.
+            InputManager::getSingleton().popControlState();
+            return;
+        }
+
+		mCombatGui-&gt;show();
+
+        // We want to play too..
+        mCombat-&gt;addAlly(this);
+
+        mCombat-&gt;start();
+
+        // reset camera
+        //resetCamera(); // if you don't call this here, the camera should smoothly move to the new position -&gt; looks nicer
+        // perhaps this should be handled differently!
+        mMovementState = 0;
+        // calculate some buffered values, so they are initialized:
+        mCameraTransitionPositionActive = false;
+        mCameraTransitionLookAtActive = false;
+        mCameraFocusedCombatant = this;
+        mCameraYaw = Degree(0);
+        mCameraPitch = Degree(50);
+        mCameraDistance = 30.0f; // only used for third-person
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+        calculateOptimalCameraPositionAndLookAt();
+ 
+        // update CombatGui
+        mCombatGui-&gt;update();
+    }
+
+    void CombatControlState::pause()
+    {
+        mCombatGui-&gt;hide();
+
+
+        // stop controlling camera actor
+        mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
+        mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
+        // cam&lt;-&gt;Level collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;));
+        // cam&lt;-&gt;Default collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
+
+        static_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject())-&gt;stopAllAnimations();
+
+        mCombat-&gt;pause();
+    }
+
+    bool CombatControlState::keyPressed(const OIS::KeyEvent&amp; evt, bool handled)
+    {
+        bool retval = false;
+        if( !handled )
+        {
+            int movement = mCommandMapper-&gt;getMovement(evt.key);
+            mMovementState |= movement;
+            
+            if( movement != MOVE_NONE )
+                retval = true;
+        }
+
+        if( ControlState::keyPressed(evt, handled || retval) )
+            retval = true;
+
+        return retval;
+    }
+     
+    bool CombatControlState::keyReleased(const OIS::KeyEvent&amp; evt, bool handled)
+    {
+        bool retval = false;
+        int movement = mCommandMapper-&gt;getMovement(evt.key);
+        if( movement != MOVE_NONE )
+        {
+            mMovementState &amp;= (~movement);
+            retval = true;
+        }
+
+        if( ControlState::keyReleased(evt, handled || retval) )
+            retval = true;
+        return retval;
+    }
+
+    void CombatControlState::run(Ogre::Real elapsedTime)
+    {
+        // updateCameraLookAt should be called before mCombatGui-&gt;update()!
+
+        // update camera look-at position
+        updateCameraLookAt(elapsedTime);
+
+
+        // update CombatGui
+        mCombatGui-&gt;update();
+
+
+        // slow down rotational movement, when radius grows
+        if( mMovementState &amp; MOVE_RIGHT )
+            mCameraYaw += Degree( 360.0/2.0 * elapsedTime / Math::Sqrt(mCameraDistance) );
+        if( mMovementState &amp; MOVE_LEFT )
+            mCameraYaw -= Degree( 360.0/2.0 * elapsedTime / Math::Sqrt(mCameraDistance) );
+        if( mMovementState &amp; MOVE_FORWARD )
+            mCameraDistance -= 5 * elapsedTime;
+        if( mMovementState &amp; MOVE_BACKWARD )
+            mCameraDistance += 5 * elapsedTime;
+
+        mCameraDistance = std::max( mCameraDistance, mCameraThirdPersonMinDistance);
+        mCameraDistance = std::min( mCameraDistance, mCameraMaxDistance);
+
+        // switch view mode smoothly if nearer:
+        if( mViewMode == VM_COMBAT_CENTERED )
+        {
+            if( mMovementState &amp; MOVE_FORWARD )
+            {
+                mViewMode = VM_THIRD_PERSON;
+            }
+        }
+        else // VM_THIRD_PERSON
+        {
+            if( mCameraDistance &gt;= mCameraSwitchDist - 0.05f &amp;&amp; mMovementState &amp; MOVE_BACKWARD )
+            {
+                mViewMode = VM_COMBAT_CENTERED;
+            }
+        }
+    }
+
+    void CombatControlState::resetCamera(void)
+    {
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+        mCameraTransitionPositionActive = false;
+        mCameraTransitionLookAtActive = false;
+        mCameraYaw = Degree(0);
+        mCameraPitch = Degree(50);
+        if( mViewMode == VM_THIRD_PERSON )
+            mCameraDistance = 2.0f; // only used for third-person
+        calculateOptimalCameraPositionAndLookAt();
+        mCameraActor-&gt;setPosition(mCameraOptPos);
+        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
+        cameraNode-&gt;lookAt(mCameraLookAt, Node::TS_WORLD);
+    }
+
+    void CombatControlState::updateCameraLookAt(Real elapsedTime)
+    {
+        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
+        cameraNode-&gt;lookAt(mCameraLookAt, Node::TS_WORLD);
+    }
+
+    Vector3 CombatControlState::calculateCombatCenterPosition()
+    {
+        // get the center of all persons (allies and opponents)
+        int n = 0;
+        Vector3 pos = Vector3::ZERO;
+
+        const Combat::CombatantSet &amp;allies (mCombat-&gt;getAllPlayerAllies() );
+        for(Combat::CombatantSet::const_iterator it = allies.begin(); it != allies.end(); it++)
+        {
+            pos += (*it)-&gt;getCreature()-&gt;getPosition();
+            n++;
+        }
+
+        const Combat::CombatantSet &amp;opponents (mCombat-&gt;getAllPlayerOpponents());
+        for(Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); it++)
+        {
+            pos += (*it)-&gt;getCreature()-&gt;getPosition();
+            n++;
+        }
+
+        if( n &gt; 0 )
+            pos /= n;
+        else
+        {
+            pos = mCharacter-&gt;getPosition();
+        }
+
+        return pos;
+    }
+
+    Real CombatControlState::calculateCombatRadius(Vector3 center)
+    {
+        // get the greatest distance from center from all persons
+        Real distance = 0;
+        const Combat::CombatantSet &amp;allies (mCombat-&gt;getAllPlayerAllies() );
+        for(Combat::CombatantSet::const_iterator it = allies.begin(); it != allies.end(); it++)
+        {
+            distance = std::max( ( (*it)-&gt;getCreature()-&gt;getPosition() - center ).length(), distance );
+        }
+        const Combat::CombatantSet &amp;opponents = mCombat-&gt;getAllPlayerOpponents();
+        for(Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); it++)
+        {
+            distance = std::max( ( (*it)-&gt;getCreature()-&gt;getPosition() - center ).length(), distance );
+        }
+        return distance;
+    }
+    
+    void CombatControlState::calculateOptimalCameraPositionAndLookAt()
+    {
+        // some variables:
+        Vector3 playerPos = mCharacter-&gt;getPosition();
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+
+
+
+        // calculate camera-distance for VM_COMBAT_CENTERED (needed for third-person view, too)
+        Real combatCenteredDistance = mCombatRadius + 2; // this is camera-distance from center projected to the plane!
+            
+        // put camera on the line player-center far enough to see all persons
+        // if player is &quot;exactly&quot; in the center, use player orientation as fallback orientation
+        // + rotation from mCameraYaw
+        Vector3 diff = playerPos - mCombatCenter;
+        diff.y = 0;
+        Quaternion combatCenteredCamYaw;
+        combatCenteredCamYaw.FromAngleAxis(mCameraYaw, Vector3::UNIT_Y);
+        if( diff.squaredLength() &lt; 0.01 )
+        {
+            diff = mCharacterActor-&gt;getOrientation()*Vector3::UNIT_Z;
+        }
+        diff.y = 0;
+        diff.normalise();
+        diff = combatCenteredCamYaw*diff;
+        diff.y = Math::Tan(mCameraPitch.valueRadians());
+
+        Real cosPitch = Math::Cos(mCameraPitch.valueRadians());
+        combatCenteredDistance = std::max( combatCenteredDistance,  mCameraCombatCenteredMinDistance*cosPitch );
+        combatCenteredDistance = std::min( combatCenteredDistance,  mCameraMaxDistance*cosPitch );
+ 
+
+
+
+
+        // TODO
+        // Bewegung wirkt zu eckig... evt hilft es lookat und position separat zu berechnen
+        // und dabei das lookat schneller auf den anvisierten combatant zu setzen...
+        // ideal scheint mir eine &quot;runde&quot; bewegung, a la kamerafahrt!
+
+
+        Vector3 center;
+        Vector3 dist;
+        if( mViewMode == VM_THIRD_PERSON &amp;&amp; mCameraFocusedCombatant )
+        {
+            center = mCameraFocusedCombatant-&gt;getPosition();
+            // if mCameraDistance is near the one needed for combatCentered,
+            // interpolate the center (between center of third-person-view
+            // and center of combat-centered-view)
+            Real interpolateDist = std::max(0.0f, combatCenteredDistance - mCameraDistance*cosPitch) / cosPitch;
+            if( interpolateDist &lt;  mCameraSwitchTransitionDist*mCameraSwitchDist )
+            {
+                center += (mCombatCenter - center)*(1 - interpolateDist/(mCameraSwitchTransitionDist*mCameraSwitchDist));
+            }
+            dist = mCameraDistance*cosPitch;
+        }
+        else // assume VM_COMBAT_CENTERED
+        {
+            center = mCombatCenter;
+            // update camera-distance variable
+            mCameraDistance = (combatCenteredDistance*diff).length();
+            dist = combatCenteredDistance;
+        }
+
+        mCameraSwitchDist = (combatCenteredDistance*diff).length();
+        mCameraOptPos = center + dist*diff;
+        mCameraLookAt = center + 1.4*Vector3::UNIT_Y;
+    }
+
+    void CombatControlState::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
+    {
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody-&gt;getPositionOrientation(camPos, camOri);
+
+        calculateOptimalCameraPositionAndLookAt();
+
+        // handle transition
+        if( mCameraTransitionPositionActive )
+        {
+            Vector3 diff = mCameraOptPos - mCameraTransitionPosition;
+            Real dist = diff.length();
+            Vector3 dir = diff/dist;
+            mCameraTransitionPosition += dir*std::min(dist, 0.5f*timestep);
+            if( (mCameraTransitionPosition - mCameraOptPos).squaredLength() &lt; 0.02 )
+                mCameraTransitionPositionActive = false;
+            mCameraOptPos = mCameraTransitionPosition;
+        }
+        if( mCameraTransitionLookAtActive )
+        {
+            Vector3 diff = mCameraLookAt - mCameraTransitionLookAt;
+            Real dist = diff.length();
+            Vector3 dir = diff/dist;
+            mCameraTransitionLookAt += dir * std::min(dist,0.5f*timestep);
+            if( (mCameraLookAt-mCameraTransitionLookAt).squaredLength() &lt; 0.02 )
+                mCameraTransitionLookAtActive = false;
+            mCameraLookAt = mCameraTransitionLookAt;
+        }
+
+
+        Vector3 diff = camPos - mCameraOptPos;
+        Vector3 cameraVelocity;
+        cameraVelocity = mCamBody-&gt;getVelocity();
+        // spring velocity
+        Vector3 springAcc = -mCameraLinearSpringK*diff - mCameraLinearDampingK * cameraVelocity;
+                                            
+        // get the camera mass
+        Real mass;
+        Vector3 inertia;
+        mCamBody-&gt;getMassMatrix(mass, inertia);
+                                                
+        mCamBody-&gt;setForce(springAcc * mass);
+    }
+
+    void CombatControlState::setViewMode(ViewMode mode)
+    {
+        if(mode != mViewMode)
+        {
+            mViewMode = mode;
+            mCameraTransitionPosition = mCameraActor-&gt;getPosition();
+            mCameraTransitionLookAt = mCameraLookAt;
+            mCameraTransitionLookAtActive = true;
+            mCameraTransitionPositionActive = true;
+        }
+    }
+
+    void CombatControlState::toggleViewMode()
+    {
+        if( mViewMode == VM_COMBAT_CENTERED )
+            setViewMode(VM_THIRD_PERSON);
+        else
+            setViewMode(VM_COMBAT_CENTERED);
+    }
+
+    CombatControlState::ViewMode CombatControlState::getViewMode()
+    {
+        return mViewMode;
+    }
+
+    void CombatControlState::setCameraFocusedCombatant(Combatant* combatant)
+    {
+        if( combatant != mCameraFocusedCombatant )
+        {
+            if( mViewMode == VM_THIRD_PERSON )
+            {
+                mCameraTransitionPosition = mCameraActor-&gt;getPosition();
+                mCameraTransitionLookAt = mCameraLookAt;
+                mCameraTransitionLookAtActive = true;
+                mCameraTransitionPositionActive = true;
+            }
+        }
+        mCameraFocusedCombatant = combatant;
+    }
+
+    int CombatControlState::onAABBOverlap(OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex)
+    {
+        // TODO handle camera collisions here
+        return 0;
+    }
+   
+    void CombatControlState::userProcess(OgreNewt::ContactJoint &amp;contactJoint, Ogre::Real timestep, int threadIndex)
+    {
+        // TODO handle camera collisions here
+    }
+
+    Ogre::String CombatControlState::getCombatantTypeName() const
+    {
+        return &quot;CombatControlState&quot;;
+    }
+
+    void CombatControlState::requestCombatantAction()
+    {
+        // Change state to allow user to choose actions for next round.
+		mState = REQUEST_USER_INPUT;
+		mCombatGui-&gt;enableUserInput(true);
+    }
+
+	bool CombatControlState::userRequestAttackOpponent(Combatant* opponent)
+	{
+		mAttackedOpponent = opponent;
+		return true;
+	}
+
+	bool CombatControlState::userRequestParryOpponent(Combatant* opponent)
+	{
+		mParriedOpponent = opponent;
+		return true;
+	}
+
+	bool CombatControlState::userRequestEndTurn()
+	{
+		// Only handle, if we accept user input now.
+		if (mState != REQUEST_USER_INPUT)
+		{
+			return true;
+		}
+
+		// Do we want to attack someone?
+		if (mAttackedOpponent)
+		{
+			// Are we in weapon range to opponent
+			if (mCombat-&gt;canAttack(this, mAttackedOpponent))
+			{
+				// Ok, we can attack
+				mCombat-&gt;registerAttacke(this, mAttackedOpponent);
+			}
+			else
+			{
+				// We can't attack from here, so go to opponent.
+				mCombat-&gt;registerFolgen(this, mAttackedOpponent);
+			}
+		}
+		if (mParriedOpponent)
+		{
+			mCombat-&gt;registerParade(this);
+		}
+
+		mCombat-&gt;registerCombatantRoundDone(this);
+
+		mState = ROUND_EXECUTION;
+
+		return true;
+	}
+
+	bool CombatControlState::enemyLeftCombat(Combatant* opponent)
+	{
+		// Make sure we don't have any dangling pointers on invalid Combatants.
+
+		if (opponent == mAttackedOpponent)
+		{
+			mAttackedOpponent = NULL;
+		}
+		if (opponent == mParriedOpponent)
+		{
+			mParriedOpponent = NULL;
+		}
+		return true;
+	}
+
+    bool CombatControlState::combatEnded(bool alliesWon)
+    {
+        ///@todo some feedback, Abenteuerpunkte, anything? 
+        InputManager::getSingleton().popControlState();
+        return true;
+    }
+}

Modified: rl/branches/persistence2/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/DialogControlState.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/src/DialogControlState.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -62,7 +62,8 @@
         : DialogController(cmdMapper, camera, character, CST_DIALOG),
         mTargetCameraPosition(Vector3::ZERO),
         mTargetCameraDirection(Vector3::UNIT_Z),
-        mDialogMode(DM_FRONT)
+        mDialogMode(DM_FRONT),
+        mDialogWindow(NULL)
     {
     }
 
@@ -254,7 +255,7 @@
 
         if (!DialogController::textFinished())
         {
-            if (mDialogState == TALKING_PARTNER_CHARACTER)
+            if (mDialogState == DS_SHOWING_RESPONSE)
             {
 
                 DialogResponse::Options options = mCurrentResponse-&gt;getAvailableOptions(mDialog);
@@ -267,9 +268,9 @@
                 }
                 mDialogWindow-&gt;setAvailableOptions(options);
                 mDialogWindow-&gt;setVisible(true);
-                mDialogState = CHOOSING_OPTION;
+                mDialogState = DS_CHOOSING_OPTION;
             }
-            else if (mDialogState == TALKING_PLAYER_CHARACTER)
+            else if (mDialogState == DS_SHOWING_OPTION)
             {
                 showResponse(mCurrentOption-&gt;getResponse());
             }
@@ -294,7 +295,7 @@
             mCurrentOption = option;
         }
 
-        mDialogState = TALKING_PLAYER_CHARACTER;
+        mDialogState = DS_SHOWING_OPTION;
         mCurrentParagraphs = mCurrentOption-&gt;getParagraphs(mDialog);
         doTalk(mCurrentParagraphs.front());
 

Modified: rl/branches/persistence2/engine/ui/src/DialogController.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/DialogController.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/src/DialogController.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -42,7 +42,8 @@
         mDialogWindow(NULL),
         mCurrentResponseText(&quot;&quot;),
         mGameLogger(NULL),
-        mCurrentSpeaker(NULL)
+        mCurrentSpeaker(NULL),
+        mDialogState(DS_UNKNOWN)
     {
         mSubtitleSpeed = ConfigurationManager::getSingleton().getRealSetting(
             &quot;General&quot;, &quot;Subtitle Speed&quot;);
@@ -153,6 +154,8 @@
             handleDialogEnd();
             return;
         }
+        
+        mDialogState = DS_SHOWING_RESPONSE;
 
         if (response-&gt;isSelection())
         {
@@ -320,5 +323,7 @@
 
             return true;
         }
+
+		return false;
     }
 }

Modified: rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/src/FreeflightControlState.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -29,6 +29,9 @@
 #include &quot;CommandMapper.h&quot;
 #include &quot;MeshObject.h&quot;
 #include &quot;WindowManager.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;PhysicsRagDoll.h&quot;
 
 using namespace Ogre;
 
@@ -61,7 +64,8 @@
     {
 		mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
 		//mCharacterActor-&gt;getPhysicalThing()-&gt;unfreeze();
-        delete mOgreNewtPlayerController;
+//        delete mOgreNewtPlayerController;
+
         mOgreNewtPlayerController = NULL;
         mCharacterActor-&gt;getPhysicalThing()-&gt;setUpConstraint();
         mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
@@ -84,7 +88,7 @@
         mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
 		//mCharacterActor-&gt;getPhysicalThing()-&gt;freeze();
         mCharacterActor-&gt;getPhysicalThing()-&gt;clearUpConstraint();
-        mOgreNewtPlayerController = new OgreNewt::PlayerController(mCharBody);
+//        mOgreNewtPlayerController = new OgreNewt::PlayerController(mCharBody);
 
         resetCamera();
 
@@ -164,7 +168,8 @@
             // put character here
             if( mCharacterActor != NULL )
             {
-                mCharacterActor-&gt;setPosition(
+                //mCharacterActor-&gt;setPosition(
+                mCharacterActor-&gt;getPhysicalThing()-&gt;setPosition(
                     mCameraActor-&gt;getPosition()
                     + mCameraActor-&gt;getWorldOrientation() * Vector3::NEGATIVE_UNIT_Z * 2
                     - 1.5 * Vector3::UNIT_Y);
@@ -213,8 +218,8 @@
         if (mPitch &lt; mPitchRange.first) mPitch = mPitchRange.first;
         if (mPitch &gt; mPitchRange.second) mPitch = mPitchRange.second;
 
-if( mCollisionsEnabled )
-    mOgreNewtPlayerController-&gt;setVelocity(mDesiredVelocity.z, mDesiredVelocity.x, mYaw);
+//if( mCollisionsEnabled )
+//    mOgreNewtPlayerController-&gt;setVelocity(mDesiredVelocity.z, mDesiredVelocity.x, mYaw);
 
         mCameraActor-&gt;setOrientation(Quaternion::IDENTITY);
         mCameraActor-&gt;yaw(mYaw.valueDegrees());
@@ -232,6 +237,20 @@
 		// with or without collision?
         // be careful to enable collision if beeing in another collision
         mCollisionsEnabled = !mCollisionsEnabled;
+
+        if( mCollisionsEnabled )
+        {
+            CreatureControllerManager::getSingleton().detachController(mCharacter);
+            PhysicsManager::getSingleton().destroyPhysicsProxy(mCharacterActor-&gt;getPhysicalThing());
+            PhysicsManager::getSingleton().createPhysicsProxy_RagDoll(mCharacterActor-&gt;getPhysicalThing());
+        }
+        else
+        {
+            PhysicsManager::getSingleton().destroyPhysicsProxy(mCharacterActor-&gt;getPhysicalThing());
+            PhysicsManager::getSingleton().createPhysicsProxy(mCharacterActor-&gt;getPhysicalThing());
+            CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
+        }
+
 	}
 
 	void FreeflightControlState::resetCamera()
@@ -285,7 +304,7 @@
             }
             else if (command == &quot;toggle_camera_collision&quot; )
             {
-                mCollisionsEnabled = !mCollisionsEnabled;
+                toggleCameraCollision();
                 retval = true;
             }
         }

Modified: rl/branches/persistence2/engine/ui/src/InputManager.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/InputManager.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/src/InputManager.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -121,7 +121,7 @@
         #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
             pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL_EXCLUSIVE&quot;)));
             pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL_FOREGROUND&quot;)));
-        #elif OGRE_PLATFORM == OGRE_PLATFORM_LINUX &amp; defined DEBUG
+        #elif OGRE_PLATFORM == OGRE_PLATFORM_LINUX &amp; defined _DEBUG
             pl.insert(std::make_pair(std::string(&quot;x11_mouse_grab&quot;), std::string(&quot;false&quot;)));
             pl.insert(std::make_pair(std::string(&quot;x11_keyboard_grab&quot;), std::string(&quot;false&quot;)));
         #endif

Modified: rl/branches/persistence2/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/InventoryWindow.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/src/InventoryWindow.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -458,14 +458,14 @@
 
 		mMouseSelector-&gt;setRay(camToWorld.getOrigin(), camToWorld.getPoint(3));
 		mMouseSelector-&gt;updateSelection();
-		Selector::GameObjectVector objs = mMouseSelector-&gt;getAllSelectedObjects();
+		GameObjectList objs = mMouseSelector-&gt;getAllSelectedObjects();
 
 		///@todo select, ...
 		if (!objs.empty())
 		{
 			LOG_MESSAGE(Logger::UI,
 				&quot;Selected &quot;+Ogre::StringConverter::toString(objs.size())+&quot; items.&quot;);
-			for (Selector::GameObjectVector::const_iterator it = objs.begin();
+			for (GameObjectList::const_iterator it = objs.begin();
 				it != objs.end(); ++it)
 			{
                 if( !mInventory-&gt;getOwner()-&gt;canReachItem(static_cast&lt;Item*&gt;(*it)) )
@@ -528,8 +528,8 @@
 				sel.setRadius(10.0);
 
 				sel.updateSelection();
-				Selector::GameObjectVector v = sel.getAllSelectedObjects();
-				for (Selector::GameObjectVector::iterator
+				GameObjectList v = sel.getAllSelectedObjects();
+				for (GameObjectList::iterator
 					it = v.begin(); it != v.end(); ++it)
 				{
                     if( !mInventory-&gt;getOwner()-&gt;canReachItem(static_cast&lt;Item*&gt;(*it)) )

Modified: rl/branches/persistence2/engine/ui/src/MainMenuWindow.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/MainMenuWindow.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/src/MainMenuWindow.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -102,16 +102,25 @@
 		MenuBase* modulesMenu = getMenu(&quot;MainMenu/Modules/Menu&quot;);
 
 		ItemEntry* itOld = NULL;
+        CeGuiString activeName;
+        activeName = mActiveModule-&gt;getName();
 		for (size_t i=0; i&lt;modulesMenu-&gt;getItemCount(); i++)
 		{
 			ItemEntry* curr = modulesMenu-&gt;getItemFromIndex(i);
-			if (curr-&gt;getText().compare(mActiveModule-&gt;getName()+&quot; *&quot;) == 0)
+            CeGuiString currName;
+            currName = curr-&gt;getText();
+			if (currName.compare(activeName+&quot; *&quot;) == 0)
 			{
 				itOld = curr;
 				break;
 			}
 		}
-		itOld-&gt;setText(mActiveModule-&gt;getName());
+        if( !itOld )
+        {
+            LOG_ERROR(Logger::UI,&quot;Could not determine last active MenuEntry in MainMenuWindow::handleChooseModule&quot;);            
+        }
+        else
+            itOld-&gt;setText(mActiveModule-&gt;getName());
 
 		mActiveModule = module;
 		it-&gt;setText(module-&gt;getName()+&quot; *&quot;);

Modified: rl/branches/persistence2/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/branches/persistence2/engine/ui/src/MovementControlState.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/engine/ui/src/MovementControlState.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -222,6 +222,7 @@
             mController =
                 CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
         }
+        mCharBody = mCharacterActor-&gt;getPhysicalThing()-&gt;_getBody();
 
         // We want to check for visibility from char's POV.
         mSelector.setCheckVisibility(true, mCharacter);
@@ -1120,10 +1121,10 @@
     {
         mCombatSelector.updateSelection();
 
-        const Selector::GameObjectVector&amp; gov = mCombatSelector.getAllSelectedObjects();
-        for (size_t i = 0, end = gov.size(); i &lt; end; ++i)
+        const GameObjectList&amp; gov = mCombatSelector.getAllSelectedObjects();
+        for (GameObjectList::const_iterator it = gov.begin(), end = gov.end(); it != end; ++it)
         {
-            Creature* creature = dynamic_cast&lt;Creature*&gt;(gov.at(i));
+            Creature* creature = dynamic_cast&lt;Creature*&gt;(*it);
             if (creature &amp;&amp;
 				creature-&gt;getAlignment() == Creature::ALIGNMENT_ENEMY &amp;&amp;
 				(creature-&gt;getLifeState() &amp; Effect::LS_NO_COMBAT) == 0)

Copied: rl/branches/persistence2/tests/dialogtests (from rev 4878, rl/trunk/tests/dialogtests)


Property changes on: rl/branches/persistence2/tests/dialogtests
___________________________________________________________________
Name: svn:ignore
   + 
.deps
.libs
Makefile
testdialog
Makefile.in

Name: svn:mergeinfo
   + 

Copied: rl/branches/persistence2/tests/dialogtests/Debug (from rev 4878, rl/trunk/tests/dialogtests/Debug)

Copied: rl/branches/persistence2/tests/dialogtests/Release (from rev 4878, rl/trunk/tests/dialogtests/Release)

Deleted: rl/branches/persistence2/tests/dialogtests/RlDialogTests.vcproj
===================================================================
--- rl/trunk/tests/dialogtests/RlDialogTests.vcproj	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/tests/dialogtests/RlDialogTests.vcproj	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,186 +0,0 @@
-&lt;?xml version=&quot;1.0&quot; encoding=&quot;Windows-1252&quot;?&gt;
-&lt;VisualStudioProject
-	ProjectType=&quot;Visual C++&quot;
-	Version=&quot;8,00&quot;
-	Name=&quot;RlDialogTests&quot;
-	ProjectGUID=&quot;{B1DBC31B-A837-4111-9D7A-4BEE8033A952}&quot;
-	&gt;
-	&lt;Platforms&gt;
-		&lt;Platform
-			Name=&quot;Win32&quot;
-		/&gt;
-	&lt;/Platforms&gt;
-	&lt;ToolFiles&gt;
-	&lt;/ToolFiles&gt;
-	&lt;Configurations&gt;
-		&lt;Configuration
-			Name=&quot;Debug|Win32&quot;
-			OutputDirectory=&quot;$(SolutionDir)$(ConfigurationName)&quot;
-			IntermediateDirectory=&quot;$(ConfigurationName)&quot;
-			ConfigurationType=&quot;1&quot;
-			&gt;
-			&lt;Tool
-				Name=&quot;VCPreBuildEventTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCCustomBuildTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCXMLDataGeneratorTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCWebServiceProxyGeneratorTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCMIDLTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCCLCompilerTool&quot;
-				Optimization=&quot;0&quot;
-				AdditionalIncludeDirectories=&quot;..\..\engine\script\include;..\..\engine\ui\include;..\..\engine\uicomponents\include;..\..\engine\dialog\include;..\..\engine\multimedia\include;..\..\engine\common\include;..\..\engine\core\include;..\..\engine\rules\include;..\..\dependencies\cppunit\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenewt\inc;..\..\dependencies\xerces\include;..\..\dependencies\newtonsdk\sdk&quot;
-				PreprocessorDefinitions=&quot;WITH_FMOD3;WIN32;_DEBUG;_WINDOWS;_CRT_SECURE_NO_DEPRECATE&quot;
-				MinimalRebuild=&quot;true&quot;
-				BasicRuntimeChecks=&quot;3&quot;
-				RuntimeLibrary=&quot;3&quot;
-				BufferSecurityCheck=&quot;false&quot;
-				DebugInformationFormat=&quot;4&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCManagedResourceCompilerTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCResourceCompilerTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCPreLinkEventTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCLinkerTool&quot;
-				AdditionalDependencies=&quot;CEGUIBase_d.lib OgreMain_d.lib cppunitd_dll.lib user32.lib RlUi.lib RlCore.lib RlMultimedia.lib&quot;
-				LinkIncremental=&quot;2&quot;
-				AdditionalLibraryDirectories=&quot;&quot;..\..\engine\ui\lib\$(ConfigurationName)&quot;;&quot;..\..\engine\core\lib\$(ConfigurationName)&quot;;&quot;..\..\engine\multimedia\lib\$(ConfigurationName)&quot;;&quot;..\..\dependencies\ogrenew\ogremain\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\cppunit\lib;..\..\dependencies\fmod\api\lib&quot;
-				GenerateDebugInformation=&quot;true&quot;
-				AssemblyDebug=&quot;1&quot;
-				GenerateMapFile=&quot;true&quot;
-				MapExports=&quot;true&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCALinkTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCManifestTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCXDCMakeTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCBscMakeTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCFxCopTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCAppVerifierTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCWebDeploymentTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCPostBuildEventTool&quot;
-			/&gt;
-		&lt;/Configuration&gt;
-		&lt;Configuration
-			Name=&quot;Release|Win32&quot;
-			OutputDirectory=&quot;$(SolutionDir)$(ConfigurationName)&quot;
-			IntermediateDirectory=&quot;$(ConfigurationName)&quot;
-			ConfigurationType=&quot;1&quot;
-			&gt;
-			&lt;Tool
-				Name=&quot;VCPreBuildEventTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCCustomBuildTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCXMLDataGeneratorTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCWebServiceProxyGeneratorTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCMIDLTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCCLCompilerTool&quot;
-				AdditionalIncludeDirectories=&quot;..\..\engine\script\include;..\..\engine\ui\include;..\..\engine\uicomponents\include;..\..\engine\dialog\include;..\..\engine\multimedia\include;..\..\engine\common\include;..\..\engine\core\include;..\..\engine\rules\include;..\..\dependencies\cppunit\include;..\..\dependencies\ogrenew\OgreMain\include;..\..\dependencies\cegui_mk2\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\ogrenewt\inc;..\..\dependencies\xerces\include;..\..\dependencies\newtonsdk\sdk&quot;
-				PreprocessorDefinitions=&quot;WITH_FMOD3;WIN32;NDEBUG;_WINDOWS;_CRT_SECURE_NO_DEPRECATE&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCManagedResourceCompilerTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCResourceCompilerTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCPreLinkEventTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCLinkerTool&quot;
-				AdditionalDependencies=&quot;CEGUIBase.lib OgreMain.lib cppunit_dll.lib user32.lib RlMultimedia.lib RlCore.lib RlUi.lib&quot;
-				AdditionalLibraryDirectories=&quot;&quot;..\..\engine\ui\lib\$(ConfigurationName)&quot;;&quot;..\..\engine\core\lib\$(ConfigurationName)&quot;;&quot;..\..\engine\multimedia\lib\$(ConfigurationName)&quot;;&quot;..\..\dependencies\ogrenew\ogremain\lib\$(ConfigurationName)&quot;;..\..\dependencies\cegui_mk2\lib;..\..\dependencies\boost\lib;..\..\dependencies\cppunit\lib;..\..\dependencies\fmod\api\lib&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCALinkTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCManifestTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCXDCMakeTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCBscMakeTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCFxCopTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCAppVerifierTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCWebDeploymentTool&quot;
-			/&gt;
-			&lt;Tool
-				Name=&quot;VCPostBuildEventTool&quot;
-			/&gt;
-		&lt;/Configuration&gt;
-	&lt;/Configurations&gt;
-	&lt;References&gt;
-	&lt;/References&gt;
-	&lt;Files&gt;
-		&lt;Filter
-			Name=&quot;Source Files&quot;
-			Filter=&quot;cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx&quot;
-			UniqueIdentifier=&quot;{4FC737F1-C7A5-4376-A066-2A32D752A2FF}&quot;
-			&gt;
-			&lt;File
-				RelativePath=&quot;.\TestDialog.cpp&quot;
-				&gt;
-			&lt;/File&gt;
-		&lt;/Filter&gt;
-		&lt;Filter
-			Name=&quot;Header Files&quot;
-			Filter=&quot;h;hpp;hxx;hm;inl;inc;xsd&quot;
-			UniqueIdentifier=&quot;{93995380-89BD-4b04-88EB-625FBE52EBFB}&quot;
-			&gt;
-		&lt;/Filter&gt;
-		&lt;Filter
-			Name=&quot;Resource Files&quot;
-			Filter=&quot;rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav&quot;
-			UniqueIdentifier=&quot;{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}&quot;
-			&gt;
-		&lt;/Filter&gt;
-	&lt;/Files&gt;
-	&lt;Globals&gt;
-	&lt;/Globals&gt;
-&lt;/VisualStudioProject&gt;

Copied: rl/branches/persistence2/tests/dialogtests/RlDialogTests.vcproj (from rev 4878, rl/trunk/tests/dialogtests/RlDialogTests.vcproj)

Deleted: rl/branches/persistence2/tests/dialogtests/TestDialog.cpp
===================================================================
--- rl/trunk/tests/dialogtests/TestDialog.cpp	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/tests/dialogtests/TestDialog.cpp	2009-04-01 20:08:44 UTC (rev 4879)
@@ -1,119 +0,0 @@
-#include &lt;xercesc/util/XMemory.hpp&gt; // Muss vor Ogre stehen (zumindest f&#239;&#191;&#189;r VS)
-
-#include &lt;Ogre.h&gt;
-#include &lt;OgreLogManager.h&gt;
-#include &lt;stdexcept&gt;
-#include &lt;errno.h&gt;
-
-#include &quot;Logger.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;RulesSubsystem.h&quot;
-#include &quot;UiSubsystem.h&quot;
-#include &quot;RubyInterpreter.h&quot;
-#include &lt;cppunit/extensions/TestFactoryRegistry.h&gt;
-#include &lt;cppunit/ui/text/TestRunner.h&gt;
-
-
-#include &quot;Exception.h&quot;
-#include &lt;CEGUIExceptions.h&gt;
-
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-    #define WIN32_LEAN_AND_MEAN
-    #include &quot;windows.h&quot;
-#endif
-
-
-int main( int argc, char **argv)
-{
-    rl::CoreSubsystem* core = NULL;
-    rl::MultimediaSubsystem* mm = NULL;
-    rl::RulesSubsystem* rules = NULL;
-    rl::DialogSubsystem* dialog = NULL;
-    rl::UiSubsystem* ui =  NULL;
-    rl::ScriptSubsystem* script =  NULL;
-
-    try {
-
-        /**@todo das nach RastullahApplication
-        * und RastullahApplication nach Startup. */
-        core = new rl::CoreSubsystem();
-        rl::Logger::getSingleton().log(rl::Logger::CORE, Ogre::LML_NORMAL, &quot;CoreSubsystem gestartet&quot;);
-
-        mm = new rl::MultimediaSubsystem();
-        rl::Logger::getSingleton().log(rl::Logger::CORE, Ogre::LML_NORMAL, &quot;SoundSubsystem gestartet&quot;);
-
-        rules = new rl::RulesSubsystem();
-        rl::Logger::getSingleton().log(rl::Logger::CORE, Ogre::LML_NORMAL, &quot;RulesSubsystem gestartet&quot;);
-
-        dialog = new rl::DialogSubsystem();
-        rl::Logger::getSingleton().log(rl::Logger::CORE, Ogre::LML_NORMAL, &quot;DialogSubsystem gestartet&quot;);
-
-        ui = new rl::UiSubsystem();
-        rl::Logger::getSingleton().log(rl::Logger::CORE, Ogre::LML_NORMAL, &quot;UiSubsystem gestartet&quot;);
-
-        script = new rl::ScriptSubsystem();
-        rl::Logger::getSingleton().log(rl::Logger::CORE, Ogre::LML_NORMAL, &quot;ScriptSubsystem gestartet&quot;);
-
-        rl::Logger::getSingleton().log(rl::Logger::CORE, Ogre::LML_NORMAL, &quot;Starte...&quot;);
-        //core-&gt;getInterpreter()-&gt;execute(&quot;load 'startup-global.rb'&quot;);
-
-        CppUnit::TextUi::TestRunner runner;
-        CppUnit::TestFactoryRegistry &amp;registry = CppUnit::TestFactoryRegistry::getRegistry();
-        runner.addTest( registry.makeTest() );
-        runner.run();
-        rl::Logger::getSingleton().log(rl::Logger::CORE, Ogre::LML_NORMAL, &quot;Ende...&quot;);
-
-    }
-    catch(Ogre::Exception&amp; oe) {
-        rl::showError(oe.getFullDescription());
-    }
-    catch(rl::Exception&amp; re) {
-        rl::showError(re.toString());
-    }
-    catch(CEGUI::Exception&amp; ce) {
-        rl::showError(ce.getMessage().c_str());
-    }
-    catch(std::runtime_error&amp; rte) {
-        rl::showError(rte.what());
-    }
-    catch(std::exception&amp; exp) {
-        rl::showError( exp.what() );
-    }
-    catch(std::string&amp; err) {
-        rl::showError( err );
-    }
-    catch(...) {
-        rl::showError( &quot;Unknown exception occured&quot; );
-    }
-
-    try
-    {
-        delete script;
-        delete ui;
-        delete dialog;
-        delete rules;
-        delete mm;
-        delete core;
-    }
-    catch(Ogre::Exception&amp; oe) {
-        rl::showError(oe.getFullDescription());
-    }
-    catch(rl::Exception&amp; re) {
-        rl::showError(re.toString());
-    }
-    catch(std::runtime_error&amp; rte) {
-        rl::showError(rte.what());
-    }
-    catch(std::exception&amp; exp) {
-        rl::showError( exp.what() );
-    }
-    catch(std::string&amp; err) {
-        rl::showError( err );
-    }
-    catch(...) {
-        rl::showError( &quot;Unknown exception occured&quot; );
-    }
-
-
-    return 0;
-}

Copied: rl/branches/persistence2/tests/dialogtests/TestDialog.cpp (from rev 4878, rl/trunk/tests/dialogtests/TestDialog.cpp)

Modified: rl/branches/persistence2/tools/copy_dependencies.bat
===================================================================
--- rl/branches/persistence2/tools/copy_dependencies.bat	2009-04-01 18:35:03 UTC (rev 4878)
+++ rl/branches/persistence2/tools/copy_dependencies.bat	2009-04-01 20:08:44 UTC (rev 4879)
@@ -53,9 +53,9 @@
 REM 
 copy &quot;%RL_ROOT%\dependencies\FMOD4\api\fmodex.dll&quot; &quot;%RL_DIST%&quot;
 
-copy &quot;%RL_ROOT%\Dependencies\NewtonSDK\sdk\dll\Newton.dll&quot; &quot;%RL_DIST%&quot;
-copy &quot;%RL_ROOT%\Dependencies\OgreNewt\lib\debug\OgreNewt_d.dll&quot; &quot;%RL_DIST%&quot;
-copy &quot;%RL_ROOT%\Dependencies\OgreNewt\lib\release\OgreNewt.dll&quot; &quot;%RL_DIST%&quot;
+copy &quot;%RL_ROOT%\Dependencies\NewtonSDK\sdk\x32\dll_vs9\Newton.dll&quot; &quot;%RL_DIST%&quot;
+copy &quot;%RL_ROOT%\Dependencies\OgreNewt\lib\OgreNewt_d.dll&quot; &quot;%RL_DIST%&quot;
+copy &quot;%RL_ROOT%\Dependencies\OgreNewt\lib\OgreNewt.dll&quot; &quot;%RL_DIST%&quot;
 
 copy &quot;%RL_ROOT%\Dependencies\cegui_mk2\bin\*.dll&quot; &quot;%RL_DIST%&quot;
 copy &quot;%RL_ROOT%\Dependencies\xerces\bin\*.dll&quot; &quot;%RL_DIST%&quot;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001935.html">[Dsa-hl-svn] r4878 - in rl/trunk/engine: ai/src core script/src
</A></li>
	<LI>Next message: <A HREF="001937.html">[Dsa-hl-svn] r4880 - content/textures
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1936">[ date ]</a>
              <a href="thread.html#1936">[ thread ]</a>
              <a href="subject.html#1936">[ subject ]</a>
              <a href="author.html#1936">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
