<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4896 - in rl/trunk/engine: ai/include ai/src core	core/include core/src rules/src script/include script/src	script/swig ui/include ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-April/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4896%20-%20in%20rl/trunk/engine%3A%20ai/include%20ai/src%20core%0A%09core/include%20core/src%20rules/src%20script/include%20script/src%0A%09script/swig%20ui/include%20ui/src&In-Reply-To=%3C200904140007.n3E07mNY014864%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001952.html">
   <LINK REL="Next"  HREF="001954.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4896 - in rl/trunk/engine: ai/include ai/src core	core/include core/src rules/src script/include script/src	script/swig ui/include ui/src</H1>
    <B>melven at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4896%20-%20in%20rl/trunk/engine%3A%20ai/include%20ai/src%20core%0A%09core/include%20core/src%20rules/src%20script/include%20script/src%0A%09script/swig%20ui/include%20ui/src&In-Reply-To=%3C200904140007.n3E07mNY014864%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4896 - in rl/trunk/engine: ai/include ai/src core	core/include core/src rules/src script/include script/src	script/swig ui/include ui/src">melven at mail.berlios.de
       </A><BR>
    <I>Tue Apr 14 02:07:49 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001952.html">[Dsa-hl-svn] r4895 - rl/trunk/editors/Lockenwickler/src
</A></li>
        <LI>Next message: <A HREF="001954.html">[Dsa-hl-svn] r4897 - in rl/branches/persistence2:	editors/Lockenwickler/src engine/ai/include engine/ai/src	engine/core engine/core/include engine/core/src	engine/rules/src engine/script/include engine/script/src	engine/script/swig engine/ui/include engine/ui/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1953">[ date ]</a>
              <a href="thread.html#1953">[ thread ]</a>
              <a href="subject.html#1953">[ subject ]</a>
              <a href="author.html#1953">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: melven
Date: 2009-04-14 02:07:38 +0200 (Tue, 14 Apr 2009)
New Revision: 4896

Added:
   rl/trunk/engine/core/include/GenericWorld.h
   rl/trunk/engine/core/src/GenericWorld.cpp
Removed:
   rl/trunk/engine/core/include/DotSceneLoader.h
   rl/trunk/engine/core/include/DotSceneOctreeWorld.h
   rl/trunk/engine/core/src/DotSceneLoader.cpp
   rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp
Modified:
   rl/trunk/engine/ai/include/AiSubsystem.h
   rl/trunk/engine/ai/src/AiSubsystem.cpp
   rl/trunk/engine/core/CMakeLists.txt
   rl/trunk/engine/core/include/CoreSubsystem.h
   rl/trunk/engine/core/include/PhysicsManager.h
   rl/trunk/engine/core/include/World.h
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/core/src/GameAreaTypes.cpp
   rl/trunk/engine/core/src/GameEventManager.cpp
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/trunk/engine/core/src/SceneQuery.cpp
   rl/trunk/engine/rules/src/CreatureControllerManager.cpp
   rl/trunk/engine/rules/src/SelectionHelper.cpp
   rl/trunk/engine/script/include/EntityNodeProcessor.h
   rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/engine/ui/include/UiSubsystem.h
   rl/trunk/engine/ui/src/MovementControlState.cpp
Log:
VC project files need to be updated!
- removed DotSceneLoader and related stuff (moved DotSceneOctreeWorld to GenericWorld (it creates a world with SceneType 'generic'))
- fixed some bugs when using OGRENEWT_USE_OGRE_ANY
- reorganized the collision-creation a bit (all real work is done in the CollisionsFactory (also the caching will be done there)) in order
  to simplify the code, caching of collisions still not implemented


Modified: rl/trunk/engine/ai/include/AiSubsystem.h
===================================================================
--- rl/trunk/engine/ai/include/AiSubsystem.h	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/ai/include/AiSubsystem.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -20,7 +20,6 @@
 #include &quot;AiPrerequisites.h&quot;
 
 #include &quot;MessagePump.h&quot;
-#include &quot;World.h&quot;
 
 namespace rl
 {

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -24,9 +24,7 @@
 #include &quot;GameLoop.h&quot;
 #include &quot;Landmark.h&quot;
 #include &quot;LandmarkPath.h&quot;
-#include &quot;Logger.h&quot;
 #include &quot;WayPointGraphManager.h&quot;
-#include &quot;World.h&quot;
 
 #include &lt;xercesc/util/PlatformUtils.hpp&gt;
 

Modified: rl/trunk/engine/core/CMakeLists.txt
===================================================================
--- rl/trunk/engine/core/CMakeLists.txt	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/CMakeLists.txt	2009-04-14 00:07:38 UTC (rev 4896)
@@ -25,8 +25,6 @@
 src/CoreSubsystem.cpp
 src/DebugVisualisable.cpp
 src/DebugVisualsManager.cpp
-src/DotSceneLoader.cpp
-src/DotSceneOctreeWorld.cpp
 src/FadeAnimation.cpp
 src/GameAreaEvent.cpp
 src/GameAreaEventSource.cpp
@@ -34,6 +32,7 @@
 src/GameAreaTypes.cpp
 src/GameEventManager.cpp
 src/GameLoop.cpp
+src/GenericWorld.cpp
 src/Job.cpp
 src/JobQueue.cpp
 src/JobScheduler.cpp

Modified: rl/trunk/engine/core/include/CoreSubsystem.h
===================================================================
--- rl/trunk/engine/core/include/CoreSubsystem.h	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/include/CoreSubsystem.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -23,6 +23,7 @@
 #include &quot;EventSource.h&quot;
 #include &quot;EventCaster.h&quot;
 #include &quot;CorePrerequisites.h&quot;
+#include &quot;World.h&quot;
 
 namespace rl {
 
@@ -69,9 +70,10 @@
     void renderOneFrame(bool executeTasks = true);
 
     World* getWorld();
-    void loadMap(const Ogre::String&amp; type, const Ogre::String&amp; filename,
-        const Ogre::String&amp; module);
 
+    // obsolete
+    // void loadMap(const Ogre::String&amp; type, const Ogre::String&amp; filename, const Ogre::String&amp; module);
+
     RubyInterpreter* getRubyInterpreter();
 
     ContentModule* getActiveAdventureModule() const;

Deleted: rl/trunk/engine/core/include/DotSceneLoader.h
===================================================================
--- rl/trunk/engine/core/include/DotSceneLoader.h	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/include/DotSceneLoader.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -1,160 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __DotSceneLoader_H__
-#define __DotSceneLoader_H__
-
-#include &quot;CorePrerequisites.h&quot;
-
-#ifdef __APPLE__
-#   include &lt;OgreNewt/OgreNewt.h&gt;
-#else
-#   include &lt;OgreNewt.h&gt;
-#endif
-
-#include &lt;string&gt;
-#include &lt;map&gt;
-
-#include &quot;XmlResourceManager.h&quot;
-#include &quot;XmlPropertyReader.h&quot;
-
-namespace Ogre {
-	class SceneNode;
-}
-
-namespace XERCES_CPP_NAMESPACE {
-	class DOMElement;
-}
-
-namespace rl {
-
-	/** Diese Klasse parst eine .scene.xml Datei.
-	 *  
-	 *  Zur Zeit sind folgenende Dinge (partiell) unterst&#252;tzt 
-	 *   - Nodes ( Name, Hierarchie + Platzierung + Skalierung + Rotation )
-	 *   - Entities ( Name, TriMeshPhysik )
-	 */
-    class DotSceneLoader : private XmlPropertyReader
-	{
-	public:
-		/// Erstellt einen Dotscene Loader, der das gew&#252;nschte File einliest
-        DotSceneLoader(const std::string&amp; filename, const std::string&amp; resourceGroup);
-		/// Standard Destruktor
-		virtual ~DotSceneLoader();
-
-		/// Laden der Szene
-		void initializeScene(Ogre::SceneManager* sceneManager);
-
-	private:
-        struct NodeUserData
-        {
-            std::string physical_body;
-			Ogre::Real renderingdistance;
-			int staticgeom_group;
-            bool is_dynamic;
-			bool is_inheriting;
-			OgreNewt::CollisionPtr collision;
-        };
-
-		// wird verwendet um einen Zeiger auf eine vorherige identische
-        // Collision zu erhalten
-        struct AlreadyUsedCollision
-        {
-        public:
-            std::string Type;
-            Ogre::Vector3 Scale;
-            OgreNewt::CollisionPtr ColPtr;
-        };
-
-
-		/// Geht alle Nodes in der .scene durch
-		void processNodes(XERCES_CPP_NAMESPACE::DOMElement* rootNodesXml, 
-			Ogre::SceneManager* sceneManager,
-			Ogre::SceneNode* parentNode );
-		/// Node und alle Unterelemente
-		void processNode(XERCES_CPP_NAMESPACE::DOMElement* rootNodeXml, 
-			Ogre::SceneManager* sceneManager,
-			Ogre::SceneNode* parentNode, NodeUserData* parentUserData );
-		/// Eine Entity+Attribute
-		void processEntity( XERCES_CPP_NAMESPACE::DOMElement* rootEntityXml, 
-			Ogre::SceneManager* sceneManager, Ogre::SceneNode* parentNode, 
-			Ogre::Real renderingDistance, const std::string &amp;bodyproxy_type );
-        /// Ein benutzerdefinierter Bereich im Node
-        void processNodeUserData( XERCES_CPP_NAMESPACE::DOMElement* rootUserDataXml, 
-			NodeUserData* userData );
-		/// Ein benutzerdefinierter Bereich in der Szene
-		void processSceneUserData( XERCES_CPP_NAMESPACE::DOMElement* rootUserDataXml );
-
-		/** Liest einen Vector aus einem XML Element, &#252;ber die Attribute x, y, z
-		 *  Sollten die Attribute nicht korrekt definiert sein, gibt es Vector::ZERO zur&#252;ck (0,0,0)
-		 */
-		Ogre::Vector3 processPosition( XERCES_CPP_NAMESPACE::DOMElement* rootPositionXml );
-
-		/** Liest einen Vector aus einem XML Element, &#252;ber die Attribute x, y, z
-		*  Sollten die Attribute nicht korrekt definiert sein, gibt es Vector::UNIT_SCALE zur&#252;ck (1,1,1)
-		*/
-		Ogre::Vector3 processScale( XERCES_CPP_NAMESPACE::DOMElement* rootPositionXml );
-		/** Liest einen Vector aus einem XML Element, &#252;ber die Attribute x, y, z
-		*  Sollten die Attribute nicht korrekt definiert sein, wird error auf true gesetzt.
-		*/
-		Ogre::Vector3 processVector( XERCES_CPP_NAMESPACE::DOMElement* rootPositionXml, bool &amp;error );
-		/** Liest ein Quaternion aus einem XML Element, 
-		*  &#252;ber die Attribute qw, qx, qy, qz  ODER angle, axisX, axisY, axisZ
-		*  Sollten die Attribute nicht korrekt definiert sein, gibt es Quaternion::IDENTITY zur&#252;ck (1,0,0,0)
-		*/
-		Ogre::Quaternion processRotation( XERCES_CPP_NAMESPACE::DOMElement* rootQuatXml );
-		/** Liest eine Liste von ein bis mehreren Bodyproxies (Collisions)
-		* SceneUserData ein.
-		* Sollten die Attribute falsch gesetzt sein, gibt es NULL zur&#252;ck; Dadurch wird keine Collision verwendet
-		*/
-		void processCollisions( XERCES_CPP_NAMESPACE::DOMElement* rootCollisionXml );
-
-        std::string getRandomName(const std::string&amp; baseName);
-        /// Builds a string from a xerces exception
-        std::string toString( const std::string&amp; type, const XERCES_CPP_NAMESPACE::SAXParseException&amp; exc ) const;
-
-		/// Der Node der Scene
-		Ogre::SceneNode* mSceneNode;
-		/// Alle statischen GeometrieNodes
-		std::map&lt;int,Ogre::SceneNode*&gt; mStaticNodes;
-
-		/// Alle bodyproxies, die schon automatisch erstellt worden sind
-		typedef std::map&lt;const std::string,AlreadyUsedCollision&gt;
-			USEDCOLLISIONSMAP;
-		USEDCOLLISIONSMAP mAutoCreatedCollisions;
-        std::vector&lt;OgreNewt::CollisionPtr&gt; mCollisions;
-
-		Ogre::Real mRenderingDistance;
-		std::map&lt;int,Ogre::Real&gt; mStaticgeomRenderingDistances;
-		std::map&lt;int,Ogre::Real&gt; mStaticgeomBatchSizes;
-		
-		/// Der Name der Scene
-		const std::string mSceneName;
-        /// ResourceGroup der dotscene-Resource
-        const std::string mResourceGroup;
-
-        /// Have any errors occured
-        int mErrorCount;
-
-        /// The Ressource
-        XmlPtr mRessource;
-        // The Parser
-        XERCES_CPP_NAMESPACE::XercesDOMParser* mParser;
-	};
-
-}
-
-#endif

Deleted: rl/trunk/engine/core/include/DotSceneOctreeWorld.h
===================================================================
--- rl/trunk/engine/core/include/DotSceneOctreeWorld.h	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/include/DotSceneOctreeWorld.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -1,39 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#ifndef __DotSceneOctreeWorld_H__
-#define __DotSceneOctreeWorld_H__
-
-#include &quot;World.h&quot;
-
-#include &quot;CorePrerequisites.h&quot;
-
-namespace rl {
-
-    class _RlCoreExport DotSceneOctreeWorld : public World
-    {
-    public:
-        DotSceneOctreeWorld();
-        ~DotSceneOctreeWorld();
-
-        virtual void clearScene();
-        virtual void initializeDefaultCamera();	
-		virtual void setCastShadows(bool enabled);
-        virtual void loadScene(const Ogre::String&amp; levelName, const Ogre::String&amp; module);
-    };
-
-}
-#endif

Copied: rl/trunk/engine/core/include/GenericWorld.h (from rev 4889, rl/trunk/engine/core/include/DotSceneOctreeWorld.h)
===================================================================
--- rl/trunk/engine/core/include/DotSceneOctreeWorld.h	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/core/include/GenericWorld.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -0,0 +1,38 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __GenericWorld_H__
+#define __GenericWorld_H__
+
+#include &quot;World.h&quot;
+
+#include &quot;CorePrerequisites.h&quot;
+
+namespace rl {
+
+    class _RlCoreExport GenericWorld : public World
+    {
+    public:
+        GenericWorld();
+        ~GenericWorld();
+
+        virtual void clearScene();
+        virtual void initializeDefaultCamera();	
+		virtual void setCastShadows(bool enabled);
+    };
+
+}
+#endif

Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -141,7 +141,7 @@
 		/// Komplette Levelgeometrie aufl&#246;sen
 		void clearLevelGeometry();
 		
-	void toggleDebugMode();
+        void toggleDebugMode();
         int isDebugMode() const;
 
         // Newton callbacks ...
@@ -207,75 +207,30 @@
         void resetMaterialPair( const OgreNewt::MaterialID* M1,
             const OgreNewt::MaterialID* M2);
 
-        /** creates a collision primitive for OgreNewt.
-		 * The collision primitive created has got a basic orientation which can be influenced by
-		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
-		 * calculated according to the size and type of collision primitiv.
-         * Whenever any of the parameters is a null pointer, it is ignored.
-         * The created collision primitive gets cached for the given mesh,
-         * so whenever an other entity with the same mesh tries to fetch
-         * a collision primitive here, then it gets back the already existing
-         * one (no need to duplicate).
-		 * @param entity gives the mesh entity that needs a collision primitive
-         * @param geomType defines the geometry of the collision type
-         * @param offset Vector3 gives the offset of the coordinate system of the coll. primitiv
-		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
-         * @param mass gives the mass of the collision primitive used for calculating the inertia
-		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
-		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
-         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
-         *                the new collision is not added to the cache
-		*/
+        /// calls PhysicsCollisionFactory::createCollisionFromEntity
 		OgreNewt::CollisionPtr createCollision(
 			Ogre::Entity* entity,
             const GeometryType&amp; geomType = GT_NONE,
-            const Ogre::String animName = &quot;&quot;,
-			Ogre::Vector3* offset = NULL,
-			Ogre::Quaternion* orientation = NULL,
+            const Ogre::String&amp; animName = &quot;&quot;,
+			const Ogre::Vector3* offset = NULL,
+			const Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
             Ogre::Vector3* inertia = NULL,
             Ogre::Vector3* centerOfMass = NULL,
             bool nocache = false);
 
-        /** creates a collision primitive for OgreNewt.
-		 * The collision primitive created has got a basic orientation which can be influenced by
-		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
-		 * calculated according to the size and type of collision primitiv.
-         * Whenever any of the parameters is a null pointer, it is ignored.
-         * The created collision primitive gets cached for the given aabb,
-         * so whenever an other aabb with the same name tries to fetch
-         * a collision primitive here, then it gets back the already existing
-         * one (no need to duplicate).
-		 * @param aabb AxisAlignedBox that contains the extents for the collision primitive to be created
-         * @param name gives the name of the AxisAlignedBox
-         * @param geomType defines the geometry of the collision type
-         * @param offset Vector3 gives the offset of the coordinate system of the coll. primitiv
-		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
-         * @param mass gives the mass of the collision primitive used for calculating the inertia
-		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
-		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
-         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
-         *                the new collision is not added to the cache
-		*/
+        /// calls PhysicsCollisionFactory::createCollisionFromAABB
         OgreNewt::CollisionPtr createCollision(
             const Ogre::String&amp; name,
             const Ogre::AxisAlignedBox&amp; aabb,
             const GeometryType&amp; geomType = GT_NONE,
-            Ogre::Vector3* offset = NULL,
-			Ogre::Quaternion* orientation = NULL,
+            const Ogre::Vector3* offset = NULL,
+			const Ogre::Quaternion* orientation = NULL,
             const Ogre::Real mass = 0,
             Ogre::Vector3* inertia = NULL,
             Ogre::Vector3* centerOfMass = NULL,
             bool nocache = false);
 
-        /** Makes the collision primitive generation available to non mesh objects.
-         * Non mesh objects need collision objects too. Therefore they can
-         * utilise this function for bypassing the caching mechanism of
-         * PhysicalManager.
-         * @returns a collision primitive creating factory object.
-         */
-        PhysicsCollisionFactory* getCollisionFactory();
-
         /** converts a string identifying a collision property into an enum.
          * Mainly for making string definitions of the collision property
          * possible in .gof files.
@@ -294,30 +249,6 @@
         OgreNewt::Debugger* getNewtonDebugger() {return &amp;mWorld-&gt;getDebugger();}
 
     private:
-
-        /** structure containing further information about the collision primitive.
-         * Actually this information should go into either the collisionptr or the
-         * object for the primitive ...
-         */
-        struct CollisionInUse
-        {
-        public:
-            CollisionInUse() :
-#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
-                colPtr(NULL),
-#endif
-                geomType(GT_NONE) {}
-            GeometryType geomType;  //! primitive type
-            OgreNewt::CollisionPtr colPtr;          //! the collision primitve
-        };
-
-        /** shortens definition of a list of collision primitives.
-         * currently only one geometry type per entity (mesh) is allowed.
-         * if multiple should be possible, the geometry type should be
-         * moved from the above struct into the key.
-         */
-        typedef std::map&lt; std::string, CollisionInUse &gt; CollisionMap;
-
         bool mEnabled;
         //! the globally used physical representation of the world by Newton
         OgreNewt::World* mWorld;
@@ -326,8 +257,6 @@
 
         //! factory for creating new collision primitives
         PhysicsCollisionFactory* mPhysicsCollisionFactory;
-        //! a list of collision primitives
-        CollisionMap mCollisionPrimitives;
 
         //! a list of objects of the physical world
         std::vector&lt;PhysicalThing*&gt; mPhysicalThings;
@@ -391,139 +320,248 @@
     class PhysicsCollisionFactory
     {
     public:
-        /** checks if the specified size is ok for OgreNewt
-         * @param aabb check the aabb's size
-         */
-        bool checkSize(const Ogre::AxisAlignedBox&amp; aabb) const;
-        /** corrects the specified size if it is not ok for OgreNewt
-         * @param aabb correct the aabb's size
-         */
-        void correctSize(Ogre::AxisAlignedBox&amp; aabb);
-        /** calculates the Inertia for the given primitive type
-         */
-        //Ogre::Vector3 calculateIntertia(const Ogre::Real&amp; Mass, Ogre::Vector3* inertiaCoefficients);
+        //! destructor, releases the collisions from the collision cache
+        ~PhysicsCollisionFactory();
 
-        /** creates a collision primitive for OgreNewt an Ogre::Entity.
+        /** creates a collision primitive for OgreNewt from an Ogre::Entity.
 		 * The collision primitive created has got a basic orientation which can be influenced by
-		 * offset and orientation parameters.
+		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
+		 * calculated according to the size and type of collision primitiv.
          * Whenever any of the parameters is a null pointer, it is ignored.
+         * The created collision primitive gets cached for the given mesh,
+         * so whenever an other entity with the same mesh tries to fetch
+         * a collision primitive here, then it gets back the already existing
+         * one (no need to duplicate).
+         * 
          * Scaling should be implemented through attaching to a scene node.
          * if that is not the case, we'll have to fix OgreNewt ...
-		 * @param entity Ogre::Entity mesh object
+		 * @param entity gives the mesh entity that needs a collision primitive
 		 * @param geomType specifies the type of collision primitiv to create.
 		 * @param offset gives the offset of the coordinate system of the coll. primitiv
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
 		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
+         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
+         *                the new collision is not added to the cache
 		*/
-        OgreNewt::CollisionPtr createCollisionFromEntity(Ogre::Entity* entity,
+        OgreNewt::CollisionPtr createCollisionFromEntity(
+            Ogre::Entity* entity,
             const GeometryType&amp; geomType,
-            Ogre::Vector3* offset = NULL, 
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real Mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation,
+            const Ogre::Real Mass,
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass,
+            bool nocache);
 
-        /** creates a collision primitive for OgreNewt from an AABB box.
+        /** creates a collision primitive for OgreNewt.
 		 * The collision primitive created has got a basic orientation which can be influenced by
-		 * offset and orientation parameters.
+		 * offset and orientation parameters. Additionally an initial inertiaCoefficents vector is
+		 * calculated according to the size and type of collision primitiv.
          * Whenever any of the parameters is a null pointer, it is ignored.
+         * The created collision primitive gets cached for the given aabb,
+         * so whenever an other aabb with the same name tries to fetch
+         * a collision primitive here, then it gets back the already existing
+         * one (no need to duplicate). There's no difference between Collisions created through an aabb or through
+         * the entity in the cache. In order to supply a support for 'scaling' the size of the cached collision is
+         * checked.
          * Since no entity is given several physical collision primitives are not
          * possible (convexhull, tree, etc.)
-         * Scaling should be implemented through attaching to a scene node.
-         * if that is not the case, we'll have to fix OgreNewt ...
-		 * @param entity Ogre::Entity mesh object
+         * // no scaling at the moment, the correct scale must be given (OgreNewt cannot scale a collision, this is a limitation
+         * // of newton. It is only possible to 'scale' a convex collision by created a ConvexHullModifier (a new collision,
+         * // that uses the old one and applies transformation through a matrix), so for aabbs (-&gt; convex collisions) a scale
+         * // that udpates with the scale of the node could be implemented, but as this would be different for treecollisions,
+         * // it is better to create a collision with the correct scale...
+         * // &quot;Scaling should be implemented through attaching to a scene node.
+         * // if that is not the case, we'll have to fix OgreNewt ...&quot;
+         * @param name gives the name of the AxisAlignedBox
+		 * @param aabb AxisAlignedBox that contains the extents for the collision primitive to be created
 		 * @param geomType specifies the type of collision primitiv to create.
 		 * @param offset gives the offset of the coordinate system of the coll. primitiv
 		 * @param orientation Quaternion gives an euler rotation for the coordinate system of the coll. primitiv
          * @param mass gives the mass of the collision primitive used for calculating the inertia
 		 * @param inertia Vector3 returns the inertia coefficients for the created collision primitiv
 		 * @param centerOfMass Vector3 returns the centerOfMass coefficients for the created collision primitiv
+         * @param nocache if set to true a new collision will be created (without looking for an existing one in the cache);
+         *                the new collision is not added to the cache
 		*/
-        OgreNewt::CollisionPtr createCollisionFromAABB(const Ogre::AxisAlignedBox aabb,
+        OgreNewt::CollisionPtr createCollisionFromAABB(
+            const Ogre::String&amp; name,
+            const Ogre::AxisAlignedBox&amp; aabb,
             const GeometryType&amp; geomType,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real Mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation,
+            const Ogre::Real Mass,
+            Ogre::Vector3* inertia,
+            Ogre::Vector3* centerOfMass,
+            bool nocache);
+
+        /// clear the collision cache
+        void clearCollisionCache();
+
     protected:
+        /** checks if the specified size is ok for OgreNewt
+         * @param aabb check the aabb's size
+         */
+        bool checkSize(const Ogre::AxisAlignedBox&amp; aabb) const;
+
+        /** corrects the specified size if it is not ok for OgreNewt
+         * @param aabb correct the aabb's size
+         */
+        void correctSize(Ogre::AxisAlignedBox&amp; aabb);
+
         /** creates a box collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
          * @param offset when not null, specifies a different offset than the standard.
          * @param orientation when not null, specifies the euler angle of orientation.
-         * @param mass gives the mass for inertia calculation.
-         * @param inertia when not null, an inertia is calculated and passed back.
-         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
-        OgreNewt::CollisionPtr createBox(const Ogre::AxisAlignedBox&amp; aabb,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+        OgreNewt::ConvexCollisionPtr createBox(const Ogre::AxisAlignedBox&amp; aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
         /** creates a pyramid collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
          * @param offset when not null, specifies a different offset than the standard.
          * @param orientation when not null, specifies the euler angle of orientation.
-         * @param mass gives the mass for inertia calculation.
-         * @param inertia when not null, an inertia is calculated and passed back.
-         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
-        OgreNewt::CollisionPtr createPyramid(const Ogre::AxisAlignedBox&amp; aabb,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+        OgreNewt::ConvexCollisionPtr createPyramid(const Ogre::AxisAlignedBox&amp; aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
         /** creates a sphere collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
          * @param offset when not null, specifies a different offset than the standard.
          * @param orientation when not null, specifies the euler angle of orientation.
-         * @param mass gives the mass for inertia calculation.
-         * @param inertia when not null, an inertia is calculated and passed back.
-         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
-        OgreNewt::CollisionPtr createSphere(const Ogre::AxisAlignedBox&amp; aabb,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+        OgreNewt::ConvexCollisionPtr createSphere(const Ogre::AxisAlignedBox&amp; aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
         /** creates a ellipsoid collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
          * @param offset when not null, specifies a different offset than the standard.
          * @param orientation when not null, specifies the euler angle of orientation.
-         * @param mass gives the mass for inertia calculation.
-         * @param inertia when not null, an inertia is calculated and passed back.
-         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
-        OgreNewt::CollisionPtr createEllipsoid(const Ogre::AxisAlignedBox&amp; aabb,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+        OgreNewt::ConvexCollisionPtr createEllipsoid(const Ogre::AxisAlignedBox&amp; aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
         /** creates a capsule collision primitive with offset at middle of bottom layer.
          * It's actually a convenience function used by both createCollision functions.
          * @param aabb gives the axis aligned dimension to create the primitive for.
          * @param offset when not null, specifies a different offset than the standard.
          * @param orientation when not null, specifies the euler angle of orientation.
-         * @param mass gives the mass for inertia calculation.
-         * @param inertia when not null, an inertia is calculated and passed back.
-         * @param centerOfMass when not null, an centerOfMass is calculated and passed back.
          */
-        OgreNewt::CollisionPtr createCapsule(const Ogre::AxisAlignedBox&amp; aabb,
-            Ogre::Vector3* offset = NULL,
-            Ogre::Quaternion* orientation = NULL,
-            const Ogre::Real mass = 0,
-            Ogre::Vector3* inertia = NULL,
-            Ogre::Vector3* centerOfMass = NULL);
+        OgreNewt::ConvexCollisionPtr createCapsule(const Ogre::AxisAlignedBox&amp; aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
+        /** creates a convex-hull collision primitive with offset at middle of bottom layer.
+         * It's actually a convenience function used by createCollisionFromEntity
+         * @param entity the entity for which a convexhull should be created, if it is attached to
+         *               a node the scale of the node is used (see OgreNewt)
+         * @param offset when not null, specifies a different offset than the standard.
+         * @param orientation when not null, specifies the euler angle of orientation.
+         */
+        OgreNewt::ConvexCollisionPtr createConvexHull(
+            Ogre::Entity* entity,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation);
+
+
+        //! class for caching convex collisions (box...convexhull), saves additionally the scale, so it can be rescaled if necessary
+        class ConvexCollisionCacheObject
+        {
+            public:
+                ConvexCollisionCacheObject() :
+#ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
+                    col(NULL),
+#endif
+                    scale(Ogre::Vector3::ZERO),
+                    type(GT_NONE)
+                    {}
+                OgreNewt::ConvexCollisionPtr col;
+                Ogre::Vector3 scale;
+                GeometryType type;
+        };
+
+        typedef std::map&lt;Ogre::String, ConvexCollisionCacheObject&gt; ConvexCollisionCacheMap;
+
+        //! cache for convex collisions
+        ConvexCollisionCacheMap mConvexCollisionsCache;
+
+        //! for using a string and a vector as key in a map... we should implement here a hash-function
+        class StringVector
+        {
+            public:
+                StringVector(const Ogre::String&amp; str, const Ogre::Vector3&amp; vec) : mStr(str)
+                {
+                    setVector(vec);
+                }
+                void setString(const Ogre::String&amp; str) {mStr = str;}
+                void setVector(const Ogre::Vector3&amp; vec)
+                {
+                    mVec = vec;
+                }
+                const Ogre::String&amp; getString() const {return mStr;}
+                const Ogre::Vector3&amp; getVector() const {return mVec;}
+
+                bool operator==(const StringVector&amp; strVec) const
+                {
+                    if( mStr != strVec.mStr )
+                        return false;
+
+                    Ogre::Vector3 diff = mVec - strVec.mVec;
+                    if( abs(diff.x) &gt; 0.01 )
+                        return false;
+                    if( abs(diff.y) &gt; 0.01 )
+                        return false;
+                    if( abs(diff.z) &gt; 0.01 )
+                        return false;
+
+                    return true;
+                }
+
+                bool operator&lt;(const StringVector&amp; strVec) const
+                {
+                    int strCompare = mStr.compare(strVec.mStr);
+                    if( strCompare == 0 ) // strings are the same
+                    {
+                        // compare vectors
+                        Ogre::Vector3 diff = mVec - strVec.mVec;
+                        if( diff.x &lt; -0.01 )
+                            return true;
+                        if( diff.x &gt; 0.01 )
+                            return false;
+                        if( diff.y &lt; -0.01 )
+                            return true;
+                        if( diff.y &gt; 0.01 )
+                            return false;
+                        if( diff.y &lt; -0.01 )
+                            return true;
+
+                        return false;
+                    }
+                    
+                    return strCompare &lt; 0;
+                }
+            private:
+                Ogre::String mStr;
+                Ogre::Vector3 mVec;
+        };
+
+        typedef std::map&lt;StringVector, OgreNewt::CollisionPtr&gt; MeshCollisionCacheMap;
+
+        //! cache for mesh collisions
+        MeshCollisionCacheMap mMeshCollisionsCache;
+
+
+
     };
 }
 

Modified: rl/trunk/engine/core/include/World.h
===================================================================
--- rl/trunk/engine/core/include/World.h	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/include/World.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -42,9 +42,10 @@
         virtual Ogre::Vector3 getStartPoint() const;
 
         virtual void clearScene(void) = 0;
-        virtual void loadScene(const Ogre::String&amp; levelName,
-            const Ogre::String&amp; module) = 0;
 
+        // obsolete
+        //virtual void loadScene(const Ogre::String&amp; levelName, const Ogre::String&amp; module) = 0;
+
         //Enables / disables a 'sky plane' i.e.
         virtual void setSkyPlane(bool enable, const Ogre::Plane &amp;plane,
             const Ogre::String &amp;materialName,

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -26,7 +26,7 @@
 #include &quot;ContentModule.h&quot;
 #include &quot;ConfigurationManager.h&quot;
 #include &quot;DebugVisualsManager.h&quot;
-#include &quot;DotSceneOctreeWorld.h&quot;
+#include &quot;GenericWorld.h&quot;
 #include &quot;Exception.h&quot;
 #include &quot;GameEventManager.h&quot;
 #include &quot;GameLoop.h&quot;
@@ -280,7 +280,7 @@
                 &quot;Video&quot;, &quot;Max Anisotropy&quot;));
 
 
-        mWorld = new DotSceneOctreeWorld();
+        mWorld = new GenericWorld();
         mActorManager-&gt;setWorld(mWorld);
 
         mPhysicsManager = new PhysicsManager();  // the World needs to be initialized before!
@@ -571,12 +571,15 @@
         return mModules;
     }
 
+    // obsolete
+/*
     void CoreSubsystem::loadMap(const Ogre::String&amp; type, const Ogre::String&amp; filename,
         const Ogre::String&amp; module)
     {
         mWorld-&gt;loadScene(filename, module);
     }
-    
+*/  
+
     void CoreSubsystem::loadPlugin(const Ogre::String&amp; plugin)
     {
         Ogre::String pluginFile;

Deleted: rl/trunk/engine/core/src/DotSceneLoader.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneLoader.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/src/DotSceneLoader.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -1,1095 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
-#include &quot;DotSceneLoader.h&quot;
-#include &quot;World.h&quot;
-
-#include &quot;PhysicsManager.h&quot;
-#include &quot;ActorManager.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;ConfigurationManager.h&quot;
-
-#include &quot;Property.h&quot;
-
-#include &quot;Exception.h&quot;
-
-#include &lt;cstdlib&gt;
-#include &lt;ctime&gt;
-
-using namespace XERCES_CPP_NAMESPACE;
-using namespace std;
-using namespace Ogre;
-
-namespace rl {
-    using XERCES_CPP_NAMESPACE::DOMDocument;
-
-    DotSceneLoader::DotSceneLoader(const string&amp; filename, const string&amp; resourceGroup)
-        : mSceneName(filename),
-          mResourceGroup(resourceGroup),
-          mStaticNodes(),
-          mRenderingDistance(ActorManager::getSingleton().getDefaultActorRenderingDistance()),
-          mStaticgeomRenderingDistances(),
-          mStaticgeomBatchSizes(),
-          mRessource(NULL),
-          mParser(NULL),
-          mErrorCount(0)
-    {
-        srand(static_cast&lt;unsigned int&gt;(time(NULL)));
-    }
-
-    DotSceneLoader::~DotSceneLoader()
-    {
-        if (!mRessource.isNull() &amp;&amp; mRessource-&gt;isLoaded())
-        {
-            XmlResourceManager::getSingleton().unload(mSceneName);
-            XmlResourceManager::getSingleton().remove(mRessource-&gt;getHandle());
-        }
-    }
-
-    void DotSceneLoader::initializeScene(SceneManager* sceneManager)
-    {
-        initializeXml();
-
-        LOG_MESSAGE(Logger::CORE, &quot;Loading Scene from &quot; + mSceneName);
-        DOMDocument* doc = loadDocument(mSceneName, mResourceGroup);
-
-        // Durch alle Unterelemente iterieren
-        DOMNode* child = doc-&gt;getDocumentElement()-&gt;getFirstChild();
-
-        while(child != NULL)
-        {
-            // Ein Node
-            if (XMLString::compareIString(child-&gt;getNodeName(), AutoXMLCh(&quot;userData&quot;).data()) == 0 )
-            {
-                processSceneUserData(static_cast&lt;DOMElement*&gt;(child));
-            }
-            child = child-&gt;getNextSibling();
-        }
-
-        LOG_DEBUG(Logger::CORE, &quot; Beginne parsen der Unterelemente&quot;);
-        DOMElement* nodes = getChildNamed(doc-&gt;getDocumentElement(), &quot;nodes&quot;);
-
-        // Eine .scene wird in einem SceneNode mit dem Namen der .scene befestigt
-        mSceneNode = sceneManager-&gt;getRootSceneNode()-&gt;createChildSceneNode(mSceneName);
-        processNodes(nodes, sceneManager, mSceneNode);
-
-        // Find out, if static geometry should be used
-        Ogre::String temp = ConfigurationManager::getSingleton().getStringSetting(
-            &quot;Video&quot;, &quot;Use Static Geometry&quot;);
-        bool useStaticGeometry;
-
-        if (temp == &quot;yes&quot;)
-        {
-            useStaticGeometry = true;
-        }
-        else if (temp == &quot;no&quot;)
-        {
-            useStaticGeometry = false;
-        }
-        else
-        {
-            // Check, if Renderer supports vertex buffer
-            useStaticGeometry = Ogre::Root::getSingleton().getRenderSystem()-&gt;getCapabilities()-&gt;hasCapability(Ogre::RSC_VBO);
-        }
-
-        if (useStaticGeometry)
-        {
-            for(std::map&lt;int,Ogre::SceneNode*&gt;::iterator it = mStaticNodes.begin();
-                it != mStaticNodes.end();)
-            {
-                Ogre::SceneNode* staticNode = it-&gt;second;
-                string staticName = Ogre::StringConverter::toString(it-&gt;first);
-                Ogre::Real renderDist = mRenderingDistance;
-                Ogre::Real batchSize = 25.0;
-
-                if (mStaticgeomRenderingDistances.find(it-&gt;first) != mStaticgeomRenderingDistances.end())
-                    renderDist = mStaticgeomRenderingDistances[it-&gt;first];
-                if (mStaticgeomBatchSizes.find(it-&gt;first) != mStaticgeomBatchSizes.end())
-                    batchSize = mStaticgeomBatchSizes[it-&gt;first];
-
-                StaticGeometry* staticGeom = sceneManager-&gt;createStaticGeometry(mSceneName + staticName );
-
-                staticGeom-&gt;setRenderingDistance(renderDist);
-                staticGeom-&gt;addSceneNode(staticNode);
-                staticGeom-&gt;setRegionDimensions(batchSize * Vector3::UNIT_SCALE);
-                // Statische Geometrie bauen
-                staticGeom-&gt;build();
-                // Nicht mehr den Original-Knoten rendern, da dieser noch erhalten ist.
-                staticNode-&gt;setVisible(false);
-                staticNode-&gt;removeAndDestroyAllChildren();
-                sceneManager-&gt;destroySceneNode(staticNode-&gt;getName());
-                staticNode = NULL;
-                LOG_DEBUG(Logger::CORE, &quot; Statische Geometrie &quot;+staticName+&quot; erstellt&quot;);
-                ++it;
-            }
-        }
-        else
-            LOG_DEBUG(Logger::CORE, &quot; Keine statischen Geometrien erstellt&quot;);
-
-        shutdownXml();
-        LOG_DEBUG(Logger::CORE, &quot;Szenenbeschreibung aus &quot; + mSceneName +&quot; fertig geparst&quot;);
-    }
-
-    // Iteriert durch die einzelnen Nodes
-    void DotSceneLoader::processNodes(DOMElement* rootNodesXml, SceneManager* sceneManager,
-        Ogre::SceneNode* parentNode)
-    {
-        if (rootNodesXml == NULL)
-            return;
-        if (parentNode == NULL)
-            Throw(NullPointerException, &quot;parentNode darf nicht null sein&quot;);
-
-
-        // Durch alle Unterelemente iterieren
-        DOMNode* child = rootNodesXml-&gt;getFirstChild();
-
-        while(child != NULL)
-        {
-            // Ein Node
-            if (XMLString::compareIString(child-&gt;getNodeName(), AutoXMLCh(&quot;node&quot;).data()) == 0 )
-            {
-                processNode(static_cast&lt;DOMElement*&gt;(child), sceneManager, parentNode, NULL);
-            }
-            child = child-&gt;getNextSibling();
-        }
-    }
-
-    // Befasst sich mit einem Node
-    void DotSceneLoader::processNode(DOMElement* rootNodeXml, SceneManager* sceneManager, Ogre::SceneNode* parentNode, NodeUserData* parentUserData)
-    {
-        if (rootNodeXml == NULL)
-            return;
-        if (parentNode == NULL)
-            Throw(NullPointerException, &quot;parentNode darf nicht null sein&quot;);
-
-        string nodeName = getAttributeValueAsStdString(rootNodeXml,
-                        &quot;name&quot;);
-
-        Ogre::SceneNode* newNode;
-        // Wurde dem Node ein Name zugewiesen?
-        if (nodeName.length() &gt; 0)
-        {
-            if (!parentNode-&gt;getCreator()-&gt;hasSceneNode(nodeName))
-            {
-                // Dann versuche einen Knoten mit dem Namen zu erstellen
-                newNode = parentNode-&gt;createChildSceneNode(nodeName);
-            }
-            else
-            {
-                // Name schon vergeben
-                newNode = parentNode-&gt;createChildSceneNode();
-                LOG_DEBUG(Logger::CORE,
-                    &quot; NodeName '&quot;+nodeName+&quot;' war schon vergeben! Es wurde der Name '&quot;+newNode-&gt;getName()+&quot;' benutzt.&quot;);
-            }
-        }
-        else
-        {
-            newNode = parentNode-&gt;createChildSceneNode();
-        }
-
-        LOG_DEBUG(Logger::CORE,
-                    &quot; Node '&quot;+newNode-&gt;getName()+&quot;' als Unterknoten von '&quot;+parentNode-&gt;getName()+&quot;' erstellt.&quot;);
-
-
-        NodeUserData userData;
-        // Defaults einstellen
-        if (parentUserData == NULL || !parentUserData-&gt;is_inheriting)
-        {
-            userData.is_dynamic = false;
-            userData.is_inheriting = false;
-            userData.physical_body = &quot;mesh&quot;;
-            userData.staticgeom_group = -1;
-            userData.renderingdistance = mRenderingDistance;
-        }
-        // Vom Vorg&#228;nger erben
-        else
-        {
-            userData.is_dynamic = parentUserData-&gt;is_dynamic;
-            userData.is_inheriting = parentUserData-&gt;is_inheriting;
-            userData.physical_body = parentUserData-&gt;physical_body;
-            userData.staticgeom_group = parentUserData-&gt;staticgeom_group;
-            userData.renderingdistance = parentUserData-&gt;renderingdistance;
-        }
-
-
-        mCollisions.clear();
-        DOMNode* child = rootNodeXml-&gt;getFirstChild();
-        DOMNode *childScale = NULL, *childPosition = NULL,
-        *childRotation = NULL;
-        // Durch alle Unterelemente iterieren und gefundenes speichern
-        while(child != NULL)
-        {
-            // Ein selbstdefinierter Bereich
-            if (XMLString::compareIString(child-&gt;getNodeName(),
-                AutoXMLCh(&quot;userData&quot;).data()) == 0)
-            {
-                // UserData direkt auslesen
-                processNodeUserData(static_cast&lt;DOMElement*&gt;(child) , &amp;userData);
-            }
-            else if (XMLString::compareIString(child-&gt;getNodeName(),
-                     AutoXMLCh(&quot;position&quot;).data()) == 0)
-                childPosition = child;//rootNodeXml-&gt;removeChild(child);
-            else if (XMLString::compareIString(child-&gt;getNodeName(),
-                     AutoXMLCh(&quot;rotation&quot;).data()) == 0)
-                childRotation = child;//rootNodeXml-&gt;removeChild(child);
-            else if (XMLString::compareIString(child-&gt;getNodeName(),
-                     AutoXMLCh(&quot;scale&quot;).data()) == 0)
-                childScale = child;//rootNodeXml-&gt;removeChild(child);
-
-            child = child-&gt;getNextSibling();
-        }
-        // so jetzt stehen nur noch entities und nodes in der liste
-
-
-
-
-
-        if (userData.staticgeom_group &gt; -1)
-        {
-            newNode-&gt;getParentSceneNode()-&gt;removeChild(newNode);
-
-            // Existiert noch nicht
-            if (mStaticNodes.find(userData.staticgeom_group) == mStaticNodes.end())
-            {
-                mStaticNodes[userData.staticgeom_group] =
-                sceneManager-&gt;getRootSceneNode()-&gt;createChildSceneNode(
-                mSceneName+&quot;_static_&quot;+Ogre::StringConverter::toString(userData.staticgeom_group));
-            }
-
-            mStaticNodes[userData.staticgeom_group]-&gt;addChild(newNode);
-        }
-
-
-        // Einzelne weitere childs auslesen, falls n&#246;tig, in der richtigen Reihenfolge
-
-        // Position des Nodes
-        if (childPosition != NULL)
-            newNode-&gt;setPosition(processPosition(static_cast&lt;DOMElement*&gt;(childPosition)));
-
-        // Rotation des Nodes
-        if (childRotation != NULL)
-            newNode-&gt;setOrientation(processRotation(static_cast&lt;DOMElement*&gt;(childRotation)));
-
-        // Skalierung des Nodes
-        if (childScale != NULL)
-            newNode-&gt;setScale(processScale(static_cast&lt;DOMElement*&gt;(childScale)));
-
-/*      // nun nicht mehr n&#246;tig!
-        {
-            // Skalierung auf alle Entities &#252;bertragen
-            for(unsigned short i = 0; i &lt; newNode-&gt;numAttachedObjects(); i++)
-            {
-                MovableObject* mo = newNode-&gt;getAttachedObject(i);
-                if (mo-&gt;getMovableType().compare(&quot;Entity&quot;) == 0)
-                    static_cast&lt;Entity*&gt;(mo)-&gt;setNormaliseNormals(newNode-&gt;getScale() != Vector3::UNIT_SCALE);
-            }
-        }
-*/
-
-
-
-        // Alle Entities und Subnodes auslesen
-        child = rootNodeXml-&gt;getFirstChild();
-        while(child != NULL)
-        {
-            // geschachteltes weiteres Node
-            if (XMLString::compareIString(child-&gt;getNodeName(),
-                AutoXMLCh(&quot;node&quot;).data()) == 0)
-                processNode(static_cast&lt;DOMElement*&gt;(child), sceneManager, newNode, &amp;userData);
-            // Eine Entity
-            else if (XMLString::compareIString(child-&gt;getNodeName(),
-                     AutoXMLCh(&quot;entity&quot;).data()) == 0)
-                processEntity(static_cast&lt;DOMElement*&gt;(child),
-                                sceneManager,
-                                newNode,
-                                userData.renderingdistance,
-                                userData.physical_body);
-
-            child = child-&gt;getNextSibling();
-        }
-    }
-
-    void DotSceneLoader::processSceneUserData(XERCES_CPP_NAMESPACE::DOMElement* rootUserDataXml)
-    {
-        DOMNode* child = rootUserDataXml-&gt;getFirstChild();
-        LOG_DEBUG(Logger::CORE, &quot; SceneUserData gefunden&quot;);
-        XmlPropertyReader* propertyReader = new XmlPropertyReader();
-
-        // Durch alle Unterelemente iterieren, um die properties zu finden
-        while(child != NULL)
-        {
-            // Ein selbstdefinierter Bereich
-            if (XMLString::compareIString(child-&gt;getNodeName(),
-                AutoXMLCh(&quot;property&quot;).data()) == 0)
-            {
-                DOMElement* propertyXml = static_cast&lt;DOMElement*&gt;(child);
-
-                PropertyEntry entry = propertyReader-&gt;processProperty(propertyXml);
-
-                try
-                {
-                    if (entry.first == &quot;default_renderingdistance&quot;)
-                    {
-                        mRenderingDistance = entry.second.toReal();
-                    }
-                    else if (Ogre::StringUtil::startsWith(entry.first, &quot;staticgeom_renderingdistance_&quot;))
-                    {
-                        int groupId = Ogre::StringConverter::parseInt(entry.first.substr(29));
-                        mStaticgeomRenderingDistances[groupId] = entry.second.toReal();
-                    }
-                    else if (Ogre::StringUtil::startsWith(entry.first, &quot;staticgeom_batchsize_&quot;))
-                    {
-                        int groupId = Ogre::StringConverter::parseInt(entry.first.substr(21));
-                        mStaticgeomBatchSizes[groupId] = entry.second.toReal();
-                    }
-                }
-                catch(...)
-                {
-                    LOG_DEBUG(Logger::CORE,
-                        &quot; &gt; Parse Error beim &#220;bernehmen der Property '&quot;+entry.first+&quot;'!&quot;);
-                }
-
-            }
-            // Manuell definiertes LOD
-            else if (XMLString::compareIString(child-&gt;getNodeName(),
-                AutoXMLCh(&quot;manualLOD&quot;).data()) == 0)
-            {
-                DOMElement* lodXml = static_cast&lt;DOMElement*&gt;(child);
-                string meshName = getAttributeValueAsStdString(lodXml,
-                    &quot;mesh&quot;);
-
-                try
-                {
-                    Ogre::MeshPtr mesh = Ogre::MeshManager::getSingleton().getByName(meshName);
-                    mesh-&gt;removeLodLevels();
-
-                    DOMNode* lodchild = child-&gt;getFirstChild();
-                    LOG_DEBUG(Logger::CORE, &quot; LOD-Bereich f&#252;r &quot;+meshName+&quot; gefunden&quot;);
-                    Ogre::Real loddist = 10.0;
-                    string lodmeshName = &quot;&quot;;
-
-                    // Durch alle Unterelemente iterieren, um die LODs zu finden
-                    while(lodchild != NULL)
-                    {
-                        if (XMLString::compareIString(lodchild-&gt;getNodeName(),
-                            AutoXMLCh(&quot;LOD&quot;).data()) == 0)
-                        {
-                            loddist = 0.0;
-                            lodmeshName = &quot;&quot;;
-
-                            try
-                            {
-                                lodXml = static_cast&lt;DOMElement*&gt;(lodchild);
-                                loddist = getAttributeValueAsReal(lodXml,
-                                    &quot;distance&quot;);
-                                lodmeshName = getAttributeValueAsStdString(lodXml,
-                                    &quot;mesh&quot;);
-
-                                if (lodmeshName.length() &gt; 0 &amp;&amp; loddist &gt; 0)
-                                {
-                                    mesh-&gt;createManualLodLevel(loddist, lodmeshName);
-                                    LOG_DEBUG(Logger::CORE,
-                                        &quot; LOD f&#252;r bei '&quot;+Ogre::StringConverter::toString(loddist)+
-                                        &quot;' als '&quot;+lodmeshName+&quot;' gesetzt!&quot;);
-                                }
-                            }
-                            catch(...) { }
-                        }
-
-                        lodchild = lodchild-&gt;getNextSibling();
-                    }
-                }
-                catch(...)
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        &quot; &gt; Parse Error beim Setzen der LOD f&#252;r '&quot;+meshName+&quot;'!&quot;);
-                }
-            }
-            child = child-&gt;getNextSibling();
-        }
-
-        delete propertyReader;
-    }
-
-    void DotSceneLoader::processNodeUserData(XERCES_CPP_NAMESPACE::DOMElement* rootUserDataXml,
-        NodeUserData* userData)
-    {
-        DOMNode* child = rootUserDataXml-&gt;getFirstChild();
-        LOG_DEBUG(Logger::CORE, &quot; NodeUserData gefunden&quot;);
-
-        // Durch alle Unterelemente iterieren, um die properties zu finden
-        while(child != NULL)
-        {
-            // Ein selbstdefinierter Bereich
-            if (XMLString::compareIString(child-&gt;getNodeName(),
-                AutoXMLCh(&quot;property&quot;).data()) == 0)
-            {
-                DOMElement* propertyXml = static_cast&lt;DOMElement*&gt;(child);
-                PropertyEntry entry = processProperty(propertyXml);
-
-                try
-                {
-                    if (entry.first == &quot;physical_body&quot;)
-                        userData-&gt;physical_body = entry.second.toString().c_str();
-                    else if (entry.first == &quot;dynamic&quot;)
-                        userData-&gt;is_dynamic = entry.second.toInt() != 0;
-                    else if (entry.first == &quot;staticgeom_group&quot;)
-                        userData-&gt;staticgeom_group = entry.second.toInt();
-                    else if (entry.first == &quot;renderingdistance&quot;)
-                        userData-&gt;renderingdistance = entry.second.toReal();
-                }
-                catch(...)
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        &quot; &gt; Parse Error beim &#220;bernehmen der Property '&quot;+entry.first+&quot;'!&quot;);
-                }
-
-            }
-            else if (XMLString::compareIString(child-&gt;getNodeName(),
-                        AutoXMLCh(&quot;collisions&quot;).data()) == 0)
-                    processCollisions(static_cast&lt;DOMElement*&gt; (child));
-
-
-            child = child-&gt;getNextSibling();
-        }
-    }
-
-    // eine benutzerdefinierte Collision
-    void DotSceneLoader::processCollisions(XERCES_CPP_NAMESPACE::DOMElement *rootCollisionXml)
-    {
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-        OgreNewt::CollisionPtr collision;
-#else
-        OgreNewt::CollisionPtr collision = NULL;
-#endif
-        DOMNode* child = rootCollisionXml-&gt;getFirstChild();
-        OgreNewt::World *thisWorld = PhysicsManager::getSingleton()._getNewtonWorld();
-
-        std::vector&lt;Ogre::Vector3&gt; vec3Vector;
-        Ogre::Vector3 scale, offset;
-        Ogre::Quaternion rotation;
-
-
-        LOG_DEBUG(Logger::CORE, &quot; collisions in NodeUserData gefunden&quot;);
-
-
-        while(child != NULL)
-        {
-            if (child-&gt;getNodeType() != DOMNode::ELEMENT_NODE)
-            {
-                child = child-&gt;getNextSibling();
-                continue;
-            }
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            collision.reset();
-#else
-            collision = NULL;
-#endif
-            // am Anfang steht ein Node mit dem Typ
-            std::string typeAsString = transcodeToStdString(child-&gt;getNodeName());
-
-            scale = Ogre::Vector3::UNIT_SCALE;
-            offset = Ogre::Vector3::ZERO;
-            rotation = Ogre::Quaternion::IDENTITY;
-            vec3Vector.clear();
-
-            DOMNode *childChild = static_cast&lt;DOMElement*&gt;(child)-&gt;getFirstChild();
-            while(childChild != NULL)
-            {
-                if (childChild-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-                {
-                    if (XMLString::compareIString(childChild-&gt;getNodeName(),
-                        AutoXMLCh(&quot;scale&quot;).data()) == 0)
-                        scale = processScale(static_cast&lt;DOMElement*&gt;(childChild));
-                    else if (XMLString::compareIString(childChild-&gt;getNodeName(),
-                             AutoXMLCh(&quot;offset&quot;).data()) == 0)
-                        offset = processPosition(static_cast&lt;DOMElement*&gt;(childChild));
-                    else if (XMLString::compareIString(childChild-&gt;getNodeName(),
-                             AutoXMLCh(&quot;rotation&quot;).data()) == 0)
-                        rotation = processRotation(static_cast&lt;DOMElement*&gt;(childChild));
-
-                    else if (XMLString::compareIString(childChild-&gt;getNodeName(),
-                             AutoXMLCh(&quot;vertices&quot;).data()) == 0)
-                    {
-                        DOMNode *childChildChild = static_cast&lt;DOMElement*&gt;(childChild)-&gt;getFirstChild();
-                        while(childChildChild != NULL)
-                        {
-                            if (childChild-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-                            {
-                                if (XMLString::compareIString(childChildChild-&gt;getNodeName(),
-                                    AutoXMLCh(&quot;vertex&quot;).data()) == 0)
-                                {
-                                    bool error = false;
-                                    Ogre::Vector3 vec3 = processVector(static_cast&lt;DOMElement*&gt;(childChildChild), error);
-                                    if (!error)
-                                        vec3Vector.push_back(vec3);
-                                }
-                            }
-                            childChildChild = childChildChild-&gt;getNextSibling();
-                        }
-                    }
-                }
-                childChild = childChild-&gt;getNextSibling();
-            }
-
-            // typangabe aus String extrahieren
-            if (typeAsString == &quot;convexhull&quot;)
-            {
-                int vertcount = vec3Vector.size();
-                Ogre::Vector3 *vertices = new Ogre::Vector3[ vertcount ];
-                Ogre::Vector3 vec3Min(0,0,0), vec3Max(0,0,0);
-                for(int i = 0; i &lt; vertcount; i++)
-                {
-                    vertices[i] = vec3Vector[i] * scale; // in array &#252;bertragen
-
-
-                    if (vertices[i].x &lt; vec3Min.x)   // und gr&#246;&#223;e des k&#246;rpers bestimmen
-                        vec3Min.x = vertices[i].x;
-                    if (vertices[i].y &lt; vec3Min.y)
-                        vec3Min.y = vertices[i].y;
-                    if (vertices[i].z &lt; vec3Min.z)
-                        vec3Min.z = vertices[i].z;
-
-                    if (vertices[i].x &gt; vec3Max.x)
-                        vec3Max.x = vertices[i].x;
-                    if (vertices[i].y &gt; vec3Max.y)
-                        vec3Max.y = vertices[i].y;
-                    if (vertices[i].z &gt; vec3Max.z)
-                        vec3Max.z = vertices[i].z;
-                }
-
-                Ogre::Vector3 size = vec3Max - vec3Min;
-                // Gr&#246;&#223;e &#252;berpr&#252;fen
-                if (size.x &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
-                    size.y &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
-                    size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
-                    vertcount &lt; 4)
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        &quot; physical_body 'convexhull' in &lt;collisions&gt; konnte nicht erstellt werden; der K&#246;rper ist zu klein!&quot;);
-
-                    // Minimale Gr&#246;&#223;e verwenden
-                    if (size.x &lt; PhysicsManager::NEWTON_GRID_WIDTH)
-                        size.x = PhysicsManager::NEWTON_GRID_WIDTH;
-                    if (size.y &lt; PhysicsManager::NEWTON_GRID_WIDTH)
-                        size.y = PhysicsManager::NEWTON_GRID_WIDTH;
-                    if (size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH)
-                        size.z = PhysicsManager::NEWTON_GRID_WIDTH;
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
-                                     thisWorld, size, rotation, offset));
-
-                    LOG_MESSAGE(Logger::CORE, &quot; stattdessen physical_body 'box' erstellt. &quot;);
-                }
-                else
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
-                                    thisWorld,
-                                    vertices,
-                                    vertcount,
-                                    rotation, offset));
-
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'convexhull' in &lt;collisions&gt; erstellt. &quot;);
-                }
-
-                delete [] vertices;
-            }
-            else
-            {
-                if (!vec3Vector.empty())   // fehler!
-                {
-                    LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim Einlesen einer Collision; Es k&#246;nne nur f&#252;r Convexhull Vektoren definiert werden!&quot;);
-                }
-
-                if (typeAsString.compare(&quot;box&quot;) == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
-                                    thisWorld, scale, rotation, offset));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'box' in &lt;collisions&gt; erstellt. &quot;);
-                }
-                else if (typeAsString.compare(&quot;sphere&quot;) == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-                                    thisWorld, scale, rotation, offset));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'sphere' in &lt;collisions&gt; erstellt. &quot;);
-                }
-                else if (typeAsString.compare(&quot;ellipsoid&quot;) == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-                    thisWorld, scale, rotation, offset));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'ellipsoid' in &lt;collisions&gt; erstellt. &quot;);
-                }
-                else if (typeAsString.compare(&quot;pyramid&quot;) == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Pyramid(
-                    thisWorld, scale, rotation, offset));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'pyramid' in &lt;collisions&gt; erstellt. &quot;);
-                }
-                else if (typeAsString.compare(&quot;capsule&quot;) == 0)
-                {
-                    double radius = std::max(scale.x, scale.z) / 2.0;
-                    double height = scale.y;
-                    offset.x -= scale.y/2;
-                    Ogre::Quaternion tempRot;
-                    tempRot.FromAngleAxis(Degree(90), Ogre::Vector3::UNIT_Z);
-                    rotation = (rotation * tempRot);
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Capsule(
-                                    thisWorld,
-                                    radius,
-                                    height,
-                                    rotation, offset));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'capsule' in &lt;collisions&gt; erstellt. &quot;);
-                }
-                else if (typeAsString.compare(&quot;cone&quot;) == 0)
-                {
-                    double radius = std::max(scale.x, scale.z) / 2.0;
-                    double height = scale.y;
-                    offset.x -= scale.y/2;
-                    Ogre::Quaternion tempRot;
-                    tempRot.FromAngleAxis(Degree(90), Ogre::Vector3::UNIT_Z);
-                    rotation = (rotation * tempRot);
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Cone(
-                                    thisWorld,
-                                    radius,
-                                    height,
-                                    rotation, offset));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'cone' in &lt;collisions&gt; erstellt. &quot;);
-                }
-                else if (typeAsString.compare(&quot;cylinder&quot;) == 0)
-                {
-                    double radius = std::max(scale.x, scale.z) / 2.0;
-                    double height = scale.y;
-                    offset.x -= scale.y/2;
-                    Ogre::Quaternion tempRot;
-                    tempRot.FromAngleAxis(Degree(90), Ogre::Vector3::UNIT_Z);
-                    rotation = (rotation * tempRot);
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder(
-                                    thisWorld,
-                                    radius,
-                                    height,
-                                    rotation, offset));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'cylinder' in &lt;collisions&gt; erstellt. &quot;);
-                }
-                else if (typeAsString.compare(&quot;chamfer_cylinder&quot;) == 0)
-                {
-                    double radius = std::max(scale.x, scale.z) / 2.0;
-                    double height = scale.y;
-                    offset.x -= scale.y/2;
-                    Ogre::Quaternion tempRot;
-                    tempRot.FromAngleAxis(Degree(90), Ogre::Vector3::UNIT_Z);
-                    rotation = (rotation * tempRot);
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ChamferCylinder(
-                                    thisWorld,
-                                    radius,
-                                    height,
-                                    rotation, offset));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'chamfer_cylinder' in &lt;collisions&gt; erstellt. &quot;);
-                }
-                else if (typeAsString.compare(&quot;mesh&quot;) == 0)
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        &quot; Mesh-Collisions in &lt;collisions&gt; werden momentan noch nicht unterst&#252;tzt (Eintrag wird ignoriert).&quot;);
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-                    collision.reset();
-#else
-                    collision = NULL;
-#endif
-                }
-/*
-                else if (typeAsString.compare(&quot;meshhull&quot;) == 0)  // automatische convexhull mit daten aus mesh
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        &quot; Entityhull-Collisions werden momentan noch nicht unterst&#252;tzt (Eintrag wird ignoriert).&quot;);
-                    collision = NULL;
-                }
-*/
-                else
-                {
-                    LOG_MESSAGE(Logger::CORE,
-                        &quot; &gt; Parse Error beim Erstellen einer Collision; ung&#252;ltiger typ: '&quot;+typeAsString+&quot;' !&quot;);
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-                    collision.reset();
-#else
-                    collision = NULL;
-#endif
-                }
-
-            }
-
-
-            // Collision dem vektor hinzuf&#252;gen
-            if ( !collision )
-                mCollisions.push_back(collision);
-
-            child = child-&gt;getNextSibling();
-        }
-    }
-
-    // Eine Entity
-    void DotSceneLoader::processEntity(DOMElement* rootEntityXml,
-        SceneManager* sceneManager, Ogre::SceneNode* parentNode,
-        Ogre::Real renderingDistance, const std::string &amp;physical_body)
-    {
-        string entName = getAttributeValueAsStdString(
-            rootEntityXml, &quot;name&quot;);
-        string meshName = getAttributeValueAsStdString(
-            rootEntityXml, &quot;meshFile&quot;);
-
-        Ogre::Entity* newEnt = NULL;
-
-        // Wurde der Entity bisher kein Name zugewiesen
-        if (entName.length() == 0)
-        {
-            entName = getRandomName(mSceneName+&quot;_&quot;+parentNode-&gt;getName());
-        }
-
-        ResourceGroupManager&amp; resGroupMgr = ResourceGroupManager::getSingleton();
-        while(parentNode-&gt;getCreator()-&gt;hasEntity(entName))
-        {
-            entName = getRandomName(entName);
-        }
-
-        try
-        {
-            // if this mesh exists in our module's resource group: preload it
-            if (resGroupMgr.resourceExists(mResourceGroup, meshName))
-            {
-                MeshManager::getSingleton().load(meshName, mResourceGroup);
-            }
-
-            // If not, it is now loaded implicitly from the default group
-            newEnt = sceneManager-&gt;createEntity(entName, meshName);
-        }
-        catch(...)
-        {
-              LOG_ERROR(Logger::CORE, &quot; Entity '&quot;+meshName+&quot;' mit dem Namen '&quot;+entName+&quot;' konnte nicht geladen werden.&quot;);
-              return;
-        }
-
-        /*if (parentNode-&gt;getScale() != Vector3::UNIT_SCALE) 
-		{
-            newEnt-&gt;setNormaliseNormals(true);
-		}*/
-
-        parentNode-&gt;attachObject(newEnt);
-
-        LOG_DEBUG(Logger::CORE, &quot; Entity '&quot;+meshName+&quot;' mit dem Namen '&quot;+entName+&quot;' in den Knoten '&quot;+parentNode-&gt;getName()+&quot;' eingef&#252;gt.&quot;);
-
-
-        // ------- Falls n&#246;tig automatisch bodyproxy erstellen -------------
-        // (wenn physical_body gesetzt wurde)
-        OgreNewt::CollisionPtr collision = OgreNewt::CollisionPtr();
-        OgreNewt::World *thisWorld = PhysicsManager::getSingleton()._getNewtonWorld();
-
-        if (physical_body.compare(&quot;none&quot;) != 0)
-        {
-            const AxisAlignedBox &amp;aab = newEnt-&gt;getMesh()-&gt;getBounds();
-            Ogre::Vector3 size = (aab.getMaximum() - aab.getMinimum()) * parentNode-&gt;getScale();
-            bool forceBox = false;
-
-            if ((size.x &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
-                 size.y &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
-                 size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH) &amp;&amp;
-                 physical_body.compare(&quot;convexhull&quot;) == 0)
-            {
-                if (size.x &lt; PhysicsManager::NEWTON_GRID_WIDTH)
-                    size.x = PhysicsManager::NEWTON_GRID_WIDTH;
-                if (size.y &lt; PhysicsManager::NEWTON_GRID_WIDTH)
-                    size.y = PhysicsManager::NEWTON_GRID_WIDTH;
-                if (size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH)
-                    size.z = PhysicsManager::NEWTON_GRID_WIDTH;
-
-                LOG_MESSAGE(Logger::CORE, &quot; Die Entity '&quot;+entName+&quot;' liegt in einer Ebene, verwende 'box' f&#252;r physical_body '&quot;+physical_body+&quot;' &quot;);
-                forceBox = true;
-            }
-            const Quaternion orientation(0,0,0,0);// = parentNode-&gt;getOrientation();
-            const Ogre::Vector3 pos = aab.getMinimum()* parentNode-&gt;getScale() + (size/2.0);
-
-
-            // Pr&#252;fen, ob schon ein identischer Proxy erstellt wurde um diesen erneut zu verwenden
-            AlreadyUsedCollision &amp;aucol (mAutoCreatedCollisions[meshName]);
-            if (aucol.Type.compare(physical_body) == 0  &amp;&amp;
-                aucol.Scale == parentNode-&gt;getScale() &amp;&amp;
-                (!forceBox)) // sicherheitshalber
-            {
-                collision = aucol.ColPtr;
-                LOG_DEBUG(Logger::CORE, &quot; Schon fr&#252;her erstellten physical_body f&#252;r Entity '&quot;+entName+&quot;' wieder verwendet. &quot;);
-            }
-            else
-            {
-
-                if (physical_body.compare(&quot;box&quot;) == 0 || forceBox)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
-                                     thisWorld, size, orientation, pos));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'box' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
-                }
-                else if (physical_body.compare(&quot;pyramid&quot;) == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Pyramid(
-                                    thisWorld, size, orientation, pos));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'pyramid' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
-                }
-                else if (physical_body.compare(&quot;sphere&quot;) == 0)
-                {
-                    double radius = std::max(size.x, std::max(size.y, size.z)) / 2.0;
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-                                    thisWorld, Vector3(radius, radius, radius),
-                                    orientation, pos));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'sphere' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
-                }
-                else if (physical_body.compare(&quot;ellipsoid&quot;) == 0)
-                {
-                    // set the size x/z values to the maximum
-                    Ogre::Vector3 s(size/2.0);
-                    s.x = std::max(s.x, s.z);
-                    s.z = s.x;
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-                                    thisWorld, s,
-                                    orientation, pos));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'ellipsoid' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
-                }
-                else if (physical_body.compare(&quot;capsule&quot;) == 0)
-                {
-                    double radius = std::max(size.x, size.z) / 2.0;
-                    double height = size.y;
-
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Capsule(
-                                    thisWorld,
-                                    radius,
-                                    height,
-                                    orientation, pos));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'capsule' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
-                }
-                else if (physical_body.compare(&quot;convexhull&quot;) == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
-                                    thisWorld,
-                                    newEnt));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'convexhull' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
-                }
-                else if (physical_body.compare(&quot;mesh&quot;) == 0 || physical_body.compare(&quot;auto&quot;) == 0)
-                {
-                    collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
-                                    thisWorld, newEnt, true));
-                    LOG_DEBUG(Logger::CORE, &quot; physical_body 'mesh' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
-                }
-                else
-                    LOG_MESSAGE(Logger::CORE,
-                        &quot; Der bodyproxy_type '&quot;+physical_body+&quot;'(aus userData) der Entity '&quot;+meshName+&quot;' ist ung&#252;ltig.&quot;);
-
-                // proxy in die liste der schon erstellten proxies hinzuf&#252;gen
-                aucol.ColPtr = collision;
-                aucol.Scale = parentNode-&gt;getScale();
-                aucol.Type = physical_body;
-            }
-        }
-
-        // zur liste hinzuf&#252;gen
-        if (collision != NULL)
-        {
-            mCollisions.push_back(collision);
-        }
-
-
-        // Zur Physik des Levels hinzuf&#252;gen
-        if (mCollisions.size() &gt; 0)
-        {
-            PhysicsManager::getSingleton().addLevelGeometry(newEnt, mCollisions);
-            LOG_DEBUG(Logger::CORE, &quot; Entity '&quot;+entName+&quot;' in levelGeometry geladen&quot;);
-        }
-
-
-        // wieder aus der liste entfernen, falls mehrere entities hier definiert werden
-        if (collision != NULL)
-        {
-            mCollisions.pop_back();
-        }
-
-        // Renderingdistanz berechnen
-        if (renderingDistance == mRenderingDistance)
-        {
-            Ogre::Real diameter
-                = (newEnt-&gt;getBoundingBox().getMaximum() - newEnt-&gt;getBoundingBox().getMinimum()).length();
-
-            // Gerade mal 10cm&#178; =&gt; 10m
-            if (diameter &lt;= 0.5)
-                renderingDistance = 15;
-            // Gerade mal 1,5m&#178; =&gt; 25m
-            else if (diameter &lt;= 1.5)
-                renderingDistance = 30;
-            // Gerade mal 2,5m&#178; =&gt; 50m
-            else if (diameter &lt;= 2.5)
-                renderingDistance = 60;
-            else if (diameter &lt;= 10)
-                renderingDistance = 150;
-            else if (diameter &lt;= 50)
-                renderingDistance = 250;
-            else if (diameter &lt;= 100)
-                renderingDistance = 450;
-            else
-                renderingDistance = 1500;
-
-            newEnt-&gt;setRenderingDistance(renderingDistance);
-        }
-        else
-            newEnt-&gt;setRenderingDistance(renderingDistance);
-        newEnt-&gt;setCastShadows(false);
-    }
-
-    string DotSceneLoader::getRandomName(const string&amp; baseName)
-    {
-        int rnd = rand();
-        stringstream rval;
-        rval &lt;&lt; baseName &lt;&lt; &quot;_&quot; &lt;&lt; rnd;
-        return rval.str();
-    }
-
-    Ogre::Vector3 DotSceneLoader::processPosition(DOMElement* rootPositionXml)
-    {
-        LOG_DEBUG(Logger::CORE, &quot; Position gefunden&quot;);
-
-        try
-        {
-            if (hasAttribute(rootPositionXml, &quot;x&quot;) &amp;&amp;
-                hasAttribute(rootPositionXml, &quot;y&quot;) &amp;&amp;
-                hasAttribute(rootPositionXml, &quot;z&quot;))
-            {
-                return Ogre::Vector3(
-                    getAttributeValueAsReal(rootPositionXml, &quot;x&quot;),
-                    getAttributeValueAsReal(rootPositionXml, &quot;y&quot;),
-                    getAttributeValueAsReal(rootPositionXml, &quot;z&quot;));
-            }
-        }
-        catch(...) { }
-
-        LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim &#220;bernehmen der Position! &quot;);
-
-        return Ogre::Vector3::ZERO;
-    }
-
-
-    Ogre::Vector3 DotSceneLoader::processScale(DOMElement* rootScaleXml)
-    {
-        LOG_DEBUG(Logger::CORE, &quot; Skalierung gefunden&quot;);
-
-        try
-        {
-            if (hasAttribute(rootScaleXml, &quot;x&quot;) &amp;&amp;
-                hasAttribute(rootScaleXml, &quot;y&quot;) &amp;&amp;
-                hasAttribute(rootScaleXml, &quot;z&quot;))
-            {
-                return Ogre::Vector3(
-                    getAttributeValueAsReal(rootScaleXml, &quot;x&quot;),
-                    getAttributeValueAsReal(rootScaleXml, &quot;y&quot;),
-                    getAttributeValueAsReal(rootScaleXml, &quot;z&quot;));
-            }
-        }
-        catch(...) { }
-
-        LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim &#220;bernehmen der Skalierung! &quot;);
-
-        return Ogre::Vector3::UNIT_SCALE;
-    }
-
-    Ogre::Vector3 DotSceneLoader::processVector(DOMElement* rootScaleXml, bool &amp;error)
-    {
-        LOG_DEBUG(Logger::CORE, &quot; Vector gefunden&quot;);
-
-        try
-        {
-            if (hasAttribute(rootScaleXml, &quot;x&quot;) &amp;&amp;
-                hasAttribute(rootScaleXml, &quot;y&quot;) &amp;&amp;
-                hasAttribute(rootScaleXml, &quot;z&quot;))
-            {
-                error = false;
-                return Ogre::Vector3(
-                    getAttributeValueAsReal(rootScaleXml, &quot;x&quot;),
-                    getAttributeValueAsReal(rootScaleXml, &quot;y&quot;),
-                    getAttributeValueAsReal(rootScaleXml, &quot;z&quot;));
-            }
-        }
-        catch(...) { }
-
-        LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim Lesen eines Vectors! &quot;);
-        error = true;
-
-        return Ogre::Vector3::UNIT_SCALE;
-    }
-
-    /// @TODO Sollten drei M&#246;glichkeiten sein...
-    Ogre::Quaternion DotSceneLoader::processRotation(DOMElement* rootQuatXml)
-    {
-        LOG_DEBUG(Logger::CORE, &quot; Rotation gefunden&quot;);
-
-        try
-        {
-            // Durch w,x,y,z definiert
-            if (hasAttribute(rootQuatXml, &quot;qw&quot;) &amp;&amp;
-                hasAttribute(rootQuatXml, &quot;qx&quot;) &amp;&amp;
-                hasAttribute(rootQuatXml, &quot;qy&quot;) &amp;&amp;
-                hasAttribute(rootQuatXml, &quot;qz&quot;))
-            {
-
-                return Ogre::Quaternion(
-                    getAttributeValueAsReal(rootQuatXml, &quot;qw&quot;),
-                    getAttributeValueAsReal(rootQuatXml, &quot;qx&quot;),
-                    getAttributeValueAsReal(rootQuatXml, &quot;qy&quot;),
-                    getAttributeValueAsReal(rootQuatXml, &quot;qz&quot;));
-            }
-
-            // Durch axisX,axisY,axisZ,angle definiert
-            if (hasAttribute(rootQuatXml, &quot;angle&quot;) &amp;&amp;
-                hasAttribute(rootQuatXml, &quot;axisX&quot;) &amp;&amp;
-                hasAttribute(rootQuatXml, &quot;axisY&quot;) &amp;&amp;
-                hasAttribute(rootQuatXml, &quot;axisZ&quot;))
-            {
-                return Ogre::Quaternion(
-                    Ogre::Degree(getAttributeValueAsReal(rootQuatXml, &quot;angle&quot;)),
-                    Ogre::Vector3(
-                    getAttributeValueAsReal(rootQuatXml, &quot;axisX&quot;),
-                    getAttributeValueAsReal(rootQuatXml, &quot;axisY&quot;),
-                    getAttributeValueAsReal(rootQuatXml, &quot;axisZ&quot;)));
-            }
-
-            // Durch angleX,angleY,angleZ definiert
-            if (hasAttribute(rootQuatXml, &quot;angleX&quot;) &amp;&amp;
-                hasAttribute(rootQuatXml, &quot;angleY&quot;) &amp;&amp;
-                hasAttribute(rootQuatXml, &quot;angleZ&quot;) )
-            {
-                Ogre::Matrix3 mat;
-                mat.FromEulerAnglesXYZ(
-                    Degree(getAttributeValueAsReal(rootQuatXml, &quot;angleX&quot;)),
-                    Degree(getAttributeValueAsReal(rootQuatXml, &quot;angleY&quot;)),
-                    Degree(getAttributeValueAsReal(rootQuatXml, &quot;angleZ&quot;)));
-                return Quaternion(mat);
-            }
-        }
-        catch(...) {}
-
-        LOG_MESSAGE(Logger::CORE, &quot; &gt; Parse Error beim &#220;bernehmen der Rotation! &quot;);
-
-        return Ogre::Quaternion::IDENTITY;
-    }
-}
-

Deleted: rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -1,160 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#include &quot;stdinc.h&quot; //precompiled header
-
-// Xerces geht vor allen Ogre includes...
-#include &quot;XmlResourceManager.h&quot;
-
-#include &quot;DotSceneOctreeWorld.h&quot;
-
-
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;ConfigurationManager.h&quot;
-#include &quot;ActorManager.h&quot;
-#include &quot;Actor.h&quot;
-#include &quot;PhysicsManager.h&quot;
-#include &quot;DotSceneLoader.h&quot;
-#include &quot;ZoneManager.h&quot;
-
-using namespace Ogre;
-
-namespace rl {
-
-    DotSceneOctreeWorld::DotSceneOctreeWorld( )
-        :   World(ST_GENERIC)
-    {
-        mSceneFile = &quot;&quot;;
-    }
-
-    DotSceneOctreeWorld::~DotSceneOctreeWorld()
-    {
-        clearScene();
-    }
-
-    void DotSceneOctreeWorld::initializeDefaultCamera(void)
-    {
-        if (mCamera == 0)
-        {
-            // Kamera erstellen..
-            Actor* actor = ActorManager::getSingleton().createCameraActor(&quot;DefaultCamera&quot;);
-            // und initialisieren.
-            mCamera = mSceneMgr-&gt;getCamera(&quot;DefaultCamera&quot;);
-
-            mCamera-&gt;setPosition( getStartPoint() );
-            mCamera-&gt;setFOVy(Degree(60));
-            mCamera-&gt;setFixedYawAxis(true);
-            mCamera-&gt;setAutoAspectRatio(true);
-
-            actor-&gt;placeIntoScene();
-
-			// Ein Viewport, das komplette Fenster
-			Viewport* newVp = CoreSubsystem::getSingleton().getRenderWindow()-&gt;addViewport(mCamera, 1);
-
-			// Schwarzer Hintergrund
-			newVp-&gt;setBackgroundColour(ColourValue(0,0,0));
-
-		}
-    }
-
-    void DotSceneOctreeWorld::loadScene(const Ogre::String&amp; levelName, const Ogre::String&amp; module)
-    {
-        // Alte Szene l&#246;schen
-        clearScene();
-
-		setCastShadows( true );
-
-        // Leerer Ogre::String, keine Map laden
-        if (levelName.length() != 0)
-        {
-            /// TODO - In den Sky-Sonnenpart verschieben
-            mSceneMgr-&gt;setAmbientLight(ColourValue(0.55, 0.55, 0.55));
-            mSceneFile = levelName;
-
-            DotSceneLoader* dot = NULL;
-            try
-            {
-                dot = new DotSceneLoader( mSceneFile, module );
-                dot-&gt;initializeScene( mSceneMgr );
-                delete dot;
-            }
-            catch( ... )
-            {
-                LOG_CRITICAL(Logger::CORE,
-                    &quot;Laden der Szenenbeschreibung aus '&quot; + mSceneFile + &quot;' ist fehlgeschlagen.&quot; );
-                delete dot;
-            }
-        }
-        else
-        {
-            mSceneFile = &quot;&quot;;
-        }
-
-        initializeDefaultCamera();
-        fireAfterSceneLoaded();
-    }
-
-    void DotSceneOctreeWorld::clearScene()
-    {
-        fireBeforeClearScene();
-
-        // This is necessary to destroy cameras too.
-        CoreSubsystem::getSingleton().getRenderWindow()-&gt;removeAllViewports();
-        ZoneManager::getSingleton().destroyAllZones();
-        ActorManager::getSingleton().destroyAllActors();
-        mSceneMgr-&gt;clearScene();
-        PhysicsManager::getSingleton().clearLevelGeometry();
-
-        mSceneFile = &quot;&quot;;
-        mCamera = NULL;
-    }
-
-    void DotSceneOctreeWorld::setCastShadows(bool enabled)
-    {
-		bool castShadows = false;
-
-		if( enabled )
-		{
-			Ogre::String tmp =
-				ConfigurationManager::getSingleton().getStringSetting(
-					&quot;Video&quot;, &quot;Cast Shadows&quot; );
-
-			if (tmp == &quot;yes&quot;)
-				castShadows = true;
-			else if (tmp == &quot;no&quot;)
-				castShadows = false;
-		}
-
-		/// @todo Settings for multiple Shadow-Types?
-		if( castShadows )
-		{
-			int textureSize =
-				ConfigurationManager::getSingleton().getIntSetting(
-					&quot;Video&quot;, &quot;Shadow Texture Size&quot; );
-			textureSize = std::max( 64, std::min( 4096, textureSize ) );
-
-			mSceneMgr-&gt;setShadowTechnique(SHADOWTYPE_TEXTURE_MODULATIVE);
-			mSceneMgr-&gt;setShadowTextureSize( textureSize );
-			mSceneMgr-&gt;setShadowColour(ColourValue(0.7, 0.7, 0.7));
-			mSceneMgr-&gt;setShadowFarDistance(8.0f);
-			mSceneMgr-&gt;setShadowDirLightTextureOffset(0.8f);
-            mSceneMgr-&gt;setShadowCameraSetup((Ogre::ShadowCameraSetupPtr) new Ogre::LiSPSMShadowCameraSetup());
-		}
-		else
-		{
-			mSceneMgr-&gt;setShadowTechnique( SHADOWTYPE_NONE);
-		}
-    }
-}

Modified: rl/trunk/engine/core/src/GameAreaTypes.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaTypes.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/src/GameAreaTypes.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -237,8 +237,8 @@
             geomType = GT_CONVEXHULL;
         }
         OgreNewt::CollisionPtr col =
-            PhysicsManager::getSingleton().getCollisionFactory()-&gt;createCollisionFromEntity(entity,
-            geomType, &amp;offset, &amp;orientation);
+            PhysicsManager::getSingleton().createCollision(entity,
+            geomType, &quot;&quot;, &amp;offset, &amp;orientation);
         mBody = new OgreNewt::Body(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             col);
@@ -262,8 +262,8 @@
             Ogre::Quaternion orientation)
     {
         OgreNewt::CollisionPtr col =
-            PhysicsManager::getSingleton().getCollisionFactory()-&gt;createCollisionFromAABB(
-            aabb, geomType, &amp;offset, &amp;orientation);
+            PhysicsManager::getSingleton().createCollision(
+            &quot;&quot;, aabb, geomType, &amp;offset, &amp;orientation, 0, NULL, NULL, true);
         mBody = new OgreNewt::Body(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             col);

Modified: rl/trunk/engine/core/src/GameEventManager.cpp
===================================================================
--- rl/trunk/engine/core/src/GameEventManager.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/src/GameEventManager.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -309,7 +309,10 @@
     Actor* GameEventManager::bodyToActor(OgreNewt::Body* body)
     {
 #ifdef OGRENEWT_USE_OGRE_ANY
-        return Ogre::any_cast&lt;Actor*&gt;(body-&gt;getUserData());
+        if( body-&gt;getUserData().getType() == typeid(Actor*) )
+            return Ogre::any_cast&lt;Actor*&gt;(body-&gt;getUserData());
+        else
+            return NULL;
 #else
         return static_cast&lt;Actor*&gt;(body-&gt;getUserData());
 #endif

Copied: rl/trunk/engine/core/src/GenericWorld.cpp (from rev 4889, rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp)
===================================================================
--- rl/trunk/engine/core/src/DotSceneOctreeWorld.cpp	2009-04-07 22:24:33 UTC (rev 4889)
+++ rl/trunk/engine/core/src/GenericWorld.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -0,0 +1,122 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+// Xerces geht vor allen Ogre includes...
+#include &quot;XmlResourceManager.h&quot;
+
+#include &quot;GenericWorld.h&quot;
+
+
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;ConfigurationManager.h&quot;
+#include &quot;ActorManager.h&quot;
+#include &quot;Actor.h&quot;
+#include &quot;PhysicsManager.h&quot;
+#include &quot;ZoneManager.h&quot;
+
+using namespace Ogre;
+
+namespace rl {
+
+    GenericWorld::GenericWorld( )
+        :   World(ST_GENERIC)
+    {
+        mSceneFile = &quot;&quot;;
+    }
+
+    GenericWorld::~GenericWorld()
+    {
+        clearScene();
+    }
+
+    void GenericWorld::initializeDefaultCamera(void)
+    {
+        if (mCamera == 0)
+        {
+            // Kamera erstellen..
+            Actor* actor = ActorManager::getSingleton().createCameraActor(&quot;DefaultCamera&quot;);
+            // und initialisieren.
+            mCamera = mSceneMgr-&gt;getCamera(&quot;DefaultCamera&quot;);
+
+            mCamera-&gt;setPosition( getStartPoint() );
+            mCamera-&gt;setFOVy(Degree(60));
+            mCamera-&gt;setFixedYawAxis(true);
+            mCamera-&gt;setAutoAspectRatio(true);
+
+            actor-&gt;placeIntoScene();
+
+			// Ein Viewport, das komplette Fenster
+			Viewport* newVp = CoreSubsystem::getSingleton().getRenderWindow()-&gt;addViewport(mCamera, 1);
+
+			// Schwarzer Hintergrund
+			newVp-&gt;setBackgroundColour(ColourValue(0,0,0));
+
+		}
+    }
+
+    void GenericWorld::clearScene()
+    {
+        fireBeforeClearScene();
+
+        // This is necessary to destroy cameras too.
+        CoreSubsystem::getSingleton().getRenderWindow()-&gt;removeAllViewports();
+        ZoneManager::getSingleton().destroyAllZones();
+        ActorManager::getSingleton().destroyAllActors();
+        mSceneMgr-&gt;clearScene();
+        PhysicsManager::getSingleton().clearLevelGeometry();
+
+        mSceneFile = &quot;&quot;;
+        mCamera = NULL;
+    }
+
+    void GenericWorld::setCastShadows(bool enabled)
+    {
+		bool castShadows = false;
+
+		if( enabled )
+		{
+			Ogre::String tmp =
+				ConfigurationManager::getSingleton().getStringSetting(
+					&quot;Video&quot;, &quot;Cast Shadows&quot; );
+
+			if (tmp == &quot;yes&quot;)
+				castShadows = true;
+			else if (tmp == &quot;no&quot;)
+				castShadows = false;
+		}
+
+		/// @todo Settings for multiple Shadow-Types?
+		if( castShadows )
+		{
+			int textureSize =
+				ConfigurationManager::getSingleton().getIntSetting(
+					&quot;Video&quot;, &quot;Shadow Texture Size&quot; );
+			textureSize = std::max( 64, std::min( 4096, textureSize ) );
+
+			mSceneMgr-&gt;setShadowTechnique(SHADOWTYPE_TEXTURE_MODULATIVE);
+			mSceneMgr-&gt;setShadowTextureSize( textureSize );
+			mSceneMgr-&gt;setShadowColour(ColourValue(0.7, 0.7, 0.7));
+			mSceneMgr-&gt;setShadowFarDistance(8.0f);
+			mSceneMgr-&gt;setShadowDirLightTextureOffset(0.8f);
+            mSceneMgr-&gt;setShadowCameraSetup((Ogre::ShadowCameraSetupPtr) new Ogre::LiSPSMShadowCameraSetup());
+		}
+		else
+		{
+			mSceneMgr-&gt;setShadowTechnique( SHADOWTYPE_NONE);
+		}
+    }
+}

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -524,7 +524,8 @@
         else
         {
             const AxisAlignedBox&amp; aabb = mPhysicalObject-&gt;getDefaultSize();
-            coll = PhysicsManager::getSingleton().getCollisionFactory()-&gt;createCollisionFromAABB(
+            coll = PhysicsManager::getSingleton().createCollision(
+                &quot;&quot;, // @todo: can we use a name here?
                 aabb,
                 mGeometryType,
                 NULL,

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -113,9 +113,6 @@
 
     PhysicsManager::~PhysicsManager()
     {
-        // simply remove all collision ptrs (is this really ok?)
-        mCollisionPrimitives.clear();
-
         // remove all material-pairs
         for (MaterialPairMap::iterator it = mMaterialPairs.begin(); it != mMaterialPairs.end(); it++)
         {
@@ -520,10 +517,13 @@
 
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
         Ogre::Entity* entity, const GeometryType&amp; geomType,
-		const Ogre::String animName, Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
+		const Ogre::String&amp; animName, const Ogre::Vector3* offset,
+        const Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
         Ogre::Vector3* centerOfMass, bool nocache)
     {
+        return mPhysicsCollisionFactory-&gt;createCollisionFromEntity(
+                entity, geomType, offset, orientation, mass, inertia, centerOfMass, nocache );
+/*
         // problem here is that a mesh can have different animations with
         // different extents. Therefore we add the animName to the meshname
         // to compute a unique name for the collision primitiv.
@@ -566,14 +566,18 @@
         }
 
         return rval;
+*/
     }
 
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
         const Ogre::String&amp; name, const Ogre::AxisAlignedBox&amp; aabb,
-        const GeometryType&amp; geomType, Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
+        const GeometryType&amp; geomType, const Ogre::Vector3* offset,
+        const Ogre::Quaternion* orientation, const Ogre::Real mass, Ogre::Vector3* inertia,
         Ogre::Vector3* centerOfMass, bool nocache)
     {
+        return mPhysicsCollisionFactory-&gt;createCollisionFromAABB(
+                name, aabb, geomType, offset, orientation, mass, inertia, centerOfMass, nocache );
+/*
         // result value
         CollisionPtr rval;
 #ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
@@ -610,13 +614,9 @@
         }
 
         return rval;
+*/
     }
 
-    PhysicsCollisionFactory* PhysicsManager::getCollisionFactory()
-    {
-        return mPhysicsCollisionFactory;
-    }
-
 	GeometryType PhysicsManager::convertStringToGeometryType(const Ogre::String&amp; geomTypeString)
 	{
 		if (geomTypeString == &quot;box&quot;)
@@ -657,6 +657,17 @@
 		return typestr;
 	}
 
+    PhysicsCollisionFactory::~PhysicsCollisionFactory()
+    {
+        clearCollisionCache();
+    }
+
+    void PhysicsCollisionFactory::clearCollisionCache()
+    {
+        mMeshCollisionsCache.clear();
+        mConvexCollisionsCache.clear();
+    }
+
     bool PhysicsCollisionFactory::checkSize(const Ogre::AxisAlignedBox&amp; aabb) const
     {
         Ogre::Vector3 size = aabb.getSize();
@@ -690,20 +701,23 @@
     }
     */
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(const Ogre::AxisAlignedBox passedAabb,
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(
+        const Ogre::String&amp; name,
+        const Ogre::AxisAlignedBox&amp; passedAabb,
         const GeometryType&amp; geomType,
-        Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation,
-        const Ogre::Real Mass,
+        const Ogre::Vector3* offset,
+        const Ogre::Quaternion* orientation,
+        const Ogre::Real mass,
         Ogre::Vector3* inertia,
-        Ogre::Vector3* centerOfMass)
+        Ogre::Vector3* centerOfMass,
+        bool nocache)
     {
         Ogre::AxisAlignedBox aabb(passedAabb);
         // type for the collision primitiv (can change internally here)
         bool forceBox (false);
 
         // result value
-        CollisionPtr rval;
+        ConvexCollisionPtr rval;
 #ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
         rval = NULL;
 #endif
@@ -738,44 +752,64 @@
 	    */
 		if (geomType == GT_BOX || forceBox == true)
         {
-			rval = createBox(aabb, offset, orientation, Mass, inertia, centerOfMass);
+			rval = createBox(aabb, offset, orientation);
         }
         else if (geomType == GT_PYRAMID)
         {
-            rval = createPyramid(aabb, offset, orientation, Mass, inertia, centerOfMass);
+            rval = createPyramid(aabb, offset, orientation);
         }
         else if (geomType == GT_SPHERE)
         {
-			rval = createSphere(aabb, offset, orientation, Mass, inertia, centerOfMass);
+			rval = createSphere(aabb, offset, orientation);
         }
         else if (geomType == GT_ELLIPSOID)
         {
-            rval = createEllipsoid(aabb, offset, orientation, Mass, inertia, centerOfMass);
+            rval = createEllipsoid(aabb, offset, orientation);
         }
 		else if (geomType == GT_CAPSULE)
 		{
-			rval = createCapsule(aabb, offset, orientation, Mass, inertia, centerOfMass);
+			rval = createCapsule(aabb, offset, orientation);
 		}
+
+        // calculate inertia / centerOfMass if needed
+        if (inertia != NULL || centerOfMass != NULL )
+        {
+            Vector3 temp_inertia, temp_centerOfMass;
+            rval-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+            if( inertia != NULL )
+                *inertia = temp_inertia*mass;
+            if( centerOfMass != NULL )
+                *centerOfMass = temp_centerOfMass;
+        }
+
         return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromEntity(Ogre::Entity* entity,
         const GeometryType&amp; geomType,
-        Ogre::Vector3* offset,
-        Ogre::Quaternion* orientation,
+        const Ogre::Vector3* offset,
+        const Ogre::Quaternion* orientation,
         const Ogre::Real mass,
         Ogre::Vector3* inertia,
-        Ogre::Vector3* centerOfMass)
+        Ogre::Vector3* centerOfMass,
+        bool nocache)
     {
         // bounding box of the mesh
         Ogre::AxisAlignedBox aabb(entity-&gt;getBoundingBox());
+        // apply scale if attached to a node (like in OgreNewt for convexhull)
+        if( entity-&gt;getParentNode() )
+            aabb.scale(entity-&gt;getParentNode()-&gt;getScale());
+
         // type for the collision primitiv (can change internally here)
         bool forceBox (false);
 
         // result value
         CollisionPtr rval;
+        ConvexCollisionPtr rvalAsConvexCollision; // store pointer to ConvexCollision, so we don't need to cast
+                                                  // this also indicates, that it is possible to calculate inertia/centerOfMass
 #ifndef OGRENEWT_COLLISION_USE_SHAREDPTR
         rval = NULL;
+        rvalAsConvexCollision = NULL;
 #endif
 
         // size check (if object is too small, it falls back to a box primitiv
@@ -797,55 +831,33 @@
 	    */
 		if (geomType == GT_BOX || forceBox == true)
         {
-			rval = createBox(aabb, offset, orientation, mass, inertia, centerOfMass);
+            rvalAsConvexCollision = createBox(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
         }
         else if (geomType == GT_PYRAMID)
         {
-            rval = createPyramid(aabb, offset, orientation, mass, inertia, centerOfMass);
+            rvalAsConvexCollision = createPyramid(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
         }
         else if (geomType == GT_SPHERE)
         {
-			rval = createSphere(aabb, offset, orientation, mass, inertia, centerOfMass);
+            rvalAsConvexCollision = createSphere(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
         }
         else if (geomType == GT_ELLIPSOID)
         {
-            rval = createEllipsoid(aabb, offset, orientation, mass, inertia, centerOfMass);
+            rvalAsConvexCollision = createEllipsoid(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
         }
 		else if (geomType == GT_CAPSULE)
 		{
-			rval = createCapsule(aabb, offset, orientation, mass, inertia, centerOfMass);
+            rvalAsConvexCollision = createCapsule(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
 		}
         else if (geomType == GT_CONVEXHULL)
         {
-            // offset of the collision primitiv
-	    	Ogre::Vector3 object_offset( Ogre::Vector3::ZERO );
-            // orientation of the collision primitiv
-		    Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
-
-            // set offset/orientation when they are null
-			if (! offset)
-				offset = &amp;object_offset;
-			if (! orientation)
-				orientation = &amp;object_orientation;
-
-			// calculate the convex hull of the animated mesh
-			rval = CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
-                PhysicsManager::getSingleton()._getNewtonWorld(),
-				entity, /*entity-&gt;hasSkeleton(),*/ *orientation, *offset));
-
-            if (inertia != NULL || centerOfMass != NULL )
-            {
-                Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-                boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-                dynamic_cast&lt;OgreNewt::ConvexCollisionPtr&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-                if( inertia != NULL )
-                    *inertia = temp_inertia*mass;
-                if( centerOfMass != NULL )
-                    *centerOfMass = temp_centerOfMass;
-            }
+            rvalAsConvexCollision = createConvexHull(entity, offset, orientation);
+            rval = rvalAsConvexCollision;
         }
         else if (geomType == GT_MESH)
         {
@@ -876,15 +888,26 @@
                 entity-&gt;getName()+&quot;'&quot;);
         }
 
+        // calculate inertia / centerOfMass if requested
+        if( rvalAsConvexCollision )
+        {
+            if (inertia != NULL || centerOfMass != NULL )
+            {
+                Vector3 temp_inertia, temp_centerOfMass;
+                rvalAsConvexCollision-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+                if( inertia != NULL )
+                    *inertia = temp_inertia*mass;
+                if( centerOfMass != NULL )
+                    *centerOfMass = temp_centerOfMass;
+            }
+        }
+
         return rval;
     }
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createBox(const Ogre::AxisAlignedBox&amp; aabb,
-            Ogre::Vector3* offset,
-            Ogre::Quaternion* orientation,
-            const Ogre::Real mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass)
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createBox(const Ogre::AxisAlignedBox&amp; aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
     {
         // offset of the collision primitiv
         Ogre::Vector3 object_offset( aabb.getCenter() );
@@ -898,34 +921,16 @@
 			orientation = &amp;object_orientation;
 
         // a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
-        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             aabb.getSize(), *orientation, *offset));
 
-
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-            dynamic_cast&lt;OgreNewt::ConvexCollisionPtr&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-            if( inertia )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass )
-                *centerOfMass = temp_centerOfMass;
-        }
-
-        return rval;
+       return rval;
     }
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createPyramid(const Ogre::AxisAlignedBox&amp; aabb,
-            Ogre::Vector3* offset,
-            Ogre::Quaternion* orientation,
-            const Ogre::Real mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass)
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createPyramid(const Ogre::AxisAlignedBox&amp; aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
     {
         Ogre::Vector3 size = aabb.getSize();
         // positional offset of the collision primitiv
@@ -939,34 +944,16 @@
 		if (! orientation)
 			orientation = &amp;object_orientation;
 
-        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             size, *orientation, *offset));
 
-
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-            dynamic_cast&lt;OgreNewt::ConvexCollisionPtr&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-            if( inertia )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass )
-                *centerOfMass = temp_centerOfMass;
-        }
- 
-        return rval;
+       return rval;
     }
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createSphere(const Ogre::AxisAlignedBox&amp; aabb,
-            Ogre::Vector3* offset,
-            Ogre::Quaternion* orientation,
-            const Ogre::Real mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass)
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createSphere(const Ogre::AxisAlignedBox&amp; aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
     {
         Ogre::Vector3 size = aabb.getSize();
         // calculate the maximum radius needed to include 'everything'
@@ -984,34 +971,16 @@
 			orientation = &amp;object_orientation;
  
         // a sphere primitiv has got its coordinate system at its center, so shift it with radius
-        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             Vector3(radius, radius, radius), *orientation, *offset));
  
-
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-            dynamic_cast&lt;OgreNewt::ConvexCollisionPtr&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-            if( inertia )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass )
-                *centerOfMass = temp_centerOfMass;
-        }
- 
-        return rval;
+       return rval;
     }
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createEllipsoid(const Ogre::AxisAlignedBox&amp; aabb,
-            Ogre::Vector3* offset,
-            Ogre::Quaternion* orientation,
-            const Ogre::Real mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass)
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createEllipsoid(const Ogre::AxisAlignedBox&amp; aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
     {
         Ogre::Vector3 size = aabb.getSize();
         // set the size x/z values to the maximum
@@ -1030,34 +999,16 @@
 			orientation = &amp;object_orientation;
 
         // an ellipsoid primitiv has got its coordinate system at its center, so shift it with radius
-        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             s, *orientation, *offset));
 
-
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-            dynamic_cast&lt;OgreNewt::ConvexCollisionPtr&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-            if( inertia )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass )
-                *centerOfMass = temp_centerOfMass;
-        }
- 
-        return rval;
+       return rval;
     }
 
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCapsule(const Ogre::AxisAlignedBox&amp; aabb,
-            Ogre::Vector3* offset,
-            Ogre::Quaternion* orientation,
-            const Ogre::Real mass,
-            Ogre::Vector3* inertia,
-            Ogre::Vector3* centerOfMass)
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createCapsule(const Ogre::AxisAlignedBox&amp; aabb,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
     {
         Ogre::Vector3 size = aabb.getSize();
         // positional offset of the collision primitiv
@@ -1066,7 +1017,7 @@
 		Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
         double radius = std::max(size.x, size.z) / 2.0;
 		double height = size.y;
-        // fixme: this is a semi ugly fix - because the orientation should be set by the loader
+        // @todo: fixme: this is a semi ugly fix - because the orientation should be set by the loader
         object_orientation.FromAngleAxis(Degree(90), Vector3::UNIT_Z);
 
 		// set offset/orientation when they are null
@@ -1083,22 +1034,35 @@
             radius, height, *orientation, *offset));
 
 
-        if (inertia != NULL || centerOfMass != NULL )
-        {
-            Vector3 temp_inertia, temp_centerOfMass;
-#ifdef OGRENEWT_COLLISION_USE_SHAREDPTR
-            boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#else
-            dynamic_cast&lt;OgreNewt::ConvexCollisionPtr&gt;(rval)-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-#endif
-            if( inertia )
-                *inertia = temp_inertia*mass;
-            if( centerOfMass )
-                *centerOfMass = temp_centerOfMass;
-        }
- 
- 
         return rval;
     }
+
+
+
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createConvexHull(
+            Ogre::Entity* entity,
+            const Ogre::Vector3* offset,
+            const Ogre::Quaternion* orientation)
+    {
+        // offset of the collision primitiv
+        Ogre::Vector3 object_offset( Ogre::Vector3::ZERO );
+        // orientation of the collision primitiv
+        Ogre::Quaternion object_orientation = Ogre::Quaternion::IDENTITY;
+
+        // set offset/orientation when they are null
+        if (! offset)
+            offset = &amp;object_offset;
+        if (! orientation)
+            orientation = &amp;object_orientation;
+
+        // calculate the convex hull of the animated mesh
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::ConvexHull(
+                    PhysicsManager::getSingleton()._getNewtonWorld(),
+                    entity, *orientation, *offset));
+
+        return rval;
+    }
+
+
 }
 

Modified: rl/trunk/engine/core/src/SceneQuery.cpp
===================================================================
--- rl/trunk/engine/core/src/SceneQuery.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/core/src/SceneQuery.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -117,7 +117,11 @@
 
                 // Add actor to this body to the result
 #ifdef OGRENEWT_USE_OGRE_ANY
-                Actor* actor = Ogre::any_cast&lt;Actor*&gt;(body-&gt;getUserData());
+                Actor* actor = NULL;
+                if( body-&gt;getUserData().getType() == typeid(Actor*) )
+                {
+                    actor = Ogre::any_cast&lt;Actor*&gt;(body-&gt;getUserData());
+                }
 #else
                 Actor* actor = static_cast&lt;Actor*&gt;(body-&gt;getUserData());
 #endif

Modified: rl/trunk/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -167,7 +167,9 @@
     void CreatureControllerManager::userProcess(OgreNewt::ContactJoint &amp;contactJoint, Real timestep, int threadid)
     {
 #ifdef OGRENEWT_USE_OGRE_ANY
-        Actor *actor = Ogre::any_cast&lt;Actor*&gt;(contactJoint.getBody0()-&gt;getUserData());
+        Actor *actor = NULL;
+        if( contactJoint.getBody0()-&gt;getUserData().getType() == typeid(Actor*) )
+            actor = Ogre::any_cast&lt;Actor*&gt;(contactJoint.getBody0()-&gt;getUserData());
 #else
         Actor *actor = static_cast&lt;Actor*&gt;(contactJoint.getBody0()-&gt;getUserData());
 #endif
@@ -183,9 +185,10 @@
 
         // if the controlled body is the second body...
 #ifdef OGRENEWT_USE_OGRE_ANY
-        actor = Ogre::any_cast&lt;Actor*&gt;(contactJoint.getBody0()-&gt;getUserData());
+        if( contactJoint.getBody1()-&gt;getUserData().getType() == typeid(Actor*) )
+            actor = Ogre::any_cast&lt;Actor*&gt;(contactJoint.getBody1()-&gt;getUserData());
 #else
-        actor = static_cast&lt;Actor*&gt;(contactJoint.getBody0()-&gt;getUserData());
+        actor = static_cast&lt;Actor*&gt;(contactJoint.getBody1()-&gt;getUserData());
 #endif
         if( actor != NULL )
         {

Modified: rl/trunk/engine/rules/src/SelectionHelper.cpp
===================================================================
--- rl/trunk/engine/rules/src/SelectionHelper.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/rules/src/SelectionHelper.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -85,7 +85,9 @@
             if (body != NULL)
             {
 #ifdef OGRENEWT_USE_OGRE_ANY
-                Actor* hitActor = Ogre::any_cast&lt;Actor*&gt;(body-&gt;getUserData());
+                Actor* hitActor = NULL;
+                if( body-&gt;getUserData().getType() == typeid(Actor*) )
+                    hitActor = Ogre::any_cast&lt;Actor*&gt;(body-&gt;getUserData());
 #else
                 Actor* hitActor = static_cast&lt;Actor*&gt;(body-&gt;getUserData());
 #endif

Modified: rl/trunk/engine/script/include/EntityNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/EntityNodeProcessor.h	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/script/include/EntityNodeProcessor.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -38,16 +38,6 @@
         virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
 
     private:
-		/// stores already constructed collision proxies for reuse
-        struct AlreadyUsedCollision
-        {
-        public:
-            Ogre::String Type;
-            Ogre::Vector3 Scale;
-            OgreNewt::CollisionPtr ColPtr;
-        };
-
-		std::map&lt;Ogre::String,AlreadyUsedCollision&gt; mAutoCreatedCollisions;
         Ogre::String mResourceGroup;
 
         void createCollision(Ogre::Entity* entity, Ogre::String meshFile, XERCES_CPP_NAMESPACE::DOMElement* physicsProxyElem);

Modified: rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -148,7 +148,6 @@
 			const Quaternion orientation(0,0,0,0);// = parentNode-&gt;getOrientation();
 			const Ogre::Vector3 pos = aab.getMinimum() * parentNode-&gt;getScale() + (size/2.0);
 
-			//collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(world, size, orientation, pos));
             collision = PhysicsManager::getSingleton().createCollision(entity, GT_BOX, &quot;&quot;, NULL, NULL, 0, NULL, NULL, true);
 
 			if ( collision != NULL )

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/script/swig/RlCore.swig	2009-04-14 00:07:38 UTC (rev 4896)
@@ -172,8 +172,6 @@
 public:	
 	enum FogMode { FOG_NONE, FOG_EXP, FOG_EXP2, FOG_LINEAR  };
 
-	void loadScene(const Ogre::String&amp; levelName, const Ogre::String&amp; resourceGroup ) = 0;
-
     virtual void setSkyBox (bool enable, const Ogre::String&amp; materialName, Ogre::Real distance=2500, bool drawFirst=true );
     virtual void setSkyDome (bool enable, const Ogre::String&amp; materialName, Ogre::Real curvature=10, Ogre::Real tiling=8, Ogre::Real distance=4000, bool drawFirst=true );
     virtual void setFog ( FogMode mode=FOG_NONE, const Ogre::ColourValue &amp;colour=Ogre::ColourValue::White, Ogre::Real expDensity=0.001, Ogre::Real linearStart=0.0, Ogre::Real linearEnd=1.0);
@@ -184,6 +182,8 @@
     virtual void setAmbientLight(Ogre::Real r, Ogre::Real g, Ogre::Real b);
     virtual Ogre::Vector3 getStartPoint() const;
     virtual void setCastShadows(bool);
+    virtual void clearScene() = 0;
+    virtual void initializeDefaultCamera() = 0;
 
     void setShowBoundingBoxes( bool dis );
 };
@@ -777,8 +777,8 @@
 public:
     static CoreSubsystem&amp; getSingleton(void);
     
-    void loadMap(const Ogre::String&amp; type, const Ogre::String&amp; filename,
-		const Ogre::String&amp; resourceGroup);
+    // obsolete
+    // void loadMap(const Ogre::String&amp; type, const Ogre::String&amp; filename, const Ogre::String&amp; resourceGroup);
 
 	void registerModule(rl::ContentModule* module);
 

Modified: rl/trunk/engine/ui/include/UiSubsystem.h
===================================================================
--- rl/trunk/engine/ui/include/UiSubsystem.h	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/ui/include/UiSubsystem.h	2009-04-14 00:07:38 UTC (rev 4896)
@@ -18,7 +18,6 @@
 #define __UiSubsystem_H__
 
 #include &quot;UiPrerequisites.h&quot;
-#include &quot;World.h&quot;
 
 
 #include &quot;ControlState.h&quot;

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2009-04-12 19:49:46 UTC (rev 4895)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2009-04-14 00:07:38 UTC (rev 4896)
@@ -162,6 +162,7 @@
         //! TODO: remove this workaround (newton-bug: &quot;spheres don't cast&quot;!)
         mCameraCastCollision = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(mCamBody-&gt;getWorld(), verts, 80));
         //mCameraCastCollision = new OgreNewt::CollisionPrimitives::Ellipsoid(mCamBody-&gt;getWorld(), Vector3::UNIT_SCALE * camRadius);
+        // we could use the real collision of the camera here...
     }
 
     //------------------------------------------------------------------------


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001952.html">[Dsa-hl-svn] r4895 - rl/trunk/editors/Lockenwickler/src
</A></li>
	<LI>Next message: <A HREF="001954.html">[Dsa-hl-svn] r4897 - in rl/branches/persistence2:	editors/Lockenwickler/src engine/ai/include engine/ai/src	engine/core engine/core/include engine/core/src	engine/rules/src engine/script/include engine/script/src	engine/script/swig engine/ui/include engine/ui/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1953">[ date ]</a>
              <a href="thread.html#1953">[ thread ]</a>
              <a href="subject.html#1953">[ subject ]</a>
              <a href="author.html#1953">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
