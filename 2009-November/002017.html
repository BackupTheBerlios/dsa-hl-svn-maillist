<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4961 - in rl/trunk: . cmake engine/ai	engine/ai/include engine/ai/src engine/common	engine/common/include engine/common/src engine/core	engine/core/include engine/core/src engine/rules	engine/rules/include engine/rules/src engine/script	engine/script/include engine/script/src engine/startup	engine/startup/src engine/ui engine/ui/include engine/ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-November/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4961%20-%20in%20rl/trunk%3A%20.%20cmake%20engine/ai%0A%09engine/ai/include%20engine/ai/src%20engine/common%0A%09engine/common/include%20engine/common/src%20engine/core%0A%09engine/core/include%20engine/core/src%20engine/rules%0A%09engine/rules/include%20engine/rules/src%20engine/script%0A%09engine/script/include%20engine/script/src%20engine/startup%0A%09engine/startup/src%20engine/ui%20engine/ui/include%20engine/ui/src&In-Reply-To=%3C200911071939.nA7JdesV003038%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002016.html">
   <LINK REL="Next"  HREF="002018.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4961 - in rl/trunk: . cmake engine/ai	engine/ai/include engine/ai/src engine/common	engine/common/include engine/common/src engine/core	engine/core/include engine/core/src engine/rules	engine/rules/include engine/rules/src engine/script	engine/script/include engine/script/src engine/startup	engine/startup/src engine/ui engine/ui/include engine/ui/src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4961%20-%20in%20rl/trunk%3A%20.%20cmake%20engine/ai%0A%09engine/ai/include%20engine/ai/src%20engine/common%0A%09engine/common/include%20engine/common/src%20engine/core%0A%09engine/core/include%20engine/core/src%20engine/rules%0A%09engine/rules/include%20engine/rules/src%20engine/script%0A%09engine/script/include%20engine/script/src%20engine/startup%0A%09engine/startup/src%20engine/ui%20engine/ui/include%20engine/ui/src&In-Reply-To=%3C200911071939.nA7JdesV003038%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4961 - in rl/trunk: . cmake engine/ai	engine/ai/include engine/ai/src engine/common	engine/common/include engine/common/src engine/core	engine/core/include engine/core/src engine/rules	engine/rules/include engine/rules/src engine/script	engine/script/include engine/script/src engine/startup	engine/startup/src engine/ui engine/ui/include engine/ui/src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Sat Nov  7 20:39:40 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002016.html">[Dsa-hl-svn] r4960 - in dependencies: . tinyxml tinyxml/docs
</A></li>
        <LI>Next message: <A HREF="002018.html">[Dsa-hl-svn] r4962 - in rl/trunk/engine/core: include src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2017">[ date ]</a>
              <a href="thread.html#2017">[ thread ]</a>
              <a href="subject.html#2017">[ subject ]</a>
              <a href="author.html#2017">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2009-11-07 20:39:22 +0100 (Sat, 07 Nov 2009)
New Revision: 4961

Added:
   rl/trunk/cmake/FindTinyXML.cmake
Removed:
   rl/trunk/engine/common/include/OgreXercesInput.h
   rl/trunk/engine/common/include/WriteableDataStreamFormatTarget.h
   rl/trunk/engine/common/src/OgreXercesInput.cpp
   rl/trunk/engine/common/src/WriteableDataStreamFormatTarget.cpp
Modified:
   rl/trunk/.project
   rl/trunk/CMakeLists.txt
   rl/trunk/engine/ai/CMakeLists.txt
   rl/trunk/engine/ai/include/DialogLoaderImpl.h
   rl/trunk/engine/ai/src/AiSubsystem.cpp
   rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
   rl/trunk/engine/ai/src/DialogManager.cpp
   rl/trunk/engine/ai/src/WayPointGraph.cpp
   rl/trunk/engine/common/CMakeLists.txt
   rl/trunk/engine/common/include/CommonPrerequisites.h
   rl/trunk/engine/common/include/RastullahPrerequisites.h
   rl/trunk/engine/common/include/XmlProcessor.h
   rl/trunk/engine/common/include/XmlPropertyReader.h
   rl/trunk/engine/common/include/XmlPropertyWriter.h
   rl/trunk/engine/common/include/XmlResource.h
   rl/trunk/engine/common/src/XmlProcessor.cpp
   rl/trunk/engine/common/src/XmlPropertyReader.cpp
   rl/trunk/engine/common/src/XmlPropertyWriter.cpp
   rl/trunk/engine/common/src/XmlResource.cpp
   rl/trunk/engine/core/CMakeLists.txt
   rl/trunk/engine/core/include/PhysicsRagDoll.h
   rl/trunk/engine/core/include/SaveGameFile.h
   rl/trunk/engine/core/include/SaveGameFileReader.h
   rl/trunk/engine/core/src/ContentModule.cpp
   rl/trunk/engine/core/src/GenericWorld.cpp
   rl/trunk/engine/core/src/JobScheduler.cpp
   rl/trunk/engine/core/src/PhysicsRagDoll.cpp
   rl/trunk/engine/core/src/SaveGameFile.cpp
   rl/trunk/engine/core/src/SaveGameFileReader.cpp
   rl/trunk/engine/core/src/SaveGameFileWriter.cpp
   rl/trunk/engine/core/src/SaveGameManager.cpp
   rl/trunk/engine/core/src/TimeSource.cpp
   rl/trunk/engine/core/src/ZoneManager.cpp
   rl/trunk/engine/rules/CMakeLists.txt
   rl/trunk/engine/rules/include/DsaDataLoader.h
   rl/trunk/engine/rules/include/QuestBook.h
   rl/trunk/engine/rules/src/DsaDataLoader.cpp
   rl/trunk/engine/rules/src/GlobalProperties.cpp
   rl/trunk/engine/rules/src/QuestBook.cpp
   rl/trunk/engine/script/CMakeLists.txt
   rl/trunk/engine/script/include/AbstractMapNodeProcessor.h
   rl/trunk/engine/script/include/EntityNodeProcessor.h
   rl/trunk/engine/script/include/EnvironmentProcessor.h
   rl/trunk/engine/script/include/GameObjectNodeProcessor.h
   rl/trunk/engine/script/include/LightNodeProcessor.h
   rl/trunk/engine/script/include/MapLoader.h
   rl/trunk/engine/script/include/ParticleSystemNodeProcessor.h
   rl/trunk/engine/script/include/PlaneNodeProcessor.h
   rl/trunk/engine/script/include/SoundNodeProcessor.h
   rl/trunk/engine/script/include/WaypointProcessor.h
   rl/trunk/engine/script/include/ZoneProcessor.h
   rl/trunk/engine/script/src/AbstractMapNodeProcessor.cpp
   rl/trunk/engine/script/src/EntityNodeProcessor.cpp
   rl/trunk/engine/script/src/EnvironmentProcessor.cpp
   rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp
   rl/trunk/engine/script/src/LightNodeProcessor.cpp
   rl/trunk/engine/script/src/MapLoader.cpp
   rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp
   rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
   rl/trunk/engine/script/src/SceneLoader.cpp
   rl/trunk/engine/script/src/SoundNodeProcessor.cpp
   rl/trunk/engine/script/src/TriggerFactory.cpp
   rl/trunk/engine/script/src/WaypointProcessor.cpp
   rl/trunk/engine/script/src/ZoneProcessor.cpp
   rl/trunk/engine/startup/CMakeLists.txt
   rl/trunk/engine/startup/src/RastullahMain.cpp
   rl/trunk/engine/ui/CMakeLists.txt
   rl/trunk/engine/ui/include/UiPrerequisites.h
   rl/trunk/engine/ui/src/InputManager.cpp
Log:
Replaced XML library (Xerces-C) by TinyXML (smaller and simpler and doesn't use symbols defined by ruby)

Modified: rl/trunk/.project
===================================================================
--- rl/trunk/.project	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/.project	2009-11-07 19:39:22 UTC (rev 4961)
@@ -79,7 +79,7 @@
 				&lt;/dictionary&gt;
 				&lt;dictionary&gt;
 					&lt;key&gt;org.eclipse.cdt.make.core.environment&lt;/key&gt;
-					&lt;value&gt;&lt;/value&gt;
+					&lt;value&gt;MAKEFLAGS=-j4|&lt;/value&gt;
 				&lt;/dictionary&gt;
 				&lt;dictionary&gt;
 					&lt;key&gt;org.eclipse.cdt.make.core.fullBuildTarget&lt;/key&gt;

Modified: rl/trunk/CMakeLists.txt
===================================================================
--- rl/trunk/CMakeLists.txt	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/CMakeLists.txt	2009-11-07 19:39:22 UTC (rev 4961)
@@ -24,7 +24,7 @@
 
 # Check for required components
 FIND_PACKAGE(PkgConfig)
-FIND_PACKAGE(XercesC REQUIRED)
+FIND_PACKAGE(TinyXML REQUIRED)
 FIND_PACKAGE(OGRE 1.6 REQUIRED)
 FIND_PACKAGE(OIS REQUIRED)
 FIND_PACKAGE(CEGUI REQUIRED)

Added: rl/trunk/cmake/FindTinyXML.cmake
===================================================================
--- rl/trunk/cmake/FindTinyXML.cmake	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/cmake/FindTinyXML.cmake	2009-11-07 19:39:22 UTC (rev 4961)
@@ -0,0 +1,64 @@
+# Find TinyXML (A small XML DOM library)
+#
+# This module defines
+# TINYXML_FOUND       - TinyXML was found
+# TINYXML_INCLUDE_DIR - Directory containing TinyXML header files
+# TINYXML_LIBRARY     - Library name of TinyXML library
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+# On a new cmake run, we do not need to be verbose
+IF(TINYXML_INCLUDE_DIR AND TINYXML_LIBRARY)
+	SET(TINYXML_FOUND_QUIETLY TRUE)
+ENDIF(TINYXML_INCLUDE_DIR AND TINYXML_LIBRARY)
+
+IF(WIN32)
+
+ELSE(WIN32)
+	IF(NOT TINYXML_FOUND)
+		SET(TINYXML_INCLUDE_SEARCH_DIRS
+		    /usr/include
+		    /usr/local/include
+		    /opt/include
+		    /opt/tinyxml/include)
+		SET(TINYXML_LIBRARY_SEARCH_DIRS
+		    /usr/lib
+		    /usr/lib64
+		    /usr/local/lib
+		    /usr/local/lib64
+		    /opt/tinyxml/lib
+		    /opt/tinyxml/lib64)
+		SET(TINYXML_INC_DIR_SUFFIXES PATH_SUFFIXES tinyxml)
+		FIND_PATH(TINYXML_INCLUDE_DIR tinyxml.h
+		          PATHS ${TINYXML_INCLUDE_SEARCH_DIRS}
+		          PATH_SUFFIXES ${TINYXML_INC_DIR_SUFFIXES})
+		SET(TINYXML_LIBRARY tinyxml)
+		FIND_PATH(TINYXML_LIBRARY_DIRS libtinyxml.a
+		             PATHS ${TINYXML_LIBRARY_SEARCH_DIRS}
+		             PATH_SUFFIXES ${TINYXML_LIB_DIR_SUFFIXES}})
+	ENDIF(NOT TINYXML_FOUND)
+ENDIF(WIN32)
+
+SET(TINYXML_INCLUDE_DIR ${TINYXML_INCLUDE_DIR} CACHE STRING &quot;Directory containing TinyXML header files&quot;)
+SET(TINYXML_LIBRARY ${TINYXML_LIBRARY} CACHE STRING &quot;Library name of TinyXML library&quot;)
+
+IF(TINYXML_INCLUDE_DIR AND TINYXML_LIBRARY_DIRS)
+	SET(TINYXML_FOUND TRUE)
+ENDIF(TINYXML_INCLUDE_DIR AND TINYXML_LIBRARY_DIRS)
+
+IF(TINYXML_FOUND)
+	IF(NOT TINYXML_FIND_QUIETLY)
+		MESSAGE(STATUS &quot;  libraries: ${TINYXML_LIBRARY} from ${TINYXML_LIBRARY_DIRS}&quot;)
+		MESSAGE(STATUS &quot;  includes: ${TINYXML_INCLUDE_DIR}&quot;)
+	ENDIF(NOT TINYXML_FIND_QUIETLY)
+ELSE(TINYXML_FOUND)
+	IF(TINYXML_FIND_REQUIRED)
+		IF(NOT TINYXML_LIBRARY_DIRS)
+			MESSAGE(SEND_ERROR, &quot;TinyXML library could not be found.&quot;)
+		ENDIF(NOT TINYXML_LIBRARY)
+		IF(NOT TINYXML_INCLUDE_DIR)
+			MESSAGE(SEND_ERROR &quot;TinyXML include files could not be found.&quot;)
+		ENDIF(NOT TINYXML_INCLUDE_DIR)
+	ENDIF(TINYXML_FIND_REQUIRED)
+ENDIF(TINYXML_FOUND)

Modified: rl/trunk/engine/ai/CMakeLists.txt
===================================================================
--- rl/trunk/engine/ai/CMakeLists.txt	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ai/CMakeLists.txt	2009-11-07 19:39:22 UTC (rev 4961)
@@ -7,7 +7,7 @@
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIRS}
 ${OPENSTEER_INCLUDE_DIR}
-${XERCESC_INCLUDE_DIR})
+${TINYXML_INCLUDE_DIR})
 
 SET(RlAi_LIB_SRCS
 src/Agent.cpp

Modified: rl/trunk/engine/ai/include/DialogLoaderImpl.h
===================================================================
--- rl/trunk/engine/ai/include/DialogLoaderImpl.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ai/include/DialogLoaderImpl.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,10 +16,11 @@
 #include &quot;AiPrerequisites.h&quot;
 
 #include &lt;list&gt;
+#include &lt;tinyxml.h&gt;
 
+#include &quot;Creature.h&quot;
 #include &quot;Properties.h&quot;
 #include &quot;XmlProcessor.h&quot;
-#include &quot;Creature.h&quot;
 
 namespace rl
 {
@@ -33,14 +34,15 @@
     class DialogVariable;
 	class Property;
 
-    class DialogLoaderImpl : private XmlProcessor
+	class DialogLoaderImpl : private XmlProcessor, public TiXmlVisitor
     {
     public:
         DialogLoaderImpl();
-        ~DialogLoaderImpl();
+        virtual ~DialogLoaderImpl();
 
         Dialog* createDialog(const Ogre::String&amp; name, const CreatureList&amp; participants) const;
         void parseDialog(Ogre::DataStreamPtr&amp; stream, const Ogre::String&amp; groupName);
+        virtual bool VisitEnter(const TiXmlElement &amp;element, const TiXmlAttribute *firstAttribute);
 
     private:
         class DialogParticipant
@@ -83,23 +85,23 @@
             PropertyRecord mPropertyVariables;
         };
 
-        void processDialog(XERCES_CPP_NAMESPACE::DOMElement* dialogXml);
-        DialogResponse* processResponseClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype* dialogPrototype);
-        DialogResponse* processResponse(XERCES_CPP_NAMESPACE::DOMElement* responseXml, DialogPrototype* dialogPrototype, bool subelements);
-        DialogResponse* processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype);
-        DialogOption* processOptionClasses(XERCES_CPP_NAMESPACE::DOMNode *node, DialogPrototype *dialogPrototype);
-        DialogOption* processOption(XERCES_CPP_NAMESPACE::DOMElement* optionXml, DialogPrototype* dialogPrototype, bool subelements);
-        DialogOption* processSwitchOption(XERCES_CPP_NAMESPACE::DOMElement* switchOptXml, DialogPrototype* dialogPrototype);
-        DialogCondition* processIf(XERCES_CPP_NAMESPACE::DOMElement *ifXml);
-        DialogCondition* processCase(XERCES_CPP_NAMESPACE::DOMElement *caseXml);
-        DialogVariable* processVariableClasses(XERCES_CPP_NAMESPACE::DOMElement* variableXml);
-        DialogCondition* processConditionClasses(XERCES_CPP_NAMESPACE::DOMElement* conditionXml);
-        DialogParagraph* processParagraph(XERCES_CPP_NAMESPACE::DOMElement* paragraphXml);
-        DialogImplication* processImplicationClasses(XERCES_CPP_NAMESPACE::DOMNode* implicationXml);
-        DialogParticipant* processPerson(XERCES_CPP_NAMESPACE::DOMElement* personXml);
-        void processTranslation(DialogElement* element, XERCES_CPP_NAMESPACE::DOMNode* translationXml);
-        void createDialogVariable(XERCES_CPP_NAMESPACE::DOMElement* variableXml, DialogPrototype* dialogPrototype);
-        void processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String&amp; nodeName, DialogPrototype* dialogPrototype);
+        void processDialog(const TiXmlElement* dialogXml);
+        DialogResponse* processResponseClasses(const TiXmlNode *node, DialogPrototype* dialogPrototype);
+        DialogResponse* processResponse(const TiXmlElement* responseXml, DialogPrototype* dialogPrototype, bool subelements);
+        DialogResponse* processSwitchResponse(const TiXmlElement* switchRespXml, DialogPrototype* dialogPrototype);
+        DialogOption* processOptionClasses(const TiXmlNode *node, DialogPrototype *dialogPrototype);
+        DialogOption* processOption(const TiXmlElement* optionXml, DialogPrototype* dialogPrototype, bool subelements);
+        DialogOption* processSwitchOption(const TiXmlElement* switchOptXml, DialogPrototype* dialogPrototype);
+        DialogCondition* processIf(const TiXmlElement *ifXml);
+        DialogCondition* processCase(const TiXmlElement *caseXml);
+        DialogVariable* processVariableClasses(const TiXmlElement* variableXml);
+        DialogCondition* processConditionClasses(const TiXmlElement* conditionXml);
+        DialogParagraph* processParagraph(const TiXmlElement* paragraphXml);
+        DialogImplication* processImplicationClasses(const TiXmlNode* implicationXml);
+        DialogParticipant* processPerson(const TiXmlElement* personXml);
+        void processTranslation(DialogElement* element, const TiXmlNode* translationXml);
+        void createDialogVariable(const TiXmlElement* variableXml, DialogPrototype* dialogPrototype);
+        void processElementNodes(const TiXmlElement* dialogXml, const Ogre::String&amp; nodeName, DialogPrototype* dialogPrototype);
 
         std::map&lt;Ogre::String, DialogPrototype*&gt; mDialogs;
 

Modified: rl/trunk/engine/ai/src/AiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiSubsystem.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ai/src/AiSubsystem.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -26,8 +26,6 @@
 #include &quot;LandmarkPath.h&quot;
 #include &quot;WayPointGraphManager.h&quot;
 
-#include &lt;xercesc/util/PlatformUtils.hpp&gt;
-
 #include &quot;XmlProcessor.h&quot;
 #include &quot;XmlResourceManager.h&quot;
 #include &quot;ContentModule.h&quot;
@@ -35,7 +33,6 @@
 
 using namespace Ogre;
 using namespace OpenSteer;
-using namespace XERCES_CPP_NAMESPACE;
 
 template&lt;&gt; rl::AiSubsystem* Singleton&lt;rl::AiSubsystem&gt;::ms_Singleton = 0;
 

Modified: rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -15,8 +15,6 @@
  */
 #include &quot;stdinc.h&quot;
 
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
 #ifdef __APPLE__
 #   include &lt;CEGUI/CEGUIPropertyHelper.h&gt;
 #else
@@ -40,7 +38,6 @@
 
 using namespace Ogre;
 using namespace std;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
@@ -64,21 +61,22 @@
 
     void DialogLoaderImpl::parseDialog(DataStreamPtr&amp; stream, const Ogre::String&amp; groupName)
     {
-        initializeXml();
-
-        DOMDocument* doc = loadDocument(stream);
+        TiXmlDocument* doc = loadDocument(stream);
         if (doc)
         {
-            DOMNodeList* dialogNodes = doc-&gt;getElementsByTagName(AutoXMLCh(&quot;dialog&quot;).data());
-
-            for (XMLSize_t i = 0; i &lt; dialogNodes-&gt;getLength(); ++i)
-            {
-                DOMNode* cur = dialogNodes-&gt;item(i);
-                processDialog(static_cast&lt;DOMElement*&gt;(cur));
-            }
+        	doc-&gt;Accept(this);
         }
+        delete doc;
+    }
 
-        shutdownXml();
+    bool DialogLoaderImpl::VisitEnter(const TiXmlElement &amp;element, const TiXmlAttribute *firstAttribute)
+    {
+    	if (element.ValueTStr() == &quot;dialog&quot;)
+    	{
+    		processDialog(&amp;element);
+    		return false;
+    	}
+    	return true;
     }
 
     Dialog* DialogLoaderImpl::createDialog(const String&amp; name, const CreatureList&amp; participants) const
@@ -94,7 +92,7 @@
         return it-&gt;second-&gt;createDialog(participants);
     }
 
-    void DialogLoaderImpl::processDialog(DOMElement* dialogElem)
+    void DialogLoaderImpl::processDialog(const TiXmlElement* dialogElem)
     {
         DialogPrototype* dialogPrototype = new DialogPrototype();
         Ogre::String name = getAttributeValueAsStdString(dialogElem, &quot;name&quot;);
@@ -106,32 +104,32 @@
         processElementNodes(dialogElem, &quot;response&quot;, dialogPrototype);
         processElementNodes(dialogElem, &quot;switchresponse&quot;, dialogPrototype);
 
-        for (DOMNode* curChild = dialogElem-&gt;getFirstChild(); curChild != NULL; curChild = curChild-&gt;getNextSibling())
+        for (const TiXmlNode* curChild = dialogElem-&gt;FirstChild(); curChild != NULL; curChild = curChild-&gt;NextSibling())
         {
             if (hasNodeName(curChild, &quot;variable&quot;))
             {
-                createDialogVariable(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
+                createDialogVariable(curChild-&gt;ToElement(), dialogPrototype);
             }
             else if (hasNodeName(curChild, &quot;option&quot;))
             {
-                processOption(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype, true);
+                processOption(curChild-&gt;ToElement(), dialogPrototype, true);
             }
             else if (hasNodeName(curChild, &quot;switchoption&quot;))
             {
-                processSwitchOption(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
+                processSwitchOption(curChild-&gt;ToElement(), dialogPrototype);
             }
             else if (hasNodeName(curChild, &quot;response&quot;))
             {
-                processResponse(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype, true);
+                processResponse(curChild-&gt;ToElement(), dialogPrototype, true);
             }
             else if (hasNodeName(curChild, &quot;switchresponse&quot;))
             {
-                processSwitchResponse(static_cast&lt;DOMElement*&gt;(curChild), dialogPrototype);
+                processSwitchResponse(curChild-&gt;ToElement(), dialogPrototype);
             }
             else if (hasNodeName(curChild, &quot;start&quot;))
             {
-                for (DOMNode* curChildChild = curChild-&gt;getFirstChild(); curChildChild != NULL;
-                     curChildChild = curChildChild-&gt;getNextSibling())
+                for (const TiXmlNode* curChildChild = curChild-&gt;FirstChild(); curChildChild != NULL;
+                     curChildChild = curChildChild-&gt;NextSibling())
                 {
                     DialogResponse* response = processResponseClasses(curChildChild, dialogPrototype);
                     if (response)
@@ -142,12 +140,12 @@
             }
             else if (hasNodeName(curChild, &quot;persons&quot;))
             {
-                for (DOMNode* curChildChild = curChild-&gt;getFirstChild(); curChildChild != NULL;
-                                     curChildChild = curChildChild-&gt;getNextSibling())
+                for (const TiXmlNode* curChildChild = curChild-&gt;FirstChild(); curChildChild != NULL;
+                                     curChildChild = curChildChild-&gt;NextSibling())
                 {
                     if (hasNodeName(curChildChild, &quot;person&quot;))
                     {
-                        dialogPrototype-&gt;addParticipant(processPerson(static_cast&lt;DOMElement*&gt;(curChildChild)));
+                        dialogPrototype-&gt;addParticipant(processPerson(curChildChild-&gt;ToElement()));
                     }
                 }
             }
@@ -155,12 +153,12 @@
         LOG_MESSAGE(Logger::AI, &quot;Processed Dialog &quot;+ name);
     }
 
-    void DialogLoaderImpl::processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String&amp; nodeName, DialogPrototype* dialogPrototype)
+    void DialogLoaderImpl::processElementNodes(const TiXmlElement* dialogXml, const Ogre::String&amp; nodeName, DialogPrototype* dialogPrototype)
     {
-        DOMNodeList* dialogElemNodes = dialogXml-&gt;getElementsByTagName(AutoXMLCh(nodeName.c_str()).data());
-        for (XMLSize_t i = 0; i &lt; dialogElemNodes-&gt;getLength(); ++i)
+        XmlElementList dialogElemNodes = getElementsByTagName(dialogXml, nodeName.c_str());
+        for (XmlElementList::iterator it = dialogElemNodes.begin(); it != dialogElemNodes.end(); ++it)
         {
-            DOMElement* dialogElemXml = static_cast&lt;DOMElement*&gt;(dialogElemNodes-&gt;item(i));
+            const TiXmlElement* dialogElemXml = *it;
             if (!hasAttribute(dialogElemXml, &quot;id&quot;))
             {
                 Throw(WrongFormatException, &quot;option/switchoption/response/switchresponse node without id found&quot;);
@@ -205,25 +203,25 @@
 
     }
 
-    DialogResponse* DialogLoaderImpl::processResponseClasses(DOMNode *node, DialogPrototype *dialogPrototype)
+    DialogResponse* DialogLoaderImpl::processResponseClasses(const TiXmlNode *node, DialogPrototype *dialogPrototype)
     {
         DialogResponse* response = NULL;
         if (hasNodeName(node, &quot;response&quot;))
         {
-            response = processResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, true);
+            response = processResponse(node-&gt;ToElement(), dialogPrototype, true);
         }
         else if (hasNodeName(node, &quot;gotoresponse&quot;))
         {
-            response = processResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, false);
+            response = processResponse(node-&gt;ToElement(), dialogPrototype, false);
         }
         else if (hasNodeName(node, &quot;switchresponse&quot;))
         {
-            response = processSwitchResponse(static_cast&lt;DOMElement*&gt;(node), dialogPrototype);
+            response = processSwitchResponse(node-&gt;ToElement(), dialogPrototype);
         }
         return response;
     }
 
-    DialogResponse* DialogLoaderImpl::processResponse(DOMElement *responseXml, DialogLoaderImpl::DialogPrototype *dialogPrototype, bool subelements)
+    DialogResponse* DialogLoaderImpl::processResponse(const TiXmlElement *responseXml, DialogLoaderImpl::DialogPrototype *dialogPrototype, bool subelements)
     {
         CeGuiString id = getAttributeValueAsString(responseXml, &quot;id&quot;);
 
@@ -232,12 +230,12 @@
         if (!response)  Throw(IllegalArgumentException, CeGuiString(&quot;No response with ID &quot;+ id).c_str());
 
         bool languageDefined = false;
-        DOMElement* defaultLanguage = NULL;
+        const TiXmlElement* defaultLanguage = NULL;
         if (subelements)
         {
             bool paragraphsDefined = false;
 
-            for (DOMNode* cur = responseXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+            for (const TiXmlNode* cur = responseXml-&gt;FirstChild(); cur != NULL; cur = cur-&gt;NextSibling())
             {
                 DialogOption* option = processOptionClasses(cur, dialogPrototype);
                 if (option)
@@ -255,13 +253,13 @@
 
                 if (hasNodeName(cur, &quot;p&quot;))
                 {
-                    response-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
+                    response-&gt;addParagraph(processParagraph(cur-&gt;ToElement()));
                     paragraphsDefined = true;
                 }
                 // process translations
                 else if (hasNodeName(cur, &quot;t&quot;))
                 {
-                    DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
+                	const TiXmlElement* translation = cur-&gt;ToElement();
                     // check loca
                     if (getAttributeValueAsStdString(translation, &quot;language&quot;)
                        == ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
@@ -278,7 +276,7 @@
                 }
                 else if (hasNodeName(cur, &quot;gotoresponse&quot;))
                 {
-                    CeGuiString id = getAttributeValueAsString(static_cast&lt;DOMElement*&gt;(cur), &quot;id&quot;);
+                    CeGuiString id = getAttributeValueAsString(cur-&gt;ToElement(), &quot;id&quot;);
                     response-&gt;addParagraph(new DialogGotoResponse(dialogPrototype-&gt;getResponse(id)));
                 }
             }
@@ -301,24 +299,24 @@
         return response;
     }
 
-    DialogResponse* DialogLoaderImpl::processSwitchResponse(XERCES_CPP_NAMESPACE::DOMElement* switchRespXml, DialogPrototype* dialogPrototype)
+    DialogResponse* DialogLoaderImpl::processSwitchResponse(const TiXmlElement* switchRespXml, DialogPrototype* dialogPrototype)
     {
         CeGuiString id = getAttributeValueAsString(switchRespXml, &quot;id&quot;);
         DialogSelection&lt;DialogResponse&gt;* response = dynamic_cast&lt;DialogSelection&lt;DialogResponse&gt;*&gt;(dialogPrototype-&gt;getResponse(id));
 
         if (!response)  Throw(IllegalArgumentException, CeGuiString(&quot;No switchresponse with ID &quot;+ id).c_str());
 
-        for (DOMNode* cur = switchRespXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        for (const TiXmlNode* cur = switchRespXml-&gt;FirstChild(); cur != NULL; cur = cur-&gt;NextSibling())
         {
-            DialogVariable* variable = processVariableClasses(static_cast&lt;DOMElement*&gt;(cur));
+            DialogVariable* variable = processVariableClasses(cur-&gt;ToElement());
             if (variable != NULL)
             {
                 response-&gt;setVariable(variable);
             }
             else if (hasNodeName(cur, &quot;case&quot;))
             {
-                DialogCondition* condition = processCase(static_cast&lt;DOMElement*&gt;(cur));
-                for (DOMNode* caseChild = cur-&gt;getFirstChild(); caseChild != NULL; caseChild = caseChild-&gt;getNextSibling())
+                DialogCondition* condition = processCase(cur-&gt;ToElement());
+                for (const TiXmlNode* caseChild = cur-&gt;FirstChild(); caseChild != NULL; caseChild = caseChild-&gt;NextSibling())
                 {
                     DialogResponse* responseCase = processResponseClasses(caseChild, dialogPrototype);
                     if (responseCase)
@@ -334,26 +332,26 @@
         return response;
     }
 
-    DialogOption* DialogLoaderImpl::processOptionClasses(DOMNode *node, DialogPrototype *dialogPrototype)
+    DialogOption* DialogLoaderImpl::processOptionClasses(const TiXmlNode *node, DialogPrototype *dialogPrototype)
     {
         DialogOption* option = NULL;
         if (hasNodeName(node, &quot;option&quot;))
         {
-            option = processOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, true);
+            option = processOption(node-&gt;ToElement(), dialogPrototype, true);
         }
         else if (hasNodeName(node, &quot;optionref&quot;))
         {
-            option = processOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype, false);
+            option = processOption(node-&gt;ToElement(), dialogPrototype, false);
         }
         else if (hasNodeName(node, &quot;switchoption&quot;))
         {
-            option = processSwitchOption(static_cast&lt;DOMElement*&gt;(node), dialogPrototype);
+            option = processSwitchOption(node-&gt;ToElement(), dialogPrototype);
         }
 
         return option;
     }
 
-    DialogOption* DialogLoaderImpl::processOption(DOMElement *optionXml, DialogLoaderImpl::DialogPrototype *dialogPrototype, bool subelements)
+    DialogOption* DialogLoaderImpl::processOption(const TiXmlElement *optionXml, DialogLoaderImpl::DialogPrototype *dialogPrototype, bool subelements)
     {
         CeGuiString id = getAttributeValueAsString(optionXml, &quot;id&quot;);
 
@@ -362,13 +360,13 @@
         if (!option)    Throw(IllegalArgumentException, CeGuiString(&quot;No option with ID &quot;+ id).c_str());
 
         bool languageDefined = false;
-        DOMElement* defaultLanguage = NULL;
+        const TiXmlElement* defaultLanguage = NULL;
 
         if (subelements)
         {
             bool paragraphsDefined = false;
 
-            for (DOMNode* cur = optionXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+            for (const TiXmlNode* cur = optionXml-&gt;FirstChild(); cur != NULL; cur = cur-&gt;NextSibling())
             {
                 DialogResponse* response = processResponseClasses(cur, dialogPrototype);
                 if (response)
@@ -377,17 +375,17 @@
                 }
                 else if (hasNodeName(cur, &quot;if&quot;))
                 {
-                    option-&gt;setPrecondition(processIf(static_cast&lt;DOMElement*&gt;(cur)));
+                    option-&gt;setPrecondition(processIf(cur-&gt;ToElement()));
                 }
                 else if (hasNodeName(cur, &quot;p&quot;))
                 {
-                    option-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
+                    option-&gt;addParagraph(processParagraph(cur-&gt;ToElement()));
                     paragraphsDefined = true;
                 }
                 // process translations
                 else if (hasNodeName(cur, &quot;t&quot;))
                 {
-                    DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
+                    const TiXmlElement* translation = cur-&gt;ToElement();
                     // check locale
                     if (getAttributeValueAsStdString(translation, &quot;language&quot;)
                        == ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
@@ -433,24 +431,24 @@
         return option;
     }
 
-    DialogOption* DialogLoaderImpl::processSwitchOption(DOMElement *switchOptXml, DialogLoaderImpl::DialogPrototype *dialogPrototype)
+    DialogOption* DialogLoaderImpl::processSwitchOption(const TiXmlElement *switchOptXml, DialogLoaderImpl::DialogPrototype *dialogPrototype)
     {
         CeGuiString id = getAttributeValueAsString(switchOptXml, &quot;id&quot;);
         DialogOptionSelection* option = dynamic_cast&lt;DialogOptionSelection*&gt;(dialogPrototype-&gt;getOption(id));
 
         if (!option) Throw(IllegalArgumentException, CeGuiString(&quot;No switchoption with ID &quot;+ id).c_str());
 
-        for (DOMNode* cur = switchOptXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        for (const TiXmlNode* cur = switchOptXml-&gt;FirstChild(); cur != NULL; cur = cur-&gt;NextSibling())
         {
-            DialogVariable* variable = processVariableClasses(static_cast&lt;DOMElement*&gt;(cur));
+            DialogVariable* variable = processVariableClasses(cur-&gt;ToElement());
             if (variable != NULL)
             {
                 option-&gt;setVariable(variable);
             }
             else if (hasNodeName(cur, &quot;case&quot;))
             {
-                DialogCondition* condition = processCase(static_cast&lt;DOMElement*&gt;(cur));
-                for (DOMNode* caseChild = cur-&gt;getFirstChild(); caseChild != NULL; caseChild = caseChild-&gt;getNextSibling())
+                DialogCondition* condition = processCase(cur-&gt;ToElement());
+                for (const TiXmlNode* caseChild = cur-&gt;FirstChild(); caseChild != NULL; caseChild = caseChild-&gt;NextSibling())
                 {
                     DialogOption* optionCase = processOptionClasses(caseChild, dialogPrototype);
                     if (optionCase)
@@ -463,7 +461,7 @@
             // process translations
             else if (hasNodeName(cur, &quot;t&quot;))
             {
-                DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
+                const TiXmlElement* translation = cur-&gt;ToElement();
                 // check loca
                 if (getAttributeValueAsStdString(translation, &quot;language&quot;) ==
                    ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
@@ -480,23 +478,23 @@
         return option;
     }
 
-    void DialogLoaderImpl::createDialogVariable(DOMElement *variableXml, DialogLoaderImpl::DialogPrototype *dialogPrototype)
+    void DialogLoaderImpl::createDialogVariable(const TiXmlElement *variableXml, DialogLoaderImpl::DialogPrototype *dialogPrototype)
     {
         XmlPropertyReader reader;
         PropertyEntry entry = reader.processProperty(variableXml);
         dialogPrototype-&gt;setProperty(entry.first, entry.second);
     }
 
-    DialogCondition* DialogLoaderImpl::processIf(DOMElement *ifXml)
+    DialogCondition* DialogLoaderImpl::processIf(const TiXmlElement *ifXml)
     {
         DialogCondition* cond = NULL;
         DialogVariable* var = NULL;
 
-        for (DOMNode* cur = ifXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        for (const TiXmlNode* cur = ifXml-&gt;FirstChild(); cur != NULL; cur = cur-&gt;NextSibling())
         {
-            if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+            if (cur-&gt;Type() == TiXmlNode::ELEMENT)
             {
-                DOMElement* curElem = static_cast&lt;DOMElement*&gt;(cur);
+                const TiXmlElement* curElem = cur-&gt;ToElement();
 
                 DialogCondition* curCond = processConditionClasses(curElem);
                 if (curCond)
@@ -516,7 +514,7 @@
         return cond;
     }
 
-    DialogParagraph* DialogLoaderImpl::processParagraph(DOMElement* paragraphXml)
+    DialogParagraph* DialogLoaderImpl::processParagraph(const TiXmlElement* paragraphXml)
     {
         Ogre::String voicefile = &quot;&quot;;
         CeGuiString person = &quot;&quot;;
@@ -531,15 +529,15 @@
         return new DialogParagraph(getValueAsString(paragraphXml), person, voicefile);
     }
 
-    DialogCondition* DialogLoaderImpl::processCase(DOMElement *caseXml)
+    DialogCondition* DialogLoaderImpl::processCase(const TiXmlElement *caseXml)
     {
         DialogCondition* cond = NULL;
 
-        for (DOMNode* cur = caseXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        for (const TiXmlNode* cur = caseXml-&gt;FirstChild(); cur != NULL; cur = cur-&gt;NextSibling())
         {
-            if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+            if (cur-&gt;Type() == TiXmlNode::ELEMENT)
             {
-                DialogCondition* curCond = processConditionClasses(static_cast&lt;DOMElement*&gt;(cur));
+                DialogCondition* curCond = processConditionClasses(cur-&gt;ToElement());
                 if (curCond)
                 {
                     cond = curCond;
@@ -695,7 +693,7 @@
             &amp;&amp; (mName.empty() || creature-&gt;getName() == mName);
     }
 
-    DialogCondition* DialogLoaderImpl::processConditionClasses(DOMElement* conditionXml)
+    DialogCondition* DialogLoaderImpl::processConditionClasses(const TiXmlElement* conditionXml)
     {
         if (hasNodeName(conditionXml, &quot;equals&quot;))
         {
@@ -732,7 +730,7 @@
         return NULL;
     }
 
-    DialogVariable* DialogLoaderImpl::processVariableClasses(DOMElement* variableXml)
+    DialogVariable* DialogLoaderImpl::processVariableClasses(const TiXmlElement* variableXml)
     {
         if (hasNodeName(variableXml, &quot;dialogvariable&quot;))
         {
@@ -776,11 +774,11 @@
     }
 
 
-    DialogImplication* DialogLoaderImpl::processImplicationClasses(DOMNode* implicationXml)
+    DialogImplication* DialogLoaderImpl::processImplicationClasses(const TiXmlNode* implicationXml)
     {
-        if (implicationXml-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+        if (implicationXml-&gt;Type() == TiXmlNode::ELEMENT)
         {
-            DOMElement* implicationElem = static_cast&lt;DOMElement*&gt;(implicationXml);
+        	const TiXmlElement* implicationElem = implicationXml-&gt;ToElement();
 
             if (hasNodeName(implicationElem, &quot;setvariable&quot;))
             {
@@ -826,18 +824,18 @@
         return NULL;
     }
 
-    void DialogLoaderImpl::processTranslation(DialogElement* element, DOMNode* translationXml)
+    void DialogLoaderImpl::processTranslation(DialogElement* element, const TiXmlNode* translationXml)
     {
-        for (DOMNode* cur = translationXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        for (const TiXmlNode* cur = translationXml-&gt;FirstChild(); cur != NULL; cur = cur-&gt;NextSibling())
         {
             if (hasNodeName(cur, &quot;p&quot;))
             {
-                element-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
+                element-&gt;addParagraph(processParagraph(cur-&gt;ToElement()));
             }
         }
     }
 
-    DialogLoaderImpl::DialogParticipant* DialogLoaderImpl::processPerson(DOMElement* personXml)
+    DialogLoaderImpl::DialogParticipant* DialogLoaderImpl::processPerson(const TiXmlElement* personXml)
     {
         CeGuiString personId(&quot;&quot;), goClass(&quot;&quot;), name(&quot;&quot;);
         int goId = -1;

Modified: rl/trunk/engine/ai/src/DialogManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogManager.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ai/src/DialogManager.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,7 +17,6 @@
 
 #include &quot;DialogManager.h&quot;
 
-
 #include &quot;Creature.h&quot;
 #include &quot;Dialog.h&quot;
 #include &quot;DialogLoader.h&quot;
@@ -27,7 +26,6 @@
 
 using namespace Ogre;
 using namespace std;
-using namespace XERCES_CPP_NAMESPACE;
 
 template&lt;&gt;
     rl::DialogManager* Ogre::Singleton&lt;rl::DialogManager&gt;::ms_Singleton = NULL;

Modified: rl/trunk/engine/ai/src/WayPointGraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraph.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ai/src/WayPointGraph.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -18,7 +18,6 @@
 #include &quot;WayPointGraph.h&quot;
 
 #include &lt;algorithm&gt;
-#include &lt;xercesc/dom/DOM.hpp&gt;
 
 #include &quot;ConfigurationManager.h&quot;
 #include &quot;ContentModule.h&quot;
@@ -97,29 +96,24 @@
 
 void WayPointGraph::load(const Ogre::String&amp; filename, const Ogre::String&amp; resourceGroup)
 {
-    using namespace XERCES_CPP_NAMESPACE;
-
     Ogre::String group = resourceGroup;
     if (group.empty())
     {
         group = CoreSubsystem::getSingleton().getActiveAdventureModule()-&gt;getId();
     }
 
-    initializeXml();
-
-    DOMDocument* doc = loadDocument(filename, group);
+    TiXmlDocument* doc = loadDocument(filename, group);
     if (doc)
     {
-        DOMElement* rootElem = doc-&gt;getDocumentElement();
+        TiXmlElement* rootElem = doc-&gt;RootElement();
 
-        DOMElement* nodesElem = getChildNamed(rootElem, &quot;waypointnodes&quot;);
+        TiXmlElement* nodesElem = getChildNamed(rootElem, &quot;waypointnodes&quot;);
         std::map&lt;int, WayPointNode*&gt; lookupTable;
-        for (DOMNode* curNode = nodesElem-&gt;getFirstChild(); curNode; curNode = curNode-&gt;getNextSibling())
+        for (TiXmlNode* curNode = nodesElem-&gt;FirstChild(); curNode; curNode = curNode-&gt;NextSibling())
         {
-            if (curNode-&gt;getNodeType() == DOMNode::ELEMENT_NODE
-                || hasNodeName(curNode, &quot;node&quot;))
+            if (curNode-&gt;Type() == TiXmlNode::ELEMENT || hasNodeName(curNode, &quot;node&quot;))
             {
-                DOMElement* curElem = static_cast&lt;DOMElement*&gt;(curNode);
+                TiXmlElement* curElem = static_cast&lt;TiXmlElement*&gt;(curNode);
 
                 Vector3 pos = getValueAsVector3(curElem);
                 CeGuiString typeS = getAttributeValueAsString(curElem, &quot;type&quot;);
@@ -140,21 +134,18 @@
             }
         }
 
-        DOMElement* edgesElem = getChildNamed(rootElem, &quot;waypointedges&quot;);
-        for (DOMNode* curNode = edgesElem-&gt;getFirstChild(); curNode; curNode = curNode-&gt;getNextSibling())
+        TiXmlElement* edgesElem = getChildNamed(rootElem, &quot;waypointedges&quot;);
+        for (TiXmlNode* curNode = edgesElem-&gt;FirstChild(); curNode; curNode = curNode-&gt;NextSibling())
         {
-            if (curNode-&gt;getNodeType() == DOMNode::ELEMENT_NODE
-                || hasNodeName(curNode, &quot;edge&quot;))
+            if (curNode-&gt;Type() == TiXmlNode::ELEMENT || hasNodeName(curNode, &quot;edge&quot;))
             {
-                DOMElement* curElem = static_cast&lt;DOMElement*&gt;(curNode);
+                TiXmlElement* curElem = static_cast&lt;TiXmlElement*&gt;(curNode);
                 int source = getAttributeValueAsInteger(curElem, &quot;source&quot;);
                 int destination = getAttributeValueAsInteger(curElem, &quot;destination&quot;);
                 addDirectedConnection(lookupTable[source], lookupTable[destination]);
             }
         }
     }
-
-    shutdownXml();
 }
 
 const WayPointNode* WayPointGraph::getNearestWayPoint(const Vector3&amp; position) const

Modified: rl/trunk/engine/common/CMakeLists.txt
===================================================================
--- rl/trunk/engine/common/CMakeLists.txt	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/CMakeLists.txt	2009-11-07 19:39:22 UTC (rev 4961)
@@ -1,6 +1,6 @@
 INCLUDE_DIRECTORIES(
 ${CMAKE_CURRENT_SOURCE_DIR}/include
-${XERCESC_INCLUDE_DIR}
+${TINYXML_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS})
 
@@ -11,12 +11,10 @@
 src/GameTask.cpp
 src/Logger.cpp
 src/MathUtil.cpp
-src/OgreXercesInput.cpp
 src/Properties.cpp
 src/Property.cpp
 src/ScriptWrapper.cpp
 src/WriteableDataStream.cpp
-src/WriteableDataStreamFormatTarget.cpp
 src/WriteableFileSystemArchiv.cpp
 src/XmlProcessor.cpp
 src/XmlPropertyReader.cpp
@@ -26,7 +24,7 @@
 
 ADD_LIBRARY(RlCommon SHARED ${RlCommon_LIB_SRCS})
 
-TARGET_LINK_LIBRARIES(RlCommon ${XERCESC_LIBRARIES} ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES} ${Boost_FILESYSTEM_LIBRARY})
+TARGET_LINK_LIBRARIES(RlCommon ${TINYXML_LIBRARY} ${OGRE_LIBRARIES} ${CEGUI_LIBRARIES} ${Boost_FILESYSTEM_LIBRARY})
 
 SET_TARGET_PROPERTIES(RlCommon PROPERTIES
 	VERSION ${RL_MAJOR_VERSION}.${RL_MINOR_VERSION}.${RL_PATCH_VERSION}

Modified: rl/trunk/engine/common/include/CommonPrerequisites.h
===================================================================
--- rl/trunk/engine/common/include/CommonPrerequisites.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/include/CommonPrerequisites.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -33,7 +33,6 @@
 #	endif
 #endif
 
-
 #undef _assert
 
 #undef max

Deleted: rl/trunk/engine/common/include/OgreXercesInput.h
===================================================================
--- rl/trunk/engine/common/include/OgreXercesInput.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/include/OgreXercesInput.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -1,55 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#ifndef __OgreXercesInput_H__
-#define __OgreXercesInput_H__
-
-#pragma warning (push)
-#pragma warning (disable : 4244)
-#include &lt;xercesc/sax/InputSource.hpp&gt;
-#include &lt;xercesc/util/BinInputStream.hpp&gt;
-#pragma warning (pop)
-
-#include &quot;CommonPrerequisites.h&quot;
-
-
-namespace rl {
-
-    class _RlCommonExport OgreBinInputStream : public XERCES_CPP_NAMESPACE::BinInputStream
-    {
-    public:
-        OgreBinInputStream(const Ogre::DataStreamPtr&amp; stream);
-
-        virtual unsigned int curPos() const;
-        virtual unsigned int readBytes(XMLByte* const toFill, const unsigned int maxToRead);
-
-    private:
-        Ogre::DataStreamPtr mStream;
-    };
-
-    class _RlCommonExport OgreInputSource : public XERCES_CPP_NAMESPACE::InputSource
-    {
-    public:
-        OgreInputSource(const Ogre::DataStreamPtr&amp; stream);
-
-        virtual XERCES_CPP_NAMESPACE::BinInputStream* makeStream() const;
-
-    private:
-        Ogre::DataStreamPtr mStream;
-    };
-}
-
-#endif //__OgreXercesInput_H__

Modified: rl/trunk/engine/common/include/RastullahPrerequisites.h
===================================================================
--- rl/trunk/engine/common/include/RastullahPrerequisites.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/include/RastullahPrerequisites.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -59,4 +59,6 @@
 #    endif
 #endif
 
+#define TIXML_USE_STL 1  // Let TinyXML use STL strings
+
 #endif

Deleted: rl/trunk/engine/common/include/WriteableDataStreamFormatTarget.h
===================================================================
--- rl/trunk/engine/common/include/WriteableDataStreamFormatTarget.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/include/WriteableDataStreamFormatTarget.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -1,33 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-
-#include &lt;xercesc/framework/XMLFormatter.hpp&gt;
-#include &quot;WriteableDataStream.h&quot;
-
-namespace rl
-{
-    class WriteableDataStreamFormatTarget : public XERCES_CPP_NAMESPACE::XMLFormatTarget
-    {
-    public:
-        WriteableDataStreamFormatTarget(WriteableDataStreamPtr stream);
-        void writeChars (const XMLByte *const toWrite, const unsigned int count, XERCES_CPP_NAMESPACE::XMLFormatter *const formatter);
-        void flush ();
-    protected:
-        WriteableDataStreamPtr mStream;
-    };
-}
-

Modified: rl/trunk/engine/common/include/XmlProcessor.h
===================================================================
--- rl/trunk/engine/common/include/XmlProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/include/XmlProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,62 +17,48 @@
 #ifndef __XmlHelper_h__
 #define __XmlHelper_h__
 
-#include &lt;xercesc/dom/DOM.hpp&gt;
-#include &lt;xercesc/util/XMLChar.hpp&gt;
-#include &lt;xercesc/util/TransService.hpp&gt;
-#include &lt;xercesc/sax/ErrorHandler.hpp&gt;
-#include &lt;xercesc/sax2/Attributes.hpp&gt;
-
-namespace XERCES_CPP_NAMESPACE
-{
-    class SAXParseException;
-}
-
 #include &quot;CommonPrerequisites.h&quot;
 
+#include &lt;tinyxml.h&gt;
+
 #include &quot;Tripel.h&quot;
 
-// Da sollten wir uns auf etwas einigen
-// So ist das laestig.
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-#   pragma warning (push)
-#   pragma warning (disable : 4267)
-#   include &lt;CEGUIString.h&gt;
-#   pragma warning (pop)
-#else
-#   include &lt;CEGUI/CEGUIString.h&gt;
-#endif
-namespace XERCES_CPP_NAMESPACE
-{
-    class XercesDOMParser;
-}
-
 namespace rl {
 
+typedef std::vector&lt;const TiXmlElement*&gt; XmlElementList;
+
 /**
  * This class offers helper methods for XML processing
  * To use this methods, just inherit this class privately 
  */
 class _RlCommonExport XmlProcessor
-    : public XERCES_CPP_NAMESPACE::ErrorHandler
 {
 public:
-    XmlProcessor() : mOpenParser(NULL) {}
+    XmlProcessor() {}
 
     /**
 	 * Erzeugt einen Kindknoten eines DOM-Elements, das einen bestimmten Namen hat, 
 	 * dieser ist wiederum ein Element-Knoten
 	 *
-     * @param doc Das DOM-Document
 	 * @param parent Knoten, dessen Kind erzeugt wird
 	 * @param name Name des Kindknotens von parent
 	 *
 	 * @return Der Kindknoten
 	 */
-    XERCES_CPP_NAMESPACE::DOMElement* appendChildElement(XERCES_CPP_NAMESPACE::DOMDocument* doc, 
-        XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name) const;
+    TiXmlElement* appendChildElement(TiXmlElement* parent, const char* const name) const;
 
     /**
+	 * Erzeugt einen Kindknoten des Roots eines DOM-Dokuments, das einen bestimmten Namen hat,
+	 * dieser ist wiederum ein Element-Knoten
+	 *
+	 * @param parent Dokument
+	 * @param name Name des Kindknotens von parent
+	 *
+	 * @return Der Kindknoten
+	 */
+    TiXmlElement* appendChildElement(TiXmlDocument* parent, const char* const name) const;
+
+    /**
 	 * Ermittelt einen Kindknoten eines DOM-Elements, das einen bestimmten Namen hat, 
 	 * dieser ist wiederum ein Element-Knoten
 	 *
@@ -81,16 +67,47 @@
 	 *
 	 * @return Der Kindknoten
 	 */
-	XERCES_CPP_NAMESPACE::DOMElement* getChildNamed(XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name) const;
+    const TiXmlElement* getChildNamed(const TiXmlElement* parent, const char* const name) const;
+
+    /**
+	 * Ermittelt einen Kindknoten eines DOM-Elements, das einen bestimmten Namen hat,
+	 * dieser ist wiederum ein Element-Knoten
+	 *
+	 * @param parent Knoten, dessen Kinder gesucht sind
+	 * @param name Name des gesuchten Kindknotens von parent
+	 *
+	 * @return Der Kindknoten
+	 */
+    TiXmlElement* getChildNamed(TiXmlElement* parent, const char* const name) const;
+
+    /**
+     * Collects all element nodes with a specified tag name
+	 *
+	 * @param parent start node
+	 * @param name node name to search
+	 *
+	 * @return vector of found element nodes
+     */
+    XmlElementList getElementsByTagName(const TiXmlElement* parent, const char* const name) const;
 	
     /**
+     * Collects all element nodes with a specified tag name
+	 *
+	 * @param parent start node
+	 * @param name node name to search
+	 *
+	 * @return vector of found element nodes
+     */
+    XmlElementList getElementsByTagName(const TiXmlDocument* parent, const char* const name) const;
+
+    /**
 	 * Setzt den Text eines Elementknotens
 	 *
 	 * @param element the DOM element node
      * @param string Der zu setzende String
 	 * @return the DOM element node
 	 */
-    void setValueAsString(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, const CeGuiString &amp;value) const;
+    void setValueAsString(TiXmlElement* element, const CeGuiString &amp;value) const;
     
     /**
 	 * Ermittelt den Text eines Elementknotens
@@ -98,7 +115,7 @@
 	 * @param element the DOM element node
 	 * @return Text innerhalb der Element-Tags, als CeGuiString
 	 */
-	CeGuiString getValueAsString(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+	CeGuiString getValueAsString(const TiXmlElement* element) const;
 	
     /**
 	 * Ermittelt den Text eines Elementknotens
@@ -106,7 +123,7 @@
 	 * @param element the DOM element node
 	 * @return Text innerhalb der Element-Tags, als CeGuiString
 	 */
-    std::string getValueAsStdString(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+    std::string getValueAsStdString(const TiXmlElement* element) const;
 
     /**
 	 * Setzt den Text eines Elementknotens, als UTF-8
@@ -116,17 +133,17 @@
      * @param utf Der zu setzende UTF String
 	 * @return the DOM element node
 	 */
-	void setValueAsUtf8(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, CEGUI::utf8* value) const;
+	void setValueAsUtf8(TiXmlElement* element, CEGUI::utf8* value) const;
     
     /**
 	 * Ermittelt den Text eines Elementknotens, als UTF-8
 	 * vor Benutzung muss initializeTranscoder() aufgerufen werden
 	 *
 	 * @param element the DOM element node
-	 * @return Text innerhalb der Element-Tags, als utf8* (muss selbst gel&#246;scht werden)
+	 * @return Text innerhalb der Element-Tags, als utf8* (muss selbst gel&#239;&#191;&#189;scht werden)
 	 * @see initializeTranscoder()
 	 */
-	CEGUI::utf8* getValueAsUtf8(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+	const CEGUI::utf8* getValueAsUtf8(const TiXmlElement* element) const;
 
 	
     /**
@@ -136,7 +153,7 @@
      * @param value Der zu setzende Bool
 	 * @return the DOM element node
 	 */
-	void setValueAsBool(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, bool value) const;
+	void setValueAsBool(TiXmlElement* element, bool value) const;
 
     
     /**
@@ -145,7 +162,7 @@
 	 * @param element the DOM element node
 	 * @return boolean within the element tags
 	 */
-	bool getValueAsBool(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+	bool getValueAsBool(const TiXmlElement* element) const;
     
     
     /**
@@ -155,7 +172,7 @@
      * @param value Der zu setzende Integer
 	 * @return the DOM element node
 	 */
-	void setValueAsInteger(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, int value) const;
+	void setValueAsInteger(TiXmlElement* element, int value) const;
 
     
     /**
@@ -164,7 +181,7 @@
 	 * @param element the DOM element node
 	 * @return number within the element tags
 	 */
-	int getValueAsInteger(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+	int getValueAsInteger(const TiXmlElement* element) const;
 
     /**
 	 * Get the text value of an element node and parse it into a real number
@@ -172,7 +189,7 @@
 	 * @param element the DOM element node
 	 * @return number within the element tags
 	 */
-    Ogre::Real getValueAsReal(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+    Ogre::Real getValueAsReal(const TiXmlElement* element) const;
 
     /**
 	 * Convert an integer pair into a string and sets it as the text of a DOM element
@@ -181,7 +198,7 @@
      * @param value the integer pair
 	 * @return the DOM element node
 	 */
-    void setValueAsIntegerPair(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, IntPair value) const;
+    void setValueAsIntegerPair(TiXmlElement* element, IntPair value) const;
 
     /**
 	 * Get the text value of an element node and parse it into an integer pair
@@ -189,7 +206,7 @@
 	 * @param element the DOM element node
 	 * @return pair within the element tags
 	 */
-    IntPair getValueAsIntegerPair(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+    IntPair getValueAsIntegerPair(const TiXmlElement* element) const;
 
     /**
 	 * Convert an integer triple into a string and set is as the text of a DOM element
@@ -198,7 +215,7 @@
      * @param value the integer triple
 	 * @return the DOM element node
 	 */
-    void setValueAsIntegerTriple(XERCES_CPP_NAMESPACE::DOMDocument* doc, XERCES_CPP_NAMESPACE::DOMElement* element, Tripel&lt;int&gt; value) const;
+    void setValueAsIntegerTriple(TiXmlElement* element, Tripel&lt;int&gt; value) const;
 
     /**
 	 * Get the text value of an element node and parse it into an integer triple
@@ -206,7 +223,7 @@
 	 * @param element the DOM element node
 	 * @return triple within the element tags
 	 */
-    Tripel&lt;int&gt; getValueAsIntegerTriple(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+    Tripel&lt;int&gt; getValueAsIntegerTriple(const TiXmlElement* element) const;
 	
     /**
      * Convert a vector3 to an xml tag
@@ -215,7 +232,7 @@
      * @param value The vector input
 	 * @return The DOM element
 	 */
-    void setValueAsVector3(XERCES_CPP_NAMESPACE::DOMElement* element, Ogre::Vector3 value) const;
+    void setValueAsVector3(TiXmlElement* element, Ogre::Vector3 value) const;
 
     /**
 	 * Processes an element node of shape &lt;any_node_name x=&quot;0&quot; y=&quot;0&quot; z=&quot;0&quot;/&gt;
@@ -224,7 +241,7 @@
 	 * @param element The DOM element
 	 * @return the vector
 	 */
-	Ogre::Vector3 getValueAsVector3(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+	Ogre::Vector3 getValueAsVector3(const TiXmlElement* element) const;
 
     /**
      * Convert a quaternion to an xml tag
@@ -233,7 +250,7 @@
      * @param value The quaternion input
 	 * @return The DOM element
 	 */
-    void setValueAsQuaternion(XERCES_CPP_NAMESPACE::DOMElement* element, Ogre::Quaternion value) const;
+    void setValueAsQuaternion(TiXmlElement* element, Ogre::Quaternion value) const;
 
     /**
 	 * Processes an element node of shape &lt;any_node_name x=&quot;0&quot; y=&quot;0&quot; z=&quot;0&quot; w=&quot;1&quot;/&gt;
@@ -242,7 +259,7 @@
 	 * @param element The DOM element
 	 * @return the quaternion
 	 */
-    Ogre::Quaternion getValueAsQuaternion(XERCES_CPP_NAMESPACE::DOMElement* element) const;
+    Ogre::Quaternion getValueAsQuaternion(const TiXmlElement* element) const;
 
 	
     /**
@@ -252,7 +269,7 @@
 	 * @param name Name des Attributes
 	 * @return &lt;code&gt;true&lt;/code&gt;, wenn das Attribut an diesem Element existiert, sonst &lt;code&gt;false&lt;/code&gt;
 	 */
-	bool hasAttribute(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+	bool hasAttribute(const TiXmlElement* element, const char* const name) const;
 
     /**
 	 * Setzt den Wert von einem Attribut eines Elementes
@@ -262,7 +279,7 @@
      * @param value Wert der gesetzt werden muss
 	 * @return &lt;code&gt;true&lt;/code&gt;, wenn das Attribut an diesem Element existiert, sonst &lt;code&gt;false&lt;/code&gt;
 	 */
-    void setAttribute(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, const char* const value) const;
+    void setAttribute(TiXmlElement* element, const char* const name, const char* const value) const;
 
     /**
 	 * Checks whether a DOMNode has a certain name
@@ -271,7 +288,7 @@
 	 * @param name the name to check
 	 * @return &lt;code&gt;true&lt;/code&gt;, if the DOM node the name &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise
 	 */
-	bool hasNodeName(XERCES_CPP_NAMESPACE::DOMNode* node, const char* const name) const;
+	bool hasNodeName(const TiXmlNode* node, const char* const name) const;
 
     
     /**
@@ -282,7 +299,7 @@
      * @param value das zu setzende Integer
 	 * @return the DOM element node
 	 */
-	void setAttributeValueAsInteger(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, int value) const;
+	void setAttributeValueAsInteger(TiXmlElement* element, const char* const name, int value) const;
 
     /**
 	 * Ermittelt den Text eines DOMElement-Attributes und parst ihn, 
@@ -292,7 +309,7 @@
 	 * @param name Name des Attributes
      * @return Zahlenwert des Attributes
 	 */
-	int getAttributeValueAsInteger(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+	int getAttributeValueAsInteger(const TiXmlElement* element, const char* const name) const;
 
     /**
 	 * Converts a 64 bit integer (long long) into a string and sets it as the text of a DOM element attribute
@@ -300,7 +317,7 @@
 	 * @param element the DOM element node
 	 * @return number within the element tags
 	 */
-	void setAttributeValueAsInt64(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, RL_LONGLONG value) const;
+	void setAttributeValueAsInt64(TiXmlElement* element, const char* const name, RL_LONGLONG value) const;
 
     /**
 	 * Gets the text value of an element attribute and parse it into a 64 bit integer (long long) 
@@ -308,7 +325,7 @@
 	 * @param element the DOM element node
 	 * @return number within the element tags
 	 */
-	RL_LONGLONG getAttributeValueAsInt64(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+	RL_LONGLONG getAttributeValueAsInt64(const TiXmlElement* element, const char* const name) const;
 
     /**
 	 * Wandelt eine Ganzzahldubel in einen Text um und setzt diesen als Attribut 
@@ -318,7 +335,7 @@
      * @param value das zu setzende IntegerPair
 	 * @return the DOM element node
 	 */
-    void setAttributeValueAsIntegerPair(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, IntPair value) const;
+    void setAttributeValueAsIntegerPair(TiXmlElement* element, const char* const name, IntPair value) const;
 
     /**
 	 * Ermittelt den Text eines DOMElement-Attributes und parst ihn, 
@@ -328,7 +345,7 @@
 	 * @param name Name des Attributes
      * @return Zahlendubel des Attributes
 	 */
-    IntPair getAttributeValueAsIntegerPair(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+    IntPair getAttributeValueAsIntegerPair(const TiXmlElement* element, const char* const name) const;
 
     /**
 	 * Wandelt eine Ganzzahltripel in einen Text um und setzt diesen als Attribut 
@@ -338,7 +355,7 @@
      * @param value das zu setzende Tripel&lt;int&gt;
 	 * @return the DOM element node
 	 */
-    void setAttributeValueAsIntegerTriple(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, Tripel&lt;int&gt; value) const;
+    void setAttributeValueAsIntegerTriple(TiXmlElement* element, const char* const name, Tripel&lt;int&gt; value) const;
 
     /**
 	 * Ermittelt den Text eines DOMElement-Attributes und parst ihn, 
@@ -348,7 +365,7 @@
 	 * @param name Name des Attributes
      * @return Zahlentripel des Attributes
 	 */
-    Tripel&lt;int&gt; getAttributeValueAsIntegerTriple(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+    Tripel&lt;int&gt; getAttributeValueAsIntegerTriple(const TiXmlElement* element, const char* const name) const;
 	
 	
     /**
@@ -359,7 +376,7 @@
      * @param value das zu setzende Vector3
 	 * @return the DOM element node
 	 */
-    void setAttributeValueAsVector3(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, Ogre::Vector3 value) const;
+    void setAttributeValueAsVector3(TiXmlElement* element, const char* const name, Ogre::Vector3 value) const;
 
     /**
 	 * Ermittelt den Text eines DOMElement-Attributes und parst ihn, 
@@ -369,7 +386,7 @@
 	 * @param name Name des Attributes
      * @return Vector3 des Attributes
 	 */
-    Ogre::Vector3 getAttributeValueAsVector3(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+    Ogre::Vector3 getAttributeValueAsVector3(const TiXmlElement* element, const char* const name) const;
 
     /**
 	 * Wandelt eine Quaternion in einen Text um und setzt diesen als Attribut 
@@ -379,7 +396,7 @@
      * @param value das zu setzende Quaternion
 	 * @return the DOM element node
 	 */
-    void setAttributeValueAsQuaternion(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, Ogre::Quaternion value) const;
+    void setAttributeValueAsQuaternion(TiXmlElement* element, const char* const name, Ogre::Quaternion value) const;
 
     /**
 	 * Ermittelt den Text eines DOMElement-Attributes und parst ihn, 
@@ -389,7 +406,7 @@
 	 * @param name Name des Attributes
      * @return Quaternion des Attributes
 	 */
-    Ogre::Quaternion getAttributeValueAsQuaternion(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+    Ogre::Quaternion getAttributeValueAsQuaternion(const TiXmlElement* element, const char* const name) const;
     
 
     /**
@@ -400,7 +417,7 @@
 	 * @param value das zu setzende CeGuiString
 	 * @return the DOM element node
 	 */	
-	void setAttributeValueAsString(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, const CeGuiString &amp;value) const;
+	void setAttributeValueAsString(TiXmlElement* element, const char* const name, const CeGuiString &amp;value) const;
     
     /**
 	 * Ermittelt den Text eines DOMElement-Attributes und konvertiert ihn zu einem CeGuiString
@@ -409,7 +426,7 @@
 	 * @param name Name des Attributes
 	 * @return Konvertierter Text als CeGuiString
 	 */	
-	CeGuiString getAttributeValueAsString(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+	CeGuiString getAttributeValueAsString(const TiXmlElement* element, const char* const name) const;
 
     /**
 	 * Setzt den Text eines DOMElement-Attributes
@@ -419,7 +436,7 @@
 	 * @param value der zu setzende std::string
 	 * @return the DOM element node
 	 */	
-    void setAttributeValueAsStdString(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, const std::string &amp;value) const;
+    void setAttributeValueAsStdString(TiXmlElement* element, const char* const name, const std::string &amp;value) const;
 
 	/**
 	 * Ermittelt den Text eines DOMElement-Attributes und konvertiert ihn zu einem std::string
@@ -428,18 +445,9 @@
 	 * @param name Name des Attributes
 	 * @return Konvertierter Text als std::string
 	 */	
-    std::string getAttributeValueAsStdString(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+    std::string getAttributeValueAsStdString(const TiXmlElement* element, const char* const name) const;
 	
     /**
-	 * Ermittelt den Text eines SAX Element-Attributes und konvertiert ihn zu einem CeGuiString
-	 *
-	 * @param element Liste aller Attribute des aktuellen Elementes
-	 * @param name Name des Attributes
-	 * @return Konvertierter Text als CeGuiString
-	 */
-	CeGuiString getAttributeValueAsString(const XERCES_CPP_NAMESPACE::Attributes&amp; attributes, const char* const name) const;
-
-    /**
 	 * Setzt den Text eines DOMElement-Attributes
 	 * 
 	 * @param element the DOM element node
@@ -447,7 +455,7 @@
 	 * @param value der zu setzende boolean
 	 * @return the DOM element node
 	 */	
-	void setAttributeValueAsBool(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, bool value) const;
+	void setAttributeValueAsBool(TiXmlElement* element, const char* const name, bool value) const;
 
 	/**
 	 * Ermittelt den Text eines DOMElement-Attributes und interpretier ihn als bool
@@ -456,7 +464,7 @@
 	 * @param name Name des Attributes
 	 * @return Konvertierter Text als bool
 	 */	
-	bool getAttributeValueAsBool(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+	bool getAttributeValueAsBool(const TiXmlElement* element, const char* const name) const;
 
     /**
 	 * Setzt den Text eines DOMElement-Attributes
@@ -466,7 +474,7 @@
 	 * @param value der zu setzende Real Wert
 	 * @return the DOM element node
 	 */	
-    void setAttributeValueAsReal(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name, Ogre::Real value) const;
+    void setAttributeValueAsReal(TiXmlElement* element, const char* const name, Ogre::Real value) const;
 
 	/**
 	 * Ermittelt den Text eines DOMElement-Attributes und konvertiert ihn zu Ogre::Real
@@ -475,148 +483,20 @@
 	 * @param name Name des Attributes
 	 * @return Konvertierter Text als Ogre::Real
 	 */	
-	Ogre::Real getAttributeValueAsReal(XERCES_CPP_NAMESPACE::DOMElement* element, const char* const name) const;
+	Ogre::Real getAttributeValueAsReal(const TiXmlElement* element, const char* const name) const;
 
 
-	/**
-	 * Initialisiert den XML&lt;-&gt;UTF-8 Transcoder, 
-	 * davor muss XMLPlatformUtils::Initialize() aufgerufen worden sein
-	 */
-	void initializeTranscoder();
-
-	/**
-	 * Konvertiert einen Xerces-XMLCh* in eine CeGuiString
-	 * Intern wird eine Konvertierung in utf8* vorgenommen,
-	 * wobei man sich hier um das nachtr&#228;gliche aufr&#228;umen 
-	 * nicht mehr zu k&#252;mmern braucht.
-	 * 
-	 * @param string16 Der zu konvertierende Xerces-XMLCh*
-	 * @return Konvertierter Text als CeGuiString
-	 * @see transcodeToUtf8(const XMLCh* const string16) const;
-	 */
-	CeGuiString transcodeToString(const XMLCh* const string16) const;
-
-	std::string transcodeToStdString(const XMLCh* const string16) const;
-
-    XERCES_CPP_NAMESPACE::DOMDocument* loadDocument(
+	TiXmlDocument* loadDocument(
         const Ogre::String&amp; resourceName, const Ogre::String&amp; resourceGroup = &quot;&quot;);
-    XERCES_CPP_NAMESPACE::DOMDocument* loadDocument(
+	TiXmlDocument* loadDocument(
         const Ogre::DataStreamPtr&amp; stream);
 
-    void initializeXml();
-    void shutdownXml();
-
-        virtual void warning(const XERCES_CPP_NAMESPACE::SAXParseException&amp; exc);
-        virtual void error(const XERCES_CPP_NAMESPACE::SAXParseException&amp; exc);
-        virtual void fatalError(const XERCES_CPP_NAMESPACE::SAXParseException&amp; exc);
-        virtual void resetErrors();
-
 protected:
-	static XERCES_CPP_NAMESPACE::XMLTranscoder* sTranscoder;
-	static XERCES_CPP_NAMESPACE::XMLTransService::Codes sFailCode;
+    std::string mOpenXmlFileName;
 
-        std::string toString( const std::string&amp; type,
-                              const XERCES_CPP_NAMESPACE::SAXParseException&amp; exc ) const;
-        
-        std::string mOpenXmlFileName;
-        XERCES_CPP_NAMESPACE::XercesDOMParser *mOpenParser;
-
-	/**
-	 * Konvertiert ein Xerces-XMLCh* in einen UTF-8-String
-	 * Vor Benutzung muss initializeTranscoder() aufgerufen werden
-	 *
-	 * @param string16 Der zu konvertierende Xerces-XMLCh*
-	 * @return Konvertierter Text als utf8* (muss selbst gel&#246;scht werden)
-	 * @see initializeTranscoder()
-	 */
-	CEGUI::utf8* transcodeToUtf8(const XMLCh* const string16) const;
-};
-
-class _RlCommonExport AutoXMLCh
-{
-public:
-    AutoXMLCh() : mData(0) { }
-
-    AutoXMLCh(const char* rhs) : mData(0)
-    {
-        mData = XERCES_CPP_NAMESPACE::XMLString::transcode(rhs);
-    }
-
-    AutoXMLCh(const AutoXMLCh&amp; rhs) : mData(0)
-    {
-        mData = XERCES_CPP_NAMESPACE::XMLString::replicate(rhs.mData);
-    }
-
-    ~AutoXMLCh()
-    {
-        XERCES_CPP_NAMESPACE::XMLString::release(&amp;mData);
-    }
-
-    const AutoXMLCh&amp; operator=(const AutoXMLCh&amp; rhs)
-    {
-        if (mData != NULL)
-        {
-            XERCES_CPP_NAMESPACE::XMLString::release(&amp;mData);
-        }
-        mData = XERCES_CPP_NAMESPACE::XMLString::replicate(rhs.mData);
-        return *this;
-    }
-
-    const AutoXMLCh&amp; operator=(const char* rhs)
-    {
-        if (mData != NULL)
-        {
-            XERCES_CPP_NAMESPACE::XMLString::release(&amp;mData);
-        }
-        mData = XERCES_CPP_NAMESPACE::XMLString::transcode(rhs);
-        return *this;
-    }
-
-    XMLCh* data() const { return mData; }
 private:
-    XMLCh* mData;
-};
+    TiXmlDocument* parseToXmlDocument(const char* content) const;
 
-class _RlCommonExport AutoChar
-{
-public:
-    AutoChar() : mData(0) { }
-
-    AutoChar(const XMLCh* str) : mData(0)
-    {
-        mData = XERCES_CPP_NAMESPACE::XMLString::transcode(str);
-    }
-
-    AutoChar(const AutoChar&amp; rhs) : mData(0)
-    {
-        mData = XERCES_CPP_NAMESPACE::XMLString::replicate(rhs.mData);
-    }
-
-    ~AutoChar()
-    {
-        XERCES_CPP_NAMESPACE::XMLString::release(&amp;mData);
-    }
-
-    const AutoChar&amp; operator=(const AutoChar&amp; rhs)
-    {
-        XERCES_CPP_NAMESPACE::XMLString::release(&amp;mData);
-        mData = XERCES_CPP_NAMESPACE::XMLString::replicate(rhs.mData);
-        return *this;
-    }
-
-    const AutoChar&amp; operator=(XMLCh* rhs)
-    {
-        if (mData != NULL)
-        {
-            XERCES_CPP_NAMESPACE::XMLString::release(&amp;mData);
-        }
-        mData = XERCES_CPP_NAMESPACE::XMLString::transcode(rhs);
-        return *this;
-    }
-
-    char* data() const { return mData; }
-private:
-    char* mData;
 };
 
 }

Modified: rl/trunk/engine/common/include/XmlPropertyReader.h
===================================================================
--- rl/trunk/engine/common/include/XmlPropertyReader.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/include/XmlPropertyReader.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -19,8 +19,7 @@
 
 #include &quot;CommonPrerequisites.h&quot;
 
-#include &lt;xercesc/dom/DOMAttr.hpp&gt;
-#include &lt;xercesc/dom/DOMElement.hpp&gt;
+#include &lt;tinyxml.h&gt;
 
 #include &quot;Properties.h&quot;
 #include &quot;XmlProcessor.h&quot;
@@ -33,7 +32,7 @@
     typedef std::pair&lt;Ogre::String, Property&gt; PropertyEntry;
 
     class _RlCommonExport XmlPropertyReader
-         : public XmlProcessor
+         : public XmlProcessor, public TiXmlVisitor
     {
     public:
         XmlPropertyReader();
@@ -42,14 +41,16 @@
         void parseGameObjectFile(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName);
         PropertyRecordVector getPropertyRecords();
 
-        PropertyEntry processProperty(XERCES_CPP_NAMESPACE::DOMElement* domElem) const;
-		PropertyEntry processProperty(XERCES_CPP_NAMESPACE::DOMAttr* domAttr) const;
+        PropertyEntry processProperty(const TiXmlElement* domElem) const;
+		PropertyEntry processProperty(const TiXmlAttribute* domAttr) const;
 
-        virtual PropertyRecordPtr getPropertiesAsRecord(XERCES_CPP_NAMESPACE::DOMElement* parent);
+        virtual PropertyRecordPtr getPropertiesAsRecord(const TiXmlElement* parent);
+        virtual bool VisitEnter(const TiXmlElement &amp;element, const TiXmlAttribute *firstAttribute);
     private:
         PropertyRecordVector mPropertyRecords;
 
         Property getProperty(const Ogre::String&amp; key, const CeGuiString&amp; value);
+        void processGameObjectClassNode(const TiXmlElement &amp;element);
     };
 } // namespace rl
 

Modified: rl/trunk/engine/common/include/XmlPropertyWriter.h
===================================================================
--- rl/trunk/engine/common/include/XmlPropertyWriter.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/include/XmlPropertyWriter.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -19,9 +19,7 @@
 
 #include &quot;CommonPrerequisites.h&quot;
 
-#include &lt;xercesc/dom/DOM.hpp&gt;
-#include &lt;xercesc/dom/DOMAttr.hpp&gt;
-#include &lt;xercesc/dom/DOMElement.hpp&gt;
+#include &lt;tinyxml.h&gt;
 
 #include &quot;Properties.h&quot;
 #include &quot;XmlProcessor.h&quot;
@@ -40,25 +38,22 @@
         XmlPropertyWriter();
         virtual ~XmlPropertyWriter();
 
-        XERCES_CPP_NAMESPACE::DOMDocument* getDocument();
+        TiXmlDocument* getDocument();
 
         PropertyRecordPtr getPropertyRecords();
         void setPropertyRecords(PropertyRecordVector sets);
         void addPropertyRecord(PropertyRecordPtr set);
 
-        XERCES_CPP_NAMESPACE::DOMElement* processProperty(XERCES_CPP_NAMESPACE::DOMElement* parent, const PropertyEntry&amp; entry);
-        XERCES_CPP_NAMESPACE::DOMElement* processPropertyRecord(XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name, const PropertyRecord&amp; set);
-        XERCES_CPP_NAMESPACE::DOMElement* processPropertyArray(XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name, const PropertyArray&amp; vector);
-        XERCES_CPP_NAMESPACE::DOMElement* processPropertyMap(XERCES_CPP_NAMESPACE::DOMElement* parent, const char* const name, const PropertyMap&amp; map);
+        TiXmlElement* processProperty(TiXmlElement* parent, const PropertyEntry&amp; entry);
+        TiXmlElement* processPropertyRecord(TiXmlElement* parent, const char* const name, const PropertyRecord&amp; set);
+        TiXmlElement* processPropertyArray(TiXmlElement* parent, const char* const name, const PropertyArray&amp; vector);
+        TiXmlElement* processPropertyMap(TiXmlElement* parent, const char* const name, const PropertyMap&amp; map);
 
-        void writeEachPropertyToElem(XERCES_CPP_NAMESPACE::DOMElement* parent, const PropertyMap &amp;map);
+        void writeEachPropertyToElem(TiXmlElement* parent, const PropertyMap &amp;map);
     protected:
         PropertyRecordVector mPropertyRecords;
 
-        XERCES_CPP_NAMESPACE::DOMDocument* mDocument;
-        XERCES_CPP_NAMESPACE::DOMImplementation* mImplementation;
-        XERCES_CPP_NAMESPACE::DOMWriter* mWriter;
-        XERCES_CPP_NAMESPACE::XMLFormatTarget* mTarget;
+        TiXmlDocument* mDocument;
 
         Property getProperty(const Ogre::String&amp; key, const CeGuiString&amp; value);
     };

Modified: rl/trunk/engine/common/include/XmlResource.h
===================================================================
--- rl/trunk/engine/common/include/XmlResource.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/include/XmlResource.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,13 +17,6 @@
 #ifndef __XmlResource_H__
 #define __XmlResource_H__
 
-#pragma warning (push)
-#pragma warning (disable : 4244)
-#include &lt;xercesc/framework/MemBufInputSource.hpp&gt;
-#include &lt;xercesc/parsers/XercesDOMParser.hpp&gt;
-#include &lt;xercesc/sax2/SAX2XMLReader.hpp&gt;
-#pragma warning (pop)
-
 #include &quot;CommonPrerequisites.h&quot;
 #include &quot;XmlProcessor.h&quot;
 
@@ -43,8 +36,7 @@
 
         virtual ~XmlResource();
 
-        bool parseBy(XERCES_CPP_NAMESPACE::XercesDOMParser* parser, XmlProcessor* const proc = NULL);
-        bool parseBy(XERCES_CPP_NAMESPACE::SAX2XMLReader* parser, XmlProcessor* const proc = NULL);
+        const char* getContent();
 
     protected:
         size_t calculateSize() const;
@@ -53,8 +45,7 @@
         void unloadImpl();
 
     private:
-        XERCES_CPP_NAMESPACE::MemBufInputSource* mXmlBuffer;
-        XMLByte* mCharBuffer;
+        char* mCharBuffer;
     };
 
     class _RlCommonExport XmlPtr :

Deleted: rl/trunk/engine/common/src/OgreXercesInput.cpp
===================================================================
--- rl/trunk/engine/common/src/OgreXercesInput.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/src/OgreXercesInput.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -1,51 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;OgreXercesInput.h&quot;
-
-using namespace XERCES_CPP_NAMESPACE;
-using namespace Ogre;
-
-namespace rl {
-
-    OgreInputSource::OgreInputSource(const Ogre::DataStreamPtr&amp; stream)
-    : mStream(stream)
-    {
-    }
-
-    BinInputStream* OgreInputSource::makeStream() const
-    {
-        return new OgreBinInputStream(mStream);
-    }
-
-    OgreBinInputStream::OgreBinInputStream(const Ogre::DataStreamPtr&amp; stream)
-    : mStream(stream)
-    {
-    }
-
-    unsigned int OgreBinInputStream::curPos() const
-    {
-        return mStream-&gt;tell();
-    }
-
-    unsigned int OgreBinInputStream::readBytes(XMLByte* const toFill, const unsigned int maxToRead)
-    {
-        return mStream-&gt;read(toFill, maxToRead);
-    }
-
-}

Deleted: rl/trunk/engine/common/src/WriteableDataStreamFormatTarget.cpp
===================================================================
--- rl/trunk/engine/common/src/WriteableDataStreamFormatTarget.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/src/WriteableDataStreamFormatTarget.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -1,38 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;WriteableDataStreamFormatTarget.h&quot;
-
-namespace rl
-{
-    WriteableDataStreamFormatTarget::WriteableDataStreamFormatTarget(WriteableDataStreamPtr stream)
-    {
-        mStream = stream;
-    }
-
-    void WriteableDataStreamFormatTarget::writeChars (const XMLByte *const toWrite, const unsigned int count, XERCES_CPP_NAMESPACE::XMLFormatter *const formatter)
-    {
-        mStream-&gt;write((char*)toWrite, count);
-    }
-
-    void WriteableDataStreamFormatTarget::flush ()
-    {
-        mStream-&gt;flush();
-    }
-}
-

Modified: rl/trunk/engine/common/src/XmlProcessor.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/src/XmlProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,136 +17,171 @@
 #include &quot;stdinc.h&quot; //precompiled header
 
 #include &lt;CEGUIPropertyHelper.h&gt;
-#include &lt;xercesc/dom/DOM.hpp&gt;
-#include &lt;xercesc/parsers/XercesDOMParser.hpp&gt;
-#include &lt;xercesc/util/PlatformUtils.hpp&gt;
-#include &lt;xercesc/sax/SAXParseException.hpp&gt;
 
 #include &quot;XmlProcessor.h&quot;
 
 #include &quot;Exception.h&quot;
 #include &quot;Logger.h&quot;
-#include &quot;OgreXercesInput.h&quot;
 #include &quot;XmlResource.h&quot;
 #include &quot;XmlResourceManager.h&quot;
 
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 using CEGUI::utf8;
 
 namespace rl 
 {
 
-XERCES_CPP_NAMESPACE::XMLTranscoder* XmlProcessor::sTranscoder = NULL;
-XERCES_CPP_NAMESPACE::XMLTransService::Codes XmlProcessor::sFailCode = XERCES_CPP_NAMESPACE::XMLTransService::Ok;
-
-DOMElement* XmlProcessor::appendChildElement(DOMDocument* doc, DOMElement* parent, const char* const name) const
+TiXmlElement* XmlProcessor::appendChildElement(TiXmlElement* parent, const char* const name) const
 {
     RlAssert(parent != NULL, &quot;XmlProcessor::appendChildElement: parent must not be NULL&quot; );
 
-    DOMElement* child = doc-&gt;createElement(XMLString::transcode(name));
-    parent-&gt;appendChild(child);
+    TiXmlElement* child = new TiXmlElement(name);
+    parent-&gt;LinkEndChild(child);
     return child;
 }
 
-DOMElement* XmlProcessor::getChildNamed(DOMElement* parent, const char* const name) const
+TiXmlElement* XmlProcessor::appendChildElement(TiXmlDocument* parent, const char* const name) const
 {
+    RlAssert(parent != NULL, &quot;XmlProcessor::appendChildElement: parent must not be NULL&quot; );
+
+	return appendChildElement(parent-&gt;RootElement(), name);
+}
+
+
+const TiXmlElement* XmlProcessor::getChildNamed(const TiXmlElement* parent, const char* const name) const
+{
     RlAssert(parent != NULL, &quot;XmlProcessor::getChildNamed: parent must not be NULL&quot; );
 
-	AutoXMLCh nameXml = name;
+	for (const TiXmlNode* cur = parent-&gt;FirstChild(); cur; cur = cur-&gt;NextSibling())
+	{
+		if (cur-&gt;Type() == TiXmlNode::ELEMENT &amp;&amp; cur-&gt;Value() == name)
+		{
+			return cur-&gt;ToElement();
+		}
+	}
 
-	DOMElement* rval = 0;
-	
-	for (DOMNode* cur = parent-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+	return NULL;
+}
+
+TiXmlElement* XmlProcessor::getChildNamed(TiXmlElement* parent, const char* const name) const
+{
+    RlAssert(parent != NULL, &quot;XmlProcessor::getChildNamed: parent must not be NULL&quot; );
+
+	for (TiXmlNode* cur = parent-&gt;FirstChild(); cur; cur = cur-&gt;NextSibling())
 	{
-		if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE &amp;&amp;
-			XMLString::compareString(cur-&gt;getNodeName(), nameXml.data()) == 0)
+		if (cur-&gt;Type() == TiXmlNode::ELEMENT &amp;&amp; cur-&gt;Value() == name)
 		{
-			rval = static_cast&lt;DOMElement*&gt;(cur);
-			break;
+			return cur-&gt;ToElement();
 		}
 	}
 
-	return rval;
+	return NULL;
 }
 
-void XmlProcessor::setValueAsString(DOMDocument* doc, DOMElement *element, const CeGuiString &amp;value) const
+class XmlElementFinder : public TiXmlVisitor
 {
+public:
+	XmlElementFinder(const char* const tagName)
+		: mResult(),
+		  mTagName(tagName)
+	{
+	}
+
+	virtual bool VisitEnter(const TiXmlElement &amp;element, const TiXmlAttribute *firstAttribute)
+	{
+		if (element.ValueTStr() == mTagName)
+		{
+			mResult.push_back(&amp;element);
+		}
+		return true;
+	}
+
+	XmlElementList getResult() const
+	{
+		return mResult;
+	}
+
+private:
+	XmlElementList mResult;
+	const char* mTagName;
+};
+
+XmlElementList XmlProcessor::getElementsByTagName(const TiXmlElement* parent, const char* const name) const
+{
+}
+
+
+XmlElementList XmlProcessor::getElementsByTagName(const TiXmlDocument* parent, const char* const name) const
+{
+	return getElementsByTagName(parent-&gt;RootElement(), name);
+}
+
+
+void XmlProcessor::setValueAsString(TiXmlElement *element, const CeGuiString &amp;value) const
+{
     RlAssert(element != NULL, &quot;XmlProcessor::setValueAsString: Element must not be NULL&quot;);
-    DOMText* text = doc-&gt;createTextNode(XMLString::transcode(value.c_str()));
-    element-&gt;appendChild(text);
+    TiXmlText* text = new TiXmlText(value.c_str());
+    element-&gt;LinkEndChild(text);
 }
 
-CeGuiString XmlProcessor::getValueAsString(DOMElement* element) const
+CeGuiString XmlProcessor::getValueAsString(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getValueAsString: Element must not be NULL&quot;);
-	return transcodeToString( element-&gt;getFirstChild()-&gt;getNodeValue() );
+	return element-&gt;FirstChild()-&gt;Value();
 }
 
-std::string XmlProcessor::getValueAsStdString(DOMElement* element) const
+std::string XmlProcessor::getValueAsStdString(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getValueAsStdString: Element must not be NULL&quot;);
-	return transcodeToStdString( element-&gt;getFirstChild()-&gt;getNodeValue() );
+	return element-&gt;FirstChild()-&gt;Value();
 }
 
-void XmlProcessor::setValueAsUtf8(DOMDocument* doc, DOMElement* element, utf8* value) const
+void XmlProcessor::setValueAsUtf8(TiXmlElement* element, utf8* value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setValueAsUtf8: Element must not be NULL&quot;);
     CeGuiString temp(value);
-    DOMText* text = doc-&gt;createTextNode(XMLString::transcode(temp.c_str()));
-    element-&gt;appendChild(text);
+    element-&gt;LinkEndChild(new TiXmlText(temp.c_str()));
 }
 
-utf8* XmlProcessor::getValueAsUtf8(DOMElement* element) const
+const utf8* XmlProcessor::getValueAsUtf8(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getValueAsUtf8: Element must not be NULL&quot;);
-	return XmlProcessor::transcodeToUtf8(element-&gt;getFirstChild()-&gt;getNodeValue());
+	return reinterpret_cast&lt;const utf8*&gt;(element-&gt;FirstChild()-&gt;Value());
 }
 
-bool XmlProcessor::hasAttribute(DOMElement* element,const char* const name) const
+bool XmlProcessor::hasAttribute(const TiXmlElement* element,const char* const name) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::hasAttribute: Element must not be NULL&quot;);
-    AutoXMLCh attrName(name);
-    bool rVal = element-&gt;hasAttribute(attrName.data());
-    return rVal;
+    return element-&gt;Attribute(name);
 }
 
-bool XmlProcessor::hasNodeName(DOMNode* node, const char* const name) const
+bool XmlProcessor::hasNodeName(const TiXmlNode* node, const char* const name) const
 {
     RlAssert(node != NULL, &quot;XmlProcessor::hasNodeName: node must not be NULL&quot;);
-    XMLCh* nodeName = XMLString::transcode(name);
-    int ival = XMLString::compareString(node-&gt;getNodeName(), nodeName);
-    bool rVal = (0 == ival);
-    XMLString::release(&amp;nodeName);
-    return rVal;
+    return node-&gt;ValueTStr() == name;
 }
 
-void XmlProcessor::setAttribute(DOMElement* element, const char* const name, const char* const value) const
+void XmlProcessor::setAttribute(TiXmlElement* element, const char* const name, const char* const value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setAttribute: Element must not be NULL&quot;);
-    AutoXMLCh attrName(name);
-    element-&gt;setAttribute(attrName.data(), XMLString::transcode(value));
+    element-&gt;SetAttribute(name, value);
 }
 
-void XmlProcessor::setAttributeValueAsInteger(DOMElement *element, const char *const name, int value) const
+void XmlProcessor::setAttributeValueAsInteger(TiXmlElement *element, const char *const name, int value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setAttributeValueAsInteger: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
-    CeGuiString temp = Ogre::StringConverter::toString(value);
-    element-&gt;setAttribute(attrName.data(), XMLString::transcode(temp.c_str()));
+    element-&gt;SetAttribute(name, Ogre::StringConverter::toString(value).c_str());
 }
 
-int XmlProcessor::getAttributeValueAsInteger(DOMElement* element,const char* const name) const
+int XmlProcessor::getAttributeValueAsInteger(const TiXmlElement* element,const char* const name) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getAttributeValueAsInteger: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
-    return XMLString::parseInt(element-&gt;getAttribute(attrName.data()));
+    return Ogre::StringConverter::parseInt(element-&gt;Attribute(name));
 }
 
-void XmlProcessor::setAttributeValueAsInt64(DOMElement *element, const char *const name, RL_LONGLONG value) const
+void XmlProcessor::setAttributeValueAsInt64(TiXmlElement *element, const char *const name, RL_LONGLONG value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setAttributeValueAsInt64: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
     
     bool negative = false;
     if (value &lt; 0)
@@ -155,7 +190,7 @@
         negative = true;
     }
 
-    CeGuiString temp(&quot;&quot;);
+    std::string temp(&quot;&quot;);
     RL_LONGLONG divider = 1000000000;
     while (value &gt; divider)
     {
@@ -169,15 +204,13 @@
         temp = &quot;-&quot; + temp;
     }
     
-    element-&gt;setAttribute(attrName.data(), XMLString::transcode(temp.c_str()));
+    element-&gt;SetAttribute(name, temp.c_str());
 }
 
-RL_LONGLONG XmlProcessor::getAttributeValueAsInt64(DOMElement* element,const char* const name) const
+RL_LONGLONG XmlProcessor::getAttributeValueAsInt64(const TiXmlElement* element,const char* const name) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getAttributeValueAsInteger: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);    
-	const XMLCh* attribute = element-&gt;getAttribute(attrName.data());
-    Ogre::String value = transcodeToStdString(attribute);
+	Ogre::String value = element-&gt;Attribute(name);
 
     RL_LONGLONG sign = 1;
     if (value[0] == '-')
@@ -202,21 +235,17 @@
 	return rVal;
 }
 
-void XmlProcessor::setAttributeValueAsIntegerPair(DOMElement* element, const char* const name, IntPair value) const
+void XmlProcessor::setAttributeValueAsIntegerPair(TiXmlElement* element, const char* const name, IntPair value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setAttributeValueAsIntegerPair: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
     CeGuiString temp = Ogre::StringConverter::toString(value.first) + &quot;,&quot; + Ogre::StringConverter::toString(value.second);
-    element-&gt;setAttribute(attrName.data(), XMLString::transcode(temp.c_str()));
+    element-&gt;SetAttribute(name, temp.c_str());
 }
 
-IntPair XmlProcessor::getAttributeValueAsIntegerPair(DOMElement* element, const char* const name) const
+IntPair XmlProcessor::getAttributeValueAsIntegerPair(const TiXmlElement* element, const char* const name) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getAttributeValueAsIntegerPair: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
-	const XMLCh* attribute = element-&gt;getAttribute(attrName.data());
-	
-    CeGuiString value = transcodeToString(attribute);
+    CeGuiString value = getAttributeValueAsString(element, name);
     CeGuiString::size_type comma1 = value.find(&quot;,&quot;);
 
 	std::pair&lt;int,int&gt; intPairVal = std::make_pair(0, 0);
@@ -230,22 +259,18 @@
     return intPairVal;
 }
 
-void XmlProcessor::setAttributeValueAsIntegerTriple(DOMElement *element, const char *const name, Tripel&lt;int&gt; value) const
+void XmlProcessor::setAttributeValueAsIntegerTriple(TiXmlElement *element, const char *const name, Tripel&lt;int&gt; value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setAttributeValueAsIntegerTriple: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
     CeGuiString temp = Ogre::StringConverter::toString(value.first) + &quot;,&quot; + Ogre::StringConverter::toString(value.second) + &quot;,&quot; + Ogre::StringConverter::toString(value.third);
-    element-&gt;setAttribute(attrName.data(), XMLString::transcode(temp.c_str()));
+    element-&gt;SetAttribute(name, temp.c_str());
 }
 
-Tripel&lt;int&gt; XmlProcessor::getAttributeValueAsIntegerTriple(DOMElement* element, const char* const name) const
+Tripel&lt;int&gt; XmlProcessor::getAttributeValueAsIntegerTriple(const TiXmlElement* element, const char* const name) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getAttributeValueAsIntegerTriple: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
-	const XMLCh* attribute = element-&gt;getAttribute(attrName.data());
+    CeGuiString value = getAttributeValueAsString(element, name);
 
-    CeGuiString value = transcodeToString(attribute);
-
     CeGuiString::size_type comma1 = value.find(&quot;,&quot;);
     CeGuiString::size_type comma2 = value.find(&quot;,&quot;, comma1 + 1);
 
@@ -260,129 +285,94 @@
     return intTripel;
 }
 
-void XmlProcessor::setAttributeValueAsReal(DOMElement *element, const char *const name, Ogre::Real value) const
+void XmlProcessor::setAttributeValueAsReal(TiXmlElement *element, const char *const name, Ogre::Real value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setAttributeValueAsReal: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
-    CeGuiString temp = Ogre::StringConverter::toString(value);
-    element-&gt;setAttribute(attrName.data(), XMLString::transcode(temp.c_str()));
+    element-&gt;SetAttribute(name, Ogre::StringConverter::toString(value).c_str());
 }
 
-Ogre::Real XmlProcessor::getAttributeValueAsReal(DOMElement* element,const char* const name) const
+Ogre::Real XmlProcessor::getAttributeValueAsReal(const TiXmlElement* element,const char* const name) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getAttributeValueAsReal: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
-	Ogre::Real rVal = Ogre::StringConverter::parseReal(
-		transcodeToString(element-&gt;getAttribute(attrName.data())).c_str() );
+	Ogre::Real rVal = Ogre::StringConverter::parseReal(getAttributeValueAsStdString(element, name));
 	return rVal;
 }
 
-void XmlProcessor::setAttributeValueAsString(DOMElement *element, const char *const name, const CeGuiString &amp;value) const
+void XmlProcessor::setAttributeValueAsString(TiXmlElement *element, const char *const name, const CeGuiString &amp;value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setAttributeValueAsString: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
-    element-&gt;setAttribute(attrName.data(), XMLString::transcode(value.c_str()));
+    element-&gt;SetAttribute(name, value.c_str());
 }
 
-CeGuiString XmlProcessor::getAttributeValueAsString(DOMElement* element, const char* const name) const
+CeGuiString XmlProcessor::getAttributeValueAsString(const TiXmlElement* element, const char* const name) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getAttributeValueAsString: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
-	CeGuiString rVal(transcodeToString(element-&gt;getAttribute(attrName.data())));
+	CeGuiString rVal(element-&gt;Attribute(name));
 	return rVal;
 }
 
-CeGuiString XmlProcessor::getAttributeValueAsString(const XERCES_CPP_NAMESPACE::Attributes&amp; attributes, const char* const name) const
+void XmlProcessor::setAttributeValueAsStdString(TiXmlElement *element, const char *const name, const std::string &amp;value) const
 {
-	AutoXMLCh attrName(name);
-	const XMLCh* valStr = attributes.getValue(attrName.data());
-	if (valStr != NULL)
-	{
-		return transcodeToString(valStr);
-	}
-	return CeGuiString();
-}
-
-void XmlProcessor::setAttributeValueAsStdString(DOMElement *element, const char *const name, const std::string &amp;value) const
-{
     RlAssert(element != NULL, &quot;XmlProcessor::setAttributeValueAsStdString: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
-    element-&gt;setAttribute(attrName.data(), XMLString::transcode(value.c_str()));
+    element-&gt;SetAttribute(name, value.c_str());
 }
 
-std::string XmlProcessor::getAttributeValueAsStdString(DOMElement* element, const char* const name) const
+std::string XmlProcessor::getAttributeValueAsStdString(const TiXmlElement* element, const char* const name) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getAttributeValueAsStdString: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
-	std::string rVal(transcodeToStdString(element-&gt;getAttribute(attrName.data())));
-	return rVal;
+	return element-&gt;Attribute(name);
 }
 
-void XmlProcessor::setAttributeValueAsBool(DOMElement *element, const char *const name, bool value) const
+void XmlProcessor::setAttributeValueAsBool(TiXmlElement *element, const char *const name, bool value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setAttributeValueAsBool: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
-    CeGuiString temp = Ogre::StringConverter::toString(value);
-    element-&gt;setAttribute(attrName.data(), XMLString::transcode(temp.c_str()));
+    element-&gt;SetAttribute(name, Ogre::StringConverter::toString(value).c_str());
 }
 
-bool XmlProcessor::getAttributeValueAsBool(DOMElement* element,const char* const name) const
+bool XmlProcessor::getAttributeValueAsBool(const TiXmlElement* element,const char* const name) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getAttributeValueAsBool: Element must not be NULL&quot;);
-	if ( XMLString::compareIString(getAttributeValueAsString(element, name).c_str(),&quot;true&quot;) == 0  )
-		return true;
-	else
-		return false;
+	return getAttributeValueAsStdString(element, name) == &quot;true&quot;;
 }
 
-void XmlProcessor::setValueAsBool(DOMDocument* doc, DOMElement *element, bool value) const
+void XmlProcessor::setValueAsBool(TiXmlElement *element, bool value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setValueAsBool: Element must not be NULL&quot;);
-    CeGuiString temp = Ogre::StringConverter::toString(value);
-    DOMText* text = doc-&gt;createTextNode(XMLString::transcode(temp.c_str()));
-    element-&gt;appendChild(text);
+    element-&gt;LinkEndChild(new TiXmlText(Ogre::StringConverter::toString(value).c_str()));
 }
 
-bool XmlProcessor::getValueAsBool(DOMElement* element) const
+bool XmlProcessor::getValueAsBool(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getValueAsBool: Element must not be NULL&quot;);
-	
-    if ( XMLString::compareIString(getValueAsString(element).c_str(),&quot;true&quot;) == 0  )
-		return true;
-	else
-		return false;
+    return getValueAsStdString(element) == &quot;true&quot;;
 }
 
-void XmlProcessor::setValueAsInteger(DOMDocument* doc, DOMElement *element, int value) const
+void XmlProcessor::setValueAsInteger(TiXmlElement *element, int value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setValueAsInteger: Element must not be NULL&quot;);
-    CeGuiString temp = Ogre::StringConverter::toString(value);
-    DOMText* text = doc-&gt;createTextNode(XMLString::transcode(temp.c_str()));
-    element-&gt;appendChild(text);
+    element-&gt;LinkEndChild(new TiXmlText(Ogre::StringConverter::toString(value).c_str()));
 }
 
-int XmlProcessor::getValueAsInteger(DOMElement* element) const
+int XmlProcessor::getValueAsInteger(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getValueAsInteger: Element must not be NULL&quot;);
-	return XMLString::parseInt(element-&gt;getFirstChild()-&gt;getNodeValue());
+	return Ogre::StringConverter::parseInt(element-&gt;FirstChild()-&gt;Value());
 }
 
-Ogre::Real XmlProcessor::getValueAsReal(XERCES_CPP_NAMESPACE::DOMElement* element) const
+Ogre::Real XmlProcessor::getValueAsReal(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getValueAsInteger: Element must not be NULL&quot;);
-    return Ogre::StringConverter::parseReal(
-        transcodeToString(element-&gt;getFirstChild()-&gt;getNodeValue()).c_str());
+    return Ogre::StringConverter::parseReal(getValueAsStdString(element));
 }
 
-void XmlProcessor::setValueAsIntegerPair(DOMDocument *doc, DOMElement *element, IntPair value) const
+void XmlProcessor::setValueAsIntegerPair(TiXmlElement *element, IntPair value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setValueAsIntegerPair: Element must not be NULL&quot;);
     CeGuiString temp = CEGUI::PropertyHelper::intToString(value.first) + ',' + CEGUI::PropertyHelper::intToString(value.second);
-    DOMText* text = doc-&gt;createTextNode(XMLString::transcode(temp.c_str()));
-    element-&gt;appendChild(text);
+    element-&gt;LinkEndChild(new TiXmlText(temp.c_str()));
 }
 
-IntPair XmlProcessor::getValueAsIntegerPair(DOMElement* element) const
+IntPair XmlProcessor::getValueAsIntegerPair(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getValueAsIntegerPair: Element must not be NULL&quot;);
     CeGuiString value = getValueAsString(element);
@@ -398,16 +388,15 @@
     return intPairVal;
 }
 
-void XmlProcessor::setValueAsIntegerTriple(DOMDocument *doc, DOMElement *element, Tripel&lt;int&gt; value) const
+void XmlProcessor::setValueAsIntegerTriple(TiXmlElement *element, Tripel&lt;int&gt; value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setValueAsIntegerTriple: Element must not be NULL&quot;);
     RlAssert(element != NULL, &quot;XmlProcessor::setValueAsIntegerPair: Element must not be NULL&quot;);
     CeGuiString temp = CEGUI::PropertyHelper::intToString(value.first) + ',' + CEGUI::PropertyHelper::intToString(value.second) + ',' + CEGUI::PropertyHelper::intToString(value.third);
-    DOMText* text = doc-&gt;createTextNode(XMLString::transcode(temp.c_str()));
-    element-&gt;appendChild(text);
+    element-&gt;LinkEndChild(new TiXmlText(temp.c_str()));
 }
 
-Tripel&lt;int&gt; XmlProcessor::getValueAsIntegerTriple(DOMElement *element) const
+Tripel&lt;int&gt; XmlProcessor::getValueAsIntegerTriple(const TiXmlElement *element) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getValueAsIntegerTriple: Element must not be NULL&quot;);
     CeGuiString value = getValueAsString(element);
@@ -425,22 +414,18 @@
     return intTripel;
 }
 
-void XmlProcessor::setAttributeValueAsVector3( DOMElement *element, const char* const name, Ogre::Vector3 value) const
+void XmlProcessor::setAttributeValueAsVector3(TiXmlElement *element, const char* const name, Ogre::Vector3 value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setAttributeValueAsVector3: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
-    CeGuiString temp = Ogre::StringConverter::toString(value.x) + &quot;,&quot; + Ogre::StringConverter::toString(value.y) + &quot;,&quot; + Ogre::StringConverter::toString(value.z);
-    element-&gt;setAttribute(attrName.data(), XMLString::transcode(temp.c_str()));
+    std::string temp = Ogre::StringConverter::toString(value.x) + &quot;,&quot; + Ogre::StringConverter::toString(value.y) + &quot;,&quot; + Ogre::StringConverter::toString(value.z);
+    element-&gt;SetAttribute(name, temp.c_str());
 }
 
-Ogre::Vector3 XmlProcessor::getAttributeValueAsVector3(DOMElement* element, const char* const name) const
+Ogre::Vector3 XmlProcessor::getAttributeValueAsVector3(const TiXmlElement* element, const char* const name) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getAttributeValueAsVector3: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
-	const XMLCh* attribute = element-&gt;getAttribute(attrName.data());
+    CeGuiString value = getAttributeValueAsString(element, name);
 
-    CeGuiString value = transcodeToString(attribute);
-
     CeGuiString::size_type comma1 = value.find(&quot;,&quot;);
     CeGuiString::size_type comma2 = value.find(&quot;,&quot;, comma1 + 1);
 
@@ -455,7 +440,7 @@
     return vec;
 }
 
-void XmlProcessor::setValueAsVector3( DOMElement *element, Ogre::Vector3 value) const
+void XmlProcessor::setValueAsVector3(TiXmlElement *element, Ogre::Vector3 value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setValueAsVector3: Element must not be NULL&quot;);
     setAttribute(element, &quot;x&quot;, Ogre::StringConverter::toString(value.x).c_str());
@@ -463,7 +448,7 @@
     setAttribute(element, &quot;z&quot;, Ogre::StringConverter::toString(value.z).c_str());
 }
 
-Ogre::Vector3 XmlProcessor::getValueAsVector3(DOMElement* element) const
+Ogre::Vector3 XmlProcessor::getValueAsVector3(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getValueAsVector3: Element must not be NULL&quot;);
 	RlAssert(
@@ -477,7 +462,7 @@
 		getAttributeValueAsReal(element, &quot;z&quot;));
 }
 
-void XmlProcessor::setValueAsQuaternion(DOMElement *element, Ogre::Quaternion value) const
+void XmlProcessor::setValueAsQuaternion(TiXmlElement *element, Ogre::Quaternion value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setValueAsQuaternion: Element must not be NULL&quot;);
     setAttribute(element, &quot;x&quot;, Ogre::StringConverter::toString(value.x).c_str());
@@ -486,7 +471,7 @@
     setAttribute(element, &quot;w&quot;, Ogre::StringConverter::toString(value.w).c_str());
 }
 
-Ogre::Quaternion XmlProcessor::getValueAsQuaternion(DOMElement* element) const
+Ogre::Quaternion XmlProcessor::getValueAsQuaternion(const TiXmlElement* element) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getValueAsQuaternion: Element must not be NULL&quot;);
 	RlAssert(
@@ -502,22 +487,18 @@
         getAttributeValueAsReal(element, &quot;w&quot;));
 }
 
-void XmlProcessor::setAttributeValueAsQuaternion(DOMElement *element, const char* const name, Ogre::Quaternion value) const
+void XmlProcessor::setAttributeValueAsQuaternion(TiXmlElement *element, const char* const name, Ogre::Quaternion value) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::setAttributeValueAsQuaternion: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
-    CeGuiString temp = Ogre::StringConverter::toString(value.w) + &quot;,&quot; + Ogre::StringConverter::toString(value.x) + &quot;,&quot; + Ogre::StringConverter::toString(value.y) + &quot;,&quot; + Ogre::StringConverter::toString(value.z);
-    element-&gt;setAttribute(attrName.data(), XMLString::transcode(temp.c_str()));
+    std::string temp = Ogre::StringConverter::toString(value.w) + &quot;,&quot; + Ogre::StringConverter::toString(value.x) + &quot;,&quot; + Ogre::StringConverter::toString(value.y) + &quot;,&quot; + Ogre::StringConverter::toString(value.z);
+    element-&gt;SetAttribute(name, temp.c_str());
 }
 
-Ogre::Quaternion XmlProcessor::getAttributeValueAsQuaternion(DOMElement* element, const char* const name) const
+Ogre::Quaternion XmlProcessor::getAttributeValueAsQuaternion(const TiXmlElement* element, const char* const name) const
 {
     RlAssert(element != NULL, &quot;XmlProcessor::getAttributeValueAsQuaternion: Element must not be NULL&quot;);
-	AutoXMLCh attrName(name);
-	const XMLCh* attribute = element-&gt;getAttribute(attrName.data());
+    CeGuiString value = getAttributeValueAsString(element, name);
 
-    CeGuiString value = transcodeToString(attribute);
-
     CeGuiString::size_type comma1 = value.find(&quot;,&quot;);
     CeGuiString::size_type comma2 = value.find(&quot;,&quot;, comma1 + 1);
     CeGuiString::size_type comma3 = value.find(&quot;,&quot;, comma2 + 1);
@@ -558,80 +539,8 @@
     return quat;
 }
 
-utf8* XmlProcessor::transcodeToUtf8(const XMLCh* const string16) const
+TiXmlDocument* XmlProcessor::loadDocument(const Ogre::String&amp; resourceName, const Ogre::String&amp; resourceGroup)
 {
-	unsigned int str16len = XMLString::stringLen(string16);
-
-    /// Check if the XMLCh contains nothing but whitespaces. If so, remove them 
-    /// @note this does also mean, that this method will never return something like &quot; &quot; 
-    XMLCh* tmpVal = XMLString::replicate(string16);
-    if(XMLChar1_0::isAllSpaces(tmpVal, str16len) &amp;&amp; str16len != 1)
-    {
-        XMLString::removeWS(tmpVal);
-        str16len = XMLString::stringLen(tmpVal);
-    }
-
-	utf8* rval;
-	unsigned int eaten = 0;
-	unsigned int size = str16len;
-
-	do
-	{
-		rval = new utf8[size+1];
-	
-		sTranscoder-&gt;transcodeTo(tmpVal, str16len, rval, size, eaten, XMLTranscoder::UnRep_RepChar);
-		rval[size] = 0;
-
-		if (eaten &lt; str16len)
-		{
-			size += str16len - eaten;
-			delete[] rval;
-		}
-	}
-	while (eaten &lt; str16len);
-    XMLString::release(&amp;tmpVal);
-	return rval;	
-}
-
-CeGuiString XmlProcessor::transcodeToString(const XMLCh* const string16) const
-{
-	unsigned int str16len = XMLString::stringLen(string16);
-	if (str16len == 0)
-	{
-		return CeGuiString();
-	}
-
-	utf8* tmpVal = transcodeToUtf8(string16);
-	CeGuiString rVal(tmpVal);
-	delete[] tmpVal;
-	return rVal;
-}
-
-std::string XmlProcessor::transcodeToStdString(const XMLCh* const string16) const
-{
-    if ( string16 == NULL )
-        return &quot;&quot;;
-
-	char* tmpVal = XMLString::transcode(string16);
-	std::string rVal(tmpVal);
-	XMLString::release(&amp;tmpVal);
-	return rVal;
-}
-
-DOMDocument* XmlProcessor::loadDocument(
-    const Ogre::String&amp; resourceName, const Ogre::String&amp; resourceGroup)
-{
-    if( mOpenParser != NULL )
-    {
-        LOG_WARNING(Logger::COMMON, 
-                &quot;XmlProcessor: there is already an opened DOMParser, but perhaps its still used, so we don't delete it&quot;);
-    }
-    mOpenParser = new XercesDOMParser();
-
-    mOpenParser-&gt;setValidationScheme(XercesDOMParser::Val_Auto);    // optional.
-    //mOpenParser-&gt;setIncludeIgnorableWhitespace(false); // optional, if you want to ignore whitespaces
-    mOpenParser-&gt;setDoNamespaces(true);    // optional
-
     XmlPtr res = XmlResourceManager::getSingleton().getByName(resourceName);
     if (res.isNull())
     {
@@ -645,103 +554,47 @@
         res = XmlResourceManager::getSingleton().create(resourceName, group);
     }
 
-    mOpenXmlFileName = resourceName;
+    TiXmlDocument* doc = parseToXmlDocument(res-&gt;getContent());
 
-    if (!res.isNull() &amp;&amp; res-&gt;parseBy(mOpenParser, this))
-    {
-        mOpenXmlFileName = &quot;&quot;;
-        return mOpenParser-&gt;getDocument();
-    }
-
-
-    return NULL;
+    return doc;
 }
 
-DOMDocument* XmlProcessor::loadDocument(const Ogre::DataStreamPtr&amp; stream)
+TiXmlDocument* XmlProcessor::loadDocument(const Ogre::DataStreamPtr&amp; stream)
 {
-    if( mOpenParser != NULL )
-    {
-        LOG_WARNING(Logger::COMMON, 
-                &quot;XmlProcessor: there is already an opened DOMParser, but perhaps its still used, so we don't delete it&quot;);
-    }
-    mOpenParser = new XercesDOMParser();
+	TiXmlDocument* doc = NULL;
+	size_t size = stream-&gt;size();
+	if (size &gt; 0)
+	{
+		char* buffer = new char[size + 1];
+		stream-&gt;read(buffer, size);
+		buffer[size] = 0;
+		doc = parseToXmlDocument(buffer);
+		delete[] buffer;
+	}
 
-    mOpenParser-&gt;setValidationScheme(XercesDOMParser::Val_Auto);    // optional.
-    mOpenParser-&gt;setDoNamespaces(true);    // optional
-
-    OgreInputSource source(stream);
-    mOpenParser-&gt;setErrorHandler(this);
-
-    mOpenXmlFileName = stream-&gt;getName();
-    mOpenParser-&gt;parse(source);
-    mOpenXmlFileName = &quot;&quot;;
-
-    if (mOpenParser-&gt;getErrorCount() == 0)
-    {
-        return mOpenParser-&gt;getDocument();
-    }
-
-    return NULL;
+    return doc;
 }
 
-void XmlProcessor::initializeXml()
+TiXmlDocument* XmlProcessor::parseToXmlDocument(const char* content) const
 {
-  	XMLPlatformUtils::Initialize();
+    TiXmlDocument* doc = new TiXmlDocument();
+    doc-&gt;Parse(content);
 
-	sTranscoder 
-        = XMLPlatformUtils::fgTransService-&gt;makeNewTranscoderFor(
-            XMLRecognizer::UTF_8, sFailCode, 16*1024);
-}
-
-void XmlProcessor::shutdownXml()
-{
-    if( mOpenParser )
+    if (doc-&gt;Error())
     {
-        delete mOpenParser;
-        mOpenParser = NULL;
+    	std::string msg;
+    	msg += &quot;XML Error '&quot;;
+		msg += doc-&gt;ErrorDesc();
+		msg += &quot;' at row &quot;;
+		msg += doc-&gt;ErrorRow();
+		msg += &quot;, col &quot;;
+		msg += doc-&gt;ErrorCol();
+    	LOG_ERROR(Logger::COMMON, msg);
+
+    	return NULL;
     }
-    delete sTranscoder;
-    sTranscoder = NULL;
-    
-    XMLPlatformUtils::Terminate();
-}
 
-std::string XmlProcessor::toString( const std::string&amp; type,
-        const XERCES_CPP_NAMESPACE::SAXParseException&amp; exc ) const
-{
-    std::stringstream strs;
-    strs &lt;&lt; &quot;A&quot; &lt;&lt; type &lt;&lt; &quot; occured while parsing &quot; &lt;&lt; mOpenXmlFileName
-         &lt;&lt; &quot; at line &quot; &lt;&lt; exc.getLineNumber() &lt;&lt; &quot; column &quot; &lt;&lt;  exc.getColumnNumber();
-
-    if( exc.getSystemId() != NULL )
-        strs &lt;&lt; &quot; with system &quot; &lt;&lt; transcodeToStdString( exc.getSystemId() );
-    if( exc.getPublicId() != NULL )
-        strs &lt;&lt; &quot; with public &quot; &lt;&lt; transcodeToStdString( exc.getPublicId() );
-
-    std::string msg = transcodeToStdString(exc.getMessage());
-    strs &lt;&lt; &quot;: &quot; &lt;&lt; msg;
-
-    return strs.str();
+    return doc;
 }
 
-void XmlProcessor::warning(const XERCES_CPP_NAMESPACE::SAXParseException&amp; exc)
-{
-    LOG_MESSAGE(Logger::CORE, toString( &quot; warning &quot;, exc ) );
-}
-
-void XmlProcessor::error(const XERCES_CPP_NAMESPACE::SAXParseException&amp; exc)
-{
-    LOG_ERROR(Logger::CORE, toString( &quot;n error&quot;, exc ) );
-}
-
-void XmlProcessor::fatalError(const XERCES_CPP_NAMESPACE::SAXParseException&amp; exc)
-{
-    LOG_CRITICAL(Logger::CORE, toString( &quot; fatal error&quot;, exc ) );
-}
-
-void XmlProcessor::resetErrors()
-{
-}
-
-
 } // end namespace rl

Modified: rl/trunk/engine/common/src/XmlPropertyReader.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlPropertyReader.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/src/XmlPropertyReader.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,8 +16,6 @@
 
 #include &quot;stdinc.h&quot; //precompiled header
 
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
 #include &quot;Properties.h&quot;
 
 #include &quot;XmlProcessor.h&quot;
@@ -25,8 +23,6 @@
 
 #include &lt;CEGUIPropertyHelper.h&gt;
 
-
-using namespace XERCES_CPP_NAMESPACE;
 using namespace Ogre;
 
 namespace rl {
@@ -41,43 +37,45 @@
 
 void XmlPropertyReader::parseGameObjectFile(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName)
 {
-    initializeXml();
+    TiXmlDocument* doc = loadDocument(stream);
+    doc-&gt;Accept(this);
+}
 
-    XERCES_CPP_NAMESPACE::DOMDocument* doc = loadDocument(stream);
+bool XmlPropertyReader::VisitEnter(const TiXmlElement &amp;element, const TiXmlAttribute *firstAttribute)
+{
+	if (element.ValueTStr() == &quot;gameobjectclass&quot;)
+	{
+		processGameObjectClassNode(element);
+		return false;
+	}
+	return true;
+}
 
-    DOMNodeList* godefsXml = doc-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(&quot;gameobjectclass&quot;).data());
-    for (unsigned int idx = 0; idx &lt; godefsXml-&gt;getLength(); idx++)
-    {
-		PropertyRecordPtr ps(new PropertyRecord());
-		DOMElement* curNode = static_cast&lt;DOMElement*&gt;(godefsXml-&gt;item(idx));
-		
-		const DOMNamedNodeMap* godefAttrs = curNode-&gt;getAttributes();
-		for (XMLSize_t attrIdx = 0; attrIdx &lt; godefAttrs-&gt;getLength(); attrIdx++)
+void XmlPropertyReader::processGameObjectClassNode(const TiXmlElement &amp;element)
+{
+	PropertyRecordPtr ps(new PropertyRecord());
+
+	for (const TiXmlAttribute* curAttr = element.FirstAttribute(); curAttr; curAttr = curAttr-&gt;Next())
+	{
+		PropertyEntry entry = processProperty(curAttr);
+		if (entry.first != &quot;&quot;)
 		{
-			PropertyEntry entry = processProperty(static_cast&lt;DOMAttr*&gt;(godefAttrs-&gt;item(attrIdx)));
-            if (entry.first != &quot;&quot;)
-            {
-                ps-&gt;setProperty(entry.first, entry.second);
-            }
+			ps-&gt;setProperty(entry.first, entry.second);
 		}
+	}
 
-        DOMNodeList* godefChildren = curNode-&gt;getChildNodes();
-        for (XMLSize_t childIdx = 0; childIdx &lt; godefChildren-&gt;getLength(); childIdx++)
-        {
-            DOMNode* curChild = godefChildren-&gt;item(childIdx);
-            if (curChild-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-            {
-                PropertyEntry entry = processProperty(static_cast&lt;DOMElement*&gt;(curChild));
-                if (entry.first != &quot;&quot;)
-                {
-                    ps-&gt;setProperty(entry.first, entry.second);
-                }
-            }
-        }
-        mPropertyRecords.push_back(ps);
-    }
-	
-    shutdownXml();
+	for (const TiXmlNode* curChild = element.FirstChild(); curChild; curChild = curChild-&gt;NextSibling())
+	{
+		if (curChild-&gt;Type() == TiXmlNode::ELEMENT)
+		{
+			PropertyEntry entry = processProperty(curChild-&gt;ToElement());
+			if (entry.first != &quot;&quot;)
+			{
+				ps-&gt;setProperty(entry.first, entry.second);
+			}
+		}
+	}
+	mPropertyRecords.push_back(ps);
 }
 
 PropertyRecordVector XmlPropertyReader::getPropertyRecords()
@@ -85,14 +83,12 @@
     return mPropertyRecords;
 }
 
-PropertyEntry XmlPropertyReader::processProperty(XERCES_CPP_NAMESPACE::DOMAttr* domAttr) const
+PropertyEntry XmlPropertyReader::processProperty(const TiXmlAttribute* attribute) const
 {
-	return std::make_pair(
-		transcodeToStdString(domAttr-&gt;getName()), 
-		Property(transcodeToString(domAttr-&gt;getValue())));
+	return std::make_pair(attribute-&gt;Name(), Property(CeGuiString(attribute-&gt;Value())));
 }
 
-PropertyEntry XmlPropertyReader::processProperty(XERCES_CPP_NAMESPACE::DOMElement* domElem) const
+PropertyEntry XmlPropertyReader::processProperty(const TiXmlElement* domElem) const
 {
     if (!hasAttribute(domElem, &quot;type&quot;))
     {
@@ -184,12 +180,12 @@
 	else if (type == &quot;ARRAY&quot;)
 	{
 		std::vector&lt;Property&gt; vecVal;
-		for (DOMNode* curChild  = domElem-&gt;getFirstChild(); curChild != NULL;
-			curChild = curChild-&gt;getNextSibling())
+		for (const TiXmlNode* curChild  = domElem-&gt;FirstChild(); curChild;
+			curChild = curChild-&gt;NextSibling())
 		{
-			if (curChild-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+			if (curChild-&gt;Type() == TiXmlNode::ELEMENT)
 			{
-				PropertyEntry entry = processProperty(static_cast&lt;DOMElement*&gt;(curChild));
+				PropertyEntry entry = processProperty(curChild-&gt;ToElement());
 				vecVal.push_back(entry.second);
 			}
 		}
@@ -225,12 +221,12 @@
 	else if (type == &quot;MAP&quot;)
 	{
 		PropertyMap mapVal;
-		for (DOMNode* curChild  = domElem-&gt;getFirstChild(); curChild != NULL;
-			curChild = curChild-&gt;getNextSibling())
+		for (const TiXmlNode* curChild  = domElem-&gt;FirstChild(); curChild;
+					curChild = curChild-&gt;NextSibling())
 		{
-			if (curChild-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+			if (curChild-&gt;Type() == TiXmlNode::ELEMENT)
 			{
-				DOMElement* curElem = static_cast&lt;DOMElement*&gt;(curChild);
+				const TiXmlElement* curElem = curChild-&gt;ToElement();
 				CeGuiString key = getAttributeValueAsString(curElem, &quot;name&quot;);
 				PropertyEntry entry = processProperty(curElem);
 				mapVal[key] = entry.second;
@@ -242,17 +238,16 @@
     return std::make_pair(key, prop);
 }
 
-PropertyRecordPtr XmlPropertyReader::getPropertiesAsRecord(DOMElement *parent)
+PropertyRecordPtr XmlPropertyReader::getPropertiesAsRecord(const TiXmlElement *parent)
 {
     PropertyRecordPtr ps(new PropertyRecord());
 
-    DOMNodeList* propertyDefChildren = parent-&gt;getChildNodes();
-    for (XMLSize_t childIdx = 0; childIdx &lt; propertyDefChildren-&gt;getLength(); childIdx++)
-    {
-        DOMNode* curChild = propertyDefChildren-&gt;item(childIdx);
-        if (curChild-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-        {
-            PropertyEntry entry = processProperty(static_cast&lt;DOMElement*&gt;(curChild));
+	for (const TiXmlNode* curChild = parent-&gt;FirstChild(); curChild;
+				curChild = curChild-&gt;NextSibling())
+	{
+		if (curChild-&gt;Type() == TiXmlNode::ELEMENT)
+		{
+            PropertyEntry entry = processProperty(curChild-&gt;ToElement());
             if (entry.first != &quot;&quot;)
             {
                 ps-&gt;setProperty(entry.first, entry.second);

Modified: rl/trunk/engine/common/src/XmlPropertyWriter.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlPropertyWriter.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/src/XmlPropertyWriter.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -24,7 +24,6 @@
 #include &lt;CEGUIPropertyHelper.h&gt;
 
 
-using namespace XERCES_CPP_NAMESPACE;
 using namespace Ogre;
 
 namespace rl {
@@ -37,7 +36,7 @@
     {
     }
 
-    DOMDocument* XmlPropertyWriter::getDocument()
+    TiXmlDocument* XmlPropertyWriter::getDocument()
     {
         return mDocument;
     }
@@ -52,9 +51,9 @@
         mPropertyRecords.push_back(set);
     }
 
-    DOMElement* XmlPropertyWriter::processProperty(DOMElement* parent, const PropertyEntry&amp; entry)
+    TiXmlElement* XmlPropertyWriter::processProperty(TiXmlElement* parent, const PropertyEntry&amp; entry)
     {
-        DOMElement* element = NULL;
+    	TiXmlElement* element = NULL;
         if(!entry.second.isEmpty())
         {
             if(entry.second.isArray())
@@ -67,7 +66,7 @@
             }
             else
             {
-                element = appendChildElement(mDocument, parent, &quot;property&quot;);
+                element = appendChildElement(parent, &quot;property&quot;);
                 if(!entry.first.empty())
                     setAttribute(element, &quot;name&quot;, entry.first.c_str());
 
@@ -97,16 +96,16 @@
         return element;
     }
 
-    DOMElement* XmlPropertyWriter::processPropertyRecord(DOMElement* parent, const char* const name, const PropertyRecord&amp; set)
+    TiXmlElement* XmlPropertyWriter::processPropertyRecord(TiXmlElement* parent, const char* const name, const PropertyRecord&amp; set)
     {
         PropertyMap map = set.toPropertyMap();
 
         return processPropertyMap(parent, name, map);
     }
 
-    DOMElement* XmlPropertyWriter::processPropertyArray(DOMElement *parent, const char *const name, const PropertyArray&amp; vector)
+    TiXmlElement* XmlPropertyWriter::processPropertyArray(TiXmlElement *parent, const char *const name, const PropertyArray&amp; vector)
     {
-        DOMElement* element = appendChildElement(mDocument, parent, &quot;property&quot;);
+    	TiXmlElement* element = appendChildElement(parent, &quot;property&quot;);
         if(name[0] != '\0')
             setAttribute(element, &quot;name&quot;, name);
         setAttribute(element, &quot;type&quot;, &quot;ARRAY&quot;);
@@ -119,9 +118,9 @@
         return element;
     }
 
-    DOMElement* XmlPropertyWriter::processPropertyMap(DOMElement *parent, const char *const name, const PropertyMap&amp; map)
+    TiXmlElement* XmlPropertyWriter::processPropertyMap(TiXmlElement *parent, const char *const name, const PropertyMap&amp; map)
     {
-        DOMElement* element = appendChildElement(mDocument, parent, &quot;property&quot;);
+    	TiXmlElement* element = appendChildElement(parent, &quot;property&quot;);
         if(name[0] != '\0')
             setAttribute(element, &quot;name&quot;, name);
         setAttribute(element, &quot;type&quot;, &quot;MAP&quot;);
@@ -134,7 +133,7 @@
         return element;
     }
 
-    void XmlPropertyWriter::writeEachPropertyToElem(DOMElement* parent, const rl::PropertyMap &amp;map)
+    void XmlPropertyWriter::writeEachPropertyToElem(TiXmlElement* parent, const rl::PropertyMap &amp;map)
     {
         PropertyMap::const_iterator it_properties;
         for(it_properties = map.begin(); it_properties != map.end(); it_properties++)

Modified: rl/trunk/engine/common/src/XmlResource.cpp
===================================================================
--- rl/trunk/engine/common/src/XmlResource.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/common/src/XmlResource.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -20,7 +20,6 @@
 #include &quot;XmlResourceManager.h&quot;
 #include &quot;XmlProcessor.h&quot;
 
-using namespace XERCES_CPP_NAMESPACE;
 using namespace Ogre;
 
 namespace rl {
@@ -29,8 +28,7 @@
         ResourceManager* creator, const Ogre::String&amp; name, ResourceHandle handle,
         const Ogre::String&amp; group, bool isManual, ManualResourceLoader* loader)
 	: Resource(creator, name, handle, group, isManual, loader),
-	mCharBuffer(NULL),
-	mXmlBuffer(NULL)
+	mCharBuffer(NULL)
 {
 }
 
@@ -45,18 +43,12 @@
 	DataStreamPtr ds = Ogre::ResourceGroupManager::getSingleton().openResource(mName, mGroup);
 	mSize = ds-&gt;size();
 	
-	mCharBuffer = new XMLByte[mSize];
+	mCharBuffer = new char[mSize];
 	ds-&gt;read(mCharBuffer, mSize);
-
-	mXmlBuffer = new MemBufInputSource(
-        mCharBuffer,
-	    static_cast&lt;const unsigned int&gt;(mSize), &quot;rl::XmlResourceManager&quot;);
 }
 
 void XmlResource::unloadImpl()
 {
-	delete mXmlBuffer;
-    mXmlBuffer = 0;
 	delete[] mCharBuffer;
     mCharBuffer = 0;
 }
@@ -66,45 +58,15 @@
 {
     return mSize;
 }
-/**
- * @todo both parseby methods could be merged in one template method, to avoid redundancy
- */
-bool XmlResource::parseBy(XERCES_CPP_NAMESPACE::XercesDOMParser* parser, XmlProcessor* const errorHandler)
-{
-	if (!isLoaded())
-		load();
 
-    if (errorHandler 
-        &amp;&amp; parser-&gt;getErrorHandler() == NULL)
-    {
-        parser-&gt;setErrorHandler(errorHandler);
-    }
-
-    parser-&gt;parse(*mXmlBuffer);
-    if(parser-&gt;getErrorCount() &gt; 0)
-    {
-        return false;
-    }
-    return true;
-}
-
-bool XmlResource::parseBy(XERCES_CPP_NAMESPACE::SAX2XMLReader* parser, XmlProcessor* const errorHandler)
+const char* XmlResource::getContent()
 {
-	if (!isLoaded())
+	if (!mCharBuffer)
+	{
 		load();
+	}
 
-    if (errorHandler 
-        &amp;&amp; parser-&gt;getErrorHandler() == NULL)
-    {
-        parser-&gt;setErrorHandler(errorHandler);
-    }
-
-    parser-&gt;parse(*mXmlBuffer);
-    if(parser-&gt;getErrorCount() &gt; 0)
-    {
-        return false;
-    }
-    return true;
+	return mCharBuffer;
 }
 
 XmlPtr::XmlPtr(const ResourcePtr&amp; res) : SharedPtr&lt;XmlResource&gt;()

Modified: rl/trunk/engine/core/CMakeLists.txt
===================================================================
--- rl/trunk/engine/core/CMakeLists.txt	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/CMakeLists.txt	2009-11-07 19:39:22 UTC (rev 4961)
@@ -3,7 +3,7 @@
 ${CMAKE_CURRENT_SOURCE_DIR}/include/fmod4driver
 ${CMAKE_CURRENT_SOURCE_DIR}/include/nulldriver
 ${RL_COMMON_INCLUDE_DIR}
-${XERCESC_INCLUDE_DIR}
+${TINYXML_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR}

Modified: rl/trunk/engine/core/include/PhysicsRagDoll.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsRagDoll.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/include/PhysicsRagDoll.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,7 +17,7 @@
 #ifndef __PhysicsRagdoll_H__
 #define __PhysicsRagdoll_H__
 
-#include &lt;xercesc/dom/DOMElement.hpp&gt;
+#include &lt;tinyxml.h&gt;
 
 #include &quot;CorePrerequisites.h&quot;
 #include &quot;PhysicsManager.h&quot;
@@ -179,7 +179,7 @@
 	RagBone* _addBone( OgreNewt::World* world, RagBone* parent, Ogre::Vector3 dir, RagBone::BoneShape shape, Ogre::Vector3 size, Ogre::Real mass, Ogre::Bone* ogrebone, Actor* parentActor );
 
 	//! recursive function for creating bones and joints
-	RagBone* _addAllBones( RagBone* parent, XERCES_CPP_NAMESPACE::DOMElement* boneElem, Actor* parentActor );
+	RagBone* _addAllBones( RagBone* parent, TiXmlElement* boneElem, Actor* parentActor );
 
     //! add a joint between two bodies
 	void _joinBones( PhysicsRagDoll::JointType type, RagBone* parent, RagBone* child, Ogre::Vector3 pos, Ogre::Vector3 pin, Ogre::Real limit1, Ogre::Real limit2, OgreNewt::World* world );

Modified: rl/trunk/engine/core/include/SaveGameFile.h
===================================================================
--- rl/trunk/engine/core/include/SaveGameFile.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/include/SaveGameFile.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,10 +17,8 @@
 #ifndef __SaveGameFile_H__
 #define __SaveGameFile_H__
 
-
-
 #include &quot;CorePrerequisites.h&quot;
-#include &lt;xercesc/framework/XMLFormatter.hpp&gt;
+
 #include &lt;ctime&gt;
 
 #include &quot;Property.h&quot;
@@ -47,7 +45,6 @@
         //access to file
         Ogre::DataStreamPtr &amp;getDataStream();
         void closeDataStream();
-        XERCES_CPP_NAMESPACE::XMLFormatTarget* getFormatTarget();
         void deleteFileFromStorage();
 
         //data to be saved

Modified: rl/trunk/engine/core/include/SaveGameFileReader.h
===================================================================
--- rl/trunk/engine/core/include/SaveGameFileReader.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/include/SaveGameFileReader.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,6 +17,8 @@
 #ifndef _SaveGameFileReader_H_
 #define _SaveGameFileReader_H_
 
+#include &lt;tinyxml.h&gt;
+
 #include &quot;SaveGameFile.h&quot;
 #include &quot;XmlPropertyReader.h&quot;
 
@@ -28,7 +30,7 @@
     class _RlCoreExport SaveGameFileReader : public XmlPropertyReader
     {
     protected:
-        XERCES_CPP_NAMESPACE::DOMDocument* mDocument;
+        TiXmlDocument* mDocument;
     public:
         SaveGameFileReader();
         void parseSaveGameFile(SaveGameFile* file, const SaveGameDataOrderMap &amp;map);
@@ -36,7 +38,7 @@
 
         PropertyRecordPtr getAllPropertiesAsRecord(SaveGameData* data);
 
-        XERCES_CPP_NAMESPACE::DOMDocument* getDocument() {return mDocument;}
+        TiXmlDocument* getDocument() {return mDocument;}
     };
 }
 

Modified: rl/trunk/engine/core/src/ContentModule.cpp
===================================================================
--- rl/trunk/engine/core/src/ContentModule.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/ContentModule.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -217,19 +217,17 @@
         return &quot;ContentModule&quot;;
     }
 
-    using namespace XERCES_CPP_NAMESPACE;
-
     void ContentModule::writeData(SaveGameFileWriter* writer)
     {
-        if(!this-&gt;isCommon())
+        if (!this-&gt;isCommon())
         {
             LOG_MESSAGE(Logger::CORE, &quot;Saving ContentLoaders&quot;);
-            DOMElement* contentLoadersNode = writer-&gt;appendChildElement(writer-&gt;getDocument(), writer-&gt;getDocument()-&gt;getDocumentElement(), getXmlNodeIdentifier().c_str());
+            TiXmlElement* contentLoadersNode = writer-&gt;appendChildElement(writer-&gt;getDocument()-&gt;RootElement(), getXmlNodeIdentifier().c_str());
             writer-&gt;setAttributeValueAsString(contentLoadersNode, &quot;name&quot;, mName);
 
             for(ContentLoaderVector::const_iterator it = mContentLoaders.begin(); it != mContentLoaders.end(); ++it)
             {
-                DOMElement* contentLoaderNode = writer-&gt;appendChildElement(writer-&gt;getDocument(), contentLoadersNode, &quot;contentloader&quot;);
+                TiXmlElement* contentLoaderNode = writer-&gt;appendChildElement(contentLoadersNode, &quot;contentloader&quot;);
                 writer-&gt;setAttributeValueAsString(contentLoaderNode, &quot;classname&quot;, Property((*it)-&gt;getClassName()));
                 writer-&gt;writeEachPropertyToElem(contentLoaderNode, (*it)-&gt;getAllProperties()-&gt;toPropertyMap());
             }

Modified: rl/trunk/engine/core/src/GenericWorld.cpp
===================================================================
--- rl/trunk/engine/core/src/GenericWorld.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/GenericWorld.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -15,7 +15,6 @@
 */
 #include &quot;stdinc.h&quot; //precompiled header
 
-// Xerces geht vor allen Ogre includes...
 #include &quot;XmlResourceManager.h&quot;
 
 #include &quot;GenericWorld.h&quot;

Modified: rl/trunk/engine/core/src/JobScheduler.cpp
===================================================================
--- rl/trunk/engine/core/src/JobScheduler.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/JobScheduler.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -173,7 +173,7 @@
 
     void JobScheduler::removeJob(unsigned long ticket)
     {
-        JobQueue::iterator it = std::find_if(mJobQueue.begin(), mJobQueue.end(),
+        JobQueue::iterator it = std::find_if (mJobQueue.begin(), mJobQueue.end(),
             std::bind2nd(FindJobEntryByTicket(), ticket));
         if (it != mJobQueue.end())
         {
@@ -182,7 +182,7 @@
         }
         else
         {
-			it = std::find_if(mAddedJobs.begin(), mAddedJobs.end(),
+			it = std::find_if (mAddedJobs.begin(), mAddedJobs.end(),
 				std::bind2nd(FindJobEntryByTicket(), ticket));
 			if (it != mAddedJobs.end())
 			{
@@ -202,17 +202,15 @@
         return NAME;
     }
 
-    using namespace XERCES_CPP_NAMESPACE;
-
     void JobScheduler::writeData(SaveGameFileWriter* writer)
     {
-        DOMElement* jobSchedulerParentNode = writer-&gt;appendChildElement(writer-&gt;getDocument(), writer-&gt;getDocument()-&gt;getDocumentElement(), getXmlNodeIdentifier().c_str());
+        TiXmlElement* jobSchedulerParentNode = writer-&gt;appendChildElement(writer-&gt;getDocument()-&gt;RootElement(), getXmlNodeIdentifier().c_str());
 
         for(JobQueue::const_iterator iter = mJobQueue.begin(); iter != mJobQueue.end(); iter++)
         {
-            if( iter-&gt;job-&gt;getPersistenceType() == Job::PERSISTENT &amp;&amp; !(iter-&gt;markedToRemove) )
+            if ( iter-&gt;job-&gt;getPersistenceType() == Job::PERSISTENT &amp;&amp; !(iter-&gt;markedToRemove) )
             {
-                DOMElement* jobNode = writer-&gt;appendChildElement(writer-&gt;getDocument(), jobSchedulerParentNode, &quot;job&quot;);
+                TiXmlElement* jobNode = writer-&gt;appendChildElement(jobSchedulerParentNode, &quot;job&quot;);
                 writer-&gt;setAttributeValueAsInteger(jobNode, &quot;priority&quot;, iter-&gt;priority);
                 writer-&gt;setAttributeValueAsInteger(jobNode, &quot;tokens&quot;, iter-&gt;tokens);
                 writer-&gt;setAttributeValueAsInteger(jobNode, &quot;start&quot;, iter-&gt;start);
@@ -246,15 +244,15 @@
         // delete and discard old jobs
         for( JobQueue::iterator iter = mJobQueue.begin(); iter != mJobQueue.end(); iter++ )
         {
-            if( iter-&gt;job-&gt;getPersistenceType() == Job::PERSISTENT )
+            if ( iter-&gt;job-&gt;getPersistenceType() == Job::PERSISTENT )
             {
                 // delete the job, but do not discard it!
                 iter-&gt;markedToRemove = true;
             }
-            else if( iter-&gt;job-&gt;getPersistenceType() == Job::FINISH_WHEN_GAME_LOADED )
+            else if ( iter-&gt;job-&gt;getPersistenceType() == Job::FINISH_WHEN_GAME_LOADED )
             {
                 // discard the job, then delete it
-                if( iter-&gt;job-&gt;isDiscardable() )
+                if ( iter-&gt;job-&gt;isDiscardable() )
                     iter-&gt;job-&gt;discard();
                 iter-&gt;markedToRemove = true;
             }
@@ -263,22 +261,19 @@
         
         // load jobs from savegamefile
 
-        reader-&gt;initializeXml();
-
-
-        DOMNodeList* rootNodeList = reader-&gt;getDocument()-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
+        XmlElementList rootNodeList = reader-&gt;getElementsByTagName(reader-&gt;getDocument()-&gt;RootElement(), getXmlNodeIdentifier().c_str());
         
-        if(rootNodeList-&gt;getLength())
+        if (!rootNodeList.empty())
         {
-            DOMNodeList* xmlJobs = static_cast&lt;DOMElement*&gt;(rootNodeList-&gt;item(0))-&gt;getElementsByTagName(AutoXMLCh(&quot;job&quot;).data());
-            if (xmlJobs-&gt;getLength())
+            XmlElementList xmlJobs = reader-&gt;getElementsByTagName(rootNodeList[0], &quot;job&quot;);
+            if (!xmlJobs.empty())
             {
-                for (XMLSize_t childIdx1 = 0; childIdx1 &lt; xmlJobs-&gt;getLength(); childIdx1++)
+                for (XmlElementList::iterator it = xmlJobs.begin(); it != xmlJobs.end(); ++it)
                 {
-                    DOMNode* xmlJob_ = xmlJobs-&gt;item(childIdx1);
-                    if (xmlJob_-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+                    const TiXmlNode* xmlJob_ = *it;
+                    if (xmlJob_-&gt;Type() == TiXmlNode::ELEMENT)
                     {
-                        DOMElement* xmlJob = static_cast&lt;DOMElement*&gt;(xmlJob_);
+                    	const TiXmlElement* xmlJob = xmlJob_-&gt;ToElement();
                         JobPriority priority;
                         unsigned short tokens;
                         int start, end;
@@ -331,8 +326,6 @@
                 }
             }
         }
-
-        reader-&gt;shutdownXml();
     }
 
     int JobScheduler::getPriority() const

Modified: rl/trunk/engine/core/src/PhysicsRagDoll.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsRagDoll.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/PhysicsRagDoll.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -23,13 +23,11 @@
 
 #include &lt;sstream&gt;
 
-using namespace XERCES_CPP_NAMESPACE;
-
 namespace rl
 {
 
-PhysicsRagDoll::RagBone::RagBone( PhysicsRagDoll* creator, OgreNewt::World* world, PhysicsRagDoll::RagBone* parent, Ogre::Bone* ogreBone, Ogre::MeshPtr mesh, 
-						  Ogre::Vector3 dir, PhysicsRagDoll::RagBone::BoneShape shape, Ogre::Vector3 size, Ogre::Real mass, Actor* parentActor )
+PhysicsRagDoll::RagBone::RagBone(PhysicsRagDoll* creator, OgreNewt::World* world, PhysicsRagDoll::RagBone* parent, Ogre::Bone* ogreBone, Ogre::MeshPtr mesh,
+						  Ogre::Vector3 dir, PhysicsRagDoll::RagBone::BoneShape shape, Ogre::Vector3 size, Ogre::Real mass, Actor* parentActor)
 {
 	mDoll = creator;
 	mParent = parent;
@@ -45,13 +43,13 @@
 	if (dir == Ogre::Vector3::UNIT_Y)
 	{
 		rot.FromEulerAnglesXYZ(Ogre::Degree(0), Ogre::Degree(0), Ogre::Degree(90));
-		orient.FromRotationMatrix( rot );
+		orient.FromRotationMatrix(rot);
 	}
 
 	if (dir == Ogre::Vector3::UNIT_Z)
 	{
 		rot.FromEulerAnglesXYZ(Ogre::Degree(0), Ogre::Degree(90), Ogre::Degree(0));
-		orient.FromRotationMatrix( rot );
+		orient.FromRotationMatrix(rot);
 	}
 
 
@@ -59,102 +57,102 @@
 	switch (shape)
 	{
 	case PhysicsRagDoll::RagBone::BS_BOX:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size, 0 ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box(world, size, 0));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CAPSULE:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Capsule( world, size.y, size.x, 0, orient, pos ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Capsule(world, size.y, size.x, 0, orient, pos));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CONE:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cone( world, size.y, size.x, 0, orient, pos ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cone(world, size.y, size.x, 0, orient, pos));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CYLINDER:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder( world, size.y, size.x, 0, orient, pos ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Cylinder(world, size.y, size.x, 0, orient, pos));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_ELLIPSOID:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid( world, size, 0 ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(world, size, 0));
 		break;
 
 	case PhysicsRagDoll::RagBone::BS_CONVEXHULL:
-		col = _makeConvexHull( world, mesh, size.x );
+		col = _makeConvexHull(world, mesh, size.x);
 		break;
 
 	default:
-		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box( world, size, 0 ));
+		col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::Box(world, size, 0));
 		break;
 	}
 
-    if( col )
+    if (col)
     {
-        if( col-&gt;getNewtonCollision() == NULL )
+        if (col-&gt;getNewtonCollision() == NULL)
         {
             col.reset();
         }
     }
 
-    if( !col )
+    if (!col)
     {
         LOG_WARNING(Logger::CORE, &quot; error creating collision for '&quot; + ogreBone-&gt;getName() + &quot;', still continuing.&quot;);
         mBody = NULL;
     }
     else
     {
-    	mBody = new OgreNewt::Body( world, col );
-        mBody-&gt;setUserData( Ogre::Any(parentActor) );
+    	mBody = new OgreNewt::Body(world, col);
+        mBody-&gt;setUserData(Ogre::Any(parentActor));
     	mBody-&gt;setStandardForceCallback();
         const OgreNewt::MaterialID* ragdollMat = PhysicsManager::getSingleton().createMaterialID(&quot;default&quot;);
         mBody-&gt;setMaterialGroupID(ragdollMat);
 
 	    Ogre::Vector3 inertia;
     	Ogre::Vector3 com;
-    	col-&gt;calculateInertialMatrix( inertia, com );
+    	col-&gt;calculateInertialMatrix(inertia, com);
 	
-	    mBody-&gt;setMassMatrix( mass, inertia * mass );
-    	mBody-&gt;setCenterOfMass( com );
+	    mBody-&gt;setMassMatrix(mass, inertia * mass);
+    	mBody-&gt;setCenterOfMass(com);
 
-	    mBody-&gt;setCustomTransformCallback( PhysicsRagDoll::_placementCallback );
+	    mBody-&gt;setCustomTransformCallback(PhysicsRagDoll::_placementCallback);
 
 
-    	mOgreBone-&gt;setManuallyControlled( true );
+    	mOgreBone-&gt;setManuallyControlled(true);
     }
 }
 
 
 PhysicsRagDoll::RagBone::~RagBone()
 {
-	mOgreBone-&gt;setManuallyControlled( false );
-    if( mBody )
+	mOgreBone-&gt;setManuallyControlled(false);
+    if (mBody)
     	delete mBody;
 }
 
 
-void PhysicsRagDoll::RagBone::_hingeCallback( OgreNewt::BasicJoints::Hinge* me )
+void PhysicsRagDoll::RagBone::_hingeCallback(OgreNewt::BasicJoints::Hinge* me)
 {
     PhysicsRagDoll::RagBone* bone = Ogre::any_cast&lt;PhysicsRagDoll::RagBone*&gt;(me-&gt;getUserData());
 
 	Ogre::Degree angle = me-&gt;getJointAngle();
-	Ogre::Degree lim1( bone-&gt;getLimit1() );
-	Ogre::Degree lim2( bone-&gt;getLimit2() );
+	Ogre::Degree lim1(bone-&gt;getLimit1());
+	Ogre::Degree lim2(bone-&gt;getLimit2());
 
 	if (angle &lt; lim1)
 	{
-		Ogre::Real accel = me-&gt;calculateStopAlpha( lim1 );
-		me-&gt;setCallbackAccel( accel );
+		Ogre::Real accel = me-&gt;calculateStopAlpha(lim1);
+		me-&gt;setCallbackAccel(accel);
 	}
 
 	if (angle &gt; lim2)
 	{
-		Ogre::Real accel = me-&gt;calculateStopAlpha( lim2 );
-		me-&gt;setCallbackAccel( accel );
+		Ogre::Real accel = me-&gt;calculateStopAlpha(lim2);
+		me-&gt;setCallbackAccel(accel);
 	}
 
 }
 
 
-OgreNewt::ConvexCollisionPtr PhysicsRagDoll::RagBone::_makeConvexHull( OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight )
+OgreNewt::ConvexCollisionPtr PhysicsRagDoll::RagBone::_makeConvexHull(OgreNewt::World* world, Ogre::MeshPtr mesh, Ogre::Real minWeight)
 {
 	std::vector&lt; Ogre::Vector3 &gt; vertexVector;
 
@@ -163,7 +161,7 @@
 	unsigned int boneIndex = mOgreBone-&gt;getHandle();
 
 	Ogre::Matrix4 invMatrix;
-	invMatrix.makeInverseTransform( -mOgreBone-&gt;_getBindingPoseInversePosition(), Ogre::Vector3::UNIT_SCALE / mOgreBone-&gt;_getBindingPoseInverseScale(), mOgreBone-&gt;_getBindingPoseInverseOrientation().Inverse());
+	invMatrix.makeInverseTransform(-mOgreBone-&gt;_getBindingPoseInversePosition(), Ogre::Vector3::UNIT_SCALE / mOgreBone-&gt;_getBindingPoseInverseScale(), mOgreBone-&gt;_getBindingPoseInverseOrientation().Inverse());
 
 	unsigned int num_sub = mesh-&gt;getNumSubMeshes();
 
@@ -183,20 +181,20 @@
 			v_data = mesh-&gt;sharedVertexData;
 			v_count = v_data-&gt;vertexCount;
 			v_decl = v_data-&gt;vertexDeclaration;
-			p_elem = v_decl-&gt;findElementBySemantic( Ogre::VES_POSITION );
+			p_elem = v_decl-&gt;findElementBySemantic(Ogre::VES_POSITION);
 		}
 		else
 		{
 			v_data = submesh-&gt;vertexData;
 			v_count = v_data-&gt;vertexCount;
 			v_decl = v_data-&gt;vertexDeclaration;
-			p_elem = v_decl-&gt;findElementBySemantic( Ogre::VES_POSITION );
+			p_elem = v_decl-&gt;findElementBySemantic(Ogre::VES_POSITION);
 		}		
 			
 		size_t start = v_data-&gt;vertexStart;
 		//pointer
-		Ogre::HardwareVertexBufferSharedPtr v_sptr = v_data-&gt;vertexBufferBinding-&gt;getBuffer( p_elem-&gt;getSource() );
-		unsigned char* v_ptr = static_cast&lt;unsigned char*&gt;(v_sptr-&gt;lock( Ogre::HardwareBuffer::HBL_READ_ONLY ));
+		Ogre::HardwareVertexBufferSharedPtr v_sptr = v_data-&gt;vertexBufferBinding-&gt;getBuffer(p_elem-&gt;getSource());
+		unsigned char* v_ptr = static_cast&lt;unsigned char*&gt;(v_sptr-&gt;lock(Ogre::HardwareBuffer::HBL_READ_ONLY));
 		unsigned char* v_offset;
 		
 		while (bai.hasMoreElements())
@@ -209,7 +207,7 @@
 				{
 					//get offset to Position data!
 					v_offset = v_ptr + (vba.vertexIndex * v_sptr-&gt;getVertexSize());
-					p_elem-&gt;baseVertexPointerToElement( v_offset, &amp;v_Posptr );
+					p_elem-&gt;baseVertexPointerToElement(v_offset, &amp;v_Posptr);
 
 					Ogre::Vector3 vert;
 					vert.x = *v_Posptr; v_Posptr++;
@@ -219,7 +217,7 @@
 					// apply transformation in to local space.
 					vert = invMatrix * vert;
 
-					vertexVector.push_back( vert );
+					vertexVector.push_back(vert);
 
 					Ogre::LogManager::getSingletonPtr()-&gt;logMessage(&quot;  vertex found! id:&quot;+Ogre::StringConverter::toString(vba.vertexIndex));
 				}
@@ -245,8 +243,8 @@
 
 	//////////////////////////////////////////////////////////////////////////////////
     OgreNewt::ConvexCollisionPtr col;
-    if( numVerts &gt; 0 )
-    	col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull( world, verts, numVerts, 0 ));
+    if (numVerts &gt; 0)
+    	col = OgreNewt::ConvexCollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(world, verts, numVerts, 0));
 
 	delete []verts;
 
@@ -256,7 +254,7 @@
 
 
 
-PhysicsRagDoll::PhysicsRagDoll( const Ogre::String&amp; ragdollResource, Actor* actor) :
+PhysicsRagDoll::PhysicsRagDoll(const Ogre::String&amp; ragdollResource, Actor* actor) :
     mRootBone(NULL),
     mNode(NULL),
     mWorld(NULL),
@@ -266,7 +264,7 @@
     mRootBone = NULL;
 	mNode = actor-&gt;_getSceneNode();
 	mWorld = PhysicsManager::getSingleton()._getNewtonWorld();
-    if( !actor-&gt;getControlledObject()-&gt;isMeshObject() )
+    if (!actor-&gt;getControlledObject()-&gt;isMeshObject())
         Throw(IllegalArgumentException, &quot;PhysicsRagDoll::PhysicsRagDoll needs a Mesh-Actor as argument!&quot;);
 
     MeshObject* meshObj = static_cast&lt;MeshObject*&gt;(actor-&gt;getControlledObject());
@@ -283,37 +281,34 @@
 
     LOG_MESSAGE(Logger::CORE, &quot;Loading ragdoll '&quot; + ragdollResource + &quot;'&quot;);
 
-    initializeXml();
-    DOMDocument* doc = loadDocument(ragdollResource);
-    if( !doc )
+    TiXmlDocument* doc = loadDocument(ragdollResource);
+    if (!doc)
     {
         LOG_ERROR(Logger::CORE, &quot;Ragdoll resource '&quot; + ragdollResource + &quot;' not found&quot;);
     }
     else
     {
 
-	    DOMElement* dataDocumentContent = doc-&gt;getDocumentElement();
-		mRootBone =_addAllBones( NULL, getChildNamed(dataDocumentContent, &quot;Bone&quot;), actor);
+	    TiXmlElement* dataDocumentContent = doc-&gt;RootElement();
+		mRootBone =_addAllBones(NULL, getChildNamed(dataDocumentContent, &quot;Bone&quot;), actor);
     }
-    shutdownXml();
-
 }
 
 
-PhysicsRagDoll::RagBone* PhysicsRagDoll::_addAllBones(PhysicsRagDoll::RagBone* parent, DOMElement* boneElement, Actor* parentActor)
+PhysicsRagDoll::RagBone* PhysicsRagDoll::_addAllBones(PhysicsRagDoll::RagBone* parent, TiXmlElement* boneElement, Actor* parentActor)
 {
 	// get the information for the bone represented by this element.
     Ogre::Vector3 dir = getAttributeValueAsVector3(boneElement, &quot;dir&quot;);
-	Ogre::Real length = getAttributeValueAsReal( boneElement, &quot;length&quot;);
+	Ogre::Real length = getAttributeValueAsReal(boneElement, &quot;length&quot;);
 		
-	Ogre::Vector3 size = getAttributeValueAsVector3( boneElement, &quot;size&quot;);
+	Ogre::Vector3 size = getAttributeValueAsVector3(boneElement, &quot;size&quot;);
 	
 	
-	Ogre::String skeleton_bone = getAttributeValueAsStdString( boneElement, &quot;skeleton_bone&quot;);
-	Ogre::Bone* ogrebone = mSkeleton-&gt;getBone( skeleton_bone );
+	Ogre::String skeleton_bone = getAttributeValueAsStdString(boneElement, &quot;skeleton_bone&quot;);
+	Ogre::Bone* ogrebone = mSkeleton-&gt;getBone(skeleton_bone);
 
 
-	Ogre::String shapestr = getAttributeValueAsStdString( boneElement, &quot;shape&quot;);
+	Ogre::String shapestr = getAttributeValueAsStdString(boneElement, &quot;shape&quot;);
 	PhysicsRagDoll::RagBone::BoneShape shape = PhysicsRagDoll::RagBone::BS_BOX;
 
 	if (shapestr==&quot;box&quot;)
@@ -334,10 +329,10 @@
 	if (shapestr==&quot;hull&quot;)
 		shape = PhysicsRagDoll::RagBone::BS_CONVEXHULL;
 
-	Ogre::Real mass = getAttributeValueAsReal( boneElement, &quot;mass&quot; );
+	Ogre::Real mass = getAttributeValueAsReal(boneElement, &quot;mass&quot;);
 	
 	///////////////////////////////////////////////////////////////////////////////
-	RagBone* me = _addBone( mWorld, parent, dir, shape, size, mass, ogrebone,  parentActor);
+	RagBone* me = _addBone(mWorld, parent, dir, shape, size, mass, ogrebone,  parentActor);
 	///////////////////////////////////////////////////////////////////////////////
 
 	// position the bone.
@@ -348,22 +343,22 @@
 	else
 		bonepos = mNode-&gt;_getFullTransform() * ogrebone-&gt;_getDerivedPosition();
 
-    if( me-&gt;getBody() )
-    	me-&gt;getBody()-&gt;setPositionOrientation( bonepos, boneorient );
+    if (me-&gt;getBody())
+    	me-&gt;getBody()-&gt;setPositionOrientation(bonepos, boneorient);
 
 	// set offsets
 	if (!parent)
 	{
 		Ogre::Quaternion offsetorient = (boneorient.Inverse()) * mNode-&gt;_getDerivedOrientation();
 		Ogre::Vector3 offsetpos = boneorient.Inverse() * (mNode-&gt;_getDerivedPosition() - bonepos);
-		me-&gt;setOffset( offsetorient, offsetpos );
+		me-&gt;setOffset(offsetorient, offsetpos);
 	}
 
 
 	// get the joint to connect this bone with it's parent.
-	if (parent &amp;&amp; me-&gt;getBody() )
+	if (parent &amp;&amp; me-&gt;getBody())
 	{
-		DOMElement* jointElement = getChildNamed( boneElement, &quot;Joint&quot; );
+		TiXmlElement* jointElement = getChildNamed(boneElement, &quot;Joint&quot;);
 		if (!jointElement)
 		{
 			// error!
@@ -371,8 +366,8 @@
 			return me;
 		}
 
-		Ogre::Vector3 jointpin = getAttributeValueAsVector3( jointElement, &quot;pin&quot;);
-		Ogre::String jointtypestr = getAttributeValueAsStdString( jointElement, &quot;type&quot;);
+		Ogre::Vector3 jointpin = getAttributeValueAsVector3(jointElement, &quot;pin&quot;);
+		Ogre::String jointtypestr = getAttributeValueAsStdString(jointElement, &quot;type&quot;);
 		PhysicsRagDoll::JointType jointtype = PhysicsRagDoll::JT_BALLSOCKET;
 
 		if (jointtypestr == &quot;ballsocket&quot;)
@@ -382,13 +377,13 @@
 			jointtype = PhysicsRagDoll::JT_HINGE;
 
 
-		Ogre::Real limit1 = getAttributeValueAsReal( jointElement, &quot;limit1&quot; );
-		Ogre::Real limit2 = getAttributeValueAsReal( jointElement, &quot;limit2&quot; );
+		Ogre::Real limit1 = getAttributeValueAsReal(jointElement, &quot;limit1&quot;);
+		Ogre::Real limit2 = getAttributeValueAsReal(jointElement, &quot;limit2&quot;);
 
 		Ogre::Vector3 jpos = mNode-&gt;_getFullTransform() * ogrebone-&gt;_getDerivedPosition();
 		Ogre::Vector3 jpin = (mNode-&gt;_getDerivedOrientation() * parent-&gt;getOgreBone()-&gt;_getDerivedOrientation()) * jointpin;
 
-		_joinBones( jointtype, parent, me, jpos, jpin, limit1, limit2, mWorld);
+		_joinBones(jointtype, parent, me, jpos, jpin, limit1, limit2, mWorld);
 	}
 	
     LOG_MESSAGE(Logger::CORE, &quot; added bone from '&quot;+ogrebone-&gt;getName()+&quot;'.&quot;);
@@ -396,12 +391,11 @@
 	///////////////////////////////////////////////////////////////////////////////
 	///////////////////////////////////////////////////////////////////////////////
 	// add all children of this bone.
-    for (DOMNode* cur = boneElement-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+    for (TiXmlNode* cur = boneElement-&gt;FirstChild(); cur; cur = cur-&gt;NextSibling())
     {
-        if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE &amp;&amp; hasNodeName(cur, &quot;Bone&quot;))
+        if (cur-&gt;Type() == TiXmlNode::ELEMENT &amp;&amp; hasNodeName(cur, &quot;Bone&quot;))
         {
-            DOMElement* childBoneElem = static_cast&lt;DOMElement*&gt;(cur);
-		    _addAllBones( me, childBoneElem, parentActor );
+		    _addAllBones(me, cur-&gt;ToElement(), parentActor);
         }
 	}
 
@@ -411,7 +405,7 @@
 
 PhysicsRagDoll::~PhysicsRagDoll()
 {
-    for(RagBoneMapIterator it = mRagBonesMap.begin(); it != mRagBonesMap.end(); it++)
+    for (RagBoneMapIterator it = mRagBonesMap.begin(); it != mRagBonesMap.end(); it++)
     {
 		RagBone* bone = it-&gt;second;
 		delete bone;
@@ -419,16 +413,16 @@
 }
 
 
-PhysicsRagDoll::RagBone* PhysicsRagDoll::_addBone( OgreNewt::World* world, PhysicsRagDoll::RagBone* parent, Ogre::Vector3 dir, RagBone::BoneShape shape, Ogre::Vector3 size, Ogre::Real mass, Ogre::Bone* ogrebone, Actor* parentActor )
+PhysicsRagDoll::RagBone* PhysicsRagDoll::_addBone(OgreNewt::World* world, PhysicsRagDoll::RagBone* parent, Ogre::Vector3 dir, RagBone::BoneShape shape, Ogre::Vector3 size, Ogre::Real mass, Ogre::Bone* ogrebone, Actor* parentActor)
 {
-	PhysicsRagDoll::RagBone* bone = new PhysicsRagDoll::RagBone( this, world, parent, ogrebone, mMesh, dir, shape, size, mass, parentActor );
+	PhysicsRagDoll::RagBone* bone = new PhysicsRagDoll::RagBone(this, world, parent, ogrebone, mMesh, dir, shape, size, mass, parentActor);
 
-	mRagBonesMap.insert(std::make_pair( bone-&gt;getBody(), bone ));
+	mRagBonesMap.insert(std::make_pair(bone-&gt;getBody(), bone));
 
 	return bone;
 }
 
-void PhysicsRagDoll::_joinBones( PhysicsRagDoll::JointType type, RagBone* parent, RagBone* child, Ogre::Vector3 pos, Ogre::Vector3 pin, Ogre::Real limit1, Ogre::Real limit2, OgreNewt::World* world )
+void PhysicsRagDoll::_joinBones(PhysicsRagDoll::JointType type, RagBone* parent, RagBone* child, Ogre::Vector3 pos, Ogre::Vector3 pin, Ogre::Real limit1, Ogre::Real limit2, OgreNewt::World* world)
 {
 	pin.normalise();
 	OgreNewt::Joint* joint = NULL;
@@ -436,27 +430,27 @@
 	switch (type)
 	{
 	case PhysicsRagDoll::JT_BALLSOCKET:
-		joint = new OgreNewt::BasicJoints::BallAndSocket( world, child-&gt;getBody(), parent-&gt;getBody(), pos );
+		joint = new OgreNewt::BasicJoints::BallAndSocket(world, child-&gt;getBody(), parent-&gt;getBody(), pos);
 		((OgreNewt::BasicJoints::BallAndSocket*)joint)-&gt;setLimits(pin, Ogre::Degree(limit1), Ogre::Degree(limit2));
 		break;
 
 	case PhysicsRagDoll::JT_HINGE:
-		joint = new OgreNewt::BasicJoints::Hinge( world, child-&gt;getBody(), parent-&gt;getBody(), pos, pin );
-		((OgreNewt::BasicJoints::Hinge*)joint)-&gt;setCallback( RagBone::_hingeCallback );
-		joint-&gt;setUserData( Ogre::Any(child) );
-		child-&gt;setLimits( limit1, limit2 );
+		joint = new OgreNewt::BasicJoints::Hinge(world, child-&gt;getBody(), parent-&gt;getBody(), pos, pin);
+		((OgreNewt::BasicJoints::Hinge*)joint)-&gt;setCallback(RagBone::_hingeCallback);
+		joint-&gt;setUserData(Ogre::Any(child));
+		child-&gt;setLimits(limit1, limit2);
 		break;
 	}
 
 }
 
 
-void PhysicsRagDoll::_placementCallback( OgreNewt::Body* me, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos, int threadindex )
+void PhysicsRagDoll::_placementCallback(OgreNewt::Body* me, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos, int threadindex)
 {
     Actor* parentActor = Ogre::any_cast&lt;Actor*&gt;(me-&gt;getUserData());
 	PhysicsRagDoll* doll = parentActor-&gt;getPhysicalThing()-&gt;getRagDoll();
     PhysicsRagDoll::RagBoneMapIterator it = doll-&gt;mRagBonesMap.find(me);
-    if( it == doll-&gt;mRagBonesMap.end() )
+    if (it == doll-&gt;mRagBonesMap.end())
     {
         LOG_ERROR(Logger::CORE, &quot;Could not find ragdoll-bone in PhysicsRagDoll::_placementCallback!&quot;);
         return;
@@ -469,8 +463,8 @@
 		Ogre::Quaternion finalorient = (orient * bone-&gt;getOffsetOrient());
 		Ogre::Vector3 finalpos = pos + (orient * bone-&gt;getOffsetPos());
 
-		doll-&gt;mNode-&gt;setPosition( finalpos );
-		doll-&gt;mNode-&gt;setOrientation( finalorient );
+		doll-&gt;mNode-&gt;setPosition(finalpos);
+		doll-&gt;mNode-&gt;setOrientation(finalorient);
 	}
 	else
 	{
@@ -478,22 +472,22 @@
 		Ogre::Quaternion parentorient;
 		Ogre::Vector3 parentpos;
 
-        if( bone-&gt;getParent()-&gt;getBody() )
-    		bone-&gt;getParent()-&gt;getBody()-&gt;getPositionOrientation( parentpos, parentorient );
+        if (bone-&gt;getParent()-&gt;getBody())
+    		bone-&gt;getParent()-&gt;getBody()-&gt;getPositionOrientation(parentpos, parentorient);
         else
             parentorient = bone-&gt;getParent()-&gt;getOgreBone()-&gt;getOrientation();
 
 
         Ogre::Quaternion localorient = orient;
-        if( bone-&gt;getOgreBone()-&gt;getInheritOrientation() )
+        if (bone-&gt;getOgreBone()-&gt;getInheritOrientation())
             localorient = parentorient.Inverse() * localorient;
 
-		bone-&gt;getOgreBone()-&gt;setOrientation( localorient );
+		bone-&gt;getOgreBone()-&gt;setOrientation(localorient);
 	}
 }
 
 
-void PhysicsRagDoll::setInheritedVelOmega( const Ogre::Vector3&amp; vel, const Ogre::Vector3&amp; omega )
+void PhysicsRagDoll::setInheritedVelOmega(const Ogre::Vector3&amp; vel, const Ogre::Vector3&amp; omega)
 {
 	// find main position.
 	Ogre::Vector3 mainpos = mNode-&gt;_getDerivedPosition();
@@ -503,15 +497,15 @@
 		Ogre::Vector3 pos;
 		Ogre::Quaternion orient;
 
-        if( it-&gt;second-&gt;getBody() )
+        if (it-&gt;second-&gt;getBody())
         {
-		    it-&gt;second-&gt;getBody()-&gt;getPositionOrientation( pos, orient );
-		    it-&gt;second-&gt;getBody()-&gt;setVelocity( vel + omega.crossProduct( pos - mainpos ) );
+		    it-&gt;second-&gt;getBody()-&gt;getPositionOrientation(pos, orient);
+		    it-&gt;second-&gt;getBody()-&gt;setVelocity(vel + omega.crossProduct(pos - mainpos));
         }
 	}
 }
 
-void PhysicsRagDoll::setPositionOrientation( const Ogre::Vector3&amp; pos, const Ogre::Quaternion &amp;orient )
+void PhysicsRagDoll::setPositionOrientation(const Ogre::Vector3&amp; pos, const Ogre::Quaternion &amp;orient)
 {
     Ogre::Vector3 oldPos = mNode-&gt;_getDerivedPosition();
     Ogre::Quaternion oldOri = mNode-&gt;_getDerivedOrientation();
@@ -520,7 +514,7 @@
     for (RagBoneMapIterator it = mRagBonesMap.begin(); it != mRagBonesMap.end(); it++)
     {
         OgreNewt::Body* body = it-&gt;second-&gt;getBody();
-        if( body )
+        if (body)
         {
             Ogre::Vector3 boneOldPos;
             Ogre::Quaternion boneOldOri;
@@ -541,9 +535,9 @@
 
 void PhysicsRagDoll::setMaterialID(const OgreNewt::MaterialID* materialid)
 {
-    for(RagBoneMapIterator it = mRagBonesMap.begin(); it != mRagBonesMap.end(); it++)
+    for (RagBoneMapIterator it = mRagBonesMap.begin(); it != mRagBonesMap.end(); it++)
     {
-        if( it-&gt;second-&gt;getBody() )
+        if (it-&gt;second-&gt;getBody())
             it-&gt;second-&gt;getBody()-&gt;setMaterialGroupID(materialid);
     }
 }

Modified: rl/trunk/engine/core/src/SaveGameFile.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveGameFile.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/SaveGameFile.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -18,7 +18,6 @@
 
 #include &quot;SaveGameFile.h&quot;
 #include &quot;SaveGameManager.h&quot;
-#include &lt;xercesc/framework/LocalFileFormatTarget.hpp&gt;
 
 #include &lt;ConfigurationManager.h&gt;
 #include &lt;CoreSubsystem.h&gt;
@@ -87,12 +86,6 @@
         Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(this);
     }
 
-    XERCES_CPP_NAMESPACE::XMLFormatTarget* SaveGameFile::getFormatTarget()
-    {
-        ///@todo: encryption
-        return new XERCES_CPP_NAMESPACE::LocalFileFormatTarget(this-&gt;buildFilename().c_str());
-    }
-
     void SaveGameFile::deleteFileFromStorage()
     {
         if(remove(buildFilename().c_str()))

Modified: rl/trunk/engine/core/src/SaveGameFileReader.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveGameFileReader.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/SaveGameFileReader.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,16 +16,12 @@
 
 #include &quot;stdinc.h&quot;
 
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
 #include &quot;SaveGameFileReader.h&quot;
 #include &quot;SaveGameManager.h&quot;
 #include &quot;SaveGameData.h&quot;
 
 #include &quot;CoreSubsystem.h&quot;
 
-using namespace XERCES_CPP_NAMESPACE;
-
 namespace rl
 {
     SaveGameFileReader::SaveGameFileReader()
@@ -34,12 +30,10 @@
 
     void SaveGameFileReader::parseSaveGameFile(SaveGameFile* file, const SaveGameDataOrderMap &amp;map)
     {
-        initializeXml();
-
         mDocument = loadDocument(file-&gt;getDataStream());
 
-        int version = getAttributeValueAsInteger(mDocument-&gt;getDocumentElement(), &quot;Engineversion&quot;);
-        if(version &gt;= CoreSubsystem::getSingleton().getEngineBuildNumber())
+        int version = getAttributeValueAsInteger(mDocument-&gt;RootElement(), &quot;Engineversion&quot;);
+        if (version &gt;= CoreSubsystem::getSingleton().getEngineBuildNumber())
             LOG_MESSAGE(Logger::CORE, &quot;Loading save game: Engine version is ok&quot;);
         else
             LOG_ERROR(Logger::CORE, &quot;Loading save game: Save game version is newer then engine version! Loading save game could crash&quot;);
@@ -52,31 +46,28 @@
 
         file-&gt;closeDataStream(); //make the save game writable
 
-        mDocument = NULL;
-
-        shutdownXml();
+		mDocument = NULL;
+        delete mDocument;
     }
 
     void SaveGameFileReader::parseSaveGameFileHeader(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName, SaveGameFile* file)
     {
-        initializeXml();
-
-        if(stream-&gt;size())
+        if (stream-&gt;size())
         {
-            DOMDocument* doc = loadDocument(stream);
+            TiXmlDocument* doc = loadDocument(stream);
 
-             DOMNodeList* headerDefsXml = doc-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(&quot;header&quot;).data());
-             if(headerDefsXml-&gt;getLength())
+             XmlElementList headerDefsXml = getElementsByTagName(mDocument-&gt;RootElement(), &quot;header&quot;);
+             if (!headerDefsXml.empty())
              {
-                 DOMElement* elem = static_cast&lt;DOMElement*&gt;(headerDefsXml-&gt;item(0));
-                 /*DOMNodeList* headerDefChildren = elem-&gt;getChildNodes();
+            	 const TiXmlElement* elem = headerDefsXml[0];
+                 /*TiXmlNodeList* headerDefChildren = elem-&gt;getChildNodes();
                  for(XMLSize_t childIdx = 0; childIdx &lt; headerDefChildren-&gt;getLength(); childIdx++)
                  {
-                     DOMNode* curChild = headerDefChildren-&gt;item(childIdx);
-                     if (curChild-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+                     TiXmlNode* curChild = headerDefChildren-&gt;item(childIdx);
+                     if (curChild-&gt;getNodeType() == TiXmlNode::ELEMENT_NODE)
                      {
-                         PropertyEntry entry = processProperty(static_cast&lt;DOMElement*&gt;(curChild));
-                         if(entry.first != &quot;&quot;)
+                         PropertyEntry entry = processProperty(static_cast&lt;TiXmlElement*&gt;(curChild));
+                         if (entry.first != &quot;&quot;)
                          {
                             file-&gt;setProperty(entry.first, entry.second);
                          }
@@ -85,27 +76,21 @@
                  PropertyRecordPtr set = getPropertiesAsRecord(elem);
                  file-&gt;setProperties(set);
              }
+             delete doc;
         }
-
-        shutdownXml();
     }
 
     PropertyRecordPtr SaveGameFileReader::getAllPropertiesAsRecord(SaveGameData* data)
     {
         PropertyRecordPtr properties(new PropertyRecord());
 
-        initializeXml();
+        XmlElementList rootNodeList = getElementsByTagName(mDocument-&gt;RootElement(), data-&gt;getXmlNodeIdentifier().c_str());
 
-        DOMNodeList* rootNodeList = getDocument()-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(data-&gt;getXmlNodeIdentifier().c_str()).data());
-
-        if (rootNodeList-&gt;getLength())
+        if (!rootNodeList.empty())
         {
-            DOMNode* xmlPropElem = rootNodeList-&gt;item(0);
-            properties = getPropertiesAsRecord(static_cast&lt;DOMElement*&gt;(xmlPropElem));
+            properties = getPropertiesAsRecord(rootNodeList[0]);
         }
 
-        shutdownXml();
-
         return properties;
     }
 }

Modified: rl/trunk/engine/core/src/SaveGameFileWriter.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveGameFileWriter.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/SaveGameFileWriter.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -21,9 +21,6 @@
 #include &quot;SaveGameManager.h&quot;
 
 #include &lt;XmlProcessor.h&gt;
-#include &lt;xercesc/dom/DOM.hpp&gt;
-#include &lt;xercesc/dom/DOMAttr.hpp&gt;
-#include &lt;xercesc/dom/DOMElement.hpp&gt;
 #include &lt;Properties.h&gt;
 
 #ifdef __APPLE__
@@ -36,9 +33,9 @@
 #include &lt;ContentModule.h&gt;
 #include &lt;TimeSource.h&gt;
 
+#include &lt;cstdio&gt;
 #include &lt;ctime&gt;
 
-using namespace XERCES_CPP_NAMESPACE;
 using namespace Ogre;
 
 namespace rl
@@ -46,39 +43,27 @@
     void SaveGameFileWriter::buildSaveGameFile(SaveGameFile *file, const SaveGameDataOrderMap &amp;map)
     {
         //@toto: build
-        initializeXml();
 
-        XMLCh tempStr[100];
-        XMLString::transcode(&quot;LS&quot;, tempStr, 99);
-        mImplementation = DOMImplementationRegistry::getDOMImplementation(tempStr);
-        mWriter = static_cast&lt;DOMImplementationLS*&gt;(mImplementation)-&gt;createDOMWriter();
-        mTarget = file-&gt;getFormatTarget();
-        mDocument = static_cast&lt;DOMImplementation*&gt;(mImplementation)-&gt;createDocument(0, XMLString::transcode(&quot;SaveGameFile&quot;), 0);
+        mDocument = new TiXmlDocument();
+        mDocument-&gt;SetValue(&quot;SaveGameFile&quot;);
 
-        if (mWriter-&gt;canSetFeature(XMLUni::fgDOMWRTDiscardDefaultContent, true))
-            mWriter-&gt;setFeature(XMLUni::fgDOMWRTDiscardDefaultContent, true);
-
-        if (mWriter-&gt;canSetFeature(XMLUni::fgDOMWRTFormatPrettyPrint, true))
-             mWriter-&gt;setFeature(XMLUni::fgDOMWRTFormatPrettyPrint, true);
-
-        mDocument-&gt;setNodeValue(XMLString::transcode(&quot;SaveGameFile&quot;)); //Set name of document root node
-
+        TiXmlElement* rootElem = mDocument-&gt;RootElement();
         //Write SaveGameVersion
-        setAttributeValueAsString(mDocument-&gt;getDocumentElement(), &quot;SaveGameFormatVersion&quot;, &quot;0.5&quot;);
-        setAttributeValueAsInteger(mDocument-&gt;getDocumentElement(), &quot;Engineversion&quot;, CoreSubsystem::getSingleton().getEngineBuildNumber());
+        setAttributeValueAsString(rootElem, &quot;SaveGameFormatVersion&quot;, &quot;0.5&quot;);
+        setAttributeValueAsInteger(rootElem, &quot;Engineversion&quot;, CoreSubsystem::getSingleton().getEngineBuildNumber());
 
         //Write modul of save game
-        DOMElement* header = appendChildElement(mDocument, mDocument-&gt;getDocumentElement(), &quot;header&quot;);
+        TiXmlElement* header = appendChildElement(rootElem, &quot;header&quot;);
         
         PropertyRecordPtr headerSet = file-&gt;getAllProperties();
         for (PropertyRecord::PropertyRecordMap::const_iterator it_header = headerSet-&gt;begin(); it_header != headerSet-&gt;end(); it_header++)
         {
-            this-&gt;processProperty(header, PropertyEntry(it_header-&gt;first.c_str(), it_header-&gt;second));
+            processProperty(header, PropertyEntry(it_header-&gt;first.c_str(), it_header-&gt;second));
         }
 
         ////Write globals
-        //DOMElement* globals = appendChildElement(mDocument, mDocument-&gt;getDocumentElement(), &quot;globals&quot;);
-        //DOMElement* gameTime = appendChildElement(mDocument, globals, &quot;gametime&quot;);
+        //TiXmlElement* globals = appendChildElement(mDocument, mDocument-&gt;getDocumentElement(), &quot;globals&quot;);
+        //TiXmlElement* gameTime = appendChildElement(mDocument, globals, &quot;gametime&quot;);
         //TimeSource* gameTimeSource = TimeSourceManager::getSingleton().getTimeSource(TimeSource::GAMETIME);
         //setAttributeValueAsInteger(gameTime, &quot;milliseconds&quot;, gameTimeSource-&gt;getClock());
 
@@ -87,20 +72,19 @@
             data_iter-&gt;second-&gt;writeData(this);
         }
 
-        mWriter-&gt;writeNode(mTarget, *mDocument);
+        std::FILE* fileHandle = std::fopen(file-&gt;buildFilename().c_str(), &quot;w&quot;);
+        if (fileHandle)
+        {
+        	mDocument-&gt;Print(fileHandle);
+        }
 
-
-        mWriter-&gt;release();
-
         delete mDocument;
-        delete mTarget;
-
-        shutdownXml();
+        mDocument = NULL;
     }
 
     void SaveGameFileWriter::writeEachProperty(SaveGameData* data, const rl::PropertyMap &amp;map)
     {
-        DOMElement* saveElem = appendChildElement(getDocument(), getDocument()-&gt;getDocumentElement(), data-&gt;getXmlNodeIdentifier().c_str());
+        TiXmlElement* saveElem = appendChildElement(mDocument-&gt;RootElement(), data-&gt;getXmlNodeIdentifier().c_str());
 
         XmlPropertyWriter::writeEachPropertyToElem(saveElem, map);
     }

Modified: rl/trunk/engine/core/src/SaveGameManager.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveGameManager.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/SaveGameManager.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -25,12 +25,8 @@
 
 #include &quot;XmlProcessor.h&quot;
 
-#include &lt;xercesc/framework/LocalFileFormatTarget.hpp&gt;
-
 template&lt;&gt; rl::SaveGameManager* Ogre::Singleton&lt;rl::SaveGameManager&gt;::ms_Singleton = 0;
 
-using namespace XERCES_CPP_NAMESPACE;
-
 namespace rl
 {
     SaveGameData::SaveGameData()

Modified: rl/trunk/engine/core/src/TimeSource.cpp
===================================================================
--- rl/trunk/engine/core/src/TimeSource.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/TimeSource.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -180,17 +180,15 @@
 		return &quot;time_sources&quot;;
 	}
 
-	using namespace XERCES_CPP_NAMESPACE;
-
     void TimeSourceManager::writeData(SaveGameFileWriter* writer)
 	{
-		DOMElement* timesources = writer-&gt;appendChildElement(writer-&gt;getDocument(), 
-			writer-&gt;getDocument()-&gt;getDocumentElement(), getXmlNodeIdentifier().c_str());
+		TiXmlElement* timesources = writer-&gt;appendChildElement(
+			writer-&gt;getDocument(), getXmlNodeIdentifier().c_str());
 
-		for(std::map&lt;TimeSource::TimeSourceType, TimeSource*&gt;::const_iterator it_time_sources = mTimeSources.begin(); 
+		for (std::map&lt;TimeSource::TimeSourceType, TimeSource*&gt;::const_iterator it_time_sources = mTimeSources.begin();
 			it_time_sources != mTimeSources.end(); it_time_sources++)
         {
-            DOMElement* timesource = writer-&gt;appendChildElement(writer-&gt;getDocument(), timesources, &quot;time_source&quot;);
+            TiXmlElement* timesource = writer-&gt;appendChildElement(timesources, &quot;time_source&quot;);
 			writer-&gt;setAttributeValueAsInteger(timesource, &quot;ID&quot;, it_time_sources-&gt;first);
 			Property time((int)it_time_sources-&gt;second-&gt;getClock());
 
@@ -202,33 +200,25 @@
 
 	void TimeSourceManager::readData(SaveGameFileReader* reader)
 	{
-		reader-&gt;initializeXml();
+		XmlElementList rootNodeList = reader-&gt;getElementsByTagName(reader-&gt;getDocument()-&gt;RootElement(), getXmlNodeIdentifier().c_str());
 
-		DOMNodeList* rootNodeList = reader-&gt;getDocument()-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
-
-		if(rootNodeList-&gt;getLength())
+		if (!rootNodeList.empty())
         {
-			DOMNodeList* xmlTimeSources = static_cast&lt;DOMElement*&gt;(rootNodeList-&gt;item(0))-&gt;getElementsByTagName(AutoXMLCh(&quot;gameobject&quot;).data()); //there should be only one &quot;gameobjects&quot; node
-            if(xmlTimeSources-&gt;getLength())
-            {
-				for(XMLSize_t childIdx = 0; childIdx &lt; xmlTimeSources-&gt;getLength(); childIdx++)
+			XmlElementList xmlTimeSources = reader-&gt;getElementsByTagName(rootNodeList[0], &quot;gameobject&quot;); //there should be only one &quot;gameobjects&quot; node
+			for (XmlElementList::iterator it = xmlTimeSources.begin(); it != xmlTimeSources.end(); ++it)
+			{
+				const TiXmlElement* xmlTimeSource = *it;
+				TimeSource::TimeSourceType ID = (TimeSource::TimeSourceType)reader-&gt;getAttributeValueAsInteger(
+					xmlTimeSource, &quot;ID&quot;);
+				PropertyRecordPtr properties = reader-&gt;getPropertiesAsRecord(xmlTimeSource);
+
+				std::map&lt;TimeSource::TimeSourceType, TimeSource*&gt;::const_iterator it_time_sources = mTimeSources.find(ID);
+				if (it_time_sources != mTimeSources.end())
 				{
-					DOMNode* xmlTimeSource = xmlTimeSources-&gt;item(childIdx);
-					if(xmlTimeSource-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-                    {
-						TimeSource::TimeSourceType ID = (TimeSource::TimeSourceType)reader-&gt;getAttributeValueAsInteger(
-							static_cast&lt;DOMElement*&gt;(xmlTimeSource), &quot;ID&quot;);
-                        PropertyRecordPtr properties = reader-&gt;getPropertiesAsRecord(static_cast&lt;DOMElement*&gt;(xmlTimeSource));
-	
-						std::map&lt;TimeSource::TimeSourceType, TimeSource*&gt;::const_iterator it_time_sources = mTimeSources.find(ID);
-						if(it_time_sources != mTimeSources.end())
-							it_time_sources-&gt;second-&gt;setClock(properties-&gt;toPropertyMap()[&quot;time&quot;].toInt());
-                    }
+					it_time_sources-&gt;second-&gt;setClock(properties-&gt;toPropertyMap()[&quot;time&quot;].toInt());
 				}
 			}
 		}
-
-		reader-&gt;shutdownXml();
 	}
     
     int TimeSourceManager::getPriority() const

Modified: rl/trunk/engine/core/src/ZoneManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ZoneManager.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/core/src/ZoneManager.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -559,11 +559,9 @@
         return &quot;zonemanager&quot;;
     }
 
-    using namespace XERCES_CPP_NAMESPACE;
-
     void ZoneManager::writeData(SaveGameFileWriter* writer)
     {
-        DOMElement* zoneManagerNode = writer-&gt;appendChildElement(writer-&gt;getDocument(), writer-&gt;getDocument()-&gt;getDocumentElement(), getXmlNodeIdentifier().c_str());
+        TiXmlElement* zoneManagerNode = writer-&gt;appendChildElement(writer-&gt;getDocument()-&gt;RootElement(), getXmlNodeIdentifier().c_str());
 
         // look at all zones if they need to be saved
         for(ZoneMap::iterator zone = mZones.begin(); zone != mZones.end(); zone++)
@@ -571,7 +569,7 @@
             // does this zone wants to be saved
             if( zone-&gt;second-&gt;needsToBeSaved() )
             {
-                DOMElement* zoneNode = writer-&gt;appendChildElement(writer-&gt;getDocument(), zoneManagerNode, &quot;zone&quot;);
+                TiXmlElement* zoneNode = writer-&gt;appendChildElement(zoneManagerNode, &quot;zone&quot;);
                 writer-&gt;setAttributeValueAsStdString(zoneNode, &quot;name&quot;, zone-&gt;first);
                     
                 
@@ -579,7 +577,7 @@
                 GameAreaEventSourceList::iterator gam; ;
                 for( gam = zone-&gt;second-&gt;getEventSources().begin(); gam != zone-&gt;second-&gt;getEventSources().end(); gam++)
                 {
-                    DOMElement* areaNode = writer-&gt;appendChildElement(writer-&gt;getDocument(), zoneNode, &quot;area&quot;);
+                    TiXmlElement* areaNode = writer-&gt;appendChildElement(zoneNode, &quot;area&quot;);
                     writer-&gt;writeEachPropertyToElem(areaNode, (*gam)-&gt;mProperties.toPropertyMap());
                 }
 
@@ -611,41 +609,27 @@
 
         // load zones
         // initialize xmlreader
-        reader-&gt;initializeXml();
+        XmlElementList rootNodeList = reader-&gt;getElementsByTagName(reader-&gt;getDocument(), getXmlNodeIdentifier().c_str());
 
-        DOMNodeList* rootNodeList = reader-&gt;getDocument()-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
-
-        if(rootNodeList-&gt;getLength())
+        if (!rootNodeList.empty())
         {
-            DOMNodeList* xmlZones = static_cast&lt;DOMElement*&gt;(rootNodeList-&gt;item(0))-&gt;getElementsByTagName(AutoXMLCh(&quot;zone&quot;).data());
-            if(xmlZones-&gt;getLength())
-            {
-                for(XMLSize_t childIdx1 = 0; childIdx1 &lt; xmlZones-&gt;getLength(); childIdx1++)
-                {
-                    DOMNode* xmlZone = xmlZones-&gt;item(childIdx1);
-                    if(xmlZone-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-                    {
-                        Ogre::String name = reader-&gt;getAttributeValueAsStdString(static_cast&lt;DOMElement*&gt;(xmlZone), &quot;name&quot;);
-                        Zone* zone = createZone(name, true);
+            XmlElementList xmlZones = reader-&gt;getElementsByTagName(rootNodeList[0], &quot;zone&quot;);
 
-                        DOMNodeList* xmlAreas = static_cast&lt;DOMElement*&gt;(xmlZone)-&gt;getElementsByTagName(AutoXMLCh(&quot;area&quot;).data());
-                        if( xmlAreas-&gt;getLength() )
-                        {
-                            for(XMLSize_t childIdx2 = 0; childIdx2 &lt; xmlAreas-&gt;getLength(); childIdx2++)
-                            {
-                                DOMNode* xmlArea = xmlAreas-&gt;item(childIdx2);
-                                PropertyRecordPtr properties = reader-&gt;getPropertiesAsRecord(static_cast&lt;DOMElement*&gt;(xmlArea));
-                                parseAreaProperties(name, properties);
-                            }
-                        }
-                    }
-                }
-            }
-        }
+			for (XmlElementList::iterator it = xmlZones.begin(); it != xmlZones.end(); ++it)
+			{
+				const TiXmlElement* xmlZone = *it;
+				Ogre::String name = reader-&gt;getAttributeValueAsStdString(xmlZone, &quot;name&quot;);
+				Zone* zone = createZone(name, true);
 
-
-        // close xmlreader
-        reader-&gt;shutdownXml();
+				XmlElementList xmlAreas = reader-&gt;getElementsByTagName(xmlZone, &quot;area&quot;);
+				for (XmlElementList::iterator itA = xmlAreas.begin(); itA != xmlAreas.end(); ++itA)
+				{
+					const TiXmlElement* xmlArea = *itA;
+					PropertyRecordPtr properties = reader-&gt;getPropertiesAsRecord(xmlArea);
+					parseAreaProperties(name, properties);
+				}
+			}
+        }
     }
 
     void ZoneManager::parseAreaProperties(const Ogre::String&amp; name, const PropertyRecordPtr properties)

Modified: rl/trunk/engine/rules/CMakeLists.txt
===================================================================
--- rl/trunk/engine/rules/CMakeLists.txt	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/rules/CMakeLists.txt	2009-11-07 19:39:22 UTC (rev 4961)
@@ -2,7 +2,7 @@
 ${CMAKE_CURRENT_SOURCE_DIR}/include
 ${RL_COMMON_INCLUDE_DIR}
 ${RL_CORE_INCLUDE_DIR}
-${XERCESC_INCLUDE_DIR}
+${TINYXML_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR})

Modified: rl/trunk/engine/rules/include/DsaDataLoader.h
===================================================================
--- rl/trunk/engine/rules/include/DsaDataLoader.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/rules/include/DsaDataLoader.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,9 +17,6 @@
 #ifndef __XdimlLoader_H__
 #define __XdimlLoader_H__
 
-#include &lt;xercesc/dom/DOMDocument.hpp&gt;
-#include &lt;xercesc/dom/DOMElement.hpp&gt;
-
 #include &quot;XmlProcessor.h&quot;
 
 namespace rl {
@@ -29,8 +26,7 @@
 	class Kampftechnik;
 
     class XdimlLoader 
-        : public Ogre::ScriptLoader,
-        private XmlProcessor
+        : public Ogre::ScriptLoader, private XmlProcessor
 	{
     public:
         XdimlLoader();
@@ -42,14 +38,14 @@
     private:
 		int getEBeFromString(const Ogre::String&amp; eBeString);
 
-		void initializeTalente(XERCES_CPP_NAMESPACE::DOMElement* rootTalente);
-		Talent* processTalent(int gruppe, XERCES_CPP_NAMESPACE::DOMElement* talentXml);
+		void initializeTalente(const TiXmlElement* rootTalente);
+		Talent* processTalent(int gruppe, const TiXmlElement* talentXml);
 
-		void initializeCreatures(XERCES_CPP_NAMESPACE::DOMElement* rootCreatures);
-		Creature* processCreature(XERCES_CPP_NAMESPACE::DOMElement* talentXml);
+		void initializeCreatures(const TiXmlElement* rootCreatures);
+		Creature* processCreature(const TiXmlElement* talentXml);
 			
-		void initializeKampftechniken(XERCES_CPP_NAMESPACE::DOMElement* rootKampftechniken);
-		Kampftechnik* processKampftechnik(XERCES_CPP_NAMESPACE::DOMElement* kampftechnikXml);
+		void initializeKampftechniken(const TiXmlElement* rootKampftechniken);
+		Kampftechnik* processKampftechnik(const TiXmlElement* kampftechnikXml);
 
         Ogre::StringVector mScriptPatterns;
     };

Modified: rl/trunk/engine/rules/include/QuestBook.h
===================================================================
--- rl/trunk/engine/rules/include/QuestBook.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/rules/include/QuestBook.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -96,6 +96,7 @@
     virtual const Ogre::StringVector &amp;getScriptPatterns(void) const;
     virtual void parseScript(Ogre::DataStreamPtr &amp;,const Ogre::String &amp;);
     virtual Ogre::Real getLoadingOrder(void) const;
+
 private:
     Ogre::StringVector mScriptPatterns;
 
@@ -112,7 +113,7 @@
     void fireJournalChanged(JournalEntry* entry, int reason);
 
     //loading quests from xml
-    virtual Quest* processQuest(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, Quest* parent);
+    virtual Quest* processQuest(TiXmlElement* dialogXml, Quest* parent);
 };
 
 }

Modified: rl/trunk/engine/rules/src/DsaDataLoader.cpp
===================================================================
--- rl/trunk/engine/rules/src/DsaDataLoader.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/rules/src/DsaDataLoader.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -15,14 +15,11 @@
  */
 #include &quot;stdinc.h&quot; //precompiled header
 
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
 // #include &quot;XdimlLoader.h&quot;
 #include &quot;DsaDataLoader.h&quot;
 
 
 #include &quot;XmlProcessor.h&quot;
-#include &quot;OgreXercesInput.h&quot;
 
 #include &quot;DsaManager.h&quot;
 #include &quot;Talent.h&quot;
@@ -33,13 +30,10 @@
 
 #include &quot;Exception.h&quot;
 
-using namespace XERCES_CPP_NAMESPACE;
 using namespace Ogre;
 
 namespace rl {
 
-	using XERCES_CPP_NAMESPACE::DOMDocument; //XXX: Warum brauche ich das unter VS 2003?
-
     XdimlLoader::XdimlLoader()
         : ScriptLoader()
     {
@@ -50,17 +44,12 @@
 
     void XdimlLoader::parseScript(Ogre::DataStreamPtr &amp;stream, const Ogre::String &amp;groupName)
     {
-        initializeXml();
+		TiXmlDocument* doc = loadDocument(stream);
+		TiXmlElement* dataDocumentContent = getChildNamed(doc-&gt;RootElement(), &quot;Inhalt&quot;);
 
-		DOMDocument* doc = loadDocument(stream);
-		DOMElement* dataDocumentContent = getChildNamed(
-            doc-&gt;getDocumentElement(), &quot;Inhalt&quot;);
-
 		initializeTalente(getChildNamed(dataDocumentContent, &quot;Talente&quot;));
 		initializeKampftechniken(getChildNamed(dataDocumentContent, &quot;Kampftechniken&quot;));
 		initializeCreatures(getChildNamed(dataDocumentContent, &quot;Personen&quot;));
-
-        shutdownXml();
     }
 
     const StringVector&amp; XdimlLoader::getScriptPatterns() const
@@ -73,42 +62,41 @@
         return 1000.0;
     }
 
-    void XdimlLoader::initializeTalente(DOMElement* rootTalente)
+    void XdimlLoader::initializeTalente(const TiXmlElement* rootTalente)
     {
 		if (rootTalente == NULL)
 			return;
 
-	    DOMNodeList* talentGruppen =
-            rootTalente-&gt;getElementsByTagName(AutoXMLCh(&quot;Talentgruppe&quot;).data());
-        for (unsigned int gruppe = 0; gruppe &lt; talentGruppen-&gt;getLength(); gruppe++)
+	    XmlElementList talentGruppen = getElementsByTagName(rootTalente, &quot;Talentgruppe&quot;);
+        for (unsigned int gruppe = 0; gruppe &lt; talentGruppen.size(); gruppe++)
 		{
-			DOMElement* gruppeData = static_cast&lt;DOMElement*&gt;(talentGruppen-&gt;item(gruppe));
-			DOMNodeList* talenteXml =
-                gruppeData-&gt;getElementsByTagName(AutoXMLCh(&quot;Talent&quot;).data());
+        	const TiXmlElement* gruppeData = talentGruppen[gruppe];
+			XmlElementList talenteXml = getElementsByTagName(gruppeData, &quot;Talent&quot;);
             //int numTalent = 0;
-            for (unsigned int talentIdx = 0; talentIdx &lt; talenteXml-&gt;getLength(); talentIdx++)
+            for (unsigned int talentIdx = 0; talentIdx &lt; talenteXml.size(); talentIdx++)
             {
-                Talent* t = processTalent(gruppe, static_cast&lt;DOMElement*&gt;(talenteXml-&gt;item(talentIdx)));
+                Talent* t = processTalent(gruppe, talenteXml[talentIdx]);
                 //numTalent++;
 				DsaManager::getSingleton()._addTalent(t);
             }
 		}
     }
 
-    Talent* XdimlLoader::processTalent(int gruppe, DOMElement* talentXml)
+    Talent* XdimlLoader::processTalent(int gruppe, const TiXmlElement* talentXml)
     {
 		CeGuiString desc = getValueAsString(getChildNamed(talentXml, &quot;Beschreibung&quot;));
         CeGuiString probe = getValueAsString(getChildNamed(talentXml, &quot;Probe&quot;));
         CeGuiString art = getValueAsString(getChildNamed(talentXml, &quot;Art&quot;));
-		DOMElement* eBeNode = getChildNamed(talentXml, &quot;eBE&quot;);
-        DOMElement* ausweichTalenteNode = static_cast&lt;DOMElement*&gt;(getChildNamed(talentXml, &quot;Ausweichtalente&quot;));
+        const TiXmlElement* eBeNode = getChildNamed(talentXml, &quot;eBE&quot;);
+        const TiXmlElement* ausweichTalenteNode = getChildNamed(talentXml, &quot;Ausweichtalente&quot;);
 
 		int ebe = EBE_KEINE_BE;
         if (eBeNode != NULL)
-			ebe = getEBeFromString(AutoChar(eBeNode-&gt;getFirstChild()-&gt;getNodeValue()).data());
+        {
+			ebe = getEBeFromString(eBeNode-&gt;FirstChild()-&gt;Value());
+        }
 
-		CeGuiString name = transcodeToString(
-            talentXml-&gt;getAttribute(AutoXMLCh(&quot;ID&quot;).data()));
+		CeGuiString name = getAttributeValueAsString(talentXml, &quot;ID&quot;);
         EigenschaftTripel eigenschaften;
 		eigenschaften.first = probe.substr(0,2);
         eigenschaften.second = probe.substr(3,2);
@@ -119,16 +107,13 @@
         Talent::AusweichTalente ausweichTalente;
         if( ausweichTalenteNode )
         {
-	        DOMNodeList* ausweichTalentGruppen =
-                ausweichTalenteNode-&gt;getElementsByTagName(AutoXMLCh(&quot;Ausweichtalent&quot;).data());
-            for( unsigned int ausweich = 0; ausweich &lt; ausweichTalentGruppen-&gt;getLength(); ausweich++ )
+	        XmlElementList ausweichTalentGruppen = getElementsByTagName(ausweichTalenteNode, &quot;Ausweichtalent&quot;);
+            for( unsigned int ausweich = 0; ausweich &lt; ausweichTalentGruppen.size(); ausweich++ )
             {
-			    DOMElement* ausweichData = static_cast&lt;DOMElement*&gt;(ausweichTalentGruppen-&gt;item(ausweich));
-	            CeGuiString ausweichName = transcodeToString(
-                    ausweichData-&gt;getAttribute(AutoXMLCh(&quot;ID&quot;).data()));
+            	const TiXmlElement* ausweichData = ausweichTalentGruppen[ausweich];
+	            CeGuiString ausweichName = getAttributeValueAsString(ausweichData, &quot;ID&quot;);
 
-                ausweichTalente[ausweichName] = 
-                    getValueAsInteger(getChildNamed(ausweichData, &quot;Aufschlag&quot;));
+                ausweichTalente[ausweichName] = getValueAsInteger(getChildNamed(ausweichData, &quot;Aufschlag&quot;));
             }
         }
 
@@ -147,35 +132,41 @@
 	int XdimlLoader::getEBeFromString(const Ogre::String&amp; eBeString)
 	{
 		if (eBeString.length() == 0)
+		{
 			return EBE_KEINE_BE;
+		}
 
 		if (!(eBeString.substr(0, 2).compare(&quot;BE&quot;)) == 0)
+		{
 			Throw(IllegalArgumentException, &quot;Ungueltige EBE-Angabe.&quot;);
+		}
 
 		Ogre::String ebe = eBeString.substr(2);
 		if (ebe.compare(&quot;x2&quot;) == 0)
+		{
 			return EBE_BEx2;
+		}
 		if (ebe.compare(&quot;&quot;) == 0)
+		{
 			return 0;
+		}
 		return atoi(ebe.c_str());
 	}
 
-    void XdimlLoader::initializeKampftechniken(DOMElement* rootKampftechniken)
+    void XdimlLoader::initializeKampftechniken(const TiXmlElement* rootKampftechniken)
     {
 		if (rootKampftechniken == NULL)
 			return;
 
-		DOMNodeList* kampfarten =
-            rootKampftechniken-&gt;getElementsByTagName(AutoXMLCh(&quot;Kampfart&quot;).data());
-		for (unsigned int art = 0; art &lt; kampfarten-&gt;getLength(); art++)
+		XmlElementList kampfarten = getElementsByTagName(rootKampftechniken, &quot;Kampfart&quot;);
+		for (unsigned int art = 0; art &lt; kampfarten.size(); art++)
 		{
-			DOMElement* artData = static_cast&lt;DOMElement*&gt;(kampfarten-&gt;item(art));
-			DOMNodeList* kampftechnikenXml =
-                artData-&gt;getElementsByTagName(AutoXMLCh(&quot;Kampftechnik&quot;).data());
+			const TiXmlElement* artData = kampfarten[art];
+			XmlElementList kampftechnikenXml = getElementsByTagName(artData, &quot;Kampftechnik&quot;);
 			int numKampftechnik = 0;
-			for (unsigned int kampftechnikIdx = 0; kampftechnikIdx &lt; kampftechnikenXml-&gt;getLength(); kampftechnikIdx++)
+			for (unsigned int kampftechnikIdx = 0; kampftechnikIdx &lt; kampftechnikenXml.size(); kampftechnikIdx++)
 			{
-				Kampftechnik* k = processKampftechnik(static_cast&lt;DOMElement*&gt;(kampftechnikenXml-&gt;item(kampftechnikIdx)));
+				Kampftechnik* k = processKampftechnik(kampftechnikenXml[kampftechnikIdx]);
 				numKampftechnik++;
 				DsaManager::getSingleton()._addKampftechnik(k);
 			}
@@ -183,51 +174,40 @@
 
 	}
 
-	Kampftechnik* XdimlLoader::processKampftechnik(DOMElement* kampftechnikXml)
+	Kampftechnik* XdimlLoader::processKampftechnik(const TiXmlElement* kampftechnikXml)
 	{
 		CeGuiString desc = getValueAsString(getChildNamed(kampftechnikXml, &quot;Beschreibung&quot;));
 		CeGuiString art = getValueAsString(getChildNamed(kampftechnikXml, &quot;Art&quot;));
-		DOMElement* eBeNode = getChildNamed(kampftechnikXml, &quot;eBE&quot;);
+		const TiXmlElement* eBeNode = getChildNamed(kampftechnikXml, &quot;eBE&quot;);
 		int ebe = EBE_KEINE_BE;
 		if (eBeNode != NULL)
-			ebe = getEBeFromString(AutoChar(eBeNode-&gt;getFirstChild()-&gt;getNodeValue()).data());
+		{
+			ebe = getEBeFromString(getValueAsStdString(eBeNode));
+		}
 
-		CeGuiString name = transcodeToString(
-            kampftechnikXml-&gt;getAttribute(AutoXMLCh(&quot;ID&quot;).data()));
+		CeGuiString name = getAttributeValueAsString(kampftechnikXml, &quot;ID&quot;);
 
-		Kampftechnik* k = new Kampftechnik(
-			name,
-			desc,
-			ebe);
-
+		Kampftechnik* k = new Kampftechnik(name, desc, ebe);
 		return k;
-
 	}
 
 
-	void XdimlLoader::initializeCreatures(DOMElement* rootPersons)
+	void XdimlLoader::initializeCreatures(const TiXmlElement* rootPersons)
 	{
 		if (rootPersons == NULL)
 			return;
 
-		DOMNodeList* personenXml = rootPersons-&gt;getElementsByTagName(AutoXMLCh(&quot;Person&quot;).data());
-		for (unsigned int idx = 0; idx &lt; personenXml-&gt;getLength(); idx++)
+		XmlElementList personenXml = getElementsByTagName(rootPersons, &quot;Person&quot;);
+		for (unsigned int idx = 0; idx &lt; personenXml.size(); idx++)
 		{
-			Creature* p =
-				processCreature(
-					static_cast&lt;DOMElement*&gt;(personenXml-&gt;item(idx)));
+			Creature* p = processCreature(personenXml[idx]);
 			DsaManager::getSingleton()._addCreature(p);
 		}
 
 	}
 
-	Creature* XdimlLoader::processCreature(DOMElement* personXml)
+	Creature* XdimlLoader::processCreature(const TiXmlElement* personXml)
 	{
-		AutoXMLCh TALENT = &quot;Talent&quot;;
-		AutoXMLCh ID = &quot;ID&quot;;
-		AutoXMLCh ABGELEITETER_WERT = &quot;AbgeleiteterWert&quot;;
-		AutoXMLCh EIGENSCHAFT = &quot;Eigenschaft&quot;;
-
 		CeGuiString name =
 			getValueAsString(getChildNamed(personXml, &quot;Name&quot;));
 		CeGuiString desc =
@@ -239,14 +219,12 @@
         rval-&gt;setDescription(desc);
 
 		// Eigenschaften laden
-		DOMNodeList* eigensch =
-			getChildNamed(personXml, &quot;Eigenschaften&quot;)-&gt;
-				getElementsByTagName(EIGENSCHAFT.data());
+		XmlElementList eigensch = getElementsByTagName(getChildNamed(personXml, &quot;Eigenschaften&quot;), &quot;Eigenschaft&quot;);
 		// Die Eigenschaftsnamen mssen durch ihre Abkrzung ersetzt werden.
-		for (unsigned int idx = 0; idx &lt; eigensch-&gt;getLength(); idx++)
+		for (unsigned int idx = 0; idx &lt; eigensch.size(); idx++)
 		{
-			DOMElement* eigenschXml = static_cast&lt;DOMElement*&gt;(eigensch-&gt;item(idx));
-			CeGuiString eigName = transcodeToString(eigenschXml-&gt;getAttribute(ID.data()));
+			const TiXmlElement* eigenschXml = eigensch[idx];
+			CeGuiString eigName = getAttributeValueAsString(eigenschXml, &quot;ID&quot;);
 			if (eigName == DsaManager::getSingleton().getEigenschaft(E_MUT)-&gt;getName())
 				eigName = DsaManager::getSingleton().getEigenschaft(E_MUT)-&gt;getNameAbbreviation();
 			if (eigName == DsaManager::getSingleton().getEigenschaft(E_KLUGHEIT)-&gt;getName())
@@ -269,16 +247,14 @@
 		}
 
 		// Abgeleitete Werte laden
-		DOMNodeList* werte =
-			getChildNamed(personXml, &quot;AbgeleiteteWerte&quot;)-&gt;
-				getElementsByTagName(ABGELEITETER_WERT.data());
-		for (unsigned int idx = 0; idx &lt; werte-&gt;getLength(); idx++)
+		XmlElementList werte = getElementsByTagName(getChildNamed(personXml, &quot;AbgeleiteteWerte&quot;), &quot;AbgeleiteterWert&quot;);
+		for (unsigned int idx = 0; idx &lt; werte.size(); idx++)
 		{
-			DOMElement* wertXml = static_cast&lt;DOMElement*&gt;(werte-&gt;item(idx));
+			const TiXmlElement* wertXml = werte[idx];
 			int basis = getValueAsInteger(getChildNamed(wertXml, &quot;Basiswert&quot;));
 			int wert = getValueAsInteger(getChildNamed(wertXml, &quot;Wert&quot;));
 
-			AutoChar wertId = wertXml-&gt;getAttribute(ID.data());
+			std::string wertId = getAttributeValueAsStdString(wertXml, &quot;ID&quot;);
 			if (strcmp(wertId.data(), &quot;Lebensenergie&quot;) == 0)
 				rval-&gt;setWert(rl::Creature::WERT_MOD_LE, wert - basis);
 			else if (strcmp(wertId.data(), &quot;Ausdauer&quot;) == 0)
@@ -302,23 +278,17 @@
 		// Talente laden
 		// Talente, die direkt unter &lt;Person&gt; angeordnet sind,
         // ergeben bereits die zusammengefassten Werte
-		DOMNodeList* talente =
-			getChildNamed(personXml, &quot;Talente&quot;)-&gt;
-				getElementsByTagName(TALENT.data());
-		for (unsigned int idx = 0; idx &lt; talente-&gt;getLength(); idx++)
+		XmlElementList talente = getElementsByTagName(getChildNamed(personXml, &quot;Talente&quot;), &quot;Talent&quot;);
+		for (unsigned int idx = 0; idx &lt; talente.size(); idx++)
 		{
-			DOMElement* talentXml = static_cast&lt;DOMElement*&gt;(talente-&gt;item(idx));
+			const TiXmlElement* talentXml = talente[idx];
 
-			CeGuiString talentName = transcodeToString(
-                talentXml-&gt;getAttribute(ID.data()));
+			CeGuiString talentName = getAttributeValueAsString(talentXml, &quot;ID&quot;);
 
-			Talent* tal =
-				DsaManager::getSingleton().getTalent(talentName);
+			Talent* tal = DsaManager::getSingleton().getTalent(talentName);
 
 			rval-&gt;addTalent(talentName);
-			rval-&gt;setTalent(
-				talentName,
-				getValueAsInteger(getChildNamed(talentXml, &quot;Wert&quot;)));
+			rval-&gt;setTalent(talentName,	getValueAsInteger(getChildNamed(talentXml, &quot;Wert&quot;)));
 		}
 		return rval;
 	}

Modified: rl/trunk/engine/rules/src/GlobalProperties.cpp
===================================================================
--- rl/trunk/engine/rules/src/GlobalProperties.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/rules/src/GlobalProperties.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -21,8 +21,6 @@
 
 template&lt;&gt; rl::GlobalProperties* Ogre::Singleton&lt;rl::GlobalProperties&gt;::ms_Singleton = 0;
 
-using namespace XERCES_CPP_NAMESPACE;
-
 namespace rl
 {
     GlobalProperties::GlobalProperties()
@@ -66,26 +64,21 @@
 
     void GlobalProperties::writeData(SaveGameFileWriter* writer)
     {
-        DOMElement* elem = writer-&gt;appendChildElement(writer-&gt;getDocument(), writer-&gt;getDocument()-&gt;getDocumentElement(), getXmlNodeIdentifier().c_str());
-
+        TiXmlElement* elem = writer-&gt;appendChildElement(writer-&gt;getDocument()-&gt;RootElement(), getXmlNodeIdentifier().c_str());
         writer-&gt;writeEachPropertyToElem(elem, mProperties.toPropertyMap());
     }
 
     void GlobalProperties::readData(SaveGameFileReader* reader)
     {
-        reader-&gt;initializeXml();
-        
-        DOMNodeList* rootNodeList = reader-&gt;getDocument()-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
-        if(rootNodeList-&gt;getLength())
+        XmlElementList rootNodeList = reader-&gt;getElementsByTagName(reader-&gt;getDocument(), getXmlNodeIdentifier().c_str());
+        if (!rootNodeList.empty())
         {
-            DOMElement* elem = static_cast&lt;DOMElement*&gt;(rootNodeList-&gt;item(0));
+        	const TiXmlElement* elem = rootNodeList[0];
 
             PropertyRecordPtr properties = reader-&gt;getPropertiesAsRecord(elem);
 
             setProperties(properties);
         }
-
-        reader-&gt;shutdownXml();
     }
 
     int GlobalProperties::getPriority() const

Modified: rl/trunk/engine/rules/src/QuestBook.cpp
===================================================================
--- rl/trunk/engine/rules/src/QuestBook.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/rules/src/QuestBook.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -22,7 +22,6 @@
 #include &quot;SaveGameManager.h&quot;
 
 using namespace std;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl {
     const Ogre::String QuestBook::PROPERTY_QUESTS = &quot;quests&quot;;
@@ -203,13 +202,13 @@
     PropertyArray QuestBook::getQuestsProperty(const Quest* rootQuest) const
     {
         PropertyArray parray;
-        if(rootQuest-&gt;hasSubquests())
+        if (rootQuest-&gt;hasSubquests())
         {
             QuestVector quests = rootQuest-&gt;getSubquests();
             for(unsigned int i = 0; i &lt; quests.size(); i++)
             {
                 PropertyMap map = quests[i]-&gt;getAllProperties()-&gt;toPropertyMap();
-                if(quests[i]-&gt;hasSubquests())
+                if (quests[i]-&gt;hasSubquests())
                     map.insert(std::pair&lt;CeGuiString, Property&gt;(&quot;quests&quot;, getQuestsProperty(quests[i])));
                 parray.push_back(map);
             }
@@ -271,7 +270,7 @@
             }
 
             quest-&gt;setProperties(curVal);
-            if(curVal.find(&quot;quests&quot;) != curVal.end())
+            if (curVal.find(&quot;quests&quot;) != curVal.end())
             {
                 setQuestsProperty(curVal[&quot;quests&quot;], quest);
             }            
@@ -354,23 +353,22 @@
 
     void QuestBook::parseScript(Ogre::DataStreamPtr&amp; stream,const Ogre::String&amp; groupname)
     {
-        initializeXml();
-
-        DOMDocument* doc = loadDocument(stream);
+        TiXmlDocument* doc = loadDocument(stream);
         if (doc)
         {
-            for (DOMNode* cur = doc-&gt;getDocumentElement()-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+            for (TiXmlNode* cur = doc-&gt;RootElement()-&gt;FirstChild(); cur != NULL; cur = cur-&gt;NextSibling())
             {
-                if(hasNodeName(cur, &quot;quest&quot;))
+                if (hasNodeName(cur, &quot;quest&quot;))
                 {
-                    processQuest(static_cast&lt;DOMElement*&gt;(cur), mRootQuest);
+                    processQuest(cur-&gt;ToElement(), mRootQuest);
                 }
             }
+            delete doc;
         }
         else
+        {
             LOG_ERROR(Logger::RULES,&quot;Quests XML is not valid!&quot;);
-
-        shutdownXml();
+        }
     }
 
     Ogre::Real QuestBook::getLoadingOrder(void) const
@@ -378,28 +376,34 @@
         return 1000;
     }
 
-    Quest* QuestBook::processQuest(XERCES_CPP_NAMESPACE::DOMElement* questXml, Quest* parent)
+    Quest* QuestBook::processQuest(TiXmlElement* questXml, Quest* parent)
     {
         Quest* quest = new Quest(getAttributeValueAsString(questXml, &quot;id&quot;));
         parent-&gt;addSubquest(quest);
         quest-&gt;setKnown(false);
         quest-&gt;setState(Quest::OPEN);
-        for (DOMNode* cur = questXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        for (TiXmlNode* cur = questXml-&gt;FirstChild(); cur != NULL; cur = cur-&gt;NextSibling())
         {
-            if(hasNodeName(cur, &quot;name&quot;))
-                quest-&gt;setProperty(Quest::PROPERTY_NAME,  Property(getValueAsString(static_cast&lt;DOMElement*&gt;(cur))));
-            
-            if(hasNodeName(cur, &quot;description&quot;))
-                quest-&gt;setProperty(Quest::PROPERTY_DESCRIPTION, Property(getValueAsString(static_cast&lt;DOMElement*&gt;(cur))));
-            
-            if(hasNodeName(cur, &quot;known&quot;))
-                quest-&gt;setKnown(getValueAsBool(static_cast&lt;DOMElement*&gt;(cur)));                
-            
-            if(hasNodeName(cur, &quot;state&quot;))
-                quest-&gt;setState(Quest::getStateFromName(getValueAsString(static_cast&lt;DOMElement*&gt;(cur))));
-
-            if(hasNodeName(cur, &quot;quest&quot;))
-                processQuest(static_cast&lt;DOMElement*&gt;(cur), quest);
+            if (hasNodeName(cur, &quot;name&quot;))
+            {
+                quest-&gt;setProperty(Quest::PROPERTY_NAME,  Property(getValueAsString(cur-&gt;ToElement())));
+            }
+            else if (hasNodeName(cur, &quot;description&quot;))
+            {
+                quest-&gt;setProperty(Quest::PROPERTY_DESCRIPTION, Property(getValueAsString(cur-&gt;ToElement())));
+            }
+            else if (hasNodeName(cur, &quot;known&quot;))
+            {
+                quest-&gt;setKnown(getValueAsBool(cur-&gt;ToElement()));
+            }
+            else if (hasNodeName(cur, &quot;state&quot;))
+            {
+                quest-&gt;setState(Quest::getStateFromName(getValueAsString(cur-&gt;ToElement())));
+            }
+            else if (hasNodeName(cur, &quot;quest&quot;))
+            {
+                processQuest(cur-&gt;ToElement(), quest);
+            }
         }
 
         return quest;

Modified: rl/trunk/engine/script/CMakeLists.txt
===================================================================
--- rl/trunk/engine/script/CMakeLists.txt	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/CMakeLists.txt	2009-11-07 19:39:22 UTC (rev 4961)
@@ -8,7 +8,7 @@
 ${RL_RULES_INCLUDE_DIR}
 ${RL_AI_INCLUDE_DIR}
 ${RL_UI_INCLUDE_DIR}
-${XERCESC_INCLUDE_DIR}
+${TINYXML_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR}

Modified: rl/trunk/engine/script/include/AbstractMapNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/AbstractMapNodeProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/AbstractMapNodeProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,11 +16,8 @@
 #ifndef __AbstractMapNodeProcessor_H__
 #define __AbstractMapNodeProcessor_H__
 
-#include &lt;xercesc/dom/DOMElement.hpp&gt;
-
 #include &quot;ScriptPrerequisites.h&quot;
 
-
 #include &quot;XmlPropertyReader.h&quot;
 
 namespace rl
@@ -33,7 +30,7 @@
     public:
         virtual ~AbstractMapNodeProcessor();
         
-        virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects) = 0;
+        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects) = 0;
         
         void setRootSceneNode(Ogre::SceneNode* node);
 
@@ -41,10 +38,10 @@
         AbstractMapNodeProcessor();
     
         Ogre::String getRandomName(const Ogre::String&amp; baseName) const;
-        Ogre::Vector3 processVector3(XERCES_CPP_NAMESPACE::DOMElement* nodeElem) const;
-		Ogre::Vector2 processVector2(XERCES_CPP_NAMESPACE::DOMElement* nodeElem) const;
-        Ogre::Quaternion processQuaternion(XERCES_CPP_NAMESPACE::DOMElement* nodeElem) const;
-        Ogre::ColourValue processColour(XERCES_CPP_NAMESPACE::DOMElement* colElem) const;
+        Ogre::Vector3 processVector3(const TiXmlElement* nodeElem) const;
+		Ogre::Vector2 processVector2(const TiXmlElement* nodeElem) const;
+        Ogre::Quaternion processQuaternion(const TiXmlElement* nodeElem) const;
+        Ogre::ColourValue processColour(const TiXmlElement* colElem) const;
         
         Ogre::SceneNode* getRootSceneNode() const;
         

Modified: rl/trunk/engine/script/include/EntityNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/EntityNodeProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/EntityNodeProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,8 +16,6 @@
 #ifndef __EntityNodeProcessor_H__
 #define __EntityNodeProcessor_H__
 
-#include &lt;xercesc/dom/DOMElement.hpp&gt;
-
 #include &quot;ScriptPrerequisites.h&quot;
 
 #ifdef __APPLE__
@@ -35,13 +33,13 @@
     public:
         EntityNodeProcessor(const Ogre::String&amp; resourcegroup);
 
-        virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
 
     private:
         Ogre::String mResourceGroup;
 
-        void createCollision(Ogre::Entity* entity, Ogre::String meshFile, XERCES_CPP_NAMESPACE::DOMElement* physicsProxyElem);
-		void processAnimation(Ogre::Entity* entity, XERCES_CPP_NAMESPACE::DOMElement *animationElem);
+        void createCollision(Ogre::Entity* entity, Ogre::String meshFile, const TiXmlElement* physicsProxyElem);
+		void processAnimation(Ogre::Entity* entity, const TiXmlElement *animationElem);
 	};
 }
 

Modified: rl/trunk/engine/script/include/EnvironmentProcessor.h
===================================================================
--- rl/trunk/engine/script/include/EnvironmentProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/EnvironmentProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -25,9 +25,9 @@
 	class EnvironmentProcessor : private AbstractMapNodeProcessor
 	{
 	public:
-		virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
-		void processFogSettings(XERCES_CPP_NAMESPACE::DOMElement* fogElem);
-		void processSkySettings(XERCES_CPP_NAMESPACE::DOMElement* fogElem);
+		virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
+		void processFogSettings(const TiXmlElement* fogElem);
+		void processSkySettings(const TiXmlElement* fogElem);
 	};
 }
 

Modified: rl/trunk/engine/script/include/GameObjectNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/GameObjectNodeProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/GameObjectNodeProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,8 +16,6 @@
 #ifndef __GameObjectNodeProcessor_H__
 #define __GameObjectNodeProcessor_H__
 
-#include &lt;xercesc/dom/DOMElement.hpp&gt;
-
 #include &quot;ScriptPrerequisites.h&quot;
 #include &quot;AbstractMapNodeProcessor.h&quot;
 
@@ -26,7 +24,7 @@
     class GameObjectNodeProcessor : public AbstractMapNodeProcessor
     {
     public:
-        virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
     };
 }
 

Modified: rl/trunk/engine/script/include/LightNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/LightNodeProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/LightNodeProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,8 +16,6 @@
 #ifndef __LightNodeProcessor_H__
 #define __LightNodeProcessor_H__
 
-#include &lt;xercesc/dom/DOMElement.hpp&gt;
-
 #include &quot;ScriptPrerequisites.h&quot;
 #include &quot;AbstractMapNodeProcessor.h&quot;
 
@@ -27,7 +25,7 @@
     class LightNodeProcessor : public AbstractMapNodeProcessor
     {
     public:
-        virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
     };
 }
 

Modified: rl/trunk/engine/script/include/MapLoader.h
===================================================================
--- rl/trunk/engine/script/include/MapLoader.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/MapLoader.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -74,7 +74,7 @@
         Ogre::StringVector mDefaultMaps;
 
         void setRootSceneNode(Ogre::SceneNode* node);
-        void processSceneNodes(XERCES_CPP_NAMESPACE::DOMElement* nodesElem, bool loadGameObjects);
+        void processSceneNodes(const TiXmlElement* nodesElem, bool loadGameObjects);
         void setLoadingPercentage(Ogre::Real percentage, const Ogre::String&amp; text = &quot;&quot;);
         bool changeScene(Ogre::StringVector mapsresources);
         void initialize(const Ogre::String&amp; resourceGroup);

Modified: rl/trunk/engine/script/include/ParticleSystemNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/ParticleSystemNodeProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/ParticleSystemNodeProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,8 +16,6 @@
 #ifndef __ParticleSystemNodeProcessor_H__
 #define __ParticleSystemNodeProcessor_H__
 
-#include &lt;xercesc/dom/DOMElement.hpp&gt;
-
 #include &quot;ScriptPrerequisites.h&quot;
 #include &quot;AbstractMapNodeProcessor.h&quot;
 
@@ -27,7 +25,7 @@
     class ParticleSystemNodeProcessor : public AbstractMapNodeProcessor
     {
     public:
-        virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
     };
 }
 

Modified: rl/trunk/engine/script/include/PlaneNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/PlaneNodeProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/PlaneNodeProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,8 +16,6 @@
 #ifndef __PlaneNodeProcessor_H__
 #define __PlaneNodeProcessor_H__
 
-#include &lt;xercesc/dom/DOMElement.hpp&gt;
-
 #include &quot;ScriptPrerequisites.h&quot;
 
 #ifdef __APPLE__
@@ -38,12 +36,12 @@
     public:
         PlaneNodeProcessor();
 
-        virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
 
     private:
 
-        void createCollision(Ogre::Entity* entity, XERCES_CPP_NAMESPACE::DOMElement* physicsProxyElem);
-		void createRenderToTextures(Ogre::Entity* entity, Ogre::Plane* plane, Ogre::MaterialPtr mat, XERCES_CPP_NAMESPACE::DOMElement* rttElem);
+        void createCollision(Ogre::Entity* entity, const TiXmlElement* physicsProxyElem);
+		void createRenderToTextures(Ogre::Entity* entity, Ogre::Plane* plane, Ogre::MaterialPtr mat, const TiXmlElement* rttElem);
 	};
 
 	class PlaneReflectionTextureListener : public Ogre::RenderTargetListener

Modified: rl/trunk/engine/script/include/SoundNodeProcessor.h
===================================================================
--- rl/trunk/engine/script/include/SoundNodeProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/SoundNodeProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -16,18 +16,16 @@
 #ifndef __SoundNodeProcessor_H__
 #define __SoundNodeProcessor_H__
 
-#include &lt;xercesc/dom/DOMElement.hpp&gt;
-
 #include &quot;ScriptPrerequisites.h&quot;
+
 #include &quot;AbstractMapNodeProcessor.h&quot;
 
-
 namespace rl
 {
     class SoundNodeProcessor : public AbstractMapNodeProcessor
     {
     public:
-        virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+        virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
     };
 }
 

Modified: rl/trunk/engine/script/include/WaypointProcessor.h
===================================================================
--- rl/trunk/engine/script/include/WaypointProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/WaypointProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -25,7 +25,7 @@
 	class WaypointProcessor : private AbstractMapNodeProcessor
 	{
 	public:
-		virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+		virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
 	};
 }
 

Modified: rl/trunk/engine/script/include/ZoneProcessor.h
===================================================================
--- rl/trunk/engine/script/include/ZoneProcessor.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/include/ZoneProcessor.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -25,7 +25,7 @@
 	class ZoneProcessor : private AbstractMapNodeProcessor
 	{
 	public:
-		virtual bool processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects);
+		virtual bool processNode(const TiXmlElement* nodeElem, bool loadGameObjects);
 	};
 }
 

Modified: rl/trunk/engine/script/src/AbstractMapNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/AbstractMapNodeProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/AbstractMapNodeProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,9 +17,7 @@
 
 #include &quot;AbstractMapNodeProcessor.h&quot;
 
-
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
@@ -33,7 +31,7 @@
     {
     }
 
-    Vector3 AbstractMapNodeProcessor::processVector3(DOMElement* vec3Elem) const
+    Vector3 AbstractMapNodeProcessor::processVector3(const TiXmlElement* vec3Elem) const
     {
         Vector3 rval(Vector3::ZERO);
         if (vec3Elem != NULL)
@@ -55,7 +53,7 @@
         return rval;
     }
 
-	Vector2 AbstractMapNodeProcessor::processVector2(DOMElement* vec2Elem) const
+	Vector2 AbstractMapNodeProcessor::processVector2(const TiXmlElement* vec2Elem) const
     {
         Vector2 rval(Vector2::ZERO);
         if (vec2Elem != NULL)
@@ -73,7 +71,7 @@
         return rval;
     }
 
-    Quaternion AbstractMapNodeProcessor::processQuaternion(DOMElement* quatElem) const
+    Quaternion AbstractMapNodeProcessor::processQuaternion(const TiXmlElement* quatElem) const
     {
         Quaternion rval(Quaternion::IDENTITY);
         if (quatElem != NULL)
@@ -99,7 +97,7 @@
         return rval;
     }
 
-    ColourValue AbstractMapNodeProcessor::processColour(DOMElement* colElem) const
+    ColourValue AbstractMapNodeProcessor::processColour(const TiXmlElement* colElem) const
     {
         ColourValue rval(1, 1, 1, 1);
         if (colElem != NULL)

Modified: rl/trunk/engine/script/src/EntityNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,14 +17,11 @@
 
 #include &quot;EntityNodeProcessor.h&quot;
 
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
 #include &quot;CoreSubsystem.h&quot;
 #include &quot;PhysicsManager.h&quot;
 #include &quot;World.h&quot;
 
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
@@ -34,7 +31,7 @@
     {
     }
 
-    bool EntityNodeProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
+    bool EntityNodeProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
     {
         if (!hasNodeName(nodeElem, &quot;entity&quot;))
         {
@@ -66,7 +63,7 @@
         Vector3 position(Vector3::ZERO);
         Quaternion orientation(Quaternion::IDENTITY);
 
-        DOMElement* posElem = getChildNamed(nodeElem, &quot;position&quot;);
+        const TiXmlElement* posElem = getChildNamed(nodeElem, &quot;position&quot;);
         if (posElem != NULL)
         {
             position = processVector3(posElem);
@@ -76,7 +73,7 @@
             LOG_WARNING(Logger::SCRIPT, &quot;No position given for entity, used (0,0,0)&quot;);
         }
 
-        DOMElement* oriElem = getChildNamed(nodeElem, &quot;rotation&quot;);
+        const TiXmlElement* oriElem = getChildNamed(nodeElem, &quot;rotation&quot;);
         if (oriElem != NULL)
         {
             orientation = processQuaternion(oriElem);
@@ -118,7 +115,7 @@
 
         parentNode-&gt;attachObject(newEnt);
 
-        DOMElement* scaleElem = getChildNamed(nodeElem, &quot;scale&quot;);
+        const TiXmlElement* scaleElem = getChildNamed(nodeElem, &quot;scale&quot;);
         if (scaleElem != NULL)
         {
             parentNode-&gt;scale(processVector3(scaleElem));
@@ -127,21 +124,17 @@
         // in order for the scale to work correctly the collision needs to be created after the scale was applied
         createCollision(newEnt, meshFile, getChildNamed(nodeElem, &quot;physicsproxy&quot;));
 
-		AutoXMLCh animation(&quot;animation&quot;);
-		DOMNodeList* list = nodeElem-&gt;getElementsByTagName(animation.data());
-		for (XMLSize_t idx = 0; idx &lt; list-&gt;getLength(); idx++)
+		XmlElementList list = getElementsByTagName(nodeElem, &quot;animation&quot;);
+		for (size_t idx = 0; idx &lt; list.size(); idx++)
 		{
-			DOMNode* cur = list-&gt;item(idx);
-			if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-			{
-				processAnimation(newEnt, static_cast&lt;DOMElement*&gt;(cur));
-			}
+			const TiXmlElement* cur = list[idx];
+			processAnimation(newEnt, cur);
 		}
 
         return true;
     }
 
-    void EntityNodeProcessor::createCollision(Entity* entity, Ogre::String meshName, DOMElement* physicsProxyElem)
+    void EntityNodeProcessor::createCollision(Entity* entity, Ogre::String meshName, const TiXmlElement* physicsProxyElem)
 	{
         Ogre::String physicsProxyTypeAsString;
         if (physicsProxyElem == NULL || !hasAttribute(physicsProxyElem, &quot;type&quot;))
@@ -347,7 +340,7 @@
 */
     }
 
-	void EntityNodeProcessor::processAnimation(Ogre::Entity* entity, DOMElement *animationElem)
+	void EntityNodeProcessor::processAnimation(Ogre::Entity* entity, const TiXmlElement *animationElem)
 	{
 		///@todo EntityNodeProcessor::processAnimation
 	}

Modified: rl/trunk/engine/script/src/EnvironmentProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EnvironmentProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/EnvironmentProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -21,13 +21,12 @@
 #include &quot;World.h&quot;
 #include &quot;XmlProcessor.h&quot;
 
-using namespace XERCES_CPP_NAMESPACE;
 using namespace Ogre;
 
 
 namespace rl
 {
-	bool EnvironmentProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
+	bool EnvironmentProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
 	{
 		if (nodeElem)
 		{
@@ -38,7 +37,7 @@
 		return true;
 	}
 
-	void EnvironmentProcessor::processSkySettings(XERCES_CPP_NAMESPACE::DOMElement* skyElem)
+	void EnvironmentProcessor::processSkySettings(const TiXmlElement* skyElem)
 	{
         if (skyElem)
 		{
@@ -70,7 +69,7 @@
 				    Ogre::Real curvature = 10;
 				    Ogre::Real tiling = 8;
 
-				    DOMElement* domeSettings = getChildNamed(skyElem, &quot;skydomesettings&quot;);
+				    const TiXmlElement* domeSettings = getChildNamed(skyElem, &quot;skydomesettings&quot;);
 				    if (domeSettings != NULL)
 				    {
 					    if (hasAttribute(domeSettings, &quot;curvature&quot;))
@@ -98,7 +97,7 @@
 	}
 
 
-	void EnvironmentProcessor::processFogSettings(XERCES_CPP_NAMESPACE::DOMElement* fogElem)
+	void EnvironmentProcessor::processFogSettings(const TiXmlElement* fogElem)
 	{
         if (fogElem)
         {
@@ -110,7 +109,7 @@
 			    return;
 		    }
 
-		    DOMElement* colourElem = getChildNamed(fogElem, &quot;colour&quot;);
+		    const TiXmlElement* colourElem = getChildNamed(fogElem, &quot;colour&quot;);
 		    if (colourElem == NULL)
 		    {
 			    LOG_ERROR(Logger::RULES, &quot;No fog colour set.&quot;);

Modified: rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/GameObjectNodeProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,17 +17,14 @@
 
 #include &quot;GameObjectNodeProcessor.h&quot;
 
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
 #include &quot;GameObject.h&quot;
 #include &quot;GameObjectManager.h&quot;
 
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
-    bool GameObjectNodeProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
+    bool GameObjectNodeProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
     {
         if (!hasNodeName(nodeElem, &quot;gameobject&quot;))
         {
@@ -61,28 +58,25 @@
                 return true;
             }
 
-            DOMElement* posElem = getChildNamed(nodeElem, &quot;position&quot;);
+            const TiXmlElement* posElem = getChildNamed(nodeElem, &quot;position&quot;);
             if (posElem != NULL)
             {
                 Vector3 pos = processVector3(posElem);
                 go-&gt;setPosition(pos);
             }
 
-            DOMElement* oriElem = getChildNamed(nodeElem, &quot;rotation&quot;);
+            const TiXmlElement* oriElem = getChildNamed(nodeElem, &quot;rotation&quot;);
             if (oriElem != NULL)
             {
                 Quaternion ori = processQuaternion(oriElem);
                 go-&gt;setOrientation(ori);
             }
 
-            DOMNodeList* goElChildNodes = nodeElem-&gt;getChildNodes();
-            for (XMLSize_t idx = 0; idx &lt; goElChildNodes-&gt;getLength(); idx++)
+            for (const TiXmlNode* cur = nodeElem-&gt;FirstChild(); cur; cur = cur-&gt;NextSibling())
             {
-                DOMNode* cur = goElChildNodes-&gt;item(idx);
-                if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE
-                    &amp;&amp; hasNodeName(cur, &quot;property&quot;))
+                if (cur-&gt;Type() == TiXmlNode::ELEMENT &amp;&amp; hasNodeName(cur, &quot;property&quot;))
                 {
-                    PropertyEntry propEntry = processProperty(static_cast&lt;DOMElement*&gt;(cur));
+                    PropertyEntry propEntry = processProperty(cur-&gt;ToElement());
                     if (propEntry.first != &quot;&quot;)
                     {
                         go-&gt;setProperty(propEntry.first, propEntry.second);

Modified: rl/trunk/engine/script/src/LightNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/LightNodeProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/LightNodeProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -21,11 +21,10 @@
 #include &quot;ActorManager.h&quot;
 
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
-    bool LightNodeProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
+    bool LightNodeProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
     {
         if (!hasNodeName(nodeElem, &quot;light&quot;))
         {
@@ -61,7 +60,7 @@
         }
         Actor* lightActor = ActorManager::getSingleton().createLightActor(name, type);
 
-        DOMElement* posElem = getChildNamed(nodeElem, &quot;position&quot;);
+        const TiXmlElement* posElem = getChildNamed(nodeElem, &quot;position&quot;);
         if (posElem != NULL)
         {
             lightActor-&gt;placeIntoScene(processVector3(posElem));
@@ -76,19 +75,19 @@
         light-&gt;setCastShadows(shadowCaster);
         light-&gt;setActive(visible);
 
-        DOMElement* diffElem = getChildNamed(nodeElem, &quot;colourDiffuse&quot;);
+        const TiXmlElement* diffElem = getChildNamed(nodeElem, &quot;colourDiffuse&quot;);
         if (diffElem != NULL)
         {
             light-&gt;setDiffuseColour(processColour(diffElem));
         }
 
-        DOMElement* specElem = getChildNamed(nodeElem, &quot;colourSpecular&quot;);
+        const TiXmlElement* specElem = getChildNamed(nodeElem, &quot;colourSpecular&quot;);
         if (specElem != NULL)
         {
             light-&gt;setSpecularColour(processColour(specElem));
         }
 
-        DOMElement* attElem = getChildNamed(nodeElem, &quot;lightAttenuation&quot;);
+        const TiXmlElement* attElem = getChildNamed(nodeElem, &quot;lightAttenuation&quot;);
         if (attElem != NULL)
         {
             if (hasAttribute(attElem, &quot;range&quot;)
@@ -108,7 +107,7 @@
 
         if (stype == &quot;directional&quot;)
         {
-            DOMElement* dirElem = getChildNamed(nodeElem, &quot;direction&quot;);
+        	const TiXmlElement* dirElem = getChildNamed(nodeElem, &quot;direction&quot;);
             if (dirElem != NULL)
             {
                 light-&gt;setDirection(processVector3(dirElem));
@@ -120,7 +119,7 @@
         }
         else if (stype == &quot;spot&quot;)
         {
-            DOMElement* rangeElem = getChildNamed(nodeElem, &quot;spotlightrange&quot;);
+        	const TiXmlElement* rangeElem = getChildNamed(nodeElem, &quot;spotlightrange&quot;);
             if (rangeElem != NULL)
             {
                 Ogre::Real innerAngle = getAttributeValueAsReal(rangeElem, &quot;inner&quot;);

Modified: rl/trunk/engine/script/src/MapLoader.cpp
===================================================================
--- rl/trunk/engine/script/src/MapLoader.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/MapLoader.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,8 +17,6 @@
 
 #include &quot;MapLoader.h&quot;
 
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
 #include &quot;AbstractMapNodeProcessor.h&quot;
 #include &quot;CoreSubsystem.h&quot;
 #include &quot;EntityNodeProcessor.h&quot;
@@ -40,13 +38,10 @@
 #include &quot;PlaneNodeProcessor.h&quot;
 
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 using std::list;
 
 namespace rl {
 
-    using XERCES_CPP_NAMESPACE::DOMDocument; //XXX: for VS 2003/2005
-
     const CeGuiString MapLoader::PROPERTY_ACTIVEMAPS = &quot;activemaps&quot;;
 
     MapLoader::MapLoader()
@@ -132,16 +127,16 @@
         {
             LOG_MESSAGE(Logger::RULES, &quot;Loading map &quot; + mapresource);
 
-  		    initializeXml();
+            TiXmlDocument* doc = loadDocument(mapresource, mResourceGroup);
 
-            DOMDocument* doc = loadDocument(mapresource, mResourceGroup);
-
             if (doc)
             {
                 setRootSceneNode(CoreSubsystem::getSingleton().getWorld()
                         -&gt;getSceneManager()-&gt;getRootSceneNode()-&gt;createChildSceneNode(mapresource));
 
-                if(getAttributeValueAsString(doc-&gt;getDocumentElement(), &quot;formatVersion&quot;) != &quot;0.4.0&quot;)
+                TiXmlElement* dataDocumentContent = doc-&gt;RootElement();
+
+                if(getAttributeValueAsString(dataDocumentContent, &quot;formatVersion&quot;) != &quot;0.4.0&quot;)
                     LOG_ERROR(Logger::SCRIPT, &quot;Map format version doesn't match with the required version&quot;);
 
 			    CoreSubsystem::getSingleton().getWorld()-&gt;initializeDefaultCamera();
@@ -149,7 +144,6 @@
 
                 LOG_MESSAGE(Logger::RULES, &quot;Processing nodes&quot;);
 
-                DOMElement* dataDocumentContent = doc-&gt;getDocumentElement();
                 processSceneNodes(getChildNamed(dataDocumentContent, &quot;nodes&quot;), loadGameObjects);
 
 			    ZoneProcessor zp;
@@ -163,11 +157,11 @@
 
                 LOG_MESSAGE(Logger::SCRIPT, &quot;Map &quot; + mapresource + &quot; loaded&quot;);
 
-                if(hasAttribute(doc-&gt;getDocumentElement(), &quot;scenescript&quot;))
+                if(hasAttribute(dataDocumentContent, &quot;scenescript&quot;))
                 {
-                    if(getAttributeValueAsString(doc-&gt;getDocumentElement(), &quot;scenescript&quot;).length() != 0)
+                    if(getAttributeValueAsString(dataDocumentContent, &quot;scenescript&quot;).length() != 0)
                     {
-                        if(!CoreSubsystem::getSingleton().getRubyInterpreter()-&gt;executeFile(getAttributeValueAsStdString(doc-&gt;getDocumentElement(), &quot;scenescript&quot;)))
+                        if(!CoreSubsystem::getSingleton().getRubyInterpreter()-&gt;executeFile(getAttributeValueAsStdString(dataDocumentContent, &quot;scenescript&quot;)))
                             LOG_MESSAGE(Logger::SCRIPT, &quot;Executed init script of map &quot; + mapresource);
                         else
                             LOG_ERROR(Logger::SCRIPT, &quot;Error while executing init script of map &quot; + mapresource);
@@ -183,8 +177,6 @@
                 LOG_ERROR(Logger::RULES, &quot;Map resource '&quot; + mapresource + &quot;' not found&quot;);
             }
 
-            shutdownXml();
-            
             mLoadedMaps.push_back(mapresource);
         }
         else
@@ -256,7 +248,7 @@
         return keys;
     }
 
-    void MapLoader::processSceneNodes(DOMElement* nodesElem, bool loadGameObjects)
+    void MapLoader::processSceneNodes(const TiXmlElement* nodesElem, bool loadGameObjects)
     {
 		if (nodesElem == NULL)
 		{
@@ -264,16 +256,19 @@
 		}
 
         setLoadingPercentage(0, &quot;Loading map nodes&quot;);
-        Ogre::Real numChildren = nodesElem-&gt;getChildNodes()-&gt;getLength();
+        Ogre::Real numChildren = 0;
+        for (const TiXmlNode* cur = nodesElem-&gt;FirstChild(); cur != NULL; cur = cur-&gt;NextSibling())
+        {
+        	numChildren++;
+        }
+
         int count = 0;
 
-        for (DOMNode* cur = nodesElem-&gt;getFirstChild();
-            cur != NULL;
-            cur = cur-&gt;getNextSibling())
+        for (const TiXmlNode* cur = nodesElem-&gt;FirstChild(); cur != NULL; cur = cur-&gt;NextSibling())
         {
-            if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+            if (cur-&gt;Type() == TiXmlNode::ELEMENT)
             {
-                DOMElement* curElem = static_cast&lt;DOMElement*&gt;(cur);
+            	const TiXmlElement* curElem = cur-&gt;ToElement();
 
                 list&lt;AbstractMapNodeProcessor*&gt;::iterator it = mNodeProcessors.begin();
                 while (it != mNodeProcessors.end() &amp;&amp; !(*it)-&gt;processNode(curElem, loadGameObjects))
@@ -284,7 +279,7 @@
                 if (it == mNodeProcessors.end())
                 {
                     LOG_WARNING(Logger::RULES,
-                        &quot;Node &quot; + transcodeToString(curElem-&gt;getNodeName()) + &quot; could not be processed.&quot;);
+                        &quot;Node &quot; + Ogre::String(curElem-&gt;Value()) + &quot; could not be processed.&quot;);
                 }
             }
 

Modified: rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/ParticleSystemNodeProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -22,11 +22,10 @@
 #include &quot;ParticleSystemObject.h&quot;
 
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
-    bool ParticleSystemNodeProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
+    bool ParticleSystemNodeProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
     {
 		if (!hasNodeName(nodeElem, &quot;particlesystem&quot;))
 		{

Modified: rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,8 +17,6 @@
 
 #include &quot;PlaneNodeProcessor.h&quot;
 
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
 #include &quot;CoreSubsystem.h&quot;
 #include &quot;PhysicsManager.h&quot;
 #include &quot;World.h&quot;
@@ -26,7 +24,6 @@
 //#include &lt;OgreMaterialManager.h&gt;
 
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
@@ -34,7 +31,7 @@
 	{
 	}
 
-	bool PlaneNodeProcessor::processNode(DOMElement *nodeElem, bool loadGameObjects)
+	bool PlaneNodeProcessor::processNode(const TiXmlElement *nodeElem, bool loadGameObjects)
 	{
 		if (!hasNodeName(nodeElem, &quot;plane&quot;))
         {
@@ -46,7 +43,7 @@
 		LOG_DEBUG(Logger::RULES,
             &quot;Processing plane node &quot;
                 + entName);
-		if(entName==&quot;&quot;)
+		if (entName==&quot;&quot;)
 		{
 			entName = getRandomName(&quot;Plane&quot;);
 		}
@@ -55,7 +52,7 @@
 		Vector3 position(Vector3::ZERO);
 		Vector2 scale(1,1);
 
-		DOMElement* oriElem = getChildNamed(nodeElem, &quot;rotation&quot;);
+		const TiXmlElement* oriElem = getChildNamed(nodeElem, &quot;rotation&quot;);
         if (oriElem != NULL)
         {
             orientation = processQuaternion(oriElem);
@@ -65,7 +62,7 @@
             LOG_WARNING(Logger::RULES, &quot;No orientation given for plane, used Identity&quot;);
         }
 
-		DOMElement* posElem = getChildNamed(nodeElem, &quot;position&quot;);
+        const TiXmlElement* posElem = getChildNamed(nodeElem, &quot;position&quot;);
         if (posElem != NULL)
         {
             position = processVector3(posElem);
@@ -75,7 +72,7 @@
             LOG_WARNING(Logger::RULES, &quot;No position given for plane, used (0,0,0)&quot;);
         }
 
-		DOMElement* scaleElem = getChildNamed(nodeElem, &quot;scale&quot;);
+        const TiXmlElement* scaleElem = getChildNamed(nodeElem, &quot;scale&quot;);
         if (posElem != NULL)
         {
             scale = processVector2(scaleElem);
@@ -108,10 +105,10 @@
 
 		createCollision(ent, getChildNamed(nodeElem, &quot;physicsproxy&quot;));
 		
-		DOMElement* materialElem = getChildNamed(nodeElem, &quot;material&quot;);
-		if(materialElem)
+		const TiXmlElement* materialElem = getChildNamed(nodeElem, &quot;material&quot;);
+		if (materialElem)
 		{	
-			if(getChildNamed(nodeElem, &quot;renderToTexture&quot;))
+			if (getChildNamed(nodeElem, &quot;renderToTexture&quot;))
 			{
 				Ogre::String matName = getAttributeValueAsStdString(materialElem, &quot;name&quot;);
 				MaterialPtr material = static_cast&lt;MaterialPtr&gt;(MaterialManager::getSingleton().getByName(matName))-&gt;clone(matName + entName);
@@ -128,14 +125,14 @@
 		return true;
 	}
 
-	void PlaneNodeProcessor::createCollision(Ogre::Entity *entity, DOMElement *physicsProxyElem)
+	void PlaneNodeProcessor::createCollision(Ogre::Entity *entity, const TiXmlElement *physicsProxyElem)
 	{
 		bool collisionEnabled = false;
 		if (physicsProxyElem == NULL || !hasAttribute(physicsProxyElem, &quot;collision&quot;))
 			collisionEnabled = false;
-		else if(getAttributeValueAsBool(physicsProxyElem, &quot;collision&quot;))
+		else if (getAttributeValueAsBool(physicsProxyElem, &quot;collision&quot;))
 			collisionEnabled = true;
-		if(collisionEnabled)
+		if (collisionEnabled)
 		{
 			std::vector&lt;OgreNewt::CollisionPtr&gt; collisions;
 			OgreNewt::CollisionPtr collision = OgreNewt::CollisionPtr();
@@ -164,9 +161,9 @@
 		}
 	}
 
-	void PlaneNodeProcessor::createRenderToTextures(Ogre::Entity* entity, Plane* plane, MaterialPtr material, XERCES_CPP_NAMESPACE::DOMElement* rttElem)
+	void PlaneNodeProcessor::createRenderToTextures(Ogre::Entity* entity, Plane* plane, MaterialPtr material, const TiXmlElement* rttElem)
 	{
-		if(rttElem == NULL)
+		if (rttElem == NULL)
 			return;
 
 		Camera* cam = CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager()-&gt;createCamera(&quot;Cam&quot; + entity-&gt;getName());
@@ -178,7 +175,7 @@
 
 		AliasTextureNamePairList aliases;
 
-		if(getAttributeValueAsBool(rttElem, &quot;reflection&quot;))
+		if (getAttributeValueAsBool(rttElem, &quot;reflection&quot;))
 		{
 			TexturePtr texture = Ogre::TextureManager::getSingleton().createManual( &quot;Reflection&quot; + entity-&gt;getName(), 
 				ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, TEX_TYPE_2D, 
@@ -193,7 +190,7 @@
 
 			cam-&gt;enableCustomNearClipPlane((MovablePlane*)plane);
 		}
-		if(getAttributeValueAsBool(rttElem, &quot;refraction&quot;))
+		if (getAttributeValueAsBool(rttElem, &quot;refraction&quot;))
 		{
 			TexturePtr texture = Ogre::TextureManager::getSingleton().createManual( &quot;Refraction&quot; + entity-&gt;getName(), 
 				ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, TEX_TYPE_2D, 
@@ -209,7 +206,7 @@
 			plane-&gt;normal = Vector3::NEGATIVE_UNIT_Y;
 			cam-&gt;enableCustomNearClipPlane((MovablePlane*)plane);
 		}
-		if(!material-&gt;applyTextureAliases(aliases))
+		if (!material-&gt;applyTextureAliases(aliases))
 			LOG_ERROR(&quot;PLANE&quot;, &quot;Texture Aliase konnten nicht angewandt werden&quot;);
 	}
 

Modified: rl/trunk/engine/script/src/SceneLoader.cpp
===================================================================
--- rl/trunk/engine/script/src/SceneLoader.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/SceneLoader.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,30 +17,22 @@
 
 #include &quot;SceneLoader.h&quot;
 
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
 #include &quot;Scene.h&quot;
 
-using namespace XERCES_CPP_NAMESPACE;
-
 namespace rl
 {
 
 Scene* SceneLoader::loadScene(Ogre::DataStreamPtr &amp;data)
 {
-    initializeXml();
-
-    DOMDocument* doc = loadDocument(data);
-    DOMElement* root = doc-&gt;getDocumentElement();
+    TiXmlDocument* doc = loadDocument(data);
+    TiXmlElement* root = doc-&gt;RootElement();
     Scene* scene = new Scene(getAttributeValueAsString(root, &quot;name&quot;));
     
-    DOMNodeList* children = root-&gt;getChildNodes();
-    for (XMLSize_t i = 0; i &lt; children-&gt;getLength(); ++i)
+    for (TiXmlNode* cur = root-&gt;FirstChild(); cur; cur = cur-&gt;NextSibling())
     {
-        DOMNode* cur = children-&gt;item(i);
-        if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+        if (cur-&gt;Type() == TiXmlNode::ELEMENT)
         {
-            DOMElement* elem = static_cast&lt;DOMElement*&gt;(cur);
+            TiXmlElement* elem = cur-&gt;ToElement();
             if (hasNodeName(elem, &quot;map&quot;))
             {
                 scene-&gt;addMap(getAttributeValueAsStdString(elem, &quot;file&quot;));
@@ -48,7 +40,7 @@
         }
     }
 
-    shutdownXml();
+    delete doc;
 
     return scene;
 }

Modified: rl/trunk/engine/script/src/SoundNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/SoundNodeProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/SoundNodeProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -18,11 +18,10 @@
 #include &quot;SoundNodeProcessor.h&quot;
 
 using namespace Ogre;
-using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
 {
-    bool SoundNodeProcessor::processNode(XERCES_CPP_NAMESPACE::DOMElement* nodeElem, bool loadGameObjects)
+    bool SoundNodeProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
     {
         if (!hasNodeName(nodeElem, &quot;sound&quot;))
         {
@@ -33,8 +32,6 @@
             &quot;Processing sound node &quot;
                 + getAttributeValueAsStdString(nodeElem, &quot;name&quot;));
 
-
-
         return false;
     }
 }

Modified: rl/trunk/engine/script/src/TriggerFactory.cpp
===================================================================
--- rl/trunk/engine/script/src/TriggerFactory.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/TriggerFactory.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -41,11 +41,9 @@
         return &quot;triggerfactory&quot;;
     }
 
-    using namespace XERCES_CPP_NAMESPACE;
-
     void TriggerFactory::writeData(SaveGameFileWriter* writer)
     {
-        DOMElement* triggerParentNode = writer-&gt;appendChildElement(writer-&gt;getDocument(), writer-&gt;getDocument()-&gt;getDocumentElement(), getXmlNodeIdentifier().c_str());
+        TiXmlElement* triggerParentNode = writer-&gt;appendChildElement(writer-&gt;getDocument()-&gt;RootElement(), getXmlNodeIdentifier().c_str());
 
         const ZoneManager::ZoneMap &amp;zoneMap(ZoneManager::getSingleton().getAllZones());
         ZoneManager::ZoneMap::const_iterator zone;
@@ -57,9 +55,9 @@
             // search for triggers in a zone
             for(std::list&lt;Trigger*&gt;::iterator trigger = allTriggers.begin(); trigger != allTriggers.end(); trigger++)
             {
-                if((*trigger)-&gt;needsToBeSaved())
+                if ((*trigger)-&gt;needsToBeSaved())
                 {
-                    DOMElement* triggerNode = writer-&gt;appendChildElement(writer-&gt;getDocument(), triggerParentNode, &quot;trigger&quot;);
+                    TiXmlElement* triggerNode = writer-&gt;appendChildElement(triggerParentNode, &quot;trigger&quot;);
                     writer-&gt;setAttributeValueAsStdString(triggerNode, &quot;name&quot;, (*trigger)-&gt;getName());
                     writer-&gt;setAttributeValueAsStdString(triggerNode, &quot;classname&quot;, (*trigger)-&gt;getClassName());
                     writer-&gt;setAttributeValueAsStdString(triggerNode, &quot;zone&quot;, zone-&gt;first);
@@ -83,10 +81,10 @@
             // search for triggers in a zone
             for(std::list&lt;Trigger*&gt;::iterator trigger = allTriggers.begin(); trigger != allTriggers.end(); trigger++)
             {
-                if((*trigger)-&gt;needsToBeSaved())
+                if ((*trigger)-&gt;needsToBeSaved())
                 {
                     zone-&gt;second-&gt;removeTrigger((*trigger));
-                    if((*trigger)-&gt;deleteIfZoneDestroyed())
+                    if ((*trigger)-&gt;deleteIfZoneDestroyed())
                     {
                         //ScriptWrapper::getSingleton().owned((*trigger));
                         delete (*trigger);
@@ -96,52 +94,43 @@
             }
         }
 
+        XmlElementList rootNodeList = reader-&gt;getElementsByTagName(reader-&gt;getDocument(), getXmlNodeIdentifier().c_str());
 
-
-
-        // initialize xmlreader
-        reader-&gt;initializeXml();
-
-        DOMNodeList* rootNodeList = reader-&gt;getDocument()-&gt;getDocumentElement()-&gt;getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
-
-        if(rootNodeList-&gt;getLength())
+        if (!rootNodeList.empty())
         {
-            DOMNodeList* xmlTriggerFactory = static_cast&lt;DOMElement*&gt;(rootNodeList-&gt;item(0))-&gt;getElementsByTagName(AutoXMLCh(&quot;trigger&quot;).data());
-            if(xmlTriggerFactory-&gt;getLength())
-            {
-                for(XMLSize_t childIdx1 = 0; childIdx1 &lt; xmlTriggerFactory-&gt;getLength(); childIdx1++)
-                {
-                    DOMNode* xmlTrigger = xmlTriggerFactory-&gt;item(childIdx1);
-                    if(xmlTrigger-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
-                    {
-                        Ogre::String classname = reader-&gt;getAttributeValueAsStdString(static_cast&lt;DOMElement*&gt;(xmlTrigger), &quot;classname&quot;);
-                        Ogre::String name = reader-&gt;getAttributeValueAsStdString(static_cast&lt;DOMElement*&gt;(xmlTrigger), &quot;name&quot;);
-                        Ogre::String zoneName = reader-&gt;getAttributeValueAsStdString(static_cast&lt;DOMElement*&gt;(xmlTrigger), &quot;zone&quot;);
+            XmlElementList xmlTriggerFactory = reader-&gt;getElementsByTagName(rootNodeList[0], &quot;trigger&quot;);
+			for (XmlElementList::iterator it = xmlTriggerFactory.begin(); it != xmlTriggerFactory.end(); ++it)
+			{
+				const TiXmlNode* xmlTrigger = *it;
+				if (xmlTrigger-&gt;Type() == TiXmlNode::ELEMENT)
+				{
+					const TiXmlElement* xmlTriggerElem = xmlTrigger-&gt;ToElement();
+					Ogre::String classname = reader-&gt;getAttributeValueAsStdString(xmlTriggerElem, &quot;classname&quot;);
+					Ogre::String name = reader-&gt;getAttributeValueAsStdString(xmlTriggerElem, &quot;name&quot;);
+					Ogre::String zoneName = reader-&gt;getAttributeValueAsStdString(xmlTriggerElem, &quot;zone&quot;);
 
-                        PropertyRecordPtr properties = reader-&gt;getPropertiesAsRecord(static_cast&lt;DOMElement*&gt;(xmlTrigger));
+					PropertyRecordPtr properties = reader-&gt;getPropertiesAsRecord(xmlTriggerElem);
 
 
-                        Trigger *trigger = createTrigger(classname, name);
-                        if( trigger ) // if not, there is an error-msg from the script!
-                        {
-                            trigger-&gt;setProperties(properties);
-                            Zone *zone = ZoneManager::getSingleton().getZone(zoneName);
-                            if(zone == NULL)
-                            {
-                                LOG_ERROR(Logger::SCRIPT, &quot;Tried to load trigger for zone '&quot;+zoneName+&quot;', but the zone could not be found!&quot;);
-                                delete trigger;
-                            }
-                            else
-                                zone-&gt;addTrigger(trigger);
-                        }
+					Trigger *trigger = createTrigger(classname, name);
+					if (trigger) // if not, there is an error-msg from the script!
+					{
+						trigger-&gt;setProperties(properties);
+						Zone *zone = ZoneManager::getSingleton().getZone(zoneName);
+						if (zone == NULL)
+						{
+							LOG_ERROR(Logger::SCRIPT, &quot;Tried to load trigger for zone '&quot;+zoneName+&quot;', but the zone could not be found!&quot;);
+							delete trigger;
+						}
+						else
+						{
+							zone-&gt;addTrigger(trigger);
+						}
+					}
 
-                    }
-                }
-            }
+				}
+			}
         }
-
-        // close xmlreader
-        reader-&gt;shutdownXml();
     }
 
     int TriggerFactory::getPriority() const

Modified: rl/trunk/engine/script/src/WaypointProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/WaypointProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/WaypointProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -21,25 +21,24 @@
 #include &quot;Landmark.h&quot;
 #include &quot;LandmarkPath.h&quot;
 
-using namespace XERCES_CPP_NAMESPACE;
 using namespace Ogre;
 
 namespace rl
 {
-	bool WaypointProcessor::processNode(DOMElement* nodeElem, bool loadGameObjects)
+	bool WaypointProcessor::processNode(const TiXmlElement* nodeElem, bool loadGameObjects)
 	{
 		if (nodeElem == NULL)
 		{
 			return false;
 		}
 
-		for (DOMNode* cur = nodeElem-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+		for (const TiXmlNode* cur = nodeElem-&gt;FirstChild(); cur != NULL; cur = cur-&gt;NextSibling())
 		{
-			if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE &amp;&amp; hasNodeName(cur, &quot;landmark&quot;))
+			if (cur-&gt;Type() == TiXmlNode::ELEMENT &amp;&amp; hasNodeName(cur, &quot;landmark&quot;))
 			{
-				DOMElement* elem = static_cast&lt;DOMElement*&gt;(cur);
+				const TiXmlElement* elem = cur-&gt;ToElement();
 				Ogre::String name = getAttributeValueAsStdString(elem, &quot;name&quot;);
-				DOMElement* posChild = getChildNamed(elem, &quot;position&quot;);
+				const TiXmlElement* posChild = getChildNamed(elem, &quot;position&quot;);
 				if (name != &quot;&quot; &amp;&amp; posChild != NULL)
 				{
 					AiSubsystem::getSingleton().createLandmark(
@@ -48,23 +47,23 @@
 			}
 		}
 
-		for (DOMNode* cur = nodeElem-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+		for (const TiXmlNode* cur = nodeElem-&gt;FirstChild(); cur != NULL; cur = cur-&gt;NextSibling())
 		{
-			if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE &amp;&amp; hasNodeName(cur, &quot;landmarkgraph&quot;))
+			if (cur-&gt;Type() == TiXmlNode::ELEMENT &amp;&amp; hasNodeName(cur, &quot;landmarkgraph&quot;))
 			{
-				DOMElement* elem = static_cast&lt;DOMElement*&gt;(cur);
+				const TiXmlElement* elem = cur-&gt;ToElement();
 				///@todo process waypointgraph
 				Ogre::String name;
 
 				LandmarkPath* path = AiSubsystem::getSingleton().createLandmarkPath(name);
 
-				for (DOMNode* curPathChild = nodeElem-&gt;getFirstChild();
-					curPathChild != NULL; curPathChild = curPathChild-&gt;getNextSibling())
+				for (const TiXmlNode* curPathChild = nodeElem-&gt;FirstChild();
+					curPathChild != NULL; curPathChild = curPathChild-&gt;NextSibling())
 				{
-					if (curPathChild-&gt;getNodeType() == DOMNode::ELEMENT_NODE
+					if (curPathChild-&gt;Type() == TiXmlNode::ELEMENT
 						&amp;&amp; hasNodeName(curPathChild, &quot;landmark&quot;))
 					{
-						DOMElement* curLmElem = static_cast&lt;DOMElement*&gt;(curPathChild);
+						const TiXmlElement* curLmElem = curPathChild-&gt;ToElement();
 						Landmark* lm = AiSubsystem::getSingleton().getLandmark(
 							getAttributeValueAsStdString(curLmElem, &quot;name&quot;));
 

Modified: rl/trunk/engine/script/src/ZoneProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/ZoneProcessor.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/script/src/ZoneProcessor.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -25,25 +25,24 @@
 #include &quot;Zone.h&quot;
 #include &quot;ZoneManager.h&quot;
 
-using namespace XERCES_CPP_NAMESPACE;
 using namespace Ogre;
 
 namespace rl
 {
 
-	bool ZoneProcessor::processNode(DOMElement* zonesElem, bool loadGameObjects)
+	bool ZoneProcessor::processNode(const TiXmlElement* zonesElem, bool loadGameObjects)
 	{
 		if (zonesElem == NULL)
 		{
 			return false; // no zones
 		}
 
-        for (DOMNode* cur = zonesElem-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+        for (const TiXmlNode* cur = zonesElem-&gt;FirstChild(); cur != NULL; cur = cur-&gt;NextSibling())
         {
-            if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE
+            if (cur-&gt;Type() == TiXmlNode::ELEMENT
 				&amp;&amp; hasNodeName(cur, &quot;zone&quot;))
             {
-				DOMElement* curZoneElem = static_cast&lt;DOMElement*&gt;(cur);
+            	const TiXmlElement* curZoneElem = cur-&gt;ToElement();
 				if (hasAttribute(curZoneElem, &quot;name&quot;))
 				{
 					Ogre::String name = getAttributeValueAsStdString(curZoneElem, &quot;name&quot;);
@@ -62,12 +61,12 @@
                         }
 
                         // multiple areas
-                        for(DOMNode* curArea = cur-&gt;getFirstChild(); curArea != NULL; curArea = curArea-&gt;getNextSibling())
+                        for (const TiXmlNode* curArea = cur-&gt;FirstChild(); curArea != NULL; curArea = curArea-&gt;NextSibling())
                         {
-                            if (curArea-&gt;getNodeType() == DOMNode::ELEMENT_NODE
+                            if (curArea-&gt;Type() == TiXmlNode::ELEMENT
                                 &amp;&amp; hasNodeName(curArea, &quot;area&quot;))
                             {
-                                DOMElement *curAreaElem = static_cast&lt;DOMElement*&gt;(curArea);
+                            	const TiXmlElement *curAreaElem = curArea-&gt;ToElement();
                                 if (hasAttribute(curAreaElem, &quot;type&quot;))
                                 {
                                     // type
@@ -83,7 +82,7 @@
 
                                     // position
                                     Vector3 position = Vector3::ZERO;
-                                    DOMElement* positionElem = getChildNamed(curAreaElem, &quot;position&quot;);
+                                    const TiXmlElement* positionElem = getChildNamed(curAreaElem, &quot;position&quot;);
                                     if (positionElem)
                                     {
                                         position = getValueAsVector3(positionElem);
@@ -91,7 +90,7 @@
 
                                     //scale, rotation, offset
                                     Vector3 scale = Vector3::UNIT_SCALE;
-                                    DOMElement* scaleElem = getChildNamed(curAreaElem, &quot;scale&quot;);
+                                    const TiXmlElement* scaleElem = getChildNamed(curAreaElem, &quot;scale&quot;);
                                     if (!scaleElem)
                                     {
                                         scaleElem = getChildNamed(curAreaElem, &quot;size&quot;);
@@ -103,14 +102,14 @@
                                     }
 
                                     Vector3 offset = Vector3::ZERO;
-                                    DOMElement* offsetElem = getChildNamed(curAreaElem, &quot;offset&quot;);
+                                    const TiXmlElement* offsetElem = getChildNamed(curAreaElem, &quot;offset&quot;);
                                     if (offsetElem)
                                     {
                                         offset = getValueAsVector3(offsetElem);
                                     }
 
                                     Quaternion rotation = Quaternion::IDENTITY;
-                                    DOMElement* rotationElem = getChildNamed(curAreaElem, &quot;rotation&quot;);
+                                    const TiXmlElement* rotationElem = getChildNamed(curAreaElem, &quot;rotation&quot;);
                                     if (rotationElem)
                                     {
                                         rotation = getValueAsQuaternion(rotationElem);
@@ -118,7 +117,7 @@
 
                                     //transition distance
                                     Real transitionDistance = 0;
-                                    DOMElement* transitionElem = getChildNamed(curAreaElem, &quot;transition_distance&quot;);
+                                    const TiXmlElement* transitionElem = getChildNamed(curAreaElem, &quot;transition_distance&quot;);
                                     if (transitionElem)
                                     {
                                         transitionDistance = getValueAsReal(transitionElem);
@@ -199,11 +198,11 @@
 
 					if (zone)
 					{
-						for (DOMNode* cur = curZoneElem-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
+						for (const TiXmlNode* cur = curZoneElem-&gt;FirstChild(); cur != NULL; cur = cur-&gt;NextSibling())
 						{
-							if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
+							if (cur-&gt;Type() == TiXmlNode::ELEMENT)
 							{
-								DOMElement* curElem = static_cast&lt;DOMElement*&gt;(cur);
+								const TiXmlElement* curElem = cur-&gt;ToElement();
 								if (hasNodeName(curElem, &quot;light&quot;))
 								{
 									Ogre::String name = getAttributeValueAsStdString(curElem, &quot;name&quot;);
@@ -226,11 +225,11 @@
 										-&gt;createTrigger(classname, name);
 
                                     // add trigger properties
-                                    for( DOMNode* curProperty = cur-&gt;getFirstChild(); curProperty != NULL; curProperty = curProperty-&gt;getNextSibling())
+                                    for (const TiXmlNode* curProperty = cur-&gt;FirstChild(); curProperty != NULL; curProperty = curProperty-&gt;NextSibling())
                                     {
                                         if (hasNodeName(curProperty, &quot;property&quot;))
                                         {
-                                            PropertyEntry propEntry = processProperty(static_cast&lt;DOMElement*&gt;(curProperty));
+                                            PropertyEntry propEntry = processProperty(curProperty-&gt;ToElement());
                                             if (propEntry.first != &quot;&quot;)
                                             {
                                                 trigger-&gt;setProperty(propEntry.first, propEntry.second);

Modified: rl/trunk/engine/startup/CMakeLists.txt
===================================================================
--- rl/trunk/engine/startup/CMakeLists.txt	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/startup/CMakeLists.txt	2009-11-07 19:39:22 UTC (rev 4961)
@@ -5,7 +5,7 @@
 ${RL_AI_INCLUDE_DIR}
 ${RL_UI_INCLUDE_DIR}
 ${RL_SCRIPT_INCLUDE_DIR}
-${XERCESC_INCLUDE_DIR}
+${TINYXML_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}
 ${OGRENEWT_INCLUDE_DIR}
@@ -16,6 +16,6 @@
 
 ADD_EXECUTABLE(rastullah ${Rastullah_APP_SRCS})
 
-TARGET_LINK_LIBRARIES(rastullah RlCommon RlCore RlRules RlAi RlUi RlScript)
+TARGET_LINK_LIBRARIES(rastullah RlCommon RlCore RlRules RlAi RlUi RlScript ${TINYXML_LIBRARY})
 
 INSTALL(TARGETS rastullah RUNTIME DESTINATION ${CMAKE_INSTALL_PREFIX}/${BINDIR})

Modified: rl/trunk/engine/startup/src/RastullahMain.cpp
===================================================================
--- rl/trunk/engine/startup/src/RastullahMain.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/startup/src/RastullahMain.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -14,8 +14,6 @@
 *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
 */
 
-#include &lt;xercesc/util/XMemory.hpp&gt;    // Muss vor Ogre stehen (zumindest fuer VS)
-
 #include &lt;stdexcept&gt;
 #include &lt;errno.h&gt;
 

Modified: rl/trunk/engine/ui/CMakeLists.txt
===================================================================
--- rl/trunk/engine/ui/CMakeLists.txt	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ui/CMakeLists.txt	2009-11-07 19:39:22 UTC (rev 4961)
@@ -4,7 +4,7 @@
 ${RL_CORE_INCLUDE_DIR}
 ${RL_RULES_INCLUDE_DIR}
 ${RL_AI_INCLUDE_DIR}
-${XERCESC_INCLUDE_DIR}
+${TINYXML_INCLUDE_DIR}
 ${OGRE_INCLUDE_DIRS}
 ${OIS_INCLUDE_DIRS}
 ${CEGUI_INCLUDE_DIRS}

Modified: rl/trunk/engine/ui/include/UiPrerequisites.h
===================================================================
--- rl/trunk/engine/ui/include/UiPrerequisites.h	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ui/include/UiPrerequisites.h	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,8 +17,6 @@
 #ifndef __UiPrerequisites_H__
 #define __UiPrerequisites_H__
 
-#include &lt;xercesc/util/XMemory.hpp&gt;	// Muss vor Ogre stehen (zumindest f&#239;&#191;&#189;r VS)
-
 #undef _assert
 
 #include &lt;vector&gt;

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2009-11-07 19:36:41 UTC (rev 4960)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2009-11-07 19:39:22 UTC (rev 4961)
@@ -17,8 +17,6 @@
 
 #include &quot;InputManager.h&quot;
 
-#include &lt;xercesc/dom/DOM.hpp&gt;
-
 #ifdef __APPLE__
 #   include &lt;OIS/OISInputManager.h&gt;
 #else
@@ -267,20 +265,15 @@
 
     void InputManager::loadKeyMapping(const Ogre::String&amp; filename)
     {
-        using namespace XERCES_CPP_NAMESPACE;
-        using XERCES_CPP_NAMESPACE::DOMDocument;
         using std::make_pair;
 
-        initializeXml();
+        TiXmlDocument* doc = loadDocument(filename);
+        TiXmlElement* dataDocumentContent = doc-&gt;RootElement();
 
-        DOMDocument* doc = loadDocument(filename);
-        DOMElement* dataDocumentContent = doc-&gt;getDocumentElement();
-
-        DOMNodeList* keymaps
-            = dataDocumentContent-&gt;getElementsByTagName(AutoXMLCh(&quot;Key&quot;).data());
-        for (unsigned int idx = 0; idx &lt; keymaps-&gt;getLength(); idx++)
+        XmlElementList keymaps = getElementsByTagName(dataDocumentContent, &quot;Key&quot;);
+        for (unsigned int idx = 0; idx &lt; keymaps.size(); idx++)
         {
-            DOMElement* key = static_cast&lt;DOMElement*&gt;(keymaps-&gt;item(idx));
+            const TiXmlElement* key = keymaps[idx];
             int keycode = getAttributeValueAsInteger(key, &quot;KeyCode&quot;);
 
             CeGuiString s;
@@ -305,8 +298,6 @@
             s = getAttributeValueAsString(key, &quot;KeyDescription&quot;);
             mKeyNames.insert(make_pair(keycode, s));
         }
-
-        shutdownXml();
     }
 
     const CEGUI::utf8&amp; InputManager::getKeyChar(int scancode, int modifiers) const


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002016.html">[Dsa-hl-svn] r4960 - in dependencies: . tinyxml tinyxml/docs
</A></li>
	<LI>Next message: <A HREF="002018.html">[Dsa-hl-svn] r4962 - in rl/trunk/engine/core: include src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2017">[ date ]</a>
              <a href="thread.html#2017">[ thread ]</a>
              <a href="subject.html#2017">[ subject ]</a>
              <a href="author.html#2017">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
