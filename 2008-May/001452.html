<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4381 - in rl/branches: .	ogre16/rl/trunk/engine/core/include ogre16/rl/trunk/engine/core/src	ogre16/rl/trunk/engine/rules/src ogre16/rl/trunk/engine/script/swig	ogre16/rl/trunk/engine/ui/src ogre16/rl/trunk/tools
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2008-May/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4381%20-%20in%20rl/branches%3A%20.%0A%09ogre16/rl/trunk/engine/core/include%20ogre16/rl/trunk/engine/core/src%0A%09ogre16/rl/trunk/engine/rules/src%20ogre16/rl/trunk/engine/script/swig%0A%09ogre16/rl/trunk/engine/ui/src%20ogre16/rl/trunk/tools&In-Reply-To=%3C200805221821.m4MILQ4A004025%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001451.html">
   <LINK REL="Next"  HREF="001453.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4381 - in rl/branches: .	ogre16/rl/trunk/engine/core/include ogre16/rl/trunk/engine/core/src	ogre16/rl/trunk/engine/rules/src ogre16/rl/trunk/engine/script/swig	ogre16/rl/trunk/engine/ui/src ogre16/rl/trunk/tools</H1>
    <B>tanis at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4381%20-%20in%20rl/branches%3A%20.%0A%09ogre16/rl/trunk/engine/core/include%20ogre16/rl/trunk/engine/core/src%0A%09ogre16/rl/trunk/engine/rules/src%20ogre16/rl/trunk/engine/script/swig%0A%09ogre16/rl/trunk/engine/ui/src%20ogre16/rl/trunk/tools&In-Reply-To=%3C200805221821.m4MILQ4A004025%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4381 - in rl/branches: .	ogre16/rl/trunk/engine/core/include ogre16/rl/trunk/engine/core/src	ogre16/rl/trunk/engine/rules/src ogre16/rl/trunk/engine/script/swig	ogre16/rl/trunk/engine/ui/src ogre16/rl/trunk/tools">tanis at mail.berlios.de
       </A><BR>
    <I>Thu May 22 20:21:26 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001451.html">[Dsa-hl-svn] r4380 - rl/trunk/tools
</A></li>
        <LI>Next message: <A HREF="001453.html">[Dsa-hl-svn] r4382 - in rl/branches/ogre16: . rl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1452">[ date ]</a>
              <a href="thread.html#1452">[ thread ]</a>
              <a href="subject.html#1452">[ subject ]</a>
              <a href="author.html#1452">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: tanis
Date: 2008-05-22 20:21:17 +0200 (Thu, 22 May 2008)
New Revision: 4381

Added:
   rl/branches/ogre16/
   rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.head.swig
   rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.swig
   rl/branches/ogre16/rl/trunk/tools/material_updater.rb
Removed:
   rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.head.swig
   rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.swig
Modified:
   rl/branches/ogre16/rl/trunk/engine/core/include/ListenerMovable.h
   rl/branches/ogre16/rl/trunk/engine/core/include/MovableText.h
   rl/branches/ogre16/rl/trunk/engine/core/include/Sound.h
   rl/branches/ogre16/rl/trunk/engine/core/include/SoundResource.h
   rl/branches/ogre16/rl/trunk/engine/core/include/SoundStitching.h
   rl/branches/ogre16/rl/trunk/engine/core/src/Actor.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/ConfigurationManager.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/DotSceneLoader.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/ListenerMovable.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/MovableText.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/Sound.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/SoundResource.cpp
   rl/branches/ogre16/rl/trunk/engine/core/src/SoundStitching.cpp
   rl/branches/ogre16/rl/trunk/engine/rules/src/CreatureController.cpp
   rl/branches/ogre16/rl/trunk/engine/ui/src/DebugWindow.cpp
   rl/branches/ogre16/rl/trunk/engine/ui/src/DialogControlState.cpp
   rl/branches/ogre16/rl/trunk/engine/ui/src/InputManager.cpp
   rl/branches/ogre16/rl/trunk/engine/ui/src/InventoryWindow.cpp
Log:
Branch for new ogre version 1.6

Copied: rl/branches/ogre16 (from rev 4375, )

Modified: rl/branches/ogre16/rl/trunk/engine/core/include/ListenerMovable.h
===================================================================
--- rl/trunk/engine/core/include/ListenerMovable.h	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/include/ListenerMovable.h	2008-05-22 18:21:17 UTC (rev 4381)
@@ -48,6 +48,7 @@
         virtual Ogre::Real getBoundingRadius() const;
         /// Rendern
         virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+		virtual void visitRenderables(Ogre::Renderable::Visitor* visitor, bool debugRenderables);
     
         /// Gibt die Hauptlautstaerke zurueck
         virtual const int getGain() const;

Modified: rl/branches/ogre16/rl/trunk/engine/core/include/MovableText.h
===================================================================
--- rl/trunk/engine/core/include/MovableText.h	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/include/MovableText.h	2008-05-22 18:21:17 UTC (rev 4381)
@@ -58,6 +58,7 @@
         const Ogre::Vector3&amp; getWorldPosition(void) const;
         void _notifyCurrentCamera(Ogre::Camera *cam);
         void _updateRenderQueue(Ogre::RenderQueue* queue);
+		void visitRenderables(Ogre::Renderable::Visitor* visitor, bool debugRenderables);
 
         const Ogre::AxisAlignedBox &amp;getBoundingBox(void) const { return mAABB; }
         const Ogre::String&amp; getMovableType(void) const { return msType; }

Modified: rl/branches/ogre16/rl/trunk/engine/core/include/Sound.h
===================================================================
--- rl/trunk/engine/core/include/Sound.h	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/include/Sound.h	2008-05-22 18:21:17 UTC (rev 4381)
@@ -81,6 +81,7 @@
         virtual Ogre::Real getBoundingRadius() const;
         /// Rendern
         virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+		void visitRenderables(Ogre::Renderable::Visitor* visitor, bool debugRenderables);
 
 
         /// Gibt die eingestellte Position der Soundquelle zurueck

Modified: rl/branches/ogre16/rl/trunk/engine/core/include/SoundResource.h
===================================================================
--- rl/trunk/engine/core/include/SoundResource.h	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/include/SoundResource.h	2008-05-22 18:21:17 UTC (rev 4381)
@@ -47,7 +47,7 @@
         /// Den Datenstrom zur&#239;&#191;&#189;ckgeben
         const Ogre::DataStreamPtr &amp;getDataStream() const;
         /// Groesse zurueckgeben.
-        int getSize() const;
+        virtual size_t getSize() const;
 
     protected:
 		/// Laedt die Soundquelle.

Modified: rl/branches/ogre16/rl/trunk/engine/core/include/SoundStitching.h
===================================================================
--- rl/trunk/engine/core/include/SoundStitching.h	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/include/SoundStitching.h	2008-05-22 18:21:17 UTC (rev 4381)
@@ -83,6 +83,7 @@
         virtual Ogre::Real getBoundingRadius() const;
         /// Rendern
         virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+		virtual void visitRenderables(Ogre::Renderable::Visitor* visitor, bool debugRenderables);
 
         /// Count of configured slots.
         unsigned int getNumSlots();

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/Actor.cpp
===================================================================
--- rl/trunk/engine/core/src/Actor.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/Actor.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -432,19 +432,6 @@
         {
             Vector3 vec = Vector3(sx,sy,sz);
             node-&gt;setScale( vec );
-
-            // Falls es sich um ein Mesh handelt ...
-            if( getControlledObject()-&gt;isMeshObject() )
-            {
-                MeshObject* meshObj = dynamic_cast&lt;MeshObject*&gt;( getControlledObject() );
-
-                // ... und gr&#246;&#223;er/kleiner als normal skaliert wird ...
-                if( vec != Vector3(1,1,1) )
-                    // ... m&#252;ssen die Normalen neu berechnet werden.
-                    meshObj-&gt;getEntity()-&gt;setNormaliseNormals( true );
-                else
-                    meshObj-&gt;getEntity()-&gt;setNormaliseNormals( false );
-            }
         }
     }
 

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -81,6 +81,7 @@
         addSetting(&quot;Video&quot;, &quot;Max Anisotropy&quot;, &quot;1&quot;);
 		addSetting(&quot;Video&quot;, &quot;Cast Shadows&quot;, &quot;yes&quot;);
 		addSetting(&quot;Video&quot;, &quot;Shadow Texture Size&quot;, &quot;512&quot;);
+		addSetting(&quot;Video&quot;, &quot;useNVPerfHUD&quot;, &quot;true&quot;);
 
         // Setup input default values
         addSetting(&quot;Input&quot;, &quot;Mouse Sensitivity&quot;, &quot;4&quot;);

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/CoreSubsystem.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -1,581 +1,582 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;XmlResourceManager.h&quot;
-
-#include &quot;CoreSubsystem.h&quot;
-
-#include &lt;OgreEnvironment.h&gt;
-
-#include &quot;ActorManager.h&quot;
-#include &quot;AnimationManager.h&quot;
-#include &quot;ContentModule.h&quot;
-#include &quot;ConfigurationManager.h&quot;
-#include &quot;DebugVisualsManager.h&quot;
-#include &quot;DotSceneOctreeWorld.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;GameEventManager.h&quot;
-#include &quot;GameLoop.h&quot;
-#include &quot;JobScheduler.h&quot;
-#include &quot;Logger.h&quot;
-#include &quot;MessagePump.h&quot;
-#include &quot;PhysicsManager.h&quot;
-#include &quot;RubyInterpreter.h&quot;
-#include &quot;SaveGameManager.h&quot;
-#include &quot;ScriptWrapper.h&quot;
-#include &quot;SoundManager.h&quot;
-#include &quot;TimeSource.h&quot;
-#include &quot;ZoneManager.h&quot;
-
-#include &lt;ctime&gt;
-
-using namespace Ogre;
-
-template&lt;&gt; rl::CoreSubsystem* Singleton&lt;rl::CoreSubsystem&gt;::ms_Singleton = 0;
-
-namespace rl
-{
-    CoreSubsystem::CoreSubsystem()
-        : Singleton&lt;CoreSubsystem&gt;(),
-        mWorld(NULL),
-        mRubyInterpreter(NULL),
-        mModules(),
-        mActiveAdventureModule(NULL),
-        mDefaultActiveModule(&quot;&quot;),
-        mClockStartTime(),
-        mDeveloperMode(false),
-        mInitialized(false),
-        mDefaultTechniques(),
-        mOgreRoot(NULL),
-        mScriptWrapper(NULL),
-        mXmlResourceManager(NULL),
-        mPhysicsManager(NULL),
-        mMessagePump(NULL),
-        mGameLoop(NULL),
-        mAnimationManager(NULL),
-        mActorManager(NULL),
-        mGameEventManager(NULL),
-        mSoundManager(NULL),
-        mDebugVisualsManager(NULL),
-        mJobScheduler(NULL),
-        mRenderWindow(NULL),
-        mZoneManager(NULL)
-    {
-        initializeCoreSubsystem();
-    }
-
-    CoreSubsystem::~CoreSubsystem()
-    {
-        delete meshmagick::OgreEnvironment::getSingletonPtr();
-        delete mWorld;
-        delete mZoneManager;
-        delete mGameEventManager;
-        delete mMessagePump;
-        delete mJobScheduler;
-        delete mAnimationManager;
-        delete mActorManager;
-        delete mPhysicsManager;
-        delete mScriptWrapper;
-        delete mDebugVisualsManager;
-        delete ConfigurationManager::getSingletonPtr();
-        delete mSoundManager;
-        mRenderWindow-&gt;destroy();
-        delete mOgreRoot;
-        delete mRubyInterpreter;
-        delete mTimeSourceManager;
-        delete mSaveGameManager;
-        delete mGameLoop;
-        //mXmlResourceManager-&gt;unloadAll();
-        //delete mXmlResourceManager;
-    }
-
-    void CoreSubsystem::startCore()
-    {
-        loadPlugins();
-
-        mInitialized = true;
-
-        if (mDefaultActiveModule == &quot;&quot;)
-        {
-            mDefaultActiveModule = &quot;intro&quot;; ///@fixme replace by last active
-        }
-
-
-        ContentModule* mod = getModule(mDefaultActiveModule);
-        if (mod == NULL)
-        {
-            Throw(rl::RuntimeException, &quot;Module &quot;+mDefaultActiveModule+&quot; not found&quot;);
-        }
-        else
-        {
-            startAdventureModule(mod);
-        }
-
-        mGameLoop-&gt;loop();
-
-        mWorld-&gt;clearScene();
-        unloadPlugins();
-
-        //mRubyInterpreter-&gt;finalizeInterpreter();
-    }
-
-    void CoreSubsystem::renderOneFrame()
-    {
-        mGameLoop-&gt;_executeOneRenderLoop();
-    }
-
-    void CoreSubsystem::setDeveloperMode(bool developerMode)
-    {
-        mDeveloperMode = developerMode;
-    }
-
-    bool CoreSubsystem::getDeveloperMode() const
-    {
-        return mDeveloperMode;
-    }
-
-    bool CoreSubsystem::isInitialized() const
-    {
-        return mInitialized;
-    }
-
-    Ogre::RenderWindow* CoreSubsystem::getRenderWindow() const
-    {
-        return mRenderWindow;
-    }
-
-	void CoreSubsystem::setPaused(bool paused)
-	{
-       // mAnimationManager-&gt;setPaused(paused);
-       // mPhysicsManager-&gt;setPaused(paused);
-        mTimeSourceManager-&gt;setPaused(paused);
-        mGameLoop-&gt;setPaused(paused);
-	}
-
-    void CoreSubsystem::setTimeFactor(const Ogre::Real &amp;factor)
-    {
-        mTimeSourceManager-&gt;setTimeFactor(factor);
-        mPhysicsManager-&gt;setTimeFactor(factor);
-        mGameLoop-&gt;setTimeFactor(factor);
-    }
-
-    bool CoreSubsystem::initializeCoreSubsystem()
-    {
-        // set default queryflags to zero
-        Ogre::MovableObject::setDefaultQueryFlags(0);
-        // By not specifying the first two parameters, OGRE will not try
-        // to load plugins.cfg and ogre.cfg
-        mOgreRoot = new Root(&quot;&quot;, &quot;&quot;, ConfigurationManager::getSingleton().getOgreLogFile());
-
-        // Load Ogre plugins
-        Ogre::StringVector pluginList = ConfigurationManager::getSingleton().getPluginList();
-        for (Ogre::StringVector::const_iterator it = pluginList.begin(); it &lt; pluginList.end(); it++)
-        {
-            mOgreRoot-&gt;loadPlugin(*it);
-        }
-
-        // Find out, what Renderer plugins are available
-        RenderSystemList* rsl = mOgreRoot-&gt;getAvailableRenderers();
-        RenderSystemList::iterator it;
-
-        for (it = rsl-&gt;begin(); it &lt; rsl-&gt;end(); it++)
-        {
-            if ((*it)-&gt;getName() == ConfigurationManager::getSingleton().getStringSetting(
-                &quot;Video&quot;, &quot;Render System&quot;))
-            {
-                // Select and initialise the render system
-                mOgreRoot-&gt;setRenderSystem(*it);
-                mOgreRoot-&gt;initialise(false, &quot;&quot;);
-            }
-        }
-
-        //Root::getSingleton().setFrameSmoothingPeriod(0.5f);
-
-        // Muss vor dem Laden der Ressourcen geschehen,
-        // weil es sonst sofort angewandt wird.
-        MeshManager::getSingleton().setBoundsPaddingFactor(0.0);
-
-        // EDIT:
-        LOG_MESSAGE(Logger::CORE,&quot;init&quot;);
-
-        std::stringstream name;
-        name &lt;&lt; &quot;Rastullahs Lockenpracht - &quot;;
-        name &lt;&lt; getEngineVersionString() &lt;&lt; &quot; &quot;;
-        name &lt;&lt; getEngineVersionName() &lt;&lt; &quot; [&quot;;
-        name &lt;&lt; getEngineBuildNumber() &lt;&lt; &quot;]&quot;;
-
-        // Get width and height of the RenderWindow from the &quot;Video Mode&quot; setting
-        Ogre::String VideoMode = ConfigurationManager::getSingleton().getStringSetting(
-            &quot;Video&quot;, &quot;Video Mode&quot;);
-        int temp = VideoMode.find(&quot;x&quot;);
-        int width = Ogre::StringConverter::parseInt(VideoMode.substr(0, temp));
-        int height = Ogre::StringConverter::parseInt(VideoMode.substr(temp + 1, VideoMode.size()));
-
-        mRenderWindow = mOgreRoot-&gt;createRenderWindow(
-            name.str(), width, height,
-            ConfigurationManager::getSingleton().getBoolSetting(
-                &quot;Video&quot;, &quot;Fullscreen&quot;),
-            ConfigurationManager::getSingleton().getVideoSettings());
-
-        if (!mRenderWindow)
-            return false;
-
-        mGameLoop = new GameLoop();
-        LOG_MESSAGE(Logger::CORE,&quot;GameLoopmanager erzeugt&quot;);
-
-        mSaveGameManager = new SaveGameManager();
-        LOG_MESSAGE(Logger::RULES, &quot;SaveGameManager erzeugt&quot;);
-		
-		mTimeSourceManager = new TimeSourceManager();
-        mTimeSourceManager-&gt;registerTimeSource(new RealTimeContinuous());
-        mTimeSourceManager-&gt;registerTimeSource(new RealTimeInterruptable());
-        LOG_MESSAGE(Logger::CORE,&quot;Time sources (realtime) created&quot;);
-
-        mScriptWrapper = new ScriptWrapper();
-        LOG_MESSAGE(Logger::CORE,&quot;Skriptwrapper erzeugt&quot;);
-        ///@todo: muss loeschbar werden.
-        mRubyInterpreter = new RubyInterpreter();
-        LOG_MESSAGE(Logger::CORE,&quot;RubyInterpreter erzeugt&quot;);
-        mRubyInterpreter-&gt;initializeInterpreter();
-        LOG_MESSAGE(Logger::CORE,&quot;RubyInterpreter initialisiert&quot;);
-
-        mMessagePump = new MessagePump();
-        GameLoop::getSingleton().addTask(mMessagePump, GameLoop::TG_LOGIC);
-        LOG_MESSAGE(Logger::CORE,&quot;MessagePump erzeugt&quot;);
-
-        mActorManager = new ActorManager();
-        LOG_MESSAGE(Logger::CORE,&quot;Aktormanager erzeugt&quot;);
-
-        mSoundManager = new SoundManager();
-        GameLoop::getSingleton().addTask(mSoundManager, GameLoop::TG_SOUND);
-        LOG_MESSAGE(Logger::CORE,&quot;SoundManager erzeugt&quot;);
-
-        initializeResources();
-
-        // Set default mipmap level (NB some APIs ignore this)
-        ///@todo: In Config-Datei verlagern
-        TextureManager::getSingleton().setDefaultNumMipmaps(5);
-        MaterialManager::getSingleton().setDefaultTextureFiltering(TFO_TRILINEAR);
-        MaterialManager::getSingleton().setDefaultAnisotropy(
-            ConfigurationManager::getSingleton().getIntSetting(
-                &quot;Video&quot;, &quot;Max Anisotropy&quot;));
-
-
-        mWorld = new DotSceneOctreeWorld();
-        mActorManager-&gt;setWorld(mWorld);
-
-        mPhysicsManager = new PhysicsManager();
-        GameLoop::getSingleton().addTask(mPhysicsManager, GameLoop::TG_PHYSICS);
-        LOG_MESSAGE(Logger::CORE,&quot;PhysicsManager erzeugt&quot;);
-
-        mAnimationManager = new AnimationManager();
-        GameLoop::getSingleton().addTask(mAnimationManager, GameLoop::TG_GRAPHICS);
-        LOG_MESSAGE(Logger::CORE,&quot;AnimationManager erzeugt&quot;);
-
-        mGameEventManager = new GameEventManager();
-        GameLoop::getSingleton().addTask(mGameEventManager, GameLoop::TG_LOGIC);
-        LOG_MESSAGE(Logger::CORE,&quot;GameEventManager erzeugt&quot;);
-
-        mDebugVisualsManager = new DebugVisualsManager();
-        GameLoop::getSingleton().addTask(mDebugVisualsManager, GameLoop::TG_GRAPHICS);
-        LOG_MESSAGE(Logger::CORE,&quot;DebugVisualsManager erzeugt&quot;);
-
-        mJobScheduler = new JobScheduler();
-        GameLoop::getSingleton().addTask(mJobScheduler, GameLoop::TG_GRAPHICS);
-        LOG_MESSAGE(Logger::CORE,&quot;JobScheduler erzeugt&quot;);
-
-		mZoneManager = new ZoneManager();
-        GameLoop::getSingleton().addTask(mZoneManager, GameLoop::TG_LOGIC);
-        LOG_MESSAGE(Logger::CORE,&quot;ZoneManager erzeugt&quot;);
-
-		new meshmagick::OgreEnvironment();
-		meshmagick::OgreEnvironment::getSingleton().initialize(false, Logger::getSingleton()._getLog());
-
-        return true;
-    }
-
-    void CoreSubsystem::initializeResources()
-    {
-        mXmlResourceManager = new XmlResourceManager();
-
-        // Fuer Configs die keinem Typ zugeordnet sind,
-        // und die per kompletten Verezeichnis erfragt werden
-        ResourceGroupManager::getSingleton().addResourceLocation(
-            ConfigurationManager::getSingleton().
-                getModulesRootDirectory(),
-            &quot;FileSystem&quot;,
-            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
-
-
-        // Initialise the modules
-        Ogre::StringVector modulesList = ConfigurationManager::getSingleton().getModuleList();
-
-        for (size_t i = 0; i &lt; modulesList.size(); i++)
-        {
-            mRubyInterpreter-&gt;executeFile(ContentModule::getInitFile(modulesList[i]));
-
-            ContentModule* module = getModule(modulesList[i]);
-
-            if (module == NULL)
-            {
-                Throw(rl::RuntimeException,
-                      ContentModule::getInitFile(modulesList[i]) + &quot; did not register module '&quot; + modulesList[i] + &quot;'&quot;);
-            }
-            //else
-            //{
-            //    if (module-&gt;isCommon())
-            //    {
-            //        module-&gt;initializeTextures();
-            //        module-&gt;initialize();
-            //    }
-            //}
-        }
-    }
-
-    ContentModule* CoreSubsystem::getModule(const Ogre::String&amp; moduleId) const
-    {
-        ModuleMap::const_iterator moduleIt = mModules.find(moduleId);
-
-        if (moduleIt != mModules.end())
-        {
-            return (*moduleIt).second;
-        }
-        else
-        {
-            return NULL;
-        }
-    }
-
-    void CoreSubsystem::registerModule(ContentModule* module)
-    {
-        mModules[module-&gt;getId()] = module;
-    }
-
-    void CoreSubsystem::updateDefaultScheme()
-    {
-        int numTu = mOgreRoot-&gt;getRenderSystem()-&gt;getCapabilities()-&gt;getNumTextureUnits();
-
-        Ogre::String tuScheme;
-
-        if (numTu &gt;= 6)
-            tuScheme = &quot;tu6&quot;;
-        else if (numTu &gt;= 2)
-            tuScheme = &quot;tu2&quot;;
-        else
-            tuScheme = &quot;tu1&quot;;
-
-        LOG_MESSAGE(Logger::CORE,
-            &quot;Found &quot; + Ogre::StringConverter::toString(numTu) + &quot; Texture Units, using &quot;+
-            &quot;alphablending scheme &quot; + tuScheme);
-
-        for (ResourceManager::ResourceMapIterator itMat =
-            MaterialManager::getSingleton().getResourceIterator();
-            itMat.hasMoreElements();)
-        {
-            MaterialPtr mat = itMat.getNext();
-            for (Material::TechniqueIterator itTech =
-                mat-&gt;getTechniqueIterator();
-                itTech.hasMoreElements();)
-            {
-                Technique* tech = itTech.getNext();
-                if (tech-&gt;getSchemeName() == tuScheme)
-                {
-                    tech-&gt;setSchemeName(MaterialManager::DEFAULT_SCHEME_NAME);
-                    mDefaultTechniques.push_back(tech);
-                }
-                else if (tech-&gt;getSchemeName() == MaterialManager::DEFAULT_SCHEME_NAME)
-                {
-                    mDefaultTechniques.push_back(tech);
-                }
-            }
-        }
-    }
-
-    void CoreSubsystem::setScheme(const Ogre::String&amp; schemeName)
-    {
-        if (schemeName != MaterialManager::getSingleton().getActiveScheme())
-        {
-            /*for (std::vector&lt;Technique*&gt;::iterator iter = mDefaultTechniques.begin();
-                iter != mDefaultTechniques.end(); ++iter)
-            {
-                Technique* cur = *iter;
-                cur-&gt;setSchemeName(schemeName);
-            }*/
-
-            MaterialManager::getSingleton().setActiveScheme(schemeName);
-        }
-    }
-
-    void CoreSubsystem::startAdventureModule(ContentModule* module)
-    {
-        if (mActiveAdventureModule != NULL)
-        {
-            mActiveAdventureModule-&gt;unload();
-        }
-
-        //mCoreEventCaster.dispatchEvent(new DataLoadedEvent(0.0));
-
-        updateDefaultScheme();
-        loadModule(module);
-        mActiveAdventureModule = module;
-
-        //mCoreEventCaster.dispatchEvent(new DataLoadedEvent(100.0));
-        
-        module-&gt;start();
-    }
-
-    void CoreSubsystem::loadModule(ContentModule* module)
-    {
-        if (module-&gt;getMinimumEngineVersion() &gt; getEngineBuildNumber())
-        {
-            Throw(
-                rl::RuntimeException,
-                &quot;Module &quot;
-                + Ogre::String(module-&gt;getName().c_str())
-                + &quot; needs engine &gt;=&quot;
-                + StringConverter::toString(module-&gt;getMinimumEngineVersion())
-                + &quot; but engine is &quot;
-                + StringConverter::toString(getEngineBuildNumber()));
-        }
-
-        StringVector deps = module-&gt;getDependencies();
-        for (StringVector::const_iterator depsIt = deps.begin(); depsIt != deps.end(); depsIt++)
-        {
-            Ogre::String depName = *depsIt;
-            ModuleMap::iterator modIt = mModules.find(depName);
-            if (modIt == mModules.end())
-            {
-                Throw(
-                    rl::RuntimeException,
-                    &quot;Depedency Module &quot; + depName
-                    + &quot; needed by &quot; + Ogre::String(module-&gt;getName().c_str())
-                    + &quot; not found.&quot;);
-            }
-
-            ContentModule* depMod = (*modIt).second;
-
-            if (!depMod-&gt;isLoaded())
-            {
-                loadModule(depMod);
-            }
-        }
-
-        LOG_MESSAGE(
-            Logger::CORE,
-            &quot;Start initializing module &quot; + module-&gt;getName());
-        module-&gt;initializeTextures();
-        module-&gt;initialize();
-
-        ResourceGroupManager::getSingleton().initialiseResourceGroup(module-&gt;getId());
-        module-&gt;precreateMeshes();
-
-        if (module-&gt;isCommon())
-        {
-            module-&gt;start();
-        }
-
-        LOG_MESSAGE(
-            Logger::CORE,
-            &quot;Module &quot; + module-&gt;getName() + &quot; initialized.&quot;);
-    }
-
-    void CoreSubsystem::setDefaultActiveModule(const Ogre::String&amp; module)
-    {
-        mDefaultActiveModule = module;
-    }
-
-    const Ogre::String&amp; CoreSubsystem::getDefaultActiveModule() const
-    {
-        return mDefaultActiveModule;
-    }
-
-    World* CoreSubsystem::getWorld()
-    {
-        return mWorld;
-    }
-
-    const Ogre::String CoreSubsystem::getEngineVersionString() const
-    {
-        static Ogre::String version = &quot;0.3.0&quot;;
-        return version;
-    }
-
-    const Ogre::String CoreSubsystem::getEngineVersionName() const
-    {
-        static Ogre::String version = &quot;Internal Build&quot;;
-        return version;
-    }
-
-    long CoreSubsystem::getEngineBuildNumber() const
-    {
-        static const Ogre::String sMonths[] =
-        {&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;,
-         &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;};
-
-        Ogre::String dateStr = Ogre::String(__DATE__);
-        Ogre::String monthStr = dateStr.substr(0,3);
-        int day = Ogre::StringConverter::parseInt(dateStr.substr(4,2));
-        int year = Ogre::StringConverter::parseInt(dateStr.substr(7,4));
-        int month = 0;
-
-        while( month &lt; 12 &amp;&amp; monthStr.compare(sMonths[month]) != 0 )
-            month++;
-
-        return /* Jahr */          year * 100000 +
-               /* Monat */         (month+1) * 1000 +
-               /* Tag */           day * 10 +
-               /* Sub-Version */   0;
-    }
-
-    RubyInterpreter* CoreSubsystem::getRubyInterpreter()
-    {
-        return mRubyInterpreter;
-    }
-
-    void CoreSubsystem::makeScreenshot( const Ogre::String&amp; sName )
-    {
-        mRenderWindow-&gt;writeContentsToTimestampedFile(sName, &quot;.png&quot;);
-    }
-
-    ContentModule* CoreSubsystem::getActiveAdventureModule() const
-    {
-        return mActiveAdventureModule;
-    }
-
-    const ModuleMap&amp; CoreSubsystem::getAllModules() const
-    {
-        return mModules;
-    }
-
-    void CoreSubsystem::loadMap(const Ogre::String type, const Ogre::String filename,
-        const Ogre::String module)
-    {
-        mWorld-&gt;loadScene(filename, module);
-    }
-
-    void CoreSubsystem::loadPlugins()
-    {
-        mSoundManager-&gt;applySettings(rl::ConfigurationManager::getSingleton().getSettings(&quot;Sound&quot;));
-        LOG_MESSAGE(Logger::CORE, &quot;Soundeinstellungen geladen&quot;);
-    }
-
-    void CoreSubsystem::unloadPlugins()
-    {
-        mSoundManager-&gt;unloadAllDrivers();
-        LOG_MESSAGE(Logger::CORE, &quot;Soundtreiber entladen&quot;);
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;XmlResourceManager.h&quot;
+
+#include &quot;CoreSubsystem.h&quot;
+
+#include &lt;OgreEnvironment.h&gt;
+
+#include &quot;ActorManager.h&quot;
+#include &quot;AnimationManager.h&quot;
+#include &quot;ContentModule.h&quot;
+#include &quot;ConfigurationManager.h&quot;
+#include &quot;DebugVisualsManager.h&quot;
+#include &quot;DotSceneOctreeWorld.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;GameEventManager.h&quot;
+#include &quot;GameLoop.h&quot;
+#include &quot;JobScheduler.h&quot;
+#include &quot;Logger.h&quot;
+#include &quot;MessagePump.h&quot;
+#include &quot;PhysicsManager.h&quot;
+#include &quot;RubyInterpreter.h&quot;
+#include &quot;SaveGameManager.h&quot;
+#include &quot;ScriptWrapper.h&quot;
+#include &quot;SoundManager.h&quot;
+#include &quot;TimeSource.h&quot;
+#include &quot;ZoneManager.h&quot;
+
+#include &lt;ctime&gt;
+
+using namespace Ogre;
+
+template&lt;&gt; rl::CoreSubsystem* Singleton&lt;rl::CoreSubsystem&gt;::ms_Singleton = 0;
+
+namespace rl
+{
+    CoreSubsystem::CoreSubsystem()
+        : Singleton&lt;CoreSubsystem&gt;(),
+        mWorld(NULL),
+        mRubyInterpreter(NULL),
+        mModules(),
+        mActiveAdventureModule(NULL),
+        mDefaultActiveModule(&quot;&quot;),
+        mClockStartTime(),
+        mDeveloperMode(false),
+        mInitialized(false),
+        mDefaultTechniques(),
+        mOgreRoot(NULL),
+        mScriptWrapper(NULL),
+        mXmlResourceManager(NULL),
+        mPhysicsManager(NULL),
+        mMessagePump(NULL),
+        mGameLoop(NULL),
+        mAnimationManager(NULL),
+        mActorManager(NULL),
+        mGameEventManager(NULL),
+        mSoundManager(NULL),
+        mDebugVisualsManager(NULL),
+        mJobScheduler(NULL),
+        mRenderWindow(NULL),
+        mZoneManager(NULL)
+    {
+        initializeCoreSubsystem();
+    }
+
+    CoreSubsystem::~CoreSubsystem()
+    {
+        delete meshmagick::OgreEnvironment::getSingletonPtr();
+        delete mWorld;
+        delete mZoneManager;
+        delete mGameEventManager;
+        delete mMessagePump;
+        delete mJobScheduler;
+        delete mAnimationManager;
+        delete mActorManager;
+        delete mPhysicsManager;
+        delete mScriptWrapper;
+        delete mDebugVisualsManager;
+        delete ConfigurationManager::getSingletonPtr();
+        delete mSoundManager;
+        mRenderWindow-&gt;destroy();
+        delete mOgreRoot;
+        delete mRubyInterpreter;
+        delete mTimeSourceManager;
+        delete mSaveGameManager;
+        delete mGameLoop;
+        //mXmlResourceManager-&gt;unloadAll();
+        //delete mXmlResourceManager;
+    }
+
+    void CoreSubsystem::startCore()
+    {
+        loadPlugins();
+
+        mInitialized = true;
+
+        if (mDefaultActiveModule == &quot;&quot;)
+        {
+            mDefaultActiveModule = &quot;intro&quot;; ///@fixme replace by last active
+        }
+
+
+        ContentModule* mod = getModule(mDefaultActiveModule);
+        if (mod == NULL)
+        {
+            Throw(rl::RuntimeException, &quot;Module &quot;+mDefaultActiveModule+&quot; not found&quot;);
+        }
+        else
+        {
+            startAdventureModule(mod);
+        }
+
+        mGameLoop-&gt;loop();
+
+        mWorld-&gt;clearScene();
+        unloadPlugins();
+
+        //mRubyInterpreter-&gt;finalizeInterpreter();
+    }
+
+    void CoreSubsystem::renderOneFrame()
+    {
+        mGameLoop-&gt;_executeOneRenderLoop();
+    }
+
+    void CoreSubsystem::setDeveloperMode(bool developerMode)
+    {
+        mDeveloperMode = developerMode;
+    }
+
+    bool CoreSubsystem::getDeveloperMode() const
+    {
+        return mDeveloperMode;
+    }
+
+    bool CoreSubsystem::isInitialized() const
+    {
+        return mInitialized;
+    }
+
+    Ogre::RenderWindow* CoreSubsystem::getRenderWindow() const
+    {
+        return mRenderWindow;
+    }
+
+	void CoreSubsystem::setPaused(bool paused)
+	{
+       // mAnimationManager-&gt;setPaused(paused);
+       // mPhysicsManager-&gt;setPaused(paused);
+        mTimeSourceManager-&gt;setPaused(paused);
+        mGameLoop-&gt;setPaused(paused);
+	}
+
+    void CoreSubsystem::setTimeFactor(const Ogre::Real &amp;factor)
+    {
+        mTimeSourceManager-&gt;setTimeFactor(factor);
+        mPhysicsManager-&gt;setTimeFactor(factor);
+        mGameLoop-&gt;setTimeFactor(factor);
+    }
+
+    bool CoreSubsystem::initializeCoreSubsystem()
+    {
+        // set default queryflags to zero
+        Ogre::MovableObject::setDefaultQueryFlags(0);
+        // By not specifying the first two parameters, OGRE will not try
+        // to load plugins.cfg and ogre.cfg
+        mOgreRoot = new Root(&quot;&quot;, &quot;&quot;, ConfigurationManager::getSingleton().getOgreLogFile());
+		LogManager::getSingleton().getDefaultLog()-&gt;setLogDetail(LL_BOREME);
+
+        // Load Ogre plugins
+        Ogre::StringVector pluginList = ConfigurationManager::getSingleton().getPluginList();
+        for (Ogre::StringVector::const_iterator it = pluginList.begin(); it &lt; pluginList.end(); it++)
+        {
+            mOgreRoot-&gt;loadPlugin(*it);
+        }
+
+        // Find out, what Renderer plugins are available
+        RenderSystemList* rsl = mOgreRoot-&gt;getAvailableRenderers();
+        RenderSystemList::iterator it;
+
+        for (it = rsl-&gt;begin(); it &lt; rsl-&gt;end(); it++)
+        {
+            if ((*it)-&gt;getName() == ConfigurationManager::getSingleton().getStringSetting(
+                &quot;Video&quot;, &quot;Render System&quot;))
+            {
+                // Select and initialise the render system
+                mOgreRoot-&gt;setRenderSystem(*it);
+                mOgreRoot-&gt;initialise(false, &quot;&quot;);
+            }
+        }
+
+        //Root::getSingleton().setFrameSmoothingPeriod(0.5f);
+
+        // Muss vor dem Laden der Ressourcen geschehen,
+        // weil es sonst sofort angewandt wird.
+        MeshManager::getSingleton().setBoundsPaddingFactor(0.0);
+
+        // EDIT:
+        LOG_MESSAGE(Logger::CORE,&quot;init&quot;);
+
+        std::stringstream name;
+        name &lt;&lt; &quot;Rastullahs Lockenpracht - &quot;;
+        name &lt;&lt; getEngineVersionString() &lt;&lt; &quot; &quot;;
+        name &lt;&lt; getEngineVersionName() &lt;&lt; &quot; [&quot;;
+        name &lt;&lt; getEngineBuildNumber() &lt;&lt; &quot;]&quot;;
+
+        // Get width and height of the RenderWindow from the &quot;Video Mode&quot; setting
+        Ogre::String VideoMode = ConfigurationManager::getSingleton().getStringSetting(
+            &quot;Video&quot;, &quot;Video Mode&quot;);
+        int temp = VideoMode.find(&quot;x&quot;);
+        int width = Ogre::StringConverter::parseInt(VideoMode.substr(0, temp));
+        int height = Ogre::StringConverter::parseInt(VideoMode.substr(temp + 1, VideoMode.size()));
+
+        mRenderWindow = mOgreRoot-&gt;createRenderWindow(
+            name.str(), width, height,
+            ConfigurationManager::getSingleton().getBoolSetting(
+                &quot;Video&quot;, &quot;Fullscreen&quot;),
+            ConfigurationManager::getSingleton().getVideoSettings());
+
+        if (!mRenderWindow)
+            return false;
+
+        mGameLoop = new GameLoop();
+        LOG_MESSAGE(Logger::CORE,&quot;GameLoopmanager erzeugt&quot;);
+
+        mSaveGameManager = new SaveGameManager();
+        LOG_MESSAGE(Logger::RULES, &quot;SaveGameManager erzeugt&quot;);
+		
+		mTimeSourceManager = new TimeSourceManager();
+        mTimeSourceManager-&gt;registerTimeSource(new RealTimeContinuous());
+        mTimeSourceManager-&gt;registerTimeSource(new RealTimeInterruptable());
+        LOG_MESSAGE(Logger::CORE,&quot;Time sources (realtime) created&quot;);
+
+        mScriptWrapper = new ScriptWrapper();
+        LOG_MESSAGE(Logger::CORE,&quot;Skriptwrapper erzeugt&quot;);
+        ///@todo: muss loeschbar werden.
+        mRubyInterpreter = new RubyInterpreter();
+        LOG_MESSAGE(Logger::CORE,&quot;RubyInterpreter erzeugt&quot;);
+        mRubyInterpreter-&gt;initializeInterpreter();
+        LOG_MESSAGE(Logger::CORE,&quot;RubyInterpreter initialisiert&quot;);
+
+        mMessagePump = new MessagePump();
+        GameLoop::getSingleton().addTask(mMessagePump, GameLoop::TG_LOGIC);
+        LOG_MESSAGE(Logger::CORE,&quot;MessagePump erzeugt&quot;);
+
+        mActorManager = new ActorManager();
+        LOG_MESSAGE(Logger::CORE,&quot;Aktormanager erzeugt&quot;);
+
+        mSoundManager = new SoundManager();
+        GameLoop::getSingleton().addTask(mSoundManager, GameLoop::TG_SOUND);
+        LOG_MESSAGE(Logger::CORE,&quot;SoundManager erzeugt&quot;);
+
+        initializeResources();
+
+        // Set default mipmap level (NB some APIs ignore this)
+        ///@todo: In Config-Datei verlagern
+        TextureManager::getSingleton().setDefaultNumMipmaps(5);
+        MaterialManager::getSingleton().setDefaultTextureFiltering(TFO_TRILINEAR);
+        MaterialManager::getSingleton().setDefaultAnisotropy(
+            ConfigurationManager::getSingleton().getIntSetting(
+                &quot;Video&quot;, &quot;Max Anisotropy&quot;));
+
+
+        mWorld = new DotSceneOctreeWorld();
+        mActorManager-&gt;setWorld(mWorld);
+
+        mPhysicsManager = new PhysicsManager();
+        GameLoop::getSingleton().addTask(mPhysicsManager, GameLoop::TG_PHYSICS);
+        LOG_MESSAGE(Logger::CORE,&quot;PhysicsManager erzeugt&quot;);
+
+        mAnimationManager = new AnimationManager();
+        GameLoop::getSingleton().addTask(mAnimationManager, GameLoop::TG_GRAPHICS);
+        LOG_MESSAGE(Logger::CORE,&quot;AnimationManager erzeugt&quot;);
+
+        mGameEventManager = new GameEventManager();
+        GameLoop::getSingleton().addTask(mGameEventManager, GameLoop::TG_LOGIC);
+        LOG_MESSAGE(Logger::CORE,&quot;GameEventManager erzeugt&quot;);
+
+        mDebugVisualsManager = new DebugVisualsManager();
+        GameLoop::getSingleton().addTask(mDebugVisualsManager, GameLoop::TG_GRAPHICS);
+        LOG_MESSAGE(Logger::CORE,&quot;DebugVisualsManager erzeugt&quot;);
+
+        mJobScheduler = new JobScheduler();
+        GameLoop::getSingleton().addTask(mJobScheduler, GameLoop::TG_GRAPHICS);
+        LOG_MESSAGE(Logger::CORE,&quot;JobScheduler erzeugt&quot;);
+
+		mZoneManager = new ZoneManager();
+        GameLoop::getSingleton().addTask(mZoneManager, GameLoop::TG_LOGIC);
+        LOG_MESSAGE(Logger::CORE,&quot;ZoneManager erzeugt&quot;);
+
+		new meshmagick::OgreEnvironment();
+		meshmagick::OgreEnvironment::getSingleton().initialize(false, Logger::getSingleton()._getLog());
+
+        return true;
+    }
+
+    void CoreSubsystem::initializeResources()
+    {
+        mXmlResourceManager = new XmlResourceManager();
+
+        // Fuer Configs die keinem Typ zugeordnet sind,
+        // und die per kompletten Verezeichnis erfragt werden
+        ResourceGroupManager::getSingleton().addResourceLocation(
+            ConfigurationManager::getSingleton().
+                getModulesRootDirectory(),
+            &quot;FileSystem&quot;,
+            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME);
+
+
+        // Initialise the modules
+        Ogre::StringVector modulesList = ConfigurationManager::getSingleton().getModuleList();
+
+        for (size_t i = 0; i &lt; modulesList.size(); i++)
+        {
+            mRubyInterpreter-&gt;executeFile(ContentModule::getInitFile(modulesList[i]));
+
+            ContentModule* module = getModule(modulesList[i]);
+
+            if (module == NULL)
+            {
+                Throw(rl::RuntimeException,
+                      ContentModule::getInitFile(modulesList[i]) + &quot; did not register module '&quot; + modulesList[i] + &quot;'&quot;);
+            }
+            //else
+            //{
+            //    if (module-&gt;isCommon())
+            //    {
+            //        module-&gt;initializeTextures();
+            //        module-&gt;initialize();
+            //    }
+            //}
+        }
+    }
+
+    ContentModule* CoreSubsystem::getModule(const Ogre::String&amp; moduleId) const
+    {
+        ModuleMap::const_iterator moduleIt = mModules.find(moduleId);
+
+        if (moduleIt != mModules.end())
+        {
+            return (*moduleIt).second;
+        }
+        else
+        {
+            return NULL;
+        }
+    }
+
+    void CoreSubsystem::registerModule(ContentModule* module)
+    {
+        mModules[module-&gt;getId()] = module;
+    }
+
+    void CoreSubsystem::updateDefaultScheme()
+    {
+        int numTu = mOgreRoot-&gt;getRenderSystem()-&gt;getCapabilities()-&gt;getNumTextureUnits();
+
+        Ogre::String tuScheme;
+
+        if (numTu &gt;= 6)
+            tuScheme = &quot;tu6&quot;;
+        else if (numTu &gt;= 2)
+            tuScheme = &quot;tu2&quot;;
+        else
+            tuScheme = &quot;tu1&quot;;
+
+        LOG_MESSAGE(Logger::CORE,
+            &quot;Found &quot; + Ogre::StringConverter::toString(numTu) + &quot; Texture Units, using &quot;+
+            &quot;alphablending scheme &quot; + tuScheme);
+
+        for (ResourceManager::ResourceMapIterator itMat =
+            MaterialManager::getSingleton().getResourceIterator();
+            itMat.hasMoreElements();)
+        {
+            MaterialPtr mat = itMat.getNext();
+            for (Material::TechniqueIterator itTech =
+                mat-&gt;getTechniqueIterator();
+                itTech.hasMoreElements();)
+            {
+                Technique* tech = itTech.getNext();
+                if (tech-&gt;getSchemeName() == tuScheme)
+                {
+                    tech-&gt;setSchemeName(MaterialManager::DEFAULT_SCHEME_NAME);
+                    mDefaultTechniques.push_back(tech);
+                }
+                else if (tech-&gt;getSchemeName() == MaterialManager::DEFAULT_SCHEME_NAME)
+                {
+                    mDefaultTechniques.push_back(tech);
+                }
+            }
+        }
+    }
+
+    void CoreSubsystem::setScheme(const Ogre::String&amp; schemeName)
+    {
+        if (schemeName != MaterialManager::getSingleton().getActiveScheme())
+        {
+            /*for (std::vector&lt;Technique*&gt;::iterator iter = mDefaultTechniques.begin();
+                iter != mDefaultTechniques.end(); ++iter)
+            {
+                Technique* cur = *iter;
+                cur-&gt;setSchemeName(schemeName);
+            }*/
+
+            MaterialManager::getSingleton().setActiveScheme(schemeName);
+        }
+    }
+
+    void CoreSubsystem::startAdventureModule(ContentModule* module)
+    {
+        if (mActiveAdventureModule != NULL)
+        {
+            mActiveAdventureModule-&gt;unload();
+        }
+
+        //mCoreEventCaster.dispatchEvent(new DataLoadedEvent(0.0));
+
+        updateDefaultScheme();
+        loadModule(module);
+        mActiveAdventureModule = module;
+
+        //mCoreEventCaster.dispatchEvent(new DataLoadedEvent(100.0));
+        
+        module-&gt;start();
+    }
+
+    void CoreSubsystem::loadModule(ContentModule* module)
+    {
+        if (module-&gt;getMinimumEngineVersion() &gt; getEngineBuildNumber())
+        {
+            Throw(
+                rl::RuntimeException,
+                &quot;Module &quot;
+                + Ogre::String(module-&gt;getName().c_str())
+                + &quot; needs engine &gt;=&quot;
+                + StringConverter::toString(module-&gt;getMinimumEngineVersion())
+                + &quot; but engine is &quot;
+                + StringConverter::toString(getEngineBuildNumber()));
+        }
+
+        StringVector deps = module-&gt;getDependencies();
+        for (StringVector::const_iterator depsIt = deps.begin(); depsIt != deps.end(); depsIt++)
+        {
+            Ogre::String depName = *depsIt;
+            ModuleMap::iterator modIt = mModules.find(depName);
+            if (modIt == mModules.end())
+            {
+                Throw(
+                    rl::RuntimeException,
+                    &quot;Depedency Module &quot; + depName
+                    + &quot; needed by &quot; + Ogre::String(module-&gt;getName().c_str())
+                    + &quot; not found.&quot;);
+            }
+
+            ContentModule* depMod = (*modIt).second;
+
+            if (!depMod-&gt;isLoaded())
+            {
+                loadModule(depMod);
+            }
+        }
+
+        LOG_MESSAGE(
+            Logger::CORE,
+            &quot;Start initializing module &quot; + module-&gt;getName());
+        module-&gt;initializeTextures();
+        module-&gt;initialize();
+
+        ResourceGroupManager::getSingleton().initialiseResourceGroup(module-&gt;getId());
+        module-&gt;precreateMeshes();
+
+        if (module-&gt;isCommon())
+        {
+            module-&gt;start();
+        }
+
+        LOG_MESSAGE(
+            Logger::CORE,
+            &quot;Module &quot; + module-&gt;getName() + &quot; initialized.&quot;);
+    }
+
+    void CoreSubsystem::setDefaultActiveModule(const Ogre::String&amp; module)
+    {
+        mDefaultActiveModule = module;
+    }
+
+    const Ogre::String&amp; CoreSubsystem::getDefaultActiveModule() const
+    {
+        return mDefaultActiveModule;
+    }
+
+    World* CoreSubsystem::getWorld()
+    {
+        return mWorld;
+    }
+
+    const Ogre::String CoreSubsystem::getEngineVersionString() const
+    {
+        static Ogre::String version = &quot;0.3.0&quot;;
+        return version;
+    }
+
+    const Ogre::String CoreSubsystem::getEngineVersionName() const
+    {
+        static Ogre::String version = &quot;Internal Build&quot;;
+        return version;
+    }
+
+    long CoreSubsystem::getEngineBuildNumber() const
+    {
+        static const Ogre::String sMonths[] =
+        {&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;,
+         &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;};
+
+        Ogre::String dateStr = Ogre::String(__DATE__);
+        Ogre::String monthStr = dateStr.substr(0,3);
+        int day = Ogre::StringConverter::parseInt(dateStr.substr(4,2));
+        int year = Ogre::StringConverter::parseInt(dateStr.substr(7,4));
+        int month = 0;
+
+        while( month &lt; 12 &amp;&amp; monthStr.compare(sMonths[month]) != 0 )
+            month++;
+
+        return /* Jahr */          year * 100000 +
+               /* Monat */         (month+1) * 1000 +
+               /* Tag */           day * 10 +
+               /* Sub-Version */   0;
+    }
+
+    RubyInterpreter* CoreSubsystem::getRubyInterpreter()
+    {
+        return mRubyInterpreter;
+    }
+
+    void CoreSubsystem::makeScreenshot( const Ogre::String&amp; sName )
+    {
+        mRenderWindow-&gt;writeContentsToTimestampedFile(sName, &quot;.png&quot;);
+    }
+
+    ContentModule* CoreSubsystem::getActiveAdventureModule() const
+    {
+        return mActiveAdventureModule;
+    }
+
+    const ModuleMap&amp; CoreSubsystem::getAllModules() const
+    {
+        return mModules;
+    }
+
+    void CoreSubsystem::loadMap(const Ogre::String type, const Ogre::String filename,
+        const Ogre::String module)
+    {
+        mWorld-&gt;loadScene(filename, module);
+    }
+
+    void CoreSubsystem::loadPlugins()
+    {
+        mSoundManager-&gt;applySettings(rl::ConfigurationManager::getSingleton().getSettings(&quot;Sound&quot;));
+        LOG_MESSAGE(Logger::CORE, &quot;Soundeinstellungen geladen&quot;);
+    }
+
+    void CoreSubsystem::unloadPlugins()
+    {
+        mSoundManager-&gt;unloadAllDrivers();
+        LOG_MESSAGE(Logger::CORE, &quot;Soundtreiber entladen&quot;);
+    }
+}

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/DotSceneLoader.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneLoader.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/DotSceneLoader.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -772,9 +772,6 @@
               return;
         }
 
-        if (parentNode-&gt;getScale() != Vector3::UNIT_SCALE)
-            newEnt-&gt;setNormaliseNormals(true);
-
         parentNode-&gt;attachObject(newEnt);
 
         LOG_DEBUG(Logger::CORE, &quot; Entity '&quot;+meshName+&quot;' mit dem Namen '&quot;+entName+&quot;' in den Knoten '&quot;+parentNode-&gt;getName()+&quot;' eingef&#252;gt.&quot;);

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/ListenerMovable.cpp
===================================================================
--- rl/trunk/engine/core/src/ListenerMovable.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/ListenerMovable.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -103,9 +103,15 @@
  */
 void ListenerMovable::_updateRenderQueue(RenderQueue *queue)
 {
-    // BListenerrauchen wir nicht
+    // Brauchen wir nicht
 }
 
+void ListenerMovable::visitRenderables(Renderable::Visitor* visitor, 
+	bool debugRenderables)
+{
+    // Brauchen wir nicht
+}
+
 /**
  * @return Die aktuelle Richtung der Soundquelle (at-Vektor)
  * @author JoSch

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/MovableText.cpp
===================================================================
--- rl/trunk/engine/core/src/MovableText.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/MovableText.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -554,4 +554,10 @@
     {
         return mAlignment;
     }
+    /************************************************************************/
+	void MovableText::visitRenderables(Renderable::Visitor* visitor, 
+		bool debugRenderables)
+	{
+		visitor-&gt;visit(this, 0, false);
+	}
 }

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/PhysicalThing.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -130,8 +130,8 @@
 		if (mBody &amp;&amp; mActor)
 		{
 			mBody-&gt;setPositionOrientation(
-				mActor-&gt;_getSceneNode()-&gt;getWorldPosition(),
-				mActor-&gt;_getSceneNode()-&gt;getWorldOrientation());
+				mActor-&gt;_getSceneNode()-&gt;_getDerivedPosition(),
+				mActor-&gt;_getSceneNode()-&gt;_getDerivedOrientation());
 			mActor-&gt;_update(Actor::UF_ALL &amp; ~Actor::UF_PHYSICAL_THING);
 		}
     }

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/PhysicsManager.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -315,8 +315,8 @@
 
 
             body-&gt;attachToNode(node);
-            body-&gt;setPositionOrientation(node-&gt;getWorldPosition(),
-                node-&gt;getWorldOrientation());
+            body-&gt;setPositionOrientation(node-&gt;_getDerivedPosition(),
+                node-&gt;_getDerivedOrientation());
             body-&gt;setMaterialGroupID(getMaterialID(&quot;level&quot;));
 
 			mLevelBodiesQuadTree.add(body);

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/Sound.cpp
===================================================================
--- rl/trunk/engine/core/src/Sound.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/Sound.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -125,6 +125,12 @@
     // Brauchen wir nicht
 }
 
+void Sound::visitRenderables(Renderable::Visitor* visitor, 
+	bool debugRenderables)
+{
+    // Brauchen wir nicht
+}
+
 void Sound::setRolloffStartDistance(const Ogre::Real&amp; distance)
 {
 	mRolloffStartDistance = distance;

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/SoundResource.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundResource.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/SoundResource.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -88,7 +88,7 @@
  * @author JoSch
  * @date 03-14-2005
  */
-int SoundResource::getSize() const
+size_t SoundResource::getSize() const
 {
     return calculateSize();
 }

Modified: rl/branches/ogre16/rl/trunk/engine/core/src/SoundStitching.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundStitching.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/core/src/SoundStitching.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -126,6 +126,12 @@
     // Brauchen wir nicht
 }
 
+void SoundStitching::visitRenderables(Renderable::Visitor* visitor, 
+	bool debugRenderables)
+{
+    // Brauchen wir nicht
+}
+
 void SoundStitching::setRolloffStartDistance(const Ogre::Real&amp; distance)
 {
 	mRolloffStartDistance = distance;

Modified: rl/branches/ogre16/rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/rules/src/CreatureController.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -85,10 +85,12 @@
         virtual bool isDirectionPossible(Ogre::Vector3 &amp;direction) const
 	{
 	    direction = Vector3::ZERO;
+        return false;
 	}
         virtual bool isRotationPossible(Ogre::Vector3 &amp;rotation) const
 	{
 	    rotation = Vector3::ZERO;
+        return false;
 	}
     protected:
         Creature::AnimationSpeedPair mAnim;

Deleted: rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.swig	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.head.swig	2008-05-22 18:21:17 UTC (rev 4381)
@@ -1,57 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-%{
-//----------- Includes - Rules -----------
-#include &quot;FixRubyHeaders.h&quot;
-#include &quot;RulesPrerequisites.h&quot;
-
-#include &quot;Action.h&quot;
-#include &quot;ActionManager.h&quot;
-#include &quot;Armor.h&quot;
-#include &quot;Container.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;CreatureController.h&quot;
-#include &quot;CreatureControllerManager.h&quot;
-#include &quot;Date.h&quot;
-#include &quot;DsaManager.h&quot;
-#include &quot;Effect.h&quot;
-#include &quot;EffectFactory.h&quot;
-#include &quot;EigenschaftenStateSet.h&quot;
-#include &quot;GameEventLog.h&quot;
-#include &quot;GameObject.h&quot;
-#include &quot;GameObjectManager.h&quot;
-#include &quot;GlobalProperties.h&quot;
-#include &quot;Inventory.h&quot;
-#include &quot;Item.h&quot;
-#include &quot;ObjectStateChangeEventSource.h&quot;
-#include &quot;ObjectStateChangeEvent.h&quot;
-#include &quot;ObjectStateChangeListener.h&quot;
-#include &quot;Quest.h&quot;
-#include &quot;QuestBook.h&quot;
-#include &quot;QuestEvent.h&quot;
-#include &quot;QuestListener.h&quot;
-#include &quot;RulesConstants.h&quot;
-#include &quot;RulesSubsystem.h&quot;
-#include &quot;Selector.h&quot;
-#include &quot;SonderfertigkeitenStateSet.h&quot;
-#include &quot;StateSet.h&quot;
-#include &quot;Talent.h&quot;
-#include &quot;TalentStateSet.h&quot;
-#include &quot;Tripel.h&quot;
-#include &quot;WaitJob.h&quot;
-#include &quot;Weapon.h&quot;
-%}

Copied: rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.head.swig (from rev 4378, rl/trunk/engine/script/swig/RlRules.head.swig)

Deleted: rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.swig	2008-05-22 18:21:17 UTC (rev 4381)
@@ -1,938 +0,0 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-//%template(GameObjectVector) std::vector&lt; rl::GameObject* &gt;;
-
-namespace rl {
-
-    // Before first use of GameObject or subclasses!
-    %apply SWIGTYPE *DYNAMIC { rl::GameObject * };
-
-                    
-   template&lt;typename T&gt;
-   class Tripel {
-   public:
-      T first;
-      T second;
-      T third;
-
-      Tripel();      
-      Tripel(const T&amp; t1, const T&amp; t2, const T&amp; t3);
-      Tripel(const Tripel&amp; rhs);
-
-      //Tripel&amp; operator=(const Tripel&amp; rhs);
-      bool operator==(const Tripel&amp; rhs);
-      bool operator&lt;(const Tripel&amp; rhs);     
-   };
-    
-    class Date {
-    public:
-        static const RL_LONGLONG ONE_SECOND = 1000ULL;
-        static const RL_LONGLONG ONE_MINUTE = 60000ULL;
-        static const RL_LONGLONG ONE_HOUR = 3600000ULL;
-        static const RL_LONGLONG ONE_DAY = 86400000ULL;
-        static const RL_LONGLONG ONE_WEEK = 604800000ULL;
-        static const RL_LONGLONG ONE_MONTH = 2592000000ULL;
-        static const RL_LONGLONG ONE_YEAR = 31536000000ULL;
-        static const RL_LONGLONG ONE_KAMPFRUNDE = 2 * ONE_SECOND;
-        static const RL_LONGLONG ONE_SPIELRUNDE = 5 * ONE_MINUTE;
-
-        Date();
-        Date(RL_LONGLONG timestamp);
-        Date(const Date&amp; rhs);
-      
-        bool operator==(const Date&amp; rhs);
-        bool operator&lt;(const Date&amp; rhs);
-        bool operator&lt;=(const Date&amp; rhs);
-        bool operator&gt;=(const Date&amp; rhs);
-        bool operator&gt;(const Date&amp; rhs);
-
-        Date operator+(const RL_LONGLONG&amp; rhs);
-        Date operator-(const RL_LONGLONG&amp; rhs);
-        Date operator*(const Ogre::Real&amp; rhs);
-        Date operator/(const Ogre::Real&amp; rhs);
-        RL_LONGLONG operator-(const Date&amp; rhs);
-      
-        RL_LONGLONG getTimestamp();
-
-        int getTimeFraction();
-        int getYear();
-        int getMonth();
-        rl::CeGuiString getMonthName();
-        int getDayOfYear();
-        int getDayOfMonth();
-        int getDayOfWeek();
-        rl::CeGuiString getDayOfWeekName();
-        int getHour();
-        int getMinute();
-        int getSecond();
-        int getMilliSecond();
-      
-        rl::CeGuiString toString();
-    };
-   
-    Date operator+(const RL_LONGLONG&amp;, const Date&amp;);
-    Date operator-(const RL_LONGLONG&amp;, const Date&amp;);
-
-    class RulesSubsystem 
-    {
-        public:
-             static rl::RulesSubsystem&amp; getSingleton();
-             rl::QuestBook* getQuestBook();
-             void resetQuestBook();
-    };
-  
-    class DsaManager {
-    public:
-        RL_LONGLONG getTimestamp();
-        Date getCurrentDate();
-        void setCurrentDate(const Date&amp; date);
-        
-        int rollD20();
-        Tripel&lt;int&gt; roll3D20();
-        int rollD6();
-        int roll(int d6, int d20);
-      
-        static DsaManager&amp; getSingleton();
-        rl::Talent* getTalent(const rl::CeGuiString name) const;
-        rl::Creature* getCreature(const int id) const;
-    };
-    
-    %feature(&quot;director&quot;) GameObjectFactory; 
-    class GameObjectFactory
-    {
-    public:
-        virtual rl::GameObject* createRubyGameObject(const Ogre::String&amp; classname, unsigned int id) = 0;
-        GameObjectFactory();
-        virtual ~GameObjectFactory();
-    };
-
-    class GameObjectManager
-    {
-    public:
-        static rl::GameObjectManager&amp; getSingleton();
-        rl::GameObject* createGameObject(const Ogre::String&amp; classId, unsigned int id = 0);
-        rl::GameObject* getGameObject(unsigned int id) const;
-        void setGameObjectFactory(rl::GameObjectFactory* gof);
-
-    private:
-        GameObjectManager();
-    };
-
-	enum GameEventType
-	{
-		GET_DEFAULT,
-		GET_COMBAT,
-		GET_DIALOG,
-		GET_QUEST
-	};
-	
-    class GameEventLog
-    {
-    public:
-        static rl::GameEventLog&amp; getSingleton();
-		void logEvent(const Ogre::String&amp; eventString, GameEventType type);
-
-    private:
-        GameEventLog();
-    };
-    
-    class GlobalProperties 
-    {
-    public:
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        bool hasProperty(const Ogre::String&amp; key) const;
-        
-        static rl::GlobalProperties&amp; getSingleton();
-    private:
-        GlobalProperties();
-    };
-
-    %feature(&quot;director&quot;) QuestListener; 
-    class QuestListener
-    {
-    public:
-        virtual ~QuestListener();
-        
-        virtual void questStateChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questPartsDoneChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questKnownChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questSubquestAdded(rl::QuestEvent* anEvent) = 0;
-        virtual void journalEntryAdded(rl::JournalEvent* anEvent) = 0;
-        virtual void journalEntryDeleted(rl::JournalEvent* anEvent) = 0;
-    };
-
-    class JournalEntry
-    {
-    public:
-        JournalEntry(const rl::CeGuiString caption, const rl::CeGuiString text);
-        virtual ~JournalEntry();
-
-        rl::CeGuiString getCaption() const;
-
-        rl::CeGuiString getText() const;
-    };
-    
-    class Quest
-    {
-    public:
-        enum State
-        {
-            OPEN = 0,
-            ASSIGNED,
-            FAILED,
-            SUCCEEDED,
-            COMPLETED
-        };
-
-        Quest(const rl::CeGuiString id, const rl::CeGuiString name, const rl::CeGuiString description);
-        virtual ~Quest();
-
-        const rl::CeGuiString getId();
-        const rl::CeGuiString getName();
-        const rl::CeGuiString getDescription();
-        int getPartsToDo();
-        void setPartsToDo(int partsToDo);
-        int getPartsDone();
-        void setPartsDone(int partsDone);
-        void increasePartsDone(int parts = 1);
-        void decreasePartsDone(int parts = 1);
-
-        rl::Quest::State getState();
-        void setState(rl::Quest::State state);
-        bool isKnown();
-        void setKnown(bool known);
-
-        // QuestVector getSubquests();
-        void addSubquest(rl::Quest* quest); 
-    };   
-    
-    class QuestEvent
-    {
-    public:
-        rl::Quest* getQuest();
-    private:
-        QuestEvent( rl::QuestBook* src, int reason );
-    };
-    
-    class QuestBook
-    {
-    public:
-        rl::Quest* getQuest(const rl::CeGuiString id);
-        void addQuest(rl::Quest* quest);
-        
-        void addJournalEntry(rl::JournalEntry* entry);
-        void addJournalEntry(rl::CeGuiString caption, rl::CeGuiString text);
-        
-        void addQuestListener(rl::QuestListener* listener);
-        void removeQuestListener(rl::QuestListener* listener);
-    };
-    
-    class Talent
-    {
-    public:
-        typedef std::map&lt;const rl::CeGuiString,int&gt; AusweichTalente;
-        Talent(const rl::CeGuiString name,
-               const rl::CeGuiString description,
-               const Tripel&lt;rl::CeGuiString&gt;&amp; eigenschaften,
-               int ebe,
-               int gruppe,
-               const rl::CeGuiString art,
-               const AusweichTalente &amp;ausweichTalente);
-
-        bool operator==(const Talent&amp; rhs) const;
-        bool operator&lt;(const Talent&amp; rhs) const;
-        rl::CeGuiString getName() const;
-        rl::CeGuiString getDescription() const;
-        int getEbe() const;
-
-        /// Berechnet effektive Behinderung bei gegebener Behinderung;
-        int calculateEbe(int be) const;
-        Tripel&lt;rl::CeGuiString&gt; getEigenschaften() const;
-    };
-
-    class ActionGroup
-    {
-    public:
-        ActionGroup(rl::CeGuiString name, ActionGroup* parent = NULL);
-        ~ActionGroup();
-    
-        const rl::CeGuiString getName() const;
-    };
-    
-    %feature(&quot;director&quot;) Action;   
-    class Action
-    {
-    public:
-        static const int ACT_NORMAL = 1&lt;&lt;0;
-        static const int ACT_INVIS_DESC = 1&lt;&lt;1;
-        static const int ACT_DISABLED = 1&lt;&lt;2;
-        static const int ACT_NEEDS_TALENT = 1&lt;&lt;8;
-
-        static const int TC_NO_TARGET = 0;
-        static const int TC_GAMEOBJECT = 1;
-        static const int TC_CREATURE = 2;
-        static const int TC_ITEM = 3;
-        static const int TC_POINT = 4;
-        static const int TC_RADIUS = 5;
-        static const int TC_POINT_AND_RADIUS = 6;
-    
-        Action(const rl::CeGuiString name, const rl::CeGuiString description);
-        virtual ~Action();
-
-        virtual const rl::CeGuiString getName() const;
-        //virtual const rl::CeGuiString getClassName() const;
-        virtual const rl::CeGuiString getDescription() const;
-        virtual int getTargetClass() const;
-        virtual void doAction(rl::GameObject *object, rl::Creature *actor,
-            rl::GameObject *target);
-        virtual bool canDo(rl::GameObject* object, rl::Creature* actor) const;
-            
-        void setGroup(rl::ActionGroup* group);
-        rl::ActionGroup* getGroup() const;
-    };
-    
-    %feature(&quot;director&quot;) ObjectStateChangeListener;      
-    class ObjectStateChangeListener      
-    {      
-    public:      
-        virtual ~ObjectStateChangeListener();      
-               
-        virtual void objectStateChanged(rl::ObjectStateChangeEvent *anEvent) = 0;      
-    };
-              
-               
-    class ObjectStateChangeEventSource      
-    {      
-    public:      
-        ObjectStateChangeEventSource( );      
-               
-        void addObjectStateChangeListener( rl::ObjectStateChangeListener*  list );      
-        void removeObjectStateChangeListener( rl::ObjectStateChangeListener* list );      
-        bool hasListeners( ) const;      
-        rl::GameObject* getObject() const;
-        void fireObjectStateChangeEvent();      
-    };      
-               
-    class ObjectStateChangeEvent      
-    {      
-    public:      
-        ObjectStateChangeEvent( rl::ObjectStateChangeEventSource* src );      
-        rl::GameObject* getProvokingObject() const;      
-        rl::ObjectStateChangeEventSource* getSource() const;      
-    };
-            
-    enum GameObjectState
-    {
-        GOS_UNDEFINED = 0,
-        GOS_UNLOADED,
-        GOS_LOADED,
-        GOS_IN_POSSESSION,
-        GOS_IN_SCENE,
-        GOS_HELD,
-        GOS_READY
-    };
-    
-    class PropertyRecord
-    {
-    public:
-        PropertyRecord();
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-    };
-    
-    %constant unsigned long QUERYFLAG_GAMEOBJECT = rl::QUERYFLAG_GAMEOBJECT;
-    %constant unsigned long QUERYFLAG_CREATURE = rl::QUERYFLAG_CREATURE;
-    %constant unsigned long QUERYFLAG_ITEM = rl::QUERYFLAG_ITEM;
-    %constant unsigned long QUERYFLAG_CONTAINER = rl::QUERYFLAG_CONTAINER;
-    %constant unsigned long QUERYFLAG_WEAPON = rl::QUERYFLAG_WEAPON;
-    %constant unsigned long QUERYFLAG_ARMOR = rl::QUERYFLAG_ARMOR;
-    %constant unsigned long QUERYFLAG_PERSON = rl::QUERYFLAG_PERSON;
-    %constant unsigned long QUERYFLAG_PLAYER = rl::QUERYFLAG_PLAYER;
-    
-    %feature(&quot;director&quot;) GameObject;
-    class GameObject: public ObjectStateChangeEventSource
-    {
-    public:
-        GameObject(unsigned int id);
-        virtual ~GameObject();
-
-        virtual unsigned int getId();
-
-        virtual const rl::CeGuiString getName() const;
-        virtual void setName(rl::CeGuiString name);
-
-        const rl::CeGuiString getDescription() const;
-        virtual void setDescription(rl::CeGuiString description);   
-        
-        void setActor(rl::Actor* actor);
-        rl::Actor* getActor();
-
-        void addAction(rl::Action *action, int option = ACT_NORMAL);
-        void addActionInGroup(Action* action, ActionGroup* group, int option = ACT_NORMAL);
-        void removeAction(rl::Action *action);
-
-        const std::vector&lt;Action*&gt; getValidActions(rl::Creature *actor) const;        
-        void setPosition(const Ogre::Vector3&amp; position);
-        void setOrientation(const Ogre::Quaternion&amp; orientation);
-        const Ogre::Quaternion&amp; getOrientation() const;
-        const Ogre::Vector3&amp; getPosition() const;
-        
-        void setMeshfile(rl::CeGuiString meshfile);
-        
-        virtual Action* getDefaultAction(rl::Creature* actor) const;
-        
-        void doAction(
-            const rl::CeGuiString actionName, 
-            rl::Creature* actor,
-            rl::GameObject* target);
-        void doAction(
-            const rl::CeGuiString actionName);
-        void doAction(rl::Action* action, rl::Creature* actor,
-            rl::GameObject* target);
-            
-        void doDefaultAction(rl::Creature* actor, rl::GameObject* target);
-            
-        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
-        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
-        
-        bool isHighlightingEnabled();
-        void setHighlightingEnabled( bool highlightenabled );
-        
-        void addEffect(rl::Effect* effect);
-        void addEffectWithCheckTime(rl::Effect* effect, RL_LONGLONG time);
-        void addEffectWithCheckDate(rl::Effect* effect, RL_LONGLONG date);
-        void removeEffect(rl::Effect* effect);
-        
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void placeIntoScene();
-        void removeFromScene();
-        
-        rl::GameObjectState getState() const;
-        void setState(rl::GameObjectState state);
-        
-        unsigned long getQueryFlags() const;
-        void addQueryFlag(unsigned long queryflag);
-        void setQueryFlags(unsigned long queryflags);
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    class WaitJob : public rl::Job
-    {
-    public:
-        WaitJob(const rl::Date&amp; dsatime);
-        WaitJob(const Ogre::Real&amp; realtime);
-    };
-    
-    %feature(&quot;director&quot;) Item;
-    class Item : public rl::GameObject {
-    public:
-        enum ItemType{
-            ITEMTYPE_WEAPON     = 1 &lt;&lt; 0,
-            ITEMTYPE_SHIELD     = 1 &lt;&lt; 1,
-            ITEMTYPE_RING       = 1 &lt;&lt; 2,
-            ITEMTYPE_GLOVES     = 1 &lt;&lt; 3,
-            ITEMTYPE_BRACELET   = 1 &lt;&lt; 4,
-            ITEMTYPE_ARMOR      = 1 &lt;&lt; 5,
-            ITEMTYPE_CAPE       = 1 &lt;&lt; 6,
-            ITEMTYPE_BRACERS    = 1 &lt;&lt; 7,
-            ITEMTYPE_BACKPACK   = 1 &lt;&lt; 8,
-            ITEMTYPE_BELT       = 1 &lt;&lt; 9,
-            ITEMTYPE_NECKLACE   = 1 &lt;&lt; 10,
-            ITEMTYPE_HELMET     = 1 &lt;&lt; 11,
-            ITEMTYPE_TROUSERS   = 1 &lt;&lt; 12,
-            ITEMTYPE_SHINBONE   = 1 &lt;&lt; 13,
-            ITEMTYPE_BOOTS      = 1 &lt;&lt; 14,
-            ITEMTYPE_CLOTHES    = 1 &lt;&lt; 15,
-            ITEMTYPE_OTHER      = 1 &lt;&lt; 16,
-            ITEMTYPE_ALL_ITEMS  = ~(0)
-        };
-    
-        Item(unsigned int id);
-        virtual ~Item();
-        
-        virtual void placeIntoScene();
-        
-        void setItemType(rl::Item::ItemType itemType);
-        rl::Item::ItemType getItemType() const;
-        virtual void setState(rl::GameObjectState state);
-        virtual void removeOldState();
-
-        void setParentSlot(rl::Slot* slot);
-        rl::Slot* getParentSlot() const;
-
-        void setParentContainer(rl::Container* cont);
-        rl::Container* getParentContainer() const;
-
-        void setOwner(rl::GameObject* go);
-        rl::GameObject* getOwner() const;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        virtual bool isContainer();
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature(&quot;director&quot;) Weapon;
-    class Weapon : public rl::Item 
-    {
-    public:
-        enum Distanzklasse { DK_H=0, DK_N, DK_S, DK_P };
-
-        Weapon(unsigned int id);
-        virtual ~Weapon();
-                
-        void setTp(int d6, int d20, int mod);
-        const Tripel&lt;int&gt;&amp; getTp() const;
-        void setTpKk(int base, int step);
-        const std::pair&lt;int, int&gt;&amp; getTpKk() const;
-        void setBf(int newBf);
-        int getBf();
-        void setIni(int newIni);
-        int getIni();
-        void setWm(std::pair&lt;int, int&gt;&amp; newWm);
-        const std::pair&lt;int,int&gt;&amp; getWm() const;
-        void setDk(Weapon::Distanzklasse newDk);
-        Weapon::Distanzklasse getDk();
-        void setKampftechnik(const rl::CeGuiString newKampftechnik);
-        const rl::CeGuiString getKampftechnik() const;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature(&quot;director&quot;) Armor;
-    class Armor : public Item
-    {
-    public:
-    
-        static const CeGuiString Armor::PROPERTY_G_BE = &quot;g_be&quot;;
-        static const CeGuiString Armor::PROPERTY_G_RS = &quot;g_rs&quot;;
-        
-        Armor(unsigned int id);
-        virtual ~Armor();
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature(&quot;director&quot;) Container;
-    class Container : public Item
-    {
-    public:
-        Container(unsigned int id);
-        virtual ~Container();
-
-        Ogre::Real getCapacity() const;
-        void setCapacity(Ogre::Real capacity);
-        void setVolume(unsigned int x, unsigned int y);
-        Ogre::Real getContentWeight() const;
-        void addItem(rl::Item* item);
-        void removeItem(rl::Item* item);
-        rl::ItemSet getItems() const;
-        int getItemCount() const;
-        rl::Item* getItemAt(unsigned int x, unsigned int y);
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-
-    %feature(&quot;director&quot;) Effect;
-    class Effect
-    {
-    public:    
-        typedef unsigned long LifeState;
-        static const LifeState LS_NONE           = 1&lt;&lt;0;
-        static const LifeState LS_BLIND          = 1&lt;&lt;1;   ///&lt; The creature can't see anything.
-        static const LifeState LS_DEAD           = 1&lt;&lt;2;   ///&lt; The creature is dead.
-        static const LifeState LS_DEAF           = 1&lt;&lt;3;   ///&lt; The creature can't hear anything.
-        static const LifeState LS_PARALYZED      = 1&lt;&lt;4;   ///&lt; The creature can't move, turn, jump etc.
-        static const LifeState LS_INCAPACITATED  = 1&lt;&lt;5;   ///&lt; The creature can't fight anymore due to serious injuries. The creature can barely move.
-        static const LifeState LS_INVISIBLE      = 1&lt;&lt;6;   ///&lt; The creature can't be seen.
-        static const LifeState LS_INVULNERABLE   = 1&lt;&lt;7;   ///&lt; The creature is immune to any mundane attacks.
-        static const LifeState LS_PETRIFIED      = 1&lt;&lt;8;   ///&lt; The creature is coated with stone and has all the effects of paralyzation
-        static const LifeState LS_SILENCED       = 1&lt;&lt;9;   ///&lt; The creature doesn't make any noises.
-        static const LifeState LS_SLEEPING       = 1&lt;&lt;10;  ///&lt; The creature is asleep.
-        static const LifeState LS_UNCONSCIOUS    = 1&lt;&lt;11;  ///&lt; Like SLEEPING, but more difficult to wake.
-
-        // Meta stati
-        static const LifeState LS_IMMOBILE = LS_PARALYZED | LS_SLEEPING | LS_UNCONSCIOUS | LS_PETRIFIED | LS_DEAD;
-        static const LifeState LS_NO_COMBAT = LS_IMMOBILE | LS_INCAPACITATED;
-
-        typedef int ModType;
-        static const ModType MODTYPE_NONE         = 1 &lt;&lt; 0;
-        static const ModType MODTYPE_SUM      = 1 &lt;&lt; 1;   ///&lt; Modifies the actual value.
-        static const ModType MODTYPE_PROBENMOD    = 1 &lt;&lt; 2;   ///&lt; Modifies the test.
-        static const ModType MODTYPE_MULT     = 1 &lt;&lt; 3;   ///&lt; Will be multiplied on the value.
-        static const ModType MODTYPE_MAXWERTMOD   = 1 &lt;&lt; 4;   ///&lt; Modifies only the maximum of the value.
-
-        typedef unsigned long ModTag;
-        static const ModTag MODTAG_NONE           = 1 &lt;&lt; 0;
-        static const ModTag MODTAG_KRANKHEIT      = 1 &lt;&lt; 1;
-        static const ModTag MODTAG_RECALCULATE    = 1 &lt;&lt; 2;
-        static const ModTag MODTAG_REGENERATION_LE = 1 &lt;&lt; 3;
-        static const ModTag MODTAG_REGENERATION_AE = 1 &lt;&lt; 4;
-        static const ModTag MODTAG_REGENERATION_AU = 1 &lt;&lt; 5;
-        static const ModTag MODTAG_ERSCHOEPFUNGSSCHWELLE = 1 &lt;&lt; 6;
-    
-        enum Quantifier
-        {
-            QUANTIFIER_MULTIPLE,
-            QUANTIFIER_UNIQUE,
-            QUANTIFIER_UNIQUE_BUT_PROLONGABLE,
-            QUANTIFIER_UNIQUE_BUT_CUMULATIVE
-        };
-        
-      // other constants
-        static const int REMOVE = -1;
-        static const int PERMANENT = 0;
-
-
-        Effect(int stufe = 1);
-        virtual ~Effect();
-
-        const rl::CeGuiString getName() const;
-        void setName(rl::CeGuiString name);
-        const rl::CeGuiString getDescription() const;
-        void setDescription(rl::CeGuiString description);
-        Quantifier getQuantifier();
-        void setQuantifier(Quantifier quantifier);
-        virtual const int getStufe();
-        virtual void increaseStufe();
-        virtual void decreaseStufe();
-        virtual void enable();
-        virtual void disable();
-        virtual RL_LONGLONG timeCheck() = 0;
-
-        virtual LifeState getLifeState() const;
-        virtual int getMod(rl::CeGuiString target, ModType type, ModTag tag);
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-    };
-
-    class EffectFactory
-    {
-    public:
-        virtual rl::Effect* createEffect(const Ogre::String&amp; name, int stufe) = 0;
-    };
-
-    class EffectFactoryManager
-    {
-    public:
-        void setEffectFactory(rl::EffectFactory* factory);
-        static rl::EffectFactoryManager&amp; getSingleton();
-    };
-
-    enum SlotType
-    {
-        SLOT_BONE,
-        SLOT_SUBMESH,
-        SLOT_MATERIAL
-    };
-
-    class Inventory 
-    {
-    private:
-        Inventory(rl::Creature* owner);
-    public:
-        void addSlot(const rl::CeGuiString&amp; name, const Ogre::String&amp; meshpartname, int itemReadyMask, int itemHeldMask, SlotType type = SLOT_BONE);
-        rl::Item* getItem(const rl::CeGuiString&amp; slotName) const;
-        void hold(rl::Item* item, const rl::CeGuiString&amp; slot);
-        void ready(rl::Item* item, const rl::CeGuiString&amp; slot);
-        void dropItem(const rl::CeGuiString&amp; slotName);
-    };
-
-    %feature(&quot;director&quot;) Creature;
-    class Creature : public GameObject {
-    public:
-    
-    typedef Ogre::String Wert;
-        enum Alignment
-        {
-            ALIGNMENT_ALLY,    ///&lt; Creature fights with the player.
-            ALIGNMENT_NEUTRAL, ///&lt; Creature doesn't fight for either side.
-            ALIGNMENT_ENEMY    ///&lt; Creature fights against the player.
-        };
-
-        enum SfStatus
-        {
-            SFSTATUS_IN_TRAINING = 1,
-            SFSTATUS_OK,
-            SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Wird das ueberhaupt gebraucht?
-        };
-
-        // some targets
-        static const std::string Creature::ALL_EIGENSCHAFTEN = &quot;alle Eigenschaften&quot;;
-        static const std::string Creature::ALL_TALENTE = &quot;alle Talente&quot;;
-        static const Creature::Wert Creature::WERT_MOD_AE = &quot;ModAE&quot;;
-        static const Creature::Wert Creature::WERT_MOD_LE = &quot;ModLE&quot;;
-        static const Creature::Wert Creature::WERT_MOD_AU = &quot;ModAU&quot;;
-        static const Creature::Wert Creature::WERT_MOD_MR = &quot;ModMR&quot;;
-        static const Creature::Wert Creature::WERT_MOD_AT = &quot;ModAT&quot;;
-        static const Creature::Wert Creature::WERT_MOD_PA = &quot;ModPA&quot;;
-        static const Creature::Wert Creature::WERT_MOD_FK = &quot;ModFK&quot;;
-        static const Creature::Wert Creature::WERT_GS = &quot;GS&quot;;
-        static const Creature::Wert Creature::WERT_SOZIALSTATUS = &quot;SO&quot;;
-        static const Creature::Wert Creature::WERT_BE = &quot;BE&quot;;
-        static const Creature::Wert Creature::WERT_RS = &quot;RS&quot;;
-        static const Creature::Wert Creature::WERT_INI = &quot;INI&quot;;
-        static const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE =&quot;Kampfunf&#195;&#164;higkeitsschwelle&quot;; 
-        static const Creature::Wert Creature::WERT_REGENERATION = &quot;Regeneration&quot;;
-        
-        
-        Creature(unsigned int id);
-        virtual ~Creature();
-
-        virtual int getLe();
-        virtual void modifyLe(int mod, bool ignoreMax);
-        virtual void modifyAe(int mod);
-        virtual void modifyAu(int mod);
-        void setWert(Wert wertId, int value);
-        virtual int getWert(Wert wertId, bool getUnmodified = false);
-        
-        virtual int getEigenschaft(const rl::CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE);
-        virtual void setEigenschaft(const rl::CeGuiString eigenschaftName, int value);
-        virtual void modifyEigenschaft(const rl::CeGuiString eigenschaftName, int mod);
-
-        
-        void addTalent(const rl::CeGuiString talentName, int value=0);
-        bool hasTalent(const rl::CeGuiString talentName, bool checkAusweichTalente = true);
-        virtual int getTalent(const rl::CeGuiString talentName);
-        virtual void setTalent(const rl::CeGuiString talentName, int value);
-        virtual void modifyTalent(const rl::CeGuiString talentName, int mod);
-        virtual void addSe(const rl::CeGuiString talentName);
-        
-        void addVorteil(const rl::CeGuiString vorteilName, int value = 0);
-        void addNachteil(const rl::CeGuiString nachteilName, int value = 0);        
-        
-        void addKampftechnik(const rl::CeGuiString kampftechnikName, std::pair&lt;int,int&gt; value = make_pair(0,0));
-        virtual void addSf(const rl::CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
-        
-        virtual int doTalentprobe(const rl::CeGuiString talentName, int modifier);
-        virtual int doEigenschaftsprobe(const rl::CeGuiString eigenschaftName, int modifier);
-        
-        rl::Inventory* getInventory();
-        
-        void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
-        static const int LEDAMAGE_NORMAL = 0;
-        static const int LEDAMAGE_FIRE = 1;
-        static const int LEDAMAGE_WATER = 2;
-        static const int LEDAMAGE_DEMONIC = 4;
-        void damageAu(int aup, int damageType = AUDAMAGE_NORMAL);
-        static const int AUDAMAGE_NORMAL = 0;
-        static const int AUDAMAGE_HEAT = 1;
-        static const int AUDAMAGE_COLD = 2;
-        static const int AUDAMAGE_CHOKE = 4;
-        static const int AUDAMAGE_DROWN = 8;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-        virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-
-        void setAlignment(Alignment);
-        Alignment getAlignment() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-   };
-   
-    %feature(&quot;director&quot;) ActionManager;
-    class ActionManager
-    {
-    public:
-        void registerAction(rl::Action* action);
-        void unregisterAction(const rl::CeGuiString actionName);
-        rl::Action* getAction(const rl::CeGuiString actionName) const;
-
-        void registerInGameGlobalAction(rl::Action* action, rl::ActionGroup* group);
-    
-        static rl::ActionManager&amp; getSingleton();
-    };
-    
-    class CreatureController
-    {
-    public:
-        
-        typedef enum
-        {
-            // these movements can be used
-            MT_NONE,
-            MT_STEHEN,
-            MT_GEHEN,
-            MT_JOGGEN,
-            MT_LAUFEN,
-            MT_RENNEN,
-            MT_RUECKWAERTS_GEHEN,
-            MT_RUECKWAERTS_JOGGEN,
-            MT_SEITWAERTS_GEHEN,
-            MT_SCHLEICHEN,
-            MT_HOCHSPRUNG,
-            MT_WEITSPRUNG,
-            // these movements are only for internal purposes and should not be used directly
-            // instead use one of the movements above
-            MT_DREHEN
-        } MovementType;
-        
-        Creature *getCreature();
-        //bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
-        MovementType getMovementId() const;
-        Ogre::Vector3 getDirection() const;
-        Ogre::Vector3 getRotation() const;
-        Ogre::Vector3 getVelocity() const;
-        Ogre::Vector3 getOmega() const;
-        void setAnimation(const Ogre::String &amp;name, 
-                          Ogre::Real speed = 1, 
-                          unsigned int timesToPlay = 0, 
-                          const Ogre::String &amp;collisionName = &quot;&quot;);
-    protected:
-        CreatureController(Creature *character);
-        ~CreatureController();
-    };
-    
-    class CreatureControllerManager
-    {
-    public:
-        /// Returns a CreatureController that can be used to control given Creature.
-        /// There is only one controller per Creature at a given time.
-        /// If no such controller exists yet, it is created.
-        rl::CreatureController* getCreatureController(rl::Creature* creature);
-
-        /// This function detaches a controller attached to the given Creature, if any.
-        void detachController(rl::Creature* creature);
-
-        static rl::CreatureControllerManager&amp; getSingleton();
-    };
-
-	// Before first use of Selector or subclasses!
-    %apply SWIGTYPE *DYNAMIC { rl::Selector* };
-
-	class Selector
-    {
-    public:
-        Selector(unsigned long mask = 0xffffffff);
-        virtual void updateSelection();
-
-        void setSelectionMask(unsigned long mask);
-        unsigned long getSelectionMask() const;
-
-        GameObject* getFirstSelectedObject() const;
-		const std::vector&lt;GameObject*&gt;&amp; getAllSelectedObjects() const;
-		unsigned int getSelectionCount() const;
-
-		virtual void updatePrimitive() = 0;
-    };
-
-
-    /// A Selector that selects all unoccluded GameObject the ray hits.
-    class RaySelector : public Selector
-    {
-    public:
-        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
-        void setRay(const Ogre::Vector3&amp; start, const Ogre::Vector3&amp; end);
-		virtual void updatePrimitive();
-    };
-
-    /// Selects this GameObject within a half sphere pointing to -Z,
-    /// that has the smallest angle difference to the -Z-Axis.
-    class HalfSphereSelector : public Selector
-    {
-    public:
-        HalfSphereSelector(unsigned long mask = 0xffffffff);
-	    void setRadius(Ogre::Real radius);
-        void setPosition(const Ogre::Vector3&amp; pos);
-        void setOrientation(const Ogre::Quaternion&amp; ori);
-		virtual void updatePrimitive();
-	};
-
-} // Namespace
-
-%{
-static swig_type_info *Selector_dynamic_cast(void **ptr)
-{
-	rl::Selector *pSelector = static_cast&lt;rl::Selector*&gt;(*ptr);
-	rl::HalfSphereSelector *pHalfSphereSel = dynamic_cast&lt;rl::HalfSphereSelector*&gt;(pSelector);
-	if (pHalfSphereSel)
-	{
-		*ptr = pHalfSphereSel;
-		return SWIGTYPE_p_rl__HalfSphereSelector;
-	}
-	rl::RaySelector *pRaySel = dynamic_cast&lt;rl::RaySelector*&gt;(pSelector);
-	if (pRaySel)
-	{
-		*ptr = pRaySel;
-		return SWIGTYPE_p_rl__RaySelector;
-	}
-}
-	
-static swig_type_info *GameObject_dynamic_cast(void **ptr)
-{
-    rl::GameObject *pGameObject = static_cast&lt;rl::GameObject*&gt;(*ptr);
-
-    rl::Creature *pCreature=dynamic_cast&lt;rl::Creature*&gt;(pGameObject);
-    if (pCreature) {
-        *ptr=pCreature;
-        return SWIGTYPE_p_rl__Creature;
-    }
-    rl::Weapon *pWeapon=dynamic_cast&lt;rl::Weapon*&gt;(pGameObject);
-    if (pWeapon) {
-        *ptr=pWeapon;
-        return SWIGTYPE_p_rl__Weapon;
-    }
-    rl::Armor *pArmor=dynamic_cast&lt;rl::Armor*&gt;(pGameObject);
-    if (pArmor) {
-        *ptr=pArmor;
-        return SWIGTYPE_p_rl__Armor;
-    }
-    rl::Container *pContainer=dynamic_cast&lt;rl::Container*&gt;(pGameObject);
-    if (pContainer) {
-        *ptr=pContainer;
-        return SWIGTYPE_p_rl__Container;
-    }
-    rl::Item *pItem=dynamic_cast&lt;rl::Item*&gt;(pGameObject);
-    if (pItem) {
-        *ptr=pItem;
-        return SWIGTYPE_p_rl__Item;
-    }
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__GameObject, GameObject_dynamic_cast);
-

Copied: rl/branches/ogre16/rl/trunk/engine/script/swig/RlRules.swig (from rev 4378, rl/trunk/engine/script/swig/RlRules.swig)

Modified: rl/branches/ogre16/rl/trunk/engine/ui/src/DebugWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DebugWindow.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/ui/src/DebugWindow.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -185,8 +185,8 @@
 
             if( charObj != NULL )
             {
-                Ogre::Vector3 pos = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;getWorldPosition();
-                Ogre::Quaternion ori = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;getWorldOrientation();
+                Ogre::Vector3 pos = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;_getDerivedPosition();
+                Ogre::Quaternion ori = charObj-&gt;getMovableObject()-&gt;getParentNode()-&gt;_getDerivedOrientation();
 
                 textSt += &quot;\nPlayer Position [ &quot;
                     + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+&quot;, &quot;

Modified: rl/branches/ogre16/rl/trunk/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogControlState.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/ui/src/DialogControlState.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -220,8 +220,8 @@
 
         // Weltkoordinaten in lokale umwandeln
         mTargetCameraPosition =
-            -1*(mCameraActor-&gt;_getSceneNode()-&gt;getParentSceneNode()-&gt;getWorldOrientation().Inverse()*
-            (mCameraActor-&gt;_getSceneNode()-&gt;getParentSceneNode()-&gt;getWorldPosition() - globalCameraPosition));
+            -1*(mCameraActor-&gt;_getSceneNode()-&gt;getParentSceneNode()-&gt;_getDerivedOrientation().Inverse()*
+            (mCameraActor-&gt;_getSceneNode()-&gt;getParentSceneNode()-&gt;_getDerivedPosition() - globalCameraPosition));
 
         mTargetCameraDirection = (listenerEyes - mTargetCameraPosition).normalisedCopy();
     }

Modified: rl/branches/ogre16/rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/ui/src/InputManager.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -118,7 +118,7 @@
         win-&gt;getCustomAttribute(&quot;WINDOW&quot;, &amp;windowHnd);
 
         #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-            pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL_EXCLUSIVE&quot;)));
+            pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL_NONEXCLUSIVE&quot;)));
             pl.insert(std::make_pair(std::string(&quot;w32_keyboard&quot;), std::string(&quot;DISCL_FOREGROUND&quot;)));
         #elif OGRE_PLATFORM == OGRE_PLATFORM_LINUX &amp; defined DEBUG
 //            pl.insert(std::make_pair(std::string(&quot;x11_mouse_grab&quot;), std::string(&quot;false&quot;)));
@@ -591,6 +591,7 @@
 
     bool InputManager::keyPressed(const OIS::KeyEvent&amp; evt)
     {
+		//return false;
         bool retval = false;
         if( WindowManager::getSingleton().getWindowInputMask() &amp; AbstractWindow::WIT_KEYBOARD_INPUT )
         {
@@ -628,12 +629,13 @@
                 
         }
 
-        return true;
-        //return retval;
+        //return true;
+        return retval;
     }
 
     bool InputManager::keyReleased(const OIS::KeyEvent&amp; evt)
     {
+		//return false;
         bool retval = false;
         if( WindowManager::getSingleton().getWindowInputMask() &amp; AbstractWindow::WIT_KEYBOARD_INPUT )
         {
@@ -644,8 +646,8 @@
         if( !mControlStates.empty() )
             if( mControlStates.top()-&gt;keyReleased(evt, retval) )
                 retval = true;
-        return true;
-        //return false;
+        //return true;
+        return false;
     }
 
 }

Modified: rl/branches/ogre16/rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2008-05-06 19:47:22 UTC (rev 4375)
+++ rl/branches/ogre16/rl/trunk/engine/ui/src/InventoryWindow.cpp	2008-05-22 18:21:17 UTC (rev 4381)
@@ -448,7 +448,7 @@
 		mousePos.d_y /= getRoot()-&gt;getPixelSize().d_height;
 		Ogre::Ray camToWorld = camera-&gt;getCameraToViewportRay(
 			mousePos.d_x, mousePos.d_y);
-		Ogre::Vector3 rayStart = camera-&gt;getCamera()-&gt;getWorldPosition();
+		Ogre::Vector3 rayStart = cameraActor-&gt;getWorldPosition();
 		Ogre::Vector3 rayDir = camera-&gt;getDirectionFromScreenPosition(
 			mousePos.d_x, mousePos.d_y);
 

Copied: rl/branches/ogre16/rl/trunk/tools/material_updater.rb (from rev 4380, rl/trunk/tools/material_updater.rb)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001451.html">[Dsa-hl-svn] r4380 - rl/trunk/tools
</A></li>
	<LI>Next message: <A HREF="001453.html">[Dsa-hl-svn] r4382 - in rl/branches/ogre16: . rl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1452">[ date ]</a>
              <a href="thread.html#1452">[ thread ]</a>
              <a href="subject.html#1452">[ subject ]</a>
              <a href="author.html#1452">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
