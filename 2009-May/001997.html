<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4941 - in rl/trunk: Mac/Rastullah.xcodeproj	engine/core/include engine/core/src engine/ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4941%20-%20in%20rl/trunk%3A%20Mac/Rastullah.xcodeproj%0A%09engine/core/include%20engine/core/src%20engine/ui/src&In-Reply-To=%3C200905241705.n4OH5o10027224%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001996.html">
   <LINK REL="Next"  HREF="001998.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4941 - in rl/trunk: Mac/Rastullah.xcodeproj	engine/core/include engine/core/src engine/ui/src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4941%20-%20in%20rl/trunk%3A%20Mac/Rastullah.xcodeproj%0A%09engine/core/include%20engine/core/src%20engine/ui/src&In-Reply-To=%3C200905241705.n4OH5o10027224%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4941 - in rl/trunk: Mac/Rastullah.xcodeproj	engine/core/include engine/core/src engine/ui/src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Sun May 24 19:05:50 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001996.html">[Dsa-hl-svn] r4940 - in rl/branches/persistence2:	editors/Lockenwickler editors/Lockenwickler/src	editors/Lockenwickler/src/media editors/Lockenwickler/src/media/help	editors/Lockenwickler/src/media/icons	editors/Lockenwickler/src/media/terrain	editors/Lockenwickler/src/media/terrain/brushes	editors/Lockenwickler/ui files engine/ai/include	engine/ai/src engine/core engine/core/include engine/core/src	engine/rules/include engine/rules/src engine/script/src	engine/script/swig engine/ui/include engine/ui/src
</A></li>
        <LI>Next message: <A HREF="001998.html">[Dsa-hl-svn] r4942 - dependencies/OgreNewt/Mac/OgreNewt.xcodeproj
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1997">[ date ]</a>
              <a href="thread.html#1997">[ thread ]</a>
              <a href="subject.html#1997">[ subject ]</a>
              <a href="author.html#1997">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2009-05-24 19:05:43 +0200 (Sun, 24 May 2009)
New Revision: 4941

Modified:
   rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/trunk/engine/core/include/stdinc.h
   rl/trunk/engine/core/src/GameAreaTypes.cpp
   rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp
   rl/trunk/engine/ui/src/CutsceneControlState.cpp
Log:
Fixes for Mac OS build

Modified: rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2009-05-22 22:18:33 UTC (rev 4940)
+++ rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2009-05-24 17:05:43 UTC (rev 4941)
@@ -67,8 +67,6 @@
 		444EAB6D0BD0E2F300C6D4A0 /* CoreSubsystem.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */; };
 		444EAB6E0BD0E2F300C6D4A0 /* DebugVisualisable.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */; };
 		444EAB6F0BD0E2F300C6D4A0 /* DebugVisualsManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */; };
-		444EAB700BD0E2F300C6D4A0 /* DotSceneLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */; };
-		444EAB710BD0E2F300C6D4A0 /* DotSceneOctreeWorld.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */; };
 		444EAB720BD0E2F300C6D4A0 /* FadeAnimation.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */; };
 		444EAB730BD0E2F300C6D4A0 /* GameAreaEvent.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */; };
 		444EAB740BD0E2F300C6D4A0 /* GameAreaEventSource.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */; };
@@ -120,8 +118,6 @@
 		444EABEA0BD0E33300C6D4A0 /* CoreSubsystem.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */; };
 		444EABEB0BD0E33300C6D4A0 /* DebugVisualisable.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */; };
 		444EABEC0BD0E33300C6D4A0 /* DebugVisualsManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */; };
-		444EABED0BD0E33300C6D4A0 /* DotSceneLoader.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */; };
-		444EABEE0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */; };
 		444EABEF0BD0E33300C6D4A0 /* FadeAnimation.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */; };
 		444EABF00BD0E33300C6D4A0 /* GameAreaEvent.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */; };
 		444EABF10BD0E33300C6D4A0 /* GameAreaEventSource.h in Headers */ = {isa = PBXBuildFile; fileRef = 444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */; };
@@ -593,8 +589,6 @@
 		485B895A0E15796500D5B19C /* Scene.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89570E15796500D5B19C /* Scene.cpp */; };
 		485B895B0E15796500D5B19C /* SceneLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89580E15796500D5B19C /* SceneLoader.cpp */; };
 		485B895C0E15796500D5B19C /* SceneManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89590E15796500D5B19C /* SceneManager.cpp */; };
-		4869D5300EF055F500619D4D /* libboost_system.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
-		4869D5310EF055F600619D4D /* libboost_filesystem.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 48A52B210E0EDA0E008DBDD8 /* libboost_filesystem.dylib */; };
 		487029C70E80DCEA00B66388 /* GameOverWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 487029C60E80DCEA00B66388 /* GameOverWindow.h */; };
 		487029C90E80DCF900B66388 /* GameOverWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487029C80E80DCF900B66388 /* GameOverWindow.cpp */; };
 		487029E80E80E12200B66388 /* PartyManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 487029E70E80E12200B66388 /* PartyManager.h */; };
@@ -635,18 +629,14 @@
 		4890C0E20E18062B00BE5850 /* StepRecognitionMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0D40E18062B00BE5850 /* StepRecognitionMovement.cpp */; };
 		4890C0E30E18062B00BE5850 /* StrafeMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0D50E18062B00BE5850 /* StrafeMovement.cpp */; };
 		4890C0E40E18062B00BE5850 /* WalkMovement.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 4890C0D60E18062B00BE5850 /* WalkMovement.cpp */; };
-		48A52B220E0EDA0E008DBDD8 /* libboost_filesystem.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52B210E0EDA0E008DBDD8 /* libboost_filesystem.dylib */; };
-		48A52CB00E0EF55C008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
-		48A52CB10E0EF55C008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
-		48A52CB30E0EF577008DBDD8 /* libboost_filesystem.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52B210E0EDA0E008DBDD8 /* libboost_filesystem.dylib */; };
+		489864DA0FC4927300736047 /* GenericWorld.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 489864D70FC4927300736047 /* GenericWorld.cpp */; };
+		489864DB0FC4927300736047 /* PhysicsCollisionFactory.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 489864D80FC4927300736047 /* PhysicsCollisionFactory.cpp */; };
+		489864DC0FC4927300736047 /* PhysicsRagDoll.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 489864D90FC4927300736047 /* PhysicsRagDoll.cpp */; };
+		489864E00FC4928B00736047 /* GenericWorld.h in Headers */ = {isa = PBXBuildFile; fileRef = 489864DD0FC4928A00736047 /* GenericWorld.h */; };
+		489864E10FC4928B00736047 /* PhysicsCollisionFactory.h in Headers */ = {isa = PBXBuildFile; fileRef = 489864DE0FC4928B00736047 /* PhysicsCollisionFactory.h */; };
+		489864E20FC4928B00736047 /* PhysicsRagDoll.h in Headers */ = {isa = PBXBuildFile; fileRef = 489864DF0FC4928B00736047 /* PhysicsRagDoll.h */; };
 		48A52CB60E0EF5BD008DBDD8 /* ApplyDamageJob.h in Headers */ = {isa = PBXBuildFile; fileRef = 48A52CB50E0EF5BD008DBDD8 /* ApplyDamageJob.h */; };
 		48A52CB80E0EF5D0008DBDD8 /* ApplyDamageJob.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48A52CB70E0EF5D0008DBDD8 /* ApplyDamageJob.cpp */; };
-		48A52CBC0E0EF77B008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
-		48A52CBD0E0EF77B008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
-		48A52CBE0E0EF77C008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
-		48A52CBF0E0EF77C008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
-		48A52CC00E0EF77D008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
-		48A52CC20E0EF77E008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
 		48B006C50ECAC05F008141C2 /* CharacterSelectionWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B006C40ECAC05F008141C2 /* CharacterSelectionWindow.cpp */; };
 		48B006C80ECAC11D008141C2 /* CharacterSelectionWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B006C70ECAC11D008141C2 /* CharacterSelectionWindow.h */; };
 		48B0B0350E6534690023B198 /* PlaneNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B0B0340E6534690023B198 /* PlaneNodeProcessor.cpp */; };
@@ -668,7 +658,6 @@
 		48CA78D40F2A513100F8E471 /* Fmod4Listener.h in Headers */ = {isa = PBXBuildFile; fileRef = 48CA78D00F2A513100F8E471 /* Fmod4Listener.h */; };
 		48CA78D50F2A513100F8E471 /* Fmod4Sound.h in Headers */ = {isa = PBXBuildFile; fileRef = 48CA78D10F2A513100F8E471 /* Fmod4Sound.h */; };
 		48CA78D60F2A513100F8E471 /* Fmod4SoundStitching.h in Headers */ = {isa = PBXBuildFile; fileRef = 48CA78D20F2A513100F8E471 /* Fmod4SoundStitching.h */; };
-		48CA78D80F2A51A400F8E471 /* libfmodex.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48CA78D70F2A51A400F8E471 /* libfmodex.dylib */; };
 		48CFBF8F0E2E869000CD0C51 /* FreeType.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 48CFBF8E0E2E869000CD0C51 /* FreeType.framework */; };
 		48D0BDC70E23375E00863824 /* libruby.dylib in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 483646A10D83D57800912FEC /* libruby.dylib */; };
 		48D0BE2C0E273C5E00863824 /* SaveAble.h in Headers */ = {isa = PBXBuildFile; fileRef = 48D0BE280E273C5E00863824 /* SaveAble.h */; };
@@ -696,6 +685,15 @@
 		48D34A810D91C7D800C89477 /* SaveGameManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 485A05710D71EDC40024198D /* SaveGameManager.h */; };
 		48EFE0A40E8B6AF6007EB7F8 /* FetchItemJob.h in Headers */ = {isa = PBXBuildFile; fileRef = 48EFE0A30E8B6AF6007EB7F8 /* FetchItemJob.h */; };
 		48EFE0A60E8B6C39007EB7F8 /* FetchItemJob.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48EFE0A50E8B6C39007EB7F8 /* FetchItemJob.cpp */; };
+		48FF23FD0FC99D3D00E71D4D /* libboost_system-mt.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48FF23FC0FC99D3D00E71D4D /* libboost_system-mt.dylib */; };
+		48FF24000FC99D8700E71D4D /* libboost_filesystem-mt.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48FF23FF0FC99D8700E71D4D /* libboost_filesystem-mt.dylib */; };
+		48FF240A0FC99F2900E71D4D /* libfmodex.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48B0B0480E65BBB30023B198 /* libfmodex.dylib */; };
+		48FF240C0FC99F4800E71D4D /* libboost_filesystem-mt.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48FF23FF0FC99D8700E71D4D /* libboost_filesystem-mt.dylib */; };
+		48FF24160FC9A19600E71D4D /* libboost_system-mt.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48FF23FC0FC99D3D00E71D4D /* libboost_system-mt.dylib */; };
+		48FF24560FC9A4F600E71D4D /* libboost_system-mt.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48FF23FC0FC99D3D00E71D4D /* libboost_system-mt.dylib */; };
+		48FF245A0FC9A53A00E71D4D /* libboost_system-mt.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48FF23FC0FC99D3D00E71D4D /* libboost_system-mt.dylib */; };
+		48FF245C0FC9A58000E71D4D /* libboost_system-mt.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48FF23FC0FC99D3D00E71D4D /* libboost_system-mt.dylib */; };
+		48FF245E0FC9A59D00E71D4D /* libboost_system-mt.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48FF23FC0FC99D3D00E71D4D /* libboost_system-mt.dylib */; };
 		8D0C4E8D0486CD37000505A6 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = 0867D6AAFE840B52C02AAC07 /* InfoPlist.strings */; };
 		8D0C4E8E0486CD37000505A6 /* main.nib in Resources */ = {isa = PBXBuildFile; fileRef = 02345980000FD03B11CA0E72 /* main.nib */; };
 /* End PBXBuildFile section */
@@ -945,8 +943,6 @@
 		444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CoreSubsystem.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DebugVisualisable.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DebugVisualsManager.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
-		444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DotSceneLoader.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
-		444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DotSceneOctreeWorld.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FadeAnimation.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameAreaEvent.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameAreaEventSource.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
@@ -999,8 +995,6 @@
 		444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CoreSubsystem.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DebugVisualisable.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DebugVisualsManager.h; sourceTree = &quot;&lt;group&gt;&quot;; };
-		444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DotSceneLoader.h; sourceTree = &quot;&lt;group&gt;&quot;; };
-		444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DotSceneOctreeWorld.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FadeAnimation.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameAreaEvent.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameAreaEventSource.h; sourceTree = &quot;&lt;group&gt;&quot;; };
@@ -1460,8 +1454,12 @@
 		4890C0D40E18062B00BE5850 /* StepRecognitionMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = StepRecognitionMovement.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		4890C0D50E18062B00BE5850 /* StrafeMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = StrafeMovement.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		4890C0D60E18062B00BE5850 /* WalkMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WalkMovement.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
-		48A52B210E0EDA0E008DBDD8 /* libboost_filesystem.dylib */ = {isa = PBXFileReference; lastKnownFileType = &quot;compiled.mach-o.dylib&quot;; name = libboost_filesystem.dylib; path = /usr/local/lib/libboost_filesystem.dylib; sourceTree = &quot;&lt;absolute&gt;&quot;; };
-		48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */ = {isa = PBXFileReference; lastKnownFileType = &quot;compiled.mach-o.dylib&quot;; name = libboost_system.dylib; path = /usr/local/lib/libboost_system.dylib; sourceTree = &quot;&lt;absolute&gt;&quot;; };
+		489864D70FC4927300736047 /* GenericWorld.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GenericWorld.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		489864D80FC4927300736047 /* PhysicsCollisionFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicsCollisionFactory.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		489864D90FC4927300736047 /* PhysicsRagDoll.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PhysicsRagDoll.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
+		489864DD0FC4928A00736047 /* GenericWorld.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GenericWorld.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		489864DE0FC4928B00736047 /* PhysicsCollisionFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsCollisionFactory.h; sourceTree = &quot;&lt;group&gt;&quot;; };
+		489864DF0FC4928B00736047 /* PhysicsRagDoll.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PhysicsRagDoll.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48A52CB50E0EF5BD008DBDD8 /* ApplyDamageJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ApplyDamageJob.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48A52CB70E0EF5D0008DBDD8 /* ApplyDamageJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ApplyDamageJob.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48B006C40ECAC05F008141C2 /* CharacterSelectionWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CharacterSelectionWindow.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
@@ -1486,7 +1484,6 @@
 		48CA78D00F2A513100F8E471 /* Fmod4Listener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Fmod4Listener.h; path = fmod4driver/Fmod4Listener.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48CA78D10F2A513100F8E471 /* Fmod4Sound.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Fmod4Sound.h; path = fmod4driver/Fmod4Sound.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48CA78D20F2A513100F8E471 /* Fmod4SoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Fmod4SoundStitching.h; path = fmod4driver/Fmod4SoundStitching.h; sourceTree = &quot;&lt;group&gt;&quot;; };
-		48CA78D70F2A51A400F8E471 /* libfmodex.dylib */ = {isa = PBXFileReference; lastKnownFileType = &quot;compiled.mach-o.dylib&quot;; name = libfmodex.dylib; path = &quot;FMOD Programmers API/api/lib/libfmodex.dylib&quot;; sourceTree = SYSTEM_DEVELOPER_DIR; };
 		48CFBF8E0E2E869000CD0C51 /* FreeType.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = FreeType.framework; path = /Library/Frameworks/FreeType.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		48D0BE280E273C5E00863824 /* SaveAble.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveAble.h; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48D0BE290E273C5E00863824 /* SaveAbleCollection.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SaveAbleCollection.h; sourceTree = &quot;&lt;group&gt;&quot;; };
@@ -1511,6 +1508,8 @@
 		48EFE0A50E8B6C39007EB7F8 /* FetchItemJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FetchItemJob.cpp; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48EFE0D70E8B6EB1007EB7F8 /* mkdmg.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; path = mkdmg.sh; sourceTree = &quot;&lt;group&gt;&quot;; };
 		48EFE0D80E8B6EB1007EB7F8 /* renameinstalldirs.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; path = renameinstalldirs.sh; sourceTree = &quot;&lt;group&gt;&quot;; };
+		48FF23FC0FC99D3D00E71D4D /* libboost_system-mt.dylib */ = {isa = PBXFileReference; lastKnownFileType = &quot;compiled.mach-o.dylib&quot;; name = &quot;libboost_system-mt.dylib&quot;; path = &quot;/opt/local/lib/libboost_system-mt.dylib&quot;; sourceTree = &quot;&lt;absolute&gt;&quot;; };
+		48FF23FF0FC99D8700E71D4D /* libboost_filesystem-mt.dylib */ = {isa = PBXFileReference; lastKnownFileType = &quot;compiled.mach-o.dylib&quot;; name = &quot;libboost_filesystem-mt.dylib&quot;; path = &quot;/opt/local/lib/libboost_filesystem-mt.dylib&quot;; sourceTree = &quot;&lt;absolute&gt;&quot;; };
 		8D0C4E960486CD37000505A6 /* Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist; path = Info.plist; sourceTree = &quot;&lt;group&gt;&quot;; };
 		8D0C4E970486CD37000505A6 /* Rastullah.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Rastullah.app; sourceTree = BUILT_PRODUCTS_DIR; };
 /* End PBXFileReference section */
@@ -1520,12 +1519,12 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				48A52B220E0EDA0E008DBDD8 /* libboost_filesystem.dylib in Frameworks */,
 				444EAEBF0BD0F09900C6D4A0 /* CEGUI.framework in Frameworks */,
 				444EAEC00BD0F09900C6D4A0 /* Ogre.framework in Frameworks */,
 				4836CBCE0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
-				48A52CB00E0EF55C008DBDD8 /* libboost_system.dylib in Frameworks */,
 				484FE6BA0E17BC8800FA880F /* Carbon.framework in Frameworks */,
+				48FF23FD0FC99D3D00E71D4D /* libboost_system-mt.dylib in Frameworks */,
+				48FF24000FC99D8700E71D4D /* libboost_filesystem-mt.dylib in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1533,17 +1532,17 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				48A52CB30E0EF577008DBDD8 /* libboost_filesystem.dylib in Frameworks */,
+				48FF24160FC9A19600E71D4D /* libboost_system-mt.dylib in Frameworks */,
 				444EB0AB0BD115CB00C6D4A0 /* libRlCommon.dylib in Frameworks */,
+				48FF240C0FC99F4800E71D4D /* libboost_filesystem-mt.dylib in Frameworks */,
+				48FF240A0FC99F2900E71D4D /* libfmodex.dylib in Frameworks */,
 				483646A20D83D57800912FEC /* libruby.dylib in Frameworks */,
 				444EAEF30BD1150500C6D4A0 /* CEGUI.framework in Frameworks */,
 				444EAEF60BD1150500C6D4A0 /* Ogre.framework in Frameworks */,
 				444EB0890BD1153500C6D4A0 /* OgreNewt.framework in Frameworks */,
 				440785DE0C09D231006E496D /* libmeshmagick.dylib in Frameworks */,
 				4836CBCD0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
-				48A52CB10E0EF55C008DBDD8 /* libboost_system.dylib in Frameworks */,
 				484FE6BC0E17BC8800FA880F /* Carbon.framework in Frameworks */,
-				48CA78D80F2A51A400F8E471 /* libfmodex.dylib in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -1555,12 +1554,12 @@
 				444EB34A0BD173A900C6D4A0 /* libRlRules.dylib in Frameworks */,
 				444EB12D0BD11A0C00C6D4A0 /* libRlCore.dylib in Frameworks */,
 				444EB1290BD119FB00C6D4A0 /* libRlCommon.dylib in Frameworks */,
+				48FF245A0FC9A53A00E71D4D /* libboost_system-mt.dylib in Frameworks */,
 				444EB0D40BD1198B00C6D4A0 /* CEGUI.framework in Frameworks */,
 				444EB0D60BD1198B00C6D4A0 /* Ogre.framework in Frameworks */,
 				444EB0D80BD1198B00C6D4A0 /* OgreNewt.framework in Frameworks */,
 				444EB0DB0BD119BB00C6D4A0 /* OpenSteer.framework in Frameworks */,
 				4836CBCC0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
-				48A52CBC0E0EF77B008DBDD8 /* libboost_system.dylib in Frameworks */,
 				484FE6BD0E17BC8800FA880F /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
@@ -1569,6 +1568,7 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
+				48FF24560FC9A4F600E71D4D /* libboost_system-mt.dylib in Frameworks */,
 				440785EB0C09D377006E496D /* libmeshmagick.dylib in Frameworks */,
 				444EB3480BD1733900C6D4A0 /* OgreNewt.framework in Frameworks */,
 				444EB3440BD1730C00C6D4A0 /* libRlCommon.dylib in Frameworks */,
@@ -1576,7 +1576,6 @@
 				444EB3410BD172BA00C6D4A0 /* CEGUI.framework in Frameworks */,
 				444EB3420BD172BA00C6D4A0 /* Ogre.framework in Frameworks */,
 				4836CBCB0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
-				48A52CBD0E0EF77B008DBDD8 /* libboost_system.dylib in Frameworks */,
 				484FE6BE0E17BC8800FA880F /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
@@ -1585,6 +1584,7 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
+				48FF245C0FC9A58000E71D4D /* libboost_system-mt.dylib in Frameworks */,
 				48389BC70D86764600AFAB66 /* libRlAi.dylib in Frameworks */,
 				444EB3610BD1756B00C6D4A0 /* libRlRules.dylib in Frameworks */,
 				444EB1CE0BD1595100C6D4A0 /* OgreNewt.framework in Frameworks */,
@@ -1595,7 +1595,6 @@
 				444EB3730BD1784A00C6D4A0 /* OgreCEGUIRenderer.framework in Frameworks */,
 				4857E4E50D46A664009D376D /* OIS.framework in Frameworks */,
 				4836CBCA0D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
-				48A52CBE0E0EF77C008DBDD8 /* libboost_system.dylib in Frameworks */,
 				484FE6BF0E17BC8800FA880F /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
@@ -1605,7 +1604,6 @@
 			buildActionMask = 2147483647;
 			files = (
 				483D87CE0D8C564400F3629E /* libRlScript.dylib in Frameworks */,
-				48A52CC00E0EF77D008DBDD8 /* libboost_system.dylib in Frameworks */,
 				484FE6C20E17BC8800FA880F /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
@@ -1624,7 +1622,6 @@
 				48570C480D8A6E9900096E35 /* libRlRules.dylib in Frameworks */,
 				48570C490D8A6E9900096E35 /* libRlUi.dylib in Frameworks */,
 				4836CBC90D8FB0BE002FE5D7 /* Xerces.framework in Frameworks */,
-				48A52CBF0E0EF77C008DBDD8 /* libboost_system.dylib in Frameworks */,
 				484FE6C00E17BC8800FA880F /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
@@ -1640,6 +1637,7 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
+				48FF245E0FC9A59D00E71D4D /* libboost_system-mt.dylib in Frameworks */,
 				444EB7A20BD1963A00C6D4A0 /* CEGUI.framework in Frameworks */,
 				444EB7A80BD1963A00C6D4A0 /* Ogre.framework in Frameworks */,
 				444EB7A90BD1963A00C6D4A0 /* OgreCEGUIRenderer.framework in Frameworks */,
@@ -1652,7 +1650,6 @@
 				444EB7A00BD195E800C6D4A0 /* libRlUi.dylib in Frameworks */,
 				4836F8BC0D885AAA00E3632F /* libruby.dylib in Frameworks */,
 				48570E020D8A6F8300096E35 /* libRlScript.dylib in Frameworks */,
-				48A52CC20E0EF77E008DBDD8 /* libboost_system.dylib in Frameworks */,
 				484FE6BB0E17BC8800FA880F /* Carbon.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
@@ -1679,7 +1676,6 @@
 		20286C29FDCF999611CA2CEA /* Rastullah */ = {
 			isa = PBXGroup;
 			children = (
-				48CA78D70F2A51A400F8E471 /* libfmodex.dylib */,
 				20286C2AFDCF999611CA2CEA /* Engine */,
 				48D401810D9E483200AE5340 /* modules */,
 				20286C2CFDCF999611CA2CEA /* Resources */,
@@ -1719,13 +1715,13 @@
 		20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */ = {
 			isa = PBXGroup;
 			children = (
+				48FF23FC0FC99D3D00E71D4D /* libboost_system-mt.dylib */,
+				48FF23FF0FC99D8700E71D4D /* libboost_filesystem-mt.dylib */,
 				487750AF0E7E3C9C0018216B /* Cg.framework */,
 				48C04B890E67DF0300CD3A7D /* PCRE.framework */,
 				48B0B0480E65BBB30023B198 /* libfmodex.dylib */,
 				48CFBF8E0E2E869000CD0C51 /* FreeType.framework */,
 				484FE6B90E17BC8800FA880F /* Carbon.framework */,
-				48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */,
-				48A52B210E0EDA0E008DBDD8 /* libboost_filesystem.dylib */,
 				4836CBC80D8FB0BE002FE5D7 /* Xerces.framework */,
 				4857E4E40D46A664009D376D /* OIS.framework */,
 				440785DD0C09D231006E496D /* libmeshmagick.dylib */,
@@ -1959,6 +1955,9 @@
 		4851EA4C0EDDC82400AB79E9 /* Source */ = {
 			isa = PBXGroup;
 			children = (
+				489864D70FC4927300736047 /* GenericWorld.cpp */,
+				489864D80FC4927300736047 /* PhysicsCollisionFactory.cpp */,
+				489864D90FC4927300736047 /* PhysicsRagDoll.cpp */,
 				48CA78C70F2A511E00F8E471 /* Fmod4Driver.cpp */,
 				48CA78C80F2A511E00F8E471 /* Fmod4Listener.cpp */,
 				48CA78C90F2A511E00F8E471 /* Fmod4Sound.cpp */,
@@ -2000,8 +1999,6 @@
 				444EAB2C0BD0E2B600C6D4A0 /* CoreSubsystem.cpp */,
 				444EAB2D0BD0E2B600C6D4A0 /* DebugVisualisable.cpp */,
 				444EAB2E0BD0E2B600C6D4A0 /* DebugVisualsManager.cpp */,
-				444EAB2F0BD0E2B600C6D4A0 /* DotSceneLoader.cpp */,
-				444EAB300BD0E2B600C6D4A0 /* DotSceneOctreeWorld.cpp */,
 				444EAB310BD0E2B600C6D4A0 /* FadeAnimation.cpp */,
 				444EAB320BD0E2B600C6D4A0 /* GameAreaEvent.cpp */,
 				444EAB330BD0E2B600C6D4A0 /* GameAreaEventSource.cpp */,
@@ -2048,6 +2045,9 @@
 		4851EA4D0EDDC8CA00AB79E9 /* Header */ = {
 			isa = PBXGroup;
 			children = (
+				489864DD0FC4928A00736047 /* GenericWorld.h */,
+				489864DE0FC4928B00736047 /* PhysicsCollisionFactory.h */,
+				489864DF0FC4928B00736047 /* PhysicsRagDoll.h */,
 				48CA78CF0F2A513100F8E471 /* Fmod4Driver.h */,
 				48CA78D00F2A513100F8E471 /* Fmod4Listener.h */,
 				48CA78D10F2A513100F8E471 /* Fmod4Sound.h */,
@@ -2092,8 +2092,6 @@
 				444EABA90BD0E33300C6D4A0 /* CoreSubsystem.h */,
 				444EABAA0BD0E33300C6D4A0 /* DebugVisualisable.h */,
 				444EABAB0BD0E33300C6D4A0 /* DebugVisualsManager.h */,
-				444EABAC0BD0E33300C6D4A0 /* DotSceneLoader.h */,
-				444EABAD0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h */,
 				444EABAE0BD0E33300C6D4A0 /* FadeAnimation.h */,
 				444EABAF0BD0E33300C6D4A0 /* GameAreaEvent.h */,
 				444EABB00BD0E33300C6D4A0 /* GameAreaEventSource.h */,
@@ -2565,8 +2563,6 @@
 				444EABEA0BD0E33300C6D4A0 /* CoreSubsystem.h in Headers */,
 				444EABEB0BD0E33300C6D4A0 /* DebugVisualisable.h in Headers */,
 				444EABEC0BD0E33300C6D4A0 /* DebugVisualsManager.h in Headers */,
-				444EABED0BD0E33300C6D4A0 /* DotSceneLoader.h in Headers */,
-				444EABEE0BD0E33300C6D4A0 /* DotSceneOctreeWorld.h in Headers */,
 				444EABEF0BD0E33300C6D4A0 /* FadeAnimation.h in Headers */,
 				444EABF00BD0E33300C6D4A0 /* GameAreaEvent.h in Headers */,
 				444EABF10BD0E33300C6D4A0 /* GameAreaEventSource.h in Headers */,
@@ -2639,6 +2635,9 @@
 				48CA78D40F2A513100F8E471 /* Fmod4Listener.h in Headers */,
 				48CA78D50F2A513100F8E471 /* Fmod4Sound.h in Headers */,
 				48CA78D60F2A513100F8E471 /* Fmod4SoundStitching.h in Headers */,
+				489864E00FC4928B00736047 /* GenericWorld.h in Headers */,
+				489864E10FC4928B00736047 /* PhysicsCollisionFactory.h in Headers */,
+				489864E20FC4928B00736047 /* PhysicsRagDoll.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3081,8 +3080,6 @@
 			isa = PBXResourcesBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
-				4869D5300EF055F500619D4D /* libboost_system.dylib in Resources */,
-				4869D5310EF055F600619D4D /* libboost_filesystem.dylib in Resources */,
 				48B0B03C0E6535AB0023B198 /* libmeshmagick.dylib in Resources */,
 				484D921E0E1E078100BCFC2B /* libRlCommon.dylib in Resources */,
 				484D921F0E1E078100BCFC2B /* libRlCore.dylib in Resources */,
@@ -3190,8 +3187,6 @@
 				483646C50D83D62E00912FEC /* SaveGameManager.cpp in Sources */,
 				444EAB6E0BD0E2F300C6D4A0 /* DebugVisualisable.cpp in Sources */,
 				444EAB6F0BD0E2F300C6D4A0 /* DebugVisualsManager.cpp in Sources */,
-				444EAB700BD0E2F300C6D4A0 /* DotSceneLoader.cpp in Sources */,
-				444EAB710BD0E2F300C6D4A0 /* DotSceneOctreeWorld.cpp in Sources */,
 				444EAB720BD0E2F300C6D4A0 /* FadeAnimation.cpp in Sources */,
 				444EAB730BD0E2F300C6D4A0 /* GameAreaEvent.cpp in Sources */,
 				444EAB740BD0E2F300C6D4A0 /* GameAreaEventSource.cpp in Sources */,
@@ -3254,6 +3249,9 @@
 				48CA78CC0F2A511E00F8E471 /* Fmod4Listener.cpp in Sources */,
 				48CA78CD0F2A511E00F8E471 /* Fmod4Sound.cpp in Sources */,
 				48CA78CE0F2A511E00F8E471 /* Fmod4SoundStitching.cpp in Sources */,
+				489864DA0FC4927300736047 /* GenericWorld.cpp in Sources */,
+				489864DB0FC4927300736047 /* PhysicsCollisionFactory.cpp in Sources */,
+				489864DC0FC4927300736047 /* PhysicsRagDoll.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3624,8 +3622,7 @@
 				);
 				INSTALL_PATH = &quot;@executable_path/../Resources&quot;;
 				LIBRARY_SEARCH_PATHS = (
-					/sw/lib,
-					/usr/local/lib,
+					&quot;$(inherited)&quot;,
 					/opt/local/lib,
 				);
 				MACH_O_TYPE = mh_dylib;
@@ -3700,9 +3697,11 @@
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1)&quot;,
 					/opt/local/lib,
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_2)&quot;,
+					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_3)&quot;,
 				);
 				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = &quot;\&quot;$(SYSTEM_LIBRARY_DIR)/Frameworks/Ruby.framework/Versions/1.8/usr/lib\&quot;&quot;;
 				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_2 = &quot;\&quot;$(DEVELOPER_DIR)/FMOD Programmers API/api/lib\&quot;&quot;;
+				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_3 = &quot;\&quot;$(DEVELOPER_DIR)/FMOD Programmers API/api/lib\&quot;&quot;;
 				MACH_O_TYPE = mh_dylib;
 				OTHER_LDFLAGS = &quot;&quot;;
 				PREBINDING = NO;
@@ -3746,9 +3745,11 @@
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1)&quot;,
 					/opt/local/lib,
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_2)&quot;,
+					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_3)&quot;,
 				);
 				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = &quot;\&quot;$(SYSTEM_LIBRARY_DIR)/Frameworks/Ruby.framework/Versions/1.8/usr/lib\&quot;&quot;;
 				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_2 = &quot;\&quot;$(DEVELOPER_DIR)/FMOD Programmers API/api/lib\&quot;&quot;;
+				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_3 = &quot;\&quot;$(DEVELOPER_DIR)/FMOD Programmers API/api/lib\&quot;&quot;;
 				OTHER_LDFLAGS = &quot;&quot;;
 				PREBINDING = NO;
 				PRODUCT_NAME = RlCore;
@@ -3783,8 +3784,7 @@
 				INSTALL_PATH = &quot;@executable_path/../Resources&quot;;
 				LIBRARY_SEARCH_PATHS = (
 					&quot;$(inherited)&quot;,
-					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_1)&quot;,
-					/sw/lib,
+					/opt/local/lib,
 				);
 				LIBRARY_SEARCH_PATHS_QUOTED_1 = &quot;\&quot;$(SRCROOT)/build/Debug\&quot;&quot;;
 				MACH_O_TYPE = mh_dylib;
@@ -3819,8 +3819,7 @@
 				INSTALL_PATH = &quot;@executable_path/../Resources&quot;;
 				LIBRARY_SEARCH_PATHS = (
 					&quot;$(inherited)&quot;,
-					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_1)&quot;,
-					/sw/lib,
+					/opt/local/lib,
 				);
 				LIBRARY_SEARCH_PATHS_QUOTED_1 = &quot;\&quot;$(SRCROOT)/build/Debug\&quot;&quot;;
 				OTHER_LDFLAGS = &quot;&quot;;
@@ -3857,6 +3856,7 @@
 				LIBRARY_SEARCH_PATHS = (
 					&quot;$(inherited)&quot;,
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_1)&quot;,
+					/opt/local/lib,
 				);
 				LIBRARY_SEARCH_PATHS_QUOTED_1 = &quot;\&quot;$(SRCROOT)/build/Debug\&quot;&quot;;
 				MACH_O_TYPE = mh_dylib;
@@ -3893,6 +3893,7 @@
 				LIBRARY_SEARCH_PATHS = (
 					&quot;$(inherited)&quot;,
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_1)&quot;,
+					/opt/local/lib,
 				);
 				LIBRARY_SEARCH_PATHS_QUOTED_1 = &quot;\&quot;$(SRCROOT)/build/Debug\&quot;&quot;;
 				OTHER_LDFLAGS = &quot;&quot;;
@@ -3929,7 +3930,10 @@
 					/Library/Frameworks/Xerces.framework/Headers,
 				);
 				INSTALL_PATH = &quot;@executable_path/../Resources&quot;;
-				LIBRARY_SEARCH_PATHS = &quot;$(inherited)&quot;;
+				LIBRARY_SEARCH_PATHS = (
+					&quot;$(inherited)&quot;,
+					/opt/local/lib,
+				);
 				LIBRARY_SEARCH_PATHS_QUOTED_1 = &quot;\&quot;$(SRCROOT)/build/Debug\&quot;&quot;;
 				MACH_O_TYPE = mh_dylib;
 				OTHER_LDFLAGS = (
@@ -3969,6 +3973,7 @@
 				LIBRARY_SEARCH_PATHS = (
 					&quot;$(inherited)&quot;,
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_1)&quot;,
+					/opt/local/lib,
 				);
 				LIBRARY_SEARCH_PATHS_QUOTED_1 = &quot;\&quot;$(SRCROOT)/build/Debug\&quot;&quot;;
 				OTHER_LDFLAGS = (
@@ -4183,6 +4188,7 @@
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_2)&quot;,
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_3)&quot;,
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_4)&quot;,
+					/opt/local/lib,
 				);
 				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = &quot;\&quot;$(SRCROOT)/build/Debug\&quot;&quot;;
 				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_2 = &quot;\&quot;$(SYSTEM_LIBRARY_DIR)/Frameworks/Ruby.framework/Versions/1.8/usr/lib\&quot;&quot;;
@@ -4217,6 +4223,7 @@
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_2)&quot;,
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_3)&quot;,
 					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1)&quot;,
+					/opt/local/lib,
 				);
 				LIBRARY_SEARCH_PATHS_QUOTED_1 = &quot;\&quot;$(SRCROOT)/build/Debug\&quot;&quot;;
 				LIBRARY_SEARCH_PATHS_QUOTED_2 = &quot;\&quot;$(SYSTEM_LIBRARY_DIR)/Frameworks/Ruby.framework/Versions/1.8/usr/lib\&quot;&quot;;

Modified: rl/trunk/engine/core/include/stdinc.h
===================================================================
--- rl/trunk/engine/core/include/stdinc.h	2009-05-22 22:18:33 UTC (rev 4940)
+++ rl/trunk/engine/core/include/stdinc.h	2009-05-24 17:05:43 UTC (rev 4941)
@@ -58,6 +58,7 @@
 #include &lt;boost/filesystem/operations.hpp&gt;
 #include &lt;boost/filesystem/exception.hpp&gt;
 #include &lt;boost/any.hpp&gt;
+#include &lt;boost/smartptr.hpp&gt;
 
 #if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
 #  include &lt;Windows.h&gt;

Modified: rl/trunk/engine/core/src/GameAreaTypes.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaTypes.cpp	2009-05-22 22:18:33 UTC (rev 4940)
+++ rl/trunk/engine/core/src/GameAreaTypes.cpp	2009-05-24 17:05:43 UTC (rev 4941)
@@ -1,270 +1,272 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;GameAreaTypes.h&quot;
-
-#include &quot;Actor.h&quot;
-#include &quot;World.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;PhysicsManager.h&quot;
-#include &quot;PhysicalThing.h&quot;
-
-
-using namespace Ogre;
-
-namespace rl {
-    GameAreaType::~GameAreaType()
-    {
-    }
-
-    void GameAreaType::addQueryFlag( unsigned long flag  )
-    {
-        setQueryMask(  getQueryMask() | flag );
-    }
-
-    void GameAreaType::removeQueryFlag( unsigned long flag )
-    {
-        setQueryMask(  getQueryMask() &amp;~ flag );
-    }
-}
-
-
-namespace rl {
-/*
-    GameSphereAreaType::GameSphereAreaType(Vector3 center, Real radius, unsigned long mask)
-    {
-        mSphereQuery = CoreSubsystem::getSingleton().getWorld()-&gt;
-            getSceneManager()-&gt;createSphereQuery( Sphere(center,radius), mask );
-
-        // Keine Welt-Geometrie erw&#252;nscht, nur Movables
-        mSphereQuery-&gt;setWorldFragmentType( SceneQuery::WFT_NONE );
-    }
-
-    GameSphereAreaType::~GameSphereAreaType()
-    {
-        mSphereQuery-&gt;clearResults();
-        CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager()-&gt;destroyQuery( mSphereQuery );
-    }
-
-    ActorMap GameSphereAreaType::performQuery(  )
-    {
-        SceneQueryResult rs = mSphereQuery-&gt;execute();
-        SceneQueryResultMovableList movList = rs.movables;
-
-        ActorMap retMap;
-
-        // Durch die Ergebnis Liste iterieren
-        SceneQueryResultMovableList::iterator it;
-        for (it = movList.begin(); it != movList.end(); ++it)
-        {
-            MovableObject* mov = *it;
-            if( mov-&gt;getUserObject() != NULL )
-            {
-                // Zur Zeit sind die einzigen an Movables gekn&#252;pfte Objekte Actoren
-                Actor* act = dynamic_cast&lt;Actor*&gt;( mov-&gt;getUserObject() );
-                retMap.insert(ActorPair(act-&gt;getName(),act));
-            }
-        }
-
-        return retMap;
-    }
-
-    unsigned long GameSphereAreaType::getQueryMask() const
-    {
-        return mSphereQuery-&gt;getQueryMask();
-    }
-
-    void GameSphereAreaType::setQueryMask( unsigned long mask )
-    {
-        mSphereQuery-&gt;setQueryMask( mask );
-    }
-
-    void GameSphereAreaType::setQueryPosition( const Ogre::Vector3&amp; vec )
-    {
-        // Wurde es bewegt?
-        if( vec != mSphereQuery-&gt;getSphere().getCenter( ) )
-            // Kugel muss neu erzeugt werden :(
-            mSphereQuery-&gt;setSphere( Sphere(vec,mSphereQuery-&gt;getSphere().getRadius()) );
-    }
-
-    Ogre::Vector3 GameSphereAreaType::getQueryPosition() const
-    {
-        return mSphereQuery-&gt;getSphere().getCenter( );
-    }
-*/
-
-
-
-    GameNewtonBodyAreaType::GameNewtonBodyAreaType() :
-        mBody(NULL),
-        mTransitionDistance(0)
-    {
-    }
-
-
-    GameNewtonBodyAreaType::~GameNewtonBodyAreaType()
-    {
-        if(mBody != NULL)
-            delete mBody;
-        mBody = NULL;
-    }
-
-    unsigned long GameNewtonBodyAreaType::getQueryMask() const
-    {
-        return mQueryMask;
-    }
-
-    void GameNewtonBodyAreaType::setQueryMask(unsigned long mask)
-    {
-        mQueryMask = mask;
-    }
-
-    Quaternion GameNewtonBodyAreaType::getQueryOrientation() const
-    {
-        Vector3 pos;
-        Quaternion orient;
-        mBody-&gt;getPositionOrientation(pos, orient);
-        return orient;
-    }
-
-    Vector3 GameNewtonBodyAreaType::getQueryPosition() const
-    {
-        Vector3 pos;
-        Quaternion orient;
-        mBody-&gt;getPositionOrientation(pos, orient);
-        return pos;
-    }
-
-    void GameNewtonBodyAreaType::setQueryPosition(const Vector3 &amp;pos)
-    {
-        Quaternion orient;
-        Vector3 old_pos;
-        mBody-&gt;getPositionOrientation(old_pos, orient);
-        mBody-&gt;setPositionOrientation(pos, orient);
-    }
-
-    void GameNewtonBodyAreaType::setQueryOrientation(const Quaternion &amp;orient)
-    {
-        Quaternion old_orient;
-        Vector3 pos;
-        mBody-&gt;getPositionOrientation(pos, old_orient);
-        mBody-&gt;setPositionOrientation(pos, orient);
-    }
-
-    void GameNewtonBodyAreaType::foundCollision(Actor* actor)
-    {
-        if( actor )
-        {
-            unsigned long flags = actor-&gt;getQueryFlags();
-            if( flags &amp; mQueryMask )
-                mFoundActors[actor-&gt;getName()] = actor;
-        }
-    }
-
-    void GameNewtonBodyAreaType::resetFoundCollisions()
-    {
-        mFoundActors.clear();
-    }
-
-    bool GameNewtonBodyAreaType::isInside(Actor *actor)
-    {
-        return getDistance(actor) &lt;= 0;
-    }
-
-    ActorMap GameNewtonBodyAreaType::performQuery()
-    {
-        return mFoundActors;
-    }
-
-    Ogre::Real GameNewtonBodyAreaType::getDistance(Actor* actor)
-    {
-        if(!actor)
-            Throw(NullPointerException, &quot;Argument actor cannot be NULL!&quot;);
-        OgreNewt::World *world = 
-            PhysicsManager::getSingleton()._getNewtonWorld();
-        Vector3 retA, retB, retNorm;
-        Vector3 positionA;
-        Quaternion orientationA;
-        mBody-&gt;getPositionOrientation(positionA, orientationA);
-        int intRet = 
-            OgreNewt::CollisionTools::CollisionClosestPoint(
-                world,
-                mBody-&gt;getCollision(), orientationA, positionA,
-                actor-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getCollision(),
-                actor-&gt;getOrientation(), actor-&gt;getPosition(),
-                retA, retB, retNorm, 0); // set threadindex to 0, I hope this is ok!
-
-        if( intRet == 0 )
-            return 0;
-
-        return (retA - retB).length();
-    }
-
-    Ogre::Real GameNewtonBodyAreaType::getTransitionDistance() const
-    {
-        return mTransitionDistance;
-    }
-
-    void GameNewtonBodyAreaType::setTransitionDistance(Ogre::Real dist) 
-    {
-        mTransitionDistance = dist;
-    }
-
-    GameMeshAreaType::GameMeshAreaType(
-            Ogre::Entity* entity,
-            GeometryType geomType,
-			Ogre::Vector3 offset,
-			Ogre::Quaternion orientation)
-    {
-        if(geomType == GT_MESH)
-        {
-            LOG_ERROR(Logger::CORE, &quot;Geometrie Typ 'GT_MESH' is not (yet) support by GameMeshAreaType, use GT_CONVEXHULL instead!&quot;);
-            geomType = GT_CONVEXHULL;
-        }
-        OgreNewt::CollisionPtr col =
-            PhysicsManager::getSingleton().createCollision(entity,
-            geomType, &quot;&quot;, offset, orientation);
-        mBody = new OgreNewt::Body(
-            PhysicsManager::getSingleton()._getNewtonWorld(),
-            col);
-        mBody-&gt;setMaterialGroupID(
-            PhysicsManager::getSingleton().getMaterialID(&quot;gamearea&quot;));
-
-        boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(col)-&gt;setAsTriggerVolume(true);
-    }
-
-    GameSimpleCollisionAreaType::GameSimpleCollisionAreaType(
-            Ogre::AxisAlignedBox aabb,
-            GeometryType geomType,
-            Ogre::Vector3 offset,
-            Ogre::Quaternion orientation)
-    {
-        OgreNewt::CollisionPtr col =
-            PhysicsManager::getSingleton().createCollision(
-            &quot;&quot;, aabb, geomType, offset, orientation, 0, NULL, NULL, true);
-        mBody = new OgreNewt::Body(
-            PhysicsManager::getSingleton()._getNewtonWorld(),
-            col);
-        mBody-&gt;setMaterialGroupID(
-            PhysicsManager::getSingleton().getMaterialID(&quot;gamearea&quot;));
-
-        boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(col)-&gt;setAsTriggerVolume(true);
-    }
-
-}
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;GameAreaTypes.h&quot;
+
+#include &lt;boost/smart_ptr.hpp&gt;
+
+#include &quot;Actor.h&quot;
+#include &quot;World.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;PhysicsManager.h&quot;
+#include &quot;PhysicalThing.h&quot;
+
+
+using namespace Ogre;
+
+namespace rl {
+    GameAreaType::~GameAreaType()
+    {
+    }
+
+    void GameAreaType::addQueryFlag( unsigned long flag  )
+    {
+        setQueryMask(  getQueryMask() | flag );
+    }
+
+    void GameAreaType::removeQueryFlag( unsigned long flag )
+    {
+        setQueryMask(  getQueryMask() &amp;~ flag );
+    }
+}
+
+
+namespace rl {
+/*
+    GameSphereAreaType::GameSphereAreaType(Vector3 center, Real radius, unsigned long mask)
+    {
+        mSphereQuery = CoreSubsystem::getSingleton().getWorld()-&gt;
+            getSceneManager()-&gt;createSphereQuery( Sphere(center,radius), mask );
+
+        // Keine Welt-Geometrie erw&#194;&#184;nscht, nur Movables
+        mSphereQuery-&gt;setWorldFragmentType( SceneQuery::WFT_NONE );
+    }
+
+    GameSphereAreaType::~GameSphereAreaType()
+    {
+        mSphereQuery-&gt;clearResults();
+        CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager()-&gt;destroyQuery( mSphereQuery );
+    }
+
+    ActorMap GameSphereAreaType::performQuery(  )
+    {
+        SceneQueryResult rs = mSphereQuery-&gt;execute();
+        SceneQueryResultMovableList movList = rs.movables;
+
+        ActorMap retMap;
+
+        // Durch die Ergebnis Liste iterieren
+        SceneQueryResultMovableList::iterator it;
+        for (it = movList.begin(); it != movList.end(); ++it)
+        {
+            MovableObject* mov = *it;
+            if( mov-&gt;getUserObject() != NULL )
+            {
+                // Zur Zeit sind die einzigen an Movables gekn&#194;&#184;pfte Objekte Actoren
+                Actor* act = dynamic_cast&lt;Actor*&gt;( mov-&gt;getUserObject() );
+                retMap.insert(ActorPair(act-&gt;getName(),act));
+            }
+        }
+
+        return retMap;
+    }
+
+    unsigned long GameSphereAreaType::getQueryMask() const
+    {
+        return mSphereQuery-&gt;getQueryMask();
+    }
+
+    void GameSphereAreaType::setQueryMask( unsigned long mask )
+    {
+        mSphereQuery-&gt;setQueryMask( mask );
+    }
+
+    void GameSphereAreaType::setQueryPosition( const Ogre::Vector3&amp; vec )
+    {
+        // Wurde es bewegt?
+        if( vec != mSphereQuery-&gt;getSphere().getCenter( ) )
+            // Kugel muss neu erzeugt werden :(
+            mSphereQuery-&gt;setSphere( Sphere(vec,mSphereQuery-&gt;getSphere().getRadius()) );
+    }
+
+    Ogre::Vector3 GameSphereAreaType::getQueryPosition() const
+    {
+        return mSphereQuery-&gt;getSphere().getCenter( );
+    }
+*/
+
+
+
+    GameNewtonBodyAreaType::GameNewtonBodyAreaType() :
+        mBody(NULL),
+        mTransitionDistance(0)
+    {
+    }
+
+
+    GameNewtonBodyAreaType::~GameNewtonBodyAreaType()
+    {
+        if(mBody != NULL)
+            delete mBody;
+        mBody = NULL;
+    }
+
+    unsigned long GameNewtonBodyAreaType::getQueryMask() const
+    {
+        return mQueryMask;
+    }
+
+    void GameNewtonBodyAreaType::setQueryMask(unsigned long mask)
+    {
+        mQueryMask = mask;
+    }
+
+    Quaternion GameNewtonBodyAreaType::getQueryOrientation() const
+    {
+        Vector3 pos;
+        Quaternion orient;
+        mBody-&gt;getPositionOrientation(pos, orient);
+        return orient;
+    }
+
+    Vector3 GameNewtonBodyAreaType::getQueryPosition() const
+    {
+        Vector3 pos;
+        Quaternion orient;
+        mBody-&gt;getPositionOrientation(pos, orient);
+        return pos;
+    }
+
+    void GameNewtonBodyAreaType::setQueryPosition(const Vector3 &amp;pos)
+    {
+        Quaternion orient;
+        Vector3 old_pos;
+        mBody-&gt;getPositionOrientation(old_pos, orient);
+        mBody-&gt;setPositionOrientation(pos, orient);
+    }
+
+    void GameNewtonBodyAreaType::setQueryOrientation(const Quaternion &amp;orient)
+    {
+        Quaternion old_orient;
+        Vector3 pos;
+        mBody-&gt;getPositionOrientation(pos, old_orient);
+        mBody-&gt;setPositionOrientation(pos, orient);
+    }
+
+    void GameNewtonBodyAreaType::foundCollision(Actor* actor)
+    {
+        if( actor )
+        {
+            unsigned long flags = actor-&gt;getQueryFlags();
+            if( flags &amp; mQueryMask )
+                mFoundActors[actor-&gt;getName()] = actor;
+        }
+    }
+
+    void GameNewtonBodyAreaType::resetFoundCollisions()
+    {
+        mFoundActors.clear();
+    }
+
+    bool GameNewtonBodyAreaType::isInside(Actor *actor)
+    {
+        return getDistance(actor) &lt;= 0;
+    }
+
+    ActorMap GameNewtonBodyAreaType::performQuery()
+    {
+        return mFoundActors;
+    }
+
+    Ogre::Real GameNewtonBodyAreaType::getDistance(Actor* actor)
+    {
+        if(!actor)
+            Throw(NullPointerException, &quot;Argument actor cannot be NULL!&quot;);
+        OgreNewt::World *world = 
+            PhysicsManager::getSingleton()._getNewtonWorld();
+        Vector3 retA, retB, retNorm;
+        Vector3 positionA;
+        Quaternion orientationA;
+        mBody-&gt;getPositionOrientation(positionA, orientationA);
+        int intRet = 
+            OgreNewt::CollisionTools::CollisionClosestPoint(
+                world,
+                mBody-&gt;getCollision(), orientationA, positionA,
+                actor-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getCollision(),
+                actor-&gt;getOrientation(), actor-&gt;getPosition(),
+                retA, retB, retNorm, 0); // set threadindex to 0, I hope this is ok!
+
+        if( intRet == 0 )
+            return 0;
+
+        return (retA - retB).length();
+    }
+
+    Ogre::Real GameNewtonBodyAreaType::getTransitionDistance() const
+    {
+        return mTransitionDistance;
+    }
+
+    void GameNewtonBodyAreaType::setTransitionDistance(Ogre::Real dist) 
+    {
+        mTransitionDistance = dist;
+    }
+
+    GameMeshAreaType::GameMeshAreaType(
+            Ogre::Entity* entity,
+            GeometryType geomType,
+			Ogre::Vector3 offset,
+			Ogre::Quaternion orientation)
+    {
+        if(geomType == GT_MESH)
+        {
+            LOG_ERROR(Logger::CORE, &quot;Geometrie Typ 'GT_MESH' is not (yet) support by GameMeshAreaType, use GT_CONVEXHULL instead!&quot;);
+            geomType = GT_CONVEXHULL;
+        }
+        OgreNewt::CollisionPtr col =
+            PhysicsManager::getSingleton().createCollision(entity,
+            geomType, &quot;&quot;, offset, orientation);
+        mBody = new OgreNewt::Body(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            col);
+        mBody-&gt;setMaterialGroupID(
+            PhysicsManager::getSingleton().getMaterialID(&quot;gamearea&quot;));
+
+        boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(col)-&gt;setAsTriggerVolume(true);
+    }
+
+    GameSimpleCollisionAreaType::GameSimpleCollisionAreaType(
+            Ogre::AxisAlignedBox aabb,
+            GeometryType geomType,
+            Ogre::Vector3 offset,
+            Ogre::Quaternion orientation)
+    {
+        OgreNewt::CollisionPtr col =
+            PhysicsManager::getSingleton().createCollision(
+            &quot;&quot;, aabb, geomType, offset, orientation, 0, NULL, NULL, true);
+        mBody = new OgreNewt::Body(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            col);
+        mBody-&gt;setMaterialGroupID(
+            PhysicsManager::getSingleton().getMaterialID(&quot;gamearea&quot;));
+
+        boost::dynamic_pointer_cast&lt;OgreNewt::ConvexCollision&gt;(col)-&gt;setAsTriggerVolume(true);
+    }
+
+}
+

Modified: rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp	2009-05-22 22:18:33 UTC (rev 4940)
+++ rl/trunk/engine/core/src/PhysicsCollisionFactory.cpp	2009-05-24 17:05:43 UTC (rev 4941)
@@ -1,790 +1,790 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;Exception.h&quot;
-#include &quot;PhysicsCollisionFactory.h&quot;
-#include &quot;PhysicsManager.h&quot;
-#include &quot;ConfigurationManager.h&quot;
-
-#include &lt;boost/filesystem/operations.hpp&gt;
-#include &lt;boost/filesystem/exception.hpp&gt;
-
-namespace fs = boost::filesystem;
-
-#ifdef __APPLE__
-#   include &lt;Ogre/OgreMesh.h&gt;
-#else
-#   include &lt;OgreMesh.h&gt;
-#endif
-
-
-
-using namespace std;
-using namespace OgreNewt;
-using namespace Ogre;
-
-
-namespace rl
-{
-
-    PhysicsCollisionFactory::PhysicsCollisionFactory() :
-        mCollisionSerializer()
-    {
-
-#       if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-        mCachePathName = Ogre::String( Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/cache/&quot;);
-        fs::path cachePath( mCachePathName, fs::portable_posix_name);
-#       else
-        mCachePathName = Ogre::String( ConfigurationManager::getSingleton().getModulesRootDirectory() + &quot;/cache/&quot; );
-        fs::path cachePath( mCachePathName );
-#       endif
-
-        if( !fs::exists(cachePath) )
-            fs::create_directory(cachePath);
-    }
-
-
-    PhysicsCollisionFactory::~PhysicsCollisionFactory()
-    {
-        clearCollisionCache();
-    }
-
-    void PhysicsCollisionFactory::clearCollisionCache()
-    {
-        mMeshCollisionsCache.clear();
-        mConvexCollisionsCache.clear();
-        mConvexAABBCollisionsCache.clear();
-    }
-
-    bool PhysicsCollisionFactory::checkSize(const Ogre::AxisAlignedBox&amp; aabb) const
-    {
-        Ogre::Vector3 size = aabb.getSize();
-        if( size.x &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
-            size.y &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
-            size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH )
-            return false;
-        return true;
-    }
-
-    void PhysicsCollisionFactory::correctSize(Ogre::AxisAlignedBox&amp; aabb)
-    {
-        Ogre::Vector3 size = aabb.getSize();
-        // correct size, log warning and fail back to box
-        if (size.x &lt; PhysicsManager::NEWTON_GRID_WIDTH)
-            size.x = PhysicsManager::NEWTON_GRID_WIDTH;
-        if (size.y &lt; PhysicsManager::NEWTON_GRID_WIDTH)
-            size.y = PhysicsManager::NEWTON_GRID_WIDTH;
-        if (size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH)
-            size.z = PhysicsManager::NEWTON_GRID_WIDTH;
-        LOG_MESSAGE(Logger::CORE, &quot;Correcting collision primitiv size&quot;);
-        Ogre::Vector3 center = aabb.getCenter();
-        aabb.setMaximum(center + 0.5*size);
-        aabb.setMinimum(center - 0.5*size);
-    }
-
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(
-        const Ogre::String&amp; name,
-        const Ogre::AxisAlignedBox&amp; passedAabb,
-        const GeometryType&amp; geomType,
-        const Ogre::Vector3 &amp;offset,
-        const Ogre::Quaternion &amp;orientation,
-        const Ogre::Real mass,
-        Ogre::Vector3* inertia,
-        Ogre::Vector3* centerOfMass,
-        bool nocache)
-    {
-
-        // don't cache if the name is &quot;&quot;
-        if( name == &quot;&quot; )
-            nocache = true;
-
-
-        Ogre::AxisAlignedBox aabb(passedAabb);
-        // type for the collision primitiv (can change internally here)
-        bool forceBox (false);
-
-        // result value
-        ConvexCollisionPtr rval;
-
-        // size check (if object is too small, it falls back to a box primitiv
-        if (checkSize(aabb) == false )
-        {
-            correctSize(aabb);
-            LOG_WARNING(Logger::CORE,
-                &quot; AABB is too small, using 'box' instead of primitiv '&quot; +
-                PhysicsManager::convertGeometryTypeToString(geomType));
-            forceBox = true;
-        }
-
-        // check if the geometry type is supported for aabb
-        if (geomType == GT_CONVEXHULL ||
-            geomType == GT_MESH)
-        {
-            LOG_WARNING(Logger::CORE,
-                &quot; the geometry type '&quot;+
-                PhysicsManager::convertGeometryTypeToString(geomType)+
-                &quot;' is not supported for aabb, fail back to box&quot;);
-            forceBox = true;
-        }
-
-
-        ConvexCollisionCacheMap::iterator convexCacheIt = mConvexAABBCollisionsCache.end();
-
-        // check if we can reuse a cached collision
-        if( !nocache )
-        {
-            if( !forceBox )
-            {
-                Ogre::String index(name);
-                std::pair&lt;ConvexCollisionCacheMap::iterator,bool&gt; iterBoolPair = mConvexAABBCollisionsCache.insert(std::make_pair(index, ConvexCollisionCacheObject()));
-                convexCacheIt = iterBoolPair.first;
-                if( !iterBoolPair.second )
-                {
-                    // there was already an element, check type, the size, offset etc if we can use it
-                    if( geomType != convexCacheIt-&gt;second.type )
-                    {
-                        LOG_MESSAGE(Logger::CORE, &quot;Performance warning: trying to create a collision for aabb '&quot; + name +
-                                &quot;' with geometry-type '&quot;+PhysicsManager::convertGeometryTypeToString(geomType)+
-                                &quot;'. There's already a collision with type '&quot;+PhysicsManager::convertGeometryTypeToString(convexCacheIt-&gt;second.type)+&quot;'!&quot;);
-                    }
-                    else if( aabb.getSize() == convexCacheIt-&gt;second.scale &amp;&amp; offset == convexCacheIt-&gt;second.offset &amp;&amp; orientation == convexCacheIt-&gt;second.orientation )
-                    {
-                        // everything fine, reuse it
-                        rval = convexCacheIt-&gt;second.col;
-
-                        if( inertia != NULL )
-                            *inertia = convexCacheIt-&gt;second.inertia;
-                        if( centerOfMass != NULL )
-                            *centerOfMass = convexCacheIt-&gt;second.centerOfMass;
-
-                        LOG_DEBUG(Logger::CORE, &quot;Reused collision for aabb '&quot; + name + &quot;'.&quot;);
-
-                        return rval;
-                    }
-                }
-            }
-        }
-
-
-        /* differentiate between the different collision primitives, because they all
-		   need different offset and probably different orientation values.
-		   Newton SDK is really nifty and helps here, because we can shift the origin
-		   of the coordinate system of the primitiv we create into any position we
-		   desire. Actually this is the bottom middle of our mesh - as the meshes are
-		   always constructed like that.
-	    */
-        if( !rval )
-        {
-            if (geomType == GT_BOX || forceBox == true)
-            {
-                rval = createBox(aabb, offset, orientation);
-            }
-            else if (geomType == GT_PYRAMID)
-            {
-                rval = createPyramid(aabb, offset, orientation);
-            }
-            else if (geomType == GT_SPHERE)
-            {
-                rval = createSphere(aabb, offset, orientation);
-            }
-            else if (geomType == GT_ELLIPSOID)
-            {
-                rval = createEllipsoid(aabb, offset, orientation);
-            }
-            else if (geomType == GT_CAPSULE)
-            {
-                rval = createCapsule(aabb, offset, orientation);
-            }
-        }
-
-        if ( rval == NULL )
-        {
-            LOG_WARNING(Logger::CORE, &quot; creating collision primitiv '&quot;+
-                PhysicsManager::convertGeometryTypeToString(geomType)+&quot;' for AABB '&quot;+ name
-                +&quot;' failed.&quot;);
-
-            // delete cacheobject
-            if( convexCacheIt != mConvexAABBCollisionsCache.end() )
-            {
-                mConvexAABBCollisionsCache.erase( convexCacheIt );
-            }
-        }
-        else
-        {
-            LOG_DEBUG(Logger::CORE, &quot; collision primitiv '&quot;+
-                PhysicsManager::convertGeometryTypeToString(geomType)+&quot;' created for AABB '&quot;+
-                name+&quot;'&quot;);
-        }
-
-
-        // calculate inertia / centerOfMass if requested
-        // and save collision in cache
-        if( rval)
-        {
-            if( convexCacheIt != mConvexAABBCollisionsCache.end() )
-            {
-                // save collision in cache
-                Vector3 temp_inertia, temp_centerOfMass;
-                rval-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-
-                convexCacheIt-&gt;second.col = rval;
-                convexCacheIt-&gt;second.scale = aabb.getSize();
-                convexCacheIt-&gt;second.offset = offset;
-                convexCacheIt-&gt;second.orientation = orientation;
-                convexCacheIt-&gt;second.inertia = temp_inertia;
-                convexCacheIt-&gt;second.centerOfMass = temp_centerOfMass;
-                convexCacheIt-&gt;second.type = geomType;
-
-                if( inertia != NULL )
-                    *inertia = temp_inertia*mass;
-                if( centerOfMass != NULL )
-                    *centerOfMass = temp_centerOfMass;
-            }
-            else if (inertia != NULL || centerOfMass != NULL )
-            {
-                Vector3 temp_inertia, temp_centerOfMass;
-                rval-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-                if( inertia != NULL )
-                    *inertia = temp_inertia*mass;
-                if( centerOfMass != NULL )
-                    *centerOfMass = temp_centerOfMass;
-            }
-        }
-
-        return rval;
-    }
-
-
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromEntity(Ogre::Entity* entity,
-        const GeometryType&amp; geomType,
-        const Ogre::String&amp; animName,
-        const Ogre::Vector3 &amp;offset,
-        const Ogre::Quaternion &amp;orientation,
-        const Ogre::Real mass,
-        Ogre::Vector3* inertia,
-        Ogre::Vector3* centerOfMass,
-        bool nocache)
-    {
-        // bounding box of the mesh
-        Ogre::AxisAlignedBox aabb(entity-&gt;getBoundingBox());
-        // apply scale if attached to a node (like in OgreNewt for convexhull)
-        Ogre::Vector3 scale = Ogre::Vector3::UNIT_SCALE;
-        if( entity-&gt;getParentNode() )
-        {
-            scale = entity-&gt;getParentNode()-&gt;getScale();
-            aabb.scale(scale);
-        }
-
-        // type for the collision primitiv (can change internally here)
-        bool forceBox (false);
-
-        // result value
-        CollisionPtr rval;
-        ConvexCollisionPtr rvalAsConvexCollision; // store pointer to ConvexCollision, so we don't need to cast
-                                                  // this also indicates, that it is possible to calculate inertia/centerOfMass
-
-        // size check (if object is too small, it falls back to a box primitiv
-        if (checkSize(aabb) == false )
-        {
-            correctSize(aabb);
-            LOG_MESSAGE(Logger::CORE, &quot; Entity '&quot;+entity-&gt;getName()+
-                &quot;' is too small, using 'box' instead of primitiv '&quot;+
-                PhysicsManager::convertGeometryTypeToString(geomType));
-            forceBox = true;
-        }
-
-
-        if( geomType == GT_MESH )
-        {
-            if( offset != Ogre::Vector3::ZERO || orientation != Ogre::Quaternion::IDENTITY )
-            {
-                LOG_WARNING(Logger::CORE, &quot; Cannot set collision offset or orientation when using mesh-collision (entity: '&quot; +
-                        entity-&gt;getName()+&quot;')!&quot;);
-            }
-            if( inertia || centerOfMass )
-            {
-                LOG_WARNING(Logger::CORE, &quot; Cannot calculate inertia or center of mass when using mesh-collision (entity: '&quot; +
-                        entity-&gt;getName()+&quot;')!&quot;);
-            }
-        }
-
-
-        MeshCollisionCacheMap::iterator meshCacheIt = mMeshCollisionsCache.end();
-        ConvexCollisionCacheMap::iterator convexCacheIt = mConvexCollisionsCache.end();
-
-        // check if we can reuse a cached collision
-        if( !nocache )
-        {
-            // use meshcollisionscache
-            if( geomType == GT_MESH &amp;&amp; !forceBox )
-            {
-                StringVector index(entity-&gt;getMesh()-&gt;getName() + animName, scale);
-                std::pair&lt;MeshCollisionCacheMap::iterator,bool&gt; iterBoolPair = mMeshCollisionsCache.insert(std::make_pair(index, MeshCollisionCacheObject()));
-                meshCacheIt = iterBoolPair.first;
-                if( !iterBoolPair.second )
-                {
-                    // there was already an element -- so we can reuse it
-
-                    LOG_DEBUG(Logger::CORE, &quot;Reused collision for entity '&quot; + entity-&gt;getName() + &quot;' (mesh: '&quot;
-                            + entity-&gt;getMesh()-&gt;getName() + &quot;', animation: '&quot; + animName + &quot;').&quot;);
-                    rval = iterBoolPair.first-&gt;second.col;
-
-                    return rval;
-                }
-            }
-            // use convexcollisionscache
-            else if( !forceBox )
-            {
-                Ogre::String index(entity-&gt;getMesh()-&gt;getName() + animName);
-                std::pair&lt;ConvexCollisionCacheMap::iterator,bool&gt; iterBoolPair = mConvexCollisionsCache.insert(std::make_pair(index, ConvexCollisionCacheObject()));
-                convexCacheIt = iterBoolPair.first;
-                if( !iterBoolPair.second )
-                {
-                    // there was already an element, check type, the size, offset etc if we can use it
-                    if( geomType != convexCacheIt-&gt;second.type )
-                    {
-                        LOG_MESSAGE(Logger::CORE, &quot;Performance warning: trying to create a collision for entity '&quot;+entity-&gt;getName()+&quot;' with animation '&quot;+
-                                animName+&quot;' with geometry-type '&quot;+PhysicsManager::convertGeometryTypeToString(geomType)+
-                                &quot;'. There's already a collision with type '&quot;+PhysicsManager::convertGeometryTypeToString(convexCacheIt-&gt;second.type)+&quot;'!&quot;);
-                    }
-                    else if( scale == convexCacheIt-&gt;second.scale &amp;&amp; offset == convexCacheIt-&gt;second.offset &amp;&amp; orientation == convexCacheIt-&gt;second.orientation )
-                    {
-                        // everything fine, reuse it
-                        rval = convexCacheIt-&gt;second.col;
-
-                        if( inertia != NULL )
-                            *inertia = convexCacheIt-&gt;second.inertia;
-                        if( centerOfMass != NULL )
-                            *centerOfMass = convexCacheIt-&gt;second.centerOfMass;
-
-                        LOG_DEBUG(Logger::CORE, &quot;Reused collision for entity '&quot; + entity-&gt;getName() + &quot;' (mesh: '&quot;
-                            + entity-&gt;getMesh()-&gt;getName() + &quot;', animation: '&quot; + animName + &quot;').&quot;);
-
-                        return rval;
-                    }
-                    else if( geomType == GT_CONVEXHULL ) // for simple types just use create a new collision
-                    {
-                        // we need to rescale (or change offset or orientation)
-                        // the old transformation
-                        Ogre::Matrix4 oldInvTransformation;
-                        oldInvTransformation.makeInverseTransform(convexCacheIt-&gt;second.offset, convexCacheIt-&gt;second.scale, convexCacheIt-&gt;second.orientation);
-                        // the new transformation
-                        Ogre::Matrix4 newTransformation;
-                        newTransformation.makeTransform(offset, scale, orientation);
-
-                        // the needed transformation from old to new:
-                        Ogre::Matrix4 transformation = oldInvTransformation*newTransformation;
-
-                        OgreNewt::ConvexModifierCollision *convexModCol = new OgreNewt::ConvexModifierCollision(
-                                PhysicsManager::getSingleton()._getNewtonWorld(),convexCacheIt-&gt;second.col);
-                        convexModCol-&gt;setScalarMatrix(transformation);
-
-                        // set the convexcollision-ptr, so centerOfMass and inertia can be calculated
-                        rval = OgreNewt::ConvexCollisionPtr(convexModCol);
-
-
-                        LOG_DEBUG(Logger::CORE, &quot;Reused collision for entity '&quot; + entity-&gt;getName() + &quot;' (mesh: '&quot;
-                                + entity-&gt;getMesh()-&gt;getName() + &quot;', animation: '&quot; + animName + &quot;') with a ConvexModifierCollision.&quot;);
-
-                        // calculate inertia / centerOfMass if needed
-                        if (inertia != NULL || centerOfMass != NULL )
-                        {
-                            Vector3 temp_inertia, temp_centerOfMass;
-                            rvalAsConvexCollision-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-                            if( inertia != NULL )
-                                *inertia = temp_inertia*mass;
-                            if( centerOfMass != NULL )
-                                *centerOfMass = temp_centerOfMass;
-                        }
-
-                        return rval;
-                    }
-                }
-            }
-        }
-
-		/* differentiate between the different collision primitives, because they all
-		   need different offset and probably different orientation values.
-		   Newton SDK is really nifty and helps here, because we can shift the origin
-		   of the coordinate system of the primitiv we create into any position we
-		   desire. Actually this is the bottom middle of our mesh - as the meshes are
-		   always constructed like that.
-	    */
-        if (geomType == GT_BOX || forceBox == true)
-        {
-            rvalAsConvexCollision = createBox(aabb, offset, orientation);
-            rval = rvalAsConvexCollision;
-        }
-        else if (geomType == GT_PYRAMID)
-        {
-            rvalAsConvexCollision = createPyramid(aabb, offset, orientation);
-            rval = rvalAsConvexCollision;
-        }
-        else if (geomType == GT_SPHERE)
-        {
-            rvalAsConvexCollision = createSphere(aabb, offset, orientation);
-            rval = rvalAsConvexCollision;
-        }
-        else if (geomType == GT_ELLIPSOID)
-        {
-            rvalAsConvexCollision = createEllipsoid(aabb, offset, orientation);
-            rval = rvalAsConvexCollision;
-        }
-        else if (geomType == GT_CAPSULE)
-        {
-            rvalAsConvexCollision = createCapsule(aabb, offset, orientation);
-            rval = rvalAsConvexCollision;
-        }
-        else if (geomType == GT_CONVEXHULL)
-        {
-            rvalAsConvexCollision = createConvexHull(entity, offset, orientation);
-            rval = rvalAsConvexCollision;
-        }
-        else if (geomType == GT_MESH)
-        {
-            rval = createMesh( entity, animName, nocache );
-
-            if( meshCacheIt != mMeshCollisionsCache.end() )
-                meshCacheIt-&gt;second.col = rval;
-        }
-        else
-        {
-            Throw(IllegalArgumentException, &quot;unknown geometry type.&quot;);
-        }
-
-
-        if ( rval == NULL )
-        {
-            LOG_WARNING(Logger::CORE, &quot; creating collision primitiv '&quot;+
-                PhysicsManager::convertGeometryTypeToString(geomType)+&quot;' for Entity '&quot;+
-                entity-&gt;getName()+&quot;' failed.&quot;);
-
-            // delete cacheobject
-            if( meshCacheIt != mMeshCollisionsCache.end() )
-            {
-                mMeshCollisionsCache.erase( meshCacheIt );
-            }
-            if( convexCacheIt != mConvexCollisionsCache.end() )
-            {
-                mConvexCollisionsCache.erase( convexCacheIt );
-            }
-        }
-        else
-        {
-            LOG_DEBUG(Logger::CORE, &quot; collision primitiv '&quot;+
-                PhysicsManager::convertGeometryTypeToString(geomType)+&quot;' created for Entity '&quot;+
-                entity-&gt;getName()+&quot;'&quot;);
-        }
-
-        // calculate inertia / centerOfMass if requested
-        // and save collision in cache
-        if( rvalAsConvexCollision )
-        {
-            if( convexCacheIt != mConvexCollisionsCache.end() )
-            {
-                // save collision in cache
-                Vector3 temp_inertia, temp_centerOfMass;
-                rvalAsConvexCollision-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-
-                convexCacheIt-&gt;second.col = rvalAsConvexCollision;
-                convexCacheIt-&gt;second.scale = scale;
-                convexCacheIt-&gt;second.offset = offset;
-                convexCacheIt-&gt;second.orientation = orientation;
-                convexCacheIt-&gt;second.inertia = temp_inertia;
-                convexCacheIt-&gt;second.centerOfMass = temp_centerOfMass;
-                convexCacheIt-&gt;second.type = geomType;
-
-                if( inertia != NULL )
-                    *inertia = temp_inertia*mass;
-                if( centerOfMass != NULL )
-                    *centerOfMass = temp_centerOfMass;
-            }
-            else if (inertia != NULL || centerOfMass != NULL )
-            {
-                Vector3 temp_inertia, temp_centerOfMass;
-                rvalAsConvexCollision-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
-                if( inertia != NULL )
-                    *inertia = temp_inertia*mass;
-                if( centerOfMass != NULL )
-                    *centerOfMass = temp_centerOfMass;
-            }
-        }
-
-        return rval;
-    }
-
-
-    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createBox(const Ogre::AxisAlignedBox&amp; aabb,
-            const Ogre::Vector3 &amp;offset,
-            const Ogre::Quaternion &amp;orientation)
-    {
-        // offset relative to center
-        Ogre::Vector3 offsetInGlobalSpace = offset + aabb.getCenter();
-
-        // a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
-        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
-            PhysicsManager::getSingleton()._getNewtonWorld(),
-            aabb.getSize(), orientation, offsetInGlobalSpace));
-
-       return rval;
-    }
-
-    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createPyramid(const Ogre::AxisAlignedBox&amp; aabb,
-            const Ogre::Vector3 &amp;offset,
-            const Ogre::Quaternion &amp;orientation)
-    {
-        // offset relative to center
-        Ogre::Vector3 offsetInGlobalSpace = offset + aabb.getCenter();
-
-        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
-            PhysicsManager::getSingleton()._getNewtonWorld(),
-            aabb.getSize(), orientation, offsetInGlobalSpace));
-
-       return rval;
-    }
-
-    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createSphere(const Ogre::AxisAlignedBox&amp; aabb,
-            const Ogre::Vector3 &amp;offset,
-            const Ogre::Quaternion &amp;orientation)
-    {
-        // offset relative to center
-        Ogre::Vector3 offsetInGlobalSpace = offset + aabb.getCenter();
-
-        Ogre::Vector3 size = aabb.getSize();
-        // calculate the maximum radius needed to include 'everything'
-        double radius = std::max(size.x, std::max(size.y, size.z)) / 2.0;
- 
-        // a sphere primitiv has got its coordinate system at its center, so shift it with radius
-        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
-            PhysicsManager::getSingleton()._getNewtonWorld(),
-            Vector3(radius, radius, radius), orientation, offsetInGlobalSpace));
- 
-       return rval;
-    }
-
-    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createEllipsoid(const Ogre::AxisAlignedBox&amp; aabb,
-            const Ogre::Vector3 &amp;offset,
-            const Ogre::Quaternion &amp;orientation)
-    {
-        // offset relative to center
-        Ogre::Vector3 offsetInGlobalSpace = offset + aabb.getCenter();
-
-        Ogre::Vector3 size = aabb.getSize();
-        // set the size x/z values to the maximum
-        Vector3 s(size/2.0);
-        s.x = std::max(s.x, s.z);
-        s.z = s.x;
-
-        // an ellipsoid primitiv has got its coordinate system at its center, so shift it with radius
-        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
-            PhysicsManager::getSingleton()._getNewtonWorld(),
-            s, orientation, offsetInGlobalSpace));
-
-       return rval;
-    }
-
-    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createCapsule(const Ogre::AxisAlignedBox&amp; aabb,
-            const Ogre::Vector3 &amp;offset,
-            const Ogre::Quaternion &amp;orientation)
-    {
-        // offset relative to center
-        Ogre::Vector3 offsetInGlobalSpace = offset + aabb.getCenter();
-        // @todo: fixme: this is a semi ugly fix - because the orientation should be set by the loader
-        //object_orientation.FromAngleAxis(Degree(90), Vector3::UNIT_Z);
-
-        Ogre::Vector3 size = aabb.getSize();
-
-        double radius = std::max(size.x, size.z) / 2.0;
-		double height = size.y;
-
-        // an capsule primitiv has got its coordinate system at its center, so shift it with radius
-        // additionally it is x axis aligned, so rotate it 90 degrees around z axis
-        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Capsule(
-            PhysicsManager::getSingleton()._getNewtonWorld(),
-            radius, height, orientation, offsetInGlobalSpace));
-
-        return rval;
-    }
-
-
-
-    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createConvexHull(
-            Ogre::Entity* entity,
-            const Ogre::Vector3 &amp;offset,
-            const Ogre::Quaternion &amp;orientation)
-    {
-        Ogre::Vector3 offsetInGlobalSpace = offset;
-
-        // calculate the convex hull of the animated mesh
-        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::ConvexHull(
-                    PhysicsManager::getSingleton()._getNewtonWorld(),
-                    entity, orientation, offsetInGlobalSpace));
-
-        return rval;
-    }
-
-
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::loadFromFile(const Ogre::String&amp; filename)
-    {
-        OgreNewt::CollisionPtr rval;
-        Ogre::String fullfilename = mCachePathName+filename;
-        FILE* pFile = fopen(fullfilename.c_str(), &quot;r&quot; );
-        if( pFile )
-        {
-            Ogre::DataStreamPtr streamPtr( new Ogre::FileHandleDataStream( pFile ) );
-            rval = mCollisionSerializer.importCollision( streamPtr, PhysicsManager::getSingleton()._getNewtonWorld() );
-
-            if( rval )
-            {
-                LOG_DEBUG(Logger::CORE, &quot;Loaded collision from file '&quot; + filename + &quot;'.&quot;);
-            }
-        }
-
-        return rval;
-    }
-
-
-
-    void PhysicsCollisionFactory::saveToFile(OgreNewt::CollisionPtr col, const Ogre::String&amp; filename)
-    {
-        mCollisionSerializer.exportCollision(col, mCachePathName + filename);
-    }
-
-
-
-    OgreNewt::CollisionPtr PhysicsCollisionFactory::createMesh( Ogre::Entity* entity, const Ogre::String&amp; animName, bool nocache )
-    {
-        OgreNewt::CollisionPtr rval;
-        Ogre::String filename;
-
-        if( !nocache )
-        {
-            Ogre::Vector3 scale(Ogre::Vector3::UNIT_SCALE);
-            if( entity-&gt;getParentNode() )
-                scale = entity-&gt;getParentNode()-&gt;getScale();
-
-            filename = entity-&gt;getMesh()-&gt;getName() + animName + Ogre::StringConverter::toString(scale) + &quot;.collision&quot;;
-
-            // check date of cache file and mesh
-            time_t meshFileModified = 
-                Ogre::ResourceGroupManager::getSingleton().resourceModifiedTime(
-                        entity-&gt;getMesh()-&gt;getGroup(),
-                        entity-&gt;getMesh()-&gt;getName());
-
-#if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-            fs::path cacheFilePath( mCachePathName+filename, fs::portable_posix_name);
-#else
-            fs::path cacheFilePath( mCachePathName+filename );
-#endif
-
-            time_t cacheFileModified = 0;
-            if( fs::exists(cacheFilePath) )
-                cacheFileModified = fs::last_write_time(cacheFilePath);
-
-
-            if( cacheFileModified &gt; meshFileModified )        
-                rval = loadFromFile( filename );
-        }
-
-
-        if( !rval )
-        {
-            rval = OgreNewt::CollisionPtr( new OgreNewt::CollisionPrimitives::TreeCollision(
-                        PhysicsManager::getSingleton()._getNewtonWorld(),
-                        entity, true ));
-
-            if( !nocache )
-            {
-                saveToFile(rval, filename );
-            }
-        }
-
-        return rval;
-    }
-
-
-
-    PhysicsCollisionFactory::StringVector::StringVector(const Ogre::String&amp; str, const Ogre::Vector3&amp; vec)
-    {
-        setString(str);
-        setVector(vec);
-    }
-    
-    void PhysicsCollisionFactory::StringVector::setString(const Ogre::String&amp; str)
-    {
-        mStr = str;
-    }
-    
-    void PhysicsCollisionFactory::StringVector::setVector(const Ogre::Vector3&amp; vec)
-    {
-        mVec = vec;
-    }
-    
-    const Ogre::String&amp; PhysicsCollisionFactory::StringVector::getString() const
-    {
-        return mStr;
-    }
-    
-    const Ogre::Vector3&amp; PhysicsCollisionFactory::StringVector::getVector() const
-    {
-        return mVec;
-    }
-
-    bool PhysicsCollisionFactory::StringVector::operator==(const PhysicsCollisionFactory::StringVector&amp; strVec) const
-    {
-        if( mStr != strVec.mStr )
-            return false;
-
-        Ogre::Vector3 diff = mVec - strVec.mVec;
-        if( abs(diff.x) &gt; 0.01 )
-            return false;
-        if( abs(diff.y) &gt; 0.01 )
-            return false;
-        if( abs(diff.z) &gt; 0.01 )
-            return false;
-
-        return true;
-    }
-
-    bool PhysicsCollisionFactory::StringVector::operator&lt;(const PhysicsCollisionFactory::StringVector&amp; strVec) const
-    {
-        int strCompare = mStr.compare(strVec.mStr);
-        // @todo: use a hash or so
-        if( strCompare == 0 ) // strings are the same
-        {
-            // compare vectors
-            Ogre::Vector3 diff = mVec - strVec.mVec;
-            if( diff.x &lt; -0.01 )
-                return true;
-            if( diff.x &gt; 0.01 )
-                return false;
-            if( diff.y &lt; -0.01 )
-                return true;
-            if( diff.y &gt; 0.01 )
-                return false;
-            if( diff.y &lt; -0.01 )
-                return true;
-
-            return false;
-        }
-        
-        return strCompare &lt; 0;
-    }
-
-
-}
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;PhysicsCollisionFactory.h&quot;
+
+#include &lt;boost/filesystem/operations.hpp&gt;
+#include &lt;boost/filesystem/exception.hpp&gt;
+
+#include &quot;ConfigurationManager.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;PhysicsManager.h&quot;
+
+namespace fs = boost::filesystem;
+
+#ifdef __APPLE__
+#   include &lt;Ogre/OgreMesh.h&gt;
+#else
+#   include &lt;OgreMesh.h&gt;
+#endif
+
+
+using namespace std;
+using namespace OgreNewt;
+using namespace Ogre;
+
+
+namespace rl
+{
+
+    PhysicsCollisionFactory::PhysicsCollisionFactory() :
+        mCollisionSerializer()
+    {
+
+#       if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
+        mCachePathName = Ogre::String( Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/cache/&quot;);
+        fs::path cachePath( mCachePathName, fs::portable_posix_name);
+#       else
+        mCachePathName = Ogre::String( ConfigurationManager::getSingleton().getModulesRootDirectory() + &quot;/cache/&quot; );
+        fs::path cachePath( mCachePathName );
+#       endif
+
+        if( !fs::exists(cachePath) )
+            fs::create_directory(cachePath);
+    }
+
+
+    PhysicsCollisionFactory::~PhysicsCollisionFactory()
+    {
+        clearCollisionCache();
+    }
+
+    void PhysicsCollisionFactory::clearCollisionCache()
+    {
+        mMeshCollisionsCache.clear();
+        mConvexCollisionsCache.clear();
+        mConvexAABBCollisionsCache.clear();
+    }
+
+    bool PhysicsCollisionFactory::checkSize(const Ogre::AxisAlignedBox&amp; aabb) const
+    {
+        Ogre::Vector3 size = aabb.getSize();
+        if( size.x &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
+            size.y &lt; PhysicsManager::NEWTON_GRID_WIDTH ||
+            size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH )
+            return false;
+        return true;
+    }
+
+    void PhysicsCollisionFactory::correctSize(Ogre::AxisAlignedBox&amp; aabb)
+    {
+        Ogre::Vector3 size = aabb.getSize();
+        // correct size, log warning and fail back to box
+        if (size.x &lt; PhysicsManager::NEWTON_GRID_WIDTH)
+            size.x = PhysicsManager::NEWTON_GRID_WIDTH;
+        if (size.y &lt; PhysicsManager::NEWTON_GRID_WIDTH)
+            size.y = PhysicsManager::NEWTON_GRID_WIDTH;
+        if (size.z &lt; PhysicsManager::NEWTON_GRID_WIDTH)
+            size.z = PhysicsManager::NEWTON_GRID_WIDTH;
+        LOG_MESSAGE(Logger::CORE, &quot;Correcting collision primitiv size&quot;);
+        Ogre::Vector3 center = aabb.getCenter();
+        aabb.setMaximum(center + 0.5*size);
+        aabb.setMinimum(center - 0.5*size);
+    }
+
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromAABB(
+        const Ogre::String&amp; name,
+        const Ogre::AxisAlignedBox&amp; passedAabb,
+        const GeometryType&amp; geomType,
+        const Ogre::Vector3 &amp;offset,
+        const Ogre::Quaternion &amp;orientation,
+        const Ogre::Real mass,
+        Ogre::Vector3* inertia,
+        Ogre::Vector3* centerOfMass,
+        bool nocache)
+    {
+
+        // don't cache if the name is &quot;&quot;
+        if( name == &quot;&quot; )
+            nocache = true;
+
+
+        Ogre::AxisAlignedBox aabb(passedAabb);
+        // type for the collision primitiv (can change internally here)
+        bool forceBox (false);
+
+        // result value
+        ConvexCollisionPtr rval;
+
+        // size check (if object is too small, it falls back to a box primitiv
+        if (checkSize(aabb) == false )
+        {
+            correctSize(aabb);
+            LOG_WARNING(Logger::CORE,
+                &quot; AABB is too small, using 'box' instead of primitiv '&quot; +
+                PhysicsManager::convertGeometryTypeToString(geomType));
+            forceBox = true;
+        }
+
+        // check if the geometry type is supported for aabb
+        if (geomType == GT_CONVEXHULL ||
+            geomType == GT_MESH)
+        {
+            LOG_WARNING(Logger::CORE,
+                &quot; the geometry type '&quot;+
+                PhysicsManager::convertGeometryTypeToString(geomType)+
+                &quot;' is not supported for aabb, fail back to box&quot;);
+            forceBox = true;
+        }
+
+
+        ConvexCollisionCacheMap::iterator convexCacheIt = mConvexAABBCollisionsCache.end();
+
+        // check if we can reuse a cached collision
+        if( !nocache )
+        {
+            if( !forceBox )
+            {
+                Ogre::String index(name);
+                std::pair&lt;ConvexCollisionCacheMap::iterator,bool&gt; iterBoolPair = mConvexAABBCollisionsCache.insert(std::make_pair(index, ConvexCollisionCacheObject()));
+                convexCacheIt = iterBoolPair.first;
+                if( !iterBoolPair.second )
+                {
+                    // there was already an element, check type, the size, offset etc if we can use it
+                    if( geomType != convexCacheIt-&gt;second.type )
+                    {
+                        LOG_MESSAGE(Logger::CORE, &quot;Performance warning: trying to create a collision for aabb '&quot; + name +
+                                &quot;' with geometry-type '&quot;+PhysicsManager::convertGeometryTypeToString(geomType)+
+                                &quot;'. There's already a collision with type '&quot;+PhysicsManager::convertGeometryTypeToString(convexCacheIt-&gt;second.type)+&quot;'!&quot;);
+                    }
+                    else if( aabb.getSize() == convexCacheIt-&gt;second.scale &amp;&amp; offset == convexCacheIt-&gt;second.offset &amp;&amp; orientation == convexCacheIt-&gt;second.orientation )
+                    {
+                        // everything fine, reuse it
+                        rval = convexCacheIt-&gt;second.col;
+
+                        if( inertia != NULL )
+                            *inertia = convexCacheIt-&gt;second.inertia;
+                        if( centerOfMass != NULL )
+                            *centerOfMass = convexCacheIt-&gt;second.centerOfMass;
+
+                        LOG_DEBUG(Logger::CORE, &quot;Reused collision for aabb '&quot; + name + &quot;'.&quot;);
+
+                        return rval;
+                    }
+                }
+            }
+        }
+
+
+        /* differentiate between the different collision primitives, because they all
+		   need different offset and probably different orientation values.
+		   Newton SDK is really nifty and helps here, because we can shift the origin
+		   of the coordinate system of the primitiv we create into any position we
+		   desire. Actually this is the bottom middle of our mesh - as the meshes are
+		   always constructed like that.
+	    */
+        if( !rval )
+        {
+            if (geomType == GT_BOX || forceBox == true)
+            {
+                rval = createBox(aabb, offset, orientation);
+            }
+            else if (geomType == GT_PYRAMID)
+            {
+                rval = createPyramid(aabb, offset, orientation);
+            }
+            else if (geomType == GT_SPHERE)
+            {
+                rval = createSphere(aabb, offset, orientation);
+            }
+            else if (geomType == GT_ELLIPSOID)
+            {
+                rval = createEllipsoid(aabb, offset, orientation);
+            }
+            else if (geomType == GT_CAPSULE)
+            {
+                rval = createCapsule(aabb, offset, orientation);
+            }
+        }
+
+        if ( rval == NULL )
+        {
+            LOG_WARNING(Logger::CORE, &quot; creating collision primitiv '&quot;+
+                PhysicsManager::convertGeometryTypeToString(geomType)+&quot;' for AABB '&quot;+ name
+                +&quot;' failed.&quot;);
+
+            // delete cacheobject
+            if( convexCacheIt != mConvexAABBCollisionsCache.end() )
+            {
+                mConvexAABBCollisionsCache.erase( convexCacheIt );
+            }
+        }
+        else
+        {
+            LOG_DEBUG(Logger::CORE, &quot; collision primitiv '&quot;+
+                PhysicsManager::convertGeometryTypeToString(geomType)+&quot;' created for AABB '&quot;+
+                name+&quot;'&quot;);
+        }
+
+
+        // calculate inertia / centerOfMass if requested
+        // and save collision in cache
+        if( rval)
+        {
+            if( convexCacheIt != mConvexAABBCollisionsCache.end() )
+            {
+                // save collision in cache
+                Vector3 temp_inertia, temp_centerOfMass;
+                rval-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+
+                convexCacheIt-&gt;second.col = rval;
+                convexCacheIt-&gt;second.scale = aabb.getSize();
+                convexCacheIt-&gt;second.offset = offset;
+                convexCacheIt-&gt;second.orientation = orientation;
+                convexCacheIt-&gt;second.inertia = temp_inertia;
+                convexCacheIt-&gt;second.centerOfMass = temp_centerOfMass;
+                convexCacheIt-&gt;second.type = geomType;
+
+                if( inertia != NULL )
+                    *inertia = temp_inertia*mass;
+                if( centerOfMass != NULL )
+                    *centerOfMass = temp_centerOfMass;
+            }
+            else if (inertia != NULL || centerOfMass != NULL )
+            {
+                Vector3 temp_inertia, temp_centerOfMass;
+                rval-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+                if( inertia != NULL )
+                    *inertia = temp_inertia*mass;
+                if( centerOfMass != NULL )
+                    *centerOfMass = temp_centerOfMass;
+            }
+        }
+
+        return rval;
+    }
+
+
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createCollisionFromEntity(Ogre::Entity* entity,
+        const GeometryType&amp; geomType,
+        const Ogre::String&amp; animName,
+        const Ogre::Vector3 &amp;offset,
+        const Ogre::Quaternion &amp;orientation,
+        const Ogre::Real mass,
+        Ogre::Vector3* inertia,
+        Ogre::Vector3* centerOfMass,
+        bool nocache)
+    {
+        // bounding box of the mesh
+        Ogre::AxisAlignedBox aabb(entity-&gt;getBoundingBox());
+        // apply scale if attached to a node (like in OgreNewt for convexhull)
+        Ogre::Vector3 scale = Ogre::Vector3::UNIT_SCALE;
+        if( entity-&gt;getParentNode() )
+        {
+            scale = entity-&gt;getParentNode()-&gt;getScale();
+            aabb.scale(scale);
+        }
+
+        // type for the collision primitiv (can change internally here)
+        bool forceBox (false);
+
+        // result value
+        CollisionPtr rval;
+        ConvexCollisionPtr rvalAsConvexCollision; // store pointer to ConvexCollision, so we don't need to cast
+                                                  // this also indicates, that it is possible to calculate inertia/centerOfMass
+
+        // size check (if object is too small, it falls back to a box primitiv
+        if (checkSize(aabb) == false )
+        {
+            correctSize(aabb);
+            LOG_MESSAGE(Logger::CORE, &quot; Entity '&quot;+entity-&gt;getName()+
+                &quot;' is too small, using 'box' instead of primitiv '&quot;+
+                PhysicsManager::convertGeometryTypeToString(geomType));
+            forceBox = true;
+        }
+
+
+        if( geomType == GT_MESH )
+        {
+            if( offset != Ogre::Vector3::ZERO || orientation != Ogre::Quaternion::IDENTITY )
+            {
+                LOG_WARNING(Logger::CORE, &quot; Cannot set collision offset or orientation when using mesh-collision (entity: '&quot; +
+                        entity-&gt;getName()+&quot;')!&quot;);
+            }
+            if( inertia || centerOfMass )
+            {
+                LOG_WARNING(Logger::CORE, &quot; Cannot calculate inertia or center of mass when using mesh-collision (entity: '&quot; +
+                        entity-&gt;getName()+&quot;')!&quot;);
+            }
+        }
+
+
+        MeshCollisionCacheMap::iterator meshCacheIt = mMeshCollisionsCache.end();
+        ConvexCollisionCacheMap::iterator convexCacheIt = mConvexCollisionsCache.end();
+
+        // check if we can reuse a cached collision
+        if( !nocache )
+        {
+            // use meshcollisionscache
+            if( geomType == GT_MESH &amp;&amp; !forceBox )
+            {
+                StringVector index(entity-&gt;getMesh()-&gt;getName() + animName, scale);
+                std::pair&lt;MeshCollisionCacheMap::iterator,bool&gt; iterBoolPair = mMeshCollisionsCache.insert(std::make_pair(index, MeshCollisionCacheObject()));
+                meshCacheIt = iterBoolPair.first;
+                if( !iterBoolPair.second )
+                {
+                    // there was already an element -- so we can reuse it
+
+                    LOG_DEBUG(Logger::CORE, &quot;Reused collision for entity '&quot; + entity-&gt;getName() + &quot;' (mesh: '&quot;
+                            + entity-&gt;getMesh()-&gt;getName() + &quot;', animation: '&quot; + animName + &quot;').&quot;);
+                    rval = iterBoolPair.first-&gt;second.col;
+
+                    return rval;
+                }
+            }
+            // use convexcollisionscache
+            else if( !forceBox )
+            {
+                Ogre::String index(entity-&gt;getMesh()-&gt;getName() + animName);
+                std::pair&lt;ConvexCollisionCacheMap::iterator,bool&gt; iterBoolPair = mConvexCollisionsCache.insert(std::make_pair(index, ConvexCollisionCacheObject()));
+                convexCacheIt = iterBoolPair.first;
+                if( !iterBoolPair.second )
+                {
+                    // there was already an element, check type, the size, offset etc if we can use it
+                    if( geomType != convexCacheIt-&gt;second.type )
+                    {
+                        LOG_MESSAGE(Logger::CORE, &quot;Performance warning: trying to create a collision for entity '&quot;+entity-&gt;getName()+&quot;' with animation '&quot;+
+                                animName+&quot;' with geometry-type '&quot;+PhysicsManager::convertGeometryTypeToString(geomType)+
+                                &quot;'. There's already a collision with type '&quot;+PhysicsManager::convertGeometryTypeToString(convexCacheIt-&gt;second.type)+&quot;'!&quot;);
+                    }
+                    else if( scale == convexCacheIt-&gt;second.scale &amp;&amp; offset == convexCacheIt-&gt;second.offset &amp;&amp; orientation == convexCacheIt-&gt;second.orientation )
+                    {
+                        // everything fine, reuse it
+                        rval = convexCacheIt-&gt;second.col;
+
+                        if( inertia != NULL )
+                            *inertia = convexCacheIt-&gt;second.inertia;
+                        if( centerOfMass != NULL )
+                            *centerOfMass = convexCacheIt-&gt;second.centerOfMass;
+
+                        LOG_DEBUG(Logger::CORE, &quot;Reused collision for entity '&quot; + entity-&gt;getName() + &quot;' (mesh: '&quot;
+                            + entity-&gt;getMesh()-&gt;getName() + &quot;', animation: '&quot; + animName + &quot;').&quot;);
+
+                        return rval;
+                    }
+                    else if( geomType == GT_CONVEXHULL ) // for simple types just use create a new collision
+                    {
+                        // we need to rescale (or change offset or orientation)
+                        // the old transformation
+                        Ogre::Matrix4 oldInvTransformation;
+                        oldInvTransformation.makeInverseTransform(convexCacheIt-&gt;second.offset, convexCacheIt-&gt;second.scale, convexCacheIt-&gt;second.orientation);
+                        // the new transformation
+                        Ogre::Matrix4 newTransformation;
+                        newTransformation.makeTransform(offset, scale, orientation);
+
+                        // the needed transformation from old to new:
+                        Ogre::Matrix4 transformation = oldInvTransformation*newTransformation;
+
+                        OgreNewt::ConvexModifierCollision *convexModCol = new OgreNewt::ConvexModifierCollision(
+                                PhysicsManager::getSingleton()._getNewtonWorld(),convexCacheIt-&gt;second.col);
+                        convexModCol-&gt;setScalarMatrix(transformation);
+
+                        // set the convexcollision-ptr, so centerOfMass and inertia can be calculated
+                        rval = OgreNewt::ConvexCollisionPtr(convexModCol);
+
+
+                        LOG_DEBUG(Logger::CORE, &quot;Reused collision for entity '&quot; + entity-&gt;getName() + &quot;' (mesh: '&quot;
+                                + entity-&gt;getMesh()-&gt;getName() + &quot;', animation: '&quot; + animName + &quot;') with a ConvexModifierCollision.&quot;);
+
+                        // calculate inertia / centerOfMass if needed
+                        if (inertia != NULL || centerOfMass != NULL )
+                        {
+                            Vector3 temp_inertia, temp_centerOfMass;
+                            rvalAsConvexCollision-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+                            if( inertia != NULL )
+                                *inertia = temp_inertia*mass;
+                            if( centerOfMass != NULL )
+                                *centerOfMass = temp_centerOfMass;
+                        }
+
+                        return rval;
+                    }
+                }
+            }
+        }
+
+		/* differentiate between the different collision primitives, because they all
+		   need different offset and probably different orientation values.
+		   Newton SDK is really nifty and helps here, because we can shift the origin
+		   of the coordinate system of the primitiv we create into any position we
+		   desire. Actually this is the bottom middle of our mesh - as the meshes are
+		   always constructed like that.
+	    */
+        if (geomType == GT_BOX || forceBox == true)
+        {
+            rvalAsConvexCollision = createBox(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
+        }
+        else if (geomType == GT_PYRAMID)
+        {
+            rvalAsConvexCollision = createPyramid(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
+        }
+        else if (geomType == GT_SPHERE)
+        {
+            rvalAsConvexCollision = createSphere(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
+        }
+        else if (geomType == GT_ELLIPSOID)
+        {
+            rvalAsConvexCollision = createEllipsoid(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
+        }
+        else if (geomType == GT_CAPSULE)
+        {
+            rvalAsConvexCollision = createCapsule(aabb, offset, orientation);
+            rval = rvalAsConvexCollision;
+        }
+        else if (geomType == GT_CONVEXHULL)
+        {
+            rvalAsConvexCollision = createConvexHull(entity, offset, orientation);
+            rval = rvalAsConvexCollision;
+        }
+        else if (geomType == GT_MESH)
+        {
+            rval = createMesh( entity, animName, nocache );
+
+            if( meshCacheIt != mMeshCollisionsCache.end() )
+                meshCacheIt-&gt;second.col = rval;
+        }
+        else
+        {
+            Throw(IllegalArgumentException, &quot;unknown geometry type.&quot;);
+        }
+
+
+        if ( rval == NULL )
+        {
+            LOG_WARNING(Logger::CORE, &quot; creating collision primitiv '&quot;+
+                PhysicsManager::convertGeometryTypeToString(geomType)+&quot;' for Entity '&quot;+
+                entity-&gt;getName()+&quot;' failed.&quot;);
+
+            // delete cacheobject
+            if( meshCacheIt != mMeshCollisionsCache.end() )
+            {
+                mMeshCollisionsCache.erase( meshCacheIt );
+            }
+            if( convexCacheIt != mConvexCollisionsCache.end() )
+            {
+                mConvexCollisionsCache.erase( convexCacheIt );
+            }
+        }
+        else
+        {
+            LOG_DEBUG(Logger::CORE, &quot; collision primitiv '&quot;+
+                PhysicsManager::convertGeometryTypeToString(geomType)+&quot;' created for Entity '&quot;+
+                entity-&gt;getName()+&quot;'&quot;);
+        }
+
+        // calculate inertia / centerOfMass if requested
+        // and save collision in cache
+        if( rvalAsConvexCollision )
+        {
+            if( convexCacheIt != mConvexCollisionsCache.end() )
+            {
+                // save collision in cache
+                Vector3 temp_inertia, temp_centerOfMass;
+                rvalAsConvexCollision-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+
+                convexCacheIt-&gt;second.col = rvalAsConvexCollision;
+                convexCacheIt-&gt;second.scale = scale;
+                convexCacheIt-&gt;second.offset = offset;
+                convexCacheIt-&gt;second.orientation = orientation;
+                convexCacheIt-&gt;second.inertia = temp_inertia;
+                convexCacheIt-&gt;second.centerOfMass = temp_centerOfMass;
+                convexCacheIt-&gt;second.type = geomType;
+
+                if( inertia != NULL )
+                    *inertia = temp_inertia*mass;
+                if( centerOfMass != NULL )
+                    *centerOfMass = temp_centerOfMass;
+            }
+            else if (inertia != NULL || centerOfMass != NULL )
+            {
+                Vector3 temp_inertia, temp_centerOfMass;
+                rvalAsConvexCollision-&gt;calculateInertialMatrix(temp_inertia, temp_centerOfMass);
+                if( inertia != NULL )
+                    *inertia = temp_inertia*mass;
+                if( centerOfMass != NULL )
+                    *centerOfMass = temp_centerOfMass;
+            }
+        }
+
+        return rval;
+    }
+
+
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createBox(const Ogre::AxisAlignedBox&amp; aabb,
+            const Ogre::Vector3 &amp;offset,
+            const Ogre::Quaternion &amp;orientation)
+    {
+        // offset relative to center
+        Ogre::Vector3 offsetInGlobalSpace = offset + aabb.getCenter();
+
+        // a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            aabb.getSize(), orientation, offsetInGlobalSpace));
+
+       return rval;
+    }
+
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createPyramid(const Ogre::AxisAlignedBox&amp; aabb,
+            const Ogre::Vector3 &amp;offset,
+            const Ogre::Quaternion &amp;orientation)
+    {
+        // offset relative to center
+        Ogre::Vector3 offsetInGlobalSpace = offset + aabb.getCenter();
+
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            aabb.getSize(), orientation, offsetInGlobalSpace));
+
+       return rval;
+    }
+
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createSphere(const Ogre::AxisAlignedBox&amp; aabb,
+            const Ogre::Vector3 &amp;offset,
+            const Ogre::Quaternion &amp;orientation)
+    {
+        // offset relative to center
+        Ogre::Vector3 offsetInGlobalSpace = offset + aabb.getCenter();
+
+        Ogre::Vector3 size = aabb.getSize();
+        // calculate the maximum radius needed to include 'everything'
+        double radius = std::max(size.x, std::max(size.y, size.z)) / 2.0;
+ 
+        // a sphere primitiv has got its coordinate system at its center, so shift it with radius
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            Vector3(radius, radius, radius), orientation, offsetInGlobalSpace));
+ 
+       return rval;
+    }
+
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createEllipsoid(const Ogre::AxisAlignedBox&amp; aabb,
+            const Ogre::Vector3 &amp;offset,
+            const Ogre::Quaternion &amp;orientation)
+    {
+        // offset relative to center
+        Ogre::Vector3 offsetInGlobalSpace = offset + aabb.getCenter();
+
+        Ogre::Vector3 size = aabb.getSize();
+        // set the size x/z values to the maximum
+        Vector3 s(size/2.0);
+        s.x = std::max(s.x, s.z);
+        s.z = s.x;
+
+        // an ellipsoid primitiv has got its coordinate system at its center, so shift it with radius
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            s, orientation, offsetInGlobalSpace));
+
+       return rval;
+    }
+
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createCapsule(const Ogre::AxisAlignedBox&amp; aabb,
+            const Ogre::Vector3 &amp;offset,
+            const Ogre::Quaternion &amp;orientation)
+    {
+        // offset relative to center
+        Ogre::Vector3 offsetInGlobalSpace = offset + aabb.getCenter();
+        // @todo: fixme: this is a semi ugly fix - because the orientation should be set by the loader
+        //object_orientation.FromAngleAxis(Degree(90), Vector3::UNIT_Z);
+
+        Ogre::Vector3 size = aabb.getSize();
+
+        double radius = std::max(size.x, size.z) / 2.0;
+		double height = size.y;
+
+        // an capsule primitiv has got its coordinate system at its center, so shift it with radius
+        // additionally it is x axis aligned, so rotate it 90 degrees around z axis
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::Capsule(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            radius, height, orientation, offsetInGlobalSpace));
+
+        return rval;
+    }
+
+
+
+    OgreNewt::ConvexCollisionPtr PhysicsCollisionFactory::createConvexHull(
+            Ogre::Entity* entity,
+            const Ogre::Vector3 &amp;offset,
+            const Ogre::Quaternion &amp;orientation)
+    {
+        Ogre::Vector3 offsetInGlobalSpace = offset;
+
+        // calculate the convex hull of the animated mesh
+        OgreNewt::ConvexCollisionPtr rval(new OgreNewt::CollisionPrimitives::ConvexHull(
+                    PhysicsManager::getSingleton()._getNewtonWorld(),
+                    entity, orientation, offsetInGlobalSpace));
+
+        return rval;
+    }
+
+
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::loadFromFile(const Ogre::String&amp; filename)
+    {
+        OgreNewt::CollisionPtr rval;
+        Ogre::String fullfilename = mCachePathName+filename;
+        FILE* pFile = fopen(fullfilename.c_str(), &quot;r&quot; );
+        if( pFile )
+        {
+            Ogre::DataStreamPtr streamPtr( new Ogre::FileHandleDataStream( pFile ) );
+            rval = mCollisionSerializer.importCollision( streamPtr, PhysicsManager::getSingleton()._getNewtonWorld() );
+
+            if( rval )
+            {
+                LOG_DEBUG(Logger::CORE, &quot;Loaded collision from file '&quot; + filename + &quot;'.&quot;);
+            }
+        }
+
+        return rval;
+    }
+
+
+
+    void PhysicsCollisionFactory::saveToFile(OgreNewt::CollisionPtr col, const Ogre::String&amp; filename)
+    {
+        mCollisionSerializer.exportCollision(col, mCachePathName + filename);
+    }
+
+
+
+    OgreNewt::CollisionPtr PhysicsCollisionFactory::createMesh( Ogre::Entity* entity, const Ogre::String&amp; animName, bool nocache )
+    {
+        OgreNewt::CollisionPtr rval;
+        Ogre::String filename;
+
+        if( !nocache )
+        {
+            Ogre::Vector3 scale(Ogre::Vector3::UNIT_SCALE);
+            if( entity-&gt;getParentNode() )
+                scale = entity-&gt;getParentNode()-&gt;getScale();
+
+            filename = entity-&gt;getMesh()-&gt;getName() + animName + Ogre::StringConverter::toString(scale) + &quot;.collision&quot;;
+
+            // check date of cache file and mesh
+            time_t meshFileModified = 
+                Ogre::ResourceGroupManager::getSingleton().resourceModifiedTime(
+                        entity-&gt;getMesh()-&gt;getGroup(),
+                        entity-&gt;getMesh()-&gt;getName());
+
+#if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
+            fs::path cacheFilePath( mCachePathName+filename, fs::portable_posix_name);
+#else
+            fs::path cacheFilePath( mCachePathName+filename );
+#endif
+
+            time_t cacheFileModified = 0;
+            if( fs::exists(cacheFilePath) )
+                cacheFileModified = fs::last_write_time(cacheFilePath);
+
+
+            if( cacheFileModified &gt; meshFileModified )        
+                rval = loadFromFile( filename );
+        }
+
+
+        if( !rval )
+        {
+            rval = OgreNewt::CollisionPtr( new OgreNewt::CollisionPrimitives::TreeCollision(
+                        PhysicsManager::getSingleton()._getNewtonWorld(),
+                        entity, true ));
+
+            if( !nocache )
+            {
+                saveToFile(rval, filename );
+            }
+        }
+
+        return rval;
+    }
+
+
+
+    PhysicsCollisionFactory::StringVector::StringVector(const Ogre::String&amp; str, const Ogre::Vector3&amp; vec)
+    {
+        setString(str);
+        setVector(vec);
+    }
+    
+    void PhysicsCollisionFactory::StringVector::setString(const Ogre::String&amp; str)
+    {
+        mStr = str;
+    }
+    
+    void PhysicsCollisionFactory::StringVector::setVector(const Ogre::Vector3&amp; vec)
+    {
+        mVec = vec;
+    }
+    
+    const Ogre::String&amp; PhysicsCollisionFactory::StringVector::getString() const
+    {
+        return mStr;
+    }
+    
+    const Ogre::Vector3&amp; PhysicsCollisionFactory::StringVector::getVector() const
+    {
+        return mVec;
+    }
+
+    bool PhysicsCollisionFactory::StringVector::operator==(const PhysicsCollisionFactory::StringVector&amp; strVec) const
+    {
+        if( mStr != strVec.mStr )
+            return false;
+
+        Ogre::Vector3 diff = mVec - strVec.mVec;
+        if( abs(diff.x) &gt; 0.01 )
+            return false;
+        if( abs(diff.y) &gt; 0.01 )
+            return false;
+        if( abs(diff.z) &gt; 0.01 )
+            return false;
+
+        return true;
+    }
+
+    bool PhysicsCollisionFactory::StringVector::operator&lt;(const PhysicsCollisionFactory::StringVector&amp; strVec) const
+    {
+        int strCompare = mStr.compare(strVec.mStr);
+        // @todo: use a hash or so
+        if( strCompare == 0 ) // strings are the same
+        {
+            // compare vectors
+            Ogre::Vector3 diff = mVec - strVec.mVec;
+            if( diff.x &lt; -0.01 )
+                return true;
+            if( diff.x &gt; 0.01 )
+                return false;
+            if( diff.y &lt; -0.01 )
+                return true;
+            if( diff.y &gt; 0.01 )
+                return false;
+            if( diff.y &lt; -0.01 )
+                return true;
+
+            return false;
+        }
+        
+        return strCompare &lt; 0;
+    }
+
+
+}
+

Modified: rl/trunk/engine/ui/src/CutsceneControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/CutsceneControlState.cpp	2009-05-22 22:18:33 UTC (rev 4940)
+++ rl/trunk/engine/ui/src/CutsceneControlState.cpp	2009-05-24 17:05:43 UTC (rev 4941)
@@ -1,118 +1,125 @@
-/*
-* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-#include &quot;stdinc.h&quot; //precompiled header
-
-#include &quot;CutsceneControlState.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;Actor.h&quot;
-#include &quot;CameraObject.h&quot;
-#include &quot;CommandMapper.h&quot;
-#include &quot;GameObject.h&quot;
-#include &quot;PhysicalThing.h&quot;
-
-using namespace Ogre;
-
-namespace rl {
-
-	CutsceneControlState::CutsceneControlState(CommandMapper* cmdMapper,
-        Actor* camera) : ControlState(cmdMapper, camera, NULL, CST_CUTSCENE),
-        mTarget(NULL)
-	{
-	}
-
-	CutsceneControlState::~CutsceneControlState()
-	{
-	}
-
-    void CutsceneControlState::pause()
-    {
-		mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
-    }
-
-    void CutsceneControlState::resume()
-    {
-		mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
-		Camera* ogreCam = static_cast&lt;Camera*&gt;(mCameraActor-&gt;_getMovableObject());
-		ogreCam-&gt;setFixedYawAxis(true);
-		mCameraActor-&gt;_getSceneNode()-&gt;setFixedYawAxis(true);
-    }
-
-	void CutsceneControlState::run(Real elapsedTime)
-	{
-	    CameraPosition pos = getBestCameraPosition();
-	    switch (pos.type)
-	    {
-	    case CPT_FIXED:
-	        setCameraPosition(pos.position);
-	        setCameraOrientation(pos.orientation1);
-	        break;
-	    case CPT_ROTATING:
-	        setCameraPosition(pos.position);
-	        lookAt(mTarget-&gt;getPosition());
-	        break;
-	    }
-	}
-
-	void CutsceneControlState::setCameraTarget(GameObject* target)
-	{
-	    mTarget = target;
-	}
-
-    void CutsceneControlState::setCameraPosition(const Vector3&amp; pos)
-    {
-        mCameraActor-&gt;setPosition(pos);
-    }
-
-    void CutsceneControlState::setCameraOrientation(const Quaternion&amp; orient)
-    {
-        mCameraActor-&gt;setOrientation(orient);
-    }
-
-    void CutsceneControlState::lookAt(const Vector3&amp; point)
-    {
-        dynamic_cast&lt;Camera*&gt;(mCameraActor-&gt;getControlledObject()-&gt;getMovableObject())
-            -&gt;lookAt(point);
-    }
-
-    CameraPosition CutsceneControlState::getBestCameraPosition() const
-    {
-        if (mPositions.empty())
-        {
-            CameraPosition nullPos = {CPT_FIXED, Vector3::ZERO, Quaternion::IDENTITY, Quaternion::IDENTITY};
-            return nullPos;
-        }
-        return *mPositions.begin();
-    }
-
-    void CutsceneControlState::addCamera(const Vector3&amp; position, const Quaternion&amp; orientation)
-    {
-        CameraPosition cpos = {CPT_FIXED, position, orientation, orientation};
-        mPositions.push_back(cpos);
-    }
-
-    void CutsceneControlState::addCamera(const Vector3&amp; position, const Quaternion&amp; orientation1,
-            const Quaternion&amp; orientation2)
-    {
-        CameraPosition cpos = {CPT_ROTATING, position, orientation1, orientation2};
-        mPositions.push_back(cpos);
-    }
-
-    void CutsceneControlState::clearCameras()
-    {
-        mPositions.clear();
-    }
-}
+/*
+* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+#include &quot;stdinc.h&quot; //precompiled header
+
+#include &quot;CutsceneControlState.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;Actor.h&quot;
+#include &quot;CameraObject.h&quot;
+#include &quot;CommandMapper.h&quot;
+#include &quot;GameObject.h&quot;
+#include &quot;PhysicalThing.h&quot;
+
+using namespace Ogre;
+using namespace std;
+
+namespace rl {
+
+	CutsceneControlState::CutsceneControlState(CommandMapper* cmdMapper,
+        Actor* camera) : ControlState(cmdMapper, camera, NULL, CST_CUTSCENE),
+        mTarget(NULL)
+	{
+	}
+
+	CutsceneControlState::~CutsceneControlState()
+	{
+	}
+
+    void CutsceneControlState::pause()
+    {
+		mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
+    }
+
+    void CutsceneControlState::resume()
+    {
+		mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
+		Camera* ogreCam = static_cast&lt;Camera*&gt;(mCameraActor-&gt;_getMovableObject());
+		ogreCam-&gt;setFixedYawAxis(true);
+		mCameraActor-&gt;_getSceneNode()-&gt;setFixedYawAxis(true);
+    }
+
+	void CutsceneControlState::run(Real elapsedTime)
+	{
+	    CameraPosition pos = getBestCameraPosition();
+	    switch (pos.type)
+	    {
+	    case CPT_FIXED:
+	        setCameraPosition(pos.position);
+	        setCameraOrientation(pos.orientation1);
+	        break;
+	    case CPT_ROTATING:
+	        setCameraPosition(pos.position);
+	        lookAt(mTarget-&gt;getPosition());
+	        break;
+	    }
+	}
+
+	void CutsceneControlState::setCameraTarget(GameObject* target)
+	{
+	    mTarget = target;
+	}
+
+    void CutsceneControlState::setCameraPosition(const Vector3&amp; pos)
+    {
+        mCameraActor-&gt;setPosition(pos);
+    }
+
+    void CutsceneControlState::setCameraOrientation(const Quaternion&amp; orient)
+    {
+        mCameraActor-&gt;setOrientation(orient);
+    }
+
+    void CutsceneControlState::lookAt(const Vector3&amp; point)
+    {
+        dynamic_cast&lt;Camera*&gt;(mCameraActor-&gt;getControlledObject()-&gt;getMovableObject())
+            -&gt;lookAt(point);
+    }
+
+    CameraPosition CutsceneControlState::getBestCameraPosition() const
+    {
+        if (mPositions.empty())
+        {
+            CameraPosition nullPos = {CPT_FIXED, Vector3::ZERO, Quaternion::IDENTITY, Quaternion::IDENTITY};
+            return nullPos;
+        }
+        
+        for (vector&lt;CameraPosition&gt;::const_iterator it = mPositions.begin(), end = mPositions.end(); it != end; ++it)
+        {
+            
+        }
+        
+        return *mPositions.begin();
+    }
+
+    void CutsceneControlState::addCamera(const Vector3&amp; position, const Quaternion&amp; orientation)
+    {
+        CameraPosition cpos = {CPT_FIXED, position, orientation, orientation};
+        mPositions.push_back(cpos);
+    }
+
+    void CutsceneControlState::addCamera(const Vector3&amp; position, const Quaternion&amp; orientation1,
+            const Quaternion&amp; orientation2)
+    {
+        CameraPosition cpos = {CPT_ROTATING, position, orientation1, orientation2};
+        mPositions.push_back(cpos);
+    }
+
+    void CutsceneControlState::clearCameras()
+    {
+        mPositions.clear();
+    }
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001996.html">[Dsa-hl-svn] r4940 - in rl/branches/persistence2:	editors/Lockenwickler editors/Lockenwickler/src	editors/Lockenwickler/src/media editors/Lockenwickler/src/media/help	editors/Lockenwickler/src/media/icons	editors/Lockenwickler/src/media/terrain	editors/Lockenwickler/src/media/terrain/brushes	editors/Lockenwickler/ui files engine/ai/include	engine/ai/src engine/core engine/core/include engine/core/src	engine/rules/include engine/rules/src engine/script/src	engine/script/swig engine/ui/include engine/ui/src
</A></li>
	<LI>Next message: <A HREF="001998.html">[Dsa-hl-svn] r4942 - dependencies/OgreNewt/Mac/OgreNewt.xcodeproj
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1997">[ date ]</a>
              <a href="thread.html#1997">[ thread ]</a>
              <a href="subject.html#1997">[ subject ]</a>
              <a href="author.html#1997">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
