<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4933 - in rl/trunk/engine: ai/include ai/src	script/swig ui/include ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4933%20-%20in%20rl/trunk/engine%3A%20ai/include%20ai/src%0A%09script/swig%20ui/include%20ui/src&In-Reply-To=%3C200905202004.n4KK42kQ016387%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001988.html">
   <LINK REL="Next"  HREF="001990.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4933 - in rl/trunk/engine: ai/include ai/src	script/swig ui/include ui/src</H1>
    <B>melven at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4933%20-%20in%20rl/trunk/engine%3A%20ai/include%20ai/src%0A%09script/swig%20ui/include%20ui/src&In-Reply-To=%3C200905202004.n4KK42kQ016387%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4933 - in rl/trunk/engine: ai/include ai/src	script/swig ui/include ui/src">melven at mail.berlios.de
       </A><BR>
    <I>Wed May 20 22:04:02 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001988.html">[Dsa-hl-svn] r4932 - in rl/trunk/engine: core/src ui/include ui/src
</A></li>
        <LI>Next message: <A HREF="001990.html">[Dsa-hl-svn] r4934 - in modules: common/scripts common/scripts/jobs	regressiontest/scripts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1989">[ date ]</a>
              <a href="thread.html#1989">[ thread ]</a>
              <a href="subject.html#1989">[ subject ]</a>
              <a href="author.html#1989">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: melven
Date: 2009-05-20 22:03:56 +0200 (Wed, 20 May 2009)
New Revision: 4933

Modified:
   rl/trunk/engine/ai/include/Dialog.h
   rl/trunk/engine/ai/include/DialogLoader.h
   rl/trunk/engine/ai/include/DialogLoaderImpl.h
   rl/trunk/engine/ai/include/DialogManager.h
   rl/trunk/engine/ai/include/DialogParagraph.h
   rl/trunk/engine/ai/src/Dialog.cpp
   rl/trunk/engine/ai/src/DialogLoader.cpp
   rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
   rl/trunk/engine/ai/src/DialogManager.cpp
   rl/trunk/engine/ai/src/DialogParagraph.cpp
   rl/trunk/engine/script/swig/RlAi.swig
   rl/trunk/engine/script/swig/RlCore.swig
   rl/trunk/engine/ui/include/DialogControlState.h
   rl/trunk/engine/ui/include/DialogController.h
   rl/trunk/engine/ui/src/DialogControlState.cpp
Log:
-using the typedef CreatureList instead of std::list&lt;Creature*&gt;
-some fixes in swig


Modified: rl/trunk/engine/ai/include/Dialog.h
===================================================================
--- rl/trunk/engine/ai/include/Dialog.h	2009-05-20 00:09:27 UTC (rev 4932)
+++ rl/trunk/engine/ai/include/Dialog.h	2009-05-20 20:03:56 UTC (rev 4933)
@@ -19,10 +19,10 @@
 #include &quot;AiPrerequisites.h&quot;
 
 #include &quot;Properties.h&quot;
+#include &quot;Creature.h&quot;
 
 namespace rl
 {
-    class Creature;
     class DialogOption;
     class DialogResponse;
     class DialogVariable;
@@ -47,12 +47,12 @@
         virtual PropertyKeys getAllPropertyKeys() const;
 
         void addParticipant(const CeGuiString&amp; personId, Creature* person);
-        std::list&lt;Creature*&gt; getParticipants() const;
+        const CreatureList&amp; getParticipants() const;
         Creature* getParticipant(const CeGuiString&amp; id) const;
 
     private:
         DialogResponse* mDialogStart;
-        std::list&lt;Creature*&gt; mAllParticipants;
+        CreatureList mAllParticipants;
         std::map&lt;CeGuiString, Creature*&gt; mParticipantMap;
         std::map&lt;Ogre::String, DialogVariable*&gt; mVariables;
         PropertyRecord mPropertyVariables;

Modified: rl/trunk/engine/ai/include/DialogLoader.h
===================================================================
--- rl/trunk/engine/ai/include/DialogLoader.h	2009-05-20 00:09:27 UTC (rev 4932)
+++ rl/trunk/engine/ai/include/DialogLoader.h	2009-05-20 20:03:56 UTC (rev 4933)
@@ -17,12 +17,11 @@
 #define __DialogLoader_H__
 
 #include &quot;AiPrerequisites.h&quot;
+#include &quot;Creature.h&quot;
 
-#include &lt;list&gt;
 
 namespace rl
 {
-	class Creature;
     class Dialog;
     class DialogLoaderImpl;
 
@@ -36,7 +35,7 @@
         virtual void parseScript(Ogre::DataStreamPtr&amp; stream, const Ogre::String&amp; groupName);
 		virtual Ogre::Real getLoadingOrder() const;
 
-		Dialog* createDialog(const Ogre::String&amp; name, const std::list&lt;Creature*&gt;&amp; participants) const;
+		Dialog* createDialog(const Ogre::String&amp; name, const CreatureList&amp; participants) const;
 
 	private:
         Ogre::StringVector mScriptPatterns;

Modified: rl/trunk/engine/ai/include/DialogLoaderImpl.h
===================================================================
--- rl/trunk/engine/ai/include/DialogLoaderImpl.h	2009-05-20 00:09:27 UTC (rev 4932)
+++ rl/trunk/engine/ai/include/DialogLoaderImpl.h	2009-05-20 20:03:56 UTC (rev 4933)
@@ -19,10 +19,10 @@
 
 #include &quot;Properties.h&quot;
 #include &quot;XmlProcessor.h&quot;
+#include &quot;Creature.h&quot;
 
 namespace rl
 {
-    class Creature;
     class Dialog;
     class DialogCondition;
     class DialogElement;
@@ -39,7 +39,7 @@
         DialogLoaderImpl();
         ~DialogLoaderImpl();
 
-        Dialog* createDialog(const Ogre::String&amp; name, const std::list&lt;Creature*&gt;&amp; participants) const;
+        Dialog* createDialog(const Ogre::String&amp; name, const CreatureList&amp; participants) const;
         void parseDialog(Ogre::DataStreamPtr&amp; stream, const Ogre::String&amp; groupName);
 
     private:
@@ -70,7 +70,7 @@
             DialogResponse* getResponse(const CeGuiString&amp; id) const;
 
             void setStartResponse(DialogResponse* response);
-            Dialog* createDialog(const std::list&lt;Creature*&gt;&amp; participants);
+            Dialog* createDialog(const CreatureList&amp; participants);
             void setProperty(const CeGuiString&amp; key, const Property&amp; value);
 
             void addParticipant(DialogParticipant* participant);

Modified: rl/trunk/engine/ai/include/DialogManager.h
===================================================================
--- rl/trunk/engine/ai/include/DialogManager.h	2009-05-20 00:09:27 UTC (rev 4932)
+++ rl/trunk/engine/ai/include/DialogManager.h	2009-05-20 20:03:56 UTC (rev 4933)
@@ -21,12 +21,12 @@
 #include &lt;list&gt;
 
 #include &quot;Properties.h&quot;
+#include &quot;Creature.h&quot;
 #include &quot;SaveGameData.h&quot;
 #include &quot;XmlProcessor.h&quot;
 
 namespace rl
 {
-    class Creature;
 	class Dialog;
 	class DialogLoader;
 
@@ -45,7 +45,7 @@
         ~DialogManager();
 
         Dialog* createDialog(const Ogre::String&amp; name, Creature* npc);
-        Dialog* createDialog(const Ogre::String&amp; name, const std::list&lt;Creature*&gt;&amp; npcs);
+        Dialog* createDialog(const Ogre::String&amp; name, const CreatureList&amp; npcs);
 
         virtual const Property getProperty(const CeGuiString&amp; key) const;
         virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
@@ -60,16 +60,16 @@
         class DialogConfiguration
         {
         public:
-            DialogConfiguration(const Ogre::String&amp; name, const std::list&lt;Creature*&gt;&amp; participants);
+            DialogConfiguration(const Ogre::String&amp; name, const CreatureList&amp; participants);
 
             const Ogre::String&amp; getName() const;
-            const std::list&lt;Creature*&gt;&amp; getParticipants() const;
+            const CreatureList&amp; getParticipants() const;
 
             bool operator==(const DialogConfiguration&amp;) const;
             bool operator&lt;(const DialogConfiguration&amp;) const;
         private:
             Ogre::String mDialogName;
-            std::list&lt;Creature*&gt; mParticipants;
+            CreatureList mParticipants;
         };
 
 

Modified: rl/trunk/engine/ai/include/DialogParagraph.h
===================================================================
--- rl/trunk/engine/ai/include/DialogParagraph.h	2009-05-20 00:09:27 UTC (rev 4932)
+++ rl/trunk/engine/ai/include/DialogParagraph.h	2009-05-20 20:03:56 UTC (rev 4933)
@@ -18,10 +18,10 @@
 #define __DialogParagraph_H__
 
 #include &quot;AiPrerequisites.h&quot;
+#include &quot;Creature.h&quot;
 
 namespace rl
 {
-    class Creature;
     class Dialog;
     class DialogElement;
     class DialogResponse;
@@ -39,7 +39,7 @@
         void _setParent(DialogElement* parent);
         virtual DialogResponse* getResponse() const;
         Creature* getSpeaker(Dialog* dialog) const;
-        std::list&lt;Creature*&gt; getListeners(Dialog* dialog) const;
+        CreatureList getListeners(Dialog* dialog) const;
 
     private:
         CeGuiString mText;

Modified: rl/trunk/engine/ai/src/Dialog.cpp
===================================================================
--- rl/trunk/engine/ai/src/Dialog.cpp	2009-05-20 00:09:27 UTC (rev 4932)
+++ rl/trunk/engine/ai/src/Dialog.cpp	2009-05-20 20:03:56 UTC (rev 4933)
@@ -100,7 +100,7 @@
         mAllParticipants.push_back(person);
     }
 
-    list&lt;Creature*&gt; Dialog::getParticipants() const
+    const CreatureList&amp; Dialog::getParticipants() const
     {
         return mAllParticipants;
     }

Modified: rl/trunk/engine/ai/src/DialogLoader.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoader.cpp	2009-05-20 00:09:27 UTC (rev 4932)
+++ rl/trunk/engine/ai/src/DialogLoader.cpp	2009-05-20 20:03:56 UTC (rev 4933)
@@ -50,7 +50,7 @@
         mLoaderImplementation-&gt;parseDialog(stream, groupName);
     }
 
-    Dialog* DialogLoader::createDialog(const Ogre::String&amp; name, const std::list&lt;Creature*&gt;&amp; participants) const
+    Dialog* DialogLoader::createDialog(const Ogre::String&amp; name, const CreatureList&amp; participants) const
     {
         return mLoaderImplementation-&gt;createDialog(name, participants);
     }

Modified: rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-05-20 00:09:27 UTC (rev 4932)
+++ rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-05-20 20:03:56 UTC (rev 4933)
@@ -81,7 +81,7 @@
         shutdownXml();
     }
 
-    Dialog* DialogLoaderImpl::createDialog(const String&amp; name, const std::list&lt;Creature*&gt;&amp; participants) const
+    Dialog* DialogLoaderImpl::createDialog(const String&amp; name, const CreatureList&amp; participants) const
     {
         std::map&lt;Ogre::String, DialogPrototype*&gt;::const_iterator it =
         mDialogs.find(name);
@@ -607,7 +607,7 @@
         return it-&gt;second;
     }
 
-    Dialog* DialogLoaderImpl::DialogPrototype::createDialog(const list&lt;Creature*&gt;&amp; participants)
+    Dialog* DialogLoaderImpl::DialogPrototype::createDialog(const CreatureList&amp; participants)
     {
         Dialog* dialog = new Dialog();
 
@@ -618,7 +618,7 @@
         bool found1stNpc = false;
         Party playerChars = PartyManager::getSingleton().getCharacters();
 
-        for (list&lt;Creature*&gt;::const_iterator itPart = participants.begin(); itPart != participants.end(); ++itPart)
+        for (CreatureList::const_iterator itPart = participants.begin(); itPart != participants.end(); ++itPart)
         {
             Creature* curCr = *itPart;
 

Modified: rl/trunk/engine/ai/src/DialogManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogManager.cpp	2009-05-20 00:09:27 UTC (rev 4932)
+++ rl/trunk/engine/ai/src/DialogManager.cpp	2009-05-20 20:03:56 UTC (rev 4933)
@@ -78,7 +78,7 @@
 
                 PropertyArray npcs;
 
-                for (list&lt;Creature*&gt;::const_iterator itNpc = it-&gt;first.getParticipants().begin();
+                for (CreatureList::const_iterator itNpc = it-&gt;first.getParticipants().begin();
                     itNpc != it-&gt;first.getParticipants().end(); ++itNpc)
                 {
                     npcs.push_back(GameObjectManager::getSingleton().toProperty(*itNpc));
@@ -133,15 +133,15 @@
 
     Dialog* DialogManager::createDialog(const Ogre::String&amp; name, Creature* npc)
     {
-        list&lt;Creature*&gt; npcs;
+        CreatureList npcs;
         npcs.push_back(npc);
 
         return createDialog(name, npcs);
     }
 
-    Dialog* DialogManager::createDialog(const Ogre::String&amp; name, const list&lt;Creature*&gt;&amp; npcs)
+    Dialog* DialogManager::createDialog(const Ogre::String&amp; name, const CreatureList&amp; npcs)
     {
-        list&lt;Creature*&gt; participants;
+        CreatureList participants;
 
         Party party = PartyManager::getSingleton().getCharacters();
         for (Party::const_iterator it = party.begin(); it != party.end(); ++it)
@@ -149,7 +149,7 @@
             participants.push_back(*it);
         }
 
-        for (list&lt;Creature*&gt;::const_iterator it = npcs.begin(); it != npcs.end(); ++it)
+        for (CreatureList::const_iterator it = npcs.begin(); it != npcs.end(); ++it)
         {
             participants.push_back(*it);
         }
@@ -178,7 +178,7 @@
     }
 
     DialogManager::DialogConfiguration::DialogConfiguration(const Ogre::String&amp; name,
-            const list&lt;Creature*&gt;&amp; participants)
+            const CreatureList&amp; participants)
         : mDialogName(name), mParticipants(participants)
     {
     }
@@ -188,7 +188,7 @@
         return mDialogName;
     }
 
-    const list&lt;Creature*&gt;&amp; DialogManager::DialogConfiguration::getParticipants() const
+    const CreatureList&amp; DialogManager::DialogConfiguration::getParticipants() const
     {
         return mParticipants;
     }

Modified: rl/trunk/engine/ai/src/DialogParagraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogParagraph.cpp	2009-05-20 00:09:27 UTC (rev 4932)
+++ rl/trunk/engine/ai/src/DialogParagraph.cpp	2009-05-20 20:03:56 UTC (rev 4933)
@@ -76,14 +76,14 @@
         return dialog-&gt;getParticipant(getPerson());
     }
 
-    list&lt;Creature*&gt; DialogParagraph::getListeners(Dialog* dialog) const
+    CreatureList DialogParagraph::getListeners(Dialog* dialog) const
     {
         Creature* speaker = getSpeaker(dialog);
 
-        list&lt;Creature*&gt; listeners;
+        CreatureList listeners;
 
-        list&lt;Creature*&gt; participants = dialog-&gt;getParticipants();
-        for (list&lt;Creature*&gt;::iterator it = participants.begin(), end = participants.end(); it != end; ++it)
+        CreatureList participants = dialog-&gt;getParticipants();
+        for (CreatureList::iterator it = participants.begin(), end = participants.end(); it != end; ++it)
         {
             if (*it != speaker)
             {

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2009-05-20 00:09:27 UTC (rev 4932)
+++ rl/trunk/engine/script/swig/RlAi.swig	2009-05-20 20:03:56 UTC (rev 4933)
@@ -301,8 +301,8 @@
     {
     public:
         static rl::DialogManager&amp; getSingleton();
-        rl::Dialog* createDialog(const Ogre::String&amp; name, rl::Creature* npc);
-        rl::Dialog* createDialog(const Ogre::String&amp; name, const std::list&lt;rl::Creature*&gt;&amp; npcs);
+        // rl::Dialog* createDialog(const Ogre::String&amp; name, rl::Creature* npc); // function overloading is not working correctly here in swig
+        rl::Dialog* createDialog(const Ogre::String&amp; name, const rl::CreatureList&amp; npcs);
     private:
         DialogManager();
     };

Modified: rl/trunk/engine/script/swig/RlCore.swig
===================================================================
--- rl/trunk/engine/script/swig/RlCore.swig	2009-05-20 00:09:27 UTC (rev 4932)
+++ rl/trunk/engine/script/swig/RlCore.swig	2009-05-20 20:03:56 UTC (rev 4933)
@@ -1,461 +1,469 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
- */
-
-
-namespace rl {
-/*
-%{
-static swig_type_info *GameAreaType_dynamic_cast(void **ptr) {
-    rl::GameAreaType *pGameAreaType = static_cast&lt;rl::GameAreaType *&gt;(*ptr);
-    
-    rl::GameSphereAreaType *pGameSphereAreaType = dynamic_cast&lt;rl::GameSphereAreaType*&gt;(pGameAreaType);
-    if (pGameSphereAreaType){
-      *ptr=pGameSphereAreaType;
-      return SWIGTYPE_p_rl__GameSphereAreaType;
-    }    
-    
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__GameAreaType, GameAreaType_dynamic_cast);
-*/
-
-
-%{
-static swig_type_info *BaseAnimation_dynamic_cast(void **ptr) {
-    rl::BaseAnimation *pBaseAnimation = static_cast&lt;rl::BaseAnimation *&gt;(*ptr);
-    
-    rl::FadeAnimation *pFadeAnimation = dynamic_cast&lt;rl::FadeAnimation*&gt;(pBaseAnimation);
-    if (pFadeAnimation){
-      *ptr=pFadeAnimation;
-      return SWIGTYPE_p_rl__FadeAnimation;
-    }    
-    rl::MeshAnimation *pMeshAnimation = dynamic_cast&lt;rl::MeshAnimation*&gt;(pBaseAnimation);
-    if (pMeshAnimation){
-      *ptr=pMeshAnimation;
-      return SWIGTYPE_p_rl__MeshAnimation;
-    }    
-    rl::TrackAnimation *pTrackAnimation = dynamic_cast&lt;rl::TrackAnimation*&gt;(pBaseAnimation);
-    if (pTrackAnimation){
-      *ptr=pTrackAnimation;
-      return SWIGTYPE_p_rl__TrackAnimation;
-    }  
-    
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__BaseAnimation, BaseAnimation_dynamic_cast);
-
-
-%{
-static swig_type_info *ActorControlledObject_dynamic_cast(void **ptr)
-{
-    rl::ActorControlledObject *pActorControlledObject =
-        static_cast&lt;rl::ActorControlledObject*&gt;(*ptr);
-
-    rl::MergeableMeshObject *pMergeableMeshObject=dynamic_cast&lt;rl::MergeableMeshObject*&gt;(pActorControlledObject);
-    if (pMergeableMeshObject) {
-        *ptr=pMergeableMeshObject;
-        return SWIGTYPE_p_rl__MergeableMeshObject;
-    }
-    rl::MeshObject *pMeshObject=dynamic_cast&lt;rl::MeshObject*&gt;(pActorControlledObject);
-    if (pMeshObject) {
-        *ptr=pMeshObject;
-        return SWIGTYPE_p_rl__MeshObject;
-    }
-    rl::CameraObject *pCameraObject=dynamic_cast&lt;rl::CameraObject*&gt;(pActorControlledObject);
-    if (pCameraObject) {
-        *ptr=pCameraObject;
-        return SWIGTYPE_p_rl__CameraObject;
-    }
-    rl::LightObject *pLightObject=dynamic_cast&lt;rl::LightObject*&gt;(pActorControlledObject);
-    if (pLightObject) {
-        *ptr=pLightObject;
-        return SWIGTYPE_p_rl__LightObject;
-    }
-    rl::ParticleSystemObject *pParticleSystemObject=dynamic_cast&lt;rl::ParticleSystemObject*&gt;(pActorControlledObject);
-    if (pParticleSystemObject) {
-        *ptr=pParticleSystemObject;
-        return SWIGTYPE_p_rl__ParticleSystemObject;
-    }
-    rl::SoundObject *pSoundObject=dynamic_cast&lt;rl::SoundObject*&gt;(pActorControlledObject);
-    if (pSoundObject) {
-        *ptr=pSoundObject;
-        return SWIGTYPE_p_rl__SoundObject;
-    }
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__ActorControlledObject, ActorControlledObject_dynamic_cast);
-
-%{
-static swig_type_info *Job_dynamic_cast(void **ptr) {
-    rl::Job *ppJob = static_cast&lt;rl::Job*&gt;(*ptr);
-      
-    
-    rl::PlayAnimationJob *pPlayAnimationJob = dynamic_cast&lt;rl::PlayAnimationJob*&gt;(ppJob);
-    if (pPlayAnimationJob){
-      *ptr=pPlayAnimationJob;
-      return SWIGTYPE_p_rl__PlayAnimationJob;
-    }    
-    rl::StartAnimationJob *pStartAnimationJob = dynamic_cast&lt;rl::StartAnimationJob*&gt;(ppJob);
-    if (pStartAnimationJob){
-      *ptr=pPlayAnimationJob;
-      return SWIGTYPE_p_rl__StartAnimationJob;
-    }    
-    rl::PlaySound3dJob *pPlaySound3dJob = dynamic_cast&lt;rl::PlaySound3dJob*&gt;(ppJob);
-    if (pPlaySound3dJob){
-      *ptr=pPlaySound3dJob;
-      return SWIGTYPE_p_rl__PlaySound3dJob;
-    }    
-    rl::PlaySound2dJob *pPlaySound2dJob = dynamic_cast&lt;rl::PlaySound2dJob*&gt;(ppJob);
-    if (pPlaySound2dJob){
-      *ptr=pPlaySound2dJob;
-      return SWIGTYPE_p_rl__PlaySound2dJob;
-    }
-    rl::JobQueue *pJobQueue = dynamic_cast&lt;rl::JobQueue*&gt;(ppJob);
-    if (pJobQueue) {
-      *ptr=pJobQueue;
-      return SWIGTYPE_p_rl__JobQueue;
-    }
-    rl::JobSet *pJobSet = dynamic_cast&lt;rl::JobSet*&gt;(ppJob);
-    if (pJobSet) {
-      *ptr=pJobSet;
-      return SWIGTYPE_p_rl__JobSet;
-    }
-    
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__Job, Job_dynamic_cast)
-
-class ActorManager {
-private:
-	ActorManager();
-public:
-	static ActorManager&amp; getSingleton(void);
-
-	rl::Actor* createParticleSystemActor(const Ogre::String&amp; name, const Ogre::String&amp; soundfile);
-    rl::Actor* createSoundStreamActor(const Ogre::String&amp; name, const Ogre::String&amp; soundfile);
-    rl::Actor* createSoundSampleActor(const Ogre::String&amp; name, const Ogre::String&amp; soundfile);
-    rl::Actor* createEmptyActor(const Ogre::String&amp; name);
-    rl::Actor* createLightActor(const Ogre::String&amp; name, rl::LightObject::LightTypes type );
-	rl::Actor* createMeshActor(const Ogre::String&amp; name, const Ogre::String&amp; meshname,
-		    rl::GeometryType geom = rl::GT_NONE,
-		    Ogre::Real mass = 0.0,
-		    bool mergeable = false);
-	rl::Actor* createBoxPrimitiveActor(const Ogre::String&amp; name,
-            const Ogre::Vector3&amp; minCorner, const Ogre::Vector3&amp; maxCorner,
-            const Ogre::String&amp; materialName = &quot;&quot;, Ogre::Real mass = 0.0);
-		    
-	//void createDebugActors();
-	    
-	rl::Actor* getActor(const Ogre::String&amp; name);
-	void destroyActor(rl::Actor* actor);
-    void destroyAllActors();
-};
-
-class World {
-public:	
-	enum FogMode { FOG_NONE, FOG_EXP, FOG_EXP2, FOG_LINEAR  };
-
-    virtual void setSkyBox (bool enable, const Ogre::String&amp; materialName, Ogre::Real distance=2500, bool drawFirst=true );
-    virtual void setSkyDome (bool enable, const Ogre::String&amp; materialName, Ogre::Real curvature=10, Ogre::Real tiling=8, Ogre::Real distance=4000, bool drawFirst=true );
-    virtual void setFog ( FogMode mode=FOG_NONE, const Ogre::ColourValue &amp;colour=Ogre::ColourValue::White, Ogre::Real expDensity=0.001, Ogre::Real linearStart=0.0, Ogre::Real linearEnd=1.0);
-    virtual FogMode getFogMode (void) const;
-    virtual const Ogre::ColourValue &amp; getFogColour (void) const;
-    virtual Ogre::Real getFogStart (void) const;
-    virtual Ogre::Real getFogEnd (void) const;	
-    virtual void setAmbientLight(Ogre::Real r, Ogre::Real g, Ogre::Real b);
-    virtual Ogre::Vector3 getStartPoint() const;
-    virtual void setCastShadows(bool);
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+
+namespace rl {
+/*
+%{
+static swig_type_info *GameAreaType_dynamic_cast(void **ptr) {
+    rl::GameAreaType *pGameAreaType = static_cast&lt;rl::GameAreaType *&gt;(*ptr);
+    
+    rl::GameSphereAreaType *pGameSphereAreaType = dynamic_cast&lt;rl::GameSphereAreaType*&gt;(pGameAreaType);
+    if (pGameSphereAreaType){
+      *ptr=pGameSphereAreaType;
+      return SWIGTYPE_p_rl__GameSphereAreaType;
+    }    
+    
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__GameAreaType, GameAreaType_dynamic_cast);
+*/
+
+
+%{
+static swig_type_info *BaseAnimation_dynamic_cast(void **ptr) {
+    rl::BaseAnimation *pBaseAnimation = static_cast&lt;rl::BaseAnimation *&gt;(*ptr);
+    
+    rl::FadeAnimation *pFadeAnimation = dynamic_cast&lt;rl::FadeAnimation*&gt;(pBaseAnimation);
+    if (pFadeAnimation){
+      *ptr=pFadeAnimation;
+      return SWIGTYPE_p_rl__FadeAnimation;
+    }    
+    rl::MeshAnimation *pMeshAnimation = dynamic_cast&lt;rl::MeshAnimation*&gt;(pBaseAnimation);
+    if (pMeshAnimation){
+      *ptr=pMeshAnimation;
+      return SWIGTYPE_p_rl__MeshAnimation;
+    }    
+    rl::TrackAnimation *pTrackAnimation = dynamic_cast&lt;rl::TrackAnimation*&gt;(pBaseAnimation);
+    if (pTrackAnimation){
+      *ptr=pTrackAnimation;
+      return SWIGTYPE_p_rl__TrackAnimation;
+    }  
+    
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__BaseAnimation, BaseAnimation_dynamic_cast);
+
+
+%{
+static swig_type_info *ActorControlledObject_dynamic_cast(void **ptr)
+{
+    rl::ActorControlledObject *pActorControlledObject =
+        static_cast&lt;rl::ActorControlledObject*&gt;(*ptr);
+
+    rl::MergeableMeshObject *pMergeableMeshObject=dynamic_cast&lt;rl::MergeableMeshObject*&gt;(pActorControlledObject);
+    if (pMergeableMeshObject) {
+        *ptr=pMergeableMeshObject;
+        return SWIGTYPE_p_rl__MergeableMeshObject;
+    }
+    rl::MeshObject *pMeshObject=dynamic_cast&lt;rl::MeshObject*&gt;(pActorControlledObject);
+    if (pMeshObject) {
+        *ptr=pMeshObject;
+        return SWIGTYPE_p_rl__MeshObject;
+    }
+    rl::CameraObject *pCameraObject=dynamic_cast&lt;rl::CameraObject*&gt;(pActorControlledObject);
+    if (pCameraObject) {
+        *ptr=pCameraObject;
+        return SWIGTYPE_p_rl__CameraObject;
+    }
+    rl::LightObject *pLightObject=dynamic_cast&lt;rl::LightObject*&gt;(pActorControlledObject);
+    if (pLightObject) {
+        *ptr=pLightObject;
+        return SWIGTYPE_p_rl__LightObject;
+    }
+    rl::ParticleSystemObject *pParticleSystemObject=dynamic_cast&lt;rl::ParticleSystemObject*&gt;(pActorControlledObject);
+    if (pParticleSystemObject) {
+        *ptr=pParticleSystemObject;
+        return SWIGTYPE_p_rl__ParticleSystemObject;
+    }
+    rl::SoundObject *pSoundObject=dynamic_cast&lt;rl::SoundObject*&gt;(pActorControlledObject);
+    if (pSoundObject) {
+        *ptr=pSoundObject;
+        return SWIGTYPE_p_rl__SoundObject;
+    }
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__ActorControlledObject, ActorControlledObject_dynamic_cast);
+
+%{
+static swig_type_info *Job_dynamic_cast(void **ptr) {
+    rl::Job *ppJob = static_cast&lt;rl::Job*&gt;(*ptr);
+      
+    
+    rl::PlayAnimationJob *pPlayAnimationJob = dynamic_cast&lt;rl::PlayAnimationJob*&gt;(ppJob);
+    if (pPlayAnimationJob){
+      *ptr=pPlayAnimationJob;
+      return SWIGTYPE_p_rl__PlayAnimationJob;
+    }    
+    rl::StartAnimationJob *pStartAnimationJob = dynamic_cast&lt;rl::StartAnimationJob*&gt;(ppJob);
+    if (pStartAnimationJob){
+      *ptr=pPlayAnimationJob;
+      return SWIGTYPE_p_rl__StartAnimationJob;
+    }    
+    rl::PlaySound3dJob *pPlaySound3dJob = dynamic_cast&lt;rl::PlaySound3dJob*&gt;(ppJob);
+    if (pPlaySound3dJob){
+      *ptr=pPlaySound3dJob;
+      return SWIGTYPE_p_rl__PlaySound3dJob;
+    }    
+    rl::PlaySound2dJob *pPlaySound2dJob = dynamic_cast&lt;rl::PlaySound2dJob*&gt;(ppJob);
+    if (pPlaySound2dJob){
+      *ptr=pPlaySound2dJob;
+      return SWIGTYPE_p_rl__PlaySound2dJob;
+    }
+    rl::JobQueue *pJobQueue = dynamic_cast&lt;rl::JobQueue*&gt;(ppJob);
+    if (pJobQueue) {
+      *ptr=pJobQueue;
+      return SWIGTYPE_p_rl__JobQueue;
+    }
+    rl::JobSet *pJobSet = dynamic_cast&lt;rl::JobSet*&gt;(ppJob);
+    if (pJobSet) {
+      *ptr=pJobSet;
+      return SWIGTYPE_p_rl__JobSet;
+    }
+    
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__Job, Job_dynamic_cast)
+
+class ActorManager {
+private:
+	ActorManager();
+public:
+	static ActorManager&amp; getSingleton(void);
+
+	rl::Actor* createParticleSystemActor(const Ogre::String&amp; name, const Ogre::String&amp; soundfile);
+    rl::Actor* createSoundStreamActor(const Ogre::String&amp; name, const Ogre::String&amp; soundfile);
+    rl::Actor* createSoundSampleActor(const Ogre::String&amp; name, const Ogre::String&amp; soundfile);
+    rl::Actor* createEmptyActor(const Ogre::String&amp; name);
+    rl::Actor* createLightActor(const Ogre::String&amp; name, rl::LightObject::LightTypes type );
+	rl::Actor* createMeshActor(const Ogre::String&amp; name, const Ogre::String&amp; meshname,
+		    rl::GeometryType geom = rl::GT_NONE,
+		    Ogre::Real mass = 0.0,
+		    bool mergeable = false);
+	rl::Actor* createBoxPrimitiveActor(const Ogre::String&amp; name,
+            const Ogre::Vector3&amp; minCorner, const Ogre::Vector3&amp; maxCorner,
+            const Ogre::String&amp; materialName = &quot;&quot;, Ogre::Real mass = 0.0);
+		    
+	//void createDebugActors();
+	    
+	rl::Actor* getActor(const Ogre::String&amp; name);
+	void destroyActor(rl::Actor* actor);
+    void destroyAllActors();
+};
+
+class World {
+public:	
+	enum FogMode { FOG_NONE, FOG_EXP, FOG_EXP2, FOG_LINEAR  };
+
+    virtual void setSkyBox (bool enable, const Ogre::String&amp; materialName, Ogre::Real distance=2500, bool drawFirst=true );
+    virtual void setSkyDome (bool enable, const Ogre::String&amp; materialName, Ogre::Real curvature=10, Ogre::Real tiling=8, Ogre::Real distance=4000, bool drawFirst=true );
+    virtual void setFog ( FogMode mode=FOG_NONE, const Ogre::ColourValue &amp;colour=Ogre::ColourValue::White, Ogre::Real expDensity=0.001, Ogre::Real linearStart=0.0, Ogre::Real linearEnd=1.0);
+    virtual FogMode getFogMode (void) const;
+    virtual const Ogre::ColourValue &amp; getFogColour (void) const;
+    virtual Ogre::Real getFogStart (void) const;
+    virtual Ogre::Real getFogEnd (void) const;	
+    virtual void setAmbientLight(Ogre::Real r, Ogre::Real g, Ogre::Real b);
+    virtual Ogre::Vector3 getStartPoint() const;
+    virtual void setCastShadows(bool);
     virtual void clearScene() = 0;
     virtual void initializeDefaultCamera() = 0;
-
-    void setShowBoundingBoxes( bool dis );
-};
-
-/// Alles was mit AreaKrams zu tun hat
-%apply SWIGTYPE *DYNAMIC { GameAreaType * };
-
-%feature(&quot;director&quot;) GameAreaListener; 
-class GameAreaListener
-{
-public:
-	virtual ~GameAreaListener();
-    virtual void areaLeft(rl::GameAreaEvent *anEvent) = 0;
-    virtual void areaEntered(rl::GameAreaEvent *anEvent) = 0;
-};
-
-class GameAreaType
-{
-private:
-	GameAreaType();
-public:
-	unsigned long getQueryMask() const;
-    void setQueryMask( unsigned long mask );
-    void addQueryFlag( unsigned long flag  );
-    void removeQueryFlag( unsigned long flag );
-    const Ogre::Vector3&amp; getQueryPosition() const;
-};
-
-/*
-class GameSphereAreaType : public GameAreaType
-{
-private:
-	GameSphereAreaType( Ogre::Vector3, Ogre::Real, unsigned long mask = 0xFFFFFFFF );
-public:
-};
-*/
-class GameAreaEventSource
-{
-private: 
-	GameAreaEventSource( rl::GameAreaType* areaType, rl::Actor* act );
-public:   
-    void addAreaListener( rl::GameAreaListener*  list );
-    void removeAreaListener( rl::GameAreaListener* list );
-    bool hasListeners( ) const;
-
-    rl::GameAreaType* getGameAreaType();
-    // const ActorMap&amp; getInsideAreaList() const;
-    rl::Actor* getActor() const;
-};
-
-class GameAreaEvent
-{
-private:
-	GameAreaEvent( rl::GameAreaEventSource* src, const unsigned int reason );
-public:
-    rl::Actor* getProvokingActor() const;
-    rl::GameAreaEventSource* getSource() const;
-};
-
-class GameEventManager
-{
-private:
-    GameEventManager( );
-public:
-    void addSphereAreaListener( rl::Actor* actor, Ogre::Real radius, 
-		rl::GameAreaListener* list, unsigned long queryMask = 0xFFFFFFFF );
-	void addMeshAreaListener( rl::Actor* actor, Ogre::Entity* ent, rl::GeometryType geom, 
-	    rl::GameAreaListener* list, unsigned long queryMask = 0xFFFFFFFF );
-	void addMeshAreaListener( rl::Actor* actor, rl::GeometryType geom, 
-	    rl::GameAreaListener* list, unsigned long queryMask = 0xFFFFFFFF );
-	
-    void removeAreaListener( rl::GameAreaListener* list );
-    void removeAllAreas( rl::Actor* actor );
-
-    static rl::GameEventManager &amp; getSingleton(void);
-};
-
-/// Alles was mit Animationen zu tun hat
-%apply SWIGTYPE *DYNAMIC { BaseAnimation * };
-
-class BaseAnimation {
-public:
-	bool isPaused() const;
-    void setPaused( bool isPaused );
-
-	bool isIgnoringGlobalSpeed() const;
-	void setIgnoringGlobalSpeed( bool isIgnoringGlobalSpeed );
-
-	Ogre::Real getSpeed() const;
-	void setSpeed( Ogre::Real speed );
-	void reverseAnimation();
-
-	void setTimesToPlay(unsigned int timesToPlay);
-	unsigned int getTimesPlayed() const;
-	void resetTimesPlayed();
-	unsigned int getTimesToPlay() const;
-	unsigned int getTimesToPlayLeft() const;
-	Ogre::Real getTimePlayed() const;
-
-	Ogre::Real getDelay(void) const;
-    void setDelay(Ogre::Real delay);
-    
-private:
-	BaseAnimation(  );
-};
-
-class FadeAnimation : public BaseAnimation {
-private:
-	FadeAnimation(  ); 
-public:
-	bool isDeleteOnFinish() const;
-	void setDeleteOnFinish( bool deleteOnFinish );
-};
-
-class MeshAnimation : public BaseAnimation {
-public:
-    rl::MeshObject* getMeshObject( );
-    
-	Ogre::Real getWeight(void) const;
-    void setWeight(Ogre::Real weight);
-private:
-	MeshAnimation(  ); 
-};
-
-class TrackAnimation : public BaseAnimation {
-public:
-	void addKeyFrame( Ogre::Real timePos );
-    void setKeyFrameTranslation( Ogre::Real timePos, Ogre::Real xPos, Ogre::Real yPos, Ogre::Real zPos );
-    void setKeyFrameRotation( Ogre::Real timePos, Ogre::Real xRotAxis, Ogre::Real yRotAxis, Ogre::Real zRotAxis, Ogre::Real angleUnits );
-    void setKeyFrameRotationQuaternion( Ogre::Real timePos, Ogre::Real w, Ogre::Real x, Ogre::Real y, Ogre::Real z );
-    void setKeyFrameScale( Ogre::Real timePos, Ogre::Real xScale, Ogre::Real yScale, Ogre::Real zScale );
-
-	void setInterpolationMode( rl::AnimationManager::InterpolationMode im );
-	rl::AnimationManager::InterpolationMode getInterpolationMode() const;
-
-	void setRotationInterpolationMode( rl::AnimationManager::RotationInterpolationMode im );
-	rl::AnimationManager::RotationInterpolationMode getRotationInterpolationMode() const;
-
-	void setUseShortestRotationPath ( bool useShortestPath );
-	bool getUseShortestRotationPath () const;
-private:
-	TrackAnimation(  ); 
-};
-
-class AnimationManager {
-private:
-	AnimationManager();
-public:
-	static AnimationManager&amp; getSingleton(void);
-	
-	enum InterpolationMode { IM_LINEAR, IM_SPLINE };
-	enum RotationInterpolationMode { RIM_LINEAR, RIM_SPHERICAL };
-	
-	rl::TrackAnimation* createTrackAnimation(rl::Actor* actor, const Ogre::String&amp; name, Ogre::Real length );
-	void removeAnimation( rl::MeshAnimation* anim );
-    void removeAnimation( rl::TrackAnimation* anim );
-    void removeAnimation( rl::FadeAnimation* anim );
-	void removeTrackAnimation( rl::Actor* act, const Ogre::String&amp; name );
-	void removeAllTrackAnimations( rl::Actor* act );
-	
-	void setGlobalAnimationSpeed( Ogre::Real speed );
-	Ogre::Real getGlobalAnimationSpeed( ) const;
-
-    rl::FadeAnimation* fadeAnimation( rl::MeshAnimation* from, rl::MeshAnimation* to, Ogre::Real time );
-    rl::FadeAnimation* fadeAnimation( rl::MeshAnimation* fromLoop, rl::MeshAnimation* blendAnim, 
-        rl::MeshAnimation* toLoop, Ogre::Real loopDuration = 0.0);
-	
-	void setDefaultInterpolationMode( rl::AnimationManager::InterpolationMode im );
-	rl::AnimationManager::InterpolationMode getDefaultInterpolationMode() const;
-
-	void setDefaultRotationInterpolationMode( rl::AnimationManager::RotationInterpolationMode rim );
-	rl::AnimationManager::RotationInterpolationMode getDefaultRotationInterpolationMode() const;
-};
-
-%apply SWIGTYPE *DYNAMIC { ActorControlledObject * };
-class ActorControlledObject {
-private:
-    ActorControlledObject();
-public:
-    rl::Actor* getActor();
-    virtual void setActive(bool active);
-};
-
-class PhysicalObject : public rl::ActorControlledObject
-{
-};
-
-class MeshObject : public rl::PhysicalObject
-{
-private:
-    MeshObject(const Ogre::String&amp; name, const Ogre::String&amp; meshname);
-public:
-    
-    /// Groesse der Boundingbox
-    Ogre::AxisAlignedBox getDefaultSize() const;
-        
-	rl::BaseAnimation* getAnimation(const Ogre::String&amp; animName);
-	rl::BaseAnimation* replaceAnimation(const Ogre::String&amp; oldAnimName, 
-	    const Ogre::String&amp; newAnimName, float speed=1.0, unsigned int timesToPlay=0);
-	rl::BaseAnimation* startAnimation(const Ogre::String&amp; animName, 
-		float speed=1.0, unsigned int timesToPlay=0);
-    void stopAnimation(const Ogre::String&amp;);
-    void stopAllAnimations();
-    
-    void setCastShadows (bool enabled);
-    bool getCastShadows (void) const;    
-};
-
-class MergeableMeshObject : public rl::MeshObject
-{
-private:
-    MergeableMeshObject(const Ogre::String&amp; name, const Ogre::String&amp; meshname);
-public:
-	void addSubmesh(const Ogre::String&amp; meshname, const Ogre::String&amp; meshfile);
-	void removeSubmesh(const Ogre::String&amp; submeshToRemove);
-	void replaceSubmesh(const Ogre::String&amp; submeshToReplace, const Ogre::String&amp; substituteMeshname);
-	void setBaseMeshPart(const Ogre::String&amp; partname);
-};
-
-class LightObject : public rl::ActorControlledObject
-{
-private:
-    LightObject(const Ogre::String&amp; name, rl::LightObject::LightTypes type);
-public:
-	enum LightTypes { LT_POINT, LT_DIRECTIONAL, LT_SPOTLIGHT };
-
-    void setAttenuation(float range, float constant,
-        float linear, float quadric);
-    void setDiffuseColour(float red, float green, float blue);
-    void setDiffuseColour(const Ogre::ColourValue&amp; colour);
-    void setDirection(float x, float y, float z);
-    void setSpecularColour(float red, float green, float blue);
-    void setSpecularColour(const Ogre::ColourValue&amp; colour);
-    void setSpotlightRange(float innerangle, float outerangle,
-        float falloff);
-    void setCastShadows( bool cast );
-};
-
-
-class SoundObject : public rl::ActorControlledObject
-{
-public:
-    SoundObject(rl::Sound *sound, const Ogre::String &amp;name);
-    virtual ~SoundObject();
-    
-  	void play(bool destroyWhenDone=false);
-
-	void load();
-	void unload();
-	bool is3d() const;
-	void set3d( bool is3d );
-
-    /// Gibt zurck ob der Sound geloopt werden soll 
-    bool isLooping() const;
-    /// Setzt ob der Sound geloopt werden soll 
-    void setLooping( bool looping );
-    /// Pausiert den Sound.
-    void pause(bool pausing);
-    /// Ist der Sound pausiert?
-    bool isPaused();
-    /// Stoppt den Sound.
-    void stop();
-	/// Setzt die Lautstaerke (1.0 = volle Lautstrke)
-	void setVolume(float volume = 1.0);
-    // Sets the priority of this sound
-    void setPriority(const int priority);
-    // Gets the priority of this sound
-    const int getPriority() const;
-	
-	rl::Sound* getSound();
-};
-
+
+    void setShowBoundingBoxes( bool dis );
+};
+
+/// Alles was mit AreaKrams zu tun hat
+%apply SWIGTYPE *DYNAMIC { GameAreaType * };
+
+%feature(&quot;director&quot;) GameAreaListener; 
+class GameAreaListener
+{
+public:
+	virtual ~GameAreaListener();
+    virtual void areaLeft(rl::GameAreaEvent *anEvent) = 0;
+    virtual void areaEntered(rl::GameAreaEvent *anEvent) = 0;
+};
+
+class GameAreaType
+{
+private:
+	GameAreaType();
+public:
+	virtual unsigned long getQueryMask() const = 0;
+    virtual void setQueryMask( unsigned long mask = 0xFFFFFFFF ) = 0;
+    void addQueryFlag( unsigned long flag  );
+    void removeQueryFlag( unsigned long flag );
+    virtual void setQueryPosition( const Ogre::Vector3&amp; vec ) = 0;
+    virtual Ogre::Vector3 getQueryPosition() const = 0;
+    virtual void setQueryOrientation( const Ogre::Quaternion&amp; ori ) = 0;
+    virtual Ogre::Quaternion getQueryOrientation() const = 0;
+    virtual OgreNewt::Body* getBody() { return NULL;}
+    virtual Ogre::Real getDistance(rl::Actor* actor) = 0;
+    virtual Ogre::Real getTransitionDistance() const = 0;
+    virtual void setTransitionDistance(Ogre::Real dist) = 0;
+    virtual bool isInside(rl::Actor *actor) = 0;
+};
+
+/*
+class GameSphereAreaType : public GameAreaType
+{
+private:
+	GameSphereAreaType( Ogre::Vector3, Ogre::Real, unsigned long mask = 0xFFFFFFFF );
+public:
+};
+*/
+class GameAreaEventSource
+{
+private: 
+	GameAreaEventSource( rl::GameAreaType* areaType, rl::Actor* act );
+public:   
+    void addAreaListener( rl::GameAreaListener*  list );
+    void removeAreaListener( rl::GameAreaListener* list );
+    bool hasListeners( ) const;
+
+    rl::GameAreaType* getGameAreaType();
+    // const ActorMap&amp; getInsideAreaList() const;
+    rl::Actor* getActor() const;
+};
+
+class GameAreaEvent
+{
+private:
+	GameAreaEvent( rl::GameAreaEventSource* src, const unsigned int reason );
+public:
+    rl::Actor* getProvokingActor() const;
+    rl::GameAreaEventSource* getSource() const;
+};
+
+class GameEventManager
+{
+private:
+    GameEventManager( );
+public:
+    void addSphereAreaListener( rl::Actor* actor, Ogre::Real radius, 
+		rl::GameAreaListener* list, unsigned long queryMask = 0xFFFFFFFF );
+	void addMeshAreaListener( rl::Actor* actor, Ogre::Entity* ent, rl::GeometryType geom, 
+	    rl::GameAreaListener* list, unsigned long queryMask = 0xFFFFFFFF );
+	void addMeshAreaListener( rl::Actor* actor, rl::GeometryType geom, 
+	    rl::GameAreaListener* list, unsigned long queryMask = 0xFFFFFFFF );
+	
+    void removeAreaListener( rl::GameAreaListener* list );
+    void removeAllAreas( rl::Actor* actor );
+
+    static rl::GameEventManager &amp; getSingleton(void);
+};
+
+/// Alles was mit Animationen zu tun hat
+%apply SWIGTYPE *DYNAMIC { BaseAnimation * };
+
+class BaseAnimation {
+public:
+	bool isPaused() const;
+    void setPaused( bool isPaused );
+
+	bool isIgnoringGlobalSpeed() const;
+	void setIgnoringGlobalSpeed( bool isIgnoringGlobalSpeed );
+
+	Ogre::Real getSpeed() const;
+	void setSpeed( Ogre::Real speed );
+	void reverseAnimation();
+
+	void setTimesToPlay(unsigned int timesToPlay);
+	unsigned int getTimesPlayed() const;
+	void resetTimesPlayed();
+	unsigned int getTimesToPlay() const;
+	unsigned int getTimesToPlayLeft() const;
+	Ogre::Real getTimePlayed() const;
+
+	Ogre::Real getDelay(void) const;
+    void setDelay(Ogre::Real delay);
+    
+private:
+	BaseAnimation(  );
+};
+
+class FadeAnimation : public BaseAnimation {
+private:
+	FadeAnimation(  ); 
+public:
+	bool isDeleteOnFinish() const;
+	void setDeleteOnFinish( bool deleteOnFinish );
+};
+
+class MeshAnimation : public BaseAnimation {
+public:
+    rl::MeshObject* getMeshObject( );
+    
+	Ogre::Real getWeight(void) const;
+    void setWeight(Ogre::Real weight);
+private:
+	MeshAnimation(  ); 
+};
+
+class TrackAnimation : public BaseAnimation {
+public:
+	void addKeyFrame( Ogre::Real timePos );
+    void setKeyFrameTranslation( Ogre::Real timePos, Ogre::Real xPos, Ogre::Real yPos, Ogre::Real zPos );
+    void setKeyFrameRotation( Ogre::Real timePos, Ogre::Real xRotAxis, Ogre::Real yRotAxis, Ogre::Real zRotAxis, Ogre::Real angleUnits );
+    void setKeyFrameRotationQuaternion( Ogre::Real timePos, Ogre::Real w, Ogre::Real x, Ogre::Real y, Ogre::Real z );
+    void setKeyFrameScale( Ogre::Real timePos, Ogre::Real xScale, Ogre::Real yScale, Ogre::Real zScale );
+
+	void setInterpolationMode( rl::AnimationManager::InterpolationMode im );
+	rl::AnimationManager::InterpolationMode getInterpolationMode() const;
+
+	void setRotationInterpolationMode( rl::AnimationManager::RotationInterpolationMode im );
+	rl::AnimationManager::RotationInterpolationMode getRotationInterpolationMode() const;
+
+	void setUseShortestRotationPath ( bool useShortestPath );
+	bool getUseShortestRotationPath () const;
+private:
+	TrackAnimation(  ); 
+};
+
+class AnimationManager {
+private:
+	AnimationManager();
+public:
+	static AnimationManager&amp; getSingleton(void);
+	
+	enum InterpolationMode { IM_LINEAR, IM_SPLINE };
+	enum RotationInterpolationMode { RIM_LINEAR, RIM_SPHERICAL };
+	
+	rl::TrackAnimation* createTrackAnimation(rl::Actor* actor, const Ogre::String&amp; name, Ogre::Real length );
+	void removeAnimation( rl::MeshAnimation* anim );
+    void removeAnimation( rl::TrackAnimation* anim );
+    void removeAnimation( rl::FadeAnimation* anim );
+	void removeTrackAnimation( rl::Actor* act, const Ogre::String&amp; name );
+	void removeAllTrackAnimations( rl::Actor* act );
+	
+	void setGlobalAnimationSpeed( Ogre::Real speed );
+	Ogre::Real getGlobalAnimationSpeed( ) const;
+
+    rl::FadeAnimation* fadeAnimation( rl::MeshAnimation* from, rl::MeshAnimation* to, Ogre::Real time );
+    rl::FadeAnimation* fadeAnimation( rl::MeshAnimation* fromLoop, rl::MeshAnimation* blendAnim, 
+        rl::MeshAnimation* toLoop, Ogre::Real loopDuration = 0.0);
+	
+	void setDefaultInterpolationMode( rl::AnimationManager::InterpolationMode im );
+	rl::AnimationManager::InterpolationMode getDefaultInterpolationMode() const;
+
+	void setDefaultRotationInterpolationMode( rl::AnimationManager::RotationInterpolationMode rim );
+	rl::AnimationManager::RotationInterpolationMode getDefaultRotationInterpolationMode() const;
+};
+
+%apply SWIGTYPE *DYNAMIC { ActorControlledObject * };
+class ActorControlledObject {
+private:
+    ActorControlledObject();
+public:
+    rl::Actor* getActor();
+    virtual void setActive(bool active);
+};
+
+class PhysicalObject : public rl::ActorControlledObject
+{
+};
+
+class MeshObject : public rl::PhysicalObject
+{
+private:
+    MeshObject(const Ogre::String&amp; name, const Ogre::String&amp; meshname);
+public:
+    
+    /// Groesse der Boundingbox
+    Ogre::AxisAlignedBox getDefaultSize() const;
+        
+	rl::BaseAnimation* getAnimation(const Ogre::String&amp; animName);
+	rl::BaseAnimation* replaceAnimation(const Ogre::String&amp; oldAnimName, 
+	    const Ogre::String&amp; newAnimName, float speed=1.0, unsigned int timesToPlay=0);
+	rl::BaseAnimation* startAnimation(const Ogre::String&amp; animName, 
+		float speed=1.0, unsigned int timesToPlay=0);
+    void stopAnimation(const Ogre::String&amp;);
+    void stopAllAnimations();
+    
+    void setCastShadows (bool enabled);
+    bool getCastShadows (void) const;    
+};
+
+class MergeableMeshObject : public rl::MeshObject
+{
+private:
+    MergeableMeshObject(const Ogre::String&amp; name, const Ogre::String&amp; meshname);
+public:
+	void addSubmesh(const Ogre::String&amp; meshname, const Ogre::String&amp; meshfile);
+	void removeSubmesh(const Ogre::String&amp; submeshToRemove);
+	void replaceSubmesh(const Ogre::String&amp; submeshToReplace, const Ogre::String&amp; substituteMeshname);
+	void setBaseMeshPart(const Ogre::String&amp; partname);
+};
+
+class LightObject : public rl::ActorControlledObject
+{
+private:
+    LightObject(const Ogre::String&amp; name, rl::LightObject::LightTypes type);
+public:
+	enum LightTypes { LT_POINT, LT_DIRECTIONAL, LT_SPOTLIGHT };
+
+    void setAttenuation(float range, float constant,
+        float linear, float quadric);
+    void setDiffuseColour(float red, float green, float blue);
+    void setDiffuseColour(const Ogre::ColourValue&amp; colour);
+    void setDirection(float x, float y, float z);
+    void setSpecularColour(float red, float green, float blue);
+    void setSpecularColour(const Ogre::ColourValue&amp; colour);
+    void setSpotlightRange(float innerangle, float outerangle,
+        float falloff);
+    void setCastShadows( bool cast );
+};
+
+
+class SoundObject : public rl::ActorControlledObject
+{
+public:
+    SoundObject(rl::Sound *sound, const Ogre::String &amp;name);
+    virtual ~SoundObject();
+    
+  	void play(bool destroyWhenDone=false);
+
+	void load();
+	void unload();
+	bool is3d() const;
+	void set3d( bool is3d );
+
+    /// Gibt zurck ob der Sound geloopt werden soll 
+    bool isLooping() const;
+    /// Setzt ob der Sound geloopt werden soll 
+    void setLooping( bool looping );
+    /// Pausiert den Sound.
+    void pause(bool pausing);
+    /// Ist der Sound pausiert?
+    bool isPaused();
+    /// Stoppt den Sound.
+    void stop();
+	/// Setzt die Lautstaerke (1.0 = volle Lautstrke)
+	void setVolume(float volume = 1.0);
+    // Sets the priority of this sound
+    void setPriority(const int priority);
+    // Gets the priority of this sound
+    const int getPriority() const;
+	
+	rl::Sound* getSound();
+};
+
 class SoundStitchingObject : public rl::ActorControlledObject
 {
 public:
@@ -464,20 +472,20 @@
     /// Destruktor
     virtual ~SoundStitchingObject();
       
-    /**
-     * Interne Methode. Wird vom Aktor aufgerufen, wenn sich dessen
-     * Status gendert hat. (Position, Orientierung, etc)
-     * Die Standardimplementierung macht nichts, kann aber
-     * von abgeleiteten Klassen berschrieben werden.
-     */
-    virtual void _update();
-    
-    /// Wie ActorControlledObject::getMovableObject()
-    /// Nur schon gebrauchsfertig gecastet.
-    rl::SoundStitching* getSoundStitching() const;
-    
-    
-    virtual Ogre::String getObjectType() const;
+    /**
+     * Interne Methode. Wird vom Aktor aufgerufen, wenn sich dessen
+     * Status gendert hat. (Position, Orientierung, etc)
+     * Die Standardimplementierung macht nichts, kann aber
+     * von abgeleiteten Klassen berschrieben werden.
+     */
+    virtual void _update();
+    
+    /// Wie ActorControlledObject::getMovableObject()
+    /// Nur schon gebrauchsfertig gecastet.
+    rl::SoundStitching* getSoundStitching() const;
+    
+    
+    virtual Ogre::String getObjectType() const;
 
     // Wollen wir 3D?
     bool is3d() const;
@@ -490,8 +498,8 @@
     void setLooping(bool looping);
     float getLength() const;
     /// Pausiert den Sound.
-    void pause();
-    /// Pausiert den Sound.
+    void pause();
+    /// Pausiert den Sound.
     void pause(bool pausing);
     /// Ist der Sound pausiert?
     bool isPaused();
@@ -505,12 +513,12 @@
     void setPriority(const int priority);
     // Gets the priority of this sound
     const int getPriority() const;
-	/// L&#228;dt den Ton
-	void load();
-    /// Entl&#228;dt den Sound.
-    void unload();
-    /// Aktivieren
-    virtual void setActive(bool active);
+	/// L&#228;dt den Ton
+	void load();
+    /// Entl&#228;dt den Sound.
+    void unload();
+    /// Aktivieren
+    virtual void setActive(bool active);
 
     /// Start sound sequence
     void start();
@@ -530,717 +538,717 @@
     virtual unsigned int getPlayingSlot() = 0;
 }; 
 
-
-class ParticleSystemObject : public rl::ActorControlledObject
-{
-public:
-     void setActive(bool active);
-private:
-	 ParticleSystemObject(const Ogre::String&amp; name, const Ogre::String&amp; partSys );
-};
-
-class CameraObject : public rl::PhysicalObject
-{
-private:
-    CameraObject(const Ogre::String&amp; name);
-public:
-};
-
-class Actor {
-private:
-	Actor(const Ogre::String&amp; name);
-public:	
-	static const Ogre::String DEFAULT_SLOT_NAME;
-
-	const const Ogre::String&amp; getName() const;
-	const Ogre::Vector3&amp; getPosition(void);
-	const Ogre::Quaternion&amp; getOrientation(void);
-	const Ogre::Vector3&amp; getWorldPosition(void);
-	const Ogre::Quaternion&amp; getWorldOrientation(void);
-
-    void setPosition(Ogre::Real x, Ogre::Real y, Ogre::Real z);
-    void setPosition( const Ogre::Vector3&amp; );
-    void setOrientation( const Ogre::Quaternion&amp; );
-    
-    rl::ActorControlledObject* getControlledObject();
-    Ogre::UserDefinedObject* getGameObject() const;
-    rl::PhysicalThing* getPhysicalThing() const;
-
-    void setScale( Ogre::Real sx, Ogre::Real sy, Ogre::Real sz );
-    void placeIntoScene(
-            const Ogre::Vector3&amp; position = Ogre::Vector3::ZERO,
-            const Ogre::Quaternion&amp; orientation = Ogre::Quaternion::IDENTITY,
-            const Ogre::String&amp; physicsBone = &quot;&quot;);  
-    void placeIntoScene(
-        Ogre::Real px, Ogre::Real py, Ogre::Real pz,
-        Ogre::Real ow, Ogre::Real ox, Ogre::Real oy, Ogre::Real oz, 
-        const Ogre::String&amp; physicsBone = &quot;&quot;);
-    void removeFromScene();
-           
-    void attach( 
-            Actor* actor,
-            const Ogre::String&amp; childSlot = &quot;SLOT_DEFAULT&quot;,
-            const Ogre::Vector3&amp; offsetPosition=Ogre::Vector3::ZERO,
-            const Ogre::Quaternion&amp; offsetOrientation=Ogre::Quaternion::IDENTITY
-            );
-   	void attachAxisRot( 
-            rl::Actor* actor,
-            const Ogre::String&amp; childSlot = &quot;SLOT_DEFAULT&quot;,            
-            const Ogre::Vector3&amp; offsetPosition=Ogre::Vector3::ZERO,
-            const Ogre::Vector3&amp; offsetAxis=Ogre::Vector3::UNIT_X,
-            const Ogre::Radian&amp; offsetRotation=Ogre::Radian(0) );
-    void attachToSlot( 
-            Actor* actor,
-            const Ogre::String&amp; slot,
-            const Ogre::String&amp; childSlot = &quot;SLOT_DEFAULT&quot;,
-            const Ogre::Vector3&amp; offsetPosition=Ogre::Vector3::ZERO,
-			const Ogre::Quaternion&amp; offsetOrientation=Ogre::Quaternion::IDENTITY
-			);
-    void attachToSlotAxisRot( 
-            rl::Actor* actor,
-            const Ogre::String&amp; slot,
-            const Ogre::String&amp; childSlot = &quot;SLOT_DEFAULT&quot;,            
-			const Ogre::Vector3&amp; offsetPosition=Ogre::Vector3::ZERO,
-            const Ogre::Vector3&amp; offsetAxis=Ogre::Vector3::UNIT_X,
-            const Ogre::Radian&amp; offsetRotation=Ogre::Radian(0) );
-                    
-    void detach(rl::Actor* actor);
-
-    void merge(Actor* actor, const Ogre::String&amp; slot);
-
-    rl::Actor* getChildByName(const Ogre::String&amp; name ) const;
-    
-    void setVisible( bool vis, bool cascade = true );
-	bool isVisible() const;
-       
-	void roll(Ogre::Real angleunits);
-	void pitch(Ogre::Real angleunits);
-	void yaw(Ogre::Real angleunits);
-	
-	unsigned long getQueryFlags() const;
-    void setQueryFlags( unsigned long mask = 0xFFFFFFFF );
-    void addQueryFlag( unsigned long flag  );
-    void removeQueryFlag( unsigned long flag );
-    void setListenerOf (Ogre::SceneNode *node);
-    Ogre::Bone *_getBone() const;
-    Ogre::SceneNode* _getSceneNode() const;
-    
-};
-
-%feature(&quot;director&quot;) PhysicsContactListener; 
-class PhysicsContactListener
-{
-public:
-    PhysicsContactListener();
-    virtual ~PhysicsContactListener();
-    
-    virtual void contactOccured(rl::Actor* actor1, rl::Actor* actor2) = 0;
-};
-
-class PhysicalThing
-{
-public:
-    PhysicalThing(
-			rl::GeometryType geomType,
-			rl::PhysicalObject* po, 
-			Ogre::Real mass, 
-			bool hullModifier = false);
-
-    void setPosition(Ogre::Real x, Ogre::Real y, Ogre::Real z);
-    void setOrientation(Ogre::Real w, Ogre::Real x, Ogre::Real y, Ogre::Real z);
-    
-    void setVelocity(const Ogre::Vector3&amp; vel);
-
-    // Sets the vector, that will always point up.
-    void setUpConstraint(const Ogre::Vector3&amp; upVector = Ogre::Vector3::UNIT_Y);
-    Ogre::Vector3 getUpConstraint() const;
-    void clearUpConstraint();
-
-    rl::Actor* getActor() const;
-
-    void addForce(const Ogre::Vector3&amp; force);
-
-    void freeze();
-    void unfreeze();
-        
-    void setGravityOverride(bool override,
-        Ogre::Real x = 0.0f, Ogre::Real y = 0.0f, Ogre::Real z = 0.0f);
-        
-    Ogre::Real getMass() const;
-    void setMass(Ogre::Real mass);
-    
-    void updateCollisionHull();
-
-    void setContactListener(rl::PhysicsContactListener* listener);
-    rl::PhysicsContactListener* getContactListener() const;
-
-    void fitToPose(const Ogre::String&amp; name);
-
-};
-
-enum GeometryType {
-    GT_NONE = -1,
-    GT_BOX = 0,
-    GT_SPHERE = 1,
-    GT_CAPSULE = 2,
-    GT_MESH = 3,
-    GT_ELLIPSOID = 4,
-    GT_CONVEXHULL = 5
-};
-    
-
-
-class PhysicsManager
-{
-public:
-
-    PhysicsManager();
-	static PhysicsManager&amp; getSingleton(void);
-    
-    rl::PhysicalThing* createPhysicalThing(rl::GeometryType geomType, rl::PhysicalObject* po,
-		Ogre::Real mass);
-
-    void removeAndDestroyPhysicalThing(PhysicalThing* thing);
-
-    void createPhysicsProxy(PhysicalThing* pt);
-
-    void createPhysicsProxy_RagDoll(PhysicalThing* pt);
-
-    void destroyPhysicsProxy(PhysicalThing* pt);
-
-    // Global Settings
-    void setGravity(Ogre::Real x, Ogre::Real y, Ogre::Real z);
-    Ogre::Vector3 getGravity() const;
-
-    bool isEnabled() const;
-    void setEnabled(bool enabled);
-	
-	void toggleDebugMode();
-    bool isDebugMode() const;
-};
-
-class DebugVisualsManager
-{
-public:
-    DebugVisualsManager();
-    static DebugVisualsManager&amp; getSingleton(void);
-
-    void show(unsigned long flags);
-    void hide(unsigned long flags);
-    void showAll();
-    void hideAll();
-    void toggleAll();
-};
-  
-class ContentLoader;
-    
-%feature(&quot;director&quot;) ContentModule; 
-class ContentModule
-{
-public:
-	ContentModule(
-		const Ogre::String&amp; id, 
-		const rl::CeGuiString&amp; name, 
-		bool common, 
-		long minimumEngineVersion);
-		
-	virtual ~ContentModule();
-		
-	virtual const Ogre::StringVector&amp; getDependencies() const = 0;
-	virtual const Ogre::StringVector&amp; getTextureLocations() const = 0;
-	virtual const Ogre::StringVector&amp; getSoundLocations() const = 0;
-	virtual const Ogre::StringVector&amp; getModelLocations() const = 0;
-
-	virtual void start() = 0;
-	
-	void loadContent();
-	
-	void registerContentLoader(rl::ContentLoader* loader);
-};
-
-%feature(&quot;director&quot;) ContentLoader;
-class ContentLoader
-{
-public:
-    ContentLoader(const Ogre::String&amp; resourceGroup);
-    virtual ~ContentLoader();
-
-    virtual void loadContent() = 0;
-    virtual void unloadContent() = 0;
-
-    virtual const CEGUI::String getClassName() const = 0;
-};
-
-class CoreSubsystem {
-private:
-	CoreSubsystem();
-public:
-    static CoreSubsystem&amp; getSingleton(void);
-    
+
+class ParticleSystemObject : public rl::ActorControlledObject
+{
+public:
+     void setActive(bool active);
+private:
+	 ParticleSystemObject(const Ogre::String&amp; name, const Ogre::String&amp; partSys );
+};
+
+class CameraObject : public rl::PhysicalObject
+{
+private:
+    CameraObject(const Ogre::String&amp; name);
+public:
+};
+
+class Actor {
+private:
+	Actor(const Ogre::String&amp; name);
+public:	
+	static const Ogre::String DEFAULT_SLOT_NAME;
+
+	const const Ogre::String&amp; getName() const;
+	const Ogre::Vector3&amp; getPosition(void);
+	const Ogre::Quaternion&amp; getOrientation(void);
+	const Ogre::Vector3&amp; getWorldPosition(void);
+	const Ogre::Quaternion&amp; getWorldOrientation(void);
+
+    void setPosition(Ogre::Real x, Ogre::Real y, Ogre::Real z);
+    void setPosition( const Ogre::Vector3&amp; );
+    void setOrientation( const Ogre::Quaternion&amp; );
+    
+    rl::ActorControlledObject* getControlledObject();
+    Ogre::UserDefinedObject* getGameObject() const;
+    rl::PhysicalThing* getPhysicalThing() const;
+
+    void setScale( Ogre::Real sx, Ogre::Real sy, Ogre::Real sz );
+    void placeIntoScene(
+            const Ogre::Vector3&amp; position = Ogre::Vector3::ZERO,
+            const Ogre::Quaternion&amp; orientation = Ogre::Quaternion::IDENTITY,
+            const Ogre::String&amp; physicsBone = &quot;&quot;);  
+    void placeIntoScene(
+        Ogre::Real px, Ogre::Real py, Ogre::Real pz,
+        Ogre::Real ow, Ogre::Real ox, Ogre::Real oy, Ogre::Real oz, 
+        const Ogre::String&amp; physicsBone = &quot;&quot;);
+    void removeFromScene();
+           
+    void attach( 
+            Actor* actor,
+            const Ogre::String&amp; childSlot = &quot;SLOT_DEFAULT&quot;,
+            const Ogre::Vector3&amp; offsetPosition=Ogre::Vector3::ZERO,
+            const Ogre::Quaternion&amp; offsetOrientation=Ogre::Quaternion::IDENTITY
+            );
+   	void attachAxisRot( 
+            rl::Actor* actor,
+            const Ogre::String&amp; childSlot = &quot;SLOT_DEFAULT&quot;,            
+            const Ogre::Vector3&amp; offsetPosition=Ogre::Vector3::ZERO,
+            const Ogre::Vector3&amp; offsetAxis=Ogre::Vector3::UNIT_X,
+            const Ogre::Radian&amp; offsetRotation=Ogre::Radian(0) );
+    void attachToSlot( 
+            Actor* actor,
+            const Ogre::String&amp; slot,
+            const Ogre::String&amp; childSlot = &quot;SLOT_DEFAULT&quot;,
+            const Ogre::Vector3&amp; offsetPosition=Ogre::Vector3::ZERO,
+			const Ogre::Quaternion&amp; offsetOrientation=Ogre::Quaternion::IDENTITY
+			);
+    void attachToSlotAxisRot( 
+            rl::Actor* actor,
+            const Ogre::String&amp; slot,
+            const Ogre::String&amp; childSlot = &quot;SLOT_DEFAULT&quot;,            
+			const Ogre::Vector3&amp; offsetPosition=Ogre::Vector3::ZERO,
+            const Ogre::Vector3&amp; offsetAxis=Ogre::Vector3::UNIT_X,
+            const Ogre::Radian&amp; offsetRotation=Ogre::Radian(0) );
+                    
+    void detach(rl::Actor* actor);
+
+    void merge(Actor* actor, const Ogre::String&amp; slot);
+
+    rl::Actor* getChildByName(const Ogre::String&amp; name ) const;
+    
+    void setVisible( bool vis, bool cascade = true );
+	bool isVisible() const;
+       
+	void roll(Ogre::Real angleunits);
+	void pitch(Ogre::Real angleunits);
+	void yaw(Ogre::Real angleunits);
+	
+	unsigned long getQueryFlags() const;
+    void setQueryFlags( unsigned long mask = 0xFFFFFFFF );
+    void addQueryFlag( unsigned long flag  );
+    void removeQueryFlag( unsigned long flag );
+    void setListenerOf (Ogre::SceneNode *node);
+    Ogre::Bone *_getBone() const;
+    Ogre::SceneNode* _getSceneNode() const;
+    
+};
+
+%feature(&quot;director&quot;) PhysicsContactListener; 
+class PhysicsContactListener
+{
+public:
+    PhysicsContactListener();
+    virtual ~PhysicsContactListener();
+    
+    virtual void contactOccured(rl::Actor* actor1, rl::Actor* actor2) = 0;
+};
+
+class PhysicalThing
+{
+public:
+    PhysicalThing(
+			rl::GeometryType geomType,
+			rl::PhysicalObject* po, 
+			Ogre::Real mass, 
+			bool hullModifier = false);
+
+    void setPosition(Ogre::Real x, Ogre::Real y, Ogre::Real z);
+    void setOrientation(Ogre::Real w, Ogre::Real x, Ogre::Real y, Ogre::Real z);
+    
+    void setVelocity(const Ogre::Vector3&amp; vel);
+
+    // Sets the vector, that will always point up.
+    void setUpConstraint(const Ogre::Vector3&amp; upVector = Ogre::Vector3::UNIT_Y);
+    Ogre::Vector3 getUpConstraint() const;
+    void clearUpConstraint();
+
+    rl::Actor* getActor() const;
+
+    void addForce(const Ogre::Vector3&amp; force);
+
+    void freeze();
+    void unfreeze();
+        
+    void setGravityOverride(bool override,
+        Ogre::Real x = 0.0f, Ogre::Real y = 0.0f, Ogre::Real z = 0.0f);
+        
+    Ogre::Real getMass() const;
+    void setMass(Ogre::Real mass);
+    
+    void updateCollisionHull();
+
+    void setContactListener(rl::PhysicsContactListener* listener);
+    rl::PhysicsContactListener* getContactListener() const;
+
+    void fitToPose(const Ogre::String&amp; name);
+
+};
+
+enum GeometryType {
+    GT_NONE = -1,
+    GT_BOX = 0,
+    GT_SPHERE = 1,
+    GT_CAPSULE = 2,
+    GT_MESH = 3,
+    GT_ELLIPSOID = 4,
+    GT_CONVEXHULL = 5
+};
+    
+
+
+class PhysicsManager
+{
+public:
+
+    PhysicsManager();
+	static PhysicsManager&amp; getSingleton(void);
+    
+    rl::PhysicalThing* createPhysicalThing(rl::GeometryType geomType, rl::PhysicalObject* po,
+		Ogre::Real mass);
+
+    void removeAndDestroyPhysicalThing(PhysicalThing* thing);
+
+    void createPhysicsProxy(PhysicalThing* pt);
+
+    void createPhysicsProxy_RagDoll(PhysicalThing* pt);
+
+    void destroyPhysicsProxy(PhysicalThing* pt);
+
+    // Global Settings
+    void setGravity(Ogre::Real x, Ogre::Real y, Ogre::Real z);
+    Ogre::Vector3 getGravity() const;
+
+    bool isEnabled() const;
+    void setEnabled(bool enabled);
+	
+	void toggleDebugMode();
+    bool isDebugMode() const;
+};
+
+class DebugVisualsManager
+{
+public:
+    DebugVisualsManager();
+    static DebugVisualsManager&amp; getSingleton(void);
+
+    void show(unsigned long flags);
+    void hide(unsigned long flags);
+    void showAll();
+    void hideAll();
+    void toggleAll();
+};
+  
+class ContentLoader;
+    
+%feature(&quot;director&quot;) ContentModule; 
+class ContentModule
+{
+public:
+	ContentModule(
+		const Ogre::String&amp; id, 
+		const rl::CeGuiString&amp; name, 
+		bool common, 
+		long minimumEngineVersion);
+		
+	virtual ~ContentModule();
+		
+	virtual const Ogre::StringVector&amp; getDependencies() const = 0;
+	virtual const Ogre::StringVector&amp; getTextureLocations() const = 0;
+	virtual const Ogre::StringVector&amp; getSoundLocations() const = 0;
+	virtual const Ogre::StringVector&amp; getModelLocations() const = 0;
+
+	virtual void start() = 0;
+	
+	void loadContent();
+	
+	void registerContentLoader(rl::ContentLoader* loader);
+};
+
+%feature(&quot;director&quot;) ContentLoader;
+class ContentLoader
+{
+public:
+    ContentLoader(const Ogre::String&amp; resourceGroup);
+    virtual ~ContentLoader();
+
+    virtual void loadContent() = 0;
+    virtual void unloadContent() = 0;
+
+    virtual const CEGUI::String getClassName() const = 0;
+};
+
+class CoreSubsystem {
+private:
+	CoreSubsystem();
+public:
+    static CoreSubsystem&amp; getSingleton(void);
+    
     // obsolete
-    // void loadMap(const Ogre::String&amp; type, const Ogre::String&amp; filename, const Ogre::String&amp; resourceGroup);
-
-	void registerModule(rl::ContentModule* module);
-
-	rl::ContentModule* getActiveAdventureModule() const;
-    rl::ContentModule* getModule(const Ogre::String&amp; moduleId) const;
-
-    rl::World* getWorld();
-    void makeScreenshot(const Ogre::String&amp; sName);
-    bool isInitialized() const;
-    void setScheme(const Ogre::String&amp; schemeName);
-    bool getDeveloperMode() const;
-    void setTimeFactor(const Ogre::Real&amp; factor = 1.0F);
-    void setPaused(bool paused);
-};
-
-class Sound 
-{
-private:
-	Sound(const SoundResourcePtr&amp; res);
-public:
-    // Einige Standardwerte fr Soundprioritten.
-    enum SOUND_PRIORITY {
-            PRIO_SPEECH = 30,
-            PRIO_MUSIC = 75,
-            PRIO_SFX_ENVIRONMENT = 128,
-            PRIO_SFX_OTHER = 175,
-            PRIO_OTHER = 220
-    };
-
-	virtual ~Sound();
-    
-    /// Name zurueckgeben
-    const Ogre::String&amp; getName() const;
-
-    /// Gibt die eingestellte Position der Soundquelle zurueck
-    const Ogre::Vector3 getPosition() const;
-    /// Setzt die Position der Soundquelle.
-    void setPosition(const Ogre::Vector3&amp; direction);
-    /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck
-    const Ogre::Real getVolume() const; 
-    /// Setzt die relative Lautstaerke der Soundquelle.
-    void setVolume(const Ogre::Real gain);
-    /// Gibt die Richtung der Soundquelle zurueck.
-    const Ogre::Quaternion getDirection() const;
-    /// Gibt die Geschwindigkeit der Soundquelle zurueck.
-    const Ogre::Vector3 getVelocity() const;
-    /// Setzt die Richtung der Soundquelle.
-    void setDirection(const Ogre::Quaternion&amp;);
-    /// Setzt die Geschwindigkeit der Soundquelle.
-    void setVelocity(const Ogre::Vector3&amp;);
-    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
-	void setRolloffStartDistance(const Ogre::Real dist);
-	const Ogre::Real getRolloffStartDistance() const;
-	/// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
-	void setRolloffEndDistance(const Ogre::Real dist);
-	const Ogre::Real getRolloffEndDistance() const;
-
-    /// Spielt den Sound ab.
-    void play() ;
-    /// Pausiert den Sound.
-    void pause(bool pausing) ;
-    /// Ist der Sound pausiert?
-    bool isPaused() ;
-    /// Stoppt den Sound.
-    void stop() ;
-    /// Laeuft der Sound noch
-    const bool isPlaying() const ;
-
-    // Sets the priority of this sound
-    virtual void setPriority(const int priority);
-    // Gets the priority of this sound
-    virtual const int getPriority() const;
-
-    /// Gibt zurck ob der Sound geloopt werden soll 
-    bool isLooping() const;
-    /// Setzt ob der Sound geloopt werden soll 
-    void setLooping( bool looping );
-    
-    // Sind wir gueltig
-    bool isValid() const;
-    
-    bool is3d();
-    void set3d(bool is3d);
-};
-
-typedef std::map&lt;CeGuiString, SoundResourcePtr&gt; SoundCache;
-
-class SoundStitching
-{
-public:
-    // Einige Standardwerte f&#252;r Soundpriorit&#228;ten.
-    enum SOUND_PRIORITY {
-        PRIO_SPEECH = 30,
-        PRIO_MUSIC = 75,
-        PRIO_SFX_ENVIRONMENT = 128,
-        PRIO_SFX_OTHER = 175,
-        PRIO_OTHER = 220
-    };
-
-    /// Konstruktor
-    SoundStitching(unsigned int numSlots, rl::CeGuiString name, rl::SoundDriver* creator);
-    /// Destruktor
-    virtual ~SoundStitching();
-      
-    // SoundResource zurueckgeben.
-    const rl::SoundResourcePtr&amp; getSoundResource() const;
-    // Wollen wir 3D?
-    bool is3d() const;
-    // Setzen des 3D-Flags.
-    void set3d(bool is3d);
-    // Sind wir gueltig
-    virtual bool isValid() const;
-    
-    // Sollen der Sound wiederholt werden?
-    bool isLooping() const;
-    // Setzen des Loop-Flags.
-    void setLooping(bool looping);
-
-    virtual float getLength() const = 0;
-
-    /// Unsere Bounding-Box
-    virtual const Ogre::AxisAlignedBox&amp; getBoundingBox(void) const;
-    /// Bound-Radius
-    virtual Ogre::Real getBoundingRadius() const;
-    /// Rendern
-    virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
-
-    /// Count of configured slots.
-    unsigned int getNumSlots();
-    /// Add a sound resource to the cache overwritting existing sound resource.
-    virtual void addSoundToCache(rl::CeGuiString label, rl::SoundResourcePtr sound);
-    /// Assign a sound recource to a slot.
-    virtual void putSoundIntoSlot(unsigned int, rl::CeGuiString label) = 0;
-    /// Get the slot of the plaing sound.
-    virtual unsigned int getPlayingSlot() = 0;
-
-    /// Gibt die eingestellte Position der Soundquelle zurueck
-    virtual const Ogre::Vector3 getPosition() const = 0;
-    /// Setzt die Position der Soundquelle.
-    virtual void setPosition(const Ogre::Vector3&amp; direction) = 0;
-    /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
-    virtual const Ogre::Real getVolume() const = 0; 
-    /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
-    virtual void setVolume(const Ogre::Real gain) = 0;
-    /// Gibt die Richtung der Soundquelle zurueck.
-    virtual const Ogre::Quaternion getDirection() const = 0;
-    /// Gibt die Geschwindigkeit der Soundquelle zurueck.
-    virtual const Ogre::Vector3 getVelocity() const = 0;
-    /// Setzt die Richtung der Soundquelle.
-    virtual void setDirection(const Ogre::Quaternion&amp;) = 0;
-    /// Setzt die Geschwindigkeit der Soundquelle.
-    virtual void setVelocity(const Ogre::Vector3&amp;) = 0;
-    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
-    virtual void setRolloffStartDistance(const Ogre::Real&amp;);
-    virtual const Ogre::Real getRolloffStartDistance() const;
-    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
-    virtual void setRolloffEndDistance(const Ogre::Real&amp;);
-    virtual const Ogre::Real getRolloffEndDistance() const;
-    // Sets the priority of this sound
-    virtual void setPriority(const int priority) = 0;
-    // Gets the priority of this sound
-    virtual const int getPriority() const = 0;
-
-    /// Spielt den Sound ab.
-    virtual void play(bool destroyWhenDone=false) = 0;
-    /// Pausiert den Sound.
-    virtual void pause(bool pausing) = 0;
-    /// Ist der Sound pausiert?
-    virtual bool isPaused() = 0;
-    /// Stoppt den Sound.
-    virtual void stop() = 0;
-    /// Laeuft der Sound noch
-    virtual const bool isPlaying() const = 0;
-   
-}; 
-
-class SoundManager
-{
-public:
-
-    SoundManager();
-    static SoundManager&amp; getSingleton(void);
-    Sound* createSound(const Ogre::String&amp; res, rl::SoundType type=ST_SAMPLE);
-    void destroySound(Sound*);
-};
-
-class GameLoop
-{
-private:
-	GameLoop();
-public:      
-	static GameLoop&amp; getSingleton(void);
-	void quitGame();
-};
-
-%apply SWIGTYPE *DYNAMIC { Job * };
-
-%feature(&quot;director&quot;) Job;
-class Job
-{
-public:
-    /**
-     * Constructor.
-     *
-     *  @param isDiscardable Set this true, if the Job's goal can be reached in a single
-     *         step. For instance if a Job is supposed to slowly close a window by fading
-     *         its alpha to 0, then it is discardable, and Job#discard will just finish
-     *         the process by closing the window.
-     *
-     *  @param destroyWhenDone Set this to true, when the JobScheduler shall delete the
-     *         Job, after execution is finished. This should usually be the case, but
-     *         sometimes it is sensible to pool a number of Jobs for reuse.
-     */
-	Job( bool isDiscardable, bool destroyWhenDone );
-	virtual ~Job();
-	
-	/**
-     * This is the function in which the job is supposed to do whatever it is supposed to do.
-     * This function is called by the JobScheduler at most once per frame. The frequency depends
-     * on the Job's priority given with JobScheduler#addJob.
-     * @param time the frame-time time, since the last call of this function.
-     * @return true, when the job is done, false else. If false is returned. The Job will be
-     * rescheduled for another execution.
-     */
-	virtual bool execute(Ogre::Real time) = 0;
-    private:
-    bool execute(Ogre::Real time);
-    /// Returns whether the job can be removed from the queue by the scheduler,
-    virtual bool isDiscardable();
-
-    /// Finish whatever the Job is doing. It won't get a chance to continue.
-    /// Overloaded functions must *not* call this implementation.
-    virtual void discard();
-
-    // Returns true, if the Job shall be deleted, if the Job is finished. Returns false else.
-    virtual bool destroyWhenDone();
-};
-
-class PlaySound2dJob : public rl::Job
-{
-public:
-    PlaySound2dJob(const Ogre::String&amp; sound, Ogre::Real volume=1.0f, int priority = Sound::PRIO_MUSIC);
-    virtual ~PlaySound2dJob();
-
-private:
-    bool execute(Ogre::Real time);
-};
-
-class PlaySound3dJob : public rl::Job
-{
-public:
-    PlaySound3dJob(const Ogre::String&amp; sound, const Ogre::Vector3&amp; pos, Ogre::Real volume=1.0f, int priority = Sound::PRIO_SFX_ENVIRONMENT);
-    virtual ~PlaySound3dJob();
-
-private:
-    bool execute(Ogre::Real time);
-};
-
-class PlayAnimationJob : public rl::Job
-{
-public:
-    PlayAnimationJob(Actor* actor, const Ogre::String&amp; anim, Ogre::Real duration,
-		bool replaceAllAnims=true);
-    PlayAnimationJob(Actor* actor, const Ogre::String&amp; anim, int loops = 1,
-		bool replaceAllAnims=true);
-    virtual ~PlayAnimationJob();
-    
-private:
-    bool execute(Ogre::Real time);
-};
-
-class StartAnimationJob : public rl::Job
-{
-public:
-    StartAnimationJob(Actor* actor, const Ogre::String&amp; anim, bool doLoop=false,
-		bool replaceAllAnims=true);
-    virtual ~StartAnimationJob();
-    
-private:
-    bool execute(Ogre::Real time);
-};
-
-//class LightFadeJob : public rl::Job
-//{
-//public:
-//    LightFadeJob(LightObject* lightObject, const Ogre::ColourValue&amp; targetDiffuse, 
-//        const Ogre::ColourValue&amp; targetSpecular, Ogre::Real duration = 1.0f);
-//
-//    virtual bool execute(Ogre::Real time);
-//};
-
-class JobQueue : public rl::Job
-{
-public:
-    JobQueue();
-    virtual ~JobQueue();
-    void add(Job* job);
-    
-private:
-    bool execute(Ogre::Real time);
-};
-
-class JobSet : public rl::Job
-{
-public:
-    JobSet();
-    virtual ~JobSet();
-    void add(Job* job);
-    
-private:
-    bool execute(Ogre::Real time);
-};
-
-class JobScheduler
-{
-public:
-    typedef enum {JP_LOW = 10, JP_NORMAL = 20, JP_HIGH = 30} JobPriority;
-	static JobScheduler&amp; getSingleton(void);
-    unsigned long addJob(rl::Job* job,
-		rl::JobScheduler::JobPriority priority = JobScheduler::JP_NORMAL,
-		Ogre::Real delay=0.0f);
-};
-
-class Zone
-{
-public:
-	void addLight(Actor* light);
-    void addSound(const Ogre::String&amp; name);
-	void addTrigger(rl::Trigger* trigger);
-	std::list&lt;Actor*&gt; getLights() const;
-    std::list&lt;Ogre::String&gt; getSounds() const;
-	std::list&lt;rl::Trigger*&gt; getTriggers() const;
-    void removeLight(Actor* light);
-    void removeSound(const Ogre::String&amp; name);
-    void removeTrigger(rl::Trigger* trigger);
-protected:
-    Zone(long id);
-private:
-    Zone();
-};
-
-
-class ZoneManager
-{
-public:
-	static const ZoneManager&amp; getSingleton();
-    rl::Zone* createZone(const Ogre::String&amp; name, bool needsToBeSaved);
-    void destroyZone(const Ogre::String&amp; name);
-
-    void addAreaToZone(const Ogre::String&amp; name, 
-        Ogre::Vector3 size, rl::GeometryType geom,
-        Ogre::Vector3 position, Ogre::Vector3 offset, Ogre::Quaternion orientation,
-        Ogre::Real transitionDistance,
-        unsigned long queryflags);
-
-    void subtractAreaFromZone(const Ogre::String&amp; name, 
-        Ogre::Vector3 size, rl::GeometryType geom,
-        Ogre::Vector3 position, Ogre::Vector3 offset, Ogre::Quaternion orientation,
-        Ogre::Real transitionDistance,
-        unsigned long queryflags);
-
-    void addMeshAreaToZone(const Ogre::String&amp; name,
-        const Ogre::String&amp; meshname, rl::GeometryType geom,
-        Ogre::Vector3 position,
-        Ogre::Vector3 scale, Ogre::Vector3 offset, Ogre::Quaternion orientation,
-        Ogre::Real transitionDistance,
-        unsigned long queryflags);
-
-    void subtractMeshAreaFromZone(const Ogre::String&amp; name,
-        const Ogre::String&amp; meshname, rl::GeometryType geom,
-        Ogre::Vector3 position,
-        Ogre::Vector3 scale, Ogre::Vector3 offset, Ogre::Quaternion orientation,
-        Ogre::Real transitionDistance,
-        unsigned long queryflags);
-        
-	rl::Zone* getDefaultZone();
-	rl::Zone* getZone(const Ogre::String&amp; name);
-    rl::Zone* getZone(long id);
-    bool isZoneActive(const rl::Zone *zone) const;
-    bool isInZone(Zone* zone, Actor *actor);
-};
-
-%feature(&quot;director&quot;) Trigger;
-class  Trigger
-{
-public:
-    Trigger(const Ogre::String &amp;classname, const Ogre::String &amp;name, bool needsToBeSaved);
-    virtual ~Trigger();
-	virtual bool activate() = 0;
-	virtual bool deactivate() = 0;
-	virtual bool deleteIfZoneDestroyed() const;
-	const Ogre::String&amp; getName() const;
-    virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
-    virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
-    virtual rl::PropertyKeys getAllPropertyKeys() const;
-};
-
-class SoundFadeJob : public rl::Job
-{
-public:
-    SoundFadeJob(SoundObject* soundObject, rl::SoundFadeFunctor* functor, bool destroyWhenDone);
-
-    virtual bool execute(Ogre::Real time);
-    virtual void discard();
-};
-
-%rename(getVolume) rl::SoundFadeFunctor::operator();
-class SoundFadeFunctor
-{
-public:
-    SoundFadeFunctor(Ogre::Real duration);
-
-    virtual Ogre::Real operator()(Ogre::Real time) = 0;
-};
-
-%rename(getVolume) rl::LinearSoundFadeFunctor::operator();
-class LinearSoundFadeFunctor : public rl::SoundFadeFunctor
-{
-public:
-    LinearSoundFadeFunctor(Ogre::Real duration, bool up);
-
-    virtual Ogre::Real operator()(Ogre::Real time);
-};
-
-%rename(getVolume) rl::PolynomicSoundFadeFunctor::operator();
-typedef std::vector&lt; std::pair&lt;Ogre::Real, Ogre::Real&gt; &gt; InterpolationPoints;
-typedef std::vector&lt;Ogre::Real&gt; Parameters;
-class PolynomicSoundFadeFunctor : public rl::SoundFadeFunctor
-{
-public:
-    PolynomicSoundFadeFunctor(Ogre::Real duration, InterpolationPoints *points);
-	~PolynomicSoundFadeFunctor();
-
-    virtual Ogre::Real operator()(Ogre::Real time);
-};
-
-typedef RL_LONGLONG rl::Time;
-
-class TimeSource : public rl::GameTask
-{
-public:
-    typedef enum
-    {
-        REALTIME_CONTINUOUS,
-        REALTIME_INTERRUPTABLE,
-        GAMETIME
-    }  TimeSourceType;
-    
-    virtual rl::TimeSource::TimeSourceType getType() const = 0;
-
-    virtual rl::Time getClock() const = 0;
-    virtual void setClock(const rl::Time&amp; time) = 0;
-    virtual void setTimeFactor(Ogre::Real factor = 1.0) = 0;
-};
-
-class TimeSourceManager
-{
-public:
-    static rl::TimeSourceManager&amp; getSingleton();
-    void registerTimeSource(rl::TimeSource* ts);
-    rl::TimeSource* getTimeSource(const rl::TimeSource::TimeSourceType&amp; type) const;
-};
-
-
-}
+    // void loadMap(const Ogre::String&amp; type, const Ogre::String&amp; filename, const Ogre::String&amp; resourceGroup);
+
+	void registerModule(rl::ContentModule* module);
+
+	rl::ContentModule* getActiveAdventureModule() const;
+    rl::ContentModule* getModule(const Ogre::String&amp; moduleId) const;
+
+    rl::World* getWorld();
+    void makeScreenshot(const Ogre::String&amp; sName);
+    bool isInitialized() const;
+    void setScheme(const Ogre::String&amp; schemeName);
+    bool getDeveloperMode() const;
+    void setTimeFactor(const Ogre::Real&amp; factor = 1.0F);
+    void setPaused(bool paused);
+};
+
+class Sound 
+{
+private:
+	Sound(const SoundResourcePtr&amp; res);
+public:
+    // Einige Standardwerte fr Soundprioritten.
+    enum SOUND_PRIORITY {
+            PRIO_SPEECH = 30,
+            PRIO_MUSIC = 75,
+            PRIO_SFX_ENVIRONMENT = 128,
+            PRIO_SFX_OTHER = 175,
+            PRIO_OTHER = 220
+    };
+
+	virtual ~Sound();
+    
+    /// Name zurueckgeben
+    const Ogre::String&amp; getName() const;
+
+    /// Gibt die eingestellte Position der Soundquelle zurueck
+    const Ogre::Vector3 getPosition() const;
+    /// Setzt die Position der Soundquelle.
+    void setPosition(const Ogre::Vector3&amp; direction);
+    /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck
+    const Ogre::Real getVolume() const; 
+    /// Setzt die relative Lautstaerke der Soundquelle.
+    void setVolume(const Ogre::Real gain);
+    /// Gibt die Richtung der Soundquelle zurueck.
+    const Ogre::Quaternion getDirection() const;
+    /// Gibt die Geschwindigkeit der Soundquelle zurueck.
+    const Ogre::Vector3 getVelocity() const;
+    /// Setzt die Richtung der Soundquelle.
+    void setDirection(const Ogre::Quaternion&amp;);
+    /// Setzt die Geschwindigkeit der Soundquelle.
+    void setVelocity(const Ogre::Vector3&amp;);
+    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
+	void setRolloffStartDistance(const Ogre::Real dist);
+	const Ogre::Real getRolloffStartDistance() const;
+	/// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
+	void setRolloffEndDistance(const Ogre::Real dist);
+	const Ogre::Real getRolloffEndDistance() const;
+
+    /// Spielt den Sound ab.
+    void play() ;
+    /// Pausiert den Sound.
+    void pause(bool pausing) ;
+    /// Ist der Sound pausiert?
+    bool isPaused() ;
+    /// Stoppt den Sound.
+    void stop() ;
+    /// Laeuft der Sound noch
+    const bool isPlaying() const ;
+
+    // Sets the priority of this sound
+    virtual void setPriority(const int priority);
+    // Gets the priority of this sound
+    virtual const int getPriority() const;
+
+    /// Gibt zurck ob der Sound geloopt werden soll 
+    bool isLooping() const;
+    /// Setzt ob der Sound geloopt werden soll 
+    void setLooping( bool looping );
+    
+    // Sind wir gueltig
+    bool isValid() const;
+    
+    bool is3d();
+    void set3d(bool is3d);
+};
+
+typedef std::map&lt;CeGuiString, SoundResourcePtr&gt; SoundCache;
+
+class SoundStitching
+{
+public:
+    // Einige Standardwerte f&#252;r Soundpriorit&#228;ten.
+    enum SOUND_PRIORITY {
+        PRIO_SPEECH = 30,
+        PRIO_MUSIC = 75,
+        PRIO_SFX_ENVIRONMENT = 128,
+        PRIO_SFX_OTHER = 175,
+        PRIO_OTHER = 220
+    };
+
+    /// Konstruktor
+    SoundStitching(unsigned int numSlots, rl::CeGuiString name, rl::SoundDriver* creator);
+    /// Destruktor
+    virtual ~SoundStitching();
+      
+    // SoundResource zurueckgeben.
+    const rl::SoundResourcePtr&amp; getSoundResource() const;
+    // Wollen wir 3D?
+    bool is3d() const;
+    // Setzen des 3D-Flags.
+    void set3d(bool is3d);
+    // Sind wir gueltig
+    virtual bool isValid() const;
+    
+    // Sollen der Sound wiederholt werden?
+    bool isLooping() const;
+    // Setzen des Loop-Flags.
+    void setLooping(bool looping);
+
+    virtual float getLength() const = 0;
+
+    /// Unsere Bounding-Box
+    virtual const Ogre::AxisAlignedBox&amp; getBoundingBox(void) const;
+    /// Bound-Radius
+    virtual Ogre::Real getBoundingRadius() const;
+    /// Rendern
+    virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+
+    /// Count of configured slots.
+    unsigned int getNumSlots();
+    /// Add a sound resource to the cache overwritting existing sound resource.
+    virtual void addSoundToCache(rl::CeGuiString label, rl::SoundResourcePtr sound);
+    /// Assign a sound recource to a slot.
+    virtual void putSoundIntoSlot(unsigned int, rl::CeGuiString label) = 0;
+    /// Get the slot of the plaing sound.
+    virtual unsigned int getPlayingSlot() = 0;
+
+    /// Gibt die eingestellte Position der Soundquelle zurueck
+    virtual const Ogre::Vector3 getPosition() const = 0;
+    /// Setzt die Position der Soundquelle.
+    virtual void setPosition(const Ogre::Vector3&amp; direction) = 0;
+    /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
+    virtual const Ogre::Real getVolume() const = 0; 
+    /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
+    virtual void setVolume(const Ogre::Real gain) = 0;
+    /// Gibt die Richtung der Soundquelle zurueck.
+    virtual const Ogre::Quaternion getDirection() const = 0;
+    /// Gibt die Geschwindigkeit der Soundquelle zurueck.
+    virtual const Ogre::Vector3 getVelocity() const = 0;
+    /// Setzt die Richtung der Soundquelle.
+    virtual void setDirection(const Ogre::Quaternion&amp;) = 0;
+    /// Setzt die Geschwindigkeit der Soundquelle.
+    virtual void setVelocity(const Ogre::Vector3&amp;) = 0;
+    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
+    virtual void setRolloffStartDistance(const Ogre::Real&amp;);
+    virtual const Ogre::Real getRolloffStartDistance() const;
+    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
+    virtual void setRolloffEndDistance(const Ogre::Real&amp;);
+    virtual const Ogre::Real getRolloffEndDistance() const;
+    // Sets the priority of this sound
+    virtual void setPriority(const int priority) = 0;
+    // Gets the priority of this sound
+    virtual const int getPriority() const = 0;
+
+    /// Spielt den Sound ab.
+    virtual void play(bool destroyWhenDone=false) = 0;
+    /// Pausiert den Sound.
+    virtual void pause(bool pausing) = 0;
+    /// Ist der Sound pausiert?
+    virtual bool isPaused() = 0;
+    /// Stoppt den Sound.
+    virtual void stop() = 0;
+    /// Laeuft der Sound noch
+    virtual const bool isPlaying() const = 0;
+   
+}; 
+
+class SoundManager
+{
+public:
+
+    SoundManager();
+    static SoundManager&amp; getSingleton(void);
+    Sound* createSound(const Ogre::String&amp; res, rl::SoundType type=ST_SAMPLE);
+    void destroySound(Sound*);
+};
+
+class GameLoop
+{
+private:
+	GameLoop();
+public:      
+	static GameLoop&amp; getSingleton(void);
+	void quitGame();
+};
+
+%apply SWIGTYPE *DYNAMIC { Job * };
+
+%feature(&quot;director&quot;) Job;
+class Job
+{
+public:
+    /**
+     * Constructor.
+     *
+     *  @param isDiscardable Set this true, if the Job's goal can be reached in a single
+     *         step. For instance if a Job is supposed to slowly close a window by fading
+     *         its alpha to 0, then it is discardable, and Job#discard will just finish
+     *         the process by closing the window.
+     *
+     *  @param destroyWhenDone Set this to true, when the JobScheduler shall delete the
+     *         Job, after execution is finished. This should usually be the case, but
+     *         sometimes it is sensible to pool a number of Jobs for reuse.
+     */
+	Job( bool isDiscardable, bool destroyWhenDone );
+	virtual ~Job();
+	
+	/**
+     * This is the function in which the job is supposed to do whatever it is supposed to do.
+     * This function is called by the JobScheduler at most once per frame. The frequency depends
+     * on the Job's priority given with JobScheduler#addJob.
+     * @param time the frame-time time, since the last call of this function.
+     * @return true, when the job is done, false else. If false is returned. The Job will be
+     * rescheduled for another execution.
+     */
+	virtual bool execute(Ogre::Real time) = 0;
+    private:
+    bool execute(Ogre::Real time);
+    /// Returns whether the job can be removed from the queue by the scheduler,
+    virtual bool isDiscardable();
+
+    /// Finish whatever the Job is doing. It won't get a chance to continue.
+    /// Overloaded functions must *not* call this implementation.
+    virtual void discard();
+
+    // Returns true, if the Job shall be deleted, if the Job is finished. Returns false else.
+    virtual bool destroyWhenDone();
+};
+
+class PlaySound2dJob : public rl::Job
+{
+public:
+    PlaySound2dJob(const Ogre::String&amp; sound, Ogre::Real volume=1.0f, int priority = Sound::PRIO_MUSIC);
+    virtual ~PlaySound2dJob();
+
+private:
+    bool execute(Ogre::Real time);
+};
+
+class PlaySound3dJob : public rl::Job
+{
+public:
+    PlaySound3dJob(const Ogre::String&amp; sound, const Ogre::Vector3&amp; pos, Ogre::Real volume=1.0f, int priority = Sound::PRIO_SFX_ENVIRONMENT);
+    virtual ~PlaySound3dJob();
+
+private:
+    bool execute(Ogre::Real time);
+};
+
+class PlayAnimationJob : public rl::Job
+{
+public:
+    PlayAnimationJob(Actor* actor, const Ogre::String&amp; anim, Ogre::Real duration,
+		bool replaceAllAnims=true);
+    PlayAnimationJob(Actor* actor, const Ogre::String&amp; anim, int loops = 1,
+		bool replaceAllAnims=true);
+    virtual ~PlayAnimationJob();
+    
+private:
+    bool execute(Ogre::Real time);
+};
+
+class StartAnimationJob : public rl::Job
+{
+public:
+    StartAnimationJob(Actor* actor, const Ogre::String&amp; anim, bool doLoop=false,
+		bool replaceAllAnims=true);
+    virtual ~StartAnimationJob();
+    
+private:
+    bool execute(Ogre::Real time);
+};
+
+//class LightFadeJob : public rl::Job
+//{
+//public:
+//    LightFadeJob(LightObject* lightObject, const Ogre::ColourValue&amp; targetDiffuse, 
+//        const Ogre::ColourValue&amp; targetSpecular, Ogre::Real duration = 1.0f);
+//
+//    virtual bool execute(Ogre::Real time);
+//};
+
+class JobQueue : public rl::Job
+{
+public:
+    JobQueue();
+    virtual ~JobQueue();
+    void add(Job* job);
+    
+private:
+    bool execute(Ogre::Real time);
+};
+
+class JobSet : public rl::Job
+{
+public:
+    JobSet();
+    virtual ~JobSet();
+    void add(Job* job);
+    
+private:
+    bool execute(Ogre::Real time);
+};
+
+class JobScheduler
+{
+public:
+    typedef enum {JP_LOW = 10, JP_NORMAL = 20, JP_HIGH = 30} JobPriority;
+	static JobScheduler&amp; getSingleton(void);
+    unsigned long addJob(rl::Job* job,
+		rl::JobScheduler::JobPriority priority = JobScheduler::JP_NORMAL,
+		Ogre::Real delay=0.0f);
+};
+
+class Zone
+{
+public:
+	void addLight(Actor* light);
+    void addSound(const Ogre::String&amp; name);
+	void addTrigger(rl::Trigger* trigger);
+	std::list&lt;Actor*&gt; getLights() const;
+    std::list&lt;Ogre::String&gt; getSounds() const;
+	std::list&lt;rl::Trigger*&gt; getTriggers() const;
+    void removeLight(Actor* light);
+    void removeSound(const Ogre::String&amp; name);
+    void removeTrigger(rl::Trigger* trigger);
+protected:
+    Zone(long id);
+private:
+    Zone();
+};
+
+
+class ZoneManager
+{
+public:
+	static const ZoneManager&amp; getSingleton();
+    rl::Zone* createZone(const Ogre::String&amp; name, bool needsToBeSaved);
+    void destroyZone(const Ogre::String&amp; name);
+
+    void addAreaToZone(const Ogre::String&amp; name, 
+        Ogre::Vector3 size, rl::GeometryType geom,
+        Ogre::Vector3 position, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+        Ogre::Real transitionDistance,
+        unsigned long queryflags);
+
+    void subtractAreaFromZone(const Ogre::String&amp; name, 
+        Ogre::Vector3 size, rl::GeometryType geom,
+        Ogre::Vector3 position, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+        Ogre::Real transitionDistance,
+        unsigned long queryflags);
+
+    void addMeshAreaToZone(const Ogre::String&amp; name,
+        const Ogre::String&amp; meshname, rl::GeometryType geom,
+        Ogre::Vector3 position,
+        Ogre::Vector3 scale, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+        Ogre::Real transitionDistance,
+        unsigned long queryflags);
+
+    void subtractMeshAreaFromZone(const Ogre::String&amp; name,
+        const Ogre::String&amp; meshname, rl::GeometryType geom,
+        Ogre::Vector3 position,
+        Ogre::Vector3 scale, Ogre::Vector3 offset, Ogre::Quaternion orientation,
+        Ogre::Real transitionDistance,
+        unsigned long queryflags);
+        
+	rl::Zone* getDefaultZone();
+	rl::Zone* getZone(const Ogre::String&amp; name);
+    rl::Zone* getZone(long id);
+    bool isZoneActive(const rl::Zone *zone) const;
+    bool isInZone(Zone* zone, Actor *actor);
+};
+
+%feature(&quot;director&quot;) Trigger;
+class  Trigger
+{
+public:
+    Trigger(const Ogre::String &amp;classname, const Ogre::String &amp;name, bool needsToBeSaved);
+    virtual ~Trigger();
+	virtual bool activate() = 0;
+	virtual bool deactivate() = 0;
+	virtual bool deleteIfZoneDestroyed() const;
+	const Ogre::String&amp; getName() const;
+    virtual const rl::Property getProperty(const rl::CeGuiString&amp; key) const;
+    virtual void setProperty(const rl::CeGuiString&amp; key, const rl::Property&amp; value);
+    virtual rl::PropertyKeys getAllPropertyKeys() const;
+};
+
+class SoundFadeJob : public rl::Job
+{
+public:
+    SoundFadeJob(SoundObject* soundObject, rl::SoundFadeFunctor* functor, bool destroyWhenDone);
+
+    virtual bool execute(Ogre::Real time);
+    virtual void discard();
+};
+
+%rename(getVolume) rl::SoundFadeFunctor::operator();
+class SoundFadeFunctor
+{
+public:
+    SoundFadeFunctor(Ogre::Real duration);
+
+    virtual Ogre::Real operator()(Ogre::Real time) = 0;
+};
+
+%rename(getVolume) rl::LinearSoundFadeFunctor::operator();
+class LinearSoundFadeFunctor : public rl::SoundFadeFunctor
+{
+public:
+    LinearSoundFadeFunctor(Ogre::Real duration, bool up);
+
+    virtual Ogre::Real operator()(Ogre::Real time);
+};
+
+%rename(getVolume) rl::PolynomicSoundFadeFunctor::operator();
+typedef std::vector&lt; std::pair&lt;Ogre::Real, Ogre::Real&gt; &gt; InterpolationPoints;
+typedef std::vector&lt;Ogre::Real&gt; Parameters;
+class PolynomicSoundFadeFunctor : public rl::SoundFadeFunctor
+{
+public:
+    PolynomicSoundFadeFunctor(Ogre::Real duration, InterpolationPoints *points);
+	~PolynomicSoundFadeFunctor();
+
+    virtual Ogre::Real operator()(Ogre::Real time);
+};
+
+typedef RL_LONGLONG rl::Time;
+
+class TimeSource : public rl::GameTask
+{
+public:
+    typedef enum
+    {
+        REALTIME_CONTINUOUS,
+        REALTIME_INTERRUPTABLE,
+        GAMETIME
+    }  TimeSourceType;
+    
+    virtual rl::TimeSource::TimeSourceType getType() const = 0;
+
+    virtual rl::Time getClock() const = 0;
+    virtual void setClock(const rl::Time&amp; time) = 0;
+    virtual void setTimeFactor(Ogre::Real factor = 1.0) = 0;
+};
+
+class TimeSourceManager
+{
+public:
+    static rl::TimeSourceManager&amp; getSingleton();
+    void registerTimeSource(rl::TimeSource* ts);
+    rl::TimeSource* getTimeSource(const rl::TimeSource::TimeSourceType&amp; type) const;
+};
+
+
+}

Modified: rl/trunk/engine/ui/include/DialogControlState.h
===================================================================
--- rl/trunk/engine/ui/include/DialogControlState.h	2009-05-20 00:09:27 UTC (rev 4932)
+++ rl/trunk/engine/ui/include/DialogControlState.h	2009-05-20 20:03:56 UTC (rev 4933)
@@ -19,11 +19,11 @@
 
 #include &quot;UiPrerequisites.h&quot;
 #include &quot;DialogController.h&quot;
+#include &quot;Creature.h&quot;
 
 namespace rl {
 
 	class Actor;
-    class Creature;
 	class Dialog;
     class DialogElement;
 	class DialogWindow;
@@ -83,7 +83,7 @@
 
 		DialogWindow* mDialogWindow;
 
-        virtual void recalculateDialogCamera(Creature* speaker, std::list&lt;Creature*&gt; listeners);
+        virtual void recalculateDialogCamera(Creature* speaker, const CreatureList&amp; listeners);
 
         void showOptions(const std::list&lt;DialogOption*&gt;&amp; options);
 	};

Modified: rl/trunk/engine/ui/include/DialogController.h
===================================================================
--- rl/trunk/engine/ui/include/DialogController.h	2009-05-20 00:09:27 UTC (rev 4932)
+++ rl/trunk/engine/ui/include/DialogController.h	2009-05-20 20:03:56 UTC (rev 4933)
@@ -9,15 +9,12 @@
 #define DIALOGCONTROLLER_H_
 
 #include &quot;AiPrerequisites.h&quot;
-
-#include &lt;list&gt;
-
 #include &quot;ControlState.h&quot;
+#include &quot;Creature.h&quot;
 
 namespace rl
 {
     class Actor;
-    class Creature;
     class Dialog;
     class DialogOption;
     class DialogParagraph;
@@ -52,7 +49,7 @@
         void doTalk(DialogParagraph* paragraph, DialogWindow* window = NULL);
         Ogre::Vector3 getParticipantPosition(Creature* participant);
         virtual bool textFinished();
-        virtual void recalculateDialogCamera(Creature* speaker, std::list&lt;Creature*&gt; listeners) = 0;
+        virtual void recalculateDialogCamera(Creature* speaker, const CreatureList&amp; listeners) = 0;
         virtual void handleDialogEnd() = 0;
         void setDialogWindow(DialogWindow* window);
         void setSubtitleWindow(SubtitleWindow* window);
@@ -68,7 +65,7 @@
         Ogre::Real mTotalFadeTextTime;
         Ogre::Real mSubtitleSpeed;
         Creature* mCurrentSpeaker;
-        std::list&lt;Creature*&gt; mCurrentListeners;
+        CreatureList mCurrentListeners;
         /// Der Untertitel-Text
         CeGuiString mText;
         /// Es wird gerade Text angezeigt

Modified: rl/trunk/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogControlState.cpp	2009-05-20 00:09:27 UTC (rev 4932)
+++ rl/trunk/engine/ui/src/DialogControlState.cpp	2009-05-20 20:03:56 UTC (rev 4933)
@@ -196,7 +196,7 @@
                 + StringConverter::toString(mCurrFadeTextTime));
     }
 
-    void DialogControlState::recalculateDialogCamera(Creature* speaker, std::list&lt;Creature*&gt; listeners)
+    void DialogControlState::recalculateDialogCamera(Creature* speaker, const CreatureList&amp; listeners)
     {
         // Position camera at position between char and dialog partner
         Vector3 speakerEyes = getParticipantPosition(speaker);
@@ -221,8 +221,8 @@
         mSubtitleWindow = NULL;
         if (mDialog != NULL)
         {
-            const list&lt;Creature*&gt; list = mDialog-&gt;getParticipants();
-            for (std::list&lt;Creature*&gt;::const_iterator it = list.begin(); it != list.end(); ++it)
+            const CreatureList list = mDialog-&gt;getParticipants();
+            for (CreatureList::const_iterator it = list.begin(); it != list.end(); ++it)
             {
                 Actor* actor = (*it)-&gt;getActor();
                 if (actor != NULL)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001988.html">[Dsa-hl-svn] r4932 - in rl/trunk/engine: core/src ui/include ui/src
</A></li>
	<LI>Next message: <A HREF="001990.html">[Dsa-hl-svn] r4934 - in modules: common/scripts common/scripts/jobs	regressiontest/scripts
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1989">[ date ]</a>
              <a href="thread.html#1989">[ thread ]</a>
              <a href="subject.html#1989">[ subject ]</a>
              <a href="author.html#1989">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
