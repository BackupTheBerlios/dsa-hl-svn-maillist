From timm at mail.berlios.de  Mon Sep  1 21:57:28 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Mon, 1 Sep 2008 21:57:28 +0200
Subject: [Dsa-hl-svn] r4492 - in modules: . teichtest teichtest/dsa
	teichtest/gui teichtest/gui/windows teichtest/maps
	teichtest/materials teichtest/materials/textures
	teichtest/models teichtest/quests teichtest/scripts
	teichtest/scripts/maps
Message-ID: <200809011957.m81JvSY2011709@sheep.berlios.de>

Author: timm
Date: 2008-09-01 21:57:00 +0200 (Mon, 01 Sep 2008)
New Revision: 4492

Added:
   modules/teichtest/
   modules/teichtest/dialogs/
   modules/teichtest/dsa/
   modules/teichtest/dsa/gameobjectdefinitions.gof
   modules/teichtest/gui/
   modules/teichtest/gui/fonts/
   modules/teichtest/gui/imagesets/
   modules/teichtest/gui/schemes/
   modules/teichtest/gui/windows/
   modules/teichtest/gui/windows/buttons/
   modules/teichtest/maps/
   modules/teichtest/maps/hero.rlmap.xml
   modules/teichtest/maps/teichtest.rlmap.xml
   modules/teichtest/maps/teichtest.rlscene
   modules/teichtest/materials/
   modules/teichtest/materials/Fresnel.source
   modules/teichtest/materials/FresnelPS_ASM.source
   modules/teichtest/materials/Numbers.material
   modules/teichtest/materials/basic_reflection.material
   modules/teichtest/materials/disorton.material
   modules/teichtest/materials/ins_rucksack.material
   modules/teichtest/materials/nx.grid.material
   modules/teichtest/materials/nx.particles.material
   modules/teichtest/materials/nx.shapes.material
   modules/teichtest/materials/nx.stairs.material
   modules/teichtest/materials/nx.track.material
   modules/teichtest/materials/nx.zones.material
   modules/teichtest/materials/teichtest.material
   modules/teichtest/materials/textures/
   modules/teichtest/materials/textures/Thumbs.db
   modules/teichtest/materials/textures/felsen_3_kana.png
   modules/teichtest/materials/textures/gras_kana.png
   modules/teichtest/materials/textures/ins_rucksack.png
   modules/teichtest/materials/textures/nx.grid.axis.png
   modules/teichtest/materials/textures/nx.grid.floor.png
   modules/teichtest/materials/textures/nx.particle.smoke.png
   modules/teichtest/materials/textures/nx.particle.steam.png
   modules/teichtest/materials/textures/nx.static.wall.png
   modules/teichtest/materials/textures/nx.trafficcone.png
   modules/teichtest/materials/textures/nx.zone.blue.png
   modules/teichtest/materials/textures/nx.zone.green.png
   modules/teichtest/materials/textures/nx.zone.nogravity.png
   modules/teichtest/materials/textures/nx.zone.orange.png
   modules/teichtest/materials/textures/nx.zone.pink.png
   modules/teichtest/materials/textures/obj_shortsleeve_dummy.png
   modules/teichtest/materials/textures/perlinvolume.dds
   modules/teichtest/materials/textures/waves2.dds
   modules/teichtest/medianotes.txt
   modules/teichtest/models/
   modules/teichtest/models/felsen.mesh
   modules/teichtest/models/ins_rucksack.mesh
   modules/teichtest/models/sphere.1m.mesh
   modules/teichtest/models/wasser.mesh
   modules/teichtest/models/wiese.mesh
   modules/teichtest/quests/
   modules/teichtest/quests/test.quests
   modules/teichtest/scripts/
   modules/teichtest/scripts/maps/
   modules/teichtest/scripts/maps/setchar.rb
   modules/teichtest/scripts/moduleconfig.rb
   modules/teichtest/sound/
Modified:
   modules/modules.cfg
Log:
Teichtest module

Modified: modules/modules.cfg
===================================================================
--- modules/modules.cfg	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/modules.cfg	2008-09-01 19:57:00 UTC (rev 4492)
@@ -14,4 +14,5 @@
 module=kanalisation
 
 module=persistenztest
+module=teichtest
 

Added: modules/teichtest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/teichtest/dsa/gameobjectdefinitions.gof	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/dsa/gameobjectdefinitions.gof	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,211 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<GameObjectDefinitions>
+
+    <gameobjectclass classid="Holzscheit" baseclass="GameObject">
+        <property name="name" type="STRING" data="Holzscheit"/>
+        <property name="description" type="STRING" data="Greater log of time check. (Very rare)"/>
+        <property name="meshfile" type="STRING" data="ver_holzscheit_01.mesh"/>
+    </gameobjectclass>
+	
+	<gameobjectclass classid="number1" baseclass="GameObject">
+        <property name="name" type="STRING" data="1"/>
+        <property name="description" type="STRING" data="Karte Nummer 1"/>
+        <property name="meshfile" type="STRING" data="Number1.mesh"/>
+        <property name="geometrytype" type="STRING" data="capsule"/>
+        <property name="mass" type="REAL" data="200"/>
+    </gameobjectclass>
+	
+	<gameobjectclass classid="number2" baseclass="GameObject">
+        <property name="name" type="STRING" data="2"/>
+        <property name="description" type="STRING" data="Karte Nummer 2"/>
+        <property name="meshfile" type="STRING" data="Number2.mesh"/>
+        <property name="geometrytype" type="STRING" data="box"/>
+        <property name="mass" type="REAL" data="200"/>
+    </gameobjectclass>
+
+    <gameobjectclass classid="apple" baseclass="GameObject">
+        <property name="name" type="STRING" data="Apfel"/>
+        <property name="description" type="STRING" data="Ein Apfel?"/>
+        <property name="meshfile" type="STRING" data="sphere.1m.mesh"/>
+        <property name="geometrytype" type="STRING" data="ellipsoid"/>
+        <property name="mass" type="REAL" data="65"/>
+    </gameobjectclass>
+
+    <gameobjectclass classid="apple2" baseclass="GameObject" inherits="apple">
+        <property name="name" type="STRING" data="Apfel 2.0"/>
+        <property name="description" type="STRING" data="Ein Apfel. Definitiv."/>
+        <property name="mass" type="REAL" data="75"/>
+    </gameobjectclass>
+
+    <gameobjectclass classid="TestPerson" baseclass="NPC">
+        <property name="name" type="STRING" data="TestPerson"/>
+        <property name="description" type="STRING" data="Wenn man mal jemanden zum Reden braucht..."/>
+        <property name="geometrytype" type="STRING" data="ellipsoid"/>
+        <property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+        <property name="mass" type="REAL" data="65"/>
+        <property name="dialog" type="STRING" data="testdialog"/>
+        <property name="behaviours" type="ARRAY">
+            <property type="STRING" data="DefaultIdleBehaviour"/>
+            <property type="STRING" data="DialogBehaviour"/>
+        </property>
+		<property name="eigenschaften" type="MAP">
+			<property name="MU" type="INT" data="12"/>
+			<property name="KL" type="INT" data="8"/>
+			<property name="IN" type="INT" data="9"/>
+			<property name="CH" type="INT" data="10"/>
+			<property name="FF" type="INT" data="11"/>
+			<property name="GE" type="INT" data="12"/>
+			<property name="KO" type="INT" data="13"/>
+			<property name="KK" type="INT" data="14"/>
+		</property>
+		<property name="talente" type="MAP">
+			<property name="Athletik" type="INT" data="3"/>
+<!--			<property name="K?rperbeherrschung" type="INT" data="3"/>-->
+		</property>
+		<!-- Animationen und Animationsgeschwindigkeiten fuer den CreatureController -->
+		<property name="animations" type="MAP">
+			<property name="stehen" type="STRING" data="idle"/>
+			<property name="stehen_rechts" type="STRING" data="drehen_rechts"/>
+			<property name="stehen_links" type="STRING" data="drehen_links"/>
+			<!-- property name="seitwaerts_links" type="STRING" data="seitwaerts_links"/ -->
+			<!-- property name="seitwaerts_rechts" type="STRING" data="seitwaerts_rechts"/ -->
+			<property name="gehen" type="STRING" data="gehen"/>
+			<property name="gehen_rueckwaerts" type="STRING" data="gehen_rueckwaerts"/>
+			<property name="joggen_rueckwaerts" type="STRING" data="gehen_rueckwaerts"/>
+			<property name="joggen" type="STRING" data="rennen"/>
+			<property name="laufen" type="STRING" data="rennen"/>
+			<property name="rennen" type="STRING" data="rennen"/>
+			<property name="stehen_zu_schleichen" type="STRING" data="idle_zu_hocke"/>
+			<property name="schleichen_zu_stehen" type="STRING" data="hocke_zu_stehen"/>
+			<property name="schleichen" type="STRING" data="hocke_idle"/>
+			<property name="schleichen_vorwaerts" type="STRING" data="hocke_gehen"/>
+			<property name="hochsprung_absprung" type="STRING" data="idle_absprung"/>
+			<property name="hochsprung" type="STRING" data="idle_sprung"/>
+			<property name="hochsprung_landung" type="STRING" data="idle_sprung_landung"/>
+			<property name="weitsprung_absprung" type="STRING" data="rennen_absprung"/>
+			<property name="weitsprung" type="STRING" data="rennen_sprung"/>
+			<property name="weitsprung_landung" type="STRING" data="rennen_sprung_landung"/>
+		</property>
+		<property name="animationspeeds" type="MAP">
+			<property name="gehen" type="REAL" data="1.0"/>
+			<property name="joggen" type="REAL" data="0.3"/>
+			<property name="laufen" type="REAL" data="0.5"/>
+			<property name="rennen" type="REAL" data="0.4"/>
+		</property>
+    </gameobjectclass>
+
+    <gameobjectclass classid="TestPersonCapsule" baseclass="NPC">
+        <property name="name" type="STRING" data="TestPerson"/>
+        <property name="description" type="STRING" data="Wenn man mal jemanden zum Reden braucht..."/>
+        <property name="geometrytype" type="STRING" data="capsule"/>
+        <property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+        <property name="mass" type="REAL" data="65"/>
+        <property name="dialogfile" type="STRING" data="testperson.xml"/>
+        <property name="behaviours" type="ARRAY">
+            <property type="STRING" data="DefaultIdleBehaviour"/>
+            <property type="STRING" data="DialogBehaviour"/>
+        </property>
+    </gameobjectclass>
+
+    <gameobjectclass classid="switch3way" baseclass="Switch3Way">
+        <property name="name" type="STRING" data="Hebel"/>
+        <property name="description" type="STRING" data="Ein Hebel"/>
+        <property name="meshfile" type="STRING" data="arc_hebel_01.mesh"/>
+        <property name="geometrytype" type="STRING" data="sphere"/>
+    </gameobjectclass>
+
+    <gameobjectclass classid="shortsword" baseclass="Weapon">
+        <property name="name" type="STRING" data="Kurzschwert"/>
+        <property name="description" type="STRING" data="Ein ordin?res Kurzschwert - scharf, aber langweilig"/>
+        <property name="meshfile" type="STRING" data="waf_kurzschwert_01.mesh"/>
+        <property name="imagename" type="STRING" data="set:ModelThumbnails image:waf_kurzschwert_01"/>
+        <property name="mass" type="REAL" data="3.0"/>
+        <property name="size" type="INTPAIR" data="2,4"/>
+		<property name="geometrytype" type="STRING" data="box"/>
+    </gameobjectclass>
+
+    <gameobjectclass classid="leather backpack" baseclass="Container">
+        <property name="name" type="STRING" data="Rucksack"/>
+        <property name="description" type="STRING" data="Ein Lederrucksack (oder so)"/>
+        <property name="meshfile" type="STRING" data="men_human_female_backpack_leather_01.mesh"/>
+        <property name="submeshfile" type="STRING" data="backpack_leather_01.mesh"/>
+        <property name="imagename" type="STRING" data="set:ModelThumbnails image:Rucksack"/>
+        <property name="capacity" type="REAL" data="20.0"/>
+        <property name="volume" type="INTPAIR" data="8,6"/>
+        <property name="size" type="INTPAIR" data="2,2"/>
+        <property name="itemtype" type="INT" data="256"/>	
+		<property name="mass" type="REAL" data="5.0"/>
+		<property name="geometrytype" type="STRING" data="ellipsoid"/>
+        <property name="actions" type="ARRAY">
+			<property type="STRING" data="showcontainercontent"/>
+        </property>
+        <property name="defaultaction" type="STRING" data="showcontainercontent"/>
+    </gameobjectclass>
+
+    <!-- ErrorHandlingTest -->
+    <gameobjectclass classid="ErrorHandling" baseclass="GameObject">
+        <property name="name" type="STRING" data="ErrorHandling-TestCase"/>
+        <property name="description" type="STRING" data="The ErrorHandling TestCase"/>
+        <property name="meshfile" type="STRING" data="arc_hebel_01.mesh"/>
+    </gameobjectclass>
+
+    <!-- SoundTest -->
+    <gameobjectclass classid="SoundFadeTest" baseclass="GameObject">
+        <property name="name" type="STRING" data="SoundFadeTest"/>
+        <property name="description" type="STRING" data="The Sound Fading TestCase"/>
+        <property name="meshfile" type="STRING" data="arc_hebel_01.mesh"/>
+    </gameobjectclass>
+
+    <!-- JobSequenceTest -->
+    <gameobjectclass classid="JobSequenceTestChest" baseclass="GameObject">
+        <property name="name" type="STRING" data="JobSequence-Truhe"/>
+        <property name="description" type="STRING" data="Eine Truhe zum Test der JobSequence"/>
+        <property name="meshfile" type="STRING" data="ver_truhe_gross01.mesh"/>
+        <property name="geometrytype" type="STRING" data="box"/>
+    </gameobjectclass>
+
+    <!-- EffectTest -->
+    <gameobjectclass classid="EffectTest" baseclass="GameObject">
+        <property name="name" type="STRING" data="Bottich der Versteinerung"/>
+        <property name="description" type="STRING" data="Der Essigbottich der Versteinerung (Vorsicht!)"/>
+        <property name="meshfile" type="STRING" data="ver_essigbottich_01.mesh"/>
+        <property name="geometrytype" type="STRING" data="box"/>
+    </gameobjectclass>
+
+	<!-- SelectorTest -->
+    <gameobjectclass classid="SelectorTest" baseclass="Item">
+        <property name="name" type="STRING" data="Bottich der Auswahl"/>
+        <property name="description" type="STRING" data="Der Essigbottich des Auswahltests, harmlos :)"/>
+        <property name="meshfile" type="STRING" data="ver_essigbottich_01.mesh"/>
+        <property name="geometrytype" type="STRING" data="box"/>
+    </gameobjectclass>
+
+	<!--InventoryTest clothes-->
+    <gameobjectclass classid="Clothes #1" baseclass="Clothing">
+        <property name="name" type="STRING" data="Kleidung #1"/>
+        <property name="description" type="STRING" data="Kleidung, Variante 1"/>
+        <property name="meshfile" type="STRING" data="obj_shortsleeve.mesh"/> <!-- the mesh for when the item is placed in the world -->
+		<property name="submeshfile" type="STRING" data="obj_shortsleeve.mesh"/> <!-- the mesh for when the item is worn by a creature -->
+        <property name="geometrytype" type="STRING" data="box"/>
+        <property name="material" type="STRING" data="obj_Shortsleeve"/>
+		<property name="itemtype" type="INT" data="32768"/> <!-- Clothes -->
+		<property name="size" type="INTPAIR" data="2,4"/>
+    </gameobjectclass>
+    <gameobjectclass classid="Clothes #2" baseclass="Clothing">
+        <property name="name" type="STRING" data="Kleidung #2"/>
+        <property name="description" type="STRING" data="Kleidung, Variante 2"/>
+        <property name="meshfile" type="STRING" data="obj_shortsleeve.mesh"/> <!-- the mesh for when the item is placed in the world -->
+		<property name="submeshfile" type="STRING" data="obj_shortsleeve.mesh"/> <!-- the mesh for when the item is worn by a creature -->
+        <property name="geometrytype" type="STRING" data="box"/>
+        <property name="material" type="STRING" data="obj_Shortsleeve_2"/>
+		<property name="itemtype" type="INT" data="32768"/> <!-- Clothes -->
+		<property name="size" type="INTPAIR" data="2,4"/>
+    </gameobjectclass>
+
+    <gameobjectclass classid="MeshAreaTestHouse" baseclass="GameObject">
+        <property name="name" type="STRING" data="MeshAreaTestHouse"/>
+	<property name="meshfile" type="STRING" data="arc_Wirtshaus_02.mesh"/>
+	<property name="geometrytype" type="STRING" data="none"/>
+    </gameobjectclass>
+	
+</GameObjectDefinitions>

Added: modules/teichtest/maps/hero.rlmap.xml
===================================================================
--- modules/teichtest/maps/hero.rlmap.xml	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/maps/hero.rlmap.xml	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,7 @@
+<scene formatVersion="0.4.0" scenescript="setchar.rb">
+    <nodes>
+        <gameobject class="mckhero" id="10" state="IN_SCENE">
+            <position x="2" y="0.0" z="0"/>
+        </gameobject>
+    </nodes>
+</scene>

Added: modules/teichtest/maps/teichtest.rlmap.xml
===================================================================
--- modules/teichtest/maps/teichtest.rlmap.xml	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/maps/teichtest.rlmap.xml	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,16 @@
+<scene formatVersion="0.4.0">
+    <nodes>
+<plane name="wasser">
+<position x="0.0" y="-0.1" z="0"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="48" y="48"/>
+<physicsproxy collision="true" />
+<renderToTexture reflection="true" refraction="true"/>
+<material name="FresnelReflectionRefraction"/>
+</plane>
+<entity name="boden" meshfile="wiese.mesh">
+<position x="0.0" y="0.0" z="0.0"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="felsen" meshfile="felsen.mesh">
+<position x="-9.461217" y="0.0" z="-0.349514"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="2.892444" y="2.892444" z="2.892444"/>
+</entity>
+    </nodes>
+</scene>
\ No newline at end of file

Added: modules/teichtest/maps/teichtest.rlscene
===================================================================
--- modules/teichtest/maps/teichtest.rlscene	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/maps/teichtest.rlscene	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,4 @@
+<scene name="scene01">
+	<map file="teichtest.rlmap.xml"/>
+	<map file="hero.rlmap.xml"/>
+</scene>
\ No newline at end of file

Added: modules/teichtest/materials/Fresnel.source
===================================================================
--- modules/teichtest/materials/Fresnel.source	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/materials/Fresnel.source	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,115 @@
+// Vertex program for fresnel reflections / refractions
+void main_vp(
+		float4 pos			: POSITION,
+		float4 normal		: NORMAL,
+		float2 tex			: TEXCOORD0,
+		
+		out float4 oPos		: POSITION,
+		out float3 noiseCoord : TEXCOORD0,
+		out float4 projectionCoord : TEXCOORD1,
+		out float3 oEyeDir : TEXCOORD2, 
+		out float3 oNormal : TEXCOORD3, 
+
+		uniform float4x4 worldViewProjMatrix,
+		uniform float3 eyePosition, // object space
+		uniform float timeVal,
+		uniform float scale,  // the amount to scale the noise texture by
+		uniform float scroll, // the amount by which to scroll the noise
+		uniform float noise  // the noise perturb as a factor of the  time
+		)
+{
+	oPos = mul(worldViewProjMatrix, pos);
+	// Projective texture coordinates, adjust for mapping
+	float4x4 scalemat = float4x4(0.5,   0,   0, 0.5, 
+	                               0,-0.5,   0, 0.5,
+								   0,   0, 0.5, 0.5,
+								   0,   0,   0,   1);
+	projectionCoord = mul(scalemat, oPos);
+	// Noise map coords
+	noiseCoord.xy = (tex + (timeVal * scroll)) * scale;
+	noiseCoord.z = noise * timeVal;
+
+	oEyeDir = normalize(pos.xyz - eyePosition); 
+	oNormal = normal.rgb; 
+	
+}
+
+// Fragment program for distorting a texture using a 3D noise texture
+void main_fp(
+		float3 noiseCoord			: TEXCOORD0,
+		float4 projectionCoord		: TEXCOORD1,
+		float3 eyeDir				: TEXCOORD2,
+		float3 normal				: TEXCOORD3,
+		
+		out float4 col		: COLOR,
+		
+		uniform float4 tintColour,
+		uniform float noiseScale, 
+		uniform float fresnelBias,
+		uniform float fresnelScale,
+		uniform float fresnelPower,
+		uniform sampler2D noiseMap : register(s0),
+		uniform sampler2D reflectMap : register(s1),
+		uniform sampler2D refractMap : register(s2)
+		)
+{
+	// Do the tex projection manually so we can distort _after_
+	float2 final = projectionCoord.xy / projectionCoord.w;
+
+	// Noise
+	float3 noiseNormal = (tex2D(noiseMap, (noiseCoord.xy / 5)).rgb - 0.5).rbg * noiseScale;
+	final += noiseNormal.xz;
+
+	// Fresnel
+	//normal = normalize(normal + noiseNormal.xz);
+	float fresnel = fresnelBias + fresnelScale * pow(1 + dot(eyeDir, normal), fresnelPower);
+
+	// Reflection / refraction
+	float4 reflectionColour = tex2D(reflectMap, final);
+	float4 refractionColour = tex2D(refractMap, final) + tintColour;
+
+	// Final colour
+	col = lerp(refractionColour, reflectionColour, fresnel);
+
+
+}
+
+
+// Old version to match ATI PS 1.3 implementation
+void main_vp_old(
+		float4 pos			: POSITION,
+		float4 normal		: NORMAL,
+		float2 tex			: TEXCOORD0,
+		
+		out float4 oPos		: POSITION,
+		out float fresnel   : COLOR,
+		out float3 noiseCoord : TEXCOORD0,
+		out float4 projectionCoord : TEXCOORD1,
+
+		uniform float4x4 worldViewProjMatrix,
+		uniform float3 eyePosition, // object space
+		uniform float fresnelBias,
+		uniform float fresnelScale,
+		uniform float fresnelPower,
+		uniform float timeVal,
+		uniform float scale,  // the amount to scale the noise texture by
+		uniform float scroll, // the amount by which to scroll the noise
+		uniform float noise  // the noise perturb as a factor of the  time
+		)
+{
+	oPos = mul(worldViewProjMatrix, pos);
+	// Projective texture coordinates, adjust for mapping
+	float4x4 scalemat = float4x4(0.5,   0,   0, 0.5, 
+	                               0,-0.5,   0, 0.5,
+								   0,   0, 0.5, 0.5,
+								   0,   0,   0,   1);
+	projectionCoord = mul(scalemat, oPos);
+	// Noise map coords
+	noiseCoord.xy = (tex + (timeVal * scroll)) * scale;
+	noiseCoord.z = noise * timeVal;
+
+	// calc fresnel factor (reflection coefficient)
+	float3 eyeDir = normalize(pos.xyz - eyePosition);
+	fresnel = fresnelBias + fresnelScale * pow(1 + dot(eyeDir, normal), fresnelPower);
+	
+}

Added: modules/teichtest/materials/FresnelPS_ASM.source
===================================================================
--- modules/teichtest/materials/FresnelPS_ASM.source	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/materials/FresnelPS_ASM.source	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,72 @@
+ps.1.4
+  // conversion from Cg generated ARB_fragment_program to ps.1.4 by NFZ
+  // command line args: -profile arbfp1 -entry main_fp
+  // program main_fp
+  // c0 : distortionRange
+  // c1 : tintColour
+  // testure 0 : noiseMap
+  // texture 1 : reflectMap
+  // texture 2 : refractMap
+  // v0.x : fresnel 
+  // t0.xyz : noiseCoord
+  // t1.xyw : projectionCoord 
+
+def c2, 2, 1, 0, 0
+
+  // Cg:	distort.x = tex3D(noiseMap, noiseCoord).x;
+  // arbfp1:	TEX R0.x, fragment.texcoord[0], texture[0], 3D;
+  // sample noise map using noiseCoord in TEX unit 0 
+
+texld r0, t0.xyz
+
+  // get projected texture coordinates from TEX coord 1
+  // will be used in phase 2
+
+texcrd r1.xy, t1_dw.xyw
+mov r1.z, c2.y
+
+  // Cg:	distort.y = tex3D(noiseMap, noiseCoord + yoffset).x;
+  // arbfp1:	ADD R1.xyz, fragment.texcoord[0], c1;
+  // arbfp1:	TEX R1.x, R1, texture[0], 3D;
+  // arbfp1:	MOV R0.y, R1.x;
+
+  // Cg:	distort = (distort * 2 - 1) * distortionRange;
+  // arbfp1:	MAD R0.xy, R0, c0.x, -c0.y;
+  // arbfp1:	MUL R0.xy, R0, u0.x;
+  // (distort * 2 - 1) same as 2*(distort -.5) so use _bx2
+
+
+  // Cg:	final = projectionCoord.xy / projectionCoord.w;
+  // Cg:	final += distort;
+  // arbfp1:	RCP R0.w, fragment.texcoord[1].w;
+  // arbfp1:	MAD R0.xy, fragment.texcoord[1], R0.w, R0;
+  // 	final = (distort *  projectionCoord.w) + projectionCoord.xy
+  // for ps.1.4 have to re-arrange things a bit to perturb projected texture coordinates
+
+mad r0.xyz, r0_bx2, c0.x, r1
+
+phase
+
+  // do dependant texture reads
+  // Cg:	reflectionColour = tex2D(reflectMap, final);
+  // arbfp1:	TEX R0, R0, texture[1], 2D;
+  // sampe reflectMap using dependant read : texunit 1 
+
+texld r1, r0.xyz
+
+  // Cg:	refractionColour = tex2D(refractMap, final) + tintColour;
+  // arbfp1:	TEX R1, R0, texture[2], 2D;
+  // sample refractMap : texunit 2 
+
+texld r2, r0.xyz
+
+  // adding tintColour that is in global c1
+  // arbfp1:	ADD R1, R1, u1;
+
+add r2, r2, c1
+
+  // Cg:	col = lerp(refractionColour, reflectionColour, fresnel);
+  // arbfp1:	ADD R0, R0, -R1;
+  // arbfp1:	MAD result.color, fragment.color.primary.x, R0, R1;
+
+lrp r0, v0.x, r1, r2

Added: modules/teichtest/materials/Numbers.material
===================================================================
--- modules/teichtest/materials/Numbers.material	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/materials/Numbers.material	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,17 @@
+material Numbers
+{
+	technique
+	{
+		pass
+		{
+			ambient 0.500000 0.500000 0.500000 1.000000
+			diffuse 0.640000 0.640000 0.640000 1.000000
+			specular 0.500000 0.500000 0.500000 1.000000 12.500000
+			emissive 0.000000 0.000000 0.000000 1.000000
+			texture_unit
+			{
+				texture nx.zone.pink.png
+			}
+		}
+	}
+}

Added: modules/teichtest/materials/basic_reflection.material
===================================================================
--- modules/teichtest/materials/basic_reflection.material	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/materials/basic_reflection.material	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,16 @@
+material basic_reflection
+{
+	technique
+	{
+		pass
+		{
+			ambient 1.000000 0.8 0.200000
+			diffuse 1.000000 0.769854 0.000000
+			specular 0.500000 0.246996 0.000000 30.500000
+			texture_unit
+			{
+				texture_alias refraction
+			}
+		}
+	}
+}

Added: modules/teichtest/materials/disorton.material
===================================================================
--- modules/teichtest/materials/disorton.material	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/materials/disorton.material	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,151 @@
+//----------------------------
+// Distortion effects
+//----------------------------
+
+vertex_program FresnelRefractReflectVP cg
+{
+	source Fresnel.source
+	entry_point main_vp
+	profiles vs_1_1 arbvp1
+}
+vertex_program FresnelRefractReflectVPold cg
+{
+	source Fresnel.source
+	entry_point main_vp_old
+	profiles vs_1_1 arbvp1
+}
+
+fragment_program FresnelRefractReflectFP cg
+{
+	source Fresnel.source
+	entry_point main_fp
+	// sorry, ps_1_1 and fp20 can't do this
+	profiles ps_2_0 arbfp1
+}
+
+fragment_program FresnelRefractReflectPS asm
+{
+	source FresnelPS_ASM.source
+	// sorry, only for ps_1_4 :)
+	syntax ps_1_4
+
+}
+
+material FresnelReflectionRefraction
+{
+	// ps_2_0 / arbfp1
+	technique
+	{
+		pass 
+		{
+			
+			vertex_program_ref FresnelRefractReflectVP
+			{
+				param_named_auto worldViewProjMatrix worldviewproj_matrix
+				param_named_auto eyePosition camera_position_object_space
+				param_named_auto timeVal time 0.05
+				param_named scroll float 1  
+				param_named scale float 1 
+				param_named noise float 1 
+				// scroll and noisePos will need updating per frame
+			}
+			fragment_program_ref FresnelRefractReflectFP
+			{
+				param_named fresnelBias float -0.1 
+				param_named fresnelScale float 1.8 
+				param_named fresnelPower float 8  
+				param_named tintColour float4 0 0.05 0.05 1
+				param_named noiseScale float 0.05 
+			}
+			// Noise
+			texture_unit
+			{
+				// Perlin noise volume
+				texture waves2.dds
+				// min / mag filtering, no mip
+				filtering linear linear none
+			}
+			// Reflection
+			texture_unit
+			{
+				// Will be filled in at runtime
+				texture_alias reflection
+				texture nx.zone.orange.png
+				tex_address_mode clamp
+				// needed by ps.1.4
+				tex_coord_set 1
+			}
+			// Refraction
+			texture_unit
+			{
+				// Will be filled in at runtime
+				texture_alias refraction
+				texture nx.zone.orange.png
+				tex_address_mode clamp
+				// needed by ps.1.4
+				tex_coord_set 2
+			}
+		}
+		
+			
+	}
+
+	// ATI 8500 +
+	technique
+	{
+		pass
+		{
+			vertex_program_ref FresnelRefractReflectVPold
+			{
+				param_named_auto worldViewProjMatrix worldviewproj_matrix
+				param_named_auto eyePosition camera_position_object_space
+				param_named fresnelBias float -0.3
+				param_named fresnelScale float 1.4
+				param_named fresnelPower float 8
+				param_named_auto timeVal time_0_1 20
+				param_named scroll float 1 
+				param_named scale float 4 
+				param_named noise float 1
+				// scroll and noisePos will need updating per frame
+			}
+
+			// for ATI RADEON 8500 - 9200
+			fragment_program_ref FresnelRefractReflectPS
+			{
+				// distortionRange
+				param_indexed 0  float 0.025  
+				// tintColour
+				param_indexed 1  float4 0.05 0.12 0.15 1
+			}
+
+			// Noise
+			texture_unit
+			{
+				// Perlin noise volume
+				texture perlinvolume.dds 3d
+				// min / mag filtering, no mip
+				filtering linear linear none
+			}
+			// Reflection
+			texture_unit
+			{
+				// Will be filled in at runtime
+				texture reflection
+				texture nx.zone.orange.png
+				tex_address_mode clamp
+				// needed by ps.1.4
+				tex_coord_set 1
+			}
+			// Refraction
+			texture_unit
+			{
+				// Will be filled in at runtime
+				texture refraction
+				texture nx.zone.orange.png
+				tex_address_mode clamp
+				// needed by ps.1.4
+				tex_coord_set 2
+			}
+		}
+	}    
+}

Added: modules/teichtest/materials/ins_rucksack.material
===================================================================
--- modules/teichtest/materials/ins_rucksack.material	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/materials/ins_rucksack.material	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,13 @@
+material SOLID/TEX/rucksack.png
+{
+	technique
+	{
+		pass
+		{
+			texture_unit
+			{
+				texture ins_rucksack.png
+			}
+		}
+	}
+}

Added: modules/teichtest/materials/nx.grid.material
===================================================================
--- modules/teichtest/materials/nx.grid.material	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/materials/nx.grid.material	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,34 @@
+material nx.grid
+{
+    technique
+    {
+        pass
+        {
+            //lighting off
+            
+            texture_unit
+            {
+                max_anisotropy 8
+                filtering anisotropic
+                texture nx.grid.floor.png
+            }
+        }
+    }
+}
+
+material nx.axis
+{
+    technique
+    {
+        pass
+        {
+            lighting off
+            scene_blend alpha_blend
+            
+            texture_unit
+            {
+                texture nx.grid.axis.png
+            }
+        }
+    }
+}

Added: modules/teichtest/materials/nx.particles.material
===================================================================
--- modules/teichtest/materials/nx.particles.material	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/materials/nx.particles.material	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,59 @@
+material nx.fx-mat.magic
+{
+	technique
+	{
+		pass
+		{
+			lighting off
+			scene_blend add
+			depth_write off
+
+			point_sprites on
+			point_size 2
+			point_size_attenuation on
+
+			texture_unit
+			{
+				texture flare.png
+			}
+		}
+	}
+}
+
+material nx.smoke
+{
+	technique
+	{
+		pass
+		{
+			lighting off
+			scene_blend alpha_blend
+			depth_write off
+
+			texture_unit
+			{
+				texture nx.particle.smoke.png
+				tex_address_mode clamp
+			}
+		}
+	}
+}
+
+material nx.steam
+{
+	technique
+	{
+		pass
+		{
+			lighting off
+			scene_blend alpha_blend
+			depth_write off
+
+			texture_unit
+			{
+				texture nx.particle.steam.png
+				tex_address_mode clamp
+			}
+		}
+	}
+}
\ No newline at end of file

Added: modules/teichtest/materials/nx.shapes.material
===================================================================
--- modules/teichtest/materials/nx.shapes.material	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/materials/nx.shapes.material	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,137 @@
+material nx.cube
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 1.000000 0.5 0.000000
+			diffuse 1.000000 0.769854 0.000000
+			specular 0.500000 0.246996 0.000000 30.500000
+			shading phong
+		}
+	}
+}
+
+material nx.cube.alt
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 1.000000 0.8 0.200000
+			diffuse 1.000000 0.769854 0.000000
+			specular 0.500000 0.246996 0.000000 30.500000
+			shading phong
+		}
+	}
+}
+
+material nx.sphere
+{
+
+	technique
+	{
+		pass
+		{
+			shading phong
+			ambient 0 1.0 0.8
+			diffuse 0 1.0 0.77
+			specular 0 0.5 0.25 0.5
+			shading phong
+		}
+	}
+}
+
+material nx.convex1
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 0.6 1.0 0.8
+			diffuse 0.6 1.0 0.77
+			specular 0.6 0.5 0.25 0.5
+			shading phong
+		}
+	}
+}
+
+material nx.chair
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 0.4 1.0 0.8
+			diffuse 0.4 1.0 0.77
+			specular 0.4 0.5 0.25 0.5
+			shading phong
+		}
+	}
+}
+
+material nx.motor.a
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 0.5 0.5 0.5
+			diffuse 0.5 0.5 0.5
+			specular 0.5 0.5 0.5 0.5
+			shading phong
+		}
+	}
+}
+
+material nx.motor.b
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 1.000000 0.8 0.200000
+			diffuse 1.000000 0.769854 0.000000
+			specular 0.500000 0.246996 0.000000 30.500000
+			shading phong
+		}
+	}
+}
+
+material nx.raycaster
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 0.1 0.1 0.1
+			diffuse 0.1 0.1 0.1
+			specular 0.1 0.1 0.1
+			shading phong
+		}
+	}
+}
+
+material nx.crosshair
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 1.0 1.0 1.0
+			diffuse 1.0 1.0 1.0
+			specular 1.0 1.0 1.0
+			shading phong
+		}
+	}
+}
+
+

Added: modules/teichtest/materials/nx.stairs.material
===================================================================
--- modules/teichtest/materials/nx.stairs.material	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/materials/nx.stairs.material	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,14 @@
+material nx.wall
+{
+	technique
+	{
+		pass
+		{
+			diffuse 0.800000 0.800000 0.800000
+			texture_unit
+			{
+				texture nx.static.wall.png
+			}
+		}
+	}
+}

Added: modules/teichtest/materials/nx.track.material
===================================================================
--- modules/teichtest/materials/nx.track.material	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/materials/nx.track.material	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1 @@
+

Added: modules/teichtest/materials/nx.zones.material
===================================================================
--- modules/teichtest/materials/nx.zones.material	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/materials/nx.zones.material	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,64 @@
+material nx.zone.green
+{
+	technique
+	{
+		pass
+		{
+			lighting off			
+			scene_blend alpha_blend			
+			texture_unit
+			{
+				texture nx.zone.green.png
+			}
+		}
+	}
+}
+
+material nx.zone.orange
+{
+	technique
+	{
+		pass
+		{
+			lighting off			
+			scene_blend alpha_blend			
+			texture_unit
+			{
+				texture nx.zone.orange.png
+			}
+		}
+	}
+}
+
+material nx.zone.blue
+{
+	technique
+	{
+		pass
+		{
+			lighting off			
+			scene_blend alpha_blend			
+			texture_unit
+			{
+				texture nx.zone.blue.png
+			}
+		}
+	}
+}
+
+material nx.zone.marker.nogravity
+{
+	technique
+	{
+		pass
+		{
+			lighting off			
+			scene_blend alpha_blend
+			
+			texture_unit
+			{
+				texture nx.zone.nogravity.png
+			}
+		}
+	}
+}
\ No newline at end of file

Added: modules/teichtest/materials/teichtest.material
===================================================================
--- modules/teichtest/materials/teichtest.material	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/materials/teichtest.material	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,42 @@
+material wasser/SOLID/TEX/Untitled
+{
+	technique
+	{
+		pass
+		{
+			specular 0.500000 0.500000 0.500000 12.500000
+			texture_unit
+			{
+				texture Untitled
+			}
+		}
+	}
+}
+material wiese/SOLID/TEX/gras_kana.png
+{
+	technique
+	{
+		pass
+		{
+			specular 0.500000 0.500000 0.500000 12.500000
+			texture_unit
+			{
+				texture gras_kana.png
+			}
+		}
+	}
+}
+material felsen/SOLID/TEX/felsen_3_kana.png
+{
+	technique
+	{
+		pass
+		{
+			specular 0.500000 0.500000 0.500000 12.500000
+			texture_unit
+			{
+				texture felsen_3_kana.png
+			}
+		}
+	}
+}

Added: modules/teichtest/materials/textures/Thumbs.db
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/Thumbs.db
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/felsen_3_kana.png
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/felsen_3_kana.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/gras_kana.png
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/gras_kana.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/ins_rucksack.png
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/ins_rucksack.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/nx.grid.axis.png
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/nx.grid.axis.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/nx.grid.floor.png
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/nx.grid.floor.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/nx.particle.smoke.png
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/nx.particle.smoke.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/nx.particle.steam.png
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/nx.particle.steam.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/nx.static.wall.png
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/nx.static.wall.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/nx.trafficcone.png
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/nx.trafficcone.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/nx.zone.blue.png
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/nx.zone.blue.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/nx.zone.green.png
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/nx.zone.green.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/nx.zone.nogravity.png
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/nx.zone.nogravity.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/nx.zone.orange.png
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/nx.zone.orange.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/nx.zone.pink.png
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/nx.zone.pink.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/obj_shortsleeve_dummy.png
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/obj_shortsleeve_dummy.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/perlinvolume.dds
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/perlinvolume.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/materials/textures/waves2.dds
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/materials/textures/waves2.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/medianotes.txt
===================================================================
--- modules/teichtest/medianotes.txt	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/medianotes.txt	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,5 @@
+All media files starting with nx. are taken from NxOgre.
+
+		(C) Robin Southern <betajaen at ihoed.com>
+
+They don't fall under our media distribution restrictions. They are free to use for other projects as long as his name is shown in the credits.

Added: modules/teichtest/models/felsen.mesh
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/models/felsen.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/models/ins_rucksack.mesh
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/models/ins_rucksack.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/models/sphere.1m.mesh
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/models/sphere.1m.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/models/wasser.mesh
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/models/wasser.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/models/wiese.mesh
===================================================================
(Binary files differ)


Property changes on: modules/teichtest/models/wiese.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/teichtest/quests/test.quests
===================================================================
--- modules/teichtest/quests/test.quests	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/quests/test.quests	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<quests>
+	<quest id="quest1">
+		<name>quest1</name>
+		<description>blub blub blahtext</description>
+		<state>COMPLETED</state>
+		<known>true</known>
+		<quest id="subquest1_1">
+			<name>subquest1_1</name>
+			<description>nochmal blah</description>
+			<known>true</known>
+		</quest>
+	</quest>
+	<quest id="quest2">
+		<name>quest2</name>
+		<description>blub blub blahtext213423</description>
+		<state>COMPLETED</state>
+		<known>true</known>
+		<quest id="subquest2_1">
+			<name>subquest2_1</name>
+			<known>false</known>
+		</quest>
+		<quest id="subquest2_2">
+			<name>subquest2_2</name>
+			<known>false</known>
+		</quest>
+		<quest id="subquest2_3">
+			<known>true</known>
+			<name>subquest2_3</name>
+			<known>true</known>
+		</quest>
+	</quest>
+	<quest id="quest3">
+		<name>quest3</name>
+		<quest id="subquest3_1">
+			<name>subquest3_1</name>
+			<known>true</known>
+		</quest>
+		<name>quest3</name>
+		<known>false</known>
+		<description>blub blub blahtext2312312312542143123</description>
+		<state>COMPLETED</state>
+	</quest>
+</quests>

Added: modules/teichtest/scripts/maps/setchar.rb
===================================================================
--- modules/teichtest/scripts/maps/setchar.rb	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/scripts/maps/setchar.rb	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,19 @@
+load "embed.rb"
+
+require 'player.rb'
+require 'hero.rb'
+
+$SCRIPT.log("Prepare hero for being the active character")
+hero = $GOM.getGameObject(10);
+PlayerSettings.preparePlayer(hero)
+
+$SCRIPT.log("Set hero as active character")
+$UI.setActiveCharacter(hero)
+
+$SCRIPT.log("Hero ready")
+itemToAdd = $GOM.createGameObject("men_human_female_legs_pants_01_long");
+hero.getInventory().hold(itemToAdd, "Trousers");
+itemToAdd = $GOM.createGameObject("men_human_female_cloth_short");
+hero.getInventory().hold(itemToAdd, "Clothes");
+itemToAdd = $GOM.createGameObject("men_human_female_feet_boots_01");
+hero.getInventory().hold(itemToAdd, "Boots");

Added: modules/teichtest/scripts/moduleconfig.rb
===================================================================
--- modules/teichtest/scripts/moduleconfig.rb	2008-08-28 18:41:29 UTC (rev 4491)
+++ modules/teichtest/scripts/moduleconfig.rb	2008-09-01 19:57:00 UTC (rev 4492)
@@ -0,0 +1,33 @@
+include RlScript
+
+class TeichTestModule < ContentModule
+    def initialize()
+        super("teichtest", "Teichtest", false, 200603080)
+    end
+
+    def getDependencies()
+        return ["common"]
+    end
+
+    def getTextureLocations()
+        return ["textures"]
+    end
+
+    def getModelLocations()
+        return []
+    end
+
+    def getSoundLocations()
+        return []
+    end
+
+    def start()
+        require "mckhero.rb"
+        require "hero.rb"
+		require "clothing.rb"
+		SceneManager::getSingleton().loadScene("scene01", false);
+		$PM.setEnabled(true)
+    end
+end
+
+CoreSubsystem.getSingleton().registerModule(TeichTestModule.new())



From melven at mail.berlios.de  Mon Sep  1 22:41:26 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 1 Sep 2008 22:41:26 +0200
Subject: [Dsa-hl-svn] r4493 - in rl/branches/newton20/engine: core/include
	core/src rules/include rules/src ui/include ui/src
Message-ID: <200809012041.m81KfQaF018197@sheep.berlios.de>

Author: melven
Date: 2008-09-01 22:41:21 +0200 (Mon, 01 Sep 2008)
New Revision: 4493

Modified:
   rl/branches/newton20/engine/core/include/GameEventManager.h
   rl/branches/newton20/engine/core/include/PhysicsGenericContactCallback.h
   rl/branches/newton20/engine/core/src/GameAreaTypes.cpp
   rl/branches/newton20/engine/core/src/GameEventManager.cpp
   rl/branches/newton20/engine/core/src/PhysicsGenericContactCallback.cpp
   rl/branches/newton20/engine/rules/include/AbstractMovement.h
   rl/branches/newton20/engine/rules/src/CreatureController.cpp
   rl/branches/newton20/engine/rules/src/CreatureControllerManager.cpp
   rl/branches/newton20/engine/ui/include/CombatControlState.h
   rl/branches/newton20/engine/ui/src/CombatControlState.cpp
Log:
some fixes and minor changes in OgreNewt (still some changes needed for trigger-volumes to work correctly)


Modified: rl/branches/newton20/engine/core/include/GameEventManager.h
===================================================================
--- rl/branches/newton20/engine/core/include/GameEventManager.h	2008-09-01 19:57:00 UTC (rev 4492)
+++ rl/branches/newton20/engine/core/include/GameEventManager.h	2008-09-01 20:41:21 UTC (rev 4493)
@@ -130,7 +130,8 @@
 	void removeQueuedDeletionSources();
 
 
-    /// newton collision callback function
+    /// newton collision callback functions
+    //int onAABBOverlap(int threadid);
     int userProcess(Ogre::Real timestep, int threadid);
 
     /// notify about newton world update

Modified: rl/branches/newton20/engine/core/include/PhysicsGenericContactCallback.h
===================================================================
--- rl/branches/newton20/engine/core/include/PhysicsGenericContactCallback.h	2008-09-01 19:57:00 UTC (rev 4492)
+++ rl/branches/newton20/engine/core/include/PhysicsGenericContactCallback.h	2008-09-01 20:41:21 UTC (rev 4493)
@@ -31,11 +31,20 @@
     class _RlCoreExport PhysicsGenericContactCallback : public OgreNewt::ContactCallback
     {
     public:
-        int userBegin();
-        int userProcess( Ogre::Real timeStep, int threadid);
-        /// This function calls the contact listeners. So any specialised listener overriding
-        /// this one, has to call it explicitly.
-        void userEnd();
+        //! this function must not be overwritten!
+        int contactProcess( Ogre::Real timeStep, int threadid );
+
+        /*!
+         * this function is called, when the aabbs of two bodies overlap, return 0 to indicate, that no contact calculation
+         * should be initiated.
+         * ATTENTION: if 0 is returned, the contact-listeners cannot be called!
+        */
+        int onAABBOverlap(int threadindex);
+
+        /*!
+         * process user defined contact forces (etc) here
+        */
+        virtual int userProcess( Ogre::Real timeStep, int threadid);
     private:
     };
 }

Modified: rl/branches/newton20/engine/core/src/GameAreaTypes.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/GameAreaTypes.cpp	2008-09-01 19:57:00 UTC (rev 4492)
+++ rl/branches/newton20/engine/core/src/GameAreaTypes.cpp	2008-09-01 20:41:21 UTC (rev 4493)
@@ -245,6 +245,7 @@
         mBody->setMaterialGroupID(
             PhysicsManager::getSingleton().getMaterialID("gamearea"));
         mBody->setUserData(NULL);
+        ((OgreNewt::ConvexCollision*)col)->setAsTriggerVolume(true);
     }
 
     GameSimpleCollisionAreaType::GameSimpleCollisionAreaType(
@@ -262,6 +263,7 @@
         mBody->setMaterialGroupID(
             PhysicsManager::getSingleton().getMaterialID("gamearea"));
         mBody->setUserData(NULL);
+        ((OgreNewt::ConvexCollision*)col)->setAsTriggerVolume(true);
     }
 
 }

Modified: rl/branches/newton20/engine/core/src/GameEventManager.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/GameEventManager.cpp	2008-09-01 19:57:00 UTC (rev 4492)
+++ rl/branches/newton20/engine/core/src/GameEventManager.cpp	2008-09-01 20:41:21 UTC (rev 4493)
@@ -274,7 +274,27 @@
 
         return NAME;
     }
+/*
+    int GameEventManager::onAABBOverlap(int)
+    {
+        NewtonBodyGameAreaMap::iterator it = mBodyGameAreaMap.find(m_body0);
+        if( it != mBodyGameAreaMap.end() )
+        {
+            it->second->foundCollision(bodyToActor(m_body1));
+            return 0;
+        }
 
+        it = mBodyGameAreaMap.find(m_body1);
+        if( it != mBodyGameAreaMap.end() )
+        {
+            it->second->foundCollision(bodyToActor(m_body0));
+            return 0;
+        }
+
+        LOG_WARNING(Logger::CORE, "Der Kollisionsk?rper konnte keiner GameArea zugeordnet werden!");
+        return 0;
+    }
+*/
     int GameEventManager::userProcess(Real timestep, int)
     {
         NewtonBodyGameAreaMap::iterator it = mBodyGameAreaMap.find(m_body0);
@@ -292,6 +312,7 @@
         }
 
         LOG_WARNING(Logger::CORE, "Der Kollisionsk?rper konnte keiner GameArea zugeordnet werden!");
+
         return 0;
     }
 

Modified: rl/branches/newton20/engine/core/src/PhysicsGenericContactCallback.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/PhysicsGenericContactCallback.cpp	2008-09-01 19:57:00 UTC (rev 4492)
+++ rl/branches/newton20/engine/core/src/PhysicsGenericContactCallback.cpp	2008-09-01 20:41:21 UTC (rev 4493)
@@ -25,7 +25,7 @@
 
 namespace rl
 {
-    int PhysicsGenericContactCallback::userBegin()
+    int PhysicsGenericContactCallback::onAABBOverlap(int threadindex)
     {
         return 1;
     }
@@ -35,8 +35,10 @@
         return 1;
     }
 
-    void PhysicsGenericContactCallback::userEnd()
+    int PhysicsGenericContactCallback::contactProcess(Real timestep, int threadid)
     {
+        int retval = userProcess(timestep, threadid);
+
         Actor* a1 = static_cast<Actor*>(m_body0->getUserData());
         Actor* a2 = static_cast<Actor*>(m_body1->getUserData());
         if (a1 && a1->getPhysicalThing()->getContactListener())
@@ -49,5 +51,7 @@
             a2->getPhysicalThing()->getContactListener()->
                 contactOccured(a2->getPhysicalThing(), a1->getPhysicalThing());
         }
+
+        return retval;
     }
 }

Modified: rl/branches/newton20/engine/rules/include/AbstractMovement.h
===================================================================
--- rl/branches/newton20/engine/rules/include/AbstractMovement.h	2008-09-01 19:57:00 UTC (rev 4492)
+++ rl/branches/newton20/engine/rules/include/AbstractMovement.h	2008-09-01 20:41:21 UTC (rev 4493)
@@ -27,7 +27,7 @@
 {
     /// this is the base class of all movements and provides a general interface for movements
     class AbstractMovement : 
-        public OgreNewt::ContactCallback
+        public PhysicsGenericContactCallback
     {
     public:
         AbstractMovement(CreatureController *movingCreature) : mMovingCreature(movingCreature), mActive(false) {}

Modified: rl/branches/newton20/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/CreatureController.cpp	2008-09-01 19:57:00 UTC (rev 4492)
+++ rl/branches/newton20/engine/rules/src/CreatureController.cpp	2008-09-01 20:41:21 UTC (rev 4493)
@@ -490,8 +490,8 @@
             // Protected members from type OgreNewt::ContactCallback have to be overridden in order
             // for the movements to work. This is because these members are used by OgreNewt functions
             // for processing this contact. Should probably be solved in OgreNewt directly.
-            OgreNewt::ContactCallback *movement = mMovement;
-            *movement = (OgreNewt::ContactCallback)(*this);
+            PhysicsGenericContactCallback *movement = mMovement;
+            *movement = (PhysicsGenericContactCallback)(*this);
             return movement->userProcess(timestep, threadid);
         }
 

Modified: rl/branches/newton20/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/CreatureControllerManager.cpp	2008-09-01 19:57:00 UTC (rev 4492)
+++ rl/branches/newton20/engine/rules/src/CreatureControllerManager.cpp	2008-09-01 20:41:21 UTC (rev 4493)
@@ -176,8 +176,8 @@
                 // Protected members from type OgreNewt::ContactCallback have to be overridden in order
                 // for the controllers to work. This is because these members are used by OgreNewt functions
                 // for processing this contact. Should probably be solved in OgreNewt directly.
-                OgreNewt::ContactCallback* controller = it->second;
-               *controller = (OgreNewt::ContactCallback)(*this);
+                PhysicsGenericContactCallback* controller = it->second;
+               *controller = (PhysicsGenericContactCallback)(*this);
                 return controller->userProcess(timestep, threadid);
             }
         }

Modified: rl/branches/newton20/engine/ui/include/CombatControlState.h
===================================================================
--- rl/branches/newton20/engine/ui/include/CombatControlState.h	2008-09-01 19:57:00 UTC (rev 4492)
+++ rl/branches/newton20/engine/ui/include/CombatControlState.h	2008-09-01 20:41:21 UTC (rev 4493)
@@ -64,7 +64,7 @@
 
 
         // camera collision: OgreNewt::ContactCallback overides
-        int OnAABBOverlap(int threadIndex);
+        int onAABBOverlap(int threadIndex);
         int userProcess(Ogre::Real timestep, int threadIndex);
 
         // camera movement: Newton force and torque callback

Modified: rl/branches/newton20/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/CombatControlState.cpp	2008-09-01 19:57:00 UTC (rev 4492)
+++ rl/branches/newton20/engine/ui/src/CombatControlState.cpp	2008-09-01 20:41:21 UTC (rev 4493)
@@ -354,7 +354,7 @@
         mCamBody->setForce(springAcc * mass);
     }
 
-    int CombatControlState::OnAABBOverlap(int threadIndex)
+    int CombatControlState::onAABBOverlap(int threadIndex)
     {
         // TODO handle camera collisions here
         return 0;



From melven at mail.berlios.de  Mon Sep  1 22:42:35 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 1 Sep 2008 22:42:35 +0200
Subject: [Dsa-hl-svn] r4494 - in dependencies/OgreNewt_ngt: inc src
Message-ID: <200809012042.m81KgZDw019891@sheep.berlios.de>

Author: melven
Date: 2008-09-01 22:42:34 +0200 (Mon, 01 Sep 2008)
New Revision: 4494

Modified:
   dependencies/OgreNewt_ngt/inc/OgreNewt_Body.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_Collision.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_ContactCallback.h
   dependencies/OgreNewt_ngt/src/OgreNewt_ContactCallback.cpp
Log:
added triggervolumes and changed function-names in the contact-callback. but the trigger-volumes still need some changes in the contact-callback to work


Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_Body.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_Body.h	2008-09-01 20:41:21 UTC (rev 4493)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_Body.h	2008-09-01 20:42:34 UTC (rev 4494)
@@ -198,7 +198,22 @@
 		returns the current center of mass, as an offset from the original origin when the body was created.
 	*/
 	Ogre::Vector3 getCenterOfMass() const;
+        //! freeze the rigid body.
+        /*!
+            this command "freezes" the Rigid Body, removing it from the active simulation list.  it will "unfreeze" if another body comes in contact with it, or you "unfreeze" it.
+            \sa unFreeze()
+        */
+       void freeze() { NewtonBodySetFreezeState( m_body, 1 ); }
 
+        //! unfreeze the rigid body.
+        /*!
+            \sa freeze()
+        */
+        void unFreeze() { NewtonBodySetFreezeState( m_body, 0 ); }
+
+        //! is the body freezed?
+        bool isFreezed() { return NewtonBodyGetFreezeState( m_body ) != 0; }
+            
 	//! set the material for the body
 	/*!
 		Materials are an extremely powerful way to control body behavior. first create a new MaterialID object, and then pass a pointer

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_Collision.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_Collision.h	2008-09-01 20:41:21 UTC (rev 4493)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_Collision.h	2008-09-01 20:42:34 UTC (rev 4494)
@@ -90,6 +90,15 @@
 	//! calculate the moment of inertia for this collision primitive, along with the theoretical center-of-mass for this shape.
 	void calculateInertialMatrix( Ogre::Vector3& inertia, Ogre::Vector3& offset ) const { NewtonConvexCollisionCalculateInertialMatrix( m_col, &inertia.x, &offset.x ); }
 
+        //! returns true, if the collision is a trigger-volume
+        bool isTriggerVolume() const { return NewtonCollisionIsTriggerVolume(m_col) != 0; }
+
+        //! set collision as trigger-volume
+        /*!
+                if a collision is marked as a trigger-volume, there's no calculation of contacts, so
+                this acts like an accurate aabb test
+        */
+        void setAsTriggerVolume(bool trigger) { NewtonCollisionSetAsTriggerVolume(m_col, (int)trigger); }
 };
 
 //typedef Ogre::SharedPtr<Collision> CollisionPtr;

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_ContactCallback.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_ContactCallback.h	2008-09-01 20:41:21 UTC (rev 4493)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_ContactCallback.h	2008-09-01 20:42:34 UTC (rev 4494)
@@ -107,7 +107,7 @@
 		user process function.  is called for each contact between the 2 bodies.  all member functions are valid from
 		within this function, and will affect the current contact.  return 0 to ignore the collision, 1 to allow it.
 	 */
-	virtual int userProcess( Ogre::Real timeStep, int threadIndex ) { return 1; }
+	virtual int contactProcess( Ogre::Real timeStep, int threadIndex ) { return 1; }
 
 	//! user-defined End function
 	/*!

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_ContactCallback.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_ContactCallback.cpp	2008-09-01 20:41:21 UTC (rev 4493)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_ContactCallback.cpp	2008-09-01 20:42:34 UTC (rev 4494)
@@ -43,8 +43,10 @@
 	        me->m_body1 = (OgreNewt::Body*)NewtonBodyGetUserData( NewtonJointGetBody1(contactJoint) );
 
 	        // call the user-defined callback function!
-	        if( !me->userProcess( (Ogre::Real)timeStep, threadIndex ) )
+	        if( !me->contactProcess( (Ogre::Real)timeStep, threadIndex ) )
+                {
                     NewtonContactJointRemoveContact(contactJoint, contact);
+                }
         }
 }
 



From blakharaz at mail.berlios.de  Tue Sep  2 07:24:38 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 2 Sep 2008 07:24:38 +0200
Subject: [Dsa-hl-svn] r4495 - in modules: common/dsa regressiontest/dsa
Message-ID: <200809020524.m825OcRm030698@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-02 07:24:32 +0200 (Tue, 02 Sep 2008)
New Revision: 4495

Added:
   modules/common/dsa/items.gof
   modules/common/dsa/persons.gof
Modified:
   modules/common/dsa/gameobjectdefinitions.gof
   modules/regressiontest/dsa/gameobjectdefinitions.gof
Log:
Split gameobject definitions

Modified: modules/common/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/common/dsa/gameobjectdefinitions.gof	2008-09-01 20:42:34 UTC (rev 4494)
+++ modules/common/dsa/gameobjectdefinitions.gof	2008-09-02 05:24:32 UTC (rev 4495)
@@ -10,307 +10,4 @@
 		<property name="openable" type="BOOL" data="true"/>
 	</gameobjectclass>
 
-	<gameobjectclass classid="hero" baseclass="Hero">
-		<property name="geometrytype" type="STRING" data="ellipsoid" />
-		<property name="mass" type="REAL" data="75"/>
-		<property name="inventorywindowtype" type="STRING" data="inventory_human.xml"/>
-		<property name="meshfile" type="STRING" data="men_alrike.mesh"/>
-		<property name="name" type="STRING" data="Alrike"/>
-		<property name="description" type="STRING" data="Heldin von Berufung"/>
-		<property name="inventory" type="MAP">
-			<property name="slots" type="ARRAY">
-				<!-- Left hand -->
-				<property type="MAP"> 
-					<property name="name" type="STRING" data="Left Hand"/>
-					<property name="type" type="STRING" data="bone"/>
-					<property name="bone" type="STRING" data="l_hand"/>
-					<property name="readies" type="INT" data="3"/> <!-- Weapons | Shields -->
-				</property>
-				<!-- Right hand -->
-				<property type="MAP"> 
-					<property name="name" type="STRING" data="Right Hand"/>
-					<property name="type" type="STRING" data="bone"/>
-					<property name="bone" type="STRING" data="r_hand"/>
-					<property name="readies" type="INT" data="3"/> <!-- Weapons | Shields -->
-				</property>
-			</property>
-		</property>
-		<property name="eigenschaften" type="MAP">
-			<property name="MU" type="INT" data="12"/>
-			<property name="KL" type="INT" data="8"/>
-			<property name="IN" type="INT" data="9"/>
-			<property name="CH" type="INT" data="10"/>
-			<property name="FF" type="INT" data="11"/>
-			<property name="GE" type="INT" data="12"/>
-			<property name="KO" type="INT" data="13"/>
-			<property name="KK" type="INT" data="14"/>
-		</property>
-		<property name="kampftechniken" type="MAP">
-			<property name="Schwerter" type="INTPAIR" data="5,7"/>
-		</property>
-		<property name="talente" type="MAP">
-			<property name="Athletik" type="INT" data="3"/>
-<!--			<property name="K?rperbeherrschung" type="INT" data="3"/>-->
-		</property>
-		<!-- Animationen und Animationsgeschwindigkeiten fuer den CreatureController -->
-		<property name="animations" type="MAP">
-			<property name="sterben" type="STRING" data="idle"/>
-			<property name="liegen" type="STRING" data="idle"/>
-			<property name="fallen" type="STRING" data="idle"/>
-			<property name="fallen_anfang" type="STRING" data="idle"/>
-			<property name="fallen_landung" type="STRING" data="idle"/>
-			<property name="stehen" type="STRING" data="idle"/>
-			<property name="stehen_rechts" type="STRING" data="drehen_links"/>
-			<property name="stehen_links" type="STRING" data="drehen_rechts"/>
-			<!-- property name="seitwaerts_links" type="STRING" data="seitwaerts_links"/ -->
-			<!-- property name="seitwaerts_rechts" type="STRING" data="seitwaerts_rechts"/ -->
-			<property name="gehen" type="STRING" data="gehen"/>
-			<property name="gehen_rueckwaerts" type="STRING" data="gehen_rueckwaerts"/>
-			<property name="joggen_rueckwaerts" type="STRING" data="gehen_rueckwaerts"/>
-			<property name="joggen" type="STRING" data="rennen"/>
-			<property name="laufen" type="STRING" data="rennen"/>
-			<property name="rennen" type="STRING" data="rennen"/>
-			<property name="stehen_zu_schleichen" type="STRING" data="idle_zu_hocke"/>
-			<property name="schleichen_zu_stehen" type="STRING" data="hocke_zu_stehen"/>
-			<property name="schleichen" type="STRING" data="hocke_idle"/>
-			<property name="schleichen_vorwaerts" type="STRING" data="hocke_gehen"/>
-			<property name="hochsprung_absprung" type="STRING" data="idle_absprung"/>
-			<property name="hochsprung" type="STRING" data="idle_sprung"/>
-			<property name="hochsprung_landung" type="STRING" data="idle_sprung_landung"/>
-			<property name="weitsprung_absprung" type="STRING" data="rennen_absprung"/>
-			<property name="weitsprung" type="STRING" data="rennen_sprung"/>
-			<property name="weitsprung_landung" type="STRING" data="rennen_sprung_landung"/>
-			<property name="fallen" type="STRING" data="idle"/>
-			<!-- Kampf -->
-			<property name="kampf_attacke_pariert" type="STRING" data="kampf_schwerter_angriff_1"/>
-			<property name="kampf_attacke_treffer_nicht_pariert" type="STRING" data="kampf_schwerter_angriff_1"/>
-			<property name="kampf_attacke_treffer" type="STRING" data="kampf_schwerter_angriff_1"/>
-			<property name="kampf_attacke_misserfolg" type="STRING" data="kampf_schwerter_angriff_1"/>
-			<property name="kampf_parade_erfolg" type="STRING" data="kampf_schwerter_parade_1"/>
-			<property name="kampf_parade_misserfolg" type="STRING" data="kampf_schwerter_getroffen"/>
-			<property name="kampf_getroffen" type="STRING" data="kampf_schwerter_getroffen"/>
-		</property>
-		<property name="animationspeeds" type="MAP">
-			<property name="gehen" type="REAL" data="1.0"/>
-			<property name="joggen" type="REAL" data="0.3"/>
-			<property name="laufen" type="REAL" data="0.5"/>
-			<property name="rennen" type="REAL" data="0.4"/>
-		</property>
-		<property name="kampfaktionen" type="ARRAY">
-			<property type="STRING" data="Attacke"/>
-			<property type="STRING" data="Parade"/>
-			<property type="STRING" data="Ausweichen"/>
-			<property type="STRING" data="Bewegen"/>
-			<property type="STRING" data="Folgen"/>
-		</property>
-	</gameobjectclass>
-
-	<gameobjectclass classid="chest" baseclass="Chest">
-	  <property name="name" type="STRING" data="Truhe"/>
-		<property name="description" type="STRING" data="Eine Truhe"/>
-		<property name="geometrytype" type="STRING" data="convexhull"/>
-		<property name="mass" type="REAL" data="0"/>
-		<property name="meshfile" type="STRING" data="ver_truhe_gross01.mesh"/>
-<!--		<property name="sound" type="STRING" data="doorcreak.ogg"/>-->
-	</gameobjectclass>
-
-
-	<gameobjectclass classid="torch" baseclass="Torch">
-		<property name="name" type="STRING" data="Eine Fackel"/>
-		<property name="geometrytype" type="STRING" data="convexhull"/>
-		<property name="meshfile" type="STRING" data="ins_fackel_01.mesh"/>
-		<property name="sound" type="STRING" data="feuer_knisternd_01.ogg"/>
-		<property name="flames" type="STRING" data="feuertest"/>
-		<!-- <property name="lightable" type="BOOL" data="true"/> -->
-		<property name="lit" type="BOOL" data="true"/>
-		<property name="size" type="INTPAIR" data="1,3"/>
-		<property name="imagename" type="STRING" data="set:ModelThumbnails image:Fackel"/>
-	</gameobjectclass>
-
-    <gameobjectclass classid="mckhero"  baseclass="MCKHero">
-        <property name="geometrytype" type="STRING" data="ellipsoid" />
-        <property name="mass" type="REAL" data="75"/>
-        <property name="inventorywindowtype" type="STRING" data="inventory_human.xml"/>
-        <property name="meshfile" type="STRING" data="men_human_female_torso.mesh"/>
-		<property name="submeshprename" type="STRING" data="men_human_female_"/>
-        <property name="geometrytype" type="STRING" data="ellipsoid"/>
-		<property name="meshparts" type="MAP">
-            <property name="torso" type="STRING" data="men_human_female_torso.mesh"/>
-            <property name="hand" type="STRING" data="men_human_female_hand_nude.mesh"/>
-            <property name="head" type="STRING" data="men_human_female_head_02.mesh"/>
-            <property name="hair" type="STRING" data="men_human_female_hair_long_01_normal.mesh"/>
-            <property name="trousers" type="STRING" data="men_human_female_legs_underpants.mesh"/>
-            <property name="boots" type="STRING" data="men_human_female_feet_nude.mesh"/>
-        </property>
-		<property name="inventory" type="MAP">
-			<property name="slots" type="ARRAY">
-				<!-- Rings on left hand -->
-				<property type="MAP"> 
-					<property name="name" type="STRING" data="Left Ring"/>
-					<property name="type" type="STRING" data="bone"/>
-					<property name="bone" type="STRING" data="Bip01 L Finger21"/>
-					<property name="holds" type="INT" data="4"/> <!-- Rings -->
-					<property name="readies" type="INT" data="4"/> <!-- Rings -->
-				</property>
-				<!-- Rings on right hand -->
-				<property type="MAP"> 
-					<property name="name" type="STRING" data="Right Ring"/>
-					<property name="type" type="STRING" data="bone"/>
-					<property name="bone" type="STRING" data="Bip01 R Finger21"/>
-					<property name="holds" type="INT" data="4"/> <!-- Rings -->
-					<property name="readies" type="INT" data="4"/> <!-- Rings -->
-				</property>
-				<!-- Left hand -->
-				<property type="MAP"> 
-					<property name="name" type="STRING" data="Left Hand"/>
-					<property name="type" type="STRING" data="bone"/>
-					<property name="bone" type="STRING" data="Bip01 L SlotHand"/>
-					<property name="readies" type="INT" data="3"/> <!-- Weapons | Shields -->
-				</property>
-				<!-- Right hand -->
-				<property type="MAP"> 
-					<property name="name" type="STRING" data="Right Hand"/>
-					<property name="type" type="STRING" data="bone"/>
-					<property name="bone" type="STRING" data="Bip01 R SlotHand"/>
-					<property name="readies" type="INT" data="3"/> <!-- Weapons | Shields -->
-				</property>
-				<!-- Head -->
-				<property type="MAP"> 
-					<property name="name" type="STRING" data="Head"/>
-					<property name="type" type="STRING" data="submesh"/>
-					<property name="submesh" type="STRING" data="head"/>
-					<property name="readies" type="INT" data="2048"/> <!-- Helmets -->
-					<property name="holds" type="INT" data="2048"/> <!-- Helmets -->
-				</property>
-				<!-- Back -->
-				<property type="MAP"> 
-					<property name="name" type="STRING" data="Back"/>
-					<property name="type" type="STRING" data="submesh"/>
-					<property name="submesh" type="STRING" data="back"/>
-					<property name="readies" type="INT" data="256"/> <!-- Backpacks -->
-					<property name="holds" type="INT" data="256"/> <!-- Backpacks -->
-				</property>
-				<!-- Armor -->
-				<property type="MAP"> 
-					<property name="name" type="STRING" data="Armor"/>
-					<property name="type" type="STRING" data="submesh"/>
-					<property name="submesh" type="STRING" data="armor"/>
-					<property name="readies" type="INT" data="32"/> <!-- Armor -->
-					<property name="holds" type="INT" data="32"/> <!-- Armor -->
-				</property>
-				<!-- Torso -->
-				<property type="MAP"> 
-					<property name="name" type="STRING" data="Torso"/>
-					<property name="type" type="STRING" data="submesh"/>
-					<property name="submesh" type="STRING" data="torso"/>
-					<property name="readies" type="INT" data="32800"/> <!-- Armor | Clothes -->
-					<property name="holds" type="INT" data="32800"/> <!-- Armor | Clothes -->
-				</property>
-				<!-- Clothes -->
-				<property type="MAP"> 
-					<property name="name" type="STRING" data="Clothes"/>
-					<property name="type" type="STRING" data="submesh"/>
-					<property name="submesh" type="STRING" data="clothes"/>
-					<property name="readies" type="INT" data="32768"/> <!-- Clothes -->
-					<property name="holds" type="INT" data="32768"/> <!-- Clothes -->
-				</property>
-				<!-- Boots -->
-				<property type="MAP"> 
-					<property name="name" type="STRING" data="Boots"/>
-					<property name="type" type="STRING" data="submesh"/>
-					<property name="submesh" type="STRING" data="boots"/>
-					<property name="readies" type="INT" data="16384"/> <!-- Boots -->
-					<property name="holds" type="INT" data="16384"/> <!-- Boots -->
-				</property>
-				<!-- Trousers -->
-				<property type="MAP"> 
-					<property name="name" type="STRING" data="Trousers"/>
-					<property name="type" type="STRING" data="submesh"/>
-					<property name="submesh" type="STRING" data="trousers"/>
-					<property name="readies" type="INT" data="4096"/> <!-- Trousers -->
-					<property name="holds" type="INT" data="4096"/> <!-- Trousers -->
-				</property>				
-			</property>
-		</property>
-		
-		<property name="kampftechniken" type="MAP">
-			<property name="Schwerter" type="INTPAIR" data="5,7"/>
-		</property>
-		
-		<!-- Animationen und Animationsgeschwindigkeiten fuer den CreatureController -->
-		<property name="animations" type="MAP">
-			<property name="sterben" type="STRING" data="Idle"/>
-			<property name="liegen" type="STRING" data="Idle"/>
-			<property name="fallen" type="STRING" data="Idle"/>
-			<property name="fallen_anfang" type="STRING" data="Idle"/>
-			<property name="fallen_landung" type="STRING" data="Idle"/>
-			<property name="stehen" type="STRING" data="Idle"/>
-			<property name="stehen_rechts" type="STRING" data="Idle"/>
-			<property name="stehen_links" type="STRING" data="Idle"/>
-			<!-- property name="seitwaerts_links" type="STRING" data="seitwaerts_links"/ -->
-			<!-- property name="seitwaerts_rechts" type="STRING" data="seitwaerts_rechts"/ -->
-			<property name="gehen" type="STRING" data="Walk"/>
-			<property name="gehen_rueckwaerts" type="STRING" data="Walk"/>
-			<property name="joggen_rueckwaerts" type="STRING" data="Walk"/>
-			<property name="joggen" type="STRING" data="Run"/>
-			<property name="laufen" type="STRING" data="Run"/>
-			<property name="rennen" type="STRING" data="Run"/>
-			<property name="stehen_zu_schleichen" type="STRING" data="idle_zu_hocke"/>
-			<property name="schleichen_zu_stehen" type="STRING" data="hocke_zu_stehen"/>
-			<property name="schleichen" type="STRING" data="hocke_idle"/>
-			<property name="schleichen_vorwaerts" type="STRING" data="hocke_gehen"/>
-			<property name="hochsprung_absprung" type="STRING" data="idle_absprung"/>
-			<property name="hochsprung" type="STRING" data="idle_sprung"/>
-			<property name="hochsprung_landung" type="STRING" data="idle_sprung_landung"/>
-			<property name="weitsprung_absprung" type="STRING" data="rennen_absprung"/>
-			<property name="weitsprung" type="STRING" data="rennen_sprung"/>
-			<property name="weitsprung_landung" type="STRING" data="rennen_sprung_landung"/>
-			
-			
-			<!-- Kampf -->
-			<property name="kampf_attacke_pariert" type="STRING" data="1h_hieb_attack1"/>
-			<property name="kampf_attacke_treffer_nicht_pariert" type="STRING" data="1h_hieb_attack1"/>
-			<property name="kampf_attacke_treffer" type="STRING" data="1h_hieb_attack1"/>
-			<property name="kampf_attacke_misserfolg" type="STRING" data="1h_hieb_attack1"/>
-			<property name="kampf_parade_erfolg" type="STRING" data="1h_hieb_block1"/>
-			<property name="kampf_parade_misserfolg" type="STRING" data="1h_hieb_gethit1"/>
-			<property name="kampf_getroffen" type="STRING" data="1h_hieb_gethit1"/>
-			
-			
-			
-			
-		</property>
-		<!-- Je nach key ist die Value ein absoluter oder ein relativer Wert! -->
-		<property name="animationspeeds" type="MAP">
-			<!-- property name="stehen" type="REAL" data="1"/ -->
-			<!-- property name="stehen_rechts" type="REAL" data="drehen_rechts"/ -->
-			<!-- property name="stehen_links" type="REAL" data="drehen_links"/ -->
-			<!-- property name="seitwaerts_links" type="REAL" data="1"/ -->
-			<!-- property name="seitwaerts_rechts" type="REAL" data="1"/ -->
-			<property name="gehen" type="REAL" data="1.1"/>
-			<!-- property name="gehen_rueckwaerts" type="REAL" data="1"/ -->
-			<!-- property name="joggen_rueckwaerts" type="REAL" data="1"/ -->
-			<property name="joggen" type="REAL" data="0.6"/>
-			<property name="laufen" type="REAL" data="0.5"/>
-			<property name="rennen" type="REAL" data="0.4"/>
-			<!-- property name="stehen_zu_schleichen" type="REAL" data="1"/ -->
-			<!-- property name="schleichen_zu_stehen" type="REAL" data="1"/ -->
-			<!-- property name="schleichen" type="REAL" data="1"/ -->
-			<!-- property name="schleichen_vorwaerts" type="REAL" data="1"/ -->
-			<!-- property name="hochsprung_absprung" type="REAL" data="1"/ -->
-			<!-- property name="hochsprung" type="REAL" data="1"/ -->
-			<!-- property name="hochsprung_landung" type="REAL" data="1"/ -->
-			<!-- property name="weitsprung_absprung" type="REAL" data="1"/ -->
-			<!-- property name="weitsprung" type="REAL" data="1"/ -->
-			<!-- property name="weitsprung_landung" type="REAL" data="1"/ -->
-		</property>
-		<property name="kampfaktionen" type="ARRAY">
-			<property type="STRING" data="Attacke"/>
-			<property type="STRING" data="Parade"/>
-			<property type="STRING" data="Ausweichen"/>
-			<property type="STRING" data="Bewegen"/>
-			<property type="STRING" data="Folgen"/>
-		</property>
-    </gameobjectclass>
-
 </GameObjectDefinitions>

Added: modules/common/dsa/items.gof
===================================================================
--- modules/common/dsa/items.gof	2008-09-01 20:42:34 UTC (rev 4494)
+++ modules/common/dsa/items.gof	2008-09-02 05:24:32 UTC (rev 4495)
@@ -0,0 +1,45 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<GameObjectDefinitions>
+
+	<gameobjectclass classid="chest" baseclass="Chest">
+	  <property name="name" type="STRING" data="Truhe"/>
+		<property name="description" type="STRING" data="Eine Truhe"/>
+		<property name="geometrytype" type="STRING" data="convexhull"/>
+		<property name="mass" type="REAL" data="0"/>
+		<property name="meshfile" type="STRING" data="ver_truhe_gross01.mesh"/>
+<!--		<property name="sound" type="STRING" data="doorcreak.ogg"/>-->
+	</gameobjectclass>
+
+	<gameobjectclass classid="torch" baseclass="Torch">
+		<property name="name" type="STRING" data="Eine Fackel"/>
+		<property name="geometrytype" type="STRING" data="convexhull"/>
+		<property name="meshfile" type="STRING" data="ins_fackel_01.mesh"/>
+		<property name="sound" type="STRING" data="feuer_knisternd_01.ogg"/>
+		<property name="flames" type="STRING" data="feuertest"/>
+		<!-- <property name="lightable" type="BOOL" data="true"/> -->
+		<property name="lit" type="BOOL" data="true"/>
+		<property name="size" type="INTPAIR" data="1,3"/>
+		<property name="imagename" type="STRING" data="set:ModelThumbnails image:Fackel"/>
+	</gameobjectclass>
+    
+    <gameobjectclass classid="leather backpack" baseclass="Container">
+        <property name="name" type="STRING" data="Rucksack"/>
+        <property name="description" type="STRING" data="Ein Lederrucksack (oder so)"/>
+        <property name="meshfile" type="STRING" data="men_human_female_backpack_leather_01.mesh"/>
+        <property name="submeshfile" type="STRING" data="backpack_leather_01.mesh"/>
+        <property name="imagename" type="STRING" data="set:ModelThumbnails image:Rucksack"/>
+        <property name="capacity" type="REAL" data="20.0"/>
+        <property name="volume" type="INTPAIR" data="8,6"/>
+        <property name="size" type="INTPAIR" data="2,2"/>
+        <property name="itemtype" type="INT" data="256"/>	
+		<property name="mass" type="REAL" data="5.0"/>
+		<property name="geometrytype" type="STRING" data="ellipsoid"/>
+        <property name="actions" type="ARRAY">
+			<property type="STRING" data="showcontainercontent"/>
+        </property>
+        <property name="defaultaction" type="STRING" data="showcontainercontent"/>
+    </gameobjectclass>
+
+
+
+</GameObjectDefinitions>

Added: modules/common/dsa/persons.gof
===================================================================
--- modules/common/dsa/persons.gof	2008-09-01 20:42:34 UTC (rev 4494)
+++ modules/common/dsa/persons.gof	2008-09-02 05:24:32 UTC (rev 4495)
@@ -0,0 +1,285 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<GameObjectDefinitions>
+
+	<gameobjectclass classid="hero" baseclass="Hero">
+		<property name="geometrytype" type="STRING" data="ellipsoid" />
+		<property name="mass" type="REAL" data="75"/>
+		<property name="inventorywindowtype" type="STRING" data="inventory_human.xml"/>
+		<property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+		<property name="name" type="STRING" data="Alrike"/>
+		<property name="description" type="STRING" data="Heldin von Berufung"/>
+		<property name="inventory" type="MAP">
+			<property name="slots" type="ARRAY">
+				<!-- Left hand -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Left Hand"/>
+					<property name="type" type="STRING" data="bone"/>
+					<property name="bone" type="STRING" data="l_hand"/>
+					<property name="readies" type="INT" data="3"/> <!-- Weapons | Shields -->
+				</property>
+				<!-- Right hand -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Right Hand"/>
+					<property name="type" type="STRING" data="bone"/>
+					<property name="bone" type="STRING" data="r_hand"/>
+					<property name="readies" type="INT" data="3"/> <!-- Weapons | Shields -->
+				</property>
+			</property>
+		</property>
+		<property name="eigenschaften" type="MAP">
+			<property name="MU" type="INT" data="12"/>
+			<property name="KL" type="INT" data="8"/>
+			<property name="IN" type="INT" data="9"/>
+			<property name="CH" type="INT" data="10"/>
+			<property name="FF" type="INT" data="11"/>
+			<property name="GE" type="INT" data="12"/>
+			<property name="KO" type="INT" data="13"/>
+			<property name="KK" type="INT" data="14"/>
+		</property>
+		<property name="kampftechniken" type="MAP">
+			<property name="Schwerter" type="INTPAIR" data="5,7"/>
+		</property>
+		<property name="talente" type="MAP">
+			<property name="Athletik" type="INT" data="3"/>
+<!--			<property name="K?rperbeherrschung" type="INT" data="3"/>-->
+		</property>
+		<!-- Animationen und Animationsgeschwindigkeiten fuer den CreatureController -->
+		<property name="animations" type="MAP">
+			<property name="sterben" type="STRING" data="idle"/>
+			<property name="liegen" type="STRING" data="idle"/>
+			<property name="fallen" type="STRING" data="idle"/>
+			<property name="fallen_anfang" type="STRING" data="idle"/>
+			<property name="fallen_landung" type="STRING" data="idle"/>
+			<property name="stehen" type="STRING" data="idle"/>
+			<property name="stehen_rechts" type="STRING" data="drehen_links"/>
+			<property name="stehen_links" type="STRING" data="drehen_rechts"/>
+			<!-- property name="seitwaerts_links" type="STRING" data="seitwaerts_links"/ -->
+			<!-- property name="seitwaerts_rechts" type="STRING" data="seitwaerts_rechts"/ -->
+			<property name="gehen" type="STRING" data="gehen"/>
+			<property name="gehen_rueckwaerts" type="STRING" data="gehen_rueckwaerts"/>
+			<property name="joggen_rueckwaerts" type="STRING" data="gehen_rueckwaerts"/>
+			<property name="joggen" type="STRING" data="rennen"/>
+			<property name="laufen" type="STRING" data="rennen"/>
+			<property name="rennen" type="STRING" data="rennen"/>
+			<property name="stehen_zu_schleichen" type="STRING" data="idle_zu_hocke"/>
+			<property name="schleichen_zu_stehen" type="STRING" data="hocke_zu_stehen"/>
+			<property name="schleichen" type="STRING" data="hocke_idle"/>
+			<property name="schleichen_vorwaerts" type="STRING" data="hocke_gehen"/>
+			<property name="hochsprung_absprung" type="STRING" data="idle_absprung"/>
+			<property name="hochsprung" type="STRING" data="idle_sprung"/>
+			<property name="hochsprung_landung" type="STRING" data="idle_sprung_landung"/>
+			<property name="weitsprung_absprung" type="STRING" data="rennen_absprung"/>
+			<property name="weitsprung" type="STRING" data="rennen_sprung"/>
+			<property name="weitsprung_landung" type="STRING" data="rennen_sprung_landung"/>
+			<property name="fallen" type="STRING" data="idle"/>
+			<!-- Kampf -->
+			<property name="kampf_attacke_pariert" type="STRING" data="kampf_schwerter_angriff_1"/>
+			<property name="kampf_attacke_treffer_nicht_pariert" type="STRING" data="kampf_schwerter_angriff_1"/>
+			<property name="kampf_attacke_treffer" type="STRING" data="kampf_schwerter_angriff_1"/>
+			<property name="kampf_attacke_misserfolg" type="STRING" data="kampf_schwerter_angriff_1"/>
+			<property name="kampf_parade_erfolg" type="STRING" data="kampf_schwerter_parade_1"/>
+			<property name="kampf_parade_misserfolg" type="STRING" data="kampf_schwerter_getroffen"/>
+			<property name="kampf_getroffen" type="STRING" data="kampf_schwerter_getroffen"/>
+		</property>
+		<property name="animationspeeds" type="MAP">
+			<property name="gehen" type="REAL" data="1.0"/>
+			<property name="joggen" type="REAL" data="0.3"/>
+			<property name="laufen" type="REAL" data="0.5"/>
+			<property name="rennen" type="REAL" data="0.4"/>
+		</property>
+		<property name="kampfaktionen" type="ARRAY">
+			<property type="STRING" data="Attacke"/>
+			<property type="STRING" data="Parade"/>
+			<property type="STRING" data="Ausweichen"/>
+			<property type="STRING" data="Bewegen"/>
+			<property type="STRING" data="Folgen"/>
+		</property>
+	</gameobjectclass>
+
+    <gameobjectclass classid="mckhero"  baseclass="MCKHero">
+        <property name="geometrytype" type="STRING" data="ellipsoid" />
+        <property name="mass" type="REAL" data="75"/>
+        <property name="inventorywindowtype" type="STRING" data="inventory_human.xml"/>
+        <property name="meshfile" type="STRING" data="men_human_female_torso.mesh"/>
+		<property name="submeshprename" type="STRING" data="men_human_female_"/>
+        <property name="geometrytype" type="STRING" data="ellipsoid"/>
+		<property name="meshparts" type="MAP">
+            <property name="torso" type="STRING" data="men_human_female_torso.mesh"/>
+            <property name="hand" type="STRING" data="men_human_female_hand_nude.mesh"/>
+            <property name="head" type="STRING" data="men_human_female_head_02.mesh"/>
+            <property name="hair" type="STRING" data="men_human_female_hair_long_01_normal.mesh"/>
+            <property name="trousers" type="STRING" data="men_human_female_legs_underpants.mesh"/>
+            <property name="boots" type="STRING" data="men_human_female_feet_nude.mesh"/>
+        </property>
+		<property name="inventory" type="MAP">
+			<property name="slots" type="ARRAY">
+				<!-- Rings on left hand -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Left Ring"/>
+					<property name="type" type="STRING" data="bone"/>
+					<property name="bone" type="STRING" data="Bip01 L Finger21"/>
+					<property name="holds" type="INT" data="4"/> <!-- Rings -->
+					<property name="readies" type="INT" data="4"/> <!-- Rings -->
+				</property>
+				<!-- Rings on right hand -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Right Ring"/>
+					<property name="type" type="STRING" data="bone"/>
+					<property name="bone" type="STRING" data="Bip01 R Finger21"/>
+					<property name="holds" type="INT" data="4"/> <!-- Rings -->
+					<property name="readies" type="INT" data="4"/> <!-- Rings -->
+				</property>
+				<!-- Left hand -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Left Hand"/>
+					<property name="type" type="STRING" data="bone"/>
+					<property name="bone" type="STRING" data="Bip01 L SlotHand"/>
+					<property name="readies" type="INT" data="3"/> <!-- Weapons | Shields -->
+				</property>
+				<!-- Right hand -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Right Hand"/>
+					<property name="type" type="STRING" data="bone"/>
+					<property name="bone" type="STRING" data="Bip01 R SlotHand"/>
+					<property name="readies" type="INT" data="3"/> <!-- Weapons | Shields -->
+				</property>
+				<!-- Head -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Head"/>
+					<property name="type" type="STRING" data="submesh"/>
+					<property name="submesh" type="STRING" data="head"/>
+					<property name="readies" type="INT" data="2048"/> <!-- Helmets -->
+					<property name="holds" type="INT" data="2048"/> <!-- Helmets -->
+				</property>
+				<!-- Back -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Back"/>
+					<property name="type" type="STRING" data="submesh"/>
+					<property name="submesh" type="STRING" data="back"/>
+					<property name="readies" type="INT" data="256"/> <!-- Backpacks -->
+					<property name="holds" type="INT" data="256"/> <!-- Backpacks -->
+				</property>
+				<!-- Armor -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Armor"/>
+					<property name="type" type="STRING" data="submesh"/>
+					<property name="submesh" type="STRING" data="armor"/>
+					<property name="readies" type="INT" data="32"/> <!-- Armor -->
+					<property name="holds" type="INT" data="32"/> <!-- Armor -->
+				</property>
+				<!-- Torso -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Torso"/>
+					<property name="type" type="STRING" data="submesh"/>
+					<property name="submesh" type="STRING" data="torso"/>
+					<property name="readies" type="INT" data="32800"/> <!-- Armor | Clothes -->
+					<property name="holds" type="INT" data="32800"/> <!-- Armor | Clothes -->
+				</property>
+				<!-- Clothes -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Clothes"/>
+					<property name="type" type="STRING" data="submesh"/>
+					<property name="submesh" type="STRING" data="clothes"/>
+					<property name="readies" type="INT" data="32768"/> <!-- Clothes -->
+					<property name="holds" type="INT" data="32768"/> <!-- Clothes -->
+				</property>
+				<!-- Boots -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Boots"/>
+					<property name="type" type="STRING" data="submesh"/>
+					<property name="submesh" type="STRING" data="boots"/>
+					<property name="readies" type="INT" data="16384"/> <!-- Boots -->
+					<property name="holds" type="INT" data="16384"/> <!-- Boots -->
+				</property>
+				<!-- Trousers -->
+				<property type="MAP"> 
+					<property name="name" type="STRING" data="Trousers"/>
+					<property name="type" type="STRING" data="submesh"/>
+					<property name="submesh" type="STRING" data="trousers"/>
+					<property name="readies" type="INT" data="4096"/> <!-- Trousers -->
+					<property name="holds" type="INT" data="4096"/> <!-- Trousers -->
+				</property>				
+			</property>
+		</property>
+		
+		<property name="kampftechniken" type="MAP">
+			<property name="Schwerter" type="INTPAIR" data="5,7"/>
+		</property>
+		
+		<!-- Animationen und Animationsgeschwindigkeiten fuer den CreatureController -->
+		<property name="animations" type="MAP">
+			<property name="sterben" type="STRING" data="Idle"/>
+			<property name="liegen" type="STRING" data="Idle"/>
+			<property name="fallen" type="STRING" data="Idle"/>
+			<property name="fallen_anfang" type="STRING" data="Idle"/>
+			<property name="fallen_landung" type="STRING" data="Idle"/>
+			<property name="stehen" type="STRING" data="Idle"/>
+			<property name="stehen_rechts" type="STRING" data="Idle"/>
+			<property name="stehen_links" type="STRING" data="Idle"/>
+			<!-- property name="seitwaerts_links" type="STRING" data="seitwaerts_links"/ -->
+			<!-- property name="seitwaerts_rechts" type="STRING" data="seitwaerts_rechts"/ -->
+			<property name="gehen" type="STRING" data="Walk"/>
+			<property name="gehen_rueckwaerts" type="STRING" data="Walk"/>
+			<property name="joggen_rueckwaerts" type="STRING" data="Walk"/>
+			<property name="joggen" type="STRING" data="Run"/>
+			<property name="laufen" type="STRING" data="Run"/>
+			<property name="rennen" type="STRING" data="Run"/>
+			<property name="stehen_zu_schleichen" type="STRING" data="idle_zu_hocke"/>
+			<property name="schleichen_zu_stehen" type="STRING" data="hocke_zu_stehen"/>
+			<property name="schleichen" type="STRING" data="hocke_idle"/>
+			<property name="schleichen_vorwaerts" type="STRING" data="hocke_gehen"/>
+			<property name="hochsprung_absprung" type="STRING" data="idle_absprung"/>
+			<property name="hochsprung" type="STRING" data="idle_sprung"/>
+			<property name="hochsprung_landung" type="STRING" data="idle_sprung_landung"/>
+			<property name="weitsprung_absprung" type="STRING" data="rennen_absprung"/>
+			<property name="weitsprung" type="STRING" data="rennen_sprung"/>
+			<property name="weitsprung_landung" type="STRING" data="rennen_sprung_landung"/>
+			
+			
+			<!-- Kampf -->
+			<property name="kampf_attacke_pariert" type="STRING" data="1h_hieb_attack1"/>
+			<property name="kampf_attacke_treffer_nicht_pariert" type="STRING" data="1h_hieb_attack1"/>
+			<property name="kampf_attacke_treffer" type="STRING" data="1h_hieb_attack1"/>
+			<property name="kampf_attacke_misserfolg" type="STRING" data="1h_hieb_attack1"/>
+			<property name="kampf_parade_erfolg" type="STRING" data="1h_hieb_block1"/>
+			<property name="kampf_parade_misserfolg" type="STRING" data="1h_hieb_gethit1"/>
+			<property name="kampf_getroffen" type="STRING" data="1h_hieb_gethit1"/>
+			
+			
+			
+			
+		</property>
+		<!-- Je nach key ist die Value ein absoluter oder ein relativer Wert! -->
+		<property name="animationspeeds" type="MAP">
+			<!-- property name="stehen" type="REAL" data="1"/ -->
+			<!-- property name="stehen_rechts" type="REAL" data="drehen_rechts"/ -->
+			<!-- property name="stehen_links" type="REAL" data="drehen_links"/ -->
+			<!-- property name="seitwaerts_links" type="REAL" data="1"/ -->
+			<!-- property name="seitwaerts_rechts" type="REAL" data="1"/ -->
+			<property name="gehen" type="REAL" data="1.1"/>
+			<!-- property name="gehen_rueckwaerts" type="REAL" data="1"/ -->
+			<!-- property name="joggen_rueckwaerts" type="REAL" data="1"/ -->
+			<property name="joggen" type="REAL" data="0.6"/>
+			<property name="laufen" type="REAL" data="0.5"/>
+			<property name="rennen" type="REAL" data="0.4"/>
+			<!-- property name="stehen_zu_schleichen" type="REAL" data="1"/ -->
+			<!-- property name="schleichen_zu_stehen" type="REAL" data="1"/ -->
+			<!-- property name="schleichen" type="REAL" data="1"/ -->
+			<!-- property name="schleichen_vorwaerts" type="REAL" data="1"/ -->
+			<!-- property name="hochsprung_absprung" type="REAL" data="1"/ -->
+			<!-- property name="hochsprung" type="REAL" data="1"/ -->
+			<!-- property name="hochsprung_landung" type="REAL" data="1"/ -->
+			<!-- property name="weitsprung_absprung" type="REAL" data="1"/ -->
+			<!-- property name="weitsprung" type="REAL" data="1"/ -->
+			<!-- property name="weitsprung_landung" type="REAL" data="1"/ -->
+		</property>
+		<property name="kampfaktionen" type="ARRAY">
+			<property type="STRING" data="Attacke"/>
+			<property type="STRING" data="Parade"/>
+			<property type="STRING" data="Ausweichen"/>
+			<property type="STRING" data="Bewegen"/>
+			<property type="STRING" data="Folgen"/>
+		</property>
+    </gameobjectclass>
+
+</GameObjectDefinitions>

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2008-09-01 20:42:34 UTC (rev 4494)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2008-09-02 05:24:32 UTC (rev 4495)
@@ -98,24 +98,6 @@
         <property name="geometrytype" type="STRING" data="sphere"/>
     </gameobjectclass>
 
-    <gameobjectclass classid="leather backpack" baseclass="Container">
-        <property name="name" type="STRING" data="Rucksack"/>
-        <property name="description" type="STRING" data="Ein Lederrucksack (oder so)"/>
-        <property name="meshfile" type="STRING" data="men_human_female_backpack_leather_01.mesh"/>
-        <property name="submeshfile" type="STRING" data="backpack_leather_01.mesh"/>
-        <property name="imagename" type="STRING" data="set:ModelThumbnails image:Rucksack"/>
-        <property name="capacity" type="REAL" data="20.0"/>
-        <property name="volume" type="INTPAIR" data="8,6"/>
-        <property name="size" type="INTPAIR" data="2,2"/>
-        <property name="itemtype" type="INT" data="256"/>	
-		<property name="mass" type="REAL" data="5.0"/>
-		<property name="geometrytype" type="STRING" data="ellipsoid"/>
-        <property name="actions" type="ARRAY">
-			<property type="STRING" data="showcontainercontent"/>
-        </property>
-        <property name="defaultaction" type="STRING" data="showcontainercontent"/>
-    </gameobjectclass>
-
     <!-- ErrorHandlingTest -->
     <gameobjectclass classid="ErrorHandling" baseclass="GameObject">
         <property name="name" type="STRING" data="ErrorHandling-TestCase"/>



From blakharaz at mail.berlios.de  Tue Sep  2 07:25:50 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 2 Sep 2008 07:25:50 +0200
Subject: [Dsa-hl-svn] r4496 - modules/persistenztest/maps
Message-ID: <200809020525.m825PoTP031206@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-02 07:25:47 +0200 (Tue, 02 Sep 2008)
New Revision: 4496

Modified:
   modules/persistenztest/maps/persistenztest01.rlmap.xml
   modules/persistenztest/maps/persistenztest02.rlmap.xml
Log:


Modified: modules/persistenztest/maps/persistenztest01.rlmap.xml
===================================================================
--- modules/persistenztest/maps/persistenztest01.rlmap.xml	2008-09-02 05:24:32 UTC (rev 4495)
+++ modules/persistenztest/maps/persistenztest01.rlmap.xml	2008-09-02 05:25:47 UTC (rev 4496)
@@ -7,6 +7,9 @@
 		<gameobject class="number1" id="11" state="IN_SCENE">
             <position x="5" y="0.2" z="0"/>
         </gameobject>
+        <gameobject class="Kurzschwert" id="115" state="IN_SCENE">
+            <position x="10" y="0.2" z="0"/>
+        </gameobject>
 		<entity meshfile="nx.crosshair.mesh">
 			<position x="0.0" y="0.2" z="4.0" />
             <scale x="1.0" y="1.0" z="1.0" />

Modified: modules/persistenztest/maps/persistenztest02.rlmap.xml
===================================================================
--- modules/persistenztest/maps/persistenztest02.rlmap.xml	2008-09-02 05:24:32 UTC (rev 4495)
+++ modules/persistenztest/maps/persistenztest02.rlmap.xml	2008-09-02 05:25:47 UTC (rev 4496)
@@ -7,5 +7,8 @@
 		<gameobject class="number2" id="12" state="IN_SCENE">
             <position x="5" y="0.0" z="0"/>
         </gameobject>
+        <gameobject class="leather backpack" id="215" state="IN_SCENE">
+            <position x="10" y="0.2" z="0"/>
+        </gameobject>
     </nodes>
 </scene>



From blakharaz at mail.berlios.de  Tue Sep  2 07:26:45 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 2 Sep 2008 07:26:45 +0200
Subject: [Dsa-hl-svn] r4497 - rl/trunk/Mac/tools
Message-ID: <200809020526.m825Qj4t031511@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-02 07:26:41 +0200 (Tue, 02 Sep 2008)
New Revision: 4497

Added:
   rl/trunk/Mac/tools/mkdmg.sh
Log:
script for creating DMG images

Added: rl/trunk/Mac/tools/mkdmg.sh
===================================================================
--- rl/trunk/Mac/tools/mkdmg.sh	2008-09-02 05:25:47 UTC (rev 4496)
+++ rl/trunk/Mac/tools/mkdmg.sh	2008-09-02 05:26:41 UTC (rev 4497)
@@ -0,0 +1,21 @@
+#!/bin/sh
+#
+# Creates a disk image (dmg) on Mac OS X from the command line.
+# usage:
+#    mkdmg.sh <volname> <srcdir>
+#
+# Where <volname> is the name to use for the mounted image, <vers> is the version
+# number of the volume and <srcdir> is where the contents to put on the dmg are.
+#
+# The result will be a file called <volname>-<vers>.dmg
+
+if [ $# != 2 ]; then
+ echo "usage: mkdmg.sh volname srcdir"
+ exit 0
+fi
+
+VOL="$1"
+FILES="$2"
+
+#hdiutil create "$DMG" -megabytes ${SIZE} -ov -srcfolder ${FILES} -fs "Journaled HFS+"
+hdiutil create "$VOL" -ov -srcfolder ${FILES} -fs "HFS+"


Property changes on: rl/trunk/Mac/tools/mkdmg.sh
___________________________________________________________________
Name: svn:executable
   + *



From blakharaz at mail.berlios.de  Wed Sep  3 08:47:37 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 3 Sep 2008 08:47:37 +0200
Subject: [Dsa-hl-svn] r4498 - rl/trunk/engine/script/swig
Message-ID: <200809030647.m836lbfP024367@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-03 08:47:34 +0200 (Wed, 03 Sep 2008)
New Revision: 4498

Modified:
   rl/trunk/engine/script/swig/RlExports.i
   rl/trunk/engine/script/swig/TypeOgreColourValue.swig
   rl/trunk/engine/script/swig/TypeOgreQuaternion.swig
   rl/trunk/engine/script/swig/TypeOgreRadian.swig
   rl/trunk/engine/script/swig/TypeOgreStringVector.swig
   rl/trunk/engine/script/swig/TypeOgreVector3.swig
   rl/trunk/engine/script/swig/TypeRlCeGuiString.swig
   rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.swig
   rl/trunk/engine/script/swig/TypeRlProperty.swig
   rl/trunk/engine/script/swig/TypeRlPropertyKeys.swig
   rl/trunk/engine/script/swig/TypeStdPairIntInt.swig
Log:
Less blocks and source code in cxx generated by SWIG

Modified: rl/trunk/engine/script/swig/RlExports.i
===================================================================
--- rl/trunk/engine/script/swig/RlExports.i	2008-09-02 05:26:41 UTC (rev 4497)
+++ rl/trunk/engine/script/swig/RlExports.i	2008-09-03 06:47:34 UTC (rev 4498)
@@ -131,6 +131,43 @@
 
 
 // Converting C++ Exceptions to Ruby Exceptions
+%{
+enum RlExceptionClass 
+{
+    RLEX_UNKNOWN,
+    RLEX_CEGUI,
+    RLEX_STL,
+    RLEX_SWIG_DIRECTOR
+};
+
+void throwRubyException(RlExceptionClass clazz, const char* exceptionMessage)
+{
+    static VALUE ceguiException = rb_define_class("CeguiException", rb_eRuntimeError);
+    static VALUE stdException = rb_define_class("StdException", rb_eRuntimeError);
+	static VALUE swigException = rb_define_class("SwigDirectorException", rb_eRuntimeError);
+    static VALUE unknownException = rb_define_class("UnknownException", rb_eRuntimeError);
+
+    VALUE rubyClass;
+    if (clazz == RLEX_CEGUI)
+    {
+        rubyClass = ceguiException;
+    }
+    else if (clazz == RLEX_STL)
+    {
+        rubyClass = stdException;
+    }
+    else if (clazz == RLEX_SWIG_DIRECTOR)
+    {
+        rubyClass = swigException;
+    }
+    else //if (clazz == RLEX_UNKNOWN)
+    {
+        rubyClass = unknownException;
+    }
+    rb_raise(rubyClass, exceptionMessage);
+}
+%}
+
 %exception %{
   try 
   {
@@ -138,23 +175,19 @@
   }
   catch (CEGUI::Exception& ce) 
   {
-    static VALUE ceguiException = rb_define_class("CeguiException", rb_eRuntimeError);
-    rb_raise(ceguiException, ce.getMessage().c_str());
+    throwRubyException(RLEX_CEGUI, ce.getMessage().c_str());
   }
   catch (std::exception& se) 
   {
-    static VALUE stdException = rb_define_class("StdException", rb_eRuntimeError);
-    rb_raise(stdException, se.what());
+    throwRubyException(RLEX_STL, se.what());
   }
   catch (Swig::DirectorException& de)
   {
-	static VALUE swigException = rb_define_class("SwigDirectorException", rb_eRuntimeError);
-	rb_raise(swigException, de.getMessage().c_str());
+	throwRubyException(RLEX_SWIG_DIRECTOR, de.getMessage().c_str());
   }
   catch (...) 
   {
-    static VALUE unknownException = rb_define_class("UnknownException", rb_eRuntimeError);
-    rb_raise(unknownException,"Unbekannte Exception");
+    throwRubyException(RLEX_UNKNOWN, "Unknown exception");
   }
 %}
 

Modified: rl/trunk/engine/script/swig/TypeOgreColourValue.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreColourValue.swig	2008-09-02 05:26:41 UTC (rev 4497)
+++ rl/trunk/engine/script/swig/TypeOgreColourValue.swig	2008-09-03 06:47:34 UTC (rev 4498)
@@ -69,19 +69,17 @@
 %}
 
 %typemap(in) Ogre::ColourValue, const Ogre::ColourValue
-{
-   Ogre::ColourValue vec(0.0, 0.0, 0.0, 0.0);
-   convertRubyToColourValue( $input, & vec );
-   $1 = vec;
-}
+%{
+   $1 = ColourValue(0.0, 0.0, 0.0, 0.0);
+   convertRubyToColourValue( $input, & $1 );
+%}
 
 %typemap(in) Ogre::ColourValue*, Ogre::ColourValue&,
    const Ogre::ColourValue*, const Ogre::ColourValue&
-{
-   Ogre::ColourValue* vec = new Ogre::ColourValue(0.0, 0.0, 0.0, 0.0);
-   convertRubyToColourValue(  $input, vec );
-   $1 = vec;
-}
+%{
+   $1 = new Ogre::ColourValue(0.0, 0.0, 0.0, 0.0);
+   convertRubyToColourValue(  $input, $1 );
+%}
 
 %{
 // Helper method for creating the ruby Array

Modified: rl/trunk/engine/script/swig/TypeOgreQuaternion.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreQuaternion.swig	2008-09-02 05:26:41 UTC (rev 4497)
+++ rl/trunk/engine/script/swig/TypeOgreQuaternion.swig	2008-09-03 06:47:34 UTC (rev 4498)
@@ -77,7 +77,7 @@
 
 %{
 // Helper method for converting ruby input to a Quaternion
-static Ogre::Quaternion* convertRubyToQuaternion( VALUE input, Ogre::Quaternion* quat )
+static void convertRubyToQuaternion( VALUE input, Ogre::Quaternion* quat )
 {
    if (RARRAY(input)->len == 2)
    {
@@ -114,24 +114,20 @@
 	   quat->y = NUM2DBL(rb_ary_entry(input, 2));
 	   quat->z = NUM2DBL(rb_ary_entry(input, 3));
    }
-
-   return quat;
 }
 %}
 
 %typemap(in) Ogre::Quaternion, const Ogre::Quaternion
-{
-   Ogre::Quaternion quat;
-   convertRubyToQuaternion( $input, & quat );
-   $1 = quat;
-}
+%{
+   convertRubyToQuaternion( $input, & $1 );
+%}
 
 %typemap(in) Ogre::Quaternion*, Ogre::Quaternion&,
    const Ogre::Quaternion*, const Ogre::Quaternion&
-{
-   Ogre::Quaternion* quat = new Ogre::Quaternion();  
-   $1 = convertRubyToQuaternion( $input, quat );
-}
+%{
+   $1 = new Ogre::Quaternion();  
+   convertRubyToQuaternion( $input, $1 );
+%}
 
 
 %{

Modified: rl/trunk/engine/script/swig/TypeOgreRadian.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreRadian.swig	2008-09-02 05:26:41 UTC (rev 4497)
+++ rl/trunk/engine/script/swig/TypeOgreRadian.swig	2008-09-03 06:47:34 UTC (rev 4498)
@@ -1,49 +1,52 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-/* Radian / Degree all Ruby Values are interpreted as DEGREE! */
-%typemap(typecheck) Ogre::Radian, const Ogre::Radian& = double;
-
-%typemap(in) Ogre::Radian, const Ogre::Radian, Ogre::Radian&, const Ogre::Radian& {
-    if (TYPE($input) == T_FLOAT) {
-		$1 = Ogre::Degree(RFLOAT($input)->value);
-    } else if (TYPE($input) == T_FIXNUM) {
-		$1 = Ogre::Degree(FIX2INT($input));
-    } else {
-        throw Swig::DirectorTypeMismatchException("float or fixnum expected");
-    }
-}
-%typemap(in) Ogre::Radian*, const Ogre::Radian*, Ogre::Radian&, const Ogre::Radian& {
-    if (TYPE($input) == T_FLOAT) {
-		$1 = new Ogre::Radian(Ogre::Degree(RFLOAT($input)->value));
-    } else if (TYPE($input) == T_FIXNUM) {
-		$1 = new Ogre::Radian(Ogre::Degree(FIX2INT($input)));
-    } else {
-        throw Swig::DirectorTypeMismatchException("float or fixnum expected");
-    }
-}
-
-%typemap(freearg) Ogre::Radian*, const Ogre::Radian*, Ogre::Radian&, const Ogre::Radian& 
-"   delete $1;"
-
-%typemap(out) Ogre::Radian, const Ogre::Radian {
-     $result = rb_float_new($1.valueDegrees());
-}
-%typemap(out) Ogre::Radian&, const Ogre::Radian& {
-     $result = rb_float_new($1->valueDegrees());
-}
-
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+/* Radian / Degree all Ruby Values are interpreted as DEGREE! */
+%typemap(typecheck) Ogre::Radian, const Ogre::Radian& = double;
+
+%typemap(in) Ogre::Radian, const Ogre::Radian, Ogre::Radian&, const Ogre::Radian& 
+%{
+    if (TYPE($input) == T_FLOAT) {
+		$1 = Ogre::Degree(RFLOAT($input)->value);
+    } else if (TYPE($input) == T_FIXNUM) {
+		$1 = Ogre::Degree(FIX2INT($input));
+    } else {
+        throw Swig::DirectorTypeMismatchException("float or fixnum expected");
+    }
+%}
+
+%typemap(in) Ogre::Radian*, const Ogre::Radian*, Ogre::Radian&, const Ogre::Radian&
+%{
+    if (TYPE($input) == T_FLOAT) {
+		$1 = new Ogre::Radian(Ogre::Degree(RFLOAT($input)->value));
+    } else if (TYPE($input) == T_FIXNUM) {
+		$1 = new Ogre::Radian(Ogre::Degree(FIX2INT($input)));
+    } else {
+        throw Swig::DirectorTypeMismatchException("float or fixnum expected");
+    }
+%}
+
+%typemap(freearg) Ogre::Radian*, const Ogre::Radian*, Ogre::Radian&, const Ogre::Radian& 
+    "delete $1;"
+
+%typemap(out) Ogre::Radian, const Ogre::Radian 
+    "$result = rb_float_new($1.valueDegrees());"
+
+%typemap(out) Ogre::Radian&, const Ogre::Radian& 
+    "$result = rb_float_new($1->valueDegrees());"
+
+
+

Modified: rl/trunk/engine/script/swig/TypeOgreStringVector.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreStringVector.swig	2008-09-02 05:26:41 UTC (rev 4497)
+++ rl/trunk/engine/script/swig/TypeOgreStringVector.swig	2008-09-03 06:47:34 UTC (rev 4498)
@@ -1,75 +1,74 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-%typemap(freearg) Ogre::StringVector &, const Ogre::StringVector & {
-  delete $1;
-}
-
-%typemap(out) Ogre::StringVector, const Ogre::StringVector {
-  VALUE arr = rb_ary_new2($1.size()); 
-  StringVector::iterator i = $1.begin(), iend = $1.end();
-  for ( ; i!=iend; i++ )
-    rb_ary_push(arr, rb_str_new2(*i));
-  $result = arr;
-}
-
-%typemap(in) Ogre::StringVector , const Ogre::StringVector {
-  Check_Type($input, T_ARRAY);
-  Ogre::StringVector vec;
-  int len = RARRAY($input)->len;
-  for (int i=0; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
-    vec.push_back(Ogre::String(StringValuePtr(inst)));
-  }
-  $1 = vec;
-}
-
-%typemap(directorin) Ogre::StringVector &, const Ogre::StringVector & {
-  VALUE arr = rb_ary_new2($1->size()); 
-  StringVector::iterator i = $1->begin(), iend = $1->end();
-  for ( ; i!=iend; i++ )
-    rb_ary_push(arr, rb_str_new2(&(*i)));
-  $result = arr;
-}
-%typemap(directorin) Ogre::StringVector, const Ogre::StringVector {
-  VALUE arr = rb_ary_new2($1.size()); 
-  StringVector::iterator i = $1.begin(), iend = $1.end();
-  for ( ; i!=iend; i++ )
-    rb_ary_push(arr, rb_str_new2(*i));
-  $result = arr;
-}
-
-%typemap(directorout) Ogre::StringVector , const Ogre::StringVector {
-  Check_Type($input, T_ARRAY);
-  Ogre::StringVector vec;
-  int len = RARRAY($input)->len;
-  for (int i=0; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
-    vec.push_back(Ogre::String(StringValuePtr(inst)));
-  }
-  $result = vec;
-}
-
-%typemap(directorout) Ogre::StringVector *, const Ogre::StringVector* , Ogre::StringVector &, const Ogre::StringVector& {
-  Check_Type($input, T_ARRAY);
-  Ogre::StringVector *vec = new Ogre::StringVector;
-  int len = RARRAY($input)->len;
-  for (int i=0; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
-    vec->push_back(Ogre::String(StringValuePtr(inst)));
-  }
-  $result = vec;
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+%typemap(freearg) Ogre::StringVector &, const Ogre::StringVector & 
+    "delete $1;"
+
+
+%typemap(out) Ogre::StringVector, const Ogre::StringVector 
+%{
+  $result = rb_ary_new2($1.size()); 
+  for (StringVector::iterator i = $1.begin(), iend = $1.end() ; i!=iend; i++ )
+  {
+    rb_ary_push($result, rb_str_new2(*i));
+  }
+%}
+
+%typemap(in) Ogre::StringVector , const Ogre::StringVector 
+%{
+  Check_Type($input, T_ARRAY);
+  int len = RARRAY($input)->len;
+  for (int i=0; i!=len; i++) {
+    VALUE inst = rb_ary_entry($input, i);
+    $1.push_back(Ogre::String(StringValuePtr(inst)));
+  }
+%}
+
+%typemap(directorin) Ogre::StringVector &, const Ogre::StringVector &
+%{
+  $result = rb_ary_new2($1->size()); 
+  for (StringVector::iterator i = $1->begin(), iend = $1->end(); i!=iend; i++ ) 
+  {
+    rb_ary_push($result, rb_str_new2(*i));
+  }
+%}
+%typemap(directorin) Ogre::StringVector, const Ogre::StringVector 
+%{
+  $result = rb_ary_new2($1.size()); 
+  for (StringVector::iterator i = $1.begin(), iend = $1.end(); i!=iend; i++ ) 
+  {
+    rb_ary_push($result, rb_str_new2(*i));
+  }
+%}
+
+%typemap(directorout) Ogre::StringVector , const Ogre::StringVector 
+%{
+  Check_Type($input, T_ARRAY);
+  for (int i=0, len = RARRAY($input)->len; i!=len; i++) {
+    VALUE inst = rb_ary_entry($input, i);
+    $result.push_back(Ogre::String(StringValuePtr(inst)));
+  }
+%}
+
+%typemap(directorout) Ogre::StringVector *, const Ogre::StringVector* , Ogre::StringVector &, const Ogre::StringVector& 
+%{
+  Check_Type($input, T_ARRAY);
+  $result = new Ogre::StringVector();
+  for (int i=0, len = RARRAY($input)->len; i!=len; i++) {
+    VALUE inst = rb_ary_entry($input, i);
+    $result->push_back(Ogre::String(StringValuePtr(inst)));
+  }
+%}

Modified: rl/trunk/engine/script/swig/TypeOgreVector3.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreVector3.swig	2008-09-02 05:26:41 UTC (rev 4497)
+++ rl/trunk/engine/script/swig/TypeOgreVector3.swig	2008-09-03 06:47:34 UTC (rev 4498)
@@ -62,19 +62,16 @@
 %}
 
 %typemap(in) Ogre::Vector3, const Ogre::Vector3
-{
-   Ogre::Vector3 vec(0.0, 0.0, 0.0);
-   convertRubyToVector3( $input, & vec );
-   $1 = vec;
-}
+%{
+   convertRubyToVector3( $input, & $1 );
+%}
 
 %typemap(in) Ogre::Vector3*, Ogre::Vector3&,
    const Ogre::Vector3*, const Ogre::Vector3&
-{
-   Ogre::Vector3* vec = new Ogre::Vector3(0.0, 0.0, 0.0);
+%{
+   $1 = new Ogre::Vector3(0.0, 0.0, 0.0);
    convertRubyToVector3(  $input, vec );
-   $1 = vec;
-}
+%}
 
 %{
 // Helper method for creating the ruby Array

Modified: rl/trunk/engine/script/swig/TypeRlCeGuiString.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlCeGuiString.swig	2008-09-02 05:26:41 UTC (rev 4497)
+++ rl/trunk/engine/script/swig/TypeRlCeGuiString.swig	2008-09-03 06:47:34 UTC (rev 4498)
@@ -32,9 +32,10 @@
     "Check_Type($input, T_STRING);
     $1 = new rl::CeGuiString(
 		reinterpret_cast<CEGUI::utf8*>(StringValuePtr($input)));"
-%typemap(freearg) rl::CeGuiString*, rl::CeGuiString&, const rl::CeGuiString*, const rl::CeGuiString&  {
-   delete $1;
-}
+
+%typemap(freearg) rl::CeGuiString*, rl::CeGuiString&, const rl::CeGuiString*, const rl::CeGuiString&
+   "delete $1;"
+
 %typemap(out) rl::CeGuiString*, rl::CeGuiString&,  const rl::CeGuiString*, const rl::CeGuiString& 
      "$result = rb_str_buf_new2($1->c_str());"
 
@@ -48,10 +49,8 @@
 	"$input = rb_str_buf_new2($1->c_str());"
 
 %typemap(directorout) rl::CeGuiString, const rl::CeGuiString 
-    "$result = rl::CeGuiString(
-		reinterpret_cast<CEGUI::utf8*>(StringValuePtr($input)));"
+    "$result = rl::CeGuiString(reinterpret_cast<CEGUI::utf8*>(StringValuePtr($input)));"
 
 %typemap(directorout) const rl::CeGuiString &, rl::CeGuiString&  
     "$result = new rl::CeGuiString();
-     $result->append( 
-		reinterpret_cast<CEGUI::utf8*>(StringValuePtr($input)) );"
+     $result->append(reinterpret_cast<CEGUI::utf8*>(StringValuePtr($input)));"

Modified: rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.swig	2008-09-02 05:26:41 UTC (rev 4497)
+++ rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.swig	2008-09-03 06:47:34 UTC (rev 4498)
@@ -19,19 +19,17 @@
 
 
 %typemap(directorin) rl::CeGuiStringVector &, const rl::CeGuiStringVector & {
-  VALUE arr = rb_ary_new2($1->size()); 
+  $result = rb_ary_new2($1->size()); 
   rl::CeGuiStringVector::iterator i = $1->begin(), iend = $1->end();
   for ( ; i!=iend; i++ )
-    rb_ary_push(arr, rb_str_new2(&(*i)));
-  $result = arr;
+    rb_ary_push($result, rb_str_new2(&(*i)));
 }
 
 %typemap(directorin) rl::CeGuiStringVector, const rl::CeGuiStringVector {
-  VALUE arr = rb_ary_new2($1.size()); 
+  $result = rb_ary_new2($1.size()); 
   rl::CeGuiStringVector::iterator i = $1.begin(), iend = $1.end();
   for ( ; i!=iend; i++ )
-    rb_ary_push(arr, rb_str_new2(*i));
-  $result = arr;
+    rb_ary_push($result, rb_str_new2(*i));
 }
 
 %typemap(directorout) rl::CeGuiStringVector , const rl::CeGuiStringVector {

Modified: rl/trunk/engine/script/swig/TypeRlProperty.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlProperty.swig	2008-09-02 05:26:41 UTC (rev 4497)
+++ rl/trunk/engine/script/swig/TypeRlProperty.swig	2008-09-03 06:47:34 UTC (rev 4498)
@@ -213,7 +213,7 @@
 
 
 %typemap(typecheck) rl::Property, const rl::Property, rl::Property&, const rl::Property&, rl::Property*, const rl::Property* 
-{
+"
     if (TYPE($input) == T_FLOAT 
         || TYPE($input) == T_FIXNUM 
 	    || TYPE($input) == T_STRING
@@ -226,7 +226,7 @@
     }
     
     return 0;
-}
+"
 
 %typemap(in) rl::Property, const rl::Property
 "   
@@ -249,9 +249,7 @@
 "   delete $1;"
 
 %typemap(directorout) rl::Property, const rl::Property, rl::Property&, const rl::Property&
-"   
-	$result = rl::convertValueToProperty($1);
-"
+"   $result = rl::convertValueToProperty($1);"
 
 %typemap(directorout) rl::Property*, const rl::Property*
 "   

Modified: rl/trunk/engine/script/swig/TypeRlPropertyKeys.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlPropertyKeys.swig	2008-09-02 05:26:41 UTC (rev 4497)
+++ rl/trunk/engine/script/swig/TypeRlPropertyKeys.swig	2008-09-03 06:47:34 UTC (rev 4498)
@@ -50,14 +50,14 @@
 
 
 %typemap(typecheck) rl::PropertyKeys, const rl::PropertyKeys 
-{
+"
     if (TYPE($input) == T_ARRAY) 
     {
         return 1;
     }
     
     return 0;
-}
+"
 
 %typemap(in) rl::PropertyKeys, const rl::PropertyKeys
 "   

Modified: rl/trunk/engine/script/swig/TypeStdPairIntInt.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeStdPairIntInt.swig	2008-09-02 05:26:41 UTC (rev 4497)
+++ rl/trunk/engine/script/swig/TypeStdPairIntInt.swig	2008-09-03 06:47:34 UTC (rev 4498)
@@ -18,46 +18,38 @@
 	std::pair<int,int>*, std::pair<int,int>&, 
 	const std::pair<int,int>*, const std::pair<int,int>&, 
 	std::pair<int,int>, const std::pair<int,int>
-{
-   $1 = TYPE($input) == T_ARRAY && RARRAY($input)->len == 2 ? 1 : 0;
-}
+"   $1 = TYPE($input) == T_ARRAY && RARRAY($input)->len == 2 ? 1 : 0; "
 
 
 %typemap(in) std::pair<int,int>*, std::pair<int,int>&,
    const std::pair<int,int>*, const std::pair<int,int>&
-{
-	std::pair<int, int>* val = new std::pair<int, int>();
-	val->first = NUM2INT(rb_ary_entry($input, 0)), 
-	val->second = NUM2INT(rb_ary_entry($input, 1));
-	
-	$1 = val;
-}
+"
+	$1 = new std::pair<int, int>();
+	$1->first = NUM2INT(rb_ary_entry($input, 0)), 
+	$1->second = NUM2INT(rb_ary_entry($input, 1));
+"
+
 %typemap(freearg) std::pair<int,int>*, std::pair<int,int>&, 
-const std::pair<int,int>*, const std::pair<int,int>&  {
-   delete $1;
-}
+const std::pair<int,int>*, const std::pair<int,int>&
+   "delete $1;"
 
 %typemap(in) std::pair<int,int>, const std::pair<int,int>
-{
+"
 	$1.first = NUM2INT(rb_ary_entry($input, 0)), 
 	$1.second = NUM2INT(rb_ary_entry($input, 1));
-}
+"
 
 %typemap(out) std::pair<int,int>, const std::pair<int,int>
-{
-	VALUE array = rb_ary_new();
-	rb_ary_push(array, rb_int_new($1.first));
-	rb_ary_push(array, rb_int_new($1.second));
-	$result = array;
-}
+"
+	$result = rb_ary_new();
+	rb_ary_push($result, rb_int_new($1.first));
+	rb_ary_push($result, rb_int_new($1.second));
+"
 
 %typemap(out) std::pair<int,int>*, std::pair<int,int>&,
    const std::pair<int,int>*, const std::pair<int,int>&
-{
-	VALUE array = rb_ary_new();
-	rb_ary_push(array, rb_int_new($1->first));
-	rb_ary_push(array, rb_int_new($1->second));
-	$result = array;
-}
-
-
+"
+	$result = rb_ary_new();
+	rb_ary_push($result, rb_int_new($1->first));
+	rb_ary_push($result, rb_int_new($1->second));
+"
\ No newline at end of file



From blakharaz at mail.berlios.de  Wed Sep  3 08:47:55 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 3 Sep 2008 08:47:55 +0200
Subject: [Dsa-hl-svn] r4499 - rl/trunk/Mac/Rastullah.xcodeproj
Message-ID: <200809030647.m836ltMJ024408@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-03 08:47:54 +0200 (Wed, 03 Sep 2008)
New Revision: 4499

Modified:
   rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
Log:


Modified: rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-03 06:47:34 UTC (rev 4498)
+++ rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-03 06:47:54 UTC (rev 4499)
@@ -430,6 +430,7 @@
 		44D8147B0BF7B62F00534175 /* Zone.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814760BF7B62F00534175 /* Zone.h */; };
 		44D8147C0BF7B62F00534175 /* ZoneManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814770BF7B62F00534175 /* ZoneManager.h */; };
 		48003B550E3211660056D073 /* libboost_system.dylib in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
+		4835559B0E6ABED100008748 /* mkdmg.sh in Resources */ = {isa = PBXBuildFile; fileRef = 4835559A0E6ABED100008748 /* mkdmg.sh */; };
 		483646990D83D13700912FEC /* ContentLoader.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646960D83D13700912FEC /* ContentLoader.h */; };
 		4836469A0D83D13700912FEC /* SoundStitching.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646970D83D13700912FEC /* SoundStitching.h */; };
 		4836469B0D83D13700912FEC /* StartAnimationJob.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646980D83D13700912FEC /* StartAnimationJob.h */; };
@@ -670,6 +671,7 @@
 		48B772E30D583521000A3B97 /* XmlProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B772E00D583521000A3B97 /* XmlProcessor.cpp */; };
 		48B772E40D583521000A3B97 /* XmlPropertyReader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B772E10D583521000A3B97 /* XmlPropertyReader.cpp */; };
 		48B772E50D583521000A3B97 /* XmlPropertyWriter.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B772E20D583521000A3B97 /* XmlPropertyWriter.cpp */; };
+		48C04B8A0E67DF0300CD3A7D /* PCRE.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 48C04B890E67DF0300CD3A7D /* PCRE.framework */; };
 		48CFBF8F0E2E869000CD0C51 /* FreeType.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 48CFBF8E0E2E869000CD0C51 /* FreeType.framework */; };
 		48D0BDC70E23375E00863824 /* libruby.dylib in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 483646A10D83D57800912FEC /* libruby.dylib */; };
 		48D0BDE60E23378700863824 /* libboost_filesystem.dylib in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52B210E0EDA0E008DBDD8 /* libboost_filesystem.dylib */; };
@@ -851,6 +853,7 @@
 			dstPath = "";
 			dstSubfolderSpec = 10;
 			files = (
+				48C04B8A0E67DF0300CD3A7D /* PCRE.framework in Copy Frameworks */,
 				48003B550E3211660056D073 /* libboost_system.dylib in Copy Frameworks */,
 				48D0BDE60E23378700863824 /* libboost_filesystem.dylib in Copy Frameworks */,
 				48CFBF8F0E2E869000CD0C51 /* FreeType.framework in Copy Frameworks */,
@@ -1296,6 +1299,7 @@
 		44D814750BF7B62F00534175 /* Trigger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Trigger.h; path = ../engine/core/include/Trigger.h; sourceTree = SOURCE_ROOT; };
 		44D814760BF7B62F00534175 /* Zone.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Zone.h; path = ../engine/core/include/Zone.h; sourceTree = SOURCE_ROOT; };
 		44D814770BF7B62F00534175 /* ZoneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZoneManager.h; path = ../engine/core/include/ZoneManager.h; sourceTree = SOURCE_ROOT; };
+		4835559A0E6ABED100008748 /* mkdmg.sh */ = {isa = PBXFileReference; explicitFileType = text.script.sh; fileEncoding = 4; name = mkdmg.sh; path = tools/mkdmg.sh; sourceTree = "<group>"; };
 		483646960D83D13700912FEC /* ContentLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ContentLoader.h; path = ../engine/core/include/ContentLoader.h; sourceTree = SOURCE_ROOT; };
 		483646970D83D13700912FEC /* SoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundStitching.h; path = ../engine/core/include/SoundStitching.h; sourceTree = SOURCE_ROOT; };
 		483646980D83D13700912FEC /* StartAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = StartAnimationJob.h; path = ../engine/core/include/StartAnimationJob.h; sourceTree = SOURCE_ROOT; };
@@ -1485,6 +1489,7 @@
 		48B772E00D583521000A3B97 /* XmlProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlProcessor.cpp; path = ../engine/common/src/XmlProcessor.cpp; sourceTree = SOURCE_ROOT; };
 		48B772E10D583521000A3B97 /* XmlPropertyReader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlPropertyReader.cpp; path = ../engine/common/src/XmlPropertyReader.cpp; sourceTree = SOURCE_ROOT; };
 		48B772E20D583521000A3B97 /* XmlPropertyWriter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlPropertyWriter.cpp; path = ../engine/common/src/XmlPropertyWriter.cpp; sourceTree = SOURCE_ROOT; };
+		48C04B890E67DF0300CD3A7D /* PCRE.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = PCRE.framework; path = /Library/Frameworks/PCRE.framework; sourceTree = "<absolute>"; };
 		48CFBF8E0E2E869000CD0C51 /* FreeType.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = FreeType.framework; path = /Library/Frameworks/FreeType.framework; sourceTree = "<absolute>"; };
 		48CFBFD70E2E87BB00CD0C51 /* renameinstalldirs.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; name = renameinstalldirs.sh; path = tools/renameinstalldirs.sh; sourceTree = "<group>"; };
 		48D0BE280E273C5E00863824 /* SaveAble.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAble.h; path = ../engine/core/include/SaveAble.h; sourceTree = SOURCE_ROOT; };
@@ -1682,6 +1687,7 @@
 		20286C29FDCF999611CA2CEA /* Rastullah */ = {
 			isa = PBXGroup;
 			children = (
+				48C04B890E67DF0300CD3A7D /* PCRE.framework */,
 				48B0B0480E65BBB30023B198 /* libfmodex.dylib */,
 				20286C2AFDCF999611CA2CEA /* Sources */,
 				20286C2CFDCF999611CA2CEA /* Resources */,
@@ -2442,6 +2448,7 @@
 			isa = PBXGroup;
 			children = (
 				48CFBFD70E2E87BB00CD0C51 /* renameinstalldirs.sh */,
+				4835559A0E6ABED100008748 /* mkdmg.sh */,
 			);
 			name = Scripts;
 			sourceTree = "<group>";
@@ -2973,7 +2980,7 @@
 				8D0C4E8F0486CD37000505A6 /* Sources */,
 				8D0C4E910486CD37000505A6 /* Frameworks */,
 				484D8D0A0E1E058D00BCFC2B /* Copy Frameworks */,
-				48D0BDF20E2342F600863824 /* ShellScript */,
+				48D0BDF20E2342F600863824 /* Rename Libs */,
 			);
 			buildRules = (
 			);
@@ -3040,6 +3047,7 @@
 				8D0C4E8E0486CD37000505A6 /* main.nib in Resources */,
 				48D409CE0D9E483300AE5340 /* modules in Resources */,
 				48B5F63A0DAF48AF00D05C95 /* Info.plist in Resources */,
+				4835559B0E6ABED100008748 /* mkdmg.sh in Resources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3059,18 +3067,19 @@
 			shellPath = /bin/sh;
 			shellScript = "pwd\ncd ../engine/script/swig\n/usr/local/bin/swig -ruby -minherit -c++ -Fmicrosoft -addextern RlExports.i";
 		};
-		48D0BDF20E2342F600863824 /* ShellScript */ = {
+		48D0BDF20E2342F600863824 /* Rename Libs */ = {
 			isa = PBXShellScriptBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
 			);
 			inputPaths = (
 			);
+			name = "Rename Libs";
 			outputPaths = (
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 			shellPath = /bin/sh;
-			shellScript = "${SOURCE_ROOT}/tools/renameinstalldirs.sh ${BUILT_PRODUCTS_DIR}/Rastullah.app/Contents/MacOS Rastullah\n";
+			shellScript = "${SOURCE_ROOT}/tools/renameinstalldirs.sh ${BUILT_PRODUCTS_DIR}/Rastullah.app/Contents/MacOS Rastullah\n# ${SOURCE_ROOT}/tools/mkdmg.sh rastullah 1 ${BUILT_PRODUCTS_DIR}/Rastullah.app";
 		};
 /* End PBXShellScriptBuildPhase section */
 



From blakharaz at mail.berlios.de  Fri Sep  5 00:11:10 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 5 Sep 2008 00:11:10 +0200
Subject: [Dsa-hl-svn] r4500 - in rl/trunk/engine/script: src swig
Message-ID: <200809042211.m84MBA43010348@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-05 00:11:08 +0200 (Fri, 05 Sep 2008)
New Revision: 4500

Modified:
   rl/trunk/engine/script/src/SceneManager.cpp
   rl/trunk/engine/script/swig/TypeOgreStringVector.swig
   rl/trunk/engine/script/swig/TypeOgreVector3.swig
   rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.swig
Log:



Modified: rl/trunk/engine/script/src/SceneManager.cpp
===================================================================
--- rl/trunk/engine/script/src/SceneManager.cpp	2008-09-03 06:47:54 UTC (rev 4499)
+++ rl/trunk/engine/script/src/SceneManager.cpp	2008-09-04 22:11:08 UTC (rev 4500)
@@ -76,21 +76,20 @@
         std::map<CeGuiString, Scene*>::iterator itScene = mScenes.find(sceneName);
         if (itScene != mScenes.end())
         {            
+            std::map<Scene*, PropertyRecordPtr>::iterator itState =
+                mSceneStates.end();
             if (saveCurrent) 
             {
-                itScene->second->load(false);
-                mCurrentScene = itScene->second;
                 std::map<Scene*, PropertyRecordPtr>::iterator itState 
                     = mSceneStates.find(mCurrentScene);
-                if (itState != mSceneStates.end())
-                {
-                    mCurrentScene->setProperties(itState->second);
-                }
             }
-            else 
+
+            itScene->second->load(itState != mSceneStates.end()); // don't load game objects if there is a saved state
+            mCurrentScene = itScene->second;
+            
+            if (itState != mSceneStates.end())
             {
-                itScene->second->load(true);
-                mCurrentScene = itScene->second;
+                mCurrentScene->setProperties(itState->second);
             }
         }
         else

Modified: rl/trunk/engine/script/swig/TypeOgreStringVector.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreStringVector.swig	2008-09-03 06:47:54 UTC (rev 4499)
+++ rl/trunk/engine/script/swig/TypeOgreStringVector.swig	2008-09-04 22:11:08 UTC (rev 4500)
@@ -1,74 +1,102 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-%typemap(freearg) Ogre::StringVector &, const Ogre::StringVector & 
-    "delete $1;"
-
-
-%typemap(out) Ogre::StringVector, const Ogre::StringVector 
-%{
-  $result = rb_ary_new2($1.size()); 
-  for (StringVector::iterator i = $1.begin(), iend = $1.end() ; i!=iend; i++ )
-  {
-    rb_ary_push($result, rb_str_new2(*i));
-  }
-%}
-
-%typemap(in) Ogre::StringVector , const Ogre::StringVector 
-%{
-  Check_Type($input, T_ARRAY);
-  int len = RARRAY($input)->len;
-  for (int i=0; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
-    $1.push_back(Ogre::String(StringValuePtr(inst)));
-  }
-%}
-
-%typemap(directorin) Ogre::StringVector &, const Ogre::StringVector &
-%{
-  $result = rb_ary_new2($1->size()); 
-  for (StringVector::iterator i = $1->begin(), iend = $1->end(); i!=iend; i++ ) 
-  {
-    rb_ary_push($result, rb_str_new2(*i));
-  }
-%}
-%typemap(directorin) Ogre::StringVector, const Ogre::StringVector 
-%{
-  $result = rb_ary_new2($1.size()); 
-  for (StringVector::iterator i = $1.begin(), iend = $1.end(); i!=iend; i++ ) 
-  {
-    rb_ary_push($result, rb_str_new2(*i));
-  }
-%}
-
-%typemap(directorout) Ogre::StringVector , const Ogre::StringVector 
-%{
-  Check_Type($input, T_ARRAY);
-  for (int i=0, len = RARRAY($input)->len; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
-    $result.push_back(Ogre::String(StringValuePtr(inst)));
-  }
-%}
-
-%typemap(directorout) Ogre::StringVector *, const Ogre::StringVector* , Ogre::StringVector &, const Ogre::StringVector& 
-%{
-  Check_Type($input, T_ARRAY);
-  $result = new Ogre::StringVector();
-  for (int i=0, len = RARRAY($input)->len; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
-    $result->push_back(Ogre::String(StringValuePtr(inst)));
-  }
-%}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+%{
+void convertRubyToOgreStringVector(VALUE input, Ogre::StringVector& vec)
+{
+  Check_Type(input, T_ARRAY);
+  int len = RARRAY(input)->len;
+  for (int i=0; i!=len; i++) 
+  {
+    VALUE inst = rb_ary_entry(input, i);
+    vec.push_back(Ogre::String(StringValuePtr(inst)));
+  }
+}
+
+VALUE convertOgreStringVectorToRuby(const Ogre::StringVector& vec)
+{
+  VALUE arr = rb_ary_new2(vec.size()); 
+  for (Ogre::StringVector::const_iterator i = vec.begin(), iend = vec.end() ; i!=iend; i++ )
+  {
+    rb_ary_push(arr, rb_str_new2(i->c_str()));
+  }
+  return arr;
+}
+
+static int checkRubyOgreStringVector( VALUE input ) 
+{
+	bool correct = false;
+
+	if (TYPE(input) == T_ARRAY)
+	{
+        correct = true;
+	}
+	
+    return (correct ? 1 : 0);
+}
+
+%}
+
+
+%typemap(typecheck)  
+   Ogre::StringVector, const Ogre::StringVector, 
+   Ogre::StringVector*, Ogre::StringVector&,
+   const Ogre::StringVector*, const Ogre::StringVector& 
+%{
+	$1 = checkRubyOgreStringVector($input);	
+%}
+
+%typemap(freearg) Ogre::StringVector &, const Ogre::StringVector & 
+    "delete $1;"
+
+%typemap(out) Ogre::StringVector, const Ogre::StringVector 
+%{
+  $result = convertOgreStringVectorToRuby($1); 
+%}
+%typemap(out) Ogre::StringVector&, const Ogre::StringVector&, Ogre::StringVector*, const Ogre::StringVector* 
+%{
+  $result = convertOgreStringVectorToRuby(*$1); 
+%}
+
+%typemap(in) Ogre::StringVector , const Ogre::StringVector 
+%{
+  convertRubyToOgreStringVector($input, $1);
+%}
+%typemap(in) Ogre::StringVector&, const Ogre::StringVector&, Ogre::StringVector*, const Ogre::StringVector*
+%{
+    $result = new Ogre::StringVector();
+    convertRubyToOgreStringVector($input, *$1);
+%}
+
+%typemap(directorin) Ogre::StringVector &, const Ogre::StringVector &
+%{
+  $result = convertOgreStringVectorToRuby(*$1); 
+%}
+%typemap(directorin) Ogre::StringVector, const Ogre::StringVector 
+%{
+  $result = convertOgreStringVectorToRuby($1);
+%}
+
+%typemap(directorout) Ogre::StringVector , const Ogre::StringVector 
+%{
+  convertRubyToOgreStringVector($input, $result);
+%}
+
+%typemap(directorout) Ogre::StringVector *, const Ogre::StringVector* , Ogre::StringVector &, const Ogre::StringVector& 
+%{
+  $result = new Ogre::StringVector();
+  convertRubyToOgreStringVector($input, *$result);
+%}

Modified: rl/trunk/engine/script/swig/TypeOgreVector3.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreVector3.swig	2008-09-03 06:47:54 UTC (rev 4499)
+++ rl/trunk/engine/script/swig/TypeOgreVector3.swig	2008-09-04 22:11:08 UTC (rev 4500)
@@ -70,7 +70,7 @@
    const Ogre::Vector3*, const Ogre::Vector3&
 %{
    $1 = new Ogre::Vector3(0.0, 0.0, 0.0);
-   convertRubyToVector3(  $input, vec );
+   convertRubyToVector3(  $input, $1 );
 %}
 
 %{

Modified: rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.swig	2008-09-03 06:47:54 UTC (rev 4499)
+++ rl/trunk/engine/script/swig/TypeRlCeGuiStringVector.swig	2008-09-04 22:11:08 UTC (rev 4500)
@@ -14,42 +14,50 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+%{
+void convertRubyToCeGuiStringVector(VALUE input, rl::CeGuiStringVector& vec)
+{
+  Check_Type(input, T_ARRAY);
+  int len = RARRAY(input)->len;
+  for (int i=0; i!=len; i++) 
+  {
+    VALUE inst = rb_ary_entry(input, i);
+    vec.push_back(rl::CeGuiString(StringValuePtr(inst)));
+  }
+}
+
+VALUE convertCeGuiStringVectorToRuby(const rl::CeGuiStringVector& input)
+{
+  VALUE arr = rb_ary_new2(input.size()); 
+  for (rl::CeGuiStringVector::const_iterator i = input.begin(), iend = input.end() ; i!=iend; i++ )
+  {
+    rb_ary_push(arr, rb_str_new2(i->c_str()));
+  }
+  return arr;
+}
+%}
+
 %typemap(freearg) rl::CeGuiStringVector &, const rl::CeGuiStringVector & 
 "  delete $1;"
 
 
-%typemap(directorin) rl::CeGuiStringVector &, const rl::CeGuiStringVector & {
-  $result = rb_ary_new2($1->size()); 
-  rl::CeGuiStringVector::iterator i = $1->begin(), iend = $1->end();
-  for ( ; i!=iend; i++ )
-    rb_ary_push($result, rb_str_new2(&(*i)));
-}
+%typemap(directorin) rl::CeGuiStringVector &, const rl::CeGuiStringVector & 
+%{
+  $result = convertCeGuiStringVectorToRuby(*$1); 
+%}
 
-%typemap(directorin) rl::CeGuiStringVector, const rl::CeGuiStringVector {
-  $result = rb_ary_new2($1.size()); 
-  rl::CeGuiStringVector::iterator i = $1.begin(), iend = $1.end();
-  for ( ; i!=iend; i++ )
-    rb_ary_push($result, rb_str_new2(*i));
-}
+%typemap(directorin) rl::CeGuiStringVector, const rl::CeGuiStringVector
+%{
+  $result = convertCeGuiStringVectorToRuby($1); 
+%}
 
-%typemap(directorout) rl::CeGuiStringVector , const rl::CeGuiStringVector {
-  Check_Type($input, T_ARRAY);
-  rl::CeGuiStringVector vec;
-  int len = RARRAY($input)->len;
-  for (int i=0; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
-    vec.push_back(rl::CeGuiString(StringValuePtr(inst)));
-  }
-  $result = vec;
-}
+%typemap(directorout) rl::CeGuiStringVector , const rl::CeGuiStringVector
+%{
+  convertRubyToCeGuiStringVector($input, $result);
+%}
 
-%typemap(directorout) rl::CeGuiStringVector &, const rl::CeGuiStringVector& {
-  Check_Type($input, T_ARRAY);
-  rl::CeGuiStringVector *vec = new rl::CeGuiStringVector;
-  int len = RARRAY($input)->len;
-  for (int i=0; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
-    vec->push_back(rl::CeGuiString(StringValuePtr(inst)));
-  }
-  $result = vec;
-}
+%typemap(directorout) rl::CeGuiStringVector &, const rl::CeGuiStringVector& 
+%{
+  $result = new rl::CeGuiStringVector();
+  convertRubyToCeGuiStringVector($input, * $result);
+%}



From blakharaz at mail.berlios.de  Fri Sep  5 00:14:35 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 5 Sep 2008 00:14:35 +0200
Subject: [Dsa-hl-svn] r4501 - rl/trunk/engine/core/src
Message-ID: <200809042214.m84MEZ5v010831@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-05 00:14:33 +0200 (Fri, 05 Sep 2008)
New Revision: 4501

Modified:
   rl/trunk/engine/core/src/ActorManager.cpp
Log:



Modified: rl/trunk/engine/core/src/ActorManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ActorManager.cpp	2008-09-04 22:11:08 UTC (rev 4500)
+++ rl/trunk/engine/core/src/ActorManager.cpp	2008-09-04 22:14:33 UTC (rev 4501)
@@ -111,6 +111,7 @@
             Throw(IllegalArgumentException, "Argument actor wird nicht vom ActorManager verwaltet.");
         }
         mActors.erase(it);
+        LOG_MESSAGE("ActorManager", "Delete actor '"+actor->getName()+"'");
         //actor->detachAllChildren(); //just avoiding a crash. is there a better resolution?
         // should not be needed, is also done in the destructor of the actor
 



From melven at mail.berlios.de  Sat Sep  6 23:09:14 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sat, 6 Sep 2008 23:09:14 +0200
Subject: [Dsa-hl-svn] r4502 - in rl/branches/newton20:
	Mac/Rastullah.xcodeproj Mac/tools engine/core/src
	engine/script/src engine/script/swig
Message-ID: <200809062109.m86L9ENi032505@sheep.berlios.de>

Author: melven
Date: 2008-09-06 23:08:59 +0200 (Sat, 06 Sep 2008)
New Revision: 4502

Added:
   rl/branches/newton20/Mac/tools/mkdmg.sh
Modified:
   rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/branches/newton20/engine/core/src/ActorManager.cpp
   rl/branches/newton20/engine/script/src/SceneManager.cpp
   rl/branches/newton20/engine/script/swig/RlExports.i
   rl/branches/newton20/engine/script/swig/TypeOgreColourValue.swig
   rl/branches/newton20/engine/script/swig/TypeOgreQuaternion.swig
   rl/branches/newton20/engine/script/swig/TypeOgreRadian.swig
   rl/branches/newton20/engine/script/swig/TypeOgreStringVector.swig
   rl/branches/newton20/engine/script/swig/TypeOgreVector3.swig
   rl/branches/newton20/engine/script/swig/TypeRlCeGuiString.swig
   rl/branches/newton20/engine/script/swig/TypeRlCeGuiStringVector.swig
   rl/branches/newton20/engine/script/swig/TypeRlProperty.swig
   rl/branches/newton20/engine/script/swig/TypeRlPropertyKeys.swig
   rl/branches/newton20/engine/script/swig/TypeStdPairIntInt.swig
Log:
merged changes from trunk


Modified: rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-04 22:14:33 UTC (rev 4501)
+++ rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-06 21:08:59 UTC (rev 4502)
@@ -430,6 +430,7 @@
 		44D8147B0BF7B62F00534175 /* Zone.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814760BF7B62F00534175 /* Zone.h */; };
 		44D8147C0BF7B62F00534175 /* ZoneManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814770BF7B62F00534175 /* ZoneManager.h */; };
 		48003B550E3211660056D073 /* libboost_system.dylib in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
+		4835559B0E6ABED100008748 /* mkdmg.sh in Resources */ = {isa = PBXBuildFile; fileRef = 4835559A0E6ABED100008748 /* mkdmg.sh */; };
 		483646990D83D13700912FEC /* ContentLoader.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646960D83D13700912FEC /* ContentLoader.h */; };
 		4836469A0D83D13700912FEC /* SoundStitching.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646970D83D13700912FEC /* SoundStitching.h */; };
 		4836469B0D83D13700912FEC /* StartAnimationJob.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646980D83D13700912FEC /* StartAnimationJob.h */; };
@@ -670,6 +671,7 @@
 		48B772E30D583521000A3B97 /* XmlProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B772E00D583521000A3B97 /* XmlProcessor.cpp */; };
 		48B772E40D583521000A3B97 /* XmlPropertyReader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B772E10D583521000A3B97 /* XmlPropertyReader.cpp */; };
 		48B772E50D583521000A3B97 /* XmlPropertyWriter.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B772E20D583521000A3B97 /* XmlPropertyWriter.cpp */; };
+		48C04B8A0E67DF0300CD3A7D /* PCRE.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 48C04B890E67DF0300CD3A7D /* PCRE.framework */; };
 		48CFBF8F0E2E869000CD0C51 /* FreeType.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 48CFBF8E0E2E869000CD0C51 /* FreeType.framework */; };
 		48D0BDC70E23375E00863824 /* libruby.dylib in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 483646A10D83D57800912FEC /* libruby.dylib */; };
 		48D0BDE60E23378700863824 /* libboost_filesystem.dylib in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52B210E0EDA0E008DBDD8 /* libboost_filesystem.dylib */; };
@@ -851,6 +853,7 @@
 			dstPath = "";
 			dstSubfolderSpec = 10;
 			files = (
+				48C04B8A0E67DF0300CD3A7D /* PCRE.framework in Copy Frameworks */,
 				48003B550E3211660056D073 /* libboost_system.dylib in Copy Frameworks */,
 				48D0BDE60E23378700863824 /* libboost_filesystem.dylib in Copy Frameworks */,
 				48CFBF8F0E2E869000CD0C51 /* FreeType.framework in Copy Frameworks */,
@@ -1296,6 +1299,7 @@
 		44D814750BF7B62F00534175 /* Trigger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Trigger.h; path = ../engine/core/include/Trigger.h; sourceTree = SOURCE_ROOT; };
 		44D814760BF7B62F00534175 /* Zone.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Zone.h; path = ../engine/core/include/Zone.h; sourceTree = SOURCE_ROOT; };
 		44D814770BF7B62F00534175 /* ZoneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZoneManager.h; path = ../engine/core/include/ZoneManager.h; sourceTree = SOURCE_ROOT; };
+		4835559A0E6ABED100008748 /* mkdmg.sh */ = {isa = PBXFileReference; explicitFileType = text.script.sh; fileEncoding = 4; name = mkdmg.sh; path = tools/mkdmg.sh; sourceTree = "<group>"; };
 		483646960D83D13700912FEC /* ContentLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ContentLoader.h; path = ../engine/core/include/ContentLoader.h; sourceTree = SOURCE_ROOT; };
 		483646970D83D13700912FEC /* SoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundStitching.h; path = ../engine/core/include/SoundStitching.h; sourceTree = SOURCE_ROOT; };
 		483646980D83D13700912FEC /* StartAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = StartAnimationJob.h; path = ../engine/core/include/StartAnimationJob.h; sourceTree = SOURCE_ROOT; };
@@ -1485,6 +1489,7 @@
 		48B772E00D583521000A3B97 /* XmlProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlProcessor.cpp; path = ../engine/common/src/XmlProcessor.cpp; sourceTree = SOURCE_ROOT; };
 		48B772E10D583521000A3B97 /* XmlPropertyReader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlPropertyReader.cpp; path = ../engine/common/src/XmlPropertyReader.cpp; sourceTree = SOURCE_ROOT; };
 		48B772E20D583521000A3B97 /* XmlPropertyWriter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlPropertyWriter.cpp; path = ../engine/common/src/XmlPropertyWriter.cpp; sourceTree = SOURCE_ROOT; };
+		48C04B890E67DF0300CD3A7D /* PCRE.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = PCRE.framework; path = /Library/Frameworks/PCRE.framework; sourceTree = "<absolute>"; };
 		48CFBF8E0E2E869000CD0C51 /* FreeType.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = FreeType.framework; path = /Library/Frameworks/FreeType.framework; sourceTree = "<absolute>"; };
 		48CFBFD70E2E87BB00CD0C51 /* renameinstalldirs.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; name = renameinstalldirs.sh; path = tools/renameinstalldirs.sh; sourceTree = "<group>"; };
 		48D0BE280E273C5E00863824 /* SaveAble.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAble.h; path = ../engine/core/include/SaveAble.h; sourceTree = SOURCE_ROOT; };
@@ -1682,6 +1687,7 @@
 		20286C29FDCF999611CA2CEA /* Rastullah */ = {
 			isa = PBXGroup;
 			children = (
+				48C04B890E67DF0300CD3A7D /* PCRE.framework */,
 				48B0B0480E65BBB30023B198 /* libfmodex.dylib */,
 				20286C2AFDCF999611CA2CEA /* Sources */,
 				20286C2CFDCF999611CA2CEA /* Resources */,
@@ -2442,6 +2448,7 @@
 			isa = PBXGroup;
 			children = (
 				48CFBFD70E2E87BB00CD0C51 /* renameinstalldirs.sh */,
+				4835559A0E6ABED100008748 /* mkdmg.sh */,
 			);
 			name = Scripts;
 			sourceTree = "<group>";
@@ -2973,7 +2980,7 @@
 				8D0C4E8F0486CD37000505A6 /* Sources */,
 				8D0C4E910486CD37000505A6 /* Frameworks */,
 				484D8D0A0E1E058D00BCFC2B /* Copy Frameworks */,
-				48D0BDF20E2342F600863824 /* ShellScript */,
+				48D0BDF20E2342F600863824 /* Rename Libs */,
 			);
 			buildRules = (
 			);
@@ -3040,6 +3047,7 @@
 				8D0C4E8E0486CD37000505A6 /* main.nib in Resources */,
 				48D409CE0D9E483300AE5340 /* modules in Resources */,
 				48B5F63A0DAF48AF00D05C95 /* Info.plist in Resources */,
+				4835559B0E6ABED100008748 /* mkdmg.sh in Resources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3059,18 +3067,19 @@
 			shellPath = /bin/sh;
 			shellScript = "pwd\ncd ../engine/script/swig\n/usr/local/bin/swig -ruby -minherit -c++ -Fmicrosoft -addextern RlExports.i";
 		};
-		48D0BDF20E2342F600863824 /* ShellScript */ = {
+		48D0BDF20E2342F600863824 /* Rename Libs */ = {
 			isa = PBXShellScriptBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
 			);
 			inputPaths = (
 			);
+			name = "Rename Libs";
 			outputPaths = (
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 			shellPath = /bin/sh;
-			shellScript = "${SOURCE_ROOT}/tools/renameinstalldirs.sh ${BUILT_PRODUCTS_DIR}/Rastullah.app/Contents/MacOS Rastullah\n";
+			shellScript = "${SOURCE_ROOT}/tools/renameinstalldirs.sh ${BUILT_PRODUCTS_DIR}/Rastullah.app/Contents/MacOS Rastullah\n# ${SOURCE_ROOT}/tools/mkdmg.sh rastullah 1 ${BUILT_PRODUCTS_DIR}/Rastullah.app";
 		};
 /* End PBXShellScriptBuildPhase section */
 

Copied: rl/branches/newton20/Mac/tools/mkdmg.sh (from rev 4501, rl/trunk/Mac/tools/mkdmg.sh)

Modified: rl/branches/newton20/engine/core/src/ActorManager.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/ActorManager.cpp	2008-09-04 22:14:33 UTC (rev 4501)
+++ rl/branches/newton20/engine/core/src/ActorManager.cpp	2008-09-06 21:08:59 UTC (rev 4502)
@@ -111,6 +111,7 @@
             Throw(IllegalArgumentException, "Argument actor wird nicht vom ActorManager verwaltet.");
         }
         mActors.erase(it);
+        LOG_MESSAGE("ActorManager", "Delete actor '"+actor->getName()+"'");
         //actor->detachAllChildren(); //just avoiding a crash. is there a better resolution?
         // should not be needed, is also done in the destructor of the actor
 

Modified: rl/branches/newton20/engine/script/src/SceneManager.cpp
===================================================================
--- rl/branches/newton20/engine/script/src/SceneManager.cpp	2008-09-04 22:14:33 UTC (rev 4501)
+++ rl/branches/newton20/engine/script/src/SceneManager.cpp	2008-09-06 21:08:59 UTC (rev 4502)
@@ -76,21 +76,20 @@
         std::map<CeGuiString, Scene*>::iterator itScene = mScenes.find(sceneName);
         if (itScene != mScenes.end())
         {            
+            std::map<Scene*, PropertyRecordPtr>::iterator itState =
+                mSceneStates.end();
             if (saveCurrent) 
             {
-                itScene->second->load(false);
-                mCurrentScene = itScene->second;
                 std::map<Scene*, PropertyRecordPtr>::iterator itState 
                     = mSceneStates.find(mCurrentScene);
-                if (itState != mSceneStates.end())
-                {
-                    mCurrentScene->setProperties(itState->second);
-                }
             }
-            else 
+
+            itScene->second->load(itState != mSceneStates.end()); // don't load game objects if there is a saved state
+            mCurrentScene = itScene->second;
+            
+            if (itState != mSceneStates.end())
             {
-                itScene->second->load(true);
-                mCurrentScene = itScene->second;
+                mCurrentScene->setProperties(itState->second);
             }
         }
         else

Modified: rl/branches/newton20/engine/script/swig/RlExports.i
===================================================================
--- rl/branches/newton20/engine/script/swig/RlExports.i	2008-09-04 22:14:33 UTC (rev 4501)
+++ rl/branches/newton20/engine/script/swig/RlExports.i	2008-09-06 21:08:59 UTC (rev 4502)
@@ -131,6 +131,43 @@
 
 
 // Converting C++ Exceptions to Ruby Exceptions
+%{
+enum RlExceptionClass 
+{
+    RLEX_UNKNOWN,
+    RLEX_CEGUI,
+    RLEX_STL,
+    RLEX_SWIG_DIRECTOR
+};
+
+void throwRubyException(RlExceptionClass clazz, const char* exceptionMessage)
+{
+    static VALUE ceguiException = rb_define_class("CeguiException", rb_eRuntimeError);
+    static VALUE stdException = rb_define_class("StdException", rb_eRuntimeError);
+	static VALUE swigException = rb_define_class("SwigDirectorException", rb_eRuntimeError);
+    static VALUE unknownException = rb_define_class("UnknownException", rb_eRuntimeError);
+
+    VALUE rubyClass;
+    if (clazz == RLEX_CEGUI)
+    {
+        rubyClass = ceguiException;
+    }
+    else if (clazz == RLEX_STL)
+    {
+        rubyClass = stdException;
+    }
+    else if (clazz == RLEX_SWIG_DIRECTOR)
+    {
+        rubyClass = swigException;
+    }
+    else //if (clazz == RLEX_UNKNOWN)
+    {
+        rubyClass = unknownException;
+    }
+    rb_raise(rubyClass, exceptionMessage);
+}
+%}
+
 %exception %{
   try 
   {
@@ -138,23 +175,19 @@
   }
   catch (CEGUI::Exception& ce) 
   {
-    static VALUE ceguiException = rb_define_class("CeguiException", rb_eRuntimeError);
-    rb_raise(ceguiException, ce.getMessage().c_str());
+    throwRubyException(RLEX_CEGUI, ce.getMessage().c_str());
   }
   catch (std::exception& se) 
   {
-    static VALUE stdException = rb_define_class("StdException", rb_eRuntimeError);
-    rb_raise(stdException, se.what());
+    throwRubyException(RLEX_STL, se.what());
   }
   catch (Swig::DirectorException& de)
   {
-	static VALUE swigException = rb_define_class("SwigDirectorException", rb_eRuntimeError);
-	rb_raise(swigException, de.getMessage().c_str());
+	throwRubyException(RLEX_SWIG_DIRECTOR, de.getMessage().c_str());
   }
   catch (...) 
   {
-    static VALUE unknownException = rb_define_class("UnknownException", rb_eRuntimeError);
-    rb_raise(unknownException,"Unbekannte Exception");
+    throwRubyException(RLEX_UNKNOWN, "Unknown exception");
   }
 %}
 

Modified: rl/branches/newton20/engine/script/swig/TypeOgreColourValue.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/TypeOgreColourValue.swig	2008-09-04 22:14:33 UTC (rev 4501)
+++ rl/branches/newton20/engine/script/swig/TypeOgreColourValue.swig	2008-09-06 21:08:59 UTC (rev 4502)
@@ -69,19 +69,17 @@
 %}
 
 %typemap(in) Ogre::ColourValue, const Ogre::ColourValue
-{
-   Ogre::ColourValue vec(0.0, 0.0, 0.0, 0.0);
-   convertRubyToColourValue( $input, & vec );
-   $1 = vec;
-}
+%{
+   $1 = ColourValue(0.0, 0.0, 0.0, 0.0);
+   convertRubyToColourValue( $input, & $1 );
+%}
 
 %typemap(in) Ogre::ColourValue*, Ogre::ColourValue&,
    const Ogre::ColourValue*, const Ogre::ColourValue&
-{
-   Ogre::ColourValue* vec = new Ogre::ColourValue(0.0, 0.0, 0.0, 0.0);
-   convertRubyToColourValue(  $input, vec );
-   $1 = vec;
-}
+%{
+   $1 = new Ogre::ColourValue(0.0, 0.0, 0.0, 0.0);
+   convertRubyToColourValue(  $input, $1 );
+%}
 
 %{
 // Helper method for creating the ruby Array

Modified: rl/branches/newton20/engine/script/swig/TypeOgreQuaternion.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/TypeOgreQuaternion.swig	2008-09-04 22:14:33 UTC (rev 4501)
+++ rl/branches/newton20/engine/script/swig/TypeOgreQuaternion.swig	2008-09-06 21:08:59 UTC (rev 4502)
@@ -77,7 +77,7 @@
 
 %{
 // Helper method for converting ruby input to a Quaternion
-static Ogre::Quaternion* convertRubyToQuaternion( VALUE input, Ogre::Quaternion* quat )
+static void convertRubyToQuaternion( VALUE input, Ogre::Quaternion* quat )
 {
    if (RARRAY(input)->len == 2)
    {
@@ -114,24 +114,20 @@
 	   quat->y = NUM2DBL(rb_ary_entry(input, 2));
 	   quat->z = NUM2DBL(rb_ary_entry(input, 3));
    }
-
-   return quat;
 }
 %}
 
 %typemap(in) Ogre::Quaternion, const Ogre::Quaternion
-{
-   Ogre::Quaternion quat;
-   convertRubyToQuaternion( $input, & quat );
-   $1 = quat;
-}
+%{
+   convertRubyToQuaternion( $input, & $1 );
+%}
 
 %typemap(in) Ogre::Quaternion*, Ogre::Quaternion&,
    const Ogre::Quaternion*, const Ogre::Quaternion&
-{
-   Ogre::Quaternion* quat = new Ogre::Quaternion();  
-   $1 = convertRubyToQuaternion( $input, quat );
-}
+%{
+   $1 = new Ogre::Quaternion();  
+   convertRubyToQuaternion( $input, $1 );
+%}
 
 
 %{

Modified: rl/branches/newton20/engine/script/swig/TypeOgreRadian.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/TypeOgreRadian.swig	2008-09-04 22:14:33 UTC (rev 4501)
+++ rl/branches/newton20/engine/script/swig/TypeOgreRadian.swig	2008-09-06 21:08:59 UTC (rev 4502)
@@ -1,49 +1,52 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-/* Radian / Degree all Ruby Values are interpreted as DEGREE! */
-%typemap(typecheck) Ogre::Radian, const Ogre::Radian& = double;
-
-%typemap(in) Ogre::Radian, const Ogre::Radian, Ogre::Radian&, const Ogre::Radian& {
-    if (TYPE($input) == T_FLOAT) {
-		$1 = Ogre::Degree(RFLOAT($input)->value);
-    } else if (TYPE($input) == T_FIXNUM) {
-		$1 = Ogre::Degree(FIX2INT($input));
-    } else {
-        throw Swig::DirectorTypeMismatchException("float or fixnum expected");
-    }
-}
-%typemap(in) Ogre::Radian*, const Ogre::Radian*, Ogre::Radian&, const Ogre::Radian& {
-    if (TYPE($input) == T_FLOAT) {
-		$1 = new Ogre::Radian(Ogre::Degree(RFLOAT($input)->value));
-    } else if (TYPE($input) == T_FIXNUM) {
-		$1 = new Ogre::Radian(Ogre::Degree(FIX2INT($input)));
-    } else {
-        throw Swig::DirectorTypeMismatchException("float or fixnum expected");
-    }
-}
-
-%typemap(freearg) Ogre::Radian*, const Ogre::Radian*, Ogre::Radian&, const Ogre::Radian& 
-"   delete $1;"
-
-%typemap(out) Ogre::Radian, const Ogre::Radian {
-     $result = rb_float_new($1.valueDegrees());
-}
-%typemap(out) Ogre::Radian&, const Ogre::Radian& {
-     $result = rb_float_new($1->valueDegrees());
-}
-
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+/* Radian / Degree all Ruby Values are interpreted as DEGREE! */
+%typemap(typecheck) Ogre::Radian, const Ogre::Radian& = double;
+
+%typemap(in) Ogre::Radian, const Ogre::Radian, Ogre::Radian&, const Ogre::Radian& 
+%{
+    if (TYPE($input) == T_FLOAT) {
+		$1 = Ogre::Degree(RFLOAT($input)->value);
+    } else if (TYPE($input) == T_FIXNUM) {
+		$1 = Ogre::Degree(FIX2INT($input));
+    } else {
+        throw Swig::DirectorTypeMismatchException("float or fixnum expected");
+    }
+%}
+
+%typemap(in) Ogre::Radian*, const Ogre::Radian*, Ogre::Radian&, const Ogre::Radian&
+%{
+    if (TYPE($input) == T_FLOAT) {
+		$1 = new Ogre::Radian(Ogre::Degree(RFLOAT($input)->value));
+    } else if (TYPE($input) == T_FIXNUM) {
+		$1 = new Ogre::Radian(Ogre::Degree(FIX2INT($input)));
+    } else {
+        throw Swig::DirectorTypeMismatchException("float or fixnum expected");
+    }
+%}
+
+%typemap(freearg) Ogre::Radian*, const Ogre::Radian*, Ogre::Radian&, const Ogre::Radian& 
+    "delete $1;"
+
+%typemap(out) Ogre::Radian, const Ogre::Radian 
+    "$result = rb_float_new($1.valueDegrees());"
+
+%typemap(out) Ogre::Radian&, const Ogre::Radian& 
+    "$result = rb_float_new($1->valueDegrees());"
+
+
+

Modified: rl/branches/newton20/engine/script/swig/TypeOgreStringVector.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/TypeOgreStringVector.swig	2008-09-04 22:14:33 UTC (rev 4501)
+++ rl/branches/newton20/engine/script/swig/TypeOgreStringVector.swig	2008-09-06 21:08:59 UTC (rev 4502)
@@ -14,62 +14,89 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
-%typemap(freearg) Ogre::StringVector &, const Ogre::StringVector & {
-  delete $1;
-}
-
-%typemap(out) Ogre::StringVector, const Ogre::StringVector {
-  VALUE arr = rb_ary_new2($1.size()); 
-  StringVector::iterator i = $1.begin(), iend = $1.end();
-  for ( ; i!=iend; i++ )
-    rb_ary_push(arr, rb_str_new2(*i));
-  $result = arr;
-}
-
-%typemap(in) Ogre::StringVector , const Ogre::StringVector {
-  Check_Type($input, T_ARRAY);
-  Ogre::StringVector vec;
-  int len = RARRAY($input)->len;
-  for (int i=0; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
+%{
+void convertRubyToOgreStringVector(VALUE input, Ogre::StringVector& vec)
+{
+  Check_Type(input, T_ARRAY);
+  int len = RARRAY(input)->len;
+  for (int i=0; i!=len; i++) 
+  {
+    VALUE inst = rb_ary_entry(input, i);
     vec.push_back(Ogre::String(StringValuePtr(inst)));
   }
-  $1 = vec;
 }
 
-%typemap(directorin) Ogre::StringVector &, const Ogre::StringVector & {
-  VALUE arr = rb_ary_new2($1->size()); 
-  StringVector::iterator i = $1->begin(), iend = $1->end();
-  for ( ; i!=iend; i++ )
-    rb_ary_push(arr, rb_str_new2(&(*i)));
-  $result = arr;
+VALUE convertOgreStringVectorToRuby(const Ogre::StringVector& vec)
+{
+  VALUE arr = rb_ary_new2(vec.size()); 
+  for (Ogre::StringVector::const_iterator i = vec.begin(), iend = vec.end() ; i!=iend; i++ )
+  {
+    rb_ary_push(arr, rb_str_new2(i->c_str()));
+  }
+  return arr;
 }
-%typemap(directorin) Ogre::StringVector, const Ogre::StringVector {
-  VALUE arr = rb_ary_new2($1.size()); 
-  StringVector::iterator i = $1.begin(), iend = $1.end();
-  for ( ; i!=iend; i++ )
-    rb_ary_push(arr, rb_str_new2(*i));
-  $result = arr;
-}
 
-%typemap(directorout) Ogre::StringVector , const Ogre::StringVector {
-  Check_Type($input, T_ARRAY);
-  Ogre::StringVector vec;
-  int len = RARRAY($input)->len;
-  for (int i=0; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
-    vec.push_back(Ogre::String(StringValuePtr(inst)));
-  }
-  $result = vec;
+static int checkRubyOgreStringVector( VALUE input ) 
+{
+	bool correct = false;
+
+	if (TYPE(input) == T_ARRAY)
+	{
+        correct = true;
+	}
+	
+    return (correct ? 1 : 0);
 }
 
-%typemap(directorout) Ogre::StringVector *, const Ogre::StringVector* , Ogre::StringVector &, const Ogre::StringVector& {
-  Check_Type($input, T_ARRAY);
-  Ogre::StringVector *vec = new Ogre::StringVector;
-  int len = RARRAY($input)->len;
-  for (int i=0; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
-    vec->push_back(Ogre::String(StringValuePtr(inst)));
-  }
-  $result = vec;
-}
+%}
+
+
+%typemap(typecheck)  
+   Ogre::StringVector, const Ogre::StringVector, 
+   Ogre::StringVector*, Ogre::StringVector&,
+   const Ogre::StringVector*, const Ogre::StringVector& 
+%{
+	$1 = checkRubyOgreStringVector($input);	
+%}
+
+%typemap(freearg) Ogre::StringVector &, const Ogre::StringVector & 
+    "delete $1;"
+
+%typemap(out) Ogre::StringVector, const Ogre::StringVector 
+%{
+  $result = convertOgreStringVectorToRuby($1); 
+%}
+%typemap(out) Ogre::StringVector&, const Ogre::StringVector&, Ogre::StringVector*, const Ogre::StringVector* 
+%{
+  $result = convertOgreStringVectorToRuby(*$1); 
+%}
+
+%typemap(in) Ogre::StringVector , const Ogre::StringVector 
+%{
+  convertRubyToOgreStringVector($input, $1);
+%}
+%typemap(in) Ogre::StringVector&, const Ogre::StringVector&, Ogre::StringVector*, const Ogre::StringVector*
+%{
+    $result = new Ogre::StringVector();
+    convertRubyToOgreStringVector($input, *$1);
+%}
+
+%typemap(directorin) Ogre::StringVector &, const Ogre::StringVector &
+%{
+  $result = convertOgreStringVectorToRuby(*$1); 
+%}
+%typemap(directorin) Ogre::StringVector, const Ogre::StringVector 
+%{
+  $result = convertOgreStringVectorToRuby($1);
+%}
+
+%typemap(directorout) Ogre::StringVector , const Ogre::StringVector 
+%{
+  convertRubyToOgreStringVector($input, $result);
+%}
+
+%typemap(directorout) Ogre::StringVector *, const Ogre::StringVector* , Ogre::StringVector &, const Ogre::StringVector& 
+%{
+  $result = new Ogre::StringVector();
+  convertRubyToOgreStringVector($input, *$result);
+%}

Modified: rl/branches/newton20/engine/script/swig/TypeOgreVector3.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/TypeOgreVector3.swig	2008-09-04 22:14:33 UTC (rev 4501)
+++ rl/branches/newton20/engine/script/swig/TypeOgreVector3.swig	2008-09-06 21:08:59 UTC (rev 4502)
@@ -62,19 +62,16 @@
 %}
 
 %typemap(in) Ogre::Vector3, const Ogre::Vector3
-{
-   Ogre::Vector3 vec(0.0, 0.0, 0.0);
-   convertRubyToVector3( $input, & vec );
-   $1 = vec;
-}
+%{
+   convertRubyToVector3( $input, & $1 );
+%}
 
 %typemap(in) Ogre::Vector3*, Ogre::Vector3&,
    const Ogre::Vector3*, const Ogre::Vector3&
-{
-   Ogre::Vector3* vec = new Ogre::Vector3(0.0, 0.0, 0.0);
-   convertRubyToVector3(  $input, vec );
-   $1 = vec;
-}
+%{
+   $1 = new Ogre::Vector3(0.0, 0.0, 0.0);
+   convertRubyToVector3(  $input, $1 );
+%}
 
 %{
 // Helper method for creating the ruby Array

Modified: rl/branches/newton20/engine/script/swig/TypeRlCeGuiString.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/TypeRlCeGuiString.swig	2008-09-04 22:14:33 UTC (rev 4501)
+++ rl/branches/newton20/engine/script/swig/TypeRlCeGuiString.swig	2008-09-06 21:08:59 UTC (rev 4502)
@@ -32,9 +32,10 @@
     "Check_Type($input, T_STRING);
     $1 = new rl::CeGuiString(
 		reinterpret_cast<CEGUI::utf8*>(StringValuePtr($input)));"
-%typemap(freearg) rl::CeGuiString*, rl::CeGuiString&, const rl::CeGuiString*, const rl::CeGuiString&  {
-   delete $1;
-}
+
+%typemap(freearg) rl::CeGuiString*, rl::CeGuiString&, const rl::CeGuiString*, const rl::CeGuiString&
+   "delete $1;"
+
 %typemap(out) rl::CeGuiString*, rl::CeGuiString&,  const rl::CeGuiString*, const rl::CeGuiString& 
      "$result = rb_str_buf_new2($1->c_str());"
 
@@ -48,10 +49,8 @@
 	"$input = rb_str_buf_new2($1->c_str());"
 
 %typemap(directorout) rl::CeGuiString, const rl::CeGuiString 
-    "$result = rl::CeGuiString(
-		reinterpret_cast<CEGUI::utf8*>(StringValuePtr($input)));"
+    "$result = rl::CeGuiString(reinterpret_cast<CEGUI::utf8*>(StringValuePtr($input)));"
 
 %typemap(directorout) const rl::CeGuiString &, rl::CeGuiString&  
     "$result = new rl::CeGuiString();
-     $result->append( 
-		reinterpret_cast<CEGUI::utf8*>(StringValuePtr($input)) );"
+     $result->append(reinterpret_cast<CEGUI::utf8*>(StringValuePtr($input)));"

Modified: rl/branches/newton20/engine/script/swig/TypeRlCeGuiStringVector.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/TypeRlCeGuiStringVector.swig	2008-09-04 22:14:33 UTC (rev 4501)
+++ rl/branches/newton20/engine/script/swig/TypeRlCeGuiStringVector.swig	2008-09-06 21:08:59 UTC (rev 4502)
@@ -14,44 +14,50 @@
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
  */
 
+%{
+void convertRubyToCeGuiStringVector(VALUE input, rl::CeGuiStringVector& vec)
+{
+  Check_Type(input, T_ARRAY);
+  int len = RARRAY(input)->len;
+  for (int i=0; i!=len; i++) 
+  {
+    VALUE inst = rb_ary_entry(input, i);
+    vec.push_back(rl::CeGuiString(StringValuePtr(inst)));
+  }
+}
+
+VALUE convertCeGuiStringVectorToRuby(const rl::CeGuiStringVector& input)
+{
+  VALUE arr = rb_ary_new2(input.size()); 
+  for (rl::CeGuiStringVector::const_iterator i = input.begin(), iend = input.end() ; i!=iend; i++ )
+  {
+    rb_ary_push(arr, rb_str_new2(i->c_str()));
+  }
+  return arr;
+}
+%}
+
 %typemap(freearg) rl::CeGuiStringVector &, const rl::CeGuiStringVector & 
 "  delete $1;"
 
 
-%typemap(directorin) rl::CeGuiStringVector &, const rl::CeGuiStringVector & {
-  VALUE arr = rb_ary_new2($1->size()); 
-  rl::CeGuiStringVector::iterator i = $1->begin(), iend = $1->end();
-  for ( ; i!=iend; i++ )
-    rb_ary_push(arr, rb_str_new2(&(*i)));
-  $result = arr;
-}
+%typemap(directorin) rl::CeGuiStringVector &, const rl::CeGuiStringVector & 
+%{
+  $result = convertCeGuiStringVectorToRuby(*$1); 
+%}
 
-%typemap(directorin) rl::CeGuiStringVector, const rl::CeGuiStringVector {
-  VALUE arr = rb_ary_new2($1.size()); 
-  rl::CeGuiStringVector::iterator i = $1.begin(), iend = $1.end();
-  for ( ; i!=iend; i++ )
-    rb_ary_push(arr, rb_str_new2(*i));
-  $result = arr;
-}
+%typemap(directorin) rl::CeGuiStringVector, const rl::CeGuiStringVector
+%{
+  $result = convertCeGuiStringVectorToRuby($1); 
+%}
 
-%typemap(directorout) rl::CeGuiStringVector , const rl::CeGuiStringVector {
-  Check_Type($input, T_ARRAY);
-  rl::CeGuiStringVector vec;
-  int len = RARRAY($input)->len;
-  for (int i=0; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
-    vec.push_back(rl::CeGuiString(StringValuePtr(inst)));
-  }
-  $result = vec;
-}
+%typemap(directorout) rl::CeGuiStringVector , const rl::CeGuiStringVector
+%{
+  convertRubyToCeGuiStringVector($input, $result);
+%}
 
-%typemap(directorout) rl::CeGuiStringVector &, const rl::CeGuiStringVector& {
-  Check_Type($input, T_ARRAY);
-  rl::CeGuiStringVector *vec = new rl::CeGuiStringVector;
-  int len = RARRAY($input)->len;
-  for (int i=0; i!=len; i++) {
-    VALUE inst = rb_ary_entry($input, i);
-    vec->push_back(rl::CeGuiString(StringValuePtr(inst)));
-  }
-  $result = vec;
-}
+%typemap(directorout) rl::CeGuiStringVector &, const rl::CeGuiStringVector& 
+%{
+  $result = new rl::CeGuiStringVector();
+  convertRubyToCeGuiStringVector($input, * $result);
+%}

Modified: rl/branches/newton20/engine/script/swig/TypeRlProperty.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/TypeRlProperty.swig	2008-09-04 22:14:33 UTC (rev 4501)
+++ rl/branches/newton20/engine/script/swig/TypeRlProperty.swig	2008-09-06 21:08:59 UTC (rev 4502)
@@ -213,7 +213,7 @@
 
 
 %typemap(typecheck) rl::Property, const rl::Property, rl::Property&, const rl::Property&, rl::Property*, const rl::Property* 
-{
+"
     if (TYPE($input) == T_FLOAT 
         || TYPE($input) == T_FIXNUM 
 	    || TYPE($input) == T_STRING
@@ -226,7 +226,7 @@
     }
     
     return 0;
-}
+"
 
 %typemap(in) rl::Property, const rl::Property
 "   
@@ -249,9 +249,7 @@
 "   delete $1;"
 
 %typemap(directorout) rl::Property, const rl::Property, rl::Property&, const rl::Property&
-"   
-	$result = rl::convertValueToProperty($1);
-"
+"   $result = rl::convertValueToProperty($1);"
 
 %typemap(directorout) rl::Property*, const rl::Property*
 "   

Modified: rl/branches/newton20/engine/script/swig/TypeRlPropertyKeys.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/TypeRlPropertyKeys.swig	2008-09-04 22:14:33 UTC (rev 4501)
+++ rl/branches/newton20/engine/script/swig/TypeRlPropertyKeys.swig	2008-09-06 21:08:59 UTC (rev 4502)
@@ -50,14 +50,14 @@
 
 
 %typemap(typecheck) rl::PropertyKeys, const rl::PropertyKeys 
-{
+"
     if (TYPE($input) == T_ARRAY) 
     {
         return 1;
     }
     
     return 0;
-}
+"
 
 %typemap(in) rl::PropertyKeys, const rl::PropertyKeys
 "   

Modified: rl/branches/newton20/engine/script/swig/TypeStdPairIntInt.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/TypeStdPairIntInt.swig	2008-09-04 22:14:33 UTC (rev 4501)
+++ rl/branches/newton20/engine/script/swig/TypeStdPairIntInt.swig	2008-09-06 21:08:59 UTC (rev 4502)
@@ -18,46 +18,38 @@
 	std::pair<int,int>*, std::pair<int,int>&, 
 	const std::pair<int,int>*, const std::pair<int,int>&, 
 	std::pair<int,int>, const std::pair<int,int>
-{
-   $1 = TYPE($input) == T_ARRAY && RARRAY($input)->len == 2 ? 1 : 0;
-}
+"   $1 = TYPE($input) == T_ARRAY && RARRAY($input)->len == 2 ? 1 : 0; "
 
 
 %typemap(in) std::pair<int,int>*, std::pair<int,int>&,
    const std::pair<int,int>*, const std::pair<int,int>&
-{
-	std::pair<int, int>* val = new std::pair<int, int>();
-	val->first = NUM2INT(rb_ary_entry($input, 0)), 
-	val->second = NUM2INT(rb_ary_entry($input, 1));
-	
-	$1 = val;
-}
+"
+	$1 = new std::pair<int, int>();
+	$1->first = NUM2INT(rb_ary_entry($input, 0)), 
+	$1->second = NUM2INT(rb_ary_entry($input, 1));
+"
+
 %typemap(freearg) std::pair<int,int>*, std::pair<int,int>&, 
-const std::pair<int,int>*, const std::pair<int,int>&  {
-   delete $1;
-}
+const std::pair<int,int>*, const std::pair<int,int>&
+   "delete $1;"
 
 %typemap(in) std::pair<int,int>, const std::pair<int,int>
-{
+"
 	$1.first = NUM2INT(rb_ary_entry($input, 0)), 
 	$1.second = NUM2INT(rb_ary_entry($input, 1));
-}
+"
 
 %typemap(out) std::pair<int,int>, const std::pair<int,int>
-{
-	VALUE array = rb_ary_new();
-	rb_ary_push(array, rb_int_new($1.first));
-	rb_ary_push(array, rb_int_new($1.second));
-	$result = array;
-}
+"
+	$result = rb_ary_new();
+	rb_ary_push($result, rb_int_new($1.first));
+	rb_ary_push($result, rb_int_new($1.second));
+"
 
 %typemap(out) std::pair<int,int>*, std::pair<int,int>&,
    const std::pair<int,int>*, const std::pair<int,int>&
-{
-	VALUE array = rb_ary_new();
-	rb_ary_push(array, rb_int_new($1->first));
-	rb_ary_push(array, rb_int_new($1->second));
-	$result = array;
-}
-
-
+"
+	$result = rb_ary_new();
+	rb_ary_push($result, rb_int_new($1->first));
+	rb_ary_push($result, rb_int_new($1->second));
+"
\ No newline at end of file



From blakharaz at mail.berlios.de  Mon Sep  8 22:17:21 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 8 Sep 2008 22:17:21 +0200
Subject: [Dsa-hl-svn] r4503 - rl/trunk/engine/core/src
Message-ID: <200809082017.m88KHLT7007998@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-08 22:17:17 +0200 (Mon, 08 Sep 2008)
New Revision: 4503

Modified:
   rl/trunk/engine/core/src/ConfigurationManager.cpp
Log:
modules.conf path for Mac OS

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-09-06 21:08:59 UTC (rev 4502)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-09-08 20:17:17 UTC (rev 4503)
@@ -265,6 +265,8 @@
         {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
             mModulesRootDirectory = RL_MODULEDIR;
+#           elsif OGRE_PLATFORM == OGRE_PLATFORM_APPLE
+            mModulesRootDirectory = mExecutablePath + "/../Resources/modules";
 #           else
             mModulesRootDirectory = "./modules";
 #           endif
@@ -436,7 +438,8 @@
 
     bool ConfigurationManager::checkForFile(const Ogre::String& filename)
     {
-        try {
+        try 
+        {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
 			std::cout << "Checking for " << fs::complete(filename);
             if (fs::exists(filename))
@@ -449,7 +452,8 @@
                 return true;
             }
         }
-        catch (fs::filesystem_error&) {
+        catch (fs::filesystem_error&) 
+        {
             return false;
         }
 



From blakharaz at mail.berlios.de  Mon Sep  8 22:17:32 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 8 Sep 2008 22:17:32 +0200
Subject: [Dsa-hl-svn] r4504 - rl/trunk/Mac/Rastullah.xcodeproj
Message-ID: <200809082017.m88KHWqT008018@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-08 22:17:30 +0200 (Mon, 08 Sep 2008)
New Revision: 4504

Modified:
   rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
Log:
modules.conf path for Mac OS

Modified: rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-08 20:17:17 UTC (rev 4503)
+++ rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-08 20:17:30 UTC (rev 4504)
@@ -884,7 +884,7 @@
 		440785E20C09D2C1006E496D /* LightFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LightFadeJob.cpp; path = ../engine/core/src/LightFadeJob.cpp; sourceTree = SOURCE_ROOT; };
 		440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MergeableMeshObject.cpp; path = ../engine/core/src/MergeableMeshObject.cpp; sourceTree = SOURCE_ROOT; };
 		440785E60C09D2DF006E496D /* MergeableMeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MergeableMeshObject.h; path = ../engine/core/include/MergeableMeshObject.h; sourceTree = SOURCE_ROOT; };
-		440786120C09D602006E496D /* RlScript-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = "RlScript-Info.plist"; sourceTree = "<group>"; };
+		440786120C09D602006E496D /* RlScript-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = "RlScript-Info.plist"; sourceTree = "<group>"; };
 		44125A2F0C083D0100C24C0A /* CreatureWalkPathJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CreatureWalkPathJob.cpp; path = ../engine/ai/src/CreatureWalkPathJob.cpp; sourceTree = SOURCE_ROOT; };
 		44125A310C083D1100C24C0A /* CreatureWalkPathJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CreatureWalkPathJob.h; path = ../engine/ai/include/CreatureWalkPathJob.h; sourceTree = SOURCE_ROOT; };
 		444825D90BF7B2B200C5A94F /* AbstractMapNodeProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AbstractMapNodeProcessor.cpp; path = ../engine/script/src/AbstractMapNodeProcessor.cpp; sourceTree = SOURCE_ROOT; };
@@ -1687,8 +1687,6 @@
 		20286C29FDCF999611CA2CEA /* Rastullah */ = {
 			isa = PBXGroup;
 			children = (
-				48C04B890E67DF0300CD3A7D /* PCRE.framework */,
-				48B0B0480E65BBB30023B198 /* libfmodex.dylib */,
 				20286C2AFDCF999611CA2CEA /* Sources */,
 				20286C2CFDCF999611CA2CEA /* Resources */,
 				20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */,
@@ -1701,10 +1699,10 @@
 			isa = PBXGroup;
 			children = (
 				48CFBFD60E2E87A800CD0C51 /* Scripts */,
-				483D86890D8C3DA200F3629E /* RlFmod4Driver */,
 				444EAC220BD0E3E000C6D4A0 /* RlAi */,
 				444EAB1F0BD0E25C00C6D4A0 /* RlCommon */,
 				444EAB200BD0E27400C6D4A0 /* RlCore */,
+				483D86890D8C3DA200F3629E /* RlFmod4Driver */,
 				444EAC590BD0E50600C6D4A0 /* RlRules */,
 				444EAE600BD0E66500C6D4A0 /* RlScript */,
 				444EAC570BD0E4CD00C6D4A0 /* RlUi */,
@@ -1728,6 +1726,8 @@
 		20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */ = {
 			isa = PBXGroup;
 			children = (
+				48C04B890E67DF0300CD3A7D /* PCRE.framework */,
+				48B0B0480E65BBB30023B198 /* libfmodex.dylib */,
 				48CFBF8E0E2E869000CD0C51 /* FreeType.framework */,
 				484FE6B90E17BC8800FA880F /* Carbon.framework */,
 				48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */,



From timm at mail.berlios.de  Sun Sep 14 22:36:49 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 14 Sep 2008 22:36:49 +0200
Subject: [Dsa-hl-svn] r4505 - rl/trunk/engine/script/src
Message-ID: <200809142036.m8EKanq4006604@sheep.berlios.de>

Author: timm
Date: 2008-09-14 22:36:42 +0200 (Sun, 14 Sep 2008)
New Revision: 4505

Modified:
   rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
Log:
tried to fix refraction of water plane, but doesn't work :(

Modified: rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2008-09-08 20:17:30 UTC (rev 4504)
+++ rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2008-09-14 20:36:42 UTC (rev 4505)
@@ -172,9 +172,9 @@
 		Camera* cam = CoreSubsystem::getSingleton().getWorld()->getSceneManager()->createCamera("Cam" + entity->getName());
 		cam->setNearClipDistance(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getNearClipDistance());
         cam->setFarClipDistance(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getFarClipDistance());
-		cam->setAutoAspectRatio(true);
+		//cam->setFarClipDistance(1000000);
+		cam->setAspectRatio(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getAspectRatio());
 		cam->setFOVy(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getFOVy());
-		cam->enableCustomNearClipPlane((MovablePlane*)plane);
 
 		AliasTextureNamePairList aliases;
 
@@ -190,6 +190,8 @@
 			rttTex->addListener(new PlaneReflectionTextureListener(entity, cam, plane));
 			
 			aliases["reflection"] = "Reflection" + entity->getName();
+
+			cam->enableCustomNearClipPlane((MovablePlane*)plane);
 		}
 		if(getAttributeValueAsBool(rttElem, "refraction"))
 		{
@@ -203,6 +205,9 @@
 			rttTex->addListener(new PlaneRefractionTextureListener(entity, cam));
 
 			aliases["refraction"] = "Refraction" + entity->getName();
+
+			plane->normal = Vector3::NEGATIVE_UNIT_Y;
+			cam->enableCustomNearClipPlane((MovablePlane*)plane);
 		}
 		if(!material->applyTextureAliases(aliases))
 			LOG_ERROR("PLANE", "Texture Aliase konnten nicht angewandt werden");
@@ -220,7 +225,7 @@
 		mCamera->setPosition(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getWorldPosition());
 		mCamera->setOrientation(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getWorldOrientation());
 		mEntity->setVisible(false);
-		mCamera->enableReflection(*mPlane);
+		mCamera->enableReflection((MovablePlane*)mPlane);
 	}
 
 	void PlaneReflectionTextureListener::postRenderTargetUpdate(const Ogre::RenderTargetEvent& evt)



From timm at mail.berlios.de  Sun Sep 14 22:37:48 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 14 Sep 2008 22:37:48 +0200
Subject: [Dsa-hl-svn] r4506 - in rl/trunk/engine: core/include core/src
	rules/include rules/src ui/src
Message-ID: <200809142037.m8EKbmsd006808@sheep.berlios.de>

Author: timm
Date: 2008-09-14 22:37:40 +0200 (Sun, 14 Sep 2008)
New Revision: 4506

Modified:
   rl/trunk/engine/core/include/SaveAble.h
   rl/trunk/engine/core/src/SaveAble.cpp
   rl/trunk/engine/rules/include/GameObjectManager.h
   rl/trunk/engine/rules/src/GameObjectManager.cpp
   rl/trunk/engine/ui/src/GameSaveLoadWindow.cpp
   rl/trunk/engine/ui/src/MainMenuLoadWindow.cpp
Log:
- started with new save game system
- removed parts from the old one

Modified: rl/trunk/engine/core/include/SaveAble.h
===================================================================
--- rl/trunk/engine/core/include/SaveAble.h	2008-09-14 20:36:42 UTC (rev 4505)
+++ rl/trunk/engine/core/include/SaveAble.h	2008-09-14 20:37:40 UTC (rev 4506)
@@ -12,4 +12,30 @@
  *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
\ No newline at end of file
+ */
+
+
+/// Basis jedes Objektes im Spiel, welches ver?nderlich ist und einen abspeicherbaren Status haben soll
+
+#ifndef __SaveAble_H__
+#define __SaveAble_H__
+
+#include "CorePrerequisites.h"
+#include "Properties.h"
+
+namespace rl
+{
+
+	class SaveAble : public PropertyHolder
+	{
+	public:
+		void setSaveAble(bool enable);
+		bool isSaveAble();
+	protected:
+		bool mIsSaveAble;
+	};
+
+}
+
+
+#endif
\ No newline at end of file

Modified: rl/trunk/engine/core/src/SaveAble.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveAble.cpp	2008-09-14 20:36:42 UTC (rev 4505)
+++ rl/trunk/engine/core/src/SaveAble.cpp	2008-09-14 20:37:40 UTC (rev 4506)
@@ -21,11 +21,15 @@
 #include "Property.h"
 #include "Properties.h"
 
-class SaveAble
+namespace rl
 {
-public:
-    void setSaveAble(bool enable);
-    bool isSaveAble();
-protected:
-    bool mIsSaveAble;
-};
\ No newline at end of file
+	void SaveAble::setSaveAble(bool enable)
+	{
+		mIsSaveAble = true;
+	}
+
+	bool SaveAble::isSaveAble()
+	{
+		return mIsSaveAble;
+	}
+}
\ No newline at end of file

Modified: rl/trunk/engine/rules/include/GameObjectManager.h
===================================================================
--- rl/trunk/engine/rules/include/GameObjectManager.h	2008-09-14 20:36:42 UTC (rev 4505)
+++ rl/trunk/engine/rules/include/GameObjectManager.h	2008-09-14 20:37:40 UTC (rev 4506)
@@ -42,8 +42,7 @@
     class _RlRulesExport GameObjectManager : 
         public Ogre::Singleton<GameObjectManager>,
         public GameObjectStateListener,
-        public Ogre::ScriptLoader,
-        public SaveGameData
+        public Ogre::ScriptLoader
     {
     public:
         GameObjectManager();
@@ -74,14 +73,6 @@
         void registerGameObjectStateListener(GameObjectStateListener* listener);
         void unregisterGameObjectStateListener(GameObjectStateListener* listener);
         void unregisterAllGameObjectStateListener();
-
-        /// Override from SaveGameData
-        /// Manages saving and loading from the SaveGameFile
-
-        virtual CeGuiString getXmlNodeIdentifier() const;
-        virtual void writeData(SaveGameFileWriter* writer);
-        virtual void readData(SaveGameFileReader* reader);
-        virtual int getPriority() const;
     private:
         typedef std::map<const CeGuiString, PropertyRecordPtr> ClassPropertyMap;
         typedef std::set<GameObjectStateListener*> GameObjectStateListenerSet;

Modified: rl/trunk/engine/rules/src/GameObjectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObjectManager.cpp	2008-09-14 20:36:42 UTC (rev 4505)
+++ rl/trunk/engine/rules/src/GameObjectManager.cpp	2008-09-14 20:37:40 UTC (rev 4506)
@@ -47,12 +47,10 @@
 
         mScriptPatterns.push_back("*.gof");
         Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
-        SaveGameManager::getSingleton().registerSaveGameData(this);
     }
 
     GameObjectManager::~GameObjectManager()
     {
-        SaveGameManager::getSingleton().unregisterSaveGameData(this);
         unregisterAllGameObjectStateListener();
         deleteAllGameObjects();
     }
@@ -293,90 +291,6 @@
         return createRubyGameObject(classname, id);
     }
 
-    CeGuiString GameObjectManager::getXmlNodeIdentifier() const
-    {
-        return "gameobjects";
-    }
-
-    using namespace XERCES_CPP_NAMESPACE;
-    
-    void GameObjectManager::writeData(SaveGameFileWriter *writer)
-    {
-        LOG_MESSAGE(Logger::RULES, "Saving Game Objects");
-        DOMElement* gameobjects = writer->appendChildElement(writer->getDocument(), writer->getDocument()->getDocumentElement(), getXmlNodeIdentifier().c_str());
-
-        std::list<GameObject*> gos = getAllGameObjects();
-
-		for(std::list<GameObject*>::const_iterator it_gameobjects = gos.begin(); it_gameobjects != gos.end(); it_gameobjects++)
-        {
-            DOMElement* gameobject = writer->appendChildElement(writer->getDocument(), gameobjects, "gameobject");
-            writer->setAttributeValueAsInteger(gameobject, "ID", (*it_gameobjects)->getId());
-            writer->setAttributeValueAsString(gameobject, "ClassID", (*it_gameobjects)->getClassId());
-            writer->setAttributeValueAsInteger(gameobject, "State", (int)(*it_gameobjects)->getState());
-            writer->setAttributeValueAsInteger(gameobject, "QueryFlags", (int)(*it_gameobjects)->getQueryFlags());
-
-            PropertyMap actualMap = (*it_gameobjects)->getAllProperties()->toPropertyMap();
-
-            writer->writeEachPropertyToElem(gameobject, (*it_gameobjects)->getAllProperties()->getDifference(getClassProperties((*it_gameobjects)->getClassId()))->toPropertyMap());
-            //writer->writeEachPropertyToElem(gameobject, getPropertyMapDifference(actualMap, getClassProperties((*it_gameobjects)->getClassId())->toPropertyMap()));
-        } 
-    }
-
-    void GameObjectManager::readData(SaveGameFileReader *reader)
-    {
-        deleteAllGameObjects();
-
-        reader->initializeXml();
-
-        DOMNodeList* rootNodeList = reader->getDocument()->getDocumentElement()->getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
-
-        if(rootNodeList->getLength())
-        {
-            DOMNodeList* xmlGameObjects = static_cast<DOMElement*>(rootNodeList->item(0))->getElementsByTagName(AutoXMLCh("gameobject").data()); //there should be only one "gameobjects" node
-            if(xmlGameObjects->getLength())
-            {
-                for(XMLSize_t childIdx = 0; childIdx < xmlGameObjects->getLength(); childIdx++)
-                {
-                    DOMNode* xmlGameObject = xmlGameObjects->item(childIdx);
-                    if(xmlGameObject->getNodeType() == DOMNode::ELEMENT_NODE)
-                    {
-                        int ID = reader->getAttributeValueAsInteger(static_cast<DOMElement*>(xmlGameObject), "ID");
-                        Ogre::String classID = reader->getAttributeValueAsStdString(static_cast<DOMElement*>(xmlGameObject), "ClassID");
-                        GameObjectState state = (GameObjectState)reader->getAttributeValueAsInteger(static_cast<DOMElement*>(xmlGameObject), "State");
-                        int flags = reader->getAttributeValueAsInteger(static_cast<DOMElement*>(xmlGameObject), "QueryFlags");
-                        PropertyRecordPtr properties = reader->getPropertiesAsRecord(static_cast<DOMElement*>(xmlGameObject));
-
-                        GameObject* object = NULL;
-                        if(getGameObject(ID) == NULL)
-                            object = createGameObject(classID, ID);
-                        else
-                            object = getGameObject(ID);
-                        
-                        applyProperties(object, properties);
-                        // Placing the actor a a little bit higher in the scene. The actor will fall onto ground.
-                        // Avoiding problems with the physics, because the character the creature is transfixed to ground
-                        if(state == GOS_IN_SCENE)
-                        {
-                            object->setProperty(GameObject::PROPERTY_POSITION, 
-	                            Property(object->getProperty(GameObject::PROPERTY_POSITION).toVector3() + Ogre::Vector3(0.0f,0.01f,0.0f)));
-                        }
-                        object->setState(state);
-                        object->setQueryFlags(flags);
-                    }
-                }
-            }
-        } 
-
-        MessagePump::getSingleton().sendMessage<MessageType_GameObjectsLoaded>();
-
-        reader->shutdownXml();
-    }
-
-    int GameObjectManager::getPriority() const
-    {
-        return 100;
-    }
-
     PropertyMap GameObjectManager::getPropertyMapDifference(PropertyMap map1, PropertyMap map2)
     {
         PropertyRecord pr;

Modified: rl/trunk/engine/ui/src/GameSaveLoadWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameSaveLoadWindow.cpp	2008-09-14 20:36:42 UTC (rev 4505)
+++ rl/trunk/engine/ui/src/GameSaveLoadWindow.cpp	2008-09-14 20:37:40 UTC (rev 4506)
@@ -106,7 +106,6 @@
     {
         //mSaveGameTable->autoSizeColumnHeader(0);
         //mSaveGameTable->autoSizeColumnHeader(1);
-        listSaveGames();
     }
 
     //------------------------------------------------------- LoadEvent
@@ -123,13 +122,6 @@
         if(filename != "")
         {
 
-            if(SaveGameManager::getSingleton().SaveGameFileExists(filename, CoreSubsystem::getSingleton().getActiveAdventureModule()->getId()))
-                SaveGameManager::getSingleton().loadSaveGameFile(filename, CoreSubsystem::getSingleton().getActiveAdventureModule()->getId());
-            else
-            {
-                LOG_ERROR(Logger::UI, "Save Game " + filename + " doesn't exist!");
-                WindowFactory::getSingleton().showMessageWindow("Der Spielstand existiert nicht");
-            }
         }*/
 
         return true;
@@ -145,18 +137,13 @@
 
         if(filename != "")
         {
-            LOG_MESSAGE(Logger::UI, "Create a SaveGameFile");
 
-            SaveGameManager::getSingleton().saveSaveGameFile(filename);
-
-            LOG_MESSAGE(Logger::UI, "Created save game");
         }
         else
         {
             WindowFactory::getSingleton().showMessageWindow("Bitte einen Namen f?r den Spielstand eingeben");
         }
 
-        listSaveGames();
 
         return true;
     }
@@ -166,35 +153,12 @@
     bool GameSaveLoadWindow::handleDeleteEvent()
     {
         LOG_MESSAGE(Logger::UI, "Delete Button pressed");
-        if(SaveGameManager::getSingleton().SaveGameFileExists(mFilename->getText(), CoreSubsystem::getSingleton().getActiveAdventureModule()->getId()))
-        {
-            SaveGameManager::getSingleton().deleteSaveGameFile(mFilename->getText(), CoreSubsystem::getSingleton().getActiveAdventureModule()->getId());
-            listSaveGames();
-        }
+
         return true;
     }
 
     void GameSaveLoadWindow::listSaveGames()
     {
-        SaveGameEntryMap saveGames = SaveGameManager::getSingleton().listSaveGames(CoreSubsystem::getSingleton().getActiveAdventureModule()->getId());
-    
-        while(mSaveGameTable->getRowCount() > saveGames.size())
-		    mSaveGameTable->removeRow(mSaveGameTable->getRowCount()-1);
-        while(mSaveGameTable->getRowCount() < saveGames.size())
-		    mSaveGameTable->addRow();
-        
-        int saveGameNum = 0;
-
-        for(SaveGameEntryMap::iterator it = saveGames.begin(); it != saveGames.end(); it++)
-        {
-            ListboxTextItem* item = new CEGUI::ListboxTextItem(it->second->getName());
-            item->setSelectionBrushImage(mSelectionImageset, mSelectionBrush);
-            mSaveGameTable->setItem(item, 0, saveGameNum);
-            item = new CEGUI::ListboxTextItem(it->second->getProperty(SaveGameFile::PROPERTY_TIME));
-            item->setSelectionBrushImage(mSelectionImageset, mSelectionBrush);
-            mSaveGameTable->setItem(item, 1, saveGameNum);
-            saveGameNum++;
-        }
         //mSaveGameTable->autoSizeColumnHeader(0);
         //mSaveGameTable->autoSizeColumnHeader(1);
     }

Modified: rl/trunk/engine/ui/src/MainMenuLoadWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/MainMenuLoadWindow.cpp	2008-09-14 20:36:42 UTC (rev 4505)
+++ rl/trunk/engine/ui/src/MainMenuLoadWindow.cpp	2008-09-14 20:37:40 UTC (rev 4506)
@@ -114,7 +114,6 @@
 		//	module = CoreSubsystem::getSingleton().getModule(moduleId.c_str());
 		//	assert(module != NULL /*MainMenuLoadWindow::handleLoadEvent()*/);
 		//	CoreSubsystem::getSingleton().startAdventureModule(module);
-		//	SaveGameManager::getSingleton().loadSaveGameFile(((SaveGameFile*)mSaveGameTable->getFirstSelectedItem()->getUserData())->getId());
 		//}
 
         return true;
@@ -129,9 +128,6 @@
         if(mSaveGameTable->getFirstSelectedItem())
 		{
             mSaveGameTable->getRowWithID(mSaveGameTable->getFirstSelectedItem()->getID());
-            
-            SaveGameManager::getSingleton().deleteSaveGameFile(
-                ((SaveGameFile*)mSaveGameTable->getFirstSelectedItem()->getUserData())->getId());
         }
 
         return true;
@@ -140,31 +136,6 @@
     void MainMenuLoadWindow::listSaveGames()
     {
         mSaveGameTable->clearAllSelections();
-        SaveGameEntryMap saveGames = SaveGameManager::getSingleton().listSaveGames();
-
-        while(mSaveGameTable->getRowCount() > saveGames.size())
-		    mSaveGameTable->removeRow(mSaveGameTable->getRowCount()-1);
-        while(mSaveGameTable->getRowCount() < saveGames.size())
-		    mSaveGameTable->addRow();
-
-        int saveGameNum = 0;
-
-        for(SaveGameEntryMap::iterator it = saveGames.begin(); it != saveGames.end(); it++)
-        {
-            CEGUI::ListboxTextItem* item = new CEGUI::ListboxTextItem(it->second->getName());
-            item->setUserData(it->second);
-            item->setSelectionBrushImage(mSelectionImageset, mSelectionBrush);
-            mSaveGameTable->setItem(item, 0, saveGameNum);
-            item = new CEGUI::ListboxTextItem(it->second->getProperty(SaveGameFile::PROPERTY_MODULENAME).toString());
-            item->setUserData(it->second);
-            item->setSelectionBrushImage(mSelectionImageset, mSelectionBrush);
-            mSaveGameTable->setItem(item, 1, saveGameNum);
-            item = new CEGUI::ListboxTextItem(it->second->getProperty(SaveGameFile::PROPERTY_TIME).toString());
-            item->setUserData(it->second);
-            item->setSelectionBrushImage(mSelectionImageset, mSelectionBrush);
-            mSaveGameTable->setItem(item, 2, saveGameNum);
-            saveGameNum++;
-        }
         /*mSaveGameTable->autoSizeColumnHeader(0);
         mSaveGameTable->autoSizeColumnHeader(1);
         mSaveGameTable->autoSizeColumnHeader(2);*/



From blakharaz at mail.berlios.de  Mon Sep 15 08:14:04 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 15 Sep 2008 08:14:04 +0200
Subject: [Dsa-hl-svn] r4507 - in rl/trunk/engine: rules/include rules/src
	script/swig
Message-ID: <200809150614.m8F6E4g5023422@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-15 08:14:01 +0200 (Mon, 15 Sep 2008)
New Revision: 4507

Modified:
   rl/trunk/engine/rules/include/Effect.h
   rl/trunk/engine/rules/include/EffectManager.h
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/Effect.cpp
   rl/trunk/engine/rules/src/EffectManager.cpp
   rl/trunk/engine/script/swig/RlRules.swig
Log:
Save effects

Modified: rl/trunk/engine/rules/include/Effect.h
===================================================================
--- rl/trunk/engine/rules/include/Effect.h	2008-09-14 20:37:40 UTC (rev 4506)
+++ rl/trunk/engine/rules/include/Effect.h	2008-09-15 06:14:01 UTC (rev 4507)
@@ -80,13 +80,16 @@
             QUANTIFIER_UNIQUE_BUT_CUMULATIVE
         };
 
+        static const Ogre::String PROPERTY_NAME;
+        static const Ogre::String PROPERTY_STUFE;
 
+
         /// Setzt den Quantifier standardmaessig auf QUANTIFIER_MULTIPLE.
 		Effect(int stufe = 1);
         virtual ~Effect() {}
 
-        const CeGuiString getName() const;
-        void setName(CeGuiString name);
+        const Ogre::String getName() const;
+        void setName(Ogre::String name);
         const CeGuiString getDescription() const;
         void setDescription(CeGuiString description);
         /// @see Quantifier
@@ -131,7 +134,7 @@
         virtual void setProperty(const CeGuiString& key, const Property& value);
         virtual PropertyKeys getAllPropertyKeys() const;
 	protected:
-		CeGuiString mName;
+		Ogre::String mName;
 		CeGuiString mDescription;
 		/// Dauer desEffekts in Aktionen.
 		int mStufe;

Modified: rl/trunk/engine/rules/include/EffectManager.h
===================================================================
--- rl/trunk/engine/rules/include/EffectManager.h	2008-09-14 20:37:40 UTC (rev 4506)
+++ rl/trunk/engine/rules/include/EffectManager.h	2008-09-15 06:14:01 UTC (rev 4507)
@@ -36,7 +36,7 @@
      * should be called every Aktion (the dark eye time unit)
      **/
 
-	class _RlRulesExport EffectManager
+    class _RlRulesExport EffectManager : public PropertyHolder
 	{
 	public:
 		EffectManager(GameObject* gameobject);
@@ -98,6 +98,10 @@
 
         void checkStateChange(Effect::LifeState oldState);
 
+        virtual const Property getProperty(const CeGuiString& key) const;
+        virtual void setProperty(const CeGuiString& key, const Property& value);
+        virtual PropertyKeys getAllPropertyKeys() const;
+
 	private:
 
         GameObject* mGameObject;

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2008-09-14 20:37:40 UTC (rev 4506)
+++ rl/trunk/engine/rules/src/Creature.cpp	2008-09-15 06:14:01 UTC (rev 4507)
@@ -1066,10 +1066,10 @@
         {
             mErschoepfung = value.toInt();
         }
-        //else if (key == Creature::PROPERTY_EFFECTS)
-        //{
-        //    mEffectManager->setProperty(Creature::PROPERTY_EFFECTS, value);
-        //}
+        else if (key == Creature::PROPERTY_EFFECTS)
+        {
+            mEffectManager->setProperty(Creature::PROPERTY_EFFECTS, value);
+        }
         else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
         {
             mEigenschaften.clear();
@@ -1161,10 +1161,10 @@
         {
             return Property(mErschoepfung);
         }
-        //else if (key == Creature::PROPERTY_EFFECTS)
-        //{
-        //    return Property(mEffectManager->getProperty(Creature::PROPERTY_EFFECTS));
-        //}
+        else if (key == Creature::PROPERTY_EFFECTS)
+        {
+            return mEffectManager->getProperty(Creature::PROPERTY_EFFECTS);
+        }
         else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
         {
             PropertyMap map = rl::convertToPropertyMap(mEigenschaften);
@@ -1237,7 +1237,7 @@
         keys.insert(Creature::PROPERTY_CURRENT_AE);
         keys.insert(Creature::PROPERTY_CURRENT_AU);
         keys.insert(Creature::PROPERTY_CURRENT_FATIGUE);
-        //keys.insert(Creature::PROPERTY_EFFECTS);
+        keys.insert(Creature::PROPERTY_EFFECTS);
         keys.insert(Creature::PROPERTY_EIGENSCHAFTEN);
         keys.insert(Creature::PROPERTY_TALENTE);
         keys.insert(Creature::PROPERTY_KAMPFTECHNIKEN);

Modified: rl/trunk/engine/rules/src/Effect.cpp
===================================================================
--- rl/trunk/engine/rules/src/Effect.cpp	2008-09-14 20:37:40 UTC (rev 4506)
+++ rl/trunk/engine/rules/src/Effect.cpp	2008-09-15 06:14:01 UTC (rev 4507)
@@ -20,6 +20,8 @@
 
 namespace rl
 {
+    const Ogre::String Effect::PROPERTY_NAME = "name";
+    const Ogre::String Effect::PROPERTY_STUFE = "stufe";
 
 	Effect::Effect(int stufe)
 	{
@@ -27,12 +29,12 @@
 		mQuantifier = QUANTIFIER_MULTIPLE;
 	}
 
-	const CeGuiString Effect::getName() const
+	const Ogre::String Effect::getName() const
 	{
 		return mName;
 	}
 
-	void Effect::setName(CeGuiString name)
+	void Effect::setName(Ogre::String name)
 	{
 		mName = name;
 	}
@@ -89,13 +91,13 @@
 
     RL_LONGLONG Effect::timeCheck()
     {
-      return PERMANENT;
+        return PERMANENT;
     }
 
 	Effect::LifeState Effect::getLifeState() const
     {
-      // should be overlaoaded in the specific derivated effects.
-      return LS_NONE;
+        // should be overlaoaded in the specific derivated effects.
+        return LS_NONE;
     }
 
     int Effect::getMod(CeGuiString target, ModType type, ModTag tag)
@@ -105,27 +107,56 @@
 
     const Property Effect::getProperty(const CeGuiString& key) const
     {
-        //else
-        //{
+        Property prop;
+        if (key == Effect::PROPERTY_NAME)
+        {
+            prop.setValue(mName);
+        }
+        else if (key == Effect::PROPERTY_STUFE)
+        {
+            prop.setValue(mStufe);
+        }
+        else
+        {
             Throw(
                 IllegalArgumentException, 
                 key + " is not a property of this effect (" + mName + ")");
-        //}
+        }
+        return prop;
     }
 
     void Effect::setProperty(const CeGuiString& key, const Property& value)
     {
-        // else
-        //{
-            LOG_WARNING(
+        try
+        {
+            if (key == Effect::PROPERTY_NAME)
+            {
+                mName = value.toString().c_str();
+            }
+            else if (key == Effect::PROPERTY_STUFE)
+            {
+                mStufe = value.toInt();
+            }
+            else
+            {
+                LOG_WARNING(
+                    Logger::RULES,
+                    key + " is not a property of this Effect (" + mName + ")");
+            }
+        }
+        catch (WrongFormatException ex)
+        {
+            LOG_ERROR(
                 Logger::RULES,
-                key + " is not a property of this Effect ("+mName+")");
-        //}
+                "property " + key + " has the wrong format");
+        }
     }
 
     PropertyKeys Effect::getAllPropertyKeys() const
     {
         PropertyKeys keys;
+        keys.insert(Effect::PROPERTY_NAME);
+        keys.insert(Effect::PROPERTY_STUFE);
         return keys;
     }
 

Modified: rl/trunk/engine/rules/src/EffectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/EffectManager.cpp	2008-09-14 20:37:40 UTC (rev 4506)
+++ rl/trunk/engine/rules/src/EffectManager.cpp	2008-09-15 06:14:01 UTC (rev 4507)
@@ -20,7 +20,9 @@
 #include <sstream>
 
 #include "CoreSubsystem.h"
+#include "Creature.h"
 #include "DsaManager.h"
+#include "EffectFactory.h"
 #include "Exception.h"
 #include "MessagePump.h"
 #include "RulesMessages.h"
@@ -28,35 +30,36 @@
 
 namespace rl
 {
-	EffectManager::EffectManager(GameObject* gameobject)
+    EffectManager::EffectManager(GameObject* gameobject)
         : mGameObject(gameobject),
         mCheckEffectsRunning(false)
-	{
-	}
+    {
+    }
 
-	EffectManager::~EffectManager()
-	{
-		for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-		{
-			//delete (*it);
+    EffectManager::~EffectManager()
+    {
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            //delete (*it);
             ScriptWrapper::getSingleton().disowned(*it);
-		}
-	}
+        }
+    }
 
-	void EffectManager::checkEffects()
-	{
-            if( mCheckEffectsRunning )
+    void EffectManager::checkEffects()
+    {
+        if( mCheckEffectsRunning ) {
                 return;
-            mCheckEffectsRunning = true;
+        }
+        mCheckEffectsRunning = true;
         RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
         Checklist::iterator checkIt = mChecklist.begin();
         if (checkIt == mChecklist.end()) return;
         while ( checkIt != mChecklist.end() && checkIt->first <= now )
         {
-				std::stringstream debugInfo;
-				debugInfo << "Effect check: " << checkIt->first << " now: " << now << std::endl;
+                std::stringstream debugInfo;
+                debugInfo << "Effect check: " << checkIt->first << " now: " << now << std::endl;
                 LOG_DEBUG(Logger::RULES,
-					debugInfo.str());
+                    debugInfo.str());
             for (Effects::iterator effIt = checkIt->second.begin(); effIt != checkIt->second.end(); effIt++)
             {
                 int nextCheck;
@@ -76,7 +79,7 @@
         }
 
         mCheckEffectsRunning = false;
-	}
+    }
 
     void EffectManager::addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect)
     {
@@ -86,10 +89,10 @@
         // Get current ingame time and add timeUntilCheck
         RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
         RL_LONGLONG timeForCheck = now + timeUntilCheck;
-				std::stringstream debugInfo;
-				debugInfo << "Adding check! now:" << now << " check: " << timeForCheck << std::endl;
-                LOG_DEBUG(Logger::RULES,
-					debugInfo.str());
+        std::stringstream debugInfo;
+        debugInfo << "Adding check! now:" << now << " check: " << timeForCheck << std::endl;
+        LOG_DEBUG(Logger::RULES,
+            debugInfo.str());
         // Insert Sum and effect into the checklist
         mChecklist[timeForCheck].insert(effect);
     }
@@ -98,46 +101,57 @@
     {
         // Preconditions: date > now, effect != NULL
         RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
-        if (date <= now) Throw(IllegalArgumentException, "date lies in the past!");
-        if (effect == NULL) Throw(IllegalArgumentException, "effect pointer is NULL!");
+        if (date <= now) 
+        {
+            Throw(IllegalArgumentException, "date lies in the past!");
+        }
+        if (effect == NULL) 
+        {
+            Throw(IllegalArgumentException, "effect pointer is NULL!");
+        }
         // Insert date and effect into the checklist
-				std::stringstream debugInfo;
-				debugInfo << "Adding check! now:" << now << " check: " << date << std::endl;
-                LOG_DEBUG(Logger::RULES,
-					debugInfo.str());
+        std::stringstream debugInfo;
+        debugInfo << "Adding check! now:" << now << " check: " << date << std::endl;
+        LOG_DEBUG(Logger::RULES, debugInfo.str());
         mChecklist[date].insert(effect);
     }
 
 
-	void EffectManager::addEffect(Effect* effect)
-	{
+    void EffectManager::addEffect(Effect* effect)
+    {
         Effect::LifeState oldState = getLifeState();
 
         LOG_DEBUG(Logger::RULES, "Adding effect " + effect->getName());
-		for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-		{
-			if ((*it)->getName() == effect->getName())
-			{
-				if ((*it)->getQuantifier() == Effect::QUANTIFIER_UNIQUE) return;
-				if ((*it)->getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_PROLONGABLE)
-				{
-					//TODO
-					//Vielleicht alten durch neuen ersetzen?
-					//oder (*it)->setDuration(effect->getDuration())
-				}
-				if ((*it)->getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_CUMULATIVE)
-				{
-					for (int i = 0; i < effect->getStufe(); i++)
-						(*it)->increaseStufe();
-				}
-			}
-		}
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            Effect* cur = *it;
+            if (cur->getName() == effect->getName())
+            {
+                if (cur->getQuantifier() == Effect::QUANTIFIER_UNIQUE) 
+                {
+                    return;
+                }
+                else if (cur->getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_PROLONGABLE)
+                {
+                    //TODO
+                    //Vielleicht alten durch neuen ersetzen?
+                    //oder (*it)->setDuration(effect->getDuration())
+                }
+                else if (cur->getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_CUMULATIVE)
+                {
+                    for (int i = 0; i < effect->getStufe(); i++)
+                    {
+                        cur->increaseStufe();
+                    }
+                }
+            }
+        }
         ScriptWrapper::getSingleton().owned(effect);
-		mEffects.insert(effect);
-		effect->enable();
+        mEffects.insert(effect);
+        effect->enable();
 
         checkStateChange(oldState);
-	}
+    }
 
     void EffectManager::removeEffect(Effect* effect)
     {
@@ -153,8 +167,8 @@
 
     void EffectManager::removeEffect(CeGuiString name)
     {
-		for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-		{
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
             if ((*it)->getName() == name)
             {
                 removeEffect(*it);
@@ -179,21 +193,21 @@
         Effect::LifeState currentState = getLifeState();
         if (currentState != oldState)
         {
-			MessagePump::getSingleton().sendMessage<MessageType_GameObjectLifeStateChanged>(mGameObject,
-				oldState, currentState);
+            MessagePump::getSingleton().sendMessage<MessageType_GameObjectLifeStateChanged>(mGameObject,
+                oldState, currentState);
         }
     }
 
     int EffectManager::getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag)
     {
-      checkEffects();
-      int mod = 0;
-	  if (type == Effect::MODTYPE_MULT) mod = 1;
-      for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-      {
-        mod += (*it)->getMod(target, type, tag);
-      }
-      return mod;
+        checkEffects();
+        int mod = 0;
+        if (type == Effect::MODTYPE_MULT) mod = 1;
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            mod += (*it)->getMod(target, type, tag);
+        }
+        return mod;
     }
 
     CeGuiString EffectManager::getEffects()
@@ -206,5 +220,62 @@
         }
         return retVal;
     }
+
+    const Property EffectManager::getProperty(const CeGuiString& key) const
+    {
+        Property rval;
+        if (key == Creature::PROPERTY_EFFECTS)
+        {
+            PropertyArray arr;
+            for (Effects::const_iterator it = mEffects.begin(); it != mEffects.end(); it++)
+            {
+                arr.push_back((*it)->getAllProperties()->toPropertyMap());
+            }
+            rval = Property(arr);
+        }
+        else 
+        {
+            Throw(IllegalArgumentException, key + " is not a property of EffectManager.");
+        }
+        return rval;
+    }
+    
+    void EffectManager::setProperty(const CeGuiString& key, const Property& value)
+    {
+        try
+        {
+            if (key == Creature::PROPERTY_EFFECTS)
+            {
+                PropertyArray arr = value.toArray();
+                for (PropertyArray::iterator it = arr.begin(); it != arr.end(); it++)
+                {
+                    PropertyMap cur = it->toMap();
+                    Ogre::String name = cur[Effect::PROPERTY_NAME].toString().c_str();
+                    int stufe = cur[Effect::PROPERTY_STUFE];
+                    Effect* eff = EffectFactoryManager::getSingleton().createEffect(name, stufe);
+                    mEffects.insert(eff);
+                    ///@TODO: activate effects
+                }                
+            }
+            else
+            {
+                LOG_WARNING(Logger::RULES, 
+                    key + " is not a property of EffectManager");
+            }
+        }
+        catch (WrongFormatException ex)
+        {
+            LOG_ERROR(Logger::RULES, 
+                "property " + key + " has the wrong format");
+        }
+    }
+
+    PropertyKeys EffectManager::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        keys.insert(Creature::PROPERTY_EFFECTS);
+        return keys;
+    }
+
 }
 

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2008-09-14 20:37:40 UTC (rev 4506)
+++ rl/trunk/engine/script/swig/RlRules.swig	2008-09-15 06:14:01 UTC (rev 4507)
@@ -638,8 +638,8 @@
         Effect(int stufe = 1);
         virtual ~Effect();
 
-        const rl::CeGuiString getName() const;
-        void setName(rl::CeGuiString name);
+        const Ogre::String getName() const;
+        void setName(Ogre::String name);
         const rl::CeGuiString getDescription() const;
         void setDescription(rl::CeGuiString description);
         Quantifier getQuantifier();



From blakharaz at mail.berlios.de  Mon Sep 15 21:30:03 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 15 Sep 2008 21:30:03 +0200
Subject: [Dsa-hl-svn] r4508 - in rl/trunk: Mac/Rastullah.xcodeproj
	engine/common/include engine/core/src engine/rules/include
	engine/rules/src
Message-ID: <200809151930.m8FJU3Zc022409@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-15 21:29:55 +0200 (Mon, 15 Sep 2008)
New Revision: 4508

Modified:
   rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/trunk/engine/common/include/Property.h
   rl/trunk/engine/core/src/ConfigurationManager.cpp
   rl/trunk/engine/rules/include/Effect.h
   rl/trunk/engine/rules/include/EffectManager.h
   rl/trunk/engine/rules/src/Effect.cpp
   rl/trunk/engine/rules/src/EffectManager.cpp
Log:
Save effects to properties

Modified: rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-15 06:14:01 UTC (rev 4507)
+++ rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-15 19:29:55 UTC (rev 4508)
@@ -615,6 +615,7 @@
 		485B895C0E15796500D5B19C /* SceneManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89590E15796500D5B19C /* SceneManager.cpp */; };
 		48760AAB0D92E4B700BEB57C /* RlExports_wrap.cxx in Sources */ = {isa = PBXBuildFile; fileRef = 48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */; };
 		48760AAC0D92E4B700BEB57C /* RlExports_wrap.h in Headers */ = {isa = PBXBuildFile; fileRef = 48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */; };
+		487750B00E7E3C9C0018216B /* Cg.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 487750AF0E7E3C9C0018216B /* Cg.framework */; };
 		4890C0B80E18061300BE5850 /* AbstractMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A70E18061300BE5850 /* AbstractMovement.h */; };
 		4890C0B90E18061300BE5850 /* FallDownMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A80E18061300BE5850 /* FallDownMovement.h */; };
 		4890C0BA0E18061300BE5850 /* JogBackwardsMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */; };
@@ -664,7 +665,6 @@
 		48B0B03C0E6535AB0023B198 /* libmeshmagick.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 440785DD0C09D231006E496D /* libmeshmagick.dylib */; };
 		48B0B0490E65BBB30023B198 /* libfmodex.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48B0B0480E65BBB30023B198 /* libfmodex.dylib */; };
 		48B0B04A0E65BBC10023B198 /* libfmodex.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 48B0B0480E65BBB30023B198 /* libfmodex.dylib */; };
-		48B5F63A0DAF48AF00D05C95 /* Info.plist in Resources */ = {isa = PBXBuildFile; fileRef = 8D0C4E960486CD37000505A6 /* Info.plist */; };
 		48B772DD0D58350B000A3B97 /* XmlProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B772DA0D58350B000A3B97 /* XmlProcessor.h */; };
 		48B772DE0D58350B000A3B97 /* XmlPropertyReader.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B772DB0D58350B000A3B97 /* XmlPropertyReader.h */; };
 		48B772DF0D58350B000A3B97 /* XmlPropertyWriter.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B772DC0D58350B000A3B97 /* XmlPropertyWriter.h */; };
@@ -853,6 +853,7 @@
 			dstPath = "";
 			dstSubfolderSpec = 10;
 			files = (
+				487750B00E7E3C9C0018216B /* Cg.framework in Copy Frameworks */,
 				48C04B8A0E67DF0300CD3A7D /* PCRE.framework in Copy Frameworks */,
 				48003B550E3211660056D073 /* libboost_system.dylib in Copy Frameworks */,
 				48D0BDE60E23378700863824 /* libboost_filesystem.dylib in Copy Frameworks */,
@@ -1445,6 +1446,7 @@
 		48760A990D92E2CD00BEB57C /* RlUi.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = RlUi.swig; path = ../engine/script/swig/RlUi.swig; sourceTree = SOURCE_ROOT; };
 		48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */ = {isa = PBXFileReference; explicitFileType = sourcecode.cpp.cpp; fileEncoding = 4; includeInIndex = 0; name = RlExports_wrap.cxx; path = ../engine/script/swig/RlExports_wrap.cxx; sourceTree = SOURCE_ROOT; };
 		48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RlExports_wrap.h; path = ../engine/script/swig/RlExports_wrap.h; sourceTree = SOURCE_ROOT; };
+		487750AF0E7E3C9C0018216B /* Cg.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cg.framework; path = /Library/Frameworks/Cg.framework; sourceTree = "<absolute>"; };
 		4890C0A70E18061300BE5850 /* AbstractMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AbstractMovement.h; path = ../engine/rules/include/AbstractMovement.h; sourceTree = SOURCE_ROOT; };
 		4890C0A80E18061300BE5850 /* FallDownMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = FallDownMovement.h; path = ../engine/rules/include/FallDownMovement.h; sourceTree = SOURCE_ROOT; };
 		4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JogBackwardsMovement.h; path = ../engine/rules/include/JogBackwardsMovement.h; sourceTree = SOURCE_ROOT; };
@@ -1688,6 +1690,7 @@
 			isa = PBXGroup;
 			children = (
 				20286C2AFDCF999611CA2CEA /* Sources */,
+				48D401810D9E483200AE5340 /* modules */,
 				20286C2CFDCF999611CA2CEA /* Resources */,
 				20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */,
 				195DF8CFFE9D517E11CA2CBB /* Products */,
@@ -1714,7 +1717,6 @@
 		20286C2CFDCF999611CA2CEA /* Resources */ = {
 			isa = PBXGroup;
 			children = (
-				48D401810D9E483200AE5340 /* modules */,
 				440786120C09D602006E496D /* RlScript-Info.plist */,
 				8D0C4E960486CD37000505A6 /* Info.plist */,
 				0867D6AAFE840B52C02AAC07 /* InfoPlist.strings */,
@@ -1726,6 +1728,7 @@
 		20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */ = {
 			isa = PBXGroup;
 			children = (
+				487750AF0E7E3C9C0018216B /* Cg.framework */,
 				48C04B890E67DF0300CD3A7D /* PCRE.framework */,
 				48B0B0480E65BBB30023B198 /* libfmodex.dylib */,
 				48CFBF8E0E2E869000CD0C51 /* FreeType.framework */,
@@ -3046,7 +3049,6 @@
 				8D0C4E8D0486CD37000505A6 /* InfoPlist.strings in Resources */,
 				8D0C4E8E0486CD37000505A6 /* main.nib in Resources */,
 				48D409CE0D9E483300AE5340 /* modules in Resources */,
-				48B5F63A0DAF48AF00D05C95 /* Info.plist in Resources */,
 				4835559B0E6ABED100008748 /* mkdmg.sh in Resources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;

Modified: rl/trunk/engine/common/include/Property.h
===================================================================
--- rl/trunk/engine/common/include/Property.h	2008-09-15 06:14:01 UTC (rev 4507)
+++ rl/trunk/engine/common/include/Property.h	2008-09-15 19:29:55 UTC (rev 4508)
@@ -87,6 +87,7 @@
         PropertyMethod(Bool, const bool&);
         PropertyMethod(String, CEGUI::String);
         PropertyMethod(Int, const int&);
+        PropertyMethod(Long, const RL_LONGLONG&);
         PropertyMethod(Real, const Ogre::Real&);
         PropertyMethod(Vector3, const Ogre::Vector3&);
         PropertyMethod(Quaternion, const Ogre::Quaternion&);

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-09-15 06:14:01 UTC (rev 4507)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-09-15 19:29:55 UTC (rev 4508)
@@ -124,8 +124,6 @@
         addSetting("MovementController keys", "reset_camera", "0 (Nummernblock)");
 
         addSetting("Localization", "language", "de");
-
-        setRastullahCfgPath();
     }
 
     ConfigurationManager::~ConfigurationManager()
@@ -187,6 +185,7 @@
 
     void ConfigurationManager::loadConfig()
     {
+        setRastullahCfgPath();
         // On Linux, we create the .rastullah directory
 #       if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
         fs::path rastullahCfgDirectory(Ogre::String(::getenv("HOME")) + "/.rastullah",
@@ -265,7 +264,7 @@
         {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
             mModulesRootDirectory = RL_MODULEDIR;
-#           elsif OGRE_PLATFORM == OGRE_PLATFORM_APPLE
+#           elif OGRE_PLATFORM == OGRE_PLATFORM_APPLE
             mModulesRootDirectory = mExecutablePath + "/../Resources/modules";
 #           else
             mModulesRootDirectory = "./modules";
@@ -390,8 +389,8 @@
 	void ConfigurationManager::setExecutable(const Ogre::String& path)
 	{
 		fs::path exeAbsolute(path, fs::portable_posix_name);
-		
 		mExecutablePath = exeAbsolute.remove_leaf().string();
+        std::cout << "ConfigurationManager" << "Executable is " << path << " " << mExecutablePath;
 	}
 
 	const Ogre::String& ConfigurationManager::getExecutablePath() const
@@ -441,11 +440,12 @@
         try 
         {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-			std::cout << "Checking for " << fs::complete(filename);
+			std::cout << "Checking for " << fs::complete(filename) << std::endl;
             if (fs::exists(filename))
 #           else
 			std::cout << "Checking for " << 
-				fs::complete(fs::path(filename, fs::portable_posix_name)).string();
+				fs::complete(fs::path(filename, fs::portable_posix_name)).string()
+                 << std::endl;
 			if (fs::exists(fs::path(filename, fs::portable_posix_name)))
 #           endif
             {

Modified: rl/trunk/engine/rules/include/Effect.h
===================================================================
--- rl/trunk/engine/rules/include/Effect.h	2008-09-15 06:14:01 UTC (rev 4507)
+++ rl/trunk/engine/rules/include/Effect.h	2008-09-15 19:29:55 UTC (rev 4508)
@@ -82,6 +82,7 @@
 
         static const Ogre::String PROPERTY_NAME;
         static const Ogre::String PROPERTY_STUFE;
+        static const Ogre::String PROPERTY_ENABLED;
 
 
         /// Setzt den Quantifier standardmaessig auf QUANTIFIER_MULTIPLE.

Modified: rl/trunk/engine/rules/include/EffectManager.h
===================================================================
--- rl/trunk/engine/rules/include/EffectManager.h	2008-09-15 06:14:01 UTC (rev 4507)
+++ rl/trunk/engine/rules/include/EffectManager.h	2008-09-15 19:29:55 UTC (rev 4508)
@@ -1,125 +1,130 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __EFFECTMANAGER_H__
-#define __EFFECTMANAGER_H__
-
-#include "RulesPrerequisites.h"
-
-#include <set>
-
-#include "Date.h"
-#include "Effect.h"
-
-namespace rl
-{
-    class GameObject;
-
-    /**
-     * @brief Manages the effects affecting a game object
-     * 
-     * This class manages all effects applied to a game object.
-     * Each game object has a seperate EffectManager. The method checkEffects()
-     * should be called every Aktion (the dark eye time unit)
-     **/
-
-    class _RlRulesExport EffectManager : public PropertyHolder
-	{
-	public:
-		EffectManager(GameObject* gameobject);
-		~EffectManager();
-
-        /**
-         *  Checks effects for changes.
-         **/
-		void checkEffects();
-        /** 
-         *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
-         *  in welcher Zeit er wieder ueberprueft werden muss.
-         *  @param time Die Zeitspanne wann die naechste Ueberpruefung faellig ist.
-         *  @param effect Der zu ueberpruefende Effekt.
-         *  @throws IllegalArgumentException time parameter is <= 0
-         *  @throws IllegalArgumentException effect pointer is NULL
-         *  @see addCheckDate Date
-         **/
-        void addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect);
-        /**
-         *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
-         *  zu welchem Zeitpunkt er wieder ueberprueft werden muss.
-         *  @param date Das Datum der naechsten Ueberpruefung.
-         *  @param effect Der zu ueberpruefende Effekt.
-         *  @throws IllegalArgumentException date lies in the past
-         *  @throws IllegalArgumentException effect pointer is NULL
-         *  @see addCheck, Date
-         **/
-        void addDateCheck(RL_LONGLONG date, Effect* effect);
-        /**
-         * Fuegt einen neuen Effekt in die Liste ein.
-         * @param effect Ein Zeiger auf den einzufuegenden Effekt.
-         **/
-		void addEffect(Effect* effect);
-        
-        /// Removes effects by pointer.
-        void removeEffect(Effect* effect);
-
-        /// Removes effects by name.
-        void removeEffect(CeGuiString name);
-        
-        /**
-         * Checks the effects for the given status.
-         **/
-        Effect::LifeState getLifeState();
-        
-        /**
-         * Returns the specified modificator.
-         * @param target specifies what modificator you want to get (e.g. "Athletik")
-         * @param type specifies what type of modificator you want (e.g. modificator of the TaW or the Probenzuschlag)
-         * @param tag add some additional restrictions (e.g. KO Probe for sicknesses or Athletik for balance acts)
-         **/
-        int getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag = Effect::MODTAG_NONE);
-
-        /**
-         * Returns a printable list of all effects
-         **/
-        CeGuiString getEffects();
-
-        void checkStateChange(Effect::LifeState oldState);
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __EFFECTMANAGER_H__
+#define __EFFECTMANAGER_H__
+
+#include "RulesPrerequisites.h"
+
+#include <set>
+
+#include "Date.h"
+#include "Effect.h"
+
+namespace rl
+{
+    class GameObject;
+
+    /**
+     * @brief Manages the effects affecting a game object
+     * 
+     * This class manages all effects applied to a game object.
+     * Each game object has a seperate EffectManager. The method checkEffects()
+     * should be called every Aktion (the dark eye time unit)
+     **/
+
+    class _RlRulesExport EffectManager : public PropertyHolder
+	{
+	public:
+    
+        static const Ogre::String PROPERTY_TIMECHECK;
+        static const Ogre::String PROPERTY_TIME;
+        static const Ogre::String PROPERTY_EFFECT;
+        
+		EffectManager(GameObject* gameobject);
+		~EffectManager();
+
+        /**
+         *  Checks effects for changes.
+         **/
+		void checkEffects();
+        /** 
+         *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
+         *  in welcher Zeit er wieder ueberprueft werden muss.
+         *  @param time Die Zeitspanne wann die naechste Ueberpruefung faellig ist.
+         *  @param effect Der zu ueberpruefende Effekt.
+         *  @throws IllegalArgumentException time parameter is <= 0
+         *  @throws IllegalArgumentException effect pointer is NULL
+         *  @see addCheckDate Date
+         **/
+        void addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect);
+        /**
+         *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
+         *  zu welchem Zeitpunkt er wieder ueberprueft werden muss.
+         *  @param date Das Datum der naechsten Ueberpruefung.
+         *  @param effect Der zu ueberpruefende Effekt.
+         *  @throws IllegalArgumentException date lies in the past
+         *  @throws IllegalArgumentException effect pointer is NULL
+         *  @see addCheck, Date
+         **/
+        void addDateCheck(RL_LONGLONG date, Effect* effect);
+        /**
+         * Fuegt einen neuen Effekt in die Liste ein.
+         * @param effect Ein Zeiger auf den einzufuegenden Effekt.
+         **/
+		void addEffect(Effect* effect);
+        
+        /// Removes effects by pointer.
+        void removeEffect(Effect* effect);
+
+        /// Removes effects by name.
+        void removeEffect(CeGuiString name);
+        
+        /**
+         * Checks the effects for the given status.
+         **/
+        Effect::LifeState getLifeState();
+        
+        /**
+         * Returns the specified modificator.
+         * @param target specifies what modificator you want to get (e.g. "Athletik")
+         * @param type specifies what type of modificator you want (e.g. modificator of the TaW or the Probenzuschlag)
+         * @param tag add some additional restrictions (e.g. KO Probe for sicknesses or Athletik for balance acts)
+         **/
+        int getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag = Effect::MODTAG_NONE);
+
+        /**
+         * Returns a printable list of all effects
+         **/
+        CeGuiString getEffects();
+
+        void checkStateChange(Effect::LifeState oldState);
+
         virtual const Property getProperty(const CeGuiString& key) const;
         virtual void setProperty(const CeGuiString& key, const Property& value);
-        virtual PropertyKeys getAllPropertyKeys() const;
-
-	private:
-
-        GameObject* mGameObject;
-
-        // only used in checkEffects!
-        bool mCheckEffectsRunning;
-
-        /// Eine einfache Menge von Effekten
-		typedef std::set<Effect*> Effects;
-		Effects mEffects;
-        /**
-         * Eine Liste die wiedergibt, wann welcher Effekt
-         * ueberprueft werden muss.
-         **/
-        typedef std::map<RL_LONGLONG, Effects> Checklist;
-        Checklist mChecklist;
-	};
-}
-
-#endif //__EFFECTMANAGER_H__
-		
+        virtual PropertyKeys getAllPropertyKeys() const;
+
+	private:
+
+        GameObject* mGameObject;
+
+        // only used in checkEffects!
+        bool mCheckEffectsRunning;
+
+        /// Eine einfache Menge von Effekten
+		typedef std::vector<Effect*> Effects;
+		Effects mEffects;
+        /**
+         * Eine Liste die wiedergibt, wann welcher Effekt
+         * ueberprueft werden muss.
+         **/
+        typedef std::map<RL_LONGLONG, Effects> Checklist;
+        Checklist mChecklist;
+	};
+}
+
+#endif //__EFFECTMANAGER_H__
+		

Modified: rl/trunk/engine/rules/src/Effect.cpp
===================================================================
--- rl/trunk/engine/rules/src/Effect.cpp	2008-09-15 06:14:01 UTC (rev 4507)
+++ rl/trunk/engine/rules/src/Effect.cpp	2008-09-15 19:29:55 UTC (rev 4508)
@@ -1,163 +1,172 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "Effect.h"
-#include "DsaManager.h"
-
-namespace rl
-{
-    const Ogre::String Effect::PROPERTY_NAME = "name";
-    const Ogre::String Effect::PROPERTY_STUFE = "stufe";
-
-	Effect::Effect(int stufe)
-	{
-		mStufe = stufe;
-		mQuantifier = QUANTIFIER_MULTIPLE;
-	}
-
-	const Ogre::String Effect::getName() const
-	{
-		return mName;
-	}
-
-	void Effect::setName(Ogre::String name)
-	{
-		mName = name;
-	}
-
-	const CeGuiString Effect::getDescription() const
-	{
-		return mDescription;
-	}
-
-	void Effect::setDescription(CeGuiString description)
-	{
-		mDescription = description;
-	}
-
-    Effect::Quantifier Effect::getQuantifier()
-	{
-		return mQuantifier;
-	}
-
-	void Effect::setQuantifier(Quantifier quantifier)
-	{
-		mQuantifier = quantifier;
-	}
-
-
-	const int Effect::getStufe()
-	{
-		return mStufe;
-	}
-
-	void Effect::increaseStufe()
-	{
-	}
-
-	void Effect::decreaseStufe()
-	{
-	}
-
-	void Effect::enable()
-	{
-		if (!mEnabled)
-		{
-			mEnabled = true;
-		}
-	}
-
-	void Effect::disable()
-	{
-		if (mEnabled)
-		{
-			mEnabled = false;
-		}
-	}
-
-    RL_LONGLONG Effect::timeCheck()
-    {
-        return PERMANENT;
-    }
-
-	Effect::LifeState Effect::getLifeState() const
-    {
-        // should be overlaoaded in the specific derivated effects.
-        return LS_NONE;
-    }
-
-    int Effect::getMod(CeGuiString target, ModType type, ModTag tag)
-    {
-        return 0;
-    }
-
-    const Property Effect::getProperty(const CeGuiString& key) const
-    {
-        Property prop;
-        if (key == Effect::PROPERTY_NAME)
-        {
-            prop.setValue(mName);
-        }
-        else if (key == Effect::PROPERTY_STUFE)
-        {
-            prop.setValue(mStufe);
-        }
-        else
-        {
-            Throw(
-                IllegalArgumentException, 
-                key + " is not a property of this effect (" + mName + ")");
-        }
-        return prop;
-    }
-
-    void Effect::setProperty(const CeGuiString& key, const Property& value)
-    {
-        try
-        {
-            if (key == Effect::PROPERTY_NAME)
-            {
-                mName = value.toString().c_str();
-            }
-            else if (key == Effect::PROPERTY_STUFE)
-            {
-                mStufe = value.toInt();
-            }
-            else
-            {
-                LOG_WARNING(
-                    Logger::RULES,
-                    key + " is not a property of this Effect (" + mName + ")");
-            }
-        }
-        catch (WrongFormatException ex)
-        {
-            LOG_ERROR(
-                Logger::RULES,
-                "property " + key + " has the wrong format");
-        }
-    }
-
-    PropertyKeys Effect::getAllPropertyKeys() const
-    {
-        PropertyKeys keys;
-        keys.insert(Effect::PROPERTY_NAME);
-        keys.insert(Effect::PROPERTY_STUFE);
-        return keys;
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include "Effect.h"
+#include "DsaManager.h"
+
+namespace rl
+{
+    const Ogre::String Effect::PROPERTY_NAME = "name";
+    const Ogre::String Effect::PROPERTY_STUFE = "stufe";
+    const Ogre::String Effect::PROPERTY_ENABLED = "enabled";    
+
+	Effect::Effect(int stufe)
+	{
+		mStufe = stufe;
+		mQuantifier = QUANTIFIER_MULTIPLE;
+	}
+
+	const Ogre::String Effect::getName() const
+	{
+		return mName;
+	}
+
+	void Effect::setName(Ogre::String name)
+	{
+		mName = name;
+	}
+
+	const CeGuiString Effect::getDescription() const
+	{
+		return mDescription;
+	}
+
+	void Effect::setDescription(CeGuiString description)
+	{
+		mDescription = description;
+	}
+
+    Effect::Quantifier Effect::getQuantifier()
+	{
+		return mQuantifier;
+	}
+
+	void Effect::setQuantifier(Quantifier quantifier)
+	{
+		mQuantifier = quantifier;
+	}
+
+
+	const int Effect::getStufe()
+	{
+		return mStufe;
+	}
+
+	void Effect::increaseStufe()
+	{
+	}
+
+	void Effect::decreaseStufe()
+	{
+	}
+
+	void Effect::enable()
+	{
+		if (!mEnabled)
+		{
+			mEnabled = true;
+		}
+	}
+
+	void Effect::disable()
+	{
+		if (mEnabled)
+		{
+			mEnabled = false;
+		}
+	}
+
+    RL_LONGLONG Effect::timeCheck()
+    {
+        return PERMANENT;
+    }
+
+	Effect::LifeState Effect::getLifeState() const
+    {
+        // should be overlaoaded in the specific derivated effects.
+        return LS_NONE;
+    }
+
+    int Effect::getMod(CeGuiString target, ModType type, ModTag tag)
+    {
+        return 0;
+    }
+
+    const Property Effect::getProperty(const CeGuiString& key) const
+    {
+        Property prop;
+        if (key == Effect::PROPERTY_NAME)
+        {
+            prop.setValue(mName);
+        }
+        else if (key == Effect::PROPERTY_STUFE)
+        {
+            prop.setValue(mStufe);
+        }
+        else if (key == Effect::PROPERTY_ENABLED)
+        {
+            prop.setValue(mEnabled);
+        }
+        else
+        {
+            Throw(
+                IllegalArgumentException, 
+                key + " is not a property of this effect (" + mName + ")");
+        }
+        return prop;
+    }
+
+    void Effect::setProperty(const CeGuiString& key, const Property& value)
+    {
+        try
+        {
+            if (key == Effect::PROPERTY_NAME)
+            {
+                mName = value.toString().c_str();
+            }
+            else if (key == Effect::PROPERTY_STUFE)
+            {
+                mStufe = value.toInt();
+            }
+            else if (key == Effect::PROPERTY_ENABLED)
+            {
+                mEnabled = value.toBool();
+            }
+            else
+            {
+                LOG_WARNING(
+                    Logger::RULES,
+                    key + " is not a property of this Effect (" + mName + ")");
+            }
+        }
+        catch (WrongFormatException ex)
+        {
+            LOG_ERROR(
+                Logger::RULES,
+                "property " + key + " has the wrong format: " + ex.getMessage());
+        }
+    }
+
+    PropertyKeys Effect::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        keys.insert(Effect::PROPERTY_NAME);
+        keys.insert(Effect::PROPERTY_STUFE);
+        return keys;
+    }
+
+}

Modified: rl/trunk/engine/rules/src/EffectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/EffectManager.cpp	2008-09-15 06:14:01 UTC (rev 4507)
+++ rl/trunk/engine/rules/src/EffectManager.cpp	2008-09-15 19:29:55 UTC (rev 4508)
@@ -1,237 +1,270 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "EffectManager.h"
-
-#include <sstream>
-
-#include "CoreSubsystem.h"
-#include "Creature.h"
-#include "DsaManager.h"
-#include "EffectFactory.h"
-#include "Exception.h"
-#include "MessagePump.h"
-#include "RulesMessages.h"
-#include "ScriptWrapper.h"
-
-namespace rl
-{
-    EffectManager::EffectManager(GameObject* gameobject)
-        : mGameObject(gameobject),
-        mCheckEffectsRunning(false)
-    {
-    }
-
-    EffectManager::~EffectManager()
-    {
-        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-        {
-            //delete (*it);
-            ScriptWrapper::getSingleton().disowned(*it);
-        }
-    }
-
-    void EffectManager::checkEffects()
-    {
-        if( mCheckEffectsRunning ) {
-                return;
-        }
-        mCheckEffectsRunning = true;
-        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
-        Checklist::iterator checkIt = mChecklist.begin();
-        if (checkIt == mChecklist.end()) return;
-        while ( checkIt != mChecklist.end() && checkIt->first <= now )
-        {
-                std::stringstream debugInfo;
-                debugInfo << "Effect check: " << checkIt->first << " now: " << now << std::endl;
-                LOG_DEBUG(Logger::RULES,
-                    debugInfo.str());
-            for (Effects::iterator effIt = checkIt->second.begin(); effIt != checkIt->second.end(); effIt++)
-            {
-                int nextCheck;
-                nextCheck = (*effIt)->timeCheck();
-                switch (nextCheck)
-                {
-                  case Effect::REMOVE:
-                    removeEffect(*effIt);
-                    break;
-                  case Effect::PERMANENT:
-                    break;
-                  default:
-                    addTimeCheck(nextCheck, *effIt);
-                }
-            }
-            mChecklist.erase(checkIt++);
-        }
-
-        mCheckEffectsRunning = false;
-    }
-
-    void EffectManager::addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect)
-    {
-        // Preconditions: time > 0, effect != NULL
-        if (time <= 0) Throw(IllegalArgumentException, "time parameter is <= 0!");
-        if (effect == NULL) Throw(IllegalArgumentException, "effect pointer is NULL!");
-        // Get current ingame time and add timeUntilCheck
-        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
-        RL_LONGLONG timeForCheck = now + timeUntilCheck;
-        std::stringstream debugInfo;
-        debugInfo << "Adding check! now:" << now << " check: " << timeForCheck << std::endl;
-        LOG_DEBUG(Logger::RULES,
-            debugInfo.str());
-        // Insert Sum and effect into the checklist
-        mChecklist[timeForCheck].insert(effect);
-    }
-
-    void EffectManager::addDateCheck(RL_LONGLONG date, Effect* effect)
-    {
-        // Preconditions: date > now, effect != NULL
-        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
-        if (date <= now) 
-        {
-            Throw(IllegalArgumentException, "date lies in the past!");
-        }
-        if (effect == NULL) 
-        {
-            Throw(IllegalArgumentException, "effect pointer is NULL!");
-        }
-        // Insert date and effect into the checklist
-        std::stringstream debugInfo;
-        debugInfo << "Adding check! now:" << now << " check: " << date << std::endl;
-        LOG_DEBUG(Logger::RULES, debugInfo.str());
-        mChecklist[date].insert(effect);
-    }
-
-
-    void EffectManager::addEffect(Effect* effect)
-    {
-        Effect::LifeState oldState = getLifeState();
-
-        LOG_DEBUG(Logger::RULES, "Adding effect " + effect->getName());
-        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-        {
-            Effect* cur = *it;
-            if (cur->getName() == effect->getName())
-            {
-                if (cur->getQuantifier() == Effect::QUANTIFIER_UNIQUE) 
-                {
-                    return;
-                }
-                else if (cur->getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_PROLONGABLE)
-                {
-                    //TODO
-                    //Vielleicht alten durch neuen ersetzen?
-                    //oder (*it)->setDuration(effect->getDuration())
-                }
-                else if (cur->getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_CUMULATIVE)
-                {
-                    for (int i = 0; i < effect->getStufe(); i++)
-                    {
-                        cur->increaseStufe();
-                    }
-                }
-            }
-        }
-        ScriptWrapper::getSingleton().owned(effect);
-        mEffects.insert(effect);
-        effect->enable();
-
-        checkStateChange(oldState);
-    }
-
-    void EffectManager::removeEffect(Effect* effect)
-    {
-        Effect::LifeState oldState = getLifeState();
-    
-        effect->disable();
-        mEffects.erase(effect);
-        ScriptWrapper::getSingleton().disowned(effect);
-        ///@todo also remove from the check lists?
-
-        checkStateChange(oldState);
-    }
-
-    void EffectManager::removeEffect(CeGuiString name)
-    {
-        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-        {
-            if ((*it)->getName() == name)
-            {
-                removeEffect(*it);
-                return;
-            }
-        }
-    }
-
-    Effect::LifeState EffectManager::getLifeState()
-    {
-        checkEffects();
-        Effect::LifeState status = 0;
-        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-        {
-            status = status | ((*it)->getLifeState());
-        }
-        return status;
-    }
-
-    void EffectManager::checkStateChange(Effect::LifeState oldState)
-    {
-        Effect::LifeState currentState = getLifeState();
-        if (currentState != oldState)
-        {
-            MessagePump::getSingleton().sendMessage<MessageType_GameObjectLifeStateChanged>(mGameObject,
-                oldState, currentState);
-        }
-    }
-
-    int EffectManager::getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag)
-    {
-        checkEffects();
-        int mod = 0;
-        if (type == Effect::MODTYPE_MULT) mod = 1;
-        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-        {
-            mod += (*it)->getMod(target, type, tag);
-        }
-        return mod;
-    }
-
-    CeGuiString EffectManager::getEffects()
-    {
-        CeGuiString retVal = "";
-        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-        {
-            retVal += (*it)->getName() + "\n";
-            retVal += (*it)->getDescription() + "\n";
-        }
-        return retVal;
-    }
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include "EffectManager.h"
+
+#include <sstream>
+
+#include "CoreSubsystem.h"
+#include "Creature.h"
+#include "DsaManager.h"
+#include "EffectFactory.h"
+#include "Exception.h"
+#include "MessagePump.h"
+#include "RulesMessages.h"
+#include "ScriptWrapper.h"
+
+namespace rl
+{
+    const Ogre::String EffectManager::PROPERTY_TIMECHECK = "timechecks";
+    const Ogre::String EffectManager::PROPERTY_TIME = "time";
+    const Ogre::String EffectManager::PROPERTY_EFFECT = "effect";
+
+    EffectManager::EffectManager(GameObject* gameobject)
+        : mGameObject(gameobject),
+        mCheckEffectsRunning(false)
+    {
+    }
+
+    EffectManager::~EffectManager()
+    {
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            //delete (*it);
+            ScriptWrapper::getSingleton().disowned(*it);
+        }
+    }
+
+    void EffectManager::checkEffects()
+    {
+        if( mCheckEffectsRunning ) {
+                return;
+        }
+        mCheckEffectsRunning = true;
+        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
+        Checklist::iterator checkIt = mChecklist.begin();
+        if (checkIt == mChecklist.end()) return;
+        while ( checkIt != mChecklist.end() && checkIt->first <= now )
+        {
+                std::stringstream debugInfo;
+                debugInfo << "Effect check: " << checkIt->first << " now: " << now << std::endl;
+                LOG_DEBUG(Logger::RULES,
+                    debugInfo.str());
+            for (Effects::iterator effIt = checkIt->second.begin(); effIt != checkIt->second.end(); effIt++)
+            {
+                int nextCheck;
+                nextCheck = (*effIt)->timeCheck();
+                switch (nextCheck)
+                {
+                  case Effect::REMOVE:
+                    removeEffect(*effIt);
+                    break;
+                  case Effect::PERMANENT:
+                    break;
+                  default:
+                    addTimeCheck(nextCheck, *effIt);
+                }
+            }
+            mChecklist.erase(checkIt++);
+        }
+
+        mCheckEffectsRunning = false;
+    }
+
+    void EffectManager::addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect)
+    {
+        // Preconditions: time > 0, effect != NULL
+        if (time <= 0) Throw(IllegalArgumentException, "time parameter is <= 0!");
+        if (effect == NULL) Throw(IllegalArgumentException, "effect pointer is NULL!");
+        // Get current ingame time and add timeUntilCheck
+        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
+        RL_LONGLONG timeForCheck = now + timeUntilCheck;
+        std::stringstream debugInfo;
+        debugInfo << "Adding check! now:" << now << " check: " << timeForCheck << std::endl;
+        LOG_DEBUG(Logger::RULES,
+            debugInfo.str());
+        // Insert Sum and effect into the checklist
+        mChecklist[timeForCheck].push_back(effect);
+    }
+
+    void EffectManager::addDateCheck(RL_LONGLONG date, Effect* effect)
+    {
+        // Preconditions: date > now, effect != NULL
+        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
+        if (date <= now) 
+        {
+            Throw(IllegalArgumentException, "date lies in the past!");
+        }
+        if (effect == NULL) 
+        {
+            Throw(IllegalArgumentException, "effect pointer is NULL!");
+        }
+        // Insert date and effect into the checklist
+        std::stringstream debugInfo;
+        debugInfo << "Adding check! now:" << now << " check: " << date << std::endl;
+        LOG_DEBUG(Logger::RULES, debugInfo.str());
+        mChecklist[date].push_back(effect);
+    }
+
+
+    void EffectManager::addEffect(Effect* effect)
+    {
+        Effect::LifeState oldState = getLifeState();
+
+        LOG_DEBUG(Logger::RULES, "Adding effect " + effect->getName());
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            Effect* cur = *it;
+            if (cur->getName() == effect->getName())
+            {
+                if (cur->getQuantifier() == Effect::QUANTIFIER_UNIQUE) 
+                {
+                    return;
+                }
+                else if (cur->getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_PROLONGABLE)
+                {
+                    //TODO
+                    //Vielleicht alten durch neuen ersetzen?
+                    //oder (*it)->setDuration(effect->getDuration())
+                }
+                else if (cur->getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_CUMULATIVE)
+                {
+                    for (int i = 0; i < effect->getStufe(); i++)
+                    {
+                        cur->increaseStufe();
+                    }
+                }
+            }
+        }
+        ScriptWrapper::getSingleton().owned(effect);
+        mEffects.push_back(effect);
+        effect->enable();
+
+        checkStateChange(oldState);
+    }
+
+    void EffectManager::removeEffect(Effect* effect)
+    {
+        Effect::LifeState oldState = getLifeState();
+    
+        effect->disable();
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); ++it)
+        {
+            if (*it == effect)
+            {
+                mEffects.erase(it);
+                break;
+            }
+        }
+        ScriptWrapper::getSingleton().disowned(effect);
+        ///@todo also remove from the check lists?
+
+        checkStateChange(oldState);
+    }
+
+    void EffectManager::removeEffect(CeGuiString name)
+    {
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            if ((*it)->getName() == name)
+            {
+                removeEffect(*it);
+                return;
+            }
+        }
+    }
+
+    Effect::LifeState EffectManager::getLifeState()
+    {
+        checkEffects();
+        Effect::LifeState status = 0;
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            status = status | ((*it)->getLifeState());
+        }
+        return status;
+    }
+
+    void EffectManager::checkStateChange(Effect::LifeState oldState)
+    {
+        Effect::LifeState currentState = getLifeState();
+        if (currentState != oldState)
+        {
+            MessagePump::getSingleton().sendMessage<MessageType_GameObjectLifeStateChanged>(mGameObject,
+                oldState, currentState);
+        }
+    }
+
+    int EffectManager::getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag)
+    {
+        checkEffects();
+        int mod = 0;
+        if (type == Effect::MODTYPE_MULT) mod = 1;
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            mod += (*it)->getMod(target, type, tag);
+        }
+        return mod;
+    }
+
+    CeGuiString EffectManager::getEffects()
+    {
+        CeGuiString retVal = "";
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            retVal += (*it)->getName() + "\n";
+            retVal += (*it)->getDescription() + "\n";
+        }
+        return retVal;
+    }
+
     const Property EffectManager::getProperty(const CeGuiString& key) const
     {
         Property rval;
         if (key == Creature::PROPERTY_EFFECTS)
         {
-            PropertyArray arr;
-            for (Effects::const_iterator it = mEffects.begin(); it != mEffects.end(); it++)
+            PropertyMap map;
+            
+            std::map<Effect*, int> effectIds;
+            PropertyArray effectProps;
+            for (int i = 0, size = mEffects.size(); i < size; ++i)
             {
-                arr.push_back((*it)->getAllProperties()->toPropertyMap());
+                Effect* cur = mEffects[i];
+                effectProps.push_back(cur->getAllProperties()->toPropertyMap());
+                effectIds[cur] = i;
             }
-            rval = Property(arr);
+            
+            PropertyArray timeCheck;
+            for (std::map<RL_LONGLONG, Effects>::const_iterator itTc = mChecklist.begin(); 
+                itTc != mChecklist.end(); ++itTc)
+            {
+                for (Effects::const_iterator itEff = itTc->second.begin(); 
+                    itEff != itTc->second.end(); ++itEff)
+                {
+                    PropertyMap tcElem;
+                    tcElem[EffectManager::PROPERTY_EFFECT] = effectIds[*itEff];
+                    tcElem[EffectManager::PROPERTY_TIME] = itTc->first;
+                    timeCheck.push_back(tcElem);
+                }
+            }
+            
+            map[Creature::PROPERTY_EFFECTS] = effectProps;
+            map[EffectManager::PROPERTY_TIMECHECK] = timeCheck;
+            rval.setValue(map);
         }
         else 
         {
@@ -246,36 +279,50 @@
         {
             if (key == Creature::PROPERTY_EFFECTS)
             {
-                PropertyArray arr = value.toArray();
-                for (PropertyArray::iterator it = arr.begin(); it != arr.end(); it++)
+                PropertyMap map = value.toMap();
+                
+                std::vector<Effect*> effectIds;
+                
+                PropertyArray arr = map[Creature::PROPERTY_EFFECTS].toArray();
+                for (int i = 0, size = arr.size(); i < size; ++i)
                 {
-                    PropertyMap cur = it->toMap();
+                    PropertyMap cur = arr[i].toMap();
                     Ogre::String name = cur[Effect::PROPERTY_NAME].toString().c_str();
                     int stufe = cur[Effect::PROPERTY_STUFE];
                     Effect* eff = EffectFactoryManager::getSingleton().createEffect(name, stufe);
-                    mEffects.insert(eff);
-                    ///@TODO: activate effects
-                }                
+                    eff->setProperties(cur);
+                    mEffects.push_back(eff);
+                    ///@TODO: activate effects?
+                }
+                
+                PropertyArray timeCheckProp = map[EffectManager::PROPERTY_TIMECHECK].toArray();
+                for (int i = 0, size = timeCheckProp.size(); i < size; ++i)
+                {
+                    PropertyMap cur = timeCheckProp[i].toMap();
+                    RL_LONGLONG time = cur[EffectManager::PROPERTY_TIME].toLong();
+                    Effect* eff = mEffects[cur[EffectManager::PROPERTY_EFFECT].toInt()];
+                    mChecklist[time].push_back(eff);
+                }
             }
-            else
-            {
-                LOG_WARNING(Logger::RULES, 
-                    key + " is not a property of EffectManager");
-            }
-        }
-        catch (WrongFormatException ex)
-        {
-            LOG_ERROR(Logger::RULES, 
-                "property " + key + " has the wrong format");
+            else
+            {
+                LOG_WARNING(Logger::RULES, 
+                    key + " is not a property of EffectManager");
+            }
         }
+        catch (WrongFormatException ex)
+        {
+            LOG_ERROR(Logger::RULES, 
+                "property " + key + " has the wrong format");
+        }
     }
 
-    PropertyKeys EffectManager::getAllPropertyKeys() const
-    {
-        PropertyKeys keys;
-        keys.insert(Creature::PROPERTY_EFFECTS);
-        return keys;
-    }
-
-}
-
+    PropertyKeys EffectManager::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        keys.insert(Creature::PROPERTY_EFFECTS);
+        return keys;
+    }
+
+}
+



From blakharaz at mail.berlios.de  Mon Sep 15 21:31:05 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 15 Sep 2008 21:31:05 +0200
Subject: [Dsa-hl-svn] r4509 - rl/trunk/Mac
Message-ID: <200809151931.m8FJV50K022645@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-15 21:31:04 +0200 (Mon, 15 Sep 2008)
New Revision: 4509

Modified:
   rl/trunk/Mac/Info.plist
Log:
Set bundle version to 0.3

Modified: rl/trunk/Mac/Info.plist
===================================================================
--- rl/trunk/Mac/Info.plist	2008-09-15 19:29:55 UTC (rev 4508)
+++ rl/trunk/Mac/Info.plist	2008-09-15 19:31:04 UTC (rev 4509)
@@ -19,7 +19,7 @@
 	<key>CFBundleSignature</key>
 	<string>????</string>
 	<key>CFBundleVersion</key>
-	<string>1.0</string>
+	<string>0.3</string>
 	<key>CSResourcesFileMapped</key>
 	<true/>
 </dict>



From blakharaz at mail.berlios.de  Tue Sep 16 22:19:45 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 16 Sep 2008 22:19:45 +0200
Subject: [Dsa-hl-svn] r4510 - rl/trunk/engine/script/src
Message-ID: <200809162019.m8GKJj57000036@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-16 22:19:44 +0200 (Tue, 16 Sep 2008)
New Revision: 4510

Modified:
   rl/trunk/engine/script/src/EnvironmentProcessor.cpp
   rl/trunk/engine/script/src/ZoneProcessor.cpp
Log:


Modified: rl/trunk/engine/script/src/EnvironmentProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EnvironmentProcessor.cpp	2008-09-15 19:31:04 UTC (rev 4509)
+++ rl/trunk/engine/script/src/EnvironmentProcessor.cpp	2008-09-16 20:19:44 UTC (rev 4510)
@@ -102,7 +102,7 @@
 	{
         if (fogElem)
         {
-		    if (!hasAttribute(fogElem, "material"))
+		    if (!hasAttribute(fogElem, "type"))
 		    {
 			    LOG_ERROR(
 				    Logger::RULES,

Modified: rl/trunk/engine/script/src/ZoneProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/ZoneProcessor.cpp	2008-09-15 19:31:04 UTC (rev 4509)
+++ rl/trunk/engine/script/src/ZoneProcessor.cpp	2008-09-16 20:19:44 UTC (rev 4510)
@@ -1,230 +1,267 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "ZoneProcessor.h"
-
-#include "ActorManager.h"
-#include "RulesConstants.h"
-#include "ScriptSubsystem.h"
-#include "Trigger.h"
-#include "TriggerFactory.h"
-#include "Zone.h"
-#include "ZoneManager.h"
-
-using namespace XERCES_CPP_NAMESPACE;
-using namespace Ogre;
-
-namespace rl
-{
-
-	bool ZoneProcessor::processNode(DOMElement* zonesElem, bool loadGameObjects)
-	{
-		if (zonesElem == NULL)
-		{
-			return false; // no zones
-		}
-
-        for (DOMNode* cur = zonesElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            if (cur->getNodeType() == DOMNode::ELEMENT_NODE
-				&& hasNodeName(cur, "zone"))
-            {
-				DOMElement* curZoneElem = static_cast<DOMElement*>(cur);
-				if (hasAttribute(curZoneElem, "name"))
-				{
-					Ogre::String name = getAttributeValueAsStdString(curZoneElem, "name");
-                    Zone* zone = NULL;
-                    if( name == "default" )
-                        zone = ZoneManager::getSingleton().getDefaultZone();
-                    else
-                    {
-                        // get the zone with that name or create one
-                        zone = ZoneManager::getSingleton().getZone(name);
-                        if( !zone )
-                            zone = ZoneManager::getSingleton().createZone(name, false);
-
-                        // multiple areas
-                        for(DOMNode* curArea = cur->getFirstChild(); curArea != NULL; curArea = curArea->getNextSibling())
-                        {
-                            if( curArea->getNodeType() == DOMNode::ELEMENT_NODE
-                                && hasNodeName(curArea, "area") )
-                            {
-                                DOMElement *curAreaElem = static_cast<DOMElement*>(curArea);
-                                if( hasAttribute(curAreaElem, "type") )
-                                {
-                                    // type
-                                    Ogre::String type;
-                                    type = getAttributeValueAsStdString(curAreaElem, "type");
-
-                                    // add or subtract?
-                                    bool subtract = false;
-                                    if( hasAttribute(curAreaElem, "subtract") )
-                                        subtract = getAttributeValueAsBool(curAreaElem, "subtract");
-
-                                    // position
-                                    Vector3 position = Vector3::ZERO;
-                                    DOMElement* positionElem = getChildNamed(curAreaElem, "position");
-                                    if( positionElem != NULL )
-                                        position = getValueAsVector3(positionElem);
-
-                                    //scale, rotation, offset
-                                    Vector3 scale = Vector3::UNIT_SCALE;
-                                    DOMElement* scaleElem = getChildNamed(curAreaElem, "scale");
-                                    if( scaleElem != NULL )
-                                        scale = getValueAsVector3(scaleElem);
-
-                                    Vector3 offset = Vector3::ZERO;
-                                    DOMElement* offsetElem = getChildNamed(curAreaElem, "offset");
-                                    if( offsetElem != NULL )
-                                        offset = getValueAsVector3(offsetElem);
-
-                                    Quaternion rotation = Quaternion::IDENTITY;
-                                    DOMElement* rotationElem = getChildNamed(curAreaElem, "rotation");
-                                    if( rotationElem != NULL )
-                                        rotation = getValueAsQuaternion(rotationElem);
-
-                                    //transition distance
-                                    Real transitionDistance = 0;
-                                    DOMElement* transitionElem = getChildNamed(curAreaElem, "transition_distance");
-                                    if( transitionElem != NULL )
-                                        transitionDistance = getValueAsReal(transitionElem);
-
-					            
-                                    if (type == "mesh")
-    					            {
-                                        Ogre::String meshName;
-                                        if( hasAttribute(curAreaElem, "meshfile") )
-                                        {
-                                            meshName = getAttributeValueAsStdString(curAreaElem, "meshfile");
-                                            if( subtract )
-                                                ZoneManager::getSingleton().subtractMeshAreaFromZone(name,
-                                                    meshName, GT_CONVEXHULL, position, scale, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
-                                            else
-                                                ZoneManager::getSingleton().addMeshAreaToZone(name,
-                                                    meshName, GT_CONVEXHULL, position, scale, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
-                                        }
-                                        else
-                                            LOG_ERROR(Logger::SCRIPT, "an <area> element with type=\"mesh\" must have attribute 'meshfile'");
-                                    }
-    					            else
-                                    {
-                                        GeometryType geom = GT_NONE;
-                                        if (type == "sphere" )
-                                            geom = GT_SPHERE;
-                                        else if (type == "box" )
-                                            geom = GT_BOX;
-                                        else if (type == "ellipsoid" )
-                                            geom = GT_ELLIPSOID;
-                                        else if (type == "pyramid" )
-                                            geom = GT_PYRAMID;
-                                        else if (type == "capsule" )
-                                            geom = GT_CAPSULE;
-                                        else
-                                        {
-                                            LOG_ERROR(Logger::SCRIPT, "Unknown area type '" + type + "' !");
-                                        }
-                                        if ( geom != GT_NONE )
-                                        {
-                                            Ogre::AxisAlignedBox aabb;
-                                            aabb.setMinimum( - scale / 2.0f);
-                                            aabb.setMaximum( + scale / 2.0f);
-
-                                            if( subtract )
-                                                ZoneManager::getSingleton().subtractAreaFromZone(name,
-                                                    aabb, geom, position, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
-                                            else
-                                                ZoneManager::getSingleton().addAreaToZone(name,
-                                                    aabb, geom, position, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
-                                        }
-                                    }
-                                }
-                                else
-                                {
-                                    LOG_ERROR(Logger::SCRIPT, "<area> elemt must have attribute 'type'");
-                                }
-                            }
-                        }
-                    }
-
-					if (zone != NULL)
-					{
-						for (DOMNode* cur = curZoneElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-						{
-							if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
-							{
-								DOMElement* curElem = static_cast<DOMElement*>(cur);
-								if (hasNodeName(curElem, "light"))
-								{
-									Ogre::String name = getAttributeValueAsStdString(curElem, "name");
-									zone->addLight(ActorManager::getSingleton().getActor(name));
-								}
-								else if (hasNodeName(curElem, "sound"))
-								{
-									Ogre::String name = getAttributeValueAsStdString(curElem, "name");
-									zone->addSound(name);
-								}
-								else if (hasNodeName(curElem, "trigger"))
-								{
-									Ogre::String classname =
-										getAttributeValueAsStdString(curElem, "classname");
-
-									Ogre::String name =
-										getAttributeValueAsStdString(curElem, "name");
-
-									Trigger* trigger = ScriptSubsystem::getSingleton().getTriggerFactory()
-										->createTrigger(classname, name);
-
-                                    // add trigger properties
-                                    for( DOMNode* curProperty = cur->getFirstChild(); curProperty != NULL; curProperty = curProperty->getNextSibling() )
-                                    {
-                                        if( hasNodeName(curProperty, "property") )
-                                        {
-                                            PropertyEntry propEntry = processProperty(static_cast<DOMElement*>(curProperty));
-                                            if (propEntry.first != "")
-                                            {
-                                                trigger->setProperty(propEntry.first, propEntry.second);
-                                            }
-                                        }
-                                    }
-
-                                    zone->addTrigger(trigger);
-								}
-                                else if (hasNodeName(curElem, "eaxpreset"))
-                                {
-									Ogre::String name = getAttributeValueAsStdString(curElem, "name");
-                                    zone->setEaxPreset(name);
-                                }
-							}
-						}
-					}
-					else
-					{
-						LOG_ERROR(Logger::SCRIPT, "Zone named '"+name+"' could not be processes.");
-					}
-				}
-				else
-				{
-					LOG_ERROR(Logger::SCRIPT, "<zone> element must have attribute 'name'.");
-				}
-			}
-		}
-
-        ZoneManager::getSingleton().update();
-		return true;
-	}
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "ZoneProcessor.h"
+
+#include "ActorManager.h"
+#include "RulesConstants.h"
+#include "ScriptSubsystem.h"
+#include "Trigger.h"
+#include "TriggerFactory.h"
+#include "Zone.h"
+#include "ZoneManager.h"
+
+using namespace XERCES_CPP_NAMESPACE;
+using namespace Ogre;
+
+namespace rl
+{
+
+	bool ZoneProcessor::processNode(DOMElement* zonesElem, bool loadGameObjects)
+	{
+		if (zonesElem == NULL)
+		{
+			return false; // no zones
+		}
+
+        for (DOMNode* cur = zonesElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+        {
+            if (cur->getNodeType() == DOMNode::ELEMENT_NODE
+				&& hasNodeName(cur, "zone"))
+            {
+				DOMElement* curZoneElem = static_cast<DOMElement*>(cur);
+				if (hasAttribute(curZoneElem, "name"))
+				{
+					Ogre::String name = getAttributeValueAsStdString(curZoneElem, "name");
+                    Zone* zone = NULL;
+                    if (name == "default")
+                    {
+                        zone = ZoneManager::getSingleton().getDefaultZone();
+                    }
+                    else
+                    {
+                        // get the zone with that name or create one
+                        zone = ZoneManager::getSingleton().getZone(name);
+                        if (!zone)
+                        {
+                            zone = ZoneManager::getSingleton().createZone(name, false);
+                        }
+
+                        // multiple areas
+                        for(DOMNode* curArea = cur->getFirstChild(); curArea != NULL; curArea = curArea->getNextSibling())
+                        {
+                            if (curArea->getNodeType() == DOMNode::ELEMENT_NODE
+                                && hasNodeName(curArea, "area"))
+                            {
+                                DOMElement *curAreaElem = static_cast<DOMElement*>(curArea);
+                                if (hasAttribute(curAreaElem, "type"))
+                                {
+                                    // type
+                                    Ogre::String type;
+                                    type = getAttributeValueAsStdString(curAreaElem, "type");
+
+                                    // add or subtract?
+                                    bool subtract = false;
+                                    if (hasAttribute(curAreaElem, "subtract"))
+                                    {
+                                        subtract = getAttributeValueAsBool(curAreaElem, "subtract");
+                                    }
+
+                                    // position
+                                    Vector3 position = Vector3::ZERO;
+                                    DOMElement* positionElem = getChildNamed(curAreaElem, "position");
+                                    if (positionElem)
+                                    {
+                                        position = getValueAsVector3(positionElem);
+                                    }
+
+                                    //scale, rotation, offset
+                                    Vector3 scale = Vector3::UNIT_SCALE;
+                                    DOMElement* scaleElem = getChildNamed(curAreaElem, "scale");
+                                    if (!scaleElem)
+                                    {
+                                        scaleElem = getChildNamed(curAreaElem, "size");
+                                    }
+                                    
+                                    if (scaleElem)
+                                    {
+                                        scale = getValueAsVector3(scaleElem);
+                                    }
+
+                                    Vector3 offset = Vector3::ZERO;
+                                    DOMElement* offsetElem = getChildNamed(curAreaElem, "offset");
+                                    if (offsetElem)
+                                    {
+                                        offset = getValueAsVector3(offsetElem);
+                                    }
+
+                                    Quaternion rotation = Quaternion::IDENTITY;
+                                    DOMElement* rotationElem = getChildNamed(curAreaElem, "rotation");
+                                    if (rotationElem)
+                                    {
+                                        rotation = getValueAsQuaternion(rotationElem);
+                                    }
+
+                                    //transition distance
+                                    Real transitionDistance = 0;
+                                    DOMElement* transitionElem = getChildNamed(curAreaElem, "transition_distance");
+                                    if (transitionElem)
+                                    {
+                                        transitionDistance = getValueAsReal(transitionElem);
+                                    }
+					            
+                                    if (type == "mesh")
+    					            {
+                                        Ogre::String meshName;
+                                        if (hasAttribute(curAreaElem, "meshfile"))
+                                        {
+                                            meshName = getAttributeValueAsStdString(curAreaElem, "meshfile");
+                                            if (subtract)
+                                            {
+                                                ZoneManager::getSingleton().subtractMeshAreaFromZone(name,
+                                                    meshName, GT_CONVEXHULL, position, scale, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
+                                            }
+                                            else
+                                            {
+                                                ZoneManager::getSingleton().addMeshAreaToZone(name,
+                                                    meshName, GT_CONVEXHULL, position, scale, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
+                                            }
+                                        }
+                                        else
+                                        {
+                                            LOG_ERROR(Logger::SCRIPT, "an <area> element with type=\"mesh\" must have attribute 'meshfile'");
+                                        }
+                                    }
+    					            else
+                                    {
+                                        GeometryType geom = GT_NONE;
+                                        if (type == "sphere")
+                                        {
+                                            geom = GT_SPHERE;
+                                        }
+                                        else if (type == "box")
+                                        {
+                                            geom = GT_BOX;
+                                        }
+                                        else if (type == "ellipsoid")
+                                        {
+                                            geom = GT_ELLIPSOID;
+                                        }
+                                        else if (type == "pyramid")
+                                        {
+                                            geom = GT_PYRAMID;
+                                        }
+                                        else if (type == "capsule")
+                                        {
+                                            geom = GT_CAPSULE;
+                                        }
+                                        else
+                                        {
+                                            LOG_ERROR(Logger::SCRIPT, "Unknown area type '" + type + "' !");
+                                        }
+                                        
+                                        if ( geom != GT_NONE)
+                                        {
+                                            Ogre::AxisAlignedBox aabb;
+                                            aabb.setMinimum( - scale / 2.0f);
+                                            aabb.setMaximum( + scale / 2.0f);
+
+                                            if (subtract)
+                                                ZoneManager::getSingleton().subtractAreaFromZone(name,
+                                                    aabb, geom, position, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
+                                            else
+                                                ZoneManager::getSingleton().addAreaToZone(name,
+                                                    aabb, geom, position, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
+                                        }
+                                    }
+                                }
+                                else
+                                {
+                                    LOG_ERROR(Logger::SCRIPT, "<area> elemt must have attribute 'type'");
+                                }
+                            }
+                        }
+                    }
+
+					if (zone)
+					{
+						for (DOMNode* cur = curZoneElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+						{
+							if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
+							{
+								DOMElement* curElem = static_cast<DOMElement*>(cur);
+								if (hasNodeName(curElem, "light"))
+								{
+									Ogre::String name = getAttributeValueAsStdString(curElem, "name");
+									zone->addLight(ActorManager::getSingleton().getActor(name));
+								}
+								else if (hasNodeName(curElem, "sound"))
+								{
+									Ogre::String name = getAttributeValueAsStdString(curElem, "name");
+									zone->addSound(name);
+								}
+								else if (hasNodeName(curElem, "trigger"))
+								{
+									Ogre::String classname =
+										getAttributeValueAsStdString(curElem, "classname");
+
+									Ogre::String name =
+										getAttributeValueAsStdString(curElem, "name");
+
+									Trigger* trigger = ScriptSubsystem::getSingleton().getTriggerFactory()
+										->createTrigger(classname, name);
+
+                                    // add trigger properties
+                                    for( DOMNode* curProperty = cur->getFirstChild(); curProperty != NULL; curProperty = curProperty->getNextSibling())
+                                    {
+                                        if (hasNodeName(curProperty, "property"))
+                                        {
+                                            PropertyEntry propEntry = processProperty(static_cast<DOMElement*>(curProperty));
+                                            if (propEntry.first != "")
+                                            {
+                                                trigger->setProperty(propEntry.first, propEntry.second);
+                                            }
+                                        }
+                                    }
+
+                                    zone->addTrigger(trigger);
+								}
+                                else if (hasNodeName(curElem, "eaxpreset"))
+                                {
+									Ogre::String name = getAttributeValueAsStdString(curElem, "name");
+                                    zone->setEaxPreset(name);
+                                }
+							}
+						}
+					}
+					else
+					{
+						LOG_ERROR(Logger::SCRIPT, "Zone named '"+name+"' could not be processes.");
+					}
+				}
+				else
+				{
+					LOG_ERROR(Logger::SCRIPT, "<zone> element must have attribute 'name'.");
+				}
+			}
+		}
+
+        ZoneManager::getSingleton().update();
+		return true;
+	}
+
+}



From blakharaz at mail.berlios.de  Thu Sep 18 00:24:32 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 18 Sep 2008 00:24:32 +0200
Subject: [Dsa-hl-svn] r4511 - in rl/trunk/engine: rules/include rules/src
	script/src script/swig ui/include ui/src
Message-ID: <200809172224.m8HMOWl7011796@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-18 00:24:26 +0200 (Thu, 18 Sep 2008)
New Revision: 4511

Added:
   rl/trunk/engine/rules/include/PartyManager.h
   rl/trunk/engine/rules/src/PartyManager.cpp
Modified:
   rl/trunk/engine/rules/include/RulesMessages.h
   rl/trunk/engine/rules/include/RulesSubsystem.h
   rl/trunk/engine/rules/src/RulesSubsystem.cpp
   rl/trunk/engine/script/src/SceneManager.cpp
   rl/trunk/engine/script/swig/RlRules.head.swig
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/script/swig/RlUi.swig
   rl/trunk/engine/ui/include/UiMessages.h
   rl/trunk/engine/ui/include/UiSubsystem.h
   rl/trunk/engine/ui/include/WindowFactory.h
   rl/trunk/engine/ui/src/DebugWindow.cpp
   rl/trunk/engine/ui/src/InputManager.cpp
   rl/trunk/engine/ui/src/UiSubsystem.cpp
   rl/trunk/engine/ui/src/WindowFactory.cpp
Log:
Moved current character to PartyManager class, started work on game over if all chars are dead

Added: rl/trunk/engine/rules/include/PartyManager.h
===================================================================
--- rl/trunk/engine/rules/include/PartyManager.h	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/rules/include/PartyManager.h	2008-09-17 22:24:26 UTC (rev 4511)
@@ -0,0 +1,52 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#ifndef __PartyManager_H__
+#define __PartyManager_H__
+
+#include "RulesPrerequisites.h"
+
+#include "Effect.h"
+#include "MessagePump.h"
+
+namespace rl
+{
+    class Creature;
+
+    class _RlRulesExport PartyManager : public Ogre::Singleton<PartyManager>
+    {
+    public:
+        PartyManager();
+        
+        Creature* getActiveCharacter() const;
+        void setActiveCharacter(Creature* character);
+        void addCharacter(Creature* character);
+        void removeCharacter(Creature* character);
+        std::vector<Creature*> getCharacters() const;
+        bool isInParty(Creature* creature) const;
+        
+    private:
+        std::vector<Creature*> mParty;
+        Creature* mActiveCharacter;
+	    MessagePump::ScopedConnection mLifeStateChangeConnection;
+
+        bool onGameObjectLifeStateChanged(GameObject* gameobject, Effect::LifeState oldstate,
+            Effect::LifeState newstate);
+            
+        void checkParty();
+   };
+}
+
+#endif // __PartyManager_H__

Modified: rl/trunk/engine/rules/include/RulesMessages.h
===================================================================
--- rl/trunk/engine/rules/include/RulesMessages.h	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/rules/include/RulesMessages.h	2008-09-17 22:24:26 UTC (rev 4511)
@@ -1,75 +1,101 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __Rl_RulesMessages_H__
-#define __Rl_RulesMessages_H__
-
-#include "RulesPrerequisites.h"
-
-#include "MessageType.h"
-#include "RulesConstants.h"
-#include "CoreMessages.h"
-#include "Effect.h"
-
-namespace rl
-{
-	class Combatant;
-	class GameObject;
-
-	/// 0x03xxxxxx as mask for rules messages
-    enum RulesMessageTypeIds
-    {
-        // Game event log //
-        // Mask
-        RLMSG_GAMEEVENTLOG_EVENTS = 0x03000100,
-        // Events
-        RLMSG_GAMEEVENTLOG_EVENT_ADDED = 0x03000101,
-
-		// Combat
-		// Mask
-		RLMSG_COMBAT_EVENTS = 0x03000200,
-		// Events
-		RLMSG_COMBAT_OPPONENT_ENTERED = 0x03000201,
-		RLMSG_COMBAT_OPPONENT_LEFT = 0x03000202,
-		RLMSG_COMBAT_ENDED = 0x03000210,
-
-		// Game object related events
-        // Mask
-        RLMSG_GAMEOBJECT_EVENTS = 0x03000300,
-        // Events
-        RLMSG_GAMEOBJECT_LIFESTATE_CHANGED = 0x03000301
-    };
-
-    /// Message sent right after a new game log event has been added.
-	typedef MessageType<RLMSG_GAMEEVENTLOG_EVENT_ADDED, GameEventType, CeGuiString>
-		MessageType_GameEventLog_EventAdded;
-
-	typedef MessageType<RLMSG_COMBAT_OPPONENT_ENTERED, Combatant*>
-		MessageType_CombatOpponentEntered;
-
-	typedef MessageType<RLMSG_COMBAT_OPPONENT_LEFT, Combatant*>
-		MessageType_CombatOpponentLeft;
-
-    typedef MessageType<RLMSG_COMBAT_ENDED, bool>
-		MessageType_CombatEnded;
-
-    typedef MessageType<RLMSG_GAMEOBJECT_LIFESTATE_CHANGED, GameObject*, Effect::LifeState, Effect::LifeState>
-		MessageType_GameObjectLifeStateChanged;
-    
-    typedef MessageType<RLMSG_SAVEGAME_GOS_LOADED> MessageType_GameObjectsLoaded;
-
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __Rl_RulesMessages_H__
+#define __Rl_RulesMessages_H__
+
+#include "RulesPrerequisites.h"
+
+#include "MessageType.h"
+#include "RulesConstants.h"
+#include "CoreMessages.h"
+#include "Effect.h"
+
+namespace rl
+{
+	class Combatant;
+    class Creature;
+	class GameObject;
+
+	/// 0x03xxxxxx as mask for rules messages
+    enum RulesMessageTypeIds
+    {
+        // Game event log //
+        // Mask
+        RLMSG_GAMEEVENTLOG_EVENTS = 0x03000100,
+        // Events
+        RLMSG_GAMEEVENTLOG_EVENT_ADDED = 0x03000101,
+
+		// Combat
+		// Mask
+		RLMSG_COMBAT_EVENTS = 0x03000200,
+		// Events
+		RLMSG_COMBAT_OPPONENT_ENTERED = 0x03000201,
+		RLMSG_COMBAT_OPPONENT_LEFT = 0x03000202,
+		RLMSG_COMBAT_ENDED = 0x03000210,
+
+		// Game object related events
+        // Mask
+        RLMSG_GAMEOBJECT_EVENTS = 0x03000300,
+        // Events
+        RLMSG_GAMEOBJECT_LIFESTATE_CHANGED = 0x03000301,
+        
+        // Player character related events
+        // Mask
+        RLMSG_PLAYERCHAR_EVENTS = 0x03000400,
+        // Events
+        RLMSG_PLAYERCHAR_DIED = 0x03000401,
+        RLMSG_PLAYERCHAR_ALL_DIED = 0x03000402,
+        RLMSG_PLAYERCHAR_ADDED = 0x03000403,
+        RLMSG_PLAYERCHAR_REMOVED = 0x03000404,
+        RLMSG_PLAYERCHAR_ACTIVE_CHANGED = 0x03000405        
+    };
+
+    /// Message sent right after a new game log event has been added.
+	typedef MessageType<RLMSG_GAMEEVENTLOG_EVENT_ADDED, GameEventType, CeGuiString>
+		MessageType_GameEventLog_EventAdded;
+
+	typedef MessageType<RLMSG_COMBAT_OPPONENT_ENTERED, Combatant*>
+		MessageType_CombatOpponentEntered;
+
+	typedef MessageType<RLMSG_COMBAT_OPPONENT_LEFT, Combatant*>
+		MessageType_CombatOpponentLeft;
+
+    typedef MessageType<RLMSG_COMBAT_ENDED, bool>
+		MessageType_CombatEnded;
+
+    typedef MessageType<RLMSG_GAMEOBJECT_LIFESTATE_CHANGED, GameObject*, Effect::LifeState, Effect::LifeState>
+		MessageType_GameObjectLifeStateChanged;
+    
+    typedef MessageType<RLMSG_SAVEGAME_GOS_LOADED> MessageType_GameObjectsLoaded;
+    
+    typedef MessageType<RLMSG_PLAYERCHAR_DIED, Creature*>
+        MessageType_PlayerCharDied;
+
+    typedef MessageType<RLMSG_PLAYERCHAR_ADDED, Creature*>
+        MessageType_PlayerCharAdded;
+
+    typedef MessageType<RLMSG_PLAYERCHAR_REMOVED, Creature*>
+        MessageType_PlayerCharRemoved;
+
+    typedef MessageType<RLMSG_PLAYERCHAR_ACTIVE_CHANGED, Creature*, Creature*>
+        MessageType_ActivePlayerCharChanged;
+
+    typedef MessageType<RLMSG_PLAYERCHAR_ALL_DIED>
+        MessageType_AllPlayerCharsDied;
+
+}
+#endif

Modified: rl/trunk/engine/rules/include/RulesSubsystem.h
===================================================================
--- rl/trunk/engine/rules/include/RulesSubsystem.h	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/rules/include/RulesSubsystem.h	2008-09-17 22:24:26 UTC (rev 4511)
@@ -31,6 +31,7 @@
 	class GameEventLog;
     class GlobalProperties;
 	class QuestBook;
+    class PartyManager;
     class XdimlLoader;
 
 	class _RlRulesExport RulesSubsystem : public Ogre::Singleton<RulesSubsystem>
@@ -52,6 +53,7 @@
         XdimlLoader* mXdimlLoader;
         GlobalProperties* mGlobalProperties;
         EffectManagementTask* mEffectManagementTask;
+        PartyManager* mPartyManager;
     };
 }
 

Added: rl/trunk/engine/rules/src/PartyManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/PartyManager.cpp	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/rules/src/PartyManager.cpp	2008-09-17 22:24:26 UTC (rev 4511)
@@ -0,0 +1,140 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h"
+
+#include "PartyManager.h"
+
+#include <boost/bind.hpp>
+
+#include "Creature.h"
+#include "RulesMessages.h"
+
+template <>
+rl::PartyManager* Ogre::Singleton<rl::PartyManager>::ms_Singleton = 0;
+
+namespace rl
+{
+    
+    PartyManager::PartyManager()
+    {
+        ///@todo watch characters for death, trigger game over if no-one is left
+        mLifeStateChangeConnection =
+            MessagePump::getSingleton().addMessageHandler<MessageType_GameObjectLifeStateChanged>(
+                boost::bind(&PartyManager::onGameObjectLifeStateChanged, this, _1, _2, _3));
+    }
+    
+    void PartyManager::addCharacter(Creature* character)
+    {
+        mParty.push_back(character);
+        ///@todo send message
+        
+        if (mActiveCharacter == NULL)
+        {
+            setActiveCharacter(character);
+        }
+    }
+    
+    void PartyManager::removeCharacter(Creature* character)
+    {
+        for (std::vector<Creature*>::iterator it = mParty.begin();
+             it != mParty.end(); ++it)
+        {
+            if (*it == character)
+            {
+                ///@todo send message
+                mParty.erase(it);
+                break;
+            }
+        }
+        checkParty();
+    }
+    
+    void PartyManager::setActiveCharacter(Creature* character)
+    {
+        if (!isInParty(character))
+        {
+            addCharacter(character);
+        }
+        if (mActiveCharacter != character)
+        {
+            Creature* oldActiveChar = mActiveCharacter;
+            mActiveCharacter = character;
+            MessagePump::getSingleton().sendMessage<MessageType_ActivePlayerCharChanged>(
+                oldActiveChar, mActiveCharacter);
+        }        
+    }
+    
+    Creature* PartyManager::getActiveCharacter() const
+    {
+        return mActiveCharacter;
+    }
+    
+    std::vector<Creature*> PartyManager::getCharacters() const
+    {
+        return mParty;
+    }
+    
+    bool PartyManager::isInParty(Creature* creature) const
+    {
+        for (int i = 0; i < mParty.size(); ++i)
+        {
+            if (mParty[i] == creature)
+            {
+                return true;
+            }
+        }
+        
+        return false;
+    }
+    
+    bool PartyManager::onGameObjectLifeStateChanged(GameObject* gameobject, 
+        Effect::LifeState oldstate, Effect::LifeState newstate)
+    {
+        LOG_DEBUG("PartyManager", "Someone changed state.");
+        if (0 != (newstate & Effect::LS_DEAD|Effect::LS_UNCONSCIOUS|Effect::LS_INCAPACITATED))
+        {
+            LOG_DEBUG("PartyManager", "Someone died or was rendered unconscious.");
+            Creature* crea = dynamic_cast<Creature*>(gameobject);
+            if (crea && isInParty(crea))
+            {
+                checkParty();
+            }
+        }
+        
+        return false;
+    }
+    
+    void PartyManager::checkParty()
+    {   
+        int alive = 0;
+        for (std::vector<Creature*>::iterator it = mParty.begin();
+             it != mParty.end(); ++it)
+        {
+            Creature* cur = *it;
+            if (!(cur->getLifeState() & Effect::LS_DEAD|Effect::LS_UNCONSCIOUS|Effect::LS_INCAPACITATED))
+            {
+                alive++;
+            }
+        }
+        
+        if (alive == 0)
+        {
+            MessagePump::getSingleton().sendMessage<MessageType_AllPlayerCharsDied>();
+        }
+    }
+    
+    
+}

Modified: rl/trunk/engine/rules/src/RulesSubsystem.cpp
===================================================================
--- rl/trunk/engine/rules/src/RulesSubsystem.cpp	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/rules/src/RulesSubsystem.cpp	2008-09-17 22:24:26 UTC (rev 4511)
@@ -1,116 +1,125 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "RulesSubsystem.h"
-#include "ActionManager.h"
-#include "CombatManager.h"
-#include "DsaManager.h"
-#include "DsaDataLoader.h"
-#include "EffectFactory.h"
-#include "EffectManagementTask.h"
-#include "GameEventLog.h"
-#include "GameLoop.h"
-#include "Logger.h"
-#include "CreatureControllerManager.h"
-#include "GameObjectManager.h"
-#include "QuestBook.h"
-#include "GameTimeSource.h"
-#include "GlobalProperties.h"
-#include <ConfigurationManager.h>
-
-template <>
-rl::RulesSubsystem* Singleton<rl::RulesSubsystem>::ms_Singleton = 0;
-namespace rl
-{
-    RulesSubsystem::RulesSubsystem()
-		: mQuestBook(NULL),
-        mActionManager(NULL),
-        mCombatManager(NULL),
-        mDsaManager(NULL),
-		mGameEventLog(NULL),
-        mMovingCreatureManager(NULL),
-        mXdimlLoader(NULL),
-        mGlobalProperties(NULL),
-        mEffectManagementTask(NULL)
-    {
-		LOG_MESSAGE(Logger::RULES, "Start");
-        //Zufallsgenerator initialisieren
-        srand(static_cast<unsigned int>(time(NULL)));
-
-        TimeSourceManager::getSingleton().registerTimeSource(
-            new GameTimeSource());
-
-        //Singletons erzeugen
-        mActionManager = new ActionManager();
-		LOG_MESSAGE(Logger::RULES, "ActionManager erzeugt");
-        mCombatManager = new CombatManager();
-		LOG_MESSAGE(Logger::RULES, "CombatManager erzeugt");
-        mDsaManager = new DsaManager();
-		LOG_MESSAGE(Logger::RULES, "DsaManager erzeugt");
-        mGameEventLog = new GameEventLog();
-		LOG_MESSAGE(Logger::RULES, "GameEventLog erzeugt");
-        mMovingCreatureManager = new CreatureControllerManager();
-		LOG_MESSAGE(Logger::RULES, "CreatureControllerManager erzeugt");
-		resetQuestBook();
-		LOG_MESSAGE(Logger::RULES, "Questverwaltung erzeugt");
-        mGlobalProperties = new GlobalProperties();
-
-        mEffectManagementTask = new EffectManagementTask();
-        GameLoop::getSingleton().addTask(
-            mEffectManagementTask, GameLoop::TG_LOGIC);
-
-		//Daten laden
-		mXdimlLoader = new XdimlLoader();
-		LOG_MESSAGE(Logger::RULES, "Basisdaten geladen");
-
-        new EffectFactoryManager();
-        new GameObjectManager();
-		LOG_MESSAGE(Logger::RULES, "Erzeugen abgeschlossen");
-    }
-
-	RulesSubsystem::~RulesSubsystem()
-    {
-        GameLoop::getSingleton().removeTask(mEffectManagementTask);
-        delete mEffectManagementTask;
-        delete mGlobalProperties;
-        if(mQuestBook)
-            Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(mQuestBook);
-        delete mQuestBook;
-		delete mGameEventLog;
-        delete mDsaManager;
-        delete mCombatManager;
-        delete mActionManager;
-        delete mXdimlLoader;
-        delete GameObjectManager::getSingletonPtr();
-        delete mMovingCreatureManager; // this manager should be deleted after the GameObjectManager
-        delete EffectFactoryManager::getSingletonPtr();
-    }
-
-	QuestBook* RulesSubsystem::getQuestBook()
-	{
-		return mQuestBook;
-	}
-
-	void RulesSubsystem::resetQuestBook()
-	{
-        if(mQuestBook)
-            Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(mQuestBook);
-		delete mQuestBook;
-		mQuestBook = new QuestBook();
-        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(mQuestBook);
-	}
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include "RulesSubsystem.h"
+
+#include "ActionManager.h"
+#include "CombatManager.h"
+#include "ConfigurationManager.h"
+#include "CreatureControllerManager.h"
+#include "DsaManager.h"
+#include "DsaDataLoader.h"
+#include "EffectFactory.h"
+#include "EffectManagementTask.h"
+#include "GameEventLog.h"
+#include "GameLoop.h"
+#include "GameObjectManager.h"
+#include "GameTimeSource.h"
+#include "GlobalProperties.h"
+#include "Logger.h"
+#include "PartyManager.h"
+#include "QuestBook.h"
+
+template <>
+rl::RulesSubsystem* Singleton<rl::RulesSubsystem>::ms_Singleton = 0;
+namespace rl
+{
+    RulesSubsystem::RulesSubsystem()
+		: mQuestBook(NULL),
+        mActionManager(NULL),
+        mCombatManager(NULL),
+        mDsaManager(NULL),
+		mGameEventLog(NULL),
+        mMovingCreatureManager(NULL),
+        mXdimlLoader(NULL),
+        mGlobalProperties(NULL),
+        mEffectManagementTask(NULL)
+    {
+		LOG_MESSAGE(Logger::RULES, "Start");
+        //Zufallsgenerator initialisieren
+        srand(static_cast<unsigned int>(time(NULL)));
+
+        TimeSourceManager::getSingleton().registerTimeSource(
+            new GameTimeSource());
+
+        //Singletons erzeugen
+        mActionManager = new ActionManager();
+		LOG_MESSAGE(Logger::RULES, "ActionManager erzeugt");
+        mCombatManager = new CombatManager();
+		LOG_MESSAGE(Logger::RULES, "CombatManager erzeugt");
+        mDsaManager = new DsaManager();
+		LOG_MESSAGE(Logger::RULES, "DsaManager erzeugt");
+        mGameEventLog = new GameEventLog();
+		LOG_MESSAGE(Logger::RULES, "GameEventLog erzeugt");
+        mMovingCreatureManager = new CreatureControllerManager();
+		LOG_MESSAGE(Logger::RULES, "CreatureControllerManager erzeugt");
+		resetQuestBook();
+		LOG_MESSAGE(Logger::RULES, "Questverwaltung erzeugt");
+        mGlobalProperties = new GlobalProperties();
+
+        mEffectManagementTask = new EffectManagementTask();
+        GameLoop::getSingleton().addTask(
+            mEffectManagementTask, GameLoop::TG_LOGIC);
+
+		//Daten laden
+		mXdimlLoader = new XdimlLoader();
+		LOG_MESSAGE(Logger::RULES, "Basisdaten geladen");
+
+        new EffectFactoryManager();
+        new GameObjectManager();
+        
+        mPartyManager = new PartyManager();
+		LOG_MESSAGE(Logger::RULES, "Erzeugen abgeschlossen");
+    }
+
+	RulesSubsystem::~RulesSubsystem()
+    {
+        delete mPartyManager;
+        GameLoop::getSingleton().removeTask(mEffectManagementTask);
+        delete mEffectManagementTask;
+        delete mGlobalProperties;
+        if (mQuestBook)
+        {
+            Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(mQuestBook);
+        }
+        delete mQuestBook;
+		delete mGameEventLog;
+        delete mDsaManager;
+        delete mCombatManager;
+        delete mActionManager;
+        delete mXdimlLoader;
+        delete GameObjectManager::getSingletonPtr();
+        delete mMovingCreatureManager; // this manager should be deleted after the GameObjectManager
+        delete EffectFactoryManager::getSingletonPtr();
+    }
+
+	QuestBook* RulesSubsystem::getQuestBook()
+	{
+		return mQuestBook;
+	}
+
+	void RulesSubsystem::resetQuestBook()
+	{
+        if (mQuestBook)
+        {
+            Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(mQuestBook);
+        }
+		delete mQuestBook;
+		mQuestBook = new QuestBook();
+        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(mQuestBook);
+	}
+}

Modified: rl/trunk/engine/script/src/SceneManager.cpp
===================================================================
--- rl/trunk/engine/script/src/SceneManager.cpp	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/script/src/SceneManager.cpp	2008-09-17 22:24:26 UTC (rev 4511)
@@ -1,124 +1,124 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#include "stdinc.h" //precompiled header
-
-#include "SceneManager.h"
-
-#include "Creature.h"
-#include "CreatureControllerManager.h"
-#include "Scene.h"
-#include "SceneLoader.h"
-#include "UiSubsystem.h"
-
-template<> rl::SceneManager* Ogre::Singleton<rl::SceneManager>::ms_Singleton = NULL;
-
-namespace rl 
-{
-
-    SceneManager::SceneManager()
-        : Ogre::Singleton<SceneManager>(),
-          Ogre::ScriptLoader(),
-          mCurrentScene(NULL)
-    {
-        mScriptPatterns.push_back("*.rlscene");
-        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
-    }
-
-    SceneManager::~SceneManager()
-    {
-        Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(this);
-        for (std::map<CeGuiString, Scene*>::iterator it = mScenes.begin();
-            it != mScenes.end(); ++it)
-        {
-            delete it->second;
-        }
-    }
-
-    void SceneManager::addScene(Scene* scene) 
-    {
-        mScenes[scene->getName()] = scene;
-    }
-
-    void SceneManager::loadScene(const CeGuiString& sceneName, bool saveCurrent)
-    {
-        if (mCurrentScene && sceneName == mCurrentScene->getName())
-        {
-            return;
-        }
-
-        Creature* activeChar = UiSubsystem::getSingleton().getActiveCharacter();
-
-        if (activeChar) {
-            CreatureControllerManager::getSingleton().detachController(
-                activeChar);
-            activeChar->setState(GOS_LOADED);
-        }
-
-        if (saveCurrent) 
-        {
-            mSceneStates[mCurrentScene] = mCurrentScene->getAllProperties();
-        }
-
-        std::map<CeGuiString, Scene*>::iterator itScene = mScenes.find(sceneName);
-        if (itScene != mScenes.end())
-        {            
-            std::map<Scene*, PropertyRecordPtr>::iterator itState =
-                mSceneStates.end();
-            if (saveCurrent) 
-            {
-                std::map<Scene*, PropertyRecordPtr>::iterator itState 
-                    = mSceneStates.find(mCurrentScene);
-            }
-
-            itScene->second->load(itState != mSceneStates.end()); // don't load game objects if there is a saved state
-            mCurrentScene = itScene->second;
-            
-            if (itState != mSceneStates.end())
-            {
-                mCurrentScene->setProperties(itState->second);
-            }
-        }
-        else
-        {
-            LOG_ERROR("SceneManager", 
-                "Scene '" + sceneName + "' not found. Have you forgotten to define it in a .rlscene file?");
-        }
-
-        if (activeChar) 
-        {
-            UiSubsystem::getSingleton().setActiveCharacter(activeChar);
-        }
-    }
-
-    const Ogre::StringVector& SceneManager::getScriptPatterns() const
-    {
-        return mScriptPatterns;
-    }
-
-    void SceneManager::parseScript(Ogre::DataStreamPtr& data, const Ogre::String& resourceGroup)
-    {
-        SceneLoader* loader = new SceneLoader();
-        addScene(loader->loadScene(data));
-        delete loader;
-    }
-
-    Ogre::Real SceneManager::getLoadingOrder() const
-    {
-        return 1000;
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "stdinc.h" //precompiled header
+
+#include "SceneManager.h"
+
+#include "Creature.h"
+#include "CreatureControllerManager.h"
+#include "PartyManager.h"
+#include "Scene.h"
+#include "SceneLoader.h"
+
+template<> rl::SceneManager* Ogre::Singleton<rl::SceneManager>::ms_Singleton = NULL;
+
+namespace rl 
+{
+
+    SceneManager::SceneManager()
+        : Ogre::Singleton<SceneManager>(),
+          Ogre::ScriptLoader(),
+          mCurrentScene(NULL)
+    {
+        mScriptPatterns.push_back("*.rlscene");
+        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
+    }
+
+    SceneManager::~SceneManager()
+    {
+        Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(this);
+        for (std::map<CeGuiString, Scene*>::iterator it = mScenes.begin();
+            it != mScenes.end(); ++it)
+        {
+            delete it->second;
+        }
+    }
+
+    void SceneManager::addScene(Scene* scene) 
+    {
+        mScenes[scene->getName()] = scene;
+    }
+
+    void SceneManager::loadScene(const CeGuiString& sceneName, bool saveCurrent)
+    {
+        if (mCurrentScene && sceneName == mCurrentScene->getName())
+        {
+            return;
+        }
+
+        Creature* activeChar = PartyManager::getSingleton().getActiveCharacter();
+
+        if (activeChar) {
+            CreatureControllerManager::getSingleton().detachController(
+                activeChar);
+            activeChar->setState(GOS_LOADED);
+        }
+
+        if (saveCurrent) 
+        {
+            mSceneStates[mCurrentScene] = mCurrentScene->getAllProperties();
+        }
+
+        std::map<CeGuiString, Scene*>::iterator itScene = mScenes.find(sceneName);
+        if (itScene != mScenes.end())
+        {            
+            std::map<Scene*, PropertyRecordPtr>::iterator itState =
+                mSceneStates.end();
+            if (saveCurrent) 
+            {
+                std::map<Scene*, PropertyRecordPtr>::iterator itState 
+                    = mSceneStates.find(mCurrentScene);
+            }
+
+            itScene->second->load(itState != mSceneStates.end()); // don't load game objects if there is a saved state
+            mCurrentScene = itScene->second;
+            
+            if (itState != mSceneStates.end())
+            {
+                mCurrentScene->setProperties(itState->second);
+            }
+        }
+        else
+        {
+            LOG_ERROR("SceneManager", 
+                "Scene '" + sceneName + "' not found. Have you forgotten to define it in a .rlscene file?");
+        }
+
+        if (activeChar) 
+        {
+            PartyManager::getSingleton().setActiveCharacter(activeChar);
+        }
+    }
+
+    const Ogre::StringVector& SceneManager::getScriptPatterns() const
+    {
+        return mScriptPatterns;
+    }
+
+    void SceneManager::parseScript(Ogre::DataStreamPtr& data, const Ogre::String& resourceGroup)
+    {
+        SceneLoader* loader = new SceneLoader();
+        addScene(loader->loadScene(data));
+        delete loader;
+    }
+
+    Ogre::Real SceneManager::getLoadingOrder() const
+    {
+        return 1000;
+    }
+
+}

Modified: rl/trunk/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.swig	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/script/swig/RlRules.head.swig	2008-09-17 22:24:26 UTC (rev 4511)
@@ -41,6 +41,7 @@
 #include "ObjectStateChangeEventSource.h"
 #include "ObjectStateChangeEvent.h"
 #include "ObjectStateChangeListener.h"
+#include "PartyManager.h"
 #include "Quest.h"
 #include "QuestBook.h"
 #include "QuestEvent.h"

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/script/swig/RlRules.swig	2008-09-17 22:24:26 UTC (rev 4511)
@@ -1,952 +1,962 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-//%template(GameObjectVector) std::vector< rl::GameObject* >;
-
-namespace rl {
-
-    // Before first use of GameObject or subclasses!
-    %apply SWIGTYPE *DYNAMIC { rl::GameObject * };
-
-                    
-   template<typename T>
-   class Tripel {
-   public:
-      T first;
-      T second;
-      T third;
-
-      Tripel();      
-      Tripel(const T& t1, const T& t2, const T& t3);
-      Tripel(const Tripel& rhs);
-
-      //Tripel& operator=(const Tripel& rhs);
-      bool operator==(const Tripel& rhs);
-      bool operator<(const Tripel& rhs);     
-   };
-    
-    class Date {
-    public:
-        static const RL_LONGLONG ONE_SECOND = 1000ULL;
-        static const RL_LONGLONG ONE_MINUTE = 60000ULL;
-        static const RL_LONGLONG ONE_HOUR = 3600000ULL;
-        static const RL_LONGLONG ONE_DAY = 86400000ULL;
-        static const RL_LONGLONG ONE_WEEK = 604800000ULL;
-        static const RL_LONGLONG ONE_MONTH = 2592000000ULL;
-        static const RL_LONGLONG ONE_YEAR = 31536000000ULL;
-        static const RL_LONGLONG ONE_KAMPFRUNDE = 2 * ONE_SECOND;
-        static const RL_LONGLONG ONE_SPIELRUNDE = 5 * ONE_MINUTE;
-
-        Date();
-        Date(RL_LONGLONG timestamp);
-        Date(const Date& rhs);
-      
-        bool operator==(const Date& rhs);
-        bool operator<(const Date& rhs);
-        bool operator<=(const Date& rhs);
-        bool operator>=(const Date& rhs);
-        bool operator>(const Date& rhs);
-
-        Date operator+(const RL_LONGLONG& rhs);
-        Date operator-(const RL_LONGLONG& rhs);
-        Date operator*(const Ogre::Real& rhs);
-        Date operator/(const Ogre::Real& rhs);
-        RL_LONGLONG operator-(const Date& rhs);
-      
-        RL_LONGLONG getTimestamp();
-
-        int getTimeFraction();
-        int getYear();
-        int getMonth();
-        rl::CeGuiString getMonthName();
-        int getDayOfYear();
-        int getDayOfMonth();
-        int getDayOfWeek();
-        rl::CeGuiString getDayOfWeekName();
-        int getHour();
-        int getMinute();
-        int getSecond();
-        int getMilliSecond();
-      
-        rl::CeGuiString toString();
-    };
-   
-    Date operator+(const RL_LONGLONG&, const Date&);
-    Date operator-(const RL_LONGLONG&, const Date&);
-
-    class RulesSubsystem 
-    {
-        public:
-             static rl::RulesSubsystem& getSingleton();
-             rl::QuestBook* getQuestBook();
-             void resetQuestBook();
-    };
-  
-    class DsaManager {
-    public:
-        RL_LONGLONG getTimestamp();
-        Date getCurrentDate();
-        void setCurrentDate(const Date& date);
-        
-        int rollD20();
-        Tripel<int> roll3D20();
-        int rollD6();
-        int roll(int d6, int d20);
-      
-        static DsaManager& getSingleton();
-        rl::Talent* getTalent(const rl::CeGuiString name) const;
-        rl::Creature* getCreature(const int id) const;
-    };
-    
-    %feature("director") GameObjectFactory; 
-    class GameObjectFactory
-    {
-    public:
-        virtual rl::GameObject* createRubyGameObject(const Ogre::String& classname, unsigned int id) = 0;
-        GameObjectFactory();
-        virtual ~GameObjectFactory();
-    };
-
-    class GameObjectManager
-    {
-    public:
-        static rl::GameObjectManager& getSingleton();
-        rl::GameObject* createGameObject(const Ogre::String& classId, unsigned int id = 0);
-        rl::GameObject* getGameObject(unsigned int id) const;
-        void setGameObjectFactory(rl::GameObjectFactory* gof);
-
-    private:
-        GameObjectManager();
-    };
-
-	enum GameEventType
-	{
-		GET_DEFAULT,
-		GET_COMBAT,
-		GET_DIALOG,
-		GET_QUEST
-	};
-	
-    class GameEventLog
-    {
-    public:
-        static rl::GameEventLog& getSingleton();
-		void logEvent(const Ogre::String& eventString, GameEventType type);
-
-    private:
-        GameEventLog();
-    };
-    
-    class GlobalProperties 
-    {
-    public:
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        bool hasProperty(const Ogre::String& key) const;
-        
-        static rl::GlobalProperties& getSingleton();
-    private:
-        GlobalProperties();
-    };
-
-    %feature("director") QuestListener; 
-    class QuestListener
-    {
-    public:
-        virtual ~QuestListener();
-        
-        virtual void questStateChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questPartsDoneChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questKnownChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questSubquestAdded(rl::QuestEvent* anEvent) = 0;
-        virtual void journalEntryAdded(rl::JournalEvent* anEvent) = 0;
-        virtual void journalEntryDeleted(rl::JournalEvent* anEvent) = 0;
-    };
-
-    class JournalEntry
-    {
-    public:
-        JournalEntry(const rl::CeGuiString caption, const rl::CeGuiString text);
-        virtual ~JournalEntry();
-
-        rl::CeGuiString getCaption() const;
-
-        rl::CeGuiString getText() const;
-    };
-    
-    class Quest
-    {
-    public:
-        enum State
-        {
-            OPEN = 0,
-            ASSIGNED,
-            FAILED,
-            SUCCEEDED,
-            COMPLETED
-        };
-
-        Quest(const rl::CeGuiString id, const rl::CeGuiString name, const rl::CeGuiString description);
-        virtual ~Quest();
-
-        const rl::CeGuiString getId();
-        const rl::CeGuiString getName();
-        const rl::CeGuiString getDescription();
-        int getPartsToDo();
-        void setPartsToDo(int partsToDo);
-        int getPartsDone();
-        void setPartsDone(int partsDone);
-        void increasePartsDone(int parts = 1);
-        void decreasePartsDone(int parts = 1);
-
-        rl::Quest::State getState();
-        void setState(rl::Quest::State state);
-        bool isKnown();
-        void setKnown(bool known);
-
-        // QuestVector getSubquests();
-        void addSubquest(rl::Quest* quest); 
-    };   
-    
-    class QuestEvent
-    {
-    public:
-        rl::Quest* getQuest();
-    private:
-        QuestEvent( rl::QuestBook* src, int reason );
-    };
-    
-    class QuestBook
-    {
-    public:
-        rl::Quest* getQuest(const rl::CeGuiString id);
-        void addQuest(rl::Quest* quest);
-        
-        void addJournalEntry(rl::JournalEntry* entry);
-        void addJournalEntry(rl::CeGuiString caption, rl::CeGuiString text);
-        
-        void addQuestListener(rl::QuestListener* listener);
-        void removeQuestListener(rl::QuestListener* listener);
-    };
-    
-    class Talent
-    {
-    public:
-        typedef std::map<const rl::CeGuiString,int> AusweichTalente;
-        Talent(const rl::CeGuiString name,
-               const rl::CeGuiString description,
-               const Tripel<rl::CeGuiString>& eigenschaften,
-               int ebe,
-               int gruppe,
-               const rl::CeGuiString art,
-               const AusweichTalente &ausweichTalente);
-
-        bool operator==(const Talent& rhs) const;
-        bool operator<(const Talent& rhs) const;
-        rl::CeGuiString getName() const;
-        rl::CeGuiString getDescription() const;
-        int getEbe() const;
-
-        /// Berechnet effektive Behinderung bei gegebener Behinderung;
-        int calculateEbe(int be) const;
-        Tripel<rl::CeGuiString> getEigenschaften() const;
-    };
-
-    class ActionGroup
-    {
-    public:
-        ActionGroup(rl::CeGuiString name, ActionGroup* parent = NULL);
-        ~ActionGroup();
-    
-        const rl::CeGuiString getName() const;
-    };
-    
-    %feature("director") Action;   
-    class Action
-    {
-    public:
-        static const int ACT_NORMAL = 1<<0;
-        static const int ACT_INVIS_DESC = 1<<1;
-        static const int ACT_DISABLED = 1<<2;
-        static const int ACT_NEEDS_TALENT = 1<<8;
-
-        static const int TC_NO_TARGET = 0;
-        static const int TC_GAMEOBJECT = 1;
-        static const int TC_CREATURE = 2;
-        static const int TC_ITEM = 3;
-        static const int TC_POINT = 4;
-        static const int TC_RADIUS = 5;
-        static const int TC_POINT_AND_RADIUS = 6;
-    
-        Action(const rl::CeGuiString name, const rl::CeGuiString description);
-        virtual ~Action();
-
-        virtual const rl::CeGuiString getName() const;
-        //virtual const rl::CeGuiString getClassName() const;
-        virtual const rl::CeGuiString getDescription() const;
-        virtual int getTargetClass() const;
-        virtual void doAction(rl::GameObject *object, rl::Creature *actor,
-            rl::GameObject *target);
-        virtual bool canDo(rl::GameObject* object, rl::Creature* actor) const;
-            
-        void setGroup(rl::ActionGroup* group);
-        rl::ActionGroup* getGroup() const;
-    };
-    
-    %feature("director") ObjectStateChangeListener;      
-    class ObjectStateChangeListener      
-    {      
-    public:      
-        virtual ~ObjectStateChangeListener();      
-               
-        virtual void objectStateChanged(rl::ObjectStateChangeEvent *anEvent) = 0;      
-    };
-              
-               
-    class ObjectStateChangeEventSource      
-    {      
-    public:      
-        ObjectStateChangeEventSource( );      
-               
-        void addObjectStateChangeListener( rl::ObjectStateChangeListener*  list );      
-        void removeObjectStateChangeListener( rl::ObjectStateChangeListener* list );      
-        bool hasListeners( ) const;      
-        rl::GameObject* getObject() const;
-        void fireObjectStateChangeEvent();      
-    };      
-               
-    class ObjectStateChangeEvent      
-    {      
-    public:      
-        ObjectStateChangeEvent( rl::ObjectStateChangeEventSource* src );      
-        rl::GameObject* getProvokingObject() const;      
-        rl::ObjectStateChangeEventSource* getSource() const;      
-    };
-            
-    enum GameObjectState
-    {
-        GOS_UNDEFINED = 0,
-        GOS_UNLOADED,
-        GOS_LOADED,
-        GOS_IN_POSSESSION,
-        GOS_IN_SCENE,
-        GOS_HELD,
-        GOS_READY
-    };
-    
-    class PropertyRecord
-    {
-    public:
-        PropertyRecord();
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-    };
-    
-    %constant unsigned long QUERYFLAG_GAMEOBJECT = rl::QUERYFLAG_GAMEOBJECT;
-    %constant unsigned long QUERYFLAG_CREATURE = rl::QUERYFLAG_CREATURE;
-    %constant unsigned long QUERYFLAG_ITEM = rl::QUERYFLAG_ITEM;
-    %constant unsigned long QUERYFLAG_CONTAINER = rl::QUERYFLAG_CONTAINER;
-    %constant unsigned long QUERYFLAG_WEAPON = rl::QUERYFLAG_WEAPON;
-    %constant unsigned long QUERYFLAG_ARMOR = rl::QUERYFLAG_ARMOR;
-    %constant unsigned long QUERYFLAG_PERSON = rl::QUERYFLAG_PERSON;
-    %constant unsigned long QUERYFLAG_PLAYER = rl::QUERYFLAG_PLAYER;
-    
-    %feature("director") GameObject;
-    class GameObject: public ObjectStateChangeEventSource
-    {
-    public:
-        GameObject(unsigned int id);
-        virtual ~GameObject();
-
-        virtual unsigned int getId();
-
-        virtual const rl::CeGuiString getName() const;
-        virtual void setName(rl::CeGuiString name);
-
-        const rl::CeGuiString getDescription() const;
-        virtual void setDescription(rl::CeGuiString description);   
-        
-        void setActor(rl::Actor* actor);
-        rl::Actor* getActor();
-
-        void addAction(rl::Action *action, int option = ACT_NORMAL);
-        void addActionInGroup(Action* action, ActionGroup* group, int option = ACT_NORMAL);
-        void removeAction(rl::Action *action);
-
-        const std::vector<Action*> getValidActions(rl::Creature *actor) const;        
-        void setPosition(const Ogre::Vector3& position);
-        void setOrientation(const Ogre::Quaternion& orientation);
-        const Ogre::Quaternion& getOrientation() const;
-        const Ogre::Vector3& getPosition() const;
-        
-        void setMeshfile(rl::CeGuiString meshfile);
-        
-        virtual Action* getDefaultAction(rl::Creature* actor) const;
-        
-        void doAction(
-            const rl::CeGuiString actionName, 
-            rl::Creature* actor,
-            rl::GameObject* target);
-        void doAction(
-            const rl::CeGuiString actionName);
-        void doAction(rl::Action* action, rl::Creature* actor,
-            rl::GameObject* target);
-            
-        void doDefaultAction(rl::Creature* actor, rl::GameObject* target);
-            
-        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
-        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
-        
-        bool isHighlightingEnabled();
-        void setHighlightingEnabled( bool highlightenabled );
-        
-        void addEffect(rl::Effect* effect);
-        void addEffectWithCheckTime(rl::Effect* effect, RL_LONGLONG time);
-        void addEffectWithCheckDate(rl::Effect* effect, RL_LONGLONG date);
-        void removeEffect(rl::Effect* effect);
-        
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void placeIntoScene();
-        void removeFromScene();
-        
-        rl::GameObjectState getState() const;
-        void setState(rl::GameObjectState state);
-        
-        unsigned long getQueryFlags() const;
-        void addQueryFlag(unsigned long queryflag);
-        void setQueryFlags(unsigned long queryflags);
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    class WaitJob : public rl::Job
-    {
-    public:
-        WaitJob(const rl::Date& dsatime);
-        WaitJob(const Ogre::Real& realtime);
-    };
-    
-    class GoToJob : public rl::Job
-    {
-    public:
-
-		GoToJob(rl::Creature* actor, const Ogre::Vector3& targetPos,
-			Ogre::Real maxDistance, Ogre::Real duration);
-		// Unclear what version is called from ruby, so uncomment second ctor.
-		//GoToJob(rl::Creature* actor, rl::GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
-    };
-    
-    %feature("director") Item;
-    class Item : public rl::GameObject {
-    public:
-        enum ItemType{
-            ITEMTYPE_WEAPON     = 1 << 0,
-            ITEMTYPE_SHIELD     = 1 << 1,
-            ITEMTYPE_RING       = 1 << 2,
-            ITEMTYPE_GLOVES     = 1 << 3,
-            ITEMTYPE_BRACELET   = 1 << 4,
-            ITEMTYPE_ARMOR      = 1 << 5,
-            ITEMTYPE_CAPE       = 1 << 6,
-            ITEMTYPE_BRACERS    = 1 << 7,
-            ITEMTYPE_BACKPACK   = 1 << 8,
-            ITEMTYPE_BELT       = 1 << 9,
-            ITEMTYPE_NECKLACE   = 1 << 10,
-            ITEMTYPE_HELMET     = 1 << 11,
-            ITEMTYPE_TROUSERS   = 1 << 12,
-            ITEMTYPE_SHINBONE   = 1 << 13,
-            ITEMTYPE_BOOTS      = 1 << 14,
-            ITEMTYPE_CLOTHES    = 1 << 15,
-            ITEMTYPE_OTHER      = 1 << 16,
-            ITEMTYPE_ALL_ITEMS  = ~(0)
-        };
-    
-        Item(unsigned int id);
-        virtual ~Item();
-        
-        virtual void placeIntoScene();
-        
-        void setItemType(rl::Item::ItemType itemType);
-        rl::Item::ItemType getItemType() const;
-        virtual void setState(rl::GameObjectState state);
-        virtual void removeOldState();
-
-        void setParentSlot(rl::Slot* slot);
-        rl::Slot* getParentSlot() const;
-
-        void setParentContainer(rl::Container* cont);
-        rl::Container* getParentContainer() const;
-
-        void setOwner(rl::GameObject* go);
-        rl::GameObject* getOwner() const;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        virtual bool isContainer();
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature("director") Weapon;
-    class Weapon : public rl::Item 
-    {
-    public:
-        enum Distanzklasse { DK_H=0, DK_N, DK_S, DK_P };
-
-        Weapon(unsigned int id);
-        virtual ~Weapon();
-                
-        void setTp(int d6, int d20, int mod);
-        const Tripel<int>& getTp() const;
-        void setTpKk(int base, int step);
-        const std::pair<int, int>& getTpKk() const;
-        void setBf(int newBf);
-        int getBf();
-        void setIni(int newIni);
-        int getIni();
-        void setWm(std::pair<int, int>& newWm);
-        const std::pair<int,int>& getWm() const;
-        void setDk(Weapon::Distanzklasse newDk);
-        Weapon::Distanzklasse getDk();
-        void setKampftechnik(const rl::CeGuiString newKampftechnik);
-        const rl::CeGuiString getKampftechnik() const;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature("director") Armor;
-    class Armor : public Item
-    {
-    public:
-    
-        static const CeGuiString Armor::PROPERTY_G_BE = "g_be";
-        static const CeGuiString Armor::PROPERTY_G_RS = "g_rs";
-        
-        Armor(unsigned int id);
-        virtual ~Armor();
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature("director") Container;
-    class Container : public Item
-    {
-    public:
-        Container(unsigned int id);
-        virtual ~Container();
-
-        Ogre::Real getCapacity() const;
-        void setCapacity(Ogre::Real capacity);
-        void setVolume(unsigned int x, unsigned int y);
-        Ogre::Real getContentWeight() const;
-        void addItem(rl::Item* item);
-        void removeItem(rl::Item* item);
-        rl::ItemSet getItems() const;
-        int getItemCount() const;
-        rl::Item* getItemAt(unsigned int x, unsigned int y);
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-
-    %feature("director") Effect;
-    class Effect
-    {
-    public:    
-        typedef unsigned long LifeState;
-        static const LifeState LS_NONE           = 1<<0;
-        static const LifeState LS_BLIND          = 1<<1;   ///< The creature can't see anything.
-        static const LifeState LS_DEAD           = 1<<2;   ///< The creature is dead.
-        static const LifeState LS_DEAF           = 1<<3;   ///< The creature can't hear anything.
-        static const LifeState LS_PARALYZED      = 1<<4;   ///< The creature can't move, turn, jump etc.
-        static const LifeState LS_INCAPACITATED  = 1<<5;   ///< The creature can't fight anymore due to serious injuries. The creature can barely move.
-        static const LifeState LS_INVISIBLE      = 1<<6;   ///< The creature can't be seen.
-        static const LifeState LS_INVULNERABLE   = 1<<7;   ///< The creature is immune to any mundane attacks.
-        static const LifeState LS_PETRIFIED      = 1<<8;   ///< The creature is coated with stone and has all the effects of paralyzation
-        static const LifeState LS_SILENCED       = 1<<9;   ///< The creature doesn't make any noises.
-        static const LifeState LS_SLEEPING       = 1<<10;  ///< The creature is asleep.
-        static const LifeState LS_UNCONSCIOUS    = 1<<11;  ///< Like SLEEPING, but more difficult to wake.
-
-        // Meta stati
-        static const LifeState LS_IMMOBILE = LS_PARALYZED | LS_SLEEPING | LS_UNCONSCIOUS | LS_PETRIFIED | LS_DEAD;
-        static const LifeState LS_NO_COMBAT = LS_IMMOBILE | LS_INCAPACITATED;
-
-        typedef int ModType;
-        static const ModType MODTYPE_NONE         = 1 << 0;
-        static const ModType MODTYPE_SUM      = 1 << 1;   ///< Modifies the actual value.
-        static const ModType MODTYPE_PROBENMOD    = 1 << 2;   ///< Modifies the test.
-        static const ModType MODTYPE_MULT     = 1 << 3;   ///< Will be multiplied on the value.
-        static const ModType MODTYPE_MAXWERTMOD   = 1 << 4;   ///< Modifies only the maximum of the value.
-
-        typedef unsigned long ModTag;
-        static const ModTag MODTAG_NONE           = 1 << 0;
-        static const ModTag MODTAG_KRANKHEIT      = 1 << 1;
-        static const ModTag MODTAG_RECALCULATE    = 1 << 2;
-        static const ModTag MODTAG_REGENERATION_LE = 1 << 3;
-        static const ModTag MODTAG_REGENERATION_AE = 1 << 4;
-        static const ModTag MODTAG_REGENERATION_AU = 1 << 5;
-        static const ModTag MODTAG_ERSCHOEPFUNGSSCHWELLE = 1 << 6;
-    
-        enum Quantifier
-        {
-            QUANTIFIER_MULTIPLE,
-            QUANTIFIER_UNIQUE,
-            QUANTIFIER_UNIQUE_BUT_PROLONGABLE,
-            QUANTIFIER_UNIQUE_BUT_CUMULATIVE
-        };
-        
-      // other constants
-        static const int REMOVE = -1;
-        static const int PERMANENT = 0;
-
-
-        Effect(int stufe = 1);
-        virtual ~Effect();
-
-        const Ogre::String getName() const;
-        void setName(Ogre::String name);
-        const rl::CeGuiString getDescription() const;
-        void setDescription(rl::CeGuiString description);
-        Quantifier getQuantifier();
-        void setQuantifier(Quantifier quantifier);
-        virtual const int getStufe();
-        virtual void increaseStufe();
-        virtual void decreaseStufe();
-        virtual void enable();
-        virtual void disable();
-        virtual RL_LONGLONG timeCheck() = 0;
-
-        virtual LifeState getLifeState() const;
-        virtual int getMod(rl::CeGuiString target, ModType type, ModTag tag);
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-    };
-
-    class EffectFactory
-    {
-    public:
-        virtual rl::Effect* createEffect(const Ogre::String& name, int stufe) = 0;
-    };
-
-    class EffectFactoryManager
-    {
-    public:
-        void setEffectFactory(rl::EffectFactory* factory);
-        static rl::EffectFactoryManager& getSingleton();
-    };
-
-    enum SlotType
-    {
-        SLOT_BONE,
-        SLOT_SUBMESH,
-        SLOT_MATERIAL
-    };
-
-    class Inventory 
-    {
-    private:
-        Inventory(rl::Creature* owner);
-    public:
-        void addSlot(const rl::CeGuiString& name, const Ogre::String& meshpartname, int itemReadyMask, int itemHeldMask, SlotType type = SLOT_BONE);
-        rl::Item* getItem(const rl::CeGuiString& slotName) const;
-        void hold(rl::Item* item, const rl::CeGuiString& slot);
-        void ready(rl::Item* item, const rl::CeGuiString& slot);
-        void dropItem(const rl::CeGuiString& slotName);
-    };
-
-    %feature("director") Creature;
-    class Creature : public GameObject {
-    public:
-    
-    typedef Ogre::String Wert;
-        enum Alignment
-        {
-            ALIGNMENT_ALLY,    ///< Creature fights with the player.
-            ALIGNMENT_NEUTRAL, ///< Creature doesn't fight for either side.
-            ALIGNMENT_ENEMY    ///< Creature fights against the player.
-        };
-
-        enum SfStatus
-        {
-            SFSTATUS_IN_TRAINING = 1,
-            SFSTATUS_OK,
-            SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Wird das ueberhaupt gebraucht?
-        };
-
-        // some targets
-        static const std::string Creature::ALL_EIGENSCHAFTEN = "alle Eigenschaften";
-        static const std::string Creature::ALL_TALENTE = "alle Talente";
-        static const Creature::Wert Creature::WERT_MOD_AE = "ModAE";
-        static const Creature::Wert Creature::WERT_MOD_LE = "ModLE";
-        static const Creature::Wert Creature::WERT_MOD_AU = "ModAU";
-        static const Creature::Wert Creature::WERT_MOD_MR = "ModMR";
-        static const Creature::Wert Creature::WERT_MOD_AT = "ModAT";
-        static const Creature::Wert Creature::WERT_MOD_PA = "ModPA";
-        static const Creature::Wert Creature::WERT_MOD_FK = "ModFK";
-        static const Creature::Wert Creature::WERT_GS = "GS";
-        static const Creature::Wert Creature::WERT_SOZIALSTATUS = "SO";
-        static const Creature::Wert Creature::WERT_BE = "BE";
-        static const Creature::Wert Creature::WERT_RS = "RS";
-        static const Creature::Wert Creature::WERT_INI = "INI";
-        static const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE ="Kampfunf??higkeitsschwelle"; 
-        static const Creature::Wert Creature::WERT_REGENERATION = "Regeneration";
-        
-        
-        Creature(unsigned int id);
-        virtual ~Creature();
-
-        virtual int getLe();
-        virtual void modifyLe(int mod, bool ignoreMax);
-        virtual void modifyAe(int mod);
-        virtual void modifyAu(int mod);
-        void setWert(Wert wertId, int value);
-        virtual int getWert(Wert wertId, bool getUnmodified = false);
-        
-        virtual int getEigenschaft(const rl::CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE);
-        virtual void setEigenschaft(const rl::CeGuiString eigenschaftName, int value);
-        virtual void modifyEigenschaft(const rl::CeGuiString eigenschaftName, int mod);
-
-        
-        void addTalent(const rl::CeGuiString talentName, int value=0);
-        bool hasTalent(const rl::CeGuiString talentName, bool checkAusweichTalente = true);
-        virtual int getTalent(const rl::CeGuiString talentName);
-        virtual void setTalent(const rl::CeGuiString talentName, int value);
-        virtual void modifyTalent(const rl::CeGuiString talentName, int mod);
-        virtual void addSe(const rl::CeGuiString talentName);
-        
-        void addVorteil(const rl::CeGuiString vorteilName, int value = 0);
-        void addNachteil(const rl::CeGuiString nachteilName, int value = 0);        
-        
-        void addKampftechnik(const rl::CeGuiString kampftechnikName, std::pair<int,int> value = make_pair(0,0));
-        virtual void addSf(const rl::CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
-        
-        virtual int doTalentprobe(const rl::CeGuiString talentName, int modifier);
-        virtual int doEigenschaftsprobe(const rl::CeGuiString eigenschaftName, int modifier);
-        
-        rl::Inventory* getInventory();
-        
-        void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
-        static const int LEDAMAGE_NORMAL = 0;
-        static const int LEDAMAGE_FIRE = 1;
-        static const int LEDAMAGE_WATER = 2;
-        static const int LEDAMAGE_DEMONIC = 4;
-        void damageAu(int aup, int damageType = AUDAMAGE_NORMAL);
-        static const int AUDAMAGE_NORMAL = 0;
-        static const int AUDAMAGE_HEAT = 1;
-        static const int AUDAMAGE_COLD = 2;
-        static const int AUDAMAGE_CHOKE = 4;
-        static const int AUDAMAGE_DROWN = 8;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-
-        void setAlignment(Alignment);
-        Alignment getAlignment() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-   };
-   
-    %feature("director") ActionManager;
-    class ActionManager
-    {
-    public:
-        void registerAction(rl::Action* action);
-        void unregisterAction(const rl::CeGuiString actionName);
-        rl::Action* getAction(const rl::CeGuiString actionName) const;
-
-        void registerInGameGlobalAction(rl::Action* action, rl::ActionGroup* group);
-    
-        static rl::ActionManager& getSingleton();
-    };
-    
-    class CreatureController
-    {
-    public:
-        
-        typedef enum
-        {
-            // these movements can be used
-            MT_NONE,
-            MT_STEHEN,
-            MT_GEHEN,
-            MT_JOGGEN,
-            MT_LAUFEN,
-            MT_RENNEN,
-            MT_RUECKWAERTS_GEHEN,
-            MT_RUECKWAERTS_JOGGEN,
-            MT_SEITWAERTS_GEHEN,
-            MT_SCHLEICHEN,
-            MT_HOCHSPRUNG,
-            MT_WEITSPRUNG,
-            MT_ZIELSPRUNG,
-            // these movements are only for internal purposes and should not be used directly
-            // instead use one of the movements above
-            MT_DREHEN,
-            MT_STUFENERKENNUNG,
-            MT_FALLEN,
-            MT_LIEGEN
-        } MovementType;
-        
-        Creature *getCreature();
-        bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
-        MovementType getMovementId() const;
-        Ogre::Vector3 getDirection() const;
-        Ogre::Vector3 getRotation() const;
-        Ogre::Vector3 getVelocity() const;
-        Ogre::Vector3 getOmega() const;
-        void setAnimation(const Ogre::String &name, 
-                          Ogre::Real speed = 1, 
-                          unsigned int timesToPlay = 0, 
-                          const Ogre::String &collisionName = "");
-    protected:
-        CreatureController(Creature *character);
-        ~CreatureController();
-    };
-    
-    class CreatureControllerManager
-    {
-    public:
-        /// Returns a CreatureController that can be used to control given Creature.
-        /// There is only one controller per Creature at a given time.
-        /// If no such controller exists yet, it is created.
-        rl::CreatureController* getCreatureController(rl::Creature* creature);
-
-        /// This function detaches a controller attached to the given Creature, if any.
-        void detachController(rl::Creature* creature);
-
-        static rl::CreatureControllerManager& getSingleton();
-    };
-
-	// Before first use of Selector or subclasses!
-    %apply SWIGTYPE *DYNAMIC { rl::Selector* };
-
-	class Selector
-    {
-    public:
-        Selector(unsigned long mask = 0xffffffff);
-        virtual void updateSelection();
-
-        void setSelectionMask(unsigned long mask);
-        unsigned long getSelectionMask() const;
-
-        GameObject* getFirstSelectedObject() const;
-		const std::vector<GameObject*>& getAllSelectedObjects() const;
-		unsigned int getSelectionCount() const;
-
-		virtual void updatePrimitive() = 0;
-    };
-
-
-    /// A Selector that selects all unoccluded GameObject the ray hits.
-    class RaySelector : public Selector
-    {
-    public:
-        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
-        void setRay(const Ogre::Vector3& start, const Ogre::Vector3& end);
-		virtual void updatePrimitive();
-    };
-
-    /// Selects this GameObject within a half sphere pointing to -Z,
-    /// that has the smallest angle difference to the -Z-Axis.
-    class HalfSphereSelector : public Selector
-    {
-    public:
-        HalfSphereSelector(unsigned long mask = 0xffffffff);
-	    void setRadius(Ogre::Real radius);
-        void setPosition(const Ogre::Vector3& pos);
-        void setOrientation(const Ogre::Quaternion& ori);
-		virtual void updatePrimitive();
-	};
-
-} // Namespace
-
-%{
-static swig_type_info *Selector_dynamic_cast(void **ptr)
-{
-	rl::Selector *pSelector = static_cast<rl::Selector*>(*ptr);
-	rl::HalfSphereSelector *pHalfSphereSel = dynamic_cast<rl::HalfSphereSelector*>(pSelector);
-	if (pHalfSphereSel)
-	{
-		*ptr = pHalfSphereSel;
-		return SWIGTYPE_p_rl__HalfSphereSelector;
-	}
-	rl::RaySelector *pRaySel = dynamic_cast<rl::RaySelector*>(pSelector);
-	if (pRaySel)
-	{
-		*ptr = pRaySel;
-		return SWIGTYPE_p_rl__RaySelector;
-	}
-}
-	
-static swig_type_info *GameObject_dynamic_cast(void **ptr)
-{
-    rl::GameObject *pGameObject = static_cast<rl::GameObject*>(*ptr);
-
-    rl::Creature *pCreature=dynamic_cast<rl::Creature*>(pGameObject);
-    if (pCreature) {
-        *ptr=pCreature;
-        return SWIGTYPE_p_rl__Creature;
-    }
-    rl::Weapon *pWeapon=dynamic_cast<rl::Weapon*>(pGameObject);
-    if (pWeapon) {
-        *ptr=pWeapon;
-        return SWIGTYPE_p_rl__Weapon;
-    }
-    rl::Armor *pArmor=dynamic_cast<rl::Armor*>(pGameObject);
-    if (pArmor) {
-        *ptr=pArmor;
-        return SWIGTYPE_p_rl__Armor;
-    }
-    rl::Container *pContainer=dynamic_cast<rl::Container*>(pGameObject);
-    if (pContainer) {
-        *ptr=pContainer;
-        return SWIGTYPE_p_rl__Container;
-    }
-    rl::Item *pItem=dynamic_cast<rl::Item*>(pGameObject);
-    if (pItem) {
-        *ptr=pItem;
-        return SWIGTYPE_p_rl__Item;
-    }
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__GameObject, GameObject_dynamic_cast);
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+//%template(GameObjectVector) std::vector< rl::GameObject* >;
+
+namespace rl {
+
+    // Before first use of GameObject or subclasses!
+    %apply SWIGTYPE *DYNAMIC { rl::GameObject * };
+
+                    
+   template<typename T>
+   class Tripel {
+   public:
+      T first;
+      T second;
+      T third;
+
+      Tripel();      
+      Tripel(const T& t1, const T& t2, const T& t3);
+      Tripel(const Tripel& rhs);
+
+      //Tripel& operator=(const Tripel& rhs);
+      bool operator==(const Tripel& rhs);
+      bool operator<(const Tripel& rhs);     
+   };
+    
+    class Date {
+    public:
+        static const RL_LONGLONG ONE_SECOND = 1000ULL;
+        static const RL_LONGLONG ONE_MINUTE = 60000ULL;
+        static const RL_LONGLONG ONE_HOUR = 3600000ULL;
+        static const RL_LONGLONG ONE_DAY = 86400000ULL;
+        static const RL_LONGLONG ONE_WEEK = 604800000ULL;
+        static const RL_LONGLONG ONE_MONTH = 2592000000ULL;
+        static const RL_LONGLONG ONE_YEAR = 31536000000ULL;
+        static const RL_LONGLONG ONE_KAMPFRUNDE = 2 * ONE_SECOND;
+        static const RL_LONGLONG ONE_SPIELRUNDE = 5 * ONE_MINUTE;
+
+        Date();
+        Date(RL_LONGLONG timestamp);
+        Date(const Date& rhs);
+      
+        bool operator==(const Date& rhs);
+        bool operator<(const Date& rhs);
+        bool operator<=(const Date& rhs);
+        bool operator>=(const Date& rhs);
+        bool operator>(const Date& rhs);
+
+        Date operator+(const RL_LONGLONG& rhs);
+        Date operator-(const RL_LONGLONG& rhs);
+        Date operator*(const Ogre::Real& rhs);
+        Date operator/(const Ogre::Real& rhs);
+        RL_LONGLONG operator-(const Date& rhs);
+      
+        RL_LONGLONG getTimestamp();
+
+        int getTimeFraction();
+        int getYear();
+        int getMonth();
+        rl::CeGuiString getMonthName();
+        int getDayOfYear();
+        int getDayOfMonth();
+        int getDayOfWeek();
+        rl::CeGuiString getDayOfWeekName();
+        int getHour();
+        int getMinute();
+        int getSecond();
+        int getMilliSecond();
+      
+        rl::CeGuiString toString();
+    };
+   
+    Date operator+(const RL_LONGLONG&, const Date&);
+    Date operator-(const RL_LONGLONG&, const Date&);
+
+    class RulesSubsystem 
+    {
+        public:
+             static rl::RulesSubsystem& getSingleton();
+             rl::QuestBook* getQuestBook();
+             void resetQuestBook();
+    };
+  
+    class DsaManager {
+    public:
+        RL_LONGLONG getTimestamp();
+        Date getCurrentDate();
+        void setCurrentDate(const Date& date);
+        
+        int rollD20();
+        Tripel<int> roll3D20();
+        int rollD6();
+        int roll(int d6, int d20);
+      
+        static DsaManager& getSingleton();
+        rl::Talent* getTalent(const rl::CeGuiString name) const;
+        rl::Creature* getCreature(const int id) const;
+    };
+    
+    %feature("director") GameObjectFactory; 
+    class GameObjectFactory
+    {
+    public:
+        virtual rl::GameObject* createRubyGameObject(const Ogre::String& classname, unsigned int id) = 0;
+        GameObjectFactory();
+        virtual ~GameObjectFactory();
+    };
+
+    class GameObjectManager
+    {
+    public:
+        static rl::GameObjectManager& getSingleton();
+        rl::GameObject* createGameObject(const Ogre::String& classId, unsigned int id = 0);
+        rl::GameObject* getGameObject(unsigned int id) const;
+        void setGameObjectFactory(rl::GameObjectFactory* gof);
+
+    private:
+        GameObjectManager();
+    };
+
+	enum GameEventType
+	{
+		GET_DEFAULT,
+		GET_COMBAT,
+		GET_DIALOG,
+		GET_QUEST
+	};
+	
+    class GameEventLog
+    {
+    public:
+        static rl::GameEventLog& getSingleton();
+		void logEvent(const Ogre::String& eventString, GameEventType type);
+
+    private:
+        GameEventLog();
+    };
+    
+    class GlobalProperties 
+    {
+    public:
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        bool hasProperty(const Ogre::String& key) const;
+        
+        static rl::GlobalProperties& getSingleton();
+    private:
+        GlobalProperties();
+    };
+
+    %feature("director") QuestListener; 
+    class QuestListener
+    {
+    public:
+        virtual ~QuestListener();
+        
+        virtual void questStateChanged(rl::QuestEvent* anEvent) = 0;
+        virtual void questPartsDoneChanged(rl::QuestEvent* anEvent) = 0;
+        virtual void questKnownChanged(rl::QuestEvent* anEvent) = 0;
+        virtual void questSubquestAdded(rl::QuestEvent* anEvent) = 0;
+        virtual void journalEntryAdded(rl::JournalEvent* anEvent) = 0;
+        virtual void journalEntryDeleted(rl::JournalEvent* anEvent) = 0;
+    };
+
+    class JournalEntry
+    {
+    public:
+        JournalEntry(const rl::CeGuiString caption, const rl::CeGuiString text);
+        virtual ~JournalEntry();
+
+        rl::CeGuiString getCaption() const;
+
+        rl::CeGuiString getText() const;
+    };
+    
+    class Quest
+    {
+    public:
+        enum State
+        {
+            OPEN = 0,
+            ASSIGNED,
+            FAILED,
+            SUCCEEDED,
+            COMPLETED
+        };
+
+        Quest(const rl::CeGuiString id, const rl::CeGuiString name, const rl::CeGuiString description);
+        virtual ~Quest();
+
+        const rl::CeGuiString getId();
+        const rl::CeGuiString getName();
+        const rl::CeGuiString getDescription();
+        int getPartsToDo();
+        void setPartsToDo(int partsToDo);
+        int getPartsDone();
+        void setPartsDone(int partsDone);
+        void increasePartsDone(int parts = 1);
+        void decreasePartsDone(int parts = 1);
+
+        rl::Quest::State getState();
+        void setState(rl::Quest::State state);
+        bool isKnown();
+        void setKnown(bool known);
+
+        // QuestVector getSubquests();
+        void addSubquest(rl::Quest* quest); 
+    };   
+    
+    class QuestEvent
+    {
+    public:
+        rl::Quest* getQuest();
+    private:
+        QuestEvent( rl::QuestBook* src, int reason );
+    };
+    
+    class QuestBook
+    {
+    public:
+        rl::Quest* getQuest(const rl::CeGuiString id);
+        void addQuest(rl::Quest* quest);
+        
+        void addJournalEntry(rl::JournalEntry* entry);
+        void addJournalEntry(rl::CeGuiString caption, rl::CeGuiString text);
+        
+        void addQuestListener(rl::QuestListener* listener);
+        void removeQuestListener(rl::QuestListener* listener);
+    };
+    
+    class Talent
+    {
+    public:
+        typedef std::map<const rl::CeGuiString,int> AusweichTalente;
+        Talent(const rl::CeGuiString name,
+               const rl::CeGuiString description,
+               const Tripel<rl::CeGuiString>& eigenschaften,
+               int ebe,
+               int gruppe,
+               const rl::CeGuiString art,
+               const AusweichTalente &ausweichTalente);
+
+        bool operator==(const Talent& rhs) const;
+        bool operator<(const Talent& rhs) const;
+        rl::CeGuiString getName() const;
+        rl::CeGuiString getDescription() const;
+        int getEbe() const;
+
+        /// Berechnet effektive Behinderung bei gegebener Behinderung;
+        int calculateEbe(int be) const;
+        Tripel<rl::CeGuiString> getEigenschaften() const;
+    };
+
+    class ActionGroup
+    {
+    public:
+        ActionGroup(rl::CeGuiString name, ActionGroup* parent = NULL);
+        ~ActionGroup();
+    
+        const rl::CeGuiString getName() const;
+    };
+    
+    %feature("director") Action;   
+    class Action
+    {
+    public:
+        static const int ACT_NORMAL = 1<<0;
+        static const int ACT_INVIS_DESC = 1<<1;
+        static const int ACT_DISABLED = 1<<2;
+        static const int ACT_NEEDS_TALENT = 1<<8;
+
+        static const int TC_NO_TARGET = 0;
+        static const int TC_GAMEOBJECT = 1;
+        static const int TC_CREATURE = 2;
+        static const int TC_ITEM = 3;
+        static const int TC_POINT = 4;
+        static const int TC_RADIUS = 5;
+        static const int TC_POINT_AND_RADIUS = 6;
+    
+        Action(const rl::CeGuiString name, const rl::CeGuiString description);
+        virtual ~Action();
+
+        virtual const rl::CeGuiString getName() const;
+        //virtual const rl::CeGuiString getClassName() const;
+        virtual const rl::CeGuiString getDescription() const;
+        virtual int getTargetClass() const;
+        virtual void doAction(rl::GameObject *object, rl::Creature *actor,
+            rl::GameObject *target);
+        virtual bool canDo(rl::GameObject* object, rl::Creature* actor) const;
+            
+        void setGroup(rl::ActionGroup* group);
+        rl::ActionGroup* getGroup() const;
+    };
+    
+    %feature("director") ObjectStateChangeListener;      
+    class ObjectStateChangeListener      
+    {      
+    public:      
+        virtual ~ObjectStateChangeListener();      
+               
+        virtual void objectStateChanged(rl::ObjectStateChangeEvent *anEvent) = 0;      
+    };
+              
+               
+    class ObjectStateChangeEventSource      
+    {      
+    public:      
+        ObjectStateChangeEventSource( );      
+               
+        void addObjectStateChangeListener( rl::ObjectStateChangeListener*  list );      
+        void removeObjectStateChangeListener( rl::ObjectStateChangeListener* list );      
+        bool hasListeners( ) const;      
+        rl::GameObject* getObject() const;
+        void fireObjectStateChangeEvent();      
+    };      
+               
+    class ObjectStateChangeEvent      
+    {      
+    public:      
+        ObjectStateChangeEvent( rl::ObjectStateChangeEventSource* src );      
+        rl::GameObject* getProvokingObject() const;      
+        rl::ObjectStateChangeEventSource* getSource() const;      
+    };
+            
+    enum GameObjectState
+    {
+        GOS_UNDEFINED = 0,
+        GOS_UNLOADED,
+        GOS_LOADED,
+        GOS_IN_POSSESSION,
+        GOS_IN_SCENE,
+        GOS_HELD,
+        GOS_READY
+    };
+    
+    class PropertyRecord
+    {
+    public:
+        PropertyRecord();
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+    };
+    
+    %constant unsigned long QUERYFLAG_GAMEOBJECT = rl::QUERYFLAG_GAMEOBJECT;
+    %constant unsigned long QUERYFLAG_CREATURE = rl::QUERYFLAG_CREATURE;
+    %constant unsigned long QUERYFLAG_ITEM = rl::QUERYFLAG_ITEM;
+    %constant unsigned long QUERYFLAG_CONTAINER = rl::QUERYFLAG_CONTAINER;
+    %constant unsigned long QUERYFLAG_WEAPON = rl::QUERYFLAG_WEAPON;
+    %constant unsigned long QUERYFLAG_ARMOR = rl::QUERYFLAG_ARMOR;
+    %constant unsigned long QUERYFLAG_PERSON = rl::QUERYFLAG_PERSON;
+    %constant unsigned long QUERYFLAG_PLAYER = rl::QUERYFLAG_PLAYER;
+    
+    %feature("director") GameObject;
+    class GameObject: public ObjectStateChangeEventSource
+    {
+    public:
+        GameObject(unsigned int id);
+        virtual ~GameObject();
+
+        virtual unsigned int getId();
+
+        virtual const rl::CeGuiString getName() const;
+        virtual void setName(rl::CeGuiString name);
+
+        const rl::CeGuiString getDescription() const;
+        virtual void setDescription(rl::CeGuiString description);   
+        
+        void setActor(rl::Actor* actor);
+        rl::Actor* getActor();
+
+        void addAction(rl::Action *action, int option = ACT_NORMAL);
+        void addActionInGroup(Action* action, ActionGroup* group, int option = ACT_NORMAL);
+        void removeAction(rl::Action *action);
+
+        const std::vector<Action*> getValidActions(rl::Creature *actor) const;        
+        void setPosition(const Ogre::Vector3& position);
+        void setOrientation(const Ogre::Quaternion& orientation);
+        const Ogre::Quaternion& getOrientation() const;
+        const Ogre::Vector3& getPosition() const;
+        
+        void setMeshfile(rl::CeGuiString meshfile);
+        
+        virtual Action* getDefaultAction(rl::Creature* actor) const;
+        
+        void doAction(
+            const rl::CeGuiString actionName, 
+            rl::Creature* actor,
+            rl::GameObject* target);
+        void doAction(
+            const rl::CeGuiString actionName);
+        void doAction(rl::Action* action, rl::Creature* actor,
+            rl::GameObject* target);
+            
+        void doDefaultAction(rl::Creature* actor, rl::GameObject* target);
+            
+        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
+        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
+        
+        bool isHighlightingEnabled();
+        void setHighlightingEnabled( bool highlightenabled );
+        
+        void addEffect(rl::Effect* effect);
+        void addEffectWithCheckTime(rl::Effect* effect, RL_LONGLONG time);
+        void addEffectWithCheckDate(rl::Effect* effect, RL_LONGLONG date);
+        void removeEffect(rl::Effect* effect);
+        
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        
+        virtual void placeIntoScene();
+        void removeFromScene();
+        
+        rl::GameObjectState getState() const;
+        void setState(rl::GameObjectState state);
+        
+        unsigned long getQueryFlags() const;
+        void addQueryFlag(unsigned long queryflag);
+        void setQueryFlags(unsigned long queryflags);
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+    class WaitJob : public rl::Job
+    {
+    public:
+        WaitJob(const rl::Date& dsatime);
+        WaitJob(const Ogre::Real& realtime);
+    };
+    
+    class GoToJob : public rl::Job
+    {
+    public:
+
+		GoToJob(rl::Creature* actor, const Ogre::Vector3& targetPos,
+			Ogre::Real maxDistance, Ogre::Real duration);
+		// Unclear what version is called from ruby, so uncomment second ctor.
+		//GoToJob(rl::Creature* actor, rl::GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
+    };
+    
+    %feature("director") Item;
+    class Item : public rl::GameObject {
+    public:
+        enum ItemType{
+            ITEMTYPE_WEAPON     = 1 << 0,
+            ITEMTYPE_SHIELD     = 1 << 1,
+            ITEMTYPE_RING       = 1 << 2,
+            ITEMTYPE_GLOVES     = 1 << 3,
+            ITEMTYPE_BRACELET   = 1 << 4,
+            ITEMTYPE_ARMOR      = 1 << 5,
+            ITEMTYPE_CAPE       = 1 << 6,
+            ITEMTYPE_BRACERS    = 1 << 7,
+            ITEMTYPE_BACKPACK   = 1 << 8,
+            ITEMTYPE_BELT       = 1 << 9,
+            ITEMTYPE_NECKLACE   = 1 << 10,
+            ITEMTYPE_HELMET     = 1 << 11,
+            ITEMTYPE_TROUSERS   = 1 << 12,
+            ITEMTYPE_SHINBONE   = 1 << 13,
+            ITEMTYPE_BOOTS      = 1 << 14,
+            ITEMTYPE_CLOTHES    = 1 << 15,
+            ITEMTYPE_OTHER      = 1 << 16,
+            ITEMTYPE_ALL_ITEMS  = ~(0)
+        };
+    
+        Item(unsigned int id);
+        virtual ~Item();
+        
+        virtual void placeIntoScene();
+        
+        void setItemType(rl::Item::ItemType itemType);
+        rl::Item::ItemType getItemType() const;
+        virtual void setState(rl::GameObjectState state);
+        virtual void removeOldState();
+
+        void setParentSlot(rl::Slot* slot);
+        rl::Slot* getParentSlot() const;
+
+        void setParentContainer(rl::Container* cont);
+        rl::Container* getParentContainer() const;
+
+        void setOwner(rl::GameObject* go);
+        rl::GameObject* getOwner() const;
+
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        virtual bool isContainer();
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+    %feature("director") Weapon;
+    class Weapon : public rl::Item 
+    {
+    public:
+        enum Distanzklasse { DK_H=0, DK_N, DK_S, DK_P };
+
+        Weapon(unsigned int id);
+        virtual ~Weapon();
+                
+        void setTp(int d6, int d20, int mod);
+        const Tripel<int>& getTp() const;
+        void setTpKk(int base, int step);
+        const std::pair<int, int>& getTpKk() const;
+        void setBf(int newBf);
+        int getBf();
+        void setIni(int newIni);
+        int getIni();
+        void setWm(std::pair<int, int>& newWm);
+        const std::pair<int,int>& getWm() const;
+        void setDk(Weapon::Distanzklasse newDk);
+        Weapon::Distanzklasse getDk();
+        void setKampftechnik(const rl::CeGuiString newKampftechnik);
+        const rl::CeGuiString getKampftechnik() const;
+
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+    %feature("director") Armor;
+    class Armor : public Item
+    {
+    public:
+    
+        static const CeGuiString Armor::PROPERTY_G_BE = "g_be";
+        static const CeGuiString Armor::PROPERTY_G_RS = "g_rs";
+        
+        Armor(unsigned int id);
+        virtual ~Armor();
+
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+    %feature("director") Container;
+    class Container : public Item
+    {
+    public:
+        Container(unsigned int id);
+        virtual ~Container();
+
+        Ogre::Real getCapacity() const;
+        void setCapacity(Ogre::Real capacity);
+        void setVolume(unsigned int x, unsigned int y);
+        Ogre::Real getContentWeight() const;
+        void addItem(rl::Item* item);
+        void removeItem(rl::Item* item);
+        rl::ItemSet getItems() const;
+        int getItemCount() const;
+        rl::Item* getItemAt(unsigned int x, unsigned int y);
+
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+
+    %feature("director") Effect;
+    class Effect
+    {
+    public:    
+        typedef unsigned long LifeState;
+        static const LifeState LS_NONE           = 1<<0;
+        static const LifeState LS_BLIND          = 1<<1;   ///< The creature can't see anything.
+        static const LifeState LS_DEAD           = 1<<2;   ///< The creature is dead.
+        static const LifeState LS_DEAF           = 1<<3;   ///< The creature can't hear anything.
+        static const LifeState LS_PARALYZED      = 1<<4;   ///< The creature can't move, turn, jump etc.
+        static const LifeState LS_INCAPACITATED  = 1<<5;   ///< The creature can't fight anymore due to serious injuries. The creature can barely move.
+        static const LifeState LS_INVISIBLE      = 1<<6;   ///< The creature can't be seen.
+        static const LifeState LS_INVULNERABLE   = 1<<7;   ///< The creature is immune to any mundane attacks.
+        static const LifeState LS_PETRIFIED      = 1<<8;   ///< The creature is coated with stone and has all the effects of paralyzation
+        static const LifeState LS_SILENCED       = 1<<9;   ///< The creature doesn't make any noises.
+        static const LifeState LS_SLEEPING       = 1<<10;  ///< The creature is asleep.
+        static const LifeState LS_UNCONSCIOUS    = 1<<11;  ///< Like SLEEPING, but more difficult to wake.
+
+        // Meta stati
+        static const LifeState LS_IMMOBILE = LS_PARALYZED | LS_SLEEPING | LS_UNCONSCIOUS | LS_PETRIFIED | LS_DEAD;
+        static const LifeState LS_NO_COMBAT = LS_IMMOBILE | LS_INCAPACITATED;
+
+        typedef int ModType;
+        static const ModType MODTYPE_NONE         = 1 << 0;
+        static const ModType MODTYPE_SUM      = 1 << 1;   ///< Modifies the actual value.
+        static const ModType MODTYPE_PROBENMOD    = 1 << 2;   ///< Modifies the test.
+        static const ModType MODTYPE_MULT     = 1 << 3;   ///< Will be multiplied on the value.
+        static const ModType MODTYPE_MAXWERTMOD   = 1 << 4;   ///< Modifies only the maximum of the value.
+
+        typedef unsigned long ModTag;
+        static const ModTag MODTAG_NONE           = 1 << 0;
+        static const ModTag MODTAG_KRANKHEIT      = 1 << 1;
+        static const ModTag MODTAG_RECALCULATE    = 1 << 2;
+        static const ModTag MODTAG_REGENERATION_LE = 1 << 3;
+        static const ModTag MODTAG_REGENERATION_AE = 1 << 4;
+        static const ModTag MODTAG_REGENERATION_AU = 1 << 5;
+        static const ModTag MODTAG_ERSCHOEPFUNGSSCHWELLE = 1 << 6;
+    
+        enum Quantifier
+        {
+            QUANTIFIER_MULTIPLE,
+            QUANTIFIER_UNIQUE,
+            QUANTIFIER_UNIQUE_BUT_PROLONGABLE,
+            QUANTIFIER_UNIQUE_BUT_CUMULATIVE
+        };
+        
+      // other constants
+        static const int REMOVE = -1;
+        static const int PERMANENT = 0;
+
+
+        Effect(int stufe = 1);
+        virtual ~Effect();
+
+        const Ogre::String getName() const;
+        void setName(Ogre::String name);
+        const rl::CeGuiString getDescription() const;
+        void setDescription(rl::CeGuiString description);
+        Quantifier getQuantifier();
+        void setQuantifier(Quantifier quantifier);
+        virtual const int getStufe();
+        virtual void increaseStufe();
+        virtual void decreaseStufe();
+        virtual void enable();
+        virtual void disable();
+        virtual RL_LONGLONG timeCheck() = 0;
+
+        virtual LifeState getLifeState() const;
+        virtual int getMod(rl::CeGuiString target, ModType type, ModTag tag);
+
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+    };
+
+    class EffectFactory
+    {
+    public:
+        virtual rl::Effect* createEffect(const Ogre::String& name, int stufe) = 0;
+    };
+
+    class EffectFactoryManager
+    {
+    public:
+        void setEffectFactory(rl::EffectFactory* factory);
+        static rl::EffectFactoryManager& getSingleton();
+    };
+
+    enum SlotType
+    {
+        SLOT_BONE,
+        SLOT_SUBMESH,
+        SLOT_MATERIAL
+    };
+
+    class Inventory 
+    {
+    private:
+        Inventory(rl::Creature* owner);
+    public:
+        void addSlot(const rl::CeGuiString& name, const Ogre::String& meshpartname, int itemReadyMask, int itemHeldMask, SlotType type = SLOT_BONE);
+        rl::Item* getItem(const rl::CeGuiString& slotName) const;
+        void hold(rl::Item* item, const rl::CeGuiString& slot);
+        void ready(rl::Item* item, const rl::CeGuiString& slot);
+        void dropItem(const rl::CeGuiString& slotName);
+    };
+
+    %feature("director") Creature;
+    class Creature : public GameObject {
+    public:
+    
+    typedef Ogre::String Wert;
+        enum Alignment
+        {
+            ALIGNMENT_ALLY,    ///< Creature fights with the player.
+            ALIGNMENT_NEUTRAL, ///< Creature doesn't fight for either side.
+            ALIGNMENT_ENEMY    ///< Creature fights against the player.
+        };
+
+        enum SfStatus
+        {
+            SFSTATUS_IN_TRAINING = 1,
+            SFSTATUS_OK,
+            SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Wird das ueberhaupt gebraucht?
+        };
+
+        // some targets
+        static const std::string Creature::ALL_EIGENSCHAFTEN = "alle Eigenschaften";
+        static const std::string Creature::ALL_TALENTE = "alle Talente";
+        static const Creature::Wert Creature::WERT_MOD_AE = "ModAE";
+        static const Creature::Wert Creature::WERT_MOD_LE = "ModLE";
+        static const Creature::Wert Creature::WERT_MOD_AU = "ModAU";
+        static const Creature::Wert Creature::WERT_MOD_MR = "ModMR";
+        static const Creature::Wert Creature::WERT_MOD_AT = "ModAT";
+        static const Creature::Wert Creature::WERT_MOD_PA = "ModPA";
+        static const Creature::Wert Creature::WERT_MOD_FK = "ModFK";
+        static const Creature::Wert Creature::WERT_GS = "GS";
+        static const Creature::Wert Creature::WERT_SOZIALSTATUS = "SO";
+        static const Creature::Wert Creature::WERT_BE = "BE";
+        static const Creature::Wert Creature::WERT_RS = "RS";
+        static const Creature::Wert Creature::WERT_INI = "INI";
+        static const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE ="Kampfunf??higkeitsschwelle"; 
+        static const Creature::Wert Creature::WERT_REGENERATION = "Regeneration";
+        
+        
+        Creature(unsigned int id);
+        virtual ~Creature();
+
+        virtual int getLe();
+        virtual void modifyLe(int mod, bool ignoreMax = false);
+        virtual void modifyAe(int mod);
+        virtual void modifyAu(int mod);
+        void setWert(Wert wertId, int value);
+        virtual int getWert(Wert wertId, bool getUnmodified = false);
+        
+        virtual int getEigenschaft(const rl::CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE);
+        virtual void setEigenschaft(const rl::CeGuiString eigenschaftName, int value);
+        virtual void modifyEigenschaft(const rl::CeGuiString eigenschaftName, int mod);
+
+        
+        void addTalent(const rl::CeGuiString talentName, int value=0);
+        bool hasTalent(const rl::CeGuiString talentName, bool checkAusweichTalente = true);
+        virtual int getTalent(const rl::CeGuiString talentName);
+        virtual void setTalent(const rl::CeGuiString talentName, int value);
+        virtual void modifyTalent(const rl::CeGuiString talentName, int mod);
+        virtual void addSe(const rl::CeGuiString talentName);
+        
+        void addVorteil(const rl::CeGuiString vorteilName, int value = 0);
+        void addNachteil(const rl::CeGuiString nachteilName, int value = 0);        
+        
+        void addKampftechnik(const rl::CeGuiString kampftechnikName, std::pair<int,int> value = make_pair(0,0));
+        virtual void addSf(const rl::CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
+        
+        virtual int doTalentprobe(const rl::CeGuiString talentName, int modifier);
+        virtual int doEigenschaftsprobe(const rl::CeGuiString eigenschaftName, int modifier);
+        
+        rl::Inventory* getInventory();
+        
+        void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
+        static const int LEDAMAGE_NORMAL = 0;
+        static const int LEDAMAGE_FIRE = 1;
+        static const int LEDAMAGE_WATER = 2;
+        static const int LEDAMAGE_DEMONIC = 4;
+        void damageAu(int aup, int damageType = AUDAMAGE_NORMAL);
+        static const int AUDAMAGE_NORMAL = 0;
+        static const int AUDAMAGE_HEAT = 1;
+        static const int AUDAMAGE_COLD = 2;
+        static const int AUDAMAGE_CHOKE = 4;
+        static const int AUDAMAGE_DROWN = 8;
+
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+
+        void setAlignment(Alignment);
+        Alignment getAlignment() const;
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+   };
+   
+    %feature("director") ActionManager;
+    class ActionManager
+    {
+    public:
+        void registerAction(rl::Action* action);
+        void unregisterAction(const rl::CeGuiString actionName);
+        rl::Action* getAction(const rl::CeGuiString actionName) const;
+
+        void registerInGameGlobalAction(rl::Action* action, rl::ActionGroup* group);
+    
+        static rl::ActionManager& getSingleton();
+    };
+    
+    class CreatureController
+    {
+    public:
+        
+        typedef enum
+        {
+            // these movements can be used
+            MT_NONE,
+            MT_STEHEN,
+            MT_GEHEN,
+            MT_JOGGEN,
+            MT_LAUFEN,
+            MT_RENNEN,
+            MT_RUECKWAERTS_GEHEN,
+            MT_RUECKWAERTS_JOGGEN,
+            MT_SEITWAERTS_GEHEN,
+            MT_SCHLEICHEN,
+            MT_HOCHSPRUNG,
+            MT_WEITSPRUNG,
+            MT_ZIELSPRUNG,
+            // these movements are only for internal purposes and should not be used directly
+            // instead use one of the movements above
+            MT_DREHEN,
+            MT_STUFENERKENNUNG,
+            MT_FALLEN,
+            MT_LIEGEN
+        } MovementType;
+        
+        Creature *getCreature();
+        bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        MovementType getMovementId() const;
+        Ogre::Vector3 getDirection() const;
+        Ogre::Vector3 getRotation() const;
+        Ogre::Vector3 getVelocity() const;
+        Ogre::Vector3 getOmega() const;
+        void setAnimation(const Ogre::String &name, 
+                          Ogre::Real speed = 1, 
+                          unsigned int timesToPlay = 0, 
+                          const Ogre::String &collisionName = "");
+    protected:
+        CreatureController(Creature *character);
+        ~CreatureController();
+    };
+    
+    class CreatureControllerManager
+    {
+    public:
+        /// Returns a CreatureController that can be used to control given Creature.
+        /// There is only one controller per Creature at a given time.
+        /// If no such controller exists yet, it is created.
+        rl::CreatureController* getCreatureController(rl::Creature* creature);
+
+        /// This function detaches a controller attached to the given Creature, if any.
+        void detachController(rl::Creature* creature);
+
+        static rl::CreatureControllerManager& getSingleton();
+    };
+
+	// Before first use of Selector or subclasses!
+    %apply SWIGTYPE *DYNAMIC { rl::Selector* };
+
+	class Selector
+    {
+    public:
+        Selector(unsigned long mask = 0xffffffff);
+        virtual void updateSelection();
+
+        void setSelectionMask(unsigned long mask);
+        unsigned long getSelectionMask() const;
+
+        GameObject* getFirstSelectedObject() const;
+		const std::vector<GameObject*>& getAllSelectedObjects() const;
+		unsigned int getSelectionCount() const;
+
+		virtual void updatePrimitive() = 0;
+    };
+
+
+    /// A Selector that selects all unoccluded GameObject the ray hits.
+    class RaySelector : public Selector
+    {
+    public:
+        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
+        void setRay(const Ogre::Vector3& start, const Ogre::Vector3& end);
+		virtual void updatePrimitive();
+    };
+
+    /// Selects this GameObject within a half sphere pointing to -Z,
+    /// that has the smallest angle difference to the -Z-Axis.
+    class HalfSphereSelector : public Selector
+    {
+    public:
+        HalfSphereSelector(unsigned long mask = 0xffffffff);
+	    void setRadius(Ogre::Real radius);
+        void setPosition(const Ogre::Vector3& pos);
+        void setOrientation(const Ogre::Quaternion& ori);
+		virtual void updatePrimitive();
+	};
+    
+    class PartyManager
+    {
+    public:
+        void setActiveCharacter(Creature* character);
+        Creature* getActiveCharacter() const;
+        void addCharacter(Creature* character);
+        void removeCharacter(Creature* character);
+        static PartyManager& getSingleton();
+    };
+
+} // Namespace
+
+%{
+static swig_type_info *Selector_dynamic_cast(void **ptr)
+{
+	rl::Selector *pSelector = static_cast<rl::Selector*>(*ptr);
+	rl::HalfSphereSelector *pHalfSphereSel = dynamic_cast<rl::HalfSphereSelector*>(pSelector);
+	if (pHalfSphereSel)
+	{
+		*ptr = pHalfSphereSel;
+		return SWIGTYPE_p_rl__HalfSphereSelector;
+	}
+	rl::RaySelector *pRaySel = dynamic_cast<rl::RaySelector*>(pSelector);
+	if (pRaySel)
+	{
+		*ptr = pRaySel;
+		return SWIGTYPE_p_rl__RaySelector;
+	}
+}
+	
+static swig_type_info *GameObject_dynamic_cast(void **ptr)
+{
+    rl::GameObject *pGameObject = static_cast<rl::GameObject*>(*ptr);
+
+    rl::Creature *pCreature=dynamic_cast<rl::Creature*>(pGameObject);
+    if (pCreature) {
+        *ptr=pCreature;
+        return SWIGTYPE_p_rl__Creature;
+    }
+    rl::Weapon *pWeapon=dynamic_cast<rl::Weapon*>(pGameObject);
+    if (pWeapon) {
+        *ptr=pWeapon;
+        return SWIGTYPE_p_rl__Weapon;
+    }
+    rl::Armor *pArmor=dynamic_cast<rl::Armor*>(pGameObject);
+    if (pArmor) {
+        *ptr=pArmor;
+        return SWIGTYPE_p_rl__Armor;
+    }
+    rl::Container *pContainer=dynamic_cast<rl::Container*>(pGameObject);
+    if (pContainer) {
+        *ptr=pContainer;
+        return SWIGTYPE_p_rl__Container;
+    }
+    rl::Item *pItem=dynamic_cast<rl::Item*>(pGameObject);
+    if (pItem) {
+        *ptr=pItem;
+        return SWIGTYPE_p_rl__Item;
+    }
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__GameObject, GameObject_dynamic_cast);
+

Modified: rl/trunk/engine/script/swig/RlUi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.swig	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/script/swig/RlUi.swig	2008-09-17 22:24:26 UTC (rev 4511)
@@ -1,162 +1,159 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-namespace rl {
-
-%apply SWIGTYPE *DYNAMIC { rl::ControlState * };
-
-%feature("director") ControlState;
-class ControlState
-{
-private:
-    ControlState(rl::Actor* camera, rl::Actor* character);
-public:
-};
-
-class CutsceneControlState : public ControlState
-{
-private:
-       CutsceneControlState(rl::Actor* camera);
-
-public:
-    virtual ~CutsceneControlState();
-
-    void setCameraPosition(const Ogre::Vector3& pos);
-    void setCameraOrientation(const Ogre::Quaternion& orient);
-    void lookAt(const Ogre::Vector3& point);
-};
-
-class UiSubsystem
-{
-public:
-    static UiSubsystem& getSingleton(void);
-    void initializeSubsystem();
-
-    rl::Creature* getActiveCharacter();
-    void setActiveCharacter(rl::Creature* chara);
-};
-
-enum ControlStateType 
-{
-    CST_NONE = 1,
-    CST_FREEFLIGHT,
-    CST_MOVEMENT,
-    CST_DIALOG,
-    CST_CUTSCENE,
-    CST_COMBAT,
-};
-
-class InputManager
-{
-public:
-    static InputManager& getSingleton(void);
-
-    void pushControlState(rl::ControlStateType);
-    void popControlState();
-
-    void linkKeyToRubyCommand(const rl::CeGuiString &key, const rl::CeGuiString &command);
-private:
-    InputManager();
-};
-
-class WindowFactory
-{
-public:
-    enum PopupType
-    {
-        ICON_ERROR = 1,
-        ICON_QUEST
-    };
-
-    static rl::WindowFactory& getSingleton();
-
-    void update();
-
-    void showAboutWindow();
-    void showActionChoice(rl::GameObject* obj);
-    void showCharacterActionChoice();
-    void showCharacterSheet();
-    void showCharacterSheet(rl::Creature* chara);
-    void showContainerContent(rl::Container* container);
-    void showDescriptionWindow(rl::GameObject* obj);
-    void showPropertiesWindow(rl::GameObject* obj);
-    void showGameSaveLoadWindow();
-    void showExitConfirmation();
-    void showJournalWindow();
-    void showLogfiles();
-    void showMainMenu();
-    void showMessageWindow(const rl::CeGuiString& message);
-    void showPlaylist();
-    void showPopupMessage(int popupTypes);
-    void showGameSettings();
-
-    void toggleConsole();
-    void toggleDebugWindow();
-    void toggleGameLogWindow();
-    void toggleCharacterStateWindow();
-    void toggleInGameGlobalMenu();
-    void toggleInventoryWindow();
-
-    void checkForErrors();
-    rl::GameLoggerWindow* getGameLogger();
-
-    void showNextDebugWindowPage();
-};
-
-class WindowManager
-{
-public:
-    static rl::WindowManager& getSingleton();
-    void closeTopWindow();
-};
-
-%feature("director") MessageWindow; 
-class MessageWindow
-{
-public:
-    enum Buttons 
-    {
-        OK,
-        YES_NO
-    };
-
-    MessageWindow::MessageWindow(
-        const rl::CeGuiString& title, 
-        const rl::CeGuiString& text, 
-        const Buttons buttons);
-    virtual ~MessageWindow();
-    virtual bool onButtonClicked(int button, const rl::CeGuiString& text);
-    void setVisible(bool visible);
-};
-
-} //namespace rl
-
-%{
-static swig_type_info *ControlState_dynamic_cast(void **ptr)
-{
-    rl::ControlState *pControlState =
-        static_cast<rl::ControlState*>(*ptr);
-
-    rl::CutsceneControlState *pCutSceneCS =
-        dynamic_cast<rl::CutsceneControlState*>(pControlState);
-    if (pCutSceneCS != NULL) {
-        *ptr=pCutSceneCS;
-        return SWIGTYPE_p_rl__CutsceneControlState;
-    }
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__ControlState, ControlState_dynamic_cast);
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+namespace rl {
+
+%apply SWIGTYPE *DYNAMIC { rl::ControlState * };
+
+%feature("director") ControlState;
+class ControlState
+{
+private:
+    ControlState(rl::Actor* camera, rl::Actor* character);
+public:
+};
+
+class CutsceneControlState : public ControlState
+{
+private:
+       CutsceneControlState(rl::Actor* camera);
+
+public:
+    virtual ~CutsceneControlState();
+
+    void setCameraPosition(const Ogre::Vector3& pos);
+    void setCameraOrientation(const Ogre::Quaternion& orient);
+    void lookAt(const Ogre::Vector3& point);
+};
+
+class UiSubsystem
+{
+public:
+    static UiSubsystem& getSingleton(void);
+    void initializeSubsystem();
+};
+
+enum ControlStateType 
+{
+    CST_NONE = 1,
+    CST_FREEFLIGHT,
+    CST_MOVEMENT,
+    CST_DIALOG,
+    CST_CUTSCENE,
+    CST_COMBAT,
+};
+
+class InputManager
+{
+public:
+    static InputManager& getSingleton(void);
+
+    void pushControlState(rl::ControlStateType);
+    void popControlState();
+
+    void linkKeyToRubyCommand(const rl::CeGuiString &key, const rl::CeGuiString &command);
+private:
+    InputManager();
+};
+
+class WindowFactory
+{
+public:
+    enum PopupType
+    {
+        ICON_ERROR = 1,
+        ICON_QUEST
+    };
+
+    static rl::WindowFactory& getSingleton();
+
+    void update();
+
+    void showAboutWindow();
+    void showActionChoice(rl::GameObject* obj);
+    void showCharacterActionChoice();
+    void showCharacterSheet();
+    void showCharacterSheet(rl::Creature* chara);
+    void showContainerContent(rl::Container* container);
+    void showDescriptionWindow(rl::GameObject* obj);
+    void showPropertiesWindow(rl::GameObject* obj);
+    void showGameSaveLoadWindow();
+    void showExitConfirmation();
+    void showJournalWindow();
+    void showLogfiles();
+    void showMainMenu();
+    void showMessageWindow(const rl::CeGuiString& message);
+    void showPlaylist();
+    void showPopupMessage(int popupTypes);
+    void showGameSettings();
+
+    void toggleConsole();
+    void toggleDebugWindow();
+    void toggleGameLogWindow();
+    void toggleCharacterStateWindow();
+    void toggleInGameGlobalMenu();
+    void toggleInventoryWindow();
+
+    void checkForErrors();
+    rl::GameLoggerWindow* getGameLogger();
+
+    void showNextDebugWindowPage();
+};
+
+class WindowManager
+{
+public:
+    static rl::WindowManager& getSingleton();
+    void closeTopWindow();
+};
+
+%feature("director") MessageWindow; 
+class MessageWindow
+{
+public:
+    enum Buttons 
+    {
+        OK,
+        YES_NO
+    };
+
+    MessageWindow::MessageWindow(
+        const rl::CeGuiString& title, 
+        const rl::CeGuiString& text, 
+        const Buttons buttons);
+    virtual ~MessageWindow();
+    virtual bool onButtonClicked(int button, const rl::CeGuiString& text);
+    void setVisible(bool visible);
+};
+
+} //namespace rl
+
+%{
+static swig_type_info *ControlState_dynamic_cast(void **ptr)
+{
+    rl::ControlState *pControlState =
+        static_cast<rl::ControlState*>(*ptr);
+
+    rl::CutsceneControlState *pCutSceneCS =
+        dynamic_cast<rl::CutsceneControlState*>(pControlState);
+    if (pCutSceneCS != NULL) {
+        *ptr=pCutSceneCS;
+        return SWIGTYPE_p_rl__CutsceneControlState;
+    }
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__ControlState, ControlState_dynamic_cast);

Modified: rl/trunk/engine/ui/include/UiMessages.h
===================================================================
--- rl/trunk/engine/ui/include/UiMessages.h	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/ui/include/UiMessages.h	2008-09-17 22:24:26 UTC (rev 4511)
@@ -37,10 +37,7 @@
 
         RLMSG_COMBAT_IO_ATTACK_OPPONENT = 0x04000103,
         RLMSG_COMBAT_IO_PARRY_OPPONENT = 0x04000104,
-        RLMSG_COMBAT_IO_END_TURN_REQUESTED = 0x04000105,
-
-        // Character change
-        RLMSG_ACTIVE_CHARACTER_CHANGED = 0x04000201
+        RLMSG_COMBAT_IO_END_TURN_REQUESTED = 0x04000105
     };
 
     /// Message sent after enemy action button has been pressed.
@@ -53,7 +50,5 @@
     typedef MessageType<RLMSG_COMBAT_IO_ATTACK_OPPONENT, Combatant*> MessageType_CombatIoAttackOpponent;
     typedef MessageType<RLMSG_COMBAT_IO_PARRY_OPPONENT, Combatant*> MessageType_CombatIoParryOpponent;
     typedef MessageType<RLMSG_COMBAT_IO_END_TURN_REQUESTED> MessageType_CombatIoEndTurnRequested;
-
-    typedef MessageType<RLMSG_ACTIVE_CHARACTER_CHANGED, Creature*> MessageType_ActiveCharacterChanged;
 }
 #endif

Modified: rl/trunk/engine/ui/include/UiSubsystem.h
===================================================================
--- rl/trunk/engine/ui/include/UiSubsystem.h	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/ui/include/UiSubsystem.h	2008-09-17 22:24:26 UTC (rev 4511)
@@ -1,84 +1,89 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __UiSubsystem_H__
-#define __UiSubsystem_H__
-
-#include "UiPrerequisites.h"
-#include "World.h"
-
-
-#include "ControlState.h"
-#include "MessagePump.h"
-
-// Gar nicht sch?n, aber ansonsten gibt es unn?tige Abh?ngigkeiten,
-// wenn man die Header hier inkludiert.
-namespace CEGUI {
-    class OgreCEGUIRenderer;
-    class OgreCEGUIResourceProvider;
-    class System;
-}
-
-namespace rl {
-
-    class Creature;
-    class GameActor;
-    class GameObject;
-    class InputManager;
-    class WindowFactory;
-    class WindowManager;
-
-    class _RlUiExport UiSubsystem : public Ogre::Singleton<UiSubsystem>
-    {
-    public:
-        static const char* CEGUI_ROOT;
-
-        /** Default Constructor */
-        UiSubsystem();
-        /** Default Deconstructor */
-        virtual ~UiSubsystem();
-
-        CEGUI::OgreCEGUIRenderer* getGUIRenderer();
-        Creature* getActiveCharacter() const;
-        ///@todo function feels misplaced here,
-        void setActiveCharacter(Creature* person);
-
-        virtual bool onBeforeClearScene();
-        virtual bool onBeforeGameObjectsLoaded();
-        virtual bool onGameObjectsLoaded();
-
-        void initializeSubsystem();
-
-    private:
-        Creature* mCharacter;
-        int mCharacterId;
-
-	    MessagePump::ScopedConnection mSceneClearingConnection;
-        MessagePump::ScopedConnection mGameObjectsLoadedConnection;
-        MessagePump::ScopedConnection mBeforeLoadingGameObjectsConnection;
-
-        // Singletons
-        InputManager* mInputManager;
-        WindowFactory* mWindowFactory;
-        WindowManager* mWindowManager;
-
-        CEGUI::OgreCEGUIRenderer* mGuiRenderer;
-        CEGUI::ResourceProvider* mGuiResourceProvider;
-        CEGUI::System* mGuiSystem;
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __UiSubsystem_H__
+#define __UiSubsystem_H__
+
+#include "UiPrerequisites.h"
+#include "World.h"
+
+
+#include "ControlState.h"
+#include "MessagePump.h"
+#include "Effect.h"
+
+// Gar nicht sch??n, aber ansonsten gibt es unn??tige Abh???ngigkeiten,
+// wenn man die Header hier inkludiert.
+namespace CEGUI {
+    class OgreCEGUIRenderer;
+    class OgreCEGUIResourceProvider;
+    class System;
+}
+
+namespace rl {
+
+    class Creature;
+    class GameActor;
+    class GameObject;
+    class InputManager;
+    class WindowFactory;
+    class WindowManager;
+
+    class _RlUiExport UiSubsystem : public Ogre::Singleton<UiSubsystem>
+    {
+    public:
+        static const char* CEGUI_ROOT;
+
+        /** Default Constructor */
+        UiSubsystem();
+        /** Default Deconstructor */
+        virtual ~UiSubsystem();
+
+        CEGUI::OgreCEGUIRenderer* getGUIRenderer();
+
+        void initializeSubsystem();
+
+    private:
+        Creature* mCharacter;
+        int mCharacterId;
+
+	    MessagePump::ScopedConnection mSceneClearingConnection;
+        MessagePump::ScopedConnection mGameObjectsLoadedConnection;
+        MessagePump::ScopedConnection mBeforeLoadingGameObjectsConnection;
+        MessagePump::ScopedConnection mActiveCharacterChangedConnection;
+        MessagePump::ScopedConnection mAllPlayerCharactersDiedConnection;
+
+        bool onBeforeClearScene();
+        bool onBeforeGameObjectsLoaded();
+        bool onGameObjectsLoaded();
+        ///@todo function feels misplaced here,
+        bool onActiveCharacterChanged(Creature* oldActive, Creature* newActive);
+        bool onAllPlayerCharactersDied();
+        
+
+        // Singletons
+        InputManager* mInputManager;
+        WindowFactory* mWindowFactory;
+        WindowManager* mWindowManager;
+
+        CEGUI::OgreCEGUIRenderer* mGuiRenderer;
+        CEGUI::ResourceProvider* mGuiResourceProvider;
+        CEGUI::System* mGuiSystem;
+        
+    };
+}
+
+#endif

Modified: rl/trunk/engine/ui/include/WindowFactory.h
===================================================================
--- rl/trunk/engine/ui/include/WindowFactory.h	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/ui/include/WindowFactory.h	2008-09-17 22:24:26 UTC (rev 4511)
@@ -86,6 +86,7 @@
         void showMainMenuLoadWindow(MainMenuWindow* win);
 		void hideMainMenuLoadWindow();
         void showPopupMessage(int popupTypes);
+        void showGameOverWindow();
         /**
          * Creates a GameSettings object and displays its layout file on screen
          */

Modified: rl/trunk/engine/ui/src/DebugWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DebugWindow.cpp	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/ui/src/DebugWindow.cpp	2008-09-17 22:24:26 UTC (rev 4511)
@@ -1,235 +1,236 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "UiPrerequisites.h"
-
-#include "UiSubsystem.h"
-#include "DebugWindow.h"
-#include "InputManager.h"
-#include "GameLoop.h"
-
-#include "Actor.h"
-#include "ActorManager.h"
-#include "CameraObject.h"
-#include "CoreSubsystem.h"
-#include "Creature.h"
-#include "Exception.h"
-#include "MeshObject.h"
-
-using namespace CEGUI;
-using namespace Ogre;
-
-template<> rl::DebugWindow* Ogre::Singleton<rl::DebugWindow>::ms_Singleton = 0;
-
-namespace rl
-{
-    DebugWindow::DebugWindow() : AbstractWindow("debugwindow.xml", WIT_NONE),
-          mMessageText(),
-          mPageCaption(),
-          mPageText(),
-          mPageTexts(),
-          mCurrentPage(StringUtil::BLANK),
-          mDebugPageName("General Informations")
-    {
-        mPageCaption = getWindow("DebugWindow/PageCaption");
-        mPageCaption->moveToFront();
-
-        mPageText = getMultiLineEditbox("DebugWindow/PageText");
-
-        mMessageText = getWindow("DebugWindow/MessageText");
-        mMessageText->moveToFront();
-
-        bindDestroyWindowToXButton();
-        registerPage("General Informations");
-    }
-
-    DebugWindow::~DebugWindow()
-    {
-        unregisterPage("General Informations");
-    }
-
-    void DebugWindow::registerPage(const Ogre::String& page)
-    {
-        if (mPageTexts.find(page) != mPageTexts.end())
-        {
-            LOG_ERROR("DebugWindow", page + " already registered as a page.");
-        }
-        else
-        {
-            mPageTexts.insert(make_pair(page, StringUtil::BLANK));
-        }
-
-        // If this is the first page, activate it
-        if (mCurrentPage == StringUtil::BLANK)
-        {
-            mCurrentPage = page;
-        }
-    }
-
-    void DebugWindow::unregisterPage(const Ogre::String& page)
-    {
-        PageTextMap::iterator it = mPageTexts.find(page);
-        if (it != mPageTexts.end())
-        {
-            mPageTexts.erase(it);
-        }
-        else
-        {
-            Throw(IllegalArgumentException, page + " is not registered as a page.");
-        }
-
-        // If this is the current page, switch over to the next
-        // or clear text, if no other page is left.
-        if (mCurrentPage == page && !mPageTexts.empty())
-        {
-            mCurrentPage = page;
-        }
-        else if (mCurrentPage == page)
-        {
-            mCurrentPage = StringUtil::BLANK;
-        }
-        updatePageText();
-    }
-
-    void DebugWindow::setPageText(const Ogre::String& page, const Ogre::String& text)
-    {
-        PageTextMap::iterator it = mPageTexts.find(page);
-        if (it == mPageTexts.end())
-        {
-            LOG_ERROR("DebugWindow", page + " is not registered as a page.");
-        }
-        else
-        {
-            it->second = text;
-        }
-
-        if (mCurrentPage == page)
-        {
-            updatePageText();
-        }
-    }
-
-    void DebugWindow::setMessageText(const Ogre::String& text)
-    {
-        CeGuiString o(text.c_str());
-        mMessageText->setText(o);
-    }
-
-    void DebugWindow::showNextPage()
-    {
-        PageTextMap::iterator it = mPageTexts.find(mCurrentPage);
-        if (it != mPageTexts.end())
-        {
-            ++it;
-            if (it == mPageTexts.end())
-            {
-                it = mPageTexts.begin();
-            }
-            mCurrentPage = it->first;
-            updatePageText();
-        }
-        else
-        {
-            RlAssert1(mPageTexts.empty());
-        }
-    }
-
-    void DebugWindow::run(Ogre::Real elapsedTime)
-    {
-        updateFps();
-    }
-
-    void DebugWindow::updatePageText()
-    {
-        Ogre::String text = mCurrentPage == StringUtil::BLANK ?
-            StringUtil::BLANK : mPageTexts[mCurrentPage];
-        mPageCaption->setText(mCurrentPage);
-        mPageText->setText(text);
-    }
-
-    void DebugWindow::updateFps()
-    {
-        const RenderTarget::FrameStats& stats = CoreSubsystem::getSingleton().getRenderWindow()->getStatistics();
-
-        Ogre::String textSt = "Current FPS: " +
-            StringConverter::toString(stats.lastFPS)+
-            "\nBest/worst/avg FPS: " +
-            StringConverter::toString(stats.bestFPS) + "/" +
-            StringConverter::toString(stats.worstFPS) + "/" +
-            StringConverter::toString(stats.avgFPS)+
-            "\nBest/worst Frame times: " +
-            StringConverter::toString(stats.bestFPS) + "/" +
-            StringConverter::toString(stats.worstFPS)+
-            "\nTriangle Count: " +
-            StringConverter::toString(stats.triangleCount);
-
-        if (UiSubsystem::getSingleton().getActiveCharacter() != NULL &&
-            UiSubsystem::getSingleton().getActiveCharacter()->getActor() != NULL)
-        {
-            ActorControlledObject* charObj = UiSubsystem::getSingletonPtr()->
-                getActiveCharacter()->getActor()->getControlledObject();
-
-            if( charObj != NULL )
-            {
-                Ogre::Vector3 pos = charObj->getMovableObject()->getParentNode()->getWorldPosition();
-                Ogre::Quaternion ori = charObj->getMovableObject()->getParentNode()->getWorldOrientation();
-
-                textSt += "\nPlayer Position [ "
-                    + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+", "
-                    + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+", "
-                    + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+" ]";
-
-                textSt += "\nPlayer Orientation [ "
-                    + StringConverter::toString(ori.w,4,0,32,std::ios_base::fixed)+", "
-                    + StringConverter::toString(ori.x,2,0,32,std::ios_base::fixed)+", "
-                    + StringConverter::toString(ori.y,2,0,32,std::ios_base::fixed)+", "
-                    + StringConverter::toString(ori.z,2,0,32,std::ios_base::fixed)+" ]";
-            }
-        }
-
-        Actor* camActor = ActorManager::getSingleton().getActor("DefaultCamera");
-        if( camActor != 0 && camActor->_getSceneNode() != NULL )
-        {
-            Ogre::Camera* cam = dynamic_cast<CameraObject*>(camActor->getControlledObject())->getCamera();
-            Ogre::Vector3 pos = cam->getDerivedPosition();
-
-            textSt += "\nCamera Position [ "
-                + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+", "
-                + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+", "
-                + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+" ]";
-        }
-
-        setPageText(mDebugPageName, textSt);
-    }
-
-    void DebugWindow::setVisible(bool visible, bool destroyAfterHide)
-    {
-        AbstractWindow::setVisible(visible, destroyAfterHide);
-        if (visible)
-            GameLoop::getSingleton().addTask(this, GameLoop::TG_GRAPHICS);
-        else
-            GameLoop::getSingleton().removeTask(this);
-    }
-
-    const Ogre::String& DebugWindow::getName() const
-    {
-        static Ogre::String NAME = "DebugWindow";
-
-        return NAME;
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include "UiPrerequisites.h"
+
+#include "UiSubsystem.h"
+#include "DebugWindow.h"
+#include "InputManager.h"
+#include "GameLoop.h"
+
+#include "Actor.h"
+#include "ActorManager.h"
+#include "CameraObject.h"
+#include "CoreSubsystem.h"
+#include "Creature.h"
+#include "Exception.h"
+#include "MeshObject.h"
+#include "PartyManager.h"
+
+using namespace CEGUI;
+using namespace Ogre;
+
+template<> rl::DebugWindow* Ogre::Singleton<rl::DebugWindow>::ms_Singleton = 0;
+
+namespace rl
+{
+    DebugWindow::DebugWindow() : AbstractWindow("debugwindow.xml", WIT_NONE),
+          mMessageText(),
+          mPageCaption(),
+          mPageText(),
+          mPageTexts(),
+          mCurrentPage(StringUtil::BLANK),
+          mDebugPageName("General Informations")
+    {
+        mPageCaption = getWindow("DebugWindow/PageCaption");
+        mPageCaption->moveToFront();
+
+        mPageText = getMultiLineEditbox("DebugWindow/PageText");
+
+        mMessageText = getWindow("DebugWindow/MessageText");
+        mMessageText->moveToFront();
+
+        bindDestroyWindowToXButton();
+        registerPage("General Informations");
+    }
+
+    DebugWindow::~DebugWindow()
+    {
+        unregisterPage("General Informations");
+    }
+
+    void DebugWindow::registerPage(const Ogre::String& page)
+    {
+        if (mPageTexts.find(page) != mPageTexts.end())
+        {
+            LOG_ERROR("DebugWindow", page + " already registered as a page.");
+        }
+        else
+        {
+            mPageTexts.insert(make_pair(page, StringUtil::BLANK));
+        }
+
+        // If this is the first page, activate it
+        if (mCurrentPage == StringUtil::BLANK)
+        {
+            mCurrentPage = page;
+        }
+    }
+
+    void DebugWindow::unregisterPage(const Ogre::String& page)
+    {
+        PageTextMap::iterator it = mPageTexts.find(page);
+        if (it != mPageTexts.end())
+        {
+            mPageTexts.erase(it);
+        }
+        else
+        {
+            Throw(IllegalArgumentException, page + " is not registered as a page.");
+        }
+
+        // If this is the current page, switch over to the next
+        // or clear text, if no other page is left.
+        if (mCurrentPage == page && !mPageTexts.empty())
+        {
+            mCurrentPage = page;
+        }
+        else if (mCurrentPage == page)
+        {
+            mCurrentPage = StringUtil::BLANK;
+        }
+        updatePageText();
+    }
+
+    void DebugWindow::setPageText(const Ogre::String& page, const Ogre::String& text)
+    {
+        PageTextMap::iterator it = mPageTexts.find(page);
+        if (it == mPageTexts.end())
+        {
+            LOG_ERROR("DebugWindow", page + " is not registered as a page.");
+        }
+        else
+        {
+            it->second = text;
+        }
+
+        if (mCurrentPage == page)
+        {
+            updatePageText();
+        }
+    }
+
+    void DebugWindow::setMessageText(const Ogre::String& text)
+    {
+        CeGuiString o(text.c_str());
+        mMessageText->setText(o);
+    }
+
+    void DebugWindow::showNextPage()
+    {
+        PageTextMap::iterator it = mPageTexts.find(mCurrentPage);
+        if (it != mPageTexts.end())
+        {
+            ++it;
+            if (it == mPageTexts.end())
+            {
+                it = mPageTexts.begin();
+            }
+            mCurrentPage = it->first;
+            updatePageText();
+        }
+        else
+        {
+            RlAssert1(mPageTexts.empty());
+        }
+    }
+
+    void DebugWindow::run(Ogre::Real elapsedTime)
+    {
+        updateFps();
+    }
+
+    void DebugWindow::updatePageText()
+    {
+        Ogre::String text = mCurrentPage == StringUtil::BLANK ?
+            StringUtil::BLANK : mPageTexts[mCurrentPage];
+        mPageCaption->setText(mCurrentPage);
+        mPageText->setText(text);
+    }
+
+    void DebugWindow::updateFps()
+    {
+        const RenderTarget::FrameStats& stats = CoreSubsystem::getSingleton().getRenderWindow()->getStatistics();
+
+        Ogre::String textSt = "Current FPS: " +
+            StringConverter::toString(stats.lastFPS)+
+            "\nBest/worst/avg FPS: " +
+            StringConverter::toString(stats.bestFPS) + "/" +
+            StringConverter::toString(stats.worstFPS) + "/" +
+            StringConverter::toString(stats.avgFPS)+
+            "\nBest/worst Frame times: " +
+            StringConverter::toString(stats.bestFPS) + "/" +
+            StringConverter::toString(stats.worstFPS)+
+            "\nTriangle Count: " +
+            StringConverter::toString(stats.triangleCount);
+
+        if (PartyManager::getSingleton().getActiveCharacter() != NULL &&
+            PartyManager::getSingleton().getActiveCharacter()->getActor() != NULL)
+        {
+            ActorControlledObject* charObj = PartyManager::getSingletonPtr()->
+                getActiveCharacter()->getActor()->getControlledObject();
+
+            if( charObj != NULL )
+            {
+                Ogre::Vector3 pos = charObj->getMovableObject()->getParentNode()->getWorldPosition();
+                Ogre::Quaternion ori = charObj->getMovableObject()->getParentNode()->getWorldOrientation();
+
+                textSt += "\nPlayer Position [ "
+                    + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+", "
+                    + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+", "
+                    + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+" ]";
+
+                textSt += "\nPlayer Orientation [ "
+                    + StringConverter::toString(ori.w,4,0,32,std::ios_base::fixed)+", "
+                    + StringConverter::toString(ori.x,2,0,32,std::ios_base::fixed)+", "
+                    + StringConverter::toString(ori.y,2,0,32,std::ios_base::fixed)+", "
+                    + StringConverter::toString(ori.z,2,0,32,std::ios_base::fixed)+" ]";
+            }
+        }
+
+        Actor* camActor = ActorManager::getSingleton().getActor("DefaultCamera");
+        if( camActor != 0 && camActor->_getSceneNode() != NULL )
+        {
+            Ogre::Camera* cam = dynamic_cast<CameraObject*>(camActor->getControlledObject())->getCamera();
+            Ogre::Vector3 pos = cam->getDerivedPosition();
+
+            textSt += "\nCamera Position [ "
+                + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+", "
+                + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+", "
+                + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+" ]";
+        }
+
+        setPageText(mDebugPageName, textSt);
+    }
+
+    void DebugWindow::setVisible(bool visible, bool destroyAfterHide)
+    {
+        AbstractWindow::setVisible(visible, destroyAfterHide);
+        if (visible)
+            GameLoop::getSingleton().addTask(this, GameLoop::TG_GRAPHICS);
+        else
+            GameLoop::getSingleton().removeTask(this);
+    }
+
+    const Ogre::String& DebugWindow::getName() const
+    {
+        static Ogre::String NAME = "DebugWindow";
+
+        return NAME;
+    }
+
+}

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2008-09-17 22:24:26 UTC (rev 4511)
@@ -51,6 +51,7 @@
 #include "Job.h"
 #include "JobScheduler.h"
 #include "MovementControlState.h"
+#include "PartyManager.h"
 #include "RubyInterpreter.h"
 #include "UiSubsystem.h"
 #include "WindowFactory.h"
@@ -394,7 +395,7 @@
     void InputManager::pushControlState(ControlStateType controlStateType)
     {
         Actor* camera = ActorManager::getSingleton().getActor("DefaultCamera");
-        Creature* character = UiSubsystem::getSingleton().getActiveCharacter();
+        Creature* character = PartyManager::getSingleton().getActiveCharacter();
 
         ControlState* controller = NULL;
         switch (controlStateType)

Modified: rl/trunk/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ui/src/UiSubsystem.cpp	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/ui/src/UiSubsystem.cpp	2008-09-17 22:24:26 UTC (rev 4511)
@@ -40,6 +40,7 @@
 #include "GameObjectManager.h"
 #include "InputManager.h"
 #include "Logger.h"
+#include "RulesMessages.h"
 #include "ScriptWrapper.h"
 #include "SoundManager.h"
 #include "UiMessages.h"
@@ -70,6 +71,9 @@
         mBeforeLoadingGameObjectsConnection = 
             MessagePump::getSingleton().addMessageHandler<MessageType<RLMSG_SAVEGAME_LOADING> >(
                 boost::bind(&UiSubsystem::onBeforeGameObjectsLoaded, this));
+        mActiveCharacterChangedConnection = 
+            MessagePump::getSingleton().addMessageHandler<MessageType_ActivePlayerCharChanged>(
+                boost::bind(&UiSubsystem::onActiveCharacterChanged, this, _1, _2));
         mWindowFactory = new WindowFactory();
     }
 
@@ -149,58 +153,47 @@
         return mGuiRenderer;
     }
 
-    Creature* UiSubsystem::getActiveCharacter() const
+    bool UiSubsystem::onActiveCharacterChanged(Creature* oldActive, Creature* newActive)
     {
-        return mCharacter;
-    }
-
-    void UiSubsystem::setActiveCharacter(Creature* creature)
-    {
         // Ensure we have a sound listener
         if (SoundManager::getSingleton().getListenerActor() == NULL)
         {
             SoundManager::getSingleton().createListenerActor();
         }
 
-        if (creature != mCharacter )
+        if (oldActive)
         {
-            if (mCharacter)
+            ScriptWrapper::getSingleton().disowned( oldActive );
+            if (oldActive->getActor())
             {
-                ScriptWrapper::getSingleton().disowned( mCharacter );
-                if (mCharacter->getActor())
-                {
-                    mCharacter->getActor()->detach(SoundManager::getSingleton().getListenerActor());
-                }
-                mCharacter->setQueryFlags(mCharacter->getQueryFlags() & (~QUERYFLAG_PLAYER));
+                oldActive->getActor()->detach(SoundManager::getSingleton().getListenerActor());
             }
-
-            if (!creature)
-            {
-                mCharacter = NULL;
-                mInputManager->clearControlStates();
-            }
-            else
-            {
-                ScriptWrapper::getSingleton().owned(creature);
-                mCharacter = creature;
-                mCharacter->addQueryFlag(QUERYFLAG_PLAYER);
-
-                mWindowFactory->setActiveCharacter(creature);
-
-                mCharacter->getActor()->attach(SoundManager::getSingleton().getListenerActor());
-                LOG_MESSAGE(Logger::UI, "SoundListener attached.");
-
-                // Reset control stack for the new Character and set to movement.
-                mInputManager->setControlState(CST_MOVEMENT);
-            }
-
-            MessagePump::getSingleton().sendMessage<MessageType_ActiveCharacterChanged>(creature);
+            oldActive->setQueryFlags(oldActive->getQueryFlags() & (~QUERYFLAG_PLAYER));
         }
+        
+        if (!newActive)
+        {
+            mInputManager->clearControlStates();
+        }
+        else
+        {
+            ScriptWrapper::getSingleton().owned(newActive);
+            newActive->addQueryFlag(QUERYFLAG_PLAYER);
+            
+            mWindowFactory->setActiveCharacter(newActive);
+            
+            newActive->getActor()->attach(SoundManager::getSingleton().getListenerActor());
+            LOG_MESSAGE(Logger::UI, "SoundListener attached.");
+            
+            // Reset control stack for the new Character and set to movement.
+            mInputManager->setControlState(CST_MOVEMENT);
+        }
+        
+        return true;
     }
 
     bool UiSubsystem::onBeforeClearScene()
     {
-        setActiveCharacter(NULL);
         // Remove control states here too, in case that there has not yet been a
         // person set active.
         mInputManager->clearControlStates();
@@ -241,9 +234,18 @@
             mCharacterId = mCharacter->getId();
         }
         else
+        {
             mCharacterId = -1;
-
+        }
+        
         //mInputManager->clearControlStates();
         return false;
     }
+    
+    bool UiSubsystem::onAllPlayerCharactersDied()
+    {
+        LOG_MESSAGE(Logger::UI, "All player chars are dead, show game over");
+        WindowFactory::getSingleton().showGameOverWindow();
+        return true;
+    }
 }

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2008-09-16 20:19:44 UTC (rev 4510)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2008-09-17 22:24:26 UTC (rev 4511)
@@ -1,455 +1,462 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "WindowFactory.h"
-
-#include "AboutWindow.h"
-#include "ActionChoiceWindow.h"
-#include "ActorManager.h"
-#include "CharacterSheetWindow.h"
-#include "CharacterStateWindow.h"
-#include "CloseConfirmationWindow.h"
-#include "CombatWindow.h"
-#include "Console.h"
-#include "CoreSubsystem.h"
-#include "Creature.h"
-#include "DebugWindow.h"
-#include "DialogControlState.h"
-#include "DialogWindow.h"
-#include "Exception.h"
-#include "GameLoggerWindow.h"
-#include "GameObject.h"
-#include "GameObjectInfoWindow.h"
-#include "PropertiesWindow.h"
-#include "GameSaveLoadWindow.h"
-#include "MainMenuLoadWindow.h"
-#include "GameSettings.h"
-#include "InfoPopup.h"
-#include "InGameMenuWindow.h"
-#include "InputManager.h"
-#include "InventoryWindow.h"
-#include "JournalWindow.h"
-#include "LogWindow.h"
-#include "MessageWindow.h"
-#include "MainMenuWindow.h"
-#include "MainMenuEngineWindow.h"
-#include "MovableText.h"
-#include "ObjectDescriptionWindow.h"
-#include "PlaylistWindow.h"
-#include "QuestBook.h"
-#include "RubyInterpreter.h"
-#include "RulesSubsystem.h"
-#include "SubtitleWindow.h"
-#include "UiSubsystem.h"
-#include "WindowManager.h"
-
-#undef max
-
-template<> rl::WindowFactory* Ogre::Singleton<rl::WindowFactory>::ms_Singleton = 0;
-
-using namespace CEGUI;
-using namespace Ogre;
-
-namespace rl {
-
-    WindowFactory::WindowFactory()
-        : mGameLogger(NULL),
-        mCharacterStateWindow(NULL),
-        mInGameMenuWindow(NULL),
-        mCharacterSheet(NULL),
-        mJournalWindow(NULL),
-        mInventoryWindow(NULL),
-        mLogWindow(NULL),
-        mDebugWindow(NULL),
-        mConsole(NULL),
-        mInfoPopup(NULL),
-        mObjectNameText(NULL),
-        mShownObject(NULL),
-        mObjectDescriptionWindow(NULL),
-        mMainMenuWindow(NULL),
-		mMainMenuLoadWindow(NULL),
-        mGameSettings(NULL),
-        mCombatWindow(NULL)
-    {
-    }
-
-    void WindowFactory::initialize()
-    {
-        mConsole = new Console();
-        mDebugWindow = new DebugWindow();
-        CoreSubsystem::getSingleton().getRubyInterpreter()->
-            setOutputFunction(
-                (VALUE(*)(...))&WindowFactory::consoleWrite );
-
-        mLogWindow = new LogWindow();
-
-        mGameLogger = new GameLoggerWindow();
-        mCharacterStateWindow = new CharacterStateWindow();
-        mInGameMenuWindow = new InGameMenuWindow();
-        mCharacterSheet = new CharacterSheetWindow();
-        mJournalWindow = new JournalWindow();
-        //mInfoPopup = new InfoPopup(); // this invisible window blocks the mouse
-        mObjectDescriptionWindow = new ObjectDescriptionWindow();
-        mGameSettings = new GameSettings();
-
-        RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mJournalWindow);
-        //RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mInfoPopup);
-        mMainMenuWindow = new MainMenuWindow( new MainMenuEngineWindow() );
-
-        logAllWindows();
-    }
-
-    WindowFactory::~WindowFactory()
-    {
-        delete mLogWindow;
-        delete mObjectDescriptionWindow;
-        delete mJournalWindow;
-        delete mGameLogger;
-        delete mCharacterSheet;
-        delete mInGameMenuWindow;
-        delete mInventoryWindow;
-        delete mCharacterStateWindow;
-        //delete mInfoPopup;
-        delete mDebugWindow;
-        delete mConsole;
-        delete mMainMenuWindow;
-        delete mGameSettings;
-        delete mCombatWindow;
-    }
-
-    void WindowFactory::showCharacterActionChoice()
-    {
-        showActionChoice(UiSubsystem::getSingleton().getActiveCharacter());
-    }
-
-    void WindowFactory::showContainerContent(Container* container)
-    {
-        if( !mInventoryWindow )
-            toggleInventoryWindow();
-
-        mInventoryWindow->showContainerContent(container);
-    }
-
-    void WindowFactory::showMessageWindow(const CeGuiString& message)
-    {
-        MessageWindow* w = new MessageWindow("", message, MessageWindow::OK);
-        w->setVisible(true);
-    }
-
-    void WindowFactory::showMainMenu()
-    {
-        mMainMenuWindow->setVisible(true);
-    }
-
-    void WindowFactory::toggleConsole()
-    {
-        mConsole->setVisible(!mConsole->isVisible());
-    }
-
-    void WindowFactory::toggleDebugWindow()
-    {
-        mDebugWindow->setVisible(!mDebugWindow->isVisible());
-    }
-
-    void WindowFactory::showPropertiesWindow(GameObject* obj)
-    {
-        PropertiesWindow* wnd = new PropertiesWindow(obj);
-        wnd->setVisible(true);
-    }
-
-    void WindowFactory::showGameSaveLoadWindow()
-    {
-        GameSaveLoadWindow* wnd = new GameSaveLoadWindow();
-        wnd->initialize();
-        wnd->setVisible(true);
-    }
-
-    void WindowFactory::showMainMenuLoadWindow(MainMenuWindow* win)
-    {
-		mMainMenuLoadWindow = new MainMenuLoadWindow(win);
-        mMainMenuLoadWindow->initialize();
-        mMainMenuLoadWindow->setVisible(true);
-    }
-
-	void WindowFactory::hideMainMenuLoadWindow()
-    {
-		if(mMainMenuLoadWindow != NULL && mMainMenuLoadWindow->isVisible())
-		{
-			mMainMenuLoadWindow->setVisible(false,true);
-			mMainMenuWindow = NULL;
-		}
-    }
-
-    void WindowFactory::toggleGameLogWindow()
-    {
-        mGameLogger->setVisible(!mGameLogger->isVisible());
-    }
-
-    void WindowFactory::toggleInventoryWindow()
-    {
-        if (mInventoryWindow != NULL && mInventoryWindow->isVisible())
-        {
-            mInventoryWindow->setVisible(false, true);
-            mInventoryWindow = NULL;
-        }
-        else
-        {
-            if (mInventoryWindow != NULL)
-            {
-                WindowManager::getSingleton().destroyWindow(mInventoryWindow);
-                mInventoryWindow = NULL;
-            }
-
-            if (UiSubsystem::getSingleton().getActiveCharacter() != NULL)
-            {
-                Creature* creat = UiSubsystem::getSingleton().getActiveCharacter();
-
-                Ogre::String inventoryWindowType = creat->getInventoryWindowType();
-                if (inventoryWindowType == "")
-                {
-                    inventoryWindowType = "inventory_default.xml"; ///@TODO: Extract
-                }
-                mInventoryWindow = new InventoryWindow(inventoryWindowType, creat->getInventory());
-                mInventoryWindow->setVisible(true);
-            }
-        }
-    }
-
-    void WindowFactory::notifyInventoryWindowDestroyed()
-    {
-        mInventoryWindow = NULL;
-    }
-
-	bool WindowFactory::isInventoryWindowDestroyed()
-	{
-		return mInventoryWindow == NULL;
-	}
-
-
-    void WindowFactory::showCharacterSheet()
-    {
-        if (mCharacterSheet->isVisible())
-        {
-            mCharacterSheet->setCharacter(NULL);
-            mCharacterSheet->setVisible(false);
-        }
-        else
-        {
-            mCharacterSheet->setCharacter(UiSubsystem::getSingleton().getActiveCharacter());
-            mCharacterSheet->setVisible(true);
-        }
-    }
-
-    void WindowFactory::showJournalWindow()
-    {
-        if (mJournalWindow->isVisible())
-        {
-            mJournalWindow->setVisible(false);
-        }
-        else
-        {
-            mJournalWindow->setVisible(true);
-        }
-    }
-
-    void WindowFactory::showAboutWindow()
-    {
-        (new AboutWindow())->setVisible(true);
-    }
-
-    void WindowFactory::showCharacterSheet(Creature* chara)
-    {
-        if (!mCharacterSheet) 
-        {
-            mCharacterSheet = new CharacterSheetWindow();
-        }
-        mCharacterSheet->setCharacter(chara);
-        mCharacterSheet->setVisible(true);
-    }
-
-    void WindowFactory::showDescriptionWindow(GameObject* obj)
-    {
-        (new GameObjectInfoWindow(obj, UiSubsystem::getSingleton().getActiveCharacter()))->setVisible(true);
-    }
-
-    void WindowFactory::toggleCharacterStateWindow()
-    {
-        mCharacterStateWindow->setVisible(!mCharacterStateWindow->isVisible());
-    }
-
-    void WindowFactory::toggleInGameGlobalMenu()
-    {
-        mInGameMenuWindow->setVisible(!mInGameMenuWindow->isVisible());
-    }
-
-    GameLoggerWindow* WindowFactory::getGameLogger()
-    {
-        return mGameLogger;
-    }
-
-    void WindowFactory::showPlaylist()
-    {
-        PlaylistWindow* wnd = new PlaylistWindow();
-        wnd->setVisible(true);
-    }
-
-    void WindowFactory::checkForErrors()
-    {
-        if (Logger::getSingleton().isErrorPresent())
-        {
-            mLogWindow->setVisible(true);
-            Logger::getSingleton().resetErrorState();
-        }
-    }
-
-    void WindowFactory::update()
-    {
-        mInGameMenuWindow->update();
-    }
-
-    void WindowFactory::showExitConfirmation()
-    {
-        AbstractWindow* closeConfirmationWindow = new CloseConfirmationWindow();
-        LOG_MESSAGE2(Logger::UI, "Start", "UiSubsystem::requestExit");
-        closeConfirmationWindow->setVisible(true);
-    }
-
-    void WindowFactory::writeToConsole(Ogre::String text)
-    {
-        if (mConsole != NULL)
-        {
-            mConsole->write(text);
-        }
-        else
-        {
-            LOG_MESSAGE("Console", text);
-        }
-    }
-
-    VALUE WindowFactory::consoleWrite(VALUE self, VALUE str)
-    {
-        CeGuiString text = RubyInterpreter::val2ceguistr(str);
-
-        if (WindowFactory::getSingletonPtr() != NULL )
-        {
-            if (WindowFactory::getSingleton().mConsole != NULL)
-            {
-                WindowFactory::getSingleton().mConsole->
-                    write(text + " \n");
-                return Qnil;
-            }
-        }
-        
-        LOG_MESSAGE("Console", text);
-        return Qnil;
-    }
-
-    void WindowFactory::setActiveCharacter(Creature* character)
-    {
-        mCharacterStateWindow->setCharacter(character);
-        if (mCharacterSheet) 
-        {
-            mCharacterSheet->setCharacter(character);
-        }
-
-        if (mInventoryWindow && mInventoryWindow->isVisible())
-        {
-            toggleInventoryWindow();
-        }
-
-        LOG_MESSAGE(Logger::UI, "CharacterStateWindow updated");
-    }
-
-    void WindowFactory::showActionChoice(GameObject* obj)
-    {
-        ActionChoiceWindow* w = new ActionChoiceWindow(UiSubsystem::getSingleton().getActiveCharacter());
-        int numActions = w->showActionsOfObject(obj);
-        if (numActions > 0)
-        {
-            w->setVisible(true);
-        }
-        else
-        {
-            WindowManager::getSingleton().destroyWindow(w);
-        }
-    }
-
-    void WindowFactory::showLogfiles()
-    {
-        (new LogWindow())->setVisible(true);
-    }
-
-    void WindowFactory::showPopupMessage(int popupTypes)
-    {
-        if (popupTypes & WindowFactory::ICON_ERROR)
-        {
-            //mInfoPopup->showError();
-        }
-
-        if (popupTypes & WindowFactory::ICON_QUEST)
-        {
-            //mInfoPopup->showQuestBookChange();
-        }
-    }
-
-    void WindowFactory::showObjectDescription(GameObject* object)
-    {
-        mObjectDescriptionWindow->show(object);
-    }
-
-    void WindowFactory::showNextDebugWindowPage()
-    {
-        mDebugWindow->showNextPage();
-    }
-
-    void WindowFactory::showGameSettings()
-    {
-        // Create the game settings window and show it
-        mGameSettings->setVisible(true);
-    }
-
-    void WindowFactory::logAllWindows()
-    {
-        CEGUI::Window* rootWnd = AbstractWindow::getRoot();
-        CEGUI::uint count = rootWnd->getChildCount();
-        for (CEGUI::uint chIdx =  0; chIdx < count; ++chIdx)
-        {
-            CEGUI::Window* wnd = rootWnd->getChildAtIdx(chIdx);
-            LOG_MESSAGE(
-                Logger::UI,
-                wnd->getName()
-                + (wnd->isVisible() ? " vis" : " nvis")
-                + " @"
-                + StringConverter::toString(wnd->getPixelRect().getPosition().d_x)
-                + ", "
-                + StringConverter::toString(wnd->getPixelRect().getPosition().d_y)
-                + " "
-                + StringConverter::toString(wnd->getPixelSize().d_width)
-                + ", "
-                + StringConverter::toString(wnd->getPixelSize().d_height));
-        }
-    }
-
-    CombatWindow* WindowFactory::getCombatWindow()
-    {
-        if (mCombatWindow == NULL)
-        {
-            mCombatWindow = new CombatWindow();
-        }
-        return mCombatWindow;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include "WindowFactory.h"
+
+#include "AboutWindow.h"
+#include "ActionChoiceWindow.h"
+#include "ActorManager.h"
+#include "CharacterSheetWindow.h"
+#include "CharacterStateWindow.h"
+#include "CloseConfirmationWindow.h"
+#include "CombatWindow.h"
+#include "Console.h"
+#include "CoreSubsystem.h"
+#include "Creature.h"
+#include "DebugWindow.h"
+#include "DialogControlState.h"
+#include "DialogWindow.h"
+#include "Exception.h"
+#include "GameLoggerWindow.h"
+#include "GameObject.h"
+#include "GameObjectInfoWindow.h"
+#include "GameOverWindow.h"
+#include "GameSaveLoadWindow.h"
+#include "GameSettings.h"
+#include "InfoPopup.h"
+#include "InGameMenuWindow.h"
+#include "InputManager.h"
+#include "InventoryWindow.h"
+#include "JournalWindow.h"
+#include "LogWindow.h"
+#include "MessageWindow.h"
+#include "MainMenuLoadWindow.h"
+#include "MainMenuWindow.h"
+#include "MainMenuEngineWindow.h"
+#include "MovableText.h"
+#include "ObjectDescriptionWindow.h"
+#include "PartyManager.h"
+#include "PlaylistWindow.h"
+#include "PropertiesWindow.h"
+#include "QuestBook.h"
+#include "RubyInterpreter.h"
+#include "RulesSubsystem.h"
+#include "SubtitleWindow.h"
+#include "UiSubsystem.h"
+#include "WindowManager.h"
+
+#undef max
+
+template<> rl::WindowFactory* Ogre::Singleton<rl::WindowFactory>::ms_Singleton = 0;
+
+using namespace CEGUI;
+using namespace Ogre;
+
+namespace rl {
+
+    WindowFactory::WindowFactory()
+        : mGameLogger(NULL),
+        mCharacterStateWindow(NULL),
+        mInGameMenuWindow(NULL),
+        mCharacterSheet(NULL),
+        mJournalWindow(NULL),
+        mInventoryWindow(NULL),
+        mLogWindow(NULL),
+        mDebugWindow(NULL),
+        mConsole(NULL),
+        mInfoPopup(NULL),
+        mObjectNameText(NULL),
+        mShownObject(NULL),
+        mObjectDescriptionWindow(NULL),
+        mMainMenuWindow(NULL),
+		mMainMenuLoadWindow(NULL),
+        mGameSettings(NULL),
+        mCombatWindow(NULL)
+    {
+    }
+
+    void WindowFactory::initialize()
+    {
+        mConsole = new Console();
+        mDebugWindow = new DebugWindow();
+        CoreSubsystem::getSingleton().getRubyInterpreter()->
+            setOutputFunction(
+                (VALUE(*)(...))&WindowFactory::consoleWrite );
+
+        mLogWindow = new LogWindow();
+
+        mGameLogger = new GameLoggerWindow();
+        mCharacterStateWindow = new CharacterStateWindow();
+        mInGameMenuWindow = new InGameMenuWindow();
+        mCharacterSheet = new CharacterSheetWindow();
+        mJournalWindow = new JournalWindow();
+        //mInfoPopup = new InfoPopup(); // this invisible window blocks the mouse
+        mObjectDescriptionWindow = new ObjectDescriptionWindow();
+        mGameSettings = new GameSettings();
+
+        RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mJournalWindow);
+        //RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mInfoPopup);
+        mMainMenuWindow = new MainMenuWindow( new MainMenuEngineWindow() );
+
+        logAllWindows();
+    }
+
+    WindowFactory::~WindowFactory()
+    {
+        delete mLogWindow;
+        delete mObjectDescriptionWindow;
+        delete mJournalWindow;
+        delete mGameLogger;
+        delete mCharacterSheet;
+        delete mInGameMenuWindow;
+        delete mInventoryWindow;
+        delete mCharacterStateWindow;
+        //delete mInfoPopup;
+        delete mDebugWindow;
+        delete mConsole;
+        delete mMainMenuWindow;
+        delete mGameSettings;
+        delete mCombatWindow;
+    }
+
+    void WindowFactory::showCharacterActionChoice()
+    {
+        showActionChoice(PartyManager::getSingleton().getActiveCharacter());
+    }
+
+    void WindowFactory::showContainerContent(Container* container)
+    {
+        if( !mInventoryWindow )
+            toggleInventoryWindow();
+
+        mInventoryWindow->showContainerContent(container);
+    }
+
+    void WindowFactory::showMessageWindow(const CeGuiString& message)
+    {
+        MessageWindow* w = new MessageWindow("", message, MessageWindow::OK);
+        w->setVisible(true);
+    }
+
+    void WindowFactory::showMainMenu()
+    {
+        mMainMenuWindow->setVisible(true);
+    }
+
+    void WindowFactory::toggleConsole()
+    {
+        mConsole->setVisible(!mConsole->isVisible());
+    }
+
+    void WindowFactory::toggleDebugWindow()
+    {
+        mDebugWindow->setVisible(!mDebugWindow->isVisible());
+    }
+
+    void WindowFactory::showPropertiesWindow(GameObject* obj)
+    {
+        PropertiesWindow* wnd = new PropertiesWindow(obj);
+        wnd->setVisible(true);
+    }
+
+    void WindowFactory::showGameSaveLoadWindow()
+    {
+        GameSaveLoadWindow* wnd = new GameSaveLoadWindow();
+        wnd->initialize();
+        wnd->setVisible(true);
+    }
+
+    void WindowFactory::showMainMenuLoadWindow(MainMenuWindow* win)
+    {
+		mMainMenuLoadWindow = new MainMenuLoadWindow(win);
+        mMainMenuLoadWindow->initialize();
+        mMainMenuLoadWindow->setVisible(true);
+    }
+
+	void WindowFactory::hideMainMenuLoadWindow()
+    {
+		if(mMainMenuLoadWindow != NULL && mMainMenuLoadWindow->isVisible())
+		{
+			mMainMenuLoadWindow->setVisible(false,true);
+			mMainMenuWindow = NULL;
+		}
+    }
+
+    void WindowFactory::toggleGameLogWindow()
+    {
+        mGameLogger->setVisible(!mGameLogger->isVisible());
+    }
+
+    void WindowFactory::toggleInventoryWindow()
+    {
+        if (mInventoryWindow != NULL && mInventoryWindow->isVisible())
+        {
+            mInventoryWindow->setVisible(false, true);
+            mInventoryWindow = NULL;
+        }
+        else
+        {
+            if (mInventoryWindow != NULL)
+            {
+                WindowManager::getSingleton().destroyWindow(mInventoryWindow);
+                mInventoryWindow = NULL;
+            }
+
+            if (PartyManager::getSingleton().getActiveCharacter() != NULL)
+            {
+                Creature* creat = PartyManager::getSingleton().getActiveCharacter();
+
+                Ogre::String inventoryWindowType = creat->getInventoryWindowType();
+                if (inventoryWindowType == "")
+                {
+                    inventoryWindowType = "inventory_default.xml"; ///@TODO: Extract
+                }
+                mInventoryWindow = new InventoryWindow(inventoryWindowType, creat->getInventory());
+                mInventoryWindow->setVisible(true);
+            }
+        }
+    }
+
+    void WindowFactory::notifyInventoryWindowDestroyed()
+    {
+        mInventoryWindow = NULL;
+    }
+
+	bool WindowFactory::isInventoryWindowDestroyed()
+	{
+		return mInventoryWindow == NULL;
+	}
+
+
+    void WindowFactory::showCharacterSheet()
+    {
+        if (mCharacterSheet->isVisible())
+        {
+            mCharacterSheet->setCharacter(NULL);
+            mCharacterSheet->setVisible(false);
+        }
+        else
+        {
+            mCharacterSheet->setCharacter(PartyManager::getSingleton().getActiveCharacter());
+            mCharacterSheet->setVisible(true);
+        }
+    }
+
+    void WindowFactory::showJournalWindow()
+    {
+        if (mJournalWindow->isVisible())
+        {
+            mJournalWindow->setVisible(false);
+        }
+        else
+        {
+            mJournalWindow->setVisible(true);
+        }
+    }
+
+    void WindowFactory::showAboutWindow()
+    {
+        (new AboutWindow())->setVisible(true);
+    }
+
+    void WindowFactory::showCharacterSheet(Creature* chara)
+    {
+        if (!mCharacterSheet) 
+        {
+            mCharacterSheet = new CharacterSheetWindow();
+        }
+        mCharacterSheet->setCharacter(chara);
+        mCharacterSheet->setVisible(true);
+    }
+
+    void WindowFactory::showDescriptionWindow(GameObject* obj)
+    {
+        (new GameObjectInfoWindow(obj, PartyManager::getSingleton().getActiveCharacter()))->setVisible(true);
+    }
+
+    void WindowFactory::toggleCharacterStateWindow()
+    {
+        mCharacterStateWindow->setVisible(!mCharacterStateWindow->isVisible());
+    }
+
+    void WindowFactory::toggleInGameGlobalMenu()
+    {
+        mInGameMenuWindow->setVisible(!mInGameMenuWindow->isVisible());
+    }
+
+    GameLoggerWindow* WindowFactory::getGameLogger()
+    {
+        return mGameLogger;
+    }
+
+    void WindowFactory::showPlaylist()
+    {
+        PlaylistWindow* wnd = new PlaylistWindow();
+        wnd->setVisible(true);
+    }
+
+    void WindowFactory::checkForErrors()
+    {
+        if (Logger::getSingleton().isErrorPresent())
+        {
+            mLogWindow->setVisible(true);
+            Logger::getSingleton().resetErrorState();
+        }
+    }
+
+    void WindowFactory::update()
+    {
+        mInGameMenuWindow->update();
+    }
+
+    void WindowFactory::showExitConfirmation()
+    {
+        AbstractWindow* closeConfirmationWindow = new CloseConfirmationWindow();
+        LOG_MESSAGE2(Logger::UI, "Start", "UiSubsystem::requestExit");
+        closeConfirmationWindow->setVisible(true);
+    }
+
+    void WindowFactory::writeToConsole(Ogre::String text)
+    {
+        if (mConsole != NULL)
+        {
+            mConsole->write(text);
+        }
+        else
+        {
+            LOG_MESSAGE("Console", text);
+        }
+    }
+
+    VALUE WindowFactory::consoleWrite(VALUE self, VALUE str)
+    {
+        CeGuiString text = RubyInterpreter::val2ceguistr(str);
+
+        if (WindowFactory::getSingletonPtr() != NULL )
+        {
+            if (WindowFactory::getSingleton().mConsole != NULL)
+            {
+                WindowFactory::getSingleton().mConsole->
+                    write(text + " \n");
+                return Qnil;
+            }
+        }
+        
+        LOG_MESSAGE("Console", text);
+        return Qnil;
+    }
+
+    void WindowFactory::setActiveCharacter(Creature* character)
+    {
+        mCharacterStateWindow->setCharacter(character);
+        if (mCharacterSheet) 
+        {
+            mCharacterSheet->setCharacter(character);
+        }
+
+        if (mInventoryWindow && mInventoryWindow->isVisible())
+        {
+            toggleInventoryWindow();
+        }
+
+        LOG_MESSAGE(Logger::UI, "CharacterStateWindow updated");
+    }
+
+    void WindowFactory::showActionChoice(GameObject* obj)
+    {
+        ActionChoiceWindow* w = new ActionChoiceWindow(PartyManager::getSingleton().getActiveCharacter());
+        int numActions = w->showActionsOfObject(obj);
+        if (numActions > 0)
+        {
+            w->setVisible(true);
+        }
+        else
+        {
+            WindowManager::getSingleton().destroyWindow(w);
+        }
+    }
+
+    void WindowFactory::showLogfiles()
+    {
+        (new LogWindow())->setVisible(true);
+    }
+
+    void WindowFactory::showPopupMessage(int popupTypes)
+    {
+        if (popupTypes & WindowFactory::ICON_ERROR)
+        {
+            //mInfoPopup->showError();
+        }
+
+        if (popupTypes & WindowFactory::ICON_QUEST)
+        {
+            //mInfoPopup->showQuestBookChange();
+        }
+    }
+
+    void WindowFactory::showObjectDescription(GameObject* object)
+    {
+        mObjectDescriptionWindow->show(object);
+    }
+
+    void WindowFactory::showNextDebugWindowPage()
+    {
+        mDebugWindow->showNextPage();
+    }
+
+    void WindowFactory::showGameSettings()
+    {
+        // Create the game settings window and show it
+        mGameSettings->setVisible(true);
+    }
+    
+    void WindowFactory::showGameOverWindow()
+    {
+        (new GameOverWindow())->setVisible(true);
+    }
+
+    void WindowFactory::logAllWindows()
+    {
+        CEGUI::Window* rootWnd = AbstractWindow::getRoot();
+        CEGUI::uint count = rootWnd->getChildCount();
+        for (CEGUI::uint chIdx =  0; chIdx < count; ++chIdx)
+        {
+            CEGUI::Window* wnd = rootWnd->getChildAtIdx(chIdx);
+            LOG_MESSAGE(
+                Logger::UI,
+                wnd->getName()
+                + (wnd->isVisible() ? " vis" : " nvis")
+                + " @"
+                + StringConverter::toString(wnd->getPixelRect().getPosition().d_x)
+                + ", "
+                + StringConverter::toString(wnd->getPixelRect().getPosition().d_y)
+                + " "
+                + StringConverter::toString(wnd->getPixelSize().d_width)
+                + ", "
+                + StringConverter::toString(wnd->getPixelSize().d_height));
+        }
+    }
+
+    CombatWindow* WindowFactory::getCombatWindow()
+    {
+        if (mCombatWindow == NULL)
+        {
+            mCombatWindow = new CombatWindow();
+        }
+        return mCombatWindow;
+    }
+}



From blakharaz at mail.berlios.de  Thu Sep 18 00:25:24 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 18 Sep 2008 00:25:24 +0200
Subject: [Dsa-hl-svn] r4512 - in modules: aitest/scripts/maps
	combattest/scripts combattest/scripts/maps common/scripts
	kanalisation/scripts kanalisation/scripts/maps
	persistenztest/scripts persistenztest/scripts/maps
	regressiontest/scripts regressiontest/scripts/maps
	ruchin/scripts ruchin/scripts/maps techdemo/scripts/maps
	techdemo2/scripts techdemo2/scripts/maps teichtest/scripts/maps
Message-ID: <200809172225.m8HMPOJ5011855@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-18 00:25:15 +0200 (Thu, 18 Sep 2008)
New Revision: 4512

Modified:
   modules/aitest/scripts/maps/aitest.rb
   modules/aitest/scripts/maps/aitest2.rb
   modules/aitest/scripts/maps/aitestold.rb
   modules/combattest/scripts/equip.rb
   modules/combattest/scripts/maps/combattest.rb
   modules/common/scripts/globals.rb
   modules/kanalisation/scripts/equip.rb
   modules/kanalisation/scripts/maps/kanalisation.rb
   modules/persistenztest/scripts/MapChange.rb
   modules/persistenztest/scripts/maps/setchar.rb
   modules/regressiontest/scripts/InventoryTest.rb
   modules/regressiontest/scripts/effecttest.rb
   modules/regressiontest/scripts/maps/regressiontest.rb
   modules/ruchin/scripts/equip.rb
   modules/ruchin/scripts/maps/maptest.rb
   modules/ruchin/scripts/maps/ruchin.rb
   modules/techdemo/scripts/maps/techdemo.rb
   modules/techdemo2/scripts/druidentod.rb
   modules/techdemo2/scripts/maps/techdemo2map1.rb
   modules/techdemo2/scripts/maps/techdemo2map2.rb
   modules/teichtest/scripts/maps/setchar.rb
Log:
Adapted ruby scripts

Modified: modules/aitest/scripts/maps/aitest.rb
===================================================================
--- modules/aitest/scripts/maps/aitest.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/aitest/scripts/maps/aitest.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -33,7 +33,7 @@
 PlayerSettings.preparePlayer($hero)
 
 $SCRIPT.log("Set hero as active character")
-$UI.setActiveCharacter($hero)
+PartyManager.getSingleton().setActiveCharacter($hero)
 $SCRIPT.log("Hero ready")
 
 $SCRIPT.log("map 'regressiontest' initialisiert.");

Modified: modules/aitest/scripts/maps/aitest2.rb
===================================================================
--- modules/aitest/scripts/maps/aitest2.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/aitest/scripts/maps/aitest2.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -35,7 +35,7 @@
 PlayerSettings.preparePlayer($hero)
 
 $SCRIPT.log("Set hero as active character")
-$UI.setActiveCharacter($hero)
+PartyManager.getSingleton().setActiveCharacter($hero)
 
 $SCRIPT.log("Hero ready")
 

Modified: modules/aitest/scripts/maps/aitestold.rb
===================================================================
--- modules/aitest/scripts/maps/aitestold.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/aitest/scripts/maps/aitestold.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -35,7 +35,7 @@
 PlayerSettings.preparePlayer($hero)
 
 $SCRIPT.log("Set hero as active character")
-$UI.setActiveCharacter($hero)
+PartyManager.getSingleton().setActiveCharacter($hero)
 
 $SCRIPT.log("Hero ready")
 

Modified: modules/combattest/scripts/equip.rb
===================================================================
--- modules/combattest/scripts/equip.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/combattest/scripts/equip.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -2,7 +2,7 @@
 require 'clothing.rb'
 	
 	$SCRIPT.log("aktiven hero geten");
-	hero = $UI.getActiveCharacter();
+	hero = PartyManager.getSingleton().getActiveCharacter();
 
     
     itemToAdd = $GOM.createGameObject("men_human_female_legs_pants_01_long");

Modified: modules/combattest/scripts/maps/combattest.rb
===================================================================
--- modules/combattest/scripts/maps/combattest.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/combattest/scripts/maps/combattest.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -23,7 +23,7 @@
 PlayerSettings.preparePlayer($hero)
 
 $SCRIPT.log("Set hero as active character")
-$UI.setActiveCharacter($hero)
+PartyManager.getSingleton().setActiveCharacter($hero)
 $SCRIPT.log("Hero ready")
 
 wolf = $GOM.createGameObject("Wolf")

Modified: modules/common/scripts/globals.rb
===================================================================
--- modules/common/scripts/globals.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/common/scripts/globals.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -9,7 +9,6 @@
 $JS = JobScheduler.getSingleton();
 $AM = ActorManager.getSingleton();
 $PM = PhysicsManager.getSingleton();
-$UI = UiSubsystem.getSingleton();
 $DM = DsaManager.getSingleton();
 $WF = WindowFactory.getSingleton();
 $AI = AiSubsystem.getSingleton();
@@ -30,7 +29,7 @@
 	
   end
   def writePos()
-	actor = $UI.getActiveCharacter().getActor();
+	actor = PartyManager.getSingleton().getActiveCharacter().getActor();
 	$SCRIPT.log("[ "+actor.getWorldPosition()[0].to_s+", "+actor.getWorldPosition()[1].to_s+", "+actor.getWorldPosition()[2].to_s+"]" );  
 	$SCRIPT.log("[ [ "+actor.getWorldOrientation()[0][0].to_s+", "+actor.getWorldOrientation()[0][1].to_s+", "+actor.getWorldOrientation()[0][2].to_s+" ] , "+actor.getWorldOrientation()[1].to_s+"]") ; 
   end

Modified: modules/kanalisation/scripts/equip.rb
===================================================================
--- modules/kanalisation/scripts/equip.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/kanalisation/scripts/equip.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -2,7 +2,7 @@
 require 'torch.rb'
 require 'clothing.rb'
 
-hero = $UI.getActiveCharacter();
+hero = PartyManager.getSingleton().getActiveCharacter();
 
 itemToAdd = $GOM.createGameObject("men_human_female_legs_pants_01_long");
 hero.getInventory().hold(itemToAdd, "Trousers");

Modified: modules/kanalisation/scripts/maps/kanalisation.rb
===================================================================
--- modules/kanalisation/scripts/maps/kanalisation.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/kanalisation/scripts/maps/kanalisation.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -38,15 +38,8 @@
 $hero.setPosition([ -35.15, 2.69, 26.09]);
 $hero.setOrientation([ [ -4.43614335381426e-005, -0.999999940395355, -3.53998184436932e-005 ] , 67.3891525268555]);
 PlayerSettings.preparePlayer($hero);
-$UI.setActiveCharacter($hero)
-$SCRIPT.log("Create hero")
+PartyManager.getSingleton().setActiveCharacter($hero)
 
-$SCRIPT.log("Prepare hero for being the active character")
-PlayerSettings.preparePlayer($hero)
-
-$SCRIPT.log("Set hero as active character")
-$UI.setActiveCharacter($hero)
-
 $SCRIPT.log("Hero ready")
 
 #$SCRIPT.log("Fackellicht erstellen..");

Modified: modules/persistenztest/scripts/MapChange.rb
===================================================================
--- modules/persistenztest/scripts/MapChange.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/persistenztest/scripts/MapChange.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -2,9 +2,9 @@
 require "areahelper.rb"
 
 def changeScene(scene)
-#	characterId = $UI.getActiveCharacter().getId()
-#	CreatureControllerManager.getSingleton().detachController($UI.getActiveCharacter())
-#	$UI.setActiveCharacter(nil)
+#	characterId = PartyManager.getSingleton().getActiveCharacter().getId()
+#	CreatureControllerManager.getSingleton().detachController(PartyManager.getSingleton().getActiveCharacter())
+#	PartyManager.getSingleton().setActiveCharacter(nil)
 	#$SCRIPT.logError(mapNames.type().to_s)
 #	mapLoader.requestSceneChange(mapNames)
 	SceneManager::getSingleton().loadScene(scene, true);

Modified: modules/persistenztest/scripts/maps/setchar.rb
===================================================================
--- modules/persistenztest/scripts/maps/setchar.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/persistenztest/scripts/maps/setchar.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -9,7 +9,7 @@
 PlayerSettings.preparePlayer(hero)
 
 $SCRIPT.log("Set hero as active character")
-$UI.setActiveCharacter(hero)
+PartyManager.getSingleton().setActiveCharacter(hero)
 
 $SCRIPT.log("Hero ready")
 itemToAdd = $GOM.createGameObject("men_human_female_legs_pants_01_long");

Modified: modules/regressiontest/scripts/InventoryTest.rb
===================================================================
--- modules/regressiontest/scripts/InventoryTest.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/regressiontest/scripts/InventoryTest.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -4,7 +4,7 @@
 class InventoryTest < TestCase
   def execute()
     $SCRIPT.log("InventoryTest started.");
-    hero = $UI.getActiveCharacter();
+    hero = PartyManager.getSingleton().getActiveCharacter();
     backpack = $GOM.createGameObject("leather backpack");
     #backpack.addAction(ShowContainerContentAction.new());
     #backpack.setPosition(center);

Modified: modules/regressiontest/scripts/effecttest.rb
===================================================================
--- modules/regressiontest/scripts/effecttest.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/regressiontest/scripts/effecttest.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -49,7 +49,7 @@
     def execute()
 	
 		# Define a pointer to the hero
-		$h = $UI.getActiveCharacter()
+		$h = PartyManager.getSingleton().getActiveCharacter()
         # Define a base box to place everything else on.
         height = 0.1
         min_base = [-2.0, 0.05, -2.0]

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -11,10 +11,11 @@
 
 $SCRIPT.log("Prepare hero for being the active character")
 $hero = $GOM.getGameObject(10);
+$hero.modifyLe(-20);
 PlayerSettings.preparePlayer($hero)
 
 $SCRIPT.log("Set hero as active character")
-$UI.setActiveCharacter($hero)
+PartyManager.getSingleton().setActiveCharacter($hero)
 
 $SCRIPT.log("Hero ready")
 

Modified: modules/ruchin/scripts/equip.rb
===================================================================
--- modules/ruchin/scripts/equip.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/ruchin/scripts/equip.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -1,7 +1,7 @@
 require 'npc.rb'
 	
 	$SCRIPT.log("aktiven hero geten");
-	hero = $UI.getActiveCharacter();
+	hero = PartyManager.getSingleton().getActiveCharacter();
 	
 	$SCRIPT.log("backpack erstellen");
     #backpack = $GOM.createGameObject("leather backpack");

Modified: modules/ruchin/scripts/maps/maptest.rb
===================================================================
--- modules/ruchin/scripts/maps/maptest.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/ruchin/scripts/maps/maptest.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -46,7 +46,7 @@
 PlayerSettings.preparePlayer($hero)
 
 $SCRIPT.log("Set hero as active character")
-$UI.setActiveCharacter($hero)
+PartyManager.getSingleton().setActiveCharacter($hero)
 
 $SCRIPT.log("Hero ready")
 

Modified: modules/ruchin/scripts/maps/ruchin.rb
===================================================================
--- modules/ruchin/scripts/maps/ruchin.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/ruchin/scripts/maps/ruchin.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -18,7 +18,7 @@
 $hero.setPosition([ -35.3738746643066, -5.64282417297363, -64.6520767211914]);
 $hero.setOrientation([ [ -4.43614335381426e-005, -0.999999940395355, -3.53998184436932e-005 ] , 67.3891525268555]);
 PlayerSettings.preparePlayer($hero);
-$UI.setActiveCharacter($hero)
+PartyManager.getSingleton().setActiveCharacter($hero)
 
 $SCRIPT.log("Initialize NPCs");
 $SCRIPT.log("Hesindiane...");

Modified: modules/techdemo/scripts/maps/techdemo.rb
===================================================================
--- modules/techdemo/scripts/maps/techdemo.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/techdemo/scripts/maps/techdemo.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -26,7 +26,7 @@
 
 
 $SCRIPT.log("Set hero as active character")
-$UI.setActiveCharacter(hero)
+PartyManager.getSingleton().setActiveCharacter(hero)
 
 $World.setFog( World::FOG_EXP, [0.8,0.8,1.0,0.5], 0.00003, 0.4, 1.0);
 

Modified: modules/techdemo2/scripts/druidentod.rb
===================================================================
--- modules/techdemo2/scripts/druidentod.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/techdemo2/scripts/druidentod.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -1,6 +1,6 @@
 #<!-- Script um Druiden mit Animationen sterben zu lassen, Physikschubs, als Dialogpartner deaktivieren. druidentod.rb-->
 
-$UI.getActiveCharacter().getActor().getControlledObject().startAnimation("kampf_schwerter_angriff_1", 1.0, 1)
+PartyManager.getSingleton().getActiveCharacter().getActor().getControlledObject().startAnimation("kampf_schwerter_angriff_1", 1.0, 1)
 
 #Ger?usch
 @mTodSound = $AM.createSoundSampleActor("TodSound","altermann005.ogg");

Modified: modules/techdemo2/scripts/maps/techdemo2map1.rb
===================================================================
--- modules/techdemo2/scripts/maps/techdemo2map1.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/techdemo2/scripts/maps/techdemo2map1.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -13,7 +13,7 @@
 $hero = $GOM.createGameObject("hero", 1);
 $hero.placeIntoScene()
 PlayerSettings.preparePlayer($hero)
-$UI.setActiveCharacter($hero)
+PartyManager.getSingleton().setActiveCharacter($hero)
 $SCRIPT.log("Held erstellt");
 
 #$heroVehicle = $AGM.createAgent(AgentManager::AGENT_PLAYER, $hero);	

Modified: modules/techdemo2/scripts/maps/techdemo2map2.rb
===================================================================
--- modules/techdemo2/scripts/maps/techdemo2map2.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/techdemo2/scripts/maps/techdemo2map2.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -10,7 +10,7 @@
 $hero = $GOM.createGameObject("hero", 1);
 $hero.placeIntoScene()
 PlayerSettings.preparePlayer($hero)
-$UI.setActiveCharacter($hero)
+PartyManager.getSingleton().setActiveCharacter($hero)
 $SCRIPT.log("Held erstellt");
 
 #$heroVehicle = $AGM.createAgent(AgentManager::AGENT_PLAYER, $hero);	

Modified: modules/teichtest/scripts/maps/setchar.rb
===================================================================
--- modules/teichtest/scripts/maps/setchar.rb	2008-09-17 22:24:26 UTC (rev 4511)
+++ modules/teichtest/scripts/maps/setchar.rb	2008-09-17 22:25:15 UTC (rev 4512)
@@ -8,7 +8,7 @@
 PlayerSettings.preparePlayer(hero)
 
 $SCRIPT.log("Set hero as active character")
-$UI.setActiveCharacter(hero)
+PartyManager.getSingleton().setActiveCharacter(hero)
 
 $SCRIPT.log("Hero ready")
 itemToAdd = $GOM.createGameObject("men_human_female_legs_pants_01_long");



From blakharaz at mail.berlios.de  Thu Sep 18 00:25:39 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 18 Sep 2008 00:25:39 +0200
Subject: [Dsa-hl-svn] r4513 - in rl/trunk/engine/ui: include src
Message-ID: <200809172225.m8HMPdIW011873@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-18 00:25:38 +0200 (Thu, 18 Sep 2008)
New Revision: 4513

Added:
   rl/trunk/engine/ui/include/GameOverWindow.h
   rl/trunk/engine/ui/src/GameOverWindow.cpp
Log:
Game Over window

Added: rl/trunk/engine/ui/include/GameOverWindow.h
===================================================================
--- rl/trunk/engine/ui/include/GameOverWindow.h	2008-09-17 22:25:15 UTC (rev 4512)
+++ rl/trunk/engine/ui/include/GameOverWindow.h	2008-09-17 22:25:38 UTC (rev 4513)
@@ -0,0 +1,36 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#ifndef __GameOverWindow_H__
+#define __GameOverWindow_H__
+
+#include "UiPrerequisites.h"
+
+#include "AbstractWindow.h"
+
+namespace rl
+{
+    class _RlUiExport GameOverWindow : public AbstractWindow
+    {
+    public:
+        GameOverWindow();
+        
+        bool handleMainMenuClick();
+        bool handleQuitClick();
+        bool handleCheatClick();
+    };
+}
+
+#endif //__GameOverWindow_H__

Added: rl/trunk/engine/ui/src/GameOverWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameOverWindow.cpp	2008-09-17 22:25:15 UTC (rev 4512)
+++ rl/trunk/engine/ui/src/GameOverWindow.cpp	2008-09-17 22:25:38 UTC (rev 4513)
@@ -0,0 +1,60 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h"
+
+#include "GameOverWindow.h"
+
+#include <boost/bind.hpp>
+
+#include "CoreSubsystem.h"
+#include "WindowFactory.h"
+#include "UiSubsystem.h"
+
+namespace rl
+{
+
+GameOverWindow::GameOverWindow()
+    : AbstractWindow(CeGuiString("gameoverwindow.xml"), AbstractWindow::WIT_MOUSE_INPUT, false, true)
+{
+    getWindow("GameOverWindow/MainMenuButton")->subscribeEvent(
+		CEGUI::Window::EventMouseClick,
+		boost::bind(&GameOverWindow::handleMainMenuClick, this));
+    getWindow("GameOverWindow/QuitButton")->subscribeEvent(
+		CEGUI::Window::EventMouseClick,
+		boost::bind(&GameOverWindow::handleQuitClick, this));
+    getWindow("GameOverWindow/CheatButton")->subscribeEvent(
+		CEGUI::Window::EventMouseClick,
+		boost::bind(&GameOverWindow::handleCheatClick, this));
+}
+
+bool GameOverWindow::handleMainMenuClick()
+{
+    CoreSubsystem::getSingleton().startAdventureModule(CoreSubsystem::getSingleton().getModule("intro"));
+    return true;
+}
+
+bool GameOverWindow::handleQuitClick()
+{
+    WindowFactory::getSingleton().showExitConfirmation();
+    return true;
+}
+
+bool GameOverWindow::handleCheatClick()
+{
+    return true;
+}
+
+}



From blakharaz at mail.berlios.de  Thu Sep 18 00:25:46 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 18 Sep 2008 00:25:46 +0200
Subject: [Dsa-hl-svn] r4514 - modules/common/gui/windows
Message-ID: <200809172225.m8HMPkDm011884@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-18 00:25:45 +0200 (Thu, 18 Sep 2008)
New Revision: 4514

Added:
   modules/common/gui/windows/gameoverwindow.xml
Log:
Game Over window

Added: modules/common/gui/windows/gameoverwindow.xml
===================================================================
--- modules/common/gui/windows/gameoverwindow.xml	2008-09-17 22:25:38 UTC (rev 4513)
+++ modules/common/gui/windows/gameoverwindow.xml	2008-09-17 22:25:45 UTC (rev 4514)
@@ -0,0 +1,30 @@
+<GUILayout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="GUILayout.xsd">
+    <Window Type="RastullahLook/FrameWindow" Name="CloseConfirmationWindow">
+        <Property Name="UnifiedPosition" Value="{{0,0},{0,0}}"/>
+        <Property Name="UnifiedSize" Value="{{0,400},{0,171}}"/>
+		<Property Name="Text" Value="Rastullahs Lockenpracht beenden"/>
+
+		<Window Type="RastullahLook/StaticText" Name="CloseConfirmationWindow/Text">
+            <Property Name="UnifiedPosition" Value="{{0,15},{0,26}}"/>
+            <Property Name="UnifiedSize" Value="{{0,370},{0,50}}"/>
+			<Property Name="FrameEnabled" Value="False"/>
+			<Property Name="Text" Value="Soll Rastullahs Lockenpracht wirklich beendet werden?" />
+            <Property Name="HorzFormatting" Value="WordWrapCentred" />
+		</Window>
+
+		<Window Type="RastullahLook/Button" Name="CloseConfirmationWindow/YesButton">
+            <Property Name="UnifiedPosition" Value="{{0,50},{0,125}}"/>
+            <Property Name="UnifiedSize" Value="{{0,125},{0,28}}"/>
+			<Property Name="Font" Value="Vera Serif-10"/>
+			<Property Name="Text" Value="Ja"/>
+		</Window>
+
+		<Window Type="RastullahLook/Button" Name="CloseConfirmationWindow/NoButton">
+            <Property Name="UnifiedPosition" Value="{{0,225},{0,125}}"/>
+            <Property Name="UnifiedSize" Value="{{0,125},{0,28}}"/>
+			<Property Name="Font" Value="Vera Serif-10"/>
+			<Property Name="Text" Value="Nein"/>
+		</Window>
+    </Window>
+</GUILayout>
+



From blakharaz at mail.berlios.de  Thu Sep 18 00:25:55 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Thu, 18 Sep 2008 00:25:55 +0200
Subject: [Dsa-hl-svn] r4515 - rl/trunk/Mac/Rastullah.xcodeproj
Message-ID: <200809172225.m8HMPtWC011896@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-18 00:25:54 +0200 (Thu, 18 Sep 2008)
New Revision: 4515

Modified:
   rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
Log:


Modified: rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-17 22:25:45 UTC (rev 4514)
+++ rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-17 22:25:54 UTC (rev 4515)
@@ -613,6 +613,10 @@
 		485B895A0E15796500D5B19C /* Scene.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89570E15796500D5B19C /* Scene.cpp */; };
 		485B895B0E15796500D5B19C /* SceneLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89580E15796500D5B19C /* SceneLoader.cpp */; };
 		485B895C0E15796500D5B19C /* SceneManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89590E15796500D5B19C /* SceneManager.cpp */; };
+		487029C70E80DCEA00B66388 /* GameOverWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 487029C60E80DCEA00B66388 /* GameOverWindow.h */; };
+		487029C90E80DCF900B66388 /* GameOverWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487029C80E80DCF900B66388 /* GameOverWindow.cpp */; };
+		487029E80E80E12200B66388 /* PartyManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 487029E70E80E12200B66388 /* PartyManager.h */; };
+		487029EA0E80E13300B66388 /* PartyManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487029E90E80E13300B66388 /* PartyManager.cpp */; };
 		48760AAB0D92E4B700BEB57C /* RlExports_wrap.cxx in Sources */ = {isa = PBXBuildFile; fileRef = 48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */; };
 		48760AAC0D92E4B700BEB57C /* RlExports_wrap.h in Headers */ = {isa = PBXBuildFile; fileRef = 48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */; };
 		487750B00E7E3C9C0018216B /* Cg.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 487750AF0E7E3C9C0018216B /* Cg.framework */; };
@@ -1443,6 +1447,10 @@
 		485B89570E15796500D5B19C /* Scene.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Scene.cpp; path = ../engine/script/src/Scene.cpp; sourceTree = SOURCE_ROOT; };
 		485B89580E15796500D5B19C /* SceneLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SceneLoader.cpp; path = ../engine/script/src/SceneLoader.cpp; sourceTree = SOURCE_ROOT; };
 		485B89590E15796500D5B19C /* SceneManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SceneManager.cpp; path = ../engine/script/src/SceneManager.cpp; sourceTree = SOURCE_ROOT; };
+		487029C60E80DCEA00B66388 /* GameOverWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameOverWindow.h; path = ../engine/ui/include/GameOverWindow.h; sourceTree = SOURCE_ROOT; };
+		487029C80E80DCF900B66388 /* GameOverWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameOverWindow.cpp; path = ../engine/ui/src/GameOverWindow.cpp; sourceTree = SOURCE_ROOT; };
+		487029E70E80E12200B66388 /* PartyManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PartyManager.h; path = ../engine/rules/include/PartyManager.h; sourceTree = SOURCE_ROOT; };
+		487029E90E80E13300B66388 /* PartyManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PartyManager.cpp; path = ../engine/rules/src/PartyManager.cpp; sourceTree = SOURCE_ROOT; };
 		48760A990D92E2CD00BEB57C /* RlUi.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = RlUi.swig; path = ../engine/script/swig/RlUi.swig; sourceTree = SOURCE_ROOT; };
 		48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */ = {isa = PBXFileReference; explicitFileType = sourcecode.cpp.cpp; fileEncoding = 4; includeInIndex = 0; name = RlExports_wrap.cxx; path = ../engine/script/swig/RlExports_wrap.cxx; sourceTree = SOURCE_ROOT; };
 		48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RlExports_wrap.h; path = ../engine/script/swig/RlExports_wrap.h; sourceTree = SOURCE_ROOT; };
@@ -2058,6 +2066,8 @@
 		444EAC570BD0E4CD00C6D4A0 /* RlUi */ = {
 			isa = PBXGroup;
 			children = (
+				487029C80E80DCF900B66388 /* GameOverWindow.cpp */,
+				487029C60E80DCEA00B66388 /* GameOverWindow.h */,
 				48389B960D86743900AFAB66 /* CombatGui.h */,
 				48389B970D86743900AFAB66 /* GameSaveLoadWindow.h */,
 				48389B980D86743900AFAB66 /* MainMenuLoadWindow.h */,
@@ -2170,9 +2180,12 @@
 		444EAC590BD0E50600C6D4A0 /* RlRules */ = {
 			isa = PBXGroup;
 			children = (
+				487029E90E80E13300B66388 /* PartyManager.cpp */,
+				487029E70E80E12200B66388 /* PartyManager.h */,
 				4890C0C90E18062B00BE5850 /* FallDownMovement.cpp */,
 				4890C0CA0E18062B00BE5850 /* JogFastMovement.cpp */,
 				4890C0CB0E18062B00BE5850 /* JogMovement.cpp */,
+				483D311D0D85B215003477A0 /* RulesMessages.h */,
 				4890C0CC0E18062B00BE5850 /* JumpHighMovement.cpp */,
 				4890C0CD0E18062B00BE5850 /* JumpLongMovement.cpp */,
 				4890C0CE0E18062B00BE5850 /* JumpToTargetMovement.cpp */,
@@ -2229,7 +2242,6 @@
 				483D311B0D85B215003477A0 /* Kampfaktion.h */,
 				483D311C0D85B215003477A0 /* RulesConstants.h */,
 				483D31160D85B215003477A0 /* EffectManagementTask.h */,
-				483D311D0D85B215003477A0 /* RulesMessages.h */,
 				44D8145B0BF7B52600534175 /* Selector.h */,
 				444826030BF7B37D00C5A94F /* SelectionHelper.cpp */,
 				444826040BF7B37D00C5A94F /* Selector.cpp */,
@@ -2711,6 +2723,7 @@
 				4890C0C60E18061300BE5850 /* StrafeMovement.h in Headers */,
 				4890C0C70E18061300BE5850 /* WalkBackwardsMovement.h in Headers */,
 				4890C0C80E18061300BE5850 /* WalkMovement.h in Headers */,
+				487029E80E80E12200B66388 /* PartyManager.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -2772,6 +2785,7 @@
 				48389B9B0D86743900AFAB66 /* GameSaveLoadWindow.h in Headers */,
 				48389B9C0D86743900AFAB66 /* MainMenuLoadWindow.h in Headers */,
 				48389B9D0D86743900AFAB66 /* UiMessages.h in Headers */,
+				487029C70E80DCEA00B66388 /* GameOverWindow.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3307,6 +3321,7 @@
 				4890C0E20E18062B00BE5850 /* StepRecognitionMovement.cpp in Sources */,
 				4890C0E30E18062B00BE5850 /* StrafeMovement.cpp in Sources */,
 				4890C0E40E18062B00BE5850 /* WalkMovement.cpp in Sources */,
+				487029EA0E80E13300B66388 /* PartyManager.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3365,6 +3380,7 @@
 				48389B930D86741F00AFAB66 /* GameSaveLoadWindow.cpp in Sources */,
 				48389B940D86741F00AFAB66 /* MainMenuLoadWindow.cpp in Sources */,
 				48389B950D86741F00AFAB66 /* stdinc.cpp in Sources */,
+				487029C90E80DCF900B66388 /* GameOverWindow.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};



From timm at mail.berlios.de  Thu Sep 18 19:13:47 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Thu, 18 Sep 2008 19:13:47 +0200
Subject: [Dsa-hl-svn] r4516 - in rl/trunk/engine: rules ui
Message-ID: <200809181713.m8IHDlED012711@sheep.berlios.de>

Author: timm
Date: 2008-09-18 19:13:35 +0200 (Thu, 18 Sep 2008)
New Revision: 4516

Modified:
   rl/trunk/engine/rules/RlRules2005.vcproj
   rl/trunk/engine/ui/RlUI2005.vcproj
Log:
windows makefiles

Modified: rl/trunk/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/trunk/engine/rules/RlRules2005.vcproj	2008-09-17 22:25:54 UTC (rev 4515)
+++ rl/trunk/engine/rules/RlRules2005.vcproj	2008-09-18 17:13:35 UTC (rev 4516)
@@ -407,6 +407,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\PartyManager.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\Quest.cpp"
 				>
 			</File>
@@ -709,6 +713,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\PartyManager.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\Quest.h"
 				>
 			</File>

Modified: rl/trunk/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/trunk/engine/ui/RlUI2005.vcproj	2008-09-17 22:25:54 UTC (rev 4515)
+++ rl/trunk/engine/ui/RlUI2005.vcproj	2008-09-18 17:13:35 UTC (rev 4516)
@@ -377,6 +377,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\GameOverWindow.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\InputManager.h"
 				>
 			</File>
@@ -598,6 +602,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\GameOverWindow.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\InputManager.cpp"
 				>
 			</File>



From chrber at mail.berlios.de  Thu Sep 18 20:58:04 2008
From: chrber at mail.berlios.de (chrber at mail.berlios.de)
Date: Thu, 18 Sep 2008 20:58:04 +0200
Subject: [Dsa-hl-svn] r4517 - in rl/trunk/engine: rules/include rules/src
	ui/include ui/src
Message-ID: <200809181858.m8IIw4hS025844@sheep.berlios.de>

Author: chrber
Date: 2008-09-18 20:58:00 +0200 (Thu, 18 Sep 2008)
New Revision: 4517

Modified:
   rl/trunk/engine/rules/include/Makefile.am
   rl/trunk/engine/rules/src/Makefile.am
   rl/trunk/engine/ui/include/Makefile.am
   rl/trunk/engine/ui/src/Makefile.am
Log:
Added missing files to Makefiles


Modified: rl/trunk/engine/rules/include/Makefile.am
===================================================================
--- rl/trunk/engine/rules/include/Makefile.am	2008-09-18 17:13:35 UTC (rev 4516)
+++ rl/trunk/engine/rules/include/Makefile.am	2008-09-18 18:58:00 UTC (rev 4517)
@@ -31,6 +31,7 @@
 	ObjectStateChangeEvent.h \
 	ObjectStateChangeEventSource.h \
 	ObjectStateChangeListener.h \
+	PartyManager.h \
 	Quest.h \
 	QuestBook.h \
 	QuestEvent.h \

Modified: rl/trunk/engine/rules/src/Makefile.am
===================================================================
--- rl/trunk/engine/rules/src/Makefile.am	2008-09-18 17:13:35 UTC (rev 4516)
+++ rl/trunk/engine/rules/src/Makefile.am	2008-09-18 18:58:00 UTC (rev 4517)
@@ -37,6 +37,7 @@
 	ObjectStateChangeEvent.cpp \
 	ObjectStateChangeEventSource.cpp \
 	ObjectStateChangeListener.cpp \
+	PartyManager.cpp \
 	Quest.cpp \
 	QuestBook.cpp \
 	QuestEvent.cpp \

Modified: rl/trunk/engine/ui/include/Makefile.am
===================================================================
--- rl/trunk/engine/ui/include/Makefile.am	2008-09-18 17:13:35 UTC (rev 4516)
+++ rl/trunk/engine/ui/include/Makefile.am	2008-09-18 18:58:00 UTC (rev 4517)
@@ -21,6 +21,7 @@
     FreeflightControlState.h \
     GameLoggerWindow.h \
     GameObjectInfoWindow.h \
+	GameOverWindow.h \
 	GameSaveLoadWindow.h \
     GameSettings.h \
     InfoPopup.h \

Modified: rl/trunk/engine/ui/src/Makefile.am
===================================================================
--- rl/trunk/engine/ui/src/Makefile.am	2008-09-18 17:13:35 UTC (rev 4516)
+++ rl/trunk/engine/ui/src/Makefile.am	2008-09-18 18:58:00 UTC (rev 4517)
@@ -29,6 +29,7 @@
     FreeflightControlState.cpp \
     GameLoggerWindow.cpp \
     GameObjectInfoWindow.cpp \
+	GameOverWindow.cpp \
 	GameSaveLoadWindow.cpp \
     GameSettings.cpp \
     InfoPopup.cpp \



From timm at mail.berlios.de  Thu Sep 18 22:15:07 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Thu, 18 Sep 2008 22:15:07 +0200
Subject: [Dsa-hl-svn] r4518 - rl/trunk/engine/rules/src
Message-ID: <200809182015.m8IKF71Z000949@sheep.berlios.de>

Author: timm
Date: 2008-09-18 22:15:00 +0200 (Thu, 18 Sep 2008)
New Revision: 4518

Modified:
   rl/trunk/engine/rules/src/PartyManager.cpp
Log:
fixed crash in PartyManager::setActiveCharacter

Modified: rl/trunk/engine/rules/src/PartyManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/PartyManager.cpp	2008-09-18 18:58:00 UTC (rev 4517)
+++ rl/trunk/engine/rules/src/PartyManager.cpp	2008-09-18 20:15:00 UTC (rev 4518)
@@ -28,7 +28,7 @@
 namespace rl
 {
     
-    PartyManager::PartyManager()
+	PartyManager::PartyManager() : mActiveCharacter(NULL)
     {
         ///@todo watch characters for death, trigger game over if no-one is left
         mLifeStateChangeConnection =



From melven at mail.berlios.de  Fri Sep 19 10:22:50 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Fri, 19 Sep 2008 10:22:50 +0200
Subject: [Dsa-hl-svn] r4519 - in rl/branches/newton20: Mac
	Mac/Rastullah.xcodeproj engine/common/include
	engine/core/include engine/core/src engine/rules
	engine/rules/include engine/rules/src engine/script/src
	engine/script/swig engine/ui engine/ui/include engine/ui/src
Message-ID: <200809190822.m8J8MoYH030513@sheep.berlios.de>

Author: melven
Date: 2008-09-19 10:22:31 +0200 (Fri, 19 Sep 2008)
New Revision: 4519

Added:
   rl/branches/newton20/engine/rules/include/PartyManager.h
   rl/branches/newton20/engine/rules/src/PartyManager.cpp
   rl/branches/newton20/engine/ui/include/GameOverWindow.h
   rl/branches/newton20/engine/ui/src/GameOverWindow.cpp
Modified:
   rl/branches/newton20/Mac/Info.plist
   rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/branches/newton20/engine/common/include/Property.h
   rl/branches/newton20/engine/core/include/SaveAble.h
   rl/branches/newton20/engine/core/src/ConfigurationManager.cpp
   rl/branches/newton20/engine/core/src/SaveAble.cpp
   rl/branches/newton20/engine/rules/RlRules2005.vcproj
   rl/branches/newton20/engine/rules/include/Effect.h
   rl/branches/newton20/engine/rules/include/EffectManager.h
   rl/branches/newton20/engine/rules/include/GameObjectManager.h
   rl/branches/newton20/engine/rules/include/Makefile.am
   rl/branches/newton20/engine/rules/include/RulesMessages.h
   rl/branches/newton20/engine/rules/include/RulesSubsystem.h
   rl/branches/newton20/engine/rules/src/Creature.cpp
   rl/branches/newton20/engine/rules/src/Effect.cpp
   rl/branches/newton20/engine/rules/src/EffectManager.cpp
   rl/branches/newton20/engine/rules/src/GameObjectManager.cpp
   rl/branches/newton20/engine/rules/src/Makefile.am
   rl/branches/newton20/engine/rules/src/RulesSubsystem.cpp
   rl/branches/newton20/engine/script/src/EnvironmentProcessor.cpp
   rl/branches/newton20/engine/script/src/PlaneNodeProcessor.cpp
   rl/branches/newton20/engine/script/src/SceneManager.cpp
   rl/branches/newton20/engine/script/src/ZoneProcessor.cpp
   rl/branches/newton20/engine/script/swig/RlRules.head.swig
   rl/branches/newton20/engine/script/swig/RlRules.swig
   rl/branches/newton20/engine/script/swig/RlUi.swig
   rl/branches/newton20/engine/ui/RlUI2005.vcproj
   rl/branches/newton20/engine/ui/include/Makefile.am
   rl/branches/newton20/engine/ui/include/UiMessages.h
   rl/branches/newton20/engine/ui/include/UiSubsystem.h
   rl/branches/newton20/engine/ui/include/WindowFactory.h
   rl/branches/newton20/engine/ui/src/DebugWindow.cpp
   rl/branches/newton20/engine/ui/src/GameSaveLoadWindow.cpp
   rl/branches/newton20/engine/ui/src/InputManager.cpp
   rl/branches/newton20/engine/ui/src/MainMenuLoadWindow.cpp
   rl/branches/newton20/engine/ui/src/Makefile.am
   rl/branches/newton20/engine/ui/src/UiSubsystem.cpp
   rl/branches/newton20/engine/ui/src/WindowFactory.cpp
Log:
merged changes from trunk


Modified: rl/branches/newton20/Mac/Info.plist
===================================================================
--- rl/branches/newton20/Mac/Info.plist	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/Mac/Info.plist	2008-09-19 08:22:31 UTC (rev 4519)
@@ -19,7 +19,7 @@
 	<key>CFBundleSignature</key>
 	<string>????</string>
 	<key>CFBundleVersion</key>
-	<string>1.0</string>
+	<string>0.3</string>
 	<key>CSResourcesFileMapped</key>
 	<true/>
 </dict>

Modified: rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-19 08:22:31 UTC (rev 4519)
@@ -613,8 +613,13 @@
 		485B895A0E15796500D5B19C /* Scene.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89570E15796500D5B19C /* Scene.cpp */; };
 		485B895B0E15796500D5B19C /* SceneLoader.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89580E15796500D5B19C /* SceneLoader.cpp */; };
 		485B895C0E15796500D5B19C /* SceneManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 485B89590E15796500D5B19C /* SceneManager.cpp */; };
+		487029C70E80DCEA00B66388 /* GameOverWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 487029C60E80DCEA00B66388 /* GameOverWindow.h */; };
+		487029C90E80DCF900B66388 /* GameOverWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487029C80E80DCF900B66388 /* GameOverWindow.cpp */; };
+		487029E80E80E12200B66388 /* PartyManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 487029E70E80E12200B66388 /* PartyManager.h */; };
+		487029EA0E80E13300B66388 /* PartyManager.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487029E90E80E13300B66388 /* PartyManager.cpp */; };
 		48760AAB0D92E4B700BEB57C /* RlExports_wrap.cxx in Sources */ = {isa = PBXBuildFile; fileRef = 48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */; };
 		48760AAC0D92E4B700BEB57C /* RlExports_wrap.h in Headers */ = {isa = PBXBuildFile; fileRef = 48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */; };
+		487750B00E7E3C9C0018216B /* Cg.framework in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 487750AF0E7E3C9C0018216B /* Cg.framework */; };
 		4890C0B80E18061300BE5850 /* AbstractMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A70E18061300BE5850 /* AbstractMovement.h */; };
 		4890C0B90E18061300BE5850 /* FallDownMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A80E18061300BE5850 /* FallDownMovement.h */; };
 		4890C0BA0E18061300BE5850 /* JogBackwardsMovement.h in Headers */ = {isa = PBXBuildFile; fileRef = 4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */; };
@@ -664,7 +669,6 @@
 		48B0B03C0E6535AB0023B198 /* libmeshmagick.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 440785DD0C09D231006E496D /* libmeshmagick.dylib */; };
 		48B0B0490E65BBB30023B198 /* libfmodex.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48B0B0480E65BBB30023B198 /* libfmodex.dylib */; };
 		48B0B04A0E65BBC10023B198 /* libfmodex.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 48B0B0480E65BBB30023B198 /* libfmodex.dylib */; };
-		48B5F63A0DAF48AF00D05C95 /* Info.plist in Resources */ = {isa = PBXBuildFile; fileRef = 8D0C4E960486CD37000505A6 /* Info.plist */; };
 		48B772DD0D58350B000A3B97 /* XmlProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B772DA0D58350B000A3B97 /* XmlProcessor.h */; };
 		48B772DE0D58350B000A3B97 /* XmlPropertyReader.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B772DB0D58350B000A3B97 /* XmlPropertyReader.h */; };
 		48B772DF0D58350B000A3B97 /* XmlPropertyWriter.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B772DC0D58350B000A3B97 /* XmlPropertyWriter.h */; };
@@ -853,6 +857,7 @@
 			dstPath = "";
 			dstSubfolderSpec = 10;
 			files = (
+				487750B00E7E3C9C0018216B /* Cg.framework in Copy Frameworks */,
 				48C04B8A0E67DF0300CD3A7D /* PCRE.framework in Copy Frameworks */,
 				48003B550E3211660056D073 /* libboost_system.dylib in Copy Frameworks */,
 				48D0BDE60E23378700863824 /* libboost_filesystem.dylib in Copy Frameworks */,
@@ -884,7 +889,7 @@
 		440785E20C09D2C1006E496D /* LightFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LightFadeJob.cpp; path = ../engine/core/src/LightFadeJob.cpp; sourceTree = SOURCE_ROOT; };
 		440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MergeableMeshObject.cpp; path = ../engine/core/src/MergeableMeshObject.cpp; sourceTree = SOURCE_ROOT; };
 		440785E60C09D2DF006E496D /* MergeableMeshObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MergeableMeshObject.h; path = ../engine/core/include/MergeableMeshObject.h; sourceTree = SOURCE_ROOT; };
-		440786120C09D602006E496D /* RlScript-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.xml; path = "RlScript-Info.plist"; sourceTree = "<group>"; };
+		440786120C09D602006E496D /* RlScript-Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = "RlScript-Info.plist"; sourceTree = "<group>"; };
 		44125A2F0C083D0100C24C0A /* CreatureWalkPathJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CreatureWalkPathJob.cpp; path = ../engine/ai/src/CreatureWalkPathJob.cpp; sourceTree = SOURCE_ROOT; };
 		44125A310C083D1100C24C0A /* CreatureWalkPathJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CreatureWalkPathJob.h; path = ../engine/ai/include/CreatureWalkPathJob.h; sourceTree = SOURCE_ROOT; };
 		444825D90BF7B2B200C5A94F /* AbstractMapNodeProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AbstractMapNodeProcessor.cpp; path = ../engine/script/src/AbstractMapNodeProcessor.cpp; sourceTree = SOURCE_ROOT; };
@@ -1442,9 +1447,14 @@
 		485B89570E15796500D5B19C /* Scene.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Scene.cpp; path = ../engine/script/src/Scene.cpp; sourceTree = SOURCE_ROOT; };
 		485B89580E15796500D5B19C /* SceneLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SceneLoader.cpp; path = ../engine/script/src/SceneLoader.cpp; sourceTree = SOURCE_ROOT; };
 		485B89590E15796500D5B19C /* SceneManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SceneManager.cpp; path = ../engine/script/src/SceneManager.cpp; sourceTree = SOURCE_ROOT; };
+		487029C60E80DCEA00B66388 /* GameOverWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameOverWindow.h; path = ../engine/ui/include/GameOverWindow.h; sourceTree = SOURCE_ROOT; };
+		487029C80E80DCF900B66388 /* GameOverWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameOverWindow.cpp; path = ../engine/ui/src/GameOverWindow.cpp; sourceTree = SOURCE_ROOT; };
+		487029E70E80E12200B66388 /* PartyManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PartyManager.h; path = ../engine/rules/include/PartyManager.h; sourceTree = SOURCE_ROOT; };
+		487029E90E80E13300B66388 /* PartyManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PartyManager.cpp; path = ../engine/rules/src/PartyManager.cpp; sourceTree = SOURCE_ROOT; };
 		48760A990D92E2CD00BEB57C /* RlUi.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = RlUi.swig; path = ../engine/script/swig/RlUi.swig; sourceTree = SOURCE_ROOT; };
 		48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */ = {isa = PBXFileReference; explicitFileType = sourcecode.cpp.cpp; fileEncoding = 4; includeInIndex = 0; name = RlExports_wrap.cxx; path = ../engine/script/swig/RlExports_wrap.cxx; sourceTree = SOURCE_ROOT; };
 		48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RlExports_wrap.h; path = ../engine/script/swig/RlExports_wrap.h; sourceTree = SOURCE_ROOT; };
+		487750AF0E7E3C9C0018216B /* Cg.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cg.framework; path = /Library/Frameworks/Cg.framework; sourceTree = "<absolute>"; };
 		4890C0A70E18061300BE5850 /* AbstractMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AbstractMovement.h; path = ../engine/rules/include/AbstractMovement.h; sourceTree = SOURCE_ROOT; };
 		4890C0A80E18061300BE5850 /* FallDownMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = FallDownMovement.h; path = ../engine/rules/include/FallDownMovement.h; sourceTree = SOURCE_ROOT; };
 		4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JogBackwardsMovement.h; path = ../engine/rules/include/JogBackwardsMovement.h; sourceTree = SOURCE_ROOT; };
@@ -1687,9 +1697,8 @@
 		20286C29FDCF999611CA2CEA /* Rastullah */ = {
 			isa = PBXGroup;
 			children = (
-				48C04B890E67DF0300CD3A7D /* PCRE.framework */,
-				48B0B0480E65BBB30023B198 /* libfmodex.dylib */,
 				20286C2AFDCF999611CA2CEA /* Sources */,
+				48D401810D9E483200AE5340 /* modules */,
 				20286C2CFDCF999611CA2CEA /* Resources */,
 				20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */,
 				195DF8CFFE9D517E11CA2CBB /* Products */,
@@ -1701,10 +1710,10 @@
 			isa = PBXGroup;
 			children = (
 				48CFBFD60E2E87A800CD0C51 /* Scripts */,
-				483D86890D8C3DA200F3629E /* RlFmod4Driver */,
 				444EAC220BD0E3E000C6D4A0 /* RlAi */,
 				444EAB1F0BD0E25C00C6D4A0 /* RlCommon */,
 				444EAB200BD0E27400C6D4A0 /* RlCore */,
+				483D86890D8C3DA200F3629E /* RlFmod4Driver */,
 				444EAC590BD0E50600C6D4A0 /* RlRules */,
 				444EAE600BD0E66500C6D4A0 /* RlScript */,
 				444EAC570BD0E4CD00C6D4A0 /* RlUi */,
@@ -1716,7 +1725,6 @@
 		20286C2CFDCF999611CA2CEA /* Resources */ = {
 			isa = PBXGroup;
 			children = (
-				48D401810D9E483200AE5340 /* modules */,
 				440786120C09D602006E496D /* RlScript-Info.plist */,
 				8D0C4E960486CD37000505A6 /* Info.plist */,
 				0867D6AAFE840B52C02AAC07 /* InfoPlist.strings */,
@@ -1728,6 +1736,9 @@
 		20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */ = {
 			isa = PBXGroup;
 			children = (
+				487750AF0E7E3C9C0018216B /* Cg.framework */,
+				48C04B890E67DF0300CD3A7D /* PCRE.framework */,
+				48B0B0480E65BBB30023B198 /* libfmodex.dylib */,
 				48CFBF8E0E2E869000CD0C51 /* FreeType.framework */,
 				484FE6B90E17BC8800FA880F /* Carbon.framework */,
 				48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */,
@@ -2055,6 +2066,8 @@
 		444EAC570BD0E4CD00C6D4A0 /* RlUi */ = {
 			isa = PBXGroup;
 			children = (
+				487029C80E80DCF900B66388 /* GameOverWindow.cpp */,
+				487029C60E80DCEA00B66388 /* GameOverWindow.h */,
 				48389B960D86743900AFAB66 /* CombatGui.h */,
 				48389B970D86743900AFAB66 /* GameSaveLoadWindow.h */,
 				48389B980D86743900AFAB66 /* MainMenuLoadWindow.h */,
@@ -2167,9 +2180,12 @@
 		444EAC590BD0E50600C6D4A0 /* RlRules */ = {
 			isa = PBXGroup;
 			children = (
+				487029E90E80E13300B66388 /* PartyManager.cpp */,
+				487029E70E80E12200B66388 /* PartyManager.h */,
 				4890C0C90E18062B00BE5850 /* FallDownMovement.cpp */,
 				4890C0CA0E18062B00BE5850 /* JogFastMovement.cpp */,
 				4890C0CB0E18062B00BE5850 /* JogMovement.cpp */,
+				483D311D0D85B215003477A0 /* RulesMessages.h */,
 				4890C0CC0E18062B00BE5850 /* JumpHighMovement.cpp */,
 				4890C0CD0E18062B00BE5850 /* JumpLongMovement.cpp */,
 				4890C0CE0E18062B00BE5850 /* JumpToTargetMovement.cpp */,
@@ -2226,7 +2242,6 @@
 				483D311B0D85B215003477A0 /* Kampfaktion.h */,
 				483D311C0D85B215003477A0 /* RulesConstants.h */,
 				483D31160D85B215003477A0 /* EffectManagementTask.h */,
-				483D311D0D85B215003477A0 /* RulesMessages.h */,
 				44D8145B0BF7B52600534175 /* Selector.h */,
 				444826030BF7B37D00C5A94F /* SelectionHelper.cpp */,
 				444826040BF7B37D00C5A94F /* Selector.cpp */,
@@ -2708,6 +2723,7 @@
 				4890C0C60E18061300BE5850 /* StrafeMovement.h in Headers */,
 				4890C0C70E18061300BE5850 /* WalkBackwardsMovement.h in Headers */,
 				4890C0C80E18061300BE5850 /* WalkMovement.h in Headers */,
+				487029E80E80E12200B66388 /* PartyManager.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -2769,6 +2785,7 @@
 				48389B9B0D86743900AFAB66 /* GameSaveLoadWindow.h in Headers */,
 				48389B9C0D86743900AFAB66 /* MainMenuLoadWindow.h in Headers */,
 				48389B9D0D86743900AFAB66 /* UiMessages.h in Headers */,
+				487029C70E80DCEA00B66388 /* GameOverWindow.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3046,7 +3063,6 @@
 				8D0C4E8D0486CD37000505A6 /* InfoPlist.strings in Resources */,
 				8D0C4E8E0486CD37000505A6 /* main.nib in Resources */,
 				48D409CE0D9E483300AE5340 /* modules in Resources */,
-				48B5F63A0DAF48AF00D05C95 /* Info.plist in Resources */,
 				4835559B0E6ABED100008748 /* mkdmg.sh in Resources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
@@ -3305,6 +3321,7 @@
 				4890C0E20E18062B00BE5850 /* StepRecognitionMovement.cpp in Sources */,
 				4890C0E30E18062B00BE5850 /* StrafeMovement.cpp in Sources */,
 				4890C0E40E18062B00BE5850 /* WalkMovement.cpp in Sources */,
+				487029EA0E80E13300B66388 /* PartyManager.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3363,6 +3380,7 @@
 				48389B930D86741F00AFAB66 /* GameSaveLoadWindow.cpp in Sources */,
 				48389B940D86741F00AFAB66 /* MainMenuLoadWindow.cpp in Sources */,
 				48389B950D86741F00AFAB66 /* stdinc.cpp in Sources */,
+				487029C90E80DCF900B66388 /* GameOverWindow.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};

Modified: rl/branches/newton20/engine/common/include/Property.h
===================================================================
--- rl/branches/newton20/engine/common/include/Property.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/common/include/Property.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -87,6 +87,7 @@
         PropertyMethod(Bool, const bool&);
         PropertyMethod(String, CEGUI::String);
         PropertyMethod(Int, const int&);
+        PropertyMethod(Long, const RL_LONGLONG&);
         PropertyMethod(Real, const Ogre::Real&);
         PropertyMethod(Vector3, const Ogre::Vector3&);
         PropertyMethod(Quaternion, const Ogre::Quaternion&);

Modified: rl/branches/newton20/engine/core/include/SaveAble.h
===================================================================
--- rl/branches/newton20/engine/core/include/SaveAble.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/core/include/SaveAble.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -12,4 +12,30 @@
  *  You should have received a copy of the Clarified Artistic License
  *  along with this program; if not you can get it here
  *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
\ No newline at end of file
+ */
+
+
+/// Basis jedes Objektes im Spiel, welches ver?nderlich ist und einen abspeicherbaren Status haben soll
+
+#ifndef __SaveAble_H__
+#define __SaveAble_H__
+
+#include "CorePrerequisites.h"
+#include "Properties.h"
+
+namespace rl
+{
+
+	class SaveAble : public PropertyHolder
+	{
+	public:
+		void setSaveAble(bool enable);
+		bool isSaveAble();
+	protected:
+		bool mIsSaveAble;
+	};
+
+}
+
+
+#endif
\ No newline at end of file

Modified: rl/branches/newton20/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/ConfigurationManager.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/core/src/ConfigurationManager.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -124,8 +124,6 @@
         addSetting("MovementController keys", "reset_camera", "0 (Nummernblock)");
 
         addSetting("Localization", "language", "de");
-
-        setRastullahCfgPath();
     }
 
     ConfigurationManager::~ConfigurationManager()
@@ -187,6 +185,7 @@
 
     void ConfigurationManager::loadConfig()
     {
+        setRastullahCfgPath();
         // On Linux, we create the .rastullah directory
 #       if OGRE_PLATFORM != OGRE_PLATFORM_WIN32
         fs::path rastullahCfgDirectory(Ogre::String(::getenv("HOME")) + "/.rastullah",
@@ -265,6 +264,8 @@
         {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
             mModulesRootDirectory = RL_MODULEDIR;
+#           elif OGRE_PLATFORM == OGRE_PLATFORM_APPLE
+            mModulesRootDirectory = mExecutablePath + "/../Resources/modules";
 #           else
             mModulesRootDirectory = "./modules";
 #           endif
@@ -388,8 +389,8 @@
 	void ConfigurationManager::setExecutable(const Ogre::String& path)
 	{
 		fs::path exeAbsolute(path, fs::portable_posix_name);
-		
 		mExecutablePath = exeAbsolute.remove_leaf().string();
+        std::cout << "ConfigurationManager" << "Executable is " << path << " " << mExecutablePath;
 	}
 
 	const Ogre::String& ConfigurationManager::getExecutablePath() const
@@ -436,20 +437,23 @@
 
     bool ConfigurationManager::checkForFile(const Ogre::String& filename)
     {
-        try {
+        try 
+        {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-			std::cout << "Checking for " << fs::complete(filename);
+			std::cout << "Checking for " << fs::complete(filename) << std::endl;
             if (fs::exists(filename))
 #           else
 			std::cout << "Checking for " << 
-				fs::complete(fs::path(filename, fs::portable_posix_name)).string();
+				fs::complete(fs::path(filename, fs::portable_posix_name)).string()
+                 << std::endl;
 			if (fs::exists(fs::path(filename, fs::portable_posix_name)))
 #           endif
             {
                 return true;
             }
         }
-        catch (fs::filesystem_error&) {
+        catch (fs::filesystem_error&) 
+        {
             return false;
         }
 

Modified: rl/branches/newton20/engine/core/src/SaveAble.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/SaveAble.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/core/src/SaveAble.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -21,11 +21,15 @@
 #include "Property.h"
 #include "Properties.h"
 
-class SaveAble
+namespace rl
 {
-public:
-    void setSaveAble(bool enable);
-    bool isSaveAble();
-protected:
-    bool mIsSaveAble;
-};
\ No newline at end of file
+	void SaveAble::setSaveAble(bool enable)
+	{
+		mIsSaveAble = true;
+	}
+
+	bool SaveAble::isSaveAble()
+	{
+		return mIsSaveAble;
+	}
+}
\ No newline at end of file

Modified: rl/branches/newton20/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/branches/newton20/engine/rules/RlRules2005.vcproj	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/RlRules2005.vcproj	2008-09-19 08:22:31 UTC (rev 4519)
@@ -407,6 +407,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\PartyManager.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\Quest.cpp"
 				>
 			</File>
@@ -709,6 +713,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\PartyManager.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\Quest.h"
 				>
 			</File>

Modified: rl/branches/newton20/engine/rules/include/Effect.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Effect.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/include/Effect.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -80,13 +80,17 @@
             QUANTIFIER_UNIQUE_BUT_CUMULATIVE
         };
 
+        static const Ogre::String PROPERTY_NAME;
+        static const Ogre::String PROPERTY_STUFE;
+        static const Ogre::String PROPERTY_ENABLED;
 
+
         /// Setzt den Quantifier standardmaessig auf QUANTIFIER_MULTIPLE.
 		Effect(int stufe = 1);
         virtual ~Effect() {}
 
-        const CeGuiString getName() const;
-        void setName(CeGuiString name);
+        const Ogre::String getName() const;
+        void setName(Ogre::String name);
         const CeGuiString getDescription() const;
         void setDescription(CeGuiString description);
         /// @see Quantifier
@@ -131,7 +135,7 @@
         virtual void setProperty(const CeGuiString& key, const Property& value);
         virtual PropertyKeys getAllPropertyKeys() const;
 	protected:
-		CeGuiString mName;
+		Ogre::String mName;
 		CeGuiString mDescription;
 		/// Dauer desEffekts in Aktionen.
 		int mStufe;

Modified: rl/branches/newton20/engine/rules/include/EffectManager.h
===================================================================
--- rl/branches/newton20/engine/rules/include/EffectManager.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/include/EffectManager.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,121 +1,130 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __EFFECTMANAGER_H__
-#define __EFFECTMANAGER_H__
-
-#include "RulesPrerequisites.h"
-
-#include <set>
-
-#include "Date.h"
-#include "Effect.h"
-
-namespace rl
-{
-    class GameObject;
-
-    /**
-     * @brief Manages the effects affecting a game object
-     * 
-     * This class manages all effects applied to a game object.
-     * Each game object has a seperate EffectManager. The method checkEffects()
-     * should be called every Aktion (the dark eye time unit)
-     **/
-
-	class _RlRulesExport EffectManager
-	{
-	public:
-		EffectManager(GameObject* gameobject);
-		~EffectManager();
-
-        /**
-         *  Checks effects for changes.
-         **/
-		void checkEffects();
-        /** 
-         *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
-         *  in welcher Zeit er wieder ueberprueft werden muss.
-         *  @param time Die Zeitspanne wann die naechste Ueberpruefung faellig ist.
-         *  @param effect Der zu ueberpruefende Effekt.
-         *  @throws IllegalArgumentException time parameter is <= 0
-         *  @throws IllegalArgumentException effect pointer is NULL
-         *  @see addCheckDate Date
-         **/
-        void addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect);
-        /**
-         *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
-         *  zu welchem Zeitpunkt er wieder ueberprueft werden muss.
-         *  @param date Das Datum der naechsten Ueberpruefung.
-         *  @param effect Der zu ueberpruefende Effekt.
-         *  @throws IllegalArgumentException date lies in the past
-         *  @throws IllegalArgumentException effect pointer is NULL
-         *  @see addCheck, Date
-         **/
-        void addDateCheck(RL_LONGLONG date, Effect* effect);
-        /**
-         * Fuegt einen neuen Effekt in die Liste ein.
-         * @param effect Ein Zeiger auf den einzufuegenden Effekt.
-         **/
-		void addEffect(Effect* effect);
-        
-        /// Removes effects by pointer.
-        void removeEffect(Effect* effect);
-
-        /// Removes effects by name.
-        void removeEffect(CeGuiString name);
-        
-        /**
-         * Checks the effects for the given status.
-         **/
-        Effect::LifeState getLifeState();
-        
-        /**
-         * Returns the specified modificator.
-         * @param target specifies what modificator you want to get (e.g. "Athletik")
-         * @param type specifies what type of modificator you want (e.g. modificator of the TaW or the Probenzuschlag)
-         * @param tag add some additional restrictions (e.g. KO Probe for sicknesses or Athletik for balance acts)
-         **/
-        int getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag = Effect::MODTAG_NONE);
-
-        /**
-         * Returns a printable list of all effects
-         **/
-        CeGuiString getEffects();
-
-        void checkStateChange(Effect::LifeState oldState);
-
-	private:
-
-        GameObject* mGameObject;
-
-        // only used in checkEffects!
-        bool mCheckEffectsRunning;
-
-        /// Eine einfache Menge von Effekten
-		typedef std::set<Effect*> Effects;
-		Effects mEffects;
-        /**
-         * Eine Liste die wiedergibt, wann welcher Effekt
-         * ueberprueft werden muss.
-         **/
-        typedef std::map<RL_LONGLONG, Effects> Checklist;
-        Checklist mChecklist;
-	};
-}
-
-#endif //__EFFECTMANAGER_H__
-		
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __EFFECTMANAGER_H__
+#define __EFFECTMANAGER_H__
+
+#include "RulesPrerequisites.h"
+
+#include <set>
+
+#include "Date.h"
+#include "Effect.h"
+
+namespace rl
+{
+    class GameObject;
+
+    /**
+     * @brief Manages the effects affecting a game object
+     * 
+     * This class manages all effects applied to a game object.
+     * Each game object has a seperate EffectManager. The method checkEffects()
+     * should be called every Aktion (the dark eye time unit)
+     **/
+
+    class _RlRulesExport EffectManager : public PropertyHolder
+	{
+	public:
+    
+        static const Ogre::String PROPERTY_TIMECHECK;
+        static const Ogre::String PROPERTY_TIME;
+        static const Ogre::String PROPERTY_EFFECT;
+        
+		EffectManager(GameObject* gameobject);
+		~EffectManager();
+
+        /**
+         *  Checks effects for changes.
+         **/
+		void checkEffects();
+        /** 
+         *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
+         *  in welcher Zeit er wieder ueberprueft werden muss.
+         *  @param time Die Zeitspanne wann die naechste Ueberpruefung faellig ist.
+         *  @param effect Der zu ueberpruefende Effekt.
+         *  @throws IllegalArgumentException time parameter is <= 0
+         *  @throws IllegalArgumentException effect pointer is NULL
+         *  @see addCheckDate Date
+         **/
+        void addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect);
+        /**
+         *  Mit dieser Funktion kann ein Effekt dem Manager mitteilen,
+         *  zu welchem Zeitpunkt er wieder ueberprueft werden muss.
+         *  @param date Das Datum der naechsten Ueberpruefung.
+         *  @param effect Der zu ueberpruefende Effekt.
+         *  @throws IllegalArgumentException date lies in the past
+         *  @throws IllegalArgumentException effect pointer is NULL
+         *  @see addCheck, Date
+         **/
+        void addDateCheck(RL_LONGLONG date, Effect* effect);
+        /**
+         * Fuegt einen neuen Effekt in die Liste ein.
+         * @param effect Ein Zeiger auf den einzufuegenden Effekt.
+         **/
+		void addEffect(Effect* effect);
+        
+        /// Removes effects by pointer.
+        void removeEffect(Effect* effect);
+
+        /// Removes effects by name.
+        void removeEffect(CeGuiString name);
+        
+        /**
+         * Checks the effects for the given status.
+         **/
+        Effect::LifeState getLifeState();
+        
+        /**
+         * Returns the specified modificator.
+         * @param target specifies what modificator you want to get (e.g. "Athletik")
+         * @param type specifies what type of modificator you want (e.g. modificator of the TaW or the Probenzuschlag)
+         * @param tag add some additional restrictions (e.g. KO Probe for sicknesses or Athletik for balance acts)
+         **/
+        int getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag = Effect::MODTAG_NONE);
+
+        /**
+         * Returns a printable list of all effects
+         **/
+        CeGuiString getEffects();
+
+        void checkStateChange(Effect::LifeState oldState);
+
+        virtual const Property getProperty(const CeGuiString& key) const;
+        virtual void setProperty(const CeGuiString& key, const Property& value);
+        virtual PropertyKeys getAllPropertyKeys() const;
+
+	private:
+
+        GameObject* mGameObject;
+
+        // only used in checkEffects!
+        bool mCheckEffectsRunning;
+
+        /// Eine einfache Menge von Effekten
+		typedef std::vector<Effect*> Effects;
+		Effects mEffects;
+        /**
+         * Eine Liste die wiedergibt, wann welcher Effekt
+         * ueberprueft werden muss.
+         **/
+        typedef std::map<RL_LONGLONG, Effects> Checklist;
+        Checklist mChecklist;
+	};
+}
+
+#endif //__EFFECTMANAGER_H__
+		

Modified: rl/branches/newton20/engine/rules/include/GameObjectManager.h
===================================================================
--- rl/branches/newton20/engine/rules/include/GameObjectManager.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/include/GameObjectManager.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -42,8 +42,7 @@
     class _RlRulesExport GameObjectManager : 
         public Ogre::Singleton<GameObjectManager>,
         public GameObjectStateListener,
-        public Ogre::ScriptLoader,
-        public SaveGameData
+        public Ogre::ScriptLoader
     {
     public:
         GameObjectManager();
@@ -74,14 +73,6 @@
         void registerGameObjectStateListener(GameObjectStateListener* listener);
         void unregisterGameObjectStateListener(GameObjectStateListener* listener);
         void unregisterAllGameObjectStateListener();
-
-        /// Override from SaveGameData
-        /// Manages saving and loading from the SaveGameFile
-
-        virtual CeGuiString getXmlNodeIdentifier() const;
-        virtual void writeData(SaveGameFileWriter* writer);
-        virtual void readData(SaveGameFileReader* reader);
-        virtual int getPriority() const;
     private:
         typedef std::map<const CeGuiString, PropertyRecordPtr> ClassPropertyMap;
         typedef std::set<GameObjectStateListener*> GameObjectStateListenerSet;

Modified: rl/branches/newton20/engine/rules/include/Makefile.am
===================================================================
--- rl/branches/newton20/engine/rules/include/Makefile.am	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/include/Makefile.am	2008-09-19 08:22:31 UTC (rev 4519)
@@ -31,6 +31,7 @@
 	ObjectStateChangeEvent.h \
 	ObjectStateChangeEventSource.h \
 	ObjectStateChangeListener.h \
+	PartyManager.h \
 	Quest.h \
 	QuestBook.h \
 	QuestEvent.h \

Copied: rl/branches/newton20/engine/rules/include/PartyManager.h (from rev 4518, rl/trunk/engine/rules/include/PartyManager.h)

Modified: rl/branches/newton20/engine/rules/include/RulesMessages.h
===================================================================
--- rl/branches/newton20/engine/rules/include/RulesMessages.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/include/RulesMessages.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,75 +1,101 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __Rl_RulesMessages_H__
-#define __Rl_RulesMessages_H__
-
-#include "RulesPrerequisites.h"
-
-#include "MessageType.h"
-#include "RulesConstants.h"
-#include "CoreMessages.h"
-#include "Effect.h"
-
-namespace rl
-{
-	class Combatant;
-	class GameObject;
-
-	/// 0x03xxxxxx as mask for rules messages
-    enum RulesMessageTypeIds
-    {
-        // Game event log //
-        // Mask
-        RLMSG_GAMEEVENTLOG_EVENTS = 0x03000100,
-        // Events
-        RLMSG_GAMEEVENTLOG_EVENT_ADDED = 0x03000101,
-
-		// Combat
-		// Mask
-		RLMSG_COMBAT_EVENTS = 0x03000200,
-		// Events
-		RLMSG_COMBAT_OPPONENT_ENTERED = 0x03000201,
-		RLMSG_COMBAT_OPPONENT_LEFT = 0x03000202,
-		RLMSG_COMBAT_ENDED = 0x03000210,
-
-		// Game object related events
-        // Mask
-        RLMSG_GAMEOBJECT_EVENTS = 0x03000300,
-        // Events
-        RLMSG_GAMEOBJECT_LIFESTATE_CHANGED = 0x03000301
-    };
-
-    /// Message sent right after a new game log event has been added.
-	typedef MessageType<RLMSG_GAMEEVENTLOG_EVENT_ADDED, GameEventType, CeGuiString>
-		MessageType_GameEventLog_EventAdded;
-
-	typedef MessageType<RLMSG_COMBAT_OPPONENT_ENTERED, Combatant*>
-		MessageType_CombatOpponentEntered;
-
-	typedef MessageType<RLMSG_COMBAT_OPPONENT_LEFT, Combatant*>
-		MessageType_CombatOpponentLeft;
-
-    typedef MessageType<RLMSG_COMBAT_ENDED, bool>
-		MessageType_CombatEnded;
-
-    typedef MessageType<RLMSG_GAMEOBJECT_LIFESTATE_CHANGED, GameObject*, Effect::LifeState, Effect::LifeState>
-		MessageType_GameObjectLifeStateChanged;
-    
-    typedef MessageType<RLMSG_SAVEGAME_GOS_LOADED> MessageType_GameObjectsLoaded;
-
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __Rl_RulesMessages_H__
+#define __Rl_RulesMessages_H__
+
+#include "RulesPrerequisites.h"
+
+#include "MessageType.h"
+#include "RulesConstants.h"
+#include "CoreMessages.h"
+#include "Effect.h"
+
+namespace rl
+{
+	class Combatant;
+    class Creature;
+	class GameObject;
+
+	/// 0x03xxxxxx as mask for rules messages
+    enum RulesMessageTypeIds
+    {
+        // Game event log //
+        // Mask
+        RLMSG_GAMEEVENTLOG_EVENTS = 0x03000100,
+        // Events
+        RLMSG_GAMEEVENTLOG_EVENT_ADDED = 0x03000101,
+
+		// Combat
+		// Mask
+		RLMSG_COMBAT_EVENTS = 0x03000200,
+		// Events
+		RLMSG_COMBAT_OPPONENT_ENTERED = 0x03000201,
+		RLMSG_COMBAT_OPPONENT_LEFT = 0x03000202,
+		RLMSG_COMBAT_ENDED = 0x03000210,
+
+		// Game object related events
+        // Mask
+        RLMSG_GAMEOBJECT_EVENTS = 0x03000300,
+        // Events
+        RLMSG_GAMEOBJECT_LIFESTATE_CHANGED = 0x03000301,
+        
+        // Player character related events
+        // Mask
+        RLMSG_PLAYERCHAR_EVENTS = 0x03000400,
+        // Events
+        RLMSG_PLAYERCHAR_DIED = 0x03000401,
+        RLMSG_PLAYERCHAR_ALL_DIED = 0x03000402,
+        RLMSG_PLAYERCHAR_ADDED = 0x03000403,
+        RLMSG_PLAYERCHAR_REMOVED = 0x03000404,
+        RLMSG_PLAYERCHAR_ACTIVE_CHANGED = 0x03000405        
+    };
+
+    /// Message sent right after a new game log event has been added.
+	typedef MessageType<RLMSG_GAMEEVENTLOG_EVENT_ADDED, GameEventType, CeGuiString>
+		MessageType_GameEventLog_EventAdded;
+
+	typedef MessageType<RLMSG_COMBAT_OPPONENT_ENTERED, Combatant*>
+		MessageType_CombatOpponentEntered;
+
+	typedef MessageType<RLMSG_COMBAT_OPPONENT_LEFT, Combatant*>
+		MessageType_CombatOpponentLeft;
+
+    typedef MessageType<RLMSG_COMBAT_ENDED, bool>
+		MessageType_CombatEnded;
+
+    typedef MessageType<RLMSG_GAMEOBJECT_LIFESTATE_CHANGED, GameObject*, Effect::LifeState, Effect::LifeState>
+		MessageType_GameObjectLifeStateChanged;
+    
+    typedef MessageType<RLMSG_SAVEGAME_GOS_LOADED> MessageType_GameObjectsLoaded;
+    
+    typedef MessageType<RLMSG_PLAYERCHAR_DIED, Creature*>
+        MessageType_PlayerCharDied;
+
+    typedef MessageType<RLMSG_PLAYERCHAR_ADDED, Creature*>
+        MessageType_PlayerCharAdded;
+
+    typedef MessageType<RLMSG_PLAYERCHAR_REMOVED, Creature*>
+        MessageType_PlayerCharRemoved;
+
+    typedef MessageType<RLMSG_PLAYERCHAR_ACTIVE_CHANGED, Creature*, Creature*>
+        MessageType_ActivePlayerCharChanged;
+
+    typedef MessageType<RLMSG_PLAYERCHAR_ALL_DIED>
+        MessageType_AllPlayerCharsDied;
+
+}
+#endif

Modified: rl/branches/newton20/engine/rules/include/RulesSubsystem.h
===================================================================
--- rl/branches/newton20/engine/rules/include/RulesSubsystem.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/include/RulesSubsystem.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -31,6 +31,7 @@
 	class GameEventLog;
     class GlobalProperties;
 	class QuestBook;
+    class PartyManager;
     class XdimlLoader;
 
 	class _RlRulesExport RulesSubsystem : public Ogre::Singleton<RulesSubsystem>
@@ -52,6 +53,7 @@
         XdimlLoader* mXdimlLoader;
         GlobalProperties* mGlobalProperties;
         EffectManagementTask* mEffectManagementTask;
+        PartyManager* mPartyManager;
     };
 }
 

Modified: rl/branches/newton20/engine/rules/src/Creature.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Creature.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/src/Creature.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1066,10 +1066,10 @@
         {
             mErschoepfung = value.toInt();
         }
-        //else if (key == Creature::PROPERTY_EFFECTS)
-        //{
-        //    mEffectManager->setProperty(Creature::PROPERTY_EFFECTS, value);
-        //}
+        else if (key == Creature::PROPERTY_EFFECTS)
+        {
+            mEffectManager->setProperty(Creature::PROPERTY_EFFECTS, value);
+        }
         else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
         {
             mEigenschaften.clear();
@@ -1161,10 +1161,10 @@
         {
             return Property(mErschoepfung);
         }
-        //else if (key == Creature::PROPERTY_EFFECTS)
-        //{
-        //    return Property(mEffectManager->getProperty(Creature::PROPERTY_EFFECTS));
-        //}
+        else if (key == Creature::PROPERTY_EFFECTS)
+        {
+            return mEffectManager->getProperty(Creature::PROPERTY_EFFECTS);
+        }
         else if (key == Creature::PROPERTY_EIGENSCHAFTEN)
         {
             PropertyMap map = rl::convertToPropertyMap(mEigenschaften);
@@ -1237,7 +1237,7 @@
         keys.insert(Creature::PROPERTY_CURRENT_AE);
         keys.insert(Creature::PROPERTY_CURRENT_AU);
         keys.insert(Creature::PROPERTY_CURRENT_FATIGUE);
-        //keys.insert(Creature::PROPERTY_EFFECTS);
+        keys.insert(Creature::PROPERTY_EFFECTS);
         keys.insert(Creature::PROPERTY_EIGENSCHAFTEN);
         keys.insert(Creature::PROPERTY_TALENTE);
         keys.insert(Creature::PROPERTY_KAMPFTECHNIKEN);

Modified: rl/branches/newton20/engine/rules/src/Effect.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Effect.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/src/Effect.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,132 +1,172 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "Effect.h"
-#include "DsaManager.h"
-
-namespace rl
-{
-
-	Effect::Effect(int stufe)
-	{
-		mStufe = stufe;
-		mQuantifier = QUANTIFIER_MULTIPLE;
-	}
-
-	const CeGuiString Effect::getName() const
-	{
-		return mName;
-	}
-
-	void Effect::setName(CeGuiString name)
-	{
-		mName = name;
-	}
-
-	const CeGuiString Effect::getDescription() const
-	{
-		return mDescription;
-	}
-
-	void Effect::setDescription(CeGuiString description)
-	{
-		mDescription = description;
-	}
-
-    Effect::Quantifier Effect::getQuantifier()
-	{
-		return mQuantifier;
-	}
-
-	void Effect::setQuantifier(Quantifier quantifier)
-	{
-		mQuantifier = quantifier;
-	}
-
-
-	const int Effect::getStufe()
-	{
-		return mStufe;
-	}
-
-	void Effect::increaseStufe()
-	{
-	}
-
-	void Effect::decreaseStufe()
-	{
-	}
-
-	void Effect::enable()
-	{
-		if (!mEnabled)
-		{
-			mEnabled = true;
-		}
-	}
-
-	void Effect::disable()
-	{
-		if (mEnabled)
-		{
-			mEnabled = false;
-		}
-	}
-
-    RL_LONGLONG Effect::timeCheck()
-    {
-      return PERMANENT;
-    }
-
-	Effect::LifeState Effect::getLifeState() const
-    {
-      // should be overlaoaded in the specific derivated effects.
-      return LS_NONE;
-    }
-
-    int Effect::getMod(CeGuiString target, ModType type, ModTag tag)
-    {
-        return 0;
-    }
-
-    const Property Effect::getProperty(const CeGuiString& key) const
-    {
-        //else
-        //{
-            Throw(
-                IllegalArgumentException, 
-                key + " is not a property of this effect (" + mName + ")");
-        //}
-    }
-
-    void Effect::setProperty(const CeGuiString& key, const Property& value)
-    {
-        // else
-        //{
-            LOG_WARNING(
-                Logger::RULES,
-                key + " is not a property of this Effect ("+mName+")");
-        //}
-    }
-
-    PropertyKeys Effect::getAllPropertyKeys() const
-    {
-        PropertyKeys keys;
-        return keys;
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include "Effect.h"
+#include "DsaManager.h"
+
+namespace rl
+{
+    const Ogre::String Effect::PROPERTY_NAME = "name";
+    const Ogre::String Effect::PROPERTY_STUFE = "stufe";
+    const Ogre::String Effect::PROPERTY_ENABLED = "enabled";    
+
+	Effect::Effect(int stufe)
+	{
+		mStufe = stufe;
+		mQuantifier = QUANTIFIER_MULTIPLE;
+	}
+
+	const Ogre::String Effect::getName() const
+	{
+		return mName;
+	}
+
+	void Effect::setName(Ogre::String name)
+	{
+		mName = name;
+	}
+
+	const CeGuiString Effect::getDescription() const
+	{
+		return mDescription;
+	}
+
+	void Effect::setDescription(CeGuiString description)
+	{
+		mDescription = description;
+	}
+
+    Effect::Quantifier Effect::getQuantifier()
+	{
+		return mQuantifier;
+	}
+
+	void Effect::setQuantifier(Quantifier quantifier)
+	{
+		mQuantifier = quantifier;
+	}
+
+
+	const int Effect::getStufe()
+	{
+		return mStufe;
+	}
+
+	void Effect::increaseStufe()
+	{
+	}
+
+	void Effect::decreaseStufe()
+	{
+	}
+
+	void Effect::enable()
+	{
+		if (!mEnabled)
+		{
+			mEnabled = true;
+		}
+	}
+
+	void Effect::disable()
+	{
+		if (mEnabled)
+		{
+			mEnabled = false;
+		}
+	}
+
+    RL_LONGLONG Effect::timeCheck()
+    {
+        return PERMANENT;
+    }
+
+	Effect::LifeState Effect::getLifeState() const
+    {
+        // should be overlaoaded in the specific derivated effects.
+        return LS_NONE;
+    }
+
+    int Effect::getMod(CeGuiString target, ModType type, ModTag tag)
+    {
+        return 0;
+    }
+
+    const Property Effect::getProperty(const CeGuiString& key) const
+    {
+        Property prop;
+        if (key == Effect::PROPERTY_NAME)
+        {
+            prop.setValue(mName);
+        }
+        else if (key == Effect::PROPERTY_STUFE)
+        {
+            prop.setValue(mStufe);
+        }
+        else if (key == Effect::PROPERTY_ENABLED)
+        {
+            prop.setValue(mEnabled);
+        }
+        else
+        {
+            Throw(
+                IllegalArgumentException, 
+                key + " is not a property of this effect (" + mName + ")");
+        }
+        return prop;
+    }
+
+    void Effect::setProperty(const CeGuiString& key, const Property& value)
+    {
+        try
+        {
+            if (key == Effect::PROPERTY_NAME)
+            {
+                mName = value.toString().c_str();
+            }
+            else if (key == Effect::PROPERTY_STUFE)
+            {
+                mStufe = value.toInt();
+            }
+            else if (key == Effect::PROPERTY_ENABLED)
+            {
+                mEnabled = value.toBool();
+            }
+            else
+            {
+                LOG_WARNING(
+                    Logger::RULES,
+                    key + " is not a property of this Effect (" + mName + ")");
+            }
+        }
+        catch (WrongFormatException ex)
+        {
+            LOG_ERROR(
+                Logger::RULES,
+                "property " + key + " has the wrong format: " + ex.getMessage());
+        }
+    }
+
+    PropertyKeys Effect::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        keys.insert(Effect::PROPERTY_NAME);
+        keys.insert(Effect::PROPERTY_STUFE);
+        return keys;
+    }
+
+}

Modified: rl/branches/newton20/engine/rules/src/EffectManager.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/EffectManager.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/src/EffectManager.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,210 +1,328 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "EffectManager.h"
-
-#include <sstream>
-
-#include "CoreSubsystem.h"
-#include "DsaManager.h"
-#include "Exception.h"
-#include "MessagePump.h"
-#include "RulesMessages.h"
-#include "ScriptWrapper.h"
-
-namespace rl
-{
-	EffectManager::EffectManager(GameObject* gameobject)
-        : mGameObject(gameobject),
-        mCheckEffectsRunning(false)
-	{
-	}
-
-	EffectManager::~EffectManager()
-	{
-		for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-		{
-			//delete (*it);
-            ScriptWrapper::getSingleton().disowned(*it);
-		}
-	}
-
-	void EffectManager::checkEffects()
-	{
-            if( mCheckEffectsRunning )
-                return;
-            mCheckEffectsRunning = true;
-        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
-        Checklist::iterator checkIt = mChecklist.begin();
-        if (checkIt == mChecklist.end()) return;
-        while ( checkIt != mChecklist.end() && checkIt->first <= now )
-        {
-				std::stringstream debugInfo;
-				debugInfo << "Effect check: " << checkIt->first << " now: " << now << std::endl;
-                LOG_DEBUG(Logger::RULES,
-					debugInfo.str());
-            for (Effects::iterator effIt = checkIt->second.begin(); effIt != checkIt->second.end(); effIt++)
-            {
-                int nextCheck;
-                nextCheck = (*effIt)->timeCheck();
-                switch (nextCheck)
-                {
-                  case Effect::REMOVE:
-                    removeEffect(*effIt);
-                    break;
-                  case Effect::PERMANENT:
-                    break;
-                  default:
-                    addTimeCheck(nextCheck, *effIt);
-                }
-            }
-            mChecklist.erase(checkIt++);
-        }
-
-        mCheckEffectsRunning = false;
-	}
-
-    void EffectManager::addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect)
-    {
-        // Preconditions: time > 0, effect != NULL
-        if (time <= 0) Throw(IllegalArgumentException, "time parameter is <= 0!");
-        if (effect == NULL) Throw(IllegalArgumentException, "effect pointer is NULL!");
-        // Get current ingame time and add timeUntilCheck
-        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
-        RL_LONGLONG timeForCheck = now + timeUntilCheck;
-				std::stringstream debugInfo;
-				debugInfo << "Adding check! now:" << now << " check: " << timeForCheck << std::endl;
-                LOG_DEBUG(Logger::RULES,
-					debugInfo.str());
-        // Insert Sum and effect into the checklist
-        mChecklist[timeForCheck].insert(effect);
-    }
-
-    void EffectManager::addDateCheck(RL_LONGLONG date, Effect* effect)
-    {
-        // Preconditions: date > now, effect != NULL
-        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
-        if (date <= now) Throw(IllegalArgumentException, "date lies in the past!");
-        if (effect == NULL) Throw(IllegalArgumentException, "effect pointer is NULL!");
-        // Insert date and effect into the checklist
-				std::stringstream debugInfo;
-				debugInfo << "Adding check! now:" << now << " check: " << date << std::endl;
-                LOG_DEBUG(Logger::RULES,
-					debugInfo.str());
-        mChecklist[date].insert(effect);
-    }
-
-
-	void EffectManager::addEffect(Effect* effect)
-	{
-        Effect::LifeState oldState = getLifeState();
-
-        LOG_DEBUG(Logger::RULES, "Adding effect " + effect->getName());
-		for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-		{
-			if ((*it)->getName() == effect->getName())
-			{
-				if ((*it)->getQuantifier() == Effect::QUANTIFIER_UNIQUE) return;
-				if ((*it)->getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_PROLONGABLE)
-				{
-					//TODO
-					//Vielleicht alten durch neuen ersetzen?
-					//oder (*it)->setDuration(effect->getDuration())
-				}
-				if ((*it)->getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_CUMULATIVE)
-				{
-					for (int i = 0; i < effect->getStufe(); i++)
-						(*it)->increaseStufe();
-				}
-			}
-		}
-        ScriptWrapper::getSingleton().owned(effect);
-		mEffects.insert(effect);
-		effect->enable();
-
-        checkStateChange(oldState);
-	}
-
-    void EffectManager::removeEffect(Effect* effect)
-    {
-        Effect::LifeState oldState = getLifeState();
-    
-        effect->disable();
-        mEffects.erase(effect);
-        ScriptWrapper::getSingleton().disowned(effect);
-        ///@todo also remove from the check lists?
-
-        checkStateChange(oldState);
-    }
-
-    void EffectManager::removeEffect(CeGuiString name)
-    {
-		for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-		{
-            if ((*it)->getName() == name)
-            {
-                removeEffect(*it);
-                return;
-            }
-        }
-    }
-
-    Effect::LifeState EffectManager::getLifeState()
-    {
-        checkEffects();
-        Effect::LifeState status = 0;
-        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-        {
-            status = status | ((*it)->getLifeState());
-        }
-        return status;
-    }
-
-    void EffectManager::checkStateChange(Effect::LifeState oldState)
-    {
-        Effect::LifeState currentState = getLifeState();
-        if (currentState != oldState)
-        {
-			MessagePump::getSingleton().sendMessage<MessageType_GameObjectLifeStateChanged>(mGameObject,
-				oldState, currentState);
-        }
-    }
-
-    int EffectManager::getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag)
-    {
-      checkEffects();
-      int mod = 0;
-	  if (type == Effect::MODTYPE_MULT) mod = 1;
-      for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-      {
-        mod += (*it)->getMod(target, type, tag);
-      }
-      return mod;
-    }
-
-    CeGuiString EffectManager::getEffects()
-    {
-        CeGuiString retVal = "";
-        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
-        {
-            retVal += (*it)->getName() + "\n";
-            retVal += (*it)->getDescription() + "\n";
-        }
-        return retVal;
-    }
-}
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include "EffectManager.h"
+
+#include <sstream>
+
+#include "CoreSubsystem.h"
+#include "Creature.h"
+#include "DsaManager.h"
+#include "EffectFactory.h"
+#include "Exception.h"
+#include "MessagePump.h"
+#include "RulesMessages.h"
+#include "ScriptWrapper.h"
+
+namespace rl
+{
+    const Ogre::String EffectManager::PROPERTY_TIMECHECK = "timechecks";
+    const Ogre::String EffectManager::PROPERTY_TIME = "time";
+    const Ogre::String EffectManager::PROPERTY_EFFECT = "effect";
+
+    EffectManager::EffectManager(GameObject* gameobject)
+        : mGameObject(gameobject),
+        mCheckEffectsRunning(false)
+    {
+    }
+
+    EffectManager::~EffectManager()
+    {
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            //delete (*it);
+            ScriptWrapper::getSingleton().disowned(*it);
+        }
+    }
+
+    void EffectManager::checkEffects()
+    {
+        if( mCheckEffectsRunning ) {
+                return;
+        }
+        mCheckEffectsRunning = true;
+        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
+        Checklist::iterator checkIt = mChecklist.begin();
+        if (checkIt == mChecklist.end()) return;
+        while ( checkIt != mChecklist.end() && checkIt->first <= now )
+        {
+                std::stringstream debugInfo;
+                debugInfo << "Effect check: " << checkIt->first << " now: " << now << std::endl;
+                LOG_DEBUG(Logger::RULES,
+                    debugInfo.str());
+            for (Effects::iterator effIt = checkIt->second.begin(); effIt != checkIt->second.end(); effIt++)
+            {
+                int nextCheck;
+                nextCheck = (*effIt)->timeCheck();
+                switch (nextCheck)
+                {
+                  case Effect::REMOVE:
+                    removeEffect(*effIt);
+                    break;
+                  case Effect::PERMANENT:
+                    break;
+                  default:
+                    addTimeCheck(nextCheck, *effIt);
+                }
+            }
+            mChecklist.erase(checkIt++);
+        }
+
+        mCheckEffectsRunning = false;
+    }
+
+    void EffectManager::addTimeCheck(RL_LONGLONG timeUntilCheck, Effect* effect)
+    {
+        // Preconditions: time > 0, effect != NULL
+        if (time <= 0) Throw(IllegalArgumentException, "time parameter is <= 0!");
+        if (effect == NULL) Throw(IllegalArgumentException, "effect pointer is NULL!");
+        // Get current ingame time and add timeUntilCheck
+        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
+        RL_LONGLONG timeForCheck = now + timeUntilCheck;
+        std::stringstream debugInfo;
+        debugInfo << "Adding check! now:" << now << " check: " << timeForCheck << std::endl;
+        LOG_DEBUG(Logger::RULES,
+            debugInfo.str());
+        // Insert Sum and effect into the checklist
+        mChecklist[timeForCheck].push_back(effect);
+    }
+
+    void EffectManager::addDateCheck(RL_LONGLONG date, Effect* effect)
+    {
+        // Preconditions: date > now, effect != NULL
+        RL_LONGLONG now = DsaManager::getSingleton().getTimestamp();
+        if (date <= now) 
+        {
+            Throw(IllegalArgumentException, "date lies in the past!");
+        }
+        if (effect == NULL) 
+        {
+            Throw(IllegalArgumentException, "effect pointer is NULL!");
+        }
+        // Insert date and effect into the checklist
+        std::stringstream debugInfo;
+        debugInfo << "Adding check! now:" << now << " check: " << date << std::endl;
+        LOG_DEBUG(Logger::RULES, debugInfo.str());
+        mChecklist[date].push_back(effect);
+    }
+
+
+    void EffectManager::addEffect(Effect* effect)
+    {
+        Effect::LifeState oldState = getLifeState();
+
+        LOG_DEBUG(Logger::RULES, "Adding effect " + effect->getName());
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            Effect* cur = *it;
+            if (cur->getName() == effect->getName())
+            {
+                if (cur->getQuantifier() == Effect::QUANTIFIER_UNIQUE) 
+                {
+                    return;
+                }
+                else if (cur->getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_PROLONGABLE)
+                {
+                    //TODO
+                    //Vielleicht alten durch neuen ersetzen?
+                    //oder (*it)->setDuration(effect->getDuration())
+                }
+                else if (cur->getQuantifier() == Effect::QUANTIFIER_UNIQUE_BUT_CUMULATIVE)
+                {
+                    for (int i = 0; i < effect->getStufe(); i++)
+                    {
+                        cur->increaseStufe();
+                    }
+                }
+            }
+        }
+        ScriptWrapper::getSingleton().owned(effect);
+        mEffects.push_back(effect);
+        effect->enable();
+
+        checkStateChange(oldState);
+    }
+
+    void EffectManager::removeEffect(Effect* effect)
+    {
+        Effect::LifeState oldState = getLifeState();
+    
+        effect->disable();
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); ++it)
+        {
+            if (*it == effect)
+            {
+                mEffects.erase(it);
+                break;
+            }
+        }
+        ScriptWrapper::getSingleton().disowned(effect);
+        ///@todo also remove from the check lists?
+
+        checkStateChange(oldState);
+    }
+
+    void EffectManager::removeEffect(CeGuiString name)
+    {
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            if ((*it)->getName() == name)
+            {
+                removeEffect(*it);
+                return;
+            }
+        }
+    }
+
+    Effect::LifeState EffectManager::getLifeState()
+    {
+        checkEffects();
+        Effect::LifeState status = 0;
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            status = status | ((*it)->getLifeState());
+        }
+        return status;
+    }
+
+    void EffectManager::checkStateChange(Effect::LifeState oldState)
+    {
+        Effect::LifeState currentState = getLifeState();
+        if (currentState != oldState)
+        {
+            MessagePump::getSingleton().sendMessage<MessageType_GameObjectLifeStateChanged>(mGameObject,
+                oldState, currentState);
+        }
+    }
+
+    int EffectManager::getMod(CeGuiString target, Effect::ModType type, Effect::ModTag tag)
+    {
+        checkEffects();
+        int mod = 0;
+        if (type == Effect::MODTYPE_MULT) mod = 1;
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            mod += (*it)->getMod(target, type, tag);
+        }
+        return mod;
+    }
+
+    CeGuiString EffectManager::getEffects()
+    {
+        CeGuiString retVal = "";
+        for (Effects::iterator it = mEffects.begin(); it != mEffects.end(); it++)
+        {
+            retVal += (*it)->getName() + "\n";
+            retVal += (*it)->getDescription() + "\n";
+        }
+        return retVal;
+    }
+
+    const Property EffectManager::getProperty(const CeGuiString& key) const
+    {
+        Property rval;
+        if (key == Creature::PROPERTY_EFFECTS)
+        {
+            PropertyMap map;
+            
+            std::map<Effect*, int> effectIds;
+            PropertyArray effectProps;
+            for (int i = 0, size = mEffects.size(); i < size; ++i)
+            {
+                Effect* cur = mEffects[i];
+                effectProps.push_back(cur->getAllProperties()->toPropertyMap());
+                effectIds[cur] = i;
+            }
+            
+            PropertyArray timeCheck;
+            for (std::map<RL_LONGLONG, Effects>::const_iterator itTc = mChecklist.begin(); 
+                itTc != mChecklist.end(); ++itTc)
+            {
+                for (Effects::const_iterator itEff = itTc->second.begin(); 
+                    itEff != itTc->second.end(); ++itEff)
+                {
+                    PropertyMap tcElem;
+                    tcElem[EffectManager::PROPERTY_EFFECT] = effectIds[*itEff];
+                    tcElem[EffectManager::PROPERTY_TIME] = itTc->first;
+                    timeCheck.push_back(tcElem);
+                }
+            }
+            
+            map[Creature::PROPERTY_EFFECTS] = effectProps;
+            map[EffectManager::PROPERTY_TIMECHECK] = timeCheck;
+            rval.setValue(map);
+        }
+        else 
+        {
+            Throw(IllegalArgumentException, key + " is not a property of EffectManager.");
+        }
+        return rval;
+    }
+    
+    void EffectManager::setProperty(const CeGuiString& key, const Property& value)
+    {
+        try
+        {
+            if (key == Creature::PROPERTY_EFFECTS)
+            {
+                PropertyMap map = value.toMap();
+                
+                std::vector<Effect*> effectIds;
+                
+                PropertyArray arr = map[Creature::PROPERTY_EFFECTS].toArray();
+                for (int i = 0, size = arr.size(); i < size; ++i)
+                {
+                    PropertyMap cur = arr[i].toMap();
+                    Ogre::String name = cur[Effect::PROPERTY_NAME].toString().c_str();
+                    int stufe = cur[Effect::PROPERTY_STUFE];
+                    Effect* eff = EffectFactoryManager::getSingleton().createEffect(name, stufe);
+                    eff->setProperties(cur);
+                    mEffects.push_back(eff);
+                    ///@TODO: activate effects?
+                }
+                
+                PropertyArray timeCheckProp = map[EffectManager::PROPERTY_TIMECHECK].toArray();
+                for (int i = 0, size = timeCheckProp.size(); i < size; ++i)
+                {
+                    PropertyMap cur = timeCheckProp[i].toMap();
+                    RL_LONGLONG time = cur[EffectManager::PROPERTY_TIME].toLong();
+                    Effect* eff = mEffects[cur[EffectManager::PROPERTY_EFFECT].toInt()];
+                    mChecklist[time].push_back(eff);
+                }
+            }
+            else
+            {
+                LOG_WARNING(Logger::RULES, 
+                    key + " is not a property of EffectManager");
+            }
+        }
+        catch (WrongFormatException ex)
+        {
+            LOG_ERROR(Logger::RULES, 
+                "property " + key + " has the wrong format");
+        }
+    }
+
+    PropertyKeys EffectManager::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        keys.insert(Creature::PROPERTY_EFFECTS);
+        return keys;
+    }
+
+}
+

Modified: rl/branches/newton20/engine/rules/src/GameObjectManager.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/GameObjectManager.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/src/GameObjectManager.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -47,12 +47,10 @@
 
         mScriptPatterns.push_back("*.gof");
         Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
-        SaveGameManager::getSingleton().registerSaveGameData(this);
     }
 
     GameObjectManager::~GameObjectManager()
     {
-        SaveGameManager::getSingleton().unregisterSaveGameData(this);
         unregisterAllGameObjectStateListener();
         deleteAllGameObjects();
     }
@@ -293,90 +291,6 @@
         return createRubyGameObject(classname, id);
     }
 
-    CeGuiString GameObjectManager::getXmlNodeIdentifier() const
-    {
-        return "gameobjects";
-    }
-
-    using namespace XERCES_CPP_NAMESPACE;
-    
-    void GameObjectManager::writeData(SaveGameFileWriter *writer)
-    {
-        LOG_MESSAGE(Logger::RULES, "Saving Game Objects");
-        DOMElement* gameobjects = writer->appendChildElement(writer->getDocument(), writer->getDocument()->getDocumentElement(), getXmlNodeIdentifier().c_str());
-
-        std::list<GameObject*> gos = getAllGameObjects();
-
-		for(std::list<GameObject*>::const_iterator it_gameobjects = gos.begin(); it_gameobjects != gos.end(); it_gameobjects++)
-        {
-            DOMElement* gameobject = writer->appendChildElement(writer->getDocument(), gameobjects, "gameobject");
-            writer->setAttributeValueAsInteger(gameobject, "ID", (*it_gameobjects)->getId());
-            writer->setAttributeValueAsString(gameobject, "ClassID", (*it_gameobjects)->getClassId());
-            writer->setAttributeValueAsInteger(gameobject, "State", (int)(*it_gameobjects)->getState());
-            writer->setAttributeValueAsInteger(gameobject, "QueryFlags", (int)(*it_gameobjects)->getQueryFlags());
-
-            PropertyMap actualMap = (*it_gameobjects)->getAllProperties()->toPropertyMap();
-
-            writer->writeEachPropertyToElem(gameobject, (*it_gameobjects)->getAllProperties()->getDifference(getClassProperties((*it_gameobjects)->getClassId()))->toPropertyMap());
-            //writer->writeEachPropertyToElem(gameobject, getPropertyMapDifference(actualMap, getClassProperties((*it_gameobjects)->getClassId())->toPropertyMap()));
-        } 
-    }
-
-    void GameObjectManager::readData(SaveGameFileReader *reader)
-    {
-        deleteAllGameObjects();
-
-        reader->initializeXml();
-
-        DOMNodeList* rootNodeList = reader->getDocument()->getDocumentElement()->getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
-
-        if(rootNodeList->getLength())
-        {
-            DOMNodeList* xmlGameObjects = static_cast<DOMElement*>(rootNodeList->item(0))->getElementsByTagName(AutoXMLCh("gameobject").data()); //there should be only one "gameobjects" node
-            if(xmlGameObjects->getLength())
-            {
-                for(XMLSize_t childIdx = 0; childIdx < xmlGameObjects->getLength(); childIdx++)
-                {
-                    DOMNode* xmlGameObject = xmlGameObjects->item(childIdx);
-                    if(xmlGameObject->getNodeType() == DOMNode::ELEMENT_NODE)
-                    {
-                        int ID = reader->getAttributeValueAsInteger(static_cast<DOMElement*>(xmlGameObject), "ID");
-                        Ogre::String classID = reader->getAttributeValueAsStdString(static_cast<DOMElement*>(xmlGameObject), "ClassID");
-                        GameObjectState state = (GameObjectState)reader->getAttributeValueAsInteger(static_cast<DOMElement*>(xmlGameObject), "State");
-                        int flags = reader->getAttributeValueAsInteger(static_cast<DOMElement*>(xmlGameObject), "QueryFlags");
-                        PropertyRecordPtr properties = reader->getPropertiesAsRecord(static_cast<DOMElement*>(xmlGameObject));
-
-                        GameObject* object = NULL;
-                        if(getGameObject(ID) == NULL)
-                            object = createGameObject(classID, ID);
-                        else
-                            object = getGameObject(ID);
-                        
-                        applyProperties(object, properties);
-                        // Placing the actor a a little bit higher in the scene. The actor will fall onto ground.
-                        // Avoiding problems with the physics, because the character the creature is transfixed to ground
-                        if(state == GOS_IN_SCENE)
-                        {
-                            object->setProperty(GameObject::PROPERTY_POSITION, 
-	                            Property(object->getProperty(GameObject::PROPERTY_POSITION).toVector3() + Ogre::Vector3(0.0f,0.01f,0.0f)));
-                        }
-                        object->setState(state);
-                        object->setQueryFlags(flags);
-                    }
-                }
-            }
-        } 
-
-        MessagePump::getSingleton().sendMessage<MessageType_GameObjectsLoaded>();
-
-        reader->shutdownXml();
-    }
-
-    int GameObjectManager::getPriority() const
-    {
-        return 100;
-    }
-
     PropertyMap GameObjectManager::getPropertyMapDifference(PropertyMap map1, PropertyMap map2)
     {
         PropertyRecord pr;

Modified: rl/branches/newton20/engine/rules/src/Makefile.am
===================================================================
--- rl/branches/newton20/engine/rules/src/Makefile.am	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/src/Makefile.am	2008-09-19 08:22:31 UTC (rev 4519)
@@ -37,6 +37,7 @@
 	ObjectStateChangeEvent.cpp \
 	ObjectStateChangeEventSource.cpp \
 	ObjectStateChangeListener.cpp \
+	PartyManager.cpp \
 	Quest.cpp \
 	QuestBook.cpp \
 	QuestEvent.cpp \

Copied: rl/branches/newton20/engine/rules/src/PartyManager.cpp (from rev 4518, rl/trunk/engine/rules/src/PartyManager.cpp)

Modified: rl/branches/newton20/engine/rules/src/RulesSubsystem.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/RulesSubsystem.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/rules/src/RulesSubsystem.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,116 +1,125 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "RulesSubsystem.h"
-#include "ActionManager.h"
-#include "CombatManager.h"
-#include "DsaManager.h"
-#include "DsaDataLoader.h"
-#include "EffectFactory.h"
-#include "EffectManagementTask.h"
-#include "GameEventLog.h"
-#include "GameLoop.h"
-#include "Logger.h"
-#include "CreatureControllerManager.h"
-#include "GameObjectManager.h"
-#include "QuestBook.h"
-#include "GameTimeSource.h"
-#include "GlobalProperties.h"
-#include <ConfigurationManager.h>
-
-template <>
-rl::RulesSubsystem* Singleton<rl::RulesSubsystem>::ms_Singleton = 0;
-namespace rl
-{
-    RulesSubsystem::RulesSubsystem()
-		: mQuestBook(NULL),
-        mActionManager(NULL),
-        mCombatManager(NULL),
-        mDsaManager(NULL),
-		mGameEventLog(NULL),
-        mMovingCreatureManager(NULL),
-        mXdimlLoader(NULL),
-        mGlobalProperties(NULL),
-        mEffectManagementTask(NULL)
-    {
-		LOG_MESSAGE(Logger::RULES, "Start");
-        //Zufallsgenerator initialisieren
-        srand(static_cast<unsigned int>(time(NULL)));
-
-        TimeSourceManager::getSingleton().registerTimeSource(
-            new GameTimeSource());
-
-        //Singletons erzeugen
-        mActionManager = new ActionManager();
-		LOG_MESSAGE(Logger::RULES, "ActionManager erzeugt");
-        mCombatManager = new CombatManager();
-		LOG_MESSAGE(Logger::RULES, "CombatManager erzeugt");
-        mDsaManager = new DsaManager();
-		LOG_MESSAGE(Logger::RULES, "DsaManager erzeugt");
-        mGameEventLog = new GameEventLog();
-		LOG_MESSAGE(Logger::RULES, "GameEventLog erzeugt");
-        mMovingCreatureManager = new CreatureControllerManager();
-		LOG_MESSAGE(Logger::RULES, "CreatureControllerManager erzeugt");
-		resetQuestBook();
-		LOG_MESSAGE(Logger::RULES, "Questverwaltung erzeugt");
-        mGlobalProperties = new GlobalProperties();
-
-        mEffectManagementTask = new EffectManagementTask();
-        GameLoop::getSingleton().addTask(
-            mEffectManagementTask, GameLoop::TG_LOGIC);
-
-		//Daten laden
-		mXdimlLoader = new XdimlLoader();
-		LOG_MESSAGE(Logger::RULES, "Basisdaten geladen");
-
-        new EffectFactoryManager();
-        new GameObjectManager();
-		LOG_MESSAGE(Logger::RULES, "Erzeugen abgeschlossen");
-    }
-
-	RulesSubsystem::~RulesSubsystem()
-    {
-        GameLoop::getSingleton().removeTask(mEffectManagementTask);
-        delete mEffectManagementTask;
-        delete mGlobalProperties;
-        if(mQuestBook)
-            Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(mQuestBook);
-        delete mQuestBook;
-		delete mGameEventLog;
-        delete mDsaManager;
-        delete mCombatManager;
-        delete mActionManager;
-        delete mXdimlLoader;
-        delete GameObjectManager::getSingletonPtr();
-        delete mMovingCreatureManager; // this manager should be deleted after the GameObjectManager
-        delete EffectFactoryManager::getSingletonPtr();
-    }
-
-	QuestBook* RulesSubsystem::getQuestBook()
-	{
-		return mQuestBook;
-	}
-
-	void RulesSubsystem::resetQuestBook()
-	{
-        if(mQuestBook)
-            Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(mQuestBook);
-		delete mQuestBook;
-		mQuestBook = new QuestBook();
-        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(mQuestBook);
-	}
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include "RulesSubsystem.h"
+
+#include "ActionManager.h"
+#include "CombatManager.h"
+#include "ConfigurationManager.h"
+#include "CreatureControllerManager.h"
+#include "DsaManager.h"
+#include "DsaDataLoader.h"
+#include "EffectFactory.h"
+#include "EffectManagementTask.h"
+#include "GameEventLog.h"
+#include "GameLoop.h"
+#include "GameObjectManager.h"
+#include "GameTimeSource.h"
+#include "GlobalProperties.h"
+#include "Logger.h"
+#include "PartyManager.h"
+#include "QuestBook.h"
+
+template <>
+rl::RulesSubsystem* Singleton<rl::RulesSubsystem>::ms_Singleton = 0;
+namespace rl
+{
+    RulesSubsystem::RulesSubsystem()
+		: mQuestBook(NULL),
+        mActionManager(NULL),
+        mCombatManager(NULL),
+        mDsaManager(NULL),
+		mGameEventLog(NULL),
+        mMovingCreatureManager(NULL),
+        mXdimlLoader(NULL),
+        mGlobalProperties(NULL),
+        mEffectManagementTask(NULL)
+    {
+		LOG_MESSAGE(Logger::RULES, "Start");
+        //Zufallsgenerator initialisieren
+        srand(static_cast<unsigned int>(time(NULL)));
+
+        TimeSourceManager::getSingleton().registerTimeSource(
+            new GameTimeSource());
+
+        //Singletons erzeugen
+        mActionManager = new ActionManager();
+		LOG_MESSAGE(Logger::RULES, "ActionManager erzeugt");
+        mCombatManager = new CombatManager();
+		LOG_MESSAGE(Logger::RULES, "CombatManager erzeugt");
+        mDsaManager = new DsaManager();
+		LOG_MESSAGE(Logger::RULES, "DsaManager erzeugt");
+        mGameEventLog = new GameEventLog();
+		LOG_MESSAGE(Logger::RULES, "GameEventLog erzeugt");
+        mMovingCreatureManager = new CreatureControllerManager();
+		LOG_MESSAGE(Logger::RULES, "CreatureControllerManager erzeugt");
+		resetQuestBook();
+		LOG_MESSAGE(Logger::RULES, "Questverwaltung erzeugt");
+        mGlobalProperties = new GlobalProperties();
+
+        mEffectManagementTask = new EffectManagementTask();
+        GameLoop::getSingleton().addTask(
+            mEffectManagementTask, GameLoop::TG_LOGIC);
+
+		//Daten laden
+		mXdimlLoader = new XdimlLoader();
+		LOG_MESSAGE(Logger::RULES, "Basisdaten geladen");
+
+        new EffectFactoryManager();
+        new GameObjectManager();
+        
+        mPartyManager = new PartyManager();
+		LOG_MESSAGE(Logger::RULES, "Erzeugen abgeschlossen");
+    }
+
+	RulesSubsystem::~RulesSubsystem()
+    {
+        delete mPartyManager;
+        GameLoop::getSingleton().removeTask(mEffectManagementTask);
+        delete mEffectManagementTask;
+        delete mGlobalProperties;
+        if (mQuestBook)
+        {
+            Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(mQuestBook);
+        }
+        delete mQuestBook;
+		delete mGameEventLog;
+        delete mDsaManager;
+        delete mCombatManager;
+        delete mActionManager;
+        delete mXdimlLoader;
+        delete GameObjectManager::getSingletonPtr();
+        delete mMovingCreatureManager; // this manager should be deleted after the GameObjectManager
+        delete EffectFactoryManager::getSingletonPtr();
+    }
+
+	QuestBook* RulesSubsystem::getQuestBook()
+	{
+		return mQuestBook;
+	}
+
+	void RulesSubsystem::resetQuestBook()
+	{
+        if (mQuestBook)
+        {
+            Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(mQuestBook);
+        }
+		delete mQuestBook;
+		mQuestBook = new QuestBook();
+        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(mQuestBook);
+	}
+}

Modified: rl/branches/newton20/engine/script/src/EnvironmentProcessor.cpp
===================================================================
--- rl/branches/newton20/engine/script/src/EnvironmentProcessor.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/script/src/EnvironmentProcessor.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -102,7 +102,7 @@
 	{
         if (fogElem)
         {
-		    if (!hasAttribute(fogElem, "material"))
+		    if (!hasAttribute(fogElem, "type"))
 		    {
 			    LOG_ERROR(
 				    Logger::RULES,

Modified: rl/branches/newton20/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/branches/newton20/engine/script/src/PlaneNodeProcessor.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/script/src/PlaneNodeProcessor.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -172,9 +172,9 @@
 		Camera* cam = CoreSubsystem::getSingleton().getWorld()->getSceneManager()->createCamera("Cam" + entity->getName());
 		cam->setNearClipDistance(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getNearClipDistance());
         cam->setFarClipDistance(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getFarClipDistance());
-		cam->setAutoAspectRatio(true);
+		//cam->setFarClipDistance(1000000);
+		cam->setAspectRatio(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getAspectRatio());
 		cam->setFOVy(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getFOVy());
-		cam->enableCustomNearClipPlane((MovablePlane*)plane);
 
 		AliasTextureNamePairList aliases;
 
@@ -190,6 +190,8 @@
 			rttTex->addListener(new PlaneReflectionTextureListener(entity, cam, plane));
 			
 			aliases["reflection"] = "Reflection" + entity->getName();
+
+			cam->enableCustomNearClipPlane((MovablePlane*)plane);
 		}
 		if(getAttributeValueAsBool(rttElem, "refraction"))
 		{
@@ -203,6 +205,9 @@
 			rttTex->addListener(new PlaneRefractionTextureListener(entity, cam));
 
 			aliases["refraction"] = "Refraction" + entity->getName();
+
+			plane->normal = Vector3::NEGATIVE_UNIT_Y;
+			cam->enableCustomNearClipPlane((MovablePlane*)plane);
 		}
 		if(!material->applyTextureAliases(aliases))
 			LOG_ERROR("PLANE", "Texture Aliase konnten nicht angewandt werden");
@@ -220,7 +225,7 @@
 		mCamera->setPosition(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getWorldPosition());
 		mCamera->setOrientation(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getWorldOrientation());
 		mEntity->setVisible(false);
-		mCamera->enableReflection(*mPlane);
+		mCamera->enableReflection((MovablePlane*)mPlane);
 	}
 
 	void PlaneReflectionTextureListener::postRenderTargetUpdate(const Ogre::RenderTargetEvent& evt)

Modified: rl/branches/newton20/engine/script/src/SceneManager.cpp
===================================================================
--- rl/branches/newton20/engine/script/src/SceneManager.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/script/src/SceneManager.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,124 +1,124 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#include "stdinc.h" //precompiled header
-
-#include "SceneManager.h"
-
-#include "Creature.h"
-#include "CreatureControllerManager.h"
-#include "Scene.h"
-#include "SceneLoader.h"
-#include "UiSubsystem.h"
-
-template<> rl::SceneManager* Ogre::Singleton<rl::SceneManager>::ms_Singleton = NULL;
-
-namespace rl 
-{
-
-    SceneManager::SceneManager()
-        : Ogre::Singleton<SceneManager>(),
-          Ogre::ScriptLoader(),
-          mCurrentScene(NULL)
-    {
-        mScriptPatterns.push_back("*.rlscene");
-        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
-    }
-
-    SceneManager::~SceneManager()
-    {
-        Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(this);
-        for (std::map<CeGuiString, Scene*>::iterator it = mScenes.begin();
-            it != mScenes.end(); ++it)
-        {
-            delete it->second;
-        }
-    }
-
-    void SceneManager::addScene(Scene* scene) 
-    {
-        mScenes[scene->getName()] = scene;
-    }
-
-    void SceneManager::loadScene(const CeGuiString& sceneName, bool saveCurrent)
-    {
-        if (mCurrentScene && sceneName == mCurrentScene->getName())
-        {
-            return;
-        }
-
-        Creature* activeChar = UiSubsystem::getSingleton().getActiveCharacter();
-
-        if (activeChar) {
-            CreatureControllerManager::getSingleton().detachController(
-                activeChar);
-            activeChar->setState(GOS_LOADED);
-        }
-
-        if (saveCurrent) 
-        {
-            mSceneStates[mCurrentScene] = mCurrentScene->getAllProperties();
-        }
-
-        std::map<CeGuiString, Scene*>::iterator itScene = mScenes.find(sceneName);
-        if (itScene != mScenes.end())
-        {            
-            std::map<Scene*, PropertyRecordPtr>::iterator itState =
-                mSceneStates.end();
-            if (saveCurrent) 
-            {
-                std::map<Scene*, PropertyRecordPtr>::iterator itState 
-                    = mSceneStates.find(mCurrentScene);
-            }
-
-            itScene->second->load(itState != mSceneStates.end()); // don't load game objects if there is a saved state
-            mCurrentScene = itScene->second;
-            
-            if (itState != mSceneStates.end())
-            {
-                mCurrentScene->setProperties(itState->second);
-            }
-        }
-        else
-        {
-            LOG_ERROR("SceneManager", 
-                "Scene '" + sceneName + "' not found. Have you forgotten to define it in a .rlscene file?");
-        }
-
-        if (activeChar) 
-        {
-            UiSubsystem::getSingleton().setActiveCharacter(activeChar);
-        }
-    }
-
-    const Ogre::StringVector& SceneManager::getScriptPatterns() const
-    {
-        return mScriptPatterns;
-    }
-
-    void SceneManager::parseScript(Ogre::DataStreamPtr& data, const Ogre::String& resourceGroup)
-    {
-        SceneLoader* loader = new SceneLoader();
-        addScene(loader->loadScene(data));
-        delete loader;
-    }
-
-    Ogre::Real SceneManager::getLoadingOrder() const
-    {
-        return 1000;
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "stdinc.h" //precompiled header
+
+#include "SceneManager.h"
+
+#include "Creature.h"
+#include "CreatureControllerManager.h"
+#include "PartyManager.h"
+#include "Scene.h"
+#include "SceneLoader.h"
+
+template<> rl::SceneManager* Ogre::Singleton<rl::SceneManager>::ms_Singleton = NULL;
+
+namespace rl 
+{
+
+    SceneManager::SceneManager()
+        : Ogre::Singleton<SceneManager>(),
+          Ogre::ScriptLoader(),
+          mCurrentScene(NULL)
+    {
+        mScriptPatterns.push_back("*.rlscene");
+        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
+    }
+
+    SceneManager::~SceneManager()
+    {
+        Ogre::ResourceGroupManager::getSingleton()._unregisterScriptLoader(this);
+        for (std::map<CeGuiString, Scene*>::iterator it = mScenes.begin();
+            it != mScenes.end(); ++it)
+        {
+            delete it->second;
+        }
+    }
+
+    void SceneManager::addScene(Scene* scene) 
+    {
+        mScenes[scene->getName()] = scene;
+    }
+
+    void SceneManager::loadScene(const CeGuiString& sceneName, bool saveCurrent)
+    {
+        if (mCurrentScene && sceneName == mCurrentScene->getName())
+        {
+            return;
+        }
+
+        Creature* activeChar = PartyManager::getSingleton().getActiveCharacter();
+
+        if (activeChar) {
+            CreatureControllerManager::getSingleton().detachController(
+                activeChar);
+            activeChar->setState(GOS_LOADED);
+        }
+
+        if (saveCurrent) 
+        {
+            mSceneStates[mCurrentScene] = mCurrentScene->getAllProperties();
+        }
+
+        std::map<CeGuiString, Scene*>::iterator itScene = mScenes.find(sceneName);
+        if (itScene != mScenes.end())
+        {            
+            std::map<Scene*, PropertyRecordPtr>::iterator itState =
+                mSceneStates.end();
+            if (saveCurrent) 
+            {
+                std::map<Scene*, PropertyRecordPtr>::iterator itState 
+                    = mSceneStates.find(mCurrentScene);
+            }
+
+            itScene->second->load(itState != mSceneStates.end()); // don't load game objects if there is a saved state
+            mCurrentScene = itScene->second;
+            
+            if (itState != mSceneStates.end())
+            {
+                mCurrentScene->setProperties(itState->second);
+            }
+        }
+        else
+        {
+            LOG_ERROR("SceneManager", 
+                "Scene '" + sceneName + "' not found. Have you forgotten to define it in a .rlscene file?");
+        }
+
+        if (activeChar) 
+        {
+            PartyManager::getSingleton().setActiveCharacter(activeChar);
+        }
+    }
+
+    const Ogre::StringVector& SceneManager::getScriptPatterns() const
+    {
+        return mScriptPatterns;
+    }
+
+    void SceneManager::parseScript(Ogre::DataStreamPtr& data, const Ogre::String& resourceGroup)
+    {
+        SceneLoader* loader = new SceneLoader();
+        addScene(loader->loadScene(data));
+        delete loader;
+    }
+
+    Ogre::Real SceneManager::getLoadingOrder() const
+    {
+        return 1000;
+    }
+
+}

Modified: rl/branches/newton20/engine/script/src/ZoneProcessor.cpp
===================================================================
--- rl/branches/newton20/engine/script/src/ZoneProcessor.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/script/src/ZoneProcessor.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,230 +1,267 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "ZoneProcessor.h"
-
-#include "ActorManager.h"
-#include "RulesConstants.h"
-#include "ScriptSubsystem.h"
-#include "Trigger.h"
-#include "TriggerFactory.h"
-#include "Zone.h"
-#include "ZoneManager.h"
-
-using namespace XERCES_CPP_NAMESPACE;
-using namespace Ogre;
-
-namespace rl
-{
-
-	bool ZoneProcessor::processNode(DOMElement* zonesElem, bool loadGameObjects)
-	{
-		if (zonesElem == NULL)
-		{
-			return false; // no zones
-		}
-
-        for (DOMNode* cur = zonesElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-        {
-            if (cur->getNodeType() == DOMNode::ELEMENT_NODE
-				&& hasNodeName(cur, "zone"))
-            {
-				DOMElement* curZoneElem = static_cast<DOMElement*>(cur);
-				if (hasAttribute(curZoneElem, "name"))
-				{
-					Ogre::String name = getAttributeValueAsStdString(curZoneElem, "name");
-                    Zone* zone = NULL;
-                    if( name == "default" )
-                        zone = ZoneManager::getSingleton().getDefaultZone();
-                    else
-                    {
-                        // get the zone with that name or create one
-                        zone = ZoneManager::getSingleton().getZone(name);
-                        if( !zone )
-                            zone = ZoneManager::getSingleton().createZone(name, false);
-
-                        // multiple areas
-                        for(DOMNode* curArea = cur->getFirstChild(); curArea != NULL; curArea = curArea->getNextSibling())
-                        {
-                            if( curArea->getNodeType() == DOMNode::ELEMENT_NODE
-                                && hasNodeName(curArea, "area") )
-                            {
-                                DOMElement *curAreaElem = static_cast<DOMElement*>(curArea);
-                                if( hasAttribute(curAreaElem, "type") )
-                                {
-                                    // type
-                                    Ogre::String type;
-                                    type = getAttributeValueAsStdString(curAreaElem, "type");
-
-                                    // add or subtract?
-                                    bool subtract = false;
-                                    if( hasAttribute(curAreaElem, "subtract") )
-                                        subtract = getAttributeValueAsBool(curAreaElem, "subtract");
-
-                                    // position
-                                    Vector3 position = Vector3::ZERO;
-                                    DOMElement* positionElem = getChildNamed(curAreaElem, "position");
-                                    if( positionElem != NULL )
-                                        position = getValueAsVector3(positionElem);
-
-                                    //scale, rotation, offset
-                                    Vector3 scale = Vector3::UNIT_SCALE;
-                                    DOMElement* scaleElem = getChildNamed(curAreaElem, "scale");
-                                    if( scaleElem != NULL )
-                                        scale = getValueAsVector3(scaleElem);
-
-                                    Vector3 offset = Vector3::ZERO;
-                                    DOMElement* offsetElem = getChildNamed(curAreaElem, "offset");
-                                    if( offsetElem != NULL )
-                                        offset = getValueAsVector3(offsetElem);
-
-                                    Quaternion rotation = Quaternion::IDENTITY;
-                                    DOMElement* rotationElem = getChildNamed(curAreaElem, "rotation");
-                                    if( rotationElem != NULL )
-                                        rotation = getValueAsQuaternion(rotationElem);
-
-                                    //transition distance
-                                    Real transitionDistance = 0;
-                                    DOMElement* transitionElem = getChildNamed(curAreaElem, "transition_distance");
-                                    if( transitionElem != NULL )
-                                        transitionDistance = getValueAsReal(transitionElem);
-
-					            
-                                    if (type == "mesh")
-    					            {
-                                        Ogre::String meshName;
-                                        if( hasAttribute(curAreaElem, "meshfile") )
-                                        {
-                                            meshName = getAttributeValueAsStdString(curAreaElem, "meshfile");
-                                            if( subtract )
-                                                ZoneManager::getSingleton().subtractMeshAreaFromZone(name,
-                                                    meshName, GT_CONVEXHULL, position, scale, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
-                                            else
-                                                ZoneManager::getSingleton().addMeshAreaToZone(name,
-                                                    meshName, GT_CONVEXHULL, position, scale, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
-                                        }
-                                        else
-                                            LOG_ERROR(Logger::SCRIPT, "an <area> element with type=\"mesh\" must have attribute 'meshfile'");
-                                    }
-    					            else
-                                    {
-                                        GeometryType geom = GT_NONE;
-                                        if (type == "sphere" )
-                                            geom = GT_SPHERE;
-                                        else if (type == "box" )
-                                            geom = GT_BOX;
-                                        else if (type == "ellipsoid" )
-                                            geom = GT_ELLIPSOID;
-                                        else if (type == "pyramid" )
-                                            geom = GT_PYRAMID;
-                                        else if (type == "capsule" )
-                                            geom = GT_CAPSULE;
-                                        else
-                                        {
-                                            LOG_ERROR(Logger::SCRIPT, "Unknown area type '" + type + "' !");
-                                        }
-                                        if ( geom != GT_NONE )
-                                        {
-                                            Ogre::AxisAlignedBox aabb;
-                                            aabb.setMinimum( - scale / 2.0f);
-                                            aabb.setMaximum( + scale / 2.0f);
-
-                                            if( subtract )
-                                                ZoneManager::getSingleton().subtractAreaFromZone(name,
-                                                    aabb, geom, position, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
-                                            else
-                                                ZoneManager::getSingleton().addAreaToZone(name,
-                                                    aabb, geom, position, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
-                                        }
-                                    }
-                                }
-                                else
-                                {
-                                    LOG_ERROR(Logger::SCRIPT, "<area> elemt must have attribute 'type'");
-                                }
-                            }
-                        }
-                    }
-
-					if (zone != NULL)
-					{
-						for (DOMNode* cur = curZoneElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
-						{
-							if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
-							{
-								DOMElement* curElem = static_cast<DOMElement*>(cur);
-								if (hasNodeName(curElem, "light"))
-								{
-									Ogre::String name = getAttributeValueAsStdString(curElem, "name");
-									zone->addLight(ActorManager::getSingleton().getActor(name));
-								}
-								else if (hasNodeName(curElem, "sound"))
-								{
-									Ogre::String name = getAttributeValueAsStdString(curElem, "name");
-									zone->addSound(name);
-								}
-								else if (hasNodeName(curElem, "trigger"))
-								{
-									Ogre::String classname =
-										getAttributeValueAsStdString(curElem, "classname");
-
-									Ogre::String name =
-										getAttributeValueAsStdString(curElem, "name");
-
-									Trigger* trigger = ScriptSubsystem::getSingleton().getTriggerFactory()
-										->createTrigger(classname, name);
-
-                                    // add trigger properties
-                                    for( DOMNode* curProperty = cur->getFirstChild(); curProperty != NULL; curProperty = curProperty->getNextSibling() )
-                                    {
-                                        if( hasNodeName(curProperty, "property") )
-                                        {
-                                            PropertyEntry propEntry = processProperty(static_cast<DOMElement*>(curProperty));
-                                            if (propEntry.first != "")
-                                            {
-                                                trigger->setProperty(propEntry.first, propEntry.second);
-                                            }
-                                        }
-                                    }
-
-                                    zone->addTrigger(trigger);
-								}
-                                else if (hasNodeName(curElem, "eaxpreset"))
-                                {
-									Ogre::String name = getAttributeValueAsStdString(curElem, "name");
-                                    zone->setEaxPreset(name);
-                                }
-							}
-						}
-					}
-					else
-					{
-						LOG_ERROR(Logger::SCRIPT, "Zone named '"+name+"' could not be processes.");
-					}
-				}
-				else
-				{
-					LOG_ERROR(Logger::SCRIPT, "<zone> element must have attribute 'name'.");
-				}
-			}
-		}
-
-        ZoneManager::getSingleton().update();
-		return true;
-	}
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "ZoneProcessor.h"
+
+#include "ActorManager.h"
+#include "RulesConstants.h"
+#include "ScriptSubsystem.h"
+#include "Trigger.h"
+#include "TriggerFactory.h"
+#include "Zone.h"
+#include "ZoneManager.h"
+
+using namespace XERCES_CPP_NAMESPACE;
+using namespace Ogre;
+
+namespace rl
+{
+
+	bool ZoneProcessor::processNode(DOMElement* zonesElem, bool loadGameObjects)
+	{
+		if (zonesElem == NULL)
+		{
+			return false; // no zones
+		}
+
+        for (DOMNode* cur = zonesElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+        {
+            if (cur->getNodeType() == DOMNode::ELEMENT_NODE
+				&& hasNodeName(cur, "zone"))
+            {
+				DOMElement* curZoneElem = static_cast<DOMElement*>(cur);
+				if (hasAttribute(curZoneElem, "name"))
+				{
+					Ogre::String name = getAttributeValueAsStdString(curZoneElem, "name");
+                    Zone* zone = NULL;
+                    if (name == "default")
+                    {
+                        zone = ZoneManager::getSingleton().getDefaultZone();
+                    }
+                    else
+                    {
+                        // get the zone with that name or create one
+                        zone = ZoneManager::getSingleton().getZone(name);
+                        if (!zone)
+                        {
+                            zone = ZoneManager::getSingleton().createZone(name, false);
+                        }
+
+                        // multiple areas
+                        for(DOMNode* curArea = cur->getFirstChild(); curArea != NULL; curArea = curArea->getNextSibling())
+                        {
+                            if (curArea->getNodeType() == DOMNode::ELEMENT_NODE
+                                && hasNodeName(curArea, "area"))
+                            {
+                                DOMElement *curAreaElem = static_cast<DOMElement*>(curArea);
+                                if (hasAttribute(curAreaElem, "type"))
+                                {
+                                    // type
+                                    Ogre::String type;
+                                    type = getAttributeValueAsStdString(curAreaElem, "type");
+
+                                    // add or subtract?
+                                    bool subtract = false;
+                                    if (hasAttribute(curAreaElem, "subtract"))
+                                    {
+                                        subtract = getAttributeValueAsBool(curAreaElem, "subtract");
+                                    }
+
+                                    // position
+                                    Vector3 position = Vector3::ZERO;
+                                    DOMElement* positionElem = getChildNamed(curAreaElem, "position");
+                                    if (positionElem)
+                                    {
+                                        position = getValueAsVector3(positionElem);
+                                    }
+
+                                    //scale, rotation, offset
+                                    Vector3 scale = Vector3::UNIT_SCALE;
+                                    DOMElement* scaleElem = getChildNamed(curAreaElem, "scale");
+                                    if (!scaleElem)
+                                    {
+                                        scaleElem = getChildNamed(curAreaElem, "size");
+                                    }
+                                    
+                                    if (scaleElem)
+                                    {
+                                        scale = getValueAsVector3(scaleElem);
+                                    }
+
+                                    Vector3 offset = Vector3::ZERO;
+                                    DOMElement* offsetElem = getChildNamed(curAreaElem, "offset");
+                                    if (offsetElem)
+                                    {
+                                        offset = getValueAsVector3(offsetElem);
+                                    }
+
+                                    Quaternion rotation = Quaternion::IDENTITY;
+                                    DOMElement* rotationElem = getChildNamed(curAreaElem, "rotation");
+                                    if (rotationElem)
+                                    {
+                                        rotation = getValueAsQuaternion(rotationElem);
+                                    }
+
+                                    //transition distance
+                                    Real transitionDistance = 0;
+                                    DOMElement* transitionElem = getChildNamed(curAreaElem, "transition_distance");
+                                    if (transitionElem)
+                                    {
+                                        transitionDistance = getValueAsReal(transitionElem);
+                                    }
+					            
+                                    if (type == "mesh")
+    					            {
+                                        Ogre::String meshName;
+                                        if (hasAttribute(curAreaElem, "meshfile"))
+                                        {
+                                            meshName = getAttributeValueAsStdString(curAreaElem, "meshfile");
+                                            if (subtract)
+                                            {
+                                                ZoneManager::getSingleton().subtractMeshAreaFromZone(name,
+                                                    meshName, GT_CONVEXHULL, position, scale, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
+                                            }
+                                            else
+                                            {
+                                                ZoneManager::getSingleton().addMeshAreaToZone(name,
+                                                    meshName, GT_CONVEXHULL, position, scale, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
+                                            }
+                                        }
+                                        else
+                                        {
+                                            LOG_ERROR(Logger::SCRIPT, "an <area> element with type=\"mesh\" must have attribute 'meshfile'");
+                                        }
+                                    }
+    					            else
+                                    {
+                                        GeometryType geom = GT_NONE;
+                                        if (type == "sphere")
+                                        {
+                                            geom = GT_SPHERE;
+                                        }
+                                        else if (type == "box")
+                                        {
+                                            geom = GT_BOX;
+                                        }
+                                        else if (type == "ellipsoid")
+                                        {
+                                            geom = GT_ELLIPSOID;
+                                        }
+                                        else if (type == "pyramid")
+                                        {
+                                            geom = GT_PYRAMID;
+                                        }
+                                        else if (type == "capsule")
+                                        {
+                                            geom = GT_CAPSULE;
+                                        }
+                                        else
+                                        {
+                                            LOG_ERROR(Logger::SCRIPT, "Unknown area type '" + type + "' !");
+                                        }
+                                        
+                                        if ( geom != GT_NONE)
+                                        {
+                                            Ogre::AxisAlignedBox aabb;
+                                            aabb.setMinimum( - scale / 2.0f);
+                                            aabb.setMaximum( + scale / 2.0f);
+
+                                            if (subtract)
+                                                ZoneManager::getSingleton().subtractAreaFromZone(name,
+                                                    aabb, geom, position, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
+                                            else
+                                                ZoneManager::getSingleton().addAreaToZone(name,
+                                                    aabb, geom, position, offset, rotation, transitionDistance, QUERYFLAG_PLAYER);
+                                        }
+                                    }
+                                }
+                                else
+                                {
+                                    LOG_ERROR(Logger::SCRIPT, "<area> elemt must have attribute 'type'");
+                                }
+                            }
+                        }
+                    }
+
+					if (zone)
+					{
+						for (DOMNode* cur = curZoneElem->getFirstChild(); cur != NULL; cur = cur->getNextSibling())
+						{
+							if (cur->getNodeType() == DOMNode::ELEMENT_NODE)
+							{
+								DOMElement* curElem = static_cast<DOMElement*>(cur);
+								if (hasNodeName(curElem, "light"))
+								{
+									Ogre::String name = getAttributeValueAsStdString(curElem, "name");
+									zone->addLight(ActorManager::getSingleton().getActor(name));
+								}
+								else if (hasNodeName(curElem, "sound"))
+								{
+									Ogre::String name = getAttributeValueAsStdString(curElem, "name");
+									zone->addSound(name);
+								}
+								else if (hasNodeName(curElem, "trigger"))
+								{
+									Ogre::String classname =
+										getAttributeValueAsStdString(curElem, "classname");
+
+									Ogre::String name =
+										getAttributeValueAsStdString(curElem, "name");
+
+									Trigger* trigger = ScriptSubsystem::getSingleton().getTriggerFactory()
+										->createTrigger(classname, name);
+
+                                    // add trigger properties
+                                    for( DOMNode* curProperty = cur->getFirstChild(); curProperty != NULL; curProperty = curProperty->getNextSibling())
+                                    {
+                                        if (hasNodeName(curProperty, "property"))
+                                        {
+                                            PropertyEntry propEntry = processProperty(static_cast<DOMElement*>(curProperty));
+                                            if (propEntry.first != "")
+                                            {
+                                                trigger->setProperty(propEntry.first, propEntry.second);
+                                            }
+                                        }
+                                    }
+
+                                    zone->addTrigger(trigger);
+								}
+                                else if (hasNodeName(curElem, "eaxpreset"))
+                                {
+									Ogre::String name = getAttributeValueAsStdString(curElem, "name");
+                                    zone->setEaxPreset(name);
+                                }
+							}
+						}
+					}
+					else
+					{
+						LOG_ERROR(Logger::SCRIPT, "Zone named '"+name+"' could not be processes.");
+					}
+				}
+				else
+				{
+					LOG_ERROR(Logger::SCRIPT, "<zone> element must have attribute 'name'.");
+				}
+			}
+		}
+
+        ZoneManager::getSingleton().update();
+		return true;
+	}
+
+}

Modified: rl/branches/newton20/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/RlRules.head.swig	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/script/swig/RlRules.head.swig	2008-09-19 08:22:31 UTC (rev 4519)
@@ -41,6 +41,7 @@
 #include "ObjectStateChangeEventSource.h"
 #include "ObjectStateChangeEvent.h"
 #include "ObjectStateChangeListener.h"
+#include "PartyManager.h"
 #include "Quest.h"
 #include "QuestBook.h"
 #include "QuestEvent.h"

Modified: rl/branches/newton20/engine/script/swig/RlRules.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/RlRules.swig	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/script/swig/RlRules.swig	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,952 +1,962 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-//%template(GameObjectVector) std::vector< rl::GameObject* >;
-
-namespace rl {
-
-    // Before first use of GameObject or subclasses!
-    %apply SWIGTYPE *DYNAMIC { rl::GameObject * };
-
-                    
-   template<typename T>
-   class Tripel {
-   public:
-      T first;
-      T second;
-      T third;
-
-      Tripel();      
-      Tripel(const T& t1, const T& t2, const T& t3);
-      Tripel(const Tripel& rhs);
-
-      //Tripel& operator=(const Tripel& rhs);
-      bool operator==(const Tripel& rhs);
-      bool operator<(const Tripel& rhs);     
-   };
-    
-    class Date {
-    public:
-        static const RL_LONGLONG ONE_SECOND = 1000ULL;
-        static const RL_LONGLONG ONE_MINUTE = 60000ULL;
-        static const RL_LONGLONG ONE_HOUR = 3600000ULL;
-        static const RL_LONGLONG ONE_DAY = 86400000ULL;
-        static const RL_LONGLONG ONE_WEEK = 604800000ULL;
-        static const RL_LONGLONG ONE_MONTH = 2592000000ULL;
-        static const RL_LONGLONG ONE_YEAR = 31536000000ULL;
-        static const RL_LONGLONG ONE_KAMPFRUNDE = 2 * ONE_SECOND;
-        static const RL_LONGLONG ONE_SPIELRUNDE = 5 * ONE_MINUTE;
-
-        Date();
-        Date(RL_LONGLONG timestamp);
-        Date(const Date& rhs);
-      
-        bool operator==(const Date& rhs);
-        bool operator<(const Date& rhs);
-        bool operator<=(const Date& rhs);
-        bool operator>=(const Date& rhs);
-        bool operator>(const Date& rhs);
-
-        Date operator+(const RL_LONGLONG& rhs);
-        Date operator-(const RL_LONGLONG& rhs);
-        Date operator*(const Ogre::Real& rhs);
-        Date operator/(const Ogre::Real& rhs);
-        RL_LONGLONG operator-(const Date& rhs);
-      
-        RL_LONGLONG getTimestamp();
-
-        int getTimeFraction();
-        int getYear();
-        int getMonth();
-        rl::CeGuiString getMonthName();
-        int getDayOfYear();
-        int getDayOfMonth();
-        int getDayOfWeek();
-        rl::CeGuiString getDayOfWeekName();
-        int getHour();
-        int getMinute();
-        int getSecond();
-        int getMilliSecond();
-      
-        rl::CeGuiString toString();
-    };
-   
-    Date operator+(const RL_LONGLONG&, const Date&);
-    Date operator-(const RL_LONGLONG&, const Date&);
-
-    class RulesSubsystem 
-    {
-        public:
-             static rl::RulesSubsystem& getSingleton();
-             rl::QuestBook* getQuestBook();
-             void resetQuestBook();
-    };
-  
-    class DsaManager {
-    public:
-        RL_LONGLONG getTimestamp();
-        Date getCurrentDate();
-        void setCurrentDate(const Date& date);
-        
-        int rollD20();
-        Tripel<int> roll3D20();
-        int rollD6();
-        int roll(int d6, int d20);
-      
-        static DsaManager& getSingleton();
-        rl::Talent* getTalent(const rl::CeGuiString name) const;
-        rl::Creature* getCreature(const int id) const;
-    };
-    
-    %feature("director") GameObjectFactory; 
-    class GameObjectFactory
-    {
-    public:
-        virtual rl::GameObject* createRubyGameObject(const Ogre::String& classname, unsigned int id) = 0;
-        GameObjectFactory();
-        virtual ~GameObjectFactory();
-    };
-
-    class GameObjectManager
-    {
-    public:
-        static rl::GameObjectManager& getSingleton();
-        rl::GameObject* createGameObject(const Ogre::String& classId, unsigned int id = 0);
-        rl::GameObject* getGameObject(unsigned int id) const;
-        void setGameObjectFactory(rl::GameObjectFactory* gof);
-
-    private:
-        GameObjectManager();
-    };
-
-	enum GameEventType
-	{
-		GET_DEFAULT,
-		GET_COMBAT,
-		GET_DIALOG,
-		GET_QUEST
-	};
-	
-    class GameEventLog
-    {
-    public:
-        static rl::GameEventLog& getSingleton();
-		void logEvent(const Ogre::String& eventString, GameEventType type);
-
-    private:
-        GameEventLog();
-    };
-    
-    class GlobalProperties 
-    {
-    public:
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        bool hasProperty(const Ogre::String& key) const;
-        
-        static rl::GlobalProperties& getSingleton();
-    private:
-        GlobalProperties();
-    };
-
-    %feature("director") QuestListener; 
-    class QuestListener
-    {
-    public:
-        virtual ~QuestListener();
-        
-        virtual void questStateChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questPartsDoneChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questKnownChanged(rl::QuestEvent* anEvent) = 0;
-        virtual void questSubquestAdded(rl::QuestEvent* anEvent) = 0;
-        virtual void journalEntryAdded(rl::JournalEvent* anEvent) = 0;
-        virtual void journalEntryDeleted(rl::JournalEvent* anEvent) = 0;
-    };
-
-    class JournalEntry
-    {
-    public:
-        JournalEntry(const rl::CeGuiString caption, const rl::CeGuiString text);
-        virtual ~JournalEntry();
-
-        rl::CeGuiString getCaption() const;
-
-        rl::CeGuiString getText() const;
-    };
-    
-    class Quest
-    {
-    public:
-        enum State
-        {
-            OPEN = 0,
-            ASSIGNED,
-            FAILED,
-            SUCCEEDED,
-            COMPLETED
-        };
-
-        Quest(const rl::CeGuiString id, const rl::CeGuiString name, const rl::CeGuiString description);
-        virtual ~Quest();
-
-        const rl::CeGuiString getId();
-        const rl::CeGuiString getName();
-        const rl::CeGuiString getDescription();
-        int getPartsToDo();
-        void setPartsToDo(int partsToDo);
-        int getPartsDone();
-        void setPartsDone(int partsDone);
-        void increasePartsDone(int parts = 1);
-        void decreasePartsDone(int parts = 1);
-
-        rl::Quest::State getState();
-        void setState(rl::Quest::State state);
-        bool isKnown();
-        void setKnown(bool known);
-
-        // QuestVector getSubquests();
-        void addSubquest(rl::Quest* quest); 
-    };   
-    
-    class QuestEvent
-    {
-    public:
-        rl::Quest* getQuest();
-    private:
-        QuestEvent( rl::QuestBook* src, int reason );
-    };
-    
-    class QuestBook
-    {
-    public:
-        rl::Quest* getQuest(const rl::CeGuiString id);
-        void addQuest(rl::Quest* quest);
-        
-        void addJournalEntry(rl::JournalEntry* entry);
-        void addJournalEntry(rl::CeGuiString caption, rl::CeGuiString text);
-        
-        void addQuestListener(rl::QuestListener* listener);
-        void removeQuestListener(rl::QuestListener* listener);
-    };
-    
-    class Talent
-    {
-    public:
-        typedef std::map<const rl::CeGuiString,int> AusweichTalente;
-        Talent(const rl::CeGuiString name,
-               const rl::CeGuiString description,
-               const Tripel<rl::CeGuiString>& eigenschaften,
-               int ebe,
-               int gruppe,
-               const rl::CeGuiString art,
-               const AusweichTalente &ausweichTalente);
-
-        bool operator==(const Talent& rhs) const;
-        bool operator<(const Talent& rhs) const;
-        rl::CeGuiString getName() const;
-        rl::CeGuiString getDescription() const;
-        int getEbe() const;
-
-        /// Berechnet effektive Behinderung bei gegebener Behinderung;
-        int calculateEbe(int be) const;
-        Tripel<rl::CeGuiString> getEigenschaften() const;
-    };
-
-    class ActionGroup
-    {
-    public:
-        ActionGroup(rl::CeGuiString name, ActionGroup* parent = NULL);
-        ~ActionGroup();
-    
-        const rl::CeGuiString getName() const;
-    };
-    
-    %feature("director") Action;   
-    class Action
-    {
-    public:
-        static const int ACT_NORMAL = 1<<0;
-        static const int ACT_INVIS_DESC = 1<<1;
-        static const int ACT_DISABLED = 1<<2;
-        static const int ACT_NEEDS_TALENT = 1<<8;
-
-        static const int TC_NO_TARGET = 0;
-        static const int TC_GAMEOBJECT = 1;
-        static const int TC_CREATURE = 2;
-        static const int TC_ITEM = 3;
-        static const int TC_POINT = 4;
-        static const int TC_RADIUS = 5;
-        static const int TC_POINT_AND_RADIUS = 6;
-    
-        Action(const rl::CeGuiString name, const rl::CeGuiString description);
-        virtual ~Action();
-
-        virtual const rl::CeGuiString getName() const;
-        //virtual const rl::CeGuiString getClassName() const;
-        virtual const rl::CeGuiString getDescription() const;
-        virtual int getTargetClass() const;
-        virtual void doAction(rl::GameObject *object, rl::Creature *actor,
-            rl::GameObject *target);
-        virtual bool canDo(rl::GameObject* object, rl::Creature* actor) const;
-            
-        void setGroup(rl::ActionGroup* group);
-        rl::ActionGroup* getGroup() const;
-    };
-    
-    %feature("director") ObjectStateChangeListener;      
-    class ObjectStateChangeListener      
-    {      
-    public:      
-        virtual ~ObjectStateChangeListener();      
-               
-        virtual void objectStateChanged(rl::ObjectStateChangeEvent *anEvent) = 0;      
-    };
-              
-               
-    class ObjectStateChangeEventSource      
-    {      
-    public:      
-        ObjectStateChangeEventSource( );      
-               
-        void addObjectStateChangeListener( rl::ObjectStateChangeListener*  list );      
-        void removeObjectStateChangeListener( rl::ObjectStateChangeListener* list );      
-        bool hasListeners( ) const;      
-        rl::GameObject* getObject() const;
-        void fireObjectStateChangeEvent();      
-    };      
-               
-    class ObjectStateChangeEvent      
-    {      
-    public:      
-        ObjectStateChangeEvent( rl::ObjectStateChangeEventSource* src );      
-        rl::GameObject* getProvokingObject() const;      
-        rl::ObjectStateChangeEventSource* getSource() const;      
-    };
-            
-    enum GameObjectState
-    {
-        GOS_UNDEFINED = 0,
-        GOS_UNLOADED,
-        GOS_LOADED,
-        GOS_IN_POSSESSION,
-        GOS_IN_SCENE,
-        GOS_HELD,
-        GOS_READY
-    };
-    
-    class PropertyRecord
-    {
-    public:
-        PropertyRecord();
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-    };
-    
-    %constant unsigned long QUERYFLAG_GAMEOBJECT = rl::QUERYFLAG_GAMEOBJECT;
-    %constant unsigned long QUERYFLAG_CREATURE = rl::QUERYFLAG_CREATURE;
-    %constant unsigned long QUERYFLAG_ITEM = rl::QUERYFLAG_ITEM;
-    %constant unsigned long QUERYFLAG_CONTAINER = rl::QUERYFLAG_CONTAINER;
-    %constant unsigned long QUERYFLAG_WEAPON = rl::QUERYFLAG_WEAPON;
-    %constant unsigned long QUERYFLAG_ARMOR = rl::QUERYFLAG_ARMOR;
-    %constant unsigned long QUERYFLAG_PERSON = rl::QUERYFLAG_PERSON;
-    %constant unsigned long QUERYFLAG_PLAYER = rl::QUERYFLAG_PLAYER;
-    
-    %feature("director") GameObject;
-    class GameObject: public ObjectStateChangeEventSource
-    {
-    public:
-        GameObject(unsigned int id);
-        virtual ~GameObject();
-
-        virtual unsigned int getId();
-
-        virtual const rl::CeGuiString getName() const;
-        virtual void setName(rl::CeGuiString name);
-
-        const rl::CeGuiString getDescription() const;
-        virtual void setDescription(rl::CeGuiString description);   
-        
-        void setActor(rl::Actor* actor);
-        rl::Actor* getActor();
-
-        void addAction(rl::Action *action, int option = ACT_NORMAL);
-        void addActionInGroup(Action* action, ActionGroup* group, int option = ACT_NORMAL);
-        void removeAction(rl::Action *action);
-
-        const std::vector<Action*> getValidActions(rl::Creature *actor) const;        
-        void setPosition(const Ogre::Vector3& position);
-        void setOrientation(const Ogre::Quaternion& orientation);
-        const Ogre::Quaternion& getOrientation() const;
-        const Ogre::Vector3& getPosition() const;
-        
-        void setMeshfile(rl::CeGuiString meshfile);
-        
-        virtual Action* getDefaultAction(rl::Creature* actor) const;
-        
-        void doAction(
-            const rl::CeGuiString actionName, 
-            rl::Creature* actor,
-            rl::GameObject* target);
-        void doAction(
-            const rl::CeGuiString actionName);
-        void doAction(rl::Action* action, rl::Creature* actor,
-            rl::GameObject* target);
-            
-        void doDefaultAction(rl::Creature* actor, rl::GameObject* target);
-            
-        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
-        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
-        
-        bool isHighlightingEnabled();
-        void setHighlightingEnabled( bool highlightenabled );
-        
-        void addEffect(rl::Effect* effect);
-        void addEffectWithCheckTime(rl::Effect* effect, RL_LONGLONG time);
-        void addEffectWithCheckDate(rl::Effect* effect, RL_LONGLONG date);
-        void removeEffect(rl::Effect* effect);
-        
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void placeIntoScene();
-        void removeFromScene();
-        
-        rl::GameObjectState getState() const;
-        void setState(rl::GameObjectState state);
-        
-        unsigned long getQueryFlags() const;
-        void addQueryFlag(unsigned long queryflag);
-        void setQueryFlags(unsigned long queryflags);
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    class WaitJob : public rl::Job
-    {
-    public:
-        WaitJob(const rl::Date& dsatime);
-        WaitJob(const Ogre::Real& realtime);
-    };
-    
-    class GoToJob : public rl::Job
-    {
-    public:
-
-		GoToJob(rl::Creature* actor, const Ogre::Vector3& targetPos,
-			Ogre::Real maxDistance, Ogre::Real duration);
-		// Unclear what version is called from ruby, so uncomment second ctor.
-		//GoToJob(rl::Creature* actor, rl::GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
-    };
-    
-    %feature("director") Item;
-    class Item : public rl::GameObject {
-    public:
-        enum ItemType{
-            ITEMTYPE_WEAPON     = 1 << 0,
-            ITEMTYPE_SHIELD     = 1 << 1,
-            ITEMTYPE_RING       = 1 << 2,
-            ITEMTYPE_GLOVES     = 1 << 3,
-            ITEMTYPE_BRACELET   = 1 << 4,
-            ITEMTYPE_ARMOR      = 1 << 5,
-            ITEMTYPE_CAPE       = 1 << 6,
-            ITEMTYPE_BRACERS    = 1 << 7,
-            ITEMTYPE_BACKPACK   = 1 << 8,
-            ITEMTYPE_BELT       = 1 << 9,
-            ITEMTYPE_NECKLACE   = 1 << 10,
-            ITEMTYPE_HELMET     = 1 << 11,
-            ITEMTYPE_TROUSERS   = 1 << 12,
-            ITEMTYPE_SHINBONE   = 1 << 13,
-            ITEMTYPE_BOOTS      = 1 << 14,
-            ITEMTYPE_CLOTHES    = 1 << 15,
-            ITEMTYPE_OTHER      = 1 << 16,
-            ITEMTYPE_ALL_ITEMS  = ~(0)
-        };
-    
-        Item(unsigned int id);
-        virtual ~Item();
-        
-        virtual void placeIntoScene();
-        
-        void setItemType(rl::Item::ItemType itemType);
-        rl::Item::ItemType getItemType() const;
-        virtual void setState(rl::GameObjectState state);
-        virtual void removeOldState();
-
-        void setParentSlot(rl::Slot* slot);
-        rl::Slot* getParentSlot() const;
-
-        void setParentContainer(rl::Container* cont);
-        rl::Container* getParentContainer() const;
-
-        void setOwner(rl::GameObject* go);
-        rl::GameObject* getOwner() const;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        virtual bool isContainer();
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature("director") Weapon;
-    class Weapon : public rl::Item 
-    {
-    public:
-        enum Distanzklasse { DK_H=0, DK_N, DK_S, DK_P };
-
-        Weapon(unsigned int id);
-        virtual ~Weapon();
-                
-        void setTp(int d6, int d20, int mod);
-        const Tripel<int>& getTp() const;
-        void setTpKk(int base, int step);
-        const std::pair<int, int>& getTpKk() const;
-        void setBf(int newBf);
-        int getBf();
-        void setIni(int newIni);
-        int getIni();
-        void setWm(std::pair<int, int>& newWm);
-        const std::pair<int,int>& getWm() const;
-        void setDk(Weapon::Distanzklasse newDk);
-        Weapon::Distanzklasse getDk();
-        void setKampftechnik(const rl::CeGuiString newKampftechnik);
-        const rl::CeGuiString getKampftechnik() const;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature("director") Armor;
-    class Armor : public Item
-    {
-    public:
-    
-        static const CeGuiString Armor::PROPERTY_G_BE = "g_be";
-        static const CeGuiString Armor::PROPERTY_G_RS = "g_rs";
-        
-        Armor(unsigned int id);
-        virtual ~Armor();
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-    %feature("director") Container;
-    class Container : public Item
-    {
-    public:
-        Container(unsigned int id);
-        virtual ~Container();
-
-        Ogre::Real getCapacity() const;
-        void setCapacity(Ogre::Real capacity);
-        void setVolume(unsigned int x, unsigned int y);
-        Ogre::Real getContentWeight() const;
-        void addItem(rl::Item* item);
-        void removeItem(rl::Item* item);
-        rl::ItemSet getItems() const;
-        int getItemCount() const;
-        rl::Item* getItemAt(unsigned int x, unsigned int y);
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-    };
-    
-
-    %feature("director") Effect;
-    class Effect
-    {
-    public:    
-        typedef unsigned long LifeState;
-        static const LifeState LS_NONE           = 1<<0;
-        static const LifeState LS_BLIND          = 1<<1;   ///< The creature can't see anything.
-        static const LifeState LS_DEAD           = 1<<2;   ///< The creature is dead.
-        static const LifeState LS_DEAF           = 1<<3;   ///< The creature can't hear anything.
-        static const LifeState LS_PARALYZED      = 1<<4;   ///< The creature can't move, turn, jump etc.
-        static const LifeState LS_INCAPACITATED  = 1<<5;   ///< The creature can't fight anymore due to serious injuries. The creature can barely move.
-        static const LifeState LS_INVISIBLE      = 1<<6;   ///< The creature can't be seen.
-        static const LifeState LS_INVULNERABLE   = 1<<7;   ///< The creature is immune to any mundane attacks.
-        static const LifeState LS_PETRIFIED      = 1<<8;   ///< The creature is coated with stone and has all the effects of paralyzation
-        static const LifeState LS_SILENCED       = 1<<9;   ///< The creature doesn't make any noises.
-        static const LifeState LS_SLEEPING       = 1<<10;  ///< The creature is asleep.
-        static const LifeState LS_UNCONSCIOUS    = 1<<11;  ///< Like SLEEPING, but more difficult to wake.
-
-        // Meta stati
-        static const LifeState LS_IMMOBILE = LS_PARALYZED | LS_SLEEPING | LS_UNCONSCIOUS | LS_PETRIFIED | LS_DEAD;
-        static const LifeState LS_NO_COMBAT = LS_IMMOBILE | LS_INCAPACITATED;
-
-        typedef int ModType;
-        static const ModType MODTYPE_NONE         = 1 << 0;
-        static const ModType MODTYPE_SUM      = 1 << 1;   ///< Modifies the actual value.
-        static const ModType MODTYPE_PROBENMOD    = 1 << 2;   ///< Modifies the test.
-        static const ModType MODTYPE_MULT     = 1 << 3;   ///< Will be multiplied on the value.
-        static const ModType MODTYPE_MAXWERTMOD   = 1 << 4;   ///< Modifies only the maximum of the value.
-
-        typedef unsigned long ModTag;
-        static const ModTag MODTAG_NONE           = 1 << 0;
-        static const ModTag MODTAG_KRANKHEIT      = 1 << 1;
-        static const ModTag MODTAG_RECALCULATE    = 1 << 2;
-        static const ModTag MODTAG_REGENERATION_LE = 1 << 3;
-        static const ModTag MODTAG_REGENERATION_AE = 1 << 4;
-        static const ModTag MODTAG_REGENERATION_AU = 1 << 5;
-        static const ModTag MODTAG_ERSCHOEPFUNGSSCHWELLE = 1 << 6;
-    
-        enum Quantifier
-        {
-            QUANTIFIER_MULTIPLE,
-            QUANTIFIER_UNIQUE,
-            QUANTIFIER_UNIQUE_BUT_PROLONGABLE,
-            QUANTIFIER_UNIQUE_BUT_CUMULATIVE
-        };
-        
-      // other constants
-        static const int REMOVE = -1;
-        static const int PERMANENT = 0;
-
-
-        Effect(int stufe = 1);
-        virtual ~Effect();
-
-        const rl::CeGuiString getName() const;
-        void setName(rl::CeGuiString name);
-        const rl::CeGuiString getDescription() const;
-        void setDescription(rl::CeGuiString description);
-        Quantifier getQuantifier();
-        void setQuantifier(Quantifier quantifier);
-        virtual const int getStufe();
-        virtual void increaseStufe();
-        virtual void decreaseStufe();
-        virtual void enable();
-        virtual void disable();
-        virtual RL_LONGLONG timeCheck() = 0;
-
-        virtual LifeState getLifeState() const;
-        virtual int getMod(rl::CeGuiString target, ModType type, ModTag tag);
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-        virtual rl::PropertyKeys getAllPropertyKeys() const;
-    };
-
-    class EffectFactory
-    {
-    public:
-        virtual rl::Effect* createEffect(const Ogre::String& name, int stufe) = 0;
-    };
-
-    class EffectFactoryManager
-    {
-    public:
-        void setEffectFactory(rl::EffectFactory* factory);
-        static rl::EffectFactoryManager& getSingleton();
-    };
-
-    enum SlotType
-    {
-        SLOT_BONE,
-        SLOT_SUBMESH,
-        SLOT_MATERIAL
-    };
-
-    class Inventory 
-    {
-    private:
-        Inventory(rl::Creature* owner);
-    public:
-        void addSlot(const rl::CeGuiString& name, const Ogre::String& meshpartname, int itemReadyMask, int itemHeldMask, SlotType type = SLOT_BONE);
-        rl::Item* getItem(const rl::CeGuiString& slotName) const;
-        void hold(rl::Item* item, const rl::CeGuiString& slot);
-        void ready(rl::Item* item, const rl::CeGuiString& slot);
-        void dropItem(const rl::CeGuiString& slotName);
-    };
-
-    %feature("director") Creature;
-    class Creature : public GameObject {
-    public:
-    
-    typedef Ogre::String Wert;
-        enum Alignment
-        {
-            ALIGNMENT_ALLY,    ///< Creature fights with the player.
-            ALIGNMENT_NEUTRAL, ///< Creature doesn't fight for either side.
-            ALIGNMENT_ENEMY    ///< Creature fights against the player.
-        };
-
-        enum SfStatus
-        {
-            SFSTATUS_IN_TRAINING = 1,
-            SFSTATUS_OK,
-            SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Wird das ueberhaupt gebraucht?
-        };
-
-        // some targets
-        static const std::string Creature::ALL_EIGENSCHAFTEN = "alle Eigenschaften";
-        static const std::string Creature::ALL_TALENTE = "alle Talente";
-        static const Creature::Wert Creature::WERT_MOD_AE = "ModAE";
-        static const Creature::Wert Creature::WERT_MOD_LE = "ModLE";
-        static const Creature::Wert Creature::WERT_MOD_AU = "ModAU";
-        static const Creature::Wert Creature::WERT_MOD_MR = "ModMR";
-        static const Creature::Wert Creature::WERT_MOD_AT = "ModAT";
-        static const Creature::Wert Creature::WERT_MOD_PA = "ModPA";
-        static const Creature::Wert Creature::WERT_MOD_FK = "ModFK";
-        static const Creature::Wert Creature::WERT_GS = "GS";
-        static const Creature::Wert Creature::WERT_SOZIALSTATUS = "SO";
-        static const Creature::Wert Creature::WERT_BE = "BE";
-        static const Creature::Wert Creature::WERT_RS = "RS";
-        static const Creature::Wert Creature::WERT_INI = "INI";
-        static const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE ="Kampfunf??higkeitsschwelle"; 
-        static const Creature::Wert Creature::WERT_REGENERATION = "Regeneration";
-        
-        
-        Creature(unsigned int id);
-        virtual ~Creature();
-
-        virtual int getLe();
-        virtual void modifyLe(int mod, bool ignoreMax);
-        virtual void modifyAe(int mod);
-        virtual void modifyAu(int mod);
-        void setWert(Wert wertId, int value);
-        virtual int getWert(Wert wertId, bool getUnmodified = false);
-        
-        virtual int getEigenschaft(const rl::CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE);
-        virtual void setEigenschaft(const rl::CeGuiString eigenschaftName, int value);
-        virtual void modifyEigenschaft(const rl::CeGuiString eigenschaftName, int mod);
-
-        
-        void addTalent(const rl::CeGuiString talentName, int value=0);
-        bool hasTalent(const rl::CeGuiString talentName, bool checkAusweichTalente = true);
-        virtual int getTalent(const rl::CeGuiString talentName);
-        virtual void setTalent(const rl::CeGuiString talentName, int value);
-        virtual void modifyTalent(const rl::CeGuiString talentName, int mod);
-        virtual void addSe(const rl::CeGuiString talentName);
-        
-        void addVorteil(const rl::CeGuiString vorteilName, int value = 0);
-        void addNachteil(const rl::CeGuiString nachteilName, int value = 0);        
-        
-        void addKampftechnik(const rl::CeGuiString kampftechnikName, std::pair<int,int> value = make_pair(0,0));
-        virtual void addSf(const rl::CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
-        
-        virtual int doTalentprobe(const rl::CeGuiString talentName, int modifier);
-        virtual int doEigenschaftsprobe(const rl::CeGuiString eigenschaftName, int modifier);
-        
-        rl::Inventory* getInventory();
-        
-        void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
-        static const int LEDAMAGE_NORMAL = 0;
-        static const int LEDAMAGE_FIRE = 1;
-        static const int LEDAMAGE_WATER = 2;
-        static const int LEDAMAGE_DEMONIC = 4;
-        void damageAu(int aup, int damageType = AUDAMAGE_NORMAL);
-        static const int AUDAMAGE_NORMAL = 0;
-        static const int AUDAMAGE_HEAT = 1;
-        static const int AUDAMAGE_COLD = 2;
-        static const int AUDAMAGE_CHOKE = 4;
-        static const int AUDAMAGE_DROWN = 8;
-
-        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
-        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
-
-        void setAlignment(Alignment);
-        Alignment getAlignment() const;
-        
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-   };
-   
-    %feature("director") ActionManager;
-    class ActionManager
-    {
-    public:
-        void registerAction(rl::Action* action);
-        void unregisterAction(const rl::CeGuiString actionName);
-        rl::Action* getAction(const rl::CeGuiString actionName) const;
-
-        void registerInGameGlobalAction(rl::Action* action, rl::ActionGroup* group);
-    
-        static rl::ActionManager& getSingleton();
-    };
-    
-    class CreatureController
-    {
-    public:
-        
-        typedef enum
-        {
-            // these movements can be used
-            MT_NONE,
-            MT_STEHEN,
-            MT_GEHEN,
-            MT_JOGGEN,
-            MT_LAUFEN,
-            MT_RENNEN,
-            MT_RUECKWAERTS_GEHEN,
-            MT_RUECKWAERTS_JOGGEN,
-            MT_SEITWAERTS_GEHEN,
-            MT_SCHLEICHEN,
-            MT_HOCHSPRUNG,
-            MT_WEITSPRUNG,
-            MT_ZIELSPRUNG,
-            // these movements are only for internal purposes and should not be used directly
-            // instead use one of the movements above
-            MT_DREHEN,
-            MT_STUFENERKENNUNG,
-            MT_FALLEN,
-            MT_LIEGEN
-        } MovementType;
-        
-        Creature *getCreature();
-        bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
-        MovementType getMovementId() const;
-        Ogre::Vector3 getDirection() const;
-        Ogre::Vector3 getRotation() const;
-        Ogre::Vector3 getVelocity() const;
-        Ogre::Vector3 getOmega() const;
-        void setAnimation(const Ogre::String &name, 
-                          Ogre::Real speed = 1, 
-                          unsigned int timesToPlay = 0, 
-                          const Ogre::String &collisionName = "");
-    protected:
-        CreatureController(Creature *character);
-        ~CreatureController();
-    };
-    
-    class CreatureControllerManager
-    {
-    public:
-        /// Returns a CreatureController that can be used to control given Creature.
-        /// There is only one controller per Creature at a given time.
-        /// If no such controller exists yet, it is created.
-        rl::CreatureController* getCreatureController(rl::Creature* creature);
-
-        /// This function detaches a controller attached to the given Creature, if any.
-        void detachController(rl::Creature* creature);
-
-        static rl::CreatureControllerManager& getSingleton();
-    };
-
-	// Before first use of Selector or subclasses!
-    %apply SWIGTYPE *DYNAMIC { rl::Selector* };
-
-	class Selector
-    {
-    public:
-        Selector(unsigned long mask = 0xffffffff);
-        virtual void updateSelection();
-
-        void setSelectionMask(unsigned long mask);
-        unsigned long getSelectionMask() const;
-
-        GameObject* getFirstSelectedObject() const;
-		const std::vector<GameObject*>& getAllSelectedObjects() const;
-		unsigned int getSelectionCount() const;
-
-		virtual void updatePrimitive() = 0;
-    };
-
-
-    /// A Selector that selects all unoccluded GameObject the ray hits.
-    class RaySelector : public Selector
-    {
-    public:
-        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
-        void setRay(const Ogre::Vector3& start, const Ogre::Vector3& end);
-		virtual void updatePrimitive();
-    };
-
-    /// Selects this GameObject within a half sphere pointing to -Z,
-    /// that has the smallest angle difference to the -Z-Axis.
-    class HalfSphereSelector : public Selector
-    {
-    public:
-        HalfSphereSelector(unsigned long mask = 0xffffffff);
-	    void setRadius(Ogre::Real radius);
-        void setPosition(const Ogre::Vector3& pos);
-        void setOrientation(const Ogre::Quaternion& ori);
-		virtual void updatePrimitive();
-	};
-
-} // Namespace
-
-%{
-static swig_type_info *Selector_dynamic_cast(void **ptr)
-{
-	rl::Selector *pSelector = static_cast<rl::Selector*>(*ptr);
-	rl::HalfSphereSelector *pHalfSphereSel = dynamic_cast<rl::HalfSphereSelector*>(pSelector);
-	if (pHalfSphereSel)
-	{
-		*ptr = pHalfSphereSel;
-		return SWIGTYPE_p_rl__HalfSphereSelector;
-	}
-	rl::RaySelector *pRaySel = dynamic_cast<rl::RaySelector*>(pSelector);
-	if (pRaySel)
-	{
-		*ptr = pRaySel;
-		return SWIGTYPE_p_rl__RaySelector;
-	}
-}
-	
-static swig_type_info *GameObject_dynamic_cast(void **ptr)
-{
-    rl::GameObject *pGameObject = static_cast<rl::GameObject*>(*ptr);
-
-    rl::Creature *pCreature=dynamic_cast<rl::Creature*>(pGameObject);
-    if (pCreature) {
-        *ptr=pCreature;
-        return SWIGTYPE_p_rl__Creature;
-    }
-    rl::Weapon *pWeapon=dynamic_cast<rl::Weapon*>(pGameObject);
-    if (pWeapon) {
-        *ptr=pWeapon;
-        return SWIGTYPE_p_rl__Weapon;
-    }
-    rl::Armor *pArmor=dynamic_cast<rl::Armor*>(pGameObject);
-    if (pArmor) {
-        *ptr=pArmor;
-        return SWIGTYPE_p_rl__Armor;
-    }
-    rl::Container *pContainer=dynamic_cast<rl::Container*>(pGameObject);
-    if (pContainer) {
-        *ptr=pContainer;
-        return SWIGTYPE_p_rl__Container;
-    }
-    rl::Item *pItem=dynamic_cast<rl::Item*>(pGameObject);
-    if (pItem) {
-        *ptr=pItem;
-        return SWIGTYPE_p_rl__Item;
-    }
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__GameObject, GameObject_dynamic_cast);
-
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+//%template(GameObjectVector) std::vector< rl::GameObject* >;
+
+namespace rl {
+
+    // Before first use of GameObject or subclasses!
+    %apply SWIGTYPE *DYNAMIC { rl::GameObject * };
+
+                    
+   template<typename T>
+   class Tripel {
+   public:
+      T first;
+      T second;
+      T third;
+
+      Tripel();      
+      Tripel(const T& t1, const T& t2, const T& t3);
+      Tripel(const Tripel& rhs);
+
+      //Tripel& operator=(const Tripel& rhs);
+      bool operator==(const Tripel& rhs);
+      bool operator<(const Tripel& rhs);     
+   };
+    
+    class Date {
+    public:
+        static const RL_LONGLONG ONE_SECOND = 1000ULL;
+        static const RL_LONGLONG ONE_MINUTE = 60000ULL;
+        static const RL_LONGLONG ONE_HOUR = 3600000ULL;
+        static const RL_LONGLONG ONE_DAY = 86400000ULL;
+        static const RL_LONGLONG ONE_WEEK = 604800000ULL;
+        static const RL_LONGLONG ONE_MONTH = 2592000000ULL;
+        static const RL_LONGLONG ONE_YEAR = 31536000000ULL;
+        static const RL_LONGLONG ONE_KAMPFRUNDE = 2 * ONE_SECOND;
+        static const RL_LONGLONG ONE_SPIELRUNDE = 5 * ONE_MINUTE;
+
+        Date();
+        Date(RL_LONGLONG timestamp);
+        Date(const Date& rhs);
+      
+        bool operator==(const Date& rhs);
+        bool operator<(const Date& rhs);
+        bool operator<=(const Date& rhs);
+        bool operator>=(const Date& rhs);
+        bool operator>(const Date& rhs);
+
+        Date operator+(const RL_LONGLONG& rhs);
+        Date operator-(const RL_LONGLONG& rhs);
+        Date operator*(const Ogre::Real& rhs);
+        Date operator/(const Ogre::Real& rhs);
+        RL_LONGLONG operator-(const Date& rhs);
+      
+        RL_LONGLONG getTimestamp();
+
+        int getTimeFraction();
+        int getYear();
+        int getMonth();
+        rl::CeGuiString getMonthName();
+        int getDayOfYear();
+        int getDayOfMonth();
+        int getDayOfWeek();
+        rl::CeGuiString getDayOfWeekName();
+        int getHour();
+        int getMinute();
+        int getSecond();
+        int getMilliSecond();
+      
+        rl::CeGuiString toString();
+    };
+   
+    Date operator+(const RL_LONGLONG&, const Date&);
+    Date operator-(const RL_LONGLONG&, const Date&);
+
+    class RulesSubsystem 
+    {
+        public:
+             static rl::RulesSubsystem& getSingleton();
+             rl::QuestBook* getQuestBook();
+             void resetQuestBook();
+    };
+  
+    class DsaManager {
+    public:
+        RL_LONGLONG getTimestamp();
+        Date getCurrentDate();
+        void setCurrentDate(const Date& date);
+        
+        int rollD20();
+        Tripel<int> roll3D20();
+        int rollD6();
+        int roll(int d6, int d20);
+      
+        static DsaManager& getSingleton();
+        rl::Talent* getTalent(const rl::CeGuiString name) const;
+        rl::Creature* getCreature(const int id) const;
+    };
+    
+    %feature("director") GameObjectFactory; 
+    class GameObjectFactory
+    {
+    public:
+        virtual rl::GameObject* createRubyGameObject(const Ogre::String& classname, unsigned int id) = 0;
+        GameObjectFactory();
+        virtual ~GameObjectFactory();
+    };
+
+    class GameObjectManager
+    {
+    public:
+        static rl::GameObjectManager& getSingleton();
+        rl::GameObject* createGameObject(const Ogre::String& classId, unsigned int id = 0);
+        rl::GameObject* getGameObject(unsigned int id) const;
+        void setGameObjectFactory(rl::GameObjectFactory* gof);
+
+    private:
+        GameObjectManager();
+    };
+
+	enum GameEventType
+	{
+		GET_DEFAULT,
+		GET_COMBAT,
+		GET_DIALOG,
+		GET_QUEST
+	};
+	
+    class GameEventLog
+    {
+    public:
+        static rl::GameEventLog& getSingleton();
+		void logEvent(const Ogre::String& eventString, GameEventType type);
+
+    private:
+        GameEventLog();
+    };
+    
+    class GlobalProperties 
+    {
+    public:
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        bool hasProperty(const Ogre::String& key) const;
+        
+        static rl::GlobalProperties& getSingleton();
+    private:
+        GlobalProperties();
+    };
+
+    %feature("director") QuestListener; 
+    class QuestListener
+    {
+    public:
+        virtual ~QuestListener();
+        
+        virtual void questStateChanged(rl::QuestEvent* anEvent) = 0;
+        virtual void questPartsDoneChanged(rl::QuestEvent* anEvent) = 0;
+        virtual void questKnownChanged(rl::QuestEvent* anEvent) = 0;
+        virtual void questSubquestAdded(rl::QuestEvent* anEvent) = 0;
+        virtual void journalEntryAdded(rl::JournalEvent* anEvent) = 0;
+        virtual void journalEntryDeleted(rl::JournalEvent* anEvent) = 0;
+    };
+
+    class JournalEntry
+    {
+    public:
+        JournalEntry(const rl::CeGuiString caption, const rl::CeGuiString text);
+        virtual ~JournalEntry();
+
+        rl::CeGuiString getCaption() const;
+
+        rl::CeGuiString getText() const;
+    };
+    
+    class Quest
+    {
+    public:
+        enum State
+        {
+            OPEN = 0,
+            ASSIGNED,
+            FAILED,
+            SUCCEEDED,
+            COMPLETED
+        };
+
+        Quest(const rl::CeGuiString id, const rl::CeGuiString name, const rl::CeGuiString description);
+        virtual ~Quest();
+
+        const rl::CeGuiString getId();
+        const rl::CeGuiString getName();
+        const rl::CeGuiString getDescription();
+        int getPartsToDo();
+        void setPartsToDo(int partsToDo);
+        int getPartsDone();
+        void setPartsDone(int partsDone);
+        void increasePartsDone(int parts = 1);
+        void decreasePartsDone(int parts = 1);
+
+        rl::Quest::State getState();
+        void setState(rl::Quest::State state);
+        bool isKnown();
+        void setKnown(bool known);
+
+        // QuestVector getSubquests();
+        void addSubquest(rl::Quest* quest); 
+    };   
+    
+    class QuestEvent
+    {
+    public:
+        rl::Quest* getQuest();
+    private:
+        QuestEvent( rl::QuestBook* src, int reason );
+    };
+    
+    class QuestBook
+    {
+    public:
+        rl::Quest* getQuest(const rl::CeGuiString id);
+        void addQuest(rl::Quest* quest);
+        
+        void addJournalEntry(rl::JournalEntry* entry);
+        void addJournalEntry(rl::CeGuiString caption, rl::CeGuiString text);
+        
+        void addQuestListener(rl::QuestListener* listener);
+        void removeQuestListener(rl::QuestListener* listener);
+    };
+    
+    class Talent
+    {
+    public:
+        typedef std::map<const rl::CeGuiString,int> AusweichTalente;
+        Talent(const rl::CeGuiString name,
+               const rl::CeGuiString description,
+               const Tripel<rl::CeGuiString>& eigenschaften,
+               int ebe,
+               int gruppe,
+               const rl::CeGuiString art,
+               const AusweichTalente &ausweichTalente);
+
+        bool operator==(const Talent& rhs) const;
+        bool operator<(const Talent& rhs) const;
+        rl::CeGuiString getName() const;
+        rl::CeGuiString getDescription() const;
+        int getEbe() const;
+
+        /// Berechnet effektive Behinderung bei gegebener Behinderung;
+        int calculateEbe(int be) const;
+        Tripel<rl::CeGuiString> getEigenschaften() const;
+    };
+
+    class ActionGroup
+    {
+    public:
+        ActionGroup(rl::CeGuiString name, ActionGroup* parent = NULL);
+        ~ActionGroup();
+    
+        const rl::CeGuiString getName() const;
+    };
+    
+    %feature("director") Action;   
+    class Action
+    {
+    public:
+        static const int ACT_NORMAL = 1<<0;
+        static const int ACT_INVIS_DESC = 1<<1;
+        static const int ACT_DISABLED = 1<<2;
+        static const int ACT_NEEDS_TALENT = 1<<8;
+
+        static const int TC_NO_TARGET = 0;
+        static const int TC_GAMEOBJECT = 1;
+        static const int TC_CREATURE = 2;
+        static const int TC_ITEM = 3;
+        static const int TC_POINT = 4;
+        static const int TC_RADIUS = 5;
+        static const int TC_POINT_AND_RADIUS = 6;
+    
+        Action(const rl::CeGuiString name, const rl::CeGuiString description);
+        virtual ~Action();
+
+        virtual const rl::CeGuiString getName() const;
+        //virtual const rl::CeGuiString getClassName() const;
+        virtual const rl::CeGuiString getDescription() const;
+        virtual int getTargetClass() const;
+        virtual void doAction(rl::GameObject *object, rl::Creature *actor,
+            rl::GameObject *target);
+        virtual bool canDo(rl::GameObject* object, rl::Creature* actor) const;
+            
+        void setGroup(rl::ActionGroup* group);
+        rl::ActionGroup* getGroup() const;
+    };
+    
+    %feature("director") ObjectStateChangeListener;      
+    class ObjectStateChangeListener      
+    {      
+    public:      
+        virtual ~ObjectStateChangeListener();      
+               
+        virtual void objectStateChanged(rl::ObjectStateChangeEvent *anEvent) = 0;      
+    };
+              
+               
+    class ObjectStateChangeEventSource      
+    {      
+    public:      
+        ObjectStateChangeEventSource( );      
+               
+        void addObjectStateChangeListener( rl::ObjectStateChangeListener*  list );      
+        void removeObjectStateChangeListener( rl::ObjectStateChangeListener* list );      
+        bool hasListeners( ) const;      
+        rl::GameObject* getObject() const;
+        void fireObjectStateChangeEvent();      
+    };      
+               
+    class ObjectStateChangeEvent      
+    {      
+    public:      
+        ObjectStateChangeEvent( rl::ObjectStateChangeEventSource* src );      
+        rl::GameObject* getProvokingObject() const;      
+        rl::ObjectStateChangeEventSource* getSource() const;      
+    };
+            
+    enum GameObjectState
+    {
+        GOS_UNDEFINED = 0,
+        GOS_UNLOADED,
+        GOS_LOADED,
+        GOS_IN_POSSESSION,
+        GOS_IN_SCENE,
+        GOS_HELD,
+        GOS_READY
+    };
+    
+    class PropertyRecord
+    {
+    public:
+        PropertyRecord();
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+    };
+    
+    %constant unsigned long QUERYFLAG_GAMEOBJECT = rl::QUERYFLAG_GAMEOBJECT;
+    %constant unsigned long QUERYFLAG_CREATURE = rl::QUERYFLAG_CREATURE;
+    %constant unsigned long QUERYFLAG_ITEM = rl::QUERYFLAG_ITEM;
+    %constant unsigned long QUERYFLAG_CONTAINER = rl::QUERYFLAG_CONTAINER;
+    %constant unsigned long QUERYFLAG_WEAPON = rl::QUERYFLAG_WEAPON;
+    %constant unsigned long QUERYFLAG_ARMOR = rl::QUERYFLAG_ARMOR;
+    %constant unsigned long QUERYFLAG_PERSON = rl::QUERYFLAG_PERSON;
+    %constant unsigned long QUERYFLAG_PLAYER = rl::QUERYFLAG_PLAYER;
+    
+    %feature("director") GameObject;
+    class GameObject: public ObjectStateChangeEventSource
+    {
+    public:
+        GameObject(unsigned int id);
+        virtual ~GameObject();
+
+        virtual unsigned int getId();
+
+        virtual const rl::CeGuiString getName() const;
+        virtual void setName(rl::CeGuiString name);
+
+        const rl::CeGuiString getDescription() const;
+        virtual void setDescription(rl::CeGuiString description);   
+        
+        void setActor(rl::Actor* actor);
+        rl::Actor* getActor();
+
+        void addAction(rl::Action *action, int option = ACT_NORMAL);
+        void addActionInGroup(Action* action, ActionGroup* group, int option = ACT_NORMAL);
+        void removeAction(rl::Action *action);
+
+        const std::vector<Action*> getValidActions(rl::Creature *actor) const;        
+        void setPosition(const Ogre::Vector3& position);
+        void setOrientation(const Ogre::Quaternion& orientation);
+        const Ogre::Quaternion& getOrientation() const;
+        const Ogre::Vector3& getPosition() const;
+        
+        void setMeshfile(rl::CeGuiString meshfile);
+        
+        virtual Action* getDefaultAction(rl::Creature* actor) const;
+        
+        void doAction(
+            const rl::CeGuiString actionName, 
+            rl::Creature* actor,
+            rl::GameObject* target);
+        void doAction(
+            const rl::CeGuiString actionName);
+        void doAction(rl::Action* action, rl::Creature* actor,
+            rl::GameObject* target);
+            
+        void doDefaultAction(rl::Creature* actor, rl::GameObject* target);
+            
+        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
+        static const rl::CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
+        
+        bool isHighlightingEnabled();
+        void setHighlightingEnabled( bool highlightenabled );
+        
+        void addEffect(rl::Effect* effect);
+        void addEffectWithCheckTime(rl::Effect* effect, RL_LONGLONG time);
+        void addEffectWithCheckDate(rl::Effect* effect, RL_LONGLONG date);
+        void removeEffect(rl::Effect* effect);
+        
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        
+        virtual void placeIntoScene();
+        void removeFromScene();
+        
+        rl::GameObjectState getState() const;
+        void setState(rl::GameObjectState state);
+        
+        unsigned long getQueryFlags() const;
+        void addQueryFlag(unsigned long queryflag);
+        void setQueryFlags(unsigned long queryflags);
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+    class WaitJob : public rl::Job
+    {
+    public:
+        WaitJob(const rl::Date& dsatime);
+        WaitJob(const Ogre::Real& realtime);
+    };
+    
+    class GoToJob : public rl::Job
+    {
+    public:
+
+		GoToJob(rl::Creature* actor, const Ogre::Vector3& targetPos,
+			Ogre::Real maxDistance, Ogre::Real duration);
+		// Unclear what version is called from ruby, so uncomment second ctor.
+		//GoToJob(rl::Creature* actor, rl::GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
+    };
+    
+    %feature("director") Item;
+    class Item : public rl::GameObject {
+    public:
+        enum ItemType{
+            ITEMTYPE_WEAPON     = 1 << 0,
+            ITEMTYPE_SHIELD     = 1 << 1,
+            ITEMTYPE_RING       = 1 << 2,
+            ITEMTYPE_GLOVES     = 1 << 3,
+            ITEMTYPE_BRACELET   = 1 << 4,
+            ITEMTYPE_ARMOR      = 1 << 5,
+            ITEMTYPE_CAPE       = 1 << 6,
+            ITEMTYPE_BRACERS    = 1 << 7,
+            ITEMTYPE_BACKPACK   = 1 << 8,
+            ITEMTYPE_BELT       = 1 << 9,
+            ITEMTYPE_NECKLACE   = 1 << 10,
+            ITEMTYPE_HELMET     = 1 << 11,
+            ITEMTYPE_TROUSERS   = 1 << 12,
+            ITEMTYPE_SHINBONE   = 1 << 13,
+            ITEMTYPE_BOOTS      = 1 << 14,
+            ITEMTYPE_CLOTHES    = 1 << 15,
+            ITEMTYPE_OTHER      = 1 << 16,
+            ITEMTYPE_ALL_ITEMS  = ~(0)
+        };
+    
+        Item(unsigned int id);
+        virtual ~Item();
+        
+        virtual void placeIntoScene();
+        
+        void setItemType(rl::Item::ItemType itemType);
+        rl::Item::ItemType getItemType() const;
+        virtual void setState(rl::GameObjectState state);
+        virtual void removeOldState();
+
+        void setParentSlot(rl::Slot* slot);
+        rl::Slot* getParentSlot() const;
+
+        void setParentContainer(rl::Container* cont);
+        rl::Container* getParentContainer() const;
+
+        void setOwner(rl::GameObject* go);
+        rl::GameObject* getOwner() const;
+
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        virtual bool isContainer();
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+    %feature("director") Weapon;
+    class Weapon : public rl::Item 
+    {
+    public:
+        enum Distanzklasse { DK_H=0, DK_N, DK_S, DK_P };
+
+        Weapon(unsigned int id);
+        virtual ~Weapon();
+                
+        void setTp(int d6, int d20, int mod);
+        const Tripel<int>& getTp() const;
+        void setTpKk(int base, int step);
+        const std::pair<int, int>& getTpKk() const;
+        void setBf(int newBf);
+        int getBf();
+        void setIni(int newIni);
+        int getIni();
+        void setWm(std::pair<int, int>& newWm);
+        const std::pair<int,int>& getWm() const;
+        void setDk(Weapon::Distanzklasse newDk);
+        Weapon::Distanzklasse getDk();
+        void setKampftechnik(const rl::CeGuiString newKampftechnik);
+        const rl::CeGuiString getKampftechnik() const;
+
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+    %feature("director") Armor;
+    class Armor : public Item
+    {
+    public:
+    
+        static const CeGuiString Armor::PROPERTY_G_BE = "g_be";
+        static const CeGuiString Armor::PROPERTY_G_RS = "g_rs";
+        
+        Armor(unsigned int id);
+        virtual ~Armor();
+
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+    %feature("director") Container;
+    class Container : public Item
+    {
+    public:
+        Container(unsigned int id);
+        virtual ~Container();
+
+        Ogre::Real getCapacity() const;
+        void setCapacity(Ogre::Real capacity);
+        void setVolume(unsigned int x, unsigned int y);
+        Ogre::Real getContentWeight() const;
+        void addItem(rl::Item* item);
+        void removeItem(rl::Item* item);
+        rl::ItemSet getItems() const;
+        int getItemCount() const;
+        rl::Item* getItemAt(unsigned int x, unsigned int y);
+
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+    };
+    
+
+    %feature("director") Effect;
+    class Effect
+    {
+    public:    
+        typedef unsigned long LifeState;
+        static const LifeState LS_NONE           = 1<<0;
+        static const LifeState LS_BLIND          = 1<<1;   ///< The creature can't see anything.
+        static const LifeState LS_DEAD           = 1<<2;   ///< The creature is dead.
+        static const LifeState LS_DEAF           = 1<<3;   ///< The creature can't hear anything.
+        static const LifeState LS_PARALYZED      = 1<<4;   ///< The creature can't move, turn, jump etc.
+        static const LifeState LS_INCAPACITATED  = 1<<5;   ///< The creature can't fight anymore due to serious injuries. The creature can barely move.
+        static const LifeState LS_INVISIBLE      = 1<<6;   ///< The creature can't be seen.
+        static const LifeState LS_INVULNERABLE   = 1<<7;   ///< The creature is immune to any mundane attacks.
+        static const LifeState LS_PETRIFIED      = 1<<8;   ///< The creature is coated with stone and has all the effects of paralyzation
+        static const LifeState LS_SILENCED       = 1<<9;   ///< The creature doesn't make any noises.
+        static const LifeState LS_SLEEPING       = 1<<10;  ///< The creature is asleep.
+        static const LifeState LS_UNCONSCIOUS    = 1<<11;  ///< Like SLEEPING, but more difficult to wake.
+
+        // Meta stati
+        static const LifeState LS_IMMOBILE = LS_PARALYZED | LS_SLEEPING | LS_UNCONSCIOUS | LS_PETRIFIED | LS_DEAD;
+        static const LifeState LS_NO_COMBAT = LS_IMMOBILE | LS_INCAPACITATED;
+
+        typedef int ModType;
+        static const ModType MODTYPE_NONE         = 1 << 0;
+        static const ModType MODTYPE_SUM      = 1 << 1;   ///< Modifies the actual value.
+        static const ModType MODTYPE_PROBENMOD    = 1 << 2;   ///< Modifies the test.
+        static const ModType MODTYPE_MULT     = 1 << 3;   ///< Will be multiplied on the value.
+        static const ModType MODTYPE_MAXWERTMOD   = 1 << 4;   ///< Modifies only the maximum of the value.
+
+        typedef unsigned long ModTag;
+        static const ModTag MODTAG_NONE           = 1 << 0;
+        static const ModTag MODTAG_KRANKHEIT      = 1 << 1;
+        static const ModTag MODTAG_RECALCULATE    = 1 << 2;
+        static const ModTag MODTAG_REGENERATION_LE = 1 << 3;
+        static const ModTag MODTAG_REGENERATION_AE = 1 << 4;
+        static const ModTag MODTAG_REGENERATION_AU = 1 << 5;
+        static const ModTag MODTAG_ERSCHOEPFUNGSSCHWELLE = 1 << 6;
+    
+        enum Quantifier
+        {
+            QUANTIFIER_MULTIPLE,
+            QUANTIFIER_UNIQUE,
+            QUANTIFIER_UNIQUE_BUT_PROLONGABLE,
+            QUANTIFIER_UNIQUE_BUT_CUMULATIVE
+        };
+        
+      // other constants
+        static const int REMOVE = -1;
+        static const int PERMANENT = 0;
+
+
+        Effect(int stufe = 1);
+        virtual ~Effect();
+
+        const Ogre::String getName() const;
+        void setName(Ogre::String name);
+        const rl::CeGuiString getDescription() const;
+        void setDescription(rl::CeGuiString description);
+        Quantifier getQuantifier();
+        void setQuantifier(Quantifier quantifier);
+        virtual const int getStufe();
+        virtual void increaseStufe();
+        virtual void decreaseStufe();
+        virtual void enable();
+        virtual void disable();
+        virtual RL_LONGLONG timeCheck() = 0;
+
+        virtual LifeState getLifeState() const;
+        virtual int getMod(rl::CeGuiString target, ModType type, ModTag tag);
+
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+        virtual rl::PropertyKeys getAllPropertyKeys() const;
+    };
+
+    class EffectFactory
+    {
+    public:
+        virtual rl::Effect* createEffect(const Ogre::String& name, int stufe) = 0;
+    };
+
+    class EffectFactoryManager
+    {
+    public:
+        void setEffectFactory(rl::EffectFactory* factory);
+        static rl::EffectFactoryManager& getSingleton();
+    };
+
+    enum SlotType
+    {
+        SLOT_BONE,
+        SLOT_SUBMESH,
+        SLOT_MATERIAL
+    };
+
+    class Inventory 
+    {
+    private:
+        Inventory(rl::Creature* owner);
+    public:
+        void addSlot(const rl::CeGuiString& name, const Ogre::String& meshpartname, int itemReadyMask, int itemHeldMask, SlotType type = SLOT_BONE);
+        rl::Item* getItem(const rl::CeGuiString& slotName) const;
+        void hold(rl::Item* item, const rl::CeGuiString& slot);
+        void ready(rl::Item* item, const rl::CeGuiString& slot);
+        void dropItem(const rl::CeGuiString& slotName);
+    };
+
+    %feature("director") Creature;
+    class Creature : public GameObject {
+    public:
+    
+    typedef Ogre::String Wert;
+        enum Alignment
+        {
+            ALIGNMENT_ALLY,    ///< Creature fights with the player.
+            ALIGNMENT_NEUTRAL, ///< Creature doesn't fight for either side.
+            ALIGNMENT_ENEMY    ///< Creature fights against the player.
+        };
+
+        enum SfStatus
+        {
+            SFSTATUS_IN_TRAINING = 1,
+            SFSTATUS_OK,
+            SFSTATUS_REQUIREMENTS_NOT_MET /// @todo Wird das ueberhaupt gebraucht?
+        };
+
+        // some targets
+        static const std::string Creature::ALL_EIGENSCHAFTEN = "alle Eigenschaften";
+        static const std::string Creature::ALL_TALENTE = "alle Talente";
+        static const Creature::Wert Creature::WERT_MOD_AE = "ModAE";
+        static const Creature::Wert Creature::WERT_MOD_LE = "ModLE";
+        static const Creature::Wert Creature::WERT_MOD_AU = "ModAU";
+        static const Creature::Wert Creature::WERT_MOD_MR = "ModMR";
+        static const Creature::Wert Creature::WERT_MOD_AT = "ModAT";
+        static const Creature::Wert Creature::WERT_MOD_PA = "ModPA";
+        static const Creature::Wert Creature::WERT_MOD_FK = "ModFK";
+        static const Creature::Wert Creature::WERT_GS = "GS";
+        static const Creature::Wert Creature::WERT_SOZIALSTATUS = "SO";
+        static const Creature::Wert Creature::WERT_BE = "BE";
+        static const Creature::Wert Creature::WERT_RS = "RS";
+        static const Creature::Wert Creature::WERT_INI = "INI";
+        static const Creature::Wert Creature::WERT_KAMPFUNFAEHIGKEITSSCHWELLE ="Kampfunf??higkeitsschwelle"; 
+        static const Creature::Wert Creature::WERT_REGENERATION = "Regeneration";
+        
+        
+        Creature(unsigned int id);
+        virtual ~Creature();
+
+        virtual int getLe();
+        virtual void modifyLe(int mod, bool ignoreMax = false);
+        virtual void modifyAe(int mod);
+        virtual void modifyAu(int mod);
+        void setWert(Wert wertId, int value);
+        virtual int getWert(Wert wertId, bool getUnmodified = false);
+        
+        virtual int getEigenschaft(const rl::CeGuiString eigenschaftName, Effect::ModTag tag = Effect::MODTAG_NONE);
+        virtual void setEigenschaft(const rl::CeGuiString eigenschaftName, int value);
+        virtual void modifyEigenschaft(const rl::CeGuiString eigenschaftName, int mod);
+
+        
+        void addTalent(const rl::CeGuiString talentName, int value=0);
+        bool hasTalent(const rl::CeGuiString talentName, bool checkAusweichTalente = true);
+        virtual int getTalent(const rl::CeGuiString talentName);
+        virtual void setTalent(const rl::CeGuiString talentName, int value);
+        virtual void modifyTalent(const rl::CeGuiString talentName, int mod);
+        virtual void addSe(const rl::CeGuiString talentName);
+        
+        void addVorteil(const rl::CeGuiString vorteilName, int value = 0);
+        void addNachteil(const rl::CeGuiString nachteilName, int value = 0);        
+        
+        void addKampftechnik(const rl::CeGuiString kampftechnikName, std::pair<int,int> value = make_pair(0,0));
+        virtual void addSf(const rl::CeGuiString sfName, SfStatus value = SFSTATUS_IN_TRAINING);
+        
+        virtual int doTalentprobe(const rl::CeGuiString talentName, int modifier);
+        virtual int doEigenschaftsprobe(const rl::CeGuiString eigenschaftName, int modifier);
+        
+        rl::Inventory* getInventory();
+        
+        void damageLe(int tp, int damageType = LEDAMAGE_NORMAL);
+        static const int LEDAMAGE_NORMAL = 0;
+        static const int LEDAMAGE_FIRE = 1;
+        static const int LEDAMAGE_WATER = 2;
+        static const int LEDAMAGE_DEMONIC = 4;
+        void damageAu(int aup, int damageType = AUDAMAGE_NORMAL);
+        static const int AUDAMAGE_NORMAL = 0;
+        static const int AUDAMAGE_HEAT = 1;
+        static const int AUDAMAGE_COLD = 2;
+        static const int AUDAMAGE_CHOKE = 4;
+        static const int AUDAMAGE_DROWN = 8;
+
+        virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
+        virtual void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+
+        void setAlignment(Alignment);
+        Alignment getAlignment() const;
+        
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+   };
+   
+    %feature("director") ActionManager;
+    class ActionManager
+    {
+    public:
+        void registerAction(rl::Action* action);
+        void unregisterAction(const rl::CeGuiString actionName);
+        rl::Action* getAction(const rl::CeGuiString actionName) const;
+
+        void registerInGameGlobalAction(rl::Action* action, rl::ActionGroup* group);
+    
+        static rl::ActionManager& getSingleton();
+    };
+    
+    class CreatureController
+    {
+    public:
+        
+        typedef enum
+        {
+            // these movements can be used
+            MT_NONE,
+            MT_STEHEN,
+            MT_GEHEN,
+            MT_JOGGEN,
+            MT_LAUFEN,
+            MT_RENNEN,
+            MT_RUECKWAERTS_GEHEN,
+            MT_RUECKWAERTS_JOGGEN,
+            MT_SEITWAERTS_GEHEN,
+            MT_SCHLEICHEN,
+            MT_HOCHSPRUNG,
+            MT_WEITSPRUNG,
+            MT_ZIELSPRUNG,
+            // these movements are only for internal purposes and should not be used directly
+            // instead use one of the movements above
+            MT_DREHEN,
+            MT_STUFENERKENNUNG,
+            MT_FALLEN,
+            MT_LIEGEN
+        } MovementType;
+        
+        Creature *getCreature();
+        bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);
+        MovementType getMovementId() const;
+        Ogre::Vector3 getDirection() const;
+        Ogre::Vector3 getRotation() const;
+        Ogre::Vector3 getVelocity() const;
+        Ogre::Vector3 getOmega() const;
+        void setAnimation(const Ogre::String &name, 
+                          Ogre::Real speed = 1, 
+                          unsigned int timesToPlay = 0, 
+                          const Ogre::String &collisionName = "");
+    protected:
+        CreatureController(Creature *character);
+        ~CreatureController();
+    };
+    
+    class CreatureControllerManager
+    {
+    public:
+        /// Returns a CreatureController that can be used to control given Creature.
+        /// There is only one controller per Creature at a given time.
+        /// If no such controller exists yet, it is created.
+        rl::CreatureController* getCreatureController(rl::Creature* creature);
+
+        /// This function detaches a controller attached to the given Creature, if any.
+        void detachController(rl::Creature* creature);
+
+        static rl::CreatureControllerManager& getSingleton();
+    };
+
+	// Before first use of Selector or subclasses!
+    %apply SWIGTYPE *DYNAMIC { rl::Selector* };
+
+	class Selector
+    {
+    public:
+        Selector(unsigned long mask = 0xffffffff);
+        virtual void updateSelection();
+
+        void setSelectionMask(unsigned long mask);
+        unsigned long getSelectionMask() const;
+
+        GameObject* getFirstSelectedObject() const;
+		const std::vector<GameObject*>& getAllSelectedObjects() const;
+		unsigned int getSelectionCount() const;
+
+		virtual void updatePrimitive() = 0;
+    };
+
+
+    /// A Selector that selects all unoccluded GameObject the ray hits.
+    class RaySelector : public Selector
+    {
+    public:
+        RaySelector(unsigned long mask = 0xffffffff, bool useOgreQuery = false);
+        void setRay(const Ogre::Vector3& start, const Ogre::Vector3& end);
+		virtual void updatePrimitive();
+    };
+
+    /// Selects this GameObject within a half sphere pointing to -Z,
+    /// that has the smallest angle difference to the -Z-Axis.
+    class HalfSphereSelector : public Selector
+    {
+    public:
+        HalfSphereSelector(unsigned long mask = 0xffffffff);
+	    void setRadius(Ogre::Real radius);
+        void setPosition(const Ogre::Vector3& pos);
+        void setOrientation(const Ogre::Quaternion& ori);
+		virtual void updatePrimitive();
+	};
+    
+    class PartyManager
+    {
+    public:
+        void setActiveCharacter(Creature* character);
+        Creature* getActiveCharacter() const;
+        void addCharacter(Creature* character);
+        void removeCharacter(Creature* character);
+        static PartyManager& getSingleton();
+    };
+
+} // Namespace
+
+%{
+static swig_type_info *Selector_dynamic_cast(void **ptr)
+{
+	rl::Selector *pSelector = static_cast<rl::Selector*>(*ptr);
+	rl::HalfSphereSelector *pHalfSphereSel = dynamic_cast<rl::HalfSphereSelector*>(pSelector);
+	if (pHalfSphereSel)
+	{
+		*ptr = pHalfSphereSel;
+		return SWIGTYPE_p_rl__HalfSphereSelector;
+	}
+	rl::RaySelector *pRaySel = dynamic_cast<rl::RaySelector*>(pSelector);
+	if (pRaySel)
+	{
+		*ptr = pRaySel;
+		return SWIGTYPE_p_rl__RaySelector;
+	}
+}
+	
+static swig_type_info *GameObject_dynamic_cast(void **ptr)
+{
+    rl::GameObject *pGameObject = static_cast<rl::GameObject*>(*ptr);
+
+    rl::Creature *pCreature=dynamic_cast<rl::Creature*>(pGameObject);
+    if (pCreature) {
+        *ptr=pCreature;
+        return SWIGTYPE_p_rl__Creature;
+    }
+    rl::Weapon *pWeapon=dynamic_cast<rl::Weapon*>(pGameObject);
+    if (pWeapon) {
+        *ptr=pWeapon;
+        return SWIGTYPE_p_rl__Weapon;
+    }
+    rl::Armor *pArmor=dynamic_cast<rl::Armor*>(pGameObject);
+    if (pArmor) {
+        *ptr=pArmor;
+        return SWIGTYPE_p_rl__Armor;
+    }
+    rl::Container *pContainer=dynamic_cast<rl::Container*>(pGameObject);
+    if (pContainer) {
+        *ptr=pContainer;
+        return SWIGTYPE_p_rl__Container;
+    }
+    rl::Item *pItem=dynamic_cast<rl::Item*>(pGameObject);
+    if (pItem) {
+        *ptr=pItem;
+        return SWIGTYPE_p_rl__Item;
+    }
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__GameObject, GameObject_dynamic_cast);
+

Modified: rl/branches/newton20/engine/script/swig/RlUi.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/RlUi.swig	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/script/swig/RlUi.swig	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,162 +1,159 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-namespace rl {
-
-%apply SWIGTYPE *DYNAMIC { rl::ControlState * };
-
-%feature("director") ControlState;
-class ControlState
-{
-private:
-    ControlState(rl::Actor* camera, rl::Actor* character);
-public:
-};
-
-class CutsceneControlState : public ControlState
-{
-private:
-       CutsceneControlState(rl::Actor* camera);
-
-public:
-    virtual ~CutsceneControlState();
-
-    void setCameraPosition(const Ogre::Vector3& pos);
-    void setCameraOrientation(const Ogre::Quaternion& orient);
-    void lookAt(const Ogre::Vector3& point);
-};
-
-class UiSubsystem
-{
-public:
-    static UiSubsystem& getSingleton(void);
-    void initializeSubsystem();
-
-    rl::Creature* getActiveCharacter();
-    void setActiveCharacter(rl::Creature* chara);
-};
-
-enum ControlStateType 
-{
-    CST_NONE = 1,
-    CST_FREEFLIGHT,
-    CST_MOVEMENT,
-    CST_DIALOG,
-    CST_CUTSCENE,
-    CST_COMBAT,
-};
-
-class InputManager
-{
-public:
-    static InputManager& getSingleton(void);
-
-    void pushControlState(rl::ControlStateType);
-    void popControlState();
-
-    void linkKeyToRubyCommand(const rl::CeGuiString &key, const rl::CeGuiString &command);
-private:
-    InputManager();
-};
-
-class WindowFactory
-{
-public:
-    enum PopupType
-    {
-        ICON_ERROR = 1,
-        ICON_QUEST
-    };
-
-    static rl::WindowFactory& getSingleton();
-
-    void update();
-
-    void showAboutWindow();
-    void showActionChoice(rl::GameObject* obj);
-    void showCharacterActionChoice();
-    void showCharacterSheet();
-    void showCharacterSheet(rl::Creature* chara);
-    void showContainerContent(rl::Container* container);
-    void showDescriptionWindow(rl::GameObject* obj);
-    void showPropertiesWindow(rl::GameObject* obj);
-    void showGameSaveLoadWindow();
-    void showExitConfirmation();
-    void showJournalWindow();
-    void showLogfiles();
-    void showMainMenu();
-    void showMessageWindow(const rl::CeGuiString& message);
-    void showPlaylist();
-    void showPopupMessage(int popupTypes);
-    void showGameSettings();
-
-    void toggleConsole();
-    void toggleDebugWindow();
-    void toggleGameLogWindow();
-    void toggleCharacterStateWindow();
-    void toggleInGameGlobalMenu();
-    void toggleInventoryWindow();
-
-    void checkForErrors();
-    rl::GameLoggerWindow* getGameLogger();
-
-    void showNextDebugWindowPage();
-};
-
-class WindowManager
-{
-public:
-    static rl::WindowManager& getSingleton();
-    void closeTopWindow();
-};
-
-%feature("director") MessageWindow; 
-class MessageWindow
-{
-public:
-    enum Buttons 
-    {
-        OK,
-        YES_NO
-    };
-
-    MessageWindow::MessageWindow(
-        const rl::CeGuiString& title, 
-        const rl::CeGuiString& text, 
-        const Buttons buttons);
-    virtual ~MessageWindow();
-    virtual bool onButtonClicked(int button, const rl::CeGuiString& text);
-    void setVisible(bool visible);
-};
-
-} //namespace rl
-
-%{
-static swig_type_info *ControlState_dynamic_cast(void **ptr)
-{
-    rl::ControlState *pControlState =
-        static_cast<rl::ControlState*>(*ptr);
-
-    rl::CutsceneControlState *pCutSceneCS =
-        dynamic_cast<rl::CutsceneControlState*>(pControlState);
-    if (pCutSceneCS != NULL) {
-        *ptr=pCutSceneCS;
-        return SWIGTYPE_p_rl__CutsceneControlState;
-    }
-    return 0;
-}
-%}
-DYNAMIC_CAST(SWIGTYPE_p_rl__ControlState, ControlState_dynamic_cast);
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+namespace rl {
+
+%apply SWIGTYPE *DYNAMIC { rl::ControlState * };
+
+%feature("director") ControlState;
+class ControlState
+{
+private:
+    ControlState(rl::Actor* camera, rl::Actor* character);
+public:
+};
+
+class CutsceneControlState : public ControlState
+{
+private:
+       CutsceneControlState(rl::Actor* camera);
+
+public:
+    virtual ~CutsceneControlState();
+
+    void setCameraPosition(const Ogre::Vector3& pos);
+    void setCameraOrientation(const Ogre::Quaternion& orient);
+    void lookAt(const Ogre::Vector3& point);
+};
+
+class UiSubsystem
+{
+public:
+    static UiSubsystem& getSingleton(void);
+    void initializeSubsystem();
+};
+
+enum ControlStateType 
+{
+    CST_NONE = 1,
+    CST_FREEFLIGHT,
+    CST_MOVEMENT,
+    CST_DIALOG,
+    CST_CUTSCENE,
+    CST_COMBAT,
+};
+
+class InputManager
+{
+public:
+    static InputManager& getSingleton(void);
+
+    void pushControlState(rl::ControlStateType);
+    void popControlState();
+
+    void linkKeyToRubyCommand(const rl::CeGuiString &key, const rl::CeGuiString &command);
+private:
+    InputManager();
+};
+
+class WindowFactory
+{
+public:
+    enum PopupType
+    {
+        ICON_ERROR = 1,
+        ICON_QUEST
+    };
+
+    static rl::WindowFactory& getSingleton();
+
+    void update();
+
+    void showAboutWindow();
+    void showActionChoice(rl::GameObject* obj);
+    void showCharacterActionChoice();
+    void showCharacterSheet();
+    void showCharacterSheet(rl::Creature* chara);
+    void showContainerContent(rl::Container* container);
+    void showDescriptionWindow(rl::GameObject* obj);
+    void showPropertiesWindow(rl::GameObject* obj);
+    void showGameSaveLoadWindow();
+    void showExitConfirmation();
+    void showJournalWindow();
+    void showLogfiles();
+    void showMainMenu();
+    void showMessageWindow(const rl::CeGuiString& message);
+    void showPlaylist();
+    void showPopupMessage(int popupTypes);
+    void showGameSettings();
+
+    void toggleConsole();
+    void toggleDebugWindow();
+    void toggleGameLogWindow();
+    void toggleCharacterStateWindow();
+    void toggleInGameGlobalMenu();
+    void toggleInventoryWindow();
+
+    void checkForErrors();
+    rl::GameLoggerWindow* getGameLogger();
+
+    void showNextDebugWindowPage();
+};
+
+class WindowManager
+{
+public:
+    static rl::WindowManager& getSingleton();
+    void closeTopWindow();
+};
+
+%feature("director") MessageWindow; 
+class MessageWindow
+{
+public:
+    enum Buttons 
+    {
+        OK,
+        YES_NO
+    };
+
+    MessageWindow::MessageWindow(
+        const rl::CeGuiString& title, 
+        const rl::CeGuiString& text, 
+        const Buttons buttons);
+    virtual ~MessageWindow();
+    virtual bool onButtonClicked(int button, const rl::CeGuiString& text);
+    void setVisible(bool visible);
+};
+
+} //namespace rl
+
+%{
+static swig_type_info *ControlState_dynamic_cast(void **ptr)
+{
+    rl::ControlState *pControlState =
+        static_cast<rl::ControlState*>(*ptr);
+
+    rl::CutsceneControlState *pCutSceneCS =
+        dynamic_cast<rl::CutsceneControlState*>(pControlState);
+    if (pCutSceneCS != NULL) {
+        *ptr=pCutSceneCS;
+        return SWIGTYPE_p_rl__CutsceneControlState;
+    }
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__ControlState, ControlState_dynamic_cast);

Modified: rl/branches/newton20/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/branches/newton20/engine/ui/RlUI2005.vcproj	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/RlUI2005.vcproj	2008-09-19 08:22:31 UTC (rev 4519)
@@ -377,6 +377,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\GameOverWindow.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\InputManager.h"
 				>
 			</File>
@@ -598,6 +602,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\GameOverWindow.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\InputManager.cpp"
 				>
 			</File>

Copied: rl/branches/newton20/engine/ui/include/GameOverWindow.h (from rev 4518, rl/trunk/engine/ui/include/GameOverWindow.h)

Modified: rl/branches/newton20/engine/ui/include/Makefile.am
===================================================================
--- rl/branches/newton20/engine/ui/include/Makefile.am	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/include/Makefile.am	2008-09-19 08:22:31 UTC (rev 4519)
@@ -21,6 +21,7 @@
     FreeflightControlState.h \
     GameLoggerWindow.h \
     GameObjectInfoWindow.h \
+	GameOverWindow.h \
 	GameSaveLoadWindow.h \
     GameSettings.h \
     InfoPopup.h \

Modified: rl/branches/newton20/engine/ui/include/UiMessages.h
===================================================================
--- rl/branches/newton20/engine/ui/include/UiMessages.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/include/UiMessages.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -37,10 +37,7 @@
 
         RLMSG_COMBAT_IO_ATTACK_OPPONENT = 0x04000103,
         RLMSG_COMBAT_IO_PARRY_OPPONENT = 0x04000104,
-        RLMSG_COMBAT_IO_END_TURN_REQUESTED = 0x04000105,
-
-        // Character change
-        RLMSG_ACTIVE_CHARACTER_CHANGED = 0x04000201
+        RLMSG_COMBAT_IO_END_TURN_REQUESTED = 0x04000105
     };
 
     /// Message sent after enemy action button has been pressed.
@@ -53,7 +50,5 @@
     typedef MessageType<RLMSG_COMBAT_IO_ATTACK_OPPONENT, Combatant*> MessageType_CombatIoAttackOpponent;
     typedef MessageType<RLMSG_COMBAT_IO_PARRY_OPPONENT, Combatant*> MessageType_CombatIoParryOpponent;
     typedef MessageType<RLMSG_COMBAT_IO_END_TURN_REQUESTED> MessageType_CombatIoEndTurnRequested;
-
-    typedef MessageType<RLMSG_ACTIVE_CHARACTER_CHANGED, Creature*> MessageType_ActiveCharacterChanged;
 }
 #endif

Modified: rl/branches/newton20/engine/ui/include/UiSubsystem.h
===================================================================
--- rl/branches/newton20/engine/ui/include/UiSubsystem.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/include/UiSubsystem.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,84 +1,89 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __UiSubsystem_H__
-#define __UiSubsystem_H__
-
-#include "UiPrerequisites.h"
-#include "World.h"
-
-
-#include "ControlState.h"
-#include "MessagePump.h"
-
-// Gar nicht sch?n, aber ansonsten gibt es unn?tige Abh?ngigkeiten,
-// wenn man die Header hier inkludiert.
-namespace CEGUI {
-    class OgreCEGUIRenderer;
-    class OgreCEGUIResourceProvider;
-    class System;
-}
-
-namespace rl {
-
-    class Creature;
-    class GameActor;
-    class GameObject;
-    class InputManager;
-    class WindowFactory;
-    class WindowManager;
-
-    class _RlUiExport UiSubsystem : public Ogre::Singleton<UiSubsystem>
-    {
-    public:
-        static const char* CEGUI_ROOT;
-
-        /** Default Constructor */
-        UiSubsystem();
-        /** Default Deconstructor */
-        virtual ~UiSubsystem();
-
-        CEGUI::OgreCEGUIRenderer* getGUIRenderer();
-        Creature* getActiveCharacter() const;
-        ///@todo function feels misplaced here,
-        void setActiveCharacter(Creature* person);
-
-        virtual bool onBeforeClearScene();
-        virtual bool onBeforeGameObjectsLoaded();
-        virtual bool onGameObjectsLoaded();
-
-        void initializeSubsystem();
-
-    private:
-        Creature* mCharacter;
-        int mCharacterId;
-
-	    MessagePump::ScopedConnection mSceneClearingConnection;
-        MessagePump::ScopedConnection mGameObjectsLoadedConnection;
-        MessagePump::ScopedConnection mBeforeLoadingGameObjectsConnection;
-
-        // Singletons
-        InputManager* mInputManager;
-        WindowFactory* mWindowFactory;
-        WindowManager* mWindowManager;
-
-        CEGUI::OgreCEGUIRenderer* mGuiRenderer;
-        CEGUI::ResourceProvider* mGuiResourceProvider;
-        CEGUI::System* mGuiSystem;
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __UiSubsystem_H__
+#define __UiSubsystem_H__
+
+#include "UiPrerequisites.h"
+#include "World.h"
+
+
+#include "ControlState.h"
+#include "MessagePump.h"
+#include "Effect.h"
+
+// Gar nicht sch??n, aber ansonsten gibt es unn??tige Abh???ngigkeiten,
+// wenn man die Header hier inkludiert.
+namespace CEGUI {
+    class OgreCEGUIRenderer;
+    class OgreCEGUIResourceProvider;
+    class System;
+}
+
+namespace rl {
+
+    class Creature;
+    class GameActor;
+    class GameObject;
+    class InputManager;
+    class WindowFactory;
+    class WindowManager;
+
+    class _RlUiExport UiSubsystem : public Ogre::Singleton<UiSubsystem>
+    {
+    public:
+        static const char* CEGUI_ROOT;
+
+        /** Default Constructor */
+        UiSubsystem();
+        /** Default Deconstructor */
+        virtual ~UiSubsystem();
+
+        CEGUI::OgreCEGUIRenderer* getGUIRenderer();
+
+        void initializeSubsystem();
+
+    private:
+        Creature* mCharacter;
+        int mCharacterId;
+
+	    MessagePump::ScopedConnection mSceneClearingConnection;
+        MessagePump::ScopedConnection mGameObjectsLoadedConnection;
+        MessagePump::ScopedConnection mBeforeLoadingGameObjectsConnection;
+        MessagePump::ScopedConnection mActiveCharacterChangedConnection;
+        MessagePump::ScopedConnection mAllPlayerCharactersDiedConnection;
+
+        bool onBeforeClearScene();
+        bool onBeforeGameObjectsLoaded();
+        bool onGameObjectsLoaded();
+        ///@todo function feels misplaced here,
+        bool onActiveCharacterChanged(Creature* oldActive, Creature* newActive);
+        bool onAllPlayerCharactersDied();
+        
+
+        // Singletons
+        InputManager* mInputManager;
+        WindowFactory* mWindowFactory;
+        WindowManager* mWindowManager;
+
+        CEGUI::OgreCEGUIRenderer* mGuiRenderer;
+        CEGUI::ResourceProvider* mGuiResourceProvider;
+        CEGUI::System* mGuiSystem;
+        
+    };
+}
+
+#endif

Modified: rl/branches/newton20/engine/ui/include/WindowFactory.h
===================================================================
--- rl/branches/newton20/engine/ui/include/WindowFactory.h	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/include/WindowFactory.h	2008-09-19 08:22:31 UTC (rev 4519)
@@ -86,6 +86,7 @@
         void showMainMenuLoadWindow(MainMenuWindow* win);
 		void hideMainMenuLoadWindow();
         void showPopupMessage(int popupTypes);
+        void showGameOverWindow();
         /**
          * Creates a GameSettings object and displays its layout file on screen
          */

Modified: rl/branches/newton20/engine/ui/src/DebugWindow.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/DebugWindow.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/src/DebugWindow.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,235 +1,236 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "UiPrerequisites.h"
-
-#include "UiSubsystem.h"
-#include "DebugWindow.h"
-#include "InputManager.h"
-#include "GameLoop.h"
-
-#include "Actor.h"
-#include "ActorManager.h"
-#include "CameraObject.h"
-#include "CoreSubsystem.h"
-#include "Creature.h"
-#include "Exception.h"
-#include "MeshObject.h"
-
-using namespace CEGUI;
-using namespace Ogre;
-
-template<> rl::DebugWindow* Ogre::Singleton<rl::DebugWindow>::ms_Singleton = 0;
-
-namespace rl
-{
-    DebugWindow::DebugWindow() : AbstractWindow("debugwindow.xml", WIT_NONE),
-          mMessageText(),
-          mPageCaption(),
-          mPageText(),
-          mPageTexts(),
-          mCurrentPage(StringUtil::BLANK),
-          mDebugPageName("General Informations")
-    {
-        mPageCaption = getWindow("DebugWindow/PageCaption");
-        mPageCaption->moveToFront();
-
-        mPageText = getMultiLineEditbox("DebugWindow/PageText");
-
-        mMessageText = getWindow("DebugWindow/MessageText");
-        mMessageText->moveToFront();
-
-        bindDestroyWindowToXButton();
-        registerPage("General Informations");
-    }
-
-    DebugWindow::~DebugWindow()
-    {
-        unregisterPage("General Informations");
-    }
-
-    void DebugWindow::registerPage(const Ogre::String& page)
-    {
-        if (mPageTexts.find(page) != mPageTexts.end())
-        {
-            LOG_ERROR("DebugWindow", page + " already registered as a page.");
-        }
-        else
-        {
-            mPageTexts.insert(make_pair(page, StringUtil::BLANK));
-        }
-
-        // If this is the first page, activate it
-        if (mCurrentPage == StringUtil::BLANK)
-        {
-            mCurrentPage = page;
-        }
-    }
-
-    void DebugWindow::unregisterPage(const Ogre::String& page)
-    {
-        PageTextMap::iterator it = mPageTexts.find(page);
-        if (it != mPageTexts.end())
-        {
-            mPageTexts.erase(it);
-        }
-        else
-        {
-            Throw(IllegalArgumentException, page + " is not registered as a page.");
-        }
-
-        // If this is the current page, switch over to the next
-        // or clear text, if no other page is left.
-        if (mCurrentPage == page && !mPageTexts.empty())
-        {
-            mCurrentPage = page;
-        }
-        else if (mCurrentPage == page)
-        {
-            mCurrentPage = StringUtil::BLANK;
-        }
-        updatePageText();
-    }
-
-    void DebugWindow::setPageText(const Ogre::String& page, const Ogre::String& text)
-    {
-        PageTextMap::iterator it = mPageTexts.find(page);
-        if (it == mPageTexts.end())
-        {
-            LOG_ERROR("DebugWindow", page + " is not registered as a page.");
-        }
-        else
-        {
-            it->second = text;
-        }
-
-        if (mCurrentPage == page)
-        {
-            updatePageText();
-        }
-    }
-
-    void DebugWindow::setMessageText(const Ogre::String& text)
-    {
-        CeGuiString o(text.c_str());
-        mMessageText->setText(o);
-    }
-
-    void DebugWindow::showNextPage()
-    {
-        PageTextMap::iterator it = mPageTexts.find(mCurrentPage);
-        if (it != mPageTexts.end())
-        {
-            ++it;
-            if (it == mPageTexts.end())
-            {
-                it = mPageTexts.begin();
-            }
-            mCurrentPage = it->first;
-            updatePageText();
-        }
-        else
-        {
-            RlAssert1(mPageTexts.empty());
-        }
-    }
-
-    void DebugWindow::run(Ogre::Real elapsedTime)
-    {
-        updateFps();
-    }
-
-    void DebugWindow::updatePageText()
-    {
-        Ogre::String text = mCurrentPage == StringUtil::BLANK ?
-            StringUtil::BLANK : mPageTexts[mCurrentPage];
-        mPageCaption->setText(mCurrentPage);
-        mPageText->setText(text);
-    }
-
-    void DebugWindow::updateFps()
-    {
-        const RenderTarget::FrameStats& stats = CoreSubsystem::getSingleton().getRenderWindow()->getStatistics();
-
-        Ogre::String textSt = "Current FPS: " +
-            StringConverter::toString(stats.lastFPS)+
-            "\nBest/worst/avg FPS: " +
-            StringConverter::toString(stats.bestFPS) + "/" +
-            StringConverter::toString(stats.worstFPS) + "/" +
-            StringConverter::toString(stats.avgFPS)+
-            "\nBest/worst Frame times: " +
-            StringConverter::toString(stats.bestFPS) + "/" +
-            StringConverter::toString(stats.worstFPS)+
-            "\nTriangle Count: " +
-            StringConverter::toString(stats.triangleCount);
-
-        if (UiSubsystem::getSingleton().getActiveCharacter() != NULL &&
-            UiSubsystem::getSingleton().getActiveCharacter()->getActor() != NULL)
-        {
-            ActorControlledObject* charObj = UiSubsystem::getSingletonPtr()->
-                getActiveCharacter()->getActor()->getControlledObject();
-
-            if( charObj != NULL )
-            {
-                Ogre::Vector3 pos = charObj->getMovableObject()->getParentNode()->getWorldPosition();
-                Ogre::Quaternion ori = charObj->getMovableObject()->getParentNode()->getWorldOrientation();
-
-                textSt += "\nPlayer Position [ "
-                    + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+", "
-                    + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+", "
-                    + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+" ]";
-
-                textSt += "\nPlayer Orientation [ "
-                    + StringConverter::toString(ori.w,4,0,32,std::ios_base::fixed)+", "
-                    + StringConverter::toString(ori.x,2,0,32,std::ios_base::fixed)+", "
-                    + StringConverter::toString(ori.y,2,0,32,std::ios_base::fixed)+", "
-                    + StringConverter::toString(ori.z,2,0,32,std::ios_base::fixed)+" ]";
-            }
-        }
-
-        Actor* camActor = ActorManager::getSingleton().getActor("DefaultCamera");
-        if( camActor != 0 && camActor->_getSceneNode() != NULL )
-        {
-            Ogre::Camera* cam = dynamic_cast<CameraObject*>(camActor->getControlledObject())->getCamera();
-            Ogre::Vector3 pos = cam->getDerivedPosition();
-
-            textSt += "\nCamera Position [ "
-                + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+", "
-                + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+", "
-                + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+" ]";
-        }
-
-        setPageText(mDebugPageName, textSt);
-    }
-
-    void DebugWindow::setVisible(bool visible, bool destroyAfterHide)
-    {
-        AbstractWindow::setVisible(visible, destroyAfterHide);
-        if (visible)
-            GameLoop::getSingleton().addTask(this, GameLoop::TG_GRAPHICS);
-        else
-            GameLoop::getSingleton().removeTask(this);
-    }
-
-    const Ogre::String& DebugWindow::getName() const
-    {
-        static Ogre::String NAME = "DebugWindow";
-
-        return NAME;
-    }
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include "UiPrerequisites.h"
+
+#include "UiSubsystem.h"
+#include "DebugWindow.h"
+#include "InputManager.h"
+#include "GameLoop.h"
+
+#include "Actor.h"
+#include "ActorManager.h"
+#include "CameraObject.h"
+#include "CoreSubsystem.h"
+#include "Creature.h"
+#include "Exception.h"
+#include "MeshObject.h"
+#include "PartyManager.h"
+
+using namespace CEGUI;
+using namespace Ogre;
+
+template<> rl::DebugWindow* Ogre::Singleton<rl::DebugWindow>::ms_Singleton = 0;
+
+namespace rl
+{
+    DebugWindow::DebugWindow() : AbstractWindow("debugwindow.xml", WIT_NONE),
+          mMessageText(),
+          mPageCaption(),
+          mPageText(),
+          mPageTexts(),
+          mCurrentPage(StringUtil::BLANK),
+          mDebugPageName("General Informations")
+    {
+        mPageCaption = getWindow("DebugWindow/PageCaption");
+        mPageCaption->moveToFront();
+
+        mPageText = getMultiLineEditbox("DebugWindow/PageText");
+
+        mMessageText = getWindow("DebugWindow/MessageText");
+        mMessageText->moveToFront();
+
+        bindDestroyWindowToXButton();
+        registerPage("General Informations");
+    }
+
+    DebugWindow::~DebugWindow()
+    {
+        unregisterPage("General Informations");
+    }
+
+    void DebugWindow::registerPage(const Ogre::String& page)
+    {
+        if (mPageTexts.find(page) != mPageTexts.end())
+        {
+            LOG_ERROR("DebugWindow", page + " already registered as a page.");
+        }
+        else
+        {
+            mPageTexts.insert(make_pair(page, StringUtil::BLANK));
+        }
+
+        // If this is the first page, activate it
+        if (mCurrentPage == StringUtil::BLANK)
+        {
+            mCurrentPage = page;
+        }
+    }
+
+    void DebugWindow::unregisterPage(const Ogre::String& page)
+    {
+        PageTextMap::iterator it = mPageTexts.find(page);
+        if (it != mPageTexts.end())
+        {
+            mPageTexts.erase(it);
+        }
+        else
+        {
+            Throw(IllegalArgumentException, page + " is not registered as a page.");
+        }
+
+        // If this is the current page, switch over to the next
+        // or clear text, if no other page is left.
+        if (mCurrentPage == page && !mPageTexts.empty())
+        {
+            mCurrentPage = page;
+        }
+        else if (mCurrentPage == page)
+        {
+            mCurrentPage = StringUtil::BLANK;
+        }
+        updatePageText();
+    }
+
+    void DebugWindow::setPageText(const Ogre::String& page, const Ogre::String& text)
+    {
+        PageTextMap::iterator it = mPageTexts.find(page);
+        if (it == mPageTexts.end())
+        {
+            LOG_ERROR("DebugWindow", page + " is not registered as a page.");
+        }
+        else
+        {
+            it->second = text;
+        }
+
+        if (mCurrentPage == page)
+        {
+            updatePageText();
+        }
+    }
+
+    void DebugWindow::setMessageText(const Ogre::String& text)
+    {
+        CeGuiString o(text.c_str());
+        mMessageText->setText(o);
+    }
+
+    void DebugWindow::showNextPage()
+    {
+        PageTextMap::iterator it = mPageTexts.find(mCurrentPage);
+        if (it != mPageTexts.end())
+        {
+            ++it;
+            if (it == mPageTexts.end())
+            {
+                it = mPageTexts.begin();
+            }
+            mCurrentPage = it->first;
+            updatePageText();
+        }
+        else
+        {
+            RlAssert1(mPageTexts.empty());
+        }
+    }
+
+    void DebugWindow::run(Ogre::Real elapsedTime)
+    {
+        updateFps();
+    }
+
+    void DebugWindow::updatePageText()
+    {
+        Ogre::String text = mCurrentPage == StringUtil::BLANK ?
+            StringUtil::BLANK : mPageTexts[mCurrentPage];
+        mPageCaption->setText(mCurrentPage);
+        mPageText->setText(text);
+    }
+
+    void DebugWindow::updateFps()
+    {
+        const RenderTarget::FrameStats& stats = CoreSubsystem::getSingleton().getRenderWindow()->getStatistics();
+
+        Ogre::String textSt = "Current FPS: " +
+            StringConverter::toString(stats.lastFPS)+
+            "\nBest/worst/avg FPS: " +
+            StringConverter::toString(stats.bestFPS) + "/" +
+            StringConverter::toString(stats.worstFPS) + "/" +
+            StringConverter::toString(stats.avgFPS)+
+            "\nBest/worst Frame times: " +
+            StringConverter::toString(stats.bestFPS) + "/" +
+            StringConverter::toString(stats.worstFPS)+
+            "\nTriangle Count: " +
+            StringConverter::toString(stats.triangleCount);
+
+        if (PartyManager::getSingleton().getActiveCharacter() != NULL &&
+            PartyManager::getSingleton().getActiveCharacter()->getActor() != NULL)
+        {
+            ActorControlledObject* charObj = PartyManager::getSingletonPtr()->
+                getActiveCharacter()->getActor()->getControlledObject();
+
+            if( charObj != NULL )
+            {
+                Ogre::Vector3 pos = charObj->getMovableObject()->getParentNode()->getWorldPosition();
+                Ogre::Quaternion ori = charObj->getMovableObject()->getParentNode()->getWorldOrientation();
+
+                textSt += "\nPlayer Position [ "
+                    + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+", "
+                    + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+", "
+                    + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+" ]";
+
+                textSt += "\nPlayer Orientation [ "
+                    + StringConverter::toString(ori.w,4,0,32,std::ios_base::fixed)+", "
+                    + StringConverter::toString(ori.x,2,0,32,std::ios_base::fixed)+", "
+                    + StringConverter::toString(ori.y,2,0,32,std::ios_base::fixed)+", "
+                    + StringConverter::toString(ori.z,2,0,32,std::ios_base::fixed)+" ]";
+            }
+        }
+
+        Actor* camActor = ActorManager::getSingleton().getActor("DefaultCamera");
+        if( camActor != 0 && camActor->_getSceneNode() != NULL )
+        {
+            Ogre::Camera* cam = dynamic_cast<CameraObject*>(camActor->getControlledObject())->getCamera();
+            Ogre::Vector3 pos = cam->getDerivedPosition();
+
+            textSt += "\nCamera Position [ "
+                + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+", "
+                + StringConverter::toString(pos.y,2,0,32,std::ios_base::fixed)+", "
+                + StringConverter::toString(pos.z,2,0,32,std::ios_base::fixed)+" ]";
+        }
+
+        setPageText(mDebugPageName, textSt);
+    }
+
+    void DebugWindow::setVisible(bool visible, bool destroyAfterHide)
+    {
+        AbstractWindow::setVisible(visible, destroyAfterHide);
+        if (visible)
+            GameLoop::getSingleton().addTask(this, GameLoop::TG_GRAPHICS);
+        else
+            GameLoop::getSingleton().removeTask(this);
+    }
+
+    const Ogre::String& DebugWindow::getName() const
+    {
+        static Ogre::String NAME = "DebugWindow";
+
+        return NAME;
+    }
+
+}

Copied: rl/branches/newton20/engine/ui/src/GameOverWindow.cpp (from rev 4518, rl/trunk/engine/ui/src/GameOverWindow.cpp)

Modified: rl/branches/newton20/engine/ui/src/GameSaveLoadWindow.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/GameSaveLoadWindow.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/src/GameSaveLoadWindow.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -106,7 +106,6 @@
     {
         //mSaveGameTable->autoSizeColumnHeader(0);
         //mSaveGameTable->autoSizeColumnHeader(1);
-        listSaveGames();
     }
 
     //------------------------------------------------------- LoadEvent
@@ -123,13 +122,6 @@
         if(filename != "")
         {
 
-            if(SaveGameManager::getSingleton().SaveGameFileExists(filename, CoreSubsystem::getSingleton().getActiveAdventureModule()->getId()))
-                SaveGameManager::getSingleton().loadSaveGameFile(filename, CoreSubsystem::getSingleton().getActiveAdventureModule()->getId());
-            else
-            {
-                LOG_ERROR(Logger::UI, "Save Game " + filename + " doesn't exist!");
-                WindowFactory::getSingleton().showMessageWindow("Der Spielstand existiert nicht");
-            }
         }*/
 
         return true;
@@ -145,18 +137,13 @@
 
         if(filename != "")
         {
-            LOG_MESSAGE(Logger::UI, "Create a SaveGameFile");
 
-            SaveGameManager::getSingleton().saveSaveGameFile(filename);
-
-            LOG_MESSAGE(Logger::UI, "Created save game");
         }
         else
         {
             WindowFactory::getSingleton().showMessageWindow("Bitte einen Namen f?r den Spielstand eingeben");
         }
 
-        listSaveGames();
 
         return true;
     }
@@ -166,35 +153,12 @@
     bool GameSaveLoadWindow::handleDeleteEvent()
     {
         LOG_MESSAGE(Logger::UI, "Delete Button pressed");
-        if(SaveGameManager::getSingleton().SaveGameFileExists(mFilename->getText(), CoreSubsystem::getSingleton().getActiveAdventureModule()->getId()))
-        {
-            SaveGameManager::getSingleton().deleteSaveGameFile(mFilename->getText(), CoreSubsystem::getSingleton().getActiveAdventureModule()->getId());
-            listSaveGames();
-        }
+
         return true;
     }
 
     void GameSaveLoadWindow::listSaveGames()
     {
-        SaveGameEntryMap saveGames = SaveGameManager::getSingleton().listSaveGames(CoreSubsystem::getSingleton().getActiveAdventureModule()->getId());
-    
-        while(mSaveGameTable->getRowCount() > saveGames.size())
-		    mSaveGameTable->removeRow(mSaveGameTable->getRowCount()-1);
-        while(mSaveGameTable->getRowCount() < saveGames.size())
-		    mSaveGameTable->addRow();
-        
-        int saveGameNum = 0;
-
-        for(SaveGameEntryMap::iterator it = saveGames.begin(); it != saveGames.end(); it++)
-        {
-            ListboxTextItem* item = new CEGUI::ListboxTextItem(it->second->getName());
-            item->setSelectionBrushImage(mSelectionImageset, mSelectionBrush);
-            mSaveGameTable->setItem(item, 0, saveGameNum);
-            item = new CEGUI::ListboxTextItem(it->second->getProperty(SaveGameFile::PROPERTY_TIME));
-            item->setSelectionBrushImage(mSelectionImageset, mSelectionBrush);
-            mSaveGameTable->setItem(item, 1, saveGameNum);
-            saveGameNum++;
-        }
         //mSaveGameTable->autoSizeColumnHeader(0);
         //mSaveGameTable->autoSizeColumnHeader(1);
     }

Modified: rl/branches/newton20/engine/ui/src/InputManager.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/InputManager.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/src/InputManager.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -51,6 +51,7 @@
 #include "Job.h"
 #include "JobScheduler.h"
 #include "MovementControlState.h"
+#include "PartyManager.h"
 #include "RubyInterpreter.h"
 #include "UiSubsystem.h"
 #include "WindowFactory.h"
@@ -394,7 +395,7 @@
     void InputManager::pushControlState(ControlStateType controlStateType)
     {
         Actor* camera = ActorManager::getSingleton().getActor("DefaultCamera");
-        Creature* character = UiSubsystem::getSingleton().getActiveCharacter();
+        Creature* character = PartyManager::getSingleton().getActiveCharacter();
 
         ControlState* controller = NULL;
         switch (controlStateType)

Modified: rl/branches/newton20/engine/ui/src/MainMenuLoadWindow.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/MainMenuLoadWindow.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/src/MainMenuLoadWindow.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -114,7 +114,6 @@
 		//	module = CoreSubsystem::getSingleton().getModule(moduleId.c_str());
 		//	assert(module != NULL /*MainMenuLoadWindow::handleLoadEvent()*/);
 		//	CoreSubsystem::getSingleton().startAdventureModule(module);
-		//	SaveGameManager::getSingleton().loadSaveGameFile(((SaveGameFile*)mSaveGameTable->getFirstSelectedItem()->getUserData())->getId());
 		//}
 
         return true;
@@ -129,9 +128,6 @@
         if(mSaveGameTable->getFirstSelectedItem())
 		{
             mSaveGameTable->getRowWithID(mSaveGameTable->getFirstSelectedItem()->getID());
-            
-            SaveGameManager::getSingleton().deleteSaveGameFile(
-                ((SaveGameFile*)mSaveGameTable->getFirstSelectedItem()->getUserData())->getId());
         }
 
         return true;
@@ -140,31 +136,6 @@
     void MainMenuLoadWindow::listSaveGames()
     {
         mSaveGameTable->clearAllSelections();
-        SaveGameEntryMap saveGames = SaveGameManager::getSingleton().listSaveGames();
-
-        while(mSaveGameTable->getRowCount() > saveGames.size())
-		    mSaveGameTable->removeRow(mSaveGameTable->getRowCount()-1);
-        while(mSaveGameTable->getRowCount() < saveGames.size())
-		    mSaveGameTable->addRow();
-
-        int saveGameNum = 0;
-
-        for(SaveGameEntryMap::iterator it = saveGames.begin(); it != saveGames.end(); it++)
-        {
-            CEGUI::ListboxTextItem* item = new CEGUI::ListboxTextItem(it->second->getName());
-            item->setUserData(it->second);
-            item->setSelectionBrushImage(mSelectionImageset, mSelectionBrush);
-            mSaveGameTable->setItem(item, 0, saveGameNum);
-            item = new CEGUI::ListboxTextItem(it->second->getProperty(SaveGameFile::PROPERTY_MODULENAME).toString());
-            item->setUserData(it->second);
-            item->setSelectionBrushImage(mSelectionImageset, mSelectionBrush);
-            mSaveGameTable->setItem(item, 1, saveGameNum);
-            item = new CEGUI::ListboxTextItem(it->second->getProperty(SaveGameFile::PROPERTY_TIME).toString());
-            item->setUserData(it->second);
-            item->setSelectionBrushImage(mSelectionImageset, mSelectionBrush);
-            mSaveGameTable->setItem(item, 2, saveGameNum);
-            saveGameNum++;
-        }
         /*mSaveGameTable->autoSizeColumnHeader(0);
         mSaveGameTable->autoSizeColumnHeader(1);
         mSaveGameTable->autoSizeColumnHeader(2);*/

Modified: rl/branches/newton20/engine/ui/src/Makefile.am
===================================================================
--- rl/branches/newton20/engine/ui/src/Makefile.am	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/src/Makefile.am	2008-09-19 08:22:31 UTC (rev 4519)
@@ -29,6 +29,7 @@
     FreeflightControlState.cpp \
     GameLoggerWindow.cpp \
     GameObjectInfoWindow.cpp \
+	GameOverWindow.cpp \
 	GameSaveLoadWindow.cpp \
     GameSettings.cpp \
     InfoPopup.cpp \

Modified: rl/branches/newton20/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/UiSubsystem.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/src/UiSubsystem.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -40,6 +40,7 @@
 #include "ItemDescriptionDragContainer.h"
 #include "ItemIconDragContainer.h"
 #include "Logger.h"
+#include "RulesMessages.h"
 #include "ScriptWrapper.h"
 #include "SoundManager.h"
 #include "UiMessages.h"
@@ -82,6 +83,9 @@
         mBeforeLoadingGameObjectsConnection = 
             MessagePump::getSingleton().addMessageHandler<MessageType<RLMSG_SAVEGAME_LOADING> >(
                 boost::bind(&UiSubsystem::onBeforeGameObjectsLoaded, this));
+        mActiveCharacterChangedConnection = 
+            MessagePump::getSingleton().addMessageHandler<MessageType_ActivePlayerCharChanged>(
+                boost::bind(&UiSubsystem::onActiveCharacterChanged, this, _1, _2));
         mWindowFactory = new WindowFactory();
     }
 
@@ -166,58 +170,47 @@
         return mGuiRenderer;
     }
 
-    Creature* UiSubsystem::getActiveCharacter() const
+    bool UiSubsystem::onActiveCharacterChanged(Creature* oldActive, Creature* newActive)
     {
-        return mCharacter;
-    }
-
-    void UiSubsystem::setActiveCharacter(Creature* creature)
-    {
         // Ensure we have a sound listener
         if (SoundManager::getSingleton().getListenerActor() == NULL)
         {
             SoundManager::getSingleton().createListenerActor();
         }
 
-        if (creature != mCharacter )
+        if (oldActive)
         {
-            if (mCharacter)
+            ScriptWrapper::getSingleton().disowned( oldActive );
+            if (oldActive->getActor())
             {
-                ScriptWrapper::getSingleton().disowned( mCharacter );
-                if (mCharacter->getActor())
-                {
-                    mCharacter->getActor()->detach(SoundManager::getSingleton().getListenerActor());
-                }
-                mCharacter->setQueryFlags(mCharacter->getQueryFlags() & (~QUERYFLAG_PLAYER));
+                oldActive->getActor()->detach(SoundManager::getSingleton().getListenerActor());
             }
-
-            if (!creature)
-            {
-                mCharacter = NULL;
-                mInputManager->clearControlStates();
-            }
-            else
-            {
-                ScriptWrapper::getSingleton().owned(creature);
-                mCharacter = creature;
-                mCharacter->addQueryFlag(QUERYFLAG_PLAYER);
-
-                mWindowFactory->setActiveCharacter(creature);
-
-                mCharacter->getActor()->attach(SoundManager::getSingleton().getListenerActor());
-                LOG_MESSAGE(Logger::UI, "SoundListener attached.");
-
-                // Reset control stack for the new Character and set to movement.
-                mInputManager->setControlState(CST_MOVEMENT);
-            }
-
-            MessagePump::getSingleton().sendMessage<MessageType_ActiveCharacterChanged>(creature);
+            oldActive->setQueryFlags(oldActive->getQueryFlags() & (~QUERYFLAG_PLAYER));
         }
+        
+        if (!newActive)
+        {
+            mInputManager->clearControlStates();
+        }
+        else
+        {
+            ScriptWrapper::getSingleton().owned(newActive);
+            newActive->addQueryFlag(QUERYFLAG_PLAYER);
+            
+            mWindowFactory->setActiveCharacter(newActive);
+            
+            newActive->getActor()->attach(SoundManager::getSingleton().getListenerActor());
+            LOG_MESSAGE(Logger::UI, "SoundListener attached.");
+            
+            // Reset control stack for the new Character and set to movement.
+            mInputManager->setControlState(CST_MOVEMENT);
+        }
+        
+        return true;
     }
 
     bool UiSubsystem::onBeforeClearScene()
     {
-        setActiveCharacter(NULL);
         // Remove control states here too, in case that there has not yet been a
         // person set active.
         mInputManager->clearControlStates();
@@ -258,9 +251,18 @@
             mCharacterId = mCharacter->getId();
         }
         else
+        {
             mCharacterId = -1;
-
+        }
+        
         //mInputManager->clearControlStates();
         return false;
     }
+    
+    bool UiSubsystem::onAllPlayerCharactersDied()
+    {
+        LOG_MESSAGE(Logger::UI, "All player chars are dead, show game over");
+        WindowFactory::getSingleton().showGameOverWindow();
+        return true;
+    }
 }

Modified: rl/branches/newton20/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/WindowFactory.cpp	2008-09-18 20:15:00 UTC (rev 4518)
+++ rl/branches/newton20/engine/ui/src/WindowFactory.cpp	2008-09-19 08:22:31 UTC (rev 4519)
@@ -1,455 +1,462 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "WindowFactory.h"
-
-#include "AboutWindow.h"
-#include "ActionChoiceWindow.h"
-#include "ActorManager.h"
-#include "CharacterSheetWindow.h"
-#include "CharacterStateWindow.h"
-#include "CloseConfirmationWindow.h"
-#include "CombatWindow.h"
-#include "Console.h"
-#include "CoreSubsystem.h"
-#include "Creature.h"
-#include "DebugWindow.h"
-#include "DialogControlState.h"
-#include "DialogWindow.h"
-#include "Exception.h"
-#include "GameLoggerWindow.h"
-#include "GameObject.h"
-#include "GameObjectInfoWindow.h"
-#include "PropertiesWindow.h"
-#include "GameSaveLoadWindow.h"
-#include "MainMenuLoadWindow.h"
-#include "GameSettings.h"
-#include "InfoPopup.h"
-#include "InGameMenuWindow.h"
-#include "InputManager.h"
-#include "InventoryWindow.h"
-#include "JournalWindow.h"
-#include "LogWindow.h"
-#include "MessageWindow.h"
-#include "MainMenuWindow.h"
-#include "MainMenuEngineWindow.h"
-#include "MovableText.h"
-#include "ObjectDescriptionWindow.h"
-#include "PlaylistWindow.h"
-#include "QuestBook.h"
-#include "RubyInterpreter.h"
-#include "RulesSubsystem.h"
-#include "SubtitleWindow.h"
-#include "UiSubsystem.h"
-#include "WindowManager.h"
-
-#undef max
-
-template<> rl::WindowFactory* Ogre::Singleton<rl::WindowFactory>::ms_Singleton = 0;
-
-using namespace CEGUI;
-using namespace Ogre;
-
-namespace rl {
-
-    WindowFactory::WindowFactory()
-        : mGameLogger(NULL),
-        mCharacterStateWindow(NULL),
-        mInGameMenuWindow(NULL),
-        mCharacterSheet(NULL),
-        mJournalWindow(NULL),
-        mInventoryWindow(NULL),
-        mLogWindow(NULL),
-        mDebugWindow(NULL),
-        mConsole(NULL),
-        mInfoPopup(NULL),
-        mObjectNameText(NULL),
-        mShownObject(NULL),
-        mObjectDescriptionWindow(NULL),
-        mMainMenuWindow(NULL),
-		mMainMenuLoadWindow(NULL),
-        mGameSettings(NULL),
-        mCombatWindow(NULL)
-    {
-    }
-
-    void WindowFactory::initialize()
-    {
-        mConsole = new Console();
-        mDebugWindow = new DebugWindow();
-        CoreSubsystem::getSingleton().getRubyInterpreter()->
-            setOutputFunction(
-                (VALUE(*)(...))&WindowFactory::consoleWrite );
-
-        mLogWindow = new LogWindow();
-
-        mGameLogger = new GameLoggerWindow();
-        mCharacterStateWindow = new CharacterStateWindow();
-        mInGameMenuWindow = new InGameMenuWindow();
-        mCharacterSheet = new CharacterSheetWindow();
-        mJournalWindow = new JournalWindow();
-        //mInfoPopup = new InfoPopup(); // this invisible window blocks the mouse
-        mObjectDescriptionWindow = new ObjectDescriptionWindow();
-        mGameSettings = new GameSettings();
-
-        RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mJournalWindow);
-        //RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mInfoPopup);
-        mMainMenuWindow = new MainMenuWindow( new MainMenuEngineWindow() );
-
-        logAllWindows();
-    }
-
-    WindowFactory::~WindowFactory()
-    {
-        delete mLogWindow;
-        delete mObjectDescriptionWindow;
-        delete mJournalWindow;
-        delete mGameLogger;
-        delete mCharacterSheet;
-        delete mInGameMenuWindow;
-        delete mInventoryWindow;
-        delete mCharacterStateWindow;
-        //delete mInfoPopup;
-        delete mDebugWindow;
-        delete mConsole;
-        delete mMainMenuWindow;
-        delete mGameSettings;
-        delete mCombatWindow;
-    }
-
-    void WindowFactory::showCharacterActionChoice()
-    {
-        showActionChoice(UiSubsystem::getSingleton().getActiveCharacter());
-    }
-
-    void WindowFactory::showContainerContent(Container* container)
-    {
-        if( !mInventoryWindow )
-            toggleInventoryWindow();
-
-        mInventoryWindow->showContainerContent(container);
-    }
-
-    void WindowFactory::showMessageWindow(const CeGuiString& message)
-    {
-        MessageWindow* w = new MessageWindow("", message, MessageWindow::OK);
-        w->setVisible(true);
-    }
-
-    void WindowFactory::showMainMenu()
-    {
-        mMainMenuWindow->setVisible(true);
-    }
-
-    void WindowFactory::toggleConsole()
-    {
-        mConsole->setVisible(!mConsole->isVisible());
-    }
-
-    void WindowFactory::toggleDebugWindow()
-    {
-        mDebugWindow->setVisible(!mDebugWindow->isVisible());
-    }
-
-    void WindowFactory::showPropertiesWindow(GameObject* obj)
-    {
-        PropertiesWindow* wnd = new PropertiesWindow(obj);
-        wnd->setVisible(true);
-    }
-
-    void WindowFactory::showGameSaveLoadWindow()
-    {
-        GameSaveLoadWindow* wnd = new GameSaveLoadWindow();
-        wnd->initialize();
-        wnd->setVisible(true);
-    }
-
-    void WindowFactory::showMainMenuLoadWindow(MainMenuWindow* win)
-    {
-		mMainMenuLoadWindow = new MainMenuLoadWindow(win);
-        mMainMenuLoadWindow->initialize();
-        mMainMenuLoadWindow->setVisible(true);
-    }
-
-	void WindowFactory::hideMainMenuLoadWindow()
-    {
-		if(mMainMenuLoadWindow != NULL && mMainMenuLoadWindow->isVisible())
-		{
-			mMainMenuLoadWindow->setVisible(false,true);
-			mMainMenuWindow = NULL;
-		}
-    }
-
-    void WindowFactory::toggleGameLogWindow()
-    {
-        mGameLogger->setVisible(!mGameLogger->isVisible());
-    }
-
-    void WindowFactory::toggleInventoryWindow()
-    {
-        if (mInventoryWindow != NULL && mInventoryWindow->isVisible())
-        {
-            mInventoryWindow->setVisible(false, true);
-            mInventoryWindow = NULL;
-        }
-        else
-        {
-            if (mInventoryWindow != NULL)
-            {
-                WindowManager::getSingleton().destroyWindow(mInventoryWindow);
-                mInventoryWindow = NULL;
-            }
-
-            if (UiSubsystem::getSingleton().getActiveCharacter() != NULL)
-            {
-                Creature* creat = UiSubsystem::getSingleton().getActiveCharacter();
-
-                Ogre::String inventoryWindowType = creat->getInventoryWindowType();
-                if (inventoryWindowType == "")
-                {
-                    inventoryWindowType = "inventory_default.xml"; ///@TODO: Extract
-                }
-                mInventoryWindow = new InventoryWindow(inventoryWindowType, creat->getInventory());
-                mInventoryWindow->setVisible(true);
-            }
-        }
-    }
-
-    void WindowFactory::notifyInventoryWindowDestroyed()
-    {
-        mInventoryWindow = NULL;
-    }
-
-	bool WindowFactory::isInventoryWindowDestroyed()
-	{
-		return mInventoryWindow == NULL;
-	}
-
-
-    void WindowFactory::showCharacterSheet()
-    {
-        if (mCharacterSheet->isVisible())
-        {
-            mCharacterSheet->setCharacter(NULL);
-            mCharacterSheet->setVisible(false);
-        }
-        else
-        {
-            mCharacterSheet->setCharacter(UiSubsystem::getSingleton().getActiveCharacter());
-            mCharacterSheet->setVisible(true);
-        }
-    }
-
-    void WindowFactory::showJournalWindow()
-    {
-        if (mJournalWindow->isVisible())
-        {
-            mJournalWindow->setVisible(false);
-        }
-        else
-        {
-            mJournalWindow->setVisible(true);
-        }
-    }
-
-    void WindowFactory::showAboutWindow()
-    {
-        (new AboutWindow())->setVisible(true);
-    }
-
-    void WindowFactory::showCharacterSheet(Creature* chara)
-    {
-        if (!mCharacterSheet) 
-        {
-            mCharacterSheet = new CharacterSheetWindow();
-        }
-        mCharacterSheet->setCharacter(chara);
-        mCharacterSheet->setVisible(true);
-    }
-
-    void WindowFactory::showDescriptionWindow(GameObject* obj)
-    {
-        (new GameObjectInfoWindow(obj, UiSubsystem::getSingleton().getActiveCharacter()))->setVisible(true);
-    }
-
-    void WindowFactory::toggleCharacterStateWindow()
-    {
-        mCharacterStateWindow->setVisible(!mCharacterStateWindow->isVisible());
-    }
-
-    void WindowFactory::toggleInGameGlobalMenu()
-    {
-        mInGameMenuWindow->setVisible(!mInGameMenuWindow->isVisible());
-    }
-
-    GameLoggerWindow* WindowFactory::getGameLogger()
-    {
-        return mGameLogger;
-    }
-
-    void WindowFactory::showPlaylist()
-    {
-        PlaylistWindow* wnd = new PlaylistWindow();
-        wnd->setVisible(true);
-    }
-
-    void WindowFactory::checkForErrors()
-    {
-        if (Logger::getSingleton().isErrorPresent())
-        {
-            mLogWindow->setVisible(true);
-            Logger::getSingleton().resetErrorState();
-        }
-    }
-
-    void WindowFactory::update()
-    {
-        mInGameMenuWindow->update();
-    }
-
-    void WindowFactory::showExitConfirmation()
-    {
-        AbstractWindow* closeConfirmationWindow = new CloseConfirmationWindow();
-        LOG_MESSAGE2(Logger::UI, "Start", "UiSubsystem::requestExit");
-        closeConfirmationWindow->setVisible(true);
-    }
-
-    void WindowFactory::writeToConsole(Ogre::String text)
-    {
-        if (mConsole != NULL)
-        {
-            mConsole->write(text);
-        }
-        else
-        {
-            LOG_MESSAGE("Console", text);
-        }
-    }
-
-    VALUE WindowFactory::consoleWrite(VALUE self, VALUE str)
-    {
-        CeGuiString text = RubyInterpreter::val2ceguistr(str);
-
-        if (WindowFactory::getSingletonPtr() != NULL )
-        {
-            if (WindowFactory::getSingleton().mConsole != NULL)
-            {
-                WindowFactory::getSingleton().mConsole->
-                    write(text + " \n");
-                return Qnil;
-            }
-        }
-        
-        LOG_MESSAGE("Console", text);
-        return Qnil;
-    }
-
-    void WindowFactory::setActiveCharacter(Creature* character)
-    {
-        mCharacterStateWindow->setCharacter(character);
-        if (mCharacterSheet) 
-        {
-            mCharacterSheet->setCharacter(character);
-        }
-
-        if (mInventoryWindow && mInventoryWindow->isVisible())
-        {
-            toggleInventoryWindow();
-        }
-
-        LOG_MESSAGE(Logger::UI, "CharacterStateWindow updated");
-    }
-
-    void WindowFactory::showActionChoice(GameObject* obj)
-    {
-        ActionChoiceWindow* w = new ActionChoiceWindow(UiSubsystem::getSingleton().getActiveCharacter());
-        int numActions = w->showActionsOfObject(obj);
-        if (numActions > 0)
-        {
-            w->setVisible(true);
-        }
-        else
-        {
-            WindowManager::getSingleton().destroyWindow(w);
-        }
-    }
-
-    void WindowFactory::showLogfiles()
-    {
-        (new LogWindow())->setVisible(true);
-    }
-
-    void WindowFactory::showPopupMessage(int popupTypes)
-    {
-        if (popupTypes & WindowFactory::ICON_ERROR)
-        {
-            //mInfoPopup->showError();
-        }
-
-        if (popupTypes & WindowFactory::ICON_QUEST)
-        {
-            //mInfoPopup->showQuestBookChange();
-        }
-    }
-
-    void WindowFactory::showObjectDescription(GameObject* object)
-    {
-        mObjectDescriptionWindow->show(object);
-    }
-
-    void WindowFactory::showNextDebugWindowPage()
-    {
-        mDebugWindow->showNextPage();
-    }
-
-    void WindowFactory::showGameSettings()
-    {
-        // Create the game settings window and show it
-        mGameSettings->setVisible(true);
-    }
-
-    void WindowFactory::logAllWindows()
-    {
-        CEGUI::Window* rootWnd = AbstractWindow::getRoot();
-        CEGUI::uint count = rootWnd->getChildCount();
-        for (CEGUI::uint chIdx =  0; chIdx < count; ++chIdx)
-        {
-            CEGUI::Window* wnd = rootWnd->getChildAtIdx(chIdx);
-            LOG_MESSAGE(
-                Logger::UI,
-                wnd->getName()
-                + (wnd->isVisible() ? " vis" : " nvis")
-                + " @"
-                + StringConverter::toString(wnd->getPixelRect().getPosition().d_x)
-                + ", "
-                + StringConverter::toString(wnd->getPixelRect().getPosition().d_y)
-                + " "
-                + StringConverter::toString(wnd->getPixelSize().d_width)
-                + ", "
-                + StringConverter::toString(wnd->getPixelSize().d_height));
-        }
-    }
-
-    CombatWindow* WindowFactory::getCombatWindow()
-    {
-        if (mCombatWindow == NULL)
-        {
-            mCombatWindow = new CombatWindow();
-        }
-        return mCombatWindow;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include "WindowFactory.h"
+
+#include "AboutWindow.h"
+#include "ActionChoiceWindow.h"
+#include "ActorManager.h"
+#include "CharacterSheetWindow.h"
+#include "CharacterStateWindow.h"
+#include "CloseConfirmationWindow.h"
+#include "CombatWindow.h"
+#include "Console.h"
+#include "CoreSubsystem.h"
+#include "Creature.h"
+#include "DebugWindow.h"
+#include "DialogControlState.h"
+#include "DialogWindow.h"
+#include "Exception.h"
+#include "GameLoggerWindow.h"
+#include "GameObject.h"
+#include "GameObjectInfoWindow.h"
+#include "GameOverWindow.h"
+#include "GameSaveLoadWindow.h"
+#include "GameSettings.h"
+#include "InfoPopup.h"
+#include "InGameMenuWindow.h"
+#include "InputManager.h"
+#include "InventoryWindow.h"
+#include "JournalWindow.h"
+#include "LogWindow.h"
+#include "MessageWindow.h"
+#include "MainMenuLoadWindow.h"
+#include "MainMenuWindow.h"
+#include "MainMenuEngineWindow.h"
+#include "MovableText.h"
+#include "ObjectDescriptionWindow.h"
+#include "PartyManager.h"
+#include "PlaylistWindow.h"
+#include "PropertiesWindow.h"
+#include "QuestBook.h"
+#include "RubyInterpreter.h"
+#include "RulesSubsystem.h"
+#include "SubtitleWindow.h"
+#include "UiSubsystem.h"
+#include "WindowManager.h"
+
+#undef max
+
+template<> rl::WindowFactory* Ogre::Singleton<rl::WindowFactory>::ms_Singleton = 0;
+
+using namespace CEGUI;
+using namespace Ogre;
+
+namespace rl {
+
+    WindowFactory::WindowFactory()
+        : mGameLogger(NULL),
+        mCharacterStateWindow(NULL),
+        mInGameMenuWindow(NULL),
+        mCharacterSheet(NULL),
+        mJournalWindow(NULL),
+        mInventoryWindow(NULL),
+        mLogWindow(NULL),
+        mDebugWindow(NULL),
+        mConsole(NULL),
+        mInfoPopup(NULL),
+        mObjectNameText(NULL),
+        mShownObject(NULL),
+        mObjectDescriptionWindow(NULL),
+        mMainMenuWindow(NULL),
+		mMainMenuLoadWindow(NULL),
+        mGameSettings(NULL),
+        mCombatWindow(NULL)
+    {
+    }
+
+    void WindowFactory::initialize()
+    {
+        mConsole = new Console();
+        mDebugWindow = new DebugWindow();
+        CoreSubsystem::getSingleton().getRubyInterpreter()->
+            setOutputFunction(
+                (VALUE(*)(...))&WindowFactory::consoleWrite );
+
+        mLogWindow = new LogWindow();
+
+        mGameLogger = new GameLoggerWindow();
+        mCharacterStateWindow = new CharacterStateWindow();
+        mInGameMenuWindow = new InGameMenuWindow();
+        mCharacterSheet = new CharacterSheetWindow();
+        mJournalWindow = new JournalWindow();
+        //mInfoPopup = new InfoPopup(); // this invisible window blocks the mouse
+        mObjectDescriptionWindow = new ObjectDescriptionWindow();
+        mGameSettings = new GameSettings();
+
+        RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mJournalWindow);
+        //RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mInfoPopup);
+        mMainMenuWindow = new MainMenuWindow( new MainMenuEngineWindow() );
+
+        logAllWindows();
+    }
+
+    WindowFactory::~WindowFactory()
+    {
+        delete mLogWindow;
+        delete mObjectDescriptionWindow;
+        delete mJournalWindow;
+        delete mGameLogger;
+        delete mCharacterSheet;
+        delete mInGameMenuWindow;
+        delete mInventoryWindow;
+        delete mCharacterStateWindow;
+        //delete mInfoPopup;
+        delete mDebugWindow;
+        delete mConsole;
+        delete mMainMenuWindow;
+        delete mGameSettings;
+        delete mCombatWindow;
+    }
+
+    void WindowFactory::showCharacterActionChoice()
+    {
+        showActionChoice(PartyManager::getSingleton().getActiveCharacter());
+    }
+
+    void WindowFactory::showContainerContent(Container* container)
+    {
+        if( !mInventoryWindow )
+            toggleInventoryWindow();
+
+        mInventoryWindow->showContainerContent(container);
+    }
+
+    void WindowFactory::showMessageWindow(const CeGuiString& message)
+    {
+        MessageWindow* w = new MessageWindow("", message, MessageWindow::OK);
+        w->setVisible(true);
+    }
+
+    void WindowFactory::showMainMenu()
+    {
+        mMainMenuWindow->setVisible(true);
+    }
+
+    void WindowFactory::toggleConsole()
+    {
+        mConsole->setVisible(!mConsole->isVisible());
+    }
+
+    void WindowFactory::toggleDebugWindow()
+    {
+        mDebugWindow->setVisible(!mDebugWindow->isVisible());
+    }
+
+    void WindowFactory::showPropertiesWindow(GameObject* obj)
+    {
+        PropertiesWindow* wnd = new PropertiesWindow(obj);
+        wnd->setVisible(true);
+    }
+
+    void WindowFactory::showGameSaveLoadWindow()
+    {
+        GameSaveLoadWindow* wnd = new GameSaveLoadWindow();
+        wnd->initialize();
+        wnd->setVisible(true);
+    }
+
+    void WindowFactory::showMainMenuLoadWindow(MainMenuWindow* win)
+    {
+		mMainMenuLoadWindow = new MainMenuLoadWindow(win);
+        mMainMenuLoadWindow->initialize();
+        mMainMenuLoadWindow->setVisible(true);
+    }
+
+	void WindowFactory::hideMainMenuLoadWindow()
+    {
+		if(mMainMenuLoadWindow != NULL && mMainMenuLoadWindow->isVisible())
+		{
+			mMainMenuLoadWindow->setVisible(false,true);
+			mMainMenuWindow = NULL;
+		}
+    }
+
+    void WindowFactory::toggleGameLogWindow()
+    {
+        mGameLogger->setVisible(!mGameLogger->isVisible());
+    }
+
+    void WindowFactory::toggleInventoryWindow()
+    {
+        if (mInventoryWindow != NULL && mInventoryWindow->isVisible())
+        {
+            mInventoryWindow->setVisible(false, true);
+            mInventoryWindow = NULL;
+        }
+        else
+        {
+            if (mInventoryWindow != NULL)
+            {
+                WindowManager::getSingleton().destroyWindow(mInventoryWindow);
+                mInventoryWindow = NULL;
+            }
+
+            if (PartyManager::getSingleton().getActiveCharacter() != NULL)
+            {
+                Creature* creat = PartyManager::getSingleton().getActiveCharacter();
+
+                Ogre::String inventoryWindowType = creat->getInventoryWindowType();
+                if (inventoryWindowType == "")
+                {
+                    inventoryWindowType = "inventory_default.xml"; ///@TODO: Extract
+                }
+                mInventoryWindow = new InventoryWindow(inventoryWindowType, creat->getInventory());
+                mInventoryWindow->setVisible(true);
+            }
+        }
+    }
+
+    void WindowFactory::notifyInventoryWindowDestroyed()
+    {
+        mInventoryWindow = NULL;
+    }
+
+	bool WindowFactory::isInventoryWindowDestroyed()
+	{
+		return mInventoryWindow == NULL;
+	}
+
+
+    void WindowFactory::showCharacterSheet()
+    {
+        if (mCharacterSheet->isVisible())
+        {
+            mCharacterSheet->setCharacter(NULL);
+            mCharacterSheet->setVisible(false);
+        }
+        else
+        {
+            mCharacterSheet->setCharacter(PartyManager::getSingleton().getActiveCharacter());
+            mCharacterSheet->setVisible(true);
+        }
+    }
+
+    void WindowFactory::showJournalWindow()
+    {
+        if (mJournalWindow->isVisible())
+        {
+            mJournalWindow->setVisible(false);
+        }
+        else
+        {
+            mJournalWindow->setVisible(true);
+        }
+    }
+
+    void WindowFactory::showAboutWindow()
+    {
+        (new AboutWindow())->setVisible(true);
+    }
+
+    void WindowFactory::showCharacterSheet(Creature* chara)
+    {
+        if (!mCharacterSheet) 
+        {
+            mCharacterSheet = new CharacterSheetWindow();
+        }
+        mCharacterSheet->setCharacter(chara);
+        mCharacterSheet->setVisible(true);
+    }
+
+    void WindowFactory::showDescriptionWindow(GameObject* obj)
+    {
+        (new GameObjectInfoWindow(obj, PartyManager::getSingleton().getActiveCharacter()))->setVisible(true);
+    }
+
+    void WindowFactory::toggleCharacterStateWindow()
+    {
+        mCharacterStateWindow->setVisible(!mCharacterStateWindow->isVisible());
+    }
+
+    void WindowFactory::toggleInGameGlobalMenu()
+    {
+        mInGameMenuWindow->setVisible(!mInGameMenuWindow->isVisible());
+    }
+
+    GameLoggerWindow* WindowFactory::getGameLogger()
+    {
+        return mGameLogger;
+    }
+
+    void WindowFactory::showPlaylist()
+    {
+        PlaylistWindow* wnd = new PlaylistWindow();
+        wnd->setVisible(true);
+    }
+
+    void WindowFactory::checkForErrors()
+    {
+        if (Logger::getSingleton().isErrorPresent())
+        {
+            mLogWindow->setVisible(true);
+            Logger::getSingleton().resetErrorState();
+        }
+    }
+
+    void WindowFactory::update()
+    {
+        mInGameMenuWindow->update();
+    }
+
+    void WindowFactory::showExitConfirmation()
+    {
+        AbstractWindow* closeConfirmationWindow = new CloseConfirmationWindow();
+        LOG_MESSAGE2(Logger::UI, "Start", "UiSubsystem::requestExit");
+        closeConfirmationWindow->setVisible(true);
+    }
+
+    void WindowFactory::writeToConsole(Ogre::String text)
+    {
+        if (mConsole != NULL)
+        {
+            mConsole->write(text);
+        }
+        else
+        {
+            LOG_MESSAGE("Console", text);
+        }
+    }
+
+    VALUE WindowFactory::consoleWrite(VALUE self, VALUE str)
+    {
+        CeGuiString text = RubyInterpreter::val2ceguistr(str);
+
+        if (WindowFactory::getSingletonPtr() != NULL )
+        {
+            if (WindowFactory::getSingleton().mConsole != NULL)
+            {
+                WindowFactory::getSingleton().mConsole->
+                    write(text + " \n");
+                return Qnil;
+            }
+        }
+        
+        LOG_MESSAGE("Console", text);
+        return Qnil;
+    }
+
+    void WindowFactory::setActiveCharacter(Creature* character)
+    {
+        mCharacterStateWindow->setCharacter(character);
+        if (mCharacterSheet) 
+        {
+            mCharacterSheet->setCharacter(character);
+        }
+
+        if (mInventoryWindow && mInventoryWindow->isVisible())
+        {
+            toggleInventoryWindow();
+        }
+
+        LOG_MESSAGE(Logger::UI, "CharacterStateWindow updated");
+    }
+
+    void WindowFactory::showActionChoice(GameObject* obj)
+    {
+        ActionChoiceWindow* w = new ActionChoiceWindow(PartyManager::getSingleton().getActiveCharacter());
+        int numActions = w->showActionsOfObject(obj);
+        if (numActions > 0)
+        {
+            w->setVisible(true);
+        }
+        else
+        {
+            WindowManager::getSingleton().destroyWindow(w);
+        }
+    }
+
+    void WindowFactory::showLogfiles()
+    {
+        (new LogWindow())->setVisible(true);
+    }
+
+    void WindowFactory::showPopupMessage(int popupTypes)
+    {
+        if (popupTypes & WindowFactory::ICON_ERROR)
+        {
+            //mInfoPopup->showError();
+        }
+
+        if (popupTypes & WindowFactory::ICON_QUEST)
+        {
+            //mInfoPopup->showQuestBookChange();
+        }
+    }
+
+    void WindowFactory::showObjectDescription(GameObject* object)
+    {
+        mObjectDescriptionWindow->show(object);
+    }
+
+    void WindowFactory::showNextDebugWindowPage()
+    {
+        mDebugWindow->showNextPage();
+    }
+
+    void WindowFactory::showGameSettings()
+    {
+        // Create the game settings window and show it
+        mGameSettings->setVisible(true);
+    }
+    
+    void WindowFactory::showGameOverWindow()
+    {
+        (new GameOverWindow())->setVisible(true);
+    }
+
+    void WindowFactory::logAllWindows()
+    {
+        CEGUI::Window* rootWnd = AbstractWindow::getRoot();
+        CEGUI::uint count = rootWnd->getChildCount();
+        for (CEGUI::uint chIdx =  0; chIdx < count; ++chIdx)
+        {
+            CEGUI::Window* wnd = rootWnd->getChildAtIdx(chIdx);
+            LOG_MESSAGE(
+                Logger::UI,
+                wnd->getName()
+                + (wnd->isVisible() ? " vis" : " nvis")
+                + " @"
+                + StringConverter::toString(wnd->getPixelRect().getPosition().d_x)
+                + ", "
+                + StringConverter::toString(wnd->getPixelRect().getPosition().d_y)
+                + " "
+                + StringConverter::toString(wnd->getPixelSize().d_width)
+                + ", "
+                + StringConverter::toString(wnd->getPixelSize().d_height));
+        }
+    }
+
+    CombatWindow* WindowFactory::getCombatWindow()
+    {
+        if (mCombatWindow == NULL)
+        {
+            mCombatWindow = new CombatWindow();
+        }
+        return mCombatWindow;
+    }
+}



From fusion2 at mail.berlios.de  Sat Sep 20 17:57:40 2008
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Sat, 20 Sep 2008 17:57:40 +0200
Subject: [Dsa-hl-svn] r4520 - in rl/trunk/editors/Lockenwickler: . src
	src/media src/media/icons
Message-ID: <200809201557.m8KFve7V020771@sheep.berlios.de>

Author: fusion2
Date: 2008-09-20 17:57:03 +0200 (Sat, 20 Sep 2008)
New Revision: 4520

Added:
   rl/trunk/editors/Lockenwickler/src/media/Pivot_Arrow.mesh
   rl/trunk/editors/Lockenwickler/src/media/Pivot_FreeMover.mesh
   rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
   rl/trunk/editors/Lockenwickler/src/media/Rotate_Torus.mesh
   rl/trunk/editors/Lockenwickler/src/media/icons/
   rl/trunk/editors/Lockenwickler/src/media/icons/back.png
   rl/trunk/editors/Lockenwickler/src/media/icons/configure.png
   rl/trunk/editors/Lockenwickler/src/media/icons/console.png
   rl/trunk/editors/Lockenwickler/src/media/icons/decrypted.png
   rl/trunk/editors/Lockenwickler/src/media/icons/edit.png
   rl/trunk/editors/Lockenwickler/src/media/icons/edit_add.png
   rl/trunk/editors/Lockenwickler/src/media/icons/edit_remove.png
   rl/trunk/editors/Lockenwickler/src/media/icons/editclear.png
   rl/trunk/editors/Lockenwickler/src/media/icons/editcopy.png
   rl/trunk/editors/Lockenwickler/src/media/icons/editcut.png
   rl/trunk/editors/Lockenwickler/src/media/icons/editdelete.png
   rl/trunk/editors/Lockenwickler/src/media/icons/editpaste.png
   rl/trunk/editors/Lockenwickler/src/media/icons/encrypted.png
   rl/trunk/editors/Lockenwickler/src/media/icons/endturn.png
   rl/trunk/editors/Lockenwickler/src/media/icons/exit.png
   rl/trunk/editors/Lockenwickler/src/media/icons/fileexport.png
   rl/trunk/editors/Lockenwickler/src/media/icons/filenew.png
   rl/trunk/editors/Lockenwickler/src/media/icons/filesave.png
   rl/trunk/editors/Lockenwickler/src/media/icons/find.png
   rl/trunk/editors/Lockenwickler/src/media/icons/forward.png
   rl/trunk/editors/Lockenwickler/src/media/icons/goto.png
   rl/trunk/editors/Lockenwickler/src/media/icons/idea.png
   rl/trunk/editors/Lockenwickler/src/media/icons/move.png
   rl/trunk/editors/Lockenwickler/src/media/icons/move_task_down.png
   rl/trunk/editors/Lockenwickler/src/media/icons/move_task_up.png
   rl/trunk/editors/Lockenwickler/src/media/icons/ok.png
   rl/trunk/editors/Lockenwickler/src/media/icons/playlist.png
   rl/trunk/editors/Lockenwickler/src/media/icons/redo.png
   rl/trunk/editors/Lockenwickler/src/media/icons/resizecol.png
   rl/trunk/editors/Lockenwickler/src/media/icons/rotate.png
   rl/trunk/editors/Lockenwickler/src/media/icons/tux.png
   rl/trunk/editors/Lockenwickler/src/media/icons/unsortedlist1.png
   rl/trunk/editors/Lockenwickler/src/media/icons/view_tree.png
   rl/trunk/editors/Lockenwickler/src/media/pivots.blend
Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/MovePivot.py
   rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
   rl/trunk/editors/Lockenwickler/src/Plugins-linux.cfg
   rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
   rl/trunk/editors/Lockenwickler/src/ui_pref_dialog.py
Log:
- the window state is now restored on startup
- removed the second ogre window 
- lots of icons added from the KDE Crystal Clear pack (http://www.kde-look.org/content/show.php?content=25668)

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2008-09-19 08:22:31 UTC (rev 4519)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2008-09-20 15:57:03 UTC (rev 4520)
@@ -1,161 +1,179 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE Project SYSTEM "Project-4.2.dtd">
-<!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2008-06-23, 19:40:36 -->
-<!-- Copyright (C) 2008 Stefan Stammberger, sstammberger at web.de -->
-<Project version="4.2">
-  <ProgLanguage mixed="0">Python</ProgLanguage>
-  <ProjectType>Qt4</ProjectType>
-  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
-  <Version>0.1</Version>
-  <Author>Stefan Stammberger</Author>
-  <Email>sstammberger at web.de</Email>
-  <Sources>
-    <Source>
-      <Dir>src</Dir>
-      <Name>Lockenwickler.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ConsoleWindow.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ModelSelectionDialog.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ModuleManager.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>MovePivot.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ObjectPropertyWin.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>OdeManager.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>OgreMainWindow.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>OgreWidget.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>PreferencesDialog.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>PythonOgreConfig.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ui_ConsoleWindow.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ui_FourPanelView.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ui_lw.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ui_model_prev.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ui_obj_prop.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ui_pref_dialog.py</Name>
-    </Source>
-    <Source>
-      <Dir>ui files</Dir>
-      <Name>batch_convert_ui.py</Name>
-    </Source>
-    <Source>
-      <Dir>ui files</Dir>
-      <Name>ui_ConsoleWindow.py</Name>
-    </Source>
-    <Source>
-      <Dir>ui files</Dir>
-      <Name>ui_FourPanelView.py</Name>
-    </Source>
-    <Source>
-      <Dir>ui files</Dir>
-      <Name>ui_lw.py</Name>
-    </Source>
-    <Source>
-      <Dir>ui files</Dir>
-      <Name>ui_model_prev.py</Name>
-    </Source>
-    <Source>
-      <Dir>ui files</Dir>
-      <Name>ui_obj_prop.py</Name>
-    </Source>
-    <Source>
-      <Dir>ui files</Dir>
-      <Name>ui_pref_dialog.py</Name>
-    </Source>
-  </Sources>
-  <Forms>
-    <Form>
-      <Dir>ui files</Dir>
-      <Name>console_window.ui</Name>
-    </Form>
-    <Form>
-      <Dir>ui files</Dir>
-      <Name>FourPanelView.ui</Name>
-    </Form>
-    <Form>
-      <Dir>ui files</Dir>
-      <Name>lockewickler.ui</Name>
-    </Form>
-    <Form>
-      <Dir>ui files</Dir>
-      <Name>model_preview.ui</Name>
-    </Form>
-    <Form>
-      <Dir>ui files</Dir>
-      <Name>object_property.ui</Name>
-    </Form>
-    <Form>
-      <Dir>ui files</Dir>
-      <Name>preferences_dialog.ui</Name>
-    </Form>
-  </Forms>
-  <Translations>
-  </Translations>
-  <Resources>
-  </Resources>
-  <Interfaces>
-  </Interfaces>
-  <Others>
-  </Others>
-  <MainScript>
-    <Dir>src</Dir>
-    <Name>Lockenwickler.py</Name>
-  </MainScript>
-  <Vcs>
-    <VcsType>None</VcsType>
-  </Vcs>
-  <FiletypeAssociations>
-    <FiletypeAssociation pattern="*.ui" type="FORMS" />
-    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
-    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
-    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
-    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
-    <FiletypeAssociation pattern="*.py" type="SOURCES" />
-    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
-  </FiletypeAssociations>
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE Project SYSTEM "Project-4.4.dtd">
+<!-- eric4 project file for project Lockenwickler -->
+<!-- Saved: 2008-09-19, 19:08:16 -->
+<!-- Copyright (C) 2008 Stefan Stammberger, sstammberger at web.de -->
+<Project version="4.4">
+  <ProgLanguage mixed="0">Python</ProgLanguage>
+  <ProjectType>Qt4</ProjectType>
+  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
+  <Version>0.1</Version>
+  <Author>Stefan Stammberger</Author>
+  <Email>sstammberger at web.de</Email>
+  <Sources>
+    <Source>src/Lockenwickler.py</Source>
+    <Source>src/ConsoleWindow.py</Source>
+    <Source>src/ModelSelectionDialog.py</Source>
+    <Source>src/ModuleManager.py</Source>
+    <Source>src/MovePivot.py</Source>
+    <Source>src/ObjectPropertyWin.py</Source>
+    <Source>src/OdeManager.py</Source>
+    <Source>src/OgreMainWindow.py</Source>
+    <Source>src/OgreWidget.py</Source>
+    <Source>src/PreferencesDialog.py</Source>
+    <Source>src/PythonOgreConfig.py</Source>
+    <Source>src/ui_ConsoleWindow.py</Source>
+    <Source>src/ui_FourPanelView.py</Source>
+    <Source>src/ui_lw.py</Source>
+    <Source>src/ui_model_prev.py</Source>
+    <Source>src/ui_obj_prop.py</Source>
+    <Source>src/ui_pref_dialog.py</Source>
+    <Source>ui files/batch_convert_ui.py</Source>
+    <Source>ui files/ui_ConsoleWindow.py</Source>
+    <Source>ui files/ui_FourPanelView.py</Source>
+    <Source>ui files/ui_lw.py</Source>
+    <Source>ui files/ui_model_prev.py</Source>
+    <Source>ui files/ui_obj_prop.py</Source>
+    <Source>ui files/ui_pref_dialog.py</Source>
+    <Source>src/SceneExplorer.py</Source>
+  </Sources>
+  <Forms>
+    <Form>ui files/console_window.ui</Form>
+    <Form>ui files/FourPanelView.ui</Form>
+    <Form>ui files/lockewickler.ui</Form>
+    <Form>ui files/model_preview.ui</Form>
+    <Form>ui files/object_property.ui</Form>
+    <Form>ui files/preferences_dialog.ui</Form>
+  </Forms>
+  <Translations>
+  </Translations>
+  <Resources>
+  </Resources>
+  <Interfaces>
+  </Interfaces>
+  <Others>
+  </Others>
+  <MainScript>src/Lockenwickler.py</MainScript>
+  <Vcs>
+    <VcsType>Subversion</VcsType>
+    <VcsOptions>
+      <dict>
+        <key>
+          <string>add</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>checkout</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>commit</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>diff</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>export</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>global</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>history</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>log</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>remove</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>status</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>tag</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>update</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+      </dict>
+    </VcsOptions>
+    <VcsOtherData>
+      <dict>
+        <key>
+          <string>standardLayout</string>
+        </key>
+        <value>
+          <bool>True</bool>
+        </value>
+      </dict>
+    </VcsOtherData>
+  </Vcs>
+  <FiletypeAssociations>
+    <FiletypeAssociation pattern="*.ui" type="FORMS" />
+    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
+    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
+    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
+    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
+    <FiletypeAssociation pattern="*.py" type="SOURCES" />
+    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
+  </FiletypeAssociations>
 </Project>
\ No newline at end of file

Modified: rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py	2008-09-19 08:22:31 UTC (rev 4519)
+++ rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py	2008-09-20 15:57:03 UTC (rev 4520)
@@ -25,10 +25,10 @@
         sys.stderr = self
 
     def write(self, text):
-        if text.isspace():
-            return
         if self.filterLog:
-            if text.startswith("Error"):
+            if text.isspace():
+                return
+            elif text.startswith("Error"):
                 self.consoleWindow.textEdit.append(text)
                 return
             elif text.startswith("OGRE EXCEPTION"):

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2008-09-19 08:22:31 UTC (rev 4519)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2008-09-20 15:57:03 UTC (rev 4520)
@@ -2,8 +2,8 @@
 import sys
 import platform
 
-sys.path.insert(0,'..')
-import PythonOgreConfig
+#sys.path.insert(0,'..')
+#import PythonOgreConfig
 
 from random import randint
 from os.path import isfile
@@ -14,8 +14,8 @@
 from ModelSelectionDialog import *
 from ConsoleWindow import *
 from ModuleManager import *
+from SceneExplorer import *
 
-
 import OgreMainWindow
 import ogre.renderer.OGRE as og
 
@@ -26,34 +26,59 @@
         self.setupUi()
 
         self.consoleWindow = ConsoleWindow(False,  self)
-        QtCore.QObject.connect(self.actionConsole_Window, QtCore.SIGNAL("triggered()"),
-                                    self.toggleConsoleWindow)
 
         self.setupOgre()
 
         self.prefDialog = PreferencesDialog(self.loadModule, self)
-        QtCore.QObject.connect(self.actionPreferences, QtCore.SIGNAL("triggered()"),
-                                    self.togglePreferencesWindow)
-
         self.objectPropertyWin = ObjectPropertyWin(self)
-        QtCore.QObject.connect(self.actionProperty_Window, QtCore.SIGNAL("triggered()"),
-                                    self.togglePropertyWindow)
-
+        self.sceneExplorerWin = SceneExplorer(self)
         self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
-        QtCore.QObject.connect(self.actionObject_Selection, QtCore.SIGNAL("triggered()"),
-                                    self.toggleModelPreviewWindow)
 
-        QtCore.QObject.connect(self.actionClose, QtCore.SIGNAL("triggered()"),
-                                    self.update)
-
         self.createDockWindows()
 
         self.mainTimer = QtCore.QTimer(self)
         self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL("timeout()"), self.update)
-        self.mainTimer.start(33)
+        self.mainTimer.start(5)
 
-        QtGui.QApplication.setKeyboardInputInterval(5000)
+        settings = QtCore.QSettings()
+        self.restoreGeometry(settings.value("MainWindow/Geometry").toByteArray())
+        self.restoreState(settings.value("MainWindow/DockWindows").toByteArray())
 
+        self.setWindowTitle("Rastullahs Lockenwickler")
+#        # Import Psyco if available
+#        try:
+#            import psyco
+#            psyco.full()
+#            #psyco.log()
+#            #psyco.profile()
+#        except ImportError:
+#            pass
+
+        #QtGui.QApplication.setKeyboardInputInterval(5000)
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QtGui.QAction(text, self)
+        if icon is not None:
+            action.setIcon(QtGui.QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            self.connect(action, QtCore.SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+
+    def addActions(self, target, actions):
+        for act in actions:
+            if act is None:
+                target.addSeparator()
+            else:
+                target.addAction(act)
+
     def setupUi(self):
         self.setObjectName("MainWindow")
         self.resize(QtCore.QSize(QtCore.QRect(0,0,660,657).size()).expandedTo(self.minimumSizeHint()))
@@ -78,35 +103,48 @@
         self.menuView.setObjectName("menuView")
         self.setMenuBar(self.menubar)
 
+
         self.statusbar = QtGui.QStatusBar(self)
         self.statusbar.setObjectName("statusbar")
         self.setStatusBar(self.statusbar)
 
-        self.actionNeu = QtGui.QAction(self)
+        self.actionNeu = QtGui.QAction(QtGui.QIcon("media/icons/package.png"), "&New",  self)
         self.actionNeu.setObjectName("actionNeu")
 
-        self.actionSceneGraph = QtGui.QAction(self)
-        self.actionSceneGraph.setCheckable(False)
-        self.actionSceneGraph.setObjectName("actionSceneGraph")
+        self.actionClose = self.createAction("Quit",  self.close,  "Alt + Q",  "exit.png",  "Quit")
+        self.actionClose.setObjectName("actionClose")
 
-        self.actionPreferences = QtGui.QAction(self)
-        self.actionPreferences.setCheckable(False)
+
+
+        self.actionMove = self.createAction("&Move",  self.actionMoveSlot,  "g",  "move.png",  "Move selected object")
+        self.actionMove.setObjectName("actionMove")
+
+        self.actionRotate = self.createAction("&Rotate",  self.actionRotateSlot,  "r",  "rotate.png",  "Rotate selected object")
+        self.actionRotate.setObjectName("actionRotate")
+
+        self.actionScale = self.createAction("&Scale",  self.actionScaleSlot,  "s",  "resizecol.png",  "Scale selected object")
+        self.actionRotate.setObjectName("actionRotate")
+
+
+        self.actionSceneExplorer = self.createAction("&Scene Exlporer",  self.toggleSceneExplorer,  "Alt + E",  "view_tree.png",  "Scene Explorer",  False)
+        self.actionSceneExplorer.setObjectName("actionSceneExplorer")
+
+        self.actionPreferences = self.createAction("&Preferences",  self.togglePreferencesWindow,  "Alt + P",  "configure.png",  "Lockenwickler Preferences",  False)
         self.actionPreferences.setObjectName("actionPreferences")
 
-        self.actionProperty_Window = QtGui.QAction(self)
+        self.actionProperty_Window = self.createAction("Pr&operty Window",  self.togglePropertyWindow,  "Alt + P",  "unsortedlist1.png",  "Property Window")
         self.actionProperty_Window.setObjectName("actionProperty_Window")
 
-        self.actionObject_Selection = QtGui.QAction(self)
+        self.actionObject_Selection = self.createAction("&Model Preview Window",  self.toggleModelPreviewWindow,  "Alt + O",  "tux.png",  "Model Preview")
         self.actionObject_Selection.setObjectName("actionObject_Selection")
 
-        self.actionClose = QtGui.QAction(self)
-        self.actionClose.setObjectName("actionClose")
+        self.actionConsole_Window = self.createAction("&Console Window",  self.toggleConsoleWindow,  "Alt + C",  "console.png",  "Console Window")
+        self.actionConsole_Window.setObjectName("actionConsole_Window")
 
-        self.actionConsole_Window = QtGui.QAction(self)
-        self.actionConsole_Window.setObjectName("actionConsole_Window")
+
         self.menuFile.addAction(self.actionNeu)
         self.menuFile.addAction(self.actionClose)
-        self.menuView.addAction(self.actionSceneGraph)
+        self.menuView.addAction(self.actionSceneExplorer)
         self.menuView.addAction(self.actionPreferences)
         self.menuView.addAction(self.actionProperty_Window)
         self.menuView.addAction(self.actionObject_Selection)
@@ -121,8 +159,10 @@
         self.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
         self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
         self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "Neu", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionSceneGraph.setText(QtGui.QApplication.translate("MainWindow", "SceneGraph", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "New", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionMove.setText(QtGui.QApplication.translate("MainWindow", "Move", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionRotate.setText(QtGui.QApplication.translate("MainWindow", "Rotate", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionSceneExplorer.setText(QtGui.QApplication.translate("MainWindow", "Scene Explorer", None, QtGui.QApplication.UnicodeUTF8))
         self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
         self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
         self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
@@ -138,11 +178,7 @@
         root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
         self.ogreRoot = root
 
-        # setup resources
-        config = og.ConfigFile()
-
-        carryOn = root.showConfigDialog()
-        if not carryOn:
+        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
             sys.exit('Quit from Config Dialog')
 
         root.initialise(False)
@@ -153,7 +189,7 @@
         self.moduleName = ""
         self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
 
-        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr, self)
+        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
         self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
         self.hboxlayout.addLayout(self.gridlayout)
         self.setCentralWidget(self.centralwidget)
@@ -167,6 +203,15 @@
     def update(self):
         self.ogreRoot.renderOneFrame()
 
+    def actionMoveSlot(self):
+        print "MOVE!!!!!!!!!!!"
+
+    def actionRotateSlot(self):
+        print "ROTATE!!!!!!!!!"
+
+    def actionScaleSlot(self):
+        print "Scale!!!!!!!!"
+
     def togglePreferencesWindow(self):
         if self.prefDialog.isHidden():
             self.prefDialog.show()
@@ -179,6 +224,12 @@
         else:
             self.modelSelectionDock.hide()
 
+    def toggleSceneExplorer(self):
+        if self.sceneExplorerDock.isHidden():
+            self.sceneExplorerDock.show()
+        else:
+            self.sceneExplorerDock.hide()
+
     def togglePropertyWindow(self):
         if self.propertyDock.isHidden():
             self.propertyDock.show()
@@ -186,10 +237,10 @@
             self.propertyDock.hide()
 
     def toggleConsoleWindow(self):
-        if self.consoleWindow.isHidden():
-            self.consoleWindow.show()
+        if self.consoleDock.isHidden():
+            self.consoleDock.show()
         else:
-            self.consoleWindow.hide()
+            self.consoleDock.hide()
 
     # parses the moduleconfig.rb and searches for all loader.loadmap(" statements in the ruby script
     # and parses them too
@@ -202,6 +253,7 @@
         self.workingDirCommon = modulePath + "common" # the module path of the common module
 
         import codecs
+        import glob
 
         modConfig = self.workingDir + "/scripts/moduleconfig.rb"
         if isfile(modConfig): # is the modconfig existing?
@@ -232,6 +284,14 @@
         self.setResourcePaths(self.workingDirCommon, "common")
         og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
 
+        command = (os.path.join(self.workingDir,  "maps") + "/*.xml")
+        for mf in glob.glob(command): # search for all xml files in the maps directory and add them
+            self.mapFiles.append(mf)
+
+        command = (os.path.join(self.workingDir,  "maps") + "/*.scene")
+        for mf in glob.glob(command): # search for all xml files in the maps directory and add them
+            self.mapFiles.append(mf)
+
         self.moduleManager.load(moduleName,  self.mapFiles)
 
     def setResourcePaths(self, path, moduleName):
@@ -249,27 +309,44 @@
 
     def createDockWindows(self):
         self.propertyDock = QtGui.QDockWidget(self.tr("Properties"), self)
+        self.propertyDock.setObjectName("PropertyDockWindow")
         self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
         self.propertyDock.setWidget(self.objectPropertyWin)
         self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
 
         self.modelSelectionDock = QtGui.QDockWidget(self.tr("Models"), self)
+        self.modelSelectionDock.setObjectName("ModelSelectionDockWindow")
         self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
         self.modelSelectionDock.setWidget(self.modelSelectionDialog)
         self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
 
+        self.sceneExplorerDock = QtGui.QDockWidget(self.tr("Scene Explorer"), self)
+        self.sceneExplorerDock.setObjectName("SceneExplorerDockWindow")
+        self.sceneExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.sceneExplorerDock.setWidget(self.sceneExplorerWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.sceneExplorerDock)
+
         self.consoleDock = QtGui.QDockWidget(self.tr("Console"), self)
+        self.consoleDock.setObjectName("ConsoleDockWindow")
         self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
         self.consoleDock.setWidget(self.consoleWindow)
         self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
 
         self.fileToolBar = self.addToolBar("File Toolbar")
+        self.fileToolBar.setObjectName("FileToolBar")
         self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
         self.fileToolBar.addAction(self.actionNeu)
         self.fileToolBar.addAction(self.actionClose)
-        self.fileToolBar.hide()
         self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
 
+        self.moveToolBar = self.addToolBar("Transformation Bar")
+        self.moveToolBar.setObjectName("TransformationBar")
+        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.moveToolBar.addAction(self.actionMove)
+        self.moveToolBar.addAction(self.actionRotate)
+        self.moveToolBar.addAction(self.actionScale)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
+
     def keyPressEvent(self,  event):
         if not event.isAutoRepeat():
             self.ogreRenderWindow.keyPressEvent(event)
@@ -279,10 +356,34 @@
             self.ogreRenderWindow.keyReleaseEvent(event)
         pass
 
+    def connectActionButtons(self):
+        pass
+
+    def saveOnClose(self):
+        reply = QtGui.QMessageBox.question(self,  "Rastullahs Lockenwickler - Unsaved Chages",  "Save unsaved changes?",  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
+        if reply == QtGui.QMessageBox.Cancel:
+            return False
+        if reply == QtGui.QMessageBox.Yes:
+            print "SAVE!!!!"
+            #TODO: implement save here
+        return True
+
+    def closeEvent(self,  event):
+        if self.saveOnClose():
+            settings = QtCore.QSettings()
+            settings.setValue("MainWindow/Geometry",  QtCore.QVariant(self.saveGeometry()))
+            settings.setValue("MainWIndow/DockWindows",  QtCore.QVariant(self.saveState()))
+        else:
+            event.ignore()
+
 if __name__ == "__main__":
-     app = QtGui.QApplication(sys.argv)
-     myapp = Lockenwickler()
-     myapp.show()
+    app = QtGui.QApplication(sys.argv)
+    app.setOrganizationName("Team Pantheon")
+    app.setOrganizationDomain("rastullahs-lockenpracht.de/team")
+    app.setApplicationName("Lockenwickler")
 
-     sys.exit(app.exec_())
+    form = Lockenwickler()
+    form.show()
 
+    sys.exit(app.exec_())
+

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2008-09-19 08:22:31 UTC (rev 4519)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2008-09-20 15:57:03 UTC (rev 4520)
@@ -4,11 +4,14 @@
 import ctypes
 import ogre.renderer.OGRE as og
 
+from MovePivot import *
+
 # a class to store information about a object that got selected
 class SelectionObject():
     def __init__(self,  entity,  distance):
         self.entity = entity #the selected entity
         self.distance = distance # the distance from camera at the time of selection
+        self.isPivot = False
 
     #if True this instance will show its bounding box else it will hide it
     def setSelected(self,  selected):
@@ -29,7 +32,9 @@
         self.mVertexList = []
         self.mIndexList = []
 
+        self.currentRay = None
         self.lastRay = None
+
     # sort algorithm for the selection list
     def sortCompareImp(self,  x,  y):
         if x.distance > y.distance:
@@ -40,10 +45,36 @@
             return -1
 
     def queryResult ( self, entity, distance ):
+        print entity.getName()
         if distance == 0.0: #camera is in the bounding box, ignore this selection
             return True
         elif entity.getName() == "rayLine" :
             return True
+        elif entity.isVisible() and entity.getName() == "EditorXArrow":
+            so = SelectionObject(entity,  distance)
+            so.isPivot = True
+            self.selectionList.append(so)
+            return False
+        elif entity.isVisible() and entity.getName() == "EditorYArrow":
+            so = SelectionObject(entity,  distance)
+            so.isPivot = True
+            self.selectionList.append(so)
+            return False
+        elif entity.isVisible() and entity.getName() == "EditorZArrow":
+            so = SelectionObject(entity,  distance)
+            so.isPivot = True
+            self.selectionList.append(so)
+            return False
+        elif entity.isVisible() and entity.getName() == "EditorFreeMover":
+            return True
+        elif entity.getName() == "EditorXRotator" or entity.getName() == "EditorYRotator" or entity.getName() == "EditorZRotator":
+            if entity.isVisible() and self.rayCastToPolygonLevelOnSingleMesh(self.currentRay,  entity):
+                so = SelectionObject(entity,  distance)
+                so.isPivot = True
+                self.selectionList.append(so)
+                return False
+            else:
+                return True
         else:
             so = SelectionObject(entity,  distance)
             self.selectionList.append(so)
@@ -88,6 +119,12 @@
 
         pMesh = entity.getMesh()
 
+        pos =    entity.getParentNode().getWorldPosition()
+        scale =  entity.getParentNode().getScale()
+        orient = entity.getParentNode().getWorldOrientation()
+
+
+
         for i in range ( pMesh.getNumSubMeshes() ):
             pSubMesh = pMesh.getSubMesh(i)
             if pSubMesh.useSharedVertices:
@@ -100,11 +137,10 @@
             numVertices += pMesh.sharedVertexData.vertexCount
 
             storageclass = ctypes.c_float * 3
-            test=storageclass(1.1)
+            test=storageclass(0.0,  0.0,  0.0)
 #         mVertexList = new Point[numVertices];
 #         mIndexList = new unsigned int[numIndices];
 
-        self.mNormalList = []
         self.mVertexList = []
         self.mIndexList = []
 
@@ -115,28 +151,19 @@
         if useSharedVertices:
             ## Real* pVertices (x, y, z order x numVertices)
             elem = pMesh.sharedVertexData.vertexDeclaration.findElementBySemantic(og.VES_POSITION)
-            elemNormal = pMesh.sharedVertexData.vertexDeclaration.findElementBySemantic(og.VES_NORMAL)
 
             if not elem:
                 ogre.Except(Exception.ERR_ITEM_NOT_FOUND, "Can't find position elements in the "
                     "mesh to be written!", "MeshSerializerImpl.writeGeometry")
 
             vbuf = pMesh.sharedVertexData.vertexBufferBinding.getBuffer(elem.getSource())
-            vbufNormal = pMesh.sharedVertexData.vertexBufferBinding.getBuffer(elemNormal.getSource())
 
             ## need space for the 3 verticies
             storageclass = ctypes.c_float * 3
-            test=storageclass(1.1)
+            test=storageclass(0.0,  0.0,  0.0)
 
-            storageclass = ctypes.c_float * 3
-            testNormal=storageclass(1.1)
-
             for j in range ( pMesh.sharedVertexData.vertexCount ):
-                #vbufNormal.readData(j * vbufNormal.getVertexSize(), 3 * ctypes.sizeof(ctype.c_float), ctypes.addressof(testNormal))
-                vbufNormal.readData(j * 3, 3 * ctypes.sizeof(ctype.c_float), ctypes.addressof(testNormal))
-                self.mNormalList.append( og.Vector3(testNormal[0], testNormal[1],  testNormal[2]) )
-
-                vbuf.readData(j * vbuf.getVertexSize(), 3 * ctypes.sizeof(ctype.c_float), ctypes.addressof(test))
+                vbuf.readData(j * vbuf.getVertexSize(), 3 * ctype.sizeof(ctype.c_float), ctype.addressof(test))
                 self.mVertexList.append( og.Vector3(test[0], test[1], test[2]) )
                 vertListCount+=1
 
@@ -145,30 +172,26 @@
             if not pSubMesh.useSharedVertices:
                 ## Real* pVertices (x, y, z order x numVertices)
                 elem = pSubMesh.vertexData.vertexDeclaration.findElementBySemantic(og.VES_POSITION)
-                elemNormal = pSubMesh.vertexData.vertexDeclaration.findElementBySemantic(og.VES_NORMAL)
 
-                if not elem or not elemNormal:
+                if not elem:
                     og.Except(Exception.ERR_ITEM_NOT_FOUND, "Can't find position elements in the "
                         "mesh to be written!", "MeshSerializerImpl.writeGeometry")
 
                 vbuf = pSubMesh.vertexData.vertexBufferBinding.getBuffer(elem.getSource())
-                vbufNormal = pSubMesh.vertexData.vertexBufferBinding.getBuffer(elemNormal.getSource())
 
                 ## need space for the verticies
-                storageclass = ctypes.c_float * (pSubMesh.vertexData.vertexCount * 3)
-                test=storageclass(1.1)
+                storageclass = ctypes.c_float * (pSubMesh.vertexData.vertexCount * 6)
+                test=storageclass(0.0)
 
-                storageclassNormal = ctypes.c_float * (pSubMesh.vertexData.vertexCount * 3)
-                testNormal=storageclassNormal(1.1)
+                vbuf.readData(0, pSubMesh.vertexData.vertexCount * 6 * ctypes.sizeof(ctypes.c_float), ctypes.addressof(test))
 
-                vbuf.readData(0, pSubMesh.vertexData.vertexCount * 3 * ctypes.sizeof(ctypes.c_float),
-                                                                                ctypes.addressof(test))
-                vbufNormal.readData(0, pSubMesh.vertexData.vertexCount * 3 * ctypes.sizeof(ctypes.c_float),
-                                                                                ctypes.addressof(testNormal))
-
-                for j in range ( pSubMesh.vertexData.vertexCount ):
-                    self.mVertexList.append( og.Vector3(test[j], test[j+1], test[j+2]) )
-                    self.mNormalList.append( og.Vector3(testNormal[j], testNormal[j+1], testNormal[j+2]) )
+                for j in range ( 0,  pSubMesh.vertexData.vertexCount * 6,  6):
+                    #print j
+                    p = og.Vector3(test[j], test[j+1], test[j+2])
+                    p /= scale
+                    p += pos
+                    p = orient * p
+                    self.mVertexList.append( p )
                     vertListCount += 1
 
             ibuf = pSubMesh.indexData.indexBuffer
@@ -176,39 +199,51 @@
             storageclass = ctypes.c_ushort * pSubMesh.indexData.indexCount
             test2=storageclass()
 
+
             ibuf.readData(0, ibuf.getSizeInBytes(), ctypes.addressof(test2))
-
             for j in range ( pSubMesh.indexData.indexCount ):
                 self.mIndexList.append (test2[j])   # unsigned short
                 indexCount += 1
 
+            ih = 0
+            for blah in self.mVertexList:
+                print str(ih) + ": "  +  str(blah)
+                ih += 1
+
+#            for blah in self.mIndexList:
+#                print blah
+
+
     # used when a new selection is made, meaning when not iterationg through the selected objects
     def rayCastToPolygonLevel(self,  ray):
         self.lastRay = ray
+
+        for so in self.selectionList:
+            if so.isPivot:
+                return so
+
         if len(self.selectionList) >= 1:
             for so in self.selectionList:
-                self.getMeshInformation(so.entity)
+                if self.rayCastToPolygonLevelOnSingleMesh(ray,  so.entity):
+                    return so
 
-                i = 0
-                while i <= (len(self.mIndexList) - 3):
-                    globalPosition = so.entity.getParentNode().getPosition()
-                    result = og.Math.intersects(ray, globalPosition + self.mVertexList[self.mIndexList[i]], globalPosition + self.mVertexList[self.mIndexList[i+1]],
-                                                                                                                                                              globalPosition + self.mVertexList[self.mIndexList[i+2]], True, True)
 
-                    if result.first:
-                        return so
-#                        self.previousSelected = self.currentSelected
-#
-#                        if self.previousSelected is not -1:
-#                            self.selectionList[self.previousSelected].setSelected(False)
-#
-#                        self.currentSelected = self.selectionList.index(so)
-#                        so.setSelected(True)
-#                        return
-                    i += 3
+    def rayCastToPolygonLevelOnSingleMesh(self,  ray,  entity):
+        self.getMeshInformation(entity)
+        globalPosition = entity.getParentNode().getWorldPosition()
 
-#        print "fertsch #####################################################################################"
+        i = 0
+        while i <= (len(self.mIndexList) - 3):
+            result = og.Math.intersects(ray, globalPosition + self.mVertexList[self.mIndexList[i]], globalPosition + self.mVertexList[self.mIndexList[i+1]],
+                                                                                                                                                          globalPosition + self.mVertexList[self.mIndexList[i+2]], True, False)
 
+            if result.first:
+                return True
+
+            i += 3
+
+        return False
+
     def rayCastToPolygonLevelOnCurrentSelection(self):
         if len(self.selectionList) >= 1:
             self.getMeshInformation(self.selectionList[self.currentSelected].entity)
@@ -238,6 +273,13 @@
         self.lastRay = None
         self.rayLine = None
 
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
     def load(self,  moduleName,  mapFiles):
         self.moduleName = moduleName
         self.mapFiles = mapFiles
@@ -248,6 +290,7 @@
             if node != None:
                 self.parseSceneNodes(node)
 
+        self.pivot = Pivot(self.sceneManager)
 
     def parseSceneNodes(self,  nodeList):
         for ent in nodeList:
@@ -281,7 +324,12 @@
                         nodeScale = og.Vector3(px, py, pz)
                         continue
 
-            e = self.sceneManager.createEntity(entityName, meshFile)
+            try:
+                e = self.sceneManager.createEntity(entityName, meshFile)
+            except:
+                print "Warning: Meshfile " + meshFile + " could not be found."
+                return
+
             n = self.sceneManager.getRootSceneNode().createChild()
             n.attachObject(e)
             n.setPosition(nodePosition)
@@ -290,28 +338,39 @@
 
         pass
 
-
+    # called when a click into Main Ogre Window occurs
     def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
-        if not controlDown and not shiftDown:
-            self.resetSelection()
-
         self.lastRay = ray
+        self.listenerDings.currentRay = ray
         self.raySceneQuery.Ray = ray
         self.raySceneQuery.execute(self.listenerDings)
 
-
         so = self.listenerDings.rayCastToPolygonLevel(ray)
-        if so is not None and not controlDown and not shiftDown:
-            so.setSelected(True)
-            self.userSelectionList.append(so)
-        elif so is not None and controlDown and not shiftDown:
-            so.setSelected(True)
-            self.userSelectionList.append(so)
-        elif so is not None and not controlDown and shiftDown:
-            for selo in self.userSelectionList:
-                if so.entity.getName() == selo.entity.getName():
-                    so.setSelected(False)
-                    self.userSelectionList.remove(selo)
+        if so is not None:
+            if not so.isPivot:
+                self.pivot.show()
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so.entity.getName() == selo.entity.getName():
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                    self.updatePivots()
+            else:
+                print "isPivot: " + str(so.entity.getName())
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            print "noneee"
+            self.resetSelection() # click in empty space, deselect everything
+            self.pivot.hide()
 
         if self.rayLine == None:
             self.rayLine = self.sceneManager.createManualObject("rayLine")
@@ -333,6 +392,10 @@
 
             self.rayLine.end()
 
+    def leftMouseUp(self):
+        if self.pivot.isTransforming:
+            self.pivot.stopTransforming()
+
     def iterateEntityUnderMouse(self):
         self.listenerDings.iterateEntityUnderMouse()
 
@@ -347,6 +410,15 @@
         self.listenerDings.reset()
         pass
 
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+
+        self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
     def unload(self,  saveOnUnload=True):
         pass
 

Modified: rl/trunk/editors/Lockenwickler/src/MovePivot.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/MovePivot.py	2008-09-19 08:22:31 UTC (rev 4519)
+++ rl/trunk/editors/Lockenwickler/src/MovePivot.py	2008-09-20 15:57:03 UTC (rev 4520)
@@ -1,17 +1,149 @@
 import sys
+import ogre.renderer.OGRE as og
 
-class MovePivot():
+
+class Pivot():
     def __init__(self,  sceneManager):
         self.sceneManager = sceneManager
-        self.moveX = False
-        self.moveY = False
-        self.moveZ = False
 
-    # set true if the mouse input should be processed or not
-    def activated(self,  moveX,  moveY,  moveZ):
-        self.moveX = moveX
-        self.moveY = moveY
-        self.moveZ = moveZ
+        self.mode = None
 
-    def move(self):
+        self.meshManager = og.MeshManager.getSingleton ()
+
+        self.pivotNode = sceneManager.getRootSceneNode().createChildSceneNode("pivotNode")
+        self.__createMovePivot()
+        self.__createRotatePivot()
+        self.__createScalePivot()
+        self.hide()
+        self.setMoveMode()
+
+        self.moveDirection = None
+        self.isTransforming = False
+        self.selectionList = None
+
+    def __createMovePivot(self):
+        self.xMoveEntity = self.sceneManager.createEntity("EditorXArrow",  "Pivot_Arrow.mesh")
+        self.xMoveEntity.setMaterialName("Lockenwickler_Pivot_X")
+        self.xMoveNode = self.pivotNode.createChildSceneNode()
+        self.xMoveNode.attachObject(self.xMoveEntity)
+        self.xMoveNode.translate(og.Vector3(2, 0, 0))
+        self.xMoveNode.rotate(og.Vector3.UNIT_Y,  og.Degree(90))
+
+#        plane = og.Plane (og.Vector3.UNIT_X, 0)
+#        self.meshManager.createPlane ('EditorXArrowSelectionPlane', 'General', plane, 5, 14, 1, 1, False, 1, 5, 5, (0, 0, 1))
+#        self.xMoveEntitySelectionPlane = self.sceneManager.createEntity ('EditorXArrowSelectionPlane', 'EditorXArrowSelectionPlane')
+#        self.xMoveNodeSelectionPlane = self.xMoveNode.createChildSceneNode()
+#        self.xMoveNodeSelectionPlane.attachObject (self.xMoveEntitySelectionPlane)
+#        self.xMoveNodeSelectionPlane.translate(og.Vector3(0, 0, 5))
+#        self.xMoveEntitySelectionPlane.setMaterialName("Lockenwickler_Pivot_X")
+
+
+
+        self.yMoveEntity = self.sceneManager.createEntity("EditorYArrow",  "Pivot_Arrow.mesh")
+        self.yMoveEntity.setMaterialName("Lockenwickler_Pivot_Y")
+        self.yMoveNode = self.pivotNode.createChildSceneNode()
+        self.yMoveNode.attachObject(self.yMoveEntity)
+        self.yMoveNode.translate(og.Vector3(0, 2, 0))
+        self.yMoveNode.rotate(og.Vector3.UNIT_X,  og.Degree(-90))
+        #self.yNode.showBoundingBox(True)
+
+#        plane = og.Plane (og.Vector3.UNIT_X, 0)
+#        self.meshManager.createPlane ('EditorYArrowSelectionPlane', 'General', plane, 14, 0, 1, 1, False, 1, 5, 5, (0, 0, 1))
+#        self.yMoveEntitySelectionPlane = self.sceneManager.createEntity ('EditorYArrowSelectionPlane', 'EditorYArrowSelectionPlane')
+#        self.yMoveNodeSelectionPlane = self.xMoveNode.createChildSceneNode()
+#        self.yMoveNodeSelectionPlane.attachObject (self.yMoveEntitySelectionPlane)
+#        self.yMoveNodeSelectionPlane.translate(og.Vector3(0, 5, 0))
+#        self.yMoveEntitySelectionPlane.setMaterialName("Lockenwickler_Pivot_Y")
+
+
+        self.zMoveEntity = self.sceneManager.createEntity("EditorZArrow",  "Pivot_Arrow.mesh")
+        self.zMoveEntity.setMaterialName("Lockenwickler_Pivot_Z")
+        self.zMoveNode = self.pivotNode.createChildSceneNode()
+        self.zMoveNode.attachObject(self.zMoveEntity)
+        self.zMoveNode.translate(og.Vector3(0, 0, 2))
+        #self.zNode.showBoundingBox(True)
+
+        self.freeMoveEntity = self.sceneManager.createEntity("EditorFreeMoveArrow",  "Pivot_FreeMover.mesh")
+        self.freeMoveEntity.setMaterialName("Lockenwickler_FreeMover")
+        self.freeMoveNode = self.pivotNode.createChildSceneNode()
+        self.freeMoveNode.attachObject(self.freeMoveEntity)
+
+
+    def __createRotatePivot(self):
+        self.xRotateEntity = self.sceneManager.createEntity("EditorXRotator",  "Rotate_Torus.mesh")
+        self.xRotateEntity.setMaterialName("Lockenwickler_Pivot_X")
+        self.xRotateNode = self.pivotNode.createChildSceneNode()
+        self.xRotateNode.attachObject(self.xRotateEntity)
+        #self.xRotateNode.translate(0, 0, -5)
+        self.xRotateNode.rotate(og.Vector3.UNIT_Y,  og.Degree(90))
+
+        self.yRotateEntity = self.sceneManager.createEntity("EditorYRotator",  "Rotate_Torus.mesh")
+        self.yRotateEntity.setMaterialName("Lockenwickler_Pivot_Y")
+        self.yRotateNode = self.pivotNode.createChildSceneNode()
+        self.yRotateNode.attachObject(self.yRotateEntity)
+        #self.yRotateNode.translate(0, 0, -10)
+        self.yRotateNode.rotate(og.Vector3.UNIT_X,  og.Degree(90))
+
+        self.zRotateEntity = self.sceneManager.createEntity("EditorZRotator",  "Rotate_Torus.mesh")
+        self.zRotateEntity.setMaterialName("Lockenwickler_Pivot_Z")
+        self.zRotateNode = self.pivotNode.createChildSceneNode()
+        self.zRotateNode.attachObject(self.zRotateEntity)
+
         pass
+
+    def __createScalePivot(self):
+        pass
+
+    def setPosition(self,  pos):
+        self.pivotNode.setPosition(pos)
+
+    def startTransforming(self, dirEntity, soList):
+        self.moveDirection = dirEntity.getName()
+        self.selectionList = soList
+        self.isTransforming = True
+        pass
+
+    def stopTransforming(self):
+        self.isTransforming = False
+        pass
+
+    def hide(self):
+        self.pivotNode.setVisible(False)
+
+    def show(self):
+        if self.mode == 1:
+            self.xMoveNode.setVisible(True)
+            self.yMoveNode.setVisible(True)
+            self.zMoveNode.setVisible(True)
+            self.freeMoveNode.setVisible(True)
+        elif self.mode == 2:
+            self.xRotateNode.setVisible(True)
+            self.yRotateNode.setVisible(True)
+            self.zRotateNode.setVisible(True)
+        elif self.mode == 3:
+            pass
+
+    def setMoveMode(self):
+        self.hide()
+        self.mode = 1
+        self.xMoveNode.setVisible(True)
+        self.yMoveNode.setVisible(True)
+        self.zMoveNode.setVisible(True)
+        self.freeMoveNode.setVisible(False)
+
+        pass
+
+    def setRotateMode(self):
+        self.hide()
+        self.mode = 2
+        self.xRotateNode.setVisible(True)
+        self.yRotateNode.setVisible(True)
+        self.zRotateNode.setVisible(True)
+        pass
+
+    def __setScaleMode(self):
+        pass
+
+    def onMouseMoved(self, globalX, globalY, incX, incY):
+        print self.moveDirection
+        pass

Modified: rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2008-09-19 08:22:31 UTC (rev 4519)
+++ rl/trunk/editors/Lockenwickler/src/OgreMainWindow.py	2008-09-20 15:57:03 UTC (rev 4520)
@@ -17,7 +17,6 @@
         self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
 
         self.ogreRenderWindow = None
-        self.ogreRenderWindow2 = None
 
         self.leftMouseDown = False
         self.middleMouseDown = False
@@ -30,8 +29,6 @@
         self.strafeCamLeft = False
         self.strafeCamRight = False
 
-        self.focusedWindow = None # the ogre window which has focus at the moment (activated by a click into the window), eventFilter method
-
         self.camUpdateTimer = QtCore.QTimer(self)
         self.camUpdateTimer.connect(self.camUpdateTimer, QtCore.SIGNAL("timeout()"), self.updateCamera)
 
@@ -61,6 +58,7 @@
         self.ogreWindowOptions = QtGui.QToolButton(self)
         QtCore.QObject.connect(self.ogreWindowOptions, QtCore.SIGNAL("clicked()"),
                                     self.onPreferencesButton)
+        self.ogreWindowOptions.hide()
 
         sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Maximum,QtGui.QSizePolicy.Minimum)
         sizePolicy.setHorizontalStretch(0)
@@ -71,18 +69,9 @@
         self.splitterV.addWidget(self.ogreWindowOptions)
 
         # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
-        self.splitterH = QtGui.QSplitter(Form)
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding,QtGui.QSizePolicy.MinimumExpanding)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.splitterH.sizePolicy().hasHeightForWidth())
-        self.splitterH.setSizePolicy(sizePolicy)
-        self.splitterH.setOrientation(QtCore.Qt.Horizontal)
-        self.splitterH.setObjectName("splitterH")
 
-
         ##################################
-        self.ogreRenderWindow = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterH,  0)
+        self.ogreRenderWindow = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterV,  0)
         self.ogreRenderWindow.setMinimumSize(QtCore.QSize(250,250))
 
         sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Maximum,QtGui.QSizePolicy.Maximum)
@@ -91,31 +80,15 @@
         sizePolicy.setHeightForWidth(self.ogreRenderWindow.sizePolicy().hasHeightForWidth())
         self.ogreRenderWindow.setSizePolicy(sizePolicy)
         self.ogreRenderWindow.setObjectName("ogreWidget")
-        self.splitterH.addWidget(self.ogreRenderWindow)
-        self.ogreRenderWindow.setBackgroundColor(og.ColourValue(0, 0, 1))
+        self.splitterV.addWidget(self.ogreRenderWindow)
+        self.ogreRenderWindow.setBackgroundColor(og.ColourValue(0, 1, 1))
         ####################################
 
-        #################################
-        self.ogreRenderWindow2 = OgreWidget.OgreWidget("OgreMainWin2", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam2", self.splitterH,  0)
-        self.ogreRenderWindow2.setMinimumSize(QtCore.QSize(250,250))
-
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Maximum,QtGui.QSizePolicy.Maximum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreRenderWindow2.sizePolicy().hasHeightForWidth())
-        self.ogreRenderWindow2.setSizePolicy(sizePolicy)
-        self.ogreRenderWindow2.setObjectName("ogreWidget2")
-        self.splitterH.addWidget(self.ogreRenderWindow2)
-        self.ogreRenderWindow2.setBackgroundColor(og.ColourValue(0, 0, 1))
-        ###################################
-
-        self.splitterV.addWidget(self.splitterH)
         self.gridlayout.addWidget(self.splitterV,0,0,1,1)
 
         # register the eventfilters for the render windows
         # this is needed to catch mouse enter and mouse leave events for these windows
         self.ogreRenderWindow.installEventFilter(self)
-        self.ogreRenderWindow2.installEventFilter(self)
 
         self.lastMousePosX = 0
         self.lastMousePosY = 0
@@ -154,7 +127,7 @@
         if event.type() == 2:
             if event.button() == 1: # left mouse button is pressed
                 self.leftMouseDown = True
-                self.focusedWindow = obj
+                self.moduleManager.leftMouseDown = True
 
                 if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
                     self.dollyCamera = True
@@ -163,33 +136,44 @@
 
             elif event.button() == 2: # right mouse button is pressed
                 self.rightMouseDown = True
-                self.focusedWindow = obj
+                self.moduleManager.rightMouseDown = True
+
             elif event.button() == 4: # middle mouse button is pressed
                 self.middleMouseDown = True
-                self.focusedWindow = obj
+                self.moduleManager.middleMouseDown = True
 
             self.camUpdateTimer.start(15)
 
         elif event.type() == 3:
             if event.button() == 1: # left mouse button is released
                 self.leftMouseDown = False
+                self.moduleManager.leftMouseDown = False
+                self.moduleManager.leftMouseUp()
 
                 if self.dollyCamera == True: #if we dolly the camera set it to false
                     self.dollyCamera = False
 
             elif event.button() == 2: # right mouse button is released
                 self.rightMouseDown = False
+                self.moduleManager.rightMouseDown = False
             elif event.button() == 4: # middle mouse button is released
                 self.middleMouseDown = False
+                self.moduleManager.middleMouseDown = False
 
             if not self.rightMouseDown:
                 self.dollyCamera = False
                 self.camUpdateTimer.stop()
 
         elif event.type() == 5: #mouse moved while button down
-            rotX = (event.globalX() - self.lastMousePosX) * 0.01
-            rotY = (event.globalY() - self.lastMousePosY) * 0.01
+            incX =  (event.globalX() - self.lastMousePosX)
+            incY =  (event.globalY() - self.lastMousePosY)
 
+            if self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
+                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
+
+            rotX = incX * 0.01
+            rotY = incY * 0.01
+
             if (rotX < 0.3 and rotY < 0.3) and (rotX > -0.3 and rotY > -0.3): # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
                 if self.dollyCamera:
                     self.focusedWindow.dollyCamera(og.Vector3( rotX, -rotY,  0))
@@ -227,17 +211,12 @@
         else:
             self.moduleManager.selectionClick(mouseRay)
 
-
-#        self.moduleManager.resetCurrentOgreSelection()
-
-
-
     def updateCamera(self):
         if self.moveCamForward:
-            self.focusedWindow.dollyCamera(og.Vector3( 0, 0,-0.2))
+            self.ogreRenderWindow.dollyCamera(og.Vector3( 0, 0,-0.2))
         if self.moveCamBackward:
-            self.focusedWindow.dollyCamera(og.Vector3( 0, 0, 0.2))
+            self.ogreRenderWindow.dollyCamera(og.Vector3( 0, 0, 0.2))
         if self.strafeCamLeft:
-            self.focusedWindow.dollyCamera(og.Vector3(-0.2, 0 , 0))
+            self.ogreRenderWindow.dollyCamera(og.Vector3(-0.2, 0 , 0))
         if self.strafeCamRight:
-            self.focusedWindow.dollyCamera(og.Vector3( 0.2, 0, 0))
+            self.ogreRenderWindow.dollyCamera(og.Vector3( 0.2, 0, 0))

Modified: rl/trunk/editors/Lockenwickler/src/Plugins-linux.cfg
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Plugins-linux.cfg	2008-09-19 08:22:31 UTC (rev 4519)
+++ rl/trunk/editors/Lockenwickler/src/Plugins-linux.cfg	2008-09-20 15:57:03 UTC (rev 4520)
@@ -1,12 +1,12 @@
 # Defines plugins to load
 
 # Define plugin folder
-PluginFolder=./plugins
+PluginFolder=/usr/lib/OGRE
 
-# Define plugins
-Plugin=RenderSystem_GL
-Plugin=Plugin_ParticleFX
-Plugin=Plugin_OctreeSceneManager
-Plugin=Plugin_CgProgramManager
+# default plugins installed with the libogre14 package
+Plugin=RenderSystem_GL.so
+Plugin=Plugin_ParticleFX.so
+Plugin=Plugin_OctreeSceneManager.so
+#Plugin=Plugin_CgProgramManager
 
 

Modified: rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2008-09-19 08:22:31 UTC (rev 4519)
+++ rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2008-09-20 15:57:03 UTC (rev 4520)
@@ -21,24 +21,24 @@
         QtCore.QObject.connect(self.prefDialog.listWidget, QtCore.SIGNAL("itemDoubleClicked(QListWidgetItem *)"),
                                self.onLoadSelectedModule)
 
-##        if platform.system() == "Windows" or platform.system() == "MAC":
-##            # TODO: delete this when ready
-##            self.prefDialog.lineEdit.setText("C:\Users\Stefan\Desktop\Lockenwickler\modules\modules.cfg")
-##            self.moduleCfgPath = "C:\Users\Stefan\Desktop\Lockenwickler\modules\modules.cfg"
-##            self.moduleCfgIsSelected = True
-##            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
-##            self.readInModules()
-##            # end delete
-##        else:
-##            # TODO: delete this when ready
-##            self.prefDialog.lineEdit.setText("/home/stefan/blubb/rl_modules/modules/modules.cfg")
-##            self.moduleCfgPath = "/home/stefan/blubb/rl_modules/modules/modules.cfg"
-##            self.moduleCfgIsSelected = True
-##            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
-##            self.readInModules()
-##            # end delete
+        if platform.system() == "Windows" or platform.system() == "MAC":
+            # TODO: delete this when ready
+            self.prefDialog.lineEdit.setText("C:\Users\Stefan\Desktop\Lockenwickler\modules\modules.cfg")
+            self.moduleCfgPath = "C:\Users\Stefan\Desktop\Lockenwickler\modules\modules.cfg"
+            self.moduleCfgIsSelected = True
+            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
+            self.readInModules()
+            # end delete
+        else:
+            # TODO: delete this when ready
+            self.prefDialog.lineEdit.setText("/home/stefan/blubb/rl_modules/modules/modules.cfg")
+            self.moduleCfgPath = "/home/stefan/blubb/rl_modules/modules/modules.cfg"
+            self.moduleCfgIsSelected = True
+            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
+            self.readInModules()
+            # end delete
 
-        #self.moduleCfgIsSelected = False
+        self.moduleCfgIsSelected = False
 
         self.setModal(True)
 
@@ -71,6 +71,7 @@
 
     def onLoadSelectedModule(self):
         item = self.prefDialog.listWidget.currentItem()
+
         if item == None:
             mbox = QtGui.QMessageBox(self)
             mbox.setModal(True)

Added: rl/trunk/editors/Lockenwickler/src/media/Pivot_Arrow.mesh
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/Pivot_Arrow.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/Pivot_FreeMover.mesh
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/Pivot_FreeMover.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material
===================================================================
--- rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2008-09-19 08:22:31 UTC (rev 4519)
+++ rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material	2008-09-20 15:57:03 UTC (rev 4520)
@@ -0,0 +1,56 @@
+material Lockenwickler_Pivot_X
+{
+	technique
+	{
+		pass
+		{
+			ambient 1.0 0.0 0.0 1.0
+			diffuse 1.0 0.0 0.0 1.0
+			specular 1.0 0.0 0.0 1.0 12.5
+			emissive 1.0 0.0 0.0 1.0
+		}
+	}
+}
+
+material Lockenwickler_Pivot_Y
+{
+	technique
+	{
+		pass
+		{
+			ambient 0.0 0.0 1.0 1.0
+			diffuse 0.0 0.0 1.0 1.0
+			specular 0.0 0.0 1.0 1.0 12.5
+			emissive 0.0 0.0 1.0 1.0
+		}
+	}
+}
+
+material Lockenwickler_Pivot_Z
+{
+	technique
+	{
+		pass
+		{
+			ambient 0.0 1.0 0.0 1.0
+			diffuse 0.0 1.0 0.0 1.0
+			specular 0.0 1.0 0.0 1.0 12.5
+			emissive 0.0 1.0 0.0 1.0
+		}
+	}
+}
+
+material Lockenwickler_FreeMover
+{
+	technique
+	{
+		pass
+		{
+			ambient 0.0 0.0 0.0 1.0
+			diffuse 0.0 0.0 0.0 1.0
+			specular 0.0 0.0 0.0 1.0 12.5
+			emissive 0.0 0.0 0.0 1.0
+		}
+	}
+}
+ 

Added: rl/trunk/editors/Lockenwickler/src/media/Rotate_Torus.mesh
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/Rotate_Torus.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/back.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/back.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/configure.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/configure.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/console.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/console.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/decrypted.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/decrypted.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/edit.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/edit.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/edit_add.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/edit_add.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/edit_remove.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/edit_remove.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/editclear.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/editclear.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/editcopy.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/editcopy.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/editcut.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/editcut.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/editdelete.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/editdelete.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/editpaste.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/editpaste.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/encrypted.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/encrypted.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/endturn.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/endturn.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/exit.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/exit.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/fileexport.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/fileexport.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/filenew.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/filenew.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/filesave.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/filesave.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/find.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/find.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/forward.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/forward.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/goto.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/goto.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/idea.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/idea.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/move.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/move.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/move_task_down.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/move_task_down.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/move_task_up.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/move_task_up.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/ok.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/ok.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/playlist.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/playlist.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/redo.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/redo.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/resizecol.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/resizecol.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/rotate.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/rotate.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/tux.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/tux.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/unsortedlist1.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/unsortedlist1.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/icons/view_tree.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/view_tree.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/pivots.blend
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/pivots.blend
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: rl/trunk/editors/Lockenwickler/src/ui_pref_dialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ui_pref_dialog.py	2008-09-19 08:22:31 UTC (rev 4519)
+++ rl/trunk/editors/Lockenwickler/src/ui_pref_dialog.py	2008-09-20 15:57:03 UTC (rev 4520)
@@ -1,85 +1,85 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'preferences_dialog.ui'
-#
-# Created: Mon Jun 23 19:28:46 2008
-#      by: PyQt4 UI code generator 4.3.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
-
-class Ui_PreferencesDialog(object):
-    def setupUi(self, PreferencesDialog):
-        PreferencesDialog.setObjectName("PreferencesDialog")
-        PreferencesDialog.resize(QtCore.QSize(QtCore.QRect(0,0,528,626).size()).expandedTo(PreferencesDialog.minimumSizeHint()))
-
-        self.gridlayout = QtGui.QGridLayout(PreferencesDialog)
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.toolBox = QtGui.QToolBox(PreferencesDialog)
-        self.toolBox.setObjectName("toolBox")
-
-        self.ResourcePaths = QtGui.QWidget()
-        self.ResourcePaths.setGeometry(QtCore.QRect(0,0,510,505))
-        self.ResourcePaths.setObjectName("ResourcePaths")
-
-        self.gridlayout1 = QtGui.QGridLayout(self.ResourcePaths)
-        self.gridlayout1.setObjectName("gridlayout1")
-
-        self.listWidget = QtGui.QListWidget(self.ResourcePaths)
-        self.listWidget.setObjectName("listWidget")
-        self.gridlayout1.addWidget(self.listWidget,0,0,1,1)
-
-        self.groupBox = QtGui.QGroupBox(self.ResourcePaths)
-        self.groupBox.setMinimumSize(QtCore.QSize(0,95))
-        self.groupBox.setObjectName("groupBox")
-
-        self.layoutWidget = QtGui.QWidget(self.groupBox)
-        self.layoutWidget.setGeometry(QtCore.QRect(10,20,471,67))
-        self.layoutWidget.setObjectName("layoutWidget")
-
-        self.gridlayout2 = QtGui.QGridLayout(self.layoutWidget)
-        self.gridlayout2.setObjectName("gridlayout2")
-
-        self.lineEdit = QtGui.QLineEdit(self.layoutWidget)
-        self.lineEdit.setObjectName("lineEdit")
-        self.gridlayout2.addWidget(self.lineEdit,0,0,1,1)
-
-        self.loadModuleBtn = QtGui.QPushButton(self.layoutWidget)
-        self.loadModuleBtn.setObjectName("loadModuleBtn")
-        self.gridlayout2.addWidget(self.loadModuleBtn,1,0,1,2)
-
-        self.modulConfigSelector = QtGui.QPushButton(self.layoutWidget)
-        self.modulConfigSelector.setObjectName("modulConfigSelector")
-        self.gridlayout2.addWidget(self.modulConfigSelector,0,1,1,1)
-        self.gridlayout1.addWidget(self.groupBox,1,0,1,1)
-        self.toolBox.addItem(self.ResourcePaths,"")
-
-        self.OgreSettings = QtGui.QWidget()
-        self.OgreSettings.setGeometry(QtCore.QRect(0,0,96,26))
-        self.OgreSettings.setObjectName("OgreSettings")
-        self.toolBox.addItem(self.OgreSettings,"")
-        self.gridlayout.addWidget(self.toolBox,0,0,1,1)
-
-        self.buttonBox = QtGui.QDialogButtonBox(PreferencesDialog)
-        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
-        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.NoButton|QtGui.QDialogButtonBox.Ok)
-        self.buttonBox.setObjectName("buttonBox")
-        self.gridlayout.addWidget(self.buttonBox,1,0,1,1)
-
-        self.retranslateUi(PreferencesDialog)
-        self.toolBox.setCurrentIndex(0)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("accepted()"),PreferencesDialog.accept)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("rejected()"),PreferencesDialog.reject)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("clicked(QAbstractButton*)"),PreferencesDialog.close)
-        QtCore.QMetaObject.connectSlotsByName(PreferencesDialog)
-
-    def retranslateUi(self, PreferencesDialog):
-        PreferencesDialog.setWindowTitle(QtGui.QApplication.translate("PreferencesDialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
-        self.groupBox.setTitle(QtGui.QApplication.translate("PreferencesDialog", "GroupBox", None, QtGui.QApplication.UnicodeUTF8))
-        self.loadModuleBtn.setText(QtGui.QApplication.translate("PreferencesDialog", "Load Selected Module", None, QtGui.QApplication.UnicodeUTF8))
-        self.modulConfigSelector.setText(QtGui.QApplication.translate("PreferencesDialog", "...", None, QtGui.QApplication.UnicodeUTF8))
-        self.toolBox.setItemText(self.toolBox.indexOf(self.ResourcePaths), QtGui.QApplication.translate("PreferencesDialog", "Resource Paths", None, QtGui.QApplication.UnicodeUTF8))
-        self.toolBox.setItemText(self.toolBox.indexOf(self.OgreSettings), QtGui.QApplication.translate("PreferencesDialog", "Ogre Settings", None, QtGui.QApplication.UnicodeUTF8))
-
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file 'preferences_dialog.ui'
+#
+# Created: Mon Jun 23 19:28:46 2008
+#      by: PyQt4 UI code generator 4.3.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_PreferencesDialog(object):
+    def setupUi(self, PreferencesDialog):
+        PreferencesDialog.setObjectName("PreferencesDialog")
+        PreferencesDialog.resize(QtCore.QSize(QtCore.QRect(0,0,528,626).size()).expandedTo(PreferencesDialog.minimumSizeHint()))
+
+        self.gridlayout = QtGui.QGridLayout(PreferencesDialog)
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.toolBox = QtGui.QToolBox(PreferencesDialog)
+        self.toolBox.setObjectName("toolBox")
+
+        self.ResourcePaths = QtGui.QWidget()
+        self.ResourcePaths.setGeometry(QtCore.QRect(0,0,510,505))
+        self.ResourcePaths.setObjectName("ResourcePaths")
+
+        self.gridlayout1 = QtGui.QGridLayout(self.ResourcePaths)
+        self.gridlayout1.setObjectName("gridlayout1")
+
+        self.listWidget = QtGui.QListWidget(self.ResourcePaths)
+        self.listWidget.setObjectName("listWidget")
+        self.gridlayout1.addWidget(self.listWidget,0,0,1,1)
+
+        self.groupBox = QtGui.QGroupBox(self.ResourcePaths)
+        self.groupBox.setMinimumSize(QtCore.QSize(0,95))
+        self.groupBox.setObjectName("groupBox")
+
+        self.layoutWidget = QtGui.QWidget(self.groupBox)
+        self.layoutWidget.setGeometry(QtCore.QRect(10,20,471,67))
+        self.layoutWidget.setObjectName("layoutWidget")
+
+        self.gridlayout2 = QtGui.QGridLayout(self.layoutWidget)
+        self.gridlayout2.setObjectName("gridlayout2")
+
+        self.lineEdit = QtGui.QLineEdit(self.layoutWidget)
+        self.lineEdit.setObjectName("lineEdit")
+        self.gridlayout2.addWidget(self.lineEdit,0,0,1,1)
+
+        self.loadModuleBtn = QtGui.QPushButton(self.layoutWidget)
+        self.loadModuleBtn.setObjectName("loadModuleBtn")
+        self.gridlayout2.addWidget(self.loadModuleBtn,1,0,1,2)
+
+        self.modulConfigSelector = QtGui.QPushButton(self.layoutWidget)
+        self.modulConfigSelector.setObjectName("modulConfigSelector")
+        self.gridlayout2.addWidget(self.modulConfigSelector,0,1,1,1)
+        self.gridlayout1.addWidget(self.groupBox,1,0,1,1)
+        self.toolBox.addItem(self.ResourcePaths,"")
+
+        self.OgreSettings = QtGui.QWidget()
+        self.OgreSettings.setGeometry(QtCore.QRect(0,0,96,26))
+        self.OgreSettings.setObjectName("OgreSettings")
+        self.toolBox.addItem(self.OgreSettings,"")
+        self.gridlayout.addWidget(self.toolBox,0,0,1,1)
+
+        self.buttonBox = QtGui.QDialogButtonBox(PreferencesDialog)
+        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
+        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.NoButton|QtGui.QDialogButtonBox.Ok)
+        self.buttonBox.setObjectName("buttonBox")
+        self.gridlayout.addWidget(self.buttonBox,1,0,1,1)
+
+        self.retranslateUi(PreferencesDialog)
+        self.toolBox.setCurrentIndex(0)
+        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("accepted()"),PreferencesDialog.accept)
+        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("rejected()"),PreferencesDialog.reject)
+        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("clicked(QAbstractButton*)"),PreferencesDialog.close)
+        QtCore.QMetaObject.connectSlotsByName(PreferencesDialog)
+
+    def retranslateUi(self, PreferencesDialog):
+        PreferencesDialog.setWindowTitle(QtGui.QApplication.translate("PreferencesDialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
+        self.groupBox.setTitle(QtGui.QApplication.translate("PreferencesDialog", "GroupBox", None, QtGui.QApplication.UnicodeUTF8))
+        self.loadModuleBtn.setText(QtGui.QApplication.translate("PreferencesDialog", "Load Selected Module", None, QtGui.QApplication.UnicodeUTF8))
+        self.modulConfigSelector.setText(QtGui.QApplication.translate("PreferencesDialog", "...", None, QtGui.QApplication.UnicodeUTF8))
+        self.toolBox.setItemText(self.toolBox.indexOf(self.ResourcePaths), QtGui.QApplication.translate("PreferencesDialog", "Resource Paths", None, QtGui.QApplication.UnicodeUTF8))
+        self.toolBox.setItemText(self.toolBox.indexOf(self.OgreSettings), QtGui.QApplication.translate("PreferencesDialog", "Ogre Settings", None, QtGui.QApplication.UnicodeUTF8))
+



From fusion2 at mail.berlios.de  Sat Sep 20 20:03:54 2008
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Sat, 20 Sep 2008 20:03:54 +0200
Subject: [Dsa-hl-svn] r4521 - in rl/trunk/editors/Lockenwickler: . src
Message-ID: <200809201803.m8KI3s8i021288@sheep.berlios.de>

Author: fusion2
Date: 2008-09-20 20:03:29 +0200 (Sat, 20 Sep 2008)
New Revision: 4521

Added:
   rl/trunk/editors/Lockenwickler/src/SceneExplorer.py
Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
Log:
- forgot to commit a file

Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2008-09-20 15:57:03 UTC (rev 4520)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2008-09-20 18:03:29 UTC (rev 4521)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Project SYSTEM "Project-4.4.dtd">
 <!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2008-09-19, 19:08:16 -->
+<!-- Saved: 2008-09-20, 20:03:11 -->
 <!-- Copyright (C) 2008 Stefan Stammberger, sstammberger at web.de -->
 <Project version="4.4">
   <ProgLanguage mixed="0">Python</ProgLanguage>

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2008-09-20 15:57:03 UTC (rev 4520)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2008-09-20 18:03:29 UTC (rev 4521)
@@ -75,13 +75,12 @@
     def addActions(self, target, actions):
         for act in actions:
             if act is None:
-                target.addSeparator()
+               target.addSeparator()
             else:
                 target.addAction(act)
 
     def setupUi(self):
         self.setObjectName("MainWindow")
-        self.resize(QtCore.QSize(QtCore.QRect(0,0,660,657).size()).expandedTo(self.minimumSizeHint()))
 
         self.centralwidget = QtGui.QWidget(self)
         self.centralwidget.setObjectName("centralwidget")
@@ -93,7 +92,6 @@
         self.gridlayout.setObjectName("gridlayout")
 
         self.menubar = QtGui.QMenuBar(self)
-        self.menubar.setGeometry(QtCore.QRect(0,0,660,22))
         self.menubar.setObjectName("menubar")
 
         self.menuFile = QtGui.QMenu(self.menubar)

Added: rl/trunk/editors/Lockenwickler/src/SceneExplorer.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/SceneExplorer.py	2008-09-20 15:57:03 UTC (rev 4520)
+++ rl/trunk/editors/Lockenwickler/src/SceneExplorer.py	2008-09-20 18:03:29 UTC (rev 4521)
@@ -0,0 +1,15 @@
+import sys
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+import ogre.renderer.OGRE as og
+
+class SceneExplorer(QWidget):
+    def __init__(self, parent=None):
+        QWidget.__init__(self, parent)
+        self.sceneTreeView = QTreeView()
+
+        vBoxLayout = QVBoxLayout()
+        vBoxLayout.addWidget(self.sceneTreeView)
+
+        self.setLayout(vBoxLayout)
+



From timm at mail.berlios.de  Sun Sep 21 22:16:01 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 21 Sep 2008 22:16:01 +0200
Subject: [Dsa-hl-svn] r4522 - in rl/trunk/engine/core: include src
Message-ID: <200809212016.m8LKG1I4006293@sheep.berlios.de>

Author: timm
Date: 2008-09-21 22:15:53 +0200 (Sun, 21 Sep 2008)
New Revision: 4522

Modified:
   rl/trunk/engine/core/include/SaveAble.h
   rl/trunk/engine/core/include/SaveAbleCollection.h
   rl/trunk/engine/core/include/SaveAbleFactory.h
   rl/trunk/engine/core/include/SaveAbleManager.h
   rl/trunk/engine/core/src/SaveAble.cpp
   rl/trunk/engine/core/src/SaveAbleCollection.cpp
   rl/trunk/engine/core/src/SaveAbleFactory.cpp
   rl/trunk/engine/core/src/SaveAbleManager.cpp
Log:
made skeletal structure of classes for new persistence system

Modified: rl/trunk/engine/core/include/SaveAble.h
===================================================================
--- rl/trunk/engine/core/include/SaveAble.h	2008-09-20 18:03:29 UTC (rev 4521)
+++ rl/trunk/engine/core/include/SaveAble.h	2008-09-21 20:15:53 UTC (rev 4522)
@@ -25,16 +25,33 @@
 
 namespace rl
 {
+	class SaveAble;
 
+	class SaveAblePtr : public Ogre::SharedPtr<SaveAble>
+	{
+	};
+
 	class SaveAble : public PropertyHolder
 	{
 	public:
+		SaveAble(int id, bool isSaveAble = true);
 		void setSaveAble(bool enable);
 		bool isSaveAble();
+
+		virtual const Property getProperty(const CeGuiString& key) const;
+        virtual void setProperty(const CeGuiString& key, const Property& value);
+        virtual PropertyKeys getAllPropertyKeys() const;
+		
+		SaveAblePtr getParent() const { return mParentSaveAble; };
+
+		int getId();
 	protected:
+		SaveAblePtr mParentSaveAble;
+		int mId;
 		bool mIsSaveAble;
-	};
+	};	
 
+	typedef std::pair<int, SaveAblePtr>  SaveAbleReference;
 }
 
 

Modified: rl/trunk/engine/core/include/SaveAbleCollection.h
===================================================================
--- rl/trunk/engine/core/include/SaveAbleCollection.h	2008-09-20 18:03:29 UTC (rev 4521)
+++ rl/trunk/engine/core/include/SaveAbleCollection.h	2008-09-21 20:15:53 UTC (rev 4522)
@@ -0,0 +1,34 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#include "CorePrerequisites.h"
+#include "SaveAble.h"
+
+namespace rl
+{
+
+	class SaveAbleCollection
+	{
+	public:
+		void attachSaveAble(SaveAblePtr saveAble);
+		void deattachSaveAble(SaveAblePtr saveAble);
+		void deattachSaveAble(int id);
+		void deattachAllSaveAbles();
+	protected:
+		Ogre::String mId;
+	};
+
+}
\ No newline at end of file

Modified: rl/trunk/engine/core/include/SaveAbleFactory.h
===================================================================
--- rl/trunk/engine/core/include/SaveAbleFactory.h	2008-09-20 18:03:29 UTC (rev 4521)
+++ rl/trunk/engine/core/include/SaveAbleFactory.h	2008-09-21 20:15:53 UTC (rev 4522)
@@ -0,0 +1,43 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __SaveAbleFactory_H__
+#define __SaveAbleFactory_H__
+
+#include "CorePrerequisites.h"
+#include "SaveAble.h"
+
+namespace rl
+{
+	class SaveAbleFactory : public Ogre::Singleton<SaveAbleFactory>
+	{
+	public:
+		virtual SaveAblePtr createSaveAble(PropertyRecordPtr params) = 0;
+	};
+
+	class SaveAbleFactoryPool : public Ogre::Singleton<SaveAbleFactoryPool>
+	{
+	public:
+		void registerFactory(const Ogre::String &key, SaveAbleFactory* fac);
+		void unregisterFactory(const Ogre::String &key);
+		void unregisterFactory(SaveAbleFactory* fac);
+		SaveAbleFactory* getFactory(const Ogre::String &key);
+	protected:
+		std::map<Ogre::String,SaveAbleFactory*> mFactories;
+	};
+}
+
+#endif

Modified: rl/trunk/engine/core/include/SaveAbleManager.h
===================================================================
--- rl/trunk/engine/core/include/SaveAbleManager.h	2008-09-20 18:03:29 UTC (rev 4521)
+++ rl/trunk/engine/core/include/SaveAbleManager.h	2008-09-21 20:15:53 UTC (rev 4522)
@@ -0,0 +1,44 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __SaveAbleManager_H__
+#define __SaveAbleManager_H__
+
+#include "CorePrerequisites.h"
+#include "SaveAble.h"
+#include "SaveAbleCollection.h"
+
+namespace rl
+{
+	class SaveAbleManager : public Ogre::Singleton<SaveAbleManager>
+	{
+	public:
+		void saveState();
+		void addSaveAble(SaveAblePtr save);
+		void removeSaveAble(SaveAblePtr save);
+		void removeSaveAble(int id);
+		void removeAllSaveAbles();
+		void attachSaveAbleToCollection(int id);
+		void deattachSaveAbleFromColltection(int id);
+		void restoreState();
+	protected:
+		std::map<int, PropertyRecordPtr> mSaveAbleStates;
+		std::map<int, SaveAblePtr> mSaveAbles;
+		std::map<Ogre::String,SaveAbleCollection> mSaveAbleCollections;
+	};
+}
+
+#endif
\ No newline at end of file

Modified: rl/trunk/engine/core/src/SaveAble.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveAble.cpp	2008-09-20 18:03:29 UTC (rev 4521)
+++ rl/trunk/engine/core/src/SaveAble.cpp	2008-09-21 20:15:53 UTC (rev 4522)
@@ -23,6 +23,10 @@
 
 namespace rl
 {
+	SaveAble::SaveAble(int id, bool isSaveAble)
+	{
+	}
+
 	void SaveAble::setSaveAble(bool enable)
 	{
 		mIsSaveAble = true;
@@ -32,4 +36,23 @@
 	{
 		return mIsSaveAble;
 	}
+
+	const Property SaveAble::getProperty(const CeGuiString& key) const
+	{
+		return Property();
+	}
+	
+	void SaveAble::setProperty(const CeGuiString& key, const Property& value)
+	{
+	}
+	
+	PropertyKeys SaveAble::getAllPropertyKeys() const
+	{
+		return PropertyKeys();
+	}
+
+	int SaveAble::getId()
+	{
+		return mId;
+	}
 }
\ No newline at end of file

Modified: rl/trunk/engine/core/src/SaveAbleCollection.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveAbleCollection.cpp	2008-09-20 18:03:29 UTC (rev 4521)
+++ rl/trunk/engine/core/src/SaveAbleCollection.cpp	2008-09-21 20:15:53 UTC (rev 4522)
@@ -14,4 +14,6 @@
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
-#include "stdinc.h"
\ No newline at end of file
+#include "stdinc.h"
+
+#include "SaveAbleCollection.h"
\ No newline at end of file

Modified: rl/trunk/engine/core/src/SaveAbleFactory.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveAbleFactory.cpp	2008-09-20 18:03:29 UTC (rev 4521)
+++ rl/trunk/engine/core/src/SaveAbleFactory.cpp	2008-09-21 20:15:53 UTC (rev 4522)
@@ -14,4 +14,6 @@
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
-#include "stdinc.h"
\ No newline at end of file
+#include "stdinc.h"
+
+#include "SaveAbleFactory.h"
\ No newline at end of file

Modified: rl/trunk/engine/core/src/SaveAbleManager.cpp
===================================================================
--- rl/trunk/engine/core/src/SaveAbleManager.cpp	2008-09-20 18:03:29 UTC (rev 4521)
+++ rl/trunk/engine/core/src/SaveAbleManager.cpp	2008-09-21 20:15:53 UTC (rev 4522)
@@ -14,4 +14,6 @@
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
-#include "stdinc.h"
\ No newline at end of file
+#include "stdinc.h"
+
+#include "SaveAbleManager.h"
\ No newline at end of file



From chrber at mail.berlios.de  Mon Sep 22 19:32:13 2008
From: chrber at mail.berlios.de (chrber at mail.berlios.de)
Date: Mon, 22 Sep 2008 19:32:13 +0200
Subject: [Dsa-hl-svn] r4523 - in rl/trunk: editors/RLdialog
	engine/common/include
Message-ID: <200809221732.m8MHWDO3023054@sheep.berlios.de>

Author: chrber
Date: 2008-09-22 19:32:06 +0200 (Mon, 22 Sep 2008)
New Revision: 4523

Modified:
   rl/trunk/editors/RLdialog/helper.h
   rl/trunk/engine/common/include/Property.h
Log:
Added Long data type to property and renamed old Long one to LongLong
Fixed a wrong include filename (even if RLdialog is not maintained at the moment)


Modified: rl/trunk/editors/RLdialog/helper.h
===================================================================
--- rl/trunk/editors/RLdialog/helper.h	2008-09-21 20:15:53 UTC (rev 4522)
+++ rl/trunk/editors/RLdialog/helper.h	2008-09-22 17:32:06 UTC (rev 4523)
@@ -2,11 +2,11 @@
 #define HELPER_H
 
 #include <QWidget>
-#include "ifDialog.h"
+#include "ifdialog.h"
 
 class startMode : public QWidget
 {
-	
+
 public:
 	startMode(QWidget *parent = 0);
 };
@@ -14,7 +14,7 @@
 class optionMode : public QWidget
 {
 	Q_OBJECT
-	
+
 public:
 	optionMode(QWidget *parent = 0);
 
@@ -31,27 +31,27 @@
 	QLabel *opt_mehrfachLabel;
 	QLabel *opt_wennLabel;
 	QLabel *opt_caseLabel;
-	
+
 	QLineEdit *opt_nameLEdit;
 	QLineEdit *opt_soundLEdit;
-	
+
 	QTextEdit *opt_textTEdit;
-	
+
 	QTreeWidget *opt_ifTree;
 	QStringList opt_ifHeaderlabels;
 	QTreeWidgetItem *if_item;
-	
+
 	QTreeWidget *opt_wennTree;
 	QTreeWidget *opt_caseTree;
-	
+
 	QToolButton *opt_ifAdd;
 	QToolButton *opt_ifRem;
 	QToolButton *opt_wenn;
 	QToolButton *opt_caseAdd;
 	QToolButton *opt_caseRem;
-	
+
 	QPushButton *opt_takeButton;
-	
+
 	QCheckBox *opt_mehrfachCheck;
 	QGroupBox *opt_mehrfachBox;
 
@@ -74,19 +74,19 @@
 	QLabel *res_soundLabel;
 	QLabel *res_effektLabel;
 	QLabel *res_gotoLabel;
-	
+
 	QLineEdit *res_nameLEdit;
 	QLineEdit *res_soundLEdit;
-	
+
 	QTextEdit *res_textTEdit;
-	
+
 	QTreeWidget *res_effektTree;
-	
+
 	QToolButton *res_effektAdd;
 	QToolButton *res_effektRem;
-	
+
 	QPushButton *res_takeButton;
-	
+
 	QComboBox *res_gotoCombo;
 };
 

Modified: rl/trunk/engine/common/include/Property.h
===================================================================
--- rl/trunk/engine/common/include/Property.h	2008-09-21 20:15:53 UTC (rev 4522)
+++ rl/trunk/engine/common/include/Property.h	2008-09-22 17:32:06 UTC (rev 4523)
@@ -1,6 +1,6 @@
-/* 
+/*
  * (C) 2003-2008. Team Pantheon. www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -78,7 +78,7 @@
 
     typedef std::vector<Property> PropertyArray;
     typedef std::map<CeGuiString, Property> PropertyMap;
-    
+
     class _RlCommonExport Property
     {
     public:
@@ -87,7 +87,8 @@
         PropertyMethod(Bool, const bool&);
         PropertyMethod(String, CEGUI::String);
         PropertyMethod(Int, const int&);
-        PropertyMethod(Long, const RL_LONGLONG&);
+        PropertyMethod(Long, const long&);
+        PropertyMethod(LongLong, const RL_LONGLONG&);
         PropertyMethod(Real, const Ogre::Real&);
         PropertyMethod(Vector3, const Ogre::Vector3&);
         PropertyMethod(Quaternion, const Ogre::Quaternion&);
@@ -163,7 +164,7 @@
             output[it->first.c_str()] = temp;
         }
     }
-    
+
     template<typename T> void convertToMap(
         const PropertyMap& propmap, std::map<const CeGuiString, T>& output)
     {
@@ -176,7 +177,7 @@
 			//output.insert(typename std::map<const CeGuiString, T>::value_type(it->first, it->second));
         }
     }
-    
+
     template<typename T> void convertToSet(
         const PropertyArray& propvec, std::set<T>& output)
     {



From melven at mail.berlios.de  Wed Sep 24 11:50:48 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 24 Sep 2008 11:50:48 +0200
Subject: [Dsa-hl-svn] r4524 - in dependencies/OgreNewt_ngt: inc src
Message-ID: <200809240950.m8O9omvJ001663@sheep.berlios.de>

Author: melven
Date: 2008-09-24 11:50:37 +0200 (Wed, 24 Sep 2008)
New Revision: 4524

Modified:
   dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h
   dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp
Log:
Added support for ConvexCast


Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h	2008-09-22 17:32:06 UTC (rev 4523)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_RayCast.h	2008-09-24 09:50:37 UTC (rev 4524)
@@ -141,8 +141,122 @@
 
 };
 
+//! general convexcast
+/*!
+	General class representing a convexcast query in the Newton world.  this class should be inherited to create specific convexcast behavior.
+*/
+class _OgreNewtExport Convexcast
+{
+public:
 
+	//! constructor
+	Convexcast();
+	
+	//! destuctor.
+	virtual ~Convexcast();
 
+	//! performs the convexcast.
+	/*!
+		call after creating the object.
+		\param world pointer to the OgreNewt::World
+                \param col pointer to a convex collision shape used for the cast
+		\param startpt starting point of ray in global space
+                \param colori orientation of the collision in global space
+		\param endpt ending point of ray in global space
+                \param maxcontactscount maximum number of contacts that should be saved,
+                       set to 0 if you only need the distance to the first intersection
+	*/
+	void go( const OgreNewt::World* world, const OgreNewt::Collision* col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount);
+
+	//! user callback pre-filter function.
+	/*!
+		This function is an optional pre-filter to completely ignore specific bodies during the raycast.
+		return false from this function to ignore this body, return true (default) to accept it.
+	*/
+	virtual bool userPreFilterCallback( OgreNewt::Body* body ) { return true; }
+
+protected:
+
+        //! list that stores the results of the convex-cast
+        NewtonWorldConvexCastReturnInfo *mReturnInfoList;
+
+        //! the real length of the list
+        int mReturnInfoListLength;
+
+        //! the actual maximum length of the list (number of elements memory has been reserved for)
+        int mReturnInfoListSize;
+
+        //! distance in [0,1] to first contact
+        Ogre::Real mFirstContactDistance;
+
+private:
+
+	//! callback used for running the raycast prefilter... used internally
+	static unsigned _CDECL newtonConvexcastPreFilter( const NewtonBody* body, const NewtonCollision* collision, void* userData );
+};
+
+
+
+
+//! Basic implementation of the convexcast
+/*!
+	This class is provided for general convexcast use.  it returns information about the body hit by the convexcast
+*/
+class _OgreNewtExport BasicConvexcast : public Convexcast
+{
+public:
+	//! simple class that represents a single convexcast contact
+	class _OgreNewtExport ConvexcastContactInfo
+	{
+	public:
+		Ogre::Real              mDistance;      //!< dist from point1 of the raycast, in range [0,1].
+		OgreNewt::Body*         mBody;          //!< pointer to body intersected with
+		int                     mCollisionID;   //!< collision ID of the primitive hit by the ray (for compound collision bodies)
+		Ogre::Vector3           mContactNormal; //!< normal of intersection.
+                Ogre::Vector3           mContactPoint;  //!< point of the contact in global space
+                Ogre::Real              mContactPenetration; //!< contact penetration at collision point
+
+		ConvexcastContactInfo();
+		~ConvexcastContactInfo();
+	};
+
+
+        //! empty constructor
+        BasicConvexcast();
+
+
+	//! constructor
+	/*!
+		performs a raycast, then the results can be queried from the object after creation.
+		\param world pointer to the OgreNewt::World
+                \param col pointer to a convex collision shape used for the cast
+		\param startpt starting point of ray in global space
+                \param colori orientation of the collision in global space
+		\param endpt ending point of ray in global space
+                \param maxcontactscount maximum number of contacts that should be saved
+	*/
+	BasicConvexcast( const OgreNewt::World* world, const OgreNewt::Collision* col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount);
+
+	//! destuctor.
+	~BasicConvexcast();
+
+	// ------------------------------------------------------
+	// the following functions can be used to retrieve information about the bodies collided by the convexcast.
+	
+	//! how many bodies did we hit? if maxcontactscount is to small, this value will be smaller too!
+	int calculateBodyHitCount() const;
+
+        //! how many contacts do we have
+        int getContactsCount() const;
+
+	//! retrieve the raycast info for a specific hit.
+	ConvexcastContactInfo getInfoAt( int hitnum ) const;
+
+        //! retrieve the distance to the first contact (in range [0,1] from startpt to endpt)
+        Ogre::Real getDistanceToFirstHit() const;
+};
+
+
 }	// end NAMESPACE OgreNewt
 	
 

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp	2008-09-22 17:32:06 UTC (rev 4523)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp	2008-09-24 09:50:37 UTC (rev 4524)
@@ -1,4 +1,5 @@
 #include "OgreNewt_RayCast.h"
+#include "OgreNewt_Tools.h"
 
 
 namespace OgreNewt
@@ -76,7 +77,7 @@
 		//return the closest hit...
 		BasicRaycast::BasicRaycastInfo ret;
 
-		Ogre::Real dist = 10000.0;
+		Ogre::Real dist = Ogre::Math::POS_INFINITY;
 
 		RaycastInfoList::const_iterator it;
 		for (it = mRayList.begin(); it != mRayList.end(); it++)
@@ -97,7 +98,7 @@
 	{
 		BasicRaycast::BasicRaycastInfo ret;
 
-		if ((hitnum < 0) || (hitnum > mRayList.size()))
+		if ((hitnum < 0) || (hitnum >= mRayList.size()))
 			return ret;
 
 		ret = mRayList.at(hitnum);
@@ -122,5 +123,130 @@
 
 
 
+
+//-------------------------------------------------------------------------------------
+        Convexcast::Convexcast() :
+            mReturnInfoList(NULL),
+            mReturnInfoListLength(0),
+            mReturnInfoListSize(0)
+        {
+        }
+
+	Convexcast::~Convexcast()
+        {
+            if( mReturnInfoList )
+            {
+                delete[] mReturnInfoList;
+            }
+        }
+
+
+	void Convexcast::go(const OgreNewt::World* world, const OgreNewt::Collision *col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount)
+	{
+                // reserve memory
+                if( mReturnInfoListSize < maxcontactscount )
+                {
+                    mReturnInfoListSize = 0;
+                    if( mReturnInfoList )
+                        delete[] mReturnInfoList;
+                    mReturnInfoList = new NewtonWorldConvexCastReturnInfo[maxcontactscount];
+                    mReturnInfoListSize = maxcontactscount;
+                }
+
+		// perform the cast
+                float matrix[16];
+                OgreNewt::Converters::QuatPosToMatrix(colori, startpt, &matrix[0] );
+                mFirstContactDistance = -1;
+                mReturnInfoListLength = 
+                        NewtonWorldConvexCast( world->getNewtonWorld(), &matrix[0], (float*)&endpt, col->getNewtonCollision(),
+                                               &mFirstContactDistance, this, OgreNewt::Convexcast::newtonConvexcastPreFilter,
+                                               mReturnInfoList, mReturnInfoListSize );
+	}
+
+	unsigned _CDECL Convexcast::newtonConvexcastPreFilter(const NewtonBody *body, const NewtonCollision *collision, void* userData)
+	{
+		// get our object!
+		Convexcast* me = (Convexcast*)userData;
+
+		Body* bod = (Body*)NewtonBodyGetUserData( body );
+
+		if (me->userPreFilterCallback( bod ))
+			return 1;
+		else
+			return 0;
+	}
+
+
+
+//-------------------------------------------------------------------------------------
+	BasicConvexcast::ConvexcastContactInfo::ConvexcastContactInfo()
+	{
+		mBody = NULL;
+		mDistance = -1.0;
+	}
+
+	BasicConvexcast::ConvexcastContactInfo::~ConvexcastContactInfo() {}
+
+        BasicConvexcast::BasicConvexcast()
+        {
+        }
+
+	BasicConvexcast::BasicConvexcast(const OgreNewt::World* world, const OgreNewt::Collision *col, const Ogre::Vector3& startpt, const Ogre::Quaternion &colori, const Ogre::Vector3& endpt, int maxcontactscount)
+	{
+		go( world, col, startpt, colori, endpt, maxcontactscount);
+	}
+
+	BasicConvexcast::~BasicConvexcast()	{}
+
+
+	int BasicConvexcast::calculateBodyHitCount() const
+        {
+            int count = 0;
+            const NewtonBody * bod = NULL;
+            for( int i = 0; i < mReturnInfoListLength; i++ )
+            {
+                if( bod != mReturnInfoList[i].m_hitBody )
+                {
+                    count++;
+                    bod = mReturnInfoList[i].m_hitBody;
+                }
+            }
+
+            return count;
+        }
+
+
+        int BasicConvexcast::getContactsCount() const
+        {
+            return mReturnInfoListLength;
+        }
+
+	BasicConvexcast::ConvexcastContactInfo BasicConvexcast::getInfoAt( int hitnum ) const
+	{
+            ConvexcastContactInfo info;
+
+            if( hitnum < 0 || hitnum >= mReturnInfoListLength )
+                return info;
+
+
+            info.mDistance = mReturnInfoList[hitnum].m_intersectionParam;
+            info.mBody = (OgreNewt::Body*) NewtonBodyGetUserData(mReturnInfoList[hitnum].m_hitBody);
+            info.mCollisionID = mReturnInfoList[hitnum].m_contactID;
+            info.mContactNormal.x = mReturnInfoList[hitnum].m_normal[0];
+            info.mContactNormal.y = mReturnInfoList[hitnum].m_normal[1];
+            info.mContactNormal.z = mReturnInfoList[hitnum].m_normal[2];
+            info.mContactPoint.x = mReturnInfoList[hitnum].m_point[0];
+            info.mContactPoint.y = mReturnInfoList[hitnum].m_point[1];
+            info.mContactPoint.z = mReturnInfoList[hitnum].m_point[2];
+            info.mContactPenetration = mReturnInfoList[hitnum].m_penetration;
+
+	    return info;
+	}
+
+        Ogre::Real BasicConvexcast::getDistanceToFirstHit() const
+        {
+            return mFirstContactDistance;
+        }
+
 }	// end NAMESPACE OgreNewt
 



From melven at mail.berlios.de  Wed Sep 24 11:56:27 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 24 Sep 2008 11:56:27 +0200
Subject: [Dsa-hl-svn] r4525 - in rl/branches/newton20/engine: core/include
	core/src ui/include ui/src
Message-ID: <200809240956.m8O9uRdh002417@sheep.berlios.de>

Author: melven
Date: 2008-09-24 11:56:24 +0200 (Wed, 24 Sep 2008)
New Revision: 4525

Modified:
   rl/branches/newton20/engine/core/include/PhysicsMaterialRaycast.h
   rl/branches/newton20/engine/core/src/ActorManager.cpp
   rl/branches/newton20/engine/core/src/PhysicsMaterialRaycast.cpp
   rl/branches/newton20/engine/ui/include/MovementControlState.h
   rl/branches/newton20/engine/ui/src/MovementControlState.cpp
Log:
-changed camera mass
-using ConvexCast for the camera movement in the MovementControlState
 TODO/BUG: ConvexCast doesn't recognize level geometry!


Modified: rl/branches/newton20/engine/core/include/PhysicsMaterialRaycast.h
===================================================================
--- rl/branches/newton20/engine/core/include/PhysicsMaterialRaycast.h	2008-09-24 09:50:37 UTC (rev 4524)
+++ rl/branches/newton20/engine/core/include/PhysicsMaterialRaycast.h	2008-09-24 09:56:24 UTC (rev 4525)
@@ -33,11 +33,12 @@
     {
         RaycastInfo() : mDistance(), mBody(), mNormal() {}
         /// dist from point1 of the raycast, in range [0,1].
-        Ogre::Real mDistance;	
+        Ogre::Real mDistance;
         /// pointer to body intersected with
         OgreNewt::Body* mBody;
         /// normal of intersection.
         Ogre::Vector3 mNormal;
+        // the collisionID for compound collisions could be added here, but we didn't need them yet
     };
 
     class _RlCoreExport PhysicsMaterialRaycast : OgreNewt::Raycast
@@ -64,6 +65,7 @@
         * If this param is NULL, every material will be found
         * @param startpt start-point of the cast
         * @param endpt end-point of the cast
+        * @param invertmat if "true", the ray finds all collisions, which do NOT have the material-id "material"
         */
         RaycastInfo execute(OgreNewt::World* world, const MaterialVector* materials,
             const Ogre::Vector3& startpt, const Ogre::Vector3& endpt, bool invertmat = false);
@@ -76,6 +78,60 @@
         bool mGetNearest;
         bool mInvertMat;
     };
+
+
+
+// --------------------------------------------------------------------------------------
+
+    // we can use the info-class from OgreNewt
+    class _RlCoreExport ConvexcastInfo : public OgreNewt::BasicConvexcast::ConvexcastContactInfo
+    {
+        public:
+            ConvexcastInfo(const OgreNewt::BasicConvexcast::ConvexcastContactInfo& info);
+    };
+
+    class _RlCoreExport PhysicsMaterialConvexcast : public OgreNewt::BasicConvexcast
+    {
+    public:
+        typedef std::vector<const OgreNewt::MaterialID*> MaterialVector;
+
+        PhysicsMaterialConvexcast();
+
+        /** executes the Convexcast
+        * @param world OgreNewt-World
+        * @param material The material, which will be found by the raycast.
+        * If this param is NULL, every material will be found
+        * @param col the collisions representing a convex shape used for the cast
+        * @param startpt start-point of the cast
+        * @param ori the orientation of the collision in global space
+        * @param endpt end-point of the cast
+        * @param invertmat if "true", the ray finds all collisions, which do NOT have the material-id "material"
+        */
+        ConvexcastInfo execute(OgreNewt::World* world, const OgreNewt::MaterialID* material,
+            const OgreNewt::Collision *col, const Ogre::Vector3& startpt, const Ogre::Quaternion &ori,
+            const Ogre::Vector3& endpt, bool invertmat = false);
+        
+        /** executes the Convexcast
+        * @param world OgreNewt-World
+        * @param materials a vector with pairs of a material and a boolean value, that describes if this material should be matched or not
+        * If this param is NULL, every material will be found
+        * @param col the collisions representing a convex shape used for the cast
+        * @param startpt start-point of the cast
+        * @param ori the orientation of the collision in global space
+        * @param endpt end-point of the cast
+        * @param invertmat if "true", the ray finds all collisions, which do NOT have the material-id "material"
+        */
+        ConvexcastInfo execute(OgreNewt::World* world, const MaterialVector* materials,
+            const OgreNewt::Collision *col, const Ogre::Vector3& startpt, const Ogre::Quaternion &ori,
+            const Ogre::Vector3& endpt, bool invertmat = false);
+
+
+        bool userPreFilterCallback( OgreNewt::Body *body );
+    private:
+        const MaterialVector *mMaterialVector;
+        const OgreNewt::MaterialID* mMaterial;
+        bool mInvertMat;
+    };
 }
 
 #endif

Modified: rl/branches/newton20/engine/core/src/ActorManager.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/ActorManager.cpp	2008-09-24 09:50:37 UTC (rev 4524)
+++ rl/branches/newton20/engine/core/src/ActorManager.cpp	2008-09-24 09:56:24 UTC (rev 4525)
@@ -291,9 +291,11 @@
         try
         {
             CameraObject* co = new CameraObject(uniquename);
+            // the mass should be as small as possible, so the camera doesn't interact with other bodies,
+            // but setting the mass to 0 means, that the body is static!
             PhysicalThing* pt = PhysicsManager::getSingleton()
                 .createPhysicalThing(GT_SPHERE, co,
-                100.0f, true);
+                0.001f, true);
             PhysicsManager::getSingleton().createPhysicsProxy(pt, NULL);
             pt->_getBody()->setMaterialGroupID(
                 PhysicsManager::getSingleton().createMaterialID("camera"));

Modified: rl/branches/newton20/engine/core/src/PhysicsMaterialRaycast.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/PhysicsMaterialRaycast.cpp	2008-09-24 09:50:37 UTC (rev 4524)
+++ rl/branches/newton20/engine/core/src/PhysicsMaterialRaycast.cpp	2008-09-24 09:56:24 UTC (rev 4525)
@@ -120,4 +120,93 @@
         return mGetNearest;
     }
 
+
+// -------------------------------------------------------------------------------------------------
+
+    ConvexcastInfo::ConvexcastInfo(const OgreNewt::BasicConvexcast::ConvexcastContactInfo &info) :
+        ConvexcastContactInfo(info)
+    {
+    }
+
+    PhysicsMaterialConvexcast::PhysicsMaterialConvexcast() :
+        mMaterialVector(NULL),
+        mMaterial(NULL),
+        mInvertMat(false)
+    {
+    }
+
+    ConvexcastInfo PhysicsMaterialConvexcast::execute(OgreNewt::World* world, const OgreNewt::MaterialID* material,
+                        const OgreNewt::Collision *col, const Vector3& startpt, const Quaternion &ori,
+                        const Vector3& endpt, bool invertmat)
+    {
+        mMaterialVector = NULL;
+        mMaterial = material;
+        mInvertMat = invertmat;
+
+        BasicConvexcast::go(world, col, startpt, ori, endpt, 1);
+
+        return ConvexcastInfo(BasicConvexcast::getInfoAt(0));
+    }
+
+    ConvexcastInfo PhysicsMaterialConvexcast::execute(OgreNewt::World* world, const MaterialVector* materials,
+                        const OgreNewt::Collision *col, const Vector3& startpt, const Quaternion &ori,
+                        const Vector3& endpt, bool invertmat)
+    {
+        mMaterialVector = materials;
+        mMaterial = NULL;
+        mInvertMat = invertmat;
+
+        BasicConvexcast::go(world, col, startpt, ori, endpt, 1);
+
+        return ConvexcastInfo(BasicConvexcast::getInfoAt(0));
+    }
+
+    bool PhysicsMaterialConvexcast::userPreFilterCallback( OgreNewt::Body *body )
+    {
+        if( body->getMaterialGroupID() == NULL )
+        {
+            LOG_MESSAGE(Logger::CORE, "Warning PhysicsMaterialRaycast found body without material (getMaterialGroupId() == NULL)!");
+            return true;
+        }
+        else if( body->getMaterialGroupID() == PhysicsManager::getSingleton().createMaterialID("gamearea") ) // don't trigger gameareas
+        {
+            return false;
+        }
+        else
+        {
+            if( mMaterial == NULL && mMaterialVector == NULL)
+            {
+                return true;
+            }
+            else if( mMaterial != NULL )
+            {
+                if (body->getMaterialGroupID()->getID() == mMaterial->getID() && !mInvertMat ||
+                    body->getMaterialGroupID()->getID() != mMaterial->getID() && mInvertMat)
+                {
+                    return true;
+                }
+            }
+            else // mMaterialVector != NULL
+            {
+                bool found = false;
+
+                MaterialVector::const_iterator iter;
+                for(iter = mMaterialVector->begin(); iter != mMaterialVector->end(); iter++)
+                {
+                    if (body->getMaterialGroupID()->getID() == (*iter)->getID())
+                    {
+                        found = true;
+                        break;
+                    }
+                }
+
+                if( found && !mInvertMat || !found && mInvertMat )
+                {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
 }

Modified: rl/branches/newton20/engine/ui/include/MovementControlState.h
===================================================================
--- rl/branches/newton20/engine/ui/include/MovementControlState.h	2008-09-24 09:50:37 UTC (rev 4524)
+++ rl/branches/newton20/engine/ui/include/MovementControlState.h	2008-09-24 09:56:24 UTC (rev 4525)
@@ -123,12 +123,8 @@
 
         ViewMode mViewMode;
 
-        int mObstractedFrameCount;
-        Ogre::Real mObstractedTime;
-        int mCameraJammedFrameCount;
-        Ogre::Real mCameraJammedTime;
-
         PhysicsMaterialRaycast* mRaycast;
+        PhysicsMaterialConvexcast * mConvexcast;
         HalfSphereSelector mSelector;
         HalfSphereSelector mCombatSelector;
 

Modified: rl/branches/newton20/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/MovementControlState.cpp	2008-09-24 09:50:37 UTC (rev 4524)
+++ rl/branches/newton20/engine/ui/src/MovementControlState.cpp	2008-09-24 09:56:24 UTC (rev 4525)
@@ -85,15 +85,12 @@
         mRotationSpeed(Degree(120.0f)),
         mMouseSensitivity(4.0f),
         mViewMode(VM_THIRD_PERSON),
-        mObstractedFrameCount(0),
-        mObstractedTime(0.0f),
-        mCameraJammedFrameCount(0),
-        mCameraJammedTime(0.0f),
         mRaycast(new PhysicsMaterialRaycast()),
+        mConvexcast(new PhysicsMaterialConvexcast()),
         mSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager()),
         mCombatSelector(CoreSubsystem::getSingleton().getWorld()->getSceneManager(),
             QUERYFLAG_CREATURE),
-        mCharPositionsBuffer(20),
+        mCharPositionsBuffer(100),
         mCharPositionsBufferIdx(-1),
         mCharacterOccludedTime(0),
         mCharacterOccludedFrameCount(0),
@@ -147,6 +144,7 @@
         delete mSelector.getFilter();
         mSelector.setFilter(NULL);
         delete mRaycast;
+        delete mConvexcast;
 
         if (DebugWindow::getSingletonPtr())
         {
@@ -268,42 +266,6 @@
         }
 
 
-
-
-        // Do we need to reset the Camera?
-        Vector3 charPos = mCharacterActor->getWorldPosition();
-        Quaternion charOri = mCharacterActor->getWorldOrientation();
-        //mCharBody->getPositionOrientation(charPos, charOri);
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody->getPositionOrientation(camPos, camOri);
-
-        float maxdistance;
-        if (mViewMode == VM_FIRST_PERSON)
-            maxdistance = 0.25;
-        else
-            maxdistance = 1.3f * mDesiredDistance + 1.4f;
-
-        // if we have more than 250ms and at least five frames with camera distance higher
-        // than desired distance, reset camera
-        if ((camPos - (charPos + charOri*mLookAtOffset)).length() > maxdistance)
-        {
-            mCameraJammedTime += elapsedTime;
-            ++mCameraJammedFrameCount;
-        }
-        else
-        {
-            mCameraJammedTime = 0.0f;
-            mCameraJammedFrameCount = 0;
-        }
-
-        if (mCameraJammedTime > 0.250f && mCameraJammedFrameCount > 5)
-        {
-            mCameraJammedFrameCount = 0;
-            resetCamera();
-        }
-
         mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
 
         if (isEnemyNear())
@@ -819,6 +781,8 @@
                 charPos,
                 true);
 
+
+            // reset the camera if the character is to far away or cannot be seen any more (Raycast)
             Real maxdistance = Math::Pow(1.5f * mDesiredDistance + 1.4f, 2);
             if( infoCastChar.mBody || (camPos - charPos).squaredLength() > maxdistance)
             {
@@ -826,7 +790,7 @@
                 mCharacterOccludedFrameCount++;
 
                 // falls zu lange, Kamera resetten:
-                if( mCharacterOccludedTime > 0.500f && mCharacterOccludedFrameCount > 10 )
+                if( mCharacterOccludedTime > 0.250f && mCharacterOccludedFrameCount > 5 )
                 {
                     resetCamera();
                     return;
@@ -834,45 +798,45 @@
 
             }
             else
+            {
                 mCharacterOccludedTime = 0;
+                mCharacterOccludedFrameCount = 0;
+            }
 
-            if( infoCastOptPos.mBody )
+            if( infoCastOptPos.mBody && !infoCastChar.mBody )
             {
-                if( !infoCastChar.mBody ) // Character noch im Blickfeld
-                {
-                    // andere Position ermitteln, die ziwschen optimaler und Character liegt
-                    // und erreichbar ist
-                    Real lenToOptCamPos = (optimalCamPos - charPos).length();
+                // andere Position ermitteln, die ziwschen optimaler und Character liegt
+                // und erreichbar ist
+                Real lenToOptCamPos = (optimalCamPos - charPos).length();
 
-                    RaycastInfo infoCastNewPos;
-                    Real delta = lenToOptCamPos/2.0f;
-                    Vector3 temp = charPos + delta * normToOptCamPos;
-                    // Annaeherung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
-                    while( delta > 0.05 ) // genauigkeit des gefundenen Punktes
+                RaycastInfo infoCastNewPos;
+                Real delta = lenToOptCamPos/2.0f;
+                Vector3 temp = charPos + delta * normToOptCamPos;
+                // Annaeherung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
+                while( delta > 0.05 ) // genauigkeit des gefundenen Punktes
+                {
+                    infoCastNewPos = mRaycast->execute(
+                        world,
+                        &materialVector,
+                        camPos + camRadius * normToOptCamPos, // Groesse der Kamera!
+                        temp,
+                        true);
+                    delta = delta/2.0f;
+                    if( infoCastNewPos.mBody ) // Hindernis gefunden, naeher an Char ran
                     {
-                        infoCastNewPos = mRaycast->execute(
-                            world,
-                            &materialVector,
-                            camPos + camRadius * normToOptCamPos, // Groesse der Kamera!
-                            temp,
-                            true);
-                        delta = delta/2.0f;
-                        if( infoCastNewPos.mBody ) // Hindernis gefunden, naeher an Char ran
-                        {
-                            temp = temp - delta * normToOptCamPos;
-                        }
-                        else // kein Hindernis gefunden, weiter von Char weg
-                        {
-                            temp = temp + delta * normToOptCamPos;
-                        }
+                        temp = temp - delta * normToOptCamPos;
                     }
-
-                    // Jetzt koennen wir sicher sein, dass diese Stelle erreichbar ist:
-                    temp = temp - 0.05 * normToOptCamPos;
-                    // Groesse der Kamera einbeziehen
-                    optimalCamPos = temp - camRadius * normToOptCamPos;
-                    // so ab hier kann ganz normal weiter gerechnet werden!
+                    else // kein Hindernis gefunden, weiter von Char weg
+                    {
+                        temp = temp + delta * normToOptCamPos;
+                    }
                 }
+
+                // Jetzt koennen wir sicher sein, dass diese Stelle erreichbar ist:
+                temp = temp - 0.05 * normToOptCamPos;
+                // Groesse der Kamera einbeziehen
+                optimalCamPos = temp - camRadius * normToOptCamPos;
+                // so ab hier kann ganz normal weiter gerechnet werden!
             }
 
 
@@ -885,7 +849,7 @@
                 // hier werden erstmal nur alte Player-Positionen betrachtet
                 // es wird davon ausgegangen, dass diese "nah" genug aneinanderliegen
                 // und durch "Geraden" miteinander verbunden werden koennen
-                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
+                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem fluessig
                 // und weich (keine scharfen Kurven) erscheinen
 
                 size_t buffSize = mCharPositionsBuffer.size();
@@ -1025,75 +989,36 @@
                                                 Math::Cos(mPitch) * mDesiredDistance);
             }
 
+            Vector3 diff = targetCamPos - charPos;
 
-            // Kamera-Gr?e beziehen
-            CameraObject* ogreCam = static_cast<CameraObject*>(
-                mCameraActor->getControlledObject());
-            AxisAlignedBox aabb = ogreCam->getDefaultSize();
-            // Radius berechnen
-            Real radius = (aabb.getMaximum().z - aabb.getMinimum().z) / 2.0f;
-            radius *= 1.1f; // bissle was dazu tun schadet nich, da ja nur wenige raycasts gemacht werden
-            // unds eigentlich ne kugel ist!
-
-
-
-            Vector3 startRay[6], endRay[6];
-
-            Real sinPitchRad = Math::Sin(mPitch) * radius;
-            Real cosPitchRad = Math::Cos(mPitch) * radius;
-            Vector3 radiusOffset = charOri * Vector3(0, sinPitchRad, cosPitchRad);
-
-            startRay[0] = charPos;
-            endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
-                                      // dadurch kann aber sichergestellt
-                                      // werden, dass kein Objekt direkt
-                                      // hinter dem Helden bersehen wird
-            startRay[1] = charPos + radiusOffset;
-            endRay[1] = targetCamPos + radiusOffset;
-            radiusOffset = charOri * Vector3(radius, sinPitchRad, cosPitchRad);
-            startRay[2] = charPos + radiusOffset;
-            endRay[2] = targetCamPos + radiusOffset;
-            startRay[3] = charPos - radiusOffset;
-            endRay[3] = targetCamPos - radiusOffset;
-            radiusOffset = charOri * Vector3(0, radius-cosPitchRad, -sinPitchRad);
-            startRay[4] = charPos + radiusOffset;
-            endRay[4] = targetCamPos + radiusOffset;
-            startRay[5] = charPos - radiusOffset;
-            endRay[5] = targetCamPos - radiusOffset;
-
-            const OgreNewt::MaterialID* materialId =
-                mCharBody->getMaterialGroupID();
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
+            // Convexcast
+            PhysicsMaterialConvexcast::MaterialVector materialVector;
+            materialVector.push_back( mCharBody->getMaterialGroupID() );
+            materialVector.push_back( mCamBody->getMaterialGroupID() );
             OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
 
-            Vector3 diff = targetCamPos - charPos;
-            bool CollisionFound = false;
-            for( int i = 0; i < 6; i++ )
-            {
-                RaycastInfo info = mRaycast->execute(
+            ConvexcastInfo info = mConvexcast->execute(
                     world,
-                    materialId,
-                    startRay[i],
-                    endRay[i],
+                    &materialVector,
+                    mCamBody->getCollision(),
+                    charPos,
+                    Quaternion::IDENTITY,
+                    targetCamPos,
                     true);
 
-                if( info.mBody && info.mBody != mCamBody )
-                {
-                    CollisionFound = true;
-                    Vector3 newdiff = (info.mDistance) * (endRay[i] - startRay[i]);
-                    if( newdiff.squaredLength() < diff.squaredLength() )
-                        diff = newdiff;
-                    if( i == 0 ) // beim ersten schon nahes hindernis gefunden?
-                    {
-                        if( diff.squaredLength() < radius*radius )
-                        {
-                            diff -= charOri * Vector3(0, sinPitchRad, cosPitchRad);
-                            break;
-                        }
-                    }
-                }
+            bool CollisionFound = false;
+            if( info.mBody )
+            {
+                CollisionFound = true;
+                Real hitBodyVel = info.mBody->getVelocity().dotProduct(diff.normalisedCopy());
+                hitBodyVel = std::min(0.0f, hitBodyVel); // if the body moves, try to avoid it
+                Real dist = std::max(info.mDistance + (hitBodyVel*timestep - 0.1)/diff.length(), 0.0);
+                diff *= dist;
+
+                mLastCameraCollision = 0;
             }
 
+
             // Langsames Entfernen vom Char:
             if( CollisionFound )
                 mTimeOfLastCollision = 0.0f;



From melven at mail.berlios.de  Wed Sep 24 13:01:14 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Wed, 24 Sep 2008 13:01:14 +0200
Subject: [Dsa-hl-svn] r4526 - in rl/branches/newton20: editors/Lockenwickler
	editors/Lockenwickler/src editors/Lockenwickler/src/media
	editors/Lockenwickler/src/media/icons editors/RLdialog
	engine/common/include engine/core/include engine/core/src
Message-ID: <200809241101.m8OB1Elx014621@sheep.berlios.de>

Author: melven
Date: 2008-09-24 13:00:44 +0200 (Wed, 24 Sep 2008)
New Revision: 4526

Added:
   rl/branches/newton20/editors/Lockenwickler/src/SceneExplorer.py
   rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_Arrow.mesh
   rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_FreeMover.mesh
   rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_Point.material
   rl/branches/newton20/editors/Lockenwickler/src/media/Rotate_Torus.mesh
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/back.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/configure.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/console.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/decrypted.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/edit.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/edit_add.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/edit_remove.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/editclear.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/editcopy.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/editcut.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/editdelete.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/editpaste.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/encrypted.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/endturn.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/exit.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/fileexport.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/filenew.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/filesave.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/find.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/forward.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/goto.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/idea.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/move.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/move_task_down.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/move_task_up.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/ok.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/playlist.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/redo.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/resizecol.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/rotate.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/tux.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/unsortedlist1.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/view_tree.png
   rl/branches/newton20/editors/Lockenwickler/src/media/pivots.blend
Removed:
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/back.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/configure.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/console.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/decrypted.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/edit.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/edit_add.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/edit_remove.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/editclear.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/editcopy.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/editcut.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/editdelete.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/editpaste.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/encrypted.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/endturn.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/exit.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/fileexport.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/filenew.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/filesave.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/find.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/forward.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/goto.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/idea.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/move.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/move_task_down.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/move_task_up.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/ok.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/playlist.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/redo.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/resizecol.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/rotate.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/tux.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/unsortedlist1.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/view_tree.png
Modified:
   rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p
   rl/branches/newton20/editors/Lockenwickler/src/ConsoleWindow.py
   rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py
   rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py
   rl/branches/newton20/editors/Lockenwickler/src/MovePivot.py
   rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py
   rl/branches/newton20/editors/Lockenwickler/src/Plugins-linux.cfg
   rl/branches/newton20/editors/Lockenwickler/src/PreferencesDialog.py
   rl/branches/newton20/editors/Lockenwickler/src/ui_pref_dialog.py
   rl/branches/newton20/editors/RLdialog/RLdialog.pro
   rl/branches/newton20/editors/RLdialog/helper.h
   rl/branches/newton20/engine/common/include/Property.h
   rl/branches/newton20/engine/core/include/SaveAble.h
   rl/branches/newton20/engine/core/include/SaveAbleCollection.h
   rl/branches/newton20/engine/core/include/SaveAbleFactory.h
   rl/branches/newton20/engine/core/include/SaveAbleManager.h
   rl/branches/newton20/engine/core/src/SaveAble.cpp
   rl/branches/newton20/engine/core/src/SaveAbleCollection.cpp
   rl/branches/newton20/engine/core/src/SaveAbleFactory.cpp
   rl/branches/newton20/engine/core/src/SaveAbleManager.cpp
Log:
merged changes from trunk


Modified: rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p	2008-09-24 11:00:44 UTC (rev 4526)
@@ -1,161 +1,179 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE Project SYSTEM "Project-4.2.dtd">
-<!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2008-06-23, 19:40:36 -->
-<!-- Copyright (C) 2008 Stefan Stammberger, sstammberger at web.de -->
-<Project version="4.2">
-  <ProgLanguage mixed="0">Python</ProgLanguage>
-  <ProjectType>Qt4</ProjectType>
-  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
-  <Version>0.1</Version>
-  <Author>Stefan Stammberger</Author>
-  <Email>sstammberger at web.de</Email>
-  <Sources>
-    <Source>
-      <Dir>src</Dir>
-      <Name>Lockenwickler.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ConsoleWindow.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ModelSelectionDialog.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ModuleManager.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>MovePivot.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ObjectPropertyWin.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>OdeManager.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>OgreMainWindow.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>OgreWidget.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>PreferencesDialog.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>PythonOgreConfig.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ui_ConsoleWindow.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ui_FourPanelView.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ui_lw.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ui_model_prev.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ui_obj_prop.py</Name>
-    </Source>
-    <Source>
-      <Dir>src</Dir>
-      <Name>ui_pref_dialog.py</Name>
-    </Source>
-    <Source>
-      <Dir>ui files</Dir>
-      <Name>batch_convert_ui.py</Name>
-    </Source>
-    <Source>
-      <Dir>ui files</Dir>
-      <Name>ui_ConsoleWindow.py</Name>
-    </Source>
-    <Source>
-      <Dir>ui files</Dir>
-      <Name>ui_FourPanelView.py</Name>
-    </Source>
-    <Source>
-      <Dir>ui files</Dir>
-      <Name>ui_lw.py</Name>
-    </Source>
-    <Source>
-      <Dir>ui files</Dir>
-      <Name>ui_model_prev.py</Name>
-    </Source>
-    <Source>
-      <Dir>ui files</Dir>
-      <Name>ui_obj_prop.py</Name>
-    </Source>
-    <Source>
-      <Dir>ui files</Dir>
-      <Name>ui_pref_dialog.py</Name>
-    </Source>
-  </Sources>
-  <Forms>
-    <Form>
-      <Dir>ui files</Dir>
-      <Name>console_window.ui</Name>
-    </Form>
-    <Form>
-      <Dir>ui files</Dir>
-      <Name>FourPanelView.ui</Name>
-    </Form>
-    <Form>
-      <Dir>ui files</Dir>
-      <Name>lockewickler.ui</Name>
-    </Form>
-    <Form>
-      <Dir>ui files</Dir>
-      <Name>model_preview.ui</Name>
-    </Form>
-    <Form>
-      <Dir>ui files</Dir>
-      <Name>object_property.ui</Name>
-    </Form>
-    <Form>
-      <Dir>ui files</Dir>
-      <Name>preferences_dialog.ui</Name>
-    </Form>
-  </Forms>
-  <Translations>
-  </Translations>
-  <Resources>
-  </Resources>
-  <Interfaces>
-  </Interfaces>
-  <Others>
-  </Others>
-  <MainScript>
-    <Dir>src</Dir>
-    <Name>Lockenwickler.py</Name>
-  </MainScript>
-  <Vcs>
-    <VcsType>None</VcsType>
-  </Vcs>
-  <FiletypeAssociations>
-    <FiletypeAssociation pattern="*.ui" type="FORMS" />
-    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
-    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
-    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
-    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
-    <FiletypeAssociation pattern="*.py" type="SOURCES" />
-    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
-  </FiletypeAssociations>
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE Project SYSTEM "Project-4.4.dtd">
+<!-- eric4 project file for project Lockenwickler -->
+<!-- Saved: 2008-09-20, 20:03:11 -->
+<!-- Copyright (C) 2008 Stefan Stammberger, sstammberger at web.de -->
+<Project version="4.4">
+  <ProgLanguage mixed="0">Python</ProgLanguage>
+  <ProjectType>Qt4</ProjectType>
+  <Description>Lockenwickler is an Editor application for the Rastulahs Lockenpracht game.</Description>
+  <Version>0.1</Version>
+  <Author>Stefan Stammberger</Author>
+  <Email>sstammberger at web.de</Email>
+  <Sources>
+    <Source>src/Lockenwickler.py</Source>
+    <Source>src/ConsoleWindow.py</Source>
+    <Source>src/ModelSelectionDialog.py</Source>
+    <Source>src/ModuleManager.py</Source>
+    <Source>src/MovePivot.py</Source>
+    <Source>src/ObjectPropertyWin.py</Source>
+    <Source>src/OdeManager.py</Source>
+    <Source>src/OgreMainWindow.py</Source>
+    <Source>src/OgreWidget.py</Source>
+    <Source>src/PreferencesDialog.py</Source>
+    <Source>src/PythonOgreConfig.py</Source>
+    <Source>src/ui_ConsoleWindow.py</Source>
+    <Source>src/ui_FourPanelView.py</Source>
+    <Source>src/ui_lw.py</Source>
+    <Source>src/ui_model_prev.py</Source>
+    <Source>src/ui_obj_prop.py</Source>
+    <Source>src/ui_pref_dialog.py</Source>
+    <Source>ui files/batch_convert_ui.py</Source>
+    <Source>ui files/ui_ConsoleWindow.py</Source>
+    <Source>ui files/ui_FourPanelView.py</Source>
+    <Source>ui files/ui_lw.py</Source>
+    <Source>ui files/ui_model_prev.py</Source>
+    <Source>ui files/ui_obj_prop.py</Source>
+    <Source>ui files/ui_pref_dialog.py</Source>
+    <Source>src/SceneExplorer.py</Source>
+  </Sources>
+  <Forms>
+    <Form>ui files/console_window.ui</Form>
+    <Form>ui files/FourPanelView.ui</Form>
+    <Form>ui files/lockewickler.ui</Form>
+    <Form>ui files/model_preview.ui</Form>
+    <Form>ui files/object_property.ui</Form>
+    <Form>ui files/preferences_dialog.ui</Form>
+  </Forms>
+  <Translations>
+  </Translations>
+  <Resources>
+  </Resources>
+  <Interfaces>
+  </Interfaces>
+  <Others>
+  </Others>
+  <MainScript>src/Lockenwickler.py</MainScript>
+  <Vcs>
+    <VcsType>Subversion</VcsType>
+    <VcsOptions>
+      <dict>
+        <key>
+          <string>add</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>checkout</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>commit</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>diff</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>export</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>global</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>history</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>log</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>remove</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>status</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>tag</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+        <key>
+          <string>update</string>
+        </key>
+        <value>
+          <list>
+            <string></string>
+          </list>
+        </value>
+      </dict>
+    </VcsOptions>
+    <VcsOtherData>
+      <dict>
+        <key>
+          <string>standardLayout</string>
+        </key>
+        <value>
+          <bool>True</bool>
+        </value>
+      </dict>
+    </VcsOtherData>
+  </Vcs>
+  <FiletypeAssociations>
+    <FiletypeAssociation pattern="*.ui" type="FORMS" />
+    <FiletypeAssociation pattern="*.idl" type="INTERFACES" />
+    <FiletypeAssociation pattern="*.ptl" type="SOURCES" />
+    <FiletypeAssociation pattern="*.pyw" type="SOURCES" />
+    <FiletypeAssociation pattern="*.ui.h" type="FORMS" />
+    <FiletypeAssociation pattern="*.py" type="SOURCES" />
+    <FiletypeAssociation pattern="*.qrc" type="RESOURCES" />
+  </FiletypeAssociations>
 </Project>
\ No newline at end of file

Modified: rl/branches/newton20/editors/Lockenwickler/src/ConsoleWindow.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ConsoleWindow.py	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/editors/Lockenwickler/src/ConsoleWindow.py	2008-09-24 11:00:44 UTC (rev 4526)
@@ -25,10 +25,10 @@
         sys.stderr = self
 
     def write(self, text):
-        if text.isspace():
-            return
         if self.filterLog:
-            if text.startswith("Error"):
+            if text.isspace():
+                return
+            elif text.startswith("Error"):
                 self.consoleWindow.textEdit.append(text)
                 return
             elif text.startswith("OGRE EXCEPTION"):

Modified: rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py	2008-09-24 11:00:44 UTC (rev 4526)
@@ -2,8 +2,8 @@
 import sys
 import platform
 
-sys.path.insert(0,'..')
-import PythonOgreConfig
+#sys.path.insert(0,'..')
+#import PythonOgreConfig
 
 from random import randint
 from os.path import isfile
@@ -14,8 +14,8 @@
 from ModelSelectionDialog import *
 from ConsoleWindow import *
 from ModuleManager import *
+from SceneExplorer import *
 
-
 import OgreMainWindow
 import ogre.renderer.OGRE as og
 
@@ -26,37 +26,61 @@
         self.setupUi()
 
         self.consoleWindow = ConsoleWindow(False,  self)
-        QtCore.QObject.connect(self.actionConsole_Window, QtCore.SIGNAL("triggered()"),
-                                    self.toggleConsoleWindow)
 
         self.setupOgre()
 
         self.prefDialog = PreferencesDialog(self.loadModule, self)
-        QtCore.QObject.connect(self.actionPreferences, QtCore.SIGNAL("triggered()"),
-                                    self.togglePreferencesWindow)
-
         self.objectPropertyWin = ObjectPropertyWin(self)
-        QtCore.QObject.connect(self.actionProperty_Window, QtCore.SIGNAL("triggered()"),
-                                    self.togglePropertyWindow)
-
+        self.sceneExplorerWin = SceneExplorer(self)
         self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
-        QtCore.QObject.connect(self.actionObject_Selection, QtCore.SIGNAL("triggered()"),
-                                    self.toggleModelPreviewWindow)
 
-        QtCore.QObject.connect(self.actionClose, QtCore.SIGNAL("triggered()"),
-                                    self.update)
-
         self.createDockWindows()
 
         self.mainTimer = QtCore.QTimer(self)
         self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL("timeout()"), self.update)
-        self.mainTimer.start(33)
+        self.mainTimer.start(5)
 
-        QtGui.QApplication.setKeyboardInputInterval(5000)
+        settings = QtCore.QSettings()
+        self.restoreGeometry(settings.value("MainWindow/Geometry").toByteArray())
+        self.restoreState(settings.value("MainWindow/DockWindows").toByteArray())
 
+        self.setWindowTitle("Rastullahs Lockenwickler")
+#        # Import Psyco if available
+#        try:
+#            import psyco
+#            psyco.full()
+#            #psyco.log()
+#            #psyco.profile()
+#        except ImportError:
+#            pass
+
+        #QtGui.QApplication.setKeyboardInputInterval(5000)
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QtGui.QAction(text, self)
+        if icon is not None:
+            action.setIcon(QtGui.QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            self.connect(action, QtCore.SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+
+    def addActions(self, target, actions):
+        for act in actions:
+            if act is None:
+               target.addSeparator()
+            else:
+                target.addAction(act)
+
     def setupUi(self):
         self.setObjectName("MainWindow")
-        self.resize(QtCore.QSize(QtCore.QRect(0,0,660,657).size()).expandedTo(self.minimumSizeHint()))
 
         self.centralwidget = QtGui.QWidget(self)
         self.centralwidget.setObjectName("centralwidget")
@@ -68,7 +92,6 @@
         self.gridlayout.setObjectName("gridlayout")
 
         self.menubar = QtGui.QMenuBar(self)
-        self.menubar.setGeometry(QtCore.QRect(0,0,660,22))
         self.menubar.setObjectName("menubar")
 
         self.menuFile = QtGui.QMenu(self.menubar)
@@ -78,35 +101,48 @@
         self.menuView.setObjectName("menuView")
         self.setMenuBar(self.menubar)
 
+
         self.statusbar = QtGui.QStatusBar(self)
         self.statusbar.setObjectName("statusbar")
         self.setStatusBar(self.statusbar)
 
-        self.actionNeu = QtGui.QAction(self)
+        self.actionNeu = QtGui.QAction(QtGui.QIcon("media/icons/package.png"), "&New",  self)
         self.actionNeu.setObjectName("actionNeu")
 
-        self.actionSceneGraph = QtGui.QAction(self)
-        self.actionSceneGraph.setCheckable(False)
-        self.actionSceneGraph.setObjectName("actionSceneGraph")
+        self.actionClose = self.createAction("Quit",  self.close,  "Alt + Q",  "exit.png",  "Quit")
+        self.actionClose.setObjectName("actionClose")
 
-        self.actionPreferences = QtGui.QAction(self)
-        self.actionPreferences.setCheckable(False)
+
+
+        self.actionMove = self.createAction("&Move",  self.actionMoveSlot,  "g",  "move.png",  "Move selected object")
+        self.actionMove.setObjectName("actionMove")
+
+        self.actionRotate = self.createAction("&Rotate",  self.actionRotateSlot,  "r",  "rotate.png",  "Rotate selected object")
+        self.actionRotate.setObjectName("actionRotate")
+
+        self.actionScale = self.createAction("&Scale",  self.actionScaleSlot,  "s",  "resizecol.png",  "Scale selected object")
+        self.actionRotate.setObjectName("actionRotate")
+
+
+        self.actionSceneExplorer = self.createAction("&Scene Exlporer",  self.toggleSceneExplorer,  "Alt + E",  "view_tree.png",  "Scene Explorer",  False)
+        self.actionSceneExplorer.setObjectName("actionSceneExplorer")
+
+        self.actionPreferences = self.createAction("&Preferences",  self.togglePreferencesWindow,  "Alt + P",  "configure.png",  "Lockenwickler Preferences",  False)
         self.actionPreferences.setObjectName("actionPreferences")
 
-        self.actionProperty_Window = QtGui.QAction(self)
+        self.actionProperty_Window = self.createAction("Pr&operty Window",  self.togglePropertyWindow,  "Alt + P",  "unsortedlist1.png",  "Property Window")
         self.actionProperty_Window.setObjectName("actionProperty_Window")
 
-        self.actionObject_Selection = QtGui.QAction(self)
+        self.actionObject_Selection = self.createAction("&Model Preview Window",  self.toggleModelPreviewWindow,  "Alt + O",  "tux.png",  "Model Preview")
         self.actionObject_Selection.setObjectName("actionObject_Selection")
 
-        self.actionClose = QtGui.QAction(self)
-        self.actionClose.setObjectName("actionClose")
+        self.actionConsole_Window = self.createAction("&Console Window",  self.toggleConsoleWindow,  "Alt + C",  "console.png",  "Console Window")
+        self.actionConsole_Window.setObjectName("actionConsole_Window")
 
-        self.actionConsole_Window = QtGui.QAction(self)
-        self.actionConsole_Window.setObjectName("actionConsole_Window")
+
         self.menuFile.addAction(self.actionNeu)
         self.menuFile.addAction(self.actionClose)
-        self.menuView.addAction(self.actionSceneGraph)
+        self.menuView.addAction(self.actionSceneExplorer)
         self.menuView.addAction(self.actionPreferences)
         self.menuView.addAction(self.actionProperty_Window)
         self.menuView.addAction(self.actionObject_Selection)
@@ -121,8 +157,10 @@
         self.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
         self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
         self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "Neu", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionSceneGraph.setText(QtGui.QApplication.translate("MainWindow", "SceneGraph", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "New", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionMove.setText(QtGui.QApplication.translate("MainWindow", "Move", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionRotate.setText(QtGui.QApplication.translate("MainWindow", "Rotate", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionSceneExplorer.setText(QtGui.QApplication.translate("MainWindow", "Scene Explorer", None, QtGui.QApplication.UnicodeUTF8))
         self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
         self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
         self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
@@ -138,11 +176,7 @@
         root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
         self.ogreRoot = root
 
-        # setup resources
-        config = og.ConfigFile()
-
-        carryOn = root.showConfigDialog()
-        if not carryOn:
+        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
             sys.exit('Quit from Config Dialog')
 
         root.initialise(False)
@@ -153,7 +187,7 @@
         self.moduleName = ""
         self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
 
-        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr, self)
+        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
         self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
         self.hboxlayout.addLayout(self.gridlayout)
         self.setCentralWidget(self.centralwidget)
@@ -167,6 +201,15 @@
     def update(self):
         self.ogreRoot.renderOneFrame()
 
+    def actionMoveSlot(self):
+        print "MOVE!!!!!!!!!!!"
+
+    def actionRotateSlot(self):
+        print "ROTATE!!!!!!!!!"
+
+    def actionScaleSlot(self):
+        print "Scale!!!!!!!!"
+
     def togglePreferencesWindow(self):
         if self.prefDialog.isHidden():
             self.prefDialog.show()
@@ -179,6 +222,12 @@
         else:
             self.modelSelectionDock.hide()
 
+    def toggleSceneExplorer(self):
+        if self.sceneExplorerDock.isHidden():
+            self.sceneExplorerDock.show()
+        else:
+            self.sceneExplorerDock.hide()
+
     def togglePropertyWindow(self):
         if self.propertyDock.isHidden():
             self.propertyDock.show()
@@ -186,10 +235,10 @@
             self.propertyDock.hide()
 
     def toggleConsoleWindow(self):
-        if self.consoleWindow.isHidden():
-            self.consoleWindow.show()
+        if self.consoleDock.isHidden():
+            self.consoleDock.show()
         else:
-            self.consoleWindow.hide()
+            self.consoleDock.hide()
 
     # parses the moduleconfig.rb and searches for all loader.loadmap(" statements in the ruby script
     # and parses them too
@@ -202,6 +251,7 @@
         self.workingDirCommon = modulePath + "common" # the module path of the common module
 
         import codecs
+        import glob
 
         modConfig = self.workingDir + "/scripts/moduleconfig.rb"
         if isfile(modConfig): # is the modconfig existing?
@@ -232,6 +282,14 @@
         self.setResourcePaths(self.workingDirCommon, "common")
         og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
 
+        command = (os.path.join(self.workingDir,  "maps") + "/*.xml")
+        for mf in glob.glob(command): # search for all xml files in the maps directory and add them
+            self.mapFiles.append(mf)
+
+        command = (os.path.join(self.workingDir,  "maps") + "/*.scene")
+        for mf in glob.glob(command): # search for all xml files in the maps directory and add them
+            self.mapFiles.append(mf)
+
         self.moduleManager.load(moduleName,  self.mapFiles)
 
     def setResourcePaths(self, path, moduleName):
@@ -249,27 +307,44 @@
 
     def createDockWindows(self):
         self.propertyDock = QtGui.QDockWidget(self.tr("Properties"), self)
+        self.propertyDock.setObjectName("PropertyDockWindow")
         self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
         self.propertyDock.setWidget(self.objectPropertyWin)
         self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
 
         self.modelSelectionDock = QtGui.QDockWidget(self.tr("Models"), self)
+        self.modelSelectionDock.setObjectName("ModelSelectionDockWindow")
         self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
         self.modelSelectionDock.setWidget(self.modelSelectionDialog)
         self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
 
+        self.sceneExplorerDock = QtGui.QDockWidget(self.tr("Scene Explorer"), self)
+        self.sceneExplorerDock.setObjectName("SceneExplorerDockWindow")
+        self.sceneExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.sceneExplorerDock.setWidget(self.sceneExplorerWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.sceneExplorerDock)
+
         self.consoleDock = QtGui.QDockWidget(self.tr("Console"), self)
+        self.consoleDock.setObjectName("ConsoleDockWindow")
         self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
         self.consoleDock.setWidget(self.consoleWindow)
         self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
 
         self.fileToolBar = self.addToolBar("File Toolbar")
+        self.fileToolBar.setObjectName("FileToolBar")
         self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
         self.fileToolBar.addAction(self.actionNeu)
         self.fileToolBar.addAction(self.actionClose)
-        self.fileToolBar.hide()
         self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
 
+        self.moveToolBar = self.addToolBar("Transformation Bar")
+        self.moveToolBar.setObjectName("TransformationBar")
+        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.moveToolBar.addAction(self.actionMove)
+        self.moveToolBar.addAction(self.actionRotate)
+        self.moveToolBar.addAction(self.actionScale)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
+
     def keyPressEvent(self,  event):
         if not event.isAutoRepeat():
             self.ogreRenderWindow.keyPressEvent(event)
@@ -279,10 +354,34 @@
             self.ogreRenderWindow.keyReleaseEvent(event)
         pass
 
+    def connectActionButtons(self):
+        pass
+
+    def saveOnClose(self):
+        reply = QtGui.QMessageBox.question(self,  "Rastullahs Lockenwickler - Unsaved Chages",  "Save unsaved changes?",  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
+        if reply == QtGui.QMessageBox.Cancel:
+            return False
+        if reply == QtGui.QMessageBox.Yes:
+            print "SAVE!!!!"
+            #TODO: implement save here
+        return True
+
+    def closeEvent(self,  event):
+        if self.saveOnClose():
+            settings = QtCore.QSettings()
+            settings.setValue("MainWindow/Geometry",  QtCore.QVariant(self.saveGeometry()))
+            settings.setValue("MainWIndow/DockWindows",  QtCore.QVariant(self.saveState()))
+        else:
+            event.ignore()
+
 if __name__ == "__main__":
-     app = QtGui.QApplication(sys.argv)
-     myapp = Lockenwickler()
-     myapp.show()
+    app = QtGui.QApplication(sys.argv)
+    app.setOrganizationName("Team Pantheon")
+    app.setOrganizationDomain("rastullahs-lockenpracht.de/team")
+    app.setApplicationName("Lockenwickler")
 
-     sys.exit(app.exec_())
+    form = Lockenwickler()
+    form.show()
 
+    sys.exit(app.exec_())
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py	2008-09-24 11:00:44 UTC (rev 4526)
@@ -4,11 +4,14 @@
 import ctypes
 import ogre.renderer.OGRE as og
 
+from MovePivot import *
+
 # a class to store information about a object that got selected
 class SelectionObject():
     def __init__(self,  entity,  distance):
         self.entity = entity #the selected entity
         self.distance = distance # the distance from camera at the time of selection
+        self.isPivot = False
 
     #if True this instance will show its bounding box else it will hide it
     def setSelected(self,  selected):
@@ -29,7 +32,9 @@
         self.mVertexList = []
         self.mIndexList = []
 
+        self.currentRay = None
         self.lastRay = None
+
     # sort algorithm for the selection list
     def sortCompareImp(self,  x,  y):
         if x.distance > y.distance:
@@ -40,10 +45,36 @@
             return -1
 
     def queryResult ( self, entity, distance ):
+        print entity.getName()
         if distance == 0.0: #camera is in the bounding box, ignore this selection
             return True
         elif entity.getName() == "rayLine" :
             return True
+        elif entity.isVisible() and entity.getName() == "EditorXArrow":
+            so = SelectionObject(entity,  distance)
+            so.isPivot = True
+            self.selectionList.append(so)
+            return False
+        elif entity.isVisible() and entity.getName() == "EditorYArrow":
+            so = SelectionObject(entity,  distance)
+            so.isPivot = True
+            self.selectionList.append(so)
+            return False
+        elif entity.isVisible() and entity.getName() == "EditorZArrow":
+            so = SelectionObject(entity,  distance)
+            so.isPivot = True
+            self.selectionList.append(so)
+            return False
+        elif entity.isVisible() and entity.getName() == "EditorFreeMover":
+            return True
+        elif entity.getName() == "EditorXRotator" or entity.getName() == "EditorYRotator" or entity.getName() == "EditorZRotator":
+            if entity.isVisible() and self.rayCastToPolygonLevelOnSingleMesh(self.currentRay,  entity):
+                so = SelectionObject(entity,  distance)
+                so.isPivot = True
+                self.selectionList.append(so)
+                return False
+            else:
+                return True
         else:
             so = SelectionObject(entity,  distance)
             self.selectionList.append(so)
@@ -88,6 +119,12 @@
 
         pMesh = entity.getMesh()
 
+        pos =    entity.getParentNode().getWorldPosition()
+        scale =  entity.getParentNode().getScale()
+        orient = entity.getParentNode().getWorldOrientation()
+
+
+
         for i in range ( pMesh.getNumSubMeshes() ):
             pSubMesh = pMesh.getSubMesh(i)
             if pSubMesh.useSharedVertices:
@@ -100,11 +137,10 @@
             numVertices += pMesh.sharedVertexData.vertexCount
 
             storageclass = ctypes.c_float * 3
-            test=storageclass(1.1)
+            test=storageclass(0.0,  0.0,  0.0)
 #         mVertexList = new Point[numVertices];
 #         mIndexList = new unsigned int[numIndices];
 
-        self.mNormalList = []
         self.mVertexList = []
         self.mIndexList = []
 
@@ -115,28 +151,19 @@
         if useSharedVertices:
             ## Real* pVertices (x, y, z order x numVertices)
             elem = pMesh.sharedVertexData.vertexDeclaration.findElementBySemantic(og.VES_POSITION)
-            elemNormal = pMesh.sharedVertexData.vertexDeclaration.findElementBySemantic(og.VES_NORMAL)
 
             if not elem:
                 ogre.Except(Exception.ERR_ITEM_NOT_FOUND, "Can't find position elements in the "
                     "mesh to be written!", "MeshSerializerImpl.writeGeometry")
 
             vbuf = pMesh.sharedVertexData.vertexBufferBinding.getBuffer(elem.getSource())
-            vbufNormal = pMesh.sharedVertexData.vertexBufferBinding.getBuffer(elemNormal.getSource())
 
             ## need space for the 3 verticies
             storageclass = ctypes.c_float * 3
-            test=storageclass(1.1)
+            test=storageclass(0.0,  0.0,  0.0)
 
-            storageclass = ctypes.c_float * 3
-            testNormal=storageclass(1.1)
-
             for j in range ( pMesh.sharedVertexData.vertexCount ):
-                #vbufNormal.readData(j * vbufNormal.getVertexSize(), 3 * ctypes.sizeof(ctype.c_float), ctypes.addressof(testNormal))
-                vbufNormal.readData(j * 3, 3 * ctypes.sizeof(ctype.c_float), ctypes.addressof(testNormal))
-                self.mNormalList.append( og.Vector3(testNormal[0], testNormal[1],  testNormal[2]) )
-
-                vbuf.readData(j * vbuf.getVertexSize(), 3 * ctypes.sizeof(ctype.c_float), ctypes.addressof(test))
+                vbuf.readData(j * vbuf.getVertexSize(), 3 * ctype.sizeof(ctype.c_float), ctype.addressof(test))
                 self.mVertexList.append( og.Vector3(test[0], test[1], test[2]) )
                 vertListCount+=1
 
@@ -145,30 +172,26 @@
             if not pSubMesh.useSharedVertices:
                 ## Real* pVertices (x, y, z order x numVertices)
                 elem = pSubMesh.vertexData.vertexDeclaration.findElementBySemantic(og.VES_POSITION)
-                elemNormal = pSubMesh.vertexData.vertexDeclaration.findElementBySemantic(og.VES_NORMAL)
 
-                if not elem or not elemNormal:
+                if not elem:
                     og.Except(Exception.ERR_ITEM_NOT_FOUND, "Can't find position elements in the "
                         "mesh to be written!", "MeshSerializerImpl.writeGeometry")
 
                 vbuf = pSubMesh.vertexData.vertexBufferBinding.getBuffer(elem.getSource())
-                vbufNormal = pSubMesh.vertexData.vertexBufferBinding.getBuffer(elemNormal.getSource())
 
                 ## need space for the verticies
-                storageclass = ctypes.c_float * (pSubMesh.vertexData.vertexCount * 3)
-                test=storageclass(1.1)
+                storageclass = ctypes.c_float * (pSubMesh.vertexData.vertexCount * 6)
+                test=storageclass(0.0)
 
-                storageclassNormal = ctypes.c_float * (pSubMesh.vertexData.vertexCount * 3)
-                testNormal=storageclassNormal(1.1)
+                vbuf.readData(0, pSubMesh.vertexData.vertexCount * 6 * ctypes.sizeof(ctypes.c_float), ctypes.addressof(test))
 
-                vbuf.readData(0, pSubMesh.vertexData.vertexCount * 3 * ctypes.sizeof(ctypes.c_float),
-                                                                                ctypes.addressof(test))
-                vbufNormal.readData(0, pSubMesh.vertexData.vertexCount * 3 * ctypes.sizeof(ctypes.c_float),
-                                                                                ctypes.addressof(testNormal))
-
-                for j in range ( pSubMesh.vertexData.vertexCount ):
-                    self.mVertexList.append( og.Vector3(test[j], test[j+1], test[j+2]) )
-                    self.mNormalList.append( og.Vector3(testNormal[j], testNormal[j+1], testNormal[j+2]) )
+                for j in range ( 0,  pSubMesh.vertexData.vertexCount * 6,  6):
+                    #print j
+                    p = og.Vector3(test[j], test[j+1], test[j+2])
+                    p /= scale
+                    p += pos
+                    p = orient * p
+                    self.mVertexList.append( p )
                     vertListCount += 1
 
             ibuf = pSubMesh.indexData.indexBuffer
@@ -176,39 +199,51 @@
             storageclass = ctypes.c_ushort * pSubMesh.indexData.indexCount
             test2=storageclass()
 
+
             ibuf.readData(0, ibuf.getSizeInBytes(), ctypes.addressof(test2))
-
             for j in range ( pSubMesh.indexData.indexCount ):
                 self.mIndexList.append (test2[j])   # unsigned short
                 indexCount += 1
 
+            ih = 0
+            for blah in self.mVertexList:
+                print str(ih) + ": "  +  str(blah)
+                ih += 1
+
+#            for blah in self.mIndexList:
+#                print blah
+
+
     # used when a new selection is made, meaning when not iterationg through the selected objects
     def rayCastToPolygonLevel(self,  ray):
         self.lastRay = ray
+
+        for so in self.selectionList:
+            if so.isPivot:
+                return so
+
         if len(self.selectionList) >= 1:
             for so in self.selectionList:
-                self.getMeshInformation(so.entity)
+                if self.rayCastToPolygonLevelOnSingleMesh(ray,  so.entity):
+                    return so
 
-                i = 0
-                while i <= (len(self.mIndexList) - 3):
-                    globalPosition = so.entity.getParentNode().getPosition()
-                    result = og.Math.intersects(ray, globalPosition + self.mVertexList[self.mIndexList[i]], globalPosition + self.mVertexList[self.mIndexList[i+1]],
-                                                                                                                                                              globalPosition + self.mVertexList[self.mIndexList[i+2]], True, True)
 
-                    if result.first:
-                        return so
-#                        self.previousSelected = self.currentSelected
-#
-#                        if self.previousSelected is not -1:
-#                            self.selectionList[self.previousSelected].setSelected(False)
-#
-#                        self.currentSelected = self.selectionList.index(so)
-#                        so.setSelected(True)
-#                        return
-                    i += 3
+    def rayCastToPolygonLevelOnSingleMesh(self,  ray,  entity):
+        self.getMeshInformation(entity)
+        globalPosition = entity.getParentNode().getWorldPosition()
 
-#        print "fertsch #####################################################################################"
+        i = 0
+        while i <= (len(self.mIndexList) - 3):
+            result = og.Math.intersects(ray, globalPosition + self.mVertexList[self.mIndexList[i]], globalPosition + self.mVertexList[self.mIndexList[i+1]],
+                                                                                                                                                          globalPosition + self.mVertexList[self.mIndexList[i+2]], True, False)
 
+            if result.first:
+                return True
+
+            i += 3
+
+        return False
+
     def rayCastToPolygonLevelOnCurrentSelection(self):
         if len(self.selectionList) >= 1:
             self.getMeshInformation(self.selectionList[self.currentSelected].entity)
@@ -238,6 +273,13 @@
         self.lastRay = None
         self.rayLine = None
 
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
     def load(self,  moduleName,  mapFiles):
         self.moduleName = moduleName
         self.mapFiles = mapFiles
@@ -248,6 +290,7 @@
             if node != None:
                 self.parseSceneNodes(node)
 
+        self.pivot = Pivot(self.sceneManager)
 
     def parseSceneNodes(self,  nodeList):
         for ent in nodeList:
@@ -281,7 +324,12 @@
                         nodeScale = og.Vector3(px, py, pz)
                         continue
 
-            e = self.sceneManager.createEntity(entityName, meshFile)
+            try:
+                e = self.sceneManager.createEntity(entityName, meshFile)
+            except:
+                print "Warning: Meshfile " + meshFile + " could not be found."
+                return
+
             n = self.sceneManager.getRootSceneNode().createChild()
             n.attachObject(e)
             n.setPosition(nodePosition)
@@ -290,28 +338,39 @@
 
         pass
 
-
+    # called when a click into Main Ogre Window occurs
     def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
-        if not controlDown and not shiftDown:
-            self.resetSelection()
-
         self.lastRay = ray
+        self.listenerDings.currentRay = ray
         self.raySceneQuery.Ray = ray
         self.raySceneQuery.execute(self.listenerDings)
 
-
         so = self.listenerDings.rayCastToPolygonLevel(ray)
-        if so is not None and not controlDown and not shiftDown:
-            so.setSelected(True)
-            self.userSelectionList.append(so)
-        elif so is not None and controlDown and not shiftDown:
-            so.setSelected(True)
-            self.userSelectionList.append(so)
-        elif so is not None and not controlDown and shiftDown:
-            for selo in self.userSelectionList:
-                if so.entity.getName() == selo.entity.getName():
-                    so.setSelected(False)
-                    self.userSelectionList.remove(selo)
+        if so is not None:
+            if not so.isPivot:
+                self.pivot.show()
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so.entity.getName() == selo.entity.getName():
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                    self.updatePivots()
+            else:
+                print "isPivot: " + str(so.entity.getName())
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            print "noneee"
+            self.resetSelection() # click in empty space, deselect everything
+            self.pivot.hide()
 
         if self.rayLine == None:
             self.rayLine = self.sceneManager.createManualObject("rayLine")
@@ -333,6 +392,10 @@
 
             self.rayLine.end()
 
+    def leftMouseUp(self):
+        if self.pivot.isTransforming:
+            self.pivot.stopTransforming()
+
     def iterateEntityUnderMouse(self):
         self.listenerDings.iterateEntityUnderMouse()
 
@@ -347,6 +410,15 @@
         self.listenerDings.reset()
         pass
 
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+
+        self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
     def unload(self,  saveOnUnload=True):
         pass
 

Modified: rl/branches/newton20/editors/Lockenwickler/src/MovePivot.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/MovePivot.py	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/editors/Lockenwickler/src/MovePivot.py	2008-09-24 11:00:44 UTC (rev 4526)
@@ -1,17 +1,149 @@
 import sys
+import ogre.renderer.OGRE as og
 
-class MovePivot():
+
+class Pivot():
     def __init__(self,  sceneManager):
         self.sceneManager = sceneManager
-        self.moveX = False
-        self.moveY = False
-        self.moveZ = False
 
-    # set true if the mouse input should be processed or not
-    def activated(self,  moveX,  moveY,  moveZ):
-        self.moveX = moveX
-        self.moveY = moveY
-        self.moveZ = moveZ
+        self.mode = None
 
-    def move(self):
+        self.meshManager = og.MeshManager.getSingleton ()
+
+        self.pivotNode = sceneManager.getRootSceneNode().createChildSceneNode("pivotNode")
+        self.__createMovePivot()
+        self.__createRotatePivot()
+        self.__createScalePivot()
+        self.hide()
+        self.setMoveMode()
+
+        self.moveDirection = None
+        self.isTransforming = False
+        self.selectionList = None
+
+    def __createMovePivot(self):
+        self.xMoveEntity = self.sceneManager.createEntity("EditorXArrow",  "Pivot_Arrow.mesh")
+        self.xMoveEntity.setMaterialName("Lockenwickler_Pivot_X")
+        self.xMoveNode = self.pivotNode.createChildSceneNode()
+        self.xMoveNode.attachObject(self.xMoveEntity)
+        self.xMoveNode.translate(og.Vector3(2, 0, 0))
+        self.xMoveNode.rotate(og.Vector3.UNIT_Y,  og.Degree(90))
+
+#        plane = og.Plane (og.Vector3.UNIT_X, 0)
+#        self.meshManager.createPlane ('EditorXArrowSelectionPlane', 'General', plane, 5, 14, 1, 1, False, 1, 5, 5, (0, 0, 1))
+#        self.xMoveEntitySelectionPlane = self.sceneManager.createEntity ('EditorXArrowSelectionPlane', 'EditorXArrowSelectionPlane')
+#        self.xMoveNodeSelectionPlane = self.xMoveNode.createChildSceneNode()
+#        self.xMoveNodeSelectionPlane.attachObject (self.xMoveEntitySelectionPlane)
+#        self.xMoveNodeSelectionPlane.translate(og.Vector3(0, 0, 5))
+#        self.xMoveEntitySelectionPlane.setMaterialName("Lockenwickler_Pivot_X")
+
+
+
+        self.yMoveEntity = self.sceneManager.createEntity("EditorYArrow",  "Pivot_Arrow.mesh")
+        self.yMoveEntity.setMaterialName("Lockenwickler_Pivot_Y")
+        self.yMoveNode = self.pivotNode.createChildSceneNode()
+        self.yMoveNode.attachObject(self.yMoveEntity)
+        self.yMoveNode.translate(og.Vector3(0, 2, 0))
+        self.yMoveNode.rotate(og.Vector3.UNIT_X,  og.Degree(-90))
+        #self.yNode.showBoundingBox(True)
+
+#        plane = og.Plane (og.Vector3.UNIT_X, 0)
+#        self.meshManager.createPlane ('EditorYArrowSelectionPlane', 'General', plane, 14, 0, 1, 1, False, 1, 5, 5, (0, 0, 1))
+#        self.yMoveEntitySelectionPlane = self.sceneManager.createEntity ('EditorYArrowSelectionPlane', 'EditorYArrowSelectionPlane')
+#        self.yMoveNodeSelectionPlane = self.xMoveNode.createChildSceneNode()
+#        self.yMoveNodeSelectionPlane.attachObject (self.yMoveEntitySelectionPlane)
+#        self.yMoveNodeSelectionPlane.translate(og.Vector3(0, 5, 0))
+#        self.yMoveEntitySelectionPlane.setMaterialName("Lockenwickler_Pivot_Y")
+
+
+        self.zMoveEntity = self.sceneManager.createEntity("EditorZArrow",  "Pivot_Arrow.mesh")
+        self.zMoveEntity.setMaterialName("Lockenwickler_Pivot_Z")
+        self.zMoveNode = self.pivotNode.createChildSceneNode()
+        self.zMoveNode.attachObject(self.zMoveEntity)
+        self.zMoveNode.translate(og.Vector3(0, 0, 2))
+        #self.zNode.showBoundingBox(True)
+
+        self.freeMoveEntity = self.sceneManager.createEntity("EditorFreeMoveArrow",  "Pivot_FreeMover.mesh")
+        self.freeMoveEntity.setMaterialName("Lockenwickler_FreeMover")
+        self.freeMoveNode = self.pivotNode.createChildSceneNode()
+        self.freeMoveNode.attachObject(self.freeMoveEntity)
+
+
+    def __createRotatePivot(self):
+        self.xRotateEntity = self.sceneManager.createEntity("EditorXRotator",  "Rotate_Torus.mesh")
+        self.xRotateEntity.setMaterialName("Lockenwickler_Pivot_X")
+        self.xRotateNode = self.pivotNode.createChildSceneNode()
+        self.xRotateNode.attachObject(self.xRotateEntity)
+        #self.xRotateNode.translate(0, 0, -5)
+        self.xRotateNode.rotate(og.Vector3.UNIT_Y,  og.Degree(90))
+
+        self.yRotateEntity = self.sceneManager.createEntity("EditorYRotator",  "Rotate_Torus.mesh")
+        self.yRotateEntity.setMaterialName("Lockenwickler_Pivot_Y")
+        self.yRotateNode = self.pivotNode.createChildSceneNode()
+        self.yRotateNode.attachObject(self.yRotateEntity)
+        #self.yRotateNode.translate(0, 0, -10)
+        self.yRotateNode.rotate(og.Vector3.UNIT_X,  og.Degree(90))
+
+        self.zRotateEntity = self.sceneManager.createEntity("EditorZRotator",  "Rotate_Torus.mesh")
+        self.zRotateEntity.setMaterialName("Lockenwickler_Pivot_Z")
+        self.zRotateNode = self.pivotNode.createChildSceneNode()
+        self.zRotateNode.attachObject(self.zRotateEntity)
+
         pass
+
+    def __createScalePivot(self):
+        pass
+
+    def setPosition(self,  pos):
+        self.pivotNode.setPosition(pos)
+
+    def startTransforming(self, dirEntity, soList):
+        self.moveDirection = dirEntity.getName()
+        self.selectionList = soList
+        self.isTransforming = True
+        pass
+
+    def stopTransforming(self):
+        self.isTransforming = False
+        pass
+
+    def hide(self):
+        self.pivotNode.setVisible(False)
+
+    def show(self):
+        if self.mode == 1:
+            self.xMoveNode.setVisible(True)
+            self.yMoveNode.setVisible(True)
+            self.zMoveNode.setVisible(True)
+            self.freeMoveNode.setVisible(True)
+        elif self.mode == 2:
+            self.xRotateNode.setVisible(True)
+            self.yRotateNode.setVisible(True)
+            self.zRotateNode.setVisible(True)
+        elif self.mode == 3:
+            pass
+
+    def setMoveMode(self):
+        self.hide()
+        self.mode = 1
+        self.xMoveNode.setVisible(True)
+        self.yMoveNode.setVisible(True)
+        self.zMoveNode.setVisible(True)
+        self.freeMoveNode.setVisible(False)
+
+        pass
+
+    def setRotateMode(self):
+        self.hide()
+        self.mode = 2
+        self.xRotateNode.setVisible(True)
+        self.yRotateNode.setVisible(True)
+        self.zRotateNode.setVisible(True)
+        pass
+
+    def __setScaleMode(self):
+        pass
+
+    def onMouseMoved(self, globalX, globalY, incX, incY):
+        print self.moveDirection
+        pass

Modified: rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py	2008-09-24 11:00:44 UTC (rev 4526)
@@ -17,7 +17,6 @@
         self.OgreMainWinSceneMgr = OgreMainWinSceneMgr
 
         self.ogreRenderWindow = None
-        self.ogreRenderWindow2 = None
 
         self.leftMouseDown = False
         self.middleMouseDown = False
@@ -30,8 +29,6 @@
         self.strafeCamLeft = False
         self.strafeCamRight = False
 
-        self.focusedWindow = None # the ogre window which has focus at the moment (activated by a click into the window), eventFilter method
-
         self.camUpdateTimer = QtCore.QTimer(self)
         self.camUpdateTimer.connect(self.camUpdateTimer, QtCore.SIGNAL("timeout()"), self.updateCamera)
 
@@ -61,6 +58,7 @@
         self.ogreWindowOptions = QtGui.QToolButton(self)
         QtCore.QObject.connect(self.ogreWindowOptions, QtCore.SIGNAL("clicked()"),
                                     self.onPreferencesButton)
+        self.ogreWindowOptions.hide()
 
         sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Maximum,QtGui.QSizePolicy.Minimum)
         sizePolicy.setHorizontalStretch(0)
@@ -71,18 +69,9 @@
         self.splitterV.addWidget(self.ogreWindowOptions)
 
         # create the horizontal splitter wich contains the two ogre render windows and add it to the vertical splitter
-        self.splitterH = QtGui.QSplitter(Form)
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding,QtGui.QSizePolicy.MinimumExpanding)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.splitterH.sizePolicy().hasHeightForWidth())
-        self.splitterH.setSizePolicy(sizePolicy)
-        self.splitterH.setOrientation(QtCore.Qt.Horizontal)
-        self.splitterH.setObjectName("splitterH")
 
-
         ##################################
-        self.ogreRenderWindow = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterH,  0)
+        self.ogreRenderWindow = OgreWidget.OgreWidget("OgreMainWin", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam", self.splitterV,  0)
         self.ogreRenderWindow.setMinimumSize(QtCore.QSize(250,250))
 
         sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Maximum,QtGui.QSizePolicy.Maximum)
@@ -91,31 +80,15 @@
         sizePolicy.setHeightForWidth(self.ogreRenderWindow.sizePolicy().hasHeightForWidth())
         self.ogreRenderWindow.setSizePolicy(sizePolicy)
         self.ogreRenderWindow.setObjectName("ogreWidget")
-        self.splitterH.addWidget(self.ogreRenderWindow)
-        self.ogreRenderWindow.setBackgroundColor(og.ColourValue(0, 0, 1))
+        self.splitterV.addWidget(self.ogreRenderWindow)
+        self.ogreRenderWindow.setBackgroundColor(og.ColourValue(0, 1, 1))
         ####################################
 
-        #################################
-        self.ogreRenderWindow2 = OgreWidget.OgreWidget("OgreMainWin2", self.ogreRoot, self.OgreMainWinSceneMgr, "MainCam2", self.splitterH,  0)
-        self.ogreRenderWindow2.setMinimumSize(QtCore.QSize(250,250))
-
-        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.Maximum,QtGui.QSizePolicy.Maximum)
-        sizePolicy.setHorizontalStretch(0)
-        sizePolicy.setVerticalStretch(0)
-        sizePolicy.setHeightForWidth(self.ogreRenderWindow2.sizePolicy().hasHeightForWidth())
-        self.ogreRenderWindow2.setSizePolicy(sizePolicy)
-        self.ogreRenderWindow2.setObjectName("ogreWidget2")
-        self.splitterH.addWidget(self.ogreRenderWindow2)
-        self.ogreRenderWindow2.setBackgroundColor(og.ColourValue(0, 0, 1))
-        ###################################
-
-        self.splitterV.addWidget(self.splitterH)
         self.gridlayout.addWidget(self.splitterV,0,0,1,1)
 
         # register the eventfilters for the render windows
         # this is needed to catch mouse enter and mouse leave events for these windows
         self.ogreRenderWindow.installEventFilter(self)
-        self.ogreRenderWindow2.installEventFilter(self)
 
         self.lastMousePosX = 0
         self.lastMousePosY = 0
@@ -154,7 +127,7 @@
         if event.type() == 2:
             if event.button() == 1: # left mouse button is pressed
                 self.leftMouseDown = True
-                self.focusedWindow = obj
+                self.moduleManager.leftMouseDown = True
 
                 if self.rightMouseDown: #if right mouse button is already pressed dolly the camera
                     self.dollyCamera = True
@@ -163,33 +136,44 @@
 
             elif event.button() == 2: # right mouse button is pressed
                 self.rightMouseDown = True
-                self.focusedWindow = obj
+                self.moduleManager.rightMouseDown = True
+
             elif event.button() == 4: # middle mouse button is pressed
                 self.middleMouseDown = True
-                self.focusedWindow = obj
+                self.moduleManager.middleMouseDown = True
 
             self.camUpdateTimer.start(15)
 
         elif event.type() == 3:
             if event.button() == 1: # left mouse button is released
                 self.leftMouseDown = False
+                self.moduleManager.leftMouseDown = False
+                self.moduleManager.leftMouseUp()
 
                 if self.dollyCamera == True: #if we dolly the camera set it to false
                     self.dollyCamera = False
 
             elif event.button() == 2: # right mouse button is released
                 self.rightMouseDown = False
+                self.moduleManager.rightMouseDown = False
             elif event.button() == 4: # middle mouse button is released
                 self.middleMouseDown = False
+                self.moduleManager.middleMouseDown = False
 
             if not self.rightMouseDown:
                 self.dollyCamera = False
                 self.camUpdateTimer.stop()
 
         elif event.type() == 5: #mouse moved while button down
-            rotX = (event.globalX() - self.lastMousePosX) * 0.01
-            rotY = (event.globalY() - self.lastMousePosY) * 0.01
+            incX =  (event.globalX() - self.lastMousePosX)
+            incY =  (event.globalY() - self.lastMousePosY)
 
+            if self.leftMouseDown and not self.middleMouseDown and not self.rightMouseDown:
+                self.moduleManager.pivot.onMouseMoved(event.globalX,  event.globalY,  incX,  incY)
+
+            rotX = incX * 0.01
+            rotY = incY * 0.01
+
             if (rotX < 0.3 and rotY < 0.3) and (rotX > -0.3 and rotY > -0.3): # check to avoid to huge values which may happen when the user clicks and lastMousePosX/Y is zero
                 if self.dollyCamera:
                     self.focusedWindow.dollyCamera(og.Vector3( rotX, -rotY,  0))
@@ -227,17 +211,12 @@
         else:
             self.moduleManager.selectionClick(mouseRay)
 
-
-#        self.moduleManager.resetCurrentOgreSelection()
-
-
-
     def updateCamera(self):
         if self.moveCamForward:
-            self.focusedWindow.dollyCamera(og.Vector3( 0, 0,-0.2))
+            self.ogreRenderWindow.dollyCamera(og.Vector3( 0, 0,-0.2))
         if self.moveCamBackward:
-            self.focusedWindow.dollyCamera(og.Vector3( 0, 0, 0.2))
+            self.ogreRenderWindow.dollyCamera(og.Vector3( 0, 0, 0.2))
         if self.strafeCamLeft:
-            self.focusedWindow.dollyCamera(og.Vector3(-0.2, 0 , 0))
+            self.ogreRenderWindow.dollyCamera(og.Vector3(-0.2, 0 , 0))
         if self.strafeCamRight:
-            self.focusedWindow.dollyCamera(og.Vector3( 0.2, 0, 0))
+            self.ogreRenderWindow.dollyCamera(og.Vector3( 0.2, 0, 0))

Modified: rl/branches/newton20/editors/Lockenwickler/src/Plugins-linux.cfg
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/Plugins-linux.cfg	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/editors/Lockenwickler/src/Plugins-linux.cfg	2008-09-24 11:00:44 UTC (rev 4526)
@@ -1,12 +1,12 @@
 # Defines plugins to load
 
 # Define plugin folder
-PluginFolder=./plugins
+PluginFolder=/usr/lib/OGRE
 
-# Define plugins
-Plugin=RenderSystem_GL
-Plugin=Plugin_ParticleFX
-Plugin=Plugin_OctreeSceneManager
-Plugin=Plugin_CgProgramManager
+# default plugins installed with the libogre14 package
+Plugin=RenderSystem_GL.so
+Plugin=Plugin_ParticleFX.so
+Plugin=Plugin_OctreeSceneManager.so
+#Plugin=Plugin_CgProgramManager
 
 

Modified: rl/branches/newton20/editors/Lockenwickler/src/PreferencesDialog.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/PreferencesDialog.py	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/editors/Lockenwickler/src/PreferencesDialog.py	2008-09-24 11:00:44 UTC (rev 4526)
@@ -21,24 +21,24 @@
         QtCore.QObject.connect(self.prefDialog.listWidget, QtCore.SIGNAL("itemDoubleClicked(QListWidgetItem *)"),
                                self.onLoadSelectedModule)
 
-##        if platform.system() == "Windows" or platform.system() == "MAC":
-##            # TODO: delete this when ready
-##            self.prefDialog.lineEdit.setText("C:\Users\Stefan\Desktop\Lockenwickler\modules\modules.cfg")
-##            self.moduleCfgPath = "C:\Users\Stefan\Desktop\Lockenwickler\modules\modules.cfg"
-##            self.moduleCfgIsSelected = True
-##            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
-##            self.readInModules()
-##            # end delete
-##        else:
-##            # TODO: delete this when ready
-##            self.prefDialog.lineEdit.setText("/home/stefan/blubb/rl_modules/modules/modules.cfg")
-##            self.moduleCfgPath = "/home/stefan/blubb/rl_modules/modules/modules.cfg"
-##            self.moduleCfgIsSelected = True
-##            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
-##            self.readInModules()
-##            # end delete
+        if platform.system() == "Windows" or platform.system() == "MAC":
+            # TODO: delete this when ready
+            self.prefDialog.lineEdit.setText("C:\Users\Stefan\Desktop\Lockenwickler\modules\modules.cfg")
+            self.moduleCfgPath = "C:\Users\Stefan\Desktop\Lockenwickler\modules\modules.cfg"
+            self.moduleCfgIsSelected = True
+            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
+            self.readInModules()
+            # end delete
+        else:
+            # TODO: delete this when ready
+            self.prefDialog.lineEdit.setText("/home/stefan/blubb/rl_modules/modules/modules.cfg")
+            self.moduleCfgPath = "/home/stefan/blubb/rl_modules/modules/modules.cfg"
+            self.moduleCfgIsSelected = True
+            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
+            self.readInModules()
+            # end delete
 
-        #self.moduleCfgIsSelected = False
+        self.moduleCfgIsSelected = False
 
         self.setModal(True)
 
@@ -71,6 +71,7 @@
 
     def onLoadSelectedModule(self):
         item = self.prefDialog.listWidget.currentItem()
+
         if item == None:
             mbox = QtGui.QMessageBox(self)
             mbox.setModal(True)

Copied: rl/branches/newton20/editors/Lockenwickler/src/SceneExplorer.py (from rev 4525, rl/trunk/editors/Lockenwickler/src/SceneExplorer.py)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_Arrow.mesh (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/Pivot_Arrow.mesh)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_FreeMover.mesh (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/Pivot_FreeMover.mesh)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/Pivot_Point.material (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/Pivot_Point.material)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/Rotate_Torus.mesh (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/Rotate_Torus.mesh)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/back.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/back.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/back.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/configure.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/configure.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/configure.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/console.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/console.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/console.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/decrypted.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/decrypted.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/decrypted.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/edit.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/edit.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/edit.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/edit_add.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/edit_add.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/edit_add.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/edit_remove.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/edit_remove.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/edit_remove.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/editclear.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/editclear.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/editclear.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/editcopy.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/editcopy.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/editcopy.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/editcut.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/editcut.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/editcut.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/editdelete.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/editdelete.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/editdelete.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/editpaste.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/editpaste.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/editpaste.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/encrypted.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/encrypted.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/encrypted.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/endturn.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/endturn.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/endturn.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/exit.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/exit.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/exit.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/fileexport.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/fileexport.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/fileexport.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/filenew.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/filenew.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/filenew.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/filesave.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/filesave.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/filesave.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/find.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/find.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/find.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/forward.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/forward.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/forward.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/goto.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/goto.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/goto.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/idea.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/idea.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/idea.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/move.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/move.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/move.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/move_task_down.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/move_task_down.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/move_task_down.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/move_task_up.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/move_task_up.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/move_task_up.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/ok.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/ok.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/ok.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/playlist.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/playlist.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/playlist.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/redo.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/redo.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/redo.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/resizecol.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/resizecol.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/resizecol.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/rotate.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/rotate.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/rotate.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/tux.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/tux.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/tux.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/unsortedlist1.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/unsortedlist1.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/unsortedlist1.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/media/icons/view_tree.png
===================================================================
(Binary files differ)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/view_tree.png (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/icons/view_tree.png)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/pivots.blend (from rev 4525, rl/trunk/editors/Lockenwickler/src/media/pivots.blend)

Modified: rl/branches/newton20/editors/Lockenwickler/src/ui_pref_dialog.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ui_pref_dialog.py	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/editors/Lockenwickler/src/ui_pref_dialog.py	2008-09-24 11:00:44 UTC (rev 4526)
@@ -1,85 +1,85 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'preferences_dialog.ui'
-#
-# Created: Mon Jun 23 19:28:46 2008
-#      by: PyQt4 UI code generator 4.3.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
-
-class Ui_PreferencesDialog(object):
-    def setupUi(self, PreferencesDialog):
-        PreferencesDialog.setObjectName("PreferencesDialog")
-        PreferencesDialog.resize(QtCore.QSize(QtCore.QRect(0,0,528,626).size()).expandedTo(PreferencesDialog.minimumSizeHint()))
-
-        self.gridlayout = QtGui.QGridLayout(PreferencesDialog)
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.toolBox = QtGui.QToolBox(PreferencesDialog)
-        self.toolBox.setObjectName("toolBox")
-
-        self.ResourcePaths = QtGui.QWidget()
-        self.ResourcePaths.setGeometry(QtCore.QRect(0,0,510,505))
-        self.ResourcePaths.setObjectName("ResourcePaths")
-
-        self.gridlayout1 = QtGui.QGridLayout(self.ResourcePaths)
-        self.gridlayout1.setObjectName("gridlayout1")
-
-        self.listWidget = QtGui.QListWidget(self.ResourcePaths)
-        self.listWidget.setObjectName("listWidget")
-        self.gridlayout1.addWidget(self.listWidget,0,0,1,1)
-
-        self.groupBox = QtGui.QGroupBox(self.ResourcePaths)
-        self.groupBox.setMinimumSize(QtCore.QSize(0,95))
-        self.groupBox.setObjectName("groupBox")
-
-        self.layoutWidget = QtGui.QWidget(self.groupBox)
-        self.layoutWidget.setGeometry(QtCore.QRect(10,20,471,67))
-        self.layoutWidget.setObjectName("layoutWidget")
-
-        self.gridlayout2 = QtGui.QGridLayout(self.layoutWidget)
-        self.gridlayout2.setObjectName("gridlayout2")
-
-        self.lineEdit = QtGui.QLineEdit(self.layoutWidget)
-        self.lineEdit.setObjectName("lineEdit")
-        self.gridlayout2.addWidget(self.lineEdit,0,0,1,1)
-
-        self.loadModuleBtn = QtGui.QPushButton(self.layoutWidget)
-        self.loadModuleBtn.setObjectName("loadModuleBtn")
-        self.gridlayout2.addWidget(self.loadModuleBtn,1,0,1,2)
-
-        self.modulConfigSelector = QtGui.QPushButton(self.layoutWidget)
-        self.modulConfigSelector.setObjectName("modulConfigSelector")
-        self.gridlayout2.addWidget(self.modulConfigSelector,0,1,1,1)
-        self.gridlayout1.addWidget(self.groupBox,1,0,1,1)
-        self.toolBox.addItem(self.ResourcePaths,"")
-
-        self.OgreSettings = QtGui.QWidget()
-        self.OgreSettings.setGeometry(QtCore.QRect(0,0,96,26))
-        self.OgreSettings.setObjectName("OgreSettings")
-        self.toolBox.addItem(self.OgreSettings,"")
-        self.gridlayout.addWidget(self.toolBox,0,0,1,1)
-
-        self.buttonBox = QtGui.QDialogButtonBox(PreferencesDialog)
-        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
-        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.NoButton|QtGui.QDialogButtonBox.Ok)
-        self.buttonBox.setObjectName("buttonBox")
-        self.gridlayout.addWidget(self.buttonBox,1,0,1,1)
-
-        self.retranslateUi(PreferencesDialog)
-        self.toolBox.setCurrentIndex(0)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("accepted()"),PreferencesDialog.accept)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("rejected()"),PreferencesDialog.reject)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("clicked(QAbstractButton*)"),PreferencesDialog.close)
-        QtCore.QMetaObject.connectSlotsByName(PreferencesDialog)
-
-    def retranslateUi(self, PreferencesDialog):
-        PreferencesDialog.setWindowTitle(QtGui.QApplication.translate("PreferencesDialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
-        self.groupBox.setTitle(QtGui.QApplication.translate("PreferencesDialog", "GroupBox", None, QtGui.QApplication.UnicodeUTF8))
-        self.loadModuleBtn.setText(QtGui.QApplication.translate("PreferencesDialog", "Load Selected Module", None, QtGui.QApplication.UnicodeUTF8))
-        self.modulConfigSelector.setText(QtGui.QApplication.translate("PreferencesDialog", "...", None, QtGui.QApplication.UnicodeUTF8))
-        self.toolBox.setItemText(self.toolBox.indexOf(self.ResourcePaths), QtGui.QApplication.translate("PreferencesDialog", "Resource Paths", None, QtGui.QApplication.UnicodeUTF8))
-        self.toolBox.setItemText(self.toolBox.indexOf(self.OgreSettings), QtGui.QApplication.translate("PreferencesDialog", "Ogre Settings", None, QtGui.QApplication.UnicodeUTF8))
-
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file 'preferences_dialog.ui'
+#
+# Created: Mon Jun 23 19:28:46 2008
+#      by: PyQt4 UI code generator 4.3.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_PreferencesDialog(object):
+    def setupUi(self, PreferencesDialog):
+        PreferencesDialog.setObjectName("PreferencesDialog")
+        PreferencesDialog.resize(QtCore.QSize(QtCore.QRect(0,0,528,626).size()).expandedTo(PreferencesDialog.minimumSizeHint()))
+
+        self.gridlayout = QtGui.QGridLayout(PreferencesDialog)
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.toolBox = QtGui.QToolBox(PreferencesDialog)
+        self.toolBox.setObjectName("toolBox")
+
+        self.ResourcePaths = QtGui.QWidget()
+        self.ResourcePaths.setGeometry(QtCore.QRect(0,0,510,505))
+        self.ResourcePaths.setObjectName("ResourcePaths")
+
+        self.gridlayout1 = QtGui.QGridLayout(self.ResourcePaths)
+        self.gridlayout1.setObjectName("gridlayout1")
+
+        self.listWidget = QtGui.QListWidget(self.ResourcePaths)
+        self.listWidget.setObjectName("listWidget")
+        self.gridlayout1.addWidget(self.listWidget,0,0,1,1)
+
+        self.groupBox = QtGui.QGroupBox(self.ResourcePaths)
+        self.groupBox.setMinimumSize(QtCore.QSize(0,95))
+        self.groupBox.setObjectName("groupBox")
+
+        self.layoutWidget = QtGui.QWidget(self.groupBox)
+        self.layoutWidget.setGeometry(QtCore.QRect(10,20,471,67))
+        self.layoutWidget.setObjectName("layoutWidget")
+
+        self.gridlayout2 = QtGui.QGridLayout(self.layoutWidget)
+        self.gridlayout2.setObjectName("gridlayout2")
+
+        self.lineEdit = QtGui.QLineEdit(self.layoutWidget)
+        self.lineEdit.setObjectName("lineEdit")
+        self.gridlayout2.addWidget(self.lineEdit,0,0,1,1)
+
+        self.loadModuleBtn = QtGui.QPushButton(self.layoutWidget)
+        self.loadModuleBtn.setObjectName("loadModuleBtn")
+        self.gridlayout2.addWidget(self.loadModuleBtn,1,0,1,2)
+
+        self.modulConfigSelector = QtGui.QPushButton(self.layoutWidget)
+        self.modulConfigSelector.setObjectName("modulConfigSelector")
+        self.gridlayout2.addWidget(self.modulConfigSelector,0,1,1,1)
+        self.gridlayout1.addWidget(self.groupBox,1,0,1,1)
+        self.toolBox.addItem(self.ResourcePaths,"")
+
+        self.OgreSettings = QtGui.QWidget()
+        self.OgreSettings.setGeometry(QtCore.QRect(0,0,96,26))
+        self.OgreSettings.setObjectName("OgreSettings")
+        self.toolBox.addItem(self.OgreSettings,"")
+        self.gridlayout.addWidget(self.toolBox,0,0,1,1)
+
+        self.buttonBox = QtGui.QDialogButtonBox(PreferencesDialog)
+        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
+        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.NoButton|QtGui.QDialogButtonBox.Ok)
+        self.buttonBox.setObjectName("buttonBox")
+        self.gridlayout.addWidget(self.buttonBox,1,0,1,1)
+
+        self.retranslateUi(PreferencesDialog)
+        self.toolBox.setCurrentIndex(0)
+        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("accepted()"),PreferencesDialog.accept)
+        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("rejected()"),PreferencesDialog.reject)
+        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("clicked(QAbstractButton*)"),PreferencesDialog.close)
+        QtCore.QMetaObject.connectSlotsByName(PreferencesDialog)
+
+    def retranslateUi(self, PreferencesDialog):
+        PreferencesDialog.setWindowTitle(QtGui.QApplication.translate("PreferencesDialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
+        self.groupBox.setTitle(QtGui.QApplication.translate("PreferencesDialog", "GroupBox", None, QtGui.QApplication.UnicodeUTF8))
+        self.loadModuleBtn.setText(QtGui.QApplication.translate("PreferencesDialog", "Load Selected Module", None, QtGui.QApplication.UnicodeUTF8))
+        self.modulConfigSelector.setText(QtGui.QApplication.translate("PreferencesDialog", "...", None, QtGui.QApplication.UnicodeUTF8))
+        self.toolBox.setItemText(self.toolBox.indexOf(self.ResourcePaths), QtGui.QApplication.translate("PreferencesDialog", "Resource Paths", None, QtGui.QApplication.UnicodeUTF8))
+        self.toolBox.setItemText(self.toolBox.indexOf(self.OgreSettings), QtGui.QApplication.translate("PreferencesDialog", "Ogre Settings", None, QtGui.QApplication.UnicodeUTF8))
+

Modified: rl/branches/newton20/editors/RLdialog/RLdialog.pro
===================================================================
--- rl/branches/newton20/editors/RLdialog/RLdialog.pro	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/editors/RLdialog/RLdialog.pro	2008-09-24 11:00:44 UTC (rev 4526)
@@ -1,14 +1,14 @@
 ######################################################################
-# Automatically generated by qmake (2.01a) Mo Dez 24 12:49:33 2007
+# Automatically generated by qmake (2.01a) Mi Sep 24 12:02:02 2008
 ######################################################################
 
 TEMPLATE = app
 TARGET = 
 DEPENDPATH += .
 INCLUDEPATH += .
-RESOURCES = rldialog.qrc
 QT += xml
 
 # Input
-HEADERS += rldialog.h helper.h editor.h ifdialog.h
-SOURCES += rldialog.cpp main.cpp helper.cpp editor.cpp ifdialog.cpp
+HEADERS += editor.h helper.h ifdialog.h rldialog.h
+SOURCES += editor.cpp helper.cpp ifdialog.cpp main.cpp rldialog.cpp
+RESOURCES += rldialog.qrc

Modified: rl/branches/newton20/editors/RLdialog/helper.h
===================================================================
--- rl/branches/newton20/editors/RLdialog/helper.h	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/editors/RLdialog/helper.h	2008-09-24 11:00:44 UTC (rev 4526)
@@ -2,11 +2,11 @@
 #define HELPER_H
 
 #include <QWidget>
-#include "ifDialog.h"
+#include "ifdialog.h"
 
 class startMode : public QWidget
 {
-	
+
 public:
 	startMode(QWidget *parent = 0);
 };
@@ -14,7 +14,7 @@
 class optionMode : public QWidget
 {
 	Q_OBJECT
-	
+
 public:
 	optionMode(QWidget *parent = 0);
 
@@ -31,27 +31,27 @@
 	QLabel *opt_mehrfachLabel;
 	QLabel *opt_wennLabel;
 	QLabel *opt_caseLabel;
-	
+
 	QLineEdit *opt_nameLEdit;
 	QLineEdit *opt_soundLEdit;
-	
+
 	QTextEdit *opt_textTEdit;
-	
+
 	QTreeWidget *opt_ifTree;
 	QStringList opt_ifHeaderlabels;
 	QTreeWidgetItem *if_item;
-	
+
 	QTreeWidget *opt_wennTree;
 	QTreeWidget *opt_caseTree;
-	
+
 	QToolButton *opt_ifAdd;
 	QToolButton *opt_ifRem;
 	QToolButton *opt_wenn;
 	QToolButton *opt_caseAdd;
 	QToolButton *opt_caseRem;
-	
+
 	QPushButton *opt_takeButton;
-	
+
 	QCheckBox *opt_mehrfachCheck;
 	QGroupBox *opt_mehrfachBox;
 
@@ -74,19 +74,19 @@
 	QLabel *res_soundLabel;
 	QLabel *res_effektLabel;
 	QLabel *res_gotoLabel;
-	
+
 	QLineEdit *res_nameLEdit;
 	QLineEdit *res_soundLEdit;
-	
+
 	QTextEdit *res_textTEdit;
-	
+
 	QTreeWidget *res_effektTree;
-	
+
 	QToolButton *res_effektAdd;
 	QToolButton *res_effektRem;
-	
+
 	QPushButton *res_takeButton;
-	
+
 	QComboBox *res_gotoCombo;
 };
 

Modified: rl/branches/newton20/engine/common/include/Property.h
===================================================================
--- rl/branches/newton20/engine/common/include/Property.h	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/engine/common/include/Property.h	2008-09-24 11:00:44 UTC (rev 4526)
@@ -1,6 +1,6 @@
-/* 
+/*
  * (C) 2003-2008. Team Pantheon. www.team-pantheon.de
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -78,7 +78,7 @@
 
     typedef std::vector<Property> PropertyArray;
     typedef std::map<CeGuiString, Property> PropertyMap;
-    
+
     class _RlCommonExport Property
     {
     public:
@@ -87,7 +87,8 @@
         PropertyMethod(Bool, const bool&);
         PropertyMethod(String, CEGUI::String);
         PropertyMethod(Int, const int&);
-        PropertyMethod(Long, const RL_LONGLONG&);
+        PropertyMethod(Long, const long&);
+        PropertyMethod(LongLong, const RL_LONGLONG&);
         PropertyMethod(Real, const Ogre::Real&);
         PropertyMethod(Vector3, const Ogre::Vector3&);
         PropertyMethod(Quaternion, const Ogre::Quaternion&);
@@ -163,7 +164,7 @@
             output[it->first.c_str()] = temp;
         }
     }
-    
+
     template<typename T> void convertToMap(
         const PropertyMap& propmap, std::map<const CeGuiString, T>& output)
     {
@@ -176,7 +177,7 @@
 			//output.insert(typename std::map<const CeGuiString, T>::value_type(it->first, it->second));
         }
     }
-    
+
     template<typename T> void convertToSet(
         const PropertyArray& propvec, std::set<T>& output)
     {

Modified: rl/branches/newton20/engine/core/include/SaveAble.h
===================================================================
--- rl/branches/newton20/engine/core/include/SaveAble.h	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/engine/core/include/SaveAble.h	2008-09-24 11:00:44 UTC (rev 4526)
@@ -25,16 +25,33 @@
 
 namespace rl
 {
+	class SaveAble;
 
+	class SaveAblePtr : public Ogre::SharedPtr<SaveAble>
+	{
+	};
+
 	class SaveAble : public PropertyHolder
 	{
 	public:
+		SaveAble(int id, bool isSaveAble = true);
 		void setSaveAble(bool enable);
 		bool isSaveAble();
+
+		virtual const Property getProperty(const CeGuiString& key) const;
+        virtual void setProperty(const CeGuiString& key, const Property& value);
+        virtual PropertyKeys getAllPropertyKeys() const;
+		
+		SaveAblePtr getParent() const { return mParentSaveAble; };
+
+		int getId();
 	protected:
+		SaveAblePtr mParentSaveAble;
+		int mId;
 		bool mIsSaveAble;
-	};
+	};	
 
+	typedef std::pair<int, SaveAblePtr>  SaveAbleReference;
 }
 
 

Modified: rl/branches/newton20/engine/core/include/SaveAbleCollection.h
===================================================================
--- rl/branches/newton20/engine/core/include/SaveAbleCollection.h	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/engine/core/include/SaveAbleCollection.h	2008-09-24 11:00:44 UTC (rev 4526)
@@ -0,0 +1,34 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#include "CorePrerequisites.h"
+#include "SaveAble.h"
+
+namespace rl
+{
+
+	class SaveAbleCollection
+	{
+	public:
+		void attachSaveAble(SaveAblePtr saveAble);
+		void deattachSaveAble(SaveAblePtr saveAble);
+		void deattachSaveAble(int id);
+		void deattachAllSaveAbles();
+	protected:
+		Ogre::String mId;
+	};
+
+}
\ No newline at end of file

Modified: rl/branches/newton20/engine/core/include/SaveAbleFactory.h
===================================================================
--- rl/branches/newton20/engine/core/include/SaveAbleFactory.h	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/engine/core/include/SaveAbleFactory.h	2008-09-24 11:00:44 UTC (rev 4526)
@@ -0,0 +1,43 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __SaveAbleFactory_H__
+#define __SaveAbleFactory_H__
+
+#include "CorePrerequisites.h"
+#include "SaveAble.h"
+
+namespace rl
+{
+	class SaveAbleFactory : public Ogre::Singleton<SaveAbleFactory>
+	{
+	public:
+		virtual SaveAblePtr createSaveAble(PropertyRecordPtr params) = 0;
+	};
+
+	class SaveAbleFactoryPool : public Ogre::Singleton<SaveAbleFactoryPool>
+	{
+	public:
+		void registerFactory(const Ogre::String &key, SaveAbleFactory* fac);
+		void unregisterFactory(const Ogre::String &key);
+		void unregisterFactory(SaveAbleFactory* fac);
+		SaveAbleFactory* getFactory(const Ogre::String &key);
+	protected:
+		std::map<Ogre::String,SaveAbleFactory*> mFactories;
+	};
+}
+
+#endif

Modified: rl/branches/newton20/engine/core/include/SaveAbleManager.h
===================================================================
--- rl/branches/newton20/engine/core/include/SaveAbleManager.h	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/engine/core/include/SaveAbleManager.h	2008-09-24 11:00:44 UTC (rev 4526)
@@ -0,0 +1,44 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __SaveAbleManager_H__
+#define __SaveAbleManager_H__
+
+#include "CorePrerequisites.h"
+#include "SaveAble.h"
+#include "SaveAbleCollection.h"
+
+namespace rl
+{
+	class SaveAbleManager : public Ogre::Singleton<SaveAbleManager>
+	{
+	public:
+		void saveState();
+		void addSaveAble(SaveAblePtr save);
+		void removeSaveAble(SaveAblePtr save);
+		void removeSaveAble(int id);
+		void removeAllSaveAbles();
+		void attachSaveAbleToCollection(int id);
+		void deattachSaveAbleFromColltection(int id);
+		void restoreState();
+	protected:
+		std::map<int, PropertyRecordPtr> mSaveAbleStates;
+		std::map<int, SaveAblePtr> mSaveAbles;
+		std::map<Ogre::String,SaveAbleCollection> mSaveAbleCollections;
+	};
+}
+
+#endif
\ No newline at end of file

Modified: rl/branches/newton20/engine/core/src/SaveAble.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/SaveAble.cpp	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/engine/core/src/SaveAble.cpp	2008-09-24 11:00:44 UTC (rev 4526)
@@ -23,6 +23,10 @@
 
 namespace rl
 {
+	SaveAble::SaveAble(int id, bool isSaveAble)
+	{
+	}
+
 	void SaveAble::setSaveAble(bool enable)
 	{
 		mIsSaveAble = true;
@@ -32,4 +36,23 @@
 	{
 		return mIsSaveAble;
 	}
+
+	const Property SaveAble::getProperty(const CeGuiString& key) const
+	{
+		return Property();
+	}
+	
+	void SaveAble::setProperty(const CeGuiString& key, const Property& value)
+	{
+	}
+	
+	PropertyKeys SaveAble::getAllPropertyKeys() const
+	{
+		return PropertyKeys();
+	}
+
+	int SaveAble::getId()
+	{
+		return mId;
+	}
 }
\ No newline at end of file

Modified: rl/branches/newton20/engine/core/src/SaveAbleCollection.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/SaveAbleCollection.cpp	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/engine/core/src/SaveAbleCollection.cpp	2008-09-24 11:00:44 UTC (rev 4526)
@@ -14,4 +14,6 @@
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
-#include "stdinc.h"
\ No newline at end of file
+#include "stdinc.h"
+
+#include "SaveAbleCollection.h"
\ No newline at end of file

Modified: rl/branches/newton20/engine/core/src/SaveAbleFactory.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/SaveAbleFactory.cpp	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/engine/core/src/SaveAbleFactory.cpp	2008-09-24 11:00:44 UTC (rev 4526)
@@ -14,4 +14,6 @@
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
-#include "stdinc.h"
\ No newline at end of file
+#include "stdinc.h"
+
+#include "SaveAbleFactory.h"
\ No newline at end of file

Modified: rl/branches/newton20/engine/core/src/SaveAbleManager.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/SaveAbleManager.cpp	2008-09-24 09:56:24 UTC (rev 4525)
+++ rl/branches/newton20/engine/core/src/SaveAbleManager.cpp	2008-09-24 11:00:44 UTC (rev 4526)
@@ -14,4 +14,6 @@
 *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
 */
 
-#include "stdinc.h"
\ No newline at end of file
+#include "stdinc.h"
+
+#include "SaveAbleManager.h"
\ No newline at end of file



From timm at mail.berlios.de  Sun Sep 28 18:08:51 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 28 Sep 2008 18:08:51 +0200
Subject: [Dsa-hl-svn] r4527 - rl/branches
Message-ID: <200809281608.m8SG8pKI017612@sheep.berlios.de>

Author: timm
Date: 2008-09-28 18:08:40 +0200 (Sun, 28 Sep 2008)
New Revision: 4527

Added:
   rl/branches/persistence/
Log:
making a new branch for new persistence system

Copied: rl/branches/persistence (from rev 4526, rl/trunk/engine)



From timm at mail.berlios.de  Sun Sep 28 18:10:55 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 28 Sep 2008 18:10:55 +0200
Subject: [Dsa-hl-svn] r4528 - in rl/branches/persistence: ai/include core
	core/include core/src rules/include rules/src script/include
	script/src script/swig ui/include ui/src
Message-ID: <200809281610.m8SGAt0K017757@sheep.berlios.de>

Author: timm
Date: 2008-09-28 18:10:32 +0200 (Sun, 28 Sep 2008)
New Revision: 4528

Modified:
   rl/branches/persistence/ai/include/SteeringVehicle.h
   rl/branches/persistence/core/RlCore2005.vcproj
   rl/branches/persistence/core/include/Job.h
   rl/branches/persistence/core/include/SaveAble.h
   rl/branches/persistence/core/include/SaveAbleCollection.h
   rl/branches/persistence/core/src/Job.cpp
   rl/branches/persistence/core/src/SaveAble.cpp
   rl/branches/persistence/rules/include/Armor.h
   rl/branches/persistence/rules/include/Container.h
   rl/branches/persistence/rules/include/Creature.h
   rl/branches/persistence/rules/include/CreatureController.h
   rl/branches/persistence/rules/include/DsaManager.h
   rl/branches/persistence/rules/include/GameObject.h
   rl/branches/persistence/rules/include/GameObjectManager.h
   rl/branches/persistence/rules/include/Item.h
   rl/branches/persistence/rules/include/Weapon.h
   rl/branches/persistence/rules/src/Armor.cpp
   rl/branches/persistence/rules/src/Container.cpp
   rl/branches/persistence/rules/src/Creature.cpp
   rl/branches/persistence/rules/src/DsaDataLoader.cpp
   rl/branches/persistence/rules/src/DsaManager.cpp
   rl/branches/persistence/rules/src/GameObject.cpp
   rl/branches/persistence/rules/src/GameObjectManager.cpp
   rl/branches/persistence/rules/src/Item.cpp
   rl/branches/persistence/rules/src/Weapon.cpp
   rl/branches/persistence/script/include/UnifiedFactory.h
   rl/branches/persistence/script/src/GameObjectNodeProcessor.cpp
   rl/branches/persistence/script/src/Scene.cpp
   rl/branches/persistence/script/swig/RlCore.head.swig
   rl/branches/persistence/script/swig/RlCore.swig
   rl/branches/persistence/script/swig/RlRules.swig
   rl/branches/persistence/script/swig/RlScript.swig
   rl/branches/persistence/ui/include/ControlState.h
   rl/branches/persistence/ui/include/UiSubsystem.h
   rl/branches/persistence/ui/src/ContainerContentWindow.cpp
   rl/branches/persistence/ui/src/InventoryWindow.cpp
   rl/branches/persistence/ui/src/UiSubsystem.cpp
Log:
- changed id of game object from int to ceguistring
- game object and job are saveables now

Modified: rl/branches/persistence/ai/include/SteeringVehicle.h
===================================================================
--- rl/branches/persistence/ai/include/SteeringVehicle.h	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/ai/include/SteeringVehicle.h	2008-09-28 16:10:32 UTC (rev 4528)
@@ -292,7 +292,7 @@
 		//! the yaw angle in radians
 		//Ogre::Radian mYaw;
 
-        int mCreatureId;
+        CeGuiString mCreatureId;
 
         bool refetchCreature();
 

Modified: rl/branches/persistence/core/RlCore2005.vcproj
===================================================================
--- rl/branches/persistence/core/RlCore2005.vcproj	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/core/RlCore2005.vcproj	2008-09-28 16:10:32 UTC (rev 4528)
@@ -568,42 +568,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\include\SaveAble.h"
-				>
-			</File>
-			<File
-				RelativePath=".\include\SaveAbleCollection.h"
-				>
-			</File>
-			<File
-				RelativePath=".\include\SaveAbleFactory.h"
-				>
-			</File>
-			<File
-				RelativePath=".\include\SaveAbleManager.h"
-				>
-			</File>
-			<File
-				RelativePath=".\include\SaveGameData.h"
-				>
-			</File>
-			<File
-				RelativePath=".\include\SaveGameFile.h"
-				>
-			</File>
-			<File
-				RelativePath=".\include\SaveGameFileReader.h"
-				>
-			</File>
-			<File
-				RelativePath=".\include\SaveGameFileWriter.h"
-				>
-			</File>
-			<File
-				RelativePath=".\include\SaveGameManager.h"
-				>
-			</File>
-			<File
 				RelativePath=".\include\SceneQuery.h"
 				>
 			</File>
@@ -699,6 +663,46 @@
 					>
 				</File>
 			</Filter>
+			<Filter
+				Name="SaveGame"
+				>
+				<File
+					RelativePath=".\include\SaveAble.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\SaveAbleCollection.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\SaveAbleFactory.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\SaveAbleManager.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\SaveGameData.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\SaveGameFile.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\SaveGameFileReader.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\SaveGameFileWriter.h"
+					>
+				</File>
+				<File
+					RelativePath=".\include\SaveGameManager.h"
+					>
+				</File>
+			</Filter>
 		</Filter>
 		<Filter
 			Name="Source Files"
@@ -889,42 +893,6 @@
 				>
 			</File>
 			<File
-				RelativePath=".\src\SaveAble.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\SaveAbleCollection.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\SaveAbleFactory.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\SaveAbleManager.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\SaveGameData.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\SaveGameFile.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\SaveGameFileReader.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\SaveGameFileWriter.cpp"
-				>
-			</File>
-			<File
-				RelativePath=".\src\SaveGameManager.cpp"
-				>
-			</File>
-			<File
 				RelativePath=".\src\SceneQuery.cpp"
 				>
 			</File>
@@ -1044,6 +1012,46 @@
 					>
 				</File>
 			</Filter>
+			<Filter
+				Name="SaveGame"
+				>
+				<File
+					RelativePath=".\src\SaveAble.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\SaveAbleCollection.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\SaveAbleFactory.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\SaveAbleManager.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\SaveGameData.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\SaveGameFile.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\SaveGameFileReader.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\SaveGameFileWriter.cpp"
+					>
+				</File>
+				<File
+					RelativePath=".\src\SaveGameManager.cpp"
+					>
+				</File>
+			</Filter>
 		</Filter>
 		<Filter
 			Name="Resource Files"

Modified: rl/branches/persistence/core/include/Job.h
===================================================================
--- rl/branches/persistence/core/include/Job.h	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/core/include/Job.h	2008-09-28 16:10:32 UTC (rev 4528)
@@ -20,11 +20,12 @@
 #include "CorePrerequisites.h"
 
 #include "TimeSource.h"
-#include "Properties.h"
 
+#include "SaveAble.h"
+
 namespace rl
 {
-    class _RlCoreExport AbstractJob : public PropertyHolder
+    class _RlCoreExport AbstractJob : public SaveAble
     {
     public:
         enum JobPersistenceType

Modified: rl/branches/persistence/core/include/SaveAble.h
===================================================================
--- rl/branches/persistence/core/include/SaveAble.h	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/core/include/SaveAble.h	2008-09-28 16:10:32 UTC (rev 4528)
@@ -27,14 +27,15 @@
 {
 	class SaveAble;
 
-	class SaveAblePtr : public Ogre::SharedPtr<SaveAble>
+	class _RlCoreExport SaveAblePtr : public Ogre::SharedPtr<SaveAble>
 	{
 	};
 
-	class SaveAble : public PropertyHolder
+	class _RlCoreExport SaveAble : public PropertyHolder
 	{
 	public:
-		SaveAble(int id, bool isSaveAble = true);
+		SaveAble(const CeGuiString &id, bool isSaveAble = true);
+		~SaveAble();
 		void setSaveAble(bool enable);
 		bool isSaveAble();
 
@@ -44,10 +45,10 @@
 		
 		SaveAblePtr getParent() const { return mParentSaveAble; };
 
-		int getId();
+		CeGuiString getId() const;
 	protected:
 		SaveAblePtr mParentSaveAble;
-		int mId;
+		CeGuiString mId;
 		bool mIsSaveAble;
 	};	
 

Modified: rl/branches/persistence/core/include/SaveAbleCollection.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleCollection.h	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/core/include/SaveAbleCollection.h	2008-09-28 16:10:32 UTC (rev 4528)
@@ -27,6 +27,7 @@
 		void deattachSaveAble(SaveAblePtr saveAble);
 		void deattachSaveAble(int id);
 		void deattachAllSaveAbles();
+		Ogre::String getId();
 	protected:
 		Ogre::String mId;
 	};

Modified: rl/branches/persistence/core/src/Job.cpp
===================================================================
--- rl/branches/persistence/core/src/Job.cpp	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/core/src/Job.cpp	2008-09-28 16:10:32 UTC (rev 4528)
@@ -22,7 +22,8 @@
 {
     AbstractJob::AbstractJob(bool isDiscardable, bool destroyWhenDone)
         : mIsDiscardable(isDiscardable), 
-        mDestroyWhenDone(destroyWhenDone)
+        mDestroyWhenDone(destroyWhenDone),
+		SaveAble("")
     {
     }
 

Modified: rl/branches/persistence/core/src/SaveAble.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAble.cpp	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/core/src/SaveAble.cpp	2008-09-28 16:10:32 UTC (rev 4528)
@@ -23,10 +23,14 @@
 
 namespace rl
 {
-	SaveAble::SaveAble(int id, bool isSaveAble)
+	SaveAble::SaveAble(const CeGuiString &id, bool isSaveAble)
 	{
 	}
 
+	SaveAble::~SaveAble()
+	{
+	}
+
 	void SaveAble::setSaveAble(bool enable)
 	{
 		mIsSaveAble = true;
@@ -51,7 +55,7 @@
 		return PropertyKeys();
 	}
 
-	int SaveAble::getId()
+	CeGuiString SaveAble::getId() const
 	{
 		return mId;
 	}

Modified: rl/branches/persistence/rules/include/Armor.h
===================================================================
--- rl/branches/persistence/rules/include/Armor.h	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/include/Armor.h	2008-09-28 16:10:32 UTC (rev 4528)
@@ -34,7 +34,7 @@
         static const Ogre::String PROPERTY_G_RS;
 
         // Konstruktor und Destruktor
-		Armor (unsigned int id);
+		Armor (const CeGuiString &id);
 		virtual ~Armor();
 		 
 

Modified: rl/branches/persistence/rules/include/Container.h
===================================================================
--- rl/branches/persistence/rules/include/Container.h	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/include/Container.h	2008-09-28 16:10:32 UTC (rev 4528)
@@ -40,7 +40,7 @@
 		/** Creates a new container
 		 * @param id the gameobject ID
 		 */
-        Container(int id);
+		Container(const CeGuiString &id);
         virtual ~Container(void);
 
 		/// Get the weight capacity (in Stein)

Modified: rl/branches/persistence/rules/include/Creature.h
===================================================================
--- rl/branches/persistence/rules/include/Creature.h	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/include/Creature.h	2008-09-28 16:10:32 UTC (rev 4528)
@@ -149,7 +149,7 @@
             static const Wert WERT_KAMPFUNFAEHIGKEITSSCHWELLE; 
             static const Wert WERT_REGENERATION;
     			
-			Creature(unsigned int id);
+			Creature(const CeGuiString &id);
 
             /// Der Standarddestruktor.
             virtual ~Creature();

Modified: rl/branches/persistence/rules/include/CreatureController.h
===================================================================
--- rl/branches/persistence/rules/include/CreatureController.h	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/include/CreatureController.h	2008-09-28 16:10:32 UTC (rev 4528)
@@ -153,7 +153,7 @@
 
     protected:
         Creature *mCreature;
-        int mGameObjectId;
+		CeGuiString mGameObjectId;
         AbstractLocation mAbstractLocation;
         
         AbstractMovement *mMovement;

Modified: rl/branches/persistence/rules/include/DsaManager.h
===================================================================
--- rl/branches/persistence/rules/include/DsaManager.h	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/include/DsaManager.h	2008-09-28 16:10:32 UTC (rev 4528)
@@ -77,7 +77,7 @@
         Talent* getTalent(const CeGuiString talentName) const;
         Kampftechnik* getKampftechnik(const CeGuiString kampftechnikName) const;
         Eigenschaft* getEigenschaft(const CeGuiString eigenschaftName) const;
-		Creature* getCreature(int id) const;        
+		Creature* getCreature(const CeGuiString &id) const;        
 				
 		int getSteigerKosten(int column, int from, int to) const;
 		int getSteigerKosten(int column, int from) const;
@@ -94,7 +94,7 @@
         Ogre::Real mTimeScale;
 
         typedef std::map<CeGuiString, Talent*> TalentMap;
-		typedef std::map<int, Creature*> CreatureMap;
+		typedef std::map<CeGuiString, Creature*> CreatureMap;
         typedef std::map<CeGuiString, Kampftechnik*> KampftechnikMap;
 		typedef std::map<CeGuiString, Eigenschaft*> EigenschaftMap;
 		EigenschaftMap mEigenschaften;

Modified: rl/branches/persistence/rules/include/GameObject.h
===================================================================
--- rl/branches/persistence/rules/include/GameObject.h	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/include/GameObject.h	2008-09-28 16:10:32 UTC (rev 4528)
@@ -21,6 +21,7 @@
 
 #include "Action.h"
 #include "Actor.h"
+#include "SaveAble.h"
 #include "RulesConstants.h"
 #include "ObjectStateChangeEventSource.h"
 #include "Properties.h"
@@ -40,11 +41,11 @@
     class _RlRulesExport GameObject 
         : public ActorNotifiedObject, 
           public ObjectStateChangeEventSource,
-          public PropertyHolder
+		  public SaveAble
     {
     public:
         typedef std::vector<std::pair<Action*, int> > ActionOptionVector;
-        static const unsigned int NO_OBJECT_ID = 0;
+		static const CeGuiString NO_OBJECT_ID;
         
         static const Ogre::String CLASS_NAME;
 
@@ -68,11 +69,9 @@
         static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
         static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
 
-        GameObject(unsigned int id);
+		GameObject(const CeGuiString &id);
         virtual ~GameObject();
 
-        int getId() const;
-
         const CeGuiString& getClassId() const;
         void setClassId(const CeGuiString& classId);
         
@@ -192,7 +191,6 @@
         void _checkEffects();
 
     protected:
-        int mId;
         GameObjectState mState;
         
         CeGuiString mName;

Modified: rl/branches/persistence/rules/include/GameObjectManager.h
===================================================================
--- rl/branches/persistence/rules/include/GameObjectManager.h	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/include/GameObjectManager.h	2008-09-28 16:10:32 UTC (rev 4528)
@@ -35,8 +35,8 @@
     public:
         GameObjectFactory();
 
-        GameObject* createGameObject(const Ogre::String& classname, unsigned int id);
-        virtual GameObject* createRubyGameObject(const Ogre::String& classname, unsigned int id) = 0;
+		GameObject* createGameObject(const Ogre::String& classname, const CeGuiString &id);
+        virtual GameObject* createRubyGameObject(const Ogre::String& classname, const CeGuiString &id) = 0;
     };
 
     class _RlRulesExport GameObjectManager : 
@@ -48,10 +48,10 @@
         GameObjectManager();
         ~GameObjectManager();
 
-        GameObject* getGameObject(unsigned int id) const;
-        GameObject* createGameObject(const CeGuiString& classId, unsigned int id = 0);
+		GameObject* getGameObject(const CeGuiString &id) const;
+		GameObject* createGameObject(const CeGuiString& classId, const CeGuiString &id = "");
 		
-        void deleteGameObject(unsigned int id);
+		void deleteGameObject(const CeGuiString &id);
         void deleteGameObject(GameObject* obj);
         void deleteAllGameObjects();
 
@@ -79,7 +79,7 @@
 
         Ogre::StringVector mScriptPatterns;
 
-        std::map<unsigned int, GameObject*> mGameObjects;
+		std::map<CeGuiString, GameObject*> mGameObjects;
         ClassPropertyMap mClassProperties;
         unsigned int mGeneratedId;
         GameObjectFactory* mGameObjectFactory;

Modified: rl/branches/persistence/rules/include/Item.h
===================================================================
--- rl/branches/persistence/rules/include/Item.h	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/include/Item.h	2008-09-28 16:10:32 UTC (rev 4528)
@@ -62,7 +62,7 @@
         static const Ogre::String PROPERTY_SIZE;
         static const Ogre::String PROPERTY_SUBMESHNAME;
 
-		Item(unsigned int id);
+		Item(const CeGuiString &id);
         virtual ~Item(void);
 
 		void setItemType(ItemType itemType);

Modified: rl/branches/persistence/rules/include/Weapon.h
===================================================================
--- rl/branches/persistence/rules/include/Weapon.h	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/include/Weapon.h	2008-09-28 16:10:32 UTC (rev 4528)
@@ -50,7 +50,7 @@
         static const Ogre::String PROPERTY_TP_KAMPFTECHNIK;
         static const Ogre::String PROPERTY_NATURAL;
 
-		Weapon (unsigned int id);
+		Weapon (const CeGuiString &id);
         virtual ~Weapon(void);
 
 		void setTp(int d6, int d20, int mod);

Modified: rl/branches/persistence/rules/src/Armor.cpp
===================================================================
--- rl/branches/persistence/rules/src/Armor.cpp	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/src/Armor.cpp	2008-09-28 16:10:32 UTC (rev 4528)
@@ -31,7 +31,7 @@
     const Ogre::String Armor::PROPERTY_G_BE = "g_be";
     const Ogre::String Armor::PROPERTY_G_RS = "g_rs";
 
-	Armor::Armor(unsigned int id)
+	Armor::Armor(const CeGuiString &id)
 		: Item(id),
 		mGRS(0),
 		mGBE(0),

Modified: rl/branches/persistence/rules/src/Container.cpp
===================================================================
--- rl/branches/persistence/rules/src/Container.cpp	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/src/Container.cpp	2008-09-28 16:10:32 UTC (rev 4528)
@@ -38,7 +38,7 @@
     const Ogre::String Container::PROPERTY_CONTENT_OBJECTS = "objects";
     const Ogre::String Container::PROPERTY_CONTENT_POSITIONS = "positions";
 
-    Container::Container(int id)
+	Container::Container(const CeGuiString &id)
         : Item(id),
           mCapacity(0.0),
 		  mVolume(std::make_pair(1,1))

Modified: rl/branches/persistence/rules/src/Creature.cpp
===================================================================
--- rl/branches/persistence/rules/src/Creature.cpp	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/src/Creature.cpp	2008-09-28 16:10:32 UTC (rev 4528)
@@ -82,7 +82,7 @@
 
 
 
-    Creature::Creature(unsigned int id)
+	Creature::Creature(const CeGuiString &id)
         : GameObject(id),
 		mCurrentLe(0),
         mCurrentAu(0),

Modified: rl/branches/persistence/rules/src/DsaDataLoader.cpp
===================================================================
--- rl/branches/persistence/rules/src/DsaDataLoader.cpp	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/src/DsaDataLoader.cpp	2008-09-28 16:10:32 UTC (rev 4528)
@@ -234,7 +234,7 @@
 			getValueAsString(getChildNamed(personXml, "Beschreibung"));
 
         //@warning replace this by correct loading process
-		Creature* rval = new Creature(10000);
+		Creature* rval = new Creature("10000");
         rval->setName(name);
         rval->setDescription(desc);
 

Modified: rl/branches/persistence/rules/src/DsaManager.cpp
===================================================================
--- rl/branches/persistence/rules/src/DsaManager.cpp	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/src/DsaManager.cpp	2008-09-28 16:10:32 UTC (rev 4528)
@@ -291,7 +291,7 @@
 		return sum;
 	}
 
-	Creature* DsaManager::getCreature(int id) const
+	Creature* DsaManager::getCreature(const CeGuiString &id) const
 	{
 		CreatureMap::const_iterator it = mCreatures.find(id);
         if (it != mCreatures.end())

Modified: rl/branches/persistence/rules/src/GameObject.cpp
===================================================================
--- rl/branches/persistence/rules/src/GameObject.cpp	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/src/GameObject.cpp	2008-09-28 16:10:32 UTC (rev 4528)
@@ -41,6 +41,8 @@
 
     const Ogre::String GameObject::CLASS_NAME = "GameObject";
 
+	const CeGuiString GameObject::NO_OBJECT_ID = "";
+
     const Ogre::String GameObject::PROPERTY_CLASS_ID = "classid";
     const Ogre::String GameObject::PROPERTY_OBJECT_ID = "id";
     const Ogre::String GameObject::PROPERTY_BASE_CLASS = "baseclass";
@@ -58,9 +60,8 @@
     const Ogre::String GameObject::PROPERTY_ACTIONS = "actions";
     const Ogre::String GameObject::PROPERTY_DEFAULT_ACTION = "defaultaction";
 
-    GameObject::GameObject(unsigned int id)
-        :   mId(id),
-            mName(""),
+	GameObject::GameObject(const CeGuiString &id)
+        :   mName(""),
             mDescription(""),
             mMeshfile(""),
 			mMeshParts(),
@@ -74,7 +75,8 @@
             mGeometryType(GT_NONE),
             mDefaultAction(DEFAULT_VIEW_OBJECT_ACTION),
             mState(GOS_LOADED),
-            mScene("")
+            mScene(""),
+			SaveAble(id)
     {
         mEffectManager = new EffectManager(this);
 
@@ -106,11 +108,6 @@
     	delete mEffectManager;
     }
 
-    int GameObject::getId() const
-    {
-        return mId;
-    }
-
     const CeGuiString& GameObject::getClassId() const
     {
         return mClassId;
@@ -185,7 +182,7 @@
 
         mActions.push_back(make_pair(action, option));
         LOG_MESSAGE(Logger::RULES,
-            "Bei GameObject #"+CEGUI::PropertyHelper::intToString(mId)+
+            "Bei GameObject #" + mId +
             " ("+getName()+") wurde Aktion "+action->getName().c_str()+" hinzugefuegt.");
     }
 
@@ -644,7 +641,7 @@
     {
         if (!mActor)
         {
-            Ogre::String actorName = Ogre::StringConverter::toString(mId);
+            Ogre::String actorName = mId.c_str();
 			Actor* actor = NULL;
 
 			if (mMeshfile.empty() && mMeshParts.empty())
@@ -652,7 +649,7 @@
 				LOG_ERROR(
 					Logger::RULES,
 					"Neither mesh file nor mesh parts are set on gameobject '" + getName()
-					+ "' (id: " + getId() + "). Can't create actor!");
+					+ "' (id: " + getId().c_str() + "). Can't create actor!");
 			}
 			else if (!mMeshParts.empty())
 			{
@@ -728,7 +725,7 @@
                 LOG_ERROR(
                     Logger::RULES,
                     "Error placing gameobject '"
-                    + Ogre::StringConverter::toString(mId)
+                    + mId
                     + "' into scene "
                     + mMeshfile);
             }

Modified: rl/branches/persistence/rules/src/GameObjectManager.cpp
===================================================================
--- rl/branches/persistence/rules/src/GameObjectManager.cpp	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/src/GameObjectManager.cpp	2008-09-28 16:10:32 UTC (rev 4528)
@@ -80,9 +80,9 @@
 
     }
 
-    GameObject* GameObjectManager::getGameObject(unsigned int id) const
+	GameObject* GameObjectManager::getGameObject(const CeGuiString &id) const
     {
-        std::map<unsigned int, GameObject*>::const_iterator it
+		std::map<CeGuiString , GameObject*>::const_iterator it
                 = mGameObjects.find(id);
 
         if (it != mGameObjects.end())
@@ -96,7 +96,7 @@
     std::list<GameObject*> GameObjectManager::getAllGameObjects() const
     {
         std::list<GameObject*> gos;
-        std::map<unsigned int, GameObject*>::const_iterator it;
+		std::map<CeGuiString, GameObject*>::const_iterator it;
 
         //
         //    Run through all GOs and put them into the list
@@ -115,11 +115,11 @@
     }
 
     GameObject* GameObjectManager::createGameObject(
-        const CeGuiString& classId, unsigned int id)
+		const CeGuiString& classId,const CeGuiString &id)
     {
 		LOG_MESSAGE("GameObjectManager", "Create/Get GameObject of type " + classId
-			+ " #" + Ogre::StringConverter::toString((int)id));
-        unsigned int goId;
+			+ " #" + id);
+		CeGuiString goId;
 
         if (id != GameObject::NO_OBJECT_ID)
         {
@@ -155,7 +155,7 @@
         return go;
     }
 
-    void GameObjectManager::deleteGameObject(unsigned int id)
+	void GameObjectManager::deleteGameObject(const CeGuiString &id)
     {
         if(mGameObjects.find(id) != mGameObjects.end())
         {
@@ -200,7 +200,7 @@
 		if (posDivider != CeGuiString::npos)
 		{
 			Ogre::String classId(serializedString.substr(0, posDivider).c_str());
-			unsigned int goid = CEGUI::PropertyHelper::stringToUint(serializedString.substr(posDivider+1));
+			Ogre::String goid = serializedString.substr(posDivider+1).c_str();
 			return createGameObject(classId, goid);
 		}
 
@@ -209,7 +209,7 @@
 
 	Property GameObjectManager::toProperty(const GameObject* const go) const
 	{
-		return Property(go->getClassId() + "|" + CEGUI::PropertyHelper::uintToString(go->getId()));
+		return Property(go->getClassId() + "|" + go->getId());
 	}
 
     const PropertyRecordPtr GameObjectManager::getClassProperties(const CeGuiString& classId) const
@@ -261,7 +261,7 @@
     {
     }
 
-    GameObject* GameObjectFactory::createGameObject(const Ogre::String& classname, unsigned int id)
+	GameObject* GameObjectFactory::createGameObject(const Ogre::String& classname, const CeGuiString &id)
     {
         if (classname == GameObject::CLASS_NAME)
         {

Modified: rl/branches/persistence/rules/src/Item.cpp
===================================================================
--- rl/branches/persistence/rules/src/Item.cpp	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/src/Item.cpp	2008-09-28 16:10:32 UTC (rev 4528)
@@ -34,7 +34,7 @@
     const Ogre::String Item::PROPERTY_SIZE = "size";
     const Ogre::String Item::PROPERTY_SUBMESHNAME = "submeshfile";
 
-    Item::Item(unsigned int id)
+	Item::Item(const CeGuiString &id)
         : GameObject(id),
 		mItemType(ITEMTYPE_OTHER),
 		mImageName(""),

Modified: rl/branches/persistence/rules/src/Weapon.cpp
===================================================================
--- rl/branches/persistence/rules/src/Weapon.cpp	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/rules/src/Weapon.cpp	2008-09-28 16:10:32 UTC (rev 4528)
@@ -37,7 +37,7 @@
     const Ogre::String Weapon::PROPERTY_TP_KAMPFTECHNIK = "kampftechnik";
     const Ogre::String Weapon::PROPERTY_NATURAL = "natural";
 
-	Weapon::Weapon(unsigned int id)
+	Weapon::Weapon(const CeGuiString &id)
 		: Item(id),
         mTp(0, 0, 0),
 		mTpKk(0, 0),

Modified: rl/branches/persistence/script/include/UnifiedFactory.h
===================================================================
--- rl/branches/persistence/script/include/UnifiedFactory.h	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/script/include/UnifiedFactory.h	2008-09-28 16:10:32 UTC (rev 4528)
@@ -35,7 +35,7 @@
 
         virtual Trigger* createTrigger(const Ogre::String& classname, const Ogre::String& name) = 0;
         virtual Effect* createEffect(const Ogre::String& name, int stufe) = 0;
-        virtual GameObject* createRubyGameObject(const Ogre::String& classname, unsigned int id) = 0;
+        virtual GameObject* createRubyGameObject(const Ogre::String& classname, const CeGuiString &id) = 0;
         virtual SteeringBehaviour* createBehaviour(const Ogre::String& classname) = 0;
     };
 }

Modified: rl/branches/persistence/script/src/GameObjectNodeProcessor.cpp
===================================================================
--- rl/branches/persistence/script/src/GameObjectNodeProcessor.cpp	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/script/src/GameObjectNodeProcessor.cpp	2008-09-28 16:10:32 UTC (rev 4528)
@@ -40,7 +40,7 @@
 
         Ogre::String classname = getAttributeValueAsStdString(nodeElem, "class");
 
-        unsigned int goid = GameObject::NO_OBJECT_ID;
+        CeGuiString goid = GameObject::NO_OBJECT_ID;
 
         if (hasAttribute(nodeElem, "id"))
         {

Modified: rl/branches/persistence/script/src/Scene.cpp
===================================================================
--- rl/branches/persistence/script/src/Scene.cpp	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/script/src/Scene.cpp	2008-09-28 16:10:32 UTC (rev 4528)
@@ -102,7 +102,7 @@
                 PropertyRecord cur(it->toMap());
                 GameObject* go = GameObjectManager::getSingleton().createGameObject(
                     cur.getProperty(GameObject::PROPERTY_CLASS_ID).toString(),
-                    cur.getProperty(GameObject::PROPERTY_OBJECT_ID).toInt());
+					cur.getProperty(GameObject::PROPERTY_OBJECT_ID).toString());
             }
         }
         else

Modified: rl/branches/persistence/script/swig/RlCore.head.swig
===================================================================
--- rl/branches/persistence/script/swig/RlCore.head.swig	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/script/swig/RlCore.head.swig	2008-09-28 16:10:32 UTC (rev 4528)
@@ -69,6 +69,8 @@
 #include "LinearSoundFadeFunctor.h"
 #include "PolynomicSoundFadeFunctor.h"
 #include "TimeSource.h"
+#include "SaveAble.h"
+#include "SaveAbleManager.h"
 
 #undef message
 #undef send

Modified: rl/branches/persistence/script/swig/RlCore.swig
===================================================================
--- rl/branches/persistence/script/swig/RlCore.swig	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/script/swig/RlCore.swig	2008-09-28 16:10:32 UTC (rev 4528)
@@ -456,14 +456,14 @@
 	rl::Sound* getSound();
 };
 
-class SoundStitchingObject : public rl::ActorControlledObject
-{
-public:
-    /// Konstruktor
-    SoundStitchingObject(rl::SoundStitching *stitching, const Ogre::String &name);
-    /// Destruktor
-    virtual ~SoundStitchingObject();
-      
+class SoundStitchingObject : public rl::ActorControlledObject
+{
+public:
+    /// Konstruktor
+    SoundStitchingObject(rl::SoundStitching *stitching, const Ogre::String &name);
+    /// Destruktor
+    virtual ~SoundStitchingObject();
+      
     /**
      * Interne Methode. Wird vom Aktor aufgerufen, wenn sich dessen
      * Status gendert hat. (Position, Orientierung, etc)
@@ -478,59 +478,59 @@
     
     
     virtual Ogre::String getObjectType() const;
-
-    // Wollen wir 3D?
-    bool is3d() const;
-    // Setzen des 3D-Flags.
-    void set3d(bool is3d);
-
-    // Sollen der Sound wiederholt werden?
-    bool isLooping() const;
-    // Setzen des Loop-Flags.
-    void setLooping(bool looping);
-    float getLength() const;
-    /// Pausiert den Sound.
+
+    // Wollen wir 3D?
+    bool is3d() const;
+    // Setzen des 3D-Flags.
+    void set3d(bool is3d);
+
+    // Sollen der Sound wiederholt werden?
+    bool isLooping() const;
+    // Setzen des Loop-Flags.
+    void setLooping(bool looping);
+    float getLength() const;
+    /// Pausiert den Sound.
     void pause();
     /// Pausiert den Sound.
-    void pause(bool pausing);
-    /// Ist der Sound pausiert?
-    bool isPaused();
-    /// Stoppt den Sound.
-    virtual void stop();
-    /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
-    const Ogre::Real getVolume() const; 
-    /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
-    void setVolume(const Ogre::Real gain);
-    // Sets the priority of this sound
-    void setPriority(const int priority);
-    // Gets the priority of this sound
-    const int getPriority() const;
+    void pause(bool pausing);
+    /// Ist der Sound pausiert?
+    bool isPaused();
+    /// Stoppt den Sound.
+    virtual void stop();
+    /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
+    const Ogre::Real getVolume() const; 
+    /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
+    void setVolume(const Ogre::Real gain);
+    // Sets the priority of this sound
+    void setPriority(const int priority);
+    // Gets the priority of this sound
+    const int getPriority() const;
 	/// L?dt den Ton
 	void load();
     /// Entl?dt den Sound.
     void unload();
     /// Aktivieren
     virtual void setActive(bool active);
-
-    /// Start sound sequence
-    void start();
-    /// Spielt den Sound ab.
-    virtual void play(bool destroyWhenDone=false);
-    /// Laeuft der Sound noch
-    virtual const bool isPlaying() const = 0;
-	virtual bool isMeshObject() const;
-
-    /// Count of configured slots.
-    unsigned int getNumSlots();
-    /// Add a sound resource to the cache overwritting existing sound resource.
-    virtual void addSoundToCache(rl::CeGuiString label, rl::SoundResourcePtr sound);
-    /// Assign a sound recource to a slot.
-    virtual void putSoundIntoSlot(unsigned int, rl::CeGuiString label) = 0;
-    /// Get the slot of the plaing sound.
-    virtual unsigned int getPlayingSlot() = 0;
-}; 
-
 
+    /// Start sound sequence
+    void start();
+    /// Spielt den Sound ab.
+    virtual void play(bool destroyWhenDone=false);
+    /// Laeuft der Sound noch
+    virtual const bool isPlaying() const = 0;
+	virtual bool isMeshObject() const;
+
+    /// Count of configured slots.
+    unsigned int getNumSlots();
+    /// Add a sound resource to the cache overwritting existing sound resource.
+    virtual void addSoundToCache(rl::CeGuiString label, rl::SoundResourcePtr sound);
+    /// Assign a sound recource to a slot.
+    virtual void putSoundIntoSlot(unsigned int, rl::CeGuiString label) = 0;
+    /// Get the slot of the plaing sound.
+    virtual unsigned int getPlayingSlot() = 0;
+}; 
+
+
 class ParticleSystemObject : public rl::ActorControlledObject
 {
 public:
@@ -788,6 +788,24 @@
     void setPaused(bool paused);
 };
 
+%feature("director") SaveAble;
+class rl::SaveAble
+{
+public:
+	SaveAble(const rl::CeGuiString &id, bool isSaveAble = true);
+	~SaveAble();
+	void setSaveAble(bool enable);
+	bool isSaveAble();
+
+	const rl::Property getProperty(const rl::CeGuiString& key) const;
+    void setProperty(const rl::CeGuiString& key, const rl::Property& value);
+    rl::PropertyKeys getAllPropertyKeys() const;
+	
+	rl::SaveAblePtr getParent() const;
+
+	rl::CeGuiString getId() const;
+};
+
 class Sound 
 {
 private:

Modified: rl/branches/persistence/script/swig/RlRules.swig
===================================================================
--- rl/branches/persistence/script/swig/RlRules.swig	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/script/swig/RlRules.swig	2008-09-28 16:10:32 UTC (rev 4528)
@@ -108,14 +108,14 @@
       
         static DsaManager& getSingleton();
         rl::Talent* getTalent(const rl::CeGuiString name) const;
-        rl::Creature* getCreature(const int id) const;
+        rl::Creature* getCreature(const rl::CeGuiString &id) const;
     };
     
     %feature("director") GameObjectFactory; 
     class GameObjectFactory
     {
     public:
-        virtual rl::GameObject* createRubyGameObject(const Ogre::String& classname, unsigned int id) = 0;
+        virtual rl::GameObject* createRubyGameObject(const Ogre::String& classname, const rl::CeGuiString &id) = 0;
         GameObjectFactory();
         virtual ~GameObjectFactory();
     };
@@ -124,8 +124,8 @@
     {
     public:
         static rl::GameObjectManager& getSingleton();
-        rl::GameObject* createGameObject(const Ogre::String& classId, unsigned int id = 0);
-        rl::GameObject* getGameObject(unsigned int id) const;
+        rl::GameObject* createGameObject(const Ogre::String& classId, const rl::CeGuiString &id = "");
+        rl::GameObject* getGameObject(const rl::CeGuiString id) const;
         void setGameObjectFactory(rl::GameObjectFactory* gof);
 
     private:
@@ -367,14 +367,12 @@
     %constant unsigned long QUERYFLAG_PLAYER = rl::QUERYFLAG_PLAYER;
     
     %feature("director") GameObject;
-    class GameObject: public ObjectStateChangeEventSource
+    class GameObject: public ObjectStateChangeEventSource, public SaveAble
     {
     public:
-        GameObject(unsigned int id);
+        GameObject(const rl::CeGuiString &id);
         virtual ~GameObject();
 
-        virtual unsigned int getId();
-
         virtual const rl::CeGuiString getName() const;
         virtual void setName(rl::CeGuiString name);
 
@@ -479,7 +477,7 @@
             ITEMTYPE_ALL_ITEMS  = ~(0)
         };
     
-        Item(unsigned int id);
+        Item(const rl::CeGuiString &id);
         virtual ~Item();
         
         virtual void placeIntoScene();
@@ -513,7 +511,7 @@
     public:
         enum Distanzklasse { DK_H=0, DK_N, DK_S, DK_P };
 
-        Weapon(unsigned int id);
+        Weapon(const rl::CeGuiString &id);
         virtual ~Weapon();
                 
         void setTp(int d6, int d20, int mod);
@@ -547,7 +545,7 @@
         static const CeGuiString Armor::PROPERTY_G_BE = "g_be";
         static const CeGuiString Armor::PROPERTY_G_RS = "g_rs";
         
-        Armor(unsigned int id);
+        Armor(const rl::CeGuiString &id);
         virtual ~Armor();
 
         virtual const rl::Property getProperty(const rl::CeGuiString& key) const;
@@ -562,7 +560,7 @@
     class Container : public Item
     {
     public:
-        Container(unsigned int id);
+        Container(const rl::CeGuiString &id);
         virtual ~Container();
 
         Ogre::Real getCapacity() const;
@@ -729,7 +727,7 @@
         static const Creature::Wert Creature::WERT_REGENERATION = "Regeneration";
         
         
-        Creature(unsigned int id);
+        Creature(const rl::CeGuiString &id);
         virtual ~Creature();
 
         virtual int getLe();

Modified: rl/branches/persistence/script/swig/RlScript.swig
===================================================================
--- rl/branches/persistence/script/swig/RlScript.swig	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/script/swig/RlScript.swig	2008-09-28 16:10:32 UTC (rev 4528)
@@ -64,7 +64,7 @@
 
 		virtual rl::Trigger* createTrigger(const Ogre::String& classname, const Ogre::String& triggername) = 0;
         virtual rl::Effect* createEffect(const Ogre::String& name, int stufe) = 0;
-        virtual rl::GameObject* createRubyGameObject(const Ogre::String& classname, unsigned int id) = 0;
+        virtual rl::GameObject* createRubyGameObject(const Ogre::String& classname, const rl::CeGuiString &id) = 0;
         virtual rl::SteeringBehaviour* createBehaviour(const Ogre::String& classname) = 0;
     };
 

Modified: rl/branches/persistence/ui/include/ControlState.h
===================================================================
--- rl/branches/persistence/ui/include/ControlState.h	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/ui/include/ControlState.h	2008-09-28 16:10:32 UTC (rev 4528)
@@ -77,7 +77,7 @@
         bool isMouseUsedByCegui() const;
 
         Creature* mCharacter;
-        int mCharacterId;
+        CeGuiString mCharacterId;
 
         Actor* mCameraActor;
         Actor* mCharacterActor;

Modified: rl/branches/persistence/ui/include/UiSubsystem.h
===================================================================
--- rl/branches/persistence/ui/include/UiSubsystem.h	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/ui/include/UiSubsystem.h	2008-09-28 16:10:32 UTC (rev 4528)
@@ -58,7 +58,7 @@
 
     private:
         Creature* mCharacter;
-        int mCharacterId;
+        CeGuiString mCharacterId;
 
 	    MessagePump::ScopedConnection mSceneClearingConnection;
         MessagePump::ScopedConnection mGameObjectsLoadedConnection;

Modified: rl/branches/persistence/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/branches/persistence/ui/src/ContainerContentWindow.cpp	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/ui/src/ContainerContentWindow.cpp	2008-09-28 16:10:32 UTC (rev 4528)
@@ -209,7 +209,7 @@
 
 		CeGuiString dragContainerName =
 			mWindow->getName() +  "/item/"
-			+ Ogre::StringConverter::toString(item->getId())+"_DragContainer";
+			+ item->getId()+"_DragContainer";
 
 		itemhandler = new ItemIconDragContainer(item,
 			dragContainerName);

Modified: rl/branches/persistence/ui/src/InventoryWindow.cpp
===================================================================
--- rl/branches/persistence/ui/src/InventoryWindow.cpp	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/ui/src/InventoryWindow.cpp	2008-09-28 16:10:32 UTC (rev 4528)
@@ -194,7 +194,7 @@
     {
 		CeGuiString dragContainerName =
 			mWindow->getName() +  "/item/"
-			+ Ogre::StringConverter::toString(item->getId())+"_DragContainer"+
+			+ item->getId()+"_DragContainer"+
 			(description?"_D":"_I");
         return dragContainerName;
     }

Modified: rl/branches/persistence/ui/src/UiSubsystem.cpp
===================================================================
--- rl/branches/persistence/ui/src/UiSubsystem.cpp	2008-09-28 16:08:40 UTC (rev 4527)
+++ rl/branches/persistence/ui/src/UiSubsystem.cpp	2008-09-28 16:10:32 UTC (rev 4528)
@@ -203,7 +203,7 @@
 
     bool UiSubsystem::onGameObjectsLoaded()
     {
-        if (mCharacterId != -1)
+        if (mCharacterId != "")
         {
             Creature* character = static_cast<Creature*>(GameObjectManager::getSingleton().getGameObject(mCharacterId));
 



From blakharaz at mail.berlios.de  Sun Sep 28 22:56:10 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 28 Sep 2008 22:56:10 +0200
Subject: [Dsa-hl-svn] r4529 - in rl/trunk/engine/rules: include src
Message-ID: <200809282056.m8SKuAI5006013@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-28 22:56:08 +0200 (Sun, 28 Sep 2008)
New Revision: 4529

Modified:
   rl/trunk/engine/rules/include/GameObject.h
   rl/trunk/engine/rules/include/GoToJob.h
   rl/trunk/engine/rules/src/GameObject.cpp
   rl/trunk/engine/rules/src/GoToJob.cpp
Log:
Added hasAction() method; cleanup

Modified: rl/trunk/engine/rules/include/GameObject.h
===================================================================
--- rl/trunk/engine/rules/include/GameObject.h	2008-09-28 16:10:32 UTC (rev 4528)
+++ rl/trunk/engine/rules/include/GameObject.h	2008-09-28 20:56:08 UTC (rev 4529)
@@ -1,240 +1,249 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __GAMEOBJECT_H__
-#define __GAMEOBJECT_H__
-
-#include "RulesPrerequisites.h"
-
-#include "Action.h"
-#include "Actor.h"
-#include "RulesConstants.h"
-#include "ObjectStateChangeEventSource.h"
-#include "Properties.h"
-#include "CoreDefines.h"
-
-namespace rl
-{
-    class Creature;
-    class Effect;
-    class EffectManager;
-
-    /**
-    * \brief Base class for all game relevant objects in RL
-    * Provides methods for identification of objects within the world
-    * Abstract concepts do not inherit this class
-    */
-    class _RlRulesExport GameObject 
-        : public ActorNotifiedObject, 
-          public ObjectStateChangeEventSource,
-          public PropertyHolder
-    {
-    public:
-        typedef std::vector<std::pair<Action*, int> > ActionOptionVector;
-        static const unsigned int NO_OBJECT_ID = 0;
-        
-        static const Ogre::String CLASS_NAME;
-
-        static const Ogre::String PROPERTY_CLASS_ID;
-        static const Ogre::String PROPERTY_OBJECT_ID;
-        static const Ogre::String PROPERTY_INHERITS;
-        static const Ogre::String PROPERTY_BASE_CLASS;
-        static const Ogre::String PROPERTY_SCENE; 
-        static const Ogre::String PROPERTY_POSITION; 
-        static const Ogre::String PROPERTY_ORIENTATION; 
-        static const Ogre::String PROPERTY_NAME;
-        static const Ogre::String PROPERTY_DESCRIPTION; 
-        static const Ogre::String PROPERTY_MESHFILE; 
-  		static const Ogre::String PROPERTY_MESHPARTS;
-        static const Ogre::String PROPERTY_SUBMESHPRENAME;
-		static const Ogre::String PROPERTY_GEOMETRY_TYPE; 
-        static const Ogre::String PROPERTY_MASS; 
-        static const Ogre::String PROPERTY_ACTIONS; 
-        static const Ogre::String PROPERTY_DEFAULT_ACTION;
-
-        static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
-        static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
-
-        GameObject(unsigned int id);
-        virtual ~GameObject();
-
-        int getId() const;
-
-        const CeGuiString& getClassId() const;
-        void setClassId(const CeGuiString& classId);
-        
-        const CeGuiString& getName() const;
-        void setName(const CeGuiString& name);
-
-        const CeGuiString& getDescription() const;
-        void setDescription(const CeGuiString& description);
-
-        const CeGuiString& getMeshfile() const;
-        void setMeshfile(const CeGuiString& meshfile);
-
-        const CeGuiString& getSubmeshPreName() const;
-        void setSubmeshPreName(const CeGuiString& name);
-
-		const MeshPartMap& getMeshParts() const;
-
-        const GeometryType getGeometryType() const;
-        void setGeometryType(GeometryType type);
-
-        const Ogre::Real getMass() const;
-        void setMass(const Ogre::Real mass);
-
-        void addAction(Action* action, int option = Action::ACT_NORMAL);
-        void addActionInGroup(Action* action, ActionGroup* group, int option = Action::ACT_NORMAL);
-        void removeAction(Action* action);
-
-        void setScene(const CeGuiString& scene);
-        const CeGuiString& getScene() const;
-    
-        /*
-         * sets the actor of this gameobject
-         * @warning if the GameObject is destroyed or the State of the GameObject changed or this function
-         * is called with another actor, the actor will be deleted!
-         */
-        void setActor(Actor* actor);
-        Actor* getActor();
-
-        /**
-         * Get all valid actions a character can perfom on this game object
-         * 
-         * @param actor the character
-         * @return a vector of actions
-         */
-        const ActionVector getValidActions(Creature* actor) const;
-        virtual Action* getDefaultAction(Creature* actor) const;
-
-        /** Trigger an action of this game object
-         *  @param actionName the action's name
-         *  @param actor the "user" of this game object, can be <code>NULL</code> sein, 
-                   if the action wasn't triggered by someone (e.g. by time)
-         *  @param target the action's target (can be <code>NULL</code> if no other game objects are involved)
-         */
-        void doAction(const CeGuiString actionName,
-                      Creature* actor,
-                      GameObject* target);
-
-        void doAction(const CeGuiString actionName);
-
-        void doAction(Action* action,
-                      Creature* actor,
-                      GameObject* target);
-                      
-        bool activateAction(Action* action,
-                      Creature* actor,
-                      GameObject* target);
-
-        void doDefaultAction(Creature* actor, GameObject* target);
-
-        void setPosition(const Ogre::Vector3& position);
-        void setOrientation(const Ogre::Quaternion& orientation);
-        const Ogre::Quaternion& getOrientation() const;
-        const Ogre::Vector3& getPosition() const;
-        Ogre::AxisAlignedBox getWorldBoundingBox() const;
-
-        /// Soll der Aktor ?berhaupt leuchten?
-        bool isHighlightingEnabled();
-        void setHighlightingEnabled( bool highlightenabled );
-
-        void setHighlighted(bool highlight);
-        bool isHighlighted() const;
-
-        virtual const Property getProperty(const CeGuiString& key) const;
-        virtual void setProperty(const CeGuiString& key, const Property& value);
-        virtual PropertyKeys getAllPropertyKeys() const;
-
-        GameObjectState getState() const;
-        virtual void setState(GameObjectState state);
-        void placeIntoScene();
-        void removeFromScene();
-
-        unsigned long getQueryFlags() const;
-        void addQueryFlag(unsigned long queryflag);
-        void setQueryFlags(unsigned long queryflags);
-
-        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
-        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
-
-        /**
-         * Lets an effect affect the game object
-         * @param effect the effect
-         * @ingroup CreatureRubyExports
-         **/
-        void addEffect(Effect* effect);
-        void addEffectWithCheckTime(Effect* effect, RL_LONGLONG time);
-        void addEffectWithCheckDate(Effect* effect, RL_LONGLONG date);
-        void removeEffect(Effect* effect);
-
-        /**
-         * Returns a printable list of all effects
-         */
-        CeGuiString getEffects();
-
-        /**
-         * Checks all effects for end-of-life
-         **/
-        void _checkEffects();
-
-    protected:
-        int mId;
-        GameObjectState mState;
-        
-        CeGuiString mName;
-        CeGuiString mDescription;
-        CeGuiString mMeshfile;
-		MeshPartMap mMeshParts;
-        CeGuiString mSubmeshPreName;
-        CeGuiString mClassId;
-        
-        Actor* mActor;
-        
-        /// Query flags to be set to the actor, when placed into scene.
-        unsigned long mQueryFlags;
-
-        /// Shall the game object be selectable
-        bool mHighlightingEnabled;
-
-        /// Manages the effects affecting this game object
-        EffectManager* mEffectManager;
-
-        Actor* createActor();
-        void destroyActor();
-
-        virtual void doPlaceIntoScene();
-        virtual void doRemoveFromScene();
-        CeGuiString mScene;
-
-    private:
-        static int sNextGameObjectId;    
-
-        ActionOptionVector mActions;
-        Ogre::Vector3 mPosition;
-        Ogre::Quaternion mOrientation;
-        Ogre::Real mMass;
-        CeGuiString mDefaultAction;
-        GeometryType mGeometryType;
-
-        ActionOptionVector::iterator findAction(ActionOptionVector::iterator begin,
-            ActionOptionVector::iterator end, const CeGuiString actionName);
-        ActionOptionVector::iterator findAction(ActionOptionVector::iterator
-            begin, ActionOptionVector::iterator end, const Action* action);    
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __GAMEOBJECT_H__
+#define __GAMEOBJECT_H__
+
+#include "RulesPrerequisites.h"
+
+#include "Action.h"
+#include "Actor.h"
+#include "RulesConstants.h"
+#include "ObjectStateChangeEventSource.h"
+#include "Properties.h"
+#include "CoreDefines.h"
+
+namespace rl
+{
+    class Creature;
+    class Effect;
+    class EffectManager;
+
+    /**
+    * \brief Base class for all game relevant objects in RL
+    * Provides methods for identification of objects within the world
+    * Abstract concepts do not inherit this class
+    */
+    class _RlRulesExport GameObject 
+        : public ActorNotifiedObject, 
+          public ObjectStateChangeEventSource,
+          public PropertyHolder
+    {
+    public:
+        typedef std::vector<std::pair<Action*, int> > ActionOptionVector;
+        static const unsigned int NO_OBJECT_ID = 0;
+        
+        static const Ogre::String CLASS_NAME;
+
+        static const Ogre::String PROPERTY_CLASS_ID;
+        static const Ogre::String PROPERTY_OBJECT_ID;
+        static const Ogre::String PROPERTY_INHERITS;
+        static const Ogre::String PROPERTY_BASE_CLASS;
+        static const Ogre::String PROPERTY_SCENE; 
+        static const Ogre::String PROPERTY_POSITION; 
+        static const Ogre::String PROPERTY_ORIENTATION; 
+        static const Ogre::String PROPERTY_NAME;
+        static const Ogre::String PROPERTY_DESCRIPTION; 
+        static const Ogre::String PROPERTY_MESHFILE; 
+  		static const Ogre::String PROPERTY_MESHPARTS;
+        static const Ogre::String PROPERTY_SUBMESHPRENAME;
+		static const Ogre::String PROPERTY_GEOMETRY_TYPE; 
+        static const Ogre::String PROPERTY_MASS; 
+        static const Ogre::String PROPERTY_ACTIONS; 
+        static const Ogre::String PROPERTY_DEFAULT_ACTION;
+
+        static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
+        static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
+
+        GameObject(unsigned int id);
+        virtual ~GameObject();
+
+        int getId() const;
+
+        const CeGuiString& getClassId() const;
+        void setClassId(const CeGuiString& classId);
+        
+        const CeGuiString& getName() const;
+        void setName(const CeGuiString& name);
+
+        const CeGuiString& getDescription() const;
+        void setDescription(const CeGuiString& description);
+
+        const CeGuiString& getMeshfile() const;
+        void setMeshfile(const CeGuiString& meshfile);
+
+        const CeGuiString& getSubmeshPreName() const;
+        void setSubmeshPreName(const CeGuiString& name);
+
+		const MeshPartMap& getMeshParts() const;
+
+        const GeometryType getGeometryType() const;
+        void setGeometryType(GeometryType type);
+
+        const Ogre::Real getMass() const;
+        void setMass(const Ogre::Real mass);
+
+        void addAction(Action* action, int option = Action::ACT_NORMAL);
+        void addActionInGroup(Action* action, ActionGroup* group, int option = Action::ACT_NORMAL);
+        void removeAction(Action* action);
+
+        void setScene(const CeGuiString& scene);
+        const CeGuiString& getScene() const;
+    
+        /*
+         * sets the actor of this gameobject
+         * @warning if the GameObject is destroyed or the State of the GameObject changed or this function
+         * is called with another actor, the actor will be deleted!
+         */
+        void setActor(Actor* actor);
+        Actor* getActor();
+        
+        /**
+         * Check whether a creature can perform an action on this game object
+         *
+         * @return a boolean
+         */
+        bool hasAction(const CeGuiString& actionName, Creature* actor) const;
+
+        /**
+         * Get all valid actions a character can perfom on this game object
+         * 
+         * @param actor the character
+         * @return a vector of actions
+         */
+        const ActionVector getValidActions(Creature* actor) const;
+        virtual Action* getDefaultAction(Creature* actor) const;
+
+        /** Trigger an action of this game object
+         *  @param actionName the action's name
+         *  @param actor the "user" of this game object, can be <code>NULL</code> sein, 
+                   if the action wasn't triggered by someone (e.g. by time)
+         *  @param target the action's target (can be <code>NULL</code> if no other game objects are involved)
+         */
+        void doAction(const CeGuiString& actionName,
+                      Creature* actor,
+                      GameObject* target);
+
+        void doAction(const CeGuiString& actionName);
+
+        void doAction(Action* action,
+                      Creature* actor,
+                      GameObject* target);
+                      
+        bool activateAction(Action* action,
+                      Creature* actor,
+                      GameObject* target);
+
+        void doDefaultAction(Creature* actor, GameObject* target);
+
+        void setPosition(const Ogre::Vector3& position);
+        void setOrientation(const Ogre::Quaternion& orientation);
+        const Ogre::Quaternion& getOrientation() const;
+        const Ogre::Vector3& getPosition() const;
+        Ogre::AxisAlignedBox getWorldBoundingBox() const;
+
+        /// Soll der Aktor ??berhaupt leuchten?
+        bool isHighlightingEnabled();
+        void setHighlightingEnabled( bool highlightenabled );
+
+        void setHighlighted(bool highlight);
+        bool isHighlighted() const;
+
+        virtual const Property getProperty(const CeGuiString& key) const;
+        virtual void setProperty(const CeGuiString& key, const Property& value);
+        virtual PropertyKeys getAllPropertyKeys() const;
+
+        GameObjectState getState() const;
+        virtual void setState(GameObjectState state);
+        void placeIntoScene();
+        void removeFromScene();
+
+        unsigned long getQueryFlags() const;
+        void addQueryFlag(unsigned long queryflag);
+        void setQueryFlags(unsigned long queryflags);
+
+        virtual void onBeforeStateChange(GameObjectState oldState, GameObjectState newState);
+        virtual void onAfterStateChange(GameObjectState oldState, GameObjectState newState);
+
+        /**
+         * Lets an effect affect the game object
+         * @param effect the effect
+         * @ingroup CreatureRubyExports
+         **/
+        void addEffect(Effect* effect);
+        void addEffectWithCheckTime(Effect* effect, RL_LONGLONG time);
+        void addEffectWithCheckDate(Effect* effect, RL_LONGLONG date);
+        void removeEffect(Effect* effect);
+
+        /**
+         * Returns a printable list of all effects
+         */
+        CeGuiString getEffects();
+
+        /**
+         * Checks all effects for end-of-life
+         **/
+        void _checkEffects();
+
+    protected:
+        int mId;
+        GameObjectState mState;
+        
+        CeGuiString mName;
+        CeGuiString mDescription;
+        CeGuiString mMeshfile;
+		MeshPartMap mMeshParts;
+        CeGuiString mSubmeshPreName;
+        CeGuiString mClassId;
+        
+        Actor* mActor;
+        
+        /// Query flags to be set to the actor, when placed into scene.
+        unsigned long mQueryFlags;
+
+        /// Shall the game object be selectable
+        bool mHighlightingEnabled;
+
+        /// Manages the effects affecting this game object
+        EffectManager* mEffectManager;
+
+        Actor* createActor();
+        void destroyActor();
+
+        virtual void doPlaceIntoScene();
+        virtual void doRemoveFromScene();
+        CeGuiString mScene;
+
+    private:
+        static int sNextGameObjectId;    
+
+        ActionOptionVector mActions;
+        Ogre::Vector3 mPosition;
+        Ogre::Quaternion mOrientation;
+        Ogre::Real mMass;
+        CeGuiString mDefaultAction;
+        GeometryType mGeometryType;
+
+        ActionOptionVector::iterator findAction(ActionOptionVector::iterator begin,
+            ActionOptionVector::iterator end, const CeGuiString actionName);
+        ActionOptionVector::const_iterator findAction(ActionOptionVector::const_iterator begin,
+            ActionOptionVector::const_iterator end, const CeGuiString actionName) const;
+        ActionOptionVector::iterator findAction(ActionOptionVector::iterator
+            begin, ActionOptionVector::iterator end, const Action* action);    
+    };
+}
+
+#endif

Modified: rl/trunk/engine/rules/include/GoToJob.h
===================================================================
--- rl/trunk/engine/rules/include/GoToJob.h	2008-09-28 16:10:32 UTC (rev 4528)
+++ rl/trunk/engine/rules/include/GoToJob.h	2008-09-28 20:56:08 UTC (rev 4529)
@@ -1,50 +1,50 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __RL_GOTO_JOB_H__
-#define __RL_GOTO_JOB_H__
-
-#include "RulesPrerequisites.h"
-#include "Creature.h"
-#include "CreatureController.h"
-#include "Job.h"
-
-namespace rl
-{
-    class MeshAnimation;
-
-    /// A rl#Job to play an animation.
-    class _RlRulesExport GoToJob : public Job
-    {
-    public:
-
-		GoToJob(Creature* actor, const Ogre::Vector3& targetPos,
-			Ogre::Real maxDistance, Ogre::Real duration);
-		GoToJob(Creature* actor, GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
-        virtual ~GoToJob();
-
-        virtual bool execute(Ogre::Real time);
-
-    private:
-		CreatureController* mActor;
-		GameObject* mTarget;
-		Ogre::Vector3 mTargetPos;
-		Ogre::Real mMaxDistance;
-		Ogre::Real mTimeLeft;
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __RL_GOTO_JOB_H__
+#define __RL_GOTO_JOB_H__
+
+#include "RulesPrerequisites.h"
+#include "Job.h"
+
+namespace rl
+{
+    class Creature;
+    class CreatureController;
+    class GameObject;
+    
+    /// A rl#Job to let a creature go to a target position
+    class _RlRulesExport GoToJob : public Job
+    {
+    public:
+
+		GoToJob(Creature* actor, const Ogre::Vector3& targetPos,
+			Ogre::Real maxDistance, Ogre::Real duration);
+		GoToJob(Creature* actor, GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
+        virtual ~GoToJob();
+
+        virtual bool execute(Ogre::Real time);
+
+    private:
+		CreatureController* mActor;
+		GameObject* mTarget;
+		Ogre::Vector3 mTargetPos;
+		Ogre::Real mMaxDistance;
+		Ogre::Real mTimeLeft;
+    };
+}
+
+#endif

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2008-09-28 16:10:32 UTC (rev 4528)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2008-09-28 20:56:08 UTC (rev 4529)
@@ -1,835 +1,880 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "GameObject.h"
-#include <CEGUIPropertyHelper.h>
-
-#include "Action.h"
-#include "ActionManager.h"
-#include "Actor.h"
-#include "ActorManager.h"
-#include "EffectManager.h"
-#include "Exception.h"
-#include "ObjectStateChangeEventSource.h"
-#include "Property.h"
-#include "RulesSubsystem.h"
-#include "GameObjectManager.h"
-#include "CoreSubsystem.h"
-#include "PhysicsManager.h"
-
-
-using namespace std;
-
-namespace rl
-{
-    const CeGuiString GameObject::DEFAULT_VIEW_OBJECT_ACTION = "viewobject";
-    const CeGuiString GameObject::DEFAULT_VIEW_OBJECT_ACTION_DEBUG = "viewobjectdebug";
-
-    const Ogre::String GameObject::CLASS_NAME = "GameObject";
-
-    const Ogre::String GameObject::PROPERTY_CLASS_ID = "classid";
-    const Ogre::String GameObject::PROPERTY_OBJECT_ID = "id";
-    const Ogre::String GameObject::PROPERTY_BASE_CLASS = "baseclass";
-    const Ogre::String GameObject::PROPERTY_POSITION = "position";
-    const Ogre::String GameObject::PROPERTY_SCENE = "scene";
-    const Ogre::String GameObject::PROPERTY_INHERITS = "inherits";
-    const Ogre::String GameObject::PROPERTY_ORIENTATION = "orientation";
-    const Ogre::String GameObject::PROPERTY_NAME = "name";
-    const Ogre::String GameObject::PROPERTY_DESCRIPTION = "description";
-    const Ogre::String GameObject::PROPERTY_MESHFILE = "meshfile";
-	const Ogre::String GameObject::PROPERTY_MESHPARTS = "meshparts";
-    const Ogre::String GameObject::PROPERTY_SUBMESHPRENAME = "submeshprename";
-    const Ogre::String GameObject::PROPERTY_GEOMETRY_TYPE = "geometrytype";
-    const Ogre::String GameObject::PROPERTY_MASS = "mass";
-    const Ogre::String GameObject::PROPERTY_ACTIONS = "actions";
-    const Ogre::String GameObject::PROPERTY_DEFAULT_ACTION = "defaultaction";
-
-    GameObject::GameObject(unsigned int id)
-        :   mId(id),
-            mName(""),
-            mDescription(""),
-            mMeshfile(""),
-			mMeshParts(),
-            mQueryFlags(QUERYFLAG_GAMEOBJECT),
-            mHighlightingEnabled(true),
-            mActor(NULL),
-            mActions(),
-            mPosition(Ogre::Vector3::ZERO),
-            mOrientation(Ogre::Quaternion::IDENTITY),
-            mMass(0),
-            mGeometryType(GT_NONE),
-            mDefaultAction(DEFAULT_VIEW_OBJECT_ACTION),
-            mState(GOS_LOADED),
-            mScene("")
-    {
-        mEffectManager = new EffectManager(this);
-
-        // Standardactions registrieren
-        Action* defaultAction = ActionManager::getSingleton().getAction(DEFAULT_VIEW_OBJECT_ACTION);
-        if (defaultAction != NULL)
-        {
-            addAction(defaultAction);
-        }
-
-        // If game in developer mode, show GameObject debug window
-        // in the radial menu
-        //if( CoreSubsystem::getSingleton().getDeveloperMode() )
-        //{
-            defaultAction = ActionManager::getSingleton().getAction(DEFAULT_VIEW_OBJECT_ACTION_DEBUG);
-            if (defaultAction != NULL)
-            {
-                addAction(defaultAction);
-            }
-        //}
-
-        // Eventsource erzeugen
-        setObject(this);
-    }
-
-    GameObject::~GameObject(void)
-    {
-        destroyActor();
-    	delete mEffectManager;
-    }
-
-    int GameObject::getId() const
-    {
-        return mId;
-    }
-
-    const CeGuiString& GameObject::getClassId() const
-    {
-        return mClassId;
-    }
-
-    void GameObject::setClassId(const CeGuiString& classId)
-    {
-        mClassId = classId;
-    }
-
-    const CeGuiString& GameObject::getName() const
-    {
-        return mName;
-    }
-
-    void GameObject::setName(const CeGuiString& name)
-    {
-        mName = name;
-    }
-
-    const CeGuiString& GameObject::getDescription() const
-    {
-        return mDescription;
-    }
-
-    void GameObject::setDescription(const CeGuiString& description)
-    {
-        mDescription = description;
-    }
-
-    const CeGuiString& GameObject::getMeshfile() const
-    {
-        return mMeshfile;
-    }
-
-    void GameObject::setMeshfile(const CeGuiString& meshfile)
-    {
-        mMeshfile = meshfile;
-    }
-
-	const MeshPartMap& GameObject::getMeshParts() const
-	{
-		return mMeshParts;
-	}
-
-    const CeGuiString& GameObject::getSubmeshPreName() const
-    {
-        return mSubmeshPreName;
-    }
-
-    void GameObject::setSubmeshPreName(const CeGuiString& name)
-    {
-        mSubmeshPreName = name;
-    }
-
-    const CeGuiString& GameObject::getScene() const
-    {
-        return mScene;
-    }
-
-    void GameObject::setScene(const CeGuiString& scene)
-    {
-        mScene = scene;
-    }
-
-    void GameObject::addAction(Action* action, int option)
-    {
-        if (action == NULL)
-        {
-            Throw(NullPointerException, "Parameter action ist NULL.");
-        }
-
-        mActions.push_back(make_pair(action, option));
-        LOG_MESSAGE(Logger::RULES,
-            "Bei GameObject #"+CEGUI::PropertyHelper::intToString(mId)+
-            " ("+getName()+") wurde Aktion "+action->getName().c_str()+" hinzugefuegt.");
-    }
-
-    void GameObject::addActionInGroup(Action* action, ActionGroup* group, int option)
-    {
-        addAction(action, option);
-        action->setGroup(group);
-    }
-
-    void GameObject::removeAction(Action* action)
-    {
-        ActionOptionVector::iterator it = findAction(mActions.begin(), mActions.end(), action);
-        if (it != mActions.end())
-        {
-            mActions.erase(it);
-        }
-    }
-
-    const ActionVector GameObject::getValidActions(Creature* actor) const
-    {
-        ActionVector actions;
-        for (ActionOptionVector::const_iterator it = mActions.begin(); it != mActions.end(); ++it)
-        {
-            LOG_MESSAGE(Logger::RULES, "Untersuche Aktion "+(*it).first->getName());
-            if ((*it).second == Action::ACT_DISABLED)
-                continue;
-            //if ((*it).second > ACT_NEEDS_TALENT)
-            if (actor != NULL && !(*it).first->canDo(const_cast<GameObject*>(this), actor)) // Aktion nicht m???glich
-                continue;
-
-            actions.push_back((*it).first);
-        }
-        return actions;
-    }
-
-    void GameObject::doAction( const CeGuiString actionName,
-                              Creature* actor,
-                              GameObject* target)
-    {
-        ActionOptionVector::const_iterator it =
-            findAction(mActions.begin(), mActions.end(), actionName);
-
-        if (it == mActions.end())
-        {
-            LOG_ERROR(
-                Logger::RULES,
-                "'" + actionName + "' ist eine dem Objekt unbekannte Aktion.");
-        }
-        else
-        {
-            doAction((*it).first, actor, target);
-        }
-    }
-
-    void GameObject::doAction(const CeGuiString actionName)
-    {
-        doAction(actionName, NULL, NULL);
-    }
-
-    void GameObject::doAction(Action* action,
-                              Creature* actor,
-                              GameObject* target)
-    {
-        action->doAction(this, actor, target);
-    }
-
-    void GameObject::doDefaultAction(Creature* actor, GameObject* target)
-    {
-        Action* action = getDefaultAction(actor);
-        if (action != NULL)
-        {
-            doAction(action, actor, target);
-        }
-        else
-        {
-            LOG_ERROR(
-                Logger::RULES,
-                "GameObject " + getName() + " has no valid default action set.");
-        }
-    }
-
-    bool GameObject::activateAction(Action* action,
-                      Creature* actor,
-                      GameObject* target)
-    {
-        doAction(action, actor, target);
-        return true;
-    }
-
-    GameObject::ActionOptionVector::iterator
-        GameObject::findAction(
-            GameObject::ActionOptionVector::iterator begin,
-            GameObject::ActionOptionVector::iterator end,
-            const CeGuiString actionName)
-    {
-        for (ActionOptionVector::iterator iter = begin; iter != end; ++iter)
-        {
-            Action* action = (*iter).first;
-
-            if (action->getName().compare(actionName) == 0)
-                return iter;
-        }
-        return end;
-    }
-
-    GameObject::ActionOptionVector::iterator
-        GameObject::findAction(
-            GameObject::ActionOptionVector::iterator begin,
-            GameObject::ActionOptionVector::iterator end,
-            const Action* action)
-    {
-        for (ActionOptionVector::iterator iter = begin; iter != end; ++iter)
-            if ((*iter).first == action)
-                return iter;
-
-        return end;
-    }
-
-    void GameObject::setActor(Actor* actor)
-    {
-        if (mActor != actor)
-        {
-            if (mActor != NULL)
-            {
-                mActor->setGameObject(NULL);
-                mActor->setQueryFlags(0);
-            }
-
-            if (actor != NULL)
-            {                
-                actor->setGameObject(this);
-                if (actor->isInScene())
-                {
-                    actor->setPosition(mPosition);
-                    actor->setOrientation(mOrientation);                    
-                }
-            }
-
-            mActor = actor;
-        }
-
-        if (mActor && mActor->isInScene())
-        {
-            mActor->setQueryFlags(mQueryFlags);
-        }
-    }
-
-    Actor* GameObject::getActor()
-    {
-        return mActor;
-    }
-
-    bool GameObject::isHighlightingEnabled()
-    {
-        return mHighlightingEnabled;
-    }
-
-    void GameObject::setHighlightingEnabled( bool highlightenabled )
-    {
-        // Leuchtet zur Zeit, sollte aber nicht leuchten
-        if( mActor != NULL && !highlightenabled && mActor->isHighlighted() )
-        {
-            mActor->setHighlighted( false );
-        }
-
-        mHighlightingEnabled = highlightenabled;
-    }
-
-    Action* GameObject::getDefaultAction(Creature* actor) const
-    {
-        return ActionManager::getSingleton().getAction(mDefaultAction);
-    }
-
-    void GameObject::setHighlighted(bool highlight)
-    {
-        if (mHighlightingEnabled && mActor != NULL)
-        {
-            mActor->setHighlighted(highlight, getName());
-        }
-    }
-
-    bool GameObject::isHighlighted() const
-    {
-        return mActor != NULL && mActor->isHighlighted();
-    }
-
-    void GameObject::setPosition(const Ogre::Vector3& position)
-    {
-        if (mActor != NULL)
-        {
-            mActor->setPosition(position);
-        }
-        else
-        {
-            mPosition = position;
-        }
-    }
-
-    const Ogre::Vector3& GameObject::getPosition() const
-    {
-        if (mActor != NULL)
-        {
-            return mActor->getPosition();
-        }
-        return mPosition;
-    }
-
-	Ogre::AxisAlignedBox GameObject::getWorldBoundingBox() const
-	{
-        if (mActor != NULL)
-        {
-            return mActor->getWorldBoundingBox();
-        }
-        return Ogre::AxisAlignedBox();
-	}
-
-    void GameObject::setOrientation(const Ogre::Quaternion& orientation)
-    {
-        if (mActor != NULL)
-        {
-            mActor->setOrientation(orientation);
-        }
-        else
-        {
-            mOrientation = orientation;
-        }
-    }
-
-    const Ogre::Quaternion& GameObject::getOrientation() const
-    {
-        if (mActor != NULL)
-        {
-            return mActor->getOrientation();
-        }
-        return mOrientation;
-    }
-
-    const GeometryType GameObject::getGeometryType() const
-    {
-        return mGeometryType;
-    }
-
-    void GameObject::setGeometryType(GeometryType type)
-    {
-        mGeometryType = type;
-    }
-
-    const Ogre::Real GameObject::getMass() const
-    {
-        return mMass;
-    }
-
-    void GameObject::setMass(const Ogre::Real mass)
-    {
-        mMass = mass;
-    }
-
-    void GameObject::addEffect(Effect* effect)
-	{
-		mEffectManager->addEffect(effect);
-	}
-
-    void GameObject::addEffectWithCheckTime(Effect* effect, RL_LONGLONG time)
-    {
-      addEffect(effect);
-      mEffectManager->addTimeCheck(time, effect);
-    }
-
-    void GameObject::addEffectWithCheckDate(Effect* effect, RL_LONGLONG date)
-    {
-      addEffect(effect);
-      mEffectManager->addDateCheck(date, effect);
-    }
-
-	void GameObject::_checkEffects()
-	{
-		/// @todo Nur einmal pro Aktion ausfuehren
-		mEffectManager->checkEffects();
-	}
-
-    void GameObject::removeEffect(Effect* effect)
-	{
-		mEffectManager->removeEffect(effect);
-	}
-
-    CeGuiString GameObject::getEffects()
-    {
-        return mEffectManager->getEffects();
-    }
-
-    const Property GameObject::getProperty(const CeGuiString& key) const
-    {
-        Property prop;
-        if (key == PROPERTY_POSITION)
-        {
-            prop.setValue(getPosition());
-        }
-        else if (key == PROPERTY_ORIENTATION)
-        {
-            prop.setValue(getOrientation());
-        }
-        else if (key == PROPERTY_NAME)
-        {
-            prop.setValue(mName);
-        }
-        else if (key == PROPERTY_DESCRIPTION)
-        {
-            prop.setValue(mDescription);
-        }
-        else if (key == PROPERTY_MESHFILE)
-        {
-            prop.setValue(mMeshfile);
-        }
-        else if (key == PROPERTY_GEOMETRY_TYPE)
-        {
-            prop.setValue(PhysicsManager::convertGeometryTypeToString(mGeometryType));
-        }
-        else if (key == PROPERTY_MASS)
-        {
-            prop.setValue(mMass);
-        }
-		else if (key == PROPERTY_MESHPARTS)
-		{
-			PropertyMap map;
-			for (MeshPartMap::const_iterator
-					it = mMeshParts.begin(); it != mMeshParts.end(); ++it)
-			{
-				map[(*it).first] = Property((*it).second);
-			}
-			prop.setValue(map);
-		}
-        else if (key == PROPERTY_SUBMESHPRENAME)
-        {
-            prop.setValue(mSubmeshPreName);
-        }
-        else
-        {
-            Throw(IllegalArgumentException, key + " is not a property of this gameobject ("+mName.c_str()+")");
-        }
-
-        return prop;
-    }
-
-    void GameObject::setProperty(const CeGuiString& key, const Property& value)
-    {
-        try
-        {
-            if (key == PROPERTY_POSITION)
-            {
-                setPosition(value.toVector3());
-            }
-            else if (key == PROPERTY_ORIENTATION)
-            {
-                setOrientation(value.toQuaternion());
-            }
-            else if (key == PROPERTY_NAME)
-            {
-                setName(value.toString());
-            }
-            else if (key == PROPERTY_DESCRIPTION)
-            {
-                setDescription(value.toString());
-            }
-            else if (key == PROPERTY_MESHFILE)
-            {
-                setMeshfile(value.toString());
-            }
-            else if (key == PROPERTY_MESHPARTS)
-            {
-				PropertyMap map = value.toMap();
-				for (PropertyMap::const_iterator
-					it = map.begin(); it != map.end(); ++it)
-				{
-					mMeshParts[(*it).first.c_str()] = (*it).second.toString().c_str();
-				}
-            }
-            else if (key == PROPERTY_GEOMETRY_TYPE)
-            {
-                setGeometryType(PhysicsManager::convertStringToGeometryType(value.toString().c_str()));
-            }
-            else if (key == PROPERTY_MASS)
-            {
-                Ogre::Real mass = 0.0;
-                if (value.isInt())
-                {
-                    mass = value.toInt();
-                }
-                else if (value.isReal())
-                {
-                    mass = value.toReal();
-                }
-                setMass(mass);
-            }
-            else if (key == PROPERTY_ACTIONS)
-            {
-                PropertyArray vecVal = value.toArray();
-                for (PropertyArray::const_iterator it = vecVal.begin(); it != vecVal.end(); it++)
-                {
-                    Ogre::String actionName = (*it).toString().c_str();
-                    Action* act = ActionManager::getSingleton().getAction(actionName);
-
-                    if (act != NULL)
-                    {
-                        addAction(act);
-                    }
-                    else
-                    {
-                        LOG_ERROR(Logger::RULES, "'"+actionName+"' not registered at ActionManager.");
-                    }
-                }
-            }
-            else if (key == PROPERTY_DEFAULT_ACTION)
-            {
-                mDefaultAction = value.toString().c_str();
-            }
-            else if (key == PROPERTY_SUBMESHPRENAME)
-            {
-                mSubmeshPreName = value.toString();
-            }
-            else
-            {
-                if( key != PROPERTY_BASE_CLASS && key != PROPERTY_CLASS_ID && key != PROPERTY_INHERITS)
-                    // these two keys can be ignored, they are only given to the GameObjectFactory when creating a GOF
-                {
-                    LOG_WARNING(Logger::RULES,
-						key + " is not a property of this GameObject ("+mName+")");
-                }
-            }
-        }
-        catch (WrongFormatException ex)
-        {
-            LOG_ERROR(
-                Logger::RULES,
-                "property " + key + " has the wrong format");
-        }
-    }
-
-    PropertyKeys GameObject::getAllPropertyKeys() const
-    {
-        PropertyKeys keys;
-        keys.insert(PROPERTY_NAME);
-        keys.insert(PROPERTY_DESCRIPTION);
-        if(mState == GOS_IN_SCENE)
-        {
-            keys.insert(PROPERTY_POSITION);
-            keys.insert(PROPERTY_ORIENTATION); 
-        }
-        keys.insert(PROPERTY_MESHFILE);
-        keys.insert(PROPERTY_MESHPARTS);
-        keys.insert(PROPERTY_GEOMETRY_TYPE);
-        keys.insert(PROPERTY_MASS);
-        return keys;
-    }
-
-    Actor* GameObject::createActor()
-    {
-        if (!mActor)
-        {
-            Ogre::String actorName = Ogre::StringConverter::toString(mId);
-			Actor* actor = NULL;
-
-			if (mMeshfile.empty() && mMeshParts.empty())
-			{
-				LOG_ERROR(
-					Logger::RULES,
-					"Neither mesh file nor mesh parts are set on gameobject '" + getName()
-					+ "' (id: " + getId() + "). Can't create actor!");
-			}
-			else if (!mMeshParts.empty())
-			{
-				actor = ActorManager::getSingleton().createMeshActor(
-						actorName,
-						mMeshfile.c_str(),
-						mMeshParts,
-						mGeometryType,
-						mMass);
-			}
-			else
-			{
-				actor = ActorManager::getSingleton().createMeshActor(
-						actorName,
-						mMeshfile.c_str(),
-						mGeometryType,
-						mMass);
-			}
-
-			if (actor == NULL)
-			{
-				LOG_ERROR(
-					Logger::RULES,
-					"Error creating actor '"
-					+ actorName	+ "'.");
-			}
-
-            setActor(actor);
-        }
-
-        return mActor;
-    }
-
-    void GameObject::destroyActor()
-    {
-        if (mActor != NULL)
-        {
-			Actor* actor = mActor;
-			setActor(NULL);
-            ActorManager::getSingleton().destroyActor(actor);
-		}
-    }
-
-    void GameObject::placeIntoScene()
-    {
-        setState(GOS_IN_SCENE);
-    }
-
-    void GameObject::removeFromScene()
-    {
-        setState(GOS_LOADED);
-    }
-
-    void GameObject::doPlaceIntoScene()
-    {
-        if (mState != GOS_IN_SCENE)
-        {
-            Actor* actor = createActor();
-
-            if (actor != NULL)
-            {
-                actor->placeIntoScene(mPosition, mOrientation);
-                setActor(actor);
-                mScene = CoreSubsystem::getSingleton().getCurrentScene();
-
-                // this is done in setstate now
-                //GameObjectState tmpState = mState;
-                //mState = GOS_IN_SCENE;
-                //GameObjectManager::getSingleton().gameObjectStateChanged(this, tmpState, mState);
-                //onStateChange(tmpState, GOS_IN_SCENE);
-            }
-            else {
-                LOG_ERROR(
-                    Logger::RULES,
-                    "Error placing gameobject '"
-                    + Ogre::StringConverter::toString(mId)
-                    + "' into scene "
-                    + mMeshfile);
-            }
-        }
-    }
-
-    void GameObject::doRemoveFromScene()
-    {
-        if (mState == GOS_IN_SCENE)
-        {
-            Actor* actor = mActor;
-            if (actor)
-            {
-                //mOrientation = actor->getWorldOrientation(); //Why world orientation?
-                //mPosition = actor->getWorldPosition(); //Why world position?
-
-                mOrientation = actor->getOrientation();
-                mPosition = actor->getPosition();
-
-                setActor(NULL);
-                actor->removeFromScene();
-                mScene = "";
-            }
-
-            // give the setstate function the possibility to reuse the actor
-            //ActorManager::getSingleton().destroyActor(actor);
-
-            // this is done in setstate now
-            //GameObjectState tmpState = mState;
-            //mState = GOS_LOADED;
-            //GameObjectManager::getSingleton().gameObjectStateChanged(this, tmpState, mState);
-        }
-    }
-
-    void GameObject::setState(GameObjectState targetstate)
-    {
-        if (targetstate == mState)
-        {
-            return;
-        }
-
-        GameObjectState oldState = mState;
-        onBeforeStateChange(oldState, targetstate);
-
-        if (targetstate == GOS_LOADED && mState == GOS_IN_SCENE)
-        {
-            doRemoveFromScene();
-            destroyActor();
-        }
-        else if (targetstate == GOS_IN_SCENE && mState == GOS_LOADED)
-        {
-            doPlaceIntoScene();
-        }
-        else
-        {
-            LOG_ERROR(
-                Logger::RULES,
-                "GameObject '" + getName()
-                + "' could not change state from "
-                + Ogre::StringConverter::toString(mState) + " to "
-                + Ogre::StringConverter::toString(targetstate));
-            return;
-        }
-
-        mState = targetstate;
-        onAfterStateChange(oldState, targetstate);
-        GameObjectManager::getSingleton().gameObjectStateChanged(this, oldState, targetstate);
-    }
-
-    void GameObject::onBeforeStateChange(GameObjectState oldState, GameObjectState newState)
-    {
-    }
-
-    void GameObject::onAfterStateChange(GameObjectState oldState, GameObjectState newState)
-    {
-    }
-
-    GameObjectState GameObject::getState() const
-    {
-        return mState;
-    }
-
-    unsigned long GameObject::getQueryFlags() const
-    {
-        return mQueryFlags;
-    }
-
-    void GameObject::addQueryFlag(unsigned long queryflag)
-    {
-        mQueryFlags |= queryflag;
-
-        setQueryFlags(mQueryFlags);
-    }
-
-    void GameObject::setQueryFlags(unsigned long queryflags)
-    {
-        mQueryFlags = queryflags;
-
-        if(mActor != NULL)
-        {
-            mActor->setQueryFlags(mQueryFlags);
-        }
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include "GameObject.h"
+#include <CEGUIPropertyHelper.h>
+
+#include "Action.h"
+#include "ActionManager.h"
+#include "Actor.h"
+#include "ActorManager.h"
+#include "EffectManager.h"
+#include "Exception.h"
+#include "ObjectStateChangeEventSource.h"
+#include "Property.h"
+#include "RulesSubsystem.h"
+#include "GameObjectManager.h"
+#include "CoreSubsystem.h"
+#include "PhysicsManager.h"
+
+
+using namespace std;
+
+namespace rl
+{
+    const CeGuiString GameObject::DEFAULT_VIEW_OBJECT_ACTION = "viewobject";
+    const CeGuiString GameObject::DEFAULT_VIEW_OBJECT_ACTION_DEBUG = "viewobjectdebug";
+
+    const Ogre::String GameObject::CLASS_NAME = "GameObject";
+
+    const Ogre::String GameObject::PROPERTY_CLASS_ID = "classid";
+    const Ogre::String GameObject::PROPERTY_OBJECT_ID = "id";
+    const Ogre::String GameObject::PROPERTY_BASE_CLASS = "baseclass";
+    const Ogre::String GameObject::PROPERTY_POSITION = "position";
+    const Ogre::String GameObject::PROPERTY_SCENE = "scene";
+    const Ogre::String GameObject::PROPERTY_INHERITS = "inherits";
+    const Ogre::String GameObject::PROPERTY_ORIENTATION = "orientation";
+    const Ogre::String GameObject::PROPERTY_NAME = "name";
+    const Ogre::String GameObject::PROPERTY_DESCRIPTION = "description";
+    const Ogre::String GameObject::PROPERTY_MESHFILE = "meshfile";
+	const Ogre::String GameObject::PROPERTY_MESHPARTS = "meshparts";
+    const Ogre::String GameObject::PROPERTY_SUBMESHPRENAME = "submeshprename";
+    const Ogre::String GameObject::PROPERTY_GEOMETRY_TYPE = "geometrytype";
+    const Ogre::String GameObject::PROPERTY_MASS = "mass";
+    const Ogre::String GameObject::PROPERTY_ACTIONS = "actions";
+    const Ogre::String GameObject::PROPERTY_DEFAULT_ACTION = "defaultaction";
+
+    GameObject::GameObject(unsigned int id)
+        :   mId(id),
+            mName(""),
+            mDescription(""),
+            mMeshfile(""),
+			mMeshParts(),
+            mQueryFlags(QUERYFLAG_GAMEOBJECT),
+            mHighlightingEnabled(true),
+            mActor(NULL),
+            mActions(),
+            mPosition(Ogre::Vector3::ZERO),
+            mOrientation(Ogre::Quaternion::IDENTITY),
+            mMass(0),
+            mGeometryType(GT_NONE),
+            mDefaultAction(DEFAULT_VIEW_OBJECT_ACTION),
+            mState(GOS_LOADED),
+            mScene("")
+    {
+        mEffectManager = new EffectManager(this);
+
+        // Standardactions registrieren
+        Action* defaultAction = ActionManager::getSingleton().getAction(DEFAULT_VIEW_OBJECT_ACTION);
+        if (defaultAction != NULL)
+        {
+            addAction(defaultAction);
+        }
+
+        // If game in developer mode, show GameObject debug window
+        // in the radial menu
+        //if( CoreSubsystem::getSingleton().getDeveloperMode() )
+        //{
+            defaultAction = ActionManager::getSingleton().getAction(DEFAULT_VIEW_OBJECT_ACTION_DEBUG);
+            if (defaultAction != NULL)
+            {
+                addAction(defaultAction);
+            }
+        //}
+
+        // Eventsource erzeugen
+        setObject(this);
+    }
+
+    GameObject::~GameObject(void)
+    {
+        destroyActor();
+    	delete mEffectManager;
+    }
+
+    int GameObject::getId() const
+    {
+        return mId;
+    }
+
+    const CeGuiString& GameObject::getClassId() const
+    {
+        return mClassId;
+    }
+
+    void GameObject::setClassId(const CeGuiString& classId)
+    {
+        mClassId = classId;
+    }
+
+    const CeGuiString& GameObject::getName() const
+    {
+        return mName;
+    }
+
+    void GameObject::setName(const CeGuiString& name)
+    {
+        mName = name;
+    }
+
+    const CeGuiString& GameObject::getDescription() const
+    {
+        return mDescription;
+    }
+
+    void GameObject::setDescription(const CeGuiString& description)
+    {
+        mDescription = description;
+    }
+
+    const CeGuiString& GameObject::getMeshfile() const
+    {
+        return mMeshfile;
+    }
+
+    void GameObject::setMeshfile(const CeGuiString& meshfile)
+    {
+        mMeshfile = meshfile;
+    }
+
+	const MeshPartMap& GameObject::getMeshParts() const
+	{
+		return mMeshParts;
+	}
+
+    const CeGuiString& GameObject::getSubmeshPreName() const
+    {
+        return mSubmeshPreName;
+    }
+
+    void GameObject::setSubmeshPreName(const CeGuiString& name)
+    {
+        mSubmeshPreName = name;
+    }
+
+    const CeGuiString& GameObject::getScene() const
+    {
+        return mScene;
+    }
+
+    void GameObject::setScene(const CeGuiString& scene)
+    {
+        mScene = scene;
+    }
+
+    void GameObject::addAction(Action* action, int option)
+    {
+        if (action == NULL)
+        {
+            Throw(NullPointerException, "Parameter action ist NULL.");
+        }
+
+        mActions.push_back(make_pair(action, option));
+        LOG_MESSAGE(Logger::RULES,
+            "Bei GameObject #"+CEGUI::PropertyHelper::intToString(mId)+
+            " ("+getName()+") wurde Aktion "+action->getName().c_str()+" hinzugefuegt.");
+    }
+
+    void GameObject::addActionInGroup(Action* action, ActionGroup* group, int option)
+    {
+        addAction(action, option);
+        action->setGroup(group);
+    }
+
+    void GameObject::removeAction(Action* action)
+    {
+        ActionOptionVector::iterator it = findAction(mActions.begin(), mActions.end(), action);
+        if (it != mActions.end())
+        {
+            mActions.erase(it);
+        }
+    }
+
+    const ActionVector GameObject::getValidActions(Creature* actor) const
+    {
+        ActionVector actions;
+        for (ActionOptionVector::const_iterator it = mActions.begin(); it != mActions.end(); ++it)
+        {
+            LOG_DEBUG(Logger::RULES, "Untersuche Aktion "+(*it).first->getName());
+            if ((*it).second == Action::ACT_DISABLED)
+            {
+                continue;                
+            }
+            //if ((*it).second > ACT_NEEDS_TALENT)
+            if (actor != NULL && !(*it).first->canDo(const_cast<GameObject*>(this), actor)) // Aktion nicht m???glich
+            {
+                continue;                
+            }
+            
+            actions.push_back((*it).first);
+        }
+        return actions;
+    }
+    
+    bool GameObject::hasAction(const CeGuiString& actionName, Creature* actor) const
+    {
+        ActionOptionVector::const_iterator it =
+            findAction(mActions.begin(), mActions.end(), actionName);
+        
+        if (it == mActions.end())
+        {
+            return false;
+        }
+
+        LOG_DEBUG(Logger::RULES, "Untersuche Aktion "+(*it).first->getName());
+        if ((*it).second == Action::ACT_DISABLED)
+        {
+            return false;                
+        }
+        //if ((*it).second > ACT_NEEDS_TALENT)
+        if (actor != NULL && !(*it).first->canDo(const_cast<GameObject*>(this), actor)) // Aktion nicht m???glich
+        {
+            return false;
+        }
+        
+        return true;
+    }
+    
+    
+    void GameObject::doAction( const CeGuiString& actionName,
+                              Creature* actor,
+                              GameObject* target)
+    {
+        ActionOptionVector::iterator it =
+            findAction(mActions.begin(), mActions.end(), actionName);
+
+        if (it == mActions.end())
+        {
+            LOG_ERROR(
+                Logger::RULES,
+                "'" + actionName + "' ist eine dem Objekt unbekannte Aktion.");
+        }
+        else
+        {
+            doAction((*it).first, actor, target);
+        }
+    }
+
+    void GameObject::doAction(const CeGuiString& actionName)
+    {
+        doAction(actionName, NULL, NULL);
+    }
+
+    void GameObject::doAction(Action* action,
+                              Creature* actor,
+                              GameObject* target)
+    {
+        action->doAction(this, actor, target);
+    }
+
+    void GameObject::doDefaultAction(Creature* actor, GameObject* target)
+    {
+        Action* action = getDefaultAction(actor);
+        if (action != NULL)
+        {
+            doAction(action, actor, target);
+        }
+        else
+        {
+            LOG_ERROR(
+                Logger::RULES,
+                "GameObject " + getName() + " has no valid default action set.");
+        }
+    }
+
+    bool GameObject::activateAction(Action* action,
+                      Creature* actor,
+                      GameObject* target)
+    {
+        doAction(action, actor, target);
+        return true;
+    }
+
+    GameObject::ActionOptionVector::iterator
+        GameObject::findAction(
+            GameObject::ActionOptionVector::iterator begin,
+            GameObject::ActionOptionVector::iterator end,
+            const CeGuiString actionName)
+    {
+        for (ActionOptionVector::iterator iter = begin; iter != end; ++iter)
+        {
+            Action* action = (*iter).first;
+
+            if (action->getName().compare(actionName) == 0)
+                return iter;
+        }
+        return end;
+    }
+
+    GameObject::ActionOptionVector::const_iterator
+    GameObject::findAction(
+                           GameObject::ActionOptionVector::const_iterator begin,
+                           GameObject::ActionOptionVector::const_iterator end,
+                           const CeGuiString actionName) const
+    {
+        for (ActionOptionVector::const_iterator iter = begin; iter != end; ++iter)
+        {
+            Action* action = (*iter).first;
+            
+            if (action->getName().compare(actionName) == 0)
+                return iter;
+        }
+        return end;
+    }
+    
+    GameObject::ActionOptionVector::iterator
+        GameObject::findAction(
+            GameObject::ActionOptionVector::iterator begin,
+            GameObject::ActionOptionVector::iterator end,
+            const Action* action)
+    {
+        for (ActionOptionVector::iterator iter = begin; iter != end; ++iter)
+            if ((*iter).first == action)
+                return iter;
+
+        return end;
+    }
+
+    void GameObject::setActor(Actor* actor)
+    {
+        if (mActor != actor)
+        {
+            if (mActor != NULL)
+            {
+                mActor->setGameObject(NULL);
+                mActor->setQueryFlags(0);
+            }
+
+            if (actor != NULL)
+            {                
+                actor->setGameObject(this);
+                if (actor->isInScene())
+                {
+                    actor->setPosition(mPosition);
+                    actor->setOrientation(mOrientation);                    
+                }
+            }
+
+            mActor = actor;
+        }
+
+        if (mActor && mActor->isInScene())
+        {
+            mActor->setQueryFlags(mQueryFlags);
+        }
+    }
+
+    Actor* GameObject::getActor()
+    {
+        return mActor;
+    }
+
+    bool GameObject::isHighlightingEnabled()
+    {
+        return mHighlightingEnabled;
+    }
+
+    void GameObject::setHighlightingEnabled( bool highlightenabled )
+    {
+        // Leuchtet zur Zeit, sollte aber nicht leuchten
+        if( mActor != NULL && !highlightenabled && mActor->isHighlighted() )
+        {
+            mActor->setHighlighted( false );
+        }
+
+        mHighlightingEnabled = highlightenabled;
+    }
+
+    Action* GameObject::getDefaultAction(Creature* actor) const
+    {
+        return ActionManager::getSingleton().getAction(mDefaultAction);
+    }
+
+    void GameObject::setHighlighted(bool highlight)
+    {
+        if (mHighlightingEnabled && mActor != NULL)
+        {
+            mActor->setHighlighted(highlight, getName());
+        }
+    }
+
+    bool GameObject::isHighlighted() const
+    {
+        return mActor != NULL && mActor->isHighlighted();
+    }
+
+    void GameObject::setPosition(const Ogre::Vector3& position)
+    {
+        if (mActor != NULL)
+        {
+            mActor->setPosition(position);
+        }
+        else
+        {
+            mPosition = position;
+        }
+    }
+
+    const Ogre::Vector3& GameObject::getPosition() const
+    {
+        if (mActor != NULL)
+        {
+            return mActor->getPosition();
+        }
+        return mPosition;
+    }
+
+	Ogre::AxisAlignedBox GameObject::getWorldBoundingBox() const
+	{
+        if (mActor != NULL)
+        {
+            return mActor->getWorldBoundingBox();
+        }
+        return Ogre::AxisAlignedBox();
+	}
+
+    void GameObject::setOrientation(const Ogre::Quaternion& orientation)
+    {
+        if (mActor != NULL)
+        {
+            mActor->setOrientation(orientation);
+        }
+        else
+        {
+            mOrientation = orientation;
+        }
+    }
+
+    const Ogre::Quaternion& GameObject::getOrientation() const
+    {
+        if (mActor != NULL)
+        {
+            return mActor->getOrientation();
+        }
+        return mOrientation;
+    }
+
+    const GeometryType GameObject::getGeometryType() const
+    {
+        return mGeometryType;
+    }
+
+    void GameObject::setGeometryType(GeometryType type)
+    {
+        mGeometryType = type;
+    }
+
+    const Ogre::Real GameObject::getMass() const
+    {
+        return mMass;
+    }
+
+    void GameObject::setMass(const Ogre::Real mass)
+    {
+        mMass = mass;
+    }
+
+    void GameObject::addEffect(Effect* effect)
+	{
+		mEffectManager->addEffect(effect);
+	}
+
+    void GameObject::addEffectWithCheckTime(Effect* effect, RL_LONGLONG time)
+    {
+      addEffect(effect);
+      mEffectManager->addTimeCheck(time, effect);
+    }
+
+    void GameObject::addEffectWithCheckDate(Effect* effect, RL_LONGLONG date)
+    {
+      addEffect(effect);
+      mEffectManager->addDateCheck(date, effect);
+    }
+
+	void GameObject::_checkEffects()
+	{
+		/// @todo Nur einmal pro Aktion ausfuehren
+		mEffectManager->checkEffects();
+	}
+
+    void GameObject::removeEffect(Effect* effect)
+	{
+		mEffectManager->removeEffect(effect);
+	}
+
+    CeGuiString GameObject::getEffects()
+    {
+        return mEffectManager->getEffects();
+    }
+
+    const Property GameObject::getProperty(const CeGuiString& key) const
+    {
+        Property prop;
+        if (key == PROPERTY_POSITION)
+        {
+            prop.setValue(getPosition());
+        }
+        else if (key == PROPERTY_ORIENTATION)
+        {
+            prop.setValue(getOrientation());
+        }
+        else if (key == PROPERTY_NAME)
+        {
+            prop.setValue(mName);
+        }
+        else if (key == PROPERTY_DESCRIPTION)
+        {
+            prop.setValue(mDescription);
+        }
+        else if (key == PROPERTY_MESHFILE)
+        {
+            prop.setValue(mMeshfile);
+        }
+        else if (key == PROPERTY_GEOMETRY_TYPE)
+        {
+            prop.setValue(PhysicsManager::convertGeometryTypeToString(mGeometryType));
+        }
+        else if (key == PROPERTY_MASS)
+        {
+            prop.setValue(mMass);
+        }
+		else if (key == PROPERTY_MESHPARTS)
+		{
+			PropertyMap map;
+			for (MeshPartMap::const_iterator
+					it = mMeshParts.begin(); it != mMeshParts.end(); ++it)
+			{
+				map[(*it).first] = Property((*it).second);
+			}
+			prop.setValue(map);
+		}
+        else if (key == PROPERTY_SUBMESHPRENAME)
+        {
+            prop.setValue(mSubmeshPreName);
+        }
+        else
+        {
+            Throw(IllegalArgumentException, key + " is not a property of this gameobject ("+mName.c_str()+")");
+        }
+
+        return prop;
+    }
+
+    void GameObject::setProperty(const CeGuiString& key, const Property& value)
+    {
+        try
+        {
+            if (key == PROPERTY_POSITION)
+            {
+                setPosition(value.toVector3());
+            }
+            else if (key == PROPERTY_ORIENTATION)
+            {
+                setOrientation(value.toQuaternion());
+            }
+            else if (key == PROPERTY_NAME)
+            {
+                setName(value.toString());
+            }
+            else if (key == PROPERTY_DESCRIPTION)
+            {
+                setDescription(value.toString());
+            }
+            else if (key == PROPERTY_MESHFILE)
+            {
+                setMeshfile(value.toString());
+            }
+            else if (key == PROPERTY_MESHPARTS)
+            {
+				PropertyMap map = value.toMap();
+				for (PropertyMap::const_iterator
+					it = map.begin(); it != map.end(); ++it)
+				{
+					mMeshParts[(*it).first.c_str()] = (*it).second.toString().c_str();
+				}
+            }
+            else if (key == PROPERTY_GEOMETRY_TYPE)
+            {
+                setGeometryType(PhysicsManager::convertStringToGeometryType(value.toString().c_str()));
+            }
+            else if (key == PROPERTY_MASS)
+            {
+                Ogre::Real mass = 0.0;
+                if (value.isInt())
+                {
+                    mass = value.toInt();
+                }
+                else if (value.isReal())
+                {
+                    mass = value.toReal();
+                }
+                setMass(mass);
+            }
+            else if (key == PROPERTY_ACTIONS)
+            {
+                PropertyArray vecVal = value.toArray();
+                for (PropertyArray::const_iterator it = vecVal.begin(); it != vecVal.end(); it++)
+                {
+                    Ogre::String actionName = (*it).toString().c_str();
+                    Action* act = ActionManager::getSingleton().getAction(actionName);
+
+                    if (act != NULL)
+                    {
+                        addAction(act);
+                    }
+                    else
+                    {
+                        LOG_ERROR(Logger::RULES, "'"+actionName+"' not registered at ActionManager.");
+                    }
+                }
+            }
+            else if (key == PROPERTY_DEFAULT_ACTION)
+            {
+                mDefaultAction = value.toString().c_str();
+            }
+            else if (key == PROPERTY_SUBMESHPRENAME)
+            {
+                mSubmeshPreName = value.toString();
+            }
+            else
+            {
+                if( key != PROPERTY_BASE_CLASS && key != PROPERTY_CLASS_ID && key != PROPERTY_INHERITS)
+                    // these two keys can be ignored, they are only given to the GameObjectFactory when creating a GOF
+                {
+                    LOG_WARNING(Logger::RULES,
+						key + " is not a property of this GameObject ("+mName+")");
+                }
+            }
+        }
+        catch (WrongFormatException ex)
+        {
+            LOG_ERROR(
+                Logger::RULES,
+                "property " + key + " has the wrong format");
+        }
+    }
+
+    PropertyKeys GameObject::getAllPropertyKeys() const
+    {
+        PropertyKeys keys;
+        keys.insert(PROPERTY_NAME);
+        keys.insert(PROPERTY_DESCRIPTION);
+        if(mState == GOS_IN_SCENE)
+        {
+            keys.insert(PROPERTY_POSITION);
+            keys.insert(PROPERTY_ORIENTATION); 
+        }
+        keys.insert(PROPERTY_MESHFILE);
+        keys.insert(PROPERTY_MESHPARTS);
+        keys.insert(PROPERTY_GEOMETRY_TYPE);
+        keys.insert(PROPERTY_MASS);
+        return keys;
+    }
+
+    Actor* GameObject::createActor()
+    {
+        if (!mActor)
+        {
+            Ogre::String actorName = Ogre::StringConverter::toString(mId);
+			Actor* actor = NULL;
+
+			if (mMeshfile.empty() && mMeshParts.empty())
+			{
+				LOG_ERROR(
+					Logger::RULES,
+					"Neither mesh file nor mesh parts are set on gameobject '" + getName()
+					+ "' (id: " + getId() + "). Can't create actor!");
+			}
+			else if (!mMeshParts.empty())
+			{
+				actor = ActorManager::getSingleton().createMeshActor(
+						actorName,
+						mMeshfile.c_str(),
+						mMeshParts,
+						mGeometryType,
+						mMass);
+			}
+			else
+			{
+				actor = ActorManager::getSingleton().createMeshActor(
+						actorName,
+						mMeshfile.c_str(),
+						mGeometryType,
+						mMass);
+			}
+
+			if (actor == NULL)
+			{
+				LOG_ERROR(
+					Logger::RULES,
+					"Error creating actor '"
+					+ actorName	+ "'.");
+			}
+
+            setActor(actor);
+        }
+
+        return mActor;
+    }
+
+    void GameObject::destroyActor()
+    {
+        if (mActor != NULL)
+        {
+			Actor* actor = mActor;
+			setActor(NULL);
+            ActorManager::getSingleton().destroyActor(actor);
+		}
+    }
+
+    void GameObject::placeIntoScene()
+    {
+        setState(GOS_IN_SCENE);
+    }
+
+    void GameObject::removeFromScene()
+    {
+        setState(GOS_LOADED);
+    }
+
+    void GameObject::doPlaceIntoScene()
+    {
+        if (mState != GOS_IN_SCENE)
+        {
+            Actor* actor = createActor();
+
+            if (actor != NULL)
+            {
+                actor->placeIntoScene(mPosition, mOrientation);
+                setActor(actor);
+                mScene = CoreSubsystem::getSingleton().getCurrentScene();
+
+                // this is done in setstate now
+                //GameObjectState tmpState = mState;
+                //mState = GOS_IN_SCENE;
+                //GameObjectManager::getSingleton().gameObjectStateChanged(this, tmpState, mState);
+                //onStateChange(tmpState, GOS_IN_SCENE);
+            }
+            else {
+                LOG_ERROR(
+                    Logger::RULES,
+                    "Error placing gameobject '"
+                    + Ogre::StringConverter::toString(mId)
+                    + "' into scene "
+                    + mMeshfile);
+            }
+        }
+    }
+
+    void GameObject::doRemoveFromScene()
+    {
+        if (mState == GOS_IN_SCENE)
+        {
+            Actor* actor = mActor;
+            if (actor)
+            {
+                //mOrientation = actor->getWorldOrientation(); //Why world orientation?
+                //mPosition = actor->getWorldPosition(); //Why world position?
+
+                mOrientation = actor->getOrientation();
+                mPosition = actor->getPosition();
+
+                setActor(NULL);
+                actor->removeFromScene();
+                mScene = "";
+            }
+
+            // give the setstate function the possibility to reuse the actor
+            //ActorManager::getSingleton().destroyActor(actor);
+
+            // this is done in setstate now
+            //GameObjectState tmpState = mState;
+            //mState = GOS_LOADED;
+            //GameObjectManager::getSingleton().gameObjectStateChanged(this, tmpState, mState);
+        }
+    }
+
+    void GameObject::setState(GameObjectState targetstate)
+    {
+        if (targetstate == mState)
+        {
+            return;
+        }
+
+        GameObjectState oldState = mState;
+        onBeforeStateChange(oldState, targetstate);
+
+        if (targetstate == GOS_LOADED && mState == GOS_IN_SCENE)
+        {
+            doRemoveFromScene();
+            destroyActor();
+        }
+        else if (targetstate == GOS_IN_SCENE && mState == GOS_LOADED)
+        {
+            doPlaceIntoScene();
+        }
+        else
+        {
+            LOG_ERROR(
+                Logger::RULES,
+                "GameObject '" + getName()
+                + "' could not change state from "
+                + Ogre::StringConverter::toString(mState) + " to "
+                + Ogre::StringConverter::toString(targetstate));
+            return;
+        }
+
+        mState = targetstate;
+        onAfterStateChange(oldState, targetstate);
+        GameObjectManager::getSingleton().gameObjectStateChanged(this, oldState, targetstate);
+    }
+
+    void GameObject::onBeforeStateChange(GameObjectState oldState, GameObjectState newState)
+    {
+    }
+
+    void GameObject::onAfterStateChange(GameObjectState oldState, GameObjectState newState)
+    {
+    }
+
+    GameObjectState GameObject::getState() const
+    {
+        return mState;
+    }
+
+    unsigned long GameObject::getQueryFlags() const
+    {
+        return mQueryFlags;
+    }
+
+    void GameObject::addQueryFlag(unsigned long queryflag)
+    {
+        mQueryFlags |= queryflag;
+
+        setQueryFlags(mQueryFlags);
+    }
+
+    void GameObject::setQueryFlags(unsigned long queryflags)
+    {
+        mQueryFlags = queryflags;
+
+        if(mActor != NULL)
+        {
+            mActor->setQueryFlags(mQueryFlags);
+        }
+    }
+}

Modified: rl/trunk/engine/rules/src/GoToJob.cpp
===================================================================
--- rl/trunk/engine/rules/src/GoToJob.cpp	2008-09-28 16:10:32 UTC (rev 4528)
+++ rl/trunk/engine/rules/src/GoToJob.cpp	2008-09-28 20:56:08 UTC (rev 4529)
@@ -18,6 +18,8 @@
 
 #include "GoToJob.h"
 
+#include "Creature.h"
+#include "CreatureController.h"
 #include "CreatureControllerManager.h"
 #include "MathUtil.h"
 



From blakharaz at mail.berlios.de  Sun Sep 28 22:56:39 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sun, 28 Sep 2008 22:56:39 +0200
Subject: [Dsa-hl-svn] r4530 - in rl/trunk: Mac/Rastullah.xcodeproj
	engine/rules/include engine/rules/src engine/script/swig
Message-ID: <200809282056.m8SKudC0006243@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-28 22:56:35 +0200 (Sun, 28 Sep 2008)
New Revision: 4530

Added:
   rl/trunk/engine/rules/include/FetchItemJob.h
   rl/trunk/engine/rules/src/FetchItemJob.cpp
Modified:
   rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/trunk/engine/script/swig/RlRules.head.swig
   rl/trunk/engine/script/swig/RlRules.swig
Log:
Added (still untested) FetchItemJob

Modified: rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-28 20:56:08 UTC (rev 4529)
+++ rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-09-28 20:56:35 UTC (rev 4530)
@@ -430,7 +430,6 @@
 		44D8147B0BF7B62F00534175 /* Zone.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814760BF7B62F00534175 /* Zone.h */; };
 		44D8147C0BF7B62F00534175 /* ZoneManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 44D814770BF7B62F00534175 /* ZoneManager.h */; };
 		48003B550E3211660056D073 /* libboost_system.dylib in Copy Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
-		4835559B0E6ABED100008748 /* mkdmg.sh in Resources */ = {isa = PBXBuildFile; fileRef = 4835559A0E6ABED100008748 /* mkdmg.sh */; };
 		483646990D83D13700912FEC /* ContentLoader.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646960D83D13700912FEC /* ContentLoader.h */; };
 		4836469A0D83D13700912FEC /* SoundStitching.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646970D83D13700912FEC /* SoundStitching.h */; };
 		4836469B0D83D13700912FEC /* StartAnimationJob.h in Headers */ = {isa = PBXBuildFile; fileRef = 483646980D83D13700912FEC /* StartAnimationJob.h */; };
@@ -703,6 +702,8 @@
 		48D34A800D91C7D800C89477 /* SaveGameFileWriter.h in Headers */ = {isa = PBXBuildFile; fileRef = 485A05700D71EDC40024198D /* SaveGameFileWriter.h */; };
 		48D34A810D91C7D800C89477 /* SaveGameManager.h in Headers */ = {isa = PBXBuildFile; fileRef = 485A05710D71EDC40024198D /* SaveGameManager.h */; };
 		48D409CE0D9E483300AE5340 /* modules in Resources */ = {isa = PBXBuildFile; fileRef = 48D401810D9E483200AE5340 /* modules */; };
+		48EFE0A40E8B6AF6007EB7F8 /* FetchItemJob.h in Headers */ = {isa = PBXBuildFile; fileRef = 48EFE0A30E8B6AF6007EB7F8 /* FetchItemJob.h */; };
+		48EFE0A60E8B6C39007EB7F8 /* FetchItemJob.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48EFE0A50E8B6C39007EB7F8 /* FetchItemJob.cpp */; };
 		8D0C4E8D0486CD37000505A6 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = 0867D6AAFE840B52C02AAC07 /* InfoPlist.strings */; };
 		8D0C4E8E0486CD37000505A6 /* main.nib in Resources */ = {isa = PBXBuildFile; fileRef = 02345980000FD03B11CA0E72 /* main.nib */; };
 /* End PBXBuildFile section */
@@ -882,9 +883,9 @@
 		4404DA6E0C48CEE2007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/ai/include/stdinc.h; sourceTree = SOURCE_ROOT; };
 		4404DA7C0C48CFB3007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/common/include/stdinc.h; sourceTree = SOURCE_ROOT; };
 		4404DA7E0C48CFC7007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/core/include/stdinc.h; sourceTree = SOURCE_ROOT; };
-		4404DA820C48D005007B4657 /* stdinc.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = stdinc.cpp; path = ../engine/rules/src/stdinc.cpp; sourceTree = SOURCE_ROOT; };
+		4404DA820C48D005007B4657 /* stdinc.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = stdinc.cpp; sourceTree = "<group>"; };
 		4404DA840C48D01E007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/script/include/stdinc.h; sourceTree = SOURCE_ROOT; };
-		4404DA850C48D037007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/ui/include/stdinc.h; sourceTree = SOURCE_ROOT; };
+		4404DA850C48D037007B4657 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = stdinc.h; sourceTree = "<group>"; };
 		440785DD0C09D231006E496D /* libmeshmagick.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libmeshmagick.dylib; path = /usr/local/lib/libmeshmagick.dylib; sourceTree = "<absolute>"; };
 		440785E20C09D2C1006E496D /* LightFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LightFadeJob.cpp; path = ../engine/core/src/LightFadeJob.cpp; sourceTree = SOURCE_ROOT; };
 		440785E30C09D2C1006E496D /* MergeableMeshObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MergeableMeshObject.cpp; path = ../engine/core/src/MergeableMeshObject.cpp; sourceTree = SOURCE_ROOT; };
@@ -913,8 +914,8 @@
 		444825F50BF7B32100C5A94F /* TriggerFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TriggerFactory.h; path = ../engine/script/include/TriggerFactory.h; sourceTree = SOURCE_ROOT; };
 		444825F60BF7B32100C5A94F /* WaypointProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WaypointProcessor.h; path = ../engine/script/include/WaypointProcessor.h; sourceTree = SOURCE_ROOT; };
 		444825F70BF7B32100C5A94F /* ZoneProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZoneProcessor.h; path = ../engine/script/include/ZoneProcessor.h; sourceTree = SOURCE_ROOT; };
-		444826030BF7B37D00C5A94F /* SelectionHelper.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SelectionHelper.cpp; path = ../engine/rules/src/SelectionHelper.cpp; sourceTree = SOURCE_ROOT; };
-		444826040BF7B37D00C5A94F /* Selector.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Selector.cpp; path = ../engine/rules/src/Selector.cpp; sourceTree = SOURCE_ROOT; };
+		444826030BF7B37D00C5A94F /* SelectionHelper.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SelectionHelper.cpp; sourceTree = "<group>"; };
+		444826040BF7B37D00C5A94F /* Selector.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Selector.cpp; sourceTree = "<group>"; };
 		444EAAAC0BD0E0C700C6D4A0 /* RastullahMain.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RastullahMain.cpp; path = ../engine/startup/src/RastullahMain.cpp; sourceTree = SOURCE_ROOT; };
 		444EAAB20BD0E0FB00C6D4A0 /* libRlCommon.dylib */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.dylib"; includeInIndex = 0; path = libRlCommon.dylib; sourceTree = BUILT_PRODUCTS_DIR; };
 		444EAAB60BD0E17000C6D4A0 /* ConfigFile.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ConfigFile.cpp; path = ../engine/common/src/ConfigFile.cpp; sourceTree = SOURCE_ROOT; };
@@ -1097,158 +1098,158 @@
 		444EAC8C0BD0E54100C6D4A0 /* WayPointGraph.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WayPointGraph.h; path = ../engine/ai/include/WayPointGraph.h; sourceTree = SOURCE_ROOT; };
 		444EAC8D0BD0E54100C6D4A0 /* WayPointGraphManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WayPointGraphManager.h; path = ../engine/ai/include/WayPointGraphManager.h; sourceTree = SOURCE_ROOT; };
 		444EAC8E0BD0E54100C6D4A0 /* WayPointNode.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WayPointNode.h; path = ../engine/ai/include/WayPointNode.h; sourceTree = SOURCE_ROOT; };
-		444EACA20BD0E57100C6D4A0 /* AboutWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AboutWindow.cpp; path = ../engine/ui/src/AboutWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACA30BD0E57100C6D4A0 /* AbstractWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = AbstractWindow.cpp; path = ../engine/ui/src/AbstractWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACA40BD0E57100C6D4A0 /* ActionChoiceWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ActionChoiceWindow.cpp; path = ../engine/ui/src/ActionChoiceWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACA60BD0E57100C6D4A0 /* CharacterSheetWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CharacterSheetWindow.cpp; path = ../engine/ui/src/CharacterSheetWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACA70BD0E57100C6D4A0 /* CharacterStateWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CharacterStateWindow.cpp; path = ../engine/ui/src/CharacterStateWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACA80BD0E57100C6D4A0 /* CloseConfirmationWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CloseConfirmationWindow.cpp; path = ../engine/ui/src/CloseConfirmationWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACAA0BD0E57100C6D4A0 /* CommandMapper.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CommandMapper.cpp; path = ../engine/ui/src/CommandMapper.cpp; sourceTree = SOURCE_ROOT; };
-		444EACAC0BD0E57100C6D4A0 /* ConfigComponent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ConfigComponent.cpp; path = ../engine/ui/src/ConfigComponent.cpp; sourceTree = SOURCE_ROOT; };
-		444EACAD0BD0E57100C6D4A0 /* Console.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Console.cpp; path = ../engine/ui/src/Console.cpp; sourceTree = SOURCE_ROOT; };
-		444EACAE0BD0E57100C6D4A0 /* ContainerContentWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ContainerContentWindow.cpp; path = ../engine/ui/src/ContainerContentWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACB10BD0E57100C6D4A0 /* DebugWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DebugWindow.cpp; path = ../engine/ui/src/DebugWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACB30BD0E57100C6D4A0 /* DialogWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogWindow.cpp; path = ../engine/ui/src/DialogWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACB50BD0E57100C6D4A0 /* GameLoggerWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameLoggerWindow.cpp; path = ../engine/ui/src/GameLoggerWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACB60BD0E57100C6D4A0 /* GameObjectInfoWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameObjectInfoWindow.cpp; path = ../engine/ui/src/GameObjectInfoWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACB80BD0E57100C6D4A0 /* GameSettings.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameSettings.cpp; path = ../engine/ui/src/GameSettings.cpp; sourceTree = SOURCE_ROOT; };
-		444EACB90BD0E57100C6D4A0 /* InfoPopup.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = InfoPopup.cpp; path = ../engine/ui/src/InfoPopup.cpp; sourceTree = SOURCE_ROOT; };
-		444EACBA0BD0E57100C6D4A0 /* InGameMenuWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = InGameMenuWindow.cpp; path = ../engine/ui/src/InGameMenuWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACBB0BD0E57100C6D4A0 /* InputManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = InputManager.cpp; path = ../engine/ui/src/InputManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EACBC0BD0E57100C6D4A0 /* InventoryWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = InventoryWindow.cpp; path = ../engine/ui/src/InventoryWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACBD0BD0E57100C6D4A0 /* ItemDragContainer.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ItemDragContainer.cpp; path = ../engine/ui/src/ItemDragContainer.cpp; sourceTree = SOURCE_ROOT; };
-		444EACBE0BD0E57100C6D4A0 /* JournalWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JournalWindow.cpp; path = ../engine/ui/src/JournalWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACBF0BD0E57100C6D4A0 /* ListboxWrappedTextItem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ListboxWrappedTextItem.cpp; path = ../engine/ui/src/ListboxWrappedTextItem.cpp; sourceTree = SOURCE_ROOT; };
-		444EACC00BD0E57100C6D4A0 /* LogWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LogWindow.cpp; path = ../engine/ui/src/LogWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACC10BD0E57100C6D4A0 /* MainMenuEngineWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MainMenuEngineWindow.cpp; path = ../engine/ui/src/MainMenuEngineWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACC20BD0E57100C6D4A0 /* MainMenuWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MainMenuWindow.cpp; path = ../engine/ui/src/MainMenuWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACC30BD0E57100C6D4A0 /* MessageWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MessageWindow.cpp; path = ../engine/ui/src/MessageWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACC50BD0E57100C6D4A0 /* ObjectDescriptionWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ObjectDescriptionWindow.cpp; path = ../engine/ui/src/ObjectDescriptionWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACC60BD0E57100C6D4A0 /* PlaylistWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PlaylistWindow.cpp; path = ../engine/ui/src/PlaylistWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACC70BD0E57100C6D4A0 /* RenderSystemConfigComponent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RenderSystemConfigComponent.cpp; path = ../engine/ui/src/RenderSystemConfigComponent.cpp; sourceTree = SOURCE_ROOT; };
-		444EACC90BD0E57100C6D4A0 /* SoundConfig.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundConfig.cpp; path = ../engine/ui/src/SoundConfig.cpp; sourceTree = SOURCE_ROOT; };
-		444EACCA0BD0E57100C6D4A0 /* SoundDriverConfigComponent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundDriverConfigComponent.cpp; path = ../engine/ui/src/SoundDriverConfigComponent.cpp; sourceTree = SOURCE_ROOT; };
-		444EACCB0BD0E57100C6D4A0 /* SubtitleWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SubtitleWindow.cpp; path = ../engine/ui/src/SubtitleWindow.cpp; sourceTree = SOURCE_ROOT; };
-		444EACCC0BD0E57100C6D4A0 /* UiSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = UiSubsystem.cpp; path = ../engine/ui/src/UiSubsystem.cpp; sourceTree = SOURCE_ROOT; };
-		444EACCD0BD0E57100C6D4A0 /* WindowFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WindowFactory.cpp; path = ../engine/ui/src/WindowFactory.cpp; sourceTree = SOURCE_ROOT; };
-		444EACCE0BD0E57100C6D4A0 /* WindowFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WindowFadeJob.cpp; path = ../engine/ui/src/WindowFadeJob.cpp; sourceTree = SOURCE_ROOT; };
-		444EACCF0BD0E57100C6D4A0 /* WindowManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WindowManager.cpp; path = ../engine/ui/src/WindowManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EACFE0BD0E58C00C6D4A0 /* AboutWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AboutWindow.h; path = ../engine/ui/include/AboutWindow.h; sourceTree = SOURCE_ROOT; };
-		444EACFF0BD0E58C00C6D4A0 /* AbstractWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AbstractWindow.h; path = ../engine/ui/include/AbstractWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD000BD0E58C00C6D4A0 /* ActionChoiceWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ActionChoiceWindow.h; path = ../engine/ui/include/ActionChoiceWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD010BD0E58C00C6D4A0 /* CeGuiHelper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CeGuiHelper.h; path = ../engine/ui/include/CeGuiHelper.h; sourceTree = SOURCE_ROOT; };
-		444EAD030BD0E58C00C6D4A0 /* CharacterSheetWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CharacterSheetWindow.h; path = ../engine/ui/include/CharacterSheetWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD040BD0E58C00C6D4A0 /* CharacterStateWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CharacterStateWindow.h; path = ../engine/ui/include/CharacterStateWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD050BD0E58C00C6D4A0 /* CloseConfirmationWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CloseConfirmationWindow.h; path = ../engine/ui/include/CloseConfirmationWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD070BD0E58C00C6D4A0 /* CommandMapper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CommandMapper.h; path = ../engine/ui/include/CommandMapper.h; sourceTree = SOURCE_ROOT; };
-		444EAD090BD0E58C00C6D4A0 /* ConfigComponent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ConfigComponent.h; path = ../engine/ui/include/ConfigComponent.h; sourceTree = SOURCE_ROOT; };
-		444EAD0A0BD0E58C00C6D4A0 /* Console.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Console.h; path = ../engine/ui/include/Console.h; sourceTree = SOURCE_ROOT; };
-		444EAD0B0BD0E58C00C6D4A0 /* ContainerContentWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ContainerContentWindow.h; path = ../engine/ui/include/ContainerContentWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD0E0BD0E58C00C6D4A0 /* DebugWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DebugWindow.h; path = ../engine/ui/include/DebugWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD100BD0E58C00C6D4A0 /* DialogWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogWindow.h; path = ../engine/ui/include/DialogWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD120BD0E58C00C6D4A0 /* GameLoggerWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameLoggerWindow.h; path = ../engine/ui/include/GameLoggerWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD130BD0E58C00C6D4A0 /* GameObjectInfoWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameObjectInfoWindow.h; path = ../engine/ui/include/GameObjectInfoWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD150BD0E58C00C6D4A0 /* GameSettings.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameSettings.h; path = ../engine/ui/include/GameSettings.h; sourceTree = SOURCE_ROOT; };
-		444EAD160BD0E58C00C6D4A0 /* InfoPopup.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = InfoPopup.h; path = ../engine/ui/include/InfoPopup.h; sourceTree = SOURCE_ROOT; };
-		444EAD170BD0E58C00C6D4A0 /* InGameMenuWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = InGameMenuWindow.h; path = ../engine/ui/include/InGameMenuWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD180BD0E58C00C6D4A0 /* InputManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = InputManager.h; path = ../engine/ui/include/InputManager.h; sourceTree = SOURCE_ROOT; };
-		444EAD190BD0E58C00C6D4A0 /* InventoryWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = InventoryWindow.h; path = ../engine/ui/include/InventoryWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD1A0BD0E58C00C6D4A0 /* ItemDragContainer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ItemDragContainer.h; path = ../engine/ui/include/ItemDragContainer.h; sourceTree = SOURCE_ROOT; };
-		444EAD1B0BD0E58C00C6D4A0 /* JournalWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JournalWindow.h; path = ../engine/ui/include/JournalWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD1C0BD0E58C00C6D4A0 /* ListboxWrappedTextItem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ListboxWrappedTextItem.h; path = ../engine/ui/include/ListboxWrappedTextItem.h; sourceTree = SOURCE_ROOT; };
-		444EAD1D0BD0E58C00C6D4A0 /* LogWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LogWindow.h; path = ../engine/ui/include/LogWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD1E0BD0E58C00C6D4A0 /* MainMenuEngineWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MainMenuEngineWindow.h; path = ../engine/ui/include/MainMenuEngineWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD1F0BD0E58C00C6D4A0 /* MainMenuWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MainMenuWindow.h; path = ../engine/ui/include/MainMenuWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD200BD0E58C00C6D4A0 /* MessageWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MessageWindow.h; path = ../engine/ui/include/MessageWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD220BD0E58C00C6D4A0 /* ObjectDescriptionWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ObjectDescriptionWindow.h; path = ../engine/ui/include/ObjectDescriptionWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD230BD0E58C00C6D4A0 /* PlaylistWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PlaylistWindow.h; path = ../engine/ui/include/PlaylistWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD240BD0E58C00C6D4A0 /* RenderSystemConfigComponent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RenderSystemConfigComponent.h; path = ../engine/ui/include/RenderSystemConfigComponent.h; sourceTree = SOURCE_ROOT; };
-		444EAD260BD0E58C00C6D4A0 /* SoundConfig.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundConfig.h; path = ../engine/ui/include/SoundConfig.h; sourceTree = SOURCE_ROOT; };
-		444EAD270BD0E58C00C6D4A0 /* SoundDriverConfigComponent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundDriverConfigComponent.h; path = ../engine/ui/include/SoundDriverConfigComponent.h; sourceTree = SOURCE_ROOT; };
-		444EAD280BD0E58C00C6D4A0 /* SubtitleWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SubtitleWindow.h; path = ../engine/ui/include/SubtitleWindow.h; sourceTree = SOURCE_ROOT; };
-		444EAD290BD0E58C00C6D4A0 /* UiPrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = UiPrerequisites.h; path = ../engine/ui/include/UiPrerequisites.h; sourceTree = SOURCE_ROOT; };
-		444EAD2A0BD0E58C00C6D4A0 /* UiSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = UiSubsystem.h; path = ../engine/ui/include/UiSubsystem.h; sourceTree = SOURCE_ROOT; };
-		444EAD2B0BD0E58C00C6D4A0 /* WindowFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WindowFactory.h; path = ../engine/ui/include/WindowFactory.h; sourceTree = SOURCE_ROOT; };
-		444EAD2C0BD0E58C00C6D4A0 /* WindowFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WindowFadeJob.h; path = ../engine/ui/include/WindowFadeJob.h; sourceTree = SOURCE_ROOT; };
-		444EAD2D0BD0E58C00C6D4A0 /* WindowManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WindowManager.h; path = ../engine/ui/include/WindowManager.h; sourceTree = SOURCE_ROOT; };
-		444EADB00BD0E64100C6D4A0 /* Action.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Action.cpp; path = ../engine/rules/src/Action.cpp; sourceTree = SOURCE_ROOT; };
-		444EADB10BD0E64100C6D4A0 /* ActionManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ActionManager.cpp; path = ../engine/rules/src/ActionManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EADB20BD0E64100C6D4A0 /* Armor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Armor.cpp; path = ../engine/rules/src/Armor.cpp; sourceTree = SOURCE_ROOT; };
-		444EADB30BD0E64100C6D4A0 /* Combat.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Combat.cpp; path = ../engine/rules/src/Combat.cpp; sourceTree = SOURCE_ROOT; };
-		444EADB40BD0E64100C6D4A0 /* CombatManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CombatManager.cpp; path = ../engine/rules/src/CombatManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EADB50BD0E64100C6D4A0 /* Container.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Container.cpp; path = ../engine/rules/src/Container.cpp; sourceTree = SOURCE_ROOT; };
-		444EADB60BD0E64100C6D4A0 /* Creature.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Creature.cpp; path = ../engine/rules/src/Creature.cpp; sourceTree = SOURCE_ROOT; };
-		444EADB70BD0E64100C6D4A0 /* Date.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Date.cpp; path = ../engine/rules/src/Date.cpp; sourceTree = SOURCE_ROOT; };
-		444EADB80BD0E64100C6D4A0 /* DsaDataLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DsaDataLoader.cpp; path = ../engine/rules/src/DsaDataLoader.cpp; sourceTree = SOURCE_ROOT; };
-		444EADB90BD0E64100C6D4A0 /* DsaManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DsaManager.cpp; path = ../engine/rules/src/DsaManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EADBA0BD0E64100C6D4A0 /* Effect.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Effect.cpp; path = ../engine/rules/src/Effect.cpp; sourceTree = SOURCE_ROOT; };
-		444EADBB0BD0E64100C6D4A0 /* EffectManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = EffectManager.cpp; path = ../engine/rules/src/EffectManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EADBC0BD0E64100C6D4A0 /* Eigenschaft.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Eigenschaft.cpp; path = ../engine/rules/src/Eigenschaft.cpp; sourceTree = SOURCE_ROOT; };
-		444EADBD0BD0E64100C6D4A0 /* EigenschaftenStateSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = EigenschaftenStateSet.cpp; path = ../engine/rules/src/EigenschaftenStateSet.cpp; sourceTree = SOURCE_ROOT; };
-		444EADBE0BD0E64100C6D4A0 /* GameObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameObject.cpp; path = ../engine/rules/src/GameObject.cpp; sourceTree = SOURCE_ROOT; };
-		444EADBF0BD0E64100C6D4A0 /* GameObjectManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameObjectManager.cpp; path = ../engine/rules/src/GameObjectManager.cpp; sourceTree = SOURCE_ROOT; };
-		444EADC10BD0E64100C6D4A0 /* Inventory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Inventory.cpp; path = ../engine/rules/src/Inventory.cpp; sourceTree = SOURCE_ROOT; };
-		444EADC20BD0E64100C6D4A0 /* Item.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Item.cpp; path = ../engine/rules/src/Item.cpp; sourceTree = SOURCE_ROOT; };
-		444EADC30BD0E64100C6D4A0 /* JournalEntry.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JournalEntry.cpp; path = ../engine/rules/src/JournalEntry.cpp; sourceTree = SOURCE_ROOT; };
-		444EADC40BD0E64100C6D4A0 /* Kampftechnik.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Kampftechnik.cpp; path = ../engine/rules/src/Kampftechnik.cpp; sourceTree = SOURCE_ROOT; };
-		444EADC50BD0E64100C6D4A0 /* ObjectStateChangeEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ObjectStateChangeEvent.cpp; path = ../engine/rules/src/ObjectStateChangeEvent.cpp; sourceTree = SOURCE_ROOT; };
-		444EADC60BD0E64100C6D4A0 /* ObjectStateChangeEventSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ObjectStateChangeEventSource.cpp; path = ../engine/rules/src/ObjectStateChangeEventSource.cpp; sourceTree = SOURCE_ROOT; };
-		444EADC70BD0E64100C6D4A0 /* ObjectStateChangeListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ObjectStateChangeListener.cpp; path = ../engine/rules/src/ObjectStateChangeListener.cpp; sourceTree = SOURCE_ROOT; };
-		444EADC90BD0E64100C6D4A0 /* Quest.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Quest.cpp; path = ../engine/rules/src/Quest.cpp; sourceTree = SOURCE_ROOT; };
-		444EADCA0BD0E64100C6D4A0 /* QuestBook.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = QuestBook.cpp; path = ../engine/rules/src/QuestBook.cpp; sourceTree = SOURCE_ROOT; };
-		444EADCB0BD0E64100C6D4A0 /* QuestEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = QuestEvent.cpp; path = ../engine/rules/src/QuestEvent.cpp; sourceTree = SOURCE_ROOT; };
-		444EADCC0BD0E64100C6D4A0 /* QuestListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = QuestListener.cpp; path = ../engine/rules/src/QuestListener.cpp; sourceTree = SOURCE_ROOT; };
-		444EADCD0BD0E64100C6D4A0 /* RulesSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RulesSubsystem.cpp; path = ../engine/rules/src/RulesSubsystem.cpp; sourceTree = SOURCE_ROOT; };
-		444EADCE0BD0E64100C6D4A0 /* Slot.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Slot.cpp; path = ../engine/rules/src/Slot.cpp; sourceTree = SOURCE_ROOT; };
-		444EADCF0BD0E64100C6D4A0 /* SonderfertigkeitenStateSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SonderfertigkeitenStateSet.cpp; path = ../engine/rules/src/SonderfertigkeitenStateSet.cpp; sourceTree = SOURCE_ROOT; };
-		444EADD00BD0E64100C6D4A0 /* StateSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = StateSet.cpp; path = ../engine/rules/src/StateSet.cpp; sourceTree = SOURCE_ROOT; };
-		444EADD10BD0E64100C6D4A0 /* Talent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Talent.cpp; path = ../engine/rules/src/Talent.cpp; sourceTree = SOURCE_ROOT; };
-		444EADD20BD0E64100C6D4A0 /* Talentgruppe.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Talentgruppe.cpp; path = ../engine/rules/src/Talentgruppe.cpp; sourceTree = SOURCE_ROOT; };
-		444EADD30BD0E64100C6D4A0 /* TalentStateSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TalentStateSet.cpp; path = ../engine/rules/src/TalentStateSet.cpp; sourceTree = SOURCE_ROOT; };
-		444EADD80BD0E64100C6D4A0 /* Weapon.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Weapon.cpp; path = ../engine/rules/src/Weapon.cpp; sourceTree = SOURCE_ROOT; };
-		444EADD90BD0E64100C6D4A0 /* ZauberStateSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ZauberStateSet.cpp; path = ../engine/rules/src/ZauberStateSet.cpp; sourceTree = SOURCE_ROOT; };
-		444EAE040BD0E65B00C6D4A0 /* Action.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Action.h; path = ../engine/rules/include/Action.h; sourceTree = SOURCE_ROOT; };
-		444EAE050BD0E65B00C6D4A0 /* ActionManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ActionManager.h; path = ../engine/rules/include/ActionManager.h; sourceTree = SOURCE_ROOT; };
-		444EAE060BD0E65B00C6D4A0 /* Armor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Armor.h; path = ../engine/rules/include/Armor.h; sourceTree = SOURCE_ROOT; };
-		444EAE070BD0E65B00C6D4A0 /* Combat.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Combat.h; path = ../engine/rules/include/Combat.h; sourceTree = SOURCE_ROOT; };
-		444EAE080BD0E65B00C6D4A0 /* CombatManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CombatManager.h; path = ../engine/rules/include/CombatManager.h; sourceTree = SOURCE_ROOT; };
-		444EAE090BD0E65B00C6D4A0 /* Container.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Container.h; path = ../engine/rules/include/Container.h; sourceTree = SOURCE_ROOT; };
-		444EAE0A0BD0E65B00C6D4A0 /* Creature.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Creature.h; path = ../engine/rules/include/Creature.h; sourceTree = SOURCE_ROOT; };
-		444EAE0B0BD0E65B00C6D4A0 /* Date.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Date.h; path = ../engine/rules/include/Date.h; sourceTree = SOURCE_ROOT; };
-		444EAE0C0BD0E65B00C6D4A0 /* DsaDataLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DsaDataLoader.h; path = ../engine/rules/include/DsaDataLoader.h; sourceTree = SOURCE_ROOT; };
-		444EAE0D0BD0E65B00C6D4A0 /* DsaManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DsaManager.h; path = ../engine/rules/include/DsaManager.h; sourceTree = SOURCE_ROOT; };
-		444EAE0E0BD0E65B00C6D4A0 /* Effect.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Effect.h; path = ../engine/rules/include/Effect.h; sourceTree = SOURCE_ROOT; };
-		444EAE0F0BD0E65B00C6D4A0 /* EffectManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EffectManager.h; path = ../engine/rules/include/EffectManager.h; sourceTree = SOURCE_ROOT; };
-		444EAE100BD0E65B00C6D4A0 /* Eigenschaft.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Eigenschaft.h; path = ../engine/rules/include/Eigenschaft.h; sourceTree = SOURCE_ROOT; };
-		444EAE110BD0E65B00C6D4A0 /* EigenschaftenStateSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EigenschaftenStateSet.h; path = ../engine/rules/include/EigenschaftenStateSet.h; sourceTree = SOURCE_ROOT; };
-		444EAE120BD0E65B00C6D4A0 /* GameObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameObject.h; path = ../engine/rules/include/GameObject.h; sourceTree = SOURCE_ROOT; };
-		444EAE130BD0E65B00C6D4A0 /* GameObjectManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameObjectManager.h; path = ../engine/rules/include/GameObjectManager.h; sourceTree = SOURCE_ROOT; };
-		444EAE160BD0E65B00C6D4A0 /* GameObjectStateListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameObjectStateListener.h; path = ../engine/rules/include/GameObjectStateListener.h; sourceTree = SOURCE_ROOT; };
-		444EAE170BD0E65B00C6D4A0 /* Inventory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Inventory.h; path = ../engine/rules/include/Inventory.h; sourceTree = SOURCE_ROOT; };
-		444EAE180BD0E65B00C6D4A0 /* Item.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Item.h; path = ../engine/rules/include/Item.h; sourceTree = SOURCE_ROOT; };
-		444EAE190BD0E65B00C6D4A0 /* JournalEntry.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JournalEntry.h; path = ../engine/rules/include/JournalEntry.h; sourceTree = SOURCE_ROOT; };
-		444EAE1A0BD0E65B00C6D4A0 /* Kampftechnik.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Kampftechnik.h; path = ../engine/rules/include/Kampftechnik.h; sourceTree = SOURCE_ROOT; };
-		444EAE1B0BD0E65B00C6D4A0 /* ObjectStateChangeEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ObjectStateChangeEvent.h; path = ../engine/rules/include/ObjectStateChangeEvent.h; sourceTree = SOURCE_ROOT; };
-		444EAE1C0BD0E65B00C6D4A0 /* ObjectStateChangeEventSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ObjectStateChangeEventSource.h; path = ../engine/rules/include/ObjectStateChangeEventSource.h; sourceTree = SOURCE_ROOT; };
-		444EAE1D0BD0E65B00C6D4A0 /* ObjectStateChangeListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ObjectStateChangeListener.h; path = ../engine/rules/include/ObjectStateChangeListener.h; sourceTree = SOURCE_ROOT; };
-		444EAE1F0BD0E65B00C6D4A0 /* Quest.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Quest.h; path = ../engine/rules/include/Quest.h; sourceTree = SOURCE_ROOT; };
-		444EAE200BD0E65B00C6D4A0 /* QuestBook.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuestBook.h; path = ../engine/rules/include/QuestBook.h; sourceTree = SOURCE_ROOT; };
-		444EAE210BD0E65B00C6D4A0 /* QuestEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuestEvent.h; path = ../engine/rules/include/QuestEvent.h; sourceTree = SOURCE_ROOT; };
-		444EAE220BD0E65B00C6D4A0 /* QuestListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = QuestListener.h; path = ../engine/rules/include/QuestListener.h; sourceTree = SOURCE_ROOT; };
-		444EAE230BD0E65B00C6D4A0 /* RulesPrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RulesPrerequisites.h; path = ../engine/rules/include/RulesPrerequisites.h; sourceTree = SOURCE_ROOT; };
-		444EAE240BD0E65B00C6D4A0 /* RulesSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RulesSubsystem.h; path = ../engine/rules/include/RulesSubsystem.h; sourceTree = SOURCE_ROOT; };
-		444EAE250BD0E65B00C6D4A0 /* Slot.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Slot.h; path = ../engine/rules/include/Slot.h; sourceTree = SOURCE_ROOT; };
-		444EAE260BD0E65B00C6D4A0 /* SonderfertigkeitenStateSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SonderfertigkeitenStateSet.h; path = ../engine/rules/include/SonderfertigkeitenStateSet.h; sourceTree = SOURCE_ROOT; };
-		444EAE270BD0E65B00C6D4A0 /* StateSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = StateSet.h; path = ../engine/rules/include/StateSet.h; sourceTree = SOURCE_ROOT; };
-		444EAE280BD0E65B00C6D4A0 /* Talent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Talent.h; path = ../engine/rules/include/Talent.h; sourceTree = SOURCE_ROOT; };
-		444EAE290BD0E65B00C6D4A0 /* Talentgruppe.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Talentgruppe.h; path = ../engine/rules/include/Talentgruppe.h; sourceTree = SOURCE_ROOT; };
-		444EAE2A0BD0E65B00C6D4A0 /* TalentInputIterator.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TalentInputIterator.h; path = ../engine/rules/include/TalentInputIterator.h; sourceTree = SOURCE_ROOT; };
-		444EAE2B0BD0E65B00C6D4A0 /* TalentStateSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = TalentStateSet.h; path = ../engine/rules/include/TalentStateSet.h; sourceTree = SOURCE_ROOT; };
-		444EAE300BD0E65B00C6D4A0 /* Weapon.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Weapon.h; path = ../engine/rules/include/Weapon.h; sourceTree = SOURCE_ROOT; };
-		444EAE310BD0E65B00C6D4A0 /* ZauberStateSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZauberStateSet.h; path = ../engine/rules/include/ZauberStateSet.h; sourceTree = SOURCE_ROOT; };
-		444EAE610BD0E6C000C6D4A0 /* ScriptObjectMarker.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ScriptObjectMarker.h; path = ../engine/script/include/ScriptObjectMarker.h; sourceTree = SOURCE_ROOT; };
-		444EAE620BD0E6C000C6D4A0 /* ScriptPrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ScriptPrerequisites.h; path = ../engine/script/include/ScriptPrerequisites.h; sourceTree = SOURCE_ROOT; };
-		444EAE630BD0E6C000C6D4A0 /* ScriptSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ScriptSubsystem.h; path = ../engine/script/include/ScriptSubsystem.h; sourceTree = SOURCE_ROOT; };
+		444EACA20BD0E57100C6D4A0 /* AboutWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = AboutWindow.cpp; sourceTree = "<group>"; };
+		444EACA30BD0E57100C6D4A0 /* AbstractWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = AbstractWindow.cpp; sourceTree = "<group>"; };
+		444EACA40BD0E57100C6D4A0 /* ActionChoiceWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ActionChoiceWindow.cpp; sourceTree = "<group>"; };
+		444EACA60BD0E57100C6D4A0 /* CharacterSheetWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CharacterSheetWindow.cpp; sourceTree = "<group>"; };
+		444EACA70BD0E57100C6D4A0 /* CharacterStateWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CharacterStateWindow.cpp; sourceTree = "<group>"; };
+		444EACA80BD0E57100C6D4A0 /* CloseConfirmationWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CloseConfirmationWindow.cpp; sourceTree = "<group>"; };
+		444EACAA0BD0E57100C6D4A0 /* CommandMapper.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CommandMapper.cpp; sourceTree = "<group>"; };
+		444EACAC0BD0E57100C6D4A0 /* ConfigComponent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ConfigComponent.cpp; sourceTree = "<group>"; };
+		444EACAD0BD0E57100C6D4A0 /* Console.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Console.cpp; sourceTree = "<group>"; };
+		444EACAE0BD0E57100C6D4A0 /* ContainerContentWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ContainerContentWindow.cpp; sourceTree = "<group>"; };
+		444EACB10BD0E57100C6D4A0 /* DebugWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DebugWindow.cpp; sourceTree = "<group>"; };
+		444EACB30BD0E57100C6D4A0 /* DialogWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DialogWindow.cpp; sourceTree = "<group>"; };
+		444EACB50BD0E57100C6D4A0 /* GameLoggerWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameLoggerWindow.cpp; sourceTree = "<group>"; };
+		444EACB60BD0E57100C6D4A0 /* GameObjectInfoWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameObjectInfoWindow.cpp; sourceTree = "<group>"; };
+		444EACB80BD0E57100C6D4A0 /* GameSettings.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameSettings.cpp; sourceTree = "<group>"; };
+		444EACB90BD0E57100C6D4A0 /* InfoPopup.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InfoPopup.cpp; sourceTree = "<group>"; };
+		444EACBA0BD0E57100C6D4A0 /* InGameMenuWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InGameMenuWindow.cpp; sourceTree = "<group>"; };
+		444EACBB0BD0E57100C6D4A0 /* InputManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InputManager.cpp; sourceTree = "<group>"; };
+		444EACBC0BD0E57100C6D4A0 /* InventoryWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = InventoryWindow.cpp; sourceTree = "<group>"; };
+		444EACBD0BD0E57100C6D4A0 /* ItemDragContainer.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ItemDragContainer.cpp; sourceTree = "<group>"; };
+		444EACBE0BD0E57100C6D4A0 /* JournalWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JournalWindow.cpp; sourceTree = "<group>"; };
+		444EACBF0BD0E57100C6D4A0 /* ListboxWrappedTextItem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ListboxWrappedTextItem.cpp; sourceTree = "<group>"; };
+		444EACC00BD0E57100C6D4A0 /* LogWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LogWindow.cpp; sourceTree = "<group>"; };
+		444EACC10BD0E57100C6D4A0 /* MainMenuEngineWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MainMenuEngineWindow.cpp; sourceTree = "<group>"; };
+		444EACC20BD0E57100C6D4A0 /* MainMenuWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MainMenuWindow.cpp; sourceTree = "<group>"; };
+		444EACC30BD0E57100C6D4A0 /* MessageWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MessageWindow.cpp; sourceTree = "<group>"; };
+		444EACC50BD0E57100C6D4A0 /* ObjectDescriptionWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ObjectDescriptionWindow.cpp; sourceTree = "<group>"; };
+		444EACC60BD0E57100C6D4A0 /* PlaylistWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PlaylistWindow.cpp; sourceTree = "<group>"; };
+		444EACC70BD0E57100C6D4A0 /* RenderSystemConfigComponent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = RenderSystemConfigComponent.cpp; sourceTree = "<group>"; };
+		444EACC90BD0E57100C6D4A0 /* SoundConfig.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundConfig.cpp; sourceTree = "<group>"; };
+		444EACCA0BD0E57100C6D4A0 /* SoundDriverConfigComponent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SoundDriverConfigComponent.cpp; sourceTree = "<group>"; };
+		444EACCB0BD0E57100C6D4A0 /* SubtitleWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SubtitleWindow.cpp; sourceTree = "<group>"; };
+		444EACCC0BD0E57100C6D4A0 /* UiSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = UiSubsystem.cpp; sourceTree = "<group>"; };
+		444EACCD0BD0E57100C6D4A0 /* WindowFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WindowFactory.cpp; sourceTree = "<group>"; };
+		444EACCE0BD0E57100C6D4A0 /* WindowFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WindowFadeJob.cpp; sourceTree = "<group>"; };
+		444EACCF0BD0E57100C6D4A0 /* WindowManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WindowManager.cpp; sourceTree = "<group>"; };
+		444EACFE0BD0E58C00C6D4A0 /* AboutWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AboutWindow.h; sourceTree = "<group>"; };
+		444EACFF0BD0E58C00C6D4A0 /* AbstractWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AbstractWindow.h; sourceTree = "<group>"; };
+		444EAD000BD0E58C00C6D4A0 /* ActionChoiceWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ActionChoiceWindow.h; sourceTree = "<group>"; };
+		444EAD010BD0E58C00C6D4A0 /* CeGuiHelper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CeGuiHelper.h; sourceTree = "<group>"; };
+		444EAD030BD0E58C00C6D4A0 /* CharacterSheetWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CharacterSheetWindow.h; sourceTree = "<group>"; };
+		444EAD040BD0E58C00C6D4A0 /* CharacterStateWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CharacterStateWindow.h; sourceTree = "<group>"; };
+		444EAD050BD0E58C00C6D4A0 /* CloseConfirmationWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CloseConfirmationWindow.h; sourceTree = "<group>"; };
+		444EAD070BD0E58C00C6D4A0 /* CommandMapper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CommandMapper.h; sourceTree = "<group>"; };
+		444EAD090BD0E58C00C6D4A0 /* ConfigComponent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ConfigComponent.h; sourceTree = "<group>"; };
+		444EAD0A0BD0E58C00C6D4A0 /* Console.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Console.h; sourceTree = "<group>"; };
+		444EAD0B0BD0E58C00C6D4A0 /* ContainerContentWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ContainerContentWindow.h; sourceTree = "<group>"; };
+		444EAD0E0BD0E58C00C6D4A0 /* DebugWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DebugWindow.h; sourceTree = "<group>"; };
+		444EAD100BD0E58C00C6D4A0 /* DialogWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DialogWindow.h; sourceTree = "<group>"; };
+		444EAD120BD0E58C00C6D4A0 /* GameLoggerWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameLoggerWindow.h; sourceTree = "<group>"; };
+		444EAD130BD0E58C00C6D4A0 /* GameObjectInfoWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameObjectInfoWindow.h; sourceTree = "<group>"; };
+		444EAD150BD0E58C00C6D4A0 /* GameSettings.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameSettings.h; sourceTree = "<group>"; };
+		444EAD160BD0E58C00C6D4A0 /* InfoPopup.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InfoPopup.h; sourceTree = "<group>"; };
+		444EAD170BD0E58C00C6D4A0 /* InGameMenuWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InGameMenuWindow.h; sourceTree = "<group>"; };
+		444EAD180BD0E58C00C6D4A0 /* InputManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InputManager.h; sourceTree = "<group>"; };
+		444EAD190BD0E58C00C6D4A0 /* InventoryWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = InventoryWindow.h; sourceTree = "<group>"; };
+		444EAD1A0BD0E58C00C6D4A0 /* ItemDragContainer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ItemDragContainer.h; sourceTree = "<group>"; };
+		444EAD1B0BD0E58C00C6D4A0 /* JournalWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JournalWindow.h; sourceTree = "<group>"; };
+		444EAD1C0BD0E58C00C6D4A0 /* ListboxWrappedTextItem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ListboxWrappedTextItem.h; sourceTree = "<group>"; };
+		444EAD1D0BD0E58C00C6D4A0 /* LogWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LogWindow.h; sourceTree = "<group>"; };
+		444EAD1E0BD0E58C00C6D4A0 /* MainMenuEngineWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MainMenuEngineWindow.h; sourceTree = "<group>"; };
+		444EAD1F0BD0E58C00C6D4A0 /* MainMenuWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MainMenuWindow.h; sourceTree = "<group>"; };
+		444EAD200BD0E58C00C6D4A0 /* MessageWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MessageWindow.h; sourceTree = "<group>"; };
+		444EAD220BD0E58C00C6D4A0 /* ObjectDescriptionWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ObjectDescriptionWindow.h; sourceTree = "<group>"; };
+		444EAD230BD0E58C00C6D4A0 /* PlaylistWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PlaylistWindow.h; sourceTree = "<group>"; };
+		444EAD240BD0E58C00C6D4A0 /* RenderSystemConfigComponent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = RenderSystemConfigComponent.h; sourceTree = "<group>"; };
+		444EAD260BD0E58C00C6D4A0 /* SoundConfig.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundConfig.h; sourceTree = "<group>"; };
+		444EAD270BD0E58C00C6D4A0 /* SoundDriverConfigComponent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SoundDriverConfigComponent.h; sourceTree = "<group>"; };
+		444EAD280BD0E58C00C6D4A0 /* SubtitleWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SubtitleWindow.h; sourceTree = "<group>"; };
+		444EAD290BD0E58C00C6D4A0 /* UiPrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = UiPrerequisites.h; sourceTree = "<group>"; };
+		444EAD2A0BD0E58C00C6D4A0 /* UiSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = UiSubsystem.h; sourceTree = "<group>"; };
+		444EAD2B0BD0E58C00C6D4A0 /* WindowFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WindowFactory.h; sourceTree = "<group>"; };
+		444EAD2C0BD0E58C00C6D4A0 /* WindowFadeJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WindowFadeJob.h; sourceTree = "<group>"; };
+		444EAD2D0BD0E58C00C6D4A0 /* WindowManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WindowManager.h; sourceTree = "<group>"; };
+		444EADB00BD0E64100C6D4A0 /* Action.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Action.cpp; sourceTree = "<group>"; };
+		444EADB10BD0E64100C6D4A0 /* ActionManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ActionManager.cpp; sourceTree = "<group>"; };
+		444EADB20BD0E64100C6D4A0 /* Armor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Armor.cpp; sourceTree = "<group>"; };
+		444EADB30BD0E64100C6D4A0 /* Combat.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Combat.cpp; sourceTree = "<group>"; };
+		444EADB40BD0E64100C6D4A0 /* CombatManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CombatManager.cpp; sourceTree = "<group>"; };
+		444EADB50BD0E64100C6D4A0 /* Container.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Container.cpp; sourceTree = "<group>"; };
+		444EADB60BD0E64100C6D4A0 /* Creature.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Creature.cpp; sourceTree = "<group>"; };
+		444EADB70BD0E64100C6D4A0 /* Date.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Date.cpp; sourceTree = "<group>"; };
+		444EADB80BD0E64100C6D4A0 /* DsaDataLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DsaDataLoader.cpp; sourceTree = "<group>"; };
+		444EADB90BD0E64100C6D4A0 /* DsaManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DsaManager.cpp; sourceTree = "<group>"; };
+		444EADBA0BD0E64100C6D4A0 /* Effect.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Effect.cpp; sourceTree = "<group>"; };
+		444EADBB0BD0E64100C6D4A0 /* EffectManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = EffectManager.cpp; sourceTree = "<group>"; };
+		444EADBC0BD0E64100C6D4A0 /* Eigenschaft.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Eigenschaft.cpp; sourceTree = "<group>"; };
+		444EADBD0BD0E64100C6D4A0 /* EigenschaftenStateSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = EigenschaftenStateSet.cpp; sourceTree = "<group>"; };
+		444EADBE0BD0E64100C6D4A0 /* GameObject.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameObject.cpp; sourceTree = "<group>"; };
+		444EADBF0BD0E64100C6D4A0 /* GameObjectManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameObjectManager.cpp; sourceTree = "<group>"; };
+		444EADC10BD0E64100C6D4A0 /* Inventory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Inventory.cpp; sourceTree = "<group>"; };
+		444EADC20BD0E64100C6D4A0 /* Item.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Item.cpp; sourceTree = "<group>"; };
+		444EADC30BD0E64100C6D4A0 /* JournalEntry.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JournalEntry.cpp; sourceTree = "<group>"; };
+		444EADC40BD0E64100C6D4A0 /* Kampftechnik.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Kampftechnik.cpp; sourceTree = "<group>"; };
+		444EADC50BD0E64100C6D4A0 /* ObjectStateChangeEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ObjectStateChangeEvent.cpp; sourceTree = "<group>"; };
+		444EADC60BD0E64100C6D4A0 /* ObjectStateChangeEventSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ObjectStateChangeEventSource.cpp; sourceTree = "<group>"; };
+		444EADC70BD0E64100C6D4A0 /* ObjectStateChangeListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ObjectStateChangeListener.cpp; sourceTree = "<group>"; };
+		444EADC90BD0E64100C6D4A0 /* Quest.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Quest.cpp; sourceTree = "<group>"; };
+		444EADCA0BD0E64100C6D4A0 /* QuestBook.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = QuestBook.cpp; sourceTree = "<group>"; };
+		444EADCB0BD0E64100C6D4A0 /* QuestEvent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = QuestEvent.cpp; sourceTree = "<group>"; };
+		444EADCC0BD0E64100C6D4A0 /* QuestListener.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = QuestListener.cpp; sourceTree = "<group>"; };
+		444EADCD0BD0E64100C6D4A0 /* RulesSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = RulesSubsystem.cpp; sourceTree = "<group>"; };
+		444EADCE0BD0E64100C6D4A0 /* Slot.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Slot.cpp; sourceTree = "<group>"; };
+		444EADCF0BD0E64100C6D4A0 /* SonderfertigkeitenStateSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SonderfertigkeitenStateSet.cpp; sourceTree = "<group>"; };
+		444EADD00BD0E64100C6D4A0 /* StateSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = StateSet.cpp; sourceTree = "<group>"; };
+		444EADD10BD0E64100C6D4A0 /* Talent.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Talent.cpp; sourceTree = "<group>"; };
+		444EADD20BD0E64100C6D4A0 /* Talentgruppe.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Talentgruppe.cpp; sourceTree = "<group>"; };
+		444EADD30BD0E64100C6D4A0 /* TalentStateSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = TalentStateSet.cpp; sourceTree = "<group>"; };
+		444EADD80BD0E64100C6D4A0 /* Weapon.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Weapon.cpp; sourceTree = "<group>"; };
+		444EADD90BD0E64100C6D4A0 /* ZauberStateSet.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ZauberStateSet.cpp; sourceTree = "<group>"; };
+		444EAE040BD0E65B00C6D4A0 /* Action.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Action.h; sourceTree = "<group>"; };
+		444EAE050BD0E65B00C6D4A0 /* ActionManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ActionManager.h; sourceTree = "<group>"; };
+		444EAE060BD0E65B00C6D4A0 /* Armor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Armor.h; sourceTree = "<group>"; };
+		444EAE070BD0E65B00C6D4A0 /* Combat.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Combat.h; sourceTree = "<group>"; };
+		444EAE080BD0E65B00C6D4A0 /* CombatManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CombatManager.h; sourceTree = "<group>"; };
+		444EAE090BD0E65B00C6D4A0 /* Container.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Container.h; sourceTree = "<group>"; };
+		444EAE0A0BD0E65B00C6D4A0 /* Creature.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Creature.h; sourceTree = "<group>"; };
+		444EAE0B0BD0E65B00C6D4A0 /* Date.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Date.h; sourceTree = "<group>"; };
+		444EAE0C0BD0E65B00C6D4A0 /* DsaDataLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DsaDataLoader.h; sourceTree = "<group>"; };
+		444EAE0D0BD0E65B00C6D4A0 /* DsaManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DsaManager.h; sourceTree = "<group>"; };
+		444EAE0E0BD0E65B00C6D4A0 /* Effect.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Effect.h; sourceTree = "<group>"; };
+		444EAE0F0BD0E65B00C6D4A0 /* EffectManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EffectManager.h; sourceTree = "<group>"; };
+		444EAE100BD0E65B00C6D4A0 /* Eigenschaft.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Eigenschaft.h; sourceTree = "<group>"; };
+		444EAE110BD0E65B00C6D4A0 /* EigenschaftenStateSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EigenschaftenStateSet.h; sourceTree = "<group>"; };
+		444EAE120BD0E65B00C6D4A0 /* GameObject.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameObject.h; sourceTree = "<group>"; };
+		444EAE130BD0E65B00C6D4A0 /* GameObjectManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameObjectManager.h; sourceTree = "<group>"; };
+		444EAE160BD0E65B00C6D4A0 /* GameObjectStateListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameObjectStateListener.h; sourceTree = "<group>"; };
+		444EAE170BD0E65B00C6D4A0 /* Inventory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Inventory.h; sourceTree = "<group>"; };
+		444EAE180BD0E65B00C6D4A0 /* Item.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Item.h; sourceTree = "<group>"; };
+		444EAE190BD0E65B00C6D4A0 /* JournalEntry.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JournalEntry.h; sourceTree = "<group>"; };
+		444EAE1A0BD0E65B00C6D4A0 /* Kampftechnik.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Kampftechnik.h; sourceTree = "<group>"; };
+		444EAE1B0BD0E65B00C6D4A0 /* ObjectStateChangeEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ObjectStateChangeEvent.h; sourceTree = "<group>"; };
+		444EAE1C0BD0E65B00C6D4A0 /* ObjectStateChangeEventSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ObjectStateChangeEventSource.h; sourceTree = "<group>"; };
+		444EAE1D0BD0E65B00C6D4A0 /* ObjectStateChangeListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ObjectStateChangeListener.h; sourceTree = "<group>"; };
+		444EAE1F0BD0E65B00C6D4A0 /* Quest.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Quest.h; sourceTree = "<group>"; };
+		444EAE200BD0E65B00C6D4A0 /* QuestBook.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = QuestBook.h; sourceTree = "<group>"; };
+		444EAE210BD0E65B00C6D4A0 /* QuestEvent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = QuestEvent.h; sourceTree = "<group>"; };
+		444EAE220BD0E65B00C6D4A0 /* QuestListener.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = QuestListener.h; sourceTree = "<group>"; };
+		444EAE230BD0E65B00C6D4A0 /* RulesPrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = RulesPrerequisites.h; sourceTree = "<group>"; };
+		444EAE240BD0E65B00C6D4A0 /* RulesSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = RulesSubsystem.h; sourceTree = "<group>"; };
+		444EAE250BD0E65B00C6D4A0 /* Slot.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Slot.h; sourceTree = "<group>"; };
+		444EAE260BD0E65B00C6D4A0 /* SonderfertigkeitenStateSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SonderfertigkeitenStateSet.h; sourceTree = "<group>"; };
+		444EAE270BD0E65B00C6D4A0 /* StateSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StateSet.h; sourceTree = "<group>"; };
+		444EAE280BD0E65B00C6D4A0 /* Talent.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Talent.h; sourceTree = "<group>"; };
+		444EAE290BD0E65B00C6D4A0 /* Talentgruppe.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Talentgruppe.h; sourceTree = "<group>"; };
+		444EAE2A0BD0E65B00C6D4A0 /* TalentInputIterator.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TalentInputIterator.h; sourceTree = "<group>"; };
+		444EAE2B0BD0E65B00C6D4A0 /* TalentStateSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = TalentStateSet.h; sourceTree = "<group>"; };
+		444EAE300BD0E65B00C6D4A0 /* Weapon.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Weapon.h; sourceTree = "<group>"; };
+		444EAE310BD0E65B00C6D4A0 /* ZauberStateSet.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ZauberStateSet.h; sourceTree = "<group>"; };
+		444EAE610BD0E6C000C6D4A0 /* ScriptObjectMarker.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ScriptObjectMarker.h; path = script/include/ScriptObjectMarker.h; sourceTree = "<group>"; };
+		444EAE620BD0E6C000C6D4A0 /* ScriptPrerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ScriptPrerequisites.h; path = script/include/ScriptPrerequisites.h; sourceTree = "<group>"; };
+		444EAE630BD0E6C000C6D4A0 /* ScriptSubsystem.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ScriptSubsystem.h; path = script/include/ScriptSubsystem.h; sourceTree = "<group>"; };
 		444EAE670BD0E6D400C6D4A0 /* ScriptObjectMarker.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ScriptObjectMarker.cpp; path = ../engine/script/src/ScriptObjectMarker.cpp; sourceTree = SOURCE_ROOT; };
 		444EAE680BD0E6D400C6D4A0 /* ScriptSubsystem.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ScriptSubsystem.cpp; path = ../engine/script/src/ScriptSubsystem.cpp; sourceTree = SOURCE_ROOT; };
 		444EAEBD0BD0F09900C6D4A0 /* CEGUI.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CEGUI.framework; path = /Library/Frameworks/CEGUI.framework; sourceTree = "<absolute>"; };
@@ -1262,37 +1263,37 @@
 		446BF46F0C4532120013C214 /* LinearSoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LinearSoundFadeFunctor.cpp; path = ../engine/core/src/LinearSoundFadeFunctor.cpp; sourceTree = SOURCE_ROOT; };
 		446BF4700C4532120013C214 /* SoundFadeFunctor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundFadeFunctor.cpp; path = ../engine/core/src/SoundFadeFunctor.cpp; sourceTree = SOURCE_ROOT; };
 		446BF4710C4532120013C214 /* SoundFadeJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SoundFadeJob.cpp; path = ../engine/core/src/SoundFadeJob.cpp; sourceTree = SOURCE_ROOT; };
-		446BF4750C4532720013C214 /* CreatureController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CreatureController.h; path = ../engine/rules/include/CreatureController.h; sourceTree = SOURCE_ROOT; };
-		446BF4760C4532720013C214 /* CreatureControllerManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CreatureControllerManager.h; path = ../engine/rules/include/CreatureControllerManager.h; sourceTree = SOURCE_ROOT; };
-		446BF4770C4532720013C214 /* EffectFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EffectFactory.h; path = ../engine/rules/include/EffectFactory.h; sourceTree = SOURCE_ROOT; };
-		446BF47B0C45329F0013C214 /* CreatureController.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CreatureController.cpp; path = ../engine/rules/src/CreatureController.cpp; sourceTree = SOURCE_ROOT; };
-		446BF47C0C45329F0013C214 /* CreatureControllerManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CreatureControllerManager.cpp; path = ../engine/rules/src/CreatureControllerManager.cpp; sourceTree = SOURCE_ROOT; };
-		446BF47D0C45329F0013C214 /* EffectFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = EffectFactory.cpp; path = ../engine/rules/src/EffectFactory.cpp; sourceTree = SOURCE_ROOT; };
+		446BF4750C4532720013C214 /* CreatureController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CreatureController.h; sourceTree = "<group>"; };
+		446BF4760C4532720013C214 /* CreatureControllerManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CreatureControllerManager.h; sourceTree = "<group>"; };
+		446BF4770C4532720013C214 /* EffectFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EffectFactory.h; sourceTree = "<group>"; };
+		446BF47B0C45329F0013C214 /* CreatureController.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CreatureController.cpp; sourceTree = "<group>"; };
+		446BF47C0C45329F0013C214 /* CreatureControllerManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CreatureControllerManager.cpp; sourceTree = "<group>"; };
+		446BF47D0C45329F0013C214 /* EffectFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = EffectFactory.cpp; sourceTree = "<group>"; };
 		446BF4810C4532B50013C214 /* UnifiedFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = UnifiedFactory.h; path = ../engine/script/include/UnifiedFactory.h; sourceTree = SOURCE_ROOT; };
-		446BF4840C45335A0013C214 /* ControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ControlState.h; path = ../engine/ui/include/ControlState.h; sourceTree = SOURCE_ROOT; };
-		446BF4850C45335A0013C214 /* CutsceneControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CutsceneControlState.h; path = ../engine/ui/include/CutsceneControlState.h; sourceTree = SOURCE_ROOT; };
-		446BF4860C45335A0013C214 /* DialogControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = DialogControlState.h; path = ../engine/ui/include/DialogControlState.h; sourceTree = SOURCE_ROOT; };
-		446BF4870C45335A0013C214 /* FreeflightControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = FreeflightControlState.h; path = ../engine/ui/include/FreeflightControlState.h; sourceTree = SOURCE_ROOT; };
-		446BF4880C45335A0013C214 /* ItemDescriptionDragContainer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ItemDescriptionDragContainer.h; path = ../engine/ui/include/ItemDescriptionDragContainer.h; sourceTree = SOURCE_ROOT; };
-		446BF4890C45335A0013C214 /* ItemIconDragContainer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ItemIconDragContainer.h; path = ../engine/ui/include/ItemIconDragContainer.h; sourceTree = SOURCE_ROOT; };
-		446BF48A0C45335A0013C214 /* MovementControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MovementControlState.h; path = ../engine/ui/include/MovementControlState.h; sourceTree = SOURCE_ROOT; };
-		446BF48B0C45335A0013C214 /* PropertiesWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PropertiesWindow.h; path = ../engine/ui/include/PropertiesWindow.h; sourceTree = SOURCE_ROOT; };
-		446BF4940C4533BD0013C214 /* CombatControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CombatControlState.cpp; path = ../engine/ui/src/CombatControlState.cpp; sourceTree = SOURCE_ROOT; };
-		446BF4950C4533BD0013C214 /* CombatWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CombatWindow.cpp; path = ../engine/ui/src/CombatWindow.cpp; sourceTree = SOURCE_ROOT; };
-		446BF4960C4533BD0013C214 /* ControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ControlState.cpp; path = ../engine/ui/src/ControlState.cpp; sourceTree = SOURCE_ROOT; };
-		446BF4970C4533BD0013C214 /* CutsceneControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CutsceneControlState.cpp; path = ../engine/ui/src/CutsceneControlState.cpp; sourceTree = SOURCE_ROOT; };
-		446BF4980C4533BD0013C214 /* DialogControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogControlState.cpp; path = ../engine/ui/src/DialogControlState.cpp; sourceTree = SOURCE_ROOT; };
-		446BF4990C4533BD0013C214 /* FreeflightControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = FreeflightControlState.cpp; path = ../engine/ui/src/FreeflightControlState.cpp; sourceTree = SOURCE_ROOT; };
-		446BF49A0C4533BD0013C214 /* ItemIconDragContainer.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ItemIconDragContainer.cpp; path = ../engine/ui/src/ItemIconDragContainer.cpp; sourceTree = SOURCE_ROOT; };
-		446BF49B0C4533BD0013C214 /* MovementControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MovementControlState.cpp; path = ../engine/ui/src/MovementControlState.cpp; sourceTree = SOURCE_ROOT; };
-		446BF49C0C4533BD0013C214 /* PropertiesWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PropertiesWindow.cpp; path = ../engine/ui/src/PropertiesWindow.cpp; sourceTree = SOURCE_ROOT; };
-		446BF4D00C453B9E0013C214 /* CombatControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CombatControlState.h; path = ../engine/ui/include/CombatControlState.h; sourceTree = SOURCE_ROOT; };
-		446BF4D10C453B9E0013C214 /* CombatWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CombatWindow.h; path = ../engine/ui/include/CombatWindow.h; sourceTree = SOURCE_ROOT; };
-		446BF4D50C453C1D0013C214 /* ItemDescriptionDragContainer.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ItemDescriptionDragContainer.cpp; path = ../engine/ui/src/ItemDescriptionDragContainer.cpp; sourceTree = SOURCE_ROOT; };
-		44D8145A0BF7B52600534175 /* SelectionHelper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SelectionHelper.h; path = ../engine/rules/include/SelectionHelper.h; sourceTree = SOURCE_ROOT; };
-		44D8145B0BF7B52600534175 /* Selector.h */ = {isa = PBXFileReference; explicitFileType = sourcecode.c.h; fileEncoding = 4; name = Selector.h; path = ../engine/rules/include/Selector.h; sourceTree = SOURCE_ROOT; };
-		44D8145F0BF7B58A00534175 /* ProgressWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ProgressWindow.h; path = ../engine/ui/include/ProgressWindow.h; sourceTree = SOURCE_ROOT; };
-		44D814630BF7B5AD00534175 /* ProgressWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ProgressWindow.cpp; path = ../engine/ui/src/ProgressWindow.cpp; sourceTree = SOURCE_ROOT; };
+		446BF4840C45335A0013C214 /* ControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ControlState.h; sourceTree = "<group>"; };
+		446BF4850C45335A0013C214 /* CutsceneControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CutsceneControlState.h; sourceTree = "<group>"; };
+		446BF4860C45335A0013C214 /* DialogControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = DialogControlState.h; sourceTree = "<group>"; };
+		446BF4870C45335A0013C214 /* FreeflightControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FreeflightControlState.h; sourceTree = "<group>"; };
+		446BF4880C45335A0013C214 /* ItemDescriptionDragContainer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ItemDescriptionDragContainer.h; sourceTree = "<group>"; };
+		446BF4890C45335A0013C214 /* ItemIconDragContainer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ItemIconDragContainer.h; sourceTree = "<group>"; };
+		446BF48A0C45335A0013C214 /* MovementControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MovementControlState.h; sourceTree = "<group>"; };
+		446BF48B0C45335A0013C214 /* PropertiesWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PropertiesWindow.h; sourceTree = "<group>"; };
+		446BF4940C4533BD0013C214 /* CombatControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CombatControlState.cpp; sourceTree = "<group>"; };
+		446BF4950C4533BD0013C214 /* CombatWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CombatWindow.cpp; sourceTree = "<group>"; };
+		446BF4960C4533BD0013C214 /* ControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ControlState.cpp; sourceTree = "<group>"; };
+		446BF4970C4533BD0013C214 /* CutsceneControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CutsceneControlState.cpp; sourceTree = "<group>"; };
+		446BF4980C4533BD0013C214 /* DialogControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = DialogControlState.cpp; sourceTree = "<group>"; };
+		446BF4990C4533BD0013C214 /* FreeflightControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FreeflightControlState.cpp; sourceTree = "<group>"; };
+		446BF49A0C4533BD0013C214 /* ItemIconDragContainer.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ItemIconDragContainer.cpp; sourceTree = "<group>"; };
+		446BF49B0C4533BD0013C214 /* MovementControlState.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MovementControlState.cpp; sourceTree = "<group>"; };
+		446BF49C0C4533BD0013C214 /* PropertiesWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PropertiesWindow.cpp; sourceTree = "<group>"; };
+		446BF4D00C453B9E0013C214 /* CombatControlState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CombatControlState.h; sourceTree = "<group>"; };
+		446BF4D10C453B9E0013C214 /* CombatWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CombatWindow.h; sourceTree = "<group>"; };
+		446BF4D50C453C1D0013C214 /* ItemDescriptionDragContainer.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ItemDescriptionDragContainer.cpp; sourceTree = "<group>"; };
+		44D8145A0BF7B52600534175 /* SelectionHelper.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SelectionHelper.h; sourceTree = "<group>"; };
+		44D8145B0BF7B52600534175 /* Selector.h */ = {isa = PBXFileReference; explicitFileType = sourcecode.c.h; fileEncoding = 4; path = Selector.h; sourceTree = "<group>"; };
+		44D8145F0BF7B58A00534175 /* ProgressWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ProgressWindow.h; sourceTree = "<group>"; };
+		44D814630BF7B5AD00534175 /* ProgressWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ProgressWindow.cpp; sourceTree = "<group>"; };
 		44D814670BF7B5C700534175 /* Landmark.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Landmark.cpp; path = ../engine/ai/src/Landmark.cpp; sourceTree = SOURCE_ROOT; };
 		44D814680BF7B5C700534175 /* LandmarkPath.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LandmarkPath.cpp; path = ../engine/ai/src/LandmarkPath.cpp; sourceTree = SOURCE_ROOT; };
 		44D8146B0BF7B5E800534175 /* Landmark.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Landmark.h; path = ../engine/ai/include/Landmark.h; sourceTree = SOURCE_ROOT; };
@@ -1304,7 +1305,6 @@
 		44D814750BF7B62F00534175 /* Trigger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Trigger.h; path = ../engine/core/include/Trigger.h; sourceTree = SOURCE_ROOT; };
 		44D814760BF7B62F00534175 /* Zone.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Zone.h; path = ../engine/core/include/Zone.h; sourceTree = SOURCE_ROOT; };
 		44D814770BF7B62F00534175 /* ZoneManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ZoneManager.h; path = ../engine/core/include/ZoneManager.h; sourceTree = SOURCE_ROOT; };
-		4835559A0E6ABED100008748 /* mkdmg.sh */ = {isa = PBXFileReference; explicitFileType = text.script.sh; fileEncoding = 4; name = mkdmg.sh; path = tools/mkdmg.sh; sourceTree = "<group>"; };
 		483646960D83D13700912FEC /* ContentLoader.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ContentLoader.h; path = ../engine/core/include/ContentLoader.h; sourceTree = SOURCE_ROOT; };
 		483646970D83D13700912FEC /* SoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SoundStitching.h; path = ../engine/core/include/SoundStitching.h; sourceTree = SOURCE_ROOT; };
 		483646980D83D13700912FEC /* StartAnimationJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = StartAnimationJob.h; path = ../engine/core/include/StartAnimationJob.h; sourceTree = SOURCE_ROOT; };
@@ -1313,14 +1313,14 @@
 		483646A10D83D57800912FEC /* libruby.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libruby.dylib; path = /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/libruby.dylib; sourceTree = "<absolute>"; };
 		4836CBC80D8FB0BE002FE5D7 /* Xerces.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Xerces.framework; path = /Library/Frameworks/Xerces.framework; sourceTree = "<absolute>"; };
 		48380B180D800EED0013EE0C /* StartAnimationJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = StartAnimationJob.cpp; path = ../engine/core/src/StartAnimationJob.cpp; sourceTree = SOURCE_ROOT; };
-		48389B8E0D86741F00AFAB66 /* CombatGui.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = CombatGui.cpp; path = ../engine/ui/src/CombatGui.cpp; sourceTree = SOURCE_ROOT; };
-		48389B8F0D86741F00AFAB66 /* GameSaveLoadWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameSaveLoadWindow.cpp; path = ../engine/ui/src/GameSaveLoadWindow.cpp; sourceTree = SOURCE_ROOT; };
-		48389B900D86741F00AFAB66 /* MainMenuLoadWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = MainMenuLoadWindow.cpp; path = ../engine/ui/src/MainMenuLoadWindow.cpp; sourceTree = SOURCE_ROOT; };
-		48389B910D86741F00AFAB66 /* stdinc.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = stdinc.cpp; path = ../engine/ui/src/stdinc.cpp; sourceTree = SOURCE_ROOT; };
-		48389B960D86743900AFAB66 /* CombatGui.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = CombatGui.h; path = ../engine/ui/include/CombatGui.h; sourceTree = SOURCE_ROOT; };
-		48389B970D86743900AFAB66 /* GameSaveLoadWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameSaveLoadWindow.h; path = ../engine/ui/include/GameSaveLoadWindow.h; sourceTree = SOURCE_ROOT; };
-		48389B980D86743900AFAB66 /* MainMenuLoadWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = MainMenuLoadWindow.h; path = ../engine/ui/include/MainMenuLoadWindow.h; sourceTree = SOURCE_ROOT; };
-		48389B990D86743900AFAB66 /* UiMessages.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = UiMessages.h; path = ../engine/ui/include/UiMessages.h; sourceTree = SOURCE_ROOT; };
+		48389B8E0D86741F00AFAB66 /* CombatGui.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CombatGui.cpp; sourceTree = "<group>"; };
+		48389B8F0D86741F00AFAB66 /* GameSaveLoadWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameSaveLoadWindow.cpp; sourceTree = "<group>"; };
+		48389B900D86741F00AFAB66 /* MainMenuLoadWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = MainMenuLoadWindow.cpp; sourceTree = "<group>"; };
+		48389B910D86741F00AFAB66 /* stdinc.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = stdinc.cpp; sourceTree = "<group>"; };
+		48389B960D86743900AFAB66 /* CombatGui.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CombatGui.h; sourceTree = "<group>"; };
+		48389B970D86743900AFAB66 /* GameSaveLoadWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameSaveLoadWindow.h; sourceTree = "<group>"; };
+		48389B980D86743900AFAB66 /* MainMenuLoadWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = MainMenuLoadWindow.h; sourceTree = "<group>"; };
+		48389B990D86743900AFAB66 /* UiMessages.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = UiMessages.h; sourceTree = "<group>"; };
 		48389BE80D8677EE00AFAB66 /* RlAi.head.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = RlAi.head.swig; path = ../engine/script/swig/RlAi.head.swig; sourceTree = SOURCE_ROOT; };
 		48389BE90D8677EE00AFAB66 /* RlAi.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = RlAi.swig; path = ../engine/script/swig/RlAi.swig; sourceTree = SOURCE_ROOT; };
 		48389BEA0D8677EE00AFAB66 /* RlCommon.head.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = RlCommon.head.swig; path = ../engine/script/swig/RlCommon.head.swig; sourceTree = SOURCE_ROOT; };
@@ -1353,25 +1353,25 @@
 		48389C1A0D867AA900AFAB66 /* TriggerFactory.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = TriggerFactory.cpp; path = ../engine/script/src/TriggerFactory.cpp; sourceTree = SOURCE_ROOT; };
 		483D31100D85B1AF003477A0 /* NullSoundStitching.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = NullSoundStitching.h; path = ../engine/core/include/nulldriver/NullSoundStitching.h; sourceTree = SOURCE_ROOT; };
 		483D31120D85B1C2003477A0 /* NullSoundStitching.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = NullSoundStitching.cpp; path = ../engine/core/src/nulldriver/NullSoundStitching.cpp; sourceTree = SOURCE_ROOT; };
-		483D31150D85B215003477A0 /* Combatant.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Combatant.h; path = ../engine/rules/include/Combatant.h; sourceTree = SOURCE_ROOT; };
-		483D31160D85B215003477A0 /* EffectManagementTask.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = EffectManagementTask.h; path = ../engine/rules/include/EffectManagementTask.h; sourceTree = SOURCE_ROOT; };
-		483D31170D85B215003477A0 /* GameEventLog.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameEventLog.h; path = ../engine/rules/include/GameEventLog.h; sourceTree = SOURCE_ROOT; };
-		483D31180D85B215003477A0 /* GameTimeSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameTimeSource.h; path = ../engine/rules/include/GameTimeSource.h; sourceTree = SOURCE_ROOT; };
-		483D31190D85B215003477A0 /* GlobalProperties.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GlobalProperties.h; path = ../engine/rules/include/GlobalProperties.h; sourceTree = SOURCE_ROOT; };
-		483D311A0D85B215003477A0 /* GoToJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GoToJob.h; path = ../engine/rules/include/GoToJob.h; sourceTree = SOURCE_ROOT; };
-		483D311B0D85B215003477A0 /* Kampfaktion.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = Kampfaktion.h; path = ../engine/rules/include/Kampfaktion.h; sourceTree = SOURCE_ROOT; };
-		483D311C0D85B215003477A0 /* RulesConstants.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RulesConstants.h; path = ../engine/rules/include/RulesConstants.h; sourceTree = SOURCE_ROOT; };
-		483D311D0D85B215003477A0 /* RulesMessages.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RulesMessages.h; path = ../engine/rules/include/RulesMessages.h; sourceTree = SOURCE_ROOT; };
-		483D311E0D85B215003477A0 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = stdinc.h; path = ../engine/rules/include/stdinc.h; sourceTree = SOURCE_ROOT; };
-		483D311F0D85B215003477A0 /* WaitJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WaitJob.h; path = ../engine/rules/include/WaitJob.h; sourceTree = SOURCE_ROOT; };
-		483D312B0D85B22C003477A0 /* Combatant.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Combatant.cpp; path = ../engine/rules/src/Combatant.cpp; sourceTree = SOURCE_ROOT; };
-		483D312C0D85B22C003477A0 /* EffectManagementTask.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = EffectManagementTask.cpp; path = ../engine/rules/src/EffectManagementTask.cpp; sourceTree = SOURCE_ROOT; };
-		483D312D0D85B22C003477A0 /* GameEventLog.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameEventLog.cpp; path = ../engine/rules/src/GameEventLog.cpp; sourceTree = SOURCE_ROOT; };
-		483D312E0D85B22C003477A0 /* GameTimeSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameTimeSource.cpp; path = ../engine/rules/src/GameTimeSource.cpp; sourceTree = SOURCE_ROOT; };
-		483D312F0D85B22C003477A0 /* GlobalProperties.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GlobalProperties.cpp; path = ../engine/rules/src/GlobalProperties.cpp; sourceTree = SOURCE_ROOT; };
-		483D31300D85B22C003477A0 /* GoToJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GoToJob.cpp; path = ../engine/rules/src/GoToJob.cpp; sourceTree = SOURCE_ROOT; };
-		483D31310D85B22C003477A0 /* Kampfaktion.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Kampfaktion.cpp; path = ../engine/rules/src/Kampfaktion.cpp; sourceTree = SOURCE_ROOT; };
-		483D31320D85B22C003477A0 /* WaitJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WaitJob.cpp; path = ../engine/rules/src/WaitJob.cpp; sourceTree = SOURCE_ROOT; };
+		483D31150D85B215003477A0 /* Combatant.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Combatant.h; sourceTree = "<group>"; };
+		483D31160D85B215003477A0 /* EffectManagementTask.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = EffectManagementTask.h; sourceTree = "<group>"; };
+		483D31170D85B215003477A0 /* GameEventLog.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameEventLog.h; sourceTree = "<group>"; };
+		483D31180D85B215003477A0 /* GameTimeSource.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameTimeSource.h; sourceTree = "<group>"; };
+		483D31190D85B215003477A0 /* GlobalProperties.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GlobalProperties.h; sourceTree = "<group>"; };
+		483D311A0D85B215003477A0 /* GoToJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GoToJob.h; sourceTree = "<group>"; };
+		483D311B0D85B215003477A0 /* Kampfaktion.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = Kampfaktion.h; sourceTree = "<group>"; };
+		483D311C0D85B215003477A0 /* RulesConstants.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = RulesConstants.h; sourceTree = "<group>"; };
+		483D311D0D85B215003477A0 /* RulesMessages.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = RulesMessages.h; sourceTree = "<group>"; };
+		483D311E0D85B215003477A0 /* stdinc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = stdinc.h; sourceTree = "<group>"; };
+		483D311F0D85B215003477A0 /* WaitJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WaitJob.h; sourceTree = "<group>"; };
+		483D312B0D85B22C003477A0 /* Combatant.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Combatant.cpp; sourceTree = "<group>"; };
+		483D312C0D85B22C003477A0 /* EffectManagementTask.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = EffectManagementTask.cpp; sourceTree = "<group>"; };
+		483D312D0D85B22C003477A0 /* GameEventLog.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameEventLog.cpp; sourceTree = "<group>"; };
+		483D312E0D85B22C003477A0 /* GameTimeSource.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameTimeSource.cpp; sourceTree = "<group>"; };
+		483D312F0D85B22C003477A0 /* GlobalProperties.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GlobalProperties.cpp; sourceTree = "<group>"; };
+		483D31300D85B22C003477A0 /* GoToJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GoToJob.cpp; sourceTree = "<group>"; };
+		483D31310D85B22C003477A0 /* Kampfaktion.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = Kampfaktion.cpp; sourceTree = "<group>"; };
+		483D31320D85B22C003477A0 /* WaitJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WaitJob.cpp; sourceTree = "<group>"; };
 		483D31450D85B398003477A0 /* AgentCombatState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AgentCombatState.h; path = ../engine/ai/include/AgentCombatState.h; sourceTree = SOURCE_ROOT; };
 		483D31460D85B398003477A0 /* AgentDialogState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AgentDialogState.h; path = ../engine/ai/include/AgentDialogState.h; sourceTree = SOURCE_ROOT; };
 		483D31470D85B398003477A0 /* AgentState.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AgentState.h; path = ../engine/ai/include/AgentState.h; sourceTree = SOURCE_ROOT; };
@@ -1447,49 +1447,49 @@
 		485B89570E15796500D5B19C /* Scene.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = Scene.cpp; path = ../engine/script/src/Scene.cpp; sourceTree = SOURCE_ROOT; };
 		485B89580E15796500D5B19C /* SceneLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SceneLoader.cpp; path = ../engine/script/src/SceneLoader.cpp; sourceTree = SOURCE_ROOT; };
 		485B89590E15796500D5B19C /* SceneManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SceneManager.cpp; path = ../engine/script/src/SceneManager.cpp; sourceTree = SOURCE_ROOT; };
-		487029C60E80DCEA00B66388 /* GameOverWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = GameOverWindow.h; path = ../engine/ui/include/GameOverWindow.h; sourceTree = SOURCE_ROOT; };
-		487029C80E80DCF900B66388 /* GameOverWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = GameOverWindow.cpp; path = ../engine/ui/src/GameOverWindow.cpp; sourceTree = SOURCE_ROOT; };
-		487029E70E80E12200B66388 /* PartyManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PartyManager.h; path = ../engine/rules/include/PartyManager.h; sourceTree = SOURCE_ROOT; };
-		487029E90E80E13300B66388 /* PartyManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PartyManager.cpp; path = ../engine/rules/src/PartyManager.cpp; sourceTree = SOURCE_ROOT; };
+		487029C60E80DCEA00B66388 /* GameOverWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = GameOverWindow.h; sourceTree = "<group>"; };
+		487029C80E80DCF900B66388 /* GameOverWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = GameOverWindow.cpp; sourceTree = "<group>"; };
+		487029E70E80E12200B66388 /* PartyManager.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = PartyManager.h; sourceTree = "<group>"; };
+		487029E90E80E13300B66388 /* PartyManager.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = PartyManager.cpp; sourceTree = "<group>"; };
 		48760A990D92E2CD00BEB57C /* RlUi.swig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text; name = RlUi.swig; path = ../engine/script/swig/RlUi.swig; sourceTree = SOURCE_ROOT; };
 		48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */ = {isa = PBXFileReference; explicitFileType = sourcecode.cpp.cpp; fileEncoding = 4; includeInIndex = 0; name = RlExports_wrap.cxx; path = ../engine/script/swig/RlExports_wrap.cxx; sourceTree = SOURCE_ROOT; };
 		48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RlExports_wrap.h; path = ../engine/script/swig/RlExports_wrap.h; sourceTree = SOURCE_ROOT; };
 		487750AF0E7E3C9C0018216B /* Cg.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cg.framework; path = /Library/Frameworks/Cg.framework; sourceTree = "<absolute>"; };
-		4890C0A70E18061300BE5850 /* AbstractMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = AbstractMovement.h; path = ../engine/rules/include/AbstractMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0A80E18061300BE5850 /* FallDownMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = FallDownMovement.h; path = ../engine/rules/include/FallDownMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JogBackwardsMovement.h; path = ../engine/rules/include/JogBackwardsMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0AA0E18061300BE5850 /* JogFastMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JogFastMovement.h; path = ../engine/rules/include/JogFastMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0AB0E18061300BE5850 /* JogMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JogMovement.h; path = ../engine/rules/include/JogMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0AC0E18061300BE5850 /* JumpHighMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JumpHighMovement.h; path = ../engine/rules/include/JumpHighMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0AD0E18061300BE5850 /* JumpLongMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JumpLongMovement.h; path = ../engine/rules/include/JumpLongMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0AE0E18061300BE5850 /* JumpToTargetMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = JumpToTargetMovement.h; path = ../engine/rules/include/JumpToTargetMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0AF0E18061300BE5850 /* LieDownMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = LieDownMovement.h; path = ../engine/rules/include/LieDownMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0B00E18061300BE5850 /* RotateMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = RotateMovement.h; path = ../engine/rules/include/RotateMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0B10E18061300BE5850 /* SneakMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SneakMovement.h; path = ../engine/rules/include/SneakMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0B20E18061300BE5850 /* SprintMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SprintMovement.h; path = ../engine/rules/include/SprintMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0B30E18061300BE5850 /* StandAroundMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = StandAroundMovement.h; path = ../engine/rules/include/StandAroundMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0B40E18061300BE5850 /* StepRecognitionMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = StepRecognitionMovement.h; path = ../engine/rules/include/StepRecognitionMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0B50E18061300BE5850 /* StrafeMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = StrafeMovement.h; path = ../engine/rules/include/StrafeMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0B60E18061300BE5850 /* WalkBackwardsMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WalkBackwardsMovement.h; path = ../engine/rules/include/WalkBackwardsMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0B70E18061300BE5850 /* WalkMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = WalkMovement.h; path = ../engine/rules/include/WalkMovement.h; sourceTree = SOURCE_ROOT; };
-		4890C0C90E18062B00BE5850 /* FallDownMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = FallDownMovement.cpp; path = ../engine/rules/src/FallDownMovement.cpp; sourceTree = SOURCE_ROOT; };
-		4890C0CA0E18062B00BE5850 /* JogFastMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JogFastMovement.cpp; path = ../engine/rules/src/JogFastMovement.cpp; sourceTree = SOURCE_ROOT; };
-		4890C0CB0E18062B00BE5850 /* JogMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JogMovement.cpp; path = ../engine/rules/src/JogMovement.cpp; sourceTree = SOURCE_ROOT; };
-		4890C0CC0E18062B00BE5850 /* JumpHighMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JumpHighMovement.cpp; path = ../engine/rules/src/JumpHighMovement.cpp; sourceTree = SOURCE_ROOT; };
-		4890C0CD0E18062B00BE5850 /* JumpLongMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JumpLongMovement.cpp; path = ../engine/rules/src/JumpLongMovement.cpp; sourceTree = SOURCE_ROOT; };
-		4890C0CE0E18062B00BE5850 /* JumpToTargetMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = JumpToTargetMovement.cpp; path = ../engine/rules/src/JumpToTargetMovement.cpp; sourceTree = SOURCE_ROOT; };
-		4890C0CF0E18062B00BE5850 /* LieDownMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = LieDownMovement.cpp; path = ../engine/rules/src/LieDownMovement.cpp; sourceTree = SOURCE_ROOT; };
-		4890C0D00E18062B00BE5850 /* RotateMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = RotateMovement.cpp; path = ../engine/rules/src/RotateMovement.cpp; sourceTree = SOURCE_ROOT; };
-		4890C0D10E18062B00BE5850 /* SneakMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SneakMovement.cpp; path = ../engine/rules/src/SneakMovement.cpp; sourceTree = SOURCE_ROOT; };
-		4890C0D20E18062B00BE5850 /* SprintMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SprintMovement.cpp; path = ../engine/rules/src/SprintMovement.cpp; sourceTree = SOURCE_ROOT; };
-		4890C0D30E18062B00BE5850 /* StandAroundMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = StandAroundMovement.cpp; path = ../engine/rules/src/StandAroundMovement.cpp; sourceTree = SOURCE_ROOT; };
-		4890C0D40E18062B00BE5850 /* StepRecognitionMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = StepRecognitionMovement.cpp; path = ../engine/rules/src/StepRecognitionMovement.cpp; sourceTree = SOURCE_ROOT; };
-		4890C0D50E18062B00BE5850 /* StrafeMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = StrafeMovement.cpp; path = ../engine/rules/src/StrafeMovement.cpp; sourceTree = SOURCE_ROOT; };
-		4890C0D60E18062B00BE5850 /* WalkMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = WalkMovement.cpp; path = ../engine/rules/src/WalkMovement.cpp; sourceTree = SOURCE_ROOT; };
+		4890C0A70E18061300BE5850 /* AbstractMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = AbstractMovement.h; sourceTree = "<group>"; };
+		4890C0A80E18061300BE5850 /* FallDownMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FallDownMovement.h; sourceTree = "<group>"; };
+		4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JogBackwardsMovement.h; sourceTree = "<group>"; };
+		4890C0AA0E18061300BE5850 /* JogFastMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JogFastMovement.h; sourceTree = "<group>"; };
+		4890C0AB0E18061300BE5850 /* JogMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JogMovement.h; sourceTree = "<group>"; };
+		4890C0AC0E18061300BE5850 /* JumpHighMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JumpHighMovement.h; sourceTree = "<group>"; };
+		4890C0AD0E18061300BE5850 /* JumpLongMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JumpLongMovement.h; sourceTree = "<group>"; };
+		4890C0AE0E18061300BE5850 /* JumpToTargetMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = JumpToTargetMovement.h; sourceTree = "<group>"; };
+		4890C0AF0E18061300BE5850 /* LieDownMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = LieDownMovement.h; sourceTree = "<group>"; };
+		4890C0B00E18061300BE5850 /* RotateMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = RotateMovement.h; sourceTree = "<group>"; };
+		4890C0B10E18061300BE5850 /* SneakMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SneakMovement.h; sourceTree = "<group>"; };
+		4890C0B20E18061300BE5850 /* SprintMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = SprintMovement.h; sourceTree = "<group>"; };
+		4890C0B30E18061300BE5850 /* StandAroundMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StandAroundMovement.h; sourceTree = "<group>"; };
+		4890C0B40E18061300BE5850 /* StepRecognitionMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StepRecognitionMovement.h; sourceTree = "<group>"; };
+		4890C0B50E18061300BE5850 /* StrafeMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = StrafeMovement.h; sourceTree = "<group>"; };
+		4890C0B60E18061300BE5850 /* WalkBackwardsMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WalkBackwardsMovement.h; sourceTree = "<group>"; };
+		4890C0B70E18061300BE5850 /* WalkMovement.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = WalkMovement.h; sourceTree = "<group>"; };
+		4890C0C90E18062B00BE5850 /* FallDownMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FallDownMovement.cpp; sourceTree = "<group>"; };
+		4890C0CA0E18062B00BE5850 /* JogFastMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JogFastMovement.cpp; sourceTree = "<group>"; };
+		4890C0CB0E18062B00BE5850 /* JogMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JogMovement.cpp; sourceTree = "<group>"; };
+		4890C0CC0E18062B00BE5850 /* JumpHighMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JumpHighMovement.cpp; sourceTree = "<group>"; };
+		4890C0CD0E18062B00BE5850 /* JumpLongMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JumpLongMovement.cpp; sourceTree = "<group>"; };
+		4890C0CE0E18062B00BE5850 /* JumpToTargetMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = JumpToTargetMovement.cpp; sourceTree = "<group>"; };
+		4890C0CF0E18062B00BE5850 /* LieDownMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = LieDownMovement.cpp; sourceTree = "<group>"; };
+		4890C0D00E18062B00BE5850 /* RotateMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = RotateMovement.cpp; sourceTree = "<group>"; };
+		4890C0D10E18062B00BE5850 /* SneakMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SneakMovement.cpp; sourceTree = "<group>"; };
+		4890C0D20E18062B00BE5850 /* SprintMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = SprintMovement.cpp; sourceTree = "<group>"; };
+		4890C0D30E18062B00BE5850 /* StandAroundMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = StandAroundMovement.cpp; sourceTree = "<group>"; };
+		4890C0D40E18062B00BE5850 /* StepRecognitionMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = StepRecognitionMovement.cpp; sourceTree = "<group>"; };
+		4890C0D50E18062B00BE5850 /* StrafeMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = StrafeMovement.cpp; sourceTree = "<group>"; };
+		4890C0D60E18062B00BE5850 /* WalkMovement.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = WalkMovement.cpp; sourceTree = "<group>"; };
 		48A52B210E0EDA0E008DBDD8 /* libboost_filesystem.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libboost_filesystem.dylib; path = /usr/local/lib/libboost_filesystem.dylib; sourceTree = "<absolute>"; };
 		48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libboost_system.dylib; path = /usr/local/lib/libboost_system.dylib; sourceTree = "<absolute>"; };
-		48A52CB50E0EF5BD008DBDD8 /* ApplyDamageJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = ApplyDamageJob.h; path = ../engine/rules/include/ApplyDamageJob.h; sourceTree = SOURCE_ROOT; };
-		48A52CB70E0EF5D0008DBDD8 /* ApplyDamageJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = ApplyDamageJob.cpp; path = ../engine/rules/src/ApplyDamageJob.cpp; sourceTree = SOURCE_ROOT; };
+		48A52CB50E0EF5BD008DBDD8 /* ApplyDamageJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ApplyDamageJob.h; sourceTree = "<group>"; };
+		48A52CB70E0EF5D0008DBDD8 /* ApplyDamageJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ApplyDamageJob.cpp; sourceTree = "<group>"; };
 		48B0B0340E6534690023B198 /* PlaneNodeProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PlaneNodeProcessor.cpp; path = ../engine/script/src/PlaneNodeProcessor.cpp; sourceTree = SOURCE_ROOT; };
 		48B0B0360E6534810023B198 /* PlaneNodeProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PlaneNodeProcessor.h; path = ../engine/script/include/PlaneNodeProcessor.h; sourceTree = SOURCE_ROOT; };
 		48B0B0480E65BBB30023B198 /* libfmodex.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libfmodex.dylib; path = "FMOD Programmers API/api/lib/libfmodex.dylib"; sourceTree = SYSTEM_DEVELOPER_DIR; };
@@ -1501,7 +1501,6 @@
 		48B772E20D583521000A3B97 /* XmlPropertyWriter.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = XmlPropertyWriter.cpp; path = ../engine/common/src/XmlPropertyWriter.cpp; sourceTree = SOURCE_ROOT; };
 		48C04B890E67DF0300CD3A7D /* PCRE.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = PCRE.framework; path = /Library/Frameworks/PCRE.framework; sourceTree = "<absolute>"; };
 		48CFBF8E0E2E869000CD0C51 /* FreeType.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = FreeType.framework; path = /Library/Frameworks/FreeType.framework; sourceTree = "<absolute>"; };
-		48CFBFD70E2E87BB00CD0C51 /* renameinstalldirs.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; name = renameinstalldirs.sh; path = tools/renameinstalldirs.sh; sourceTree = "<group>"; };
 		48D0BE280E273C5E00863824 /* SaveAble.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAble.h; path = ../engine/core/include/SaveAble.h; sourceTree = SOURCE_ROOT; };
 		48D0BE290E273C5E00863824 /* SaveAbleCollection.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAbleCollection.h; path = ../engine/core/include/SaveAbleCollection.h; sourceTree = SOURCE_ROOT; };
 		48D0BE2A0E273C5E00863824 /* SaveAbleFactory.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveAbleFactory.h; path = ../engine/core/include/SaveAbleFactory.h; sourceTree = SOURCE_ROOT; };
@@ -1521,6 +1520,10 @@
 		48D34A610D90F5D500C89477 /* SaveGameData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameData.h; path = ../engine/core/include/SaveGameData.h; sourceTree = SOURCE_ROOT; };
 		48D34A620D90F5D500C89477 /* SaveGameData.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameData.cpp; path = ../engine/core/src/SaveGameData.cpp; sourceTree = SOURCE_ROOT; };
 		48D401810D9E483200AE5340 /* modules */ = {isa = PBXFileReference; lastKnownFileType = folder; name = modules; path = ../../../modules; sourceTree = SOURCE_ROOT; };
+		48EFE0A30E8B6AF6007EB7F8 /* FetchItemJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FetchItemJob.h; sourceTree = "<group>"; };
+		48EFE0A50E8B6C39007EB7F8 /* FetchItemJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FetchItemJob.cpp; sourceTree = "<group>"; };
+		48EFE0D70E8B6EB1007EB7F8 /* mkdmg.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; path = mkdmg.sh; sourceTree = "<group>"; };
+		48EFE0D80E8B6EB1007EB7F8 /* renameinstalldirs.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; path = renameinstalldirs.sh; sourceTree = "<group>"; };
 		8D0C4E960486CD37000505A6 /* Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist; path = Info.plist; sourceTree = "<group>"; };
 		8D0C4E970486CD37000505A6 /* Rastullah.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Rastullah.app; sourceTree = BUILT_PRODUCTS_DIR; };
 /* End PBXFileReference section */
@@ -1697,7 +1700,7 @@
 		20286C29FDCF999611CA2CEA /* Rastullah */ = {
 			isa = PBXGroup;
 			children = (
-				20286C2AFDCF999611CA2CEA /* Sources */,
+				20286C2AFDCF999611CA2CEA /* Engine */,
 				48D401810D9E483200AE5340 /* modules */,
 				20286C2CFDCF999611CA2CEA /* Resources */,
 				20286C32FDCF999611CA2CEA /* External Frameworks and Libraries */,
@@ -1706,10 +1709,10 @@
 			name = Rastullah;
 			sourceTree = "<group>";
 		};
-		20286C2AFDCF999611CA2CEA /* Sources */ = {
+		20286C2AFDCF999611CA2CEA /* Engine */ = {
 			isa = PBXGroup;
 			children = (
-				48CFBFD60E2E87A800CD0C51 /* Scripts */,
+				48CFBFD60E2E87A800CD0C51 /* Mac Scripts */,
 				444EAC220BD0E3E000C6D4A0 /* RlAi */,
 				444EAB1F0BD0E25C00C6D4A0 /* RlCommon */,
 				444EAB200BD0E27400C6D4A0 /* RlCore */,
@@ -1719,7 +1722,8 @@
 				444EAC570BD0E4CD00C6D4A0 /* RlUi */,
 				444EAAAC0BD0E0C700C6D4A0 /* RastullahMain.cpp */,
 			);
-			name = Sources;
+			name = Engine;
+			path = ../engine;
 			sourceTree = "<group>";
 		};
 		20286C2CFDCF999611CA2CEA /* Resources */ = {
@@ -2066,29 +2070,180 @@
 		444EAC570BD0E4CD00C6D4A0 /* RlUi */ = {
 			isa = PBXGroup;
 			children = (
-				487029C80E80DCF900B66388 /* GameOverWindow.cpp */,
-				487029C60E80DCEA00B66388 /* GameOverWindow.h */,
-				48389B960D86743900AFAB66 /* CombatGui.h */,
-				48389B970D86743900AFAB66 /* GameSaveLoadWindow.h */,
-				48389B980D86743900AFAB66 /* MainMenuLoadWindow.h */,
-				48389B990D86743900AFAB66 /* UiMessages.h */,
-				48389B8E0D86741F00AFAB66 /* CombatGui.cpp */,
-				48389B8F0D86741F00AFAB66 /* GameSaveLoadWindow.cpp */,
-				48389B900D86741F00AFAB66 /* MainMenuLoadWindow.cpp */,
-				48389B910D86741F00AFAB66 /* stdinc.cpp */,
+				48EFE0890E8B6900007EB7F8 /* Source */,
+				48EFE0880E8B6822007EB7F8 /* Headers */,
+			);
+			name = RlUi;
+			path = ../engine/ui;
+			sourceTree = "<group>";
+		};
+		444EAC590BD0E50600C6D4A0 /* RlRules */ = {
+			isa = PBXGroup;
+			children = (
+				48EFE0A20E8B69F5007EB7F8 /* Headers */,
+				48EFE0A10E8B69EE007EB7F8 /* Source */,
+			);
+			name = RlRules;
+			path = rules;
+			sourceTree = "<group>";
+		};
+		444EAE600BD0E66500C6D4A0 /* RlScript */ = {
+			isa = PBXGroup;
+			children = (
+				48B0B0230E6533940023B198 /* Headers */,
+				48B0B0240E6533A50023B198 /* Source */,
+				48389C010D86783200AFAB66 /* swig */,
+			);
+			name = RlScript;
+			sourceTree = "<group>";
+		};
+		48389C010D86783200AFAB66 /* swig */ = {
+			isa = PBXGroup;
+			children = (
+				48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */,
+				48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */,
+				48500B780D906A1000EAD8DB /* RlScriptExportsMac.cpp */,
+				48389C020D86787900AFAB66 /* RlExports.i */,
+				48389BE80D8677EE00AFAB66 /* RlAi.head.swig */,
+				48389BE90D8677EE00AFAB66 /* RlAi.swig */,
+				48389BEA0D8677EE00AFAB66 /* RlCommon.head.swig */,
+				48389BEB0D8677EE00AFAB66 /* RlCommon.swig */,
+				48389BEC0D8677EE00AFAB66 /* RlCore.head.swig */,
+				48389BED0D8677EE00AFAB66 /* RlCore.swig */,
+				48389BEE0D8677EE00AFAB66 /* RlRules.head.swig */,
+				48389BEF0D8677EE00AFAB66 /* RlRules.swig */,
+				48389BF00D8677EE00AFAB66 /* RlScript.head.swig */,
+				48389BF10D8677EE00AFAB66 /* RlScript.swig */,
+				48389BF20D8677EE00AFAB66 /* RlUi.head.swig */,
+				48760A990D92E2CD00BEB57C /* RlUi.swig */,
+				48389BF30D8677EE00AFAB66 /* TypeDynamicDirector.swig */,
+				48389BF40D8677EE00AFAB66 /* TypeMaps.i */,
+				48389BF50D8677EE00AFAB66 /* TypeOgreColourValue.swig */,
+				48389BF60D8677EE00AFAB66 /* TypeOgreQuaternion.swig */,
+				48389BF70D8677EE00AFAB66 /* TypeOgreRadian.swig */,
+				48389BF80D8677EE00AFAB66 /* TypeOgreReal.swig */,
+				48389BF90D8677EE00AFAB66 /* TypeOgreString.swig */,
+				48389BFA0D8677EE00AFAB66 /* TypeOgreStringVector.swig */,
+				48389BFB0D8677EE00AFAB66 /* TypeOgreVector3.swig */,
+				48389BFC0D8677EE00AFAB66 /* TypeRlCeGuiString.swig */,
+				48389BFD0D8677EE00AFAB66 /* TypeRlCeGuiStringVector.swig */,
+				48389BFE0D8677EE00AFAB66 /* TypeRlProperty.swig */,
+				48389BFF0D8677EE00AFAB66 /* TypeRlPropertyKeys.swig */,
+				48389C000D8677EE00AFAB66 /* TypeStdPairIntInt.swig */,
+			);
+			name = swig;
+			sourceTree = "<group>";
+		};
+		483D86890D8C3DA200F3629E /* RlFmod4Driver */ = {
+			isa = PBXGroup;
+			children = (
+				483D868B0D8C3DA200F3629E /* include */,
+				483D86950D8C3DA200F3629E /* src */,
+			);
+			name = RlFmod4Driver;
+			path = ../plugins/fmod4driver;
+			sourceTree = SOURCE_ROOT;
+		};
+		483D868B0D8C3DA200F3629E /* include */ = {
+			isa = PBXGroup;
+			children = (
+				483D868C0D8C3DA200F3629E /* Fmod4ConfigComponent.h */,
+				483D868D0D8C3DA200F3629E /* Fmod4Driver.h */,
+				483D868E0D8C3DA200F3629E /* Fmod4DriverPrerequisites.h */,
+				483D868F0D8C3DA200F3629E /* Fmod4Listener.h */,
+				483D86900D8C3DA200F3629E /* Fmod4Sound.h */,
+				483D86910D8C3DA200F3629E /* Fmod4SoundStitching.h */,
+			);
+			path = include;
+			sourceTree = "<group>";
+		};
+		483D86950D8C3DA200F3629E /* src */ = {
+			isa = PBXGroup;
+			children = (
+				483D86960D8C3DA200F3629E /* Fmod4ConfigComponent.cpp */,
+				483D86970D8C3DA200F3629E /* Fmod4Driver.cpp */,
+				483D86980D8C3DA200F3629E /* Fmod4DriverDllMain.cpp */,
+				483D86990D8C3DA200F3629E /* Fmod4Listener.cpp */,
+				483D869A0D8C3DA200F3629E /* Fmod4Sound.cpp */,
+				483D869B0D8C3DA200F3629E /* Fmod4SoundStitching.cpp */,
+			);
+			path = src;
+			sourceTree = "<group>";
+		};
+		48B0B0230E6533940023B198 /* Headers */ = {
+			isa = PBXGroup;
+			children = (
+				444EAE610BD0E6C000C6D4A0 /* ScriptObjectMarker.h */,
+				444EAE620BD0E6C000C6D4A0 /* ScriptPrerequisites.h */,
+				444EAE630BD0E6C000C6D4A0 /* ScriptSubsystem.h */,
+				444825ED0BF7B32100C5A94F /* AbstractMapNodeProcessor.h */,
+				444825EE0BF7B32100C5A94F /* EntityNodeProcessor.h */,
+				444825EF0BF7B32100C5A94F /* EnvironmentProcessor.h */,
+				444825F00BF7B32100C5A94F /* GameObjectNodeProcessor.h */,
+				444825F10BF7B32100C5A94F /* LightNodeProcessor.h */,
+				444825F20BF7B32100C5A94F /* MapLoader.h */,
+				444825F30BF7B32100C5A94F /* ParticleSystemNodeProcessor.h */,
+				48B0B0360E6534810023B198 /* PlaneNodeProcessor.h */,
+				485B89510E15794A00D5B19C /* Scene.h */,
+				485B89520E15794A00D5B19C /* SceneLoader.h */,
+				485B89530E15794A00D5B19C /* SceneManager.h */,
+				444825F40BF7B32100C5A94F /* SoundNodeProcessor.h */,
+				4404DA840C48D01E007B4657 /* stdinc.h */,
+				444825F50BF7B32100C5A94F /* TriggerFactory.h */,
+				446BF4810C4532B50013C214 /* UnifiedFactory.h */,
+				444825F60BF7B32100C5A94F /* WaypointProcessor.h */,
+				444825F70BF7B32100C5A94F /* ZoneProcessor.h */,
+			);
+			name = Headers;
+			sourceTree = "<group>";
+		};
+		48B0B0240E6533A50023B198 /* Source */ = {
+			isa = PBXGroup;
+			children = (
+				444825D90BF7B2B200C5A94F /* AbstractMapNodeProcessor.cpp */,
+				444825DA0BF7B2B200C5A94F /* EntityNodeProcessor.cpp */,
+				444825DB0BF7B2B200C5A94F /* EnvironmentProcessor.cpp */,
+				444825DC0BF7B2B200C5A94F /* GameObjectNodeProcessor.cpp */,
+				444825DD0BF7B2B200C5A94F /* LightNodeProcessor.cpp */,
+				444825DE0BF7B2B200C5A94F /* MapLoader.cpp */,
+				444825DF0BF7B2B200C5A94F /* ParticleSystemNodeProcessor.cpp */,
+				48B0B0340E6534690023B198 /* PlaneNodeProcessor.cpp */,
+				485B89570E15796500D5B19C /* Scene.cpp */,
+				485B89580E15796500D5B19C /* SceneLoader.cpp */,
+				485B89590E15796500D5B19C /* SceneManager.cpp */,
+				444EAE670BD0E6D400C6D4A0 /* ScriptObjectMarker.cpp */,
+				444EAE680BD0E6D400C6D4A0 /* ScriptSubsystem.cpp */,
+				444825E00BF7B2B200C5A94F /* SoundNodeProcessor.cpp */,
+				48389C190D867AA900AFAB66 /* stdinc.cpp */,
+				48389C1A0D867AA900AFAB66 /* TriggerFactory.cpp */,
+				444825E10BF7B2B200C5A94F /* WaypointProcessor.cpp */,
+				444825E20BF7B2B200C5A94F /* ZoneProcessor.cpp */,
+			);
+			name = Source;
+			sourceTree = "<group>";
+		};
+		48CFBFD60E2E87A800CD0C51 /* Mac Scripts */ = {
+			isa = PBXGroup;
+			children = (
+				48EFE0D70E8B6EB1007EB7F8 /* mkdmg.sh */,
+				48EFE0D80E8B6EB1007EB7F8 /* renameinstalldirs.sh */,
+			);
+			name = "Mac Scripts";
+			path = ../Mac/tools;
+			sourceTree = "<group>";
+		};
+		48EFE0880E8B6822007EB7F8 /* Headers */ = {
+			isa = PBXGroup;
+			children = (
+				44D8145F0BF7B58A00534175 /* ProgressWindow.h */,
+				444EACFE0BD0E58C00C6D4A0 /* AboutWindow.h */,
+				444EACFF0BD0E58C00C6D4A0 /* AbstractWindow.h */,
+				444EAD000BD0E58C00C6D4A0 /* ActionChoiceWindow.h */,
+				444EAD010BD0E58C00C6D4A0 /* CeGuiHelper.h */,
+				444EAD030BD0E58C00C6D4A0 /* CharacterSheetWindow.h */,
 				4404DA850C48D037007B4657 /* stdinc.h */,
-				446BF4D50C453C1D0013C214 /* ItemDescriptionDragContainer.cpp */,
 				446BF4D00C453B9E0013C214 /* CombatControlState.h */,
 				446BF4D10C453B9E0013C214 /* CombatWindow.h */,
-				446BF4940C4533BD0013C214 /* CombatControlState.cpp */,
-				446BF4950C4533BD0013C214 /* CombatWindow.cpp */,
-				446BF4960C4533BD0013C214 /* ControlState.cpp */,
-				446BF4970C4533BD0013C214 /* CutsceneControlState.cpp */,
-				446BF4980C4533BD0013C214 /* DialogControlState.cpp */,
-				446BF4990C4533BD0013C214 /* FreeflightControlState.cpp */,
-				446BF49A0C4533BD0013C214 /* ItemIconDragContainer.cpp */,
-				446BF49B0C4533BD0013C214 /* MovementControlState.cpp */,
-				446BF49C0C4533BD0013C214 /* PropertiesWindow.cpp */,
 				446BF4840C45335A0013C214 /* ControlState.h */,
 				446BF4850C45335A0013C214 /* CutsceneControlState.h */,
 				446BF4860C45335A0013C214 /* DialogControlState.h */,
@@ -2097,13 +2252,10 @@
 				446BF4890C45335A0013C214 /* ItemIconDragContainer.h */,
 				446BF48A0C45335A0013C214 /* MovementControlState.h */,
 				446BF48B0C45335A0013C214 /* PropertiesWindow.h */,
-				44D814630BF7B5AD00534175 /* ProgressWindow.cpp */,
-				44D8145F0BF7B58A00534175 /* ProgressWindow.h */,
-				444EACFE0BD0E58C00C6D4A0 /* AboutWindow.h */,
-				444EACFF0BD0E58C00C6D4A0 /* AbstractWindow.h */,
-				444EAD000BD0E58C00C6D4A0 /* ActionChoiceWindow.h */,
-				444EAD010BD0E58C00C6D4A0 /* CeGuiHelper.h */,
-				444EAD030BD0E58C00C6D4A0 /* CharacterSheetWindow.h */,
+				487029C60E80DCEA00B66388 /* GameOverWindow.h */,
+				48389B960D86743900AFAB66 /* CombatGui.h */,
+				48389B970D86743900AFAB66 /* GameSaveLoadWindow.h */,
+				48389B980D86743900AFAB66 /* MainMenuLoadWindow.h */,
 				444EAD040BD0E58C00C6D4A0 /* CharacterStateWindow.h */,
 				444EAD050BD0E58C00C6D4A0 /* CloseConfirmationWindow.h */,
 				444EAD070BD0E58C00C6D4A0 /* CommandMapper.h */,
@@ -2137,6 +2289,38 @@
 				444EAD2B0BD0E58C00C6D4A0 /* WindowFactory.h */,
 				444EAD2C0BD0E58C00C6D4A0 /* WindowFadeJob.h */,
 				444EAD2D0BD0E58C00C6D4A0 /* WindowManager.h */,
+				48389B990D86743900AFAB66 /* UiMessages.h */,
+			);
+			name = Headers;
+			path = include;
+			sourceTree = "<group>";
+		};
+		48EFE0890E8B6900007EB7F8 /* Source */ = {
+			isa = PBXGroup;
+			children = (
+				444EACC90BD0E57100C6D4A0 /* SoundConfig.cpp */,
+				444EACCA0BD0E57100C6D4A0 /* SoundDriverConfigComponent.cpp */,
+				444EACCB0BD0E57100C6D4A0 /* SubtitleWindow.cpp */,
+				444EACCC0BD0E57100C6D4A0 /* UiSubsystem.cpp */,
+				444EACCD0BD0E57100C6D4A0 /* WindowFactory.cpp */,
+				444EACCE0BD0E57100C6D4A0 /* WindowFadeJob.cpp */,
+				444EACCF0BD0E57100C6D4A0 /* WindowManager.cpp */,
+				487029C80E80DCF900B66388 /* GameOverWindow.cpp */,
+				48389B8E0D86741F00AFAB66 /* CombatGui.cpp */,
+				48389B8F0D86741F00AFAB66 /* GameSaveLoadWindow.cpp */,
+				48389B900D86741F00AFAB66 /* MainMenuLoadWindow.cpp */,
+				48389B910D86741F00AFAB66 /* stdinc.cpp */,
+				446BF4D50C453C1D0013C214 /* ItemDescriptionDragContainer.cpp */,
+				446BF4940C4533BD0013C214 /* CombatControlState.cpp */,
+				446BF4950C4533BD0013C214 /* CombatWindow.cpp */,
+				446BF4960C4533BD0013C214 /* ControlState.cpp */,
+				446BF4970C4533BD0013C214 /* CutsceneControlState.cpp */,
+				446BF4980C4533BD0013C214 /* DialogControlState.cpp */,
+				446BF4990C4533BD0013C214 /* FreeflightControlState.cpp */,
+				446BF49A0C4533BD0013C214 /* ItemIconDragContainer.cpp */,
+				446BF49B0C4533BD0013C214 /* MovementControlState.cpp */,
+				446BF49C0C4533BD0013C214 /* PropertiesWindow.cpp */,
+				44D814630BF7B5AD00534175 /* ProgressWindow.cpp */,
 				444EACA20BD0E57100C6D4A0 /* AboutWindow.cpp */,
 				444EACA30BD0E57100C6D4A0 /* AbstractWindow.cpp */,
 				444EACA40BD0E57100C6D4A0 /* ActionChoiceWindow.cpp */,
@@ -2166,26 +2350,34 @@
 				444EACC50BD0E57100C6D4A0 /* ObjectDescriptionWindow.cpp */,
 				444EACC60BD0E57100C6D4A0 /* PlaylistWindow.cpp */,
 				444EACC70BD0E57100C6D4A0 /* RenderSystemConfigComponent.cpp */,
-				444EACC90BD0E57100C6D4A0 /* SoundConfig.cpp */,
-				444EACCA0BD0E57100C6D4A0 /* SoundDriverConfigComponent.cpp */,
-				444EACCB0BD0E57100C6D4A0 /* SubtitleWindow.cpp */,
-				444EACCC0BD0E57100C6D4A0 /* UiSubsystem.cpp */,
-				444EACCD0BD0E57100C6D4A0 /* WindowFactory.cpp */,
-				444EACCE0BD0E57100C6D4A0 /* WindowFadeJob.cpp */,
-				444EACCF0BD0E57100C6D4A0 /* WindowManager.cpp */,
 			);
-			name = RlUi;
+			name = Source;
+			path = src;
 			sourceTree = "<group>";
 		};
-		444EAC590BD0E50600C6D4A0 /* RlRules */ = {
+		48EFE0A10E8B69EE007EB7F8 /* Source */ = {
 			isa = PBXGroup;
 			children = (
+				48EFE0A50E8B6C39007EB7F8 /* FetchItemJob.cpp */,
+				48A52CB70E0EF5D0008DBDD8 /* ApplyDamageJob.cpp */,
+				483D312D0D85B22C003477A0 /* GameEventLog.cpp */,
+				483D312E0D85B22C003477A0 /* GameTimeSource.cpp */,
+				483D31300D85B22C003477A0 /* GoToJob.cpp */,
+				4404DA820C48D005007B4657 /* stdinc.cpp */,
+				446BF47B0C45329F0013C214 /* CreatureController.cpp */,
+				446BF47C0C45329F0013C214 /* CreatureControllerManager.cpp */,
+				446BF47D0C45329F0013C214 /* EffectFactory.cpp */,
+				483D312F0D85B22C003477A0 /* GlobalProperties.cpp */,
+				483D312B0D85B22C003477A0 /* Combatant.cpp */,
+				483D312C0D85B22C003477A0 /* EffectManagementTask.cpp */,
+				483D31310D85B22C003477A0 /* Kampfaktion.cpp */,
+				483D31320D85B22C003477A0 /* WaitJob.cpp */,
+				444826030BF7B37D00C5A94F /* SelectionHelper.cpp */,
+				444826040BF7B37D00C5A94F /* Selector.cpp */,
 				487029E90E80E13300B66388 /* PartyManager.cpp */,
-				487029E70E80E12200B66388 /* PartyManager.h */,
 				4890C0C90E18062B00BE5850 /* FallDownMovement.cpp */,
 				4890C0CA0E18062B00BE5850 /* JogFastMovement.cpp */,
 				4890C0CB0E18062B00BE5850 /* JogMovement.cpp */,
-				483D311D0D85B215003477A0 /* RulesMessages.h */,
 				4890C0CC0E18062B00BE5850 /* JumpHighMovement.cpp */,
 				4890C0CD0E18062B00BE5850 /* JumpLongMovement.cpp */,
 				4890C0CE0E18062B00BE5850 /* JumpToTargetMovement.cpp */,
@@ -2197,6 +2389,53 @@
 				4890C0D40E18062B00BE5850 /* StepRecognitionMovement.cpp */,
 				4890C0D50E18062B00BE5850 /* StrafeMovement.cpp */,
 				4890C0D60E18062B00BE5850 /* WalkMovement.cpp */,
+				444EADB00BD0E64100C6D4A0 /* Action.cpp */,
+				444EADB10BD0E64100C6D4A0 /* ActionManager.cpp */,
+				444EADB20BD0E64100C6D4A0 /* Armor.cpp */,
+				444EADB30BD0E64100C6D4A0 /* Combat.cpp */,
+				444EADB40BD0E64100C6D4A0 /* CombatManager.cpp */,
+				444EADB50BD0E64100C6D4A0 /* Container.cpp */,
+				444EADB60BD0E64100C6D4A0 /* Creature.cpp */,
+				444EADB70BD0E64100C6D4A0 /* Date.cpp */,
+				444EADB80BD0E64100C6D4A0 /* DsaDataLoader.cpp */,
+				444EADB90BD0E64100C6D4A0 /* DsaManager.cpp */,
+				444EADBA0BD0E64100C6D4A0 /* Effect.cpp */,
+				444EADBB0BD0E64100C6D4A0 /* EffectManager.cpp */,
+				444EADBC0BD0E64100C6D4A0 /* Eigenschaft.cpp */,
+				444EADBD0BD0E64100C6D4A0 /* EigenschaftenStateSet.cpp */,
+				444EADBE0BD0E64100C6D4A0 /* GameObject.cpp */,
+				444EADBF0BD0E64100C6D4A0 /* GameObjectManager.cpp */,
+				444EADC10BD0E64100C6D4A0 /* Inventory.cpp */,
+				444EADC20BD0E64100C6D4A0 /* Item.cpp */,
+				444EADC30BD0E64100C6D4A0 /* JournalEntry.cpp */,
+				444EADC40BD0E64100C6D4A0 /* Kampftechnik.cpp */,
+				444EADC50BD0E64100C6D4A0 /* ObjectStateChangeEvent.cpp */,
+				444EADC60BD0E64100C6D4A0 /* ObjectStateChangeEventSource.cpp */,
+				444EADC70BD0E64100C6D4A0 /* ObjectStateChangeListener.cpp */,
+				444EADC90BD0E64100C6D4A0 /* Quest.cpp */,
+				444EADCA0BD0E64100C6D4A0 /* QuestBook.cpp */,
+				444EADCB0BD0E64100C6D4A0 /* QuestEvent.cpp */,
+				444EADCC0BD0E64100C6D4A0 /* QuestListener.cpp */,
+				444EADCD0BD0E64100C6D4A0 /* RulesSubsystem.cpp */,
+				444EADCE0BD0E64100C6D4A0 /* Slot.cpp */,
+				444EADCF0BD0E64100C6D4A0 /* SonderfertigkeitenStateSet.cpp */,
+				444EADD00BD0E64100C6D4A0 /* StateSet.cpp */,
+				444EADD10BD0E64100C6D4A0 /* Talent.cpp */,
+				444EADD20BD0E64100C6D4A0 /* Talentgruppe.cpp */,
+				444EADD30BD0E64100C6D4A0 /* TalentStateSet.cpp */,
+				444EADD80BD0E64100C6D4A0 /* Weapon.cpp */,
+				444EADD90BD0E64100C6D4A0 /* ZauberStateSet.cpp */,
+			);
+			name = Source;
+			path = src;
+			sourceTree = "<group>";
+		};
+		48EFE0A20E8B69F5007EB7F8 /* Headers */ = {
+			isa = PBXGroup;
+			children = (
+				48EFE0A30E8B6AF6007EB7F8 /* FetchItemJob.h */,
+				487029E70E80E12200B66388 /* PartyManager.h */,
+				483D311D0D85B215003477A0 /* RulesMessages.h */,
 				4890C0A70E18061300BE5850 /* AbstractMovement.h */,
 				4890C0A80E18061300BE5850 /* FallDownMovement.h */,
 				4890C0A90E18061300BE5850 /* JogBackwardsMovement.h */,
@@ -2210,41 +2449,24 @@
 				4890C0B10E18061300BE5850 /* SneakMovement.h */,
 				4890C0B20E18061300BE5850 /* SprintMovement.h */,
 				4890C0B30E18061300BE5850 /* StandAroundMovement.h */,
-				4890C0B40E18061300BE5850 /* StepRecognitionMovement.h */,
-				4890C0B50E18061300BE5850 /* StrafeMovement.h */,
-				4890C0B60E18061300BE5850 /* WalkBackwardsMovement.h */,
-				4890C0B70E18061300BE5850 /* WalkMovement.h */,
-				48A52CB70E0EF5D0008DBDD8 /* ApplyDamageJob.cpp */,
 				48A52CB50E0EF5BD008DBDD8 /* ApplyDamageJob.h */,
 				483D311E0D85B215003477A0 /* stdinc.h */,
-				483D312D0D85B22C003477A0 /* GameEventLog.cpp */,
-				483D312E0D85B22C003477A0 /* GameTimeSource.cpp */,
-				483D31300D85B22C003477A0 /* GoToJob.cpp */,
 				483D31170D85B215003477A0 /* GameEventLog.h */,
 				483D311F0D85B215003477A0 /* WaitJob.h */,
 				483D31190D85B215003477A0 /* GlobalProperties.h */,
-				4404DA820C48D005007B4657 /* stdinc.cpp */,
-				446BF47B0C45329F0013C214 /* CreatureController.cpp */,
-				446BF47C0C45329F0013C214 /* CreatureControllerManager.cpp */,
+				4890C0B40E18061300BE5850 /* StepRecognitionMovement.h */,
+				4890C0B60E18061300BE5850 /* WalkBackwardsMovement.h */,
 				483D31150D85B215003477A0 /* Combatant.h */,
-				446BF47D0C45329F0013C214 /* EffectFactory.cpp */,
 				446BF4750C4532720013C214 /* CreatureController.h */,
 				446BF4760C4532720013C214 /* CreatureControllerManager.h */,
 				446BF4770C4532720013C214 /* EffectFactory.h */,
 				44D8145A0BF7B52600534175 /* SelectionHelper.h */,
 				483D311A0D85B215003477A0 /* GoToJob.h */,
 				483D31180D85B215003477A0 /* GameTimeSource.h */,
-				483D312F0D85B22C003477A0 /* GlobalProperties.cpp */,
-				483D312B0D85B22C003477A0 /* Combatant.cpp */,
-				483D312C0D85B22C003477A0 /* EffectManagementTask.cpp */,
-				483D31310D85B22C003477A0 /* Kampfaktion.cpp */,
-				483D31320D85B22C003477A0 /* WaitJob.cpp */,
 				483D311B0D85B215003477A0 /* Kampfaktion.h */,
 				483D311C0D85B215003477A0 /* RulesConstants.h */,
 				483D31160D85B215003477A0 /* EffectManagementTask.h */,
 				44D8145B0BF7B52600534175 /* Selector.h */,
-				444826030BF7B37D00C5A94F /* SelectionHelper.cpp */,
-				444826040BF7B37D00C5A94F /* Selector.cpp */,
 				444EAE040BD0E65B00C6D4A0 /* Action.h */,
 				444EAE050BD0E65B00C6D4A0 /* ActionManager.h */,
 				444EAE060BD0E65B00C6D4A0 /* Armor.h */,
@@ -2284,190 +2506,13 @@
 				444EAE2B0BD0E65B00C6D4A0 /* TalentStateSet.h */,
 				444EAE300BD0E65B00C6D4A0 /* Weapon.h */,
 				444EAE310BD0E65B00C6D4A0 /* ZauberStateSet.h */,
-				444EADB00BD0E64100C6D4A0 /* Action.cpp */,
-				444EADB10BD0E64100C6D4A0 /* ActionManager.cpp */,
-				444EADB20BD0E64100C6D4A0 /* Armor.cpp */,
-				444EADB30BD0E64100C6D4A0 /* Combat.cpp */,
-				444EADB40BD0E64100C6D4A0 /* CombatManager.cpp */,
-				444EADB50BD0E64100C6D4A0 /* Container.cpp */,
-				444EADB60BD0E64100C6D4A0 /* Creature.cpp */,
-				444EADB70BD0E64100C6D4A0 /* Date.cpp */,
-				444EADB80BD0E64100C6D4A0 /* DsaDataLoader.cpp */,
-				444EADB90BD0E64100C6D4A0 /* DsaManager.cpp */,
-				444EADBA0BD0E64100C6D4A0 /* Effect.cpp */,
-				444EADBB0BD0E64100C6D4A0 /* EffectManager.cpp */,
-				444EADBC0BD0E64100C6D4A0 /* Eigenschaft.cpp */,
-				444EADBD0BD0E64100C6D4A0 /* EigenschaftenStateSet.cpp */,
-				444EADBE0BD0E64100C6D4A0 /* GameObject.cpp */,
-				444EADBF0BD0E64100C6D4A0 /* GameObjectManager.cpp */,
-				444EADC10BD0E64100C6D4A0 /* Inventory.cpp */,
-				444EADC20BD0E64100C6D4A0 /* Item.cpp */,
-				444EADC30BD0E64100C6D4A0 /* JournalEntry.cpp */,
-				444EADC40BD0E64100C6D4A0 /* Kampftechnik.cpp */,
-				444EADC50BD0E64100C6D4A0 /* ObjectStateChangeEvent.cpp */,
-				444EADC60BD0E64100C6D4A0 /* ObjectStateChangeEventSource.cpp */,
-				444EADC70BD0E64100C6D4A0 /* ObjectStateChangeListener.cpp */,
-				444EADC90BD0E64100C6D4A0 /* Quest.cpp */,
-				444EADCA0BD0E64100C6D4A0 /* QuestBook.cpp */,
-				444EADCB0BD0E64100C6D4A0 /* QuestEvent.cpp */,
-				444EADCC0BD0E64100C6D4A0 /* QuestListener.cpp */,
-				444EADCD0BD0E64100C6D4A0 /* RulesSubsystem.cpp */,
-				444EADCE0BD0E64100C6D4A0 /* Slot.cpp */,
-				444EADCF0BD0E64100C6D4A0 /* SonderfertigkeitenStateSet.cpp */,
-				444EADD00BD0E64100C6D4A0 /* StateSet.cpp */,
-				444EADD10BD0E64100C6D4A0 /* Talent.cpp */,
-				444EADD20BD0E64100C6D4A0 /* Talentgruppe.cpp */,
-				444EADD30BD0E64100C6D4A0 /* TalentStateSet.cpp */,
-				444EADD80BD0E64100C6D4A0 /* Weapon.cpp */,
-				444EADD90BD0E64100C6D4A0 /* ZauberStateSet.cpp */,
+				4890C0B70E18061300BE5850 /* WalkMovement.h */,
+				4890C0B50E18061300BE5850 /* StrafeMovement.h */,
 			);
-			name = RlRules;
-			sourceTree = "<group>";
-		};
-		444EAE600BD0E66500C6D4A0 /* RlScript */ = {
-			isa = PBXGroup;
-			children = (
-				48B0B0230E6533940023B198 /* Headers */,
-				48B0B0240E6533A50023B198 /* Source */,
-				48389C010D86783200AFAB66 /* swig */,
-				444EAE610BD0E6C000C6D4A0 /* ScriptObjectMarker.h */,
-				444EAE620BD0E6C000C6D4A0 /* ScriptPrerequisites.h */,
-				444EAE630BD0E6C000C6D4A0 /* ScriptSubsystem.h */,
-			);
-			name = RlScript;
-			sourceTree = "<group>";
-		};
-		48389C010D86783200AFAB66 /* swig */ = {
-			isa = PBXGroup;
-			children = (
-				48760AA90D92E4B700BEB57C /* RlExports_wrap.cxx */,
-				48760AAA0D92E4B700BEB57C /* RlExports_wrap.h */,
-				48500B780D906A1000EAD8DB /* RlScriptExportsMac.cpp */,
-				48389C020D86787900AFAB66 /* RlExports.i */,
-				48389BE80D8677EE00AFAB66 /* RlAi.head.swig */,
-				48389BE90D8677EE00AFAB66 /* RlAi.swig */,
-				48389BEA0D8677EE00AFAB66 /* RlCommon.head.swig */,
-				48389BEB0D8677EE00AFAB66 /* RlCommon.swig */,
-				48389BEC0D8677EE00AFAB66 /* RlCore.head.swig */,
-				48389BED0D8677EE00AFAB66 /* RlCore.swig */,
-				48389BEE0D8677EE00AFAB66 /* RlRules.head.swig */,
-				48389BEF0D8677EE00AFAB66 /* RlRules.swig */,
-				48389BF00D8677EE00AFAB66 /* RlScript.head.swig */,
-				48389BF10D8677EE00AFAB66 /* RlScript.swig */,
-				48389BF20D8677EE00AFAB66 /* RlUi.head.swig */,
-				48760A990D92E2CD00BEB57C /* RlUi.swig */,
-				48389BF30D8677EE00AFAB66 /* TypeDynamicDirector.swig */,
-				48389BF40D8677EE00AFAB66 /* TypeMaps.i */,
-				48389BF50D8677EE00AFAB66 /* TypeOgreColourValue.swig */,
-				48389BF60D8677EE00AFAB66 /* TypeOgreQuaternion.swig */,
-				48389BF70D8677EE00AFAB66 /* TypeOgreRadian.swig */,
-				48389BF80D8677EE00AFAB66 /* TypeOgreReal.swig */,
-				48389BF90D8677EE00AFAB66 /* TypeOgreString.swig */,
-				48389BFA0D8677EE00AFAB66 /* TypeOgreStringVector.swig */,
-				48389BFB0D8677EE00AFAB66 /* TypeOgreVector3.swig */,
-				48389BFC0D8677EE00AFAB66 /* TypeRlCeGuiString.swig */,
-				48389BFD0D8677EE00AFAB66 /* TypeRlCeGuiStringVector.swig */,
-				48389BFE0D8677EE00AFAB66 /* TypeRlProperty.swig */,
-				48389BFF0D8677EE00AFAB66 /* TypeRlPropertyKeys.swig */,
-				48389C000D8677EE00AFAB66 /* TypeStdPairIntInt.swig */,
-			);
-			name = swig;
-			sourceTree = "<group>";
-		};
-		483D86890D8C3DA200F3629E /* RlFmod4Driver */ = {
-			isa = PBXGroup;
-			children = (
-				483D868B0D8C3DA200F3629E /* include */,
-				483D86950D8C3DA200F3629E /* src */,
-			);
-			name = RlFmod4Driver;
-			path = ../plugins/fmod4driver;
-			sourceTree = SOURCE_ROOT;
-		};
-		483D868B0D8C3DA200F3629E /* include */ = {
-			isa = PBXGroup;
-			children = (
-				483D868C0D8C3DA200F3629E /* Fmod4ConfigComponent.h */,
-				483D868D0D8C3DA200F3629E /* Fmod4Driver.h */,
-				483D868E0D8C3DA200F3629E /* Fmod4DriverPrerequisites.h */,
-				483D868F0D8C3DA200F3629E /* Fmod4Listener.h */,
-				483D86900D8C3DA200F3629E /* Fmod4Sound.h */,
-				483D86910D8C3DA200F3629E /* Fmod4SoundStitching.h */,
-			);
+			name = Headers;
 			path = include;
 			sourceTree = "<group>";
 		};
-		483D86950D8C3DA200F3629E /* src */ = {
-			isa = PBXGroup;
-			children = (
-				483D86960D8C3DA200F3629E /* Fmod4ConfigComponent.cpp */,
-				483D86970D8C3DA200F3629E /* Fmod4Driver.cpp */,
-				483D86980D8C3DA200F3629E /* Fmod4DriverDllMain.cpp */,
-				483D86990D8C3DA200F3629E /* Fmod4Listener.cpp */,
-				483D869A0D8C3DA200F3629E /* Fmod4Sound.cpp */,
-				483D869B0D8C3DA200F3629E /* Fmod4SoundStitching.cpp */,
-			);
-			path = src;
-			sourceTree = "<group>";
-		};
-		48B0B0230E6533940023B198 /* Headers */ = {
-			isa = PBXGroup;
-			children = (
-				444825ED0BF7B32100C5A94F /* AbstractMapNodeProcessor.h */,
-				444825EE0BF7B32100C5A94F /* EntityNodeProcessor.h */,
-				444825EF0BF7B32100C5A94F /* EnvironmentProcessor.h */,
-				444825F00BF7B32100C5A94F /* GameObjectNodeProcessor.h */,
-				444825F10BF7B32100C5A94F /* LightNodeProcessor.h */,
-				444825F20BF7B32100C5A94F /* MapLoader.h */,
-				444825F30BF7B32100C5A94F /* ParticleSystemNodeProcessor.h */,
-				48B0B0360E6534810023B198 /* PlaneNodeProcessor.h */,
-				485B89510E15794A00D5B19C /* Scene.h */,
-				485B89520E15794A00D5B19C /* SceneLoader.h */,
-				485B89530E15794A00D5B19C /* SceneManager.h */,
-				444825F40BF7B32100C5A94F /* SoundNodeProcessor.h */,
-				4404DA840C48D01E007B4657 /* stdinc.h */,
-				444825F50BF7B32100C5A94F /* TriggerFactory.h */,
-				446BF4810C4532B50013C214 /* UnifiedFactory.h */,
-				444825F60BF7B32100C5A94F /* WaypointProcessor.h */,
-				444825F70BF7B32100C5A94F /* ZoneProcessor.h */,
-			);
-			name = Headers;
-			sourceTree = "<group>";
-		};
-		48B0B0240E6533A50023B198 /* Source */ = {
-			isa = PBXGroup;
-			children = (
-				444825D90BF7B2B200C5A94F /* AbstractMapNodeProcessor.cpp */,
-				444825DA0BF7B2B200C5A94F /* EntityNodeProcessor.cpp */,
-				444825DB0BF7B2B200C5A94F /* EnvironmentProcessor.cpp */,
-				444825DC0BF7B2B200C5A94F /* GameObjectNodeProcessor.cpp */,
-				444825DD0BF7B2B200C5A94F /* LightNodeProcessor.cpp */,
-				444825DE0BF7B2B200C5A94F /* MapLoader.cpp */,
-				444825DF0BF7B2B200C5A94F /* ParticleSystemNodeProcessor.cpp */,
-				48B0B0340E6534690023B198 /* PlaneNodeProcessor.cpp */,
-				485B89570E15796500D5B19C /* Scene.cpp */,
-				485B89580E15796500D5B19C /* SceneLoader.cpp */,
-				485B89590E15796500D5B19C /* SceneManager.cpp */,
-				444EAE670BD0E6D400C6D4A0 /* ScriptObjectMarker.cpp */,
-				444EAE680BD0E6D400C6D4A0 /* ScriptSubsystem.cpp */,
-				444825E00BF7B2B200C5A94F /* SoundNodeProcessor.cpp */,
-				48389C190D867AA900AFAB66 /* stdinc.cpp */,
-				48389C1A0D867AA900AFAB66 /* TriggerFactory.cpp */,
-				444825E10BF7B2B200C5A94F /* WaypointProcessor.cpp */,
-				444825E20BF7B2B200C5A94F /* ZoneProcessor.cpp */,
-			);
-			name = Source;
-			sourceTree = "<group>";
-		};
-		48CFBFD60E2E87A800CD0C51 /* Scripts */ = {
-			isa = PBXGroup;
-			children = (
-				48CFBFD70E2E87BB00CD0C51 /* renameinstalldirs.sh */,
-				4835559A0E6ABED100008748 /* mkdmg.sh */,
-			);
-			name = Scripts;
-			sourceTree = "<group>";
-		};
 /* End PBXGroup section */
 
 /* Begin PBXHeadersBuildPhase section */
@@ -2724,6 +2769,7 @@
 				4890C0C70E18061300BE5850 /* WalkBackwardsMovement.h in Headers */,
 				4890C0C80E18061300BE5850 /* WalkMovement.h in Headers */,
 				487029E80E80E12200B66388 /* PartyManager.h in Headers */,
+				48EFE0A40E8B6AF6007EB7F8 /* FetchItemJob.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3063,7 +3109,6 @@
 				8D0C4E8D0486CD37000505A6 /* InfoPlist.strings in Resources */,
 				8D0C4E8E0486CD37000505A6 /* main.nib in Resources */,
 				48D409CE0D9E483300AE5340 /* modules in Resources */,
-				4835559B0E6ABED100008748 /* mkdmg.sh in Resources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3322,6 +3367,7 @@
 				4890C0E30E18062B00BE5850 /* StrafeMovement.cpp in Sources */,
 				4890C0E40E18062B00BE5850 /* WalkMovement.cpp in Sources */,
 				487029EA0E80E13300B66388 /* PartyManager.cpp in Sources */,
+				48EFE0A60E8B6C39007EB7F8 /* FetchItemJob.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};

Added: rl/trunk/engine/rules/include/FetchItemJob.h
===================================================================
--- rl/trunk/engine/rules/include/FetchItemJob.h	2008-09-28 20:56:08 UTC (rev 4529)
+++ rl/trunk/engine/rules/include/FetchItemJob.h	2008-09-28 20:56:35 UTC (rev 4530)
@@ -0,0 +1,47 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __RL_FETCH_ITEM_JOB_H__
+#define __RL_FETCH_ITEM_JOB_H__
+
+#include "RulesPrerequisites.h"
+#include "Job.h"
+
+namespace rl
+{
+    class Creature;
+    class CreatureController;
+    class Item;
+    
+    /// A rl#Job to fetch an item
+    class _RlRulesExport FetchItemJob : public Job
+    {
+    public:
+
+		FetchItemJob(Creature* actor, Item* item, const Ogre::String& targetSlot, Ogre::Real duration);
+        virtual ~FetchItemJob();
+
+        virtual bool execute(Ogre::Real time);
+
+    private:
+		CreatureController* mActor;
+		Item* mItem;
+		Ogre::String mTargetSlot;
+		Ogre::Real mTimeLeft;
+    };
+}
+
+#endif //__RL_FETCH_ITEM_JOB_H__

Added: rl/trunk/engine/rules/src/FetchItemJob.cpp
===================================================================
--- rl/trunk/engine/rules/src/FetchItemJob.cpp	2008-09-28 20:56:08 UTC (rev 4529)
+++ rl/trunk/engine/rules/src/FetchItemJob.cpp	2008-09-28 20:56:35 UTC (rev 4530)
@@ -0,0 +1,107 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "stdinc.h"
+
+#include "FetchItemJob.h"
+
+#include "Container.h"
+#include "Creature.h"
+#include "CreatureController.h"
+#include "CreatureControllerManager.h"
+#include "Inventory.h"
+#include "Item.h"
+#include "MathUtil.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+	FetchItemJob::FetchItemJob(Creature* actor, Item* item, const Ogre::String& targetSlot, Ogre::Real duration)
+		: Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
+		  mActor(CreatureControllerManager::getSingleton().getCreatureController(actor)),
+		  mItem(item),
+		  mTargetSlot(targetSlot),
+		  mTimeLeft(duration)
+	{
+	}
+
+
+    FetchItemJob::~FetchItemJob()
+	{
+	}
+
+    bool FetchItemJob::execute(Ogre::Real time)
+	{
+		// Check now, one frame after done, to make sure everything is
+		if (mTimeLeft < 0 || !mItem)
+		{
+			// Stay put where ever we are.
+			mActor->setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
+			return true;
+		}
+
+		Vector3 targetPos = mItem->getPosition();
+
+		// Are we there now?
+		Ogre::Real distance = MathUtil::distance(mItem->getWorldBoundingBox(),
+			mActor->getCreature()->getWorldBoundingBox());
+		if (distance < 1.0f)
+		{
+			mActor->setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
+            
+            switch (mItem->getState())
+            {
+                case GOS_IN_SCENE:
+                    // @todo play pickup animation
+                    mActor->getCreature()->getInventory()->hold(mItem, mTargetSlot);
+                    return true;
+                    break;
+                case GOS_IN_POSSESSION:
+                    Container* container = mItem->getParentContainer();
+                    if (container && container->hasAction(CeGuiString("open"), mActor->getCreature()))
+                    {
+                        container->doAction(CeGuiString("open"), mActor->getCreature(), mItem);
+                        container->removeItem(mItem);
+                        mActor->getCreature()->getInventory()->hold(mItem, mTargetSlot);
+                        return true;
+                    }
+                    break;
+                case GOS_READY:
+                case GOS_HELD:
+                    LOG_WARNING("FetchItemJob", "Target item is held by someone");
+                    return true;
+                    break;
+            }
+
+            return false;
+		}
+        else 
+        {
+            // Hard set orientation.
+            /// @todo Use CreatureController properly to turn smoothly
+            Vector3 pos = mActor->getCreature()->getPosition();
+            pos.y = 0;
+            targetPos.y = 0;
+            mActor->getCreature()->setOrientation(Vector3::NEGATIVE_UNIT_Z.getRotationTo(targetPos - pos));
+            mActor->setMovement(CreatureController::MT_LAUFEN, Vector3::NEGATIVE_UNIT_Z, Vector3::ZERO);
+            
+            mTimeLeft  -= time;
+            return false;            
+        }
+
+	}
+}

Modified: rl/trunk/engine/script/swig/RlRules.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.head.swig	2008-09-28 20:56:08 UTC (rev 4529)
+++ rl/trunk/engine/script/swig/RlRules.head.swig	2008-09-28 20:56:35 UTC (rev 4530)
@@ -31,6 +31,7 @@
 #include "Effect.h"
 #include "EffectFactory.h"
 #include "EigenschaftenStateSet.h"
+#include "FetchItemJob.h"
 #include "GameEventLog.h"
 #include "GameObject.h"
 #include "GameObjectManager.h"

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2008-09-28 20:56:08 UTC (rev 4529)
+++ rl/trunk/engine/script/swig/RlRules.swig	2008-09-28 20:56:35 UTC (rev 4530)
@@ -455,6 +455,14 @@
 		//GoToJob(rl::Creature* actor, rl::GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
     };
     
+    /// A rl#Job to fetch an item
+    class FetchItemJob : public Job
+    {
+    public:
+
+		FetchItemJob(rl::Creature* actor, rl::Item* item, const Ogre::String& targetSlot, Ogre::Real duration);
+    };
+    
     %feature("director") Item;
     class Item : public rl::GameObject {
     public:



From timm at mail.berlios.de  Sun Sep 28 23:31:55 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 28 Sep 2008 23:31:55 +0200
Subject: [Dsa-hl-svn] r4531 - in rl/branches/persistence/core: include src
Message-ID: <200809282131.m8SLVtX9008663@sheep.berlios.de>

Author: timm
Date: 2008-09-28 23:31:46 +0200 (Sun, 28 Sep 2008)
New Revision: 4531

Modified:
   rl/branches/persistence/core/include/Job.h
   rl/branches/persistence/core/src/Job.cpp
   rl/branches/persistence/core/src/RubyInterpreter.cpp
Log:
job becomes save able

Modified: rl/branches/persistence/core/include/Job.h
===================================================================
--- rl/branches/persistence/core/include/Job.h	2008-09-28 20:56:35 UTC (rev 4530)
+++ rl/branches/persistence/core/include/Job.h	2008-09-28 21:31:46 UTC (rev 4531)
@@ -47,7 +47,7 @@
          *         Job, after execution is finished. This should usually be the case, but
          *         sometimes it is sensible to pool a number of Jobs for reuse.
          */
-        AbstractJob(bool isDiscardable, 
+        AbstractJob(const CeGuiString &id, bool isDiscardable, 
             bool destroyWhenDone);
 
         virtual ~AbstractJob();

Modified: rl/branches/persistence/core/src/Job.cpp
===================================================================
--- rl/branches/persistence/core/src/Job.cpp	2008-09-28 20:56:35 UTC (rev 4530)
+++ rl/branches/persistence/core/src/Job.cpp	2008-09-28 21:31:46 UTC (rev 4531)
@@ -21,9 +21,11 @@
 namespace rl
 {
     AbstractJob::AbstractJob(bool isDiscardable, bool destroyWhenDone)
+    AbstractJob::AbstractJob(const CeGuiString &id, bool isDiscardable, bool destroyWhenDone)
         : mIsDiscardable(isDiscardable), 
+        mDestroyWhenDone(destroyWhenDone)
         mDestroyWhenDone(destroyWhenDone),
-		SaveAble("")
+		SaveAble(id)
     {
     }
 

Modified: rl/branches/persistence/core/src/RubyInterpreter.cpp
===================================================================
--- rl/branches/persistence/core/src/RubyInterpreter.cpp	2008-09-28 20:56:35 UTC (rev 4530)
+++ rl/branches/persistence/core/src/RubyInterpreter.cpp	2008-09-28 21:31:46 UTC (rev 4531)
@@ -153,10 +153,12 @@
 bool RubyInterpreter::executeFile(Ogre::String rubyfile)
 {
     bool error = execute("load '" + rubyfile + "'");
+#ifdef _DEBUG
     if (CoreSubsystem::getSingleton().isInitialized())
     {
         execute("load 'checkerrors.rb'");
     }
+#endif
     return error;
 }
 



From blakharaz at mail.berlios.de  Mon Sep 29 13:43:36 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 29 Sep 2008 13:43:36 +0200
Subject: [Dsa-hl-svn] r4532 - in rl/trunk/engine: rules rules/src ui
Message-ID: <200809291143.m8TBha7r032729@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-29 13:43:27 +0200 (Mon, 29 Sep 2008)
New Revision: 4532

Modified:
   rl/trunk/engine/rules/RlRules2005.vcproj
   rl/trunk/engine/rules/src/FetchItemJob.cpp
   rl/trunk/engine/ui/RlUI2005.vcproj
Log:
Fix for VC, also added to projects

Modified: rl/trunk/engine/rules/RlRules2005.vcproj
===================================================================
--- rl/trunk/engine/rules/RlRules2005.vcproj	2008-09-28 21:31:46 UTC (rev 4531)
+++ rl/trunk/engine/rules/RlRules2005.vcproj	2008-09-29 11:43:27 UTC (rev 4532)
@@ -359,6 +359,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\FetchItemJob.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\GameEventLog.cpp"
 				>
 			</File>
@@ -661,6 +665,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\FetchItemJob.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\GameEventLog.h"
 				>
 			</File>

Modified: rl/trunk/engine/rules/src/FetchItemJob.cpp
===================================================================
--- rl/trunk/engine/rules/src/FetchItemJob.cpp	2008-09-28 21:31:46 UTC (rev 4531)
+++ rl/trunk/engine/rules/src/FetchItemJob.cpp	2008-09-29 11:43:27 UTC (rev 4532)
@@ -46,8 +46,11 @@
 
     bool FetchItemJob::execute(Ogre::Real time)
 	{
-		// Check now, one frame after done, to make sure everything is
-		if (mTimeLeft < 0 || !mItem)
+		if (mTimeLeft < 0 
+			|| !mItem 
+			|| mItem->getState() == GOS_UNDEFINED
+			|| mItem->getState() == GOS_UNLOADED
+			|| mItem->getState() == GOS_LOADED)
 		{
 			// Stay put where ever we are.
 			mActor->setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
@@ -63,28 +66,28 @@
 		{
 			mActor->setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
             
-            switch (mItem->getState())
+            if (mItem->getState() == GOS_IN_SCENE)
             {
-                case GOS_IN_SCENE:
                     // @todo play pickup animation
                     mActor->getCreature()->getInventory()->hold(mItem, mTargetSlot);
                     return true;
-                    break;
-                case GOS_IN_POSSESSION:
-                    Container* container = mItem->getParentContainer();
-                    if (container && container->hasAction(CeGuiString("open"), mActor->getCreature()))
-                    {
-                        container->doAction(CeGuiString("open"), mActor->getCreature(), mItem);
-                        container->removeItem(mItem);
-                        mActor->getCreature()->getInventory()->hold(mItem, mTargetSlot);
-                        return true;
-                    }
-                    break;
-                case GOS_READY:
-                case GOS_HELD:
+			}
+            else if (mItem->getState() == GOS_IN_POSSESSION)
+			{
+				Container* container = mItem->getParentContainer();
+				if (container && container->hasAction(CeGuiString("open"), mActor->getCreature()))
+				{
+					container->doAction(CeGuiString("open"), mActor->getCreature(), mItem);
+					container->removeItem(mItem);
+					mActor->getCreature()->getInventory()->hold(mItem, mTargetSlot);
+					return true;
+				}
+			}
+            else if (mItem->getState() == GOS_READY
+					 || mItem->getState() == GOS_HELD)
+			{
                     LOG_WARNING("FetchItemJob", "Target item is held by someone");
                     return true;
-                    break;
             }
 
             return false;

Modified: rl/trunk/engine/ui/RlUI2005.vcproj
===================================================================
--- rl/trunk/engine/ui/RlUI2005.vcproj	2008-09-28 21:31:46 UTC (rev 4531)
+++ rl/trunk/engine/ui/RlUI2005.vcproj	2008-09-29 11:43:27 UTC (rev 4532)
@@ -476,6 +476,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\include\GameOverWindow.h"
+					>
+				</File>
+				<File
 					RelativePath=".\include\GameSaveLoadWindow.h"
 					>
 				</File>
@@ -717,6 +721,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\src\GameOverWindow.cpp"
+					>
+				</File>
+				<File
 					RelativePath=".\src\GameSaveLoadWindow.cpp"
 					>
 				</File>



From blakharaz at mail.berlios.de  Mon Sep 29 13:44:23 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 29 Sep 2008 13:44:23 +0200
Subject: [Dsa-hl-svn] r4533 - rl/trunk/engine/core/include
Message-ID: <200809291144.m8TBiNsS000015@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-29 13:44:22 +0200 (Mon, 29 Sep 2008)
New Revision: 4533

Modified:
   rl/trunk/engine/core/include/MessagePump.h
Log:
Added some logging

Modified: rl/trunk/engine/core/include/MessagePump.h
===================================================================
--- rl/trunk/engine/core/include/MessagePump.h	2008-09-29 11:43:27 UTC (rev 4532)
+++ rl/trunk/engine/core/include/MessagePump.h	2008-09-29 11:44:22 UTC (rev 4533)
@@ -52,7 +52,7 @@
 
         virtual bool Invoke(MessageObjectBase* obj)
         {
-            MessageObjectType* obj2 = (MessageObjectType*)obj;
+            MessageObjectType* obj2 = static_cast<MessageObjectType*>(obj);
             return obj2->Invoke(mHandler);
         }
 
@@ -127,6 +127,10 @@
             MessageHandlerMapEntry entry = {mNextConnectionId++, wrapper};
             entries->push_back(entry);
 
+            LOG_MESSAGE("MessagePump", 
+                "Added message handler for message type " 
+                + Ogre::StringConverter::toString(_MessageType::MessageTypeId));
+
             Connection con;
             con.pump = this;
             con.connectionId = entry.connectionId;
@@ -216,13 +220,14 @@
 
         // overloads from GameTask
 
-		virtual void run(Ogre::Real elapsedTime);
+        virtual void run(Ogre::Real elapsedTime);
 
         virtual const Ogre::String& getName() const;
 
     private:
         MessageHandlerMapEntries* getOrCreateMapEntries(int id) 
         {
+            LOG_MESSAGE("MessagePump", "Create or get id " + Ogre::StringConverter::toString(id));
             MessageHandlerMap::iterator it = mMessageHandlerMap.find(id);
             if(it == mMessageHandlerMap.end())
             {



From blakharaz at mail.berlios.de  Mon Sep 29 13:48:26 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 29 Sep 2008 13:48:26 +0200
Subject: [Dsa-hl-svn] r4534 - in rl/trunk/engine/rules: include src
Message-ID: <200809291148.m8TBmQTW000260@sheep.berlios.de>

Author: blakharaz
Date: 2008-09-29 13:48:25 +0200 (Mon, 29 Sep 2008)
New Revision: 4534

Modified:
   rl/trunk/engine/rules/include/PartyManager.h
   rl/trunk/engine/rules/src/PartyManager.cpp
Log:


Modified: rl/trunk/engine/rules/include/PartyManager.h
===================================================================
--- rl/trunk/engine/rules/include/PartyManager.h	2008-09-29 11:44:22 UTC (rev 4533)
+++ rl/trunk/engine/rules/include/PartyManager.h	2008-09-29 11:48:25 UTC (rev 4534)
@@ -28,17 +28,19 @@
     class _RlRulesExport PartyManager : public Ogre::Singleton<PartyManager>
     {
     public:
-        PartyManager();
+		typedef std::vector<Creature*> Party;
+
+		PartyManager();
         
         Creature* getActiveCharacter() const;
         void setActiveCharacter(Creature* character);
         void addCharacter(Creature* character);
         void removeCharacter(Creature* character);
-        std::vector<Creature*> getCharacters() const;
+        Party getCharacters() const;
         bool isInParty(Creature* creature) const;
         
     private:
-        std::vector<Creature*> mParty;
+		Party mParty;
         Creature* mActiveCharacter;
 	    MessagePump::ScopedConnection mLifeStateChangeConnection;
 

Modified: rl/trunk/engine/rules/src/PartyManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/PartyManager.cpp	2008-09-29 11:44:22 UTC (rev 4533)
+++ rl/trunk/engine/rules/src/PartyManager.cpp	2008-09-29 11:48:25 UTC (rev 4534)
@@ -28,18 +28,21 @@
 namespace rl
 {
     
-	PartyManager::PartyManager() : mActiveCharacter(NULL)
+	PartyManager::PartyManager()
+		: mActiveCharacter(NULL)
     {
         ///@todo watch characters for death, trigger game over if no-one is left
+        LOG_MESSAGE("PartyManager", "Register message handler");
         mLifeStateChangeConnection =
             MessagePump::getSingleton().addMessageHandler<MessageType_GameObjectLifeStateChanged>(
                 boost::bind(&PartyManager::onGameObjectLifeStateChanged, this, _1, _2, _3));
     }
-    
+
     void PartyManager::addCharacter(Creature* character)
     {
         mParty.push_back(character);
-        ///@todo send message
+        MessagePump::getSingleton().sendMessage<MessageType_PlayerCharRemoved>(
+			character);
         
         if (mActiveCharacter == NULL)
         {
@@ -54,9 +57,10 @@
         {
             if (*it == character)
             {
-                ///@todo send message
                 mParty.erase(it);
-                break;
+                MessagePump::getSingleton().sendMessage<MessageType_PlayerCharRemoved>(
+					character);
+				break;
             }
         }
         checkParty();
@@ -89,9 +93,9 @@
     
     bool PartyManager::isInParty(Creature* creature) const
     {
-        for (int i = 0; i < mParty.size(); ++i)
+		for (Party::const_iterator it = mParty.begin(); it != mParty.end(); ++it)
         {
-            if (mParty[i] == creature)
+            if (*it == creature)
             {
                 return true;
             }



From timm at mail.berlios.de  Mon Sep 29 17:15:58 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Mon, 29 Sep 2008 17:15:58 +0200
Subject: [Dsa-hl-svn] r4535 - in rl/branches/persistence/rules: include src
Message-ID: <200809291515.m8TFFwJD019482@sheep.berlios.de>

Author: timm
Date: 2008-09-29 17:15:48 +0200 (Mon, 29 Sep 2008)
New Revision: 4535

Modified:
   rl/branches/persistence/rules/include/PartyManager.h
   rl/branches/persistence/rules/src/PartyManager.cpp
Log:


Modified: rl/branches/persistence/rules/include/PartyManager.h
===================================================================
--- rl/branches/persistence/rules/include/PartyManager.h	2008-09-29 11:48:25 UTC (rev 4534)
+++ rl/branches/persistence/rules/include/PartyManager.h	2008-09-29 15:15:48 UTC (rev 4535)
@@ -28,17 +28,19 @@
     class _RlRulesExport PartyManager : public Ogre::Singleton<PartyManager>
     {
     public:
-        PartyManager();
+		typedef std::vector<Creature*> Party;
+
+		PartyManager();
         
         Creature* getActiveCharacter() const;
         void setActiveCharacter(Creature* character);
         void addCharacter(Creature* character);
         void removeCharacter(Creature* character);
-        std::vector<Creature*> getCharacters() const;
+        Party getCharacters() const;
         bool isInParty(Creature* creature) const;
         
     private:
-        std::vector<Creature*> mParty;
+		Party mParty;
         Creature* mActiveCharacter;
 	    MessagePump::ScopedConnection mLifeStateChangeConnection;
 

Modified: rl/branches/persistence/rules/src/PartyManager.cpp
===================================================================
--- rl/branches/persistence/rules/src/PartyManager.cpp	2008-09-29 11:48:25 UTC (rev 4534)
+++ rl/branches/persistence/rules/src/PartyManager.cpp	2008-09-29 15:15:48 UTC (rev 4535)
@@ -28,18 +28,21 @@
 namespace rl
 {
     
-	PartyManager::PartyManager() : mActiveCharacter(NULL)
+	PartyManager::PartyManager()
+		: mActiveCharacter(NULL)
     {
         ///@todo watch characters for death, trigger game over if no-one is left
+        LOG_MESSAGE("PartyManager", "Register message handler");
         mLifeStateChangeConnection =
             MessagePump::getSingleton().addMessageHandler<MessageType_GameObjectLifeStateChanged>(
                 boost::bind(&PartyManager::onGameObjectLifeStateChanged, this, _1, _2, _3));
     }
-    
+
     void PartyManager::addCharacter(Creature* character)
     {
         mParty.push_back(character);
-        ///@todo send message
+        MessagePump::getSingleton().sendMessage<MessageType_PlayerCharRemoved>(
+			character);
         
         if (mActiveCharacter == NULL)
         {
@@ -54,9 +57,10 @@
         {
             if (*it == character)
             {
-                ///@todo send message
                 mParty.erase(it);
-                break;
+                MessagePump::getSingleton().sendMessage<MessageType_PlayerCharRemoved>(
+					character);
+				break;
             }
         }
         checkParty();
@@ -89,9 +93,9 @@
     
     bool PartyManager::isInParty(Creature* creature) const
     {
-        for (int i = 0; i < mParty.size(); ++i)
+		for (Party::const_iterator it = mParty.begin(); it != mParty.end(); ++it)
         {
-            if (mParty[i] == creature)
+            if (*it == creature)
             {
                 return true;
             }



From timm at mail.berlios.de  Mon Sep 29 17:43:10 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Mon, 29 Sep 2008 17:43:10 +0200
Subject: [Dsa-hl-svn] r4536 - in rl/branches/persistence: core/include rules
	rules/include rules/src script/swig ui
Message-ID: <200809291543.m8TFhAAZ021195@sheep.berlios.de>

Author: timm
Date: 2008-09-29 17:43:00 +0200 (Mon, 29 Sep 2008)
New Revision: 4536

Added:
   rl/branches/persistence/rules/include/FetchItemJob.h
   rl/branches/persistence/rules/src/FetchItemJob.cpp
Modified:
   rl/branches/persistence/core/include/MessagePump.h
   rl/branches/persistence/rules/RlRules2005.vcproj
   rl/branches/persistence/rules/include/GameObject.h
   rl/branches/persistence/rules/src/GameObject.cpp
   rl/branches/persistence/script/swig/RlRules.head.swig
   rl/branches/persistence/script/swig/RlRules.swig
   rl/branches/persistence/ui/RlUI2005.vcproj
Log:
merged from trunk

Modified: rl/branches/persistence/core/include/MessagePump.h
===================================================================
--- rl/branches/persistence/core/include/MessagePump.h	2008-09-29 15:15:48 UTC (rev 4535)
+++ rl/branches/persistence/core/include/MessagePump.h	2008-09-29 15:43:00 UTC (rev 4536)
@@ -52,7 +52,7 @@
 
         virtual bool Invoke(MessageObjectBase* obj)
         {
-            MessageObjectType* obj2 = (MessageObjectType*)obj;
+            MessageObjectType* obj2 = static_cast<MessageObjectType*>(obj);
             return obj2->Invoke(mHandler);
         }
 
@@ -127,6 +127,10 @@
             MessageHandlerMapEntry entry = {mNextConnectionId++, wrapper};
             entries->push_back(entry);
 
+            LOG_MESSAGE("MessagePump", 
+                "Added message handler for message type " 
+                + Ogre::StringConverter::toString(_MessageType::MessageTypeId));
+
             Connection con;
             con.pump = this;
             con.connectionId = entry.connectionId;
@@ -216,13 +220,14 @@
 
         // overloads from GameTask
 
-		virtual void run(Ogre::Real elapsedTime);
+        virtual void run(Ogre::Real elapsedTime);
 
         virtual const Ogre::String& getName() const;
 
     private:
         MessageHandlerMapEntries* getOrCreateMapEntries(int id) 
         {
+            LOG_MESSAGE("MessagePump", "Create or get id " + Ogre::StringConverter::toString(id));
             MessageHandlerMap::iterator it = mMessageHandlerMap.find(id);
             if(it == mMessageHandlerMap.end())
             {

Modified: rl/branches/persistence/rules/RlRules2005.vcproj
===================================================================
--- rl/branches/persistence/rules/RlRules2005.vcproj	2008-09-29 15:15:48 UTC (rev 4535)
+++ rl/branches/persistence/rules/RlRules2005.vcproj	2008-09-29 15:43:00 UTC (rev 4536)
@@ -359,6 +359,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\src\FetchItemJob.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\src\GameEventLog.cpp"
 				>
 			</File>
@@ -661,6 +665,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\include\FetchItemJob.h"
+				>
+			</File>
+			<File
 				RelativePath=".\include\GameEventLog.h"
 				>
 			</File>

Copied: rl/branches/persistence/rules/include/FetchItemJob.h (from rev 4530, rl/trunk/engine/rules/include/FetchItemJob.h)

Modified: rl/branches/persistence/rules/include/GameObject.h
===================================================================
--- rl/branches/persistence/rules/include/GameObject.h	2008-09-29 15:15:48 UTC (rev 4535)
+++ rl/branches/persistence/rules/include/GameObject.h	2008-09-29 15:43:00 UTC (rev 4536)
@@ -41,7 +41,7 @@
     class _RlRulesExport GameObject 
         : public ActorNotifiedObject, 
           public ObjectStateChangeEventSource,
-		  public SaveAble
+		  public SaveAble
     {
     public:
         typedef std::vector<std::pair<Action*, int> > ActionOptionVector;
@@ -72,7 +72,7 @@
 		GameObject(const CeGuiString &id);
         virtual ~GameObject();
 
-        const CeGuiString& getClassId() const;
+        const CeGuiString& getClassId() const;
         void setClassId(const CeGuiString& classId);
         
         const CeGuiString& getName() const;
@@ -109,6 +109,13 @@
          */
         void setActor(Actor* actor);
         Actor* getActor();
+        
+        /**
+         * Check whether a creature can perform an action on this game object
+         *
+         * @return a boolean
+         */
+        bool hasAction(const CeGuiString& actionName, Creature* actor) const;
 
         /**
          * Get all valid actions a character can perfom on this game object
@@ -125,11 +132,11 @@
                    if the action wasn't triggered by someone (e.g. by time)
          *  @param target the action's target (can be <code>NULL</code> if no other game objects are involved)
          */
-        void doAction(const CeGuiString actionName,
+        void doAction(const CeGuiString& actionName,
                       Creature* actor,
                       GameObject* target);
 
-        void doAction(const CeGuiString actionName);
+        void doAction(const CeGuiString& actionName);
 
         void doAction(Action* action,
                       Creature* actor,
@@ -147,7 +154,7 @@
         const Ogre::Vector3& getPosition() const;
         Ogre::AxisAlignedBox getWorldBoundingBox() const;
 
-        /// Soll der Aktor ?berhaupt leuchten?
+        /// Soll der Aktor ??berhaupt leuchten?
         bool isHighlightingEnabled();
         void setHighlightingEnabled( bool highlightenabled );
 
@@ -230,6 +237,8 @@
 
         ActionOptionVector::iterator findAction(ActionOptionVector::iterator begin,
             ActionOptionVector::iterator end, const CeGuiString actionName);
+        ActionOptionVector::const_iterator findAction(ActionOptionVector::const_iterator begin,
+            ActionOptionVector::const_iterator end, const CeGuiString actionName) const;
         ActionOptionVector::iterator findAction(ActionOptionVector::iterator
             begin, ActionOptionVector::iterator end, const Action* action);    
     };

Copied: rl/branches/persistence/rules/src/FetchItemJob.cpp (from rev 4530, rl/trunk/engine/rules/src/FetchItemJob.cpp)
===================================================================
--- rl/trunk/engine/rules/src/FetchItemJob.cpp	2008-09-28 20:56:35 UTC (rev 4530)
+++ rl/branches/persistence/rules/src/FetchItemJob.cpp	2008-09-29 15:43:00 UTC (rev 4536)
@@ -0,0 +1,110 @@
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#include "stdinc.h"
+
+#include "FetchItemJob.h"
+
+#include "Container.h"
+#include "Creature.h"
+#include "CreatureController.h"
+#include "CreatureControllerManager.h"
+#include "Inventory.h"
+#include "Item.h"
+#include "MathUtil.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+	FetchItemJob::FetchItemJob(Creature* actor, Item* item, const Ogre::String& targetSlot, Ogre::Real duration)
+		: Job(false, true, TimeSource::REALTIME_INTERRUPTABLE),
+		  mActor(CreatureControllerManager::getSingleton().getCreatureController(actor)),
+		  mItem(item),
+		  mTargetSlot(targetSlot),
+		  mTimeLeft(duration)
+	{
+	}
+
+
+    FetchItemJob::~FetchItemJob()
+	{
+	}
+
+    bool FetchItemJob::execute(Ogre::Real time)
+	{
+		if (mTimeLeft < 0 
+			|| !mItem 
+			|| mItem->getState() == GOS_UNDEFINED
+			|| mItem->getState() == GOS_UNLOADED
+			|| mItem->getState() == GOS_LOADED)
+		{
+			// Stay put where ever we are.
+			mActor->setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
+			return true;
+		}
+
+		Vector3 targetPos = mItem->getPosition();
+
+		// Are we there now?
+		Ogre::Real distance = MathUtil::distance(mItem->getWorldBoundingBox(),
+			mActor->getCreature()->getWorldBoundingBox());
+		if (distance < 1.0f)
+		{
+			mActor->setMovement(CreatureController::MT_STEHEN, Vector3::ZERO, Vector3::ZERO);
+            
+            if (mItem->getState() == GOS_IN_SCENE)
+            {
+                    // @todo play pickup animation
+                    mActor->getCreature()->getInventory()->hold(mItem, mTargetSlot);
+                    return true;
+			}
+            else if (mItem->getState() == GOS_IN_POSSESSION)
+			{
+				Container* container = mItem->getParentContainer();
+				if (container && container->hasAction(CeGuiString("open"), mActor->getCreature()))
+				{
+					container->doAction(CeGuiString("open"), mActor->getCreature(), mItem);
+					container->removeItem(mItem);
+					mActor->getCreature()->getInventory()->hold(mItem, mTargetSlot);
+					return true;
+				}
+			}
+            else if (mItem->getState() == GOS_READY
+					 || mItem->getState() == GOS_HELD)
+			{
+                    LOG_WARNING("FetchItemJob", "Target item is held by someone");
+                    return true;
+            }
+
+            return false;
+		}
+        else 
+        {
+            // Hard set orientation.
+            /// @todo Use CreatureController properly to turn smoothly
+            Vector3 pos = mActor->getCreature()->getPosition();
+            pos.y = 0;
+            targetPos.y = 0;
+            mActor->getCreature()->setOrientation(Vector3::NEGATIVE_UNIT_Z.getRotationTo(targetPos - pos));
+            mActor->setMovement(CreatureController::MT_LAUFEN, Vector3::NEGATIVE_UNIT_Z, Vector3::ZERO);
+            
+            mTimeLeft  -= time;
+            return false;            
+        }
+
+	}
+}

Modified: rl/branches/persistence/rules/src/GameObject.cpp
===================================================================
--- rl/branches/persistence/rules/src/GameObject.cpp	2008-09-29 15:15:48 UTC (rev 4535)
+++ rl/branches/persistence/rules/src/GameObject.cpp	2008-09-29 15:43:00 UTC (rev 4536)
@@ -217,12 +217,37 @@
         }
         return actions;
     }
+    
+    bool GameObject::hasAction(const CeGuiString& actionName, Creature* actor) const
+    {
+        ActionOptionVector::const_iterator it =
+            findAction(mActions.begin(), mActions.end(), actionName);
+        
+        if (it == mActions.end())
+        {
+            return false;
+        }
 
-    void GameObject::doAction( const CeGuiString actionName,
+        LOG_DEBUG(Logger::RULES, "Untersuche Aktion "+(*it).first->getName());
+        if ((*it).second == Action::ACT_DISABLED)
+        {
+            return false;                
+        }
+        //if ((*it).second > ACT_NEEDS_TALENT)
+        if (actor != NULL && !(*it).first->canDo(const_cast<GameObject*>(this), actor)) // Aktion nicht m???glich
+        {
+            return false;
+        }
+        
+        return true;
+    }
+    
+    
+    void GameObject::doAction( const CeGuiString& actionName,
                               Creature* actor,
                               GameObject* target)
     {
-        ActionOptionVector::const_iterator it =
+        ActionOptionVector::iterator it =
             findAction(mActions.begin(), mActions.end(), actionName);
 
         if (it == mActions.end())
@@ -237,7 +262,7 @@
         }
     }
 
-    void GameObject::doAction(const CeGuiString actionName)
+    void GameObject::doAction(const CeGuiString& actionName)
     {
         doAction(actionName, NULL, NULL);
     }
@@ -288,6 +313,22 @@
         return end;
     }
 
+    GameObject::ActionOptionVector::const_iterator
+    GameObject::findAction(
+                           GameObject::ActionOptionVector::const_iterator begin,
+                           GameObject::ActionOptionVector::const_iterator end,
+                           const CeGuiString actionName) const
+    {
+        for (ActionOptionVector::const_iterator iter = begin; iter != end; ++iter)
+        {
+            Action* action = (*iter).first;
+            
+            if (action->getName().compare(actionName) == 0)
+                return iter;
+        }
+        return end;
+    }
+    
     GameObject::ActionOptionVector::iterator
         GameObject::findAction(
             GameObject::ActionOptionVector::iterator begin,

Modified: rl/branches/persistence/script/swig/RlRules.head.swig
===================================================================
--- rl/branches/persistence/script/swig/RlRules.head.swig	2008-09-29 15:15:48 UTC (rev 4535)
+++ rl/branches/persistence/script/swig/RlRules.head.swig	2008-09-29 15:43:00 UTC (rev 4536)
@@ -31,6 +31,7 @@
 #include "Effect.h"
 #include "EffectFactory.h"
 #include "EigenschaftenStateSet.h"
+#include "FetchItemJob.h"
 #include "GameEventLog.h"
 #include "GameObject.h"
 #include "GameObjectManager.h"

Modified: rl/branches/persistence/script/swig/RlRules.swig
===================================================================
--- rl/branches/persistence/script/swig/RlRules.swig	2008-09-29 15:15:48 UTC (rev 4535)
+++ rl/branches/persistence/script/swig/RlRules.swig	2008-09-29 15:43:00 UTC (rev 4536)
@@ -453,6 +453,14 @@
 		//GoToJob(rl::Creature* actor, rl::GameObject* target, Ogre::Real maxDistance, Ogre::Real duration);
     };
     
+    /// A rl#Job to fetch an item
+    class FetchItemJob : public Job
+    {
+    public:
+
+		FetchItemJob(rl::Creature* actor, rl::Item* item, const Ogre::String& targetSlot, Ogre::Real duration);
+    };
+    
     %feature("director") Item;
     class Item : public rl::GameObject {
     public:

Modified: rl/branches/persistence/ui/RlUI2005.vcproj
===================================================================
--- rl/branches/persistence/ui/RlUI2005.vcproj	2008-09-29 15:15:48 UTC (rev 4535)
+++ rl/branches/persistence/ui/RlUI2005.vcproj	2008-09-29 15:43:00 UTC (rev 4536)
@@ -476,6 +476,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\include\GameOverWindow.h"
+					>
+				</File>
+				<File
 					RelativePath=".\include\GameSaveLoadWindow.h"
 					>
 				</File>
@@ -717,6 +721,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\src\GameOverWindow.cpp"
+					>
+				</File>
+				<File
 					RelativePath=".\src\GameSaveLoadWindow.cpp"
 					>
 				</File>



