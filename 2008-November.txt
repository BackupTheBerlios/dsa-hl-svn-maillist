From melven at mail.berlios.de  Mon Nov  3 16:50:04 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Mon, 3 Nov 2008 16:50:04 +0100
Subject: [Dsa-hl-svn] r4571 - in rl/branches/newton20: editors/Lockenwickler
	editors/Lockenwickler/src editors/Lockenwickler/src/media/icons
	editors/Lockenwickler/ui files engine/ui/include engine/ui/src
Message-ID: <200811031550.mA3Fo4XT004499@sheep.berlios.de>

Author: melven
Date: 2008-11-03 16:49:51 +0100 (Mon, 03 Nov 2008)
New Revision: 4571

Added:
   rl/branches/newton20/editors/Lockenwickler/src/GOStringEditor.py
   rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py
   rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassManager.py
   rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassView.py
   rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py
   rl/branches/newton20/editors/Lockenwickler/src/Ui_GOPropertyEditorDialogSTRING.py
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/agt_games.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/agt_multimedia.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/lockenwickler_provisorium.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/lockenwickler_provisorium_small.png
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/multirow.png
   rl/branches/newton20/editors/Lockenwickler/ui files/GOPropertyEditorDialogINT.ui
   rl/branches/newton20/editors/Lockenwickler/ui files/GOPropertyEditorDialogSTRING.ui
   rl/branches/newton20/editors/Lockenwickler/ui files/PropertyEditorDialog.ui
Removed:
   rl/branches/newton20/editors/Lockenwickler/ui files/FourPanelView.ui
   rl/branches/newton20/editors/Lockenwickler/ui files/batch_convert_ui.py
   rl/branches/newton20/editors/Lockenwickler/ui files/console_window.ui
   rl/branches/newton20/editors/Lockenwickler/ui files/lockewickler.ui
   rl/branches/newton20/editors/Lockenwickler/ui files/model_preview.ui
   rl/branches/newton20/editors/Lockenwickler/ui files/object_property.ui
   rl/branches/newton20/editors/Lockenwickler/ui files/preferences_dialog.ui
   rl/branches/newton20/editors/Lockenwickler/ui files/ui_ConsoleWindow.py
   rl/branches/newton20/editors/Lockenwickler/ui files/ui_FourPanelView.py
   rl/branches/newton20/editors/Lockenwickler/ui files/ui_lw.py
   rl/branches/newton20/editors/Lockenwickler/ui files/ui_model_prev.py
   rl/branches/newton20/editors/Lockenwickler/ui files/ui_obj_prop.py
   rl/branches/newton20/editors/Lockenwickler/ui files/ui_pref_dialog.py
Modified:
   rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p
   rl/branches/newton20/editors/Lockenwickler/src/ConsoleWindow.py
   rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py
   rl/branches/newton20/editors/Lockenwickler/src/ModelSelectionDialog.py
   rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py
   rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py
   rl/branches/newton20/editors/Lockenwickler/src/Plugins-linux.cfg
   rl/branches/newton20/editors/Lockenwickler/src/PreferencesDialog.py
   rl/branches/newton20/engine/ui/include/CombatControlState.h
   rl/branches/newton20/engine/ui/src/CombatControlState.cpp
   rl/branches/newton20/engine/ui/src/CombatGui.cpp
Log:
-merged changes from trunk (Lockenwickler)
-implemented camera-movement with third-person view (if zooming in) in the combat-control-state,
 (works, but needs still some improvements to make it look nicer!)


Modified: rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Project SYSTEM "Project-4.5.dtd">
 <!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2008-10-16, 19:21:23 -->
+<!-- Saved: 2008-10-31, 11:20:58 -->
 <!-- Copyright (C) 2008 Stefan Stammberger, sstammberger at web.de -->
 <Project version="4.5">
   <ProgLanguage mixed="0">Python</ProgLanguage>
@@ -23,25 +23,20 @@
     <Source>src/PythonOgreConfig.py</Source>
     <Source>src/ui_ConsoleWindow.py</Source>
     <Source>src/ui_pref_dialog.py</Source>
-    <Source>ui files/batch_convert_ui.py</Source>
-    <Source>ui files/ui_ConsoleWindow.py</Source>
-    <Source>ui files/ui_FourPanelView.py</Source>
-    <Source>ui files/ui_lw.py</Source>
-    <Source>ui files/ui_model_prev.py</Source>
-    <Source>ui files/ui_obj_prop.py</Source>
-    <Source>ui files/ui_pref_dialog.py</Source>
     <Source>src/SceneExplorer.py</Source>
     <Source>src/Property.py</Source>
     <Source>src/ViewportGrid.py</Source>
     <Source>src/ObjectPropertyModel.py</Source>
+    <Source>src/GameObjectClass.py</Source>
+    <Source>src/GameObjectClassManager.py</Source>
+    <Source>src/setup.py</Source>
+    <Source>src/GameObjectClassView.py</Source>
+    <Source>src/MyRaySceneQueryListener.py</Source>
+    <Source>src/GOStringEditor.py</Source>
   </Sources>
   <Forms>
-    <Form>ui files/console_window.ui</Form>
-    <Form>ui files/FourPanelView.ui</Form>
-    <Form>ui files/lockewickler.ui</Form>
-    <Form>ui files/model_preview.ui</Form>
-    <Form>ui files/object_property.ui</Form>
-    <Form>ui files/preferences_dialog.ui</Form>
+    <Form>ui files/GOPropertyEditorDialogINT.ui</Form>
+    <Form>ui files/GOPropertyEditorDialogSTRING.ui</Form>
   </Forms>
   <Translations>
   </Translations>

Modified: rl/branches/newton20/editors/Lockenwickler/src/ConsoleWindow.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ConsoleWindow.py	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/src/ConsoleWindow.py	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,74 +1,74 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from ui_ConsoleWindow import *
-import ogre.renderer.OGRE as og
-
-
-
-class LockenLog(og.LogListener):
-    def __init__(self, logFunction):
-        og.LogListener.__init__(self)
-        self.logFunction = logFunction
-
-    def messageLogged(self, message, level, debug, logName):
-        self.logFunction(str(message))
-
-class ConsoleWindow(QtGui.QDialog):
-    def __init__(self, filterLog, parent=None):
-        QtGui.QDialog.__init__(self, parent)
-        self.filterLog = filterLog
-
-        self.consoleWindow = Ui_ConsoleWindow()
-        self.consoleWindow.setupUi(self)
-        self.consoleWindow.textEdit.setReadOnly(True)
-        self.lockenLog = LockenLog(self.write)
-
-        sys.stdout = self
-        sys.stderr = self
-
-        clearAction= QAction("Clear Window",  self)
-        self.consoleWindow.textEdit.addAction(clearAction)
-        self.consoleWindow.textEdit.setContextMenuPolicy(Qt.ActionsContextMenu)
-        clearAction.setShortcut("Ctrl + R")
-        self.connect(clearAction, SIGNAL("triggered()"), self.consoleWindow.textEdit.clear)
-
-
-    def write(self, text):
-        if self.filterLog:
-            if text.isspace():
-                return
-            elif text.startswith("Error"):
-                self.consoleWindow.textEdit.append(text)
-                return
-            elif text.startswith("OGRE EXCEPTION"):
-                self.consoleWindow.textEdit.append(text)
-                return
-            elif text.startswith("dbg:"):
-                self.consoleWindow.textEdit.append(text)
-                return
-        else:
-            self.consoleWindow.textEdit.append(text)
-
-    def clear(self):
-        self.consoleWindow.textEdit.clear()
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from ui_ConsoleWindow import *
+import ogre.renderer.OGRE as og
+
+
+
+class LockenLog(og.LogListener):
+    def __init__(self, logFunction):
+        og.LogListener.__init__(self)
+        self.logFunction = logFunction
+
+    def messageLogged(self, message, level, debug, logName):
+        self.logFunction(str(message))
+
+class ConsoleWindow(QtGui.QDialog):
+    def __init__(self, filterLog, parent=None):
+        QtGui.QDialog.__init__(self, parent)
+        self.filterLog = filterLog
+
+        self.consoleWindow = Ui_ConsoleWindow()
+        self.consoleWindow.setupUi(self)
+        self.consoleWindow.textEdit.setReadOnly(True)
+        self.lockenLog = LockenLog(self.write)
+
+        sys.stdout = self
+        sys.stderr = self
+
+        clearAction= QAction("Clear Window",  self)
+        self.consoleWindow.textEdit.addAction(clearAction)
+        self.consoleWindow.textEdit.setContextMenuPolicy(Qt.ActionsContextMenu)
+        clearAction.setShortcut("Ctrl + R")
+        self.connect(clearAction, SIGNAL("triggered()"), self.consoleWindow.textEdit.clear)
+
+
+    def write(self, text):
+        if self.filterLog:
+            if text.isspace():
+                return
+            elif text.startswith("Error"):
+                self.consoleWindow.textEdit.append(text)
+                return
+            elif text.startswith("OGRE EXCEPTION"):
+                self.consoleWindow.textEdit.append(text)
+                return
+            elif text.startswith("dbg:"):
+                self.consoleWindow.textEdit.append(text)
+                return
+        else:
+            self.consoleWindow.textEdit.append(text)
+
+    def clear(self):
+        self.consoleWindow.textEdit.clear()

Copied: rl/branches/newton20/editors/Lockenwickler/src/GOStringEditor.py (from rev 4567, rl/trunk/editors/Lockenwickler/src/GOStringEditor.py)

Copied: rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py (from rev 4567, rl/trunk/editors/Lockenwickler/src/GameObjectClass.py)
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2008-10-27 20:25:20 UTC (rev 4567)
+++ rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py	2008-11-03 15:49:51 UTC (rev 4571)
@@ -0,0 +1,176 @@
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+from elementtree.ElementTree import *
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from GOStringEditor import *
+
+class GOCStringProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "STRING"
+
+    def openEditor(self, row, parent = None):
+        dlg = GOStringEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCRealProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "REAL"
+
+class GOCBoolProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "BOOL"
+
+class GOCIntProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "INT"
+
+class GOCIntPairProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "INTPAIR"
+
+class GOCIntTripleProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "INTTRIPPLE"
+
+class GOCMapProperty():
+    def __init__(self, name):
+        self.name = name
+        self.childProperties = []
+
+    def getType(self):
+        return "MAP"
+
+class GameObjectRepresentation():
+    def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
+        self.inWorldId = inWorldId
+        self.goc = gameObjectClass
+        self.node = node
+        self.meshFile = meshFile
+
+    def setPosition(self, pos):
+        self.node.setPosition(pos)
+
+
+class GameObjectClass():
+    def __init__(self,  parentElement):
+        self.classid = parentElement.get("classid")
+        self.baseclass = parentElement.get("baseclass")
+
+        self.meshFile = None
+
+        self.properties = []
+
+        for property in parentElement:#.getiterator("property"):
+            if property.get("type") == "ARRAY":
+                pass
+            elif property.get("type") == "MAP":
+                self.properties.append(self.createPropertyMap(property))
+            else:
+                self.properties.append(self.createProperty(property))
+
+    def getType(self):
+        return "GAME_OBJECT"
+
+    def createPropertyMap(self, property):
+        propMap = GOCMapProperty(property.get("name"))
+        for subProperty in property:
+            if subProperty.get("type") == "MAP":
+                propMap.childProperties.append(self.createPropertyMap(property))
+            else:
+                for subProperty1 in property:
+                    propMap.childProperties.append(self.createProperty(subProperty1))
+
+        return propMap
+
+    def getMeshFileName(self):
+        if self.meshFile is None:
+            for prop in self.properties:
+                if prop.getType() == "STRING":
+                    if prop.name == "meshfile":
+                        self.meshFile = prop.data
+                        return self.meshFile
+            return None
+        else:
+            return self.meshFile
+
+
+    def createProperty(self, property):
+        if property.get("type") == "STRING":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCStringProperty(name, data)
+        elif property.get("type") == "REAL":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCRealProperty(name, data)
+        elif property.get("type") == "BOOL":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCBoolProperty(name, data)
+        elif property.get("type") == "INT":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCIntProperty(name, data)
+        elif property.get("type") == "INTPAIR":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCIntPairProperty(name, data)
+        elif property.get("type") == "INTTRIPLE":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCIntTripleProperty(name, data)
+        else:
+            print property.get("type")
+
+
+

Copied: rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassManager.py (from rev 4567, rl/trunk/editors/Lockenwickler/src/GameObjectClassManager.py)
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GameObjectClassManager.py	2008-10-27 20:25:20 UTC (rev 4567)
+++ rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassManager.py	2008-11-03 15:49:51 UTC (rev 4571)
@@ -0,0 +1,52 @@
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+from elementtree.ElementTree import parse
+
+from GameObjectClass import *
+
+class GameObjectClassManager():
+    def __init__(self):
+        self.fileDict = {}
+        self.callback = None
+
+    def parseGOFFiles(self, filePaths):
+        for filePath in filePaths:
+            tree = parse(filePath)
+            gocList = []
+            for parent in tree.getiterator("gameobjectclass"): # return all allements with the "gameobjectclass" tag
+                go = GameObjectClass(parent)
+                gocList.append(go)
+
+            self.fileDict[filePath] = gocList
+
+        if self.callback is not None:
+            self.callback(self.fileDict)
+
+    def getGameObjectWithClassId(self, id):
+        for key in self.fileDict:
+            for go in self.fileDict[key]:
+                if go.classid == id:
+                    return go
+
+        return None
+
+        # whenever a gameobject changes outside of the view, the view has to update itself wth the new values
+    def setGameObjectsViewUpdateCallback(self, callback):
+        self.callback = callback
+

Copied: rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassView.py (from rev 4567, rl/trunk/editors/Lockenwickler/src/GameObjectClassView.py)
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GameObjectClassView.py	2008-10-27 20:25:20 UTC (rev 4567)
+++ rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassView.py	2008-11-03 15:49:51 UTC (rev 4571)
@@ -0,0 +1,139 @@
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from GameObjectClass import *
+
+# The drag events are processed in ObgreMainWindow.py
+
+class GoTreeWidget(QTreeWidget):
+    def __init__(self, parent = None):
+        super(GoTreeWidget, self).__init__(parent)
+        self.setDragEnabled(True)
+
+    def startDrag(self,  dropActions):
+        data = QByteArray()
+        stream = QDataStream(data,  QIODevice.WriteOnly)
+        stream << self.currentItem().text(0)
+        mimeData = QMimeData()
+        mimeData.setData("application/x-game_object", data)
+        drag = QDrag(self)
+        drag.setMimeData(mimeData)
+        drag.start(Qt.CopyAction)
+
+class GameObjectClassView(QWidget):
+    def __init__(self, gocManager, parent = None):
+        super(GameObjectClassView, self).__init__(parent)
+        self.gocManager = gocManager
+        self.gocManager.setGameObjectsViewUpdateCallback(self.updateObjectList)
+
+        self.gameObjectDict = {}
+
+        self.setupUi()
+
+    def addItemToDict(self, property, item):
+        self.gameObjectDict[item] = property
+
+    def setupUi(self):
+        self.setObjectName("gameObjectClassView")
+        self.resize(QSize(QRect(0,0,272,744).size()).expandedTo(self.minimumSizeHint()))
+
+        self.gridlayout = QGridLayout(self)
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.treeWidget = GoTreeWidget()
+        self.treeWidget.setColumnCount(3)
+        self.treeWidget.setObjectName("ObjectTreeView")
+
+        self.gridlayout.addWidget(self.treeWidget , 1, 0, 1, 1)
+
+        self.setWindowTitle(QApplication.translate("objectPreviewDialog", "Dialog", None, QApplication.UnicodeUTF8))
+        self.connect(self.treeWidget, SIGNAL("itemDoubleClicked (QTreeWidgetItem *,int)"), self.onDoubleClick)
+        QMetaObject.connectSlotsByName(self)
+
+    def onDoubleClick(self, item,  row):
+        if self.gameObjectDict[item].getType() == "MAP" or self.gameObjectDict[item].getType() == "ARRAY"or self.gameObjectDict[item].getType() == "GAME_OBJECT":
+            print "NOT YET :)"
+        else:
+            if self.gameObjectDict[item].openEditor(row, self):
+                item.setText(0, str(self.gameObjectDict[item].name))
+                item.setText(2, str(self.gameObjectDict[item].data))
+
+
+
+    def createPropertyMapItem(self, property, parentItem):
+        for subProperty in property.childProperties:
+            if subProperty is not None:
+                if subProperty.getType() == "MAP":
+                    item = QTreeWidgetItem(parentItem)
+                    self.addItemToDict(subProperty, item)
+                    item.setText(0, subProperty.name)
+                    item.setText(1, subProperty.getType())
+                    self.createPropertyMapItem(property, item)
+                else:
+                    item = QTreeWidgetItem(parentItem)
+                    self.addItemToDict(subProperty, item)
+                    item.setText(0, subProperty.name)
+                    item.setText(1, subProperty.getType())
+                    if not subProperty.getType() == "ARRAY":
+                        item.setText(2, subProperty.data)
+
+
+    def updateObjectList(self,  objectsDict):
+        for key in objectsDict:
+            changeColor = True
+            file = objectsDict[key]
+            fileItem = QTreeWidgetItem(self.treeWidget)
+            fileItem.setText(0, str(key))
+            fileItem.setIcon(0, QIcon("media/icons/filenew.png"))
+
+            for go in file:
+                goItem = QTreeWidgetItem(fileItem)
+                self.addItemToDict(go, goItem)
+                goItem.setIcon(0, QIcon("media/icons/agt_games.png"))
+                if changeColor:
+                    goItem.setBackgroundColor(0, QColor("lightGray"))
+                    goItem.setBackgroundColor(1, QColor("lightGray"))
+                    goItem.setBackgroundColor(2, QColor("lightGray"))
+                goItem.setText(0, str(go.classid))
+                goItem.setText(1, str(go.baseclass))
+                changeColor = not changeColor
+
+                changeColor2 = False
+                for prop in go.properties:
+                    item1 = QTreeWidgetItem(goItem) #the property item, needs to be created regardless the type
+                    self.addItemToDict(prop, item1)
+                    if changeColor:
+                        item1.setBackgroundColor(0, QColor("lightGray"))
+                        item1.setBackgroundColor(1, QColor("lightGray"))
+                        item1.setBackgroundColor(2, QColor("lightGray"))
+                    item1.setIcon(0, QIcon("media/icons/agt_multimedia.png"))
+                    item1.setText(0, str(prop.name))
+                    item1.setText(1, prop.getType())
+                    if prop.getType() is "MAP":
+                        self.createPropertyMapItem(prop, item1)
+                    elif prop.getType() is "ARRAY":
+                        pass
+                    else:
+                        item1.setText(2, unicode(prop.data))
+
+                    changeColor2 = not changeColor
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py	2008-11-03 15:49:51 UTC (rev 4571)
@@ -21,8 +21,8 @@
 import sys
 import platform
 
-sys.path.insert(0,'..')
-import PythonOgreConfig
+#sys.path.insert(0,'..')
+#import PythonOgreConfig
 
 from random import randint
 from os.path import isfile
@@ -31,6 +31,7 @@
 from PreferencesDialog import *
 from ObjectPropertyWin import *
 from ModelSelectionDialog import *
+from GameObjectClassView import *
 from ConsoleWindow import *
 from ModuleManager import *
 from SceneExplorer import *
@@ -42,9 +43,15 @@
     def __init__(self, parent=None):
         QtGui.QWidget.__init__(self, parent)
 
+        pixmap = QPixmap("media/icons/lockenwickler_provisorium.png")
+        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
+        splash.setMask(pixmap.mask())
+        splash.showMessage("Starting...")
+        splash.show()
+
         self.setupUi()
 
-        self.consoleWindow = ConsoleWindow(True,  self)
+        self.consoleWindow = ConsoleWindow(False,  self)
 
         self.setupOgre()
 
@@ -52,6 +59,7 @@
         self.objectPropertyWin = ObjectPropertyWin(self)
         self.sceneExplorerWin = SceneExplorer(self)
         self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
 
         self.createDockWindows()
 
@@ -63,6 +71,7 @@
         self.restoreGeometry(settings.value("MainWindow/Geometry").toByteArray())
         self.restoreState(settings.value("MainWindow/DockWindows").toByteArray())
 
+        self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
         self.setWindowTitle("Rastullahs Lockenwickler")
 #        # Import Psyco if available
 #        try:
@@ -75,6 +84,8 @@
 
         #QtGui.QApplication.setKeyboardInputInterval(5000)
 
+        splash.finish(self)
+
     def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
         action = QtGui.QAction(text, self)
         if icon is not None:
@@ -174,6 +185,9 @@
         self.actionObject_Selection = self.createAction("&Model Preview Window",  self.toggleModelPreviewWindow,  "Alt + O",  "tux.png",  "Model Preview")
         self.actionObject_Selection.setObjectName("actionObject_Selection")
 
+        self.actionGameObjectClass_Selection = self.createAction("&Game Object Class Preview Window",  self.toggleGameObjectViewWindow,  "Alt + G",  "multirow.png",  "GameObjectClass Preview")
+        self.actionGameObjectClass_Selection.setObjectName("actionObject_Selection")
+
         self.actionConsole_Window = self.createAction("&Console Window",  self.toggleConsoleWindow,  "Alt + C",  "console.png",  "Console Window")
         self.actionConsole_Window.setObjectName("actionConsole_Window")
 
@@ -197,6 +211,7 @@
         self.menuView.addAction(self.actionPreferences)
         self.menuView.addAction(self.actionProperty_Window)
         self.menuView.addAction(self.actionObject_Selection)
+        self.menuView.addAction(self.actionGameObjectClass_Selection)
         self.menuView.addAction(self.actionConsole_Window)
         self.menubar.addAction(self.menuFile.menuAction())
         self.menubar.addAction(self.menuEdit.menuAction())
@@ -299,6 +314,12 @@
         else:
             self.modelSelectionDock.hide()
 
+    def toggleGameObjectViewWindow(self):
+        if self.gameObjectClassViewDock.isHidden():
+            self.gameObjectClassViewDock.show()
+        else:
+            self.gameObjectClassViewDock.hide()
+
     def toggleSceneExplorer(self):
         if self.sceneExplorerDock.isHidden():
             self.sceneExplorerDock.show()
@@ -338,7 +359,7 @@
             pass
 
         self.mapFiles = [] # a list in case the module has more than one map file
-
+        self.gofFiles = [] # gof File list
         for line in f:
             lStripped = line.strip() #strip the whitespace away, not needed here
 
@@ -364,11 +385,19 @@
             self.mapFiles.append(mf)
 
         command = (os.path.join(self.workingDir,  "maps") + "/*.scene")
-        for mf in glob.glob(command): # search for all xml files in the maps directory and add them
+        for mf in glob.glob(command): # search for all .scene files in the maps directory and add them
             self.mapFiles.append(mf)
 
-        self.moduleManager.load(moduleName,  self.mapFiles)
+        command = (os.path.join(self.workingDir,  "dsa") + "/*.gof")
+        for gf in glob.glob(command): # search for all .gof files in the dsa directory in the module dir
+            self.gofFiles.append(gf)
 
+        command = (os.path.join(self.workingDirCommon,  "dsa") + "/*.gof")
+        for gf in glob.glob(command): # search for all .gof files in the dsa directory in the common module dir
+            self.gofFiles.append(gf)
+
+        self.moduleManager.load(moduleName,  self.mapFiles,  self.gofFiles)
+
     def setResourcePaths(self, path, moduleName):
         for file in os.listdir(path):
             curFile = path + "/" + file
@@ -395,6 +424,12 @@
         self.modelSelectionDock.setWidget(self.modelSelectionDialog)
         self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
 
+        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr("GameObjectClasses"), self)
+        self.gameObjectClassViewDock.setObjectName("GameObjectClassView")
+        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
+
         self.sceneExplorerDock = QtGui.QDockWidget(self.tr("Scene Explorer"), self)
         self.sceneExplorerDock.setObjectName("SceneExplorerDockWindow")
         self.sceneExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)

Modified: rl/branches/newton20/editors/Lockenwickler/src/ModelSelectionDialog.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ModelSelectionDialog.py	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/src/ModelSelectionDialog.py	2008-11-03 15:49:51 UTC (rev 4571)
@@ -28,6 +28,7 @@
 import OgreWidget
 import ogre.renderer.OGRE as og
 
+# The drag events are processed in ObgreMainWindow.py
 
 class MyListWidget(QListWidget):
     def __init__(self,  parent):
@@ -39,7 +40,7 @@
         stream = QDataStream(data,  QIODevice.WriteOnly)
         stream << self.currentItem().text()
         mimeData = QMimeData()
-        mimeData.setData("application/x-text", data)
+        mimeData.setData("application/x-static_model", data)
         drag = QDrag(self)
         drag.setMimeData(mimeData)
         drag.start(Qt.CopyAction)

Modified: rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,603 +1,360 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-import sys
-import xml.dom.minidom as xml
-
-import ctypes
-import ogre.renderer.OGRE as og
-
-from MovePivot import *
-
-# a class to store information about a object that got selected
-class SelectionObject():
-    def __init__(self,  entity,  distance):
-        self.entityName = entity.getName()
-        self.entity = entity #the selected entity
-        self.distance = distance # the distance from camera at the time of selection
-        self.isPivot = False
-
-    #if True this instance will show its bounding box else it will hide it
-    def setSelected(self,  selected):
-        if selected == True:
-            self.entity.getParentNode().showBoundingBox(True)
-        else:
-            self.entity.getParentNode().showBoundingBox(False)
-
-    def __eq__(self, other):
-        return self.entity.getName() == other.entity.getName()
-
-    def __ne__(self, other):
-        return self.entity.getName() != other.entity.getName()
-
-class MyRaySceneQueryListener ( og.RaySceneQueryListener ):
-    def __init__( self ):
-        super ( MyRaySceneQueryListener, self ).__init__()
-        self.previouseSelection = None
-        self.selectionList = []
-        self.previousSelected = -1
-        self.currentSelected = -1
-
-        self.mNormalList = []
-        self.mVertexList = []
-        self.mIndexList = []
-
-        self.currentRay = None
-        self.lastRay = None
-
-    # sort algorithm for the selection list
-    def sortCompareImp(self,  x,  y):
-        if x.distance > y.distance:
-            return 1
-        elif x.distance == y.distance:
-            return 0
-        else: # x<y
-            return -1
-
-    def queryResult ( self, entity, distance ):
-        #print "dbg: " + entity.getName()
-        if distance == 0.0: #camera is in the bounding box, ignore this selection
-            return True
-#        elif entity.getName() == "rayLine" :
-#            return True
-        elif entity.getName() == "OgreMainWin::0::ViewportGrid":
-            return True
-        elif entity.isVisible() and entity.getName() == "EditorXArrow":
-            so = SelectionObject(entity,  distance)
-            so.isPivot = True
-            self.selectionList.append(so)
-            return False
-        elif entity.isVisible() and entity.getName() == "EditorYArrow":
-            so = SelectionObject(entity,  distance)
-            so.isPivot = True
-            self.selectionList.append(so)
-            return False
-        elif entity.isVisible() and entity.getName() == "EditorZArrow":
-            so = SelectionObject(entity,  distance)
-            so.isPivot = True
-            self.selectionList.append(so)
-            return False
-        elif entity.isVisible() and entity.getName() == "EditorFreeMover":
-            return True
-        elif entity.getName() == "EditorXRotator" or entity.getName() == "EditorYRotator" or entity.getName() == "EditorZRotator":
-            if entity.isVisible() and self.rayCastToPolygonLevelOnSingleMesh(self.currentRay,  entity):
-                so = SelectionObject(entity,  distance)
-                so.isPivot = True
-                self.selectionList.append(so)
-                return False
-            else:
-                return True
-        else:
-            so = SelectionObject(entity,  distance)
-            self.selectionList.append(so)
-
-        self.selectionList.sort(self.sortCompareImp)
-
-        return True
-
-    def reset(self):
-        self.previousSelected = -1
-        self.currentSelected = -1
-        del self.selectionList[:]
-        #self.selectionList = []
-
-#    def iterateEntityUnderMouse(self):
-#        self.previousSelected = self.currentSelected
-#        if len(self.selectionList) >= self.currentSelected: # would mean we are out of bounds
-#            self.selectionList[self.currentSelected].setSelected(False)
-#
-#        self.currentSelected += 1
-#
-#        if len(self.selectionList) == self.currentSelected: # means we are out of bounds and reached the end of the list, reset it to zero
-#            self.currentSelected = 0
-#
-#        if len(self.selectionList) >= self.currentSelected: # would mean we are out of bounds
-#            #print str(self.selectionList[self.currentSelected].distance) + " "  + self.selectionList[self.currentSelected].entity.getName()
-#            if self.rayCastToPolygonLevelOnCurrentSelection():
-#                self.selectionList[self.currentSelected].setSelected(True)
-#                return self.selectionList[self.currentSelected]
-
-
-    def getMeshInformation(self,  entity):
-        numVertices = 0
-        numIndices = 0
-        useSharedVertices = False
-
-        if not entity:
-            return False
-
-        pMesh = entity.getMesh()
-
-        pos =    entity.getParentNode().getWorldPosition()
-        orient = entity.getParentNode().getWorldOrientation()
-        scale =  entity.getParentNode().getScale()
-
-        for i in range ( pMesh.getNumSubMeshes() ):
-            pSubMesh = pMesh.getSubMesh(i)
-            if pSubMesh.useSharedVertices:
-                useSharedVertices = True
-            else:
-                numVertices += pSubMesh.vertexData.vertexCount
-            numIndices += pSubMesh.indexData.indexCount
-
-        if useSharedVertices:
-            numVertices += pMesh.sharedVertexData.vertexCount
-
-            storageclass = ctypes.c_float * 3
-            test=storageclass(0.0,  0.0,  0.0)
-#         mVertexList = new Point[numVertices];
-#         mIndexList = new unsigned int[numIndices];
-
-        self.mVertexList = []
-        self.mIndexList = []
-
-        ## Count the number of vertices and incides so we can Set them
-        indexCount = 0
-        vertListCount = 0
-
-        if useSharedVertices:
-            ## Real* pVertices (x, y, z order x numVertices)
-            elem = pMesh.sharedVertexData.vertexDeclaration.findElementBySemantic(og.VES_POSITION)
-
-            if not elem:
-                ogre.Except(Exception.ERR_ITEM_NOT_FOUND, "Can't find position elements in the "
-                    "mesh to be written!", "MeshSerializerImpl.writeGeometry")
-
-            vbuf = pMesh.sharedVertexData.vertexBufferBinding.getBuffer(elem.getSource())
-
-            ## need space for the 3 verticies
-            storageclass = ctypes.c_float * 3
-            test=storageclass(0.0,  0.0,  0.0)
-
-            for j in range ( pMesh.sharedVertexData.vertexCount ):
-                vbuf.readData(j * vbuf.getVertexSize(), 3 * ctype.sizeof(ctype.c_float), ctype.addressof(test))
-                self.mVertexList.append( og.Vector3(test[0], test[1], test[2]) )
-                vertListCount+=1
-
-        for i in range ( pMesh.getNumSubMeshes() ):
-            pSubMesh = pMesh.getSubMesh(i)
-            if not pSubMesh.useSharedVertices:
-                ## Real* pVertices (x, y, z order x numVertices)
-                elem = pSubMesh.vertexData.vertexDeclaration.findElementBySemantic(og.VES_POSITION)
-
-                if not elem:
-                    og.Except(Exception.ERR_ITEM_NOT_FOUND, "Can't find position elements in the "
-                        "mesh to be written!", "MeshSerializerImpl.writeGeometry")
-
-                vbuf = pSubMesh.vertexData.vertexBufferBinding.getBuffer(elem.getSource())
-
-                ## need space for the verticies
-                storageclass = ctypes.c_float * (pSubMesh.vertexData.vertexCount * 6)
-                test=storageclass(0.0)
-
-                vbuf.readData(0, pSubMesh.vertexData.vertexCount * 6 * ctypes.sizeof(ctypes.c_float), ctypes.addressof(test))
-
-                for j in range ( 0,  pSubMesh.vertexData.vertexCount * 6,  6):
-                    #print j
-                    p = og.Vector3(test[j], test[j+1], test[j+2])
-                    p /= scale
-                    p += pos
-                    p = orient * p
-                    self.mVertexList.append( p )
-                    vertListCount += 1
-
-            ibuf = pSubMesh.indexData.indexBuffer
-            ## need space for the verticies
-            storageclass = ctypes.c_ushort * pSubMesh.indexData.indexCount
-            test2=storageclass()
-
-
-            ibuf.readData(0, ibuf.getSizeInBytes(), ctypes.addressof(test2))
-            for j in range ( pSubMesh.indexData.indexCount ):
-                self.mIndexList.append (test2[j])   # unsigned short
-                indexCount += 1
-
-            ih = 0
-            for blah in self.mVertexList:
-                #print str(ih) + ": "  +  str(blah)
-                ih += 1
-
-#            for blah in self.mIndexList:
-#                print blah
-
-
-    # used when a new selection is made, meaning when not iterationg through the selected objects
-    def rayCastToPolygonLevel(self,  ray):
-        self.lastRay = ray
-
-        for so in self.selectionList:
-            if so.isPivot:
-                return so
-
-        if len(self.selectionList) >= 1:
-            for so in self.selectionList:
-                if self.rayCastToPolygonLevelOnSingleMesh(ray,  so.entity):
-                    return so
-
-
-    def rayCastToPolygonLevelOnSingleMesh(self,  ray,  entity):
-        return True
-        self.getMeshInformation(entity)
-        name = entity.getName()
-        print "dbg: " + name
-
-        temp = []
-        for vec in self.mVertexList:
-            temp.append(vec.x)
-            temp.append(vec.y)
-            temp.append(vec.z)
-
-        globalPosition = entity.getParentNode().getWorldPosition()
-        globalOrientation = entity.getParentNode().getWorldOrientation()
-
-
-        i = 0
-        while i <= (len(self.mIndexList) - 3):
-            verta = globalPosition + self.mVertexList[self.mIndexList[i]]
-            vertb = globalPosition + self.mVertexList[self.mIndexList[i+1]]
-            vertc = globalPosition + self.mVertexList[self.mIndexList[i+2]]
-
-            verta = globalOrientation * verta
-            vertb = globalOrientation * vertb
-            vertc = globalOrientation * vertc
-            normal = og.Math.calculateBasicFaceNormal(verta, vertb, vertc)
-
-            result = og.Math.intersects(ray, verta, vertb, vertc, True, True)
-            #result = og.Math.intersects(ray, globalPosition + self.mVertexList[self.mIndexList[i]], globalPosition + self.mVertexList[self.mIndexList[i+1]],
-            #                                                                                                                                              globalPosition + self.mVertexList[self.mIndexList[i+2]], normal,  True, True)
-
-            if result.first:
-                print "dbg: Treffer!!!!!!!!!"
-                return True
-
-            i += 3
-
-        return False
-
-    def rayCastToPolygonLevelOnCurrentSelection(self):
-        if len(self.selectionList) >= 1:
-            self.getMeshInformation(self.selectionList[self.currentSelected].entity)
-
-            i = 0
-            while i <= (len(self.mIndexList) - 3):
-                globalPosition = self.selectionList[self.currentSelected].entity.getParentNode().getPosition()
-                result = og.Math.intersects(self.lastRay, globalPosition + self.mVertexList[self.mIndexList[i]], globalPosition + self.mVertexList[self.mIndexList[i+1]],
-                                                                                                                                                          globalPosition + self.mVertexList[self.mIndexList[i+2]], True, True)
-
-                if result.first:
-                   return True
-
-                i += 3
-            return False
-
-class ModuleManager(object):
-    def __init__(self,  ogreRoot,  sceneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
-
-        self.userSelectionList = []
-        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
-        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-
-        self.listenerDings = MyRaySceneQueryListener()
-
-        self.lastRay = None
-#        self.rayLine = None
-
-        self.pivot = None
-        self.movingPivot = False
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.dropCount = 0
-        self.dropNode = None
-        self.dropEntity = None
-        self.dropCollisionPlane = og.Plane(og.Vector3.UNIT_Y, og.Vector3.ZERO)
-
-        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
-
-    def load(self,  moduleName,  mapFiles):
-        self.moduleName = moduleName
-        self.mapFiles = mapFiles
-
-        for a in self.mapFiles:
-            doc = xml.parse(a)
-            node = doc.getElementsByTagName("entity")
-            if node != None:
-                self.parseSceneNodes(node)
-
-        self.pivot = Pivot(self.sceneManager)
-        self.pivot.hide()
-
-    def parseSceneNodes(self,  nodeList):
-        for ent in nodeList:
-            entityName = ent.attributes["name"].nodeValue # get the name of the ent
-            meshFile = ent.attributes["meshfile"].nodeValue # meshfile
-            nodePosition = None
-            nodeRotation = None
-            nodeScale = None
-
-            for cn in ent.childNodes:
-                if cn.nodeType == cn.ELEMENT_NODE:
-                    if cn.localName == "position":
-                        px = float(cn.attributes["x"].nodeValue)
-                        py = float(cn.attributes["y"].nodeValue)
-                        pz = float(cn.attributes["z"].nodeValue)
-                        nodePosition = og.Vector3(px, py, pz)
-                        continue
-
-                    if cn.localName == "rotation":
-                        qw = float(cn.attributes["qw"].nodeValue)
-                        qx = float(cn.attributes["qx"].nodeValue)
-                        qy = float(cn.attributes["qy"].nodeValue)
-                        qz = float(cn.attributes["qz"].nodeValue)
-                        nodeRotation = og.Quaternion(qw,  qx, qy, qz)
-                        continue
-
-                    if cn.localName == "scale":
-                        px = float(cn.attributes["x"].nodeValue)
-                        py = float(cn.attributes["y"].nodeValue)
-                        pz = float(cn.attributes["z"].nodeValue)
-                        nodeScale = og.Vector3(px, py, pz)
-                        continue
-
-            try:
-                e = self.sceneManager.createEntity(entityName, meshFile)
-            except:
-                print "Warning: Meshfile " + meshFile + " could not be found."
-                return
-
-            n = self.sceneManager.getRootSceneNode().createChild(entityName + "_node")
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            #n.setOrientation(nodeRotation)
-            n.setScale(nodeScale)
-
-        pass
-
-    # called when a click into Main Ogre Window occurs
-    def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
-        self.listenerDings.reset()
-        self.lastRay = ray
-        self.listenerDings.currentRay = ray
-        self.raySceneQuery.Ray = ray
-        self.raySceneQuery.execute(self.listenerDings)
-
-        so = self.listenerDings.rayCastToPolygonLevel(ray)
-        if so is not None:
-            if not so.isPivot:
-                if self.pivot is not None:
-                    self.pivot.show()
-                if not controlDown and not shiftDown:
-                    self.resetSelection()
-                    so.setSelected(True)
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-                elif controlDown and not shiftDown:
-                    so.setSelected(True)
-
-                    for soFromList in self.userSelectionList:
-                        if soFromList == so:
-                            return # object already selected
-
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-
-
-                elif not controlDown and shiftDown:
-                    for selo in self.userSelectionList:
-                        if so == selo:
-                            so.setSelected(False)
-                            self.userSelectionList.remove(selo)
-                    self.updatePivots()
-            else:
-                #so.entity is the pivot direction that was clicked
-                self.pivot.startTransforming(so.entity,  self.userSelectionList)
-        else:
-            self.resetSelection() # click in empty space, deselect everything
-            if self.pivot is not None:
-                self.pivot.hide()
-
-#        if self.rayLine == None:
-#            self.rayLine = self.sceneManager.createManualObject("rayLine")
-#            self.rayLine.setDynamic(True)
-#            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
-#
-#            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-#
-#        else:
-#            self.rayLine.beginUpdate(0)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-
-    def deleteObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.pivot.hide()
-
-        for so in self.userSelectionList:
-            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
-            del so
-
-        self.userSelectionList = []
-
-    def incrementNameSuffixNumber(self, name):
-        newName = ""
-        split = name.split("_")
-        lastPart = len(split)-1
-        newName = name.rstrip(split[lastPart])
-        newName = newName + str(self.numerOfCopys)
-
-#        if split[lastPart].isdigit() and not split[lastPart].startswith("0"):
-#            num = int(split[lastPart])
-#            num = num + 1
-#            newName = name.rstrip(split[lastPart])
-#            newName = newName + str(num)
-#        else:
-#            newName = name + "_1"
-
-        self.numerOfCopys = self.numerOfCopys + 1
-        return newName
-
-    def copyObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        newSelectionList = []
-        print "dbg: "
-        for so in self.userSelectionList:
-            nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
-            newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
-
-            entityName = self.incrementNameSuffixNumber(so.entity.getName())
-            newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
-
-            newNode.attachObject(newEntity)
-            newNode.setPosition(so.entity.getParentNode().getPosition())
-            newNode.setOrientation(so.entity.getParentNode().getOrientation())
-            newNode.setScale(so.entity.getParentNode().getScale())
-
-            newSO = SelectionObject(newEntity, so.distance)
-            newSO.setSelected(True)
-            newSelectionList.append(newSO)
-
-        self.resetSelection()
-        self.userSelectionList = newSelectionList
-
-    def cutObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.cutList = []
-        for so in self.userSelectionList:
-            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
-            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
-            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
-            # so we only have to translate them to their new destination when they get pasted
-            # the position of the pivot point is considered as the center of gravity
-            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
-            self.cutList.append(so)
-        self.resetSelection()
-    def pasteObjects(self,  ray):
-        if len(self.cutList) < 1:
-            return
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
-                i = i+1
-        else:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
-                i = i+1
-        self.cutList = []
-
-    def leftMouseUp(self):
-        if self.pivot is not None and self.pivot.isTransforming:
-            self.pivot.stopTransforming()
-
-#    def iterateEntityUnderMouse(self):
-#        self.listenerDings.iterateEntityUnderMouse()
-#
-#        pass
-
-    def resetSelection(self):
-        for so in self.userSelectionList:
-            so.setSelected(False)
-
-        self.userSelectionList = []
-
-        self.listenerDings.reset()
-        pass
-
-
-    def updatePivots(self):
-        newPivotPosition = og.Vector3(0, 0, 0)
-
-        for so in self.userSelectionList:
-            newPivotPosition += so.entity.getParentNode().getPosition()
-        if self.pivot is not None:
-            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
-
-    def unload(self,  saveOnUnload=True):
-        pass
-
-    def save(self):
-        pass
-
-    def startDropModelAction(self, meshFile, ray):
-        self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-        self.dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
-        self.dropNode.attachObject(self.dropEntity)
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-        self.dropCount += 1
-
-    def moveDropModelAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-
-    def stopDropModelAction(self, ray):
-        pass
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+import sys
+import xml.dom.minidom as xml
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+from MovePivot import *
+from GameObjectClassManager import *
+from MyRaySceneQueryListener import *
+
+class ModuleManager(object):
+    def __init__(self,  ogreRoot,  sceneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
+
+        self.gocManager = GameObjectClassManager()
+
+        self.userSelectionList = []
+        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
+        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
+
+        self.listenerDings = MyRaySceneQueryListener()
+
+        self.lastRay = None
+#        self.rayLine = None
+
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.dropCount = 0
+        self.dropNode = None
+        self.dropEntity = None
+        self.dropCollisionPlane = og.Plane(og.Vector3.UNIT_Y, og.Vector3.ZERO)
+
+        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
+
+    def load(self,  moduleName,  mapFiles,  gofFiles):
+        self.moduleName = moduleName
+        self.mapFiles = mapFiles
+        self.gofFiles = gofFiles
+
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
+        for a in self.mapFiles:
+            doc = xml.parse(a)
+            node = doc.getElementsByTagName("entity")
+            if node != None:
+                self.parseSceneNodes(node)
+
+        self.pivot = Pivot(self.sceneManager)
+        self.pivot.hide()
+
+    def parseSceneNodes(self,  nodeList):
+        for ent in nodeList:
+            entityName = ent.attributes["name"].nodeValue # get the name of the ent
+            meshFile = ent.attributes["meshfile"].nodeValue # meshfile
+            nodePosition = None
+            nodeRotation = None
+            nodeScale = None
+
+            for cn in ent.childNodes:
+                if cn.nodeType == cn.ELEMENT_NODE:
+                    if cn.localName == "position":
+                        px = float(cn.attributes["x"].nodeValue)
+                        py = float(cn.attributes["y"].nodeValue)
+                        pz = float(cn.attributes["z"].nodeValue)
+                        nodePosition = og.Vector3(px, py, pz)
+                        continue
+
+                    if cn.localName == "rotation":
+                        qw = float(cn.attributes["qw"].nodeValue)
+                        qx = float(cn.attributes["qx"].nodeValue)
+                        qy = float(cn.attributes["qy"].nodeValue)
+                        qz = float(cn.attributes["qz"].nodeValue)
+                        nodeRotation = og.Quaternion(qw,  qx, qy, qz)
+                        continue
+
+                    if cn.localName == "scale":
+                        px = float(cn.attributes["x"].nodeValue)
+                        py = float(cn.attributes["y"].nodeValue)
+                        pz = float(cn.attributes["z"].nodeValue)
+                        nodeScale = og.Vector3(px, py, pz)
+                        continue
+
+            try:
+                e = self.sceneManager.createEntity(entityName, meshFile)
+            except:
+                print "Warning: Meshfile " + meshFile + " could not be found."
+                return
+
+            n = self.sceneManager.getRootSceneNode().createChild(entityName + "_node")
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            #n.setOrientation(nodeRotation)
+            n.setScale(nodeScale)
+
+        pass
+
+    # called when a click into Main Ogre Window occurs
+    def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
+        self.listenerDings.reset()
+        self.lastRay = ray
+        self.listenerDings.currentRay = ray
+        self.raySceneQuery.Ray = ray
+        self.raySceneQuery.execute(self.listenerDings)
+
+        so = self.listenerDings.rayCastToPolygonLevel(ray)
+        if so is not None:
+            if not so.isPivot:
+                if self.pivot is not None:
+                    self.pivot.show()
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+
+                    for soFromList in self.userSelectionList:
+                        if soFromList == so:
+                            return # object already selected
+
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+
+
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so == selo:
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                    self.updatePivots()
+            else:
+                #so.entity is the pivot direction that was clicked
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            self.resetSelection() # click in empty space, deselect everything
+            if self.pivot is not None:
+                self.pivot.hide()
+
+#        if self.rayLine == None:
+#            self.rayLine = self.sceneManager.createManualObject("rayLine")
+#            self.rayLine.setDynamic(True)
+#            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
+#
+#            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+#
+#        else:
+#            self.rayLine.beginUpdate(0)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+
+    def deleteObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.pivot.hide()
+
+        for so in self.userSelectionList:
+            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
+            del so
+
+        self.userSelectionList = []
+
+    def incrementNameSuffixNumber(self, name):
+        newName = ""
+        split = name.split("_")
+        lastPart = len(split)-1
+        newName = name.rstrip(split[lastPart])
+        newName = newName + str(self.numerOfCopys)
+
+#        if split[lastPart].isdigit() and not split[lastPart].startswith("0"):
+#            num = int(split[lastPart])
+#            num = num + 1
+#            newName = name.rstrip(split[lastPart])
+#            newName = newName + str(num)
+#        else:
+#            newName = name + "_1"
+
+        self.numerOfCopys = self.numerOfCopys + 1
+        return newName
+
+    def copyObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        newSelectionList = []
+        print "dbg: "
+        for so in self.userSelectionList:
+            nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
+            newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
+
+            entityName = self.incrementNameSuffixNumber(so.entity.getName())
+            newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+
+            newNode.attachObject(newEntity)
+            newNode.setPosition(so.entity.getParentNode().getPosition())
+            newNode.setOrientation(so.entity.getParentNode().getOrientation())
+            newNode.setScale(so.entity.getParentNode().getScale())
+
+            newSO = SelectionObject(newEntity, so.distance)
+            newSO.setSelected(True)
+            newSelectionList.append(newSO)
+
+        self.resetSelection()
+        self.userSelectionList = newSelectionList
+
+    def cutObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+            return
+
+        self.cutList = []
+        for so in self.userSelectionList:
+            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
+            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
+            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
+            # so we only have to translate them to their new destination when they get pasted
+            # the position of the pivot point is considered as the center of gravity
+            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
+            self.cutList.append(so)
+        self.resetSelection()
+    def pasteObjects(self,  ray):
+        if len(self.cutList) < 1:
+            return
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
+                i = i+1
+        else:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
+                i = i+1
+        self.cutList = []
+
+    def leftMouseUp(self):
+        if self.pivot is not None and self.pivot.isTransforming:
+            self.pivot.stopTransforming()
+
+#    def iterateEntityUnderMouse(self):
+#        self.listenerDings.iterateEntityUnderMouse()
+#
+#        pass
+
+    def resetSelection(self):
+        for so in self.userSelectionList:
+            so.setSelected(False)
+
+        self.userSelectionList = []
+
+        self.listenerDings.reset()
+        pass
+
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+        if self.pivot is not None:
+            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
+    def unload(self,  saveOnUnload=True):
+        pass
+
+    def save(self):
+        pass
+
+    def startDropGameObjectAction(self, classid, ray):
+        go = self.gocManager.getGameObjectWithClassId(classid)
+        meshFile = go.getMeshFileName()
+
+        if go is not None:
+            dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+            dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
+            dropNode.attachObject(dropEntity)
+
+            result = og.Math.intersects(ray, self.dropCollisionPlane)
+            if result.first == True:
+                dropNode.setPosition(ray.getPoint(result.second))
+            else:
+                dropNode.setPosition(ray.getPoint(50))
+
+            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
+            dropEntity.setUserObject(self.dropGO)
+
+        self.dropCount += 1
+
+    def moveDropGameObjectAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropGO.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropGO.setPosition(ray.getPoint(50))
+
+    def stopDropGameObjectAction(self, ray):
+        print "sd"
+
+    def startDropModelAction(self, meshFile, ray):
+        self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+        self.dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
+        self.dropNode.attachObject(self.dropEntity)
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+        self.dropCount += 1
+
+    def moveDropModelAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+
+    def stopDropModelAction(self, ray):
+        pass
+

Copied: rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py (from rev 4567, rl/trunk/editors/Lockenwickler/src/MyRaySceneQueryListener.py)

Modified: rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/src/OgreMainWindow.py	2008-11-03 15:49:51 UTC (rev 4571)
@@ -227,8 +227,8 @@
         return False
 
     def dragEnterEvent(self, event):
-        if event.mimeData().hasFormat("application/x-text"):
-            data = event.mimeData().data("application/x-text")
+        if event.mimeData().hasFormat("application/x-static_model"):
+            data = event.mimeData().data("application/x-static_model")
             stream = QDataStream(data, QIODevice.ReadOnly)
             text = QString()
             stream >> text
@@ -238,18 +238,39 @@
             event.setDropAction(Qt.CopyAction)
             event.accept()
 
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            data = event.mimeData().data("application/x-game_object")
+            stream = QDataStream(data, QIODevice.ReadOnly)
+            text = QString()
+            stream >> text
+
+            self.moduleManager.startDropGameObjectAction(text, self.getCameraToViewportRay()) #start the model draging
+
+            event.setDropAction(Qt.CopyAction)
+            event.accept()
         else:
             event.ignore()
 
 
     def dragMoveEvent(self, event):
-        self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+        if event.mimeData().hasFormat("application/x-static_model"):
+            self.moduleManager.moveDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            self.moduleManager.moveDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
 
-        event.accept()
-
     def dropEvent(self, event):
-        self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) # place it down
-        event.accept()
+        if event.mimeData().hasFormat("application/x-static_model"):
+            self.moduleManager.stopDropModelAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        elif event.mimeData().hasFormat("application/x-game_object"):
+            self.moduleManager.stopDropGameObjectAction(self.getCameraToViewportRay()) #move it with the mouse
+            event.accept()
+        else:
+            event.ignore()
 
     def getCameraToViewportRay(self):
         relMousePos = self.ogreRenderWindow.mapFromGlobal(QCursor.pos())

Modified: rl/branches/newton20/editors/Lockenwickler/src/Plugins-linux.cfg
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/Plugins-linux.cfg	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/src/Plugins-linux.cfg	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,7 +1,8 @@
 # Defines plugins to load
 
 # Define plugin folder
-PluginFolder=/home/stefan/development/root/usr/lib/OGRE/
+#PluginFolder=/home/stefan/development/root/usr/lib/OGRE/
+PluginFolder=/usr/lib/OGRE
 
 # default plugins installed with the libogre14 package
 Plugin=RenderSystem_GL.so

Modified: rl/branches/newton20/editors/Lockenwickler/src/PreferencesDialog.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/PreferencesDialog.py	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/src/PreferencesDialog.py	2008-11-03 15:49:51 UTC (rev 4571)
@@ -43,11 +43,11 @@
         if platform.system() == "Windows" or platform.system() == "MAC":
             pass
             # TODO: delete this when ready
-#            self.prefDialog.lineEdit.setText("C:\Users\Stefan\Desktop\Lockenwickler\modules\modules.cfg")
-#            self.moduleCfgPath = "C:\Users\Stefan\Desktop\Lockenwickler\modules\modules.cfg"
-#            self.moduleCfgIsSelected = True
-#            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
-#            self.readInModules()
+            self.prefDialog.lineEdit.setText("C:/a11/modules/modules.cfg")
+            self.moduleCfgPath = 'C:/a11/modules/modules.cfg'
+            self.moduleCfgIsSelected = True
+            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
+            self.readInModules()
             # end delete
         else:
             # TODO: delete this when ready

Copied: rl/branches/newton20/editors/Lockenwickler/src/Ui_GOPropertyEditorDialogSTRING.py (from rev 4567, rl/trunk/editors/Lockenwickler/src/Ui_GOPropertyEditorDialogSTRING.py)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/agt_games.png (from rev 4567, rl/trunk/editors/Lockenwickler/src/media/icons/agt_games.png)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/agt_multimedia.png (from rev 4567, rl/trunk/editors/Lockenwickler/src/media/icons/agt_multimedia.png)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/lockenwickler_provisorium.png (from rev 4567, rl/trunk/editors/Lockenwickler/src/media/icons/lockenwickler_provisorium.png)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/lockenwickler_provisorium_small.png (from rev 4567, rl/trunk/editors/Lockenwickler/src/media/icons/lockenwickler_provisorium_small.png)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/multirow.png (from rev 4567, rl/trunk/editors/Lockenwickler/src/media/icons/multirow.png)

Deleted: rl/branches/newton20/editors/Lockenwickler/ui files/FourPanelView.ui
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/ui files/FourPanelView.ui	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/ui files/FourPanelView.ui	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,41 +0,0 @@
-<ui version="4.0" >
- <class>FourPaneView</class>
- <widget class="QWidget" name="FourPaneView" >
-  <property name="geometry" >
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>902</width>
-    <height>759</height>
-   </rect>
-  </property>
-  <property name="windowTitle" >
-   <string>Form</string>
-  </property>
-  <layout class="QGridLayout" >
-   <item row="0" column="0" >
-    <widget class="QSplitter" name="splitter_3" >
-     <property name="orientation" >
-      <enum>Qt::Horizontal</enum>
-     </property>
-     <widget class="QSplitter" name="splitter" >
-      <property name="orientation" >
-       <enum>Qt::Vertical</enum>
-      </property>
-      <widget class="QWidget" native="1" name="widget" />
-      <widget class="QWidget" native="1" name="widget_4" />
-     </widget>
-     <widget class="QSplitter" name="splitter_2" >
-      <property name="orientation" >
-       <enum>Qt::Vertical</enum>
-      </property>
-      <widget class="QWidget" native="1" name="widget_2" />
-      <widget class="QWidget" native="1" name="widget_3" />
-     </widget>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections/>
-</ui>

Copied: rl/branches/newton20/editors/Lockenwickler/ui files/GOPropertyEditorDialogINT.ui (from rev 4567, rl/trunk/editors/Lockenwickler/ui files/GOPropertyEditorDialogINT.ui)

Copied: rl/branches/newton20/editors/Lockenwickler/ui files/GOPropertyEditorDialogSTRING.ui (from rev 4567, rl/trunk/editors/Lockenwickler/ui files/GOPropertyEditorDialogSTRING.ui)

Copied: rl/branches/newton20/editors/Lockenwickler/ui files/PropertyEditorDialog.ui (from rev 4567, rl/trunk/editors/Lockenwickler/ui files/PropertyEditorDialog.ui)

Deleted: rl/branches/newton20/editors/Lockenwickler/ui files/batch_convert_ui.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/ui files/batch_convert_ui.py	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/ui files/batch_convert_ui.py	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,72 +0,0 @@
-import sys
-import os
-import platform
-
-copyCommand = "cp "
-cpDestination =  " ../src/"
-
-if platform.system() == "Windows":
-    copyCommand = "copy "
-    cpDestination = " ..\src\\"
-
-###########################################################################
-output = os.popen("pyuic4 lockewickler.ui > ui_lw.py")
-for line in output.readlines():
-    print line
-
-output = os.popen(copyCommand + "ui_lw.py" + cpDestination)
-for line in output.readlines():
-    print "pyuic4 lockewickler.ui > ui_lw.py " + line
-###########################################################################
-
-###########################################################################
-output = os.popen("pyuic4 preferences_dialog.ui > ui_pref_dialog.py")
-for line in output.readlines():
-    print line
-
-output = os.popen(copyCommand + "ui_pref_dialog.py" + cpDestination)
-for line in output.readlines():
-    print "pyuic4 preferences_dialog.ui > ui_pref_dialog.py " + line
-###########################################################################
-
-###########################################################################
-output = os.popen("pyuic4 object_property.ui > ui_obj_prop.py")
-for line in output.readlines():
-    print line
-
-output = os.popen(copyCommand + "ui_obj_prop.py" + cpDestination)
-for line in output.readlines():
-    print "pyuic4 object_property.ui > ui_obj_prop.py " + line
-###########################################################################
-
-###########################################################################
-output = os.popen("pyuic4 model_preview.ui > ui_model_prev.py")
-for line in output.readlines():
-    print line
-
-output = os.popen(copyCommand + "ui_model_prev.py" + cpDestination)
-for line in output.readlines():
-    print "pyuic4 model_preview.ui > ui_model_prev.py " + line
-###########################################################################
-
-###########################################################################
-output = os.popen("pyuic4 FourPanelView.ui > ui_FourPanelView.py")
-for line in output.readlines():
-        print line
-
-output = os.popen(copyCommand + "ui_FourPanelView.py" + cpDestination)
-for line in output.readlines():
-    print "pyuic4 FourPanelView.ui > ui_FourPanelView.py " + line
-###########################################################################
-
-###########################################################################
-output = os.popen("pyuic4 console_window.ui > ui_ConsoleWindow.py")
-for line in output.readlines():
-        print line
-
-output = os.popen(copyCommand + "ui_ConsoleWindow.py" + cpDestination)
-for line in output.readlines():
-    print "pyuic4 console_window.ui > ui_ConsoleWindow.py " + line
-###########################################################################
-
-print "Fertig!"

Deleted: rl/branches/newton20/editors/Lockenwickler/ui files/console_window.ui
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/ui files/console_window.ui	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/ui files/console_window.ui	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,23 +0,0 @@
-<ui version="4.0" >
- <class>ConsoleWindow</class>
- <widget class="QWidget" name="ConsoleWindow" >
-  <property name="geometry" >
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>884</width>
-    <height>225</height>
-   </rect>
-  </property>
-  <property name="windowTitle" >
-   <string>Form</string>
-  </property>
-  <layout class="QGridLayout" >
-   <item row="0" column="0" >
-    <widget class="QTextEdit" name="textEdit" />
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections/>
-</ui>

Deleted: rl/branches/newton20/editors/Lockenwickler/ui files/lockewickler.ui
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/ui files/lockewickler.ui	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/ui files/lockewickler.ui	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,108 +0,0 @@
-<ui version="4.0" >
- <author>Stefan Stammberger</author>
- <class>MainWindow</class>
- <widget class="QMainWindow" name="MainWindow" >
-  <property name="geometry" >
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>660</width>
-    <height>657</height>
-   </rect>
-  </property>
-  <property name="windowTitle" >
-   <string>MainWindow</string>
-  </property>
-  <widget class="QWidget" name="centralwidget" >
-   <layout class="QHBoxLayout" >
-    <item>
-     <layout class="QGridLayout" >
-      <item row="0" column="0" >
-       <widget class="QWidget" native="1" name="ogreRenderWindow" >
-        <property name="minimumSize" >
-         <size>
-          <width>250</width>
-          <height>250</height>
-         </size>
-        </property>
-       </widget>
-      </item>
-     </layout>
-    </item>
-   </layout>
-  </widget>
-  <widget class="QMenuBar" name="menubar" >
-   <property name="geometry" >
-    <rect>
-     <x>0</x>
-     <y>0</y>
-     <width>660</width>
-     <height>22</height>
-    </rect>
-   </property>
-   <widget class="QMenu" name="menuFile" >
-    <property name="title" >
-     <string>File</string>
-    </property>
-    <addaction name="actionNeu" />
-    <addaction name="actionClose" />
-   </widget>
-   <widget class="QMenu" name="menuView" >
-    <property name="title" >
-     <string>View</string>
-    </property>
-    <addaction name="actionSceneGraph" />
-    <addaction name="actionPreferences" />
-    <addaction name="actionProperty_Window" />
-    <addaction name="actionObject_Selection" />
-    <addaction name="actionConsole_Window" />
-   </widget>
-   <addaction name="menuFile" />
-   <addaction name="menuView" />
-  </widget>
-  <widget class="QStatusBar" name="statusbar" />
-  <action name="actionNeu" >
-   <property name="text" >
-    <string>Neu</string>
-   </property>
-  </action>
-  <action name="actionSceneGraph" >
-   <property name="checkable" >
-    <bool>false</bool>
-   </property>
-   <property name="text" >
-    <string>SceneGraph</string>
-   </property>
-  </action>
-  <action name="actionPreferences" >
-   <property name="checkable" >
-    <bool>false</bool>
-   </property>
-   <property name="text" >
-    <string>Preferences</string>
-   </property>
-  </action>
-  <action name="actionProperty_Window" >
-   <property name="text" >
-    <string>Property Window</string>
-   </property>
-  </action>
-  <action name="actionObject_Selection" >
-   <property name="text" >
-    <string>Object Selection</string>
-   </property>
-  </action>
-  <action name="actionClose" >
-   <property name="text" >
-    <string>Quit</string>
-   </property>
-  </action>
-  <action name="actionConsole_Window" >
-   <property name="text" >
-    <string>Console Window</string>
-   </property>
-  </action>
- </widget>
- <resources/>
- <connections/>
-</ui>

Deleted: rl/branches/newton20/editors/Lockenwickler/ui files/model_preview.ui
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/ui files/model_preview.ui	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/ui files/model_preview.ui	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,56 +0,0 @@
-<ui version="4.0" >
- <class>modelPreviewDialog</class>
- <widget class="QDialog" name="modelPreviewDialog" >
-  <property name="geometry" >
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>272</width>
-    <height>744</height>
-   </rect>
-  </property>
-  <property name="windowTitle" >
-   <string>Dialog</string>
-  </property>
-  <layout class="QGridLayout" >
-   <item row="0" column="0" >
-    <widget class="QLineEdit" name="modelSearchBox" />
-   </item>
-   <item row="1" column="0" >
-    <widget class="QSplitter" name="splitter" >
-     <property name="orientation" >
-      <enum>Qt::Vertical</enum>
-     </property>
-     <widget class="QListWidget" name="listWidget" />
-     <widget class="QWidget" native="1" name="modelPreviewWindow" >
-      <property name="minimumSize" >
-       <size>
-        <width>200</width>
-        <height>200</height>
-       </size>
-      </property>
-     </widget>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections>
-  <connection>
-   <sender>modelSearchBox</sender>
-   <signal>textChanged(QString)</signal>
-   <receiver>listWidget</receiver>
-   <slot>clearSelection()</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>115</x>
-     <y>20</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>114</x>
-     <y>48</y>
-    </hint>
-   </hints>
-  </connection>
- </connections>
-</ui>

Deleted: rl/branches/newton20/editors/Lockenwickler/ui files/object_property.ui
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/ui files/object_property.ui	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/ui files/object_property.ui	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,76 +0,0 @@
-<ui version="4.0" >
- <class>ObjectPropertys</class>
- <widget class="QDialog" name="ObjectPropertys" >
-  <property name="geometry" >
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>202</width>
-    <height>724</height>
-   </rect>
-  </property>
-  <property name="windowTitle" >
-   <string>Object Properties</string>
-  </property>
-  <widget class="QTreeWidget" name="treeWidget" >
-   <property name="geometry" >
-    <rect>
-     <x>0</x>
-     <y>0</y>
-     <width>901</width>
-     <height>721</height>
-    </rect>
-   </property>
-   <property name="minimumSize" >
-    <size>
-     <width>400</width>
-     <height>400</height>
-    </size>
-   </property>
-   <column>
-    <property name="text" >
-     <string>Property</string>
-    </property>
-   </column>
-   <column>
-    <property name="text" >
-     <string>Value</string>
-    </property>
-   </column>
-   <item>
-    <property name="text" >
-     <string>Position</string>
-    </property>
-    <property name="text" >
-     <string/>
-    </property>
-    <item>
-     <property name="text" >
-      <string>X</string>
-     </property>
-     <property name="text" >
-      <string/>
-     </property>
-    </item>
-    <item>
-     <property name="text" >
-      <string>Y</string>
-     </property>
-     <property name="text" >
-      <string/>
-     </property>
-    </item>
-    <item>
-     <property name="text" >
-      <string>Z</string>
-     </property>
-     <property name="text" >
-      <string/>
-     </property>
-    </item>
-   </item>
-  </widget>
- </widget>
- <resources/>
- <connections/>
-</ui>

Deleted: rl/branches/newton20/editors/Lockenwickler/ui files/preferences_dialog.ui
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/ui files/preferences_dialog.ui	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/ui files/preferences_dialog.ui	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,159 +0,0 @@
-<ui version="4.0" >
- <class>PreferencesDialog</class>
- <widget class="QDialog" name="PreferencesDialog" >
-  <property name="geometry" >
-   <rect>
-    <x>0</x>
-    <y>0</y>
-    <width>528</width>
-    <height>626</height>
-   </rect>
-  </property>
-  <property name="windowTitle" >
-   <string>Dialog</string>
-  </property>
-  <layout class="QGridLayout" >
-   <item row="0" column="0" >
-    <widget class="QToolBox" name="toolBox" >
-     <property name="currentIndex" >
-      <number>0</number>
-     </property>
-     <widget class="QWidget" name="ResourcePaths" >
-      <property name="geometry" >
-       <rect>
-        <x>0</x>
-        <y>0</y>
-        <width>510</width>
-        <height>505</height>
-       </rect>
-      </property>
-      <attribute name="label" >
-       <string>Resource Paths</string>
-      </attribute>
-      <layout class="QGridLayout" >
-       <item row="0" column="0" >
-        <widget class="QListWidget" name="listWidget" />
-       </item>
-       <item row="1" column="0" >
-        <widget class="QGroupBox" name="groupBox" >
-         <property name="minimumSize" >
-          <size>
-           <width>0</width>
-           <height>95</height>
-          </size>
-         </property>
-         <property name="title" >
-          <string>GroupBox</string>
-         </property>
-         <widget class="QWidget" name="layoutWidget" >
-          <property name="geometry" >
-           <rect>
-            <x>10</x>
-            <y>20</y>
-            <width>471</width>
-            <height>67</height>
-           </rect>
-          </property>
-          <layout class="QGridLayout" >
-           <item row="0" column="0" >
-            <widget class="QLineEdit" name="lineEdit" />
-           </item>
-           <item row="1" column="0" colspan="2" >
-            <widget class="QPushButton" name="loadModuleBtn" >
-             <property name="text" >
-              <string>Load Selected Module</string>
-             </property>
-            </widget>
-           </item>
-           <item row="0" column="1" >
-            <widget class="QPushButton" name="modulConfigSelector" >
-             <property name="text" >
-              <string>...</string>
-             </property>
-            </widget>
-           </item>
-          </layout>
-         </widget>
-        </widget>
-       </item>
-      </layout>
-     </widget>
-     <widget class="QWidget" name="OgreSettings" >
-      <property name="geometry" >
-       <rect>
-        <x>0</x>
-        <y>0</y>
-        <width>96</width>
-        <height>26</height>
-       </rect>
-      </property>
-      <attribute name="label" >
-       <string>Ogre Settings</string>
-      </attribute>
-     </widget>
-    </widget>
-   </item>
-   <item row="1" column="0" >
-    <widget class="QDialogButtonBox" name="buttonBox" >
-     <property name="orientation" >
-      <enum>Qt::Horizontal</enum>
-     </property>
-     <property name="standardButtons" >
-      <set>QDialogButtonBox::Cancel|QDialogButtonBox::NoButton|QDialogButtonBox::Ok</set>
-     </property>
-    </widget>
-   </item>
-  </layout>
- </widget>
- <resources/>
- <connections>
-  <connection>
-   <sender>buttonBox</sender>
-   <signal>accepted()</signal>
-   <receiver>PreferencesDialog</receiver>
-   <slot>accept()</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>227</x>
-     <y>387</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>157</x>
-     <y>274</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>buttonBox</sender>
-   <signal>rejected()</signal>
-   <receiver>PreferencesDialog</receiver>
-   <slot>reject()</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>295</x>
-     <y>387</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>286</x>
-     <y>274</y>
-    </hint>
-   </hints>
-  </connection>
-  <connection>
-   <sender>buttonBox</sender>
-   <signal>clicked(QAbstractButton*)</signal>
-   <receiver>PreferencesDialog</receiver>
-   <slot>close()</slot>
-   <hints>
-    <hint type="sourcelabel" >
-     <x>467</x>
-     <y>387</y>
-    </hint>
-    <hint type="destinationlabel" >
-     <x>240</x>
-     <y>0</y>
-    </hint>
-   </hints>
-  </connection>
- </connections>
-</ui>

Deleted: rl/branches/newton20/editors/Lockenwickler/ui files/ui_ConsoleWindow.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/ui files/ui_ConsoleWindow.py	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/ui files/ui_ConsoleWindow.py	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,29 +0,0 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'console_window.ui'
-#
-# Created: Mon May 12 15:09:24 2008
-#      by: PyQt4 UI code generator 4.3.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
-
-class Ui_ConsoleWindow(object):
-    def setupUi(self, ConsoleWindow):
-        ConsoleWindow.setObjectName("ConsoleWindow")
-        ConsoleWindow.resize(QtCore.QSize(QtCore.QRect(0,0,884,225).size()).expandedTo(ConsoleWindow.minimumSizeHint()))
-
-        self.gridlayout = QtGui.QGridLayout(ConsoleWindow)
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.textEdit = QtGui.QTextEdit(ConsoleWindow)
-        self.textEdit.setObjectName("textEdit")
-        self.gridlayout.addWidget(self.textEdit,0,0,1,1)
-
-        self.retranslateUi(ConsoleWindow)
-        QtCore.QMetaObject.connectSlotsByName(ConsoleWindow)
-
-    def retranslateUi(self, ConsoleWindow):
-        ConsoleWindow.setWindowTitle(QtGui.QApplication.translate("ConsoleWindow", "Form", None, QtGui.QApplication.UnicodeUTF8))
-

Deleted: rl/branches/newton20/editors/Lockenwickler/ui files/ui_FourPanelView.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/ui files/ui_FourPanelView.py	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/ui files/ui_FourPanelView.py	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,50 +0,0 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'FourPanelView.ui'
-#
-# Created: Mon May 12 15:09:24 2008
-#      by: PyQt4 UI code generator 4.3.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
-
-class Ui_FourPaneView(object):
-    def setupUi(self, FourPaneView):
-        FourPaneView.setObjectName("FourPaneView")
-        FourPaneView.resize(QtCore.QSize(QtCore.QRect(0,0,827,856).size()).expandedTo(FourPaneView.minimumSizeHint()))
-
-        self.gridlayout = QtGui.QGridLayout(FourPaneView)
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.splitter_3 = QtGui.QSplitter(FourPaneView)
-        self.splitter_3.setOrientation(QtCore.Qt.Horizontal)
-        self.splitter_3.setObjectName("splitter_3")
-
-        self.splitter = QtGui.QSplitter(self.splitter_3)
-        self.splitter.setOrientation(QtCore.Qt.Vertical)
-        self.splitter.setObjectName("splitter")
-
-        self.widget = QtGui.QWidget(self.splitter)
-        self.widget.setObjectName("widget")
-
-        self.widget_4 = QtGui.QWidget(self.splitter)
-        self.widget_4.setObjectName("widget_4")
-
-        self.splitter_2 = QtGui.QSplitter(self.splitter_3)
-        self.splitter_2.setOrientation(QtCore.Qt.Vertical)
-        self.splitter_2.setObjectName("splitter_2")
-
-        self.widget_2 = QtGui.QWidget(self.splitter_2)
-        self.widget_2.setObjectName("widget_2")
-
-        self.widget_3 = QtGui.QWidget(self.splitter_2)
-        self.widget_3.setObjectName("widget_3")
-        self.gridlayout.addWidget(self.splitter_3,0,0,1,1)
-
-        self.retranslateUi(FourPaneView)
-        QtCore.QMetaObject.connectSlotsByName(FourPaneView)
-
-    def retranslateUi(self, FourPaneView):
-        FourPaneView.setWindowTitle(QtGui.QApplication.translate("FourPaneView", "Form", None, QtGui.QApplication.UnicodeUTF8))
-

Deleted: rl/branches/newton20/editors/Lockenwickler/ui files/ui_lw.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/ui files/ui_lw.py	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/ui files/ui_lw.py	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,94 +0,0 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'lockewickler.ui'
-#
-# Created: Mon May 12 15:09:23 2008
-#      by: PyQt4 UI code generator 4.3.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
-
-class Ui_MainWindow(object):
-    def setupUi(self, MainWindow):
-        MainWindow.setObjectName("MainWindow")
-        MainWindow.resize(QtCore.QSize(QtCore.QRect(0,0,660,657).size()).expandedTo(MainWindow.minimumSizeHint()))
-
-        self.centralwidget = QtGui.QWidget(MainWindow)
-        self.centralwidget.setObjectName("centralwidget")
-
-        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
-        self.hboxlayout.setObjectName("hboxlayout")
-
-        self.gridlayout = QtGui.QGridLayout()
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.ogreRenderWindow = QtGui.QWidget(self.centralwidget)
-        self.ogreRenderWindow.setMinimumSize(QtCore.QSize(250,250))
-        self.ogreRenderWindow.setObjectName("ogreRenderWindow")
-        self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
-        self.hboxlayout.addLayout(self.gridlayout)
-        MainWindow.setCentralWidget(self.centralwidget)
-
-        self.menubar = QtGui.QMenuBar(MainWindow)
-        self.menubar.setGeometry(QtCore.QRect(0,0,660,22))
-        self.menubar.setObjectName("menubar")
-
-        self.menuFile = QtGui.QMenu(self.menubar)
-        self.menuFile.setObjectName("menuFile")
-
-        self.menuView = QtGui.QMenu(self.menubar)
-        self.menuView.setObjectName("menuView")
-        MainWindow.setMenuBar(self.menubar)
-
-        self.statusbar = QtGui.QStatusBar(MainWindow)
-        self.statusbar.setObjectName("statusbar")
-        MainWindow.setStatusBar(self.statusbar)
-
-        self.actionNeu = QtGui.QAction(MainWindow)
-        self.actionNeu.setObjectName("actionNeu")
-
-        self.actionSceneGraph = QtGui.QAction(MainWindow)
-        self.actionSceneGraph.setCheckable(False)
-        self.actionSceneGraph.setObjectName("actionSceneGraph")
-
-        self.actionPreferences = QtGui.QAction(MainWindow)
-        self.actionPreferences.setCheckable(False)
-        self.actionPreferences.setObjectName("actionPreferences")
-
-        self.actionProperty_Window = QtGui.QAction(MainWindow)
-        self.actionProperty_Window.setObjectName("actionProperty_Window")
-
-        self.actionObject_Selection = QtGui.QAction(MainWindow)
-        self.actionObject_Selection.setObjectName("actionObject_Selection")
-
-        self.actionClose = QtGui.QAction(MainWindow)
-        self.actionClose.setObjectName("actionClose")
-
-        self.actionConsole_Window = QtGui.QAction(MainWindow)
-        self.actionConsole_Window.setObjectName("actionConsole_Window")
-        self.menuFile.addAction(self.actionNeu)
-        self.menuFile.addAction(self.actionClose)
-        self.menuView.addAction(self.actionSceneGraph)
-        self.menuView.addAction(self.actionPreferences)
-        self.menuView.addAction(self.actionProperty_Window)
-        self.menuView.addAction(self.actionObject_Selection)
-        self.menuView.addAction(self.actionConsole_Window)
-        self.menubar.addAction(self.menuFile.menuAction())
-        self.menubar.addAction(self.menuView.menuAction())
-
-        self.retranslateUi(MainWindow)
-        QtCore.QMetaObject.connectSlotsByName(MainWindow)
-
-    def retranslateUi(self, MainWindow):
-        MainWindow.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "Neu", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionSceneGraph.setText(QtGui.QApplication.translate("MainWindow", "SceneGraph", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionClose.setText(QtGui.QApplication.translate("MainWindow", "Quit", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionConsole_Window.setText(QtGui.QApplication.translate("MainWindow", "Console Window", None, QtGui.QApplication.UnicodeUTF8))
-

Deleted: rl/branches/newton20/editors/Lockenwickler/ui files/ui_model_prev.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/ui files/ui_model_prev.py	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/ui files/ui_model_prev.py	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,42 +0,0 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'model_preview.ui'
-#
-# Created: Mon May 12 15:09:24 2008
-#      by: PyQt4 UI code generator 4.3.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
-
-class Ui_modelPreviewDialog(object):
-    def setupUi(self, modelPreviewDialog):
-        modelPreviewDialog.setObjectName("modelPreviewDialog")
-        modelPreviewDialog.resize(QtCore.QSize(QtCore.QRect(0,0,272,744).size()).expandedTo(modelPreviewDialog.minimumSizeHint()))
-
-        self.gridlayout = QtGui.QGridLayout(modelPreviewDialog)
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.modelSearchBox = QtGui.QLineEdit(modelPreviewDialog)
-        self.modelSearchBox.setObjectName("modelSearchBox")
-        self.gridlayout.addWidget(self.modelSearchBox,0,0,1,1)
-
-        self.splitter = QtGui.QSplitter(modelPreviewDialog)
-        self.splitter.setOrientation(QtCore.Qt.Vertical)
-        self.splitter.setObjectName("splitter")
-
-        self.listWidget = QtGui.QListWidget(self.splitter)
-        self.listWidget.setObjectName("listWidget")
-
-        self.modelPreviewWindow = QtGui.QWidget(self.splitter)
-        self.modelPreviewWindow.setMinimumSize(QtCore.QSize(200,200))
-        self.modelPreviewWindow.setObjectName("modelPreviewWindow")
-        self.gridlayout.addWidget(self.splitter,1,0,1,1)
-
-        self.retranslateUi(modelPreviewDialog)
-        QtCore.QObject.connect(self.modelSearchBox,QtCore.SIGNAL("textChanged(QString)"),self.listWidget.clearSelection)
-        QtCore.QMetaObject.connectSlotsByName(modelPreviewDialog)
-
-    def retranslateUi(self, modelPreviewDialog):
-        modelPreviewDialog.setWindowTitle(QtGui.QApplication.translate("modelPreviewDialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
-

Deleted: rl/branches/newton20/editors/Lockenwickler/ui files/ui_obj_prop.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/ui files/ui_obj_prop.py	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/ui files/ui_obj_prop.py	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,46 +0,0 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'object_property.ui'
-#
-# Created: Mon May 12 15:09:23 2008
-#      by: PyQt4 UI code generator 4.3.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
-
-class Ui_ObjectPropertys(object):
-    def setupUi(self, ObjectPropertys):
-        ObjectPropertys.setObjectName("ObjectPropertys")
-        ObjectPropertys.resize(QtCore.QSize(QtCore.QRect(0,0,761,724).size()).expandedTo(ObjectPropertys.minimumSizeHint()))
-
-        self.treeWidget = QtGui.QTreeWidget(ObjectPropertys)
-        self.treeWidget.setGeometry(QtCore.QRect(0,0,901,721))
-        self.treeWidget.setMinimumSize(QtCore.QSize(400,400))
-        self.treeWidget.setObjectName("treeWidget")
-
-        self.retranslateUi(ObjectPropertys)
-        QtCore.QMetaObject.connectSlotsByName(ObjectPropertys)
-
-    def retranslateUi(self, ObjectPropertys):
-        ObjectPropertys.setWindowTitle(QtGui.QApplication.translate("ObjectPropertys", "Object Properties", None, QtGui.QApplication.UnicodeUTF8))
-        self.treeWidget.headerItem().setText(0,QtGui.QApplication.translate("ObjectPropertys", "Property", None, QtGui.QApplication.UnicodeUTF8))
-        self.treeWidget.headerItem().setText(1,QtGui.QApplication.translate("ObjectPropertys", "Value", None, QtGui.QApplication.UnicodeUTF8))
-        self.treeWidget.clear()
-
-        item = QtGui.QTreeWidgetItem(self.treeWidget)
-        item.setText(0,QtGui.QApplication.translate("ObjectPropertys", "Position", None, QtGui.QApplication.UnicodeUTF8))
-        item.setText(1,"")
-
-        item1 = QtGui.QTreeWidgetItem(item)
-        item1.setText(0,QtGui.QApplication.translate("ObjectPropertys", "X", None, QtGui.QApplication.UnicodeUTF8))
-        item1.setText(1,"")
-
-        item2 = QtGui.QTreeWidgetItem(item)
-        item2.setText(0,QtGui.QApplication.translate("ObjectPropertys", "Y", None, QtGui.QApplication.UnicodeUTF8))
-        item2.setText(1,"")
-
-        item3 = QtGui.QTreeWidgetItem(item)
-        item3.setText(0,QtGui.QApplication.translate("ObjectPropertys", "Z", None, QtGui.QApplication.UnicodeUTF8))
-        item3.setText(1,"")
-

Deleted: rl/branches/newton20/editors/Lockenwickler/ui files/ui_pref_dialog.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/ui files/ui_pref_dialog.py	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/editors/Lockenwickler/ui files/ui_pref_dialog.py	2008-11-03 15:49:51 UTC (rev 4571)
@@ -1,85 +0,0 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'preferences_dialog.ui'
-#
-# Created: Mon May 12 15:09:23 2008
-#      by: PyQt4 UI code generator 4.3.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
-
-class Ui_PreferencesDialog(object):
-    def setupUi(self, PreferencesDialog):
-        PreferencesDialog.setObjectName("PreferencesDialog")
-        PreferencesDialog.resize(QtCore.QSize(QtCore.QRect(0,0,528,626).size()).expandedTo(PreferencesDialog.minimumSizeHint()))
-
-        self.gridlayout = QtGui.QGridLayout(PreferencesDialog)
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.toolBox = QtGui.QToolBox(PreferencesDialog)
-        self.toolBox.setObjectName("toolBox")
-
-        self.ResourcePaths = QtGui.QWidget()
-        self.ResourcePaths.setGeometry(QtCore.QRect(0,0,510,505))
-        self.ResourcePaths.setObjectName("ResourcePaths")
-
-        self.gridlayout1 = QtGui.QGridLayout(self.ResourcePaths)
-        self.gridlayout1.setObjectName("gridlayout1")
-
-        self.listWidget = QtGui.QListWidget(self.ResourcePaths)
-        self.listWidget.setObjectName("listWidget")
-        self.gridlayout1.addWidget(self.listWidget,0,0,1,1)
-
-        self.groupBox = QtGui.QGroupBox(self.ResourcePaths)
-        self.groupBox.setMinimumSize(QtCore.QSize(0,95))
-        self.groupBox.setObjectName("groupBox")
-
-        self.layoutWidget = QtGui.QWidget(self.groupBox)
-        self.layoutWidget.setGeometry(QtCore.QRect(10,20,471,67))
-        self.layoutWidget.setObjectName("layoutWidget")
-
-        self.gridlayout2 = QtGui.QGridLayout(self.layoutWidget)
-        self.gridlayout2.setObjectName("gridlayout2")
-
-        self.lineEdit = QtGui.QLineEdit(self.layoutWidget)
-        self.lineEdit.setObjectName("lineEdit")
-        self.gridlayout2.addWidget(self.lineEdit,0,0,1,1)
-
-        self.loadModuleBtn = QtGui.QPushButton(self.layoutWidget)
-        self.loadModuleBtn.setObjectName("loadModuleBtn")
-        self.gridlayout2.addWidget(self.loadModuleBtn,1,0,1,2)
-
-        self.modulConfigSelector = QtGui.QPushButton(self.layoutWidget)
-        self.modulConfigSelector.setObjectName("modulConfigSelector")
-        self.gridlayout2.addWidget(self.modulConfigSelector,0,1,1,1)
-        self.gridlayout1.addWidget(self.groupBox,1,0,1,1)
-        self.toolBox.addItem(self.ResourcePaths,"")
-
-        self.OgreSettings = QtGui.QWidget()
-        self.OgreSettings.setGeometry(QtCore.QRect(0,0,96,26))
-        self.OgreSettings.setObjectName("OgreSettings")
-        self.toolBox.addItem(self.OgreSettings,"")
-        self.gridlayout.addWidget(self.toolBox,0,0,1,1)
-
-        self.buttonBox = QtGui.QDialogButtonBox(PreferencesDialog)
-        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
-        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.NoButton|QtGui.QDialogButtonBox.Ok)
-        self.buttonBox.setObjectName("buttonBox")
-        self.gridlayout.addWidget(self.buttonBox,1,0,1,1)
-
-        self.retranslateUi(PreferencesDialog)
-        self.toolBox.setCurrentIndex(0)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("accepted()"),PreferencesDialog.accept)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("rejected()"),PreferencesDialog.reject)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("clicked(QAbstractButton*)"),PreferencesDialog.close)
-        QtCore.QMetaObject.connectSlotsByName(PreferencesDialog)
-
-    def retranslateUi(self, PreferencesDialog):
-        PreferencesDialog.setWindowTitle(QtGui.QApplication.translate("PreferencesDialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
-        self.groupBox.setTitle(QtGui.QApplication.translate("PreferencesDialog", "GroupBox", None, QtGui.QApplication.UnicodeUTF8))
-        self.loadModuleBtn.setText(QtGui.QApplication.translate("PreferencesDialog", "Load Selected Module", None, QtGui.QApplication.UnicodeUTF8))
-        self.modulConfigSelector.setText(QtGui.QApplication.translate("PreferencesDialog", "...", None, QtGui.QApplication.UnicodeUTF8))
-        self.toolBox.setItemText(self.toolBox.indexOf(self.ResourcePaths), QtGui.QApplication.translate("PreferencesDialog", "Resource Paths", None, QtGui.QApplication.UnicodeUTF8))
-        self.toolBox.setItemText(self.toolBox.indexOf(self.OgreSettings), QtGui.QApplication.translate("PreferencesDialog", "Ogre Settings", None, QtGui.QApplication.UnicodeUTF8))
-

Modified: rl/branches/newton20/engine/ui/include/CombatControlState.h
===================================================================
--- rl/branches/newton20/engine/ui/include/CombatControlState.h	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/engine/ui/include/CombatControlState.h	2008-11-03 15:49:51 UTC (rev 4571)
@@ -41,6 +41,14 @@
             public PhysicsGenericContactCallback
 	{
 	public:
+        /** 
+         * Different view-modes:
+         * @VM_COMBAT_CENTERED: "cameraLookAt" to center of combat (middle of all combatant positions)
+         * @VM_THIRD_PERSON: zooms to one combatant (not only hero!)
+        */
+        typedef enum {VM_COMBAT_CENTERED, VM_THIRD_PERSON} ViewMode;
+
+
 		/**
 		*  @throw NullPointerException if camera is NULL.
 		*  @warning Ownership of combat is taken by the CombatControlState.
@@ -70,6 +78,13 @@
         // camera movement: Newton force and torque callback
         void OnApplyForceAndTorque(PhysicalThing *pt, float timstep);
 
+        // Change ViewMode
+        void setViewMode(ViewMode mode);
+        ViewMode getViewMode();
+        void toggleViewMode();
+        // set the combatant (must be part of this combat), the camera should focus on (VM_THIRD_PERSON) (only used internally?)
+        void setCameraFocusedCombatant(Combatant* combatant);
+
     private:
 		enum State {REQUEST_USER_INPUT, ROUND_EXECUTION};
 
@@ -90,17 +105,36 @@
         CameraObject* mCamera;
 
 		State mState;
+
         // Camera:
         Ogre::Degree mCameraYaw, mCameraPitch;
-        Ogre::Real mMaxCameraDistance, mMinCameraDistance;
-        int mMovementState;
+        Ogre::Real mCameraMaxDistance, mCameraCombatCenteredMinDistance, mCameraThirdPersonMinDistance;
+        int mMovementState; // keyboard input
         Ogre::Real mCameraLinearDampingK, mCameraLinearSpringK;
+        ViewMode mViewMode;
+        Ogre::Vector3 mCameraLookAt; // set by calculateOptimalCameraPositionAndLookAt
+        Ogre::Vector3 mCameraOptPos; // set by calculateOptimalCameraPositionAndLookAt
+        Ogre::Real mCameraDistance; // only used in third-person, changed by calculateOptimalCameraAndPosition
+        Ogre::Real mCameraSwitchDist; // set by calculateOptimalCameraPositionAndLookAt, dist at which switches to third-person
+        Ogre::Real mCameraSwitchTransitionDist; // relative value (0-1) of mCameraSwitchDist
+        Combatant* mCameraFocusedCombatant;  // the combatant currently focused by camera (VM_THIRD_PERSON)
+        // when switching from one view-mode to another or when changing focused combatant, these variables are used
+        // to provide smooth camera movement
+        bool mCameraTransitionLookAtActive;
+        bool mCameraTransitionPositionActive;
+        Ogre::Vector3 mCameraTransitionPosition;
+        Ogre::Vector3 mCameraTransitionLookAt;
+        // buffered values needed fo camera-movement, calculated once per frame:
+        Ogre::Vector3 mCombatCenter; // result of calculateCombatCenterPosition
+        Ogre::Real mCombatRadius; // result of calculateCombatRadius
 
         // Camera helper functions
         void resetCamera();
         void updateCameraLookAt(Ogre::Real timestep);
-        Ogre::Vector3 getCombatCenterPosition();
-        Ogre::Vector3 calculateOptimalCameraPosition();
+        Ogre::Vector3 calculateCombatCenterPosition();
+        Ogre::Real calculateCombatRadius(Ogre::Vector3 center);
+        // sets the variables mCameraLookAt, mCameraOptPos, mCameraDistance, usually called in OnApplyForceAndTorque
+        void calculateOptimalCameraPositionAndLookAt();
         
         // Event handlers
 		bool userRequestAttackOpponent(Combatant*);

Modified: rl/branches/newton20/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/CombatControlState.cpp	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/engine/ui/src/CombatControlState.cpp	2008-11-03 15:49:51 UTC (rev 4571)
@@ -56,8 +56,15 @@
           mMovementState(0),
           mCameraLinearSpringK(100.0f),
           mCameraLinearDampingK(Math::NEG_INFINITY),
-          mMaxCameraDistance(30.0f),
-          mMinCameraDistance(5.0f)
+          mViewMode(VM_COMBAT_CENTERED),
+          mCameraFocusedCombatant(NULL),
+          mCameraTransitionLookAtActive(false),
+          mCameraTransitionPositionActive(false),
+          mCameraMaxDistance(30.0f),
+          mCameraCombatCenteredMinDistance(5.0f),
+          mCameraThirdPersonMinDistance(1.0f),
+          mCameraSwitchDist(30.0f),
+          mCameraSwitchTransitionDist(0.3f)
     {
         CreatureSelectionFilter* filter = new CreatureSelectionFilter();
         filter->setAlignmentMask(Creature::ALIGNMENT_ENEMY);
@@ -129,10 +136,7 @@
         mat_pair->setDefaultFriction(0,0);
         mat_pair->setDefaultFriction(0,1);
 
-        // reset camera
-        //resetCamera(); // if you don't call this here, the camera should smoothly move to the new position -> looks nicer
-        // perhaps this should be handled differently!
-        mMovementState = 0;
+       
 
 
         ///\todo Richtig machen, nur tempor?r Ani hier setzen.
@@ -166,6 +170,24 @@
         mCombat->addAlly(this);
 
         mCombat->start();
+
+        // reset camera
+        //resetCamera(); // if you don't call this here, the camera should smoothly move to the new position -> looks nicer
+        // perhaps this should be handled differently!
+        mMovementState = 0;
+        // calculate some buffered values, so they are initialized:
+        mCameraTransitionPositionActive = false;
+        mCameraTransitionLookAtActive = false;
+        mCameraFocusedCombatant = this;
+        mCameraYaw = Degree(0);
+        mCameraPitch = Degree(50);
+        mCameraDistance = 30.0f; // only used for third-person
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+        calculateOptimalCameraPositionAndLookAt();
+ 
+        // update CombatGui
+        mCombatGui->update();
     }
 
     void CombatControlState::pause()
@@ -228,37 +250,69 @@
 
     void CombatControlState::run(Ogre::Real elapsedTime)
     {
+        // updateCameraLookAt should be called before mCombatGui->update()!
+
+        // update camera look-at position
+        updateCameraLookAt(elapsedTime);
+
+
         // update CombatGui
         mCombatGui->update();
 
 
-
-        // update camera look-at position
-        updateCameraLookAt(elapsedTime);
-
+        // slow down rotational movement, when radius grows
         if( mMovementState & MOVE_RIGHT )
-            mCameraYaw += Degree( 360.0/10.0 * elapsedTime );
+            mCameraYaw += Degree( 360.0/2.0 * elapsedTime / Math::Sqrt(mCameraDistance) );
         if( mMovementState & MOVE_LEFT )
-            mCameraYaw -= Degree( 360.0/10.0 * elapsedTime );
+            mCameraYaw -= Degree( 360.0/2.0 * elapsedTime / Math::Sqrt(mCameraDistance) );
+        if( mMovementState & MOVE_FORWARD )
+            mCameraDistance -= 5 * elapsedTime;
+        if( mMovementState & MOVE_BACKWARD )
+            mCameraDistance += 5 * elapsedTime;
 
+        mCameraDistance = std::max( mCameraDistance, mCameraThirdPersonMinDistance);
+        mCameraDistance = std::min( mCameraDistance, mCameraMaxDistance);
+
+        // switch view mode smoothly if nearer:
+        if( mViewMode == VM_COMBAT_CENTERED )
+        {
+            if( mMovementState & MOVE_FORWARD )
+            {
+                mViewMode = VM_THIRD_PERSON;
+            }
+        }
+        else // VM_THIRD_PERSON
+        {
+            if( mCameraDistance >= mCameraSwitchDist - 0.05f && mMovementState & MOVE_BACKWARD )
+            {
+                mViewMode = VM_COMBAT_CENTERED;
+            }
+        }
     }
 
     void CombatControlState::resetCamera(void)
     {
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+        mCameraTransitionPositionActive = false;
+        mCameraTransitionLookAtActive = false;
         mCameraYaw = Degree(0);
         mCameraPitch = Degree(50);
-        mCameraActor->setPosition(calculateOptimalCameraPosition());
+        if( mViewMode == VM_THIRD_PERSON )
+            mCameraDistance = 2.0f; // only used for third-person
+        calculateOptimalCameraPositionAndLookAt();
+        mCameraActor->setPosition(mCameraOptPos);
+        SceneNode* cameraNode = mCameraActor->_getSceneNode();
+        cameraNode->lookAt(mCameraLookAt, Node::TS_WORLD);
     }
 
     void CombatControlState::updateCameraLookAt(Real elapsedTime)
     {
-        Vector3 combatCenter = getCombatCenterPosition();
         SceneNode* cameraNode = mCameraActor->_getSceneNode();
-
-        cameraNode->lookAt(combatCenter + 2*Vector3::UNIT_Y, Node::TS_WORLD);
+        cameraNode->lookAt(mCameraLookAt, Node::TS_WORLD);
     }
 
-    Vector3 CombatControlState::getCombatCenterPosition()
+    Vector3 CombatControlState::calculateCombatCenterPosition()
     {
         // get the center of all persons (allies and opponents)
         int n = 0;
@@ -287,11 +341,9 @@
 
         return pos;
     }
-    
-    Vector3 CombatControlState::calculateOptimalCameraPosition()
+
+    Real CombatControlState::calculateCombatRadius(Vector3 center)
     {
-        Vector3 center = getCombatCenterPosition();
-
         // get the greatest distance from center from all persons
         Real distance = 0;
         const Combat::CombatantSet &allies (mCombat->getAllAllies() );
@@ -304,31 +356,77 @@
         {
             distance = std::max( ( (*it)->getCreature()->getPosition() - center ).length(), distance );
         }
-        distance+=2;
+        return distance;
+    }
+    
+    void CombatControlState::calculateOptimalCameraPositionAndLookAt()
+    {
+        // some variables:
+        Vector3 playerPos = mCharacter->getPosition();
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
 
 
+
+        // calculate camera-distance for VM_COMBAT_CENTERED (needed for third-person view, too)
+        Real combatCenteredDistance = mCombatRadius + 2; // this is camera-distance from center projected to the plane!
+            
         // put camera on the line player-center far enough to see all persons
         // if player is "exactly" in the center, use player orientation as fallback orientation
         // + rotation from mCameraYaw
-        Vector3 playerPos = mCharacter->getPosition();
-        Vector3 diff = playerPos - center;
+        Vector3 diff = playerPos - mCombatCenter;
         diff.y = 0;
-        Quaternion camYaw;
-        camYaw.FromAngleAxis(mCameraYaw, Vector3::UNIT_Y);
+        Quaternion combatCenteredCamYaw;
+        combatCenteredCamYaw.FromAngleAxis(mCameraYaw, Vector3::UNIT_Y);
         if( diff.squaredLength() < 0.01 )
         {
             diff = mCharacterActor->getOrientation()*Vector3::UNIT_Z;
         }
         diff.y = 0;
         diff.normalise();
-        diff = camYaw*diff;
+        diff = combatCenteredCamYaw*diff;
         diff.y = Math::Tan(mCameraPitch.valueRadians());
 
-        distance = std::max( distance,  mMinCameraDistance*Math::Cos(mCameraPitch.valueRadians()) );
-        distance = std::min( distance,  mMaxCameraDistance*Math::Cos(mCameraPitch.valueRadians()) );
-            
-        Vector3 camPos = center + distance*diff;
-        return camPos;
+        Real cosPitch = Math::Cos(mCameraPitch.valueRadians());
+        combatCenteredDistance = std::max( combatCenteredDistance,  mCameraCombatCenteredMinDistance*cosPitch );
+        combatCenteredDistance = std::min( combatCenteredDistance,  mCameraMaxDistance*cosPitch );
+ 
+
+
+
+
+        // TODO
+        // Bewegung wirkt zu eckig... evt hilft es lookat und position separat zu berechnen
+        // und dabei das lookat schneller auf den anvisierten combatant zu setzen...
+        // ideal scheint mir eine "runde" bewegung, a la kamerafahrt!
+
+
+        Vector3 center;
+        Vector3 dist;
+        if( mViewMode == VM_THIRD_PERSON && mCameraFocusedCombatant )
+        {
+            center = mCameraFocusedCombatant->getPosition();
+            // if mCameraDistance is near the one needed for combatCentered,
+            // interpolate the center (between center of third-person-view
+            // and center of combat-centered-view)
+            Real interpolateDist = std::max(0.0f, combatCenteredDistance - mCameraDistance*cosPitch) / cosPitch;
+            if( interpolateDist <  mCameraSwitchTransitionDist*mCameraSwitchDist )
+            {
+                center += (mCombatCenter - center)*(1 - interpolateDist/(mCameraSwitchTransitionDist*mCameraSwitchDist));
+            }
+            dist = mCameraDistance*cosPitch;
+        }
+        else // assume VM_COMBAT_CENTERED
+        {
+            center = mCombatCenter;
+            // update camera-distance variable
+            mCameraDistance = (combatCenteredDistance*diff).length();
+            dist = combatCenteredDistance;
+        }
+
+        mCameraSwitchDist = (combatCenteredDistance*diff).length();
+        mCameraOptPos = center + dist*diff;
+        mCameraLookAt = center + 1.4*Vector3::UNIT_Y;
     }
 
     void CombatControlState::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
@@ -337,10 +435,32 @@
         Quaternion camOri;
         mCamBody->getPositionOrientation(camPos, camOri);
 
-        Vector3 optimalCamPos = calculateOptimalCameraPosition();
+        calculateOptimalCameraPositionAndLookAt();
 
+        // handle transition
+        if( mCameraTransitionPositionActive )
+        {
+            Vector3 diff = mCameraOptPos - mCameraTransitionPosition;
+            Real dist = diff.length();
+            Vector3 dir = diff/dist;
+            mCameraTransitionPosition += dir*std::min(dist, 0.5f*timestep);
+            if( (mCameraTransitionPosition - mCameraOptPos).squaredLength() < 0.02 )
+                mCameraTransitionPositionActive = false;
+            mCameraOptPos = mCameraTransitionPosition;
+        }
+        if( mCameraTransitionLookAtActive )
+        {
+            Vector3 diff = mCameraLookAt - mCameraTransitionLookAt;
+            Real dist = diff.length();
+            Vector3 dir = diff/dist;
+            mCameraTransitionLookAt += dir * std::min(dist,0.5f*timestep);
+            if( (mCameraLookAt-mCameraTransitionLookAt).squaredLength() < 0.02 )
+                mCameraTransitionLookAtActive = false;
+            mCameraLookAt = mCameraTransitionLookAt;
+        }
 
-        Vector3 diff = camPos - optimalCamPos;
+
+        Vector3 diff = camPos - mCameraOptPos;
         Vector3 cameraVelocity;
         cameraVelocity = mCamBody->getVelocity();
         // spring velocity
@@ -354,6 +474,46 @@
         mCamBody->setForce(springAcc * mass);
     }
 
+    void CombatControlState::setViewMode(ViewMode mode)
+    {
+        if(mode != mViewMode)
+        {
+            mViewMode = mode;
+            mCameraTransitionPosition = mCameraActor->getPosition();
+            mCameraTransitionLookAt = mCameraLookAt;
+            mCameraTransitionLookAtActive = true;
+            mCameraTransitionPositionActive = true;
+        }
+    }
+
+    void CombatControlState::toggleViewMode()
+    {
+        if( mViewMode == VM_COMBAT_CENTERED )
+            setViewMode(VM_THIRD_PERSON);
+        else
+            setViewMode(VM_COMBAT_CENTERED);
+    }
+
+    CombatControlState::ViewMode CombatControlState::getViewMode()
+    {
+        return mViewMode;
+    }
+
+    void CombatControlState::setCameraFocusedCombatant(Combatant* combatant)
+    {
+        if( combatant != mCameraFocusedCombatant )
+        {
+            if( mViewMode == VM_THIRD_PERSON )
+            {
+                mCameraTransitionPosition = mCameraActor->getPosition();
+                mCameraTransitionLookAt = mCameraLookAt;
+                mCameraTransitionLookAtActive = true;
+                mCameraTransitionPositionActive = true;
+            }
+        }
+        mCameraFocusedCombatant = combatant;
+    }
+
     int CombatControlState::onAABBOverlap(int threadIndex)
     {
         // TODO handle camera collisions here

Modified: rl/branches/newton20/engine/ui/src/CombatGui.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/CombatGui.cpp	2008-10-31 16:37:06 UTC (rev 4570)
+++ rl/branches/newton20/engine/ui/src/CombatGui.cpp	2008-11-03 15:49:51 UTC (rev 4571)
@@ -104,14 +104,15 @@
                 (*it)->getCreatureController()->getCreature()->getActor()
                     ->_getSceneNode()->_getWorldAABB());
 
-			// Place buttons, if needed by current state
-			if (mUserInputEnabled)
-			{
-				Ogre::Rect screenRect = mCamera->getPixelRectOnScreen(rec);
-				// Place button set above opponent, horizontally centered.
-				int xpos = screenRect.left + ((screenRect.right - screenRect.left) - setSize.first) / 2;
-				mCombatWindow->placeEnemyButtonSet(mOpponentButtons[*it], xpos, screenRect.top - setSize.second);
-			}
+			// Place buttons, update every frame (camera movement requires this)
+                        // TODO: is there any better possibility (attach button-windows to ogre node?!?)
+			//if (mUserInputEnabled)
+			//{
+			Ogre::Rect screenRect = mCamera->getPixelRectOnScreen(rec);
+			// Place button set above opponent, horizontally centered.
+			int xpos = screenRect.left + ((screenRect.right - screenRect.left) - setSize.first) / 2;
+			mCombatWindow->placeEnemyButtonSet(mOpponentButtons[*it], xpos, screenRect.top - setSize.second);
+			//}
 
 			// draw Hud
 



From fusion2 at mail.berlios.de  Wed Nov  5 22:08:37 2008
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Wed, 5 Nov 2008 22:08:37 +0100
Subject: [Dsa-hl-svn] r4572 - in rl/trunk/editors/Lockenwickler/src: . media
	media/icons
Message-ID: <200811052108.mA5L8bVX013939@sheep.berlios.de>

Author: fusion2
Date: 2008-11-05 22:08:25 +0100 (Wed, 05 Nov 2008)
New Revision: 4572

Added:
   rl/trunk/editors/Lockenwickler/src/media/icons/cursor.png
   rl/trunk/editors/Lockenwickler/src/media/lightbulb.blend
Modified:
   rl/trunk/editors/Lockenwickler/src/GameObjectClass.py
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/MyRaySceneQueryListener.py
Log:
- updated game object placement


Modified: rl/trunk/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2008-11-03 15:49:51 UTC (rev 4571)
+++ rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2008-11-05 21:08:25 UTC (rev 4572)
@@ -1,176 +1,184 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-from elementtree.ElementTree import *
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from GOStringEditor import *
-
-class GOCStringProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "STRING"
-
-    def openEditor(self, row, parent = None):
-        dlg = GOStringEditor(parent)
-        dlg.nameEdit.setText(self.name)
-        dlg.dataEdit.setText(self.data)
-        result = dlg.exec_()
-        if result:
-            self.name = dlg.nameEdit.text()
-            self.data = dlg.dataEdit.toPlainText()
-
-        return result
-
-class GOCRealProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "REAL"
-
-class GOCBoolProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "BOOL"
-
-class GOCIntProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "INT"
-
-class GOCIntPairProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "INTPAIR"
-
-class GOCIntTripleProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "INTTRIPPLE"
-
-class GOCMapProperty():
-    def __init__(self, name):
-        self.name = name
-        self.childProperties = []
-
-    def getType(self):
-        return "MAP"
-
-class GameObjectRepresentation():
-    def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
-        self.inWorldId = inWorldId
-        self.goc = gameObjectClass
-        self.node = node
-        self.meshFile = meshFile
-
-    def setPosition(self, pos):
-        self.node.setPosition(pos)
-
-
-class GameObjectClass():
-    def __init__(self,  parentElement):
-        self.classid = parentElement.get("classid")
-        self.baseclass = parentElement.get("baseclass")
-
-        self.meshFile = None
-
-        self.properties = []
-
-        for property in parentElement:#.getiterator("property"):
-            if property.get("type") == "ARRAY":
-                pass
-            elif property.get("type") == "MAP":
-                self.properties.append(self.createPropertyMap(property))
-            else:
-                self.properties.append(self.createProperty(property))
-
-    def getType(self):
-        return "GAME_OBJECT"
-
-    def createPropertyMap(self, property):
-        propMap = GOCMapProperty(property.get("name"))
-        for subProperty in property:
-            if subProperty.get("type") == "MAP":
-                propMap.childProperties.append(self.createPropertyMap(property))
-            else:
-                for subProperty1 in property:
-                    propMap.childProperties.append(self.createProperty(subProperty1))
-
-        return propMap
-
-    def getMeshFileName(self):
-        if self.meshFile is None:
-            for prop in self.properties:
-                if prop.getType() == "STRING":
-                    if prop.name == "meshfile":
-                        self.meshFile = prop.data
-                        return self.meshFile
-            return None
-        else:
-            return self.meshFile
-
-
-    def createProperty(self, property):
-        if property.get("type") == "STRING":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCStringProperty(name, data)
-        elif property.get("type") == "REAL":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCRealProperty(name, data)
-        elif property.get("type") == "BOOL":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCBoolProperty(name, data)
-        elif property.get("type") == "INT":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCIntProperty(name, data)
-        elif property.get("type") == "INTPAIR":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCIntPairProperty(name, data)
-        elif property.get("type") == "INTTRIPLE":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCIntTripleProperty(name, data)
-        else:
-            print property.get("type")
-
-
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+from elementtree.ElementTree import *
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+import ogre.renderer.OGRE as og
+
+from GOStringEditor import *
+
+class GOCStringProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "STRING"
+
+    def openEditor(self, row, parent = None):
+        dlg = GOStringEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCRealProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "REAL"
+
+class GOCBoolProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "BOOL"
+
+class GOCIntProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "INT"
+
+class GOCIntPairProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "INTPAIR"
+
+class GOCIntTripleProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "INTTRIPPLE"
+
+class GOCMapProperty():
+    def __init__(self, name):
+        self.name = name
+        self.childProperties = []
+
+    def getType(self):
+        return "MAP"
+
+# gameObjectClass is the id of the class itself
+# since a game object can be ingame more than once there is also a id for those
+class GameObjectRepresentation(og.UserDefinedObject):
+    def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
+        og.UserDefinedObject.__init__(self)
+        self.inWorldId = inWorldId
+        self.gocName = gameObjectClass
+        self.node = node
+        self.meshFile = meshFile
+
+    def getType(self):
+        return "GAME_OBJECT_REPRESENTATION"
+
+    def setPosition(self, pos):
+        self.node.setPosition(pos)
+
+
+class GameObjectClass():
+    def __init__(self,  parentElement):
+        self.classid = parentElement.get("classid")
+        self.baseclass = parentElement.get("baseclass")
+
+        self.meshFile = None
+
+        self.properties = []
+
+        for property in parentElement:#.getiterator("property"):
+            if property.get("type") == "ARRAY":
+                pass
+            elif property.get("type") == "MAP":
+                self.properties.append(self.createPropertyMap(property))
+            else:
+                self.properties.append(self.createProperty(property))
+
+    def getType(self):
+        return "GAME_OBJECT"
+
+    def createPropertyMap(self, property):
+        propMap = GOCMapProperty(property.get("name"))
+        for subProperty in property:
+            if subProperty.get("type") == "MAP":
+                propMap.childProperties.append(self.createPropertyMap(property))
+            else:
+                for subProperty1 in property:
+                    propMap.childProperties.append(self.createProperty(subProperty1))
+
+        return propMap
+
+    def getMeshFileName(self):
+        if self.meshFile is None:
+            for prop in self.properties:
+                if prop.getType() == "STRING":
+                    if prop.name == "meshfile":
+                        self.meshFile = prop.data
+                        return self.meshFile
+            return None
+        else:
+            return self.meshFile
+
+
+    def createProperty(self, property):
+        if property.get("type") == "STRING":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCStringProperty(name, data)
+        elif property.get("type") == "REAL":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCRealProperty(name, data)
+        elif property.get("type") == "BOOL":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCBoolProperty(name, data)
+        elif property.get("type") == "INT":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCIntProperty(name, data)
+        elif property.get("type") == "INTPAIR":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCIntPairProperty(name, data)
+        elif property.get("type") == "INTTRIPLE":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCIntTripleProperty(name, data)
+        else:
+            print property.get("type")
+
+
+

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2008-11-03 15:49:51 UTC (rev 4571)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2008-11-05 21:08:25 UTC (rev 4572)
@@ -1,499 +1,507 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-#sys.path.insert(0,'..')
-#import PythonOgreConfig
-
-from random import randint
-from os.path import isfile
-
-from PyQt4 import QtGui, QtCore
-from PreferencesDialog import *
-from ObjectPropertyWin import *
-from ModelSelectionDialog import *
-from GameObjectClassView import *
-from ConsoleWindow import *
-from ModuleManager import *
-from SceneExplorer import *
-
-import OgreMainWindow
-import ogre.renderer.OGRE as og
-
-class Lockenwickler(QtGui.QMainWindow):
-    def __init__(self, parent=None):
-        QtGui.QWidget.__init__(self, parent)
-
-        pixmap = QPixmap("media/icons/lockenwickler_provisorium.png")
-        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
-        splash.setMask(pixmap.mask())
-        splash.showMessage("Starting...")
-        splash.show()
-
-        self.setupUi()
-
-        self.consoleWindow = ConsoleWindow(False,  self)
-
-        self.setupOgre()
-
-        self.prefDialog = PreferencesDialog(self.loadModule, self)
-        self.objectPropertyWin = ObjectPropertyWin(self)
-        self.sceneExplorerWin = SceneExplorer(self)
-        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
-        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
-
-        self.createDockWindows()
-
-        self.mainTimer = QtCore.QTimer(self)
-        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL("timeout()"), self.update)
-        self.mainTimer.start(5)
-
-        settings = QtCore.QSettings()
-        self.restoreGeometry(settings.value("MainWindow/Geometry").toByteArray())
-        self.restoreState(settings.value("MainWindow/DockWindows").toByteArray())
-
-        self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
-        self.setWindowTitle("Rastullahs Lockenwickler")
-#        # Import Psyco if available
-#        try:
-#            import psyco
-#            psyco.full()
-#            #psyco.log()
-#            #psyco.profile()
-#        except ImportError:
-#            pass
-
-        #QtGui.QApplication.setKeyboardInputInterval(5000)
-
-        splash.finish(self)
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
-        action = QtGui.QAction(text, self)
-        if icon is not None:
-            action.setIcon(QtGui.QIcon("media/icons/%s" % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            self.connect(action, QtCore.SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
-
-    def addActions(self, target, actions):
-        for act in actions:
-            if act is None:
-               target.addSeparator()
-            else:
-                target.addAction(act)
-
-    def setupUi(self):
-        self.setObjectName("MainWindow")
-
-        self.centralwidget = QtGui.QWidget(self)
-        self.centralwidget.setObjectName("centralwidget")
-
-        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
-        self.hboxlayout.setObjectName("hboxlayout")
-
-        self.gridlayout = QtGui.QGridLayout()
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.menubar = QtGui.QMenuBar(self)
-        self.menubar.setObjectName("menubar")
-
-        self.menuFile = QtGui.QMenu(self.menubar)
-        self.menuFile.setObjectName("menuFile")
-
-        self.menuEdit = QtGui.QMenu(self.menubar)
-        self.menuEdit.setObjectName("menuEdit")
-
-        self.menuView = QtGui.QMenu(self.menubar)
-        self.menuView.setObjectName("menuView")
-        self.setMenuBar(self.menubar)
-
-
-        self.statusbar = QtGui.QStatusBar(self)
-        self.statusbar.setObjectName("statusbar")
-        self.setStatusBar(self.statusbar)
-
-#####################################
-        self.actionNeu =self.createAction("&New",  self.actionNewSlot,  QKeySequence.New,  "filenew.png",  "New")
-        self.actionNeu.setObjectName("actionNeu")
-
-        self.actionClose = self.createAction("Quit",  self.actionQuitSlot,  "Alt + Q",  "exit.png",  "Quit")
-        self.actionClose.setObjectName("actionQuit")
-#####################################
-
-
-#####################################
-        self.actionDelete = self.createAction("Delete",  self.actionDeleteSlot,  QKeySequence.Delete,  "editdelete.png",  "Delete")
-        self.actionDelete.setObjectName("actionDelete")
-
-        self.actionCopy = self.createAction("Copy",  self.actionCopySlot,  QKeySequence.Copy,  "editcopy.png",  "Copy")
-        self.actionCopy.setObjectName("actionCopy")
-
-        self.actionCut = self.createAction("Cut",  self.actionCutSlot,  QKeySequence.Cut,  "editcut.png",  "Cut")
-        self.actionCut.setObjectName("actionCut")
-
-        self.actionPaste = self.createAction("Paste",  self.actionPasteSlot,  QKeySequence.Paste,  "editpaste.png",  "Paste")
-        self.actionPaste.setObjectName("actionPaste")
-
-        self.actionMove = self.createAction("&Move",  self.actionMoveSlot,  "g",  "move.png",  "Move selected object")
-        self.actionMove.setObjectName("actionMove")
-
-        self.actionRotate = self.createAction("&Rotate",  self.actionRotateSlot,  "r",  "rotate.png",  "Rotate selected object")
-        self.actionRotate.setObjectName("actionRotate")
-
-        self.actionScale = self.createAction("&Scale",  self.actionScaleSlot,  "x",  "resizecol.png",  "Scale selected object")
-        self.actionRotate.setObjectName("actionRotate")
-
-
-#####################################
-#####################################
-        self.actionSceneExplorer = self.createAction("&Scene Exlporer",  self.toggleSceneExplorer,  "Alt + E",  "view_tree.png",  "Scene Explorer",  False)
-        self.actionSceneExplorer.setObjectName("actionSceneExplorer")
-
-        self.actionPreferences = self.createAction("&Preferences",  self.togglePreferencesWindow,  "Alt + P",  "configure.png",  "Lockenwickler Preferences",  False)
-        self.actionPreferences.setObjectName("actionPreferences")
-
-        self.actionProperty_Window = self.createAction("Pr&operty Window",  self.togglePropertyWindow,  "Alt + P",  "unsortedlist1.png",  "Property Window")
-        self.actionProperty_Window.setObjectName("actionProperty_Window")
-
-        self.actionObject_Selection = self.createAction("&Model Preview Window",  self.toggleModelPreviewWindow,  "Alt + O",  "tux.png",  "Model Preview")
-        self.actionObject_Selection.setObjectName("actionObject_Selection")
-
-        self.actionGameObjectClass_Selection = self.createAction("&Game Object Class Preview Window",  self.toggleGameObjectViewWindow,  "Alt + G",  "multirow.png",  "GameObjectClass Preview")
-        self.actionGameObjectClass_Selection.setObjectName("actionObject_Selection")
-
-        self.actionConsole_Window = self.createAction("&Console Window",  self.toggleConsoleWindow,  "Alt + C",  "console.png",  "Console Window")
-        self.actionConsole_Window.setObjectName("actionConsole_Window")
-
-#####################################
-#####################################
-
-
-        self.menuFile.addAction(self.actionNeu)
-        self.menuFile.addAction(self.actionClose)
-
-        self.menuEdit.addAction(self.actionMove)
-        self.menuEdit.addAction(self.actionRotate)
-        self.menuEdit.addAction(self.actionScale)
-        self.menuEdit.addSeparator()
-        self.menuEdit.addAction(self.actionDelete)
-        self.menuEdit.addAction(self.actionCopy)
-        self.menuEdit.addAction(self.actionCut)
-        self.menuEdit.addAction(self.actionPaste)
-
-        self.menuView.addAction(self.actionSceneExplorer)
-        self.menuView.addAction(self.actionPreferences)
-        self.menuView.addAction(self.actionProperty_Window)
-        self.menuView.addAction(self.actionObject_Selection)
-        self.menuView.addAction(self.actionGameObjectClass_Selection)
-        self.menuView.addAction(self.actionConsole_Window)
-        self.menubar.addAction(self.menuFile.menuAction())
-        self.menubar.addAction(self.menuEdit.menuAction())
-        self.menubar.addAction(self.menuView.menuAction())
-
-        self.retranslateUi()
-        QtCore.QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuEdit.setTitle(QtGui.QApplication.translate("MainWindow", "Edit", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "New", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionMove.setText(QtGui.QApplication.translate("MainWindow", "Move", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionRotate.setText(QtGui.QApplication.translate("MainWindow", "Rotate", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionSceneExplorer.setText(QtGui.QApplication.translate("MainWindow", "Scene Explorer", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionClose.setText(QtGui.QApplication.translate("MainWindow", "Quit", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionConsole_Window.setText(QtGui.QApplication.translate("MainWindow", "Console Window", None, QtGui.QApplication.UnicodeUTF8))
-
-    def setupOgre(self, pluginCfgPath="./Plugins.cfg", ogreCfgPath="./ogre.cfg", logPath="./ogre.log"):
-        if platform.system() == "Windows":
-            pluginCfgPath="./Plugins-windows.cfg"
-        else:
-            pluginCfgPath="./Plugins-linux.cfg"
-
-        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
-        self.ogreRoot = root
-
-        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
-            sys.exit('Quit from Config Dialog')
-
-        root.initialise(False)
-
-        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, "OgreMainWinSceneMgr")
-        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
-
-        self.moduleName = ""
-        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
-
-        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
-        self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
-        self.hboxlayout.addLayout(self.gridlayout)
-        self.setCentralWidget(self.centralwidget)
-
-        og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
-        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-        oglog = og.LogManager.getSingleton().getDefaultLog()
-        oglog.addListener(self.consoleWindow.lockenLog)
-
-    def update(self):
-#        try:
-#            self.OgreMainWinSceneMgr.getSceneNode("saeule_076_node").yaw(0.02)
-#        except Exception,  e:
-#            pass
-
-        self.ogreRoot.renderOneFrame()
-
-    def actionNewSlot(self):
-        print "dbg: new"
-        return
-
-    def actionQuitSlot(self):
-        self.close()
-
-    def actionDeleteSlot(self):
-        self.moduleManager.deleteObjects()
-
-    def actionCopySlot(self):
-        self.moduleManager.copyObjects()
-
-    def actionCutSlot(self):
-        self.moduleManager.cutObjects()
-
-    def actionPasteSlot(self):
-        self.moduleManager.pasteObjects(self.ogreRenderWindow.getCameraToViewportRay())
-
-    def actionMoveSlot(self):
-        self.moduleManager.pivot.setMoveMode()
-
-    def actionRotateSlot(self):
-        self.moduleManager.pivot.setRotateMode()
-
-    def actionScaleSlot(self):
-        self.moduleManager.pivot.setScaleMode()
-
-    def togglePreferencesWindow(self):
-        if self.prefDialog.isHidden():
-            self.prefDialog.show()
-        else:
-            self.prefDialog.hide()
-
-    def toggleModelPreviewWindow(self):
-        if self.modelSelectionDock.isHidden():
-            self.modelSelectionDock.show()
-        else:
-            self.modelSelectionDock.hide()
-
-    def toggleGameObjectViewWindow(self):
-        if self.gameObjectClassViewDock.isHidden():
-            self.gameObjectClassViewDock.show()
-        else:
-            self.gameObjectClassViewDock.hide()
-
-    def toggleSceneExplorer(self):
-        if self.sceneExplorerDock.isHidden():
-            self.sceneExplorerDock.show()
-        else:
-            self.sceneExplorerDock.hide()
-
-    def togglePropertyWindow(self):
-        if self.propertyDock.isHidden():
-            self.propertyDock.show()
-        else:
-            self.propertyDock.hide()
-
-    def toggleConsoleWindow(self):
-        if self.consoleDock.isHidden():
-            self.consoleDock.show()
-        else:
-            self.consoleDock.hide()
-
-    # parses the moduleconfig.rb and searches for all loader.loadmap(" statements in the ruby script
-    # and parses them too
-    def loadModule(self, modulePath, moduleName):
-        if self.moduleName == moduleName:
-            return
-
-        self.moduleName = moduleName
-        self.workingDir = modulePath + moduleName # the module path
-        self.workingDirCommon = modulePath + "common" # the module path of the common module
-
-        import codecs
-        import glob
-
-        modConfig = self.workingDir + "/scripts/moduleconfig.rb"
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
-        else:
-            print ("Error: couldn't find module config")
-            pass
-
-        self.mapFiles = [] # a list in case the module has more than one map file
-        self.gofFiles = [] # gof File list
-        for line in f:
-            lStripped = line.strip() #strip the whitespace away, not needed here
-
-            # get the map file(s)
-            if lStripped.startswith("loader.loadMap("): # all loadMap commands begin with loader.loadMap(
-                spl = lStripped.split('"')
-                for a in spl:
-                    if a.endswith(".xml"):
-                        pathToMapFile = self.workingDir + "/maps/" + a
-                        self.mapFiles.append(pathToMapFile)
-
-        self.setWindowTitle(moduleName)
-
-        self.modelSelectionDialog.scanDirForModels(self.workingDir, moduleName)
-        self.modelSelectionDialog.scanDirForModels(self.workingDirCommon, "common")
-
-        self.setResourcePaths(self.workingDir, moduleName)
-        self.setResourcePaths(self.workingDirCommon, "common")
-        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-        command = (os.path.join(self.workingDir,  "maps") + "/*.xml")
-        for mf in glob.glob(command): # search for all xml files in the maps directory and add them
-            self.mapFiles.append(mf)
-
-        command = (os.path.join(self.workingDir,  "maps") + "/*.scene")
-        for mf in glob.glob(command): # search for all .scene files in the maps directory and add them
-            self.mapFiles.append(mf)
-
-        command = (os.path.join(self.workingDir,  "dsa") + "/*.gof")
-        for gf in glob.glob(command): # search for all .gof files in the dsa directory in the module dir
-            self.gofFiles.append(gf)
-
-        command = (os.path.join(self.workingDirCommon,  "dsa") + "/*.gof")
-        for gf in glob.glob(command): # search for all .gof files in the dsa directory in the common module dir
-            self.gofFiles.append(gf)
-
-        self.moduleManager.load(moduleName,  self.mapFiles,  self.gofFiles)
-
-    def setResourcePaths(self, path, moduleName):
-        for file in os.listdir(path):
-            curFile = path + "/" + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", moduleName, False)
-                self.setResourcePaths(curFile, moduleName)
-                continue
-            if isfile(curFile):
-                pass
-
-    def createDockWindows(self):
-        self.propertyDock = QtGui.QDockWidget(self.tr("Properties"), self)
-        self.propertyDock.setObjectName("PropertyDockWindow")
-        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.propertyDock.setWidget(self.objectPropertyWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
-
-        self.modelSelectionDock = QtGui.QDockWidget(self.tr("Models"), self)
-        self.modelSelectionDock.setObjectName("ModelSelectionDockWindow")
-        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
-
-        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr("GameObjectClasses"), self)
-        self.gameObjectClassViewDock.setObjectName("GameObjectClassView")
-        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
-
-        self.sceneExplorerDock = QtGui.QDockWidget(self.tr("Scene Explorer"), self)
-        self.sceneExplorerDock.setObjectName("SceneExplorerDockWindow")
-        self.sceneExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.sceneExplorerDock.setWidget(self.sceneExplorerWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.sceneExplorerDock)
-
-        self.consoleDock = QtGui.QDockWidget(self.tr("Console"), self)
-        self.consoleDock.setObjectName("ConsoleDockWindow")
-        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
-        self.consoleDock.setWidget(self.consoleWindow)
-        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
-
-        self.fileToolBar = self.addToolBar("File Toolbar")
-        self.fileToolBar.setObjectName("FileToolBar")
-        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.fileToolBar.addAction(self.actionNeu)
-        self.fileToolBar.addAction(self.actionClose)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
-
-        self.moveToolBar = self.addToolBar("Transformation Bar")
-        self.moveToolBar.setObjectName("TransformationBar")
-        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.moveToolBar.addAction(self.actionMove)
-        self.moveToolBar.addAction(self.actionRotate)
-        self.moveToolBar.addAction(self.actionScale)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
-
-    def keyPressEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreRenderWindow.keyPressEvent(event)
-
-    def keyReleaseEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreRenderWindow.keyReleaseEvent(event)
-        pass
-
-    def connectActionButtons(self):
-        pass
-
-    def saveOnClose(self):
-        reply = QtGui.QMessageBox.question(self,  "Rastullahs Lockenwickler - Unsaved Chages",  "Save unsaved changes?",  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
-        if reply == QtGui.QMessageBox.Cancel:
-            return False
-        if reply == QtGui.QMessageBox.Yes:
-            print""
-            #TODO: implement save here
-        return True
-
-    def closeEvent(self,  event):
-        if self.saveOnClose():
-            settings = QtCore.QSettings()
-            settings.setValue("MainWindow/Geometry",  QtCore.QVariant(self.saveGeometry()))
-            settings.setValue("MainWIndow/DockWindows",  QtCore.QVariant(self.saveState()))
-        else:
-            event.ignore()
-
-if __name__ == "__main__":
-    app = QtGui.QApplication(sys.argv)
-    app.setOrganizationName("Team Pantheon")
-    app.setOrganizationDomain("rastullahs-lockenpracht.de/team")
-    app.setApplicationName("Lockenwickler")
-
-    form = Lockenwickler()
-    form.show()
-
-    sys.exit(app.exec_())
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import os
+import sys
+import platform
+
+#sys.path.insert(0,'..')
+#import PythonOgreConfig
+
+from random import randint
+from os.path import isfile
+
+from PyQt4 import QtGui, QtCore
+from PreferencesDialog import *
+from ObjectPropertyWin import *
+from ModelSelectionDialog import *
+from GameObjectClassView import *
+from ConsoleWindow import *
+from ModuleManager import *
+from SceneExplorer import *
+
+import OgreMainWindow
+import ogre.renderer.OGRE as og
+
+class Lockenwickler(QtGui.QMainWindow):
+    def __init__(self, parent=None):
+        QtGui.QWidget.__init__(self, parent)
+
+        pixmap = QPixmap("media/icons/lockenwickler_provisorium.png")
+        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
+        splash.setMask(pixmap.mask())
+        splash.showMessage("Starting...")
+        splash.show()
+
+        self.setupUi()
+
+        self.consoleWindow = ConsoleWindow(False,  self)
+
+        self.setupOgre()
+
+        self.prefDialog = PreferencesDialog(self.loadModule, self)
+        self.objectPropertyWin = ObjectPropertyWin(self)
+        self.sceneExplorerWin = SceneExplorer(self)
+        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
+
+        self.createDockWindows()
+
+        self.mainTimer = QtCore.QTimer(self)
+        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL("timeout()"), self.update)
+        self.mainTimer.start(5)
+
+        settings = QtCore.QSettings()
+        self.restoreGeometry(settings.value("MainWindow/Geometry").toByteArray())
+        self.restoreState(settings.value("MainWindow/DockWindows").toByteArray())
+
+        self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
+        self.setWindowTitle("Rastullahs Lockenwickler")
+#        # Import Psyco if available
+#        try:
+#            import psyco
+#            psyco.full()
+#            #psyco.log()
+#            #psyco.profile()
+#        except ImportError:
+#            pass
+
+        #QtGui.QApplication.setKeyboardInputInterval(5000)
+
+        splash.finish(self)
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QtGui.QAction(text, self)
+        if icon is not None:
+            action.setIcon(QtGui.QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            self.connect(action, QtCore.SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+
+    def addActions(self, target, actions):
+        for act in actions:
+            if act is None:
+               target.addSeparator()
+            else:
+                target.addAction(act)
+
+    def setupUi(self):
+        self.setObjectName("MainWindow")
+
+        self.centralwidget = QtGui.QWidget(self)
+        self.centralwidget.setObjectName("centralwidget")
+
+        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
+        self.hboxlayout.setObjectName("hboxlayout")
+
+        self.gridlayout = QtGui.QGridLayout()
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.menubar = QtGui.QMenuBar(self)
+        self.menubar.setObjectName("menubar")
+
+        self.menuFile = QtGui.QMenu(self.menubar)
+        self.menuFile.setObjectName("menuFile")
+
+        self.menuEdit = QtGui.QMenu(self.menubar)
+        self.menuEdit.setObjectName("menuEdit")
+
+        self.menuView = QtGui.QMenu(self.menubar)
+        self.menuView.setObjectName("menuView")
+        self.setMenuBar(self.menubar)
+
+
+        self.statusbar = QtGui.QStatusBar(self)
+        self.statusbar.setObjectName("statusbar")
+        self.setStatusBar(self.statusbar)
+
+#####################################
+        self.actionNeu =self.createAction("&New",  self.actionNewSlot,  QKeySequence.New,  "filenew.png",  "New")
+        self.actionNeu.setObjectName("actionNeu")
+
+        self.actionClose = self.createAction("Quit",  self.actionQuitSlot,  "Alt + Q",  "exit.png",  "Quit")
+        self.actionClose.setObjectName("actionQuit")
+#####################################
+
+
+#####################################
+        self.actionDelete = self.createAction("Delete",  self.actionDeleteSlot,  QKeySequence.Delete,  "editdelete.png",  "Delete")
+        self.actionDelete.setObjectName("actionDelete")
+
+        self.actionCopy = self.createAction("Copy",  self.actionCopySlot,  QKeySequence.Copy,  "editcopy.png",  "Copy")
+        self.actionCopy.setObjectName("actionCopy")
+
+        self.actionCut = self.createAction("Cut",  self.actionCutSlot,  QKeySequence.Cut,  "editcut.png",  "Cut")
+        self.actionCut.setObjectName("actionCut")
+
+        self.actionPaste = self.createAction("Paste",  self.actionPasteSlot,  QKeySequence.Paste,  "editpaste.png",  "Paste")
+        self.actionPaste.setObjectName("actionPaste")
+
+        self.actionSelect = self.createAction("&Select",  self.actionSelectSlot,  "Space",  "cursor.png",  "Move selected object")
+        self.actionSelect.setObjectName("actionSelect")
+
+        self.actionMove = self.createAction("&Move",  self.actionMoveSlot,  "g",  "move.png",  "Move selected object")
+        self.actionMove.setObjectName("actionMove")
+
+        self.actionRotate = self.createAction("&Rotate",  self.actionRotateSlot,  "r",  "rotate.png",  "Rotate selected object")
+        self.actionRotate.setObjectName("actionRotate")
+
+        self.actionScale = self.createAction("&Scale",  self.actionScaleSlot,  "x",  "resizecol.png",  "Scale selected object")
+        self.actionRotate.setObjectName("actionRotate")
+
+
+#####################################
+#####################################
+        self.actionSceneExplorer = self.createAction("&Scene Exlporer",  self.toggleSceneExplorer,  "Alt + E",  "view_tree.png",  "Scene Explorer",  False)
+        self.actionSceneExplorer.setObjectName("actionSceneExplorer")
+
+        self.actionPreferences = self.createAction("&Preferences",  self.togglePreferencesWindow,  "Alt + P",  "configure.png",  "Lockenwickler Preferences",  False)
+        self.actionPreferences.setObjectName("actionPreferences")
+
+        self.actionProperty_Window = self.createAction("Pr&operty Window",  self.togglePropertyWindow,  "Alt + P",  "unsortedlist1.png",  "Property Window")
+        self.actionProperty_Window.setObjectName("actionProperty_Window")
+
+        self.actionObject_Selection = self.createAction("&Model Preview Window",  self.toggleModelPreviewWindow,  "Alt + O",  "tux.png",  "Model Preview")
+        self.actionObject_Selection.setObjectName("actionObject_Selection")
+
+        self.actionGameObjectClass_Selection = self.createAction("&Game Object Class Preview Window",  self.toggleGameObjectViewWindow,  "Alt + G",  "multirow.png",  "GameObjectClass Preview")
+        self.actionGameObjectClass_Selection.setObjectName("actionObject_Selection")
+
+        self.actionConsole_Window = self.createAction("&Console Window",  self.toggleConsoleWindow,  "Alt + C",  "console.png",  "Console Window")
+        self.actionConsole_Window.setObjectName("actionConsole_Window")
+
+#####################################
+#####################################
+
+
+        self.menuFile.addAction(self.actionNeu)
+        self.menuFile.addAction(self.actionClose)
+
+        self.menuEdit.addAction(self.actionSelect)
+        self.menuEdit.addAction(self.actionMove)
+        self.menuEdit.addAction(self.actionRotate)
+        self.menuEdit.addAction(self.actionScale)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionDelete)
+        self.menuEdit.addAction(self.actionCopy)
+        self.menuEdit.addAction(self.actionCut)
+        self.menuEdit.addAction(self.actionPaste)
+
+        self.menuView.addAction(self.actionSceneExplorer)
+        self.menuView.addAction(self.actionPreferences)
+        self.menuView.addAction(self.actionProperty_Window)
+        self.menuView.addAction(self.actionObject_Selection)
+        self.menuView.addAction(self.actionGameObjectClass_Selection)
+        self.menuView.addAction(self.actionConsole_Window)
+        self.menubar.addAction(self.menuFile.menuAction())
+        self.menubar.addAction(self.menuEdit.menuAction())
+        self.menubar.addAction(self.menuView.menuAction())
+
+        self.retranslateUi()
+        QtCore.QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuEdit.setTitle(QtGui.QApplication.translate("MainWindow", "Edit", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "New", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionMove.setText(QtGui.QApplication.translate("MainWindow", "Move", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionRotate.setText(QtGui.QApplication.translate("MainWindow", "Rotate", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionSceneExplorer.setText(QtGui.QApplication.translate("MainWindow", "Scene Explorer", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionClose.setText(QtGui.QApplication.translate("MainWindow", "Quit", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionConsole_Window.setText(QtGui.QApplication.translate("MainWindow", "Console Window", None, QtGui.QApplication.UnicodeUTF8))
+
+    def setupOgre(self, pluginCfgPath="./Plugins.cfg", ogreCfgPath="./ogre.cfg", logPath="./ogre.log"):
+        if platform.system() == "Windows":
+            pluginCfgPath="./Plugins-windows.cfg"
+        else:
+            pluginCfgPath="./Plugins-linux.cfg"
+
+        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
+        self.ogreRoot = root
+
+        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
+            sys.exit('Quit from Config Dialog')
+
+        root.initialise(False)
+
+        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, "OgreMainWinSceneMgr")
+        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
+
+        self.moduleName = ""
+        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
+
+        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
+        self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
+        self.hboxlayout.addLayout(self.gridlayout)
+        self.setCentralWidget(self.centralwidget)
+
+        og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
+        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+        oglog = og.LogManager.getSingleton().getDefaultLog()
+        oglog.addListener(self.consoleWindow.lockenLog)
+
+    def update(self):
+#        try:
+#            self.OgreMainWinSceneMgr.getSceneNode("saeule_076_node").yaw(0.02)
+#        except Exception,  e:
+#            pass
+
+        self.ogreRoot.renderOneFrame()
+
+    def actionNewSlot(self):
+        print "dbg: new"
+        return
+
+    def actionQuitSlot(self):
+        self.close()
+
+    def actionDeleteSlot(self):
+        self.moduleManager.deleteObjects()
+
+    def actionCopySlot(self):
+        self.moduleManager.copyObjects()
+
+    def actionCutSlot(self):
+        self.moduleManager.cutObjects()
+
+    def actionPasteSlot(self):
+        self.moduleManager.pasteObjects(self.ogreRenderWindow.getCameraToViewportRay())
+
+    def actionSelectSlot(self):
+        self.moduleManager.pivot.hide()
+
+    def actionMoveSlot(self):
+        self.moduleManager.pivot.setMoveMode()
+
+    def actionRotateSlot(self):
+        self.moduleManager.pivot.setRotateMode()
+
+    def actionScaleSlot(self):
+        self.moduleManager.pivot.setScaleMode()
+
+    def togglePreferencesWindow(self):
+        if self.prefDialog.isHidden():
+            self.prefDialog.show()
+        else:
+            self.prefDialog.hide()
+
+    def toggleModelPreviewWindow(self):
+        if self.modelSelectionDock.isHidden():
+            self.modelSelectionDock.show()
+        else:
+            self.modelSelectionDock.hide()
+
+    def toggleGameObjectViewWindow(self):
+        if self.gameObjectClassViewDock.isHidden():
+            self.gameObjectClassViewDock.show()
+        else:
+            self.gameObjectClassViewDock.hide()
+
+    def toggleSceneExplorer(self):
+        if self.sceneExplorerDock.isHidden():
+            self.sceneExplorerDock.show()
+        else:
+            self.sceneExplorerDock.hide()
+
+    def togglePropertyWindow(self):
+        if self.propertyDock.isHidden():
+            self.propertyDock.show()
+        else:
+            self.propertyDock.hide()
+
+    def toggleConsoleWindow(self):
+        if self.consoleDock.isHidden():
+            self.consoleDock.show()
+        else:
+            self.consoleDock.hide()
+
+    # parses the moduleconfig.rb and searches for all loader.loadmap(" statements in the ruby script
+    # and parses them too
+    def loadModule(self, modulePath, moduleName):
+        if self.moduleName == moduleName:
+            return
+
+        self.moduleName = moduleName
+        self.workingDir = modulePath + moduleName # the module path
+        self.workingDirCommon = modulePath + "common" # the module path of the common module
+
+        import codecs
+        import glob
+
+        modConfig = self.workingDir + "/scripts/moduleconfig.rb"
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print ("Error: couldn't find module config")
+            pass
+
+        self.mapFiles = [] # a list in case the module has more than one map file
+        self.gofFiles = [] # gof File list
+        for line in f:
+            lStripped = line.strip() #strip the whitespace away, not needed here
+
+            # get the map file(s)
+            if lStripped.startswith("loader.loadMap("): # all loadMap commands begin with loader.loadMap(
+                spl = lStripped.split('"')
+                for a in spl:
+                    if a.endswith(".xml"):
+                        pathToMapFile = self.workingDir + "/maps/" + a
+                        self.mapFiles.append(pathToMapFile)
+
+        self.setWindowTitle(moduleName)
+
+        self.modelSelectionDialog.scanDirForModels(self.workingDir, moduleName)
+        self.modelSelectionDialog.scanDirForModels(self.workingDirCommon, "common")
+
+        self.setResourcePaths(self.workingDir, moduleName)
+        self.setResourcePaths(self.workingDirCommon, "common")
+        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+        command = (os.path.join(self.workingDir,  "maps") + "/*.xml")
+        for mf in glob.glob(command): # search for all xml files in the maps directory and add them
+            self.mapFiles.append(mf)
+
+        command = (os.path.join(self.workingDir,  "maps") + "/*.scene")
+        for mf in glob.glob(command): # search for all .scene files in the maps directory and add them
+            self.mapFiles.append(mf)
+
+        command = (os.path.join(self.workingDir,  "dsa") + "/*.gof")
+        for gf in glob.glob(command): # search for all .gof files in the dsa directory in the module dir
+            self.gofFiles.append(gf)
+
+        command = (os.path.join(self.workingDirCommon,  "dsa") + "/*.gof")
+        for gf in glob.glob(command): # search for all .gof files in the dsa directory in the common module dir
+            self.gofFiles.append(gf)
+
+        self.moduleManager.load(moduleName,  self.mapFiles,  self.gofFiles)
+
+    def setResourcePaths(self, path, moduleName):
+        for file in os.listdir(path):
+            curFile = path + "/" + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", moduleName, False)
+                self.setResourcePaths(curFile, moduleName)
+                continue
+            if isfile(curFile):
+                pass
+
+    def createDockWindows(self):
+        self.propertyDock = QtGui.QDockWidget(self.tr("Properties"), self)
+        self.propertyDock.setObjectName("PropertyDockWindow")
+        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.propertyDock.setWidget(self.objectPropertyWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
+
+        self.modelSelectionDock = QtGui.QDockWidget(self.tr("Models"), self)
+        self.modelSelectionDock.setObjectName("ModelSelectionDockWindow")
+        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
+
+        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr("GameObjectClasses"), self)
+        self.gameObjectClassViewDock.setObjectName("GameObjectClassView")
+        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
+
+        self.sceneExplorerDock = QtGui.QDockWidget(self.tr("Scene Explorer"), self)
+        self.sceneExplorerDock.setObjectName("SceneExplorerDockWindow")
+        self.sceneExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.sceneExplorerDock.setWidget(self.sceneExplorerWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.sceneExplorerDock)
+
+        self.consoleDock = QtGui.QDockWidget(self.tr("Console"), self)
+        self.consoleDock.setObjectName("ConsoleDockWindow")
+        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
+        self.consoleDock.setWidget(self.consoleWindow)
+        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
+
+        self.fileToolBar = self.addToolBar("File Toolbar")
+        self.fileToolBar.setObjectName("FileToolBar")
+        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.fileToolBar.addAction(self.actionNeu)
+        self.fileToolBar.addAction(self.actionClose)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
+
+        self.moveToolBar = self.addToolBar("Transformation Bar")
+        self.moveToolBar.setObjectName("TransformationBar")
+        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.moveToolBar.addAction(self.actionSelect)
+        self.moveToolBar.addAction(self.actionMove)
+        self.moveToolBar.addAction(self.actionRotate)
+        self.moveToolBar.addAction(self.actionScale)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
+
+    def keyPressEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreRenderWindow.keyPressEvent(event)
+
+    def keyReleaseEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreRenderWindow.keyReleaseEvent(event)
+        pass
+
+    def connectActionButtons(self):
+        pass
+
+    def saveOnClose(self):
+        reply = QtGui.QMessageBox.question(self,  "Rastullahs Lockenwickler - Unsaved Chages",  "Save unsaved changes?",  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
+        if reply == QtGui.QMessageBox.Cancel:
+            return False
+        if reply == QtGui.QMessageBox.Yes:
+            print""
+            #TODO: implement save here
+        return True
+
+    def closeEvent(self,  event):
+        if self.saveOnClose():
+            settings = QtCore.QSettings()
+            settings.setValue("MainWindow/Geometry",  QtCore.QVariant(self.saveGeometry()))
+            settings.setValue("MainWIndow/DockWindows",  QtCore.QVariant(self.saveState()))
+        else:
+            event.ignore()
+
+if __name__ == "__main__":
+    app = QtGui.QApplication(sys.argv)
+    app.setOrganizationName("Team Pantheon")
+    app.setOrganizationDomain("rastullahs-lockenpracht.de/team")
+    app.setApplicationName("Lockenwickler")
+
+    form = Lockenwickler()
+    form.show()
+
+    sys.exit(app.exec_())
+

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2008-11-03 15:49:51 UTC (rev 4571)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2008-11-05 21:08:25 UTC (rev 4572)
@@ -1,360 +1,384 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-import sys
-import xml.dom.minidom as xml
-
-import ctypes
-import ogre.renderer.OGRE as og
-
-from MovePivot import *
-from GameObjectClassManager import *
-from MyRaySceneQueryListener import *
-
-class ModuleManager(object):
-    def __init__(self,  ogreRoot,  sceneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
-
-        self.gocManager = GameObjectClassManager()
-
-        self.userSelectionList = []
-        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
-        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-
-        self.listenerDings = MyRaySceneQueryListener()
-
-        self.lastRay = None
-#        self.rayLine = None
-
-        self.pivot = None
-        self.movingPivot = False
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.dropCount = 0
-        self.dropNode = None
-        self.dropEntity = None
-        self.dropCollisionPlane = og.Plane(og.Vector3.UNIT_Y, og.Vector3.ZERO)
-
-        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
-
-    def load(self,  moduleName,  mapFiles,  gofFiles):
-        self.moduleName = moduleName
-        self.mapFiles = mapFiles
-        self.gofFiles = gofFiles
-
-        self.gocManager.parseGOFFiles(self.gofFiles)
-
-        for a in self.mapFiles:
-            doc = xml.parse(a)
-            node = doc.getElementsByTagName("entity")
-            if node != None:
-                self.parseSceneNodes(node)
-
-        self.pivot = Pivot(self.sceneManager)
-        self.pivot.hide()
-
-    def parseSceneNodes(self,  nodeList):
-        for ent in nodeList:
-            entityName = ent.attributes["name"].nodeValue # get the name of the ent
-            meshFile = ent.attributes["meshfile"].nodeValue # meshfile
-            nodePosition = None
-            nodeRotation = None
-            nodeScale = None
-
-            for cn in ent.childNodes:
-                if cn.nodeType == cn.ELEMENT_NODE:
-                    if cn.localName == "position":
-                        px = float(cn.attributes["x"].nodeValue)
-                        py = float(cn.attributes["y"].nodeValue)
-                        pz = float(cn.attributes["z"].nodeValue)
-                        nodePosition = og.Vector3(px, py, pz)
-                        continue
-
-                    if cn.localName == "rotation":
-                        qw = float(cn.attributes["qw"].nodeValue)
-                        qx = float(cn.attributes["qx"].nodeValue)
-                        qy = float(cn.attributes["qy"].nodeValue)
-                        qz = float(cn.attributes["qz"].nodeValue)
-                        nodeRotation = og.Quaternion(qw,  qx, qy, qz)
-                        continue
-
-                    if cn.localName == "scale":
-                        px = float(cn.attributes["x"].nodeValue)
-                        py = float(cn.attributes["y"].nodeValue)
-                        pz = float(cn.attributes["z"].nodeValue)
-                        nodeScale = og.Vector3(px, py, pz)
-                        continue
-
-            try:
-                e = self.sceneManager.createEntity(entityName, meshFile)
-            except:
-                print "Warning: Meshfile " + meshFile + " could not be found."
-                return
-
-            n = self.sceneManager.getRootSceneNode().createChild(entityName + "_node")
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            #n.setOrientation(nodeRotation)
-            n.setScale(nodeScale)
-
-        pass
-
-    # called when a click into Main Ogre Window occurs
-    def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
-        self.listenerDings.reset()
-        self.lastRay = ray
-        self.listenerDings.currentRay = ray
-        self.raySceneQuery.Ray = ray
-        self.raySceneQuery.execute(self.listenerDings)
-
-        so = self.listenerDings.rayCastToPolygonLevel(ray)
-        if so is not None:
-            if not so.isPivot:
-                if self.pivot is not None:
-                    self.pivot.show()
-                if not controlDown and not shiftDown:
-                    self.resetSelection()
-                    so.setSelected(True)
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-                elif controlDown and not shiftDown:
-                    so.setSelected(True)
-
-                    for soFromList in self.userSelectionList:
-                        if soFromList == so:
-                            return # object already selected
-
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-
-
-                elif not controlDown and shiftDown:
-                    for selo in self.userSelectionList:
-                        if so == selo:
-                            so.setSelected(False)
-                            self.userSelectionList.remove(selo)
-                    self.updatePivots()
-            else:
-                #so.entity is the pivot direction that was clicked
-                self.pivot.startTransforming(so.entity,  self.userSelectionList)
-        else:
-            self.resetSelection() # click in empty space, deselect everything
-            if self.pivot is not None:
-                self.pivot.hide()
-
-#        if self.rayLine == None:
-#            self.rayLine = self.sceneManager.createManualObject("rayLine")
-#            self.rayLine.setDynamic(True)
-#            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
-#
-#            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-#
-#        else:
-#            self.rayLine.beginUpdate(0)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-
-    def deleteObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.pivot.hide()
-
-        for so in self.userSelectionList:
-            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
-            del so
-
-        self.userSelectionList = []
-
-    def incrementNameSuffixNumber(self, name):
-        newName = ""
-        split = name.split("_")
-        lastPart = len(split)-1
-        newName = name.rstrip(split[lastPart])
-        newName = newName + str(self.numerOfCopys)
-
-#        if split[lastPart].isdigit() and not split[lastPart].startswith("0"):
-#            num = int(split[lastPart])
-#            num = num + 1
-#            newName = name.rstrip(split[lastPart])
-#            newName = newName + str(num)
-#        else:
-#            newName = name + "_1"
-
-        self.numerOfCopys = self.numerOfCopys + 1
-        return newName
-
-    def copyObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        newSelectionList = []
-        print "dbg: "
-        for so in self.userSelectionList:
-            nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
-            newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
-
-            entityName = self.incrementNameSuffixNumber(so.entity.getName())
-            newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
-
-            newNode.attachObject(newEntity)
-            newNode.setPosition(so.entity.getParentNode().getPosition())
-            newNode.setOrientation(so.entity.getParentNode().getOrientation())
-            newNode.setScale(so.entity.getParentNode().getScale())
-
-            newSO = SelectionObject(newEntity, so.distance)
-            newSO.setSelected(True)
-            newSelectionList.append(newSO)
-
-        self.resetSelection()
-        self.userSelectionList = newSelectionList
-
-    def cutObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-            return
-
-        self.cutList = []
-        for so in self.userSelectionList:
-            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
-            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
-            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
-            # so we only have to translate them to their new destination when they get pasted
-            # the position of the pivot point is considered as the center of gravity
-            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
-            self.cutList.append(so)
-        self.resetSelection()
-    def pasteObjects(self,  ray):
-        if len(self.cutList) < 1:
-            return
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
-                i = i+1
-        else:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
-                i = i+1
-        self.cutList = []
-
-    def leftMouseUp(self):
-        if self.pivot is not None and self.pivot.isTransforming:
-            self.pivot.stopTransforming()
-
-#    def iterateEntityUnderMouse(self):
-#        self.listenerDings.iterateEntityUnderMouse()
-#
-#        pass
-
-    def resetSelection(self):
-        for so in self.userSelectionList:
-            so.setSelected(False)
-
-        self.userSelectionList = []
-
-        self.listenerDings.reset()
-        pass
-
-
-    def updatePivots(self):
-        newPivotPosition = og.Vector3(0, 0, 0)
-
-        for so in self.userSelectionList:
-            newPivotPosition += so.entity.getParentNode().getPosition()
-        if self.pivot is not None:
-            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
-
-    def unload(self,  saveOnUnload=True):
-        pass
-
-    def save(self):
-        pass
-
-    def startDropGameObjectAction(self, classid, ray):
-        go = self.gocManager.getGameObjectWithClassId(classid)
-        meshFile = go.getMeshFileName()
-
-        if go is not None:
-            dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-            dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
-            dropNode.attachObject(dropEntity)
-
-            result = og.Math.intersects(ray, self.dropCollisionPlane)
-            if result.first == True:
-                dropNode.setPosition(ray.getPoint(result.second))
-            else:
-                dropNode.setPosition(ray.getPoint(50))
-
-            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
-            dropEntity.setUserObject(self.dropGO)
-
-        self.dropCount += 1
-
-    def moveDropGameObjectAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropGO.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropGO.setPosition(ray.getPoint(50))
-
-    def stopDropGameObjectAction(self, ray):
-        print "sd"
-
-    def startDropModelAction(self, meshFile, ray):
-        self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-        self.dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
-        self.dropNode.attachObject(self.dropEntity)
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-        self.dropCount += 1
-
-    def moveDropModelAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-
-    def stopDropModelAction(self, ray):
-        pass
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+import sys
+import xml.dom.minidom as xml
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+from MovePivot import *
+from GameObjectClassManager import *
+from MyRaySceneQueryListener import *
+
+class ModuleManager(object):
+    def __init__(self,  ogreRoot,  sceneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
+
+        self.gocManager = GameObjectClassManager()
+
+        self.userSelectionList = []
+        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
+        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
+
+        # we need to hold a reference to the game object representaions ourself
+        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
+        # and deletes the object
+        self.gameObjectRepresentationDict = []
+
+        self.listenerDings = MyRaySceneQueryListener()
+
+        self.lastRay = None
+#        self.rayLine = None
+
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.dropCount = 0
+        self.dropNode = None
+        self.dropEntity = None
+        self.dropCollisionPlane = og.Plane(og.Vector3.UNIT_Y, og.Vector3.ZERO)
+
+        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
+
+    def load(self,  moduleName,  mapFiles,  gofFiles):
+        self.moduleName = moduleName
+        self.mapFiles = mapFiles
+        self.gofFiles = gofFiles
+
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
+        for a in self.mapFiles:
+            doc = xml.parse(a)
+            node = doc.getElementsByTagName("entity")
+            if node != None:
+                self.parseSceneNodes(node)
+
+        self.pivot = Pivot(self.sceneManager)
+        self.pivot.hide()
+
+    def parseSceneNodes(self,  nodeList):
+        for ent in nodeList:
+            entityName = ent.attributes["name"].nodeValue # get the name of the ent
+            meshFile = ent.attributes["meshfile"].nodeValue # meshfile
+            nodePosition = None
+            nodeRotation = None
+            nodeScale = None
+
+            for cn in ent.childNodes:
+                if cn.nodeType == cn.ELEMENT_NODE:
+                    if cn.localName == "position":
+                        px = float(cn.attributes["x"].nodeValue)
+                        py = float(cn.attributes["y"].nodeValue)
+                        pz = float(cn.attributes["z"].nodeValue)
+                        nodePosition = og.Vector3(px, py, pz)
+                        continue
+
+                    if cn.localName == "rotation":
+                        qw = float(cn.attributes["qw"].nodeValue)
+                        qx = float(cn.attributes["qx"].nodeValue)
+                        qy = float(cn.attributes["qy"].nodeValue)
+                        qz = float(cn.attributes["qz"].nodeValue)
+                        nodeRotation = og.Quaternion(qw,  qx, qy, qz)
+                        continue
+
+                    if cn.localName == "scale":
+                        px = float(cn.attributes["x"].nodeValue)
+                        py = float(cn.attributes["y"].nodeValue)
+                        pz = float(cn.attributes["z"].nodeValue)
+                        nodeScale = og.Vector3(px, py, pz)
+                        continue
+
+            try:
+                e = self.sceneManager.createEntity(entityName, meshFile)
+            except:
+                print "Warning: Meshfile " + meshFile + " could not be found."
+                return
+
+            n = self.sceneManager.getRootSceneNode().createChild(entityName + "_node")
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            #n.setOrientation(nodeRotation)
+            n.setScale(nodeScale)
+
+        pass
+
+    # called when a click into Main Ogre Window occurs
+    def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
+        self.listenerDings.reset()
+        self.lastRay = ray
+        self.listenerDings.currentRay = ray
+        self.raySceneQuery.Ray = ray
+        self.raySceneQuery.execute(self.listenerDings)
+
+        so = self.listenerDings.rayCastToPolygonLevel(ray)
+
+        if so is not None:
+            if not so.isPivot:
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+
+                    for soFromList in self.userSelectionList:
+                        if soFromList == so:
+                            return # object already selected
+
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+
+
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so == selo:
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                    self.updatePivots()
+            else:
+                #so.entity is the pivot direction that was clicked
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            self.resetSelection() # click in empty space, deselect everything
+            if self.pivot is not None:
+                self.pivot.hide()
+
+#        if self.rayLine == None:
+#            self.rayLine = self.sceneManager.createManualObject("rayLine")
+#            self.rayLine.setDynamic(True)
+#            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
+#
+#            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+#
+#        else:
+#            self.rayLine.beginUpdate(0)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+
+    def deleteObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.pivot.hide()
+
+        for so in self.userSelectionList:
+            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
+            del so
+
+        self.userSelectionList = []
+
+    def incrementNameSuffixNumber(self, name):
+        newName = ""
+        split = name.split("_")
+        lastPart = len(split)-1
+        newName = name.rstrip(split[lastPart])
+        newName = newName + str(self.numerOfCopys)
+
+#        if split[lastPart].isdigit() and not split[lastPart].startswith("0"):
+#            num = int(split[lastPart])
+#            num = num + 1
+#            newName = name.rstrip(split[lastPart])
+#            newName = newName + str(num)
+#        else:
+#            newName = name + "_1"
+
+        self.numerOfCopys = self.numerOfCopys + 1
+        return newName
+
+    def copyObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        newSelectionList = []
+
+        for so in self.userSelectionList:
+            if so.entity.getUserObject() is not None:
+                if so.entity.getUserObject().getType() == "GAME_OBJECT_REPRESENTATION":
+                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
+                    meshFile = go.getMeshFileName()
+
+                    if go is not None:
+                        newEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+                        newNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
+                        newNode.attachObject(newEntity)
+                        newNode.setPosition(so.entity.getParentNode().getPosition())
+
+                        newGO = GameObjectRepresentation(self.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
+                        self.gameObjectRepresentationDict.append(newGO)
+                        newEntity.setUserObject(newGO)
+                        newGO.setPosition(og.Vector3(0, 0, 0))
+
+                        newSO = SelectionObject(newEntity, so.distance)
+                        newSO.setSelected(True)
+                        newSelectionList.append(newSO)
+                        self.dropCount += 1
+            else:
+                nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
+                newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
+
+                entityName = self.incrementNameSuffixNumber(so.entity.getName())
+                newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+
+                newNode.attachObject(newEntity)
+                newNode.setPosition(so.entity.getParentNode().getPosition())
+                newNode.setOrientation(so.entity.getParentNode().getOrientation())
+                newNode.setScale(so.entity.getParentNode().getScale())
+
+                newSO = SelectionObject(newEntity, so.distance)
+                newSO.setSelected(True)
+                newSelectionList.append(newSO)
+
+        self.resetSelection()
+        self.userSelectionList = newSelectionList
+
+    def cutObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.cutList = []
+        for so in self.userSelectionList:
+            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
+            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
+            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
+            # so we only have to translate them to their new destination when they get pasted
+            # the position of the pivot point is considered as the center of gravity
+            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
+            self.cutList.append(so)
+        self.resetSelection()
+    def pasteObjects(self,  ray):
+        if len(self.cutList) < 1:
+            return
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
+                i = i+1
+        else:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
+                i = i+1
+        self.cutList = []
+
+    def leftMouseUp(self):
+        if self.pivot is not None and self.pivot.isTransforming:
+            self.pivot.stopTransforming()
+
+#    def iterateEntityUnderMouse(self):
+#        self.listenerDings.iterateEntityUnderMouse()
+#
+#        pass
+
+    def resetSelection(self):
+        for so in self.userSelectionList:
+            so.setSelected(False)
+
+        self.userSelectionList = []
+
+        self.listenerDings.reset()
+        pass
+
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+        if self.pivot is not None:
+            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
+    def unload(self,  saveOnUnload=True):
+        pass
+
+    def save(self):
+        pass
+
+    def startDropGameObjectAction(self, classid, ray):
+        go = self.gocManager.getGameObjectWithClassId(classid)
+        meshFile = go.getMeshFileName()
+
+        if go is not None:
+            dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+            dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
+            dropNode.attachObject(dropEntity)
+
+            result = og.Math.intersects(ray, self.dropCollisionPlane)
+            if result.first == True:
+                dropNode.setPosition(ray.getPoint(result.second))
+            else:
+                dropNode.setPosition(ray.getPoint(50))
+
+            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
+            dropEntity.setUserObject(self.dropGO)
+
+        self.dropCount += 1
+
+    def moveDropGameObjectAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropGO.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropGO.setPosition(ray.getPoint(50))
+
+    def stopDropGameObjectAction(self, ray):
+        print "sd"
+
+    def startDropModelAction(self, meshFile, ray):
+        self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+        self.dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
+        self.dropNode.attachObject(self.dropEntity)
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+        self.dropCount += 1
+
+    def moveDropModelAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+
+    def stopDropModelAction(self, ray):
+        pass
+

Modified: rl/trunk/editors/Lockenwickler/src/MyRaySceneQueryListener.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2008-11-03 15:49:51 UTC (rev 4571)
+++ rl/trunk/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2008-11-05 21:08:25 UTC (rev 4572)
@@ -26,6 +26,12 @@
         self.entity = entity #the selected entity
         self.distance = distance # the distance from camera at the time of selection
         self.isPivot = False
+
+#        if self.entity.getUserObject() is not None:
+#            self.isGameObject = True
+#        else:
+#            self.isGameObject = False
+
     #if True this instance will show its bounding box else it will hide it
     def setSelected(self,  selected):
         if selected == True:

Added: rl/trunk/editors/Lockenwickler/src/media/icons/cursor.png
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/icons/cursor.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: rl/trunk/editors/Lockenwickler/src/media/lightbulb.blend
===================================================================
(Binary files differ)


Property changes on: rl/trunk/editors/Lockenwickler/src/media/lightbulb.blend
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From blakharaz at mail.berlios.de  Fri Nov  7 17:29:09 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 7 Nov 2008 17:29:09 +0100
Subject: [Dsa-hl-svn] r4573 - modules/common/scripts/jobs
Message-ID: <200811071629.mA7GT9W9022624@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-07 17:29:08 +0100 (Fri, 07 Nov 2008)
New Revision: 4573

Added:
   modules/common/scripts/jobs/fetchitemjobs.rb
Modified:
   modules/common/scripts/jobs/gotojobs.rb
Log:
Added ruby fetch item jobs

Added: modules/common/scripts/jobs/fetchitemjobs.rb
===================================================================
--- modules/common/scripts/jobs/fetchitemjobs.rb	2008-11-05 21:08:25 UTC (rev 4572)
+++ modules/common/scripts/jobs/fetchitemjobs.rb	2008-11-07 16:29:08 UTC (rev 4573)
@@ -0,0 +1,10 @@
+require 'globals.rb'
+
+def Fetch(acting_creature, item, slot = "Right Hand")
+    job = FetchItemJob.new(acting_creature, targetpos, slot, 1000000)
+    $JS.addJob(job)
+end
+
+def _Fetch(acting_creature, item, slot = "Right Hand")
+    return FetchItemJob.new(acting_creature, targetpos, slot, 1000000)
+end

Modified: modules/common/scripts/jobs/gotojobs.rb
===================================================================
--- modules/common/scripts/jobs/gotojobs.rb	2008-11-05 21:08:25 UTC (rev 4572)
+++ modules/common/scripts/jobs/gotojobs.rb	2008-11-07 16:29:08 UTC (rev 4573)
@@ -6,5 +6,5 @@
 end
 
 def _GoTo(acting_creature, targetpos)
-    GoToJob.new(acting_creature, targetpos, 0.5, 1000000)
+    return GoToJob.new(acting_creature, targetpos, 0.5, 1000000)
 end



From blakharaz at mail.berlios.de  Fri Nov  7 17:30:29 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 7 Nov 2008 17:30:29 +0100
Subject: [Dsa-hl-svn] r4574 - rl/trunk/engine/core/src
Message-ID: <200811071630.mA7GUTB9022804@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-07 17:30:28 +0100 (Fri, 07 Nov 2008)
New Revision: 4574

Modified:
   rl/trunk/engine/core/src/ConfigurationManager.cpp
Log:
Fix for boost 1.34

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-11-07 16:29:08 UTC (rev 4573)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-11-07 16:30:28 UTC (rev 4574)
@@ -388,9 +388,14 @@
 	
 	void ConfigurationManager::setExecutable(const Ogre::String& path)
 	{
+#       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+		return;
+		fs::path exeAbsolute(path);
+#       else
 		fs::path exeAbsolute(path, fs::portable_posix_name);
-		mExecutablePath = exeAbsolute.remove_leaf().string();
-        std::cout << "ConfigurationManager" << "Executable is " << path << " " << mExecutablePath;
+#		endif
+		mExecutablePath = exeAbsolute.branch_path().string();
+        std::cout << "ConfigurationManager " << "Executable is " << path << " " << mExecutablePath;
 	}
 
 	const Ogre::String& ConfigurationManager::getExecutablePath() const
@@ -440,17 +445,14 @@
         try 
         {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-			std::cout << "Checking for " << fs::complete(filename) << std::endl;
-            if (fs::exists(filename))
+			std::cout << "Checking for " << fs::complete(filename).string() << std::endl;
+            return fs::exists(filename);
 #           else
 			std::cout << "Checking for " << 
 				fs::complete(fs::path(filename, fs::portable_posix_name)).string()
                  << std::endl;
-			if (fs::exists(fs::path(filename, fs::portable_posix_name)))
+			return fs::exists(fs::path(filename, fs::portable_posix_name));
 #           endif
-            {
-                return true;
-            }
         }
         catch (fs::filesystem_error&) 
         {



From blakharaz at mail.berlios.de  Fri Nov  7 17:32:15 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 7 Nov 2008 17:32:15 +0100
Subject: [Dsa-hl-svn] r4575 - in rl/trunk/engine/rules: include src
Message-ID: <200811071632.mA7GWFQP022935@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-07 17:32:14 +0100 (Fri, 07 Nov 2008)
New Revision: 4575

Modified:
   rl/trunk/engine/rules/include/Container.h
   rl/trunk/engine/rules/src/Container.cpp
   rl/trunk/engine/rules/src/Item.cpp
Log:
Fix for infinite recursion between Item and Container

Modified: rl/trunk/engine/rules/include/Container.h
===================================================================
--- rl/trunk/engine/rules/include/Container.h	2008-11-07 16:30:28 UTC (rev 4574)
+++ rl/trunk/engine/rules/include/Container.h	2008-11-07 16:32:14 UTC (rev 4575)
@@ -71,8 +71,22 @@
 		 * @return <code>true</code> if adding was successful, <code>false</code> otherwise (e.g. not enough space)
 		 */
         bool addItem(Item* item, IntPair position = IntPair(0,0));
+
+        /**
+         * Remove an item from the container
+         *
+		 * @param item the item
+         */
         void removeItem(Item* item);
 
+        /**
+         * Remove an item from the container
+         * Note: This method must only be called by Item, use removeItem in all other cases
+         *
+		 * @param item the item
+         */
+        void _doRemoveItem(Item* item);
+
         ItemSet getItems() const;
 
 		int getItemCount() const;

Modified: rl/trunk/engine/rules/src/Container.cpp
===================================================================
--- rl/trunk/engine/rules/src/Container.cpp	2008-11-07 16:30:28 UTC (rev 4574)
+++ rl/trunk/engine/rules/src/Container.cpp	2008-11-07 16:32:14 UTC (rev 4575)
@@ -168,16 +168,25 @@
 		}
     }
 
-    void Container::removeItem(Item* item)
+    void Container::_doRemoveItem(Item* item)
     {
         ItemSet::iterator it = mItems.find(item);
         if (it != mItems.end())
         {
             mItems.erase(it);
             mItemPositions.erase(mItemPositions.find(item));
-            
-            // this is the case, if the item is removed automatically
-            // don't change this without looking at Item::setState
+        }
+        else
+        {
+            Throw(IllegalArgumentException, "Item not in Container.");
+        }
+    }
+
+    void Container::removeItem(Item* item)
+    {
+        ItemSet::iterator it = mItems.find(item);
+        if (it != mItems.end())
+        {
             item->removeOldState();
             item->setScene("");
         }

Modified: rl/trunk/engine/rules/src/Item.cpp
===================================================================
--- rl/trunk/engine/rules/src/Item.cpp	2008-11-07 16:30:28 UTC (rev 4574)
+++ rl/trunk/engine/rules/src/Item.cpp	2008-11-07 16:32:14 UTC (rev 4575)
@@ -95,7 +95,7 @@
         }
         if (mParentContainer != NULL)
         {
-            mParentContainer->removeItem(this);
+            mParentContainer->_doRemoveItem(this);
             mParentContainer = NULL;
         }
         if (mParentSlot != NULL)



From blakharaz at mail.berlios.de  Fri Nov  7 17:33:38 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 7 Nov 2008 17:33:38 +0100
Subject: [Dsa-hl-svn] r4576 - rl/trunk/engine/ui/src
Message-ID: <200811071633.mA7GXcDP023047@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-07 17:33:37 +0100 (Fri, 07 Nov 2008)
New Revision: 4576

Modified:
   rl/trunk/engine/ui/src/InputManager.cpp
Log:


Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2008-11-07 16:32:14 UTC (rev 4575)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2008-11-07 16:33:37 UTC (rev 4576)
@@ -446,7 +446,10 @@
     {
         while (!mControlStates.empty())
         {
-            popControlState();
+            ControlState* controller = mControlStates.top();
+            mControlStates.pop();
+            controller->pause();
+            mFinishedControlStates.push_back(controller);
         }
     }
 



From blakharaz at mail.berlios.de  Fri Nov  7 17:34:31 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 7 Nov 2008 17:34:31 +0100
Subject: [Dsa-hl-svn] r4577 - in rl/trunk/engine/ui: include src
Message-ID: <200811071634.mA7GYVWe023127@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-07 17:34:30 +0100 (Fri, 07 Nov 2008)
New Revision: 4577

Modified:
   rl/trunk/engine/ui/include/CombatGui.h
   rl/trunk/engine/ui/src/CombatGui.cpp
Log:
Only hide/show when visible/not visible

Modified: rl/trunk/engine/ui/include/CombatGui.h
===================================================================
--- rl/trunk/engine/ui/include/CombatGui.h	2008-11-07 16:33:37 UTC (rev 4576)
+++ rl/trunk/engine/ui/include/CombatGui.h	2008-11-07 16:34:30 UTC (rev 4577)
@@ -73,6 +73,8 @@
 		/// Needed to only close it after combat if it was not shown before.
 		bool mGameLoggerWindowOpened;
 
+        bool mVisible;
+
         Ogre::FloatRect getScreenRectFromWorldAabb(const Ogre::AxisAlignedBox& aabb) const;
 	};
 }

Modified: rl/trunk/engine/ui/src/CombatGui.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatGui.cpp	2008-11-07 16:33:37 UTC (rev 4576)
+++ rl/trunk/engine/ui/src/CombatGui.cpp	2008-11-07 16:34:30 UTC (rev 4577)
@@ -37,7 +37,8 @@
 		  mCombat(combat),
 		  mCamera(camera),
 		  mUserInputEnabled(false),
-		  mGameLoggerWindowOpened(false)
+		  mGameLoggerWindowOpened(false),
+          mVisible(false)
     {
         mCombatWindow = WindowFactory::getSingleton().getCombatWindow();
 		mGameLoggerWindow = WindowFactory::getSingleton().getGameLogger();
@@ -68,7 +69,7 @@
         sceneMgr->getRootSceneNode()->createChildSceneNode()->attachObject(mHud);
 
 		// Create an attack/parry/(goto) button set for all opponents present at the beginning.
-        const Combat::CombatantSet& opponents = mCombat->getAllOpponents();
+        const Combat::CombatantSet& opponents = mCombat->getAllPlayerOpponents();
         for (Combat::CombatantSet::const_iterator it = opponents.begin(), end = opponents.end();
             it != end; ++it)
         {
@@ -82,6 +83,7 @@
 	CombatGui::~CombatGui()
 	{
 		hide();
+        mHud->getParentSceneNode()->detachObject(mHud);
         SceneManager* sceneMgr = CoreSubsystem::getSingleton().getWorld()->getSceneManager();
 		sceneMgr->destroyManualObject(mHud);
 	}
@@ -96,7 +98,7 @@
         mHud->clear();
 
         mHud->begin("alpha_red", RenderOperation::OT_LINE_LIST);
-        const Combat::CombatantSet& opponents = mCombat->getAllOpponents();
+        const Combat::CombatantSet& opponents = mCombat->getAllPlayerOpponents();
         for (Combat::CombatantSet::const_iterator it = opponents.begin(), end = opponents.end();
             it != end; ++it)
         {
@@ -160,16 +162,25 @@
 
 	void CombatGui::show()
 	{
-		mGameLoggerWindowOpened = !mGameLoggerWindow->isVisible();
-        mCombatWindow->setVisible(true);
-		mGameLoggerWindow->setVisible(true);
+        if (!mVisible)
+        {
+		    mGameLoggerWindowOpened = !mGameLoggerWindow->isVisible();
+            mCombatWindow->setVisible(true);
+		    mGameLoggerWindow->setVisible(true);
+            mHud->setVisible(true);
+            mVisible = true;
+        }
 	}
 
 	void CombatGui::hide()
 	{
-        mCombatWindow->setVisible(false);
-		mGameLoggerWindow->setVisible(!mGameLoggerWindowOpened);
-		mHud->clear();
+        if (mVisible)
+        {
+            mCombatWindow->setVisible(false);
+		    mGameLoggerWindow->setVisible(!mGameLoggerWindowOpened);
+            mHud->setVisible(false);
+            mVisible = false;
+        }
 	}
 
 	bool CombatGui::enemyButtonClicked(int handle, int buttonIndex)



From blakharaz at mail.berlios.de  Fri Nov  7 17:36:20 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Fri, 7 Nov 2008 17:36:20 +0100
Subject: [Dsa-hl-svn] r4578 - in rl/trunk/engine: ai/include ai/src
	rules/include rules/src
Message-ID: <200811071636.mA7GaKWj023199@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-07 17:36:19 +0100 (Fri, 07 Nov 2008)
New Revision: 4578

Modified:
   rl/trunk/engine/ai/include/AgentCombatState.h
   rl/trunk/engine/ai/src/AgentCombatState.cpp
   rl/trunk/engine/rules/include/Combat.h
   rl/trunk/engine/rules/src/Combat.cpp
Log:
A bit more "intelligence" in combat (try to flee if badly hurt, remove combatants if distance to enemy is too large)

Modified: rl/trunk/engine/ai/include/AgentCombatState.h
===================================================================
--- rl/trunk/engine/ai/include/AgentCombatState.h	2008-11-07 16:34:30 UTC (rev 4577)
+++ rl/trunk/engine/ai/include/AgentCombatState.h	2008-11-07 16:36:19 UTC (rev 4578)
@@ -18,6 +18,7 @@
 
 #include "AiPrerequisites.h"
 #include "AgentState.h"
+#include "Combat.h"
 #include "Combatant.h"
 
 namespace rl
@@ -46,6 +47,10 @@
     protected:
         typedef enum {} CombatState;
         CombatState mState;
+
+    private:
+        Combatant* findOpponent(const Combat::CombatantSet& opponents) const;
+        Ogre::Vector3 getFleeTarget(const Combat::CombatantSet& opponents) const;
 	};
 }
 #endif

Modified: rl/trunk/engine/ai/src/AgentCombatState.cpp
===================================================================
--- rl/trunk/engine/ai/src/AgentCombatState.cpp	2008-11-07 16:34:30 UTC (rev 4577)
+++ rl/trunk/engine/ai/src/AgentCombatState.cpp	2008-11-07 16:36:19 UTC (rev 4578)
@@ -19,6 +19,7 @@
 #include "AgentCombatState.h"
 #include "Combat.h"
 #include "CombatManager.h"
+#include "Creature.h"
 #include "CreatureControllerManager.h"
 
 namespace rl
@@ -45,13 +46,19 @@
     void AgentCombatState::requestCombatantAction()
     {
         // Think!
-		const Combat::CombatantSet& allies = mCombat->getAllAllies();
-		if (!allies.empty())
+        Combat::CombatantSet opponents = mCombat->getAllOpponents(this);
+		if (!opponents.empty())
 		{
-			Combatant* target = *allies.begin();
-			// Are we in weapon range to opponent
-			if (target)
-			{
+			Combatant* target = findOpponent(opponents);
+            
+            mCombat->registerParade(target);
+
+            if (getCreature()->getLe() <= 5)
+            {
+                mCombat->registerBewegen(this, getFleeTarget(opponents));
+            }
+            else if (target)
+            {
 				// Are we in weapon range to opponent
 				if (mCombat->canAttack(this, target))
 				{
@@ -72,4 +79,47 @@
     {
         mAgent->updateVehicle(0, elapsedTime);
     }
+
+    class DistanceComparator
+		: std::binary_function<Combatant*, Combatant*, bool>
+    {
+    private:
+        const Combatant* mActingCombatant;
+
+    public:
+        DistanceComparator(const Combatant* actingCombatant)
+            : mActingCombatant(actingCombatant)
+        {
+        }
+
+        bool operator()(const Combatant* c1, const Combatant* c2) const
+        {
+            Vector3 pos = mActingCombatant->getPosition();
+            return pos.squaredDistance(c1->getPosition())
+                < pos.squaredDistance(c2->getPosition());
+        }
+    };
+
+
+    Combatant* AgentCombatState::findOpponent(const Combat::CombatantSet& opponents) const
+    {
+        ///@todo support different search patterns (search for most dangerous, weakest, ... opponent)
+        Combat::CombatantSet::const_iterator minIt = 
+            std::min_element(opponents.begin(), opponents.end(), DistanceComparator(this));
+        return *minIt;
+    }
+
+    Vector3 AgentCombatState::getFleeTarget(const Combat::CombatantSet& opponents) const
+    {
+        Vector3 oppPosition;
+        for (Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); ++it)
+        {
+            oppPosition += (*it)->getPosition();
+        }
+        oppPosition /= opponents.size();
+
+        Vector3 pos = getPosition();
+        Vector3 oppositeDirection = (pos - oppPosition).normalisedCopy();
+        return pos + 10 * oppositeDirection;
+    }
 }

Modified: rl/trunk/engine/rules/include/Combat.h
===================================================================
--- rl/trunk/engine/rules/include/Combat.h	2008-11-07 16:34:30 UTC (rev 4577)
+++ rl/trunk/engine/rules/include/Combat.h	2008-11-07 16:36:19 UTC (rev 4578)
@@ -41,7 +41,7 @@
     public:
         typedef std::set<Combatant*> CombatantSet;
 
-        Combat();
+        Combat(Ogre::Real maxDistance = 10.0f);
         ~Combat();
 
         void addOpponent(Combatant*);
@@ -54,8 +54,9 @@
 
         void removeAlly(Combatant*);
 
-        const CombatantSet& getAllOpponents() const;
-        const CombatantSet& getAllAllies() const;
+        const CombatantSet getAllOpponents(Combatant* combatant) const;
+        const CombatantSet& getAllPlayerOpponents() const;
+        const CombatantSet& getAllPlayerAllies() const;
 
         void start();
         void pause();

Modified: rl/trunk/engine/rules/src/Combat.cpp
===================================================================
--- rl/trunk/engine/rules/src/Combat.cpp	2008-11-07 16:34:30 UTC (rev 4577)
+++ rl/trunk/engine/rules/src/Combat.cpp	2008-11-07 16:36:19 UTC (rev 4578)
@@ -59,7 +59,7 @@
         }
     };
 
-    Combat::Combat()
+    Combat::Combat(Ogre::Real maxDistance)
         : mOwnedCombatants(),
 		  mOpponents(),
           mAllies(),
@@ -165,16 +165,31 @@
 		mRemovedCombatants.clear();
 	}
 
-    const Combat::CombatantSet& Combat::getAllOpponents() const
+    const Combat::CombatantSet& Combat::getAllPlayerOpponents() const
     {
         return mOpponents;
     }
 
-    const Combat::CombatantSet& Combat::getAllAllies() const
+    const Combat::CombatantSet& Combat::getAllPlayerAllies() const
     {
         return mAllies;
     }
 
+    const Combat::CombatantSet Combat::getAllOpponents(Combatant* combatant) const
+    {
+        if (mOpponents.find(combatant) != mOpponents.end())
+        {
+            return mAllies;
+        }
+        
+        if (mAllies.find(combatant) != mAllies.end())
+        {
+            return mOpponents;
+        }
+        
+        return Combat::CombatantSet(); // not in combat -> no opponents
+    }
+
     void Combat::start()
     {
 		GameEventLog::getSingleton().logEvent("Kampf beginnt.", GET_COMBAT);
@@ -384,6 +399,25 @@
     void Combat::endRound()
     {
 		clearRemovedCombatantSet();
+
+        // check for fleeing from combat
+        for (CombatantSet::iterator it = mAllies.begin(); it != mAllies.end(); ++it)
+        {
+            if (outOfCombatRange(*it, mOpponents))
+            {
+                removeAlly(*it);
+            }
+        }
+        for (CombatantSet::iterator it = mOpponents.begin(); it != mOpponents.end(); ++it)
+        {
+            if (outOfCombatRange(*it, mAllies))
+            {
+                removeOpponent(*it);
+            }
+        }
+
+		clearRemovedCombatantSet();
+
         // All actions executed. Analyze outcome of this round.
         if (mAllies.empty())
         {



From timm at mail.berlios.de  Fri Nov  7 18:46:37 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Fri, 7 Nov 2008 18:46:37 +0100
Subject: [Dsa-hl-svn] r4579 - in modules/kanalisation: maps materials
	materials/textures scripts scripts/maps
Message-ID: <200811071746.mA7HkbhL015363@sheep.berlios.de>

Author: timm
Date: 2008-11-07 18:46:18 +0100 (Fri, 07 Nov 2008)
New Revision: 4579

Added:
   modules/kanalisation/maps/kanalisation.rlmap.xml
   modules/kanalisation/materials/DirtyWater.material
   modules/kanalisation/materials/TotalReflectDirtWater.source
   modules/kanalisation/materials/textures/nx.zone.orange.png
   modules/kanalisation/materials/textures/perlinvolume.dds
   modules/kanalisation/materials/textures/waves2.dds
Removed:
   modules/kanalisation/maps/kanalisation_scene.xml
Modified:
   modules/kanalisation/scripts/maps/kanalisation.rb
   modules/kanalisation/scripts/moduleconfig.rb
Log:
- added dirty water to kanalisation
- renamed root node of xml mapfile to rlmap

Copied: modules/kanalisation/maps/kanalisation.rlmap.xml (from rev 4561, modules/kanalisation/maps/kanalisation_scene.xml)
===================================================================
--- modules/kanalisation/maps/kanalisation_scene.xml	2008-10-19 13:02:32 UTC (rev 4561)
+++ modules/kanalisation/maps/kanalisation.rlmap.xml	2008-11-07 17:46:18 UTC (rev 4579)
@@ -0,0 +1,269 @@
+<rlmap formatVersion="0.4.0">
+    <nodes>
+<entity name="Spinne" meshfile="tie_waldspinne.mesh">
+<position x="83.61" y="-1.05" z="28.88"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="8.0" y="8.0" z="8.0"/>
+</entity>
+<entity name="bruecke" meshfile="bruecke.mesh">
+<position x="2.892947" y="3.346505" z="7.881136"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="boden_komplett_oben" meshfile="Plane.001.mesh">
+<position x="4.907471" y="-33.65706" z="9.325613"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="wurzeln_03" meshfile="wurzeln_klein.mesh">
+<position x="3.815631" y="3.215424" z="3.961683"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="felsen_hoehle" meshfile="felswaende.mesh">
+<position x="30.294416" y="7.783535" z="26.360363"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="saeule_08.001" meshfile="saeule_08.001.mesh">
+<position x="56.201435" y="9.379703" z="41.7188"/><rotation qw="0.706179" qx="-2.81E-4" qy="-0.708033" qz="-2.82E-4"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="pilze" meshfile="pilze.001.mesh">
+<position x="6.899021" y="-0.0085" z="13.837756"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="matschboden" meshfile="matschboden.mesh">
+<position x="4.907471" y="-33.65706" z="9.325613"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="tuern.001" meshfile="tuern.001.mesh">
+<position x="51.963837" y="4.32096" z="56.169384"/><rotation qw="0.706179" qx="-2.81E-4" qy="-0.708033" qz="-2.82E-4"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="boden_komplett_ob" meshfile="Plane.007.mesh">
+<position x="59.330944" y="-33.159164" z="48.06011"/><rotation qw="0.706179" qx="-2.81E-4" qy="-0.708033" qz="-2.82E-4"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="gaenge_01" meshfile="gaenge_komplett.003.mesh">
+<position x="-14.217243" y="3.248992" z="38.87323"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="saeulen.002" meshfile="saeulen.004.mesh">
+<position x="0.813724" y="3.700742" z="8.508488"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="brunnen" meshfile="brunnen.mesh">
+<position x="140.5463" y="74.190155" z="378.74002"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="boden_felswand.002" meshfile="boden_fels.002.mesh">
+<position x="37.711838" y="5.930392" z="27.968113"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="gitter_zu.001" meshfile="Cube.025.mesh">
+<position x="-12.877804" y="2.514648" z="61.443035"/><rotation qw="0.578332" qx="-2.3E-4" qy="-0.815801" qz="-3.25E-4"/><scale x="0.192361" y="0.192361" z="0.192361"/>
+</entity>
+<entity name="tempelgang_decke.002" meshfile="Cube.002.mesh">
+<position x="16.682463" y="4.846837" z="56.49011"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="0.569132" y="0.569132" z="0.569132"/>
+</entity>
+<entity name="tempelgang_decke.001" meshfile="Cube.012.mesh">
+<position x="-15.229253" y="5.874734" z="24.490736"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="0.569132" y="0.569132" z="0.569132"/>
+</entity>
+<entity name="tempelgang_treppe.001" meshfile="treppe_gemauert.001.mesh">
+<position x="-23.316332" y="7.303283" z="16.492294"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="tempelgang_treppe.002" meshfile="treppe_gemauert.003.mesh">
+<position x="-36.38294" y="7.10427" z="27.145168"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="0.556166" y="0.556166" z="0.556166"/>
+</entity>
+<entity name="saeule_07" meshfile="saeule_07.mesh">
+<position x="1.244043" y="10.20761" z="6.341633"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="zugemauert" meshfile="Cube.001.mesh">
+<position x="82.31271" y="0.0" z="26.776424"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="tempelgang_waende.001" meshfile="Cube.011.mesh">
+<position x="-20.391804" y="3.431791" z="29.280613"/><rotation qw="0.708878" qx="-2.82E-4" qy="0.705331" qz="2.81E-4"/><scale x="0.569131" y="0.569132" z="0.569132"/>
+</entity>
+<entity name="randsteine_04.001" meshfile="randsteine_04.001.mesh">
+<position x="-2.300682" y="0.0" z="0.0"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="stuetzbalken" meshfile="stuetzbalken.mesh">
+<position x="38.6939" y="9.522685" z="30.678297"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="Plane.001" meshfile="Plane.003.mesh">
+<position x="-18.778461" y="3.790074" z="24.69996"/><rotation qw="0.503159" qx="0.502758" qy="-0.497222" qz="0.496826"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="gaenge_01.019" meshfile="gaenge_komplett.mesh">
+<position x="-11.712984" y="2.751104" z="38.87323"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="gaenge_01.018" meshfile="gaenge_komplett.017.mesh">
+<position x="-11.712984" y="2.751104" z="38.87323"/><rotation qw="0.977955" qx="-3.89E-4" qy="-0.208817" qz="-8.3E-5"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="Cube" meshfile="Cube.006.mesh">
+<position x="-19.678776" y="3.064484" z="25.362461"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="torboegen.002" meshfile="torboegen.002.mesh">
+<position x="-2.584131" y="2.751112" z="27.977468"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="tempelgang_decke" meshfile="Cube.mesh">
+<position x="94.64457" y="4.292408" z="25.715137"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="brocken" meshfile="brocken.mesh">
+<position x="45.444912" y="3.694921" z="29.209862"/><rotation qw="0.994933" qx="-3.96E-4" qy="-0.100537" qz="-4.0E-5"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="tempelgang_saeule" meshfile="saeule_01.001.mesh">
+<position x="-19.892523" y="5.950263" z="24.17252"/><rotation qw="0.013436" qx="0.0" qy="0.99991" qz="3.98E-4"/><scale x="0.569132" y="0.569132" z="0.569132"/>
+</entity>
+<entity name="fackeln_g2.003" meshfile="fackeln.004.mesh">
+<position x="39.97495" y="5.598745" z="29.590656"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="fackeln_eingangshalle" meshfile="fackeln.001.mesh">
+<position x="17.838156" y="1.844218" z="15.676789"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<plane name="schmutzwasser">
+<position x="-17.99887" y="2.354909" z="26.217978"/><rotation qw="1.0" qx="0.0" qy="0.0" qz="0.0"/><scale x="48" y="48"/>
+<physicsproxy collision="false" />
+<renderToTexture reflection="true" refraction="false"/>
+<material name="DirtyWater"/>
+</plane>
+<entity name="raum_01.007" meshfile="raum_01.005.mesh">
+<position x="-40.115147" y="5.383284" z="26.274029"/><rotation qw="0.840188" qx="-3.35E-4" qy="0.542295" qz="2.16E-4"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="raum_01.004" meshfile="raum_01.004.mesh">
+<position x="29.826838" y="2.72995" z="31.43219"/><rotation qw="0.542761" qx="-2.16E-4" qy="-0.839887" qz="-3.34E-4"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="raum_01.005" meshfile="raum_01.007.mesh">
+<position x="-11.642996" y="2.232062" z="38.87323"/><rotation qw="0.977955" qx="-3.89E-4" qy="-0.208817" qz="-8.3E-5"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="raum_01.006" meshfile="raum_01.006.mesh">
+<position x="29.826838" y="2.72995" z="31.43219"/><rotation qw="0.542761" qx="-2.16E-4" qy="-0.839887" qz="-3.34E-4"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="saeule_07.001" meshfile="saeule_07.001.mesh">
+<position x="62.32452" y="10.705501" z="44.40452"/><rotation qw="0.706179" qx="-2.81E-4" qy="-0.708033" qz="-2.82E-4"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="raum_01.001" meshfile="raum_01.001.mesh">
+<position x="-11.642996" y="2.232062" z="38.87323"/><rotation qw="0.977955" qx="-3.89E-4" qy="-0.208817" qz="-8.3E-5"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="gitter_zu" meshfile="Cube.023.mesh">
+<position x="6.479543" y="2.514645" z="1.955386"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="0.208358" y="0.208358" z="0.208358"/>
+</entity>
+<entity name="raum_01.003" meshfile="raum_01.003.mesh">
+<position x="29.826838" y="2.72995" z="31.43219"/><rotation qw="0.542761" qx="-2.16E-4" qy="-0.839887" qz="-3.34E-4"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="raum_01.002" meshfile="raum_01.002.mesh">
+<position x="-11.642996" y="2.232062" z="38.87323"/><rotation qw="0.977955" qx="-3.89E-4" qy="-0.208817" qz="-8.3E-5"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="wurzeln_02.002" meshfile="wurzeln_02.mesh">
+<position x="2.693319" y="4.398726" z="13.058824"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="faesser_tunnel_02" meshfile="Circle.011.mesh">
+<position x="57.166122" y="-0.837035" z="26.112844"/><rotation qw="0.694621" qx="0.694067" qy="0.133793" qz="-0.133686"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="gaenge_01.002" meshfile="gaenge_komplett.004.mesh">
+<position x="-14.217243" y="3.248992" z="38.87323"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="gaenge_01.001" meshfile="gaenge_komplett.002.mesh">
+<position x="-14.217243" y="3.248992" z="38.87323"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="eingangstuer" meshfile="Cube.005.mesh">
+<position x="-40.139088" y="6.390891" z="25.772146"/><rotation qw="1.0" qx="-7.96E-4" qy="0.0" qz="0.0"/><scale x="-0.097711" y="1.0" z="1.0"/>
+</entity>
+<entity name="tempelgang_waende" meshfile="Cube.003.mesh">
+<position x="85.57365" y="0.0" z="34.131252"/><rotation qw="0.708878" qx="-2.82E-4" qy="0.705331" qz="2.81E-4"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="saeule_01.001" meshfile="saeule_01.004.mesh">
+<position x="52.24556" y="9.379703" z="51.07818"/><rotation qw="0.706179" qx="-2.81E-4" qy="-0.708033" qz="-2.82E-4"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="tuern" meshfile="tuern.mesh">
+<position x="13.036044" y="3.823069" z="16.671421"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="wurzeln.001" meshfile="wurzeln_alle.001.mesh">
+<position x="64.69753" y="3.194272" z="47.05233"/><rotation qw="0.706179" qx="-2.81E-4" qy="-0.708033" qz="-2.82E-4"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="randsteine_01" meshfile="randsteine_01.mesh">
+<position x="-2.300682" y="0.0" z="0.0"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="randsteine_03" meshfile="randsteine_03.mesh">
+<position x="-2.300682" y="0.0" z="0.0"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="randsteine_02" meshfile="randsteine_02.mesh">
+<position x="-2.300682" y="0.0" z="0.0"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="randsteine_04" meshfile="randsteine_04.mesh">
+<position x="-2.300682" y="0.0" z="0.0"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="tempelgang_treppe" meshfile="treppe_gemauert.mesh">
+<position x="53.427147" y="7.565333" z="30.14977"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="gitter_zu.003" meshfile="Cube.027.mesh">
+<position x="66.71472" y="2.933403" z="49.673588"/><rotation qw="0.709539" qx="-2.83E-4" qy="-0.704666" qz="-2.81E-4"/><scale x="0.208358" y="0.208358" z="0.208358"/>
+</entity>
+<entity name="treppe" meshfile="treppe_02.mesh">
+<position x="3.132164" y="2.587981" z="6.686421"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="tempelgang_boden" meshfile="boden_fels.001.mesh">
+<position x="37.711838" y="5.930392" z="27.968113"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="tempelgang_saeulen" meshfile="saeule_01.011.mesh">
+<position x="86.45091" y="4.425117" z="25.15601"/><rotation qw="0.013434" qx="0.0" qy="0.99991" qz="3.98E-4"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="gitter_zu.002" meshfile="Cube.026.mesh">
+<position x="-5.445406" y="2.514649" z="67.09695"/><rotation qw="0.96454" qx="-3.84E-4" qy="-0.263938" qz="-1.05E-4"/><scale x="0.178084" y="0.178084" z="0.178084"/>
+</entity>
+<entity name="tempelgang_randst" meshfile="Cube.007.mesh">
+<position x="-15.235514" y="5.567721" z="28.191092"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="0.569132" y="0.569132" z="0.569132"/>
+</entity>
+<entity name="moderholz" meshfile="moderbalken_01.mesh">
+<position x="37.592186" y="6.02605" z="32.072422"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="tempelgang_randsteine" meshfile="Cube.009.mesh">
+<position x="94.63357" y="3.752965" z="32.216892"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="brocken.001" meshfile="brocken.001.mesh">
+<position x="83.84499" y="3.694921" z="29.906654"/><rotation qw="0.994933" qx="-3.96E-4" qy="-0.100537" qz="-4.0E-5"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="durchbruch_02" meshfile="durchbruch_02.mesh">
+<position x="43.158157" y="6.466876" z="27.790565"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="fackeln" meshfile="fackeln.mesh">
+<position x="15.30493" y="2.587982" z="15.800744"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="Cube.001" meshfile="Cube.014.mesh">
+<position x="-19.678776" y="3.064484" z="25.362461"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="saeule_06" meshfile="saeule_06.mesh">
+<position x="4.451921" y="3.546391" z="14.409163"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="saeule_05" meshfile="saeule_05.mesh">
+<position x="7.967321" y="8.881814" z="3.944559"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="Cube.002" meshfile="Cube.015.mesh">
+<position x="-40.626343" y="0.0" z="26.123762"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="Cube.005" meshfile="Cube.019.mesh">
+<position x="11.334853" y="2.948639" z="60.276592"/><rotation qw="0.0" qx="0.0" qy="1.0" qz="3.98E-4"/><scale x="1.0" y="0.500934" z="1.0"/>
+</entity>
+<entity name="Cube.004" meshfile="durchgang.mesh">
+<position x="42.81224" y="7.032636" z="33.16056"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="saeule_01" meshfile="saeule_01.mesh">
+<position x="7.944117" y="8.881815" z="16.403053"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="Cube.006" meshfile="Cube.004.mesh">
+<position x="-0.04573" y="3.819188" z="61.17655"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="Cube.008" meshfile="Cube.016.mesh">
+<position x="0.144417" y="0.0" z="55.632095"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="farn" meshfile="farn.mesh">
+<physicsproxy type="none" />
+<position x="-2.364898" y="-1.932347" z="2.648438"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="raum_01" meshfile="raum_01.mesh">
+<position x="-11.642996" y="2.232062" z="38.87323"/><rotation qw="0.977955" qx="-3.89E-4" qy="-0.208817" qz="-8.3E-5"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="saeule_08" meshfile="saeule_08.mesh">
+<position x="-1.425607" y="8.881815" z="12.471745"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="randsteine_03.001" meshfile="Cube.008.mesh">
+<position x="0.349848" y="1.044165" z="7.637593"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="randsteine_03.002" meshfile="randsteine_03.001.mesh">
+<position x="-2.300682" y="0.0" z="0.0"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="randsteine_03.003" meshfile="randsteine_03.002.mesh">
+<position x="-2.300682" y="0.0" z="0.0"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="randsteine_03.005" meshfile="randsteine_03.004.mesh">
+<position x="14.49704" y="0.0" z="19.140228"/><rotation qw="0.999974" qx="-3.98E-4" qy="-0.007229" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="saeulen" meshfile="saeulen.mesh">
+<position x="60.158802" y="4.198632" z="43.96852"/><rotation qw="0.706179" qx="-2.81E-4" qy="-0.708033" qz="-2.82E-4"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+<entity name="wurzeln" meshfile="wurzeln_alle.mesh">
+<position x="3.885619" y="2.696382" z="3.961683"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
+</entity>
+    </nodes>
+</rlmap>
\ No newline at end of file


Property changes on: modules/kanalisation/maps/kanalisation.rlmap.xml
___________________________________________________________________
Name: svn:mergeinfo
   + 

Deleted: modules/kanalisation/maps/kanalisation_scene.xml
===================================================================
--- modules/kanalisation/maps/kanalisation_scene.xml	2008-11-07 16:36:19 UTC (rev 4578)
+++ modules/kanalisation/maps/kanalisation_scene.xml	2008-11-07 17:46:18 UTC (rev 4579)
@@ -1,267 +0,0 @@
-<scene formatVersion="0.4.0">
-    <nodes>
-<entity name="Spinne" meshfile="tie_waldspinne.mesh">
-<position x="83.61" y="-1.05" z="28.88"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="8.0" y="8.0" z="8.0"/>
-</entity>
-<entity name="bruecke" meshfile="bruecke.mesh">
-<position x="2.892947" y="3.346505" z="7.881136"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="boden_komplett_oben" meshfile="Plane.001.mesh">
-<position x="4.907471" y="-33.65706" z="9.325613"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="wurzeln_03" meshfile="wurzeln_klein.mesh">
-<position x="3.815631" y="3.215424" z="3.961683"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="felsen_hoehle" meshfile="felswaende.mesh">
-<position x="30.294416" y="7.783535" z="26.360363"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="saeule_08.001" meshfile="saeule_08.001.mesh">
-<position x="56.201435" y="9.379703" z="41.7188"/><rotation qw="0.706179" qx="-2.81E-4" qy="-0.708033" qz="-2.82E-4"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="pilze" meshfile="pilze.001.mesh">
-<position x="6.899021" y="-0.0085" z="13.837756"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="matschboden" meshfile="matschboden.mesh">
-<position x="4.907471" y="-33.65706" z="9.325613"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="tuern.001" meshfile="tuern.001.mesh">
-<position x="51.963837" y="4.32096" z="56.169384"/><rotation qw="0.706179" qx="-2.81E-4" qy="-0.708033" qz="-2.82E-4"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="boden_komplett_ob" meshfile="Plane.007.mesh">
-<position x="59.330944" y="-33.159164" z="48.06011"/><rotation qw="0.706179" qx="-2.81E-4" qy="-0.708033" qz="-2.82E-4"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="gaenge_01" meshfile="gaenge_komplett.003.mesh">
-<position x="-14.217243" y="3.248992" z="38.87323"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="saeulen.002" meshfile="saeulen.004.mesh">
-<position x="0.813724" y="3.700742" z="8.508488"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="brunnen" meshfile="brunnen.mesh">
-<position x="140.5463" y="74.190155" z="378.74002"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="boden_felswand.002" meshfile="boden_fels.002.mesh">
-<position x="37.711838" y="5.930392" z="27.968113"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="gitter_zu.001" meshfile="Cube.025.mesh">
-<position x="-12.877804" y="2.514648" z="61.443035"/><rotation qw="0.578332" qx="-2.3E-4" qy="-0.815801" qz="-3.25E-4"/><scale x="0.192361" y="0.192361" z="0.192361"/>
-</entity>
-<entity name="tempelgang_decke.002" meshfile="Cube.002.mesh">
-<position x="16.682463" y="4.846837" z="56.49011"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="0.569132" y="0.569132" z="0.569132"/>
-</entity>
-<entity name="tempelgang_decke.001" meshfile="Cube.012.mesh">
-<position x="-15.229253" y="5.874734" z="24.490736"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="0.569132" y="0.569132" z="0.569132"/>
-</entity>
-<entity name="tempelgang_treppe.001" meshfile="treppe_gemauert.001.mesh">
-<position x="-23.316332" y="7.303283" z="16.492294"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="tempelgang_treppe.002" meshfile="treppe_gemauert.003.mesh">
-<position x="-36.38294" y="7.10427" z="27.145168"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="0.556166" y="0.556166" z="0.556166"/>
-</entity>
-<entity name="saeule_07" meshfile="saeule_07.mesh">
-<position x="1.244043" y="10.20761" z="6.341633"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="zugemauert" meshfile="Cube.001.mesh">
-<position x="82.31271" y="0.0" z="26.776424"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="tempelgang_waende.001" meshfile="Cube.011.mesh">
-<position x="-20.391804" y="3.431791" z="29.280613"/><rotation qw="0.708878" qx="-2.82E-4" qy="0.705331" qz="2.81E-4"/><scale x="0.569131" y="0.569132" z="0.569132"/>
-</entity>
-<entity name="randsteine_04.001" meshfile="randsteine_04.001.mesh">
-<position x="-2.300682" y="0.0" z="0.0"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="stuetzbalken" meshfile="stuetzbalken.mesh">
-<position x="38.6939" y="9.522685" z="30.678297"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Plane.001" meshfile="Plane.003.mesh">
-<position x="-18.778461" y="3.790074" z="24.69996"/><rotation qw="0.503159" qx="0.502758" qy="-0.497222" qz="0.496826"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="gaenge_01.019" meshfile="gaenge_komplett.mesh">
-<position x="-11.712984" y="2.751104" z="38.87323"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="gaenge_01.018" meshfile="gaenge_komplett.017.mesh">
-<position x="-11.712984" y="2.751104" z="38.87323"/><rotation qw="0.977955" qx="-3.89E-4" qy="-0.208817" qz="-8.3E-5"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Cube" meshfile="Cube.006.mesh">
-<position x="-19.678776" y="3.064484" z="25.362461"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="torboegen.002" meshfile="torboegen.002.mesh">
-<position x="-2.584131" y="2.751112" z="27.977468"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="tempelgang_decke" meshfile="Cube.mesh">
-<position x="94.64457" y="4.292408" z="25.715137"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="brocken" meshfile="brocken.mesh">
-<position x="45.444912" y="3.694921" z="29.209862"/><rotation qw="0.994933" qx="-3.96E-4" qy="-0.100537" qz="-4.0E-5"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="tempelgang_saeule" meshfile="saeule_01.001.mesh">
-<position x="-19.892523" y="5.950263" z="24.17252"/><rotation qw="0.013436" qx="0.0" qy="0.99991" qz="3.98E-4"/><scale x="0.569132" y="0.569132" z="0.569132"/>
-</entity>
-<entity name="fackeln_g2.003" meshfile="fackeln.004.mesh">
-<position x="39.97495" y="5.598745" z="29.590656"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="fackeln_eingangshalle" meshfile="fackeln.001.mesh">
-<position x="17.838156" y="1.844218" z="15.676789"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="schmutzwasser" meshfile="wasser.mesh">
-<physicsproxy type="none" />
-<position x="-17.99887" y="2.354909" z="26.217978"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="raum_01.007" meshfile="raum_01.005.mesh">
-<position x="-40.115147" y="5.383284" z="26.274029"/><rotation qw="0.840188" qx="-3.35E-4" qy="0.542295" qz="2.16E-4"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="raum_01.004" meshfile="raum_01.004.mesh">
-<position x="29.826838" y="2.72995" z="31.43219"/><rotation qw="0.542761" qx="-2.16E-4" qy="-0.839887" qz="-3.34E-4"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="raum_01.005" meshfile="raum_01.007.mesh">
-<position x="-11.642996" y="2.232062" z="38.87323"/><rotation qw="0.977955" qx="-3.89E-4" qy="-0.208817" qz="-8.3E-5"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="raum_01.006" meshfile="raum_01.006.mesh">
-<position x="29.826838" y="2.72995" z="31.43219"/><rotation qw="0.542761" qx="-2.16E-4" qy="-0.839887" qz="-3.34E-4"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="saeule_07.001" meshfile="saeule_07.001.mesh">
-<position x="62.32452" y="10.705501" z="44.40452"/><rotation qw="0.706179" qx="-2.81E-4" qy="-0.708033" qz="-2.82E-4"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="raum_01.001" meshfile="raum_01.001.mesh">
-<position x="-11.642996" y="2.232062" z="38.87323"/><rotation qw="0.977955" qx="-3.89E-4" qy="-0.208817" qz="-8.3E-5"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="gitter_zu" meshfile="Cube.023.mesh">
-<position x="6.479543" y="2.514645" z="1.955386"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="0.208358" y="0.208358" z="0.208358"/>
-</entity>
-<entity name="raum_01.003" meshfile="raum_01.003.mesh">
-<position x="29.826838" y="2.72995" z="31.43219"/><rotation qw="0.542761" qx="-2.16E-4" qy="-0.839887" qz="-3.34E-4"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="raum_01.002" meshfile="raum_01.002.mesh">
-<position x="-11.642996" y="2.232062" z="38.87323"/><rotation qw="0.977955" qx="-3.89E-4" qy="-0.208817" qz="-8.3E-5"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="wurzeln_02.002" meshfile="wurzeln_02.mesh">
-<position x="2.693319" y="4.398726" z="13.058824"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="faesser_tunnel_02" meshfile="Circle.011.mesh">
-<position x="57.166122" y="-0.837035" z="26.112844"/><rotation qw="0.694621" qx="0.694067" qy="0.133793" qz="-0.133686"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="gaenge_01.002" meshfile="gaenge_komplett.004.mesh">
-<position x="-14.217243" y="3.248992" z="38.87323"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="gaenge_01.001" meshfile="gaenge_komplett.002.mesh">
-<position x="-14.217243" y="3.248992" z="38.87323"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="eingangstuer" meshfile="Cube.005.mesh">
-<position x="-40.139088" y="6.390891" z="25.772146"/><rotation qw="1.0" qx="-7.96E-4" qy="0.0" qz="0.0"/><scale x="-0.097711" y="1.0" z="1.0"/>
-</entity>
-<entity name="tempelgang_waende" meshfile="Cube.003.mesh">
-<position x="85.57365" y="0.0" z="34.131252"/><rotation qw="0.708878" qx="-2.82E-4" qy="0.705331" qz="2.81E-4"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="saeule_01.001" meshfile="saeule_01.004.mesh">
-<position x="52.24556" y="9.379703" z="51.07818"/><rotation qw="0.706179" qx="-2.81E-4" qy="-0.708033" qz="-2.82E-4"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="tuern" meshfile="tuern.mesh">
-<position x="13.036044" y="3.823069" z="16.671421"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="wurzeln.001" meshfile="wurzeln_alle.001.mesh">
-<position x="64.69753" y="3.194272" z="47.05233"/><rotation qw="0.706179" qx="-2.81E-4" qy="-0.708033" qz="-2.82E-4"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="randsteine_01" meshfile="randsteine_01.mesh">
-<position x="-2.300682" y="0.0" z="0.0"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="randsteine_03" meshfile="randsteine_03.mesh">
-<position x="-2.300682" y="0.0" z="0.0"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="randsteine_02" meshfile="randsteine_02.mesh">
-<position x="-2.300682" y="0.0" z="0.0"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="randsteine_04" meshfile="randsteine_04.mesh">
-<position x="-2.300682" y="0.0" z="0.0"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="tempelgang_treppe" meshfile="treppe_gemauert.mesh">
-<position x="53.427147" y="7.565333" z="30.14977"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="gitter_zu.003" meshfile="Cube.027.mesh">
-<position x="66.71472" y="2.933403" z="49.673588"/><rotation qw="0.709539" qx="-2.83E-4" qy="-0.704666" qz="-2.81E-4"/><scale x="0.208358" y="0.208358" z="0.208358"/>
-</entity>
-<entity name="treppe" meshfile="treppe_02.mesh">
-<position x="3.132164" y="2.587981" z="6.686421"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="tempelgang_boden" meshfile="boden_fels.001.mesh">
-<position x="37.711838" y="5.930392" z="27.968113"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="tempelgang_saeulen" meshfile="saeule_01.011.mesh">
-<position x="86.45091" y="4.425117" z="25.15601"/><rotation qw="0.013434" qx="0.0" qy="0.99991" qz="3.98E-4"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="gitter_zu.002" meshfile="Cube.026.mesh">
-<position x="-5.445406" y="2.514649" z="67.09695"/><rotation qw="0.96454" qx="-3.84E-4" qy="-0.263938" qz="-1.05E-4"/><scale x="0.178084" y="0.178084" z="0.178084"/>
-</entity>
-<entity name="tempelgang_randst" meshfile="Cube.007.mesh">
-<position x="-15.235514" y="5.567721" z="28.191092"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="0.569132" y="0.569132" z="0.569132"/>
-</entity>
-<entity name="moderholz" meshfile="moderbalken_01.mesh">
-<position x="37.592186" y="6.02605" z="32.072422"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="tempelgang_randsteine" meshfile="Cube.009.mesh">
-<position x="94.63357" y="3.752965" z="32.216892"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="brocken.001" meshfile="brocken.001.mesh">
-<position x="83.84499" y="3.694921" z="29.906654"/><rotation qw="0.994933" qx="-3.96E-4" qy="-0.100537" qz="-4.0E-5"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="durchbruch_02" meshfile="durchbruch_02.mesh">
-<position x="43.158157" y="6.466876" z="27.790565"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="fackeln" meshfile="fackeln.mesh">
-<position x="15.30493" y="2.587982" z="15.800744"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Cube.001" meshfile="Cube.014.mesh">
-<position x="-19.678776" y="3.064484" z="25.362461"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="saeule_06" meshfile="saeule_06.mesh">
-<position x="4.451921" y="3.546391" z="14.409163"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="saeule_05" meshfile="saeule_05.mesh">
-<position x="7.967321" y="8.881814" z="3.944559"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Cube.002" meshfile="Cube.015.mesh">
-<position x="-40.626343" y="0.0" z="26.123762"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Cube.005" meshfile="Cube.019.mesh">
-<position x="11.334853" y="2.948639" z="60.276592"/><rotation qw="0.0" qx="0.0" qy="1.0" qz="3.98E-4"/><scale x="1.0" y="0.500934" z="1.0"/>
-</entity>
-<entity name="Cube.004" meshfile="durchgang.mesh">
-<position x="42.81224" y="7.032636" z="33.16056"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="saeule_01" meshfile="saeule_01.mesh">
-<position x="7.944117" y="8.881815" z="16.403053"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Cube.006" meshfile="Cube.004.mesh">
-<position x="-0.04573" y="3.819188" z="61.17655"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="Cube.008" meshfile="Cube.016.mesh">
-<position x="0.144417" y="0.0" z="55.632095"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="farn" meshfile="farn.mesh">
-<physicsproxy type="none" />
-<position x="-2.364898" y="-1.932347" z="2.648438"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="raum_01" meshfile="raum_01.mesh">
-<position x="-11.642996" y="2.232062" z="38.87323"/><rotation qw="0.977955" qx="-3.89E-4" qy="-0.208817" qz="-8.3E-5"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="saeule_08" meshfile="saeule_08.mesh">
-<position x="-1.425607" y="8.881815" z="12.471745"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="randsteine_03.001" meshfile="Cube.008.mesh">
-<position x="0.349848" y="1.044165" z="7.637593"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="randsteine_03.002" meshfile="randsteine_03.001.mesh">
-<position x="-2.300682" y="0.0" z="0.0"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="randsteine_03.003" meshfile="randsteine_03.002.mesh">
-<position x="-2.300682" y="0.0" z="0.0"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="randsteine_03.005" meshfile="randsteine_03.004.mesh">
-<position x="14.49704" y="0.0" z="19.140228"/><rotation qw="0.999974" qx="-3.98E-4" qy="-0.007229" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="saeulen" meshfile="saeulen.mesh">
-<position x="60.158802" y="4.198632" z="43.96852"/><rotation qw="0.706179" qx="-2.81E-4" qy="-0.708033" qz="-2.82E-4"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-<entity name="wurzeln" meshfile="wurzeln_alle.mesh">
-<position x="3.885619" y="2.696382" z="3.961683"/><rotation qw="1.0" qx="-3.98E-4" qy="0.0" qz="0.0"/><scale x="1.0" y="1.0" z="1.0"/>
-</entity>
-    </nodes>
-</scene>
\ No newline at end of file

Added: modules/kanalisation/materials/DirtyWater.material
===================================================================
--- modules/kanalisation/materials/DirtyWater.material	2008-11-07 16:36:19 UTC (rev 4578)
+++ modules/kanalisation/materials/DirtyWater.material	2008-11-07 17:46:18 UTC (rev 4579)
@@ -0,0 +1,78 @@
+//----------------------------
+// Distortion effects
+//----------------------------
+
+vertex_program TotalReflectDirtWaterVP cg
+{
+	source TotalReflectDirtWater.source
+	entry_point main_vp
+	profiles vs_1_1 arbvp1
+}
+
+fragment_program TotalReflectDirtWaterFP cg
+{
+	source TotalReflectDirtWater.source
+	entry_point main_fp
+	// sorry, ps_1_1 and fp20 can't do this
+	profiles ps_2_0 arbfp1
+}
+
+material DirtyWater
+{
+	// ps_2_0 / arbfp1
+	technique
+	{
+		pass 
+		{
+			ambient 0.609804 0.609804 0.609804 1
+			
+			vertex_program_ref TotalReflectDirtWaterVP
+			{
+				param_named_auto worldViewProjMatrix worldviewproj_matrix
+				param_named_auto eyePosition camera_position_object_space
+				param_named_auto timeVal time 0.05
+				param_named_auto ambient ambient_light_colour
+				param_named scroll float 1  
+				param_named scale float 1 
+				param_named noise float 1 
+				// scroll and noisePos will need updating per frame
+			}
+			fragment_program_ref TotalReflectDirtWaterFP
+			{
+				param_named fresnelBias float -0.1 
+				param_named fresnelScale float 1.8 
+				param_named fresnelPower float 8  
+				param_named noiseScale float 0.05 
+			}
+			// Noise
+			texture_unit
+			{
+				// Perlin noise volume
+				texture waves2.dds
+				// min / mag filtering, no mip
+				filtering linear linear none
+			}
+			// Reflection
+			texture_unit
+			{
+				// Will be filled in at runtime
+				texture_alias reflection
+				texture nx.zone.orange.png
+				tex_address_mode clamp
+				// needed by ps.1.4
+				tex_coord_set 1
+			}
+			// Refraction
+			texture_unit
+			{
+				texture boden_kana.png
+				tex_address_mode clamp
+				// needed by ps.1.4
+				tex_coord_set 2
+			}
+		}
+		
+			
+	}
+   
+}

Added: modules/kanalisation/materials/TotalReflectDirtWater.source
===================================================================
--- modules/kanalisation/materials/TotalReflectDirtWater.source	2008-11-07 16:36:19 UTC (rev 4578)
+++ modules/kanalisation/materials/TotalReflectDirtWater.source	2008-11-07 17:46:18 UTC (rev 4579)
@@ -0,0 +1,81 @@
+// Vertex program for fresnel reflections / refractions
+void main_vp(
+		float4 pos			: POSITION,
+		float4 normal		: NORMAL,
+		float2 tex			: TEXCOORD0,
+		
+		out float4 oPos		: POSITION,
+		out float3 noiseCoord : TEXCOORD0,
+		out float4 projectionCoord : TEXCOORD1,
+		out float3 oEyeDir : TEXCOORD2, 
+		out float3 oNormal : TEXCOORD3,
+		out float2 oTex    : TEXCOORD4,
+		out float4 color   : COLOR,
+		
+		uniform float4x4 worldViewProjMatrix,
+		uniform float3 eyePosition, // object space
+		uniform float timeVal,
+		uniform float scale,  // the amount to scale the noise texture by
+		uniform float scroll, // the amount by which to scroll the noise
+		uniform float noise,  // the noise perturb as a factor of the  time
+		uniform float4 ambient  //ambient light color
+		)
+{
+	oPos = mul(worldViewProjMatrix, pos);
+	// Projective texture coordinates, adjust for mapping
+	float4x4 scalemat = float4x4(0.5,   0,   0, 0.5, 
+	                               0,-0.5,   0, 0.5,
+								   0,   0, 0.5, 0.5,
+								   0,   0,   0,   1);
+	projectionCoord = mul(scalemat, oPos);
+	// Noise map coords
+	noiseCoord.xy = (tex + (timeVal * scroll)) * scale;
+	noiseCoord.z = noise * timeVal;
+
+	oEyeDir = normalize(pos.xyz - eyePosition); 
+	oNormal = normal.rgb; 
+	
+	oTex = tex;
+	color = ambient;
+}
+
+// Fragment program for distorting a texture using a 3D noise texture
+void main_fp(
+		float3 noiseCoord			: TEXCOORD0,
+		float4 projectionCoord		: TEXCOORD1,
+		float3 eyeDir				: TEXCOORD2,
+		float3 normal				: TEXCOORD3,
+		float2 tex					: TEXCOORD4,
+		float4 color				: COLOR,
+		
+		out float4 col		: COLOR,
+		
+		uniform float noiseScale, 
+		uniform float fresnelBias,
+		uniform float fresnelScale,
+		uniform float fresnelPower,
+		uniform sampler2D noiseMap : register(s0),
+		uniform sampler2D reflectMap : register(s1),
+		uniform sampler2D dirtMap : register(s2)
+		)
+{
+	// Do the tex projection manually so we can distort _after_
+	float2 final = projectionCoord.xy / projectionCoord.w;
+
+	// Noise
+	float3 noiseNormal = (tex2D(noiseMap, (noiseCoord.xy / 5)).rgb - 0.5).rbg * noiseScale;
+	final += noiseNormal.xz;
+
+	// Fresnel
+	//normal = normalize(normal + noiseNormal.xz);
+	float fresnel = fresnelBias + fresnelScale * (saturate(pow(1 + dot(eyeDir, normal), fresnelPower)+0.2));
+
+	// Reflection / refraction
+	float4 reflectionColour = tex2D(reflectMap, final);
+	float4 dirtColour = tex2D(dirtMap, tex) * color;
+
+	// Final colour
+	col = lerp(dirtColour, reflectionColour, fresnel);
+
+
+}

Added: modules/kanalisation/materials/textures/nx.zone.orange.png
===================================================================
(Binary files differ)


Property changes on: modules/kanalisation/materials/textures/nx.zone.orange.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/kanalisation/materials/textures/perlinvolume.dds
===================================================================
(Binary files differ)


Property changes on: modules/kanalisation/materials/textures/perlinvolume.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/kanalisation/materials/textures/waves2.dds
===================================================================
(Binary files differ)


Property changes on: modules/kanalisation/materials/textures/waves2.dds
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: modules/kanalisation/scripts/maps/kanalisation.rb
===================================================================
--- modules/kanalisation/scripts/maps/kanalisation.rb	2008-11-07 16:36:19 UTC (rev 4578)
+++ modules/kanalisation/scripts/maps/kanalisation.rb	2008-11-07 17:46:18 UTC (rev 4579)
@@ -33,7 +33,7 @@
 $SCRIPT.log("Sound fertig");
 
 $SCRIPT.log("Initialize hero");
-$hero = $GOM.createGameObject("mckhero", 1);
+$hero = $GOM.createGameObject("mckhero", "hero");
 $hero.placeIntoScene();
 $hero.setPosition([ -35.15, 2.69, 26.09]);
 $hero.setOrientation([ [ -4.43614335381426e-005, -0.999999940395355, -3.53998184436932e-005 ] , 67.3891525268555]);

Modified: modules/kanalisation/scripts/moduleconfig.rb
===================================================================
--- modules/kanalisation/scripts/moduleconfig.rb	2008-11-07 16:36:19 UTC (rev 4578)
+++ modules/kanalisation/scripts/moduleconfig.rb	2008-11-07 17:46:18 UTC (rev 4579)
@@ -28,7 +28,7 @@
         #$CORE.loadMap("Octree", "kanalisation.scene", "kanalisation");
 		loader = MapLoader.new("kanalisation");
 		loader.loadMap("kana_lights.rlmap.xml");
-		loader.loadMap("kanalisation_scene.xml");
+		loader.loadMap("kanalisation.rlmap.xml");
         load "kanalisation.rb"
         $World = $CORE.getWorld();
     end



From timm at mail.berlios.de  Fri Nov  7 18:57:59 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Fri, 7 Nov 2008 18:57:59 +0100
Subject: [Dsa-hl-svn] r4580 - in modules/kanalisation: maps scripts
	scripts/maps
Message-ID: <200811071757.mA7Hvx6W028785@sheep.berlios.de>

Author: timm
Date: 2008-11-07 18:57:51 +0100 (Fri, 07 Nov 2008)
New Revision: 4580

Added:
   modules/kanalisation/maps/hero.rlmap.xml
   modules/kanalisation/maps/kanalisation.lrscene
   modules/kanalisation/scripts/maps/setchar.rb
Modified:
   modules/kanalisation/scripts/maps/kanalisation.rb
   modules/kanalisation/scripts/moduleconfig.rb
Log:
define scene kanalisation

Added: modules/kanalisation/maps/hero.rlmap.xml
===================================================================
--- modules/kanalisation/maps/hero.rlmap.xml	2008-11-07 17:46:18 UTC (rev 4579)
+++ modules/kanalisation/maps/hero.rlmap.xml	2008-11-07 17:57:51 UTC (rev 4580)
@@ -0,0 +1,7 @@
+<scene formatVersion="0.4.0" scenescript="setchar.rb">
+    <nodes>
+        <gameobject class="mckhero" id="10" state="IN_SCENE">
+            <position x="2" y="0.0" z="0"/>
+        </gameobject>
+    </nodes>
+</scene>

Added: modules/kanalisation/maps/kanalisation.lrscene
===================================================================
--- modules/kanalisation/maps/kanalisation.lrscene	2008-11-07 17:46:18 UTC (rev 4579)
+++ modules/kanalisation/maps/kanalisation.lrscene	2008-11-07 17:57:51 UTC (rev 4580)
@@ -0,0 +1,5 @@
+<scene name="kanalisation">
+	<map file="kana_lights.rlmap.xml"/>
+	<map file="kanalisation.rlmap.xml"/>
+	<map file="hero.rlmap.xml"/>
+</scene>
\ No newline at end of file

Modified: modules/kanalisation/scripts/maps/kanalisation.rb
===================================================================
--- modules/kanalisation/scripts/maps/kanalisation.rb	2008-11-07 17:46:18 UTC (rev 4579)
+++ modules/kanalisation/scripts/maps/kanalisation.rb	2008-11-07 17:57:51 UTC (rev 4580)
@@ -32,15 +32,15 @@
 kanalLied.getControlledObject().play();
 $SCRIPT.log("Sound fertig");
 
-$SCRIPT.log("Initialize hero");
-$hero = $GOM.createGameObject("mckhero", "hero");
-$hero.placeIntoScene();
-$hero.setPosition([ -35.15, 2.69, 26.09]);
-$hero.setOrientation([ [ -4.43614335381426e-005, -0.999999940395355, -3.53998184436932e-005 ] , 67.3891525268555]);
-PlayerSettings.preparePlayer($hero);
-PartyManager.getSingleton().setActiveCharacter($hero)
+#$SCRIPT.log("Initialize hero");
+#$hero = $GOM.createGameObject("mckhero", "hero");
+#$hero.placeIntoScene();
+#$hero.setPosition([ -35.15, 2.69, 26.09]);
+#$hero.setOrientation([ [ -4.43614335381426e-005, -0.999999940395355, -3.53998184436932e-005 ] , 67.3891525268555]);
+#PlayerSettings.preparePlayer($hero);
+#PartyManager.getSingleton().setActiveCharacter($hero)
 
-$SCRIPT.log("Hero ready")
+#$SCRIPT.log("Hero ready")
 
 #$SCRIPT.log("Fackellicht erstellen..");
 #fackellicht = $AM.createLightActor("Das Licht der Fackel", LightObject::LT_POINT );

Added: modules/kanalisation/scripts/maps/setchar.rb
===================================================================
--- modules/kanalisation/scripts/maps/setchar.rb	2008-11-07 17:46:18 UTC (rev 4579)
+++ modules/kanalisation/scripts/maps/setchar.rb	2008-11-07 17:57:51 UTC (rev 4580)
@@ -0,0 +1,21 @@
+load "embed.rb"
+
+require 'player.rb'
+require 'hero.rb'
+
+$SCRIPT.log("Prepare hero for being the active character")
+hero = $GOM.getGameObject(10);
+hero.setPosition([ -35.15, 2.69, 26.09]);
+hero.setOrientation([ [ -4.43614335381426e-005, -0.999999940395355, -3.53998184436932e-005 ] , 67.3891525268555]);
+PlayerSettings.preparePlayer(hero)
+
+$SCRIPT.log("Set hero as active character")
+PartyManager.getSingleton().setActiveCharacter(hero)
+
+$SCRIPT.log("Hero ready")
+itemToAdd = $GOM.createGameObject("men_human_female_legs_pants_01_long");
+hero.getInventory().hold(itemToAdd, "Trousers");
+itemToAdd = $GOM.createGameObject("men_human_female_cloth_short");
+hero.getInventory().hold(itemToAdd, "Clothes");
+itemToAdd = $GOM.createGameObject("men_human_female_feet_boots_01");
+hero.getInventory().hold(itemToAdd, "Boots");

Modified: modules/kanalisation/scripts/moduleconfig.rb
===================================================================
--- modules/kanalisation/scripts/moduleconfig.rb	2008-11-07 17:46:18 UTC (rev 4579)
+++ modules/kanalisation/scripts/moduleconfig.rb	2008-11-07 17:57:51 UTC (rev 4580)
@@ -26,9 +26,10 @@
 		require 'mckhero.rb'
 		require 'torch.rb'
         #$CORE.loadMap("Octree", "kanalisation.scene", "kanalisation");
-		loader = MapLoader.new("kanalisation");
-		loader.loadMap("kana_lights.rlmap.xml");
-		loader.loadMap("kanalisation.rlmap.xml");
+		#loader = MapLoader.new("kanalisation");
+		#loader.loadMap("kana_lights.rlmap.xml");
+		#loader.loadMap("kanalisation.rlmap.xml");
+		SceneManager.getSingleton().loadScene("kanalisation");
         load "kanalisation.rb"
         $World = $CORE.getWorld();
     end



From blakharaz at mail.berlios.de  Sat Nov  8 13:55:52 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Sat, 8 Nov 2008 13:55:52 +0100
Subject: [Dsa-hl-svn] r4581 - in rl/trunk/engine/rules: include src
Message-ID: <200811081255.mA8CtqA9026562@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-08 13:55:50 +0100 (Sat, 08 Nov 2008)
New Revision: 4581

Modified:
   rl/trunk/engine/rules/include/Combat.h
   rl/trunk/engine/rules/src/Combat.cpp
Log:
Fix Combat class


Modified: rl/trunk/engine/rules/include/Combat.h
===================================================================
--- rl/trunk/engine/rules/include/Combat.h	2008-11-07 17:57:51 UTC (rev 4580)
+++ rl/trunk/engine/rules/include/Combat.h	2008-11-08 12:55:50 UTC (rev 4581)
@@ -120,6 +120,10 @@
 
         unsigned short mCurrentRound;
 		unsigned short mNextActionId;
+		
+		/// Maximum distance to enemies, a combatant is  this exceededing distance to its enemies
+		/// he is considered fleeing
+		Ogre::Real mMaxDistance;
 
 		MessagePump::ScopedConnection mLifeStateChangeConnection;
 
@@ -139,8 +143,9 @@
 		/// destroy combatants owned by this combat instance.
 		void clearRemovedCombatantSet();
 
+		bool isOutOfCombatRange(Combatant* combatant, const CombatantSet& enemies) const;
+
         // Message handlers
-
         bool onGameObjectLifeStateChanged(GameObject*, Effect::LifeState, Effect::LifeState);
     };
 }

Modified: rl/trunk/engine/rules/src/Combat.cpp
===================================================================
--- rl/trunk/engine/rules/src/Combat.cpp	2008-11-07 17:57:51 UTC (rev 4580)
+++ rl/trunk/engine/rules/src/Combat.cpp	2008-11-08 12:55:50 UTC (rev 4581)
@@ -70,7 +70,8 @@
 		  mRemovedCombatants(),
           mCurrentRound(0),
 		  mNextActionId(0),
-		  mAnimationSequenceTicket(0)
+		  mAnimationSequenceTicket(0),
+		  mMaxDistance(maxDistance)
     {
         LOG_MESSAGE("Combat", "Register message handler");
 		mLifeStateChangeConnection =
@@ -403,14 +404,14 @@
         // check for fleeing from combat
         for (CombatantSet::iterator it = mAllies.begin(); it != mAllies.end(); ++it)
         {
-            if (outOfCombatRange(*it, mOpponents))
+            if (isOutOfCombatRange(*it, mOpponents))
             {
                 removeAlly(*it);
             }
         }
         for (CombatantSet::iterator it = mOpponents.begin(); it != mOpponents.end(); ++it)
         {
-            if (outOfCombatRange(*it, mAllies))
+            if (isOutOfCombatRange(*it, mAllies))
             {
                 removeOpponent(*it);
             }
@@ -578,4 +579,19 @@
 		}
 		return false;
 	}
+
+	bool Combat::isOutOfCombatRange(Combatant* combatant, const Combat::CombatantSet& enemies) const
+	{
+		Vector3 pos = combatant->getPosition();
+		Ogre::Real sqD = mMaxDistance * mMaxDistance;
+		for (CombatantSet::const_iterator it = enemies.begin(); it != enemies.end(); ++it)
+		{
+			if (pos.squaredDistance((*it)->getPosition()) <= sqD)
+			{
+				return false;
+			}
+		}
+
+		return true;
+	}
 }



From timm at mail.berlios.de  Sat Nov  8 20:04:24 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sat, 8 Nov 2008 20:04:24 +0100
Subject: [Dsa-hl-svn] r4582 - in rl/branches/persistence: ai/include ai/src
	core/include core/src rules/include rules/src ui/include ui/src
Message-ID: <200811081904.mA8J4Orb015452@sheep.berlios.de>

Author: timm
Date: 2008-11-08 20:04:01 +0100 (Sat, 08 Nov 2008)
New Revision: 4582

Modified:
   rl/branches/persistence/ai/include/AgentCombatState.h
   rl/branches/persistence/ai/src/AgentCombatState.cpp
   rl/branches/persistence/core/include/SaveAbleCollection.h
   rl/branches/persistence/core/include/SaveAbleManager.h
   rl/branches/persistence/core/src/ConfigurationManager.cpp
   rl/branches/persistence/core/src/SaveAbleCollection.cpp
   rl/branches/persistence/core/src/SaveAbleManager.cpp
   rl/branches/persistence/rules/include/Combat.h
   rl/branches/persistence/rules/include/Container.h
   rl/branches/persistence/rules/src/Combat.cpp
   rl/branches/persistence/rules/src/Container.cpp
   rl/branches/persistence/rules/src/Item.cpp
   rl/branches/persistence/ui/include/CombatGui.h
   rl/branches/persistence/ui/src/CombatGui.cpp
   rl/branches/persistence/ui/src/InputManager.cpp
Log:
- merged from trunk
- uploaded some updates for persistence

Modified: rl/branches/persistence/ai/include/AgentCombatState.h
===================================================================
--- rl/branches/persistence/ai/include/AgentCombatState.h	2008-11-08 12:55:50 UTC (rev 4581)
+++ rl/branches/persistence/ai/include/AgentCombatState.h	2008-11-08 19:04:01 UTC (rev 4582)
@@ -18,6 +18,7 @@
 
 #include "AiPrerequisites.h"
 #include "AgentState.h"
+#include "Combat.h"
 #include "Combatant.h"
 
 namespace rl
@@ -46,6 +47,10 @@
     protected:
         typedef enum {} CombatState;
         CombatState mState;
+
+    private:
+        Combatant* findOpponent(const Combat::CombatantSet& opponents) const;
+        Ogre::Vector3 getFleeTarget(const Combat::CombatantSet& opponents) const;
 	};
 }
 #endif

Modified: rl/branches/persistence/ai/src/AgentCombatState.cpp
===================================================================
--- rl/branches/persistence/ai/src/AgentCombatState.cpp	2008-11-08 12:55:50 UTC (rev 4581)
+++ rl/branches/persistence/ai/src/AgentCombatState.cpp	2008-11-08 19:04:01 UTC (rev 4582)
@@ -19,6 +19,7 @@
 #include "AgentCombatState.h"
 #include "Combat.h"
 #include "CombatManager.h"
+#include "Creature.h"
 #include "CreatureControllerManager.h"
 
 namespace rl
@@ -45,13 +46,19 @@
     void AgentCombatState::requestCombatantAction()
     {
         // Think!
-		const Combat::CombatantSet& allies = mCombat->getAllAllies();
-		if (!allies.empty())
+        Combat::CombatantSet opponents = mCombat->getAllOpponents(this);
+		if (!opponents.empty())
 		{
-			Combatant* target = *allies.begin();
-			// Are we in weapon range to opponent
-			if (target)
-			{
+			Combatant* target = findOpponent(opponents);
+            
+            mCombat->registerParade(target);
+
+            if (getCreature()->getLe() <= 5)
+            {
+                mCombat->registerBewegen(this, getFleeTarget(opponents));
+            }
+            else if (target)
+            {
 				// Are we in weapon range to opponent
 				if (mCombat->canAttack(this, target))
 				{
@@ -72,4 +79,47 @@
     {
         mAgent->updateVehicle(0, elapsedTime);
     }
+
+    class DistanceComparator
+		: std::binary_function<Combatant*, Combatant*, bool>
+    {
+    private:
+        const Combatant* mActingCombatant;
+
+    public:
+        DistanceComparator(const Combatant* actingCombatant)
+            : mActingCombatant(actingCombatant)
+        {
+        }
+
+        bool operator()(const Combatant* c1, const Combatant* c2) const
+        {
+            Vector3 pos = mActingCombatant->getPosition();
+            return pos.squaredDistance(c1->getPosition())
+                < pos.squaredDistance(c2->getPosition());
+        }
+    };
+
+
+    Combatant* AgentCombatState::findOpponent(const Combat::CombatantSet& opponents) const
+    {
+        ///@todo support different search patterns (search for most dangerous, weakest, ... opponent)
+        Combat::CombatantSet::const_iterator minIt = 
+            std::min_element(opponents.begin(), opponents.end(), DistanceComparator(this));
+        return *minIt;
+    }
+
+    Vector3 AgentCombatState::getFleeTarget(const Combat::CombatantSet& opponents) const
+    {
+        Vector3 oppPosition;
+        for (Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); ++it)
+        {
+            oppPosition += (*it)->getPosition();
+        }
+        oppPosition /= opponents.size();
+
+        Vector3 pos = getPosition();
+        Vector3 oppositeDirection = (pos - oppPosition).normalisedCopy();
+        return pos + 10 * oppositeDirection;
+    }
 }

Modified: rl/branches/persistence/core/include/SaveAbleCollection.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleCollection.h	2008-11-08 12:55:50 UTC (rev 4581)
+++ rl/branches/persistence/core/include/SaveAbleCollection.h	2008-11-08 19:04:01 UTC (rev 4582)
@@ -23,13 +23,15 @@
 	class SaveAbleCollection
 	{
 	public:
+		SaveAbleCollection(const CeGuiString &id);
 		void attachSaveAble(SaveAblePtr saveAble);
 		void deattachSaveAble(SaveAblePtr saveAble);
 		void deattachSaveAble(int id);
 		void deattachAllSaveAbles();
 		Ogre::String getId();
 	protected:
-		Ogre::String mId;
+		std::map<int, SaveAblePtr> mSaveAbles;
+		CeGuiString mId;
 	};
 
 }
\ No newline at end of file

Modified: rl/branches/persistence/core/include/SaveAbleManager.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleManager.h	2008-11-08 12:55:50 UTC (rev 4581)
+++ rl/branches/persistence/core/include/SaveAbleManager.h	2008-11-08 19:04:01 UTC (rev 4582)
@@ -29,10 +29,10 @@
 		void saveState();
 		void addSaveAble(SaveAblePtr save);
 		void removeSaveAble(SaveAblePtr save);
-		void removeSaveAble(int id);
+		void removeSaveAble(const CeGuiString &id);
 		void removeAllSaveAbles();
-		void attachSaveAbleToCollection(int id);
-		void deattachSaveAbleFromColltection(int id);
+		void attachSaveAbleToCollection(const CeGuiString &id);
+		void deattachSaveAbleFromColltection(const CeGuiString &id);
 		void restoreState();
 	protected:
 		std::map<int, PropertyRecordPtr> mSaveAbleStates;

Modified: rl/branches/persistence/core/src/ConfigurationManager.cpp
===================================================================
--- rl/branches/persistence/core/src/ConfigurationManager.cpp	2008-11-08 12:55:50 UTC (rev 4581)
+++ rl/branches/persistence/core/src/ConfigurationManager.cpp	2008-11-08 19:04:01 UTC (rev 4582)
@@ -388,9 +388,14 @@
 	
 	void ConfigurationManager::setExecutable(const Ogre::String& path)
 	{
+#       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+		return;
+		fs::path exeAbsolute(path);
+#       else
 		fs::path exeAbsolute(path, fs::portable_posix_name);
-		mExecutablePath = exeAbsolute.remove_leaf().string();
-        std::cout << "ConfigurationManager" << "Executable is " << path << " " << mExecutablePath;
+#		endif
+		mExecutablePath = exeAbsolute.branch_path().string();
+        std::cout << "ConfigurationManager " << "Executable is " << path << " " << mExecutablePath;
 	}
 
 	const Ogre::String& ConfigurationManager::getExecutablePath() const
@@ -440,17 +445,14 @@
         try 
         {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-			std::cout << "Checking for " << fs::complete(filename) << std::endl;
-            if (fs::exists(filename))
+			std::cout << "Checking for " << fs::complete(filename).string() << std::endl;
+            return fs::exists(filename);
 #           else
 			std::cout << "Checking for " << 
 				fs::complete(fs::path(filename, fs::portable_posix_name)).string()
                  << std::endl;
-			if (fs::exists(fs::path(filename, fs::portable_posix_name)))
+			return fs::exists(fs::path(filename, fs::portable_posix_name));
 #           endif
-            {
-                return true;
-            }
         }
         catch (fs::filesystem_error&) 
         {

Modified: rl/branches/persistence/core/src/SaveAbleCollection.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleCollection.cpp	2008-11-08 12:55:50 UTC (rev 4581)
+++ rl/branches/persistence/core/src/SaveAbleCollection.cpp	2008-11-08 19:04:01 UTC (rev 4582)
@@ -16,4 +16,12 @@
 
 #include "stdinc.h"
 
-#include "SaveAbleCollection.h"
\ No newline at end of file
+#include "SaveAbleCollection.h"
+
+namespace rl
+{
+	SaveAbleCollection::SaveAbleCollection(const CeGuiString &id)
+	{
+		mId = id;
+	}
+}
\ No newline at end of file

Modified: rl/branches/persistence/core/src/SaveAbleManager.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleManager.cpp	2008-11-08 12:55:50 UTC (rev 4581)
+++ rl/branches/persistence/core/src/SaveAbleManager.cpp	2008-11-08 19:04:01 UTC (rev 4582)
@@ -22,5 +22,35 @@
 
 namespace rl
 {
-	
+	void SaveAbleManager::saveState()
+	{
+	}
+
+	void SaveAbleManager::addSaveAble(SaveAblePtr save)
+	{
+	}
+
+	void SaveAbleManager::removeSaveAble(SaveAblePtr save)
+	{
+	}
+		
+	void SaveAbleManager::removeSaveAble(const CeGuiString &id)
+	{
+	}
+		
+	void SaveAbleManager::removeAllSaveAbles()
+	{
+	}
+		
+	void SaveAbleManager::attachSaveAbleToCollection(const CeGuiString &id)
+	{
+	}
+		
+	void SaveAbleManager::deattachSaveAbleFromColltection(const CeGuiString &id)
+	{
+	}
+		
+	void SaveAbleManager::restoreState()
+	{
+	}
 }

Modified: rl/branches/persistence/rules/include/Combat.h
===================================================================
--- rl/branches/persistence/rules/include/Combat.h	2008-11-08 12:55:50 UTC (rev 4581)
+++ rl/branches/persistence/rules/include/Combat.h	2008-11-08 19:04:01 UTC (rev 4582)
@@ -41,7 +41,7 @@
     public:
         typedef std::set<Combatant*> CombatantSet;
 
-        Combat();
+        Combat(Ogre::Real maxDistance = 10.0f);
         ~Combat();
 
         void addOpponent(Combatant*);
@@ -54,8 +54,9 @@
 
         void removeAlly(Combatant*);
 
-        const CombatantSet& getAllOpponents() const;
-        const CombatantSet& getAllAllies() const;
+        const CombatantSet getAllOpponents(Combatant* combatant) const;
+        const CombatantSet& getAllPlayerOpponents() const;
+        const CombatantSet& getAllPlayerAllies() const;
 
         void start();
         void pause();
@@ -119,6 +120,10 @@
 
         unsigned short mCurrentRound;
 		unsigned short mNextActionId;
+		
+		/// Maximum distance to enemies, a combatant is  this exceededing distance to its enemies
+		/// he is considered fleeing
+		Ogre::Real mMaxDistance;
 
 		MessagePump::ScopedConnection mLifeStateChangeConnection;
 
@@ -138,8 +143,9 @@
 		/// destroy combatants owned by this combat instance.
 		void clearRemovedCombatantSet();
 
+		bool isOutOfCombatRange(Combatant* combatant, const CombatantSet& enemies) const;
+
         // Message handlers
-
         bool onGameObjectLifeStateChanged(GameObject*, Effect::LifeState, Effect::LifeState);
     };
 }

Modified: rl/branches/persistence/rules/include/Container.h
===================================================================
--- rl/branches/persistence/rules/include/Container.h	2008-11-08 12:55:50 UTC (rev 4581)
+++ rl/branches/persistence/rules/include/Container.h	2008-11-08 19:04:01 UTC (rev 4582)
@@ -71,8 +71,22 @@
 		 * @return <code>true</code> if adding was successful, <code>false</code> otherwise (e.g. not enough space)
 		 */
         bool addItem(Item* item, IntPair position = IntPair(0,0));
+
+        /**
+         * Remove an item from the container
+         *
+		 * @param item the item
+         */
         void removeItem(Item* item);
 
+        /**
+         * Remove an item from the container
+         * Note: This method must only be called by Item, use removeItem in all other cases
+         *
+		 * @param item the item
+         */
+        void _doRemoveItem(Item* item);
+
         ItemSet getItems() const;
 
 		int getItemCount() const;

Modified: rl/branches/persistence/rules/src/Combat.cpp
===================================================================
--- rl/branches/persistence/rules/src/Combat.cpp	2008-11-08 12:55:50 UTC (rev 4581)
+++ rl/branches/persistence/rules/src/Combat.cpp	2008-11-08 19:04:01 UTC (rev 4582)
@@ -59,7 +59,7 @@
         }
     };
 
-    Combat::Combat()
+    Combat::Combat(Ogre::Real maxDistance)
         : mOwnedCombatants(),
 		  mOpponents(),
           mAllies(),
@@ -70,7 +70,8 @@
 		  mRemovedCombatants(),
           mCurrentRound(0),
 		  mNextActionId(0),
-		  mAnimationSequenceTicket(0)
+		  mAnimationSequenceTicket(0),
+		  mMaxDistance(maxDistance)
     {
         LOG_MESSAGE("Combat", "Register message handler");
 		mLifeStateChangeConnection =
@@ -165,16 +166,31 @@
 		mRemovedCombatants.clear();
 	}
 
-    const Combat::CombatantSet& Combat::getAllOpponents() const
+    const Combat::CombatantSet& Combat::getAllPlayerOpponents() const
     {
         return mOpponents;
     }
 
-    const Combat::CombatantSet& Combat::getAllAllies() const
+    const Combat::CombatantSet& Combat::getAllPlayerAllies() const
     {
         return mAllies;
     }
 
+    const Combat::CombatantSet Combat::getAllOpponents(Combatant* combatant) const
+    {
+        if (mOpponents.find(combatant) != mOpponents.end())
+        {
+            return mAllies;
+        }
+        
+        if (mAllies.find(combatant) != mAllies.end())
+        {
+            return mOpponents;
+        }
+        
+        return Combat::CombatantSet(); // not in combat -> no opponents
+    }
+
     void Combat::start()
     {
 		GameEventLog::getSingleton().logEvent("Kampf beginnt.", GET_COMBAT);
@@ -384,6 +400,25 @@
     void Combat::endRound()
     {
 		clearRemovedCombatantSet();
+
+        // check for fleeing from combat
+        for (CombatantSet::iterator it = mAllies.begin(); it != mAllies.end(); ++it)
+        {
+            if (isOutOfCombatRange(*it, mOpponents))
+            {
+                removeAlly(*it);
+            }
+        }
+        for (CombatantSet::iterator it = mOpponents.begin(); it != mOpponents.end(); ++it)
+        {
+            if (isOutOfCombatRange(*it, mAllies))
+            {
+                removeOpponent(*it);
+            }
+        }
+
+		clearRemovedCombatantSet();
+
         // All actions executed. Analyze outcome of this round.
         if (mAllies.empty())
         {
@@ -544,4 +579,19 @@
 		}
 		return false;
 	}
+
+	bool Combat::isOutOfCombatRange(Combatant* combatant, const Combat::CombatantSet& enemies) const
+	{
+		Vector3 pos = combatant->getPosition();
+		Ogre::Real sqD = mMaxDistance * mMaxDistance;
+		for (CombatantSet::const_iterator it = enemies.begin(); it != enemies.end(); ++it)
+		{
+			if (pos.squaredDistance((*it)->getPosition()) <= sqD)
+			{
+				return false;
+			}
+		}
+
+		return true;
+	}
 }

Modified: rl/branches/persistence/rules/src/Container.cpp
===================================================================
--- rl/branches/persistence/rules/src/Container.cpp	2008-11-08 12:55:50 UTC (rev 4581)
+++ rl/branches/persistence/rules/src/Container.cpp	2008-11-08 19:04:01 UTC (rev 4582)
@@ -168,16 +168,25 @@
 		}
     }
 
-    void Container::removeItem(Item* item)
+    void Container::_doRemoveItem(Item* item)
     {
         ItemSet::iterator it = mItems.find(item);
         if (it != mItems.end())
         {
             mItems.erase(it);
             mItemPositions.erase(mItemPositions.find(item));
-            
-            // this is the case, if the item is removed automatically
-            // don't change this without looking at Item::setState
+        }
+        else
+        {
+            Throw(IllegalArgumentException, "Item not in Container.");
+        }
+    }
+
+    void Container::removeItem(Item* item)
+    {
+        ItemSet::iterator it = mItems.find(item);
+        if (it != mItems.end())
+        {
             item->removeOldState();
             item->setScene("");
         }

Modified: rl/branches/persistence/rules/src/Item.cpp
===================================================================
--- rl/branches/persistence/rules/src/Item.cpp	2008-11-08 12:55:50 UTC (rev 4581)
+++ rl/branches/persistence/rules/src/Item.cpp	2008-11-08 19:04:01 UTC (rev 4582)
@@ -95,7 +95,7 @@
         }
         if (mParentContainer != NULL)
         {
-            mParentContainer->removeItem(this);
+            mParentContainer->_doRemoveItem(this);
             mParentContainer = NULL;
         }
         if (mParentSlot != NULL)

Modified: rl/branches/persistence/ui/include/CombatGui.h
===================================================================
--- rl/branches/persistence/ui/include/CombatGui.h	2008-11-08 12:55:50 UTC (rev 4581)
+++ rl/branches/persistence/ui/include/CombatGui.h	2008-11-08 19:04:01 UTC (rev 4582)
@@ -73,6 +73,8 @@
 		/// Needed to only close it after combat if it was not shown before.
 		bool mGameLoggerWindowOpened;
 
+        bool mVisible;
+
         Ogre::FloatRect getScreenRectFromWorldAabb(const Ogre::AxisAlignedBox& aabb) const;
 	};
 }

Modified: rl/branches/persistence/ui/src/CombatGui.cpp
===================================================================
--- rl/branches/persistence/ui/src/CombatGui.cpp	2008-11-08 12:55:50 UTC (rev 4581)
+++ rl/branches/persistence/ui/src/CombatGui.cpp	2008-11-08 19:04:01 UTC (rev 4582)
@@ -37,7 +37,8 @@
 		  mCombat(combat),
 		  mCamera(camera),
 		  mUserInputEnabled(false),
-		  mGameLoggerWindowOpened(false)
+		  mGameLoggerWindowOpened(false),
+          mVisible(false)
     {
         mCombatWindow = WindowFactory::getSingleton().getCombatWindow();
 		mGameLoggerWindow = WindowFactory::getSingleton().getGameLogger();
@@ -68,7 +69,7 @@
         sceneMgr->getRootSceneNode()->createChildSceneNode()->attachObject(mHud);
 
 		// Create an attack/parry/(goto) button set for all opponents present at the beginning.
-        const Combat::CombatantSet& opponents = mCombat->getAllOpponents();
+        const Combat::CombatantSet& opponents = mCombat->getAllPlayerOpponents();
         for (Combat::CombatantSet::const_iterator it = opponents.begin(), end = opponents.end();
             it != end; ++it)
         {
@@ -82,6 +83,7 @@
 	CombatGui::~CombatGui()
 	{
 		hide();
+        mHud->getParentSceneNode()->detachObject(mHud);
         SceneManager* sceneMgr = CoreSubsystem::getSingleton().getWorld()->getSceneManager();
 		sceneMgr->destroyManualObject(mHud);
 	}
@@ -96,7 +98,7 @@
         mHud->clear();
 
         mHud->begin("alpha_red", RenderOperation::OT_LINE_LIST);
-        const Combat::CombatantSet& opponents = mCombat->getAllOpponents();
+        const Combat::CombatantSet& opponents = mCombat->getAllPlayerOpponents();
         for (Combat::CombatantSet::const_iterator it = opponents.begin(), end = opponents.end();
             it != end; ++it)
         {
@@ -160,16 +162,25 @@
 
 	void CombatGui::show()
 	{
-		mGameLoggerWindowOpened = !mGameLoggerWindow->isVisible();
-        mCombatWindow->setVisible(true);
-		mGameLoggerWindow->setVisible(true);
+        if (!mVisible)
+        {
+		    mGameLoggerWindowOpened = !mGameLoggerWindow->isVisible();
+            mCombatWindow->setVisible(true);
+		    mGameLoggerWindow->setVisible(true);
+            mHud->setVisible(true);
+            mVisible = true;
+        }
 	}
 
 	void CombatGui::hide()
 	{
-        mCombatWindow->setVisible(false);
-		mGameLoggerWindow->setVisible(!mGameLoggerWindowOpened);
-		mHud->clear();
+        if (mVisible)
+        {
+            mCombatWindow->setVisible(false);
+		    mGameLoggerWindow->setVisible(!mGameLoggerWindowOpened);
+            mHud->setVisible(false);
+            mVisible = false;
+        }
 	}
 
 	bool CombatGui::enemyButtonClicked(int handle, int buttonIndex)

Modified: rl/branches/persistence/ui/src/InputManager.cpp
===================================================================
--- rl/branches/persistence/ui/src/InputManager.cpp	2008-11-08 12:55:50 UTC (rev 4581)
+++ rl/branches/persistence/ui/src/InputManager.cpp	2008-11-08 19:04:01 UTC (rev 4582)
@@ -446,7 +446,10 @@
     {
         while (!mControlStates.empty())
         {
-            popControlState();
+            ControlState* controller = mControlStates.top();
+            mControlStates.pop();
+            controller->pause();
+            mFinishedControlStates.push_back(controller);
         }
     }
 



From timm at mail.berlios.de  Sun Nov  9 14:23:35 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 9 Nov 2008 14:23:35 +0100
Subject: [Dsa-hl-svn] r4583 - rl/branches/persistence/script/src
Message-ID: <200811091323.mA9DNZdl025187@sheep.berlios.de>

Author: timm
Date: 2008-11-09 14:23:29 +0100 (Sun, 09 Nov 2008)
New Revision: 4583

Modified:
   rl/branches/persistence/script/src/MapLoader.cpp
Log:
changed xml attribute scenescript -> mapscript

Modified: rl/branches/persistence/script/src/MapLoader.cpp
===================================================================
--- rl/branches/persistence/script/src/MapLoader.cpp	2008-11-08 19:04:01 UTC (rev 4582)
+++ rl/branches/persistence/script/src/MapLoader.cpp	2008-11-09 13:23:29 UTC (rev 4583)
@@ -163,7 +163,7 @@
 
                 LOG_MESSAGE(Logger::SCRIPT, "Map " + mapresource + " loaded");
 
-                if(hasAttribute(doc->getDocumentElement(), "scenescript"))
+                if(hasAttribute(doc->getDocumentElement(), "mapscript"))
                 {
                     if(getAttributeValueAsString(doc->getDocumentElement(), "scenescript").length() != 0)
                     {



From timm at mail.berlios.de  Sun Nov  9 14:35:12 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 9 Nov 2008 14:35:12 +0100
Subject: [Dsa-hl-svn] r4584 - rl/branches/persistence/script/src
Message-ID: <200811091335.mA9DZCTw026772@sheep.berlios.de>

Author: timm
Date: 2008-11-09 14:35:01 +0100 (Sun, 09 Nov 2008)
New Revision: 4584

Modified:
   rl/branches/persistence/script/src/MapLoader.cpp
Log:


Modified: rl/branches/persistence/script/src/MapLoader.cpp
===================================================================
--- rl/branches/persistence/script/src/MapLoader.cpp	2008-11-09 13:23:29 UTC (rev 4583)
+++ rl/branches/persistence/script/src/MapLoader.cpp	2008-11-09 13:35:01 UTC (rev 4584)
@@ -165,7 +165,7 @@
 
                 if(hasAttribute(doc->getDocumentElement(), "mapscript"))
                 {
-                    if(getAttributeValueAsString(doc->getDocumentElement(), "scenescript").length() != 0)
+                    if(getAttributeValueAsString(doc->getDocumentElement(), "mapscript").length() != 0)
                     {
                         if(!CoreSubsystem::getSingleton().getRubyInterpreter()->executeFile(getAttributeValueAsStdString(doc->getDocumentElement(), "scenescript")))
                             LOG_MESSAGE(Logger::SCRIPT, "Executed init script of map " + mapresource);



From timm at mail.berlios.de  Sun Nov  9 15:13:47 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 9 Nov 2008 15:13:47 +0100
Subject: [Dsa-hl-svn] r4585 - in rl/branches/persistence/core: include src
Message-ID: <200811091413.mA9EDlXb029215@sheep.berlios.de>

Author: timm
Date: 2008-11-09 15:13:40 +0100 (Sun, 09 Nov 2008)
New Revision: 4585

Modified:
   rl/branches/persistence/core/include/ContentModule.h
   rl/branches/persistence/core/src/ContentModule.cpp
Log:
ContentModule is not SaveGameData anymore

Modified: rl/branches/persistence/core/include/ContentModule.h
===================================================================
--- rl/branches/persistence/core/include/ContentModule.h	2008-11-09 13:35:01 UTC (rev 4584)
+++ rl/branches/persistence/core/include/ContentModule.h	2008-11-09 14:13:40 UTC (rev 4585)
@@ -24,7 +24,7 @@
 namespace rl
 {
 
-    class _RlCoreExport ContentModule : public SaveGameData
+    class _RlCoreExport ContentModule
 	{
 	public:
 		ContentModule(const Ogre::String& id, const CeGuiString& name, bool common, long minimumEngineVersion);
@@ -52,12 +52,6 @@
         bool isLoaded() const;
 
         void registerContentLoader(ContentLoader* loader);
-
-        CeGuiString getXmlNodeIdentifier() const;
-        void writeData(SaveGameFileWriter* writer);
-        void readData(SaveGameFileReader* reader);
-        /// defines the loading/saving order higher priority are saved last and loaded first
-        int getPriority() const;
 	private:
         typedef std::vector<ContentLoader*> ContentLoaderVector;
         ContentLoaderVector mContentLoaders;

Modified: rl/branches/persistence/core/src/ContentModule.cpp
===================================================================
--- rl/branches/persistence/core/src/ContentModule.cpp	2008-11-09 13:35:01 UTC (rev 4584)
+++ rl/branches/persistence/core/src/ContentModule.cpp	2008-11-09 14:13:40 UTC (rev 4585)
@@ -110,8 +110,6 @@
 
     void ContentModule::initialize()
     {
-        SaveGameManager::getSingleton().registerSaveGameData(this);
-
         Ogre::String moduleDir = getDirectory();
 
         Ogre::String resourceGroup = getId();
@@ -191,7 +189,6 @@
 
     void ContentModule::unload()
     {
-        SaveGameManager::getSingleton().unregisterSaveGameData(this);
         for(ContentLoaderVector::const_iterator it = mContentLoaders.begin(); it != mContentLoaders.end(); ++it)
         {
             (*it)->unloadContent();
@@ -211,38 +208,4 @@
     {
         mContentLoaders.push_back(loader);
     }
-
-    CeGuiString ContentModule::getXmlNodeIdentifier() const
-    {
-        return "ContentModule";
-    }
-
-    using namespace XERCES_CPP_NAMESPACE;
-
-    void ContentModule::writeData(SaveGameFileWriter* writer)
-    {
-        if(!this->isCommon())
-        {
-            LOG_MESSAGE(Logger::CORE, "Saving ContentLoaders");
-            DOMElement* contentLoadersNode = writer->appendChildElement(writer->getDocument(), writer->getDocument()->getDocumentElement(), getXmlNodeIdentifier().c_str());
-            writer->setAttributeValueAsString(contentLoadersNode, "name", mName);
-
-            for(ContentLoaderVector::const_iterator it = mContentLoaders.begin(); it != mContentLoaders.end(); ++it)
-            {
-                DOMElement* contentLoaderNode = writer->appendChildElement(writer->getDocument(), contentLoadersNode, "contentloader");
-                writer->setAttributeValueAsString(contentLoaderNode, "classname", Property((*it)->getClassName()));
-                writer->writeEachPropertyToElem(contentLoaderNode, (*it)->getAllProperties()->toPropertyMap());
-            }
-        }
-    }
-
-    void ContentModule::readData(SaveGameFileReader* reader)
-    {
-    }
-
-    /// defines the loading/saving order higher priority are saved last and loaded first
-    int ContentModule::getPriority() const
-    {
-        return 10;
-    }
 }



From fusion2 at mail.berlios.de  Thu Nov 13 20:03:35 2008
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Thu, 13 Nov 2008 20:03:35 +0100
Subject: [Dsa-hl-svn] r4586 - in rl/trunk/editors/Lockenwickler: . src
Message-ID: <200811131903.mADJ3Zn9022457@sheep.berlios.de>

Author: fusion2
Date: 2008-11-13 20:03:07 +0100 (Thu, 13 Nov 2008)
New Revision: 4586

Added:
   rl/trunk/editors/Lockenwickler/src/CodeDump.py
   rl/trunk/editors/Lockenwickler/src/GOIntEditor.py
   rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py
   rl/trunk/editors/Lockenwickler/src/Ui_GOPropertyEditorDialogINT.py
   rl/trunk/editors/Lockenwickler/src/Ui_NewModuleWizard.py
Removed:
   rl/trunk/editors/Lockenwickler/src/ui_pref_dialog.py
Modified:
   rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
   rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py
   rl/trunk/editors/Lockenwickler/src/GameObjectClass.py
   rl/trunk/editors/Lockenwickler/src/GameObjectClassManager.py
   rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
   rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
Log:
- lots of work on the new module handling (loading, saving, editing)


Modified: rl/trunk/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2008-11-09 14:13:40 UTC (rev 4585)
+++ rl/trunk/editors/Lockenwickler/Lockenwickler.e4p	2008-11-13 19:03:07 UTC (rev 4586)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Project SYSTEM "Project-4.5.dtd">
 <!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2008-10-31, 11:20:58 -->
+<!-- Saved: 2008-11-09, 21:48:49 -->
 <!-- Copyright (C) 2008 Stefan Stammberger, sstammberger at web.de -->
 <Project version="4.5">
   <ProgLanguage mixed="0">Python</ProgLanguage>
@@ -22,7 +22,6 @@
     <Source>src/PreferencesDialog.py</Source>
     <Source>src/PythonOgreConfig.py</Source>
     <Source>src/ui_ConsoleWindow.py</Source>
-    <Source>src/ui_pref_dialog.py</Source>
     <Source>src/SceneExplorer.py</Source>
     <Source>src/Property.py</Source>
     <Source>src/ViewportGrid.py</Source>
@@ -33,10 +32,14 @@
     <Source>src/GameObjectClassView.py</Source>
     <Source>src/MyRaySceneQueryListener.py</Source>
     <Source>src/GOStringEditor.py</Source>
+    <Source>src/GOIntEditor.py</Source>
+    <Source>src/CodeDump.py</Source>
+    <Source>src/NewModuleWizard.py</Source>
   </Sources>
   <Forms>
     <Form>ui files/GOPropertyEditorDialogINT.ui</Form>
     <Form>ui files/GOPropertyEditorDialogSTRING.ui</Form>
+    <Form>ui files/NewModuleWizard.ui</Form>
   </Forms>
   <Translations>
   </Translations>

Added: rl/trunk/editors/Lockenwickler/src/CodeDump.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/CodeDump.py	2008-11-09 14:13:40 UTC (rev 4585)
+++ rl/trunk/editors/Lockenwickler/src/CodeDump.py	2008-11-13 19:03:07 UTC (rev 4586)
@@ -0,0 +1,86 @@
+    #THIS IS A GENERAL CODE DUMB FOR DEPRECATED CODE
+
+
+    # parses the moduleconfig.rb and searches for all loader.loadmap(" statements in the ruby script
+    # and parses them too
+
+class old():
+
+
+
+    def setResourcePaths(self, path, moduleName):
+        for file in os.listdir(path):
+            curFile = path + "/" + file
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", moduleName, False)
+                self.setResourcePaths(curFile, moduleName)
+                continue
+            if isfile(curFile):
+                pass
+
+
+
+    def load(self,  moduleName,  mapFiles,  gofFiles):
+        self.moduleName = moduleName
+        self.mapFiles = mapFiles
+        self.gofFiles = gofFiles
+
+        self.gocManager.parseGOFFiles(self.gofFiles)
+
+        for a in self.mapFiles:
+            doc = xml.parse(a)
+            node = doc.getElementsByTagName("entity")
+            if node != None:
+                self.parseSceneNodes(node)
+
+        self.pivot = Pivot(self.sceneManager)
+        self.pivot.hide()
+
+    def parseSceneNodes(self,  nodeList):
+        for ent in nodeList:
+            entityName = ent.attributes["name"].nodeValue # get the name of the ent
+            meshFile = ent.attributes["meshfile"].nodeValue # meshfile
+            nodePosition = None
+            nodeRotation = None
+            nodeScale = None
+
+            for cn in ent.childNodes:
+                if cn.nodeType == cn.ELEMENT_NODE:
+                    if cn.localName == "position":
+                        px = float(cn.attributes["x"].nodeValue)
+                        py = float(cn.attributes["y"].nodeValue)
+                        pz = float(cn.attributes["z"].nodeValue)
+                        nodePosition = og.Vector3(px, py, pz)
+                        continue
+
+                    if cn.localName == "rotation":
+                        qw = float(cn.attributes["qw"].nodeValue)
+                        qx = float(cn.attributes["qx"].nodeValue)
+                        qy = float(cn.attributes["qy"].nodeValue)
+                        qz = float(cn.attributes["qz"].nodeValue)
+                        nodeRotation = og.Quaternion(qw,  qx, qy, qz)
+                        continue
+
+                    if cn.localName == "scale":
+                        px = float(cn.attributes["x"].nodeValue)
+                        py = float(cn.attributes["y"].nodeValue)
+                        pz = float(cn.attributes["z"].nodeValue)
+                        nodeScale = og.Vector3(px, py, pz)
+                        continue
+
+            try:
+                e = self.sceneManager.createEntity(entityName, meshFile)
+            except:
+                print "Warning: Meshfile " + meshFile + " could not be found."
+                return
+
+            n = self.sceneManager.getRootSceneNode().createChild(entityName + "_node")
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            #n.setOrientation(nodeRotation)
+            n.setScale(nodeScale)
+
+        pass

Modified: rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py	2008-11-09 14:13:40 UTC (rev 4585)
+++ rl/trunk/editors/Lockenwickler/src/ConsoleWindow.py	2008-11-13 19:03:07 UTC (rev 4586)
@@ -1,74 +1,74 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from ui_ConsoleWindow import *
-import ogre.renderer.OGRE as og
-
-
-
-class LockenLog(og.LogListener):
-    def __init__(self, logFunction):
-        og.LogListener.__init__(self)
-        self.logFunction = logFunction
-
-    def messageLogged(self, message, level, debug, logName):
-        self.logFunction(str(message))
-
-class ConsoleWindow(QtGui.QDialog):
-    def __init__(self, filterLog, parent=None):
-        QtGui.QDialog.__init__(self, parent)
-        self.filterLog = filterLog
-
-        self.consoleWindow = Ui_ConsoleWindow()
-        self.consoleWindow.setupUi(self)
-        self.consoleWindow.textEdit.setReadOnly(True)
-        self.lockenLog = LockenLog(self.write)
-
-        sys.stdout = self
-        sys.stderr = self
-
-        clearAction= QAction("Clear Window",  self)
-        self.consoleWindow.textEdit.addAction(clearAction)
-        self.consoleWindow.textEdit.setContextMenuPolicy(Qt.ActionsContextMenu)
-        clearAction.setShortcut("Ctrl + R")
-        self.connect(clearAction, SIGNAL("triggered()"), self.consoleWindow.textEdit.clear)
-
-
-    def write(self, text):
-        if self.filterLog:
-            if text.isspace():
-                return
-            elif text.startswith("Error"):
-                self.consoleWindow.textEdit.append(text)
-                return
-            elif text.startswith("OGRE EXCEPTION"):
-                self.consoleWindow.textEdit.append(text)
-                return
-            elif text.startswith("dbg:"):
-                self.consoleWindow.textEdit.append(text)
-                return
-        else:
-            self.consoleWindow.textEdit.append(text)
-
-    def clear(self):
-        self.consoleWindow.textEdit.clear()
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from ui_ConsoleWindow import *
+import ogre.renderer.OGRE as og
+
+
+
+class LockenLog(og.LogListener):
+    def __init__(self, logFunction):
+        og.LogListener.__init__(self)
+        self.logFunction = logFunction
+
+    def messageLogged(self, message, level, debug, logName):
+        self.logFunction(str(message))
+
+class ConsoleWindow(QtGui.QDialog):
+    def __init__(self, filterLog, parent=None):
+        QtGui.QDialog.__init__(self, parent)
+        self.filterLog = filterLog
+
+        self.consoleWindow = Ui_ConsoleWindow()
+        self.consoleWindow.setupUi(self)
+        self.consoleWindow.textEdit.setReadOnly(True)
+        self.lockenLog = LockenLog(self.write)
+
+        sys.stdout = self
+        sys.stderr = self
+
+        clearAction= QAction("Clear Window",  self)
+        self.consoleWindow.textEdit.addAction(clearAction)
+        self.consoleWindow.textEdit.setContextMenuPolicy(Qt.ActionsContextMenu)
+        clearAction.setShortcut("Ctrl + R")
+        self.connect(clearAction, SIGNAL("triggered()"), self.consoleWindow.textEdit.clear)
+
+
+    def write(self, text):
+        if self.filterLog:
+            if text.isspace():
+                return
+            elif text.startswith("Error"):
+                self.consoleWindow.textEdit.append(text)
+                return
+            elif text.startswith("OGRE EXCEPTION"):
+                self.consoleWindow.textEdit.append(text)
+                return
+            elif text.startswith("dbg:"):
+                self.consoleWindow.textEdit.append(text)
+                return
+        else:
+            self.consoleWindow.textEdit.append(text)
+
+    def clear(self):
+        self.consoleWindow.textEdit.clear()

Added: rl/trunk/editors/Lockenwickler/src/GOIntEditor.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GOIntEditor.py	2008-11-09 14:13:40 UTC (rev 4585)
+++ rl/trunk/editors/Lockenwickler/src/GOIntEditor.py	2008-11-13 19:03:07 UTC (rev 4586)
@@ -0,0 +1,37 @@
+# -*- coding: utf-8 -*-
+
+"""
+Module implementing GOIntEditor.
+"""
+
+from PyQt4.QtGui import QDialog
+from PyQt4.QtCore import pyqtSignature
+
+from Ui_GOPropertyEditorDialogINT import Ui_PropertyEditDialog
+
+class GOIntEditor(QDialog, Ui_PropertyEditDialog):
+    """
+    Class documentation goes here.
+    """
+    def __init__(self, parent = None):
+        """
+        Constructor
+        """
+        QDialog.__init__(self, parent)
+        self.setupUi(self)
+
+    @pyqtSignature("")
+    def on_buttonBox_accepted(self):
+        """
+        Slot documentation goes here.
+        """
+        # TODO: not implemented yet
+        #raise NotImplementedError
+
+    @pyqtSignature("")
+    def on_buttonBox_rejected(self):
+        """
+        Slot documentation goes here.
+        """
+        # TODO: not implemented yet
+        #raise NotImplementedError

Modified: rl/trunk/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2008-11-09 14:13:40 UTC (rev 4585)
+++ rl/trunk/editors/Lockenwickler/src/GameObjectClass.py	2008-11-13 19:03:07 UTC (rev 4586)
@@ -24,6 +24,7 @@
 import ogre.renderer.OGRE as og
 
 from GOStringEditor import *
+from GOIntEditor import *
 
 class GOCStringProperty():
     def __init__(self, name, data):
@@ -52,6 +53,17 @@
     def getType(self):
         return "REAL"
 
+    def openEditor(self, row, parent = None):
+        dlg = GOStringEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
 class GOCBoolProperty():
     def __init__(self, name, data):
         self.name = name
@@ -68,6 +80,17 @@
     def getType(self):
         return "INT"
 
+    def openEditor(self, row, parent = None):
+        dlg = GOIntEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
 class GOCIntPairProperty():
     def __init__(self, name, data):
         self.name = name

Modified: rl/trunk/editors/Lockenwickler/src/GameObjectClassManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/GameObjectClassManager.py	2008-11-09 14:13:40 UTC (rev 4585)
+++ rl/trunk/editors/Lockenwickler/src/GameObjectClassManager.py	2008-11-13 19:03:07 UTC (rev 4586)
@@ -1,52 +1,52 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-from elementtree.ElementTree import parse
-
-from GameObjectClass import *
-
-class GameObjectClassManager():
-    def __init__(self):
-        self.fileDict = {}
-        self.callback = None
-
-    def parseGOFFiles(self, filePaths):
-        for filePath in filePaths:
-            tree = parse(filePath)
-            gocList = []
-            for parent in tree.getiterator("gameobjectclass"): # return all allements with the "gameobjectclass" tag
-                go = GameObjectClass(parent)
-                gocList.append(go)
-
-            self.fileDict[filePath] = gocList
-
-        if self.callback is not None:
-            self.callback(self.fileDict)
-
-    def getGameObjectWithClassId(self, id):
-        for key in self.fileDict:
-            for go in self.fileDict[key]:
-                if go.classid == id:
-                    return go
-
-        return None
-
-        # whenever a gameobject changes outside of the view, the view has to update itself wth the new values
-    def setGameObjectsViewUpdateCallback(self, callback):
-        self.callback = callback
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+from elementtree.ElementTree import parse
+
+from GameObjectClass import *
+
+class GameObjectClassManager():
+    def __init__(self):
+        self.fileDict = {}
+        self.callback = None
+
+    def parseGOFFiles(self, filePaths):
+        for filePath in filePaths:
+            tree = parse(filePath)
+            gocList = []
+            for parent in tree.getiterator("gameobjectclass"): # return all allements with the "gameobjectclass" tag
+                go = GameObjectClass(parent)
+                gocList.append(go)
+
+            self.fileDict[filePath] = gocList
+
+        if self.callback is not None:
+            self.callback(self.fileDict)
+
+    def getGameObjectWithClassId(self, id):
+        for key in self.fileDict:
+            for go in self.fileDict[key]:
+                if go.classid == id:
+                    return go
+
+        return None
+
+        # whenever a gameobject changes outside of the view, the view has to update itself wth the new values
+    def setGameObjectsViewUpdateCallback(self, callback):
+        self.callback = callback
+

Modified: rl/trunk/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2008-11-09 14:13:40 UTC (rev 4585)
+++ rl/trunk/editors/Lockenwickler/src/Lockenwickler.py	2008-11-13 19:03:07 UTC (rev 4586)
@@ -25,7 +25,6 @@
 #import PythonOgreConfig
 
 from random import randint
-from os.path import isfile
 
 from PyQt4 import QtGui, QtCore
 from PreferencesDialog import *
@@ -35,6 +34,7 @@
 from ConsoleWindow import *
 from ModuleManager import *
 from SceneExplorer import *
+from NewModuleWizard import *
 
 import OgreMainWindow
 import ogre.renderer.OGRE as og
@@ -55,7 +55,7 @@
 
         self.setupOgre()
 
-        self.prefDialog = PreferencesDialog(self.loadModule, self)
+        self.prefDialog = PreferencesDialog(self)
         self.objectPropertyWin = ObjectPropertyWin(self)
         self.sceneExplorerWin = SceneExplorer(self)
         self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
@@ -70,9 +70,13 @@
         settings = QtCore.QSettings()
         self.restoreGeometry(settings.value("MainWindow/Geometry").toByteArray())
         self.restoreState(settings.value("MainWindow/DockWindows").toByteArray())
+        if not self.prefDialog.setCfgPath(settings.value("Preferences/moduleCfgPath").toString()):
+            self.prefDialog.show()
 
         self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
         self.setWindowTitle("Rastullahs Lockenwickler")
+
+
 #        # Import Psyco if available
 #        try:
 #            import psyco
@@ -82,8 +86,6 @@
 #        except ImportError:
 #            pass
 
-        #QtGui.QApplication.setKeyboardInputInterval(5000)
-
         splash.finish(self)
 
     def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
@@ -140,9 +142,12 @@
         self.setStatusBar(self.statusbar)
 
 #####################################
-        self.actionNeu =self.createAction("&New",  self.actionNewSlot,  QKeySequence.New,  "filenew.png",  "New")
+        self.actionNeu =self.createAction("&New Module",  self.actionNewSlot,  QKeySequence.New,  "filenew.png",  "New Module")
         self.actionNeu.setObjectName("actionNeu")
 
+        self.actionOpen = self.createAction("&Open Module",  self.actionOpenSlot,  QKeySequence.Open,  "filenew.png",  "Open Module")
+        self.actionOpen.setObjectName("actionOpen")
+
         self.actionClose = self.createAction("Quit",  self.actionQuitSlot,  "Alt + Q",  "exit.png",  "Quit")
         self.actionClose.setObjectName("actionQuit")
 #####################################
@@ -199,6 +204,7 @@
 
 
         self.menuFile.addAction(self.actionNeu)
+        self.menuFile.addAction(self.actionOpen)
         self.menuFile.addAction(self.actionClose)
 
         self.menuEdit.addAction(self.actionSelect)
@@ -229,7 +235,7 @@
         self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
         self.menuEdit.setTitle(QtGui.QApplication.translate("MainWindow", "Edit", None, QtGui.QApplication.UnicodeUTF8))
         self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "New", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "New Module", None, QtGui.QApplication.UnicodeUTF8))
         self.actionMove.setText(QtGui.QApplication.translate("MainWindow", "Move", None, QtGui.QApplication.UnicodeUTF8))
         self.actionRotate.setText(QtGui.QApplication.translate("MainWindow", "Rotate", None, QtGui.QApplication.UnicodeUTF8))
         self.actionSceneExplorer.setText(QtGui.QApplication.translate("MainWindow", "Scene Explorer", None, QtGui.QApplication.UnicodeUTF8))
@@ -271,15 +277,14 @@
         oglog.addListener(self.consoleWindow.lockenLog)
 
     def update(self):
-#        try:
-#            self.OgreMainWinSceneMgr.getSceneNode("saeule_076_node").yaw(0.02)
-#        except Exception,  e:
-#            pass
-
         self.ogreRoot.renderOneFrame()
 
+    def actionOpenSlot(self):
+        self.moduleManager.openLoadModuleDialog(self.prefDialog.lineEdit.text(), self)
+
     def actionNewSlot(self):
-        print "dbg: new"
+        newModuleWiz = NewModuleWizard(self)
+        newModuleWiz.exec_()
         return
 
     def actionQuitSlot(self):
@@ -345,79 +350,6 @@
         else:
             self.consoleDock.hide()
 
-    # parses the moduleconfig.rb and searches for all loader.loadmap(" statements in the ruby script
-    # and parses them too
-    def loadModule(self, modulePath, moduleName):
-        if self.moduleName == moduleName:
-            return
-
-        self.moduleName = moduleName
-        self.workingDir = modulePath + moduleName # the module path
-        self.workingDirCommon = modulePath + "common" # the module path of the common module
-
-        import codecs
-        import glob
-
-        modConfig = self.workingDir + "/scripts/moduleconfig.rb"
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
-        else:
-            print ("Error: couldn't find module config")
-            pass
-
-        self.mapFiles = [] # a list in case the module has more than one map file
-        self.gofFiles = [] # gof File list
-        for line in f:
-            lStripped = line.strip() #strip the whitespace away, not needed here
-
-            # get the map file(s)
-            if lStripped.startswith("loader.loadMap("): # all loadMap commands begin with loader.loadMap(
-                spl = lStripped.split('"')
-                for a in spl:
-                    if a.endswith(".xml"):
-                        pathToMapFile = self.workingDir + "/maps/" + a
-                        self.mapFiles.append(pathToMapFile)
-
-        self.setWindowTitle(moduleName)
-
-        self.modelSelectionDialog.scanDirForModels(self.workingDir, moduleName)
-        self.modelSelectionDialog.scanDirForModels(self.workingDirCommon, "common")
-
-        self.setResourcePaths(self.workingDir, moduleName)
-        self.setResourcePaths(self.workingDirCommon, "common")
-        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-        command = (os.path.join(self.workingDir,  "maps") + "/*.xml")
-        for mf in glob.glob(command): # search for all xml files in the maps directory and add them
-            self.mapFiles.append(mf)
-
-        command = (os.path.join(self.workingDir,  "maps") + "/*.scene")
-        for mf in glob.glob(command): # search for all .scene files in the maps directory and add them
-            self.mapFiles.append(mf)
-
-        command = (os.path.join(self.workingDir,  "dsa") + "/*.gof")
-        for gf in glob.glob(command): # search for all .gof files in the dsa directory in the module dir
-            self.gofFiles.append(gf)
-
-        command = (os.path.join(self.workingDirCommon,  "dsa") + "/*.gof")
-        for gf in glob.glob(command): # search for all .gof files in the dsa directory in the common module dir
-            self.gofFiles.append(gf)
-
-        self.moduleManager.load(moduleName,  self.mapFiles,  self.gofFiles)
-
-    def setResourcePaths(self, path, moduleName):
-        for file in os.listdir(path):
-            curFile = path + "/" + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", moduleName, False)
-                self.setResourcePaths(curFile, moduleName)
-                continue
-            if isfile(curFile):
-                pass
-
     def createDockWindows(self):
         self.propertyDock = QtGui.QDockWidget(self.tr("Properties"), self)
         self.propertyDock.setObjectName("PropertyDockWindow")
@@ -489,6 +421,7 @@
     def closeEvent(self,  event):
         if self.saveOnClose():
             settings = QtCore.QSettings()
+            settings.setValue("Preferences/moduleCfgPath", QtCore.QVariant(self.prefDialog.lineEdit.text()))
             settings.setValue("MainWindow/Geometry",  QtCore.QVariant(self.saveGeometry()))
             settings.setValue("MainWIndow/DockWindows",  QtCore.QVariant(self.saveState()))
         else:

Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2008-11-09 14:13:40 UTC (rev 4585)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2008-11-13 19:03:07 UTC (rev 4586)
@@ -17,16 +17,142 @@
  #################################################
 
 import sys
-import xml.dom.minidom as xml
+import codecs
+import glob
+import os
+from os.path import isfile,  join
 
+
+import elementtree.ElementTree as xml
+
 import ctypes
 import ogre.renderer.OGRE as og
 
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
 from MovePivot import *
 from GameObjectClassManager import *
 from MyRaySceneQueryListener import *
 
-class ModuleManager(object):
+class Map():
+    def __init__(self):
+        return
+
+class Scene():
+    def __init__(self):
+        return
+
+class Module():
+    def __init__(self,name, modulePath):
+        self.name = name
+        self.moduleRoot = join(modulePath, name)
+        self.__isCommon = False
+
+        self.hasDependencies = False
+        self.moduleDependencies = []
+
+        self.mapFiles = [] # a list in case the module has more than one map file
+        self.gofFiles = [] # gof File list
+
+    def isCommon(self):
+        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print ("Error: couldn't find module config")
+            return
+
+        for i, line in enumerate(f):
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith("super("):
+                split = lStripped.split(",")
+                if split[2].strip() == unicode("true"):
+                    self.__isCommon = True
+                    return True
+
+        return False
+
+    def load(self):
+        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print ("Error: couldn't find module config")
+            return
+
+        isDependencieLine = False
+
+        for i, line in enumerate(f):
+            lStripped = line.strip() #strip the whitespace away, not needed here
+
+            if isDependencieLine:
+                if lStripped == "end":
+                    isDependencieLine = False
+                else:
+                    self.moduleDependencies.append(lStripped.split('"')[1])
+
+            elif lStripped == "def getDependencies()":
+                isDependencieLine = True
+
+        self.setResourcePaths()
+
+    def setResourcePaths(self, recurseFolder = ""):
+        if recurseFolder == "":
+            rootFolder = self.moduleRoot
+        else:
+            rootFolder = join(self.moduleRoot, recurseFolder)
+
+        for file in os.listdir(rootFolder):
+            curFile = join(rootFolder, file)
+
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                continue
+            if os.path.isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
+                self.setResourcePaths(curFile)
+                continue
+            if os.path.isfile(curFile):
+                pass
+
+
+#                spl = lStripped.split('"')
+#                for a in spl:
+#                    if a.endswith(".xml"):
+#                        pathToMapFile = self.workingDir + "/maps/" + a
+#                        self.mapFiles.append(pathToMapFile)
+
+#        self.setWindowTitle(moduleName)
+#
+#        self.modelSelectionDialog.scanDirForModels(self.workingDir, moduleName)
+#        self.modelSelectionDialog.scanDirForModels(self.workingDirCommon, "common")
+#
+#        self.setResourcePaths(self.workingDir, moduleName)
+#        self.setResourcePaths(self.workingDirCommon, "common")
+#        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+#
+#        command = (os.path.join(self.workingDir,  "maps") + "/*.xml")
+#        for mf in glob.glob(command): # search for all xml files in the maps directory and add them
+#            self.mapFiles.append(mf)
+#
+#        command = (os.path.join(self.workingDir,  "maps") + "/*.scene")
+#        for mf in glob.glob(command): # search for all .scene files in the maps directory and add them
+#            self.mapFiles.append(mf)
+#
+#        command = (os.path.join(self.workingDir,  "dsa") + "/*.gof")
+#        for gf in glob.glob(command): # search for all .gof files in the dsa directory in the module dir
+#            self.gofFiles.append(gf)
+#
+#        command = (os.path.join(self.workingDirCommon,  "dsa") + "/*.gof")
+#        for gf in glob.glob(command): # search for all .gof files in the dsa directory in the common module dir
+#            self.gofFiles.append(gf)
+#
+#        self.moduleManager.load(moduleName,  self.mapFiles,  self.gofFiles)
+
+
+
+class ModuleManager():
     def __init__(self,  ogreRoot,  sceneManager):
         self.sceneManager = sceneManager
         self.ogreRoot = ogreRoot
@@ -34,6 +160,7 @@
 
         self.gocManager = GameObjectClassManager()
 
+        self.moduleList = []
         self.userSelectionList = []
         self.cutList = [] # selection objects that has been cut out and wait to be pasted again
         self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
@@ -61,69 +188,55 @@
         self.dropCollisionPlane = og.Plane(og.Vector3.UNIT_Y, og.Vector3.ZERO)
 
         self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
+        self.moduleConfigIsParsed = False
 
-    def load(self,  moduleName,  mapFiles,  gofFiles):
-        self.moduleName = moduleName
-        self.mapFiles = mapFiles
-        self.gofFiles = gofFiles
 
-        self.gocManager.parseGOFFiles(self.gofFiles)
+    def parseModuleConfig(self):
+        if self.moduleConfigIsParsed:
+            return
 
-        for a in self.mapFiles:
-            doc = xml.parse(a)
-            node = doc.getElementsByTagName("entity")
-            if node != None:
-                self.parseSceneNodes(node)
+        import codecs
+        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
 
-        self.pivot = Pivot(self.sceneManager)
-        self.pivot.hide()
+        for line in f:
+            if line.startswith('#'):
+                continue
 
-    def parseSceneNodes(self,  nodeList):
-        for ent in nodeList:
-            entityName = ent.attributes["name"].nodeValue # get the name of the ent
-            meshFile = ent.attributes["meshfile"].nodeValue # meshfile
-            nodePosition = None
-            nodeRotation = None
-            nodeScale = None
+            if line.startswith('module='):
+                splines = line.split('=')
+                str = splines[1].rstrip().rstrip()
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  "")))
 
-            for cn in ent.childNodes:
-                if cn.nodeType == cn.ELEMENT_NODE:
-                    if cn.localName == "position":
-                        px = float(cn.attributes["x"].nodeValue)
-                        py = float(cn.attributes["y"].nodeValue)
-                        pz = float(cn.attributes["z"].nodeValue)
-                        nodePosition = og.Vector3(px, py, pz)
-                        continue
+        self.moduleConfigIsParsed = True
 
-                    if cn.localName == "rotation":
-                        qw = float(cn.attributes["qw"].nodeValue)
-                        qx = float(cn.attributes["qx"].nodeValue)
-                        qy = float(cn.attributes["qy"].nodeValue)
-                        qz = float(cn.attributes["qz"].nodeValue)
-                        nodeRotation = og.Quaternion(qw,  qx, qy, qz)
-                        continue
+    def openLoadModuleDialog(self, moduleConfigPath, lw):
+        self.moduleCfgPath = str(moduleConfigPath)
+        self.moduleFolder = str(moduleConfigPath.replace("modules.cfg", ""))
 
-                    if cn.localName == "scale":
-                        px = float(cn.attributes["x"].nodeValue)
-                        py = float(cn.attributes["y"].nodeValue)
-                        pz = float(cn.attributes["z"].nodeValue)
-                        nodeScale = og.Vector3(px, py, pz)
-                        continue
+        self.parseModuleConfig()
 
-            try:
-                e = self.sceneManager.createEntity(entityName, meshFile)
-            except:
-                print "Warning: Meshfile " + meshFile + " could not be found."
-                return
+        dlg = QDialog()
+        list = QListWidget()
+        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
+        dlg.connect(btnBox, SIGNAL("rejected()"), dlg.reject)
 
-            n = self.sceneManager.getRootSceneNode().createChild(entityName + "_node")
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            #n.setOrientation(nodeRotation)
-            n.setScale(nodeScale)
+        for m in self.moduleList:
+            if not m.isCommon():
+                list.addItem(m.name)
 
-        pass
+        layout = QVBoxLayout()
+        layout.addWidget(list)
+        layout.addWidget(btnBox)
+        dlg.setLayout(layout)
+        if dlg.exec_():
+            self.loadModule(list.currentItem().text())
 
+    def loadModule(self, moduleName):
+        for m in self.moduleList:
+            if m.name == moduleName:
+                m.load()
+
     # called when a click into Main Ogre Window occurs
     def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
         self.listenerDings.reset()
@@ -276,6 +389,7 @@
             so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
             self.cutList.append(so)
         self.resetSelection()
+
     def pasteObjects(self,  ray):
         if len(self.cutList) < 1:
             return
@@ -299,11 +413,6 @@
         if self.pivot is not None and self.pivot.isTransforming:
             self.pivot.stopTransforming()
 
-#    def iterateEntityUnderMouse(self):
-#        self.listenerDings.iterateEntityUnderMouse()
-#
-#        pass
-
     def resetSelection(self):
         for so in self.userSelectionList:
             so.setSelected(False)

Added: rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py	2008-11-09 14:13:40 UTC (rev 4585)
+++ rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py	2008-11-13 19:03:07 UTC (rev 4586)
@@ -0,0 +1,48 @@
+# -*- coding: utf-8 -*-
+
+"""
+Module implementing NewModuleWizard.
+"""
+
+from PyQt4.QtGui import QDialog
+from PyQt4.QtCore import pyqtSignature
+
+from Ui_NewModuleWizard import Ui_Dialog
+
+class NewModuleWizard(QDialog, Ui_Dialog):
+    """
+    Class documentation goes here.
+    """
+    def __init__(self, moduleManager, parent = None):
+        """
+        Constructor
+        """
+
+        self.moduleManager = moduleManager
+
+        QDialog.__init__(self, parent)
+        self.setupUi(self)
+
+    @pyqtSignature("QString")
+    def on_moduleNameLineEdit_textChanged(self, p0):
+        return
+        # TODO: not implemented yet
+        #raise NotImplementedError
+
+    @pyqtSignature("")
+    def on_moduleNameLineEdit_returnPressed(self):
+
+        # TODO: not implemented yet
+        raise NotImplementedError
+
+    @pyqtSignature("")
+    def on_okButton_clicked(self):
+
+        # TODO: not implemented yet
+        raise NotImplementedError
+
+    @pyqtSignature("")
+    def on_cancelButton_pressed(self):
+        self.close()
+
+

Modified: rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2008-11-09 14:13:40 UTC (rev 4585)
+++ rl/trunk/editors/Lockenwickler/src/PreferencesDialog.py	2008-11-13 19:03:07 UTC (rev 4586)
@@ -1,106 +1,89 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import platform
-import string
-from ui_pref_dialog import *
-
-class PreferencesDialog(QtGui.QDialog):
-    def __init__(self, loadModuleCallback, parent=None):
-        QtGui.QDialog.__init__(self, parent)
-
-        self.loadModuleCallback = loadModuleCallback
-
-        self.prefDialog = Ui_PreferencesDialog()
-        self.prefDialog.setupUi(self)
-
-        QtCore.QObject.connect(self.prefDialog.modulConfigSelector, QtCore.SIGNAL("clicked()"),
-                               self.openModulConfigSelector)
-
-        QtCore.QObject.connect(self.prefDialog.loadModuleBtn, QtCore.SIGNAL("clicked()"),
-                               self.onLoadSelectedModule)
-
-        QtCore.QObject.connect(self.prefDialog.listWidget, QtCore.SIGNAL("itemDoubleClicked(QListWidgetItem *)"),
-                               self.onLoadSelectedModule)
-
-        if platform.system() == "Windows" or platform.system() == "MAC":
-            pass
-            # TODO: delete this when ready
-            self.prefDialog.lineEdit.setText("C:/a11/modules/modules.cfg")
-            self.moduleCfgPath = 'C:/a11/modules/modules.cfg'
-            self.moduleCfgIsSelected = True
-            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
-            self.readInModules()
-            # end delete
-        else:
-            # TODO: delete this when ready
-            self.prefDialog.lineEdit.setText("/home/stefan/blubb/rl_modules/modules/modules.cfg")
-            self.moduleCfgPath = "/home/stefan/blubb/rl_modules/modules/modules.cfg"
-            self.moduleCfgIsSelected = True
-            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
-            self.readInModules()
-            # end delete
-
-        self.moduleCfgIsSelected = False
-
-        self.setModal(True)
-
-    def openModulConfigSelector(self):
-        dialog = QtGui.QFileDialog(self)
-        self.moduleCfgPath = str(dialog.getOpenFileName(self, "Select modules.cfg", "/home/stefan/blubb/rl_modules/modules/", "modules.cfg (*.cfg)"))
-        self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
-
-        from os.path import isfile
-
-        if isfile(self.moduleCfgPath):
-            self.prefDialog.lineEdit.setText(self.moduleCfgPath)
-            self.moduleCfgIsSelected = True
-            self.readInModules()
-
-    def readInModules(self):
-        if self.moduleCfgIsSelected:
-            import codecs
-            f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
-
-            for line in f:
-                if line.startswith('#'):
-                    continue
-
-                if line.startswith('module='):
-                    splines = line.split('=')
-                    str = splines[1].rstrip().rstrip()
-                    if str != "common":
-                        self.prefDialog.listWidget.addItem(str)
-
-    def onLoadSelectedModule(self):
-        item = self.prefDialog.listWidget.currentItem()
-
-        if item == None:
-            mbox = QtGui.QMessageBox(self)
-            mbox.setModal(True)
-            mbox.setText("Please select a module.")
-            mbox.show()
-        else:
-            tempo = str(item.text())
-            self.loadModuleCallback(self.modulePath, tempo)
-            self.hide()
-
-
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import platform
+import string
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+class PreferencesDialog(QDialog):
+    def __init__(self, parent=None):
+        QDialog.__init__(self, parent)
+
+        self.label = QLabel()
+        self.label.setText("Please select the modules.cfg file.")
+        self.modulConfigSelector = QPushButton()
+        self.modulConfigSelector.setText("...")
+        self.lineEdit = QLineEdit()
+
+        layout = QGridLayout()
+        layout.addWidget(self.label, 0, 0, 1, 2)
+        layout.addWidget(self.lineEdit, 1, 0)
+        layout.addWidget(self.modulConfigSelector, 1, 1)
+
+        self.setLayout(layout)
+
+        QObject.connect(self.modulConfigSelector, SIGNAL("clicked()"),
+                               self.openModulConfigSelector)
+
+        self.setModal(True)
+
+    def setCfgPath(self, inPath):
+        path = str(inPath)
+
+        from os.path import isfile
+
+        if isfile(path):
+            self.moduleCfgPath = path
+            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
+            self.lineEdit.setText(self.moduleCfgPath)
+            return True
+        else:
+            return False
+
+    def openModulConfigSelector(self):
+        dialog = QFileDialog(self)
+        self.moduleCfgPath = str(dialog.getOpenFileName(self, "Select modules.cfg", "/home/stefan/blubb/rl_modules/modules/", "modules.cfg (*.cfg)"))
+        self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
+
+        from os.path import isfile
+
+        if isfile(self.moduleCfgPath):
+            self.lineEdit.setText(self.moduleCfgPath)
+
+
+
+    def onLoadSelectedModule(self):
+        item = self.prefDialog.listWidget.currentItem()
+
+        if item == None:
+            mbox = QMessageBox(self)
+            mbox.setModal(True)
+            mbox.setText("Please select a module.")
+            mbox.show()
+        else:
+            tempo = str(item.text())
+            self.loadModuleCallback(self.modulePath, tempo)
+            self.hide()
+
+    def getModuleConfigPath(self):
+        return self.lineEdit
+

Added: rl/trunk/editors/Lockenwickler/src/Ui_GOPropertyEditorDialogINT.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Ui_GOPropertyEditorDialogINT.py	2008-11-09 14:13:40 UTC (rev 4585)
+++ rl/trunk/editors/Lockenwickler/src/Ui_GOPropertyEditorDialogINT.py	2008-11-13 19:03:07 UTC (rev 4586)
@@ -0,0 +1,86 @@
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file '/home/stefan/Lockenwickler/ui files/GOPropertyEditorDialogINT.ui'
+#
+# Created: Sat Nov  8 16:24:03 2008
+#      by: PyQt4 UI code generator 4.4.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_PropertyEditDialog(object):
+    def setupUi(self, PropertyEditDialog):
+        PropertyEditDialog.setObjectName("PropertyEditDialog")
+        PropertyEditDialog.setWindowModality(QtCore.Qt.ApplicationModal)
+        PropertyEditDialog.resize(464, 93)
+        self.gridLayout = QtGui.QGridLayout(PropertyEditDialog)
+        self.gridLayout.setObjectName("gridLayout")
+        self.label = QtGui.QLabel(PropertyEditDialog)
+        self.label.setObjectName("label")
+        self.gridLayout.addWidget(self.label, 0, 0, 1, 1)
+        self.label_2 = QtGui.QLabel(PropertyEditDialog)
+        self.label_2.setObjectName("label_2")
+        self.gridLayout.addWidget(self.label_2, 0, 1, 1, 1)
+        self.label_3 = QtGui.QLabel(PropertyEditDialog)
+        self.label_3.setObjectName("label_3")
+        self.gridLayout.addWidget(self.label_3, 0, 2, 1, 1)
+        self.nameEdit = QtGui.QLineEdit(PropertyEditDialog)
+        self.nameEdit.setMinimumSize(QtCore.QSize(120, 0))
+        self.nameEdit.setMaximumSize(QtCore.QSize(250, 16777215))
+        self.nameEdit.setObjectName("nameEdit")
+        self.gridLayout.addWidget(self.nameEdit, 1, 0, 1, 1)
+        self.comboBox = QtGui.QComboBox(PropertyEditDialog)
+        self.comboBox.setObjectName("comboBox")
+        self.comboBox.addItem(QtCore.QString())
+        self.comboBox.addItem(QtCore.QString())
+        self.comboBox.addItem(QtCore.QString())
+        self.comboBox.addItem(QtCore.QString())
+        self.comboBox.addItem(QtCore.QString())
+        self.comboBox.addItem(QtCore.QString())
+        self.comboBox.addItem(QtCore.QString())
+        self.comboBox.addItem(QtCore.QString())
+        self.gridLayout.addWidget(self.comboBox, 1, 1, 1, 1)
+        self.dataEdit = QtGui.QLineEdit(PropertyEditDialog)
+        self.dataEdit.setMinimumSize(QtCore.QSize(120, 0))
+        self.dataEdit.setObjectName("dataEdit")
+        self.gridLayout.addWidget(self.dataEdit, 1, 2, 1, 1)
+        self.buttonBox = QtGui.QDialogButtonBox(PropertyEditDialog)
+        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
+        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.Ok)
+        self.buttonBox.setObjectName("buttonBox")
+        self.gridLayout.addWidget(self.buttonBox, 2, 0, 1, 3)
+        self.label.setBuddy(self.nameEdit)
+        self.label_2.setBuddy(self.comboBox)
+        self.label_3.setBuddy(self.dataEdit)
+
+        self.retranslateUi(PropertyEditDialog)
+        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL("accepted()"), PropertyEditDialog.accept)
+        QtCore.QObject.connect(self.buttonBox, QtCore.SIGNAL("rejected()"), PropertyEditDialog.reject)
+        QtCore.QMetaObject.connectSlotsByName(PropertyEditDialog)
+
+    def retranslateUi(self, PropertyEditDialog):
+        PropertyEditDialog.setWindowTitle(QtGui.QApplication.translate("PropertyEditDialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
+        self.label.setText(QtGui.QApplication.translate("PropertyEditDialog", "&Name", None, QtGui.QApplication.UnicodeUTF8))
+        self.label_2.setText(QtGui.QApplication.translate("PropertyEditDialog", "&Type", None, QtGui.QApplication.UnicodeUTF8))
+        self.label_3.setText(QtGui.QApplication.translate("PropertyEditDialog", "&Data", None, QtGui.QApplication.UnicodeUTF8))
+        self.comboBox.setItemText(0, QtGui.QApplication.translate("PropertyEditDialog", "INT", None, QtGui.QApplication.UnicodeUTF8))
+        self.comboBox.setItemText(1, QtGui.QApplication.translate("PropertyEditDialog", "STRING", None, QtGui.QApplication.UnicodeUTF8))
+        self.comboBox.setItemText(2, QtGui.QApplication.translate("PropertyEditDialog", "BOOL", None, QtGui.QApplication.UnicodeUTF8))
+        self.comboBox.setItemText(3, QtGui.QApplication.translate("PropertyEditDialog", "INTPAIR", None, QtGui.QApplication.UnicodeUTF8))
+        self.comboBox.setItemText(4, QtGui.QApplication.translate("PropertyEditDialog", "INTTRIPPLE", None, QtGui.QApplication.UnicodeUTF8))
+        self.comboBox.setItemText(5, QtGui.QApplication.translate("PropertyEditDialog", "REAL", None, QtGui.QApplication.UnicodeUTF8))
+        self.comboBox.setItemText(6, QtGui.QApplication.translate("PropertyEditDialog", "MAP", None, QtGui.QApplication.UnicodeUTF8))
+        self.comboBox.setItemText(7, QtGui.QApplication.translate("PropertyEditDialog", "ARRAY", None, QtGui.QApplication.UnicodeUTF8))
+        self.dataEdit.setInputMask(QtGui.QApplication.translate("PropertyEditDialog", "999999999999999999999999999999; ", None, QtGui.QApplication.UnicodeUTF8))
+
+
+if __name__ == "__main__":
+    import sys
+    app = QtGui.QApplication(sys.argv)
+    PropertyEditDialog = QtGui.QDialog()
+    ui = Ui_PropertyEditDialog()
+    ui.setupUi(PropertyEditDialog)
+    PropertyEditDialog.show()
+    sys.exit(app.exec_())
+

Added: rl/trunk/editors/Lockenwickler/src/Ui_NewModuleWizard.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/Ui_NewModuleWizard.py	2008-11-09 14:13:40 UTC (rev 4585)
+++ rl/trunk/editors/Lockenwickler/src/Ui_NewModuleWizard.py	2008-11-13 19:03:07 UTC (rev 4586)
@@ -0,0 +1,100 @@
+# -*- coding: utf-8 -*-
+
+# Form implementation generated from reading ui file '/home/stefan/Lockenwickler/ui files/NewModuleWizard.ui'
+#
+# Created: Sun Nov  9 14:15:16 2008
+#      by: PyQt4 UI code generator 4.4.3
+#
+# WARNING! All changes made in this file will be lost!
+
+from PyQt4 import QtCore, QtGui
+
+class Ui_Dialog(object):
+    def setupUi(self, Dialog):
+        Dialog.setObjectName("Dialog")
+        Dialog.resize(675, 703)
+        self.gridLayout_3 = QtGui.QGridLayout(Dialog)
+        self.gridLayout_3.setObjectName("gridLayout_3")
+        self.label = QtGui.QLabel(Dialog)
+        self.label.setObjectName("label")
+        self.gridLayout_3.addWidget(self.label, 0, 0, 1, 1)
+        self.moduleNameLineEdit = QtGui.QLineEdit(Dialog)
+        self.moduleNameLineEdit.setObjectName("moduleNameLineEdit")
+        self.gridLayout_3.addWidget(self.moduleNameLineEdit, 0, 1, 1, 1)
+        self.label_2 = QtGui.QLabel(Dialog)
+        self.label_2.setObjectName("label_2")
+        self.gridLayout_3.addWidget(self.label_2, 1, 0, 1, 1)
+        self.sceneNameLineEdit = QtGui.QLineEdit(Dialog)
+        self.sceneNameLineEdit.setEnabled(False)
+        self.sceneNameLineEdit.setObjectName("sceneNameLineEdit")
+        self.gridLayout_3.addWidget(self.sceneNameLineEdit, 1, 1, 1, 1)
+        self.label_3 = QtGui.QLabel(Dialog)
+        self.label_3.setObjectName("label_3")
+        self.gridLayout_3.addWidget(self.label_3, 2, 0, 1, 1)
+        self.mapNameLineEdit = QtGui.QLineEdit(Dialog)
+        self.mapNameLineEdit.setEnabled(False)
+        self.mapNameLineEdit.setObjectName("mapNameLineEdit")
+        self.gridLayout_3.addWidget(self.mapNameLineEdit, 2, 1, 1, 1)
+        self.groupBox = QtGui.QGroupBox(Dialog)
+        self.groupBox.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
+        self.groupBox.setObjectName("groupBox")
+        self.gridLayout_2 = QtGui.QGridLayout(self.groupBox)
+        self.gridLayout_2.setObjectName("gridLayout_2")
+        self.moduleDependenciesList = QtGui.QListView(self.groupBox)
+        self.moduleDependenciesList.setEnabled(False)
+        self.moduleDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
+        self.moduleDependenciesList.setObjectName("moduleDependenciesList")
+        self.gridLayout_2.addWidget(self.moduleDependenciesList, 1, 0, 1, 1)
+        self.gridLayout_3.addWidget(self.groupBox, 3, 0, 1, 2)
+        self.groupBox_2 = QtGui.QGroupBox(Dialog)
+        self.groupBox_2.setObjectName("groupBox_2")
+        self.gridLayout = QtGui.QGridLayout(self.groupBox_2)
+        self.gridLayout.setObjectName("gridLayout")
+        self.scriptDependenciesList = QtGui.QListView(self.groupBox_2)
+        self.scriptDependenciesList.setEnabled(False)
+        self.scriptDependenciesList.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
+        self.scriptDependenciesList.setObjectName("scriptDependenciesList")
+        self.gridLayout.addWidget(self.scriptDependenciesList, 0, 0, 1, 1)
+        self.gridLayout_3.addWidget(self.groupBox_2, 4, 0, 1, 2)
+        self.hboxlayout = QtGui.QHBoxLayout()
+        self.hboxlayout.setSpacing(6)
+        self.hboxlayout.setMargin(0)
+        self.hboxlayout.setObjectName("hboxlayout")
+        spacerItem = QtGui.QSpacerItem(131, 31, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
+        self.hboxlayout.addItem(spacerItem)
+        self.okButton = QtGui.QPushButton(Dialog)
+        self.okButton.setEnabled(False)
+        self.okButton.setObjectName("okButton")
+        self.hboxlayout.addWidget(self.okButton)
+        self.cancelButton = QtGui.QPushButton(Dialog)
+        self.cancelButton.setObjectName("cancelButton")
+        self.hboxlayout.addWidget(self.cancelButton)
+        self.gridLayout_3.addLayout(self.hboxlayout, 5, 0, 1, 2)
+
+        self.retranslateUi(Dialog)
+        QtCore.QObject.connect(self.okButton, QtCore.SIGNAL("clicked()"), Dialog.accept)
+        QtCore.QObject.connect(self.cancelButton, QtCore.SIGNAL("clicked()"), Dialog.reject)
+        QtCore.QMetaObject.connectSlotsByName(Dialog)
+
+    def retranslateUi(self, Dialog):
+        Dialog.setWindowTitle(QtGui.QApplication.translate("Dialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
+        self.label.setText(QtGui.QApplication.translate("Dialog", "Step 1: Module Name", None, QtGui.QApplication.UnicodeUTF8))
+        self.label_2.setText(QtGui.QApplication.translate("Dialog", "Step 2: Scene Name", None, QtGui.QApplication.UnicodeUTF8))
+        self.label_3.setText(QtGui.QApplication.translate("Dialog", "Step 3: Map Name", None, QtGui.QApplication.UnicodeUTF8))
+        self.groupBox.setTitle(QtGui.QApplication.translate("Dialog", "Step 4: Module Dependencies", None, QtGui.QApplication.UnicodeUTF8))
+        self.moduleDependenciesList.setToolTip(QtGui.QApplication.translate("Dialog", "Modules the new module will depend on", None, QtGui.QApplication.UnicodeUTF8))
+        self.groupBox_2.setTitle(QtGui.QApplication.translate("Dialog", "Step 5: Script Dependencies", None, QtGui.QApplication.UnicodeUTF8))
+        self.scriptDependenciesList.setToolTip(QtGui.QApplication.translate("Dialog", "Modules the new module will depend on", None, QtGui.QApplication.UnicodeUTF8))
+        self.okButton.setText(QtGui.QApplication.translate("Dialog", "&OK", None, QtGui.QApplication.UnicodeUTF8))
+        self.cancelButton.setText(QtGui.QApplication.translate("Dialog", "&Cancel", None, QtGui.QApplication.UnicodeUTF8))
+
+
+if __name__ == "__main__":
+    import sys
+    app = QtGui.QApplication(sys.argv)
+    Dialog = QtGui.QDialog()
+    ui = Ui_Dialog()
+    ui.setupUi(Dialog)
+    Dialog.show()
+    sys.exit(app.exec_())
+

Deleted: rl/trunk/editors/Lockenwickler/src/ui_pref_dialog.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ui_pref_dialog.py	2008-11-09 14:13:40 UTC (rev 4585)
+++ rl/trunk/editors/Lockenwickler/src/ui_pref_dialog.py	2008-11-13 19:03:07 UTC (rev 4586)
@@ -1,85 +0,0 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'preferences_dialog.ui'
-#
-# Created: Mon Jun 23 19:28:46 2008
-#      by: PyQt4 UI code generator 4.3.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
-
-class Ui_PreferencesDialog(object):
-    def setupUi(self, PreferencesDialog):
-        PreferencesDialog.setObjectName("PreferencesDialog")
-        PreferencesDialog.resize(QtCore.QSize(QtCore.QRect(0,0,528,626).size()).expandedTo(PreferencesDialog.minimumSizeHint()))
-
-        self.gridlayout = QtGui.QGridLayout(PreferencesDialog)
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.toolBox = QtGui.QToolBox(PreferencesDialog)
-        self.toolBox.setObjectName("toolBox")
-
-        self.ResourcePaths = QtGui.QWidget()
-        self.ResourcePaths.setGeometry(QtCore.QRect(0,0,510,505))
-        self.ResourcePaths.setObjectName("ResourcePaths")
-
-        self.gridlayout1 = QtGui.QGridLayout(self.ResourcePaths)
-        self.gridlayout1.setObjectName("gridlayout1")
-
-        self.listWidget = QtGui.QListWidget(self.ResourcePaths)
-        self.listWidget.setObjectName("listWidget")
-        self.gridlayout1.addWidget(self.listWidget,0,0,1,1)
-
-        self.groupBox = QtGui.QGroupBox(self.ResourcePaths)
-        self.groupBox.setMinimumSize(QtCore.QSize(0,95))
-        self.groupBox.setObjectName("groupBox")
-
-        self.layoutWidget = QtGui.QWidget(self.groupBox)
-        self.layoutWidget.setGeometry(QtCore.QRect(10,20,471,67))
-        self.layoutWidget.setObjectName("layoutWidget")
-
-        self.gridlayout2 = QtGui.QGridLayout(self.layoutWidget)
-        self.gridlayout2.setObjectName("gridlayout2")
-
-        self.lineEdit = QtGui.QLineEdit(self.layoutWidget)
-        self.lineEdit.setObjectName("lineEdit")
-        self.gridlayout2.addWidget(self.lineEdit,0,0,1,1)
-
-        self.loadModuleBtn = QtGui.QPushButton(self.layoutWidget)
-        self.loadModuleBtn.setObjectName("loadModuleBtn")
-        self.gridlayout2.addWidget(self.loadModuleBtn,1,0,1,2)
-
-        self.modulConfigSelector = QtGui.QPushButton(self.layoutWidget)
-        self.modulConfigSelector.setObjectName("modulConfigSelector")
-        self.gridlayout2.addWidget(self.modulConfigSelector,0,1,1,1)
-        self.gridlayout1.addWidget(self.groupBox,1,0,1,1)
-        self.toolBox.addItem(self.ResourcePaths,"")
-
-        self.OgreSettings = QtGui.QWidget()
-        self.OgreSettings.setGeometry(QtCore.QRect(0,0,96,26))
-        self.OgreSettings.setObjectName("OgreSettings")
-        self.toolBox.addItem(self.OgreSettings,"")
-        self.gridlayout.addWidget(self.toolBox,0,0,1,1)
-
-        self.buttonBox = QtGui.QDialogButtonBox(PreferencesDialog)
-        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
-        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.NoButton|QtGui.QDialogButtonBox.Ok)
-        self.buttonBox.setObjectName("buttonBox")
-        self.gridlayout.addWidget(self.buttonBox,1,0,1,1)
-
-        self.retranslateUi(PreferencesDialog)
-        self.toolBox.setCurrentIndex(0)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("accepted()"),PreferencesDialog.accept)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("rejected()"),PreferencesDialog.reject)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("clicked(QAbstractButton*)"),PreferencesDialog.close)
-        QtCore.QMetaObject.connectSlotsByName(PreferencesDialog)
-
-    def retranslateUi(self, PreferencesDialog):
-        PreferencesDialog.setWindowTitle(QtGui.QApplication.translate("PreferencesDialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
-        self.groupBox.setTitle(QtGui.QApplication.translate("PreferencesDialog", "GroupBox", None, QtGui.QApplication.UnicodeUTF8))
-        self.loadModuleBtn.setText(QtGui.QApplication.translate("PreferencesDialog", "Load Selected Module", None, QtGui.QApplication.UnicodeUTF8))
-        self.modulConfigSelector.setText(QtGui.QApplication.translate("PreferencesDialog", "...", None, QtGui.QApplication.UnicodeUTF8))
-        self.toolBox.setItemText(self.toolBox.indexOf(self.ResourcePaths), QtGui.QApplication.translate("PreferencesDialog", "Resource Paths", None, QtGui.QApplication.UnicodeUTF8))
-        self.toolBox.setItemText(self.toolBox.indexOf(self.OgreSettings), QtGui.QApplication.translate("PreferencesDialog", "Ogre Settings", None, QtGui.QApplication.UnicodeUTF8))
-



From timm at mail.berlios.de  Sat Nov 15 11:12:58 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sat, 15 Nov 2008 11:12:58 +0100
Subject: [Dsa-hl-svn] r4587 - in modules/kanalisation: maps scripts/maps
Message-ID: <200811151012.mAFACwQt022567@sheep.berlios.de>

Author: timm
Date: 2008-11-15 11:12:49 +0100 (Sat, 15 Nov 2008)
New Revision: 4587

Added:
   modules/kanalisation/maps/kanalisation.rlscene
Removed:
   modules/kanalisation/maps/kanalisation.lrscene
Modified:
   modules/kanalisation/scripts/maps/kanalisation.rb
   modules/kanalisation/scripts/maps/setchar.rb
Log:
- fixed naming of scene file
- fixed init scripts

Deleted: modules/kanalisation/maps/kanalisation.lrscene
===================================================================
--- modules/kanalisation/maps/kanalisation.lrscene	2008-11-13 19:03:07 UTC (rev 4586)
+++ modules/kanalisation/maps/kanalisation.lrscene	2008-11-15 10:12:49 UTC (rev 4587)
@@ -1,5 +0,0 @@
-<scene name="kanalisation">
-	<map file="kana_lights.rlmap.xml"/>
-	<map file="kanalisation.rlmap.xml"/>
-	<map file="hero.rlmap.xml"/>
-</scene>
\ No newline at end of file

Copied: modules/kanalisation/maps/kanalisation.rlscene (from rev 4580, modules/kanalisation/maps/kanalisation.lrscene)


Property changes on: modules/kanalisation/maps/kanalisation.rlscene
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: modules/kanalisation/scripts/maps/kanalisation.rb
===================================================================
--- modules/kanalisation/scripts/maps/kanalisation.rb	2008-11-13 19:03:07 UTC (rev 4586)
+++ modules/kanalisation/scripts/maps/kanalisation.rb	2008-11-15 10:12:49 UTC (rev 4587)
@@ -51,5 +51,4 @@
 #$SCRIPT.log("Fackellicht erstellt.");
 
 load "particle.rb"
-load "equip.rb"
 

Modified: modules/kanalisation/scripts/maps/setchar.rb
===================================================================
--- modules/kanalisation/scripts/maps/setchar.rb	2008-11-13 19:03:07 UTC (rev 4586)
+++ modules/kanalisation/scripts/maps/setchar.rb	2008-11-15 10:12:49 UTC (rev 4587)
@@ -19,3 +19,5 @@
 hero.getInventory().hold(itemToAdd, "Clothes");
 itemToAdd = $GOM.createGameObject("men_human_female_feet_boots_01");
 hero.getInventory().hold(itemToAdd, "Boots");
+
+load "equip.rb"



From fusion2 at mail.berlios.de  Sat Nov 15 13:49:46 2008
From: fusion2 at mail.berlios.de (fusion2 at mail.berlios.de)
Date: Sat, 15 Nov 2008 13:49:46 +0100
Subject: [Dsa-hl-svn] r4588 - rl/trunk/editors/Lockenwickler/src
Message-ID: <200811151249.mAFCnkVR030276@sheep.berlios.de>

Author: fusion2
Date: 2008-11-15 13:49:44 +0100 (Sat, 15 Nov 2008)
New Revision: 4588

Modified:
   rl/trunk/editors/Lockenwickler/src/ModuleManager.py
Log:
- entity nodes load correctly


Modified: rl/trunk/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2008-11-15 10:12:49 UTC (rev 4587)
+++ rl/trunk/editors/Lockenwickler/src/ModuleManager.py	2008-11-15 12:49:44 UTC (rev 4588)
@@ -36,15 +36,73 @@
 from MyRaySceneQueryListener import *
 
 class Map():
-    def __init__(self):
-        return
+    def __init__(self, pathToFile, sceneManager, ogreRoot):
+        self.pathToMapFile = pathToFile
+        self.sceneManager = sceneManager
+        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
+        self.ogreRoot = ogreRoot
 
+        xmlTree = xml.parse(pathToFile)
+        root = xmlTree.getroot()
+
+        if root.attrib["formatVersion"] == "0.4.0":
+            self.parseMap(root)
+        else:
+            print pathToFile + " has wrong format version. It needs to be 0.4.0"
+            return
+
+    def parseMap(self, rootElement):
+        nodes = rootElement.getiterator("entity")
+        for n in nodes:
+            entityName = n.attrib["name"]
+            meshFile = n.attrib["meshfile"]
+            nodePosition = None
+            nodeRotation = None
+            nodeScale = None
+
+            transformations = n.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+                elif t.tag == "scale":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodeScale = og.Vector3(x, y, z)
+
+            try:
+                e = self.sceneManager.createEntity(entityName, meshFile)
+            except:
+                print "Warning: Meshfile " + meshFile + " could not be found."
+                return
+
+            n = self.mapNode.createChild(entityName + "_node")
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            n.setOrientation(nodeRotation)
+            n.setScale(nodeScale)
+
+
+
+
 class Scene():
     def __init__(self):
         return
 
 class Module():
-    def __init__(self,name, modulePath):
+    def __init__(self,name, modulePath, sceneManager, ogreRoot):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+
         self.name = name
         self.moduleRoot = join(modulePath, name)
         self.__isCommon = False
@@ -55,6 +113,10 @@
         self.mapFiles = [] # a list in case the module has more than one map file
         self.gofFiles = [] # gof File list
 
+        self.scenes =[]
+
+        self.isLoaded = False
+
     def isCommon(self):
         modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
         if isfile(modConfig): # is the modconfig existing?
@@ -62,7 +124,7 @@
         else:
             print ("Error: couldn't find module config")
             return
-
+        isDependencieLine = False
         for i, line in enumerate(f):
             lStripped = line.strip() #strip the whitespace away, not needed here
             if lStripped.startswith("super("):
@@ -71,9 +133,24 @@
                     self.__isCommon = True
                     return True
 
+
+            elif isDependencieLine:
+                if lStripped == "end":
+                    isDependencieLine = False
+                else:
+                    self.hasDependencies = True
+                    self.moduleDependencies.append(lStripped.split('"')[1])
+
+            elif lStripped == "def getDependencies()":
+                isDependencieLine = True
+
         return False
 
     def load(self):
+        if self.isLoaded:
+            return
+
+        self.isLoaded = True
         modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
         if isfile(modConfig): # is the modconfig existing?
             f = codecs.open(modConfig, 'r', 'utf-8')
@@ -81,22 +158,28 @@
             print ("Error: couldn't find module config")
             return
 
-        isDependencieLine = False
+        #for i, line in enumerate(f):
+            #lStripped = line.strip() #strip the whitespace away, not needed here
 
-        for i, line in enumerate(f):
-            lStripped = line.strip() #strip the whitespace away, not needed here
+        self.setResourcePaths()
+        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
 
-            if isDependencieLine:
-                if lStripped == "end":
-                    isDependencieLine = False
-                else:
-                    self.moduleDependencies.append(lStripped.split('"')[1])
+        if not self.isCommon():
+            cmd = join(self.moduleRoot, "maps/*.rlmap.xml")
+            maps = glob.glob(cmd)
+            for m in maps:
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot))
 
-            elif lStripped == "def getDependencies()":
-                isDependencieLine = True
+            cmd = join(self.moduleRoot, "maps/*.rlscene")
+            sceneFile = glob.glob(cmd)
+            #self.loadScenes(sceneFile)
 
-        self.setResourcePaths()
+    def saveMaps(self):
+        return
 
+    def saveScenes(self):
+        return
+
     def setResourcePaths(self, recurseFolder = ""):
         if recurseFolder == "":
             rootFolder = self.moduleRoot
@@ -108,50 +191,13 @@
 
 
             if file.startswith('.'): #ignore dot files (hidden)
-                continue
+                pass
             if os.path.isdir(curFile):
                 og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
                 self.setResourcePaths(curFile)
-                continue
             if os.path.isfile(curFile):
                 pass
 
-
-#                spl = lStripped.split('"')
-#                for a in spl:
-#                    if a.endswith(".xml"):
-#                        pathToMapFile = self.workingDir + "/maps/" + a
-#                        self.mapFiles.append(pathToMapFile)
-
-#        self.setWindowTitle(moduleName)
-#
-#        self.modelSelectionDialog.scanDirForModels(self.workingDir, moduleName)
-#        self.modelSelectionDialog.scanDirForModels(self.workingDirCommon, "common")
-#
-#        self.setResourcePaths(self.workingDir, moduleName)
-#        self.setResourcePaths(self.workingDirCommon, "common")
-#        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-#
-#        command = (os.path.join(self.workingDir,  "maps") + "/*.xml")
-#        for mf in glob.glob(command): # search for all xml files in the maps directory and add them
-#            self.mapFiles.append(mf)
-#
-#        command = (os.path.join(self.workingDir,  "maps") + "/*.scene")
-#        for mf in glob.glob(command): # search for all .scene files in the maps directory and add them
-#            self.mapFiles.append(mf)
-#
-#        command = (os.path.join(self.workingDir,  "dsa") + "/*.gof")
-#        for gf in glob.glob(command): # search for all .gof files in the dsa directory in the module dir
-#            self.gofFiles.append(gf)
-#
-#        command = (os.path.join(self.workingDirCommon,  "dsa") + "/*.gof")
-#        for gf in glob.glob(command): # search for all .gof files in the dsa directory in the common module dir
-#            self.gofFiles.append(gf)
-#
-#        self.moduleManager.load(moduleName,  self.mapFiles,  self.gofFiles)
-
-
-
 class ModuleManager():
     def __init__(self,  ogreRoot,  sceneManager):
         self.sceneManager = sceneManager
@@ -160,6 +206,8 @@
 
         self.gocManager = GameObjectClassManager()
 
+        self.mainModule = []
+        self.mainModuledependencieList =[]
         self.moduleList = []
         self.userSelectionList = []
         self.cutList = [] # selection objects that has been cut out and wait to be pasted again
@@ -205,7 +253,7 @@
             if line.startswith('module='):
                 splines = line.split('=')
                 str = splines[1].rstrip().rstrip()
-                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  "")))
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot))
 
         self.moduleConfigIsParsed = True
 
@@ -230,13 +278,22 @@
         layout.addWidget(btnBox)
         dlg.setLayout(layout)
         if dlg.exec_():
-            self.loadModule(list.currentItem().text())
+            self.loadModule(str(list.currentItem().text()))
 
     def loadModule(self, moduleName):
         for m in self.moduleList:
             if m.name == moduleName:
+                if m.hasDependencies:
+                    for moduleDependencie in m.moduleDependencies:
+                        for m2 in self.moduleList:
+                            if m2.name == moduleDependencie:
+                                m2.load()
+                                self.mainModuledependencieList.append(m2)
+
                 m.load()
+                self.mainModule = m
 
+
     # called when a click into Main Ogre Window occurs
     def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
         self.listenerDings.reset()



From timm at mail.berlios.de  Sun Nov 16 00:40:04 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 16 Nov 2008 00:40:04 +0100
Subject: [Dsa-hl-svn] r4589 - rl/branches/persistence/script/src
Message-ID: <200811152340.mAFNe4Sf021866@sheep.berlios.de>

Author: timm
Date: 2008-11-16 00:39:57 +0100 (Sun, 16 Nov 2008)
New Revision: 4589

Modified:
   rl/branches/persistence/script/src/MapLoader.cpp
Log:
attribute scenescript becomes mapscript

Modified: rl/branches/persistence/script/src/MapLoader.cpp
===================================================================
--- rl/branches/persistence/script/src/MapLoader.cpp	2008-11-15 12:49:44 UTC (rev 4588)
+++ rl/branches/persistence/script/src/MapLoader.cpp	2008-11-15 23:39:57 UTC (rev 4589)
@@ -167,7 +167,7 @@
                 {
                     if(getAttributeValueAsString(doc->getDocumentElement(), "mapscript").length() != 0)
                     {
-                        if(!CoreSubsystem::getSingleton().getRubyInterpreter()->executeFile(getAttributeValueAsStdString(doc->getDocumentElement(), "scenescript")))
+                        if(!CoreSubsystem::getSingleton().getRubyInterpreter()->executeFile(getAttributeValueAsStdString(doc->getDocumentElement(), "mapscript")))
                             LOG_MESSAGE(Logger::SCRIPT, "Executed init script of map " + mapresource);
                         else
                             LOG_ERROR(Logger::SCRIPT, "Error while executing init script of map " + mapresource);



From timm at mail.berlios.de  Sun Nov 16 12:12:25 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 16 Nov 2008 12:12:25 +0100
Subject: [Dsa-hl-svn] r4590 - in rl/branches/persistence: core/include
	core/src script/include
Message-ID: <200811161112.mAGBCPuX024247@sheep.berlios.de>

Author: timm
Date: 2008-11-16 12:12:11 +0100 (Sun, 16 Nov 2008)
New Revision: 4590

Modified:
   rl/branches/persistence/core/include/SaveAbleCollection.h
   rl/branches/persistence/core/include/SaveAbleManager.h
   rl/branches/persistence/core/src/SaveAbleCollection.cpp
   rl/branches/persistence/core/src/SaveAbleManager.cpp
   rl/branches/persistence/script/include/Scene.h
Log:
working on SaveAbleCollection and SaveAbleManager

Modified: rl/branches/persistence/core/include/SaveAbleCollection.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleCollection.h	2008-11-15 23:39:57 UTC (rev 4589)
+++ rl/branches/persistence/core/include/SaveAbleCollection.h	2008-11-16 11:12:11 UTC (rev 4590)
@@ -24,11 +24,11 @@
 	{
 	public:
 		SaveAbleCollection(const CeGuiString &id);
-		void attachSaveAble(SaveAblePtr saveAble);
-		void deattachSaveAble(SaveAblePtr saveAble);
-		void deattachSaveAble(int id);
-		void deattachAllSaveAbles();
-		Ogre::String getId();
+		virtual void attachSaveAble(SaveAblePtr saveAble) = 0;
+		virtual void deattachSaveAble(SaveAblePtr saveAble) = 0;
+		virtual void deattachSaveAble(const CeGuiString &id) = 0;
+		virtual void deattachAllSaveAbles() = 0;
+		CeGuiString getId() const;
 	protected:
 		std::map<int, SaveAblePtr> mSaveAbles;
 		CeGuiString mId;

Modified: rl/branches/persistence/core/include/SaveAbleManager.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleManager.h	2008-11-15 23:39:57 UTC (rev 4589)
+++ rl/branches/persistence/core/include/SaveAbleManager.h	2008-11-16 11:12:11 UTC (rev 4590)
@@ -31,13 +31,13 @@
 		void removeSaveAble(SaveAblePtr save);
 		void removeSaveAble(const CeGuiString &id);
 		void removeAllSaveAbles();
-		void attachSaveAbleToCollection(const CeGuiString &id);
-		void deattachSaveAbleFromColltection(const CeGuiString &id);
+		void attachSaveAbleToCollection(const CeGuiString &saveAbleId, const CeGuiString &collectionId);
+		void deattachSaveAbleFromColltection(const CeGuiString &saveAbleId, const CeGuiString &collectionId);
 		void restoreState();
 	protected:
 		std::map<int, PropertyRecordPtr> mSaveAbleStates;
 		std::map<int, SaveAblePtr> mSaveAbles;
-		std::map<Ogre::String,SaveAbleCollection> mSaveAbleCollections;
+		std::map<Ogre::String,SaveAbleCollection*> mSaveAbleCollections;
 	};
 }
 

Modified: rl/branches/persistence/core/src/SaveAbleCollection.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleCollection.cpp	2008-11-15 23:39:57 UTC (rev 4589)
+++ rl/branches/persistence/core/src/SaveAbleCollection.cpp	2008-11-16 11:12:11 UTC (rev 4590)
@@ -24,4 +24,9 @@
 	{
 		mId = id;
 	}
+
+	CeGuiString SaveAbleCollection::getId() const
+	{
+		return mId;
+	}
 }
\ No newline at end of file

Modified: rl/branches/persistence/core/src/SaveAbleManager.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleManager.cpp	2008-11-15 23:39:57 UTC (rev 4589)
+++ rl/branches/persistence/core/src/SaveAbleManager.cpp	2008-11-16 11:12:11 UTC (rev 4590)
@@ -42,11 +42,11 @@
 	{
 	}
 		
-	void SaveAbleManager::attachSaveAbleToCollection(const CeGuiString &id)
+	void SaveAbleManager::attachSaveAbleToCollection(const CeGuiString &saveAbleId, const CeGuiString &collectionId)
 	{
 	}
 		
-	void SaveAbleManager::deattachSaveAbleFromColltection(const CeGuiString &id)
+	void SaveAbleManager::deattachSaveAbleFromColltection(const CeGuiString &saveAbleId, const CeGuiString &collectionId)
 	{
 	}
 		

Modified: rl/branches/persistence/script/include/Scene.h
===================================================================
--- rl/branches/persistence/script/include/Scene.h	2008-11-15 23:39:57 UTC (rev 4589)
+++ rl/branches/persistence/script/include/Scene.h	2008-11-16 11:12:11 UTC (rev 4590)
@@ -22,10 +22,11 @@
 #include <vector>
 
 #include "Properties.h"
+#include "SaveAbleCollection.h"
 
 namespace rl {
 
-    class Scene : public PropertyHolder
+    class Scene : public PropertyHolder, public SaveAbleCollection
     {
     public:
         static const Ogre::String PROPERTY_GAMEOBJECTS;



From blakharaz at mail.berlios.de  Wed Nov 19 21:54:46 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 19 Nov 2008 21:54:46 +0100
Subject: [Dsa-hl-svn] r4591 - in rl/trunk/plugins/fmod4driver: include src
Message-ID: <200811192054.mAJKskmw010984@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-19 21:54:44 +0100 (Wed, 19 Nov 2008)
New Revision: 4591

Modified:
   rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h
   rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp
Log:
Interface changes of fmod 4.20


Modified: rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h
===================================================================
--- rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h	2008-11-16 11:12:11 UTC (rev 4590)
+++ rl/trunk/plugins/fmod4driver/include/Fmod4Driver.h	2008-11-19 20:54:44 UTC (rev 4591)
@@ -137,9 +137,8 @@
         static FMOD_RESULT F_CALLBACK channelCallback(
             FMOD_CHANNEL* channel,
             FMOD_CHANNEL_CALLBACKTYPE type,
-            int command,
-            unsigned int commanddata1,
-            unsigned int commanddata2
+            void* commanddata1,
+            void* commanddata2
         );
 
         typedef std::map<const Ogre::String, FMOD_REVERB_PROPERTIES> EaxPresetMap;

Modified: rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp	2008-11-16 11:12:11 UTC (rev 4590)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp	2008-11-19 20:54:44 UTC (rev 4591)
@@ -209,17 +209,19 @@
 
         int numPlugins;
         mFmod4System->getNumPlugins(FMOD_PLUGINTYPE_CODEC, &numPlugins);
-        for (int i = 0; i < numDrivers; i++)
+        for (int i = 0; i < numPlugins; i++)
         {
             char pluginName[128];
             unsigned int version;
+			FMOD_PLUGINTYPE type;
 
-            mFmod4System->getPluginInfo(
-                FMOD_PLUGINTYPE_CODEC,
+            FMOD_RESULT result = mFmod4System->getPluginInfo(
                 i,
-                pluginName,
+                &type,
+				pluginName,
                 127,
                 &version);
+			CHECK_FMOD4_ERRORS(result);
             LOG_MESSAGE(Logger::MULTIMEDIA,
                 String("Fmod4Driver Plugin '")
                 + pluginName
@@ -407,9 +409,8 @@
 FMOD_RESULT F_CALLBACK Fmod4Driver::channelCallback(
     FMOD_CHANNEL *_channel,
     FMOD_CHANNEL_CALLBACKTYPE type,
-    int command,
-    unsigned int commanddata1, 
-    unsigned int commanddata2)
+    void* commanddata1, 
+    void* commanddata2)
 {
     /// Extract the Fmod channel and then our Sound object.
     FMOD::Channel* channel = (FMOD::Channel*)_channel;
@@ -444,7 +445,7 @@
         
                     // We get the time point of the sync point and put it in a timing event.
                     sound->getFmodChannel()->getCurrentSound(&fmodsound);
-                    fmodsound->getSyncPoint(commanddata1, &syncpoint);
+                    fmodsound->getSyncPoint(*static_cast<int*>(commanddata1), &syncpoint);
                     fmodsound->getSyncPointInfo(syncpoint, NULL, 0, &event.mTime, FMOD_TIMEUNIT_MS);
                     sound->dispatchEvent(&event);
                 }
@@ -480,12 +481,8 @@
 
     void Fmod4Driver::_registerChannel(FMOD::Channel* channel, Fmod4Sound* sound)
     {
-        FMOD_RESULT res = channel->setCallback(FMOD_CHANNEL_CALLBACKTYPE_END, channelCallback, 0);
+        FMOD_RESULT res = channel->setCallback(channelCallback);
         CHECK_FMOD4_ERRORS(res);
-        res = channel->setCallback(FMOD_CHANNEL_CALLBACKTYPE_SYNCPOINT, channelCallback, 0);
-        CHECK_FMOD4_ERRORS(res);
-        res = channel->setCallback(FMOD_CHANNEL_CALLBACKTYPE_VIRTUALVOICE, channelCallback, 0);
-        CHECK_FMOD4_ERRORS(res);
         mChannelSoundMap.insert(std::make_pair(channel, sound));
     }
 



From blakharaz at mail.berlios.de  Wed Nov 19 22:00:18 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 19 Nov 2008 22:00:18 +0100
Subject: [Dsa-hl-svn] r4592 - rl/trunk/plugins/fmod4driver/src
Message-ID: <200811192100.mAJL0IDx011729@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-19 22:00:18 +0100 (Wed, 19 Nov 2008)
New Revision: 4592

Modified:
   rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp
Log:
Fix plugin info ouput


Modified: rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp
===================================================================
--- rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp	2008-11-19 20:54:44 UTC (rev 4591)
+++ rl/trunk/plugins/fmod4driver/src/Fmod4Driver.cpp	2008-11-19 21:00:18 UTC (rev 4592)
@@ -213,10 +213,13 @@
         {
             char pluginName[128];
             unsigned int version;
-			FMOD_PLUGINTYPE type;
+			FMOD_PLUGINTYPE type = FMOD_PLUGINTYPE_CODEC;
+			unsigned int handle;
+			FMOD_RESULT result = mFmod4System->getPluginHandle(FMOD_PLUGINTYPE_CODEC, i, &handle);
+			CHECK_FMOD4_ERRORS(result);
 
-            FMOD_RESULT result = mFmod4System->getPluginInfo(
-                i,
+            result = mFmod4System->getPluginInfo(
+                handle,
                 &type,
 				pluginName,
                 127,



From blakharaz at mail.berlios.de  Wed Nov 19 23:04:51 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 19 Nov 2008 23:04:51 +0100
Subject: [Dsa-hl-svn] r4593 - modules modules/common/materials
	modules/intro/materials modules/kanalisation/maps
	modules/kanalisation/materials modules/ruchin
	modules/ruchin/materials modules/ruchin/models
	modules/techdemo/maps modules/techdemo2/materials
	modules/techdemo2/scripts/maps modules/teichtest/materials
	rl/trunk/engine/core/include rl/trunk/engine/core/src
	rl/trunk/engine/script/src rl/trunk/engine/ui/src
Message-ID: <200811192204.mAJM4pNw018506@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-19 23:04:20 +0100 (Wed, 19 Nov 2008)
New Revision: 4593

Modified:
   modules/common/materials/arc_bett_01.material
   modules/common/materials/arc_nachtkasten_schrank.material
   modules/common/materials/arc_regal_01.material
   modules/common/materials/arc_schreibtisch_01.material
   modules/common/materials/arc_stuhl_01.material
   modules/common/materials/arc_tisch_01.material
   modules/common/materials/arc_tisch_02.material
   modules/common/materials/arg_tisch_01.material
   modules/common/materials/fackel.material
   modules/common/materials/getreide.material
   modules/common/materials/men_alrike.material
   modules/common/materials/men_human_female_armor_garethplatte.mesh.material
   modules/common/materials/men_human_female_armor_kroetenhaut.mesh.material
   modules/common/materials/men_human_female_backpack_leather_01.material
   modules/common/materials/men_human_female_cloth_short.mesh.material
   modules/common/materials/men_human_female_feet_boots01.mesh.material
   modules/common/materials/men_human_female_hair_long01_normal.mesh.material
   modules/common/materials/men_human_female_hand_nude.mesh.material
   modules/common/materials/men_human_female_head02.mesh.material
   modules/common/materials/men_human_female_leg_pants01_long.mesh.material
   modules/common/materials/men_human_female_legs_underpants.mesh.material
   modules/common/materials/men_human_female_torso.mesh.material
   modules/common/materials/men_human_male_head_01.mesh.material
   modules/common/materials/nat_baum_01.material
   modules/common/materials/nat_baum_03.material
   modules/common/materials/nat_baum_mittel_02.material
   modules/common/materials/nat_baum_shadix_01.material
   modules/common/materials/nat_busch_klein.material
   modules/common/materials/obj_Shortsleeve.material
   modules/common/materials/schreibtisch.material
   modules/common/materials/stuhl.material
   modules/common/materials/ver_truhe_gross01.material
   modules/common/materials/waf_kurzschwert_01.material
   modules/common/materials/wasstertest.material
   modules/intro/materials/wueste.material
   modules/kanalisation/maps/kanalisation.material
   modules/kanalisation/materials/Wassershader_Kanalisation.program
   modules/modules.cfg
   modules/ruchin/maptest.material
   modules/ruchin/materials/maptest.material
   modules/ruchin/materials/nat_TD2Fluss.material
   modules/ruchin/materials/nat_nadelbaum_02.material
   modules/ruchin/materials/nat_nadelbaum_03_lod.material
   modules/ruchin/materials/nat_nadelbaum_lod.material
   modules/ruchin/materials/nat_wasser_techdemo2.material
   modules/ruchin/materials/statue02.material
   modules/ruchin/models/Ruchin_ground.material
   modules/ruchin/models/Ruchin_inside.material
   modules/ruchin/models/Ruchin_skydome.material
   modules/ruchin/models/Ruchintest.material
   modules/ruchin/models/Stadtmauer.material
   modules/ruchin/models/Stadtwache.material
   modules/ruchin/models/Statue01.material
   modules/ruchin/models/fass.material
   modules/ruchin/models/kiste.material
   modules/ruchin/models/nat_grasplane_02.material
   modules/ruchin/models/ruchin_terrain.material
   modules/ruchin/models/temple_outside.material
   modules/techdemo/maps/techdemo_terrain.rlmap.xml
   modules/techdemo2/materials/Techdemo2.material
   modules/techdemo2/materials/Techdemo2map2.material
   modules/techdemo2/materials/men_druide.material
   modules/techdemo2/materials/nat_TD2Fluss.material
   modules/techdemo2/materials/nat_baum_shadix_03.material
   modules/techdemo2/materials/nat_nadelbaum_02.material
   modules/techdemo2/materials/nat_nadelbaum_03_lod.material
   modules/techdemo2/materials/nat_nadelbaum_lod.material
   modules/techdemo2/materials/nat_wasser_techdemo2.material
   modules/techdemo2/scripts/maps/techdemo2map1.rb
   modules/teichtest/materials/teichtest.material
   rl/trunk/engine/core/include/ListenerMovable.h
   rl/trunk/engine/core/include/MovableText.h
   rl/trunk/engine/core/include/Sound.h
   rl/trunk/engine/core/include/SoundResource.h
   rl/trunk/engine/core/include/SoundStitching.h
   rl/trunk/engine/core/src/Actor.cpp
   rl/trunk/engine/core/src/DotSceneLoader.cpp
   rl/trunk/engine/core/src/ListenerMovable.cpp
   rl/trunk/engine/core/src/MovableText.cpp
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/trunk/engine/core/src/Sound.cpp
   rl/trunk/engine/core/src/SoundResource.cpp
   rl/trunk/engine/core/src/SoundStitching.cpp
   rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
   rl/trunk/engine/ui/src/DebugWindow.cpp
   rl/trunk/engine/ui/src/DialogControlState.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
Log:
Changes for Ogre 1.6

Modified: modules/common/materials/arc_bett_01.material
===================================================================
--- modules/common/materials/arc_bett_01.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/arc_bett_01.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+
 
 material arc_bett_01: Basic_Vertex_Shader
 {

Modified: modules/common/materials/arc_nachtkasten_schrank.material
===================================================================
--- modules/common/materials/arc_nachtkasten_schrank.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/arc_nachtkasten_schrank.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+
 
 material nachtkasten: Basic_Vertex_Shader
 {

Modified: modules/common/materials/arc_regal_01.material
===================================================================
--- modules/common/materials/arc_regal_01.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/arc_regal_01.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+
 
 material arc_regal_essen: Basic_Vertex_Shader
 {

Modified: modules/common/materials/arc_schreibtisch_01.material
===================================================================
--- modules/common/materials/arc_schreibtisch_01.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/arc_schreibtisch_01.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+
 
 material arc_schreibtisch_01: Basic_Vertex_Shader
 {

Modified: modules/common/materials/arc_stuhl_01.material
===================================================================
--- modules/common/materials/arc_stuhl_01.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/arc_stuhl_01.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+
 
 material arc_stuhl_01: Basic_Vertex_Shader
 {

Modified: modules/common/materials/arc_tisch_01.material
===================================================================
--- modules/common/materials/arc_tisch_01.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/arc_tisch_01.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+
 material arc_tisch_01: Basic_Vertex_Shader
 {
 set_texture_alias diffuse zeugs_02_schreibtisch01_tischkleinrund.dds 

Modified: modules/common/materials/arc_tisch_02.material
===================================================================
--- modules/common/materials/arc_tisch_02.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/arc_tisch_02.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+
 
 material arc_tisch_02: Basic_Vertex_Shader
 {

Modified: modules/common/materials/arg_tisch_01.material
===================================================================
--- modules/common/materials/arg_tisch_01.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/arg_tisch_01.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+
 
 material arg_tisch_01: Basic_Vertex_Shader
 {

Modified: modules/common/materials/fackel.material
===================================================================
--- modules/common/materials/fackel.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/fackel.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Normalmapping from Basic_Normalmapping.material
+
 material fackel/SOLID/TEX/fackel_kana.png: Basic_Normalmapping
 {
 set_texture_alias DiffuseMap fackel_kana.png

Modified: modules/common/materials/getreide.material
===================================================================
--- modules/common/materials/getreide.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/getreide.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import windy_grass from WindyGrass.program
+
 material ALPHA/getreide.png : windy_grass
 {
 	lod_distances 50.0

Modified: modules/common/materials/men_alrike.material
===================================================================
--- modules/common/materials/men_alrike.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/men_alrike.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import DiffuseSpecMapping from DiffuseSpecMapping.program
+
 
 material men_alrike/base : DiffuseSpecMapping
 {

Modified: modules/common/materials/men_human_female_armor_garethplatte.mesh.material
===================================================================
--- modules/common/materials/men_human_female_armor_garethplatte.mesh.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/men_human_female_armor_garethplatte.mesh.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Normalmapping_Spec from Basic_Normalmapping_Spec.material
+
 
 material men_human_female_armor_garethplatte : Basic_Normalmapping_Spec
 {

Modified: modules/common/materials/men_human_female_armor_kroetenhaut.mesh.material
===================================================================
--- modules/common/materials/men_human_female_armor_kroetenhaut.mesh.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/men_human_female_armor_kroetenhaut.mesh.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Normalmapping_Spec_mirrored from Basic_Normalmapping_Spec.material
+
 
 material men_human_female_armor_kroetenhaut : Basic_Normalmapping_Spec_mirrored
 {

Modified: modules/common/materials/men_human_female_backpack_leather_01.material
===================================================================
--- modules/common/materials/men_human_female_backpack_leather_01.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/men_human_female_backpack_leather_01.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Normalmapping from Basic_Normalmapping.material
+
 
 material men_human_female_backpack_leather_01: Basic_Normalmapping
 {

Modified: modules/common/materials/men_human_female_cloth_short.mesh.material
===================================================================
--- modules/common/materials/men_human_female_cloth_short.mesh.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/men_human_female_cloth_short.mesh.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Normalmapping_Spec from Basic_Normalmapping_Spec.material
+
 material men_human_female_cloth_short : Basic_Normalmapping_Spec
 {
 set_texture_alias DiffuseMap obj_shortsleeve02_diffuse.png

Modified: modules/common/materials/men_human_female_feet_boots01.mesh.material
===================================================================
--- modules/common/materials/men_human_female_feet_boots01.mesh.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/men_human_female_feet_boots01.mesh.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Normalmapping_mirrored from Basic_Normalmapping.material
+
 
 material men_human_female_feet_boots_01 : Basic_Normalmapping_mirrored
 {

Modified: modules/common/materials/men_human_female_hair_long01_normal.mesh.material
===================================================================
--- modules/common/materials/men_human_female_hair_long01_normal.mesh.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/men_human_female_hair_long01_normal.mesh.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Normalmapping_Spec_Hair from Basic_Normalmapping_Spec.material
+
 
 material men_human_female_hair_long_01_normal : Basic_Normalmapping_Spec_Hair
 {

Modified: modules/common/materials/men_human_female_hand_nude.mesh.material
===================================================================
--- modules/common/materials/men_human_female_hand_nude.mesh.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/men_human_female_hand_nude.mesh.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,6 @@
+import Skin_Normalmapping from Skin_Normalmapping.material
+import Skin_Normalmapping_mirrored from Skin_Normalmapping.material
+
 
 material men_human_female_hand_nude : Skin_Normalmapping
 {

Modified: modules/common/materials/men_human_female_head02.mesh.material
===================================================================
--- modules/common/materials/men_human_female_head02.mesh.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/men_human_female_head02.mesh.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Face_Normalmapping_mirrored from Skin_Normalmapping.material
+
 
 material men_human_female_head_02 : Face_Normalmapping_mirrored
 {

Modified: modules/common/materials/men_human_female_leg_pants01_long.mesh.material
===================================================================
--- modules/common/materials/men_human_female_leg_pants01_long.mesh.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/men_human_female_leg_pants01_long.mesh.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Normalmapping_Spec_mirrored from Basic_Normalmapping_Spec.material
+
 
 material men_human_female_legs_pants_01_long : Basic_Normalmapping_Spec_mirrored
 {

Modified: modules/common/materials/men_human_female_legs_underpants.mesh.material
===================================================================
--- modules/common/materials/men_human_female_legs_underpants.mesh.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/men_human_female_legs_underpants.mesh.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Normalmapping from Basic_Normalmapping.material
+
 
 material men_human_female_legs_underpants : Basic_Normalmapping
 {

Modified: modules/common/materials/men_human_female_torso.mesh.material
===================================================================
--- modules/common/materials/men_human_female_torso.mesh.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/men_human_female_torso.mesh.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,6 @@
+import Skin_Normalmapping from Skin_Normalmapping.material
+import Skin_Normalmapping_mirrored from Skin_Normalmapping.material
+
 material men_human_female_torso : Skin_Normalmapping
 {
 set_texture_alias DiffuseMap men_human_female_diffuse.png

Modified: modules/common/materials/men_human_male_head_01.mesh.material
===================================================================
--- modules/common/materials/men_human_male_head_01.mesh.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/men_human_male_head_01.mesh.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Face_Normalmapping_mirrored from Skin_Normalmapping.material
+
 
 material men_human_male_head_01 : Face_Normalmapping_mirrored
 {

Modified: modules/common/materials/nat_baum_01.material
===================================================================
--- modules/common/materials/nat_baum_01.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/nat_baum_01.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,5 +1,7 @@
+import windy_grass from WindyGrass.program
 
 
+
 material nat_baum_01/stamm
 {
 	technique

Modified: modules/common/materials/nat_baum_03.material
===================================================================
--- modules/common/materials/nat_baum_03.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/nat_baum_03.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import windy_grass from WindyGrass.program
+
 
 
 material nat_baum_03/stamm

Modified: modules/common/materials/nat_baum_mittel_02.material
===================================================================
--- modules/common/materials/nat_baum_mittel_02.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/nat_baum_mittel_02.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import windy_grass from WindyGrass.program
+
 material nat_baum_mittel_02 : windy_grass
 {
 	lod_distances 75.0

Modified: modules/common/materials/nat_baum_shadix_01.material
===================================================================
--- modules/common/materials/nat_baum_shadix_01.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/nat_baum_shadix_01.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import windy_grass from WindyGrass.program
+
 material nat_baum_shadix_01/baumblatt : windy_grass
 {
 	lod_distances 75.0

Modified: modules/common/materials/nat_busch_klein.material
===================================================================
--- modules/common/materials/nat_busch_klein.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/nat_busch_klein.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import windy_grass from WindyGrass.program
+
 material nat_busch_klein : windy_grass
 {
 	lod_distances 50.0

Modified: modules/common/materials/obj_Shortsleeve.material
===================================================================
--- modules/common/materials/obj_Shortsleeve.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/obj_Shortsleeve.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Normalmapping_Spec from Basic_Normalmapping_Spec.material
+
 
 material obj_Shortsleeve : Basic_Normalmapping_Spec
 {

Modified: modules/common/materials/schreibtisch.material
===================================================================
--- modules/common/materials/schreibtisch.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/schreibtisch.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+
 material schreibtisch: Basic_Vertex_Shader
 {
 set_texture_alias diffuse schreibtisch.dds 

Modified: modules/common/materials/stuhl.material
===================================================================
--- modules/common/materials/stuhl.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/stuhl.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+
 material stuhl: Basic_Vertex_Shader
 {
 set_texture_alias diffuse stuhl.dds 

Modified: modules/common/materials/ver_truhe_gross01.material
===================================================================
--- modules/common/materials/ver_truhe_gross01.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/ver_truhe_gross01.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+
 material ver_truhe_gross01: Basic_Vertex_Shader
 {
 set_texture_alias diffuse ver_truhe_gross.dds 

Modified: modules/common/materials/waf_kurzschwert_01.material
===================================================================
--- modules/common/materials/waf_kurzschwert_01.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/waf_kurzschwert_01.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+
 
 material waf_kurzschwert_01 : Basic_Vertex_Shader
 {

Modified: modules/common/materials/wasstertest.material
===================================================================
--- modules/common/materials/wasstertest.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/common/materials/wasstertest.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Wassershader from Wassershader.program
+
 
 material wasstertest : Wassershader
 {

Modified: modules/intro/materials/wueste.material
===================================================================
--- modules/intro/materials/wueste.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/intro/materials/wueste.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Splatting3NoDetailVertexPhong from Splatting3NoDetailVertexPhong.program
+
 material wuesten_alphamap : Splatting3NoDetailVertexPhong
 {
 	receive_shadows on

Modified: modules/kanalisation/maps/kanalisation.material
===================================================================
--- modules/kanalisation/maps/kanalisation.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/kanalisation/maps/kanalisation.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,6 @@
+import Basic_Normalmapping_kana from Normalmapping.program
+import Wassershader_Kanalisation from Wassershader_Kanalisation.program
+
 material matschboden/SOLID/TEX/boden_kana.png: Basic_Normalmapping_kana
 {
 set_texture_alias DiffuseMap boden_kana.png

Modified: modules/kanalisation/materials/Wassershader_Kanalisation.program
===================================================================
--- modules/kanalisation/materials/Wassershader_Kanalisation.program	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/kanalisation/materials/Wassershader_Kanalisation.program	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Wassershader from Wassershader.program
+
 material Wassershader_Kanalisation : Wassershader
 {	
     technique hlsl

Modified: modules/modules.cfg
===================================================================
--- modules/modules.cfg	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/modules.cfg	2008-11-19 22:04:20 UTC (rev 4593)
@@ -16,4 +16,4 @@
 module=persistenztest
 module=teichtest
 
-module=editortest
+#module=editortest

Modified: modules/ruchin/maptest.material
===================================================================
--- modules/ruchin/maptest.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/maptest.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import nat_wasser_see from nat_wasser_see.program
+
 material SOLID/TEX/boden_02.png
 {
 	technique

Modified: modules/ruchin/materials/maptest.material
===================================================================
--- modules/ruchin/materials/maptest.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/materials/maptest.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,6 @@
+import Splatting5 from Splatting5.program
+import nat_wasser_see from nat_wasser_see.program
+
 material SOLID/TEX/alpha.dds : Splatting5
 {
 	technique hlsl

Modified: modules/ruchin/materials/nat_TD2Fluss.material
===================================================================
--- modules/ruchin/materials/nat_TD2Fluss.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/materials/nat_TD2Fluss.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import nat_wasser_see from nat_wasser_see.program
+
 material nat_TD2Fluss : nat_wasser_see
 {
     technique hlsl

Modified: modules/ruchin/materials/nat_nadelbaum_02.material
===================================================================
--- modules/ruchin/materials/nat_nadelbaum_02.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/materials/nat_nadelbaum_02.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import windy_grass from WindyGrass.program
+
 
 material nat_nadelbaum_02/trunk
 {

Modified: modules/ruchin/materials/nat_nadelbaum_03_lod.material
===================================================================
--- modules/ruchin/materials/nat_nadelbaum_03_lod.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/materials/nat_nadelbaum_03_lod.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import billboard_lod from OrientBillboard.program
+
 material nat_nadelbaum_03_lod : billboard_lod
 {
     technique hlsl

Modified: modules/ruchin/materials/nat_nadelbaum_lod.material
===================================================================
--- modules/ruchin/materials/nat_nadelbaum_lod.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/materials/nat_nadelbaum_lod.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import billboard_lod from OrientBillboard.program
+
 material nat_nadelbaum_lod : billboard_lod
 {
     technique hlsl

Modified: modules/ruchin/materials/nat_wasser_techdemo2.material
===================================================================
--- modules/ruchin/materials/nat_wasser_techdemo2.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/materials/nat_wasser_techdemo2.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import nat_wasser_see from nat_wasser_see.program
+
 material nat_wasser_techdemo2 : nat_wasser_see
 {
     technique hlsl

Modified: modules/ruchin/materials/statue02.material
===================================================================
--- modules/ruchin/materials/statue02.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/materials/statue02.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Normalmapping_Spec from Basic_Normalmapping_Spec.material
+
 material Statue_02 : Basic_Normalmapping_Spec
 {
 	set_texture_alias DiffuseMap Statue_02_diffuse.png

Modified: modules/ruchin/models/Ruchin_ground.material
===================================================================
--- modules/ruchin/models/Ruchin_ground.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/models/Ruchin_ground.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import TerrainVColorBlending from TerrainVColorBlending.material
+
 
 material Ruchin_ground: TerrainVColorBlending
 {

Modified: modules/ruchin/models/Ruchin_inside.material
===================================================================
--- modules/ruchin/models/Ruchin_inside.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/models/Ruchin_inside.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,6 @@
+import Basic_Vertex_Shader_Alpha from Basic_Vertex_Shader_Alpha.material
+import Basic_Vertex_Shader_noDirectional from Basic_Vertex_Shader.program
+
 
 material Ruchin_inside_base : Basic_Vertex_Shader_noDirectional
 {

Modified: modules/ruchin/models/Ruchin_skydome.material
===================================================================
--- modules/ruchin/models/Ruchin_skydome.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/models/Ruchin_skydome.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Skydome_shader from Skydome.material
+
 
 material Ruchin_skydome : Skydome_shader
 {

Modified: modules/ruchin/models/Ruchintest.material
===================================================================
--- modules/ruchin/models/Ruchintest.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/models/Ruchintest.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,9 @@
+import Architecture_Normalmapping from Architecture_Normalmapping.material
+import Basic_Normalmapping from Basic_Normalmapping.material
+import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+import Basic_Vertex_Shader_AO from Basic_Vertex_Shader_AO.material
+import Basic_Vertex_Shader_Alpha from Basic_Vertex_Shader_Alpha.material
+
 
 material Ruchin_l/base : Basic_Vertex_Shader
 {

Modified: modules/ruchin/models/Stadtmauer.material
===================================================================
--- modules/ruchin/models/Stadtmauer.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/models/Stadtmauer.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Architecture_Normalmapping from Architecture_Normalmapping.material
+
 
 material Ruchin_Stadtmauer : Architecture_Normalmapping
 {

Modified: modules/ruchin/models/Stadtwache.material
===================================================================
--- modules/ruchin/models/Stadtwache.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/models/Stadtwache.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,8 @@
+import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+import Ruchin/base from Ruchintest.material
+import Ruchin_Stadtmauer/Dach from Stadtmauer.material
+import Ruchin_Stadtmauer/Wand from __unkown_material_file__
+
 material Stadtwache/Wand : Ruchin_Stadtmauer/Wand
 {
 

Modified: modules/ruchin/models/Statue01.material
===================================================================
--- modules/ruchin/models/Statue01.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/models/Statue01.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Normalmapping_Spec from Basic_Normalmapping_Spec.material
+
 material Statue_01 : Basic_Normalmapping_Spec
 {
 			set_texture_alias NormalMap Ingrimiane_normal.png

Modified: modules/ruchin/models/fass.material
===================================================================
--- modules/ruchin/models/fass.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/models/fass.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+
 
 material arc_fass : Basic_Vertex_Shader
 {

Modified: modules/ruchin/models/kiste.material
===================================================================
--- modules/ruchin/models/kiste.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/models/kiste.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Vertex_Shader from Basic_Vertex_Shader.program
+
 
 material arc_kiste : Basic_Vertex_Shader
 {

Modified: modules/ruchin/models/nat_grasplane_02.material
===================================================================
--- modules/ruchin/models/nat_grasplane_02.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/models/nat_grasplane_02.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Basic_Vertex_Shader_Sprite from Basic_Vertex_Shader.program
+
 
 material nat_grasplanes_02: Basic_Vertex_Shader_Sprite
 {

Modified: modules/ruchin/models/ruchin_terrain.material
===================================================================
--- modules/ruchin/models/ruchin_terrain.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/models/ruchin_terrain.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import TerrainVColorBlending from TerrainVColorBlending.material
+
 
 material ruchin_terrain: TerrainVColorBlending
 {

Modified: modules/ruchin/models/temple_outside.material
===================================================================
--- modules/ruchin/models/temple_outside.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/ruchin/models/temple_outside.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Architecture_Normalmapping from Architecture_Normalmapping.material
+
 
 material temple_outside: Architecture_Normalmapping
 {

Modified: modules/techdemo/maps/techdemo_terrain.rlmap.xml
===================================================================
--- modules/techdemo/maps/techdemo_terrain.rlmap.xml	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/techdemo/maps/techdemo_terrain.rlmap.xml	2008-11-19 22:04:20 UTC (rev 4593)
@@ -30569,7 +30569,7 @@
       <staticgeometrygroup id="0" />
       <physicsproxy type="none" />
     </entity>
-		<gameobject class="hero" id="1" state="IN_SCENE">
+		<gameobject class="mckhero" id="1" state="IN_SCENE">
 			<position x="0" y="0.7" z="0"/>
 		</gameobject>
 		<gameobject class="ArnolfGrossschaedel" state="IN_SCENE">

Modified: modules/techdemo2/materials/Techdemo2.material
===================================================================
--- modules/techdemo2/materials/Techdemo2.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/techdemo2/materials/Techdemo2.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Splatting5 from Splatting5.program
+
 material Techdemo2map1 : Splatting5
 {
 	technique hlsl

Modified: modules/techdemo2/materials/Techdemo2map2.material
===================================================================
--- modules/techdemo2/materials/Techdemo2map2.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/techdemo2/materials/Techdemo2map2.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Splatting5 from Splatting5.program
+
 material Techdemo2_map2 : Splatting5
 {
 	technique hlsl

Modified: modules/techdemo2/materials/men_druide.material
===================================================================
--- modules/techdemo2/materials/men_druide.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/techdemo2/materials/men_druide.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import DiffuseSpecMapping from DiffuseSpecMapping.program
+
 
 material men_druide/base : DiffuseSpecMapping
 {

Modified: modules/techdemo2/materials/nat_TD2Fluss.material
===================================================================
--- modules/techdemo2/materials/nat_TD2Fluss.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/techdemo2/materials/nat_TD2Fluss.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import nat_wasser_see from nat_wasser_see.program
+
 material nat_TD2Fluss : Wassershader
 {
 set_texture_alias Cubemap desert07.dds

Modified: modules/techdemo2/materials/nat_baum_shadix_03.material
===================================================================
--- modules/techdemo2/materials/nat_baum_shadix_03.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/techdemo2/materials/nat_baum_shadix_03.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import windy_grass from WindyGrass.program
+
 
 material nat_baum_shadix_03/baumblatt3 : windy_grass
 {

Modified: modules/techdemo2/materials/nat_nadelbaum_02.material
===================================================================
--- modules/techdemo2/materials/nat_nadelbaum_02.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/techdemo2/materials/nat_nadelbaum_02.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import windy_grass from WindyGrass.program
+
 
 material nat_nadelbaum_02/trunk
 {

Modified: modules/techdemo2/materials/nat_nadelbaum_03_lod.material
===================================================================
--- modules/techdemo2/materials/nat_nadelbaum_03_lod.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/techdemo2/materials/nat_nadelbaum_03_lod.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import billboard_lod from OrientBillboard.program
+
 material nat_nadelbaum_03_lod : billboard_lod
 {
     technique hlsl

Modified: modules/techdemo2/materials/nat_nadelbaum_lod.material
===================================================================
--- modules/techdemo2/materials/nat_nadelbaum_lod.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/techdemo2/materials/nat_nadelbaum_lod.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import billboard_lod from OrientBillboard.program
+
 material nat_nadelbaum_lod : billboard_lod
 {
     technique hlsl

Modified: modules/techdemo2/materials/nat_wasser_techdemo2.material
===================================================================
--- modules/techdemo2/materials/nat_wasser_techdemo2.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/techdemo2/materials/nat_wasser_techdemo2.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import nat_wasser_see from nat_wasser_see.program
+
 material nat_wasser_techdemo2 : nat_wasser_see
 {
     technique hlsl

Modified: modules/techdemo2/scripts/maps/techdemo2map1.rb
===================================================================
--- modules/techdemo2/scripts/maps/techdemo2map1.rb	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/techdemo2/scripts/maps/techdemo2map1.rb	2008-11-19 22:04:20 UTC (rev 4593)
@@ -57,7 +57,7 @@
 $SCRIPT.log(" Loopen");
 techdemoDorf.getControlledObject().setLooping( true );
 $SCRIPT.log(" Laden");
-techdemoDorf.getControlledObject().load();
+#techdemoDorf.getControlledObject().load();
 $SCRIPT.log("Dorf-Thema fertig");
 
 $World.setFog( World::FOG_EXP, [0.1,0.08,0.01,0.1], 0.00503, 10.0, 100.0);
@@ -86,7 +86,7 @@
 $SCRIPT.log("Weiteres geladen");
 
 #Musik als letztes Starten
-techdemoDorf.getControlledObject().play();
+#techdemoDorf.getControlledObject().play();
 
 # Tagebucheintrag
 entry = $tagebuchtexte['dorf1']

Modified: modules/teichtest/materials/teichtest.material
===================================================================
--- modules/teichtest/materials/teichtest.material	2008-11-19 21:00:18 UTC (rev 4592)
+++ modules/teichtest/materials/teichtest.material	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,3 +1,5 @@
+import Wassershader_Kanalisation from Wassershader_Kanalisation.program
+
 material wasser/SOLID/TEX/Untitled
 {
 	technique

Modified: rl/trunk/engine/core/include/ListenerMovable.h
===================================================================
--- rl/trunk/engine/core/include/ListenerMovable.h	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/core/include/ListenerMovable.h	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,94 +1,98 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __ListenerMovable_H__
-#define __ListenerMovable_H__
-
-#include "CorePrerequisites.h"
-
-
-namespace rl {
-    
-   /** Diese Klasse dient der Interaktion mit Ogre3d und
-    * kapselt den H?rer.
-    * @author Josch
-    * @date 06-29-2005
-    * @version 1.0
-    * @version 2.0
-    */
-    class _RlCoreExport ListenerMovable : public Ogre::MovableObject
-    {
-    public:
-        /// Konstruktor
-        ListenerMovable(const Ogre::String& name);
-        /// Destruktor
-        virtual ~ListenerMovable() = 0;
-        /// Name zur?ckgeben
-        virtual const Ogre::String& getName() const;
-        /// Moveable-Typ
-        virtual const Ogre::String& getMovableType() const;
-        /// Kamera informieren
-        virtual void _notifyCurrentCamera(Ogre::Camera *cam);
-        /// Unsere Bounding-Box
-        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
-        /// Bound-Radius
-        virtual Ogre::Real getBoundingRadius() const;
-        /// Rendern
-        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
-    
-        /// Gibt die Hauptlautstaerke zurueck
-        virtual const int getGain() const;
-        /// Setzt die Hauptlautstaerke.
-        virtual void setGain(const int direction);
-        /// Gibt die eingestellte Position der Soundquelle zurueck
-        virtual const Ogre::Vector3 getPosition() const;
-        /// Setzt die Position der Soundquelle.
-        virtual void setPosition(const Ogre::Vector3& direction);
-        /// Gibt die Richtung der Soundquelle zurueck.
-        virtual const Ogre::Quaternion getOrientation() const;
-        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
-        virtual const Ogre::Vector3 getVelocity() const;
-        /// Setzt die Richtung der Soundquelle.
-        virtual void setOrientation(const Ogre::Quaternion &orientation);
-        /// Setzt die Geschwindigkeit der Soundquelle.
-        virtual void setVelocity(const Ogre::Vector3&);
-        
-        /// Ist dies der aktuelle Listener
-        bool isActive() const;
-		void setActive(bool active);
-        
-    protected:
-         /// Shared class-level name for Movable type
-        static Ogre::String msMovableType;
-        /// Alignment-Box: gebraucht von MovableObject.
-        static Ogre::AxisAlignedBox msAABox;
-        /// Position
-        Ogre::Vector3 mPosition;
-        /// Geschwindigkeit
-        Ogre::Vector3 mVelocity;
-        /// Orientierung
-        Ogre::Quaternion mOrientation;
-        /// Hauptlautst?rke
-        int mGain;
-
-    private:
-        /// Der Name des ListenerMovable
-        Ogre::String mName;
-		bool mActive;
-    };
-
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __ListenerMovable_H__
+#define __ListenerMovable_H__
+
+#include "CorePrerequisites.h"
+
+
+namespace rl {
+    
+   /** Diese Klasse dient der Interaktion mit Ogre3d und
+    * kapselt den H?rer.
+    * @author Josch
+    * @date 06-29-2005
+    * @version 1.0
+    * @version 2.0
+    */
+    class _RlCoreExport ListenerMovable : public Ogre::MovableObject
+    {
+    public:
+        /// Konstruktor
+        ListenerMovable(const Ogre::String& name);
+        /// Destruktor
+        virtual ~ListenerMovable() = 0;
+        /// Name zur?ckgeben
+        virtual const Ogre::String& getName() const;
+        /// Moveable-Typ
+        virtual const Ogre::String& getMovableType() const;
+        /// Kamera informieren
+        virtual void _notifyCurrentCamera(Ogre::Camera *cam);
+        /// Unsere Bounding-Box
+        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
+        /// Bound-Radius
+        virtual Ogre::Real getBoundingRadius() const;
+        /// Rendern
+        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+    
+        /// Gibt die Hauptlautstaerke zurueck
+        virtual const int getGain() const;
+        /// Setzt die Hauptlautstaerke.
+        virtual void setGain(const int direction);
+        /// Gibt die eingestellte Position der Soundquelle zurueck
+        virtual const Ogre::Vector3 getPosition() const;
+        /// Setzt die Position der Soundquelle.
+        virtual void setPosition(const Ogre::Vector3& direction);
+        /// Gibt die Richtung der Soundquelle zurueck.
+        virtual const Ogre::Quaternion getOrientation() const;
+        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
+        virtual const Ogre::Vector3 getVelocity() const;
+        /// Setzt die Richtung der Soundquelle.
+        virtual void setOrientation(const Ogre::Quaternion &orientation);
+        /// Setzt die Geschwindigkeit der Soundquelle.
+        virtual void setVelocity(const Ogre::Vector3&);
+        
+        /// Ist dies der aktuelle Listener
+        bool isActive() const;
+		void setActive(bool active);
+
+		/// From MovableObject
+		virtual void visitRenderables(Ogre::Renderable::Visitor* visitor, 
+			bool debugRenderables = false);
+        
+    protected:
+         /// Shared class-level name for Movable type
+        static Ogre::String msMovableType;
+        /// Alignment-Box: gebraucht von MovableObject.
+        static Ogre::AxisAlignedBox msAABox;
+        /// Position
+        Ogre::Vector3 mPosition;
+        /// Geschwindigkeit
+        Ogre::Vector3 mVelocity;
+        /// Orientierung
+        Ogre::Quaternion mOrientation;
+        /// Hauptlautst?rke
+        int mGain;
+
+    private:
+        /// Der Name des ListenerMovable
+        Ogre::String mName;
+		bool mActive;
+    };
+
+}
+#endif

Modified: rl/trunk/engine/core/include/MovableText.h
===================================================================
--- rl/trunk/engine/core/include/MovableText.h	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/core/include/MovableText.h	2008-11-19 22:04:20 UTC (rev 4593)
@@ -63,6 +63,7 @@
         const Ogre::String& getMovableType(void) const { return msType; }
         Ogre::Real getBoundingRadius(void) const {return mRadius;}
         Ogre::Real getSquaredViewDepth(const Ogre::Camera* cam) const { return 0; }
+		void visitRenderables(Ogre::Renderable::Visitor* visitor,  bool debugRenderables = false);
  
         // from renderable
         void getRenderOperation(Ogre::RenderOperation &op);

Modified: rl/trunk/engine/core/include/Sound.h
===================================================================
--- rl/trunk/engine/core/include/Sound.h	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/core/include/Sound.h	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,163 +1,167 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __Sound_H__
-#define __Sound_H__
-
-#include "CorePrerequisites.h"
-#include <set>
-
-#include "Exception.h"
-#include "EventCaster.h"
-#include "SoundEvents.h"
-#include "SoundResource.h"
-
-namespace rl {
-
-    class SoundDriver;
-
-   /** Diese Klasse dient der Interaktion mit dem jeweiligen Soundsystem
-    * ein Objekt stellt eine einzelne Sounddatei oder einen Stream dar
-    * @author Josch
-    * @date 06-29-2005
-    * @version 1.0
-    * @version 2.0
-    */
-    class _RlCoreExport Sound : public Ogre::MovableObject, 
-        public EventCaster<SoundEvent>, public EventSource
-    {
-    public:
-        // Einige Standardwerte f??r Soundpriorit??ten.
-        enum SOUND_PRIORITY {
-            PRIO_SPEECH = 30,
-            PRIO_MUSIC = 75,
-            PRIO_SFX_ENVIRONMENT = 128,
-            PRIO_SFX_OTHER = 175,
-            PRIO_OTHER = 220
-        };
-
-        /// Konstruktor
-        Sound(const SoundResourcePtr& soundres, SoundDriver* creator);
-        /// Destruktor
-        virtual ~Sound();
-          
-        /// Laedt den Sound.
-        virtual void load() throw (RuntimeException) = 0;
-        /// Entlaedt den Sound.
-        virtual void unload() throw (RuntimeException) = 0;
-
-        // SoundResource zurueckgeben.
-        const SoundResourcePtr& getSoundResource() const;
-        // Wollen wir 3D?
-        bool is3d() const;
-        // Setzen des 3D-Flags.
-        void set3d(bool is3d);
-        // Sind wir gueltig
-        virtual bool isValid() const throw (RuntimeException) = 0;
-        
-        // Sollen der Sound wiederholt werden?
-        bool isLooping() const;
-        // Setzen des Loop-Flags.
-        void setLooping(bool looping);
-
-        virtual float getLength() const = 0;
-
-        /// Unsere Bounding-Box
-        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
-        /// Bound-Radius
-        virtual Ogre::Real getBoundingRadius() const;
-        /// Rendern
-        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
-
-
-        /// Gibt die eingestellte Position der Soundquelle zurueck
-        virtual const Ogre::Vector3 getPosition() const = 0;
-        /// Setzt die Position der Soundquelle.
-        virtual void setPosition(const Ogre::Vector3& direction) = 0;
-        /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
-	    virtual const Ogre::Real getVolume() const = 0; 
-        /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
-	    virtual void setVolume(const Ogre::Real gain) = 0;
-        /// Gibt die Richtung der Soundquelle zurueck.
-        virtual const Ogre::Quaternion getDirection() const = 0;
-        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
-        virtual const Ogre::Vector3 getVelocity() const = 0;
-        /// Setzt die Richtung der Soundquelle.
-        virtual void setDirection(const Ogre::Quaternion&) = 0;
-        /// Setzt die Geschwindigkeit der Soundquelle.
-        virtual void setVelocity(const Ogre::Vector3&) = 0;
-	    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
-	    virtual void setRolloffStartDistance(const Ogre::Real&);
-	    virtual const Ogre::Real getRolloffStartDistance() const;
-	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
-	    virtual void setRolloffEndDistance(const Ogre::Real&);
-	    virtual const Ogre::Real getRolloffEndDistance() const;
-        // Sets the priority of this sound
-        virtual void setPriority(const int priority) = 0;
-        // Gets the priority of this sound
-        virtual const int getPriority() const = 0;
-
-        /// Spielt den Sound ab.
-        virtual void play(bool destroyWhenDone=false) = 0;
-        /// Pausiert den Sound.
-        virtual void pause(bool pausing) = 0;
-        /// Ist der Sound pausiert?
-        virtual bool isPaused() = 0;
-        /// Stoppt den Sound.
-        virtual void stop() = 0;
-        /// Zurueck auf Anfang.
-    //        virtual void rewind() throw (RuntimeException) = 0;
-        /// Laeuft der Sound noch
-        virtual const bool isPlaying() const = 0;
-
-    protected:
-        SoundDriver* mCreator;
-
-        /// Die Lautstaerke
-	    Ogre::Real mVolume;
-        /// Die Position
-        Ogre::Vector3 mPosition;
-        /// Die Richtung
-        Ogre::Quaternion mDirection;
-        /// Die Geschwindigkeit
-        Ogre::Vector3 mVelocity;
-        /// The priority of this sound
-        int mPriority;
-
-	    Ogre::Real mRolloffStartDistance;
-	    Ogre::Real mRolloffEndDistance;
-
-    private:
-        /// Shared class-level name for Movable type
-        static Ogre::AxisAlignedBox msAABox;
-
-        /// Der Soundresource, auf den wir verweisen.
-        SoundResourcePtr mSoundResource;
-
-        // Damit die Timings alle 0.5 sek. abgeschickt werden.
-        int mTicks;
-        // Ob dieser Sound 3D sein soll.
-        bool mIs3d;
-        // Ob dieser Sound loopen soll.
-        bool mIsLooping;
-        
-    }; 
-
-
-    typedef std::set<Sound*> SoundSet;
-
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __Sound_H__
+#define __Sound_H__
+
+#include "CorePrerequisites.h"
+#include <set>
+
+#include "Exception.h"
+#include "EventCaster.h"
+#include "SoundEvents.h"
+#include "SoundResource.h"
+
+namespace rl {
+
+    class SoundDriver;
+
+   /** Diese Klasse dient der Interaktion mit dem jeweiligen Soundsystem
+    * ein Objekt stellt eine einzelne Sounddatei oder einen Stream dar
+    * @author Josch
+    * @date 06-29-2005
+    * @version 1.0
+    * @version 2.0
+    */
+    class _RlCoreExport Sound : public Ogre::MovableObject, 
+        public EventCaster<SoundEvent>, public EventSource
+    {
+    public:
+        // Einige Standardwerte f??r Soundpriorit??ten.
+        enum SOUND_PRIORITY {
+            PRIO_SPEECH = 30,
+            PRIO_MUSIC = 75,
+            PRIO_SFX_ENVIRONMENT = 128,
+            PRIO_SFX_OTHER = 175,
+            PRIO_OTHER = 220
+        };
+
+        /// Konstruktor
+        Sound(const SoundResourcePtr& soundres, SoundDriver* creator);
+        /// Destruktor
+        virtual ~Sound();
+          
+        /// Laedt den Sound.
+        virtual void load() throw (RuntimeException) = 0;
+        /// Entlaedt den Sound.
+        virtual void unload() throw (RuntimeException) = 0;
+
+        // SoundResource zurueckgeben.
+        const SoundResourcePtr& getSoundResource() const;
+        // Wollen wir 3D?
+        bool is3d() const;
+        // Setzen des 3D-Flags.
+        void set3d(bool is3d);
+        // Sind wir gueltig
+        virtual bool isValid() const throw (RuntimeException) = 0;
+        
+        // Sollen der Sound wiederholt werden?
+        bool isLooping() const;
+        // Setzen des Loop-Flags.
+        void setLooping(bool looping);
+
+        virtual float getLength() const = 0;
+
+        /// Unsere Bounding-Box
+        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
+        /// Bound-Radius
+        virtual Ogre::Real getBoundingRadius() const;
+        /// Rendern
+        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+
+
+        /// Gibt die eingestellte Position der Soundquelle zurueck
+        virtual const Ogre::Vector3 getPosition() const = 0;
+        /// Setzt die Position der Soundquelle.
+        virtual void setPosition(const Ogre::Vector3& direction) = 0;
+        /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
+	    virtual const Ogre::Real getVolume() const = 0; 
+        /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
+	    virtual void setVolume(const Ogre::Real gain) = 0;
+        /// Gibt die Richtung der Soundquelle zurueck.
+        virtual const Ogre::Quaternion getDirection() const = 0;
+        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
+        virtual const Ogre::Vector3 getVelocity() const = 0;
+        /// Setzt die Richtung der Soundquelle.
+        virtual void setDirection(const Ogre::Quaternion&) = 0;
+        /// Setzt die Geschwindigkeit der Soundquelle.
+        virtual void setVelocity(const Ogre::Vector3&) = 0;
+	    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
+	    virtual void setRolloffStartDistance(const Ogre::Real&);
+	    virtual const Ogre::Real getRolloffStartDistance() const;
+	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
+	    virtual void setRolloffEndDistance(const Ogre::Real&);
+	    virtual const Ogre::Real getRolloffEndDistance() const;
+        // Sets the priority of this sound
+        virtual void setPriority(const int priority) = 0;
+        // Gets the priority of this sound
+        virtual const int getPriority() const = 0;
+
+        /// Spielt den Sound ab.
+        virtual void play(bool destroyWhenDone=false) = 0;
+        /// Pausiert den Sound.
+        virtual void pause(bool pausing) = 0;
+        /// Ist der Sound pausiert?
+        virtual bool isPaused() = 0;
+        /// Stoppt den Sound.
+        virtual void stop() = 0;
+        /// Zurueck auf Anfang.
+    //        virtual void rewind() throw (RuntimeException) = 0;
+        /// Laeuft der Sound noch
+        virtual const bool isPlaying() const = 0;
+
+	/// From MovableObject
+		virtual void visitRenderables(Ogre::Renderable::Visitor* visitor, 
+			bool debugRenderables = false);
+	
+	protected:
+        SoundDriver* mCreator;
+
+        /// Die Lautstaerke
+	    Ogre::Real mVolume;
+        /// Die Position
+        Ogre::Vector3 mPosition;
+        /// Die Richtung
+        Ogre::Quaternion mDirection;
+        /// Die Geschwindigkeit
+        Ogre::Vector3 mVelocity;
+        /// The priority of this sound
+        int mPriority;
+
+	    Ogre::Real mRolloffStartDistance;
+	    Ogre::Real mRolloffEndDistance;
+
+    private:
+        /// Shared class-level name for Movable type
+        static Ogre::AxisAlignedBox msAABox;
+
+        /// Der Soundresource, auf den wir verweisen.
+        SoundResourcePtr mSoundResource;
+
+        // Damit die Timings alle 0.5 sek. abgeschickt werden.
+        int mTicks;
+        // Ob dieser Sound 3D sein soll.
+        bool mIs3d;
+        // Ob dieser Sound loopen soll.
+        bool mIsLooping;
+        
+    }; 
+
+
+    typedef std::set<Sound*> SoundSet;
+
+}
+#endif

Modified: rl/trunk/engine/core/include/SoundResource.h
===================================================================
--- rl/trunk/engine/core/include/SoundResource.h	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/core/include/SoundResource.h	2008-11-19 22:04:20 UTC (rev 4593)
@@ -33,10 +33,6 @@
  */
 class _RlCoreExport SoundResource: public Ogre::Resource
 {
-    private:
-        /// Unsere Daten von Ogres ResourceManager.
-        Ogre::DataStreamPtr mDataStream;
-                       
     public:
         /// Der Standardkonstruktor
         SoundResource(Ogre::ResourceManager* creator, const Ogre::String& name, 
@@ -44,10 +40,8 @@
             Ogre::ManualResourceLoader* loader);
         /// Der Destruktor
         virtual ~SoundResource();
-        /// Den Datenstrom zur???ckgeben
+        /// Den Datenstrom zurueckgeben
         const Ogre::DataStreamPtr &getDataStream() const;
-        /// Groesse zurueckgeben.
-        int getSize() const;
 
     protected:
 		/// Laedt die Soundquelle.
@@ -57,6 +51,10 @@
 		/// Bestimmt die Groesse im Speicher (wird erst nach dem Laden aufgerufen)
 		virtual size_t calculateSize() const;        
         
+
+	private:
+        /// Unsere Daten von Ogres ResourceManager.
+        Ogre::DataStreamPtr mDataStream;
 };
 
 class _RlCoreExport SoundResourcePtr :

Modified: rl/trunk/engine/core/include/SoundStitching.h
===================================================================
--- rl/trunk/engine/core/include/SoundStitching.h	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/core/include/SoundStitching.h	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,178 +1,182 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __SoundStitching_H__
-#define __SoundStitching_H__
-
-#include "CorePrerequisites.h"
-#include <set>
-
-#include "Exception.h"
-#include "EventCaster.h"
-#include "SoundEvents.h"
-#include "SoundResource.h"
-
-namespace rl {
-
-    class SoundDriver;
-
-    typedef std::map<CeGuiString, SoundResourcePtr> SoundCache;
-
-   /** Diese Klasse dient der Interaktion mit dem jeweiligen Soundsystem
-    * ein Objekt stellt eine einzelne Sounddatei oder einen Stream dar
-    * @author Josch
-    * @date 06-29-2005
-    * @version 1.0
-    * @version 2.0
-    */
-    class _RlCoreExport SoundStitching : public Ogre::MovableObject, 
-        public EventCaster<SoundEvent>, public EventSource
-    {
-    public:
-        // Einige Standardwerte f??r Soundpriorit??ten.
-        enum SOUND_PRIORITY {
-            PRIO_SPEECH = 30,
-            PRIO_MUSIC = 75,
-            PRIO_SFX_ENVIRONMENT = 128,
-            PRIO_SFX_OTHER = 175,
-            PRIO_OTHER = 220
-        };
-
-        /// Konstruktor
-        SoundStitching(unsigned int numSlots, const CeGuiString& name, SoundDriver* creator);
-        /// Destruktor
-        virtual ~SoundStitching();
-          
-        /// Laedt den Sound.
-        virtual void load() throw (RuntimeException) = 0;
-        /// Entlaedt den Sound.
-        virtual void unload() throw (RuntimeException) = 0;
-
-        virtual float getLength() const;
-
-        // SoundResource zurueckgeben.
-        const SoundResourcePtr& getSoundResource() const;
-        // Wollen wir 3D?
-        bool is3d() const;
-        // Setzen des 3D-Flags.
-        void set3d(bool is3d);
-        // Sind wir gueltig
-        virtual bool isValid() const throw (RuntimeException) = 0;
-        
-        // Sollen der Sound wiederholt werden?
-        bool isLooping() const;
-        // Setzen des Loop-Flags.
-        void setLooping(bool looping);
-
-        /// Unsere Bounding-Box
-        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
-        /// Bound-Radius
-        virtual Ogre::Real getBoundingRadius() const;
-        /// Rendern
-        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
-
-        /// Count of configured slots.
-        unsigned int getNumSlots();
-        /// Add a sound resource to the cache overwritting existing sound resource.
-        virtual void addSoundToCache(CeGuiString label, SoundResourcePtr sound);
-        /// Assign a sound recource to a slot.
-        virtual void putSoundIntoSlot(unsigned int, CeGuiString label) = 0;
-        /// Get the slot of the plaing sound.
-        virtual unsigned int getPlayingSlot() = 0;
-
-        /// Gibt die eingestellte Position der Soundquelle zurueck
-        virtual const Ogre::Vector3 getPosition() const = 0;
-        /// Setzt die Position der Soundquelle.
-        virtual void setPosition(const Ogre::Vector3& direction) = 0;
-        /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
-	    virtual const Ogre::Real getVolume() const = 0; 
-        /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
-	    virtual void setVolume(const Ogre::Real gain) = 0;
-        /// Gibt die Richtung der Soundquelle zurueck.
-        virtual const Ogre::Quaternion getDirection() const = 0;
-        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
-        virtual const Ogre::Vector3 getVelocity() const = 0;
-        /// Setzt die Richtung der Soundquelle.
-        virtual void setDirection(const Ogre::Quaternion&) = 0;
-        /// Setzt die Geschwindigkeit der Soundquelle.
-        virtual void setVelocity(const Ogre::Vector3&) = 0;
-	    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
-	    virtual void setRolloffStartDistance(const Ogre::Real&);
-	    virtual const Ogre::Real getRolloffStartDistance() const;
-	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
-	    virtual void setRolloffEndDistance(const Ogre::Real&);
-	    virtual const Ogre::Real getRolloffEndDistance() const;
-        // Sets the priority of this sound
-        virtual void setPriority(const int priority) = 0;
-        // Gets the priority of this sound
-        virtual const int getPriority() const = 0;
-
-        /// Spielt den Sound ab.
-        virtual void play(bool destroyWhenDone=false) = 0;
-        /// Pausiert den Sound.
-        virtual void pause(bool pausing) = 0;
-        /// Ist der Sound pausiert?
-        virtual bool isPaused() = 0;
-        /// Stoppt den Sound.
-        virtual void stop() = 0;
-        /// Laeuft der Sound noch
-        virtual const bool isPlaying() const = 0;
-
-    protected:
-        SoundDriver* mCreator;
-
-        /// Die Lautstaerke
-	    Ogre::Real mVolume;
-        /// Die Position
-        Ogre::Vector3 mPosition;
-        /// Die Richtung
-        Ogre::Quaternion mDirection;
-        /// Die Geschwindigkeit
-        Ogre::Vector3 mVelocity;
-        /// The priority of this sound
-        int mPriority;
-
-	    Ogre::Real mRolloffStartDistance;
-	    Ogre::Real mRolloffEndDistance;
-
-        // Sound-Cache
-        SoundCache mSoundCache;
-
-    private:
-        /// Shared class-level name for Movable type
-        static Ogre::AxisAlignedBox msAABox;
-
-        /// Der Soundresource, auf den wir verweisen.
-        SoundResourcePtr mSoundResource;
-
-        // Damit die Timings alle 0.5 sek. abgeschickt werden.
-        int mTicks;
-        // Ob dieser Sound 3D sein soll.
-        bool mIs3d;
-        // Ob dieser Sound loopen soll.
-        bool mIsLooping;
-
-        // Anzahl der Soundslots
-        unsigned int mNumSlots;
-
-        // Name
-        CeGuiString mName;
-        
-    }; 
-
-}
-#endif
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __SoundStitching_H__
+#define __SoundStitching_H__
+
+#include "CorePrerequisites.h"
+#include <set>
+
+#include "Exception.h"
+#include "EventCaster.h"
+#include "SoundEvents.h"
+#include "SoundResource.h"
+
+namespace rl {
+
+    class SoundDriver;
+
+    typedef std::map<CeGuiString, SoundResourcePtr> SoundCache;
+
+   /** Diese Klasse dient der Interaktion mit dem jeweiligen Soundsystem
+    * ein Objekt stellt eine einzelne Sounddatei oder einen Stream dar
+    * @author Josch
+    * @date 06-29-2005
+    * @version 1.0
+    * @version 2.0
+    */
+    class _RlCoreExport SoundStitching : public Ogre::MovableObject, 
+        public EventCaster<SoundEvent>, public EventSource
+    {
+    public:
+        // Einige Standardwerte f??r Soundpriorit??ten.
+        enum SOUND_PRIORITY {
+            PRIO_SPEECH = 30,
+            PRIO_MUSIC = 75,
+            PRIO_SFX_ENVIRONMENT = 128,
+            PRIO_SFX_OTHER = 175,
+            PRIO_OTHER = 220
+        };
+
+        /// Konstruktor
+        SoundStitching(unsigned int numSlots, const CeGuiString& name, SoundDriver* creator);
+        /// Destruktor
+        virtual ~SoundStitching();
+          
+        /// Laedt den Sound.
+        virtual void load() throw (RuntimeException) = 0;
+        /// Entlaedt den Sound.
+        virtual void unload() throw (RuntimeException) = 0;
+
+        virtual float getLength() const;
+
+        // SoundResource zurueckgeben.
+        const SoundResourcePtr& getSoundResource() const;
+        // Wollen wir 3D?
+        bool is3d() const;
+        // Setzen des 3D-Flags.
+        void set3d(bool is3d);
+        // Sind wir gueltig
+        virtual bool isValid() const throw (RuntimeException) = 0;
+        
+        // Sollen der Sound wiederholt werden?
+        bool isLooping() const;
+        // Setzen des Loop-Flags.
+        void setLooping(bool looping);
+
+        /// Unsere Bounding-Box
+        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
+        /// Bound-Radius
+        virtual Ogre::Real getBoundingRadius() const;
+        /// Rendern
+        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+
+        /// Count of configured slots.
+        unsigned int getNumSlots();
+        /// Add a sound resource to the cache overwritting existing sound resource.
+        virtual void addSoundToCache(CeGuiString label, SoundResourcePtr sound);
+        /// Assign a sound recource to a slot.
+        virtual void putSoundIntoSlot(unsigned int, CeGuiString label) = 0;
+        /// Get the slot of the plaing sound.
+        virtual unsigned int getPlayingSlot() = 0;
+
+        /// Gibt die eingestellte Position der Soundquelle zurueck
+        virtual const Ogre::Vector3 getPosition() const = 0;
+        /// Setzt die Position der Soundquelle.
+        virtual void setPosition(const Ogre::Vector3& direction) = 0;
+        /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
+	    virtual const Ogre::Real getVolume() const = 0; 
+        /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
+	    virtual void setVolume(const Ogre::Real gain) = 0;
+        /// Gibt die Richtung der Soundquelle zurueck.
+        virtual const Ogre::Quaternion getDirection() const = 0;
+        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
+        virtual const Ogre::Vector3 getVelocity() const = 0;
+        /// Setzt die Richtung der Soundquelle.
+        virtual void setDirection(const Ogre::Quaternion&) = 0;
+        /// Setzt die Geschwindigkeit der Soundquelle.
+        virtual void setVelocity(const Ogre::Vector3&) = 0;
+	    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
+	    virtual void setRolloffStartDistance(const Ogre::Real&);
+	    virtual const Ogre::Real getRolloffStartDistance() const;
+	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
+	    virtual void setRolloffEndDistance(const Ogre::Real&);
+	    virtual const Ogre::Real getRolloffEndDistance() const;
+        // Sets the priority of this sound
+        virtual void setPriority(const int priority) = 0;
+        // Gets the priority of this sound
+        virtual const int getPriority() const = 0;
+
+        /// Spielt den Sound ab.
+        virtual void play(bool destroyWhenDone=false) = 0;
+        /// Pausiert den Sound.
+        virtual void pause(bool pausing) = 0;
+        /// Ist der Sound pausiert?
+        virtual bool isPaused() = 0;
+        /// Stoppt den Sound.
+        virtual void stop() = 0;
+        /// Laeuft der Sound noch
+        virtual const bool isPlaying() const = 0;
+
+		/// From MovableObject
+		virtual void visitRenderables(Ogre::Renderable::Visitor* visitor, 
+			bool debugRenderables = false);
+
+    protected:
+        SoundDriver* mCreator;
+
+        /// Die Lautstaerke
+	    Ogre::Real mVolume;
+        /// Die Position
+        Ogre::Vector3 mPosition;
+        /// Die Richtung
+        Ogre::Quaternion mDirection;
+        /// Die Geschwindigkeit
+        Ogre::Vector3 mVelocity;
+        /// The priority of this sound
+        int mPriority;
+
+	    Ogre::Real mRolloffStartDistance;
+	    Ogre::Real mRolloffEndDistance;
+
+        // Sound-Cache
+        SoundCache mSoundCache;
+
+    private:
+        /// Shared class-level name for Movable type
+        static Ogre::AxisAlignedBox msAABox;
+
+        /// Der Soundresource, auf den wir verweisen.
+        SoundResourcePtr mSoundResource;
+
+        // Damit die Timings alle 0.5 sek. abgeschickt werden.
+        int mTicks;
+        // Ob dieser Sound 3D sein soll.
+        bool mIs3d;
+        // Ob dieser Sound loopen soll.
+        bool mIsLooping;
+
+        // Anzahl der Soundslots
+        unsigned int mNumSlots;
+
+        // Name
+        CeGuiString mName;
+        
+    }; 
+
+}
+#endif
+

Modified: rl/trunk/engine/core/src/Actor.cpp
===================================================================
--- rl/trunk/engine/core/src/Actor.cpp	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/core/src/Actor.cpp	2008-11-19 22:04:20 UTC (rev 4593)
@@ -434,17 +434,17 @@
             node->setScale( vec );
 
             // Falls es sich um ein Mesh handelt ...
-            if( getControlledObject()->isMeshObject() )
+/*            if( getControlledObject()->isMeshObject() )
             {
                 MeshObject* meshObj = dynamic_cast<MeshObject*>( getControlledObject() );
 
                 // ... und gr??er/kleiner als normal skaliert wird ...
                 if( vec != Vector3(1,1,1) )
                     // ... m?ssen die Normalen neu berechnet werden.
-                    meshObj->getEntity()->setNormaliseNormals( true );
+					meshObj->getEntity()->setNormaliseNormals( true );
                 else
                     meshObj->getEntity()->setNormaliseNormals( false );
-            }
+            }*/
         }
     }
 

Modified: rl/trunk/engine/core/src/DotSceneLoader.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneLoader.cpp	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/core/src/DotSceneLoader.cpp	2008-11-19 22:04:20 UTC (rev 4593)
@@ -771,8 +771,10 @@
               return;
         }
 
-        if (parentNode->getScale() != Vector3::UNIT_SCALE)
+        /*if (parentNode->getScale() != Vector3::UNIT_SCALE) 
+		{
             newEnt->setNormaliseNormals(true);
+		}*/
 
         parentNode->attachObject(newEnt);
 

Modified: rl/trunk/engine/core/src/ListenerMovable.cpp
===================================================================
--- rl/trunk/engine/core/src/ListenerMovable.cpp	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/core/src/ListenerMovable.cpp	2008-11-19 22:04:20 UTC (rev 4593)
@@ -203,4 +203,9 @@
 	mActive = active;
 }
 
+void ListenerMovable::visitRenderables(Renderable::Visitor* visitor, 
+			bool debugRenderables)
+{
 }
+
+}

Modified: rl/trunk/engine/core/src/MovableText.cpp
===================================================================
--- rl/trunk/engine/core/src/MovableText.cpp	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/core/src/MovableText.cpp	2008-11-19 22:04:20 UTC (rev 4593)
@@ -554,4 +554,11 @@
     {
         return mAlignment;
     }
+
+    /************************************************************************/
+	void MovableText::visitRenderables(Renderable::Visitor* visitor, 
+			bool debugRenderables)
+	{
+		visitor->visit(this, 0, debugRenderables);
+	}
 }

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2008-11-19 22:04:20 UTC (rev 4593)
@@ -130,8 +130,8 @@
 		if (mBody && mActor)
 		{
 			mBody->setPositionOrientation(
-				mActor->_getSceneNode()->getWorldPosition(),
-				mActor->_getSceneNode()->getWorldOrientation());
+				mActor->_getSceneNode()->_getDerivedPosition(),
+				mActor->_getSceneNode()->_getDerivedOrientation());
 			mActor->_update(Actor::UF_ALL & ~Actor::UF_PHYSICAL_THING);
 		}
     }

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2008-11-19 22:04:20 UTC (rev 4593)
@@ -315,8 +315,8 @@
 
 
             body->attachToNode(node);
-            body->setPositionOrientation(node->getWorldPosition(),
-                node->getWorldOrientation());
+            body->setPositionOrientation(node->_getDerivedPosition(),
+                node->_getDerivedOrientation());
             body->setMaterialGroupID(getMaterialID("level"));
 
 			mLevelBodiesQuadTree.add(body);

Modified: rl/trunk/engine/core/src/Sound.cpp
===================================================================
--- rl/trunk/engine/core/src/Sound.cpp	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/core/src/Sound.cpp	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,148 +1,153 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "Sound.h"
-#include "SoundDriver.h"
-
-using namespace Ogre;
-
-namespace rl
-{
-
-AxisAlignedBox Sound::msAABox = Ogre::AxisAlignedBox(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
-
-Sound::Sound(const SoundResourcePtr &soundres, SoundDriver* creator)
-: MovableObject(soundres->getName()),
-   EventSource(),
-   EventCaster<SoundEvent>(),
-   mCreator(creator),
-   mVolume(1.0),
-   mSoundResource(soundres),
-   mIsLooping(false),
-   mIs3d(false),
-   mTicks(0),
-   mPosition(Vector3::ZERO),
-   mDirection(Quaternion::IDENTITY),
-   mVelocity(Vector3::ZERO),
-   mPriority(128),
-   mRolloffStartDistance(1.0),
-   mRolloffEndDistance(10000.0)
-{
-}
-
-Sound::~Sound()
-{
-}
-
-/**
- * @return Ob der Sound wiederholt werden soll
- * @author JoSch
- * @date 08-08-2005
- */
-bool Sound::isLooping() const
-{
-    return mIsLooping;
-}
-
-/**
- * @param looping Ob der Sound wiederholt werden soll
- * @author JoSch
- * @date 08-08-2005
- */
-void Sound::setLooping(bool looping)
-{
-    mIsLooping = looping;
-}
-
-/**
- * @return Ob der Sound ein 3D-Sound ist.
- * @author JoSch
- * @date 08-08-2005
- */
-bool Sound::is3d() const
-{
-    return mIs3d;
-}
-
-/**
- * @param is3d Ob der Sound ein 3D-Sound ist.
- * @author JoSch
- * @date 08-08-2005
- */
-void Sound::set3d(bool is3d)
-{
-    mIs3d = is3d;
-}
-
-/** SoundResource zur?ckgeben.
- * @return Der Pointer auf die zugeh?rige Soundresource.
- * @author JoSch
- * @date 08-08-2005
- */
-const SoundResourcePtr &Sound::getSoundResource() const
-{
-    return mSoundResource;
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-const AxisAlignedBox& Sound::getBoundingBox() const
-{
-    return msAABox;
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-Real Sound::getBoundingRadius (void) const
-{
-    return 0.0f; // SQRT(3*SQR(0.0)) to fit with AABB
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-void Sound::_updateRenderQueue(RenderQueue *queue)
-{
-    // Brauchen wir nicht
-}
-
-void Sound::setRolloffStartDistance(const Ogre::Real& distance)
-{
-	mRolloffStartDistance = distance;
-}
-
-const Ogre::Real Sound::getRolloffStartDistance() const
-{
-	return mRolloffStartDistance;
-}
-
-void Sound::setRolloffEndDistance(const Ogre::Real& distance)
-{
-	mRolloffEndDistance = distance;
-}
-
-const Ogre::Real Sound::getRolloffEndDistance() const
-{
-	return mRolloffEndDistance;
-}
-
-};
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "Sound.h"
+#include "SoundDriver.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+
+AxisAlignedBox Sound::msAABox = Ogre::AxisAlignedBox(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
+
+Sound::Sound(const SoundResourcePtr &soundres, SoundDriver* creator)
+: MovableObject(soundres->getName()),
+   EventSource(),
+   EventCaster<SoundEvent>(),
+   mCreator(creator),
+   mVolume(1.0),
+   mSoundResource(soundres),
+   mIsLooping(false),
+   mIs3d(false),
+   mTicks(0),
+   mPosition(Vector3::ZERO),
+   mDirection(Quaternion::IDENTITY),
+   mVelocity(Vector3::ZERO),
+   mPriority(128),
+   mRolloffStartDistance(1.0),
+   mRolloffEndDistance(10000.0)
+{
+}
+
+Sound::~Sound()
+{
+}
+
+/**
+ * @return Ob der Sound wiederholt werden soll
+ * @author JoSch
+ * @date 08-08-2005
+ */
+bool Sound::isLooping() const
+{
+    return mIsLooping;
+}
+
+/**
+ * @param looping Ob der Sound wiederholt werden soll
+ * @author JoSch
+ * @date 08-08-2005
+ */
+void Sound::setLooping(bool looping)
+{
+    mIsLooping = looping;
+}
+
+/**
+ * @return Ob der Sound ein 3D-Sound ist.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+bool Sound::is3d() const
+{
+    return mIs3d;
+}
+
+/**
+ * @param is3d Ob der Sound ein 3D-Sound ist.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+void Sound::set3d(bool is3d)
+{
+    mIs3d = is3d;
+}
+
+/** SoundResource zur?ckgeben.
+ * @return Der Pointer auf die zugeh?rige Soundresource.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+const SoundResourcePtr &Sound::getSoundResource() const
+{
+    return mSoundResource;
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+const AxisAlignedBox& Sound::getBoundingBox() const
+{
+    return msAABox;
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+Real Sound::getBoundingRadius (void) const
+{
+    return 0.0f; // SQRT(3*SQR(0.0)) to fit with AABB
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+void Sound::_updateRenderQueue(RenderQueue *queue)
+{
+    // Brauchen wir nicht
+}
+
+void Sound::setRolloffStartDistance(const Ogre::Real& distance)
+{
+	mRolloffStartDistance = distance;
+}
+
+const Ogre::Real Sound::getRolloffStartDistance() const
+{
+	return mRolloffStartDistance;
+}
+
+void Sound::setRolloffEndDistance(const Ogre::Real& distance)
+{
+	mRolloffEndDistance = distance;
+}
+
+const Ogre::Real Sound::getRolloffEndDistance() const
+{
+	return mRolloffEndDistance;
+}
+
+void Sound::visitRenderables(Renderable::Visitor* visitor, 
+			bool debugRenderables)
+{
+}
+
+};

Modified: rl/trunk/engine/core/src/SoundResource.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundResource.cpp	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/core/src/SoundResource.cpp	2008-11-19 22:04:20 UTC (rev 4593)
@@ -85,15 +85,6 @@
 }
 
 /**
- * @author JoSch
- * @date 03-14-2005
- */
-int SoundResource::getSize() const
-{
-    return calculateSize();
-}
-
-/**
  * @author Blakharaz
  * @date 03-14-2005
  */

Modified: rl/trunk/engine/core/src/SoundStitching.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundStitching.cpp	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/core/src/SoundStitching.cpp	2008-11-19 22:04:20 UTC (rev 4593)
@@ -1,166 +1,171 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "SoundStitching.h"
-#include "SoundDriver.h"
-
-using namespace Ogre;
-
-namespace rl
-{
-
-AxisAlignedBox SoundStitching::msAABox = Ogre::AxisAlignedBox(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
-
-SoundStitching::SoundStitching(unsigned int numSlots, const CeGuiString& name, SoundDriver* creator)
-:  MovableObject(name.c_str()),
-   EventSource(),
-   EventCaster<SoundEvent>(),
-   mCreator(creator),
-   mVolume(1.0),
-   mName(name),
-   mIsLooping(true),
-   mIs3d(false),
-   mTicks(0),
-   mPosition(Vector3::ZERO),
-   mDirection(Quaternion::IDENTITY),
-   mVelocity(Vector3::ZERO),
-   mPriority(128),
-   mRolloffStartDistance(1.0),
-   mRolloffEndDistance(10000.0),
-   mNumSlots(numSlots)
-{
-}
-
-SoundStitching::~SoundStitching()
-{
-}
-
-/**
- * @return Ob der Sound wiederholt werden soll
- * @author JoSch
- * @date 08-08-2005
- */
-bool SoundStitching::isLooping() const
-{
-    return mIsLooping;
-}
-
-/**
- * @param looping Ob der Sound wiederholt werden soll
- * @author JoSch
- * @date 08-08-2005
- */
-void SoundStitching::setLooping(bool looping)
-{
-    mIsLooping = looping;
-}
-
-/**
- * @return Ob der Sound ein 3D-Sound ist.
- * @author JoSch
- * @date 08-08-2005
- */
-bool SoundStitching::is3d() const
-{
-    return mIs3d;
-}
-
-/**
- * @param is3d Ob der Sound ein 3D-Sound ist.
- * @author JoSch
- * @date 08-08-2005
- */
-void SoundStitching::set3d(bool is3d)
-{
-    mIs3d = is3d;
-}
-
-/** SoundResource zur?ckgeben.
- * @return Der Pointer auf die zugeh?rige Soundresource.
- * @author JoSch
- * @date 08-08-2005
- */
-const SoundResourcePtr &SoundStitching::getSoundResource() const
-{
-    return mSoundResource;
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-const AxisAlignedBox& SoundStitching::getBoundingBox() const
-{
-    return msAABox;
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-Real SoundStitching::getBoundingRadius (void) const
-{
-    return 0.0f; // SQRT(3*SQR(0.0)) to fit with AABB
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-void SoundStitching::_updateRenderQueue(RenderQueue *queue)
-{
-    // Brauchen wir nicht
-}
-
-void SoundStitching::setRolloffStartDistance(const Ogre::Real& distance)
-{
-	mRolloffStartDistance = distance;
-}
-
-const Ogre::Real SoundStitching::getRolloffStartDistance() const
-{
-	return mRolloffStartDistance;
-}
-
-void SoundStitching::setRolloffEndDistance(const Ogre::Real& distance)
-{
-	mRolloffEndDistance = distance;
-}
-
-const Ogre::Real SoundStitching::getRolloffEndDistance() const
-{
-	return mRolloffEndDistance;
-}
-
-
-void SoundStitching::addSoundToCache(CeGuiString label, SoundResourcePtr sound)
-{
-    mSoundCache[label] = sound;
-}
-
-unsigned int SoundStitching::getNumSlots()
-{
-    return mNumSlots;
-}
-
-float SoundStitching::getLength() const
-{
-    return 0.0f;
-}
-
-};
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "SoundStitching.h"
+#include "SoundDriver.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+
+AxisAlignedBox SoundStitching::msAABox = Ogre::AxisAlignedBox(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
+
+SoundStitching::SoundStitching(unsigned int numSlots, const CeGuiString& name, SoundDriver* creator)
+:  MovableObject(name.c_str()),
+   EventSource(),
+   EventCaster<SoundEvent>(),
+   mCreator(creator),
+   mVolume(1.0),
+   mName(name),
+   mIsLooping(true),
+   mIs3d(false),
+   mTicks(0),
+   mPosition(Vector3::ZERO),
+   mDirection(Quaternion::IDENTITY),
+   mVelocity(Vector3::ZERO),
+   mPriority(128),
+   mRolloffStartDistance(1.0),
+   mRolloffEndDistance(10000.0),
+   mNumSlots(numSlots)
+{
+}
+
+SoundStitching::~SoundStitching()
+{
+}
+
+/**
+ * @return Ob der Sound wiederholt werden soll
+ * @author JoSch
+ * @date 08-08-2005
+ */
+bool SoundStitching::isLooping() const
+{
+    return mIsLooping;
+}
+
+/**
+ * @param looping Ob der Sound wiederholt werden soll
+ * @author JoSch
+ * @date 08-08-2005
+ */
+void SoundStitching::setLooping(bool looping)
+{
+    mIsLooping = looping;
+}
+
+/**
+ * @return Ob der Sound ein 3D-Sound ist.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+bool SoundStitching::is3d() const
+{
+    return mIs3d;
+}
+
+/**
+ * @param is3d Ob der Sound ein 3D-Sound ist.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+void SoundStitching::set3d(bool is3d)
+{
+    mIs3d = is3d;
+}
+
+/** SoundResource zur?ckgeben.
+ * @return Der Pointer auf die zugeh?rige Soundresource.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+const SoundResourcePtr &SoundStitching::getSoundResource() const
+{
+    return mSoundResource;
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+const AxisAlignedBox& SoundStitching::getBoundingBox() const
+{
+    return msAABox;
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+Real SoundStitching::getBoundingRadius (void) const
+{
+    return 0.0f; // SQRT(3*SQR(0.0)) to fit with AABB
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+void SoundStitching::_updateRenderQueue(RenderQueue *queue)
+{
+    // Brauchen wir nicht
+}
+
+void SoundStitching::setRolloffStartDistance(const Ogre::Real& distance)
+{
+	mRolloffStartDistance = distance;
+}
+
+const Ogre::Real SoundStitching::getRolloffStartDistance() const
+{
+	return mRolloffStartDistance;
+}
+
+void SoundStitching::setRolloffEndDistance(const Ogre::Real& distance)
+{
+	mRolloffEndDistance = distance;
+}
+
+const Ogre::Real SoundStitching::getRolloffEndDistance() const
+{
+	return mRolloffEndDistance;
+}
+
+
+void SoundStitching::addSoundToCache(CeGuiString label, SoundResourcePtr sound)
+{
+    mSoundCache[label] = sound;
+}
+
+unsigned int SoundStitching::getNumSlots()
+{
+    return mNumSlots;
+}
+
+float SoundStitching::getLength() const
+{
+    return 0.0f;
+}
+
+void SoundStitching::visitRenderables(Renderable::Visitor* visitor, 
+			bool debugRenderables)
+{
+}
+
+};
+

Modified: rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2008-11-19 22:04:20 UTC (rev 4593)
@@ -222,8 +222,8 @@
 
 	void PlaneReflectionTextureListener::preRenderTargetUpdate(const RenderTargetEvent &evt)
 	{
-		mCamera->setPosition(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getWorldPosition());
-		mCamera->setOrientation(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getWorldOrientation());
+		mCamera->setPosition(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getDerivedPosition());
+		mCamera->setOrientation(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getDerivedOrientation());
 		mEntity->setVisible(false);
 		mCamera->enableReflection((MovablePlane*)mPlane);
 	}
@@ -242,8 +242,8 @@
 
 	void PlaneRefractionTextureListener::preRenderTargetUpdate(const Ogre::RenderTargetEvent& evt)
 	{
-		mCamera->setPosition(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getWorldPosition());
-		mCamera->setOrientation(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getWorldOrientation());
+		mCamera->setPosition(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getDerivedPosition());
+		mCamera->setOrientation(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getDerivedOrientation());
 		mEntity->setVisible(false);
 	}
 

Modified: rl/trunk/engine/ui/src/DebugWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DebugWindow.cpp	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/ui/src/DebugWindow.cpp	2008-11-19 22:04:20 UTC (rev 4593)
@@ -186,8 +186,8 @@
 
             if( charObj != NULL )
             {
-                Ogre::Vector3 pos = charObj->getMovableObject()->getParentNode()->getWorldPosition();
-                Ogre::Quaternion ori = charObj->getMovableObject()->getParentNode()->getWorldOrientation();
+                Ogre::Vector3 pos = charObj->getMovableObject()->getParentNode()->_getDerivedPosition();
+                Ogre::Quaternion ori = charObj->getMovableObject()->getParentNode()->_getDerivedOrientation();
 
                 textSt += "\nPlayer Position [ "
                     + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+", "

Modified: rl/trunk/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogControlState.cpp	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/ui/src/DialogControlState.cpp	2008-11-19 22:04:20 UTC (rev 4593)
@@ -220,8 +220,8 @@
 
         // Weltkoordinaten in lokale umwandeln
         mTargetCameraPosition =
-            -1*(mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldOrientation().Inverse()*
-            (mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldPosition() - globalCameraPosition));
+            -1*(mCameraActor->_getSceneNode()->getParentSceneNode()->_getDerivedOrientation().Inverse()*
+            (mCameraActor->_getSceneNode()->getParentSceneNode()->_getDerivedPosition() - globalCameraPosition));
 
         mTargetCameraDirection = (listenerEyes - mTargetCameraPosition).normalisedCopy();
     }

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2008-11-19 21:00:18 UTC (rev 4592)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2008-11-19 22:04:20 UTC (rev 4593)
@@ -448,7 +448,7 @@
 		mousePos.d_y /= getRoot()->getPixelSize().d_height;
 		Ogre::Ray camToWorld = camera->getCameraToViewportRay(
 			mousePos.d_x, mousePos.d_y);
-		Ogre::Vector3 rayStart = camera->getCamera()->getWorldPosition();
+		Ogre::Vector3 rayStart = camera->getCamera()->getDerivedPosition();
 		Ogre::Vector3 rayDir = camera->getDirectionFromScreenPosition(
 			mousePos.d_x, mousePos.d_y);
 



From timm at mail.berlios.de  Fri Nov 21 16:18:38 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Fri, 21 Nov 2008 16:18:38 +0100
Subject: [Dsa-hl-svn] r4594 - modules/common/materials/particle
Message-ID: <200811211518.mALFIcBV024063@sheep.berlios.de>

Author: timm
Date: 2008-11-21 16:18:24 +0100 (Fri, 21 Nov 2008)
New Revision: 4594

Modified:
   modules/common/materials/particle/Fackel.particle
   modules/common/materials/particle/feuertest.particle
   modules/common/materials/particle/glow01.particle
   modules/common/materials/particle/kerzenflamme.particle
   modules/common/materials/particle/lagerfeuer.particle
   modules/common/materials/particle/regen.particle
   modules/common/materials/particle/sandsturm.particle
Log:
fixed particle scripts

Modified: modules/common/materials/particle/Fackel.particle
===================================================================
--- modules/common/materials/particle/Fackel.particle	2008-11-19 22:04:20 UTC (rev 4593)
+++ modules/common/materials/particle/Fackel.particle	2008-11-21 15:18:24 UTC (rev 4594)
@@ -1,5 +1,4 @@
-
-flammen
+particle_system flammen
 {
 	quota	10
 	material	fackel

Modified: modules/common/materials/particle/feuertest.particle
===================================================================
--- modules/common/materials/particle/feuertest.particle	2008-11-19 22:04:20 UTC (rev 4593)
+++ modules/common/materials/particle/feuertest.particle	2008-11-21 15:18:24 UTC (rev 4594)
@@ -1,4 +1,4 @@
-feuertest
+particle_system feuertest
 {
 	quota	30
 	material	glow01

Modified: modules/common/materials/particle/glow01.particle
===================================================================
--- modules/common/materials/particle/glow01.particle	2008-11-19 22:04:20 UTC (rev 4593)
+++ modules/common/materials/particle/glow01.particle	2008-11-21 15:18:24 UTC (rev 4594)
@@ -1,4 +1,4 @@
-glow01
+particle_system glow01
 {
 	quota	1000
 	material	glow01

Modified: modules/common/materials/particle/kerzenflamme.particle
===================================================================
--- modules/common/materials/particle/kerzenflamme.particle	2008-11-19 22:04:20 UTC (rev 4593)
+++ modules/common/materials/particle/kerzenflamme.particle	2008-11-21 15:18:24 UTC (rev 4594)
@@ -1,5 +1,4 @@
-
-Kerzenflammen
+particle_system Kerzenflammen
 {
 	quota	10
 	material	fackel

Modified: modules/common/materials/particle/lagerfeuer.particle
===================================================================
--- modules/common/materials/particle/lagerfeuer.particle	2008-11-19 22:04:20 UTC (rev 4593)
+++ modules/common/materials/particle/lagerfeuer.particle	2008-11-21 15:18:24 UTC (rev 4594)
@@ -1,5 +1,4 @@
-
-feuer
+particle_system feuer
 {
 	quota	1500
 	material	feuer

Modified: modules/common/materials/particle/regen.particle
===================================================================
--- modules/common/materials/particle/regen.particle	2008-11-19 22:04:20 UTC (rev 4593)
+++ modules/common/materials/particle/regen.particle	2008-11-21 15:18:24 UTC (rev 4594)
@@ -1,5 +1,4 @@
-
-regen
+particle_system regen
 {
 	quota	1000
 	material	regen

Modified: modules/common/materials/particle/sandsturm.particle
===================================================================
--- modules/common/materials/particle/sandsturm.particle	2008-11-19 22:04:20 UTC (rev 4593)
+++ modules/common/materials/particle/sandsturm.particle	2008-11-21 15:18:24 UTC (rev 4594)
@@ -1,4 +1,4 @@
-Rl/Sandsturm
+particle_system Rl/Sandsturm
 {
 	quota	50
 	material	RL/Sandsturm



From timm at mail.berlios.de  Fri Nov 21 16:20:34 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Fri, 21 Nov 2008 16:20:34 +0100
Subject: [Dsa-hl-svn] r4595 - modules/kanalisation/materials
Message-ID: <200811211520.mALFKY84024163@sheep.berlios.de>

Author: timm
Date: 2008-11-21 16:20:26 +0100 (Fri, 21 Nov 2008)
New Revision: 4595

Modified:
   modules/kanalisation/materials/vlight.particle
   modules/kanalisation/materials/waber.particle
Log:
fixed particle scripts of kanalisation

Modified: modules/kanalisation/materials/vlight.particle
===================================================================
--- modules/kanalisation/materials/vlight.particle	2008-11-21 15:18:24 UTC (rev 4594)
+++ modules/kanalisation/materials/vlight.particle	2008-11-21 15:20:26 UTC (rev 4595)
@@ -1,4 +1,4 @@
-vlight
+particle_system vlight
 {
 	quota	10
 	material	vlight

Modified: modules/kanalisation/materials/waber.particle
===================================================================
--- modules/kanalisation/materials/waber.particle	2008-11-21 15:18:24 UTC (rev 4594)
+++ modules/kanalisation/materials/waber.particle	2008-11-21 15:20:26 UTC (rev 4595)
@@ -1,4 +1,4 @@
-waber
+particle_system waber
 {
 	quota	200
 	material	waber



From timm at mail.berlios.de  Fri Nov 21 16:24:20 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Fri, 21 Nov 2008 16:24:20 +0100
Subject: [Dsa-hl-svn] r4596 - in modules: ruchin/materials techdemo/materials
Message-ID: <200811211524.mALFOKZA024483@sheep.berlios.de>

Author: timm
Date: 2008-11-21 16:24:13 +0100 (Fri, 21 Nov 2008)
New Revision: 4596

Modified:
   modules/ruchin/materials/feuertest.particle
   modules/ruchin/materials/nebel.particle
   modules/ruchin/materials/qualm.particle
   modules/techdemo/materials/hen.particle
   modules/techdemo/materials/staubwolke.particle
   modules/techdemo/materials/taenzelnderstaub.particle
Log:
and updates particle scrips of ruchin and techdemo

Modified: modules/ruchin/materials/feuertest.particle
===================================================================
--- modules/ruchin/materials/feuertest.particle	2008-11-21 15:20:26 UTC (rev 4595)
+++ modules/ruchin/materials/feuertest.particle	2008-11-21 15:24:13 UTC (rev 4596)
@@ -1,4 +1,4 @@
-feuertest2
+particle_system feuertest2
 {
 	quota	70
 	material	feuertest

Modified: modules/ruchin/materials/nebel.particle
===================================================================
--- modules/ruchin/materials/nebel.particle	2008-11-21 15:20:26 UTC (rev 4595)
+++ modules/ruchin/materials/nebel.particle	2008-11-21 15:24:13 UTC (rev 4596)
@@ -1,4 +1,4 @@
-nebel
+particle_system nebel
 {
 	quota	80
 	material	nebel

Modified: modules/ruchin/materials/qualm.particle
===================================================================
--- modules/ruchin/materials/qualm.particle	2008-11-21 15:20:26 UTC (rev 4595)
+++ modules/ruchin/materials/qualm.particle	2008-11-21 15:24:13 UTC (rev 4596)
@@ -1,5 +1,4 @@
-
-qualm
+particle_system qualm
 {
 	quota	10
 	material	qualm

Modified: modules/techdemo/materials/hen.particle
===================================================================
--- modules/techdemo/materials/hen.particle	2008-11-21 15:20:26 UTC (rev 4595)
+++ modules/techdemo/materials/hen.particle	2008-11-21 15:24:13 UTC (rev 4596)
@@ -1,5 +1,4 @@
-
-PEExamples/explo
+particle_system PEExamples/explo
 {
 	quota	50
 	material	RL/flamme

Modified: modules/techdemo/materials/staubwolke.particle
===================================================================
--- modules/techdemo/materials/staubwolke.particle	2008-11-21 15:20:26 UTC (rev 4595)
+++ modules/techdemo/materials/staubwolke.particle	2008-11-21 15:24:13 UTC (rev 4596)
@@ -1,4 +1,4 @@
-Techdemo/Steinstaubwolke
+particle_system Techdemo/Steinstaubwolke
 {
 	quota	200
 	material	RL/Staubwolke

Modified: modules/techdemo/materials/taenzelnderstaub.particle
===================================================================
--- modules/techdemo/materials/taenzelnderstaub.particle	2008-11-21 15:20:26 UTC (rev 4595)
+++ modules/techdemo/materials/taenzelnderstaub.particle	2008-11-21 15:24:13 UTC (rev 4596)
@@ -1,5 +1,4 @@
-
-staub
+particle_system staub
 {
 	quota	500
 	material	staub



From timm at mail.berlios.de  Fri Nov 21 16:25:35 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Fri, 21 Nov 2008 16:25:35 +0100
Subject: [Dsa-hl-svn] r4597 - in modules: . branch_persistenz
	branch_persistenz/dsa branch_persistenz/gui
	branch_persistenz/gui/windows branch_persistenz/maps
	branch_persistenz/materials
	branch_persistenz/materials/textures branch_persistenz/models
	branch_persistenz/quests branch_persistenz/scripts
	branch_persistenz/scripts/maps
Message-ID: <200811211525.mALFPZxi024559@sheep.berlios.de>

Author: timm
Date: 2008-11-21 16:24:57 +0100 (Fri, 21 Nov 2008)
New Revision: 4597

Added:
   modules/branch_persistenz/
   modules/branch_persistenz/dialogs/
   modules/branch_persistenz/dsa/
   modules/branch_persistenz/dsa/gameobjectdefinitions.gof
   modules/branch_persistenz/gui/
   modules/branch_persistenz/gui/fonts/
   modules/branch_persistenz/gui/imagesets/
   modules/branch_persistenz/gui/schemes/
   modules/branch_persistenz/gui/windows/
   modules/branch_persistenz/gui/windows/buttons/
   modules/branch_persistenz/maps/
   modules/branch_persistenz/maps/Cube.mesh
   modules/branch_persistenz/maps/hero.rlmap.xml
   modules/branch_persistenz/maps/map01.rlscene
   modules/branch_persistenz/maps/map02.rlscene
   modules/branch_persistenz/maps/persistenztest01.rlmap.xml
   modules/branch_persistenz/maps/persistenztest02.rlmap.xml
   modules/branch_persistenz/maps/regressiontest_floorplane.mesh
   modules/branch_persistenz/materials/
   modules/branch_persistenz/materials/Numbers.material
   modules/branch_persistenz/materials/ins_rucksack.material
   modules/branch_persistenz/materials/nx.grid.material
   modules/branch_persistenz/materials/nx.particles.material
   modules/branch_persistenz/materials/nx.shapes.material
   modules/branch_persistenz/materials/nx.stairs.material
   modules/branch_persistenz/materials/nx.track.material
   modules/branch_persistenz/materials/nx.zones.material
   modules/branch_persistenz/materials/textures/
   modules/branch_persistenz/materials/textures/Thumbs.db
   modules/branch_persistenz/materials/textures/ins_rucksack.png
   modules/branch_persistenz/materials/textures/nx.grid.axis.png
   modules/branch_persistenz/materials/textures/nx.grid.floor.png
   modules/branch_persistenz/materials/textures/nx.particle.smoke.png
   modules/branch_persistenz/materials/textures/nx.particle.steam.png
   modules/branch_persistenz/materials/textures/nx.static.wall.png
   modules/branch_persistenz/materials/textures/nx.trafficcone.png
   modules/branch_persistenz/materials/textures/nx.zone.blue.png
   modules/branch_persistenz/materials/textures/nx.zone.green.png
   modules/branch_persistenz/materials/textures/nx.zone.nogravity.png
   modules/branch_persistenz/materials/textures/nx.zone.orange.png
   modules/branch_persistenz/materials/textures/nx.zone.pink.png
   modules/branch_persistenz/materials/textures/obj_shortsleeve_dummy.png
   modules/branch_persistenz/medianotes.txt
   modules/branch_persistenz/models/
   modules/branch_persistenz/models/Number1.mesh
   modules/branch_persistenz/models/Number2.mesh
   modules/branch_persistenz/models/cube.1m-2m-1m.mesh
   modules/branch_persistenz/models/cube.1m.mesh
   modules/branch_persistenz/models/ins_rucksack.mesh
   modules/branch_persistenz/models/nx.chair.mesh
   modules/branch_persistenz/models/nx.convex1.mesh
   modules/branch_persistenz/models/nx.crosshair.mesh
   modules/branch_persistenz/models/nx.raycaster.mesh
   modules/branch_persistenz/models/nx.stairs1.mesh
   modules/branch_persistenz/models/nx.trafficcone.mesh
   modules/branch_persistenz/models/sphere.1m.mesh
   modules/branch_persistenz/quests/
   modules/branch_persistenz/quests/test.quests
   modules/branch_persistenz/scripts/
   modules/branch_persistenz/scripts/MapChange.rb
   modules/branch_persistenz/scripts/maps/
   modules/branch_persistenz/scripts/maps/map01.rb
   modules/branch_persistenz/scripts/maps/map02.rb
   modules/branch_persistenz/scripts/maps/persistenztest.rb
   modules/branch_persistenz/scripts/maps/setchar.rb
   modules/branch_persistenz/scripts/moduleconfig.rb
   modules/branch_persistenz/sound/
Modified:
   modules/modules.cfg
Log:
added persistenz branch testing module

Added: modules/branch_persistenz/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/branch_persistenz/dsa/gameobjectdefinitions.gof	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/dsa/gameobjectdefinitions.gof	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,211 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<GameObjectDefinitions>
+
+    <gameobjectclass classid="Holzscheit" baseclass="GameObject">
+        <property name="name" type="STRING" data="Holzscheit"/>
+        <property name="description" type="STRING" data="Greater log of time check. (Very rare)"/>
+        <property name="meshfile" type="STRING" data="ver_holzscheit_01.mesh"/>
+    </gameobjectclass>
+	
+	<gameobjectclass classid="number1" baseclass="GameObject">
+        <property name="name" type="STRING" data="1"/>
+        <property name="description" type="STRING" data="Karte Nummer 1"/>
+        <property name="meshfile" type="STRING" data="Number1.mesh"/>
+        <property name="geometrytype" type="STRING" data="capsule"/>
+        <property name="mass" type="REAL" data="200"/>
+    </gameobjectclass>
+	
+	<gameobjectclass classid="number2" baseclass="GameObject">
+        <property name="name" type="STRING" data="2"/>
+        <property name="description" type="STRING" data="Karte Nummer 2"/>
+        <property name="meshfile" type="STRING" data="Number2.mesh"/>
+        <property name="geometrytype" type="STRING" data="box"/>
+        <property name="mass" type="REAL" data="200"/>
+    </gameobjectclass>
+
+    <gameobjectclass classid="apple" baseclass="GameObject">
+        <property name="name" type="STRING" data="Apfel"/>
+        <property name="description" type="STRING" data="Ein Apfel?"/>
+        <property name="meshfile" type="STRING" data="sphere.1m.mesh"/>
+        <property name="geometrytype" type="STRING" data="ellipsoid"/>
+        <property name="mass" type="REAL" data="65"/>
+    </gameobjectclass>
+
+    <gameobjectclass classid="apple2" baseclass="GameObject" inherits="apple">
+        <property name="name" type="STRING" data="Apfel 2.0"/>
+        <property name="description" type="STRING" data="Ein Apfel. Definitiv."/>
+        <property name="mass" type="REAL" data="75"/>
+    </gameobjectclass>
+
+    <gameobjectclass classid="TestPerson" baseclass="NPC">
+        <property name="name" type="STRING" data="TestPerson"/>
+        <property name="description" type="STRING" data="Wenn man mal jemanden zum Reden braucht..."/>
+        <property name="geometrytype" type="STRING" data="ellipsoid"/>
+        <property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+        <property name="mass" type="REAL" data="65"/>
+        <property name="dialog" type="STRING" data="testdialog"/>
+        <property name="behaviours" type="ARRAY">
+            <property type="STRING" data="DefaultIdleBehaviour"/>
+            <property type="STRING" data="DialogBehaviour"/>
+        </property>
+		<property name="eigenschaften" type="MAP">
+			<property name="MU" type="INT" data="12"/>
+			<property name="KL" type="INT" data="8"/>
+			<property name="IN" type="INT" data="9"/>
+			<property name="CH" type="INT" data="10"/>
+			<property name="FF" type="INT" data="11"/>
+			<property name="GE" type="INT" data="12"/>
+			<property name="KO" type="INT" data="13"/>
+			<property name="KK" type="INT" data="14"/>
+		</property>
+		<property name="talente" type="MAP">
+			<property name="Athletik" type="INT" data="3"/>
+<!--			<property name="K?rperbeherrschung" type="INT" data="3"/>-->
+		</property>
+		<!-- Animationen und Animationsgeschwindigkeiten fuer den CreatureController -->
+		<property name="animations" type="MAP">
+			<property name="stehen" type="STRING" data="idle"/>
+			<property name="stehen_rechts" type="STRING" data="drehen_rechts"/>
+			<property name="stehen_links" type="STRING" data="drehen_links"/>
+			<!-- property name="seitwaerts_links" type="STRING" data="seitwaerts_links"/ -->
+			<!-- property name="seitwaerts_rechts" type="STRING" data="seitwaerts_rechts"/ -->
+			<property name="gehen" type="STRING" data="gehen"/>
+			<property name="gehen_rueckwaerts" type="STRING" data="gehen_rueckwaerts"/>
+			<property name="joggen_rueckwaerts" type="STRING" data="gehen_rueckwaerts"/>
+			<property name="joggen" type="STRING" data="rennen"/>
+			<property name="laufen" type="STRING" data="rennen"/>
+			<property name="rennen" type="STRING" data="rennen"/>
+			<property name="stehen_zu_schleichen" type="STRING" data="idle_zu_hocke"/>
+			<property name="schleichen_zu_stehen" type="STRING" data="hocke_zu_stehen"/>
+			<property name="schleichen" type="STRING" data="hocke_idle"/>
+			<property name="schleichen_vorwaerts" type="STRING" data="hocke_gehen"/>
+			<property name="hochsprung_absprung" type="STRING" data="idle_absprung"/>
+			<property name="hochsprung" type="STRING" data="idle_sprung"/>
+			<property name="hochsprung_landung" type="STRING" data="idle_sprung_landung"/>
+			<property name="weitsprung_absprung" type="STRING" data="rennen_absprung"/>
+			<property name="weitsprung" type="STRING" data="rennen_sprung"/>
+			<property name="weitsprung_landung" type="STRING" data="rennen_sprung_landung"/>
+		</property>
+		<property name="animationspeeds" type="MAP">
+			<property name="gehen" type="REAL" data="1.0"/>
+			<property name="joggen" type="REAL" data="0.3"/>
+			<property name="laufen" type="REAL" data="0.5"/>
+			<property name="rennen" type="REAL" data="0.4"/>
+		</property>
+    </gameobjectclass>
+
+    <gameobjectclass classid="TestPersonCapsule" baseclass="NPC">
+        <property name="name" type="STRING" data="TestPerson"/>
+        <property name="description" type="STRING" data="Wenn man mal jemanden zum Reden braucht..."/>
+        <property name="geometrytype" type="STRING" data="capsule"/>
+        <property name="meshfile" type="STRING" data="men_alrike.mesh"/>
+        <property name="mass" type="REAL" data="65"/>
+        <property name="dialogfile" type="STRING" data="testperson.xml"/>
+        <property name="behaviours" type="ARRAY">
+            <property type="STRING" data="DefaultIdleBehaviour"/>
+            <property type="STRING" data="DialogBehaviour"/>
+        </property>
+    </gameobjectclass>
+
+    <gameobjectclass classid="switch3way" baseclass="Switch3Way">
+        <property name="name" type="STRING" data="Hebel"/>
+        <property name="description" type="STRING" data="Ein Hebel"/>
+        <property name="meshfile" type="STRING" data="arc_hebel_01.mesh"/>
+        <property name="geometrytype" type="STRING" data="sphere"/>
+    </gameobjectclass>
+
+    <gameobjectclass classid="shortsword" baseclass="Weapon">
+        <property name="name" type="STRING" data="Kurzschwert"/>
+        <property name="description" type="STRING" data="Ein ordin?res Kurzschwert - scharf, aber langweilig"/>
+        <property name="meshfile" type="STRING" data="waf_kurzschwert_01.mesh"/>
+        <property name="imagename" type="STRING" data="set:ModelThumbnails image:waf_kurzschwert_01"/>
+        <property name="mass" type="REAL" data="3.0"/>
+        <property name="size" type="INTPAIR" data="2,4"/>
+		<property name="geometrytype" type="STRING" data="box"/>
+    </gameobjectclass>
+
+    <gameobjectclass classid="leather backpack" baseclass="Container">
+        <property name="name" type="STRING" data="Rucksack"/>
+        <property name="description" type="STRING" data="Ein Lederrucksack (oder so)"/>
+        <property name="meshfile" type="STRING" data="men_human_female_backpack_leather_01.mesh"/>
+        <property name="submeshfile" type="STRING" data="backpack_leather_01.mesh"/>
+        <property name="imagename" type="STRING" data="set:ModelThumbnails image:Rucksack"/>
+        <property name="capacity" type="REAL" data="20.0"/>
+        <property name="volume" type="INTPAIR" data="8,6"/>
+        <property name="size" type="INTPAIR" data="2,2"/>
+        <property name="itemtype" type="INT" data="256"/>	
+		<property name="mass" type="REAL" data="5.0"/>
+		<property name="geometrytype" type="STRING" data="ellipsoid"/>
+        <property name="actions" type="ARRAY">
+			<property type="STRING" data="showcontainercontent"/>
+        </property>
+        <property name="defaultaction" type="STRING" data="showcontainercontent"/>
+    </gameobjectclass>
+
+    <!-- ErrorHandlingTest -->
+    <gameobjectclass classid="ErrorHandling" baseclass="GameObject">
+        <property name="name" type="STRING" data="ErrorHandling-TestCase"/>
+        <property name="description" type="STRING" data="The ErrorHandling TestCase"/>
+        <property name="meshfile" type="STRING" data="arc_hebel_01.mesh"/>
+    </gameobjectclass>
+
+    <!-- SoundTest -->
+    <gameobjectclass classid="SoundFadeTest" baseclass="GameObject">
+        <property name="name" type="STRING" data="SoundFadeTest"/>
+        <property name="description" type="STRING" data="The Sound Fading TestCase"/>
+        <property name="meshfile" type="STRING" data="arc_hebel_01.mesh"/>
+    </gameobjectclass>
+
+    <!-- JobSequenceTest -->
+    <gameobjectclass classid="JobSequenceTestChest" baseclass="GameObject">
+        <property name="name" type="STRING" data="JobSequence-Truhe"/>
+        <property name="description" type="STRING" data="Eine Truhe zum Test der JobSequence"/>
+        <property name="meshfile" type="STRING" data="ver_truhe_gross01.mesh"/>
+        <property name="geometrytype" type="STRING" data="box"/>
+    </gameobjectclass>
+
+    <!-- EffectTest -->
+    <gameobjectclass classid="EffectTest" baseclass="GameObject">
+        <property name="name" type="STRING" data="Bottich der Versteinerung"/>
+        <property name="description" type="STRING" data="Der Essigbottich der Versteinerung (Vorsicht!)"/>
+        <property name="meshfile" type="STRING" data="ver_essigbottich_01.mesh"/>
+        <property name="geometrytype" type="STRING" data="box"/>
+    </gameobjectclass>
+
+	<!-- SelectorTest -->
+    <gameobjectclass classid="SelectorTest" baseclass="Item">
+        <property name="name" type="STRING" data="Bottich der Auswahl"/>
+        <property name="description" type="STRING" data="Der Essigbottich des Auswahltests, harmlos :)"/>
+        <property name="meshfile" type="STRING" data="ver_essigbottich_01.mesh"/>
+        <property name="geometrytype" type="STRING" data="box"/>
+    </gameobjectclass>
+
+	<!--InventoryTest clothes-->
+    <gameobjectclass classid="Clothes #1" baseclass="Clothing">
+        <property name="name" type="STRING" data="Kleidung #1"/>
+        <property name="description" type="STRING" data="Kleidung, Variante 1"/>
+        <property name="meshfile" type="STRING" data="obj_shortsleeve.mesh"/> <!-- the mesh for when the item is placed in the world -->
+		<property name="submeshfile" type="STRING" data="obj_shortsleeve.mesh"/> <!-- the mesh for when the item is worn by a creature -->
+        <property name="geometrytype" type="STRING" data="box"/>
+        <property name="material" type="STRING" data="obj_Shortsleeve"/>
+		<property name="itemtype" type="INT" data="32768"/> <!-- Clothes -->
+		<property name="size" type="INTPAIR" data="2,4"/>
+    </gameobjectclass>
+    <gameobjectclass classid="Clothes #2" baseclass="Clothing">
+        <property name="name" type="STRING" data="Kleidung #2"/>
+        <property name="description" type="STRING" data="Kleidung, Variante 2"/>
+        <property name="meshfile" type="STRING" data="obj_shortsleeve.mesh"/> <!-- the mesh for when the item is placed in the world -->
+		<property name="submeshfile" type="STRING" data="obj_shortsleeve.mesh"/> <!-- the mesh for when the item is worn by a creature -->
+        <property name="geometrytype" type="STRING" data="box"/>
+        <property name="material" type="STRING" data="obj_Shortsleeve_2"/>
+		<property name="itemtype" type="INT" data="32768"/> <!-- Clothes -->
+		<property name="size" type="INTPAIR" data="2,4"/>
+    </gameobjectclass>
+
+    <gameobjectclass classid="MeshAreaTestHouse" baseclass="GameObject">
+        <property name="name" type="STRING" data="MeshAreaTestHouse"/>
+	<property name="meshfile" type="STRING" data="arc_Wirtshaus_02.mesh"/>
+	<property name="geometrytype" type="STRING" data="none"/>
+    </gameobjectclass>
+	
+</GameObjectDefinitions>

Added: modules/branch_persistenz/maps/Cube.mesh
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/maps/Cube.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/maps/hero.rlmap.xml
===================================================================
--- modules/branch_persistenz/maps/hero.rlmap.xml	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/maps/hero.rlmap.xml	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,7 @@
+<scene formatVersion="0.4.0" scenescript="setchar.rb">
+    <nodes>
+        <gameobject class="mckhero" id="hero" state="IN_SCENE">
+            <position x="2" y="0.0" z="0"/>
+        </gameobject>
+    </nodes>
+</scene>

Added: modules/branch_persistenz/maps/map01.rlscene
===================================================================
--- modules/branch_persistenz/maps/map01.rlscene	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/maps/map01.rlscene	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,4 @@
+<scene name="scene01">
+	<map file="persistenztest01.rlmap.xml"/>
+	<map file="hero.rlmap.xml"/>
+</scene>
\ No newline at end of file

Added: modules/branch_persistenz/maps/map02.rlscene
===================================================================
--- modules/branch_persistenz/maps/map02.rlscene	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/maps/map02.rlscene	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,4 @@
+<scene name="scene02">
+	<map file="persistenztest02.rlmap.xml"/>
+	<map file="hero.rlmap.xml"/>
+</scene>
\ No newline at end of file

Added: modules/branch_persistenz/maps/persistenztest01.rlmap.xml
===================================================================
--- modules/branch_persistenz/maps/persistenztest01.rlmap.xml	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/maps/persistenztest01.rlmap.xml	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,18 @@
+<scene formatVersion="0.4.0" scenescript="map01.rb">
+    <nodes>
+        <entity meshfile="regressiontest_floorplane.mesh">
+            <position x="0.0" y="0.0" z="0.0" />
+            <scale x="1.0" y="1.0" z="1.0" />
+        </entity>
+		<gameobject class="number1" id="11" state="IN_SCENE">
+            <position x="5" y="0.2" z="0"/>
+        </gameobject>
+        <gameobject class="Kurzschwert" id="115" state="IN_SCENE">
+            <position x="10" y="0.2" z="0"/>
+        </gameobject>
+		<entity meshfile="nx.crosshair.mesh">
+			<position x="0.0" y="0.2" z="4.0" />
+            <scale x="1.0" y="1.0" z="1.0" />
+		</entity>
+    </nodes>
+</scene>

Added: modules/branch_persistenz/maps/persistenztest02.rlmap.xml
===================================================================
--- modules/branch_persistenz/maps/persistenztest02.rlmap.xml	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/maps/persistenztest02.rlmap.xml	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,14 @@
+<scene formatVersion="0.4.0" scenescript="map02.rb">
+    <nodes>
+        <entity meshfile="regressiontest_floorplane.mesh">
+            <position x="0.0" y="0.0" z="0.0" />
+            <scale x="1.0" y="1.0" z="1.0" />
+        </entity>
+		<gameobject class="number2" id="12" state="IN_SCENE">
+            <position x="5" y="0.0" z="0"/>
+        </gameobject>
+        <gameobject class="leather backpack" id="215" state="IN_SCENE">
+            <position x="10" y="0.2" z="0"/>
+        </gameobject>
+    </nodes>
+</scene>

Added: modules/branch_persistenz/maps/regressiontest_floorplane.mesh
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/maps/regressiontest_floorplane.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/materials/Numbers.material
===================================================================
--- modules/branch_persistenz/materials/Numbers.material	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/materials/Numbers.material	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,17 @@
+material Numbers
+{
+	technique
+	{
+		pass
+		{
+			ambient 0.500000 0.500000 0.500000 1.000000
+			diffuse 0.640000 0.640000 0.640000 1.000000
+			specular 0.500000 0.500000 0.500000 1.000000 12.500000
+			emissive 0.000000 0.000000 0.000000 1.000000
+			texture_unit
+			{
+				texture nx.zone.pink.png
+			}
+		}
+	}
+}

Added: modules/branch_persistenz/materials/ins_rucksack.material
===================================================================
--- modules/branch_persistenz/materials/ins_rucksack.material	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/materials/ins_rucksack.material	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,13 @@
+material SOLID/TEX/rucksack.png
+{
+	technique
+	{
+		pass
+		{
+			texture_unit
+			{
+				texture ins_rucksack.png
+			}
+		}
+	}
+}

Added: modules/branch_persistenz/materials/nx.grid.material
===================================================================
--- modules/branch_persistenz/materials/nx.grid.material	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/materials/nx.grid.material	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,34 @@
+material nx.grid
+{
+    technique
+    {
+        pass
+        {
+            //lighting off
+            
+            texture_unit
+            {
+                max_anisotropy 8
+                filtering anisotropic
+                texture nx.grid.floor.png
+            }
+        }
+    }
+}
+
+material nx.axis
+{
+    technique
+    {
+        pass
+        {
+            lighting off
+            scene_blend alpha_blend
+            
+            texture_unit
+            {
+                texture nx.grid.axis.png
+            }
+        }
+    }
+}

Added: modules/branch_persistenz/materials/nx.particles.material
===================================================================
--- modules/branch_persistenz/materials/nx.particles.material	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/materials/nx.particles.material	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,59 @@
+material nx.fx-mat.magic
+{
+	technique
+	{
+		pass
+		{
+			lighting off
+			scene_blend add
+			depth_write off
+
+			point_sprites on
+			point_size 2
+			point_size_attenuation on
+
+			texture_unit
+			{
+				texture flare.png
+			}
+		}
+	}
+}
+
+material nx.smoke
+{
+	technique
+	{
+		pass
+		{
+			lighting off
+			scene_blend alpha_blend
+			depth_write off
+
+			texture_unit
+			{
+				texture nx.particle.smoke.png
+				tex_address_mode clamp
+			}
+		}
+	}
+}
+
+material nx.steam
+{
+	technique
+	{
+		pass
+		{
+			lighting off
+			scene_blend alpha_blend
+			depth_write off
+
+			texture_unit
+			{
+				texture nx.particle.steam.png
+				tex_address_mode clamp
+			}
+		}
+	}
+}
\ No newline at end of file

Added: modules/branch_persistenz/materials/nx.shapes.material
===================================================================
--- modules/branch_persistenz/materials/nx.shapes.material	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/materials/nx.shapes.material	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,137 @@
+material nx.cube
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 1.000000 0.5 0.000000
+			diffuse 1.000000 0.769854 0.000000
+			specular 0.500000 0.246996 0.000000 30.500000
+			shading phong
+		}
+	}
+}
+
+material nx.cube.alt
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 1.000000 0.8 0.200000
+			diffuse 1.000000 0.769854 0.000000
+			specular 0.500000 0.246996 0.000000 30.500000
+			shading phong
+		}
+	}
+}
+
+material nx.sphere
+{
+
+	technique
+	{
+		pass
+		{
+			shading phong
+			ambient 0 1.0 0.8
+			diffuse 0 1.0 0.77
+			specular 0 0.5 0.25 0.5
+			shading phong
+		}
+	}
+}
+
+material nx.convex1
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 0.6 1.0 0.8
+			diffuse 0.6 1.0 0.77
+			specular 0.6 0.5 0.25 0.5
+			shading phong
+		}
+	}
+}
+
+material nx.chair
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 0.4 1.0 0.8
+			diffuse 0.4 1.0 0.77
+			specular 0.4 0.5 0.25 0.5
+			shading phong
+		}
+	}
+}
+
+material nx.motor.a
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 0.5 0.5 0.5
+			diffuse 0.5 0.5 0.5
+			specular 0.5 0.5 0.5 0.5
+			shading phong
+		}
+	}
+}
+
+material nx.motor.b
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 1.000000 0.8 0.200000
+			diffuse 1.000000 0.769854 0.000000
+			specular 0.500000 0.246996 0.000000 30.500000
+			shading phong
+		}
+	}
+}
+
+material nx.raycaster
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 0.1 0.1 0.1
+			diffuse 0.1 0.1 0.1
+			specular 0.1 0.1 0.1
+			shading phong
+		}
+	}
+}
+
+material nx.crosshair
+{
+
+	technique
+	{
+		pass
+		{
+			ambient 1.0 1.0 1.0
+			diffuse 1.0 1.0 1.0
+			specular 1.0 1.0 1.0
+			shading phong
+		}
+	}
+}
+
+

Added: modules/branch_persistenz/materials/nx.stairs.material
===================================================================
--- modules/branch_persistenz/materials/nx.stairs.material	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/materials/nx.stairs.material	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,14 @@
+material nx.wall
+{
+	technique
+	{
+		pass
+		{
+			diffuse 0.800000 0.800000 0.800000
+			texture_unit
+			{
+				texture nx.static.wall.png
+			}
+		}
+	}
+}

Added: modules/branch_persistenz/materials/nx.track.material
===================================================================
--- modules/branch_persistenz/materials/nx.track.material	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/materials/nx.track.material	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1 @@
+

Added: modules/branch_persistenz/materials/nx.zones.material
===================================================================
--- modules/branch_persistenz/materials/nx.zones.material	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/materials/nx.zones.material	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,64 @@
+material nx.zone.green
+{
+	technique
+	{
+		pass
+		{
+			lighting off			
+			scene_blend alpha_blend			
+			texture_unit
+			{
+				texture nx.zone.green.png
+			}
+		}
+	}
+}
+
+material nx.zone.orange
+{
+	technique
+	{
+		pass
+		{
+			lighting off			
+			scene_blend alpha_blend			
+			texture_unit
+			{
+				texture nx.zone.orange.png
+			}
+		}
+	}
+}
+
+material nx.zone.blue
+{
+	technique
+	{
+		pass
+		{
+			lighting off			
+			scene_blend alpha_blend			
+			texture_unit
+			{
+				texture nx.zone.blue.png
+			}
+		}
+	}
+}
+
+material nx.zone.marker.nogravity
+{
+	technique
+	{
+		pass
+		{
+			lighting off			
+			scene_blend alpha_blend
+			
+			texture_unit
+			{
+				texture nx.zone.nogravity.png
+			}
+		}
+	}
+}
\ No newline at end of file

Added: modules/branch_persistenz/materials/textures/Thumbs.db
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/materials/textures/Thumbs.db
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/materials/textures/ins_rucksack.png
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/materials/textures/ins_rucksack.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/materials/textures/nx.grid.axis.png
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/materials/textures/nx.grid.axis.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/materials/textures/nx.grid.floor.png
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/materials/textures/nx.grid.floor.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/materials/textures/nx.particle.smoke.png
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/materials/textures/nx.particle.smoke.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/materials/textures/nx.particle.steam.png
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/materials/textures/nx.particle.steam.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/materials/textures/nx.static.wall.png
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/materials/textures/nx.static.wall.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/materials/textures/nx.trafficcone.png
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/materials/textures/nx.trafficcone.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/materials/textures/nx.zone.blue.png
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/materials/textures/nx.zone.blue.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/materials/textures/nx.zone.green.png
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/materials/textures/nx.zone.green.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/materials/textures/nx.zone.nogravity.png
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/materials/textures/nx.zone.nogravity.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/materials/textures/nx.zone.orange.png
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/materials/textures/nx.zone.orange.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/materials/textures/nx.zone.pink.png
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/materials/textures/nx.zone.pink.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/materials/textures/obj_shortsleeve_dummy.png
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/materials/textures/obj_shortsleeve_dummy.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/medianotes.txt
===================================================================
--- modules/branch_persistenz/medianotes.txt	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/medianotes.txt	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,5 @@
+All media files starting with nx. are taken from NxOgre.
+
+		(C) Robin Southern <betajaen at ihoed.com>
+
+They don't fall under our media distribution restrictions. They are free to use for other projects as long as his name is shown in the credits.

Added: modules/branch_persistenz/models/Number1.mesh
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/models/Number1.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/models/Number2.mesh
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/models/Number2.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/models/cube.1m-2m-1m.mesh
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/models/cube.1m-2m-1m.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/models/cube.1m.mesh
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/models/cube.1m.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/models/ins_rucksack.mesh
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/models/ins_rucksack.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/models/nx.chair.mesh
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/models/nx.chair.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/models/nx.convex1.mesh
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/models/nx.convex1.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/models/nx.crosshair.mesh
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/models/nx.crosshair.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/models/nx.raycaster.mesh
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/models/nx.raycaster.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/models/nx.stairs1.mesh
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/models/nx.stairs1.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/models/nx.trafficcone.mesh
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/models/nx.trafficcone.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/models/sphere.1m.mesh
===================================================================
(Binary files differ)


Property changes on: modules/branch_persistenz/models/sphere.1m.mesh
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: modules/branch_persistenz/quests/test.quests
===================================================================
--- modules/branch_persistenz/quests/test.quests	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/quests/test.quests	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
+<quests>
+	<quest id="quest1">
+		<name>quest1</name>
+		<description>blub blub blahtext</description>
+		<state>COMPLETED</state>
+		<known>true</known>
+		<quest id="subquest1_1">
+			<name>subquest1_1</name>
+			<description>nochmal blah</description>
+			<known>true</known>
+		</quest>
+	</quest>
+	<quest id="quest2">
+		<name>quest2</name>
+		<description>blub blub blahtext213423</description>
+		<state>COMPLETED</state>
+		<known>true</known>
+		<quest id="subquest2_1">
+			<name>subquest2_1</name>
+			<known>false</known>
+		</quest>
+		<quest id="subquest2_2">
+			<name>subquest2_2</name>
+			<known>false</known>
+		</quest>
+		<quest id="subquest2_3">
+			<known>true</known>
+			<name>subquest2_3</name>
+			<known>true</known>
+		</quest>
+	</quest>
+	<quest id="quest3">
+		<name>quest3</name>
+		<quest id="subquest3_1">
+			<name>subquest3_1</name>
+			<known>true</known>
+		</quest>
+		<name>quest3</name>
+		<known>false</known>
+		<description>blub blub blahtext2312312312542143123</description>
+		<state>COMPLETED</state>
+	</quest>
+</quests>

Added: modules/branch_persistenz/scripts/MapChange.rb
===================================================================
--- modules/branch_persistenz/scripts/MapChange.rb	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/scripts/MapChange.rb	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,52 @@
+require "embed.rb"
+require "areahelper.rb"
+
+def changeScene(scene)
+#	characterId = PartyManager.getSingleton().getActiveCharacter().getId()
+#	CreatureControllerManager.getSingleton().detachController(PartyManager.getSingleton().getActiveCharacter())
+#	PartyManager.getSingleton().setActiveCharacter(nil)
+	#$SCRIPT.logError(mapNames.type().to_s)
+#	mapLoader.requestSceneChange(mapNames)
+	SceneManager::getSingleton().loadScene(scene, true);
+end
+
+class SceneChangeTrigger < Trigger
+  def initialize(classname, name)
+    super(classname, name, false);
+  end
+
+  def activate()
+	changeScene(@scene)
+    return false
+  end
+  def deactivate()
+    return false
+  end
+  def setProperty(name, value)
+    super(name, value)
+  end
+  def getProperty(name)
+	super(name)
+  end
+  def setScene(scene)
+	@scene = scene
+  end
+  def getAllProperties()
+    ps = super();
+    return ps
+  end
+end
+
+def CreateSceneChangeTrigger(name, pos, orientation, size, scene)
+	unless ( ZoneManager.getSingleton().getZone("SceneChangeZone_" + name) == nil )
+		raise ArgumentError, "A SceneChangeTrigger with name " + name + " already exists!", caller
+	end
+	trigger = $SCRIPT.getTriggerFactory().createTrigger("SceneChangeTrigger", "SceneChangeTrigger" + name)
+	trigger.setScene(scene)
+	zone = ZoneManager.getSingleton().createZone("SceneChangeZone_" + name, true)
+	ZoneManager.getSingleton().addAreaToZone(
+	    "SceneChangeZone_" + name, 
+	    size, PhysicsManager::GT_BOX, pos, [0,0,0], orientation, 0.2, RlScript::QUERYFLAG_PLAYER);
+	trigger.setProperty("zone","SceneChangeZone_" + name)
+	zone.addTrigger(trigger)
+end
\ No newline at end of file

Added: modules/branch_persistenz/scripts/maps/map01.rb
===================================================================
--- modules/branch_persistenz/scripts/maps/map01.rb	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/scripts/maps/map01.rb	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,14 @@
+require 'embed.rb'
+require 'MapChange.rb'
+
+$SCRIPT.log("map 1 von 'persistenztest' wird initialisiert....")
+
+base = $AM.createBoxPrimitiveActor("SelectorTestBase", [-2,0.05,-2], [2,0.3,2], "alpha_blue")
+
+base.placeIntoScene([8,0,8])
+
+CreateSceneChangeTrigger("map1", [8,0,8], [0,0,0,1], [2, 2, 2], "scene02")
+
+puts 'Map 1 init script wurde ausgef?hrt!'
+
+$SCRIPT.log("map 1 von 'persistenztest' initialisiert.")

Added: modules/branch_persistenz/scripts/maps/map02.rb
===================================================================
--- modules/branch_persistenz/scripts/maps/map02.rb	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/scripts/maps/map02.rb	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,13 @@
+require 'embed.rb'
+
+$SCRIPT.log("map 2 von 'persistenztest' wird initialisiert....")
+
+base = $AM.createBoxPrimitiveActor("SelectorTestBase", [-2,0.05,-2], [2,0.3,2], "alpha_blue")
+
+base.placeIntoScene([8,0,-8])
+
+CreateSceneChangeTrigger("map2", [8,0,-8], [0,0,0,1], [2, 2, 2], "scene01")
+
+puts 'Map 2 ausgef?hrt'
+
+$SCRIPT.log("map 2 von 'persistenztest' initialisiert.")
\ No newline at end of file

Added: modules/branch_persistenz/scripts/maps/persistenztest.rb
===================================================================
--- modules/branch_persistenz/scripts/maps/persistenztest.rb	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/scripts/maps/persistenztest.rb	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,55 @@
+load "embed.rb"
+
+require 'player.rb'
+require 'hero.rb'
+require 'messagebox.rb'
+require 'MapChange.rb'
+
+# Physik aktivieren
+$PM.setEnabled(true)
+
+$SCRIPT.log("init map 'regressiontest'...")
+
+
+
+$SCRIPT.log("begin tests.")
+
+
+class PersistenzTest
+	def initialize
+		@mErrors = 0
+		@mTests = 0
+		@mFailedTests = Array.new()
+	end
+
+	def runTest(test, coords)
+		p "Start test " + test.to_s()
+		@mTests += 1
+		testErrors = test.new(coords).run()
+		if testErrors != 0
+			@mErrors += testErrors
+			@mFailedTests << test.to_s()
+		end
+		p "Finished test " + test.to_s()
+	end
+	
+	def runTests()
+		p $MAPLOADER
+		
+		$PM.setEnabled(false)
+		#changeMap($MAPLOADER, ["persistenztest02.scene","hero.scene"])
+		$PM.setEnabled(true)
+		
+		if @mErrors > 0
+		  MessageBox.showModal(
+			@mErrors.to_s() + " of the " + @mTests.to_s() +  " tests were not successful.\nNot working:\n" + @mFailedTests.join(", "),
+			"Regressiontest Results",
+			MessageBox::OK)
+		end
+
+		$SCRIPT.log("tests initialisiert.")
+	end
+end
+
+PersistenzTest.new().runTests()
+$SCRIPT.log("map 'persistenztest' initialisiert.")

Added: modules/branch_persistenz/scripts/maps/setchar.rb
===================================================================
--- modules/branch_persistenz/scripts/maps/setchar.rb	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/scripts/maps/setchar.rb	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,22 @@
+load "embed.rb"
+
+require 'player.rb'
+require 'hero.rb'
+require 'MapChange.rb'
+
+$SCRIPT.log("Prepare hero for being the active character")
+hero = $GOM.getGameObject("hero");
+$SCRIPT.log("Hero with id" + hero.getId())
+PlayerSettings.preparePlayer(hero)
+
+
+$SCRIPT.log("Set hero as active character")
+PartyManager.getSingleton().setActiveCharacter(hero)
+
+$SCRIPT.log("Hero ready")
+itemToAdd = $GOM.createGameObject("men_human_female_legs_pants_01_long");
+hero.getInventory().hold(itemToAdd, "Trousers");
+itemToAdd = $GOM.createGameObject("men_human_female_cloth_short");
+hero.getInventory().hold(itemToAdd, "Clothes");
+itemToAdd = $GOM.createGameObject("men_human_female_feet_boots_01");
+hero.getInventory().hold(itemToAdd, "Boots");

Added: modules/branch_persistenz/scripts/moduleconfig.rb
===================================================================
--- modules/branch_persistenz/scripts/moduleconfig.rb	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/branch_persistenz/scripts/moduleconfig.rb	2008-11-21 15:24:57 UTC (rev 4597)
@@ -0,0 +1,34 @@
+include RlScript
+
+class PersistenzTestModule < ContentModule
+    def initialize()
+        super("branch_persistenz", "Persistenztest2", false, 200603080)
+    end
+
+    def getDependencies()
+        return ["common"]
+    end
+
+    def getTextureLocations()
+        return ["textures"]
+    end
+
+    def getModelLocations()
+        return []
+    end
+
+    def getSoundLocations()
+        return []
+    end
+
+    def start()
+        require "mckhero.rb"
+        require "hero.rb"
+		require "MapChange.rb"
+		require "clothing.rb"
+		SceneManager::getSingleton().loadScene("scene01", false);
+		$PM.setEnabled(true)
+    end
+end
+
+CoreSubsystem.getSingleton().registerModule(PersistenzTestModule.new())

Modified: modules/modules.cfg
===================================================================
--- modules/modules.cfg	2008-11-21 15:24:13 UTC (rev 4596)
+++ modules/modules.cfg	2008-11-21 15:24:57 UTC (rev 4597)
@@ -16,4 +16,5 @@
 module=persistenztest
 module=teichtest
 
-#module=editortest
+module=branch_persistenz
+



From timm at mail.berlios.de  Fri Nov 21 16:26:26 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Fri, 21 Nov 2008 16:26:26 +0100
Subject: [Dsa-hl-svn] r4598 - modules/branch_persistenz/materials/textures
Message-ID: <200811211526.mALFQQvi024636@sheep.berlios.de>

Author: timm
Date: 2008-11-21 16:26:21 +0100 (Fri, 21 Nov 2008)
New Revision: 4598

Removed:
   modules/branch_persistenz/materials/textures/Thumbs.db
Log:
removed thumbs.db

Deleted: modules/branch_persistenz/materials/textures/Thumbs.db
===================================================================
(Binary files differ)



From timm at mail.berlios.de  Fri Nov 21 16:29:13 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Fri, 21 Nov 2008 16:29:13 +0100
Subject: [Dsa-hl-svn] r4599 - in rl/branches/persistence: core/include
	core/src script/src ui/src
Message-ID: <200811211529.mALFTDJG024872@sheep.berlios.de>

Author: timm
Date: 2008-11-21 16:28:58 +0100 (Fri, 21 Nov 2008)
New Revision: 4599

Modified:
   rl/branches/persistence/core/include/ListenerMovable.h
   rl/branches/persistence/core/include/MovableText.h
   rl/branches/persistence/core/include/Sound.h
   rl/branches/persistence/core/include/SoundResource.h
   rl/branches/persistence/core/include/SoundStitching.h
   rl/branches/persistence/core/src/Actor.cpp
   rl/branches/persistence/core/src/ListenerMovable.cpp
   rl/branches/persistence/core/src/MovableText.cpp
   rl/branches/persistence/core/src/PhysicalThing.cpp
   rl/branches/persistence/core/src/PhysicsManager.cpp
   rl/branches/persistence/core/src/Sound.cpp
   rl/branches/persistence/core/src/SoundResource.cpp
   rl/branches/persistence/core/src/SoundStitching.cpp
   rl/branches/persistence/script/src/PlaneNodeProcessor.cpp
   rl/branches/persistence/ui/src/DebugWindow.cpp
   rl/branches/persistence/ui/src/DialogControlState.cpp
   rl/branches/persistence/ui/src/InventoryWindow.cpp
Log:
merged with current trunk

Modified: rl/branches/persistence/core/include/ListenerMovable.h
===================================================================
--- rl/branches/persistence/core/include/ListenerMovable.h	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/core/include/ListenerMovable.h	2008-11-21 15:28:58 UTC (rev 4599)
@@ -1,94 +1,98 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __ListenerMovable_H__
-#define __ListenerMovable_H__
-
-#include "CorePrerequisites.h"
-
-
-namespace rl {
-    
-   /** Diese Klasse dient der Interaktion mit Ogre3d und
-    * kapselt den H?rer.
-    * @author Josch
-    * @date 06-29-2005
-    * @version 1.0
-    * @version 2.0
-    */
-    class _RlCoreExport ListenerMovable : public Ogre::MovableObject
-    {
-    public:
-        /// Konstruktor
-        ListenerMovable(const Ogre::String& name);
-        /// Destruktor
-        virtual ~ListenerMovable() = 0;
-        /// Name zur?ckgeben
-        virtual const Ogre::String& getName() const;
-        /// Moveable-Typ
-        virtual const Ogre::String& getMovableType() const;
-        /// Kamera informieren
-        virtual void _notifyCurrentCamera(Ogre::Camera *cam);
-        /// Unsere Bounding-Box
-        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
-        /// Bound-Radius
-        virtual Ogre::Real getBoundingRadius() const;
-        /// Rendern
-        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
-    
-        /// Gibt die Hauptlautstaerke zurueck
-        virtual const int getGain() const;
-        /// Setzt die Hauptlautstaerke.
-        virtual void setGain(const int direction);
-        /// Gibt die eingestellte Position der Soundquelle zurueck
-        virtual const Ogre::Vector3 getPosition() const;
-        /// Setzt die Position der Soundquelle.
-        virtual void setPosition(const Ogre::Vector3& direction);
-        /// Gibt die Richtung der Soundquelle zurueck.
-        virtual const Ogre::Quaternion getOrientation() const;
-        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
-        virtual const Ogre::Vector3 getVelocity() const;
-        /// Setzt die Richtung der Soundquelle.
-        virtual void setOrientation(const Ogre::Quaternion &orientation);
-        /// Setzt die Geschwindigkeit der Soundquelle.
-        virtual void setVelocity(const Ogre::Vector3&);
-        
-        /// Ist dies der aktuelle Listener
-        bool isActive() const;
-		void setActive(bool active);
-        
-    protected:
-         /// Shared class-level name for Movable type
-        static Ogre::String msMovableType;
-        /// Alignment-Box: gebraucht von MovableObject.
-        static Ogre::AxisAlignedBox msAABox;
-        /// Position
-        Ogre::Vector3 mPosition;
-        /// Geschwindigkeit
-        Ogre::Vector3 mVelocity;
-        /// Orientierung
-        Ogre::Quaternion mOrientation;
-        /// Hauptlautst?rke
-        int mGain;
-
-    private:
-        /// Der Name des ListenerMovable
-        Ogre::String mName;
-		bool mActive;
-    };
-
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __ListenerMovable_H__
+#define __ListenerMovable_H__
+
+#include "CorePrerequisites.h"
+
+
+namespace rl {
+    
+   /** Diese Klasse dient der Interaktion mit Ogre3d und
+    * kapselt den H?rer.
+    * @author Josch
+    * @date 06-29-2005
+    * @version 1.0
+    * @version 2.0
+    */
+    class _RlCoreExport ListenerMovable : public Ogre::MovableObject
+    {
+    public:
+        /// Konstruktor
+        ListenerMovable(const Ogre::String& name);
+        /// Destruktor
+        virtual ~ListenerMovable() = 0;
+        /// Name zur?ckgeben
+        virtual const Ogre::String& getName() const;
+        /// Moveable-Typ
+        virtual const Ogre::String& getMovableType() const;
+        /// Kamera informieren
+        virtual void _notifyCurrentCamera(Ogre::Camera *cam);
+        /// Unsere Bounding-Box
+        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
+        /// Bound-Radius
+        virtual Ogre::Real getBoundingRadius() const;
+        /// Rendern
+        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+    
+        /// Gibt die Hauptlautstaerke zurueck
+        virtual const int getGain() const;
+        /// Setzt die Hauptlautstaerke.
+        virtual void setGain(const int direction);
+        /// Gibt die eingestellte Position der Soundquelle zurueck
+        virtual const Ogre::Vector3 getPosition() const;
+        /// Setzt die Position der Soundquelle.
+        virtual void setPosition(const Ogre::Vector3& direction);
+        /// Gibt die Richtung der Soundquelle zurueck.
+        virtual const Ogre::Quaternion getOrientation() const;
+        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
+        virtual const Ogre::Vector3 getVelocity() const;
+        /// Setzt die Richtung der Soundquelle.
+        virtual void setOrientation(const Ogre::Quaternion &orientation);
+        /// Setzt die Geschwindigkeit der Soundquelle.
+        virtual void setVelocity(const Ogre::Vector3&);
+        
+        /// Ist dies der aktuelle Listener
+        bool isActive() const;
+		void setActive(bool active);
+
+		/// From MovableObject
+		virtual void visitRenderables(Ogre::Renderable::Visitor* visitor, 
+			bool debugRenderables = false);
+        
+    protected:
+         /// Shared class-level name for Movable type
+        static Ogre::String msMovableType;
+        /// Alignment-Box: gebraucht von MovableObject.
+        static Ogre::AxisAlignedBox msAABox;
+        /// Position
+        Ogre::Vector3 mPosition;
+        /// Geschwindigkeit
+        Ogre::Vector3 mVelocity;
+        /// Orientierung
+        Ogre::Quaternion mOrientation;
+        /// Hauptlautst?rke
+        int mGain;
+
+    private:
+        /// Der Name des ListenerMovable
+        Ogre::String mName;
+		bool mActive;
+    };
+
+}
+#endif

Modified: rl/branches/persistence/core/include/MovableText.h
===================================================================
--- rl/branches/persistence/core/include/MovableText.h	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/core/include/MovableText.h	2008-11-21 15:28:58 UTC (rev 4599)
@@ -63,6 +63,7 @@
         const Ogre::String& getMovableType(void) const { return msType; }
         Ogre::Real getBoundingRadius(void) const {return mRadius;}
         Ogre::Real getSquaredViewDepth(const Ogre::Camera* cam) const { return 0; }
+		void visitRenderables(Ogre::Renderable::Visitor* visitor,  bool debugRenderables = false);
  
         // from renderable
         void getRenderOperation(Ogre::RenderOperation &op);

Modified: rl/branches/persistence/core/include/Sound.h
===================================================================
--- rl/branches/persistence/core/include/Sound.h	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/core/include/Sound.h	2008-11-21 15:28:58 UTC (rev 4599)
@@ -1,163 +1,167 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __Sound_H__
-#define __Sound_H__
-
-#include "CorePrerequisites.h"
-#include <set>
-
-#include "Exception.h"
-#include "EventCaster.h"
-#include "SoundEvents.h"
-#include "SoundResource.h"
-
-namespace rl {
-
-    class SoundDriver;
-
-   /** Diese Klasse dient der Interaktion mit dem jeweiligen Soundsystem
-    * ein Objekt stellt eine einzelne Sounddatei oder einen Stream dar
-    * @author Josch
-    * @date 06-29-2005
-    * @version 1.0
-    * @version 2.0
-    */
-    class _RlCoreExport Sound : public Ogre::MovableObject, 
-        public EventCaster<SoundEvent>, public EventSource
-    {
-    public:
-        // Einige Standardwerte f??r Soundpriorit??ten.
-        enum SOUND_PRIORITY {
-            PRIO_SPEECH = 30,
-            PRIO_MUSIC = 75,
-            PRIO_SFX_ENVIRONMENT = 128,
-            PRIO_SFX_OTHER = 175,
-            PRIO_OTHER = 220
-        };
-
-        /// Konstruktor
-        Sound(const SoundResourcePtr& soundres, SoundDriver* creator);
-        /// Destruktor
-        virtual ~Sound();
-          
-        /// Laedt den Sound.
-        virtual void load() throw (RuntimeException) = 0;
-        /// Entlaedt den Sound.
-        virtual void unload() throw (RuntimeException) = 0;
-
-        // SoundResource zurueckgeben.
-        const SoundResourcePtr& getSoundResource() const;
-        // Wollen wir 3D?
-        bool is3d() const;
-        // Setzen des 3D-Flags.
-        void set3d(bool is3d);
-        // Sind wir gueltig
-        virtual bool isValid() const throw (RuntimeException) = 0;
-        
-        // Sollen der Sound wiederholt werden?
-        bool isLooping() const;
-        // Setzen des Loop-Flags.
-        void setLooping(bool looping);
-
-        virtual float getLength() const = 0;
-
-        /// Unsere Bounding-Box
-        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
-        /// Bound-Radius
-        virtual Ogre::Real getBoundingRadius() const;
-        /// Rendern
-        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
-
-
-        /// Gibt die eingestellte Position der Soundquelle zurueck
-        virtual const Ogre::Vector3 getPosition() const = 0;
-        /// Setzt die Position der Soundquelle.
-        virtual void setPosition(const Ogre::Vector3& direction) = 0;
-        /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
-	    virtual const Ogre::Real getVolume() const = 0; 
-        /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
-	    virtual void setVolume(const Ogre::Real gain) = 0;
-        /// Gibt die Richtung der Soundquelle zurueck.
-        virtual const Ogre::Quaternion getDirection() const = 0;
-        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
-        virtual const Ogre::Vector3 getVelocity() const = 0;
-        /// Setzt die Richtung der Soundquelle.
-        virtual void setDirection(const Ogre::Quaternion&) = 0;
-        /// Setzt die Geschwindigkeit der Soundquelle.
-        virtual void setVelocity(const Ogre::Vector3&) = 0;
-	    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
-	    virtual void setRolloffStartDistance(const Ogre::Real&);
-	    virtual const Ogre::Real getRolloffStartDistance() const;
-	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
-	    virtual void setRolloffEndDistance(const Ogre::Real&);
-	    virtual const Ogre::Real getRolloffEndDistance() const;
-        // Sets the priority of this sound
-        virtual void setPriority(const int priority) = 0;
-        // Gets the priority of this sound
-        virtual const int getPriority() const = 0;
-
-        /// Spielt den Sound ab.
-        virtual void play(bool destroyWhenDone=false) = 0;
-        /// Pausiert den Sound.
-        virtual void pause(bool pausing) = 0;
-        /// Ist der Sound pausiert?
-        virtual bool isPaused() = 0;
-        /// Stoppt den Sound.
-        virtual void stop() = 0;
-        /// Zurueck auf Anfang.
-    //        virtual void rewind() throw (RuntimeException) = 0;
-        /// Laeuft der Sound noch
-        virtual const bool isPlaying() const = 0;
-
-    protected:
-        SoundDriver* mCreator;
-
-        /// Die Lautstaerke
-	    Ogre::Real mVolume;
-        /// Die Position
-        Ogre::Vector3 mPosition;
-        /// Die Richtung
-        Ogre::Quaternion mDirection;
-        /// Die Geschwindigkeit
-        Ogre::Vector3 mVelocity;
-        /// The priority of this sound
-        int mPriority;
-
-	    Ogre::Real mRolloffStartDistance;
-	    Ogre::Real mRolloffEndDistance;
-
-    private:
-        /// Shared class-level name for Movable type
-        static Ogre::AxisAlignedBox msAABox;
-
-        /// Der Soundresource, auf den wir verweisen.
-        SoundResourcePtr mSoundResource;
-
-        // Damit die Timings alle 0.5 sek. abgeschickt werden.
-        int mTicks;
-        // Ob dieser Sound 3D sein soll.
-        bool mIs3d;
-        // Ob dieser Sound loopen soll.
-        bool mIsLooping;
-        
-    }; 
-
-
-    typedef std::set<Sound*> SoundSet;
-
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __Sound_H__
+#define __Sound_H__
+
+#include "CorePrerequisites.h"
+#include <set>
+
+#include "Exception.h"
+#include "EventCaster.h"
+#include "SoundEvents.h"
+#include "SoundResource.h"
+
+namespace rl {
+
+    class SoundDriver;
+
+   /** Diese Klasse dient der Interaktion mit dem jeweiligen Soundsystem
+    * ein Objekt stellt eine einzelne Sounddatei oder einen Stream dar
+    * @author Josch
+    * @date 06-29-2005
+    * @version 1.0
+    * @version 2.0
+    */
+    class _RlCoreExport Sound : public Ogre::MovableObject, 
+        public EventCaster<SoundEvent>, public EventSource
+    {
+    public:
+        // Einige Standardwerte f??r Soundpriorit??ten.
+        enum SOUND_PRIORITY {
+            PRIO_SPEECH = 30,
+            PRIO_MUSIC = 75,
+            PRIO_SFX_ENVIRONMENT = 128,
+            PRIO_SFX_OTHER = 175,
+            PRIO_OTHER = 220
+        };
+
+        /// Konstruktor
+        Sound(const SoundResourcePtr& soundres, SoundDriver* creator);
+        /// Destruktor
+        virtual ~Sound();
+          
+        /// Laedt den Sound.
+        virtual void load() throw (RuntimeException) = 0;
+        /// Entlaedt den Sound.
+        virtual void unload() throw (RuntimeException) = 0;
+
+        // SoundResource zurueckgeben.
+        const SoundResourcePtr& getSoundResource() const;
+        // Wollen wir 3D?
+        bool is3d() const;
+        // Setzen des 3D-Flags.
+        void set3d(bool is3d);
+        // Sind wir gueltig
+        virtual bool isValid() const throw (RuntimeException) = 0;
+        
+        // Sollen der Sound wiederholt werden?
+        bool isLooping() const;
+        // Setzen des Loop-Flags.
+        void setLooping(bool looping);
+
+        virtual float getLength() const = 0;
+
+        /// Unsere Bounding-Box
+        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
+        /// Bound-Radius
+        virtual Ogre::Real getBoundingRadius() const;
+        /// Rendern
+        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+
+
+        /// Gibt die eingestellte Position der Soundquelle zurueck
+        virtual const Ogre::Vector3 getPosition() const = 0;
+        /// Setzt die Position der Soundquelle.
+        virtual void setPosition(const Ogre::Vector3& direction) = 0;
+        /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
+	    virtual const Ogre::Real getVolume() const = 0; 
+        /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
+	    virtual void setVolume(const Ogre::Real gain) = 0;
+        /// Gibt die Richtung der Soundquelle zurueck.
+        virtual const Ogre::Quaternion getDirection() const = 0;
+        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
+        virtual const Ogre::Vector3 getVelocity() const = 0;
+        /// Setzt die Richtung der Soundquelle.
+        virtual void setDirection(const Ogre::Quaternion&) = 0;
+        /// Setzt die Geschwindigkeit der Soundquelle.
+        virtual void setVelocity(const Ogre::Vector3&) = 0;
+	    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
+	    virtual void setRolloffStartDistance(const Ogre::Real&);
+	    virtual const Ogre::Real getRolloffStartDistance() const;
+	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
+	    virtual void setRolloffEndDistance(const Ogre::Real&);
+	    virtual const Ogre::Real getRolloffEndDistance() const;
+        // Sets the priority of this sound
+        virtual void setPriority(const int priority) = 0;
+        // Gets the priority of this sound
+        virtual const int getPriority() const = 0;
+
+        /// Spielt den Sound ab.
+        virtual void play(bool destroyWhenDone=false) = 0;
+        /// Pausiert den Sound.
+        virtual void pause(bool pausing) = 0;
+        /// Ist der Sound pausiert?
+        virtual bool isPaused() = 0;
+        /// Stoppt den Sound.
+        virtual void stop() = 0;
+        /// Zurueck auf Anfang.
+    //        virtual void rewind() throw (RuntimeException) = 0;
+        /// Laeuft der Sound noch
+        virtual const bool isPlaying() const = 0;
+
+	/// From MovableObject
+		virtual void visitRenderables(Ogre::Renderable::Visitor* visitor, 
+			bool debugRenderables = false);
+	
+	protected:
+        SoundDriver* mCreator;
+
+        /// Die Lautstaerke
+	    Ogre::Real mVolume;
+        /// Die Position
+        Ogre::Vector3 mPosition;
+        /// Die Richtung
+        Ogre::Quaternion mDirection;
+        /// Die Geschwindigkeit
+        Ogre::Vector3 mVelocity;
+        /// The priority of this sound
+        int mPriority;
+
+	    Ogre::Real mRolloffStartDistance;
+	    Ogre::Real mRolloffEndDistance;
+
+    private:
+        /// Shared class-level name for Movable type
+        static Ogre::AxisAlignedBox msAABox;
+
+        /// Der Soundresource, auf den wir verweisen.
+        SoundResourcePtr mSoundResource;
+
+        // Damit die Timings alle 0.5 sek. abgeschickt werden.
+        int mTicks;
+        // Ob dieser Sound 3D sein soll.
+        bool mIs3d;
+        // Ob dieser Sound loopen soll.
+        bool mIsLooping;
+        
+    }; 
+
+
+    typedef std::set<Sound*> SoundSet;
+
+}
+#endif

Modified: rl/branches/persistence/core/include/SoundResource.h
===================================================================
--- rl/branches/persistence/core/include/SoundResource.h	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/core/include/SoundResource.h	2008-11-21 15:28:58 UTC (rev 4599)
@@ -33,10 +33,6 @@
  */
 class _RlCoreExport SoundResource: public Ogre::Resource
 {
-    private:
-        /// Unsere Daten von Ogres ResourceManager.
-        Ogre::DataStreamPtr mDataStream;
-                       
     public:
         /// Der Standardkonstruktor
         SoundResource(Ogre::ResourceManager* creator, const Ogre::String& name, 
@@ -44,10 +40,8 @@
             Ogre::ManualResourceLoader* loader);
         /// Der Destruktor
         virtual ~SoundResource();
-        /// Den Datenstrom zur???ckgeben
+        /// Den Datenstrom zurueckgeben
         const Ogre::DataStreamPtr &getDataStream() const;
-        /// Groesse zurueckgeben.
-        int getSize() const;
 
     protected:
 		/// Laedt die Soundquelle.
@@ -57,6 +51,10 @@
 		/// Bestimmt die Groesse im Speicher (wird erst nach dem Laden aufgerufen)
 		virtual size_t calculateSize() const;        
         
+
+	private:
+        /// Unsere Daten von Ogres ResourceManager.
+        Ogre::DataStreamPtr mDataStream;
 };
 
 class _RlCoreExport SoundResourcePtr :

Modified: rl/branches/persistence/core/include/SoundStitching.h
===================================================================
--- rl/branches/persistence/core/include/SoundStitching.h	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/core/include/SoundStitching.h	2008-11-21 15:28:58 UTC (rev 4599)
@@ -1,178 +1,182 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __SoundStitching_H__
-#define __SoundStitching_H__
-
-#include "CorePrerequisites.h"
-#include <set>
-
-#include "Exception.h"
-#include "EventCaster.h"
-#include "SoundEvents.h"
-#include "SoundResource.h"
-
-namespace rl {
-
-    class SoundDriver;
-
-    typedef std::map<CeGuiString, SoundResourcePtr> SoundCache;
-
-   /** Diese Klasse dient der Interaktion mit dem jeweiligen Soundsystem
-    * ein Objekt stellt eine einzelne Sounddatei oder einen Stream dar
-    * @author Josch
-    * @date 06-29-2005
-    * @version 1.0
-    * @version 2.0
-    */
-    class _RlCoreExport SoundStitching : public Ogre::MovableObject, 
-        public EventCaster<SoundEvent>, public EventSource
-    {
-    public:
-        // Einige Standardwerte f??r Soundpriorit??ten.
-        enum SOUND_PRIORITY {
-            PRIO_SPEECH = 30,
-            PRIO_MUSIC = 75,
-            PRIO_SFX_ENVIRONMENT = 128,
-            PRIO_SFX_OTHER = 175,
-            PRIO_OTHER = 220
-        };
-
-        /// Konstruktor
-        SoundStitching(unsigned int numSlots, const CeGuiString& name, SoundDriver* creator);
-        /// Destruktor
-        virtual ~SoundStitching();
-          
-        /// Laedt den Sound.
-        virtual void load() throw (RuntimeException) = 0;
-        /// Entlaedt den Sound.
-        virtual void unload() throw (RuntimeException) = 0;
-
-        virtual float getLength() const;
-
-        // SoundResource zurueckgeben.
-        const SoundResourcePtr& getSoundResource() const;
-        // Wollen wir 3D?
-        bool is3d() const;
-        // Setzen des 3D-Flags.
-        void set3d(bool is3d);
-        // Sind wir gueltig
-        virtual bool isValid() const throw (RuntimeException) = 0;
-        
-        // Sollen der Sound wiederholt werden?
-        bool isLooping() const;
-        // Setzen des Loop-Flags.
-        void setLooping(bool looping);
-
-        /// Unsere Bounding-Box
-        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
-        /// Bound-Radius
-        virtual Ogre::Real getBoundingRadius() const;
-        /// Rendern
-        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
-
-        /// Count of configured slots.
-        unsigned int getNumSlots();
-        /// Add a sound resource to the cache overwritting existing sound resource.
-        virtual void addSoundToCache(CeGuiString label, SoundResourcePtr sound);
-        /// Assign a sound recource to a slot.
-        virtual void putSoundIntoSlot(unsigned int, CeGuiString label) = 0;
-        /// Get the slot of the plaing sound.
-        virtual unsigned int getPlayingSlot() = 0;
-
-        /// Gibt die eingestellte Position der Soundquelle zurueck
-        virtual const Ogre::Vector3 getPosition() const = 0;
-        /// Setzt die Position der Soundquelle.
-        virtual void setPosition(const Ogre::Vector3& direction) = 0;
-        /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
-	    virtual const Ogre::Real getVolume() const = 0; 
-        /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
-	    virtual void setVolume(const Ogre::Real gain) = 0;
-        /// Gibt die Richtung der Soundquelle zurueck.
-        virtual const Ogre::Quaternion getDirection() const = 0;
-        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
-        virtual const Ogre::Vector3 getVelocity() const = 0;
-        /// Setzt die Richtung der Soundquelle.
-        virtual void setDirection(const Ogre::Quaternion&) = 0;
-        /// Setzt die Geschwindigkeit der Soundquelle.
-        virtual void setVelocity(const Ogre::Vector3&) = 0;
-	    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
-	    virtual void setRolloffStartDistance(const Ogre::Real&);
-	    virtual const Ogre::Real getRolloffStartDistance() const;
-	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
-	    virtual void setRolloffEndDistance(const Ogre::Real&);
-	    virtual const Ogre::Real getRolloffEndDistance() const;
-        // Sets the priority of this sound
-        virtual void setPriority(const int priority) = 0;
-        // Gets the priority of this sound
-        virtual const int getPriority() const = 0;
-
-        /// Spielt den Sound ab.
-        virtual void play(bool destroyWhenDone=false) = 0;
-        /// Pausiert den Sound.
-        virtual void pause(bool pausing) = 0;
-        /// Ist der Sound pausiert?
-        virtual bool isPaused() = 0;
-        /// Stoppt den Sound.
-        virtual void stop() = 0;
-        /// Laeuft der Sound noch
-        virtual const bool isPlaying() const = 0;
-
-    protected:
-        SoundDriver* mCreator;
-
-        /// Die Lautstaerke
-	    Ogre::Real mVolume;
-        /// Die Position
-        Ogre::Vector3 mPosition;
-        /// Die Richtung
-        Ogre::Quaternion mDirection;
-        /// Die Geschwindigkeit
-        Ogre::Vector3 mVelocity;
-        /// The priority of this sound
-        int mPriority;
-
-	    Ogre::Real mRolloffStartDistance;
-	    Ogre::Real mRolloffEndDistance;
-
-        // Sound-Cache
-        SoundCache mSoundCache;
-
-    private:
-        /// Shared class-level name for Movable type
-        static Ogre::AxisAlignedBox msAABox;
-
-        /// Der Soundresource, auf den wir verweisen.
-        SoundResourcePtr mSoundResource;
-
-        // Damit die Timings alle 0.5 sek. abgeschickt werden.
-        int mTicks;
-        // Ob dieser Sound 3D sein soll.
-        bool mIs3d;
-        // Ob dieser Sound loopen soll.
-        bool mIsLooping;
-
-        // Anzahl der Soundslots
-        unsigned int mNumSlots;
-
-        // Name
-        CeGuiString mName;
-        
-    }; 
-
-}
-#endif
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __SoundStitching_H__
+#define __SoundStitching_H__
+
+#include "CorePrerequisites.h"
+#include <set>
+
+#include "Exception.h"
+#include "EventCaster.h"
+#include "SoundEvents.h"
+#include "SoundResource.h"
+
+namespace rl {
+
+    class SoundDriver;
+
+    typedef std::map<CeGuiString, SoundResourcePtr> SoundCache;
+
+   /** Diese Klasse dient der Interaktion mit dem jeweiligen Soundsystem
+    * ein Objekt stellt eine einzelne Sounddatei oder einen Stream dar
+    * @author Josch
+    * @date 06-29-2005
+    * @version 1.0
+    * @version 2.0
+    */
+    class _RlCoreExport SoundStitching : public Ogre::MovableObject, 
+        public EventCaster<SoundEvent>, public EventSource
+    {
+    public:
+        // Einige Standardwerte f??r Soundpriorit??ten.
+        enum SOUND_PRIORITY {
+            PRIO_SPEECH = 30,
+            PRIO_MUSIC = 75,
+            PRIO_SFX_ENVIRONMENT = 128,
+            PRIO_SFX_OTHER = 175,
+            PRIO_OTHER = 220
+        };
+
+        /// Konstruktor
+        SoundStitching(unsigned int numSlots, const CeGuiString& name, SoundDriver* creator);
+        /// Destruktor
+        virtual ~SoundStitching();
+          
+        /// Laedt den Sound.
+        virtual void load() throw (RuntimeException) = 0;
+        /// Entlaedt den Sound.
+        virtual void unload() throw (RuntimeException) = 0;
+
+        virtual float getLength() const;
+
+        // SoundResource zurueckgeben.
+        const SoundResourcePtr& getSoundResource() const;
+        // Wollen wir 3D?
+        bool is3d() const;
+        // Setzen des 3D-Flags.
+        void set3d(bool is3d);
+        // Sind wir gueltig
+        virtual bool isValid() const throw (RuntimeException) = 0;
+        
+        // Sollen der Sound wiederholt werden?
+        bool isLooping() const;
+        // Setzen des Loop-Flags.
+        void setLooping(bool looping);
+
+        /// Unsere Bounding-Box
+        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
+        /// Bound-Radius
+        virtual Ogre::Real getBoundingRadius() const;
+        /// Rendern
+        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+
+        /// Count of configured slots.
+        unsigned int getNumSlots();
+        /// Add a sound resource to the cache overwritting existing sound resource.
+        virtual void addSoundToCache(CeGuiString label, SoundResourcePtr sound);
+        /// Assign a sound recource to a slot.
+        virtual void putSoundIntoSlot(unsigned int, CeGuiString label) = 0;
+        /// Get the slot of the plaing sound.
+        virtual unsigned int getPlayingSlot() = 0;
+
+        /// Gibt die eingestellte Position der Soundquelle zurueck
+        virtual const Ogre::Vector3 getPosition() const = 0;
+        /// Setzt die Position der Soundquelle.
+        virtual void setPosition(const Ogre::Vector3& direction) = 0;
+        /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
+	    virtual const Ogre::Real getVolume() const = 0; 
+        /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
+	    virtual void setVolume(const Ogre::Real gain) = 0;
+        /// Gibt die Richtung der Soundquelle zurueck.
+        virtual const Ogre::Quaternion getDirection() const = 0;
+        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
+        virtual const Ogre::Vector3 getVelocity() const = 0;
+        /// Setzt die Richtung der Soundquelle.
+        virtual void setDirection(const Ogre::Quaternion&) = 0;
+        /// Setzt die Geschwindigkeit der Soundquelle.
+        virtual void setVelocity(const Ogre::Vector3&) = 0;
+	    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
+	    virtual void setRolloffStartDistance(const Ogre::Real&);
+	    virtual const Ogre::Real getRolloffStartDistance() const;
+	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
+	    virtual void setRolloffEndDistance(const Ogre::Real&);
+	    virtual const Ogre::Real getRolloffEndDistance() const;
+        // Sets the priority of this sound
+        virtual void setPriority(const int priority) = 0;
+        // Gets the priority of this sound
+        virtual const int getPriority() const = 0;
+
+        /// Spielt den Sound ab.
+        virtual void play(bool destroyWhenDone=false) = 0;
+        /// Pausiert den Sound.
+        virtual void pause(bool pausing) = 0;
+        /// Ist der Sound pausiert?
+        virtual bool isPaused() = 0;
+        /// Stoppt den Sound.
+        virtual void stop() = 0;
+        /// Laeuft der Sound noch
+        virtual const bool isPlaying() const = 0;
+
+		/// From MovableObject
+		virtual void visitRenderables(Ogre::Renderable::Visitor* visitor, 
+			bool debugRenderables = false);
+
+    protected:
+        SoundDriver* mCreator;
+
+        /// Die Lautstaerke
+	    Ogre::Real mVolume;
+        /// Die Position
+        Ogre::Vector3 mPosition;
+        /// Die Richtung
+        Ogre::Quaternion mDirection;
+        /// Die Geschwindigkeit
+        Ogre::Vector3 mVelocity;
+        /// The priority of this sound
+        int mPriority;
+
+	    Ogre::Real mRolloffStartDistance;
+	    Ogre::Real mRolloffEndDistance;
+
+        // Sound-Cache
+        SoundCache mSoundCache;
+
+    private:
+        /// Shared class-level name for Movable type
+        static Ogre::AxisAlignedBox msAABox;
+
+        /// Der Soundresource, auf den wir verweisen.
+        SoundResourcePtr mSoundResource;
+
+        // Damit die Timings alle 0.5 sek. abgeschickt werden.
+        int mTicks;
+        // Ob dieser Sound 3D sein soll.
+        bool mIs3d;
+        // Ob dieser Sound loopen soll.
+        bool mIsLooping;
+
+        // Anzahl der Soundslots
+        unsigned int mNumSlots;
+
+        // Name
+        CeGuiString mName;
+        
+    }; 
+
+}
+#endif
+

Modified: rl/branches/persistence/core/src/Actor.cpp
===================================================================
--- rl/branches/persistence/core/src/Actor.cpp	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/core/src/Actor.cpp	2008-11-21 15:28:58 UTC (rev 4599)
@@ -434,17 +434,17 @@
             node->setScale( vec );
 
             // Falls es sich um ein Mesh handelt ...
-            if( getControlledObject()->isMeshObject() )
+/*            if( getControlledObject()->isMeshObject() )
             {
                 MeshObject* meshObj = dynamic_cast<MeshObject*>( getControlledObject() );
 
                 // ... und gr??er/kleiner als normal skaliert wird ...
                 if( vec != Vector3(1,1,1) )
                     // ... m?ssen die Normalen neu berechnet werden.
-                    meshObj->getEntity()->setNormaliseNormals( true );
+					meshObj->getEntity()->setNormaliseNormals( true );
                 else
                     meshObj->getEntity()->setNormaliseNormals( false );
-            }
+            }*/
         }
     }
 

Modified: rl/branches/persistence/core/src/ListenerMovable.cpp
===================================================================
--- rl/branches/persistence/core/src/ListenerMovable.cpp	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/core/src/ListenerMovable.cpp	2008-11-21 15:28:58 UTC (rev 4599)
@@ -203,4 +203,9 @@
 	mActive = active;
 }
 
+void ListenerMovable::visitRenderables(Renderable::Visitor* visitor, 
+			bool debugRenderables)
+{
 }
+
+}

Modified: rl/branches/persistence/core/src/MovableText.cpp
===================================================================
--- rl/branches/persistence/core/src/MovableText.cpp	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/core/src/MovableText.cpp	2008-11-21 15:28:58 UTC (rev 4599)
@@ -554,4 +554,11 @@
     {
         return mAlignment;
     }
+
+    /************************************************************************/
+	void MovableText::visitRenderables(Renderable::Visitor* visitor, 
+			bool debugRenderables)
+	{
+		visitor->visit(this, 0, debugRenderables);
+	}
 }

Modified: rl/branches/persistence/core/src/PhysicalThing.cpp
===================================================================
--- rl/branches/persistence/core/src/PhysicalThing.cpp	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/core/src/PhysicalThing.cpp	2008-11-21 15:28:58 UTC (rev 4599)
@@ -130,8 +130,8 @@
 		if (mBody && mActor)
 		{
 			mBody->setPositionOrientation(
-				mActor->_getSceneNode()->getWorldPosition(),
-				mActor->_getSceneNode()->getWorldOrientation());
+				mActor->_getSceneNode()->_getDerivedPosition(),
+				mActor->_getSceneNode()->_getDerivedOrientation());
 			mActor->_update(Actor::UF_ALL & ~Actor::UF_PHYSICAL_THING);
 		}
     }

Modified: rl/branches/persistence/core/src/PhysicsManager.cpp
===================================================================
--- rl/branches/persistence/core/src/PhysicsManager.cpp	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/core/src/PhysicsManager.cpp	2008-11-21 15:28:58 UTC (rev 4599)
@@ -315,8 +315,8 @@
 
 
             body->attachToNode(node);
-            body->setPositionOrientation(node->getWorldPosition(),
-                node->getWorldOrientation());
+            body->setPositionOrientation(node->_getDerivedPosition(),
+                node->_getDerivedOrientation());
             body->setMaterialGroupID(getMaterialID("level"));
 
 			mLevelBodiesQuadTree.add(body);

Modified: rl/branches/persistence/core/src/Sound.cpp
===================================================================
--- rl/branches/persistence/core/src/Sound.cpp	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/core/src/Sound.cpp	2008-11-21 15:28:58 UTC (rev 4599)
@@ -1,148 +1,153 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "Sound.h"
-#include "SoundDriver.h"
-
-using namespace Ogre;
-
-namespace rl
-{
-
-AxisAlignedBox Sound::msAABox = Ogre::AxisAlignedBox(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
-
-Sound::Sound(const SoundResourcePtr &soundres, SoundDriver* creator)
-: MovableObject(soundres->getName()),
-   EventSource(),
-   EventCaster<SoundEvent>(),
-   mCreator(creator),
-   mVolume(1.0),
-   mSoundResource(soundres),
-   mIsLooping(false),
-   mIs3d(false),
-   mTicks(0),
-   mPosition(Vector3::ZERO),
-   mDirection(Quaternion::IDENTITY),
-   mVelocity(Vector3::ZERO),
-   mPriority(128),
-   mRolloffStartDistance(1.0),
-   mRolloffEndDistance(10000.0)
-{
-}
-
-Sound::~Sound()
-{
-}
-
-/**
- * @return Ob der Sound wiederholt werden soll
- * @author JoSch
- * @date 08-08-2005
- */
-bool Sound::isLooping() const
-{
-    return mIsLooping;
-}
-
-/**
- * @param looping Ob der Sound wiederholt werden soll
- * @author JoSch
- * @date 08-08-2005
- */
-void Sound::setLooping(bool looping)
-{
-    mIsLooping = looping;
-}
-
-/**
- * @return Ob der Sound ein 3D-Sound ist.
- * @author JoSch
- * @date 08-08-2005
- */
-bool Sound::is3d() const
-{
-    return mIs3d;
-}
-
-/**
- * @param is3d Ob der Sound ein 3D-Sound ist.
- * @author JoSch
- * @date 08-08-2005
- */
-void Sound::set3d(bool is3d)
-{
-    mIs3d = is3d;
-}
-
-/** SoundResource zur?ckgeben.
- * @return Der Pointer auf die zugeh?rige Soundresource.
- * @author JoSch
- * @date 08-08-2005
- */
-const SoundResourcePtr &Sound::getSoundResource() const
-{
-    return mSoundResource;
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-const AxisAlignedBox& Sound::getBoundingBox() const
-{
-    return msAABox;
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-Real Sound::getBoundingRadius (void) const
-{
-    return 0.0f; // SQRT(3*SQR(0.0)) to fit with AABB
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-void Sound::_updateRenderQueue(RenderQueue *queue)
-{
-    // Brauchen wir nicht
-}
-
-void Sound::setRolloffStartDistance(const Ogre::Real& distance)
-{
-	mRolloffStartDistance = distance;
-}
-
-const Ogre::Real Sound::getRolloffStartDistance() const
-{
-	return mRolloffStartDistance;
-}
-
-void Sound::setRolloffEndDistance(const Ogre::Real& distance)
-{
-	mRolloffEndDistance = distance;
-}
-
-const Ogre::Real Sound::getRolloffEndDistance() const
-{
-	return mRolloffEndDistance;
-}
-
-};
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "Sound.h"
+#include "SoundDriver.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+
+AxisAlignedBox Sound::msAABox = Ogre::AxisAlignedBox(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
+
+Sound::Sound(const SoundResourcePtr &soundres, SoundDriver* creator)
+: MovableObject(soundres->getName()),
+   EventSource(),
+   EventCaster<SoundEvent>(),
+   mCreator(creator),
+   mVolume(1.0),
+   mSoundResource(soundres),
+   mIsLooping(false),
+   mIs3d(false),
+   mTicks(0),
+   mPosition(Vector3::ZERO),
+   mDirection(Quaternion::IDENTITY),
+   mVelocity(Vector3::ZERO),
+   mPriority(128),
+   mRolloffStartDistance(1.0),
+   mRolloffEndDistance(10000.0)
+{
+}
+
+Sound::~Sound()
+{
+}
+
+/**
+ * @return Ob der Sound wiederholt werden soll
+ * @author JoSch
+ * @date 08-08-2005
+ */
+bool Sound::isLooping() const
+{
+    return mIsLooping;
+}
+
+/**
+ * @param looping Ob der Sound wiederholt werden soll
+ * @author JoSch
+ * @date 08-08-2005
+ */
+void Sound::setLooping(bool looping)
+{
+    mIsLooping = looping;
+}
+
+/**
+ * @return Ob der Sound ein 3D-Sound ist.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+bool Sound::is3d() const
+{
+    return mIs3d;
+}
+
+/**
+ * @param is3d Ob der Sound ein 3D-Sound ist.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+void Sound::set3d(bool is3d)
+{
+    mIs3d = is3d;
+}
+
+/** SoundResource zur?ckgeben.
+ * @return Der Pointer auf die zugeh?rige Soundresource.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+const SoundResourcePtr &Sound::getSoundResource() const
+{
+    return mSoundResource;
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+const AxisAlignedBox& Sound::getBoundingBox() const
+{
+    return msAABox;
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+Real Sound::getBoundingRadius (void) const
+{
+    return 0.0f; // SQRT(3*SQR(0.0)) to fit with AABB
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+void Sound::_updateRenderQueue(RenderQueue *queue)
+{
+    // Brauchen wir nicht
+}
+
+void Sound::setRolloffStartDistance(const Ogre::Real& distance)
+{
+	mRolloffStartDistance = distance;
+}
+
+const Ogre::Real Sound::getRolloffStartDistance() const
+{
+	return mRolloffStartDistance;
+}
+
+void Sound::setRolloffEndDistance(const Ogre::Real& distance)
+{
+	mRolloffEndDistance = distance;
+}
+
+const Ogre::Real Sound::getRolloffEndDistance() const
+{
+	return mRolloffEndDistance;
+}
+
+void Sound::visitRenderables(Renderable::Visitor* visitor, 
+			bool debugRenderables)
+{
+}
+
+};

Modified: rl/branches/persistence/core/src/SoundResource.cpp
===================================================================
--- rl/branches/persistence/core/src/SoundResource.cpp	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/core/src/SoundResource.cpp	2008-11-21 15:28:58 UTC (rev 4599)
@@ -85,15 +85,6 @@
 }
 
 /**
- * @author JoSch
- * @date 03-14-2005
- */
-int SoundResource::getSize() const
-{
-    return calculateSize();
-}
-
-/**
  * @author Blakharaz
  * @date 03-14-2005
  */

Modified: rl/branches/persistence/core/src/SoundStitching.cpp
===================================================================
--- rl/branches/persistence/core/src/SoundStitching.cpp	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/core/src/SoundStitching.cpp	2008-11-21 15:28:58 UTC (rev 4599)
@@ -1,166 +1,171 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "SoundStitching.h"
-#include "SoundDriver.h"
-
-using namespace Ogre;
-
-namespace rl
-{
-
-AxisAlignedBox SoundStitching::msAABox = Ogre::AxisAlignedBox(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
-
-SoundStitching::SoundStitching(unsigned int numSlots, const CeGuiString& name, SoundDriver* creator)
-:  MovableObject(name.c_str()),
-   EventSource(),
-   EventCaster<SoundEvent>(),
-   mCreator(creator),
-   mVolume(1.0),
-   mName(name),
-   mIsLooping(true),
-   mIs3d(false),
-   mTicks(0),
-   mPosition(Vector3::ZERO),
-   mDirection(Quaternion::IDENTITY),
-   mVelocity(Vector3::ZERO),
-   mPriority(128),
-   mRolloffStartDistance(1.0),
-   mRolloffEndDistance(10000.0),
-   mNumSlots(numSlots)
-{
-}
-
-SoundStitching::~SoundStitching()
-{
-}
-
-/**
- * @return Ob der Sound wiederholt werden soll
- * @author JoSch
- * @date 08-08-2005
- */
-bool SoundStitching::isLooping() const
-{
-    return mIsLooping;
-}
-
-/**
- * @param looping Ob der Sound wiederholt werden soll
- * @author JoSch
- * @date 08-08-2005
- */
-void SoundStitching::setLooping(bool looping)
-{
-    mIsLooping = looping;
-}
-
-/**
- * @return Ob der Sound ein 3D-Sound ist.
- * @author JoSch
- * @date 08-08-2005
- */
-bool SoundStitching::is3d() const
-{
-    return mIs3d;
-}
-
-/**
- * @param is3d Ob der Sound ein 3D-Sound ist.
- * @author JoSch
- * @date 08-08-2005
- */
-void SoundStitching::set3d(bool is3d)
-{
-    mIs3d = is3d;
-}
-
-/** SoundResource zur?ckgeben.
- * @return Der Pointer auf die zugeh?rige Soundresource.
- * @author JoSch
- * @date 08-08-2005
- */
-const SoundResourcePtr &SoundStitching::getSoundResource() const
-{
-    return mSoundResource;
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-const AxisAlignedBox& SoundStitching::getBoundingBox() const
-{
-    return msAABox;
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-Real SoundStitching::getBoundingRadius (void) const
-{
-    return 0.0f; // SQRT(3*SQR(0.0)) to fit with AABB
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-void SoundStitching::_updateRenderQueue(RenderQueue *queue)
-{
-    // Brauchen wir nicht
-}
-
-void SoundStitching::setRolloffStartDistance(const Ogre::Real& distance)
-{
-	mRolloffStartDistance = distance;
-}
-
-const Ogre::Real SoundStitching::getRolloffStartDistance() const
-{
-	return mRolloffStartDistance;
-}
-
-void SoundStitching::setRolloffEndDistance(const Ogre::Real& distance)
-{
-	mRolloffEndDistance = distance;
-}
-
-const Ogre::Real SoundStitching::getRolloffEndDistance() const
-{
-	return mRolloffEndDistance;
-}
-
-
-void SoundStitching::addSoundToCache(CeGuiString label, SoundResourcePtr sound)
-{
-    mSoundCache[label] = sound;
-}
-
-unsigned int SoundStitching::getNumSlots()
-{
-    return mNumSlots;
-}
-
-float SoundStitching::getLength() const
-{
-    return 0.0f;
-}
-
-};
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "SoundStitching.h"
+#include "SoundDriver.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+
+AxisAlignedBox SoundStitching::msAABox = Ogre::AxisAlignedBox(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
+
+SoundStitching::SoundStitching(unsigned int numSlots, const CeGuiString& name, SoundDriver* creator)
+:  MovableObject(name.c_str()),
+   EventSource(),
+   EventCaster<SoundEvent>(),
+   mCreator(creator),
+   mVolume(1.0),
+   mName(name),
+   mIsLooping(true),
+   mIs3d(false),
+   mTicks(0),
+   mPosition(Vector3::ZERO),
+   mDirection(Quaternion::IDENTITY),
+   mVelocity(Vector3::ZERO),
+   mPriority(128),
+   mRolloffStartDistance(1.0),
+   mRolloffEndDistance(10000.0),
+   mNumSlots(numSlots)
+{
+}
+
+SoundStitching::~SoundStitching()
+{
+}
+
+/**
+ * @return Ob der Sound wiederholt werden soll
+ * @author JoSch
+ * @date 08-08-2005
+ */
+bool SoundStitching::isLooping() const
+{
+    return mIsLooping;
+}
+
+/**
+ * @param looping Ob der Sound wiederholt werden soll
+ * @author JoSch
+ * @date 08-08-2005
+ */
+void SoundStitching::setLooping(bool looping)
+{
+    mIsLooping = looping;
+}
+
+/**
+ * @return Ob der Sound ein 3D-Sound ist.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+bool SoundStitching::is3d() const
+{
+    return mIs3d;
+}
+
+/**
+ * @param is3d Ob der Sound ein 3D-Sound ist.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+void SoundStitching::set3d(bool is3d)
+{
+    mIs3d = is3d;
+}
+
+/** SoundResource zur?ckgeben.
+ * @return Der Pointer auf die zugeh?rige Soundresource.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+const SoundResourcePtr &SoundStitching::getSoundResource() const
+{
+    return mSoundResource;
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+const AxisAlignedBox& SoundStitching::getBoundingBox() const
+{
+    return msAABox;
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+Real SoundStitching::getBoundingRadius (void) const
+{
+    return 0.0f; // SQRT(3*SQR(0.0)) to fit with AABB
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+void SoundStitching::_updateRenderQueue(RenderQueue *queue)
+{
+    // Brauchen wir nicht
+}
+
+void SoundStitching::setRolloffStartDistance(const Ogre::Real& distance)
+{
+	mRolloffStartDistance = distance;
+}
+
+const Ogre::Real SoundStitching::getRolloffStartDistance() const
+{
+	return mRolloffStartDistance;
+}
+
+void SoundStitching::setRolloffEndDistance(const Ogre::Real& distance)
+{
+	mRolloffEndDistance = distance;
+}
+
+const Ogre::Real SoundStitching::getRolloffEndDistance() const
+{
+	return mRolloffEndDistance;
+}
+
+
+void SoundStitching::addSoundToCache(CeGuiString label, SoundResourcePtr sound)
+{
+    mSoundCache[label] = sound;
+}
+
+unsigned int SoundStitching::getNumSlots()
+{
+    return mNumSlots;
+}
+
+float SoundStitching::getLength() const
+{
+    return 0.0f;
+}
+
+void SoundStitching::visitRenderables(Renderable::Visitor* visitor, 
+			bool debugRenderables)
+{
+}
+
+};
+

Modified: rl/branches/persistence/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/branches/persistence/script/src/PlaneNodeProcessor.cpp	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/script/src/PlaneNodeProcessor.cpp	2008-11-21 15:28:58 UTC (rev 4599)
@@ -222,8 +222,8 @@
 
 	void PlaneReflectionTextureListener::preRenderTargetUpdate(const RenderTargetEvent &evt)
 	{
-		mCamera->setPosition(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getWorldPosition());
-		mCamera->setOrientation(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getWorldOrientation());
+		mCamera->setPosition(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getDerivedPosition());
+		mCamera->setOrientation(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getDerivedOrientation());
 		mEntity->setVisible(false);
 		mCamera->enableReflection((MovablePlane*)mPlane);
 	}
@@ -242,8 +242,8 @@
 
 	void PlaneRefractionTextureListener::preRenderTargetUpdate(const Ogre::RenderTargetEvent& evt)
 	{
-		mCamera->setPosition(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getWorldPosition());
-		mCamera->setOrientation(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getWorldOrientation());
+		mCamera->setPosition(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getDerivedPosition());
+		mCamera->setOrientation(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getDerivedOrientation());
 		mEntity->setVisible(false);
 	}
 

Modified: rl/branches/persistence/ui/src/DebugWindow.cpp
===================================================================
--- rl/branches/persistence/ui/src/DebugWindow.cpp	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/ui/src/DebugWindow.cpp	2008-11-21 15:28:58 UTC (rev 4599)
@@ -186,8 +186,8 @@
 
             if( charObj != NULL )
             {
-                Ogre::Vector3 pos = charObj->getMovableObject()->getParentNode()->getWorldPosition();
-                Ogre::Quaternion ori = charObj->getMovableObject()->getParentNode()->getWorldOrientation();
+                Ogre::Vector3 pos = charObj->getMovableObject()->getParentNode()->_getDerivedPosition();
+                Ogre::Quaternion ori = charObj->getMovableObject()->getParentNode()->_getDerivedOrientation();
 
                 textSt += "\nPlayer Position [ "
                     + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+", "

Modified: rl/branches/persistence/ui/src/DialogControlState.cpp
===================================================================
--- rl/branches/persistence/ui/src/DialogControlState.cpp	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/ui/src/DialogControlState.cpp	2008-11-21 15:28:58 UTC (rev 4599)
@@ -220,8 +220,8 @@
 
         // Weltkoordinaten in lokale umwandeln
         mTargetCameraPosition =
-            -1*(mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldOrientation().Inverse()*
-            (mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldPosition() - globalCameraPosition));
+            -1*(mCameraActor->_getSceneNode()->getParentSceneNode()->_getDerivedOrientation().Inverse()*
+            (mCameraActor->_getSceneNode()->getParentSceneNode()->_getDerivedPosition() - globalCameraPosition));
 
         mTargetCameraDirection = (listenerEyes - mTargetCameraPosition).normalisedCopy();
     }

Modified: rl/branches/persistence/ui/src/InventoryWindow.cpp
===================================================================
--- rl/branches/persistence/ui/src/InventoryWindow.cpp	2008-11-21 15:26:21 UTC (rev 4598)
+++ rl/branches/persistence/ui/src/InventoryWindow.cpp	2008-11-21 15:28:58 UTC (rev 4599)
@@ -448,7 +448,7 @@
 		mousePos.d_y /= getRoot()->getPixelSize().d_height;
 		Ogre::Ray camToWorld = camera->getCameraToViewportRay(
 			mousePos.d_x, mousePos.d_y);
-		Ogre::Vector3 rayStart = camera->getCamera()->getWorldPosition();
+		Ogre::Vector3 rayStart = camera->getCamera()->getDerivedPosition();
 		Ogre::Vector3 rayDir = camera->getDirectionFromScreenPosition(
 			mousePos.d_x, mousePos.d_y);
 



From tanis at mail.berlios.de  Fri Nov 21 20:26:22 2008
From: tanis at mail.berlios.de (tanis at mail.berlios.de)
Date: Fri, 21 Nov 2008 20:26:22 +0100
Subject: [Dsa-hl-svn] r4600 - in rl/trunk: . engine/rules/src
Message-ID: <200811211926.mALJQMgZ005029@sheep.berlios.de>

Author: tanis
Date: 2008-11-21 20:26:07 +0100 (Fri, 21 Nov 2008)
New Revision: 4600

Modified:
   rl/trunk/bootstrap
   rl/trunk/engine/rules/src/Makefile.am
Log:
fixed linux build

Modified: rl/trunk/bootstrap
===================================================================
--- rl/trunk/bootstrap	2008-11-21 15:28:58 UTC (rev 4599)
+++ rl/trunk/bootstrap	2008-11-21 19:26:07 UTC (rev 4600)
@@ -1,32 +1,4 @@
 #!/bin/sh
-
-# Check for proper versions of autotools
-# We require:
-#  - autoconf 2.50+
-#  - automake 1.6+
-#  - libtool 1.4+
-
-# Deal with some gentoo-specific issues
-export WANT_AUTOMAKE='1.7'
-export WANT_AUTOCONF_2_5=1
-
-## Using prereq in autoconf rather than here, mostly for the debian systems at
-## this point
-if test -z "`autoconf --version 2>&1|head -n 1|egrep '2.[5-9]'`"; then
-	echo "Autoconf 2.50 or above is required. Aborting build...";
-    exit 1;
-fi
-
-if test -z "`automake --version 2>&1|head -n 1|egrep '1.([6-9]|[1-9][0-9])'`"; then
-	echo "Automake 1.6 or above is required. Aborting build...";
-	exit 1;
-fi
-
-if test -z "`libtool --version 2>&1|head -n 1|egrep '1.[4-5]'`"; then
-	echo "Libtool 1.4 or above is required. Aborting build...";
-	exit 1;
-fi
-
 echo "Bootstrap..."
 
 # Fire up autotools

Modified: rl/trunk/engine/rules/src/Makefile.am
===================================================================
--- rl/trunk/engine/rules/src/Makefile.am	2008-11-21 15:28:58 UTC (rev 4599)
+++ rl/trunk/engine/rules/src/Makefile.am	2008-11-21 19:26:07 UTC (rev 4600)
@@ -29,6 +29,7 @@
 	GameTimeSource.cpp \
 	GlobalProperties.cpp \
 	GoToJob.cpp \
+	FetchItemJob.cpp \
 	Item.cpp \
 	Inventory.cpp \
 	JournalEntry.cpp \



From timm at mail.berlios.de  Sun Nov 23 19:09:48 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 23 Nov 2008 19:09:48 +0100
Subject: [Dsa-hl-svn] r4601 - in rl/branches/persistence: ai/src common/src
	core/include core/src rules/src script/include script/src ui
Message-ID: <200811231809.mANI9mtb029780@sheep.berlios.de>

Author: timm
Date: 2008-11-23 19:09:31 +0100 (Sun, 23 Nov 2008)
New Revision: 4601

Modified:
   rl/branches/persistence/ai/src/DialogManager.cpp
   rl/branches/persistence/common/src/WriteableFileSystemArchiv.cpp
   rl/branches/persistence/core/include/CoreSubsystem.h
   rl/branches/persistence/core/include/SaveAbleCollection.h
   rl/branches/persistence/core/include/SaveAbleManager.h
   rl/branches/persistence/core/include/SaveAbleSerializer.h
   rl/branches/persistence/core/include/SaveGameFileWriter.h
   rl/branches/persistence/core/src/CoreSubsystem.cpp
   rl/branches/persistence/core/src/SaveAbleSerializer.cpp
   rl/branches/persistence/core/src/SaveGameFileWriter.cpp
   rl/branches/persistence/core/src/SaveGameManager.cpp
   rl/branches/persistence/rules/src/Makefile.am
   rl/branches/persistence/script/include/Scene.h
   rl/branches/persistence/script/src/Scene.cpp
   rl/branches/persistence/ui/RlUI2005.vcproj
Log:
begin to join different parts of save able system

Modified: rl/branches/persistence/ai/src/DialogManager.cpp
===================================================================
--- rl/branches/persistence/ai/src/DialogManager.cpp	2008-11-21 19:26:07 UTC (rev 4600)
+++ rl/branches/persistence/ai/src/DialogManager.cpp	2008-11-23 18:09:31 UTC (rev 4601)
@@ -113,7 +113,7 @@
         LOG_MESSAGE(Logger::RULES, "Saving dialogs");
 
         PropertyRecordPtr set = getAllProperties();
-        writer->writeEachProperty(this, set->toPropertyMap());
+        //writer->writeEachProperty(this, set->toPropertyMap());
     }
 
     void DialogManager::readData(SaveGameFileReader* reader)

Modified: rl/branches/persistence/common/src/WriteableFileSystemArchiv.cpp
===================================================================
--- rl/branches/persistence/common/src/WriteableFileSystemArchiv.cpp	2008-11-21 19:26:07 UTC (rev 4600)
+++ rl/branches/persistence/common/src/WriteableFileSystemArchiv.cpp	2008-11-23 18:09:31 UTC (rev 4601)
@@ -74,12 +74,6 @@
     {
         String full_path = concatenate_path(mName, filename);
 
-        // Use filesystem to determine size 
-        // (quicker than streaming to the end and back)
-        struct stat tagStat;
-	int ret = stat(full_path.c_str(), &tagStat);
-        assert(ret == 0 && "Problem getting file size" );
-
         // Always open in binary mode
         std::fstream *origStream = new std::fstream();
         origStream->open(full_path.c_str(), std::ios::in | std::ios::out | std::ios::binary);
@@ -89,19 +83,19 @@
         {
             delete origStream;
             OGRE_EXCEPT(Exception::ERR_FILE_NOT_FOUND,
-                "Cannot open file: " + filename,
+                "Cannot open or create file: " + filename,
                 "WriteableFileSystemArchive::open");
         }
 
         /// Construct return stream, tell it to delete on destroy
         WriteableFileStreamDataStream* stream = new WriteableFileStreamDataStream(filename,
-            origStream, tagStat.st_size, true);
+            origStream, true);
         return DataStreamPtr(stream);
     }
     
     const String& WriteableFileSystemArchiveFactory::getType(void) const
     {
-        static String name = "FileSystem";
+        static String name = "WriteableFileSystem";
         return name;
     }
 

Modified: rl/branches/persistence/core/include/CoreSubsystem.h
===================================================================
--- rl/branches/persistence/core/include/CoreSubsystem.h	2008-11-21 19:26:07 UTC (rev 4600)
+++ rl/branches/persistence/core/include/CoreSubsystem.h	2008-11-23 18:09:31 UTC (rev 4601)
@@ -43,6 +43,7 @@
 class SoundManager;
 class DebugVisualsManager;
 class SaveGameManager;
+class SaveAbleSerializer;
 class JobScheduler;
 class ZoneManager;
 class TimeSourceManager;
@@ -140,6 +141,7 @@
     SoundManager* mSoundManager;
     DebugVisualsManager* mDebugVisualsManager;
     SaveGameManager* mSaveGameManager;
+	SaveAbleSerializer* mSaveAbleSerializer;
     JobScheduler* mJobScheduler;
 	ZoneManager* mZoneManager;
     TimeSourceManager* mTimeSourceManager;

Modified: rl/branches/persistence/core/include/SaveAbleCollection.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleCollection.h	2008-11-21 19:26:07 UTC (rev 4600)
+++ rl/branches/persistence/core/include/SaveAbleCollection.h	2008-11-23 18:09:31 UTC (rev 4601)
@@ -20,7 +20,7 @@
 namespace rl
 {
 
-	class SaveAbleCollection
+	class _RlCoreExport SaveAbleCollection
 	{
 	public:
 		SaveAbleCollection(const CeGuiString &id);

Modified: rl/branches/persistence/core/include/SaveAbleManager.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleManager.h	2008-11-21 19:26:07 UTC (rev 4600)
+++ rl/branches/persistence/core/include/SaveAbleManager.h	2008-11-23 18:09:31 UTC (rev 4601)
@@ -25,6 +25,8 @@
 {
 	class _RlCoreExport SaveAbleManager : public Ogre::Singleton<SaveAbleManager>
 	{
+	protected:
+		typedef std::map<CeGuiString, SaveAbleCollection*> SaveAbleCollectionMap;
 	public:
 		void saveState();
 		void addSaveAble(SaveAblePtr save);
@@ -34,10 +36,13 @@
 		void attachSaveAbleToCollection(const CeGuiString &saveAbleId, const CeGuiString &collectionId);
 		void deattachSaveAbleFromColltection(const CeGuiString &saveAbleId, const CeGuiString &collectionId);
 		void restoreState();
+		void restoreSaveAble(const CeGuiString &id);
+		SaveAbleCollectionMap getCollections();
 	protected:
-		std::map<int, PropertyRecordPtr> mSaveAbleStates;
-		std::map<int, SaveAblePtr> mSaveAbles;
-		std::map<Ogre::String,SaveAbleCollection*> mSaveAbleCollections;
+		std::map<CeGuiString, PropertyRecordPtr> mSaveAbleStates;
+		std::map<CeGuiString, SaveAblePtr> mSaveAbles;
+		
+		SaveAbleCollectionMap mSaveAbleCollections;
 	};
 }
 

Modified: rl/branches/persistence/core/include/SaveAbleSerializer.h
===================================================================
--- rl/branches/persistence/core/include/SaveAbleSerializer.h	2008-11-21 19:26:07 UTC (rev 4600)
+++ rl/branches/persistence/core/include/SaveAbleSerializer.h	2008-11-23 18:09:31 UTC (rev 4601)
@@ -27,15 +27,35 @@
 
 namespace rl
 {
-	class _RlCoreExport SaveAbleSerializer : public ScriptSerializer
+	class _RlCoreExport SaveAbleSerializer : public Ogre::Singleton<SaveAbleSerializer>, public ScriptSerializer
 	{
 	public:
-		void writeToSaveGameFile();
-		void readFromSaveGameFile();
+		SaveAbleSerializer();
+
+		typedef std::map<int, SaveGameFile*> SaveGameEntryMap;
+
+		SaveGameEntryMap listSaveGames();
+		SaveGameEntryMap listSaveGames(const CeGuiString &moduleId);
+
+		virtual const Ogre::StringVector&  getScriptPatterns(void) const;
+        virtual void parseScript(Ogre::DataStreamPtr &stream, const Ogre::String &groupName);
+        virtual Ogre::Real getLoadingOrder(void) const;
+
+		void createNewSaveGame();
+		void writeSaveGame(int fileId);
+		void readSaveGame(int fileId);
+
+		int getHighestSaveGameNumber();
 	protected:
-		std::map<CeGuiString, SaveGameFile*> mSaveGameFile;
+		void writeToSaveGameFile(SaveGameFile* file);
+		void readFromSaveGameFile(SaveGameFile* file);
+
+		SaveGameEntryMap mSaveGameFile;
 		SaveGameFileReader mReader;
 		SaveGameFileWriter mWriter;
+
+		Ogre::StringVector mScriptPatterns;
+		int mHighestSaveGameNumber;
 	};
 }
 

Modified: rl/branches/persistence/core/include/SaveGameFileWriter.h
===================================================================
--- rl/branches/persistence/core/include/SaveGameFileWriter.h	2008-11-21 19:26:07 UTC (rev 4600)
+++ rl/branches/persistence/core/include/SaveGameFileWriter.h	2008-11-23 18:09:31 UTC (rev 4601)
@@ -25,15 +25,16 @@
 
 namespace rl
 {
-    class SaveGameData;
-    typedef std::multimap<int,SaveGameData*> SaveGameDataOrderMap;
+    //class SaveGameData;
+    //typedef std::multimap<int,SaveGameData*> SaveGameDataOrderMap;
 
     class _RlCoreExport SaveGameFileWriter 
         : public XmlPropertyWriter
     {
     public:
-        void buildSaveGameFile(SaveGameFile *file, const SaveGameDataOrderMap &map);
-        void writeEachProperty(SaveGameData* data, const rl::PropertyMap &map);
+		void buildSaveGameFile(SaveGameFile* file);
+        //void buildSaveGameFile(SaveGameFile *file, const SaveGameDataOrderMap &map);
+        //void writeEachProperty(SaveGameData* data, const rl::PropertyMap &map);
     };
 }
 

Modified: rl/branches/persistence/core/src/CoreSubsystem.cpp
===================================================================
--- rl/branches/persistence/core/src/CoreSubsystem.cpp	2008-11-21 19:26:07 UTC (rev 4600)
+++ rl/branches/persistence/core/src/CoreSubsystem.cpp	2008-11-23 18:09:31 UTC (rev 4601)
@@ -36,6 +36,7 @@
 #include "PhysicsManager.h"
 #include "RubyInterpreter.h"
 #include "SaveGameManager.h"
+#include "SaveAbleSerializer.h"
 #include "ScriptWrapper.h"
 #include "SoundManager.h"
 #include "TimeSource.h"
@@ -100,6 +101,7 @@
         delete mRubyInterpreter;
         delete mTimeSourceManager;
         delete mSaveGameManager;
+		delete mSaveAbleSerializer;
         delete mGameLoop;
         //mXmlResourceManager->unloadAll();
         //delete mXmlResourceManager;
@@ -244,6 +246,9 @@
 
         mSaveGameManager = new SaveGameManager();
         LOG_MESSAGE(Logger::RULES, "SaveGameManager erzeugt");
+
+		mSaveAbleSerializer = new SaveAbleSerializer();
+        LOG_MESSAGE(Logger::RULES, "SaveAbleSerializer erzeugt");
 		
 		mTimeSourceManager = new TimeSourceManager();
         mTimeSourceManager->registerTimeSource(new RealTimeContinuous());

Modified: rl/branches/persistence/core/src/SaveAbleSerializer.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-11-21 19:26:07 UTC (rev 4600)
+++ rl/branches/persistence/core/src/SaveAbleSerializer.cpp	2008-11-23 18:09:31 UTC (rev 4601)
@@ -17,7 +17,64 @@
 #include "stdinc.h"
 
 #include "SaveAbleSerializer.h"
+#include "ConfigurationManager.h"
 
+template<> rl::SaveAbleSerializer* Ogre::Singleton<rl::SaveAbleSerializer>::ms_Singleton = 0;
+
+
+
 namespace rl
 {
-}
\ No newline at end of file
+	CeGuiString convertTimeToString(tm* time)
+    {
+        CeGuiString string = ((Ogre::String)(Ogre::StringConverter::toString(time->tm_mday) + "." 
+            + Ogre::StringConverter::toString(time->tm_mon) + "."
+            + Ogre::StringConverter::toString(time->tm_year + 1900) + " - " 
+            + Ogre::StringConverter::toString(time->tm_hour) + ":"
+            + Ogre::StringConverter::toString(time->tm_min) + ":" 
+            + Ogre::StringConverter::toString(time->tm_sec))).c_str();
+        return string;
+    }
+
+	SaveAbleSerializer::SaveAbleSerializer()
+	{
+		Ogre::ResourceGroupManager::getSingleton().createResourceGroup("SaveGameFiles");
+
+        mScriptPatterns.push_back("*.save");
+        Ogre::ResourceGroupManager::getSingleton()._registerScriptLoader(this);
+
+        Ogre::ResourceGroupManager::getSingleton().addResourceLocation(ConfigurationManager::getSingleton().getModulesRootDirectory() 
+            + "/saves", "WriteableFileSystem", "SaveGameFiles");
+        Ogre::ResourceGroupManager::getSingleton().initialiseResourceGroup("SaveGameFiles");
+	}
+
+	void SaveAbleSerializer::readFromSaveGameFile(rl::SaveGameFile *file)
+	{
+	}
+
+	void SaveAbleSerializer::writeToSaveGameFile(rl::SaveGameFile *file)
+	{
+		if(file)
+		{
+			mWriter.buildSaveGameFile(file);
+		}
+		else
+			LOG_ERROR("CORE", "Error: could not save game, ne file given!!");
+	}
+
+	void SaveAbleSerializer::parseScript(Ogre::DataStreamPtr &stream, const Ogre::String &groupName)
+	{
+	}
+
+	const Ogre::StringVector& SaveAbleSerializer::getScriptPatterns() const
+    {
+        return mScriptPatterns;
+    }
+
+    Ogre::Real SaveAbleSerializer::getLoadingOrder() const
+    {
+        return 2000.0f;
+    }
+
+
+}

Modified: rl/branches/persistence/core/src/SaveGameFileWriter.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveGameFileWriter.cpp	2008-11-21 19:26:07 UTC (rev 4600)
+++ rl/branches/persistence/core/src/SaveGameFileWriter.cpp	2008-11-23 18:09:31 UTC (rev 4601)
@@ -43,65 +43,75 @@
 
 namespace rl
 {
-    void SaveGameFileWriter::buildSaveGameFile(SaveGameFile *file, const SaveGameDataOrderMap &map)
-    {
-        //@toto: build
-        initializeXml();
 
-        XMLCh tempStr[100];
-        XMLString::transcode("LS", tempStr, 99);
-        mImplementation = DOMImplementationRegistry::getDOMImplementation(tempStr);
-        mWriter = static_cast<DOMImplementationLS*>(mImplementation)->createDOMWriter();
-        mTarget = file->getFormatTarget();
-        mDocument = static_cast<DOMImplementation*>(mImplementation)->createDocument(0, XMLString::transcode("SaveGameFile"), 0);
+	void SaveGameFileWriter::buildSaveGameFile(rl::SaveGameFile *file)
+	{
+		initializeXml();
 
-        if (mWriter->canSetFeature(XMLUni::fgDOMWRTDiscardDefaultContent, true))
-            mWriter->setFeature(XMLUni::fgDOMWRTDiscardDefaultContent, true);
 
-        if (mWriter->canSetFeature(XMLUni::fgDOMWRTFormatPrettyPrint, true))
-             mWriter->setFeature(XMLUni::fgDOMWRTFormatPrettyPrint, true);
 
-        mDocument->setNodeValue(XMLString::transcode("SaveGameFile")); //Set name of document root node
+		shutdownXml();
+	}
 
-        //Write SaveGameVersion
-        setAttributeValueAsString(mDocument->getDocumentElement(), "SaveGameFormatVersion", "0.5");
-        setAttributeValueAsInteger(mDocument->getDocumentElement(), "Engineversion", CoreSubsystem::getSingleton().getEngineBuildNumber());
+    //void SaveGameFileWriter::buildSaveGameFile(SaveGameFile *file, const SaveGameDataOrderMap &map)
+    //{
+    //    //@toto: build
+    //    initializeXml();
 
-        //Write modul of save game
-        DOMElement* header = appendChildElement(mDocument, mDocument->getDocumentElement(), "header");
-        
-        PropertyRecordPtr headerSet = file->getAllProperties();
-        for (PropertyRecord::PropertyRecordMap::const_iterator it_header = headerSet->begin(); it_header != headerSet->end(); it_header++)
-        {
-            this->processProperty(header, PropertyEntry(it_header->first.c_str(), it_header->second));
-        }
+    //    XMLCh tempStr[100];
+    //    XMLString::transcode("LS", tempStr, 99);
+    //    mImplementation = DOMImplementationRegistry::getDOMImplementation(tempStr);
+    //    mWriter = static_cast<DOMImplementationLS*>(mImplementation)->createDOMWriter();
+    //    mTarget = file->getFormatTarget();
+    //    mDocument = static_cast<DOMImplementation*>(mImplementation)->createDocument(0, XMLString::transcode("SaveGameFile"), 0);
 
-        ////Write globals
-        //DOMElement* globals = appendChildElement(mDocument, mDocument->getDocumentElement(), "globals");
-        //DOMElement* gameTime = appendChildElement(mDocument, globals, "gametime");
-        //TimeSource* gameTimeSource = TimeSourceManager::getSingleton().getTimeSource(TimeSource::GAMETIME);
-        //setAttributeValueAsInteger(gameTime, "milliseconds", gameTimeSource->getClock());
+    //    if (mWriter->canSetFeature(XMLUni::fgDOMWRTDiscardDefaultContent, true))
+    //        mWriter->setFeature(XMLUni::fgDOMWRTDiscardDefaultContent, true);
 
-        for(SaveGameDataOrderMap::const_iterator data_iter = map.begin(); data_iter != map.end(); data_iter++)
-        {
-            data_iter->second->writeData(this);
-        }
+    //    if (mWriter->canSetFeature(XMLUni::fgDOMWRTFormatPrettyPrint, true))
+    //         mWriter->setFeature(XMLUni::fgDOMWRTFormatPrettyPrint, true);
 
-        mWriter->writeNode(mTarget, *mDocument);
+    //    mDocument->setNodeValue(XMLString::transcode("SaveGameFile")); //Set name of document root node
 
+    //    //Write SaveGameVersion
+    //    setAttributeValueAsString(mDocument->getDocumentElement(), "SaveGameFormatVersion", "0.5");
+    //    setAttributeValueAsInteger(mDocument->getDocumentElement(), "Engineversion", CoreSubsystem::getSingleton().getEngineBuildNumber());
 
-        mWriter->release();
+    //    //Write modul of save game
+    //    DOMElement* header = appendChildElement(mDocument, mDocument->getDocumentElement(), "header");
+    //    
+    //    PropertyRecordPtr headerSet = file->getAllProperties();
+    //    for (PropertyRecord::PropertyRecordMap::const_iterator it_header = headerSet->begin(); it_header != headerSet->end(); it_header++)
+    //    {
+    //        this->processProperty(header, PropertyEntry(it_header->first.c_str(), it_header->second));
+    //    }
 
-        delete mDocument;
-        delete mTarget;
+    //    ////Write globals
+    //    //DOMElement* globals = appendChildElement(mDocument, mDocument->getDocumentElement(), "globals");
+    //    //DOMElement* gameTime = appendChildElement(mDocument, globals, "gametime");
+    //    //TimeSource* gameTimeSource = TimeSourceManager::getSingleton().getTimeSource(TimeSource::GAMETIME);
+    //    //setAttributeValueAsInteger(gameTime, "milliseconds", gameTimeSource->getClock());
 
-        shutdownXml();
-    }
+    //    for(SaveGameDataOrderMap::const_iterator data_iter = map.begin(); data_iter != map.end(); data_iter++)
+    //    {
+    //        data_iter->second->writeData(this);
+    //    }
 
-    void SaveGameFileWriter::writeEachProperty(SaveGameData* data, const rl::PropertyMap &map)
-    {
-        DOMElement* saveElem = appendChildElement(getDocument(), getDocument()->getDocumentElement(), data->getXmlNodeIdentifier().c_str());
+    //    mWriter->writeNode(mTarget, *mDocument);
 
-        XmlPropertyWriter::writeEachPropertyToElem(saveElem, map);
-    }
+
+    //    mWriter->release();
+
+    //    delete mDocument;
+    //    delete mTarget;
+
+    //    shutdownXml();
+    //}
+
+    //void SaveGameFileWriter::writeEachProperty(SaveGameData* data, const rl::PropertyMap &map)
+    //{
+    //    DOMElement* saveElem = appendChildElement(getDocument(), getDocument()->getDocumentElement(), data->getXmlNodeIdentifier().c_str());
+
+    //    XmlPropertyWriter::writeEachPropertyToElem(saveElem, map);
+    //}
 }

Modified: rl/branches/persistence/core/src/SaveGameManager.cpp
===================================================================
--- rl/branches/persistence/core/src/SaveGameManager.cpp	2008-11-21 19:26:07 UTC (rev 4600)
+++ rl/branches/persistence/core/src/SaveGameManager.cpp	2008-11-23 18:09:31 UTC (rev 4601)
@@ -119,7 +119,7 @@
         mSaveGames[file->getId()] = file;
 
         SaveGameFileWriter writer;
-        writer.buildSaveGameFile(file, mSaveGameDataOrderMap);
+        //writer.buildSaveGameFile(file, mSaveGameDataOrderMap);
 
         //freeSaveGameMap();
 

Modified: rl/branches/persistence/rules/src/Makefile.am
===================================================================
--- rl/branches/persistence/rules/src/Makefile.am	2008-11-21 19:26:07 UTC (rev 4600)
+++ rl/branches/persistence/rules/src/Makefile.am	2008-11-23 18:09:31 UTC (rev 4601)
@@ -29,6 +29,7 @@
 	GameTimeSource.cpp \
 	GlobalProperties.cpp \
 	GoToJob.cpp \
+	FetchItemJob.cpp \
 	Item.cpp \
 	Inventory.cpp \
 	JournalEntry.cpp \

Modified: rl/branches/persistence/script/include/Scene.h
===================================================================
--- rl/branches/persistence/script/include/Scene.h	2008-11-21 19:26:07 UTC (rev 4600)
+++ rl/branches/persistence/script/include/Scene.h	2008-11-23 18:09:31 UTC (rev 4601)
@@ -26,7 +26,7 @@
 
 namespace rl {
 
-    class Scene : public PropertyHolder, public SaveAbleCollection
+    class _RlScriptExport Scene : public PropertyHolder, public SaveAbleCollection
     {
     public:
         static const Ogre::String PROPERTY_GAMEOBJECTS;
@@ -42,6 +42,10 @@
         virtual void setProperty(const CeGuiString& key, const Property& value);
         virtual PropertyKeys getAllPropertyKeys() const;
 
+		virtual void attachSaveAble(SaveAblePtr saveAble);
+		virtual void deattachSaveAble(SaveAblePtr saveAble);
+		virtual void deattachSaveAble(const CeGuiString &id);
+		virtual void deattachAllSaveAbles();
     private:
         CeGuiString mName;
         std::vector<Ogre::String> mMaps;

Modified: rl/branches/persistence/script/src/Scene.cpp
===================================================================
--- rl/branches/persistence/script/src/Scene.cpp	2008-11-21 19:26:07 UTC (rev 4600)
+++ rl/branches/persistence/script/src/Scene.cpp	2008-11-23 18:09:31 UTC (rev 4601)
@@ -30,7 +30,7 @@
 const Ogre::String Scene::PROPERTY_GAMEOBJECTS = "gameobjects";
 
 Scene::Scene(const CeGuiString& name)
-: mName(name)
+: mName(name), SaveAbleCollection(name)
 {
 }
 
@@ -125,4 +125,20 @@
     return keys;
 }
 
+void Scene::attachSaveAble(SaveAblePtr saveAble)
+{
+}
+
+void Scene::deattachSaveAble(SaveAblePtr saveAble)
+{
+}
+
+void Scene::deattachSaveAble(const CeGuiString &id)
+{
+}
+
+void Scene::deattachAllSaveAbles()
+{
+}
+
 }
\ No newline at end of file

Modified: rl/branches/persistence/ui/RlUI2005.vcproj
===================================================================
--- rl/branches/persistence/ui/RlUI2005.vcproj	2008-11-21 19:26:07 UTC (rev 4600)
+++ rl/branches/persistence/ui/RlUI2005.vcproj	2008-11-23 18:09:31 UTC (rev 4601)
@@ -46,7 +46,7 @@
 			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				AdditionalOptions="-Zm130"
+				AdditionalOptions="-Zm140"
 				Optimization="0"
 				AdditionalIncludeDirectories=".\include;..\common\include;..\ai\include;..\core\include;..\rules\include;..\..\dependencies\ogrenew\OgreMain\include;&quot;..\..\dependencies\ruby\lib\ruby\1.8\i386-mswin32&quot;;..\..\dependencies\cegui_mk2\include;..\..\dependencies\boost\include;..\..\dependencies\xerces\include;..\..\dependencies\fmod\api\inc;..\..\dependencies\OgreNewt\include\OgreNewt;..\..\dependencies\NewtonSDK\sdk\;..\..\dependencies\ogrenew\Samples\Common\CEGUIRenderer\include;..\..\dependencies\ogrenew\Dependencies\include;..\..\dependencies\ois\includes"
 				PreprocessorDefinitions="WITH_FMOD3;_WINDOWS,_DEBUG,WIN32,RLUI_EXPORTS;_CRT_SECURE_NO_DEPRECATE;RL_USE_PCH"



From blakharaz at mail.berlios.de  Mon Nov 24 22:59:38 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 24 Nov 2008 22:59:38 +0100
Subject: [Dsa-hl-svn] r4602 - rl/trunk/engine/core/src
Message-ID: <200811242159.mAOLxcQA007146@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-24 22:59:37 +0100 (Mon, 24 Nov 2008)
New Revision: 4602

Modified:
   rl/trunk/engine/core/src/JobScheduler.cpp
Log:


Modified: rl/trunk/engine/core/src/JobScheduler.cpp
===================================================================
--- rl/trunk/engine/core/src/JobScheduler.cpp	2008-11-23 18:09:31 UTC (rev 4601)
+++ rl/trunk/engine/core/src/JobScheduler.cpp	2008-11-24 21:59:37 UTC (rev 4602)
@@ -1,323 +1,350 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "JobScheduler.h"
-#include "Job.h"
-#include "JobListener.h"
-#include "GameLoop.h"
-#include "TimeSource.h"
-#include "SaveGameManager.h"
-
-using namespace Ogre;
-
-template<> rl::JobScheduler* Singleton<rl::JobScheduler>::ms_Singleton = 0;
-
-namespace rl
-{
-    JobScheduler::JobScheduler()
-        : GameTask(true),
-        mJobQueue(), 
-        mAddedJobs(),
-        mTokenThreshold(JP_NORMAL), 
-        mTicketCounter(0)
-    {
-        SaveGameManager::getSingleton().registerSaveGameData(this);
-    }
-
-    JobScheduler::~JobScheduler()
-    {
-    }
-
-    unsigned long JobScheduler::addJob(AbstractJob* job, JobPriority priority, Real delay, Real maxRuntime,
-        JobListener* listener)
-    {
-        unsigned long ticket = ++mTicketCounter;
-        TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(
-            job->getTimeSource());
-        unsigned long clock = ts->getClock();
-        unsigned long start = clock + delay*1000;
-        unsigned long end = maxRuntime >= Math::POS_INFINITY ?
-            0xffffffff : static_cast<unsigned long>(start + maxRuntime*1000);
-        JobEntry entry = {job, listener, ticket, priority, priority, start, end, start, job->getTimeSource(), false, false};
-        mAddedJobs.push_back(entry);
-        return ticket;
-    }
-
-    void JobScheduler::run(Ogre::Real time)
-    {
-        ///@todo use different buckets for jobs not yet started, instead of
-        ///      iterating over those each time.
-
-        ///@todo dynamically determine token threshold. Maybe make it work load depending.
-
-
-        // Queue for finished jobs
-        JobQueue notDone;
-
-        for (JobQueue::iterator it = mJobQueue.begin(), end = mJobQueue.end(); it != end; ++it)
-        {
-            JobEntry entry = *it;
-
-            TimeSource::TimeSourceType tst = entry.job->getTimeSource();
-            TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(tst);
-            Time clock = ts->getClock();
-            if (tst != entry.timeSourceLastCall) // time source has changed, e.g. in a job queue
-            {
-                entry.timeLastCall = clock;
-                entry.timeSourceLastCall = tst;
-            }
-
-            if (entry.markedToRemove)
-            {
-                // Notify listener, the job was removed
-                if (entry.listener != NULL)
-                {
-                    entry.listener->jobRemoved(entry.ticket);
-                }
-
-                if (entry.job->destroyWhenDone() )
-                {
-                    delete entry.job;
-                }
-            }
-            else if (entry.start <= clock && clock < entry.end)
-            {
-                // Is the token threshold reached?
-                if (entry.tokens >= mTokenThreshold)
-                {
-                    // Yes, pay run fee and execute.
-                    entry.tokens = 0;
-                    bool runAgain = !entry.job->execute(clock - entry.timeLastCall);
-
-                    if (!entry.called)
-                    {
-                        // Notify listener, the job started for the first time
-                        if (entry.listener != NULL)
-                        {
-                            entry.listener->jobStarted(entry.ticket);
-                        }
-                        entry.called = true;
-                    }
-
-                    if (runAgain)
-                    {
-                        // Job is not done, reset token count and requeue.
-                        entry.tokens = entry.priority;
-                        entry.timeLastCall = clock;
-                        notDone.push_back(entry);
-                    }
-                    else
-                    {
-                        // Notify listener, the job finished regularly.
-                        if (entry.listener != NULL)
-                        {
-                            entry.listener->jobFinished(entry.ticket);
-                        }
-
-                        // If we are supposed to delete the Job, do so now.
-                        if (entry.job->destroyWhenDone())
-                        {
-                            delete entry.job;
-                        }
-                    }
-                }
-                else
-                {
-                    // No, increase token count
-                    entry.tokens += entry.priority;
-                    notDone.push_back(entry);
-                }
-            }
-            else if (clock < entry.end)
-            {
-                // Start time not yet reached. Queue again.
-                notDone.push_back(entry);
-            }
-            else
-            {
-                // Job reached its end time and didn't want to finish itself, so we do it.
-                if (entry.job->isDiscardable())
-                {
-                    entry.job->discard();
-                    if (entry.listener != NULL)
-                    {
-                        entry.listener->jobDiscarded(entry.ticket);
-                    }
-                }
-                if (entry.job->destroyWhenDone() )
-                {
-                    delete entry.job;
-                }
-            }
-        }
-
-        // Copy requeued jobs for next run.
-        mJobQueue = notDone;
-		mJobQueue.insert(mJobQueue.end(), mAddedJobs.begin(), mAddedJobs.end());
-		mAddedJobs.clear();
-    }
-
-    void JobScheduler::removeJob(unsigned long ticket)
-    {
-        JobQueue::iterator it = std::find_if(mJobQueue.begin(), mJobQueue.end(),
-            std::bind2nd(FindJobEntryByTicket(), ticket));
-        if (it != mJobQueue.end())
-        {
-            //mRemovedJobs.push_back(*it);
-            (*it).markedToRemove = true;
-        }
-        else
-        {
-			it = std::find_if(mAddedJobs.begin(), mAddedJobs.end(),
-				std::bind2nd(FindJobEntryByTicket(), ticket));
-			if (it != mAddedJobs.end())
-			{
-				mAddedJobs.erase(it);
-			}
-			else
-			{
-				///@todo Log missing job for the ticket.
-			}
-        }
-    }
-
-    const Ogre::String& JobScheduler::getName() const
-    {
-        static Ogre::String NAME = "JobScheduler";
-
-        return NAME;
-    }
-
-    using namespace XERCES_CPP_NAMESPACE;
-
-    void JobScheduler::writeData(SaveGameFileWriter* writer)
-    {
-        DOMElement* jobSchedulerParentNode = writer->appendChildElement(writer->getDocument(), writer->getDocument()->getDocumentElement(), getXmlNodeIdentifier().c_str());
-
-        for(JobQueue::const_iterator iter = mJobQueue.begin(); iter != mJobQueue.end(); iter++)
-        {
-            if( iter->job->getPersistenceType() == Job::PERSISTENT && !(iter->markedToRemove) )
-            {
-                DOMElement* jobNode = writer->appendChildElement(writer->getDocument(), jobSchedulerParentNode, "job");
-                writer->setAttributeValueAsInteger(jobNode, "priority", iter->priority);
-                writer->setAttributeValueAsInteger(jobNode, "tokens", iter->tokens);
-                writer->setAttributeValueAsInteger(jobNode, "start", iter->start);
-                writer->setAttributeValueAsInteger(jobNode, "end", iter->end);
-                writer->setAttributeValueAsInt64(jobNode, "timeLastCall", iter->timeLastCall);
-                writer->setAttributeValueAsBool(jobNode, "called", iter->called);
-                writer->setAttributeValueAsString(jobNode, "classname", iter->job->getClassName());
-
-                PropertyMap map = iter->job->getAllProperties()->toPropertyMap();
-                writer->writeEachPropertyToElem(jobNode, map);
-            }
-        }
-    }
-
-    void JobScheduler::readData(SaveGameFileReader* reader)
-    {
-        // delete and discard old jobs
-        for( JobQueue::iterator iter = mJobQueue.begin(); iter != mJobQueue.end(); iter++ )
-        {
-            if( iter->job->getPersistenceType() == Job::PERSISTENT )
-            {
-                // delete the job, but do not discard it!
-                iter->markedToRemove = true;
-            }
-            else if( iter->job->getPersistenceType() == Job::FINISH_WHEN_GAME_LOADED )
-            {
-                // discard the job, then delete it
-                if( iter->job->isDiscardable() )
-                    iter->job->discard();
-                iter->markedToRemove = true;
-            }
-        }
-
-        
-        // load jobs from savegamefile
-
-        reader->initializeXml();
-
-
-        DOMNodeList* rootNodeList = reader->getDocument()->getDocumentElement()->getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
-        
-        if(rootNodeList->getLength())
-        {
-            DOMNodeList* xmlJobs = static_cast<DOMElement*>(rootNodeList->item(0))->getElementsByTagName(AutoXMLCh("job").data());
-            if (xmlJobs->getLength())
-            {
-                for (XMLSize_t childIdx1 = 0; childIdx1 < xmlJobs->getLength(); childIdx1++)
-                {
-                    DOMNode* xmlJob_ = xmlJobs->item(childIdx1);
-                    if (xmlJob_->getNodeType() == DOMNode::ELEMENT_NODE)
-                    {
-                        DOMElement* xmlJob = static_cast<DOMElement*>(xmlJob_);
-                        JobPriority priority;
-                        unsigned short tokens;
-                        int start, end;
-                        Time timeLastCall;
-                        bool called;
-                        priority = JobPriority(reader->getAttributeValueAsInteger(xmlJob, "priority"));
-                        tokens = reader->getAttributeValueAsInteger(xmlJob, "tokens");
-                        start = reader->getAttributeValueAsInteger(xmlJob, "start");
-                        end = reader->getAttributeValueAsInteger(xmlJob, "end");
-                        timeLastCall = reader->getAttributeValueAsInt64(xmlJob, "timeLastCall");
-                        called = reader->getAttributeValueAsBool(xmlJob, "called");
-
-                        Ogre::String className = reader->getAttributeValueAsStdString(xmlJob, "classname");
-
-                        JobCreationMap::iterator it = mJobCreationMap.find(className);
-                        if (it == mJobCreationMap.end())
-                        {
-                            LOG_ERROR(Logger::CORE, "Die Job-Klasse '" + className + "' ist nicht beim JobScheduler registriert!");
-                            continue;
-                        }
-
-                        AbstractJob* job = it->second();
-                        if (job == NULL)
-                        {
-                            LOG_ERROR(Logger::CORE, "Fehler beim Erstellen eines Objekts der Job-Klasse '" + className + "'!");
-                            continue;
-                        }
-                        PropertyRecordPtr properties = reader->getPropertiesAsRecord(xmlJob);
-                        job->setProperties(properties);
-                        
-                        
-                        unsigned long ticket = ++mTicketCounter;
-                        TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(job->getTimeSource());
-                        JobEntry entry = {job, NULL, ticket, priority, tokens, start, end, timeLastCall, TimeSource::UNKNOWN, called, false};
-                        mJobQueue.push_back(entry);
-                    }
-                }
-            }
-        }
-
-        reader->shutdownXml();
-    }
-
-    int JobScheduler::getPriority() const
-    {
-        return 0; // must be loaded before triggers!
-    }
-
-    CeGuiString JobScheduler::getXmlNodeIdentifier() const
-    {
-        static const CeGuiString name = "jobscheduler";
-        return name;
-    }
-
-    JobScheduler::JobCreationMap JobScheduler::mJobCreationMap;
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "JobScheduler.h"
+#include "Job.h"
+#include "JobListener.h"
+#include "GameLoop.h"
+#include "TimeSource.h"
+#include "SaveGameManager.h"
+
+using namespace Ogre;
+
+template<> rl::JobScheduler* Singleton<rl::JobScheduler>::ms_Singleton = 0;
+
+namespace rl
+{
+    JobScheduler::JobScheduler()
+        : GameTask(true),
+        mJobQueue(), 
+        mAddedJobs(),
+        mTokenThreshold(JP_NORMAL), 
+        mTicketCounter(0)
+    {
+        SaveGameManager::getSingleton().registerSaveGameData(this);
+    }
+
+    JobScheduler::~JobScheduler()
+    {
+    }
+
+    unsigned long JobScheduler::addJob(AbstractJob* job, JobPriority priority, Real delay, Real maxRuntime,
+        JobListener* listener)
+    {
+        unsigned long ticket = ++mTicketCounter;
+        TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(
+            job->getTimeSource());
+        unsigned long clock = ts->getClock();
+        unsigned long start = clock + delay*1000;
+        unsigned long end = maxRuntime >= Math::POS_INFINITY ?
+            0xffffffff : static_cast<unsigned long>(start + maxRuntime*1000);
+        JobEntry entry = {job, listener, ticket, priority, priority, start, end, start, job->getTimeSource(), false, false};
+        mAddedJobs.push_back(entry);
+        return ticket;
+    }
+
+    void JobScheduler::run(Ogre::Real time)
+    {
+        ///@todo use different buckets for jobs not yet started, instead of
+        ///      iterating over those each time.
+
+        ///@todo dynamically determine token threshold. Maybe make it work load depending.
+
+
+        // Queue for finished jobs
+        JobQueue notDone;
+
+        for (JobQueue::iterator it = mJobQueue.begin(), end = mJobQueue.end(); it != end; ++it)
+        {
+            JobEntry entry = *it;
+
+            TimeSource::TimeSourceType tst = entry.job->getTimeSource();
+            TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(tst);
+            Time clock = ts->getClock();
+            if (tst != entry.timeSourceLastCall) // time source has changed, e.g. in a job queue
+            {
+                entry.timeLastCall = clock;
+                entry.timeSourceLastCall = tst;
+            }
+
+            if (entry.markedToRemove)
+            {
+                // Notify listener, the job was removed
+                if (entry.listener != NULL)
+                {
+                    entry.listener->jobRemoved(entry.ticket);
+                }
+
+                if (entry.job->destroyWhenDone() )
+                {
+                    delete entry.job;
+                }
+            }
+            else if (entry.start <= clock && clock < entry.end)
+            {
+                // Is the token threshold reached?
+                if (entry.tokens >= mTokenThreshold)
+                {
+                    // Yes, pay run fee and execute.
+                    entry.tokens = 0;
+                    bool runAgain = !entry.job->execute(clock - entry.timeLastCall);
+
+                    if (!entry.called)
+                    {
+                        // Notify listener, the job started for the first time
+                        if (entry.listener != NULL)
+                        {
+                            entry.listener->jobStarted(entry.ticket);
+                        }
+                        entry.called = true;
+                    }
+
+                    if (runAgain)
+                    {
+                        // Job is not done, reset token count and requeue.
+                        entry.tokens = entry.priority;
+                        entry.timeLastCall = clock;
+                        notDone.push_back(entry);
+                    }
+                    else
+                    {
+                        // Notify listener, the job finished regularly.
+                        if (entry.listener != NULL)
+                        {
+                            entry.listener->jobFinished(entry.ticket);
+                        }
+
+                        // If we are supposed to delete the Job, do so now.
+                        if (entry.job->destroyWhenDone())
+                        {
+                            delete entry.job;
+                        }
+                    }
+                }
+                else
+                {
+                    // No, increase token count
+                    entry.tokens += entry.priority;
+                    notDone.push_back(entry);
+                }
+            }
+            else if (clock < entry.end)
+            {
+                // Start time not yet reached. Queue again.
+                notDone.push_back(entry);
+            }
+            else
+            {
+                // Job reached its end time and didn't want to finish itself, so we do it.
+                if (entry.job->isDiscardable())
+                {
+                    entry.job->discard();
+                    if (entry.listener != NULL)
+                    {
+                        entry.listener->jobDiscarded(entry.ticket);
+                    }
+                }
+                if (entry.job->destroyWhenDone() )
+                {
+                    delete entry.job;
+                }
+            }
+        }
+
+        // Copy requeued jobs for next run.
+        mJobQueue = notDone;
+		mJobQueue.insert(mJobQueue.end(), mAddedJobs.begin(), mAddedJobs.end());
+		mAddedJobs.clear();
+    }
+
+    void JobScheduler::removeJob(unsigned long ticket)
+    {
+        JobQueue::iterator it = std::find_if(mJobQueue.begin(), mJobQueue.end(),
+            std::bind2nd(FindJobEntryByTicket(), ticket));
+        if (it != mJobQueue.end())
+        {
+            //mRemovedJobs.push_back(*it);
+            (*it).markedToRemove = true;
+        }
+        else
+        {
+			it = std::find_if(mAddedJobs.begin(), mAddedJobs.end(),
+				std::bind2nd(FindJobEntryByTicket(), ticket));
+			if (it != mAddedJobs.end())
+			{
+				mAddedJobs.erase(it);
+			}
+			else
+			{
+				///@todo Log missing job for the ticket.
+			}
+        }
+    }
+
+    const Ogre::String& JobScheduler::getName() const
+    {
+        static Ogre::String NAME = "JobScheduler";
+
+        return NAME;
+    }
+
+    using namespace XERCES_CPP_NAMESPACE;
+
+    void JobScheduler::writeData(SaveGameFileWriter* writer)
+    {
+        DOMElement* jobSchedulerParentNode = writer->appendChildElement(writer->getDocument(), writer->getDocument()->getDocumentElement(), getXmlNodeIdentifier().c_str());
+
+        for(JobQueue::const_iterator iter = mJobQueue.begin(); iter != mJobQueue.end(); iter++)
+        {
+            if( iter->job->getPersistenceType() == Job::PERSISTENT && !(iter->markedToRemove) )
+            {
+                DOMElement* jobNode = writer->appendChildElement(writer->getDocument(), jobSchedulerParentNode, "job");
+                writer->setAttributeValueAsInteger(jobNode, "priority", iter->priority);
+                writer->setAttributeValueAsInteger(jobNode, "tokens", iter->tokens);
+                writer->setAttributeValueAsInteger(jobNode, "start", iter->start);
+                writer->setAttributeValueAsInteger(jobNode, "end", iter->end);
+                writer->setAttributeValueAsInt64(jobNode, "timeLastCall", iter->timeLastCall);
+                writer->setAttributeValueAsBool(jobNode, "called", iter->called);
+                writer->setAttributeValueAsString(jobNode, "classname", iter->job->getClassName());
+                CeGuiString timeSource = "unknown";
+                switch (iter->job->getTimeSource())
+                {
+                    case TimeSource::GAMETIME:
+                        timeSource = "gametime";
+                        break;
+                    case TimeSource::REALTIME_CONTINUOUS:
+                        timeSource = "realtime_continuous";
+                        break;
+                    case TimeSource::REALTIME_INTERRUPTABLE:
+                        timeSource = "realtime_interruptable";
+                        break;
+                }
+                writer->setAttributeValueAsString(jobNode, "time", timeSource);
+
+                PropertyMap map = iter->job->getAllProperties()->toPropertyMap();
+                writer->writeEachPropertyToElem(jobNode, map);
+            }
+        }
+    }
+
+    void JobScheduler::readData(SaveGameFileReader* reader)
+    {
+        // delete and discard old jobs
+        for( JobQueue::iterator iter = mJobQueue.begin(); iter != mJobQueue.end(); iter++ )
+        {
+            if( iter->job->getPersistenceType() == Job::PERSISTENT )
+            {
+                // delete the job, but do not discard it!
+                iter->markedToRemove = true;
+            }
+            else if( iter->job->getPersistenceType() == Job::FINISH_WHEN_GAME_LOADED )
+            {
+                // discard the job, then delete it
+                if( iter->job->isDiscardable() )
+                    iter->job->discard();
+                iter->markedToRemove = true;
+            }
+        }
+
+        
+        // load jobs from savegamefile
+
+        reader->initializeXml();
+
+
+        DOMNodeList* rootNodeList = reader->getDocument()->getDocumentElement()->getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
+        
+        if(rootNodeList->getLength())
+        {
+            DOMNodeList* xmlJobs = static_cast<DOMElement*>(rootNodeList->item(0))->getElementsByTagName(AutoXMLCh("job").data());
+            if (xmlJobs->getLength())
+            {
+                for (XMLSize_t childIdx1 = 0; childIdx1 < xmlJobs->getLength(); childIdx1++)
+                {
+                    DOMNode* xmlJob_ = xmlJobs->item(childIdx1);
+                    if (xmlJob_->getNodeType() == DOMNode::ELEMENT_NODE)
+                    {
+                        DOMElement* xmlJob = static_cast<DOMElement*>(xmlJob_);
+                        JobPriority priority;
+                        unsigned short tokens;
+                        int start, end;
+                        Time timeLastCall;
+                        bool called;
+                        priority = JobPriority(reader->getAttributeValueAsInteger(xmlJob, "priority"));
+                        tokens = reader->getAttributeValueAsInteger(xmlJob, "tokens");
+                        start = reader->getAttributeValueAsInteger(xmlJob, "start");
+                        end = reader->getAttributeValueAsInteger(xmlJob, "end");
+                        timeLastCall = reader->getAttributeValueAsInt64(xmlJob, "timeLastCall");
+                        called = reader->getAttributeValueAsBool(xmlJob, "called");
+
+                        Ogre::String className = reader->getAttributeValueAsStdString(xmlJob, "classname");
+
+                        JobCreationMap::iterator it = mJobCreationMap.find(className);
+                        if (it == mJobCreationMap.end())
+                        {
+                            LOG_ERROR(Logger::CORE, "Die Job-Klasse '" + className + "' ist nicht beim JobScheduler registriert!");
+                            continue;
+                        }
+
+                        AbstractJob* job = it->second();
+                        if (job == NULL)
+                        {
+                            LOG_ERROR(Logger::CORE, "Fehler beim Erstellen eines Objekts der Job-Klasse '" + className + "'!");
+                            continue;
+                        }
+                        PropertyRecordPtr properties = reader->getPropertiesAsRecord(xmlJob);
+                        job->setProperties(properties);
+                        
+                        CeGuiString timeSourceStr = reader->getAttributeValueAsString(xmlJob, "time");
+                        TimeSource::TimeSourceType ts = TimeSource::UNKNOWN;
+                        if (timeSourceStr == "gametime") 
+                        {
+                            ts = TimeSource::GAMETIME;
+                        }
+                        else if (timeSourceStr == "realtime_continuous") 
+                        {
+                            ts = TimeSource::REALTIME_CONTINUOUS;
+                        }
+                        else if (timeSourceStr == "realtime_interruptable") 
+                        {
+                            ts = TimeSource::REALTIME_INTERRUPTABLE;
+                        }
+                        
+                        unsigned long ticket = ++mTicketCounter;
+                        JobEntry entry = {job, NULL, ticket, priority, tokens, start, end, timeLastCall, ts, called, false};
+                        mJobQueue.push_back(entry);
+                    }
+                }
+            }
+        }
+
+        reader->shutdownXml();
+    }
+
+    int JobScheduler::getPriority() const
+    {
+        return 0; // must be loaded before triggers!
+    }
+
+    CeGuiString JobScheduler::getXmlNodeIdentifier() const
+    {
+        static const CeGuiString name = "jobscheduler";
+        return name;
+    }
+
+    JobScheduler::JobCreationMap JobScheduler::mJobCreationMap;
+}



From blakharaz at mail.berlios.de  Mon Nov 24 23:01:48 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 24 Nov 2008 23:01:48 +0100
Subject: [Dsa-hl-svn] r4603 - in rl/trunk/engine/rules: include src
Message-ID: <200811242201.mAOM1moO007364@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-24 23:01:45 +0100 (Mon, 24 Nov 2008)
New Revision: 4603

Modified:
   rl/trunk/engine/rules/include/GameObject.h
   rl/trunk/engine/rules/include/Item.h
   rl/trunk/engine/rules/src/GameObject.cpp
   rl/trunk/engine/rules/src/Item.cpp
Log:
moved getMeshfile to GameObject

Modified: rl/trunk/engine/rules/include/GameObject.h
===================================================================
--- rl/trunk/engine/rules/include/GameObject.h	2008-11-24 21:59:37 UTC (rev 4602)
+++ rl/trunk/engine/rules/include/GameObject.h	2008-11-24 22:01:45 UTC (rev 4603)
@@ -64,6 +64,7 @@
         static const Ogre::String PROPERTY_MASS; 
         static const Ogre::String PROPERTY_ACTIONS; 
         static const Ogre::String PROPERTY_DEFAULT_ACTION;
+        static const Ogre::String PROPERTY_IMAGENAME;
 
         static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
         static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
@@ -82,6 +83,9 @@
         const CeGuiString& getDescription() const;
         void setDescription(const CeGuiString& description);
 
+		const CeGuiString& getImageName() const;
+		void setImageName(const CeGuiString& name);
+        
         const CeGuiString& getMeshfile() const;
         void setMeshfile(const CeGuiString& meshfile);
 
@@ -204,6 +208,7 @@
         
         CeGuiString mName;
         CeGuiString mDescription;
+        CeGuiString mImageName;
         CeGuiString mMeshfile;
 		MeshPartMap mMeshParts;
         CeGuiString mSubmeshPreName;

Modified: rl/trunk/engine/rules/include/Item.h
===================================================================
--- rl/trunk/engine/rules/include/Item.h	2008-11-24 21:59:37 UTC (rev 4602)
+++ rl/trunk/engine/rules/include/Item.h	2008-11-24 22:01:45 UTC (rev 4603)
@@ -1,124 +1,119 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __ITEM_H__
-#define __ITEM_H__
-
-#include "GameObject.h"
-
-namespace rl
-{
-	class _RlRulesExport Item;
-    class Slot;
-    class Container;
-
-	typedef std::vector<Item*> ContainerColumn;
-	typedef std::vector<ContainerColumn> ContainerLayout;
-
-
-    /// Aufnehmbare Objekte in der Spielwelt.
-    class _RlRulesExport Item : public GameObject
-    {
-    public:
-		enum ItemType{
-			ITEMTYPE_WEAPON     = 1 << 0,
-			ITEMTYPE_SHIELD     = 1 << 1,
-			ITEMTYPE_RING       = 1 << 2,
-			ITEMTYPE_GLOVES     = 1 << 3,
-			ITEMTYPE_BRACELET   = 1 << 4,
-			ITEMTYPE_ARMOR      = 1 << 5,
-			ITEMTYPE_CAPE       = 1 << 6,
-			ITEMTYPE_BRACERS    = 1 << 7,
-			ITEMTYPE_BACKPACK   = 1 << 8,
-			ITEMTYPE_BELT       = 1 << 9,
-			ITEMTYPE_NECKLACE   = 1 << 10,
-			ITEMTYPE_HELMET     = 1 << 11,
-			ITEMTYPE_TROUSERS   = 1 << 12,
-			ITEMTYPE_SHINBONE   = 1 << 13,
-			ITEMTYPE_BOOTS      = 1 << 14,
-            ITEMTYPE_CLOTHES    = 1 << 15,
-			ITEMTYPE_OTHER      = 1 << 16,
-            ITEMTYPE_ALL_ITEMS  = ~(0)
-		};
-
-
-        static const Ogre::String CLASS_NAME;
-
-        static const Ogre::String PROPERTY_ITEMTYPE;
-        static const Ogre::String PROPERTY_IMAGENAME;
-        static const Ogre::String PROPERTY_SIZE;
-        static const Ogre::String PROPERTY_SUBMESHNAME;
-
-		Item(unsigned int id);
-        virtual ~Item(void);
-
-		void setItemType(ItemType itemType);
-		ItemType getItemType() const;
-
-		const CeGuiString& getImageName() const;
-		void setImageName(const CeGuiString& name);
-
-        const CeGuiString& getSubmeshName() const;
-        void setSubmeshName(const CeGuiString& name);
-
-		/**
-		 * @return ob es sich um ein Item handelt,
-		 * in dem andere gespeichert werden koennen
-		 */
-        virtual bool isContainer() const;
-		
-		std::pair<int,int> getSize() const;
-		void setSize(int width, int height);
-
-
-        /**
-         * F?gt das Verhalten f?r die GO-States: GOS_READY, GOS_HELD und GOS_IN_POSSESION hinzu.
-         * @warning Bevor einer der drei States gesetzt wird, sollte zun?chst die Funktion removeOldState
-         * aufgerufen werden, dann m?ssen Owner und ParentSlot/ParentContainer gesetzt werden und
-         * eventuell doCreateActor. Als letztes muss diese Funktion mit dem neuen State aufgerufen werden.
-         * Die Reihenfolge ist wichtig, damit die onStateChange-Funktionen funktionieren k?nnen!
-         **/
-        virtual void setState(GameObjectState state);
-        virtual void removeOldState();
-
-        void setParentSlot(Slot* slot);
-        Slot* getParentSlot() const;
-
-        void setParentContainer(Container* cont);
-        Container* getParentContainer() const;
-
-        virtual void setOwner(GameObject* go);
-        GameObject* getOwner() const;
-
-        virtual const Property getProperty(const CeGuiString& key) const;
-        virtual void setProperty(const CeGuiString& key, const Property& value);
-        virtual PropertyKeys getAllPropertyKeys() const;
-
-        void doCreateActor();
-    protected:
-		ItemType mItemType;
-		CeGuiString mImageName;
-        CeGuiString mSubmeshName;
-		std::pair<int,int> mSize;
-        GameObject* mOwner;
-        Slot* mParentSlot;
-        Container* mParentContainer;
-
-		void doLoose();
-	};
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __ITEM_H__
+#define __ITEM_H__
+
+#include "GameObject.h"
+
+namespace rl
+{
+	class _RlRulesExport Item;
+    class Slot;
+    class Container;
+
+	typedef std::vector<Item*> ContainerColumn;
+	typedef std::vector<ContainerColumn> ContainerLayout;
+
+
+    /// Aufnehmbare Objekte in der Spielwelt.
+    class _RlRulesExport Item : public GameObject
+    {
+    public:
+		enum ItemType{
+			ITEMTYPE_WEAPON     = 1 << 0,
+			ITEMTYPE_SHIELD     = 1 << 1,
+			ITEMTYPE_RING       = 1 << 2,
+			ITEMTYPE_GLOVES     = 1 << 3,
+			ITEMTYPE_BRACELET   = 1 << 4,
+			ITEMTYPE_ARMOR      = 1 << 5,
+			ITEMTYPE_CAPE       = 1 << 6,
+			ITEMTYPE_BRACERS    = 1 << 7,
+			ITEMTYPE_BACKPACK   = 1 << 8,
+			ITEMTYPE_BELT       = 1 << 9,
+			ITEMTYPE_NECKLACE   = 1 << 10,
+			ITEMTYPE_HELMET     = 1 << 11,
+			ITEMTYPE_TROUSERS   = 1 << 12,
+			ITEMTYPE_SHINBONE   = 1 << 13,
+			ITEMTYPE_BOOTS      = 1 << 14,
+            ITEMTYPE_CLOTHES    = 1 << 15,
+			ITEMTYPE_OTHER      = 1 << 16,
+            ITEMTYPE_ALL_ITEMS  = ~(0)
+		};
+
+
+        static const Ogre::String CLASS_NAME;
+
+        static const Ogre::String PROPERTY_ITEMTYPE;
+        static const Ogre::String PROPERTY_SIZE;
+        static const Ogre::String PROPERTY_SUBMESHNAME;
+
+		Item(unsigned int id);
+        virtual ~Item(void);
+
+		void setItemType(ItemType itemType);
+		ItemType getItemType() const;
+
+        const CeGuiString& getSubmeshName() const;
+        void setSubmeshName(const CeGuiString& name);
+
+		/**
+		 * @return ob es sich um ein Item handelt,
+		 * in dem andere gespeichert werden koennen
+		 */
+        virtual bool isContainer() const;
+		
+		std::pair<int,int> getSize() const;
+		void setSize(int width, int height);
+
+
+        /**
+         * F??gt das Verhalten f??r die GO-States: GOS_READY, GOS_HELD und GOS_IN_POSSESION hinzu.
+         * @warning Bevor einer der drei States gesetzt wird, sollte zun???chst die Funktion removeOldState
+         * aufgerufen werden, dann m??ssen Owner und ParentSlot/ParentContainer gesetzt werden und
+         * eventuell doCreateActor. Als letztes muss diese Funktion mit dem neuen State aufgerufen werden.
+         * Die Reihenfolge ist wichtig, damit die onStateChange-Funktionen funktionieren k??nnen!
+         **/
+        virtual void setState(GameObjectState state);
+        virtual void removeOldState();
+
+        void setParentSlot(Slot* slot);
+        Slot* getParentSlot() const;
+
+        void setParentContainer(Container* cont);
+        Container* getParentContainer() const;
+
+        virtual void setOwner(GameObject* go);
+        GameObject* getOwner() const;
+
+        virtual const Property getProperty(const CeGuiString& key) const;
+        virtual void setProperty(const CeGuiString& key, const Property& value);
+        virtual PropertyKeys getAllPropertyKeys() const;
+
+        void doCreateActor();
+    protected:
+		ItemType mItemType;
+        CeGuiString mSubmeshName;
+		std::pair<int,int> mSize;
+        GameObject* mOwner;
+        Slot* mParentSlot;
+        Container* mParentContainer;
+
+		void doLoose();
+	};
+}
+
+#endif

Modified: rl/trunk/engine/rules/src/GameObject.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObject.cpp	2008-11-24 21:59:37 UTC (rev 4602)
+++ rl/trunk/engine/rules/src/GameObject.cpp	2008-11-24 22:01:45 UTC (rev 4603)
@@ -57,11 +57,13 @@
     const Ogre::String GameObject::PROPERTY_MASS = "mass";
     const Ogre::String GameObject::PROPERTY_ACTIONS = "actions";
     const Ogre::String GameObject::PROPERTY_DEFAULT_ACTION = "defaultaction";
-
+    const Ogre::String GameObject::PROPERTY_IMAGENAME = "imagename";
+    
     GameObject::GameObject(unsigned int id)
         :   mId(id),
             mName(""),
             mDescription(""),
+            mImageName(""),
             mMeshfile(""),
 			mMeshParts(),
             mQueryFlags(QUERYFLAG_GAMEOBJECT),
@@ -141,6 +143,16 @@
         mDescription = description;
     }
 
+	void GameObject::setImageName(const CeGuiString& name)
+	{
+		mImageName = name;
+	}
+    
+	const CeGuiString& GameObject::getImageName() const
+	{
+		return mImageName;
+	}
+    
     const CeGuiString& GameObject::getMeshfile() const
     {
         return mMeshfile;
@@ -540,6 +552,10 @@
         {
             prop.setValue(mDescription);
         }
+        else if (key == PROPERTY_IMAGENAME)
+        {
+            prop.setValue(mImageName);
+        }
         else if (key == PROPERTY_MESHFILE)
         {
             prop.setValue(mMeshfile);
@@ -594,6 +610,10 @@
             {
                 setDescription(value.toString());
             }
+            else if (key == PROPERTY_IMAGENAME)
+            {
+                setImageName(value.toString());
+            }
             else if (key == PROPERTY_MESHFILE)
             {
                 setMeshfile(value.toString());
@@ -682,6 +702,7 @@
         keys.insert(PROPERTY_MESHPARTS);
         keys.insert(PROPERTY_GEOMETRY_TYPE);
         keys.insert(PROPERTY_MASS);
+        keys.insert(PROPERTY_IMAGENAME);
         return keys;
     }
 

Modified: rl/trunk/engine/rules/src/Item.cpp
===================================================================
--- rl/trunk/engine/rules/src/Item.cpp	2008-11-24 21:59:37 UTC (rev 4602)
+++ rl/trunk/engine/rules/src/Item.cpp	2008-11-24 22:01:45 UTC (rev 4603)
@@ -1,278 +1,258 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "Item.h"
-
-#include "Actor.h"
-#include "Container.h"
-#include "Exception.h"
-#include "Slot.h"
-#include "GameObjectManager.h"
-
-using namespace std;
-
-namespace rl
-{
-    const Ogre::String Item::CLASS_NAME = "Item";
-
-    const Ogre::String Item::PROPERTY_IMAGENAME = "imagename";
-    const Ogre::String Item::PROPERTY_ITEMTYPE = "itemtype";
-    const Ogre::String Item::PROPERTY_SIZE = "size";
-    const Ogre::String Item::PROPERTY_SUBMESHNAME = "submeshfile";
-
-    Item::Item(unsigned int id)
-        : GameObject(id),
-		mItemType(ITEMTYPE_OTHER),
-		mImageName(""),
-		mSize(pair<int,int>(1,1)),
-        mOwner(NULL),
-        mParentSlot(NULL),
-        mParentContainer(NULL),
-        mSubmeshName("")
-    {
-        mQueryFlags |= QUERYFLAG_ITEM;
-    }
-
-    Item::~Item(void)
-    {
-        removeOldState(); // so the parent-container etc knows this item doesn't exists any more
-    }
-
-	void Item::setItemType(ItemType itemType)
-	{
-		mItemType = itemType;
-	}
-
-	Item::ItemType Item::getItemType() const
-	{
-		return mItemType;
-	}
-
-	void Item::setImageName(const CeGuiString& name)
-	{
-		mImageName = name;
-	}
-
-	const CeGuiString& Item::getImageName() const
-	{
-		return mImageName;
-	}
-
-	bool Item::isContainer() const
-	{
-		return false;
-	}
-
-	pair<int,int> Item::getSize() const
-	{
-		return mSize;
-	}
-
-	void Item::setSize(int widthSize,int heightSize)
-	{
-		mSize = pair<int,int>(widthSize,heightSize);
-	}
-
-    void Item::doLoose()
-    {
-        if (mActor != NULL)
-        {
-            mActor->detachFromParent();
-        }
-        if (mParentContainer != NULL)
-        {
-            mParentContainer->_doRemoveItem(this);
-            mParentContainer = NULL;
-        }
-        if (mParentSlot != NULL)
-        {
-            mParentSlot->setItem(NULL);
-            mParentSlot = NULL;
-        }
-        setOwner(NULL);
-    }
-
-    void Item::removeOldState()
-    {
-        setState(GOS_LOADED);
-    }
-
-// --------------- Warning ------------
-// do not change this function without
-// having a look at the containers and slots
-    void Item::setState(GameObjectState targetState)
-    {
-        if (mState == targetState)
-        {
-            return;
-        }
-
-        // do only things that are possible
-        if( targetState & (GOS_HELD | GOS_READY | GOS_IN_POSSESSION | GOS_IN_SCENE) && mState & (GOS_HELD | GOS_READY | GOS_IN_POSSESSION | GOS_IN_SCENE) )
-        {
-            LOG_ERROR(Logger::RULES,
-                "Item '" + getName() + "' could not change state from '"
-                + Ogre::StringConverter::toString(mState) + "' to state '"
-                + Ogre::StringConverter::toString(targetState) + "'!"
-                + "\nYou need to call 'Item::removeOldState()' first.");
-            
-            // first remove the old state (thats a recursive function call)
-            //removeOldState();
-        }
-
-        // everything else is not handled here, so give it to the parent
-        if ((targetState == GOS_IN_SCENE || targetState == GOS_LOADED)
-            && (mState == GOS_IN_SCENE || mState == GOS_LOADED))
-        {
-            GameObject::setState(targetState);
-            return;
-        }
-
-        GameObjectState oldState = mState;
-        onBeforeStateChange(oldState, targetState);        
-
-        if (targetState == GOS_LOADED 
-            && (mState == GOS_HELD || mState == GOS_READY || GOS_IN_POSSESSION) )
-        {
-            mState = targetState; // this is needed here to prevent an endless recursion
-            // "remove old state"
-            doLoose();
-            destroyActor();
-        }
-        else if (mState == GOS_LOADED &&
-                 (targetState == GOS_HELD || targetState == GOS_READY))
-        {
-            createActor();
-            mState = targetState;
-            // do nothing, the user has to do what he needs himself
-        }
-        else if ((mState == GOS_LOADED && targetState == GOS_IN_POSSESSION)
-            || (mState == GOS_IN_POSSESSION && targetState == GOS_LOADED))
-        {
-            mState = targetState;
-        }
-        else
-        {
-            Throw(rl::IllegalStateException, "Unhandled state change");
-        }
-
-        onAfterStateChange(oldState, targetState);
-        GameObjectManager::getSingleton().gameObjectStateChanged(this, oldState, targetState);
-    }
-
-    void Item::setProperty(const CeGuiString& key, const Property& value)
-    {
-        if (key == Item::PROPERTY_IMAGENAME)
-        {
-            mImageName = value.toString();
-        }
-        else if (key == Item::PROPERTY_SIZE)
-        {
-            mSize = value.toIntPair();
-        }
-        else if (key == Item::PROPERTY_ITEMTYPE)
-        {
-            mItemType = static_cast<Item::ItemType>(value.toInt());
-        }
-        else if (key == Item::PROPERTY_SUBMESHNAME)
-        {
-            mSubmeshName = value.toString();
-        }
-        else
-        {
-            GameObject::setProperty(key, value);
-        }
-    }
-
-    const Property Item::getProperty(const CeGuiString& key) const
-    {
-        if (key == Item::PROPERTY_IMAGENAME)
-        {
-            return Property(mImageName);
-        }
-        else if (key == Item::PROPERTY_SIZE)
-        {
-            return Property(mSize);
-        }
-        else if (key == Item::PROPERTY_ITEMTYPE)
-        {
-            return Property(mItemType);
-        }
-        else if (key == Item::PROPERTY_SUBMESHNAME)
-        {
-            return Property(mSubmeshName);
-        }
-        else
-        {
-            return GameObject::getProperty(key);
-        }
-    }
-
-    PropertyKeys Item::getAllPropertyKeys() const
-    {
-        PropertyKeys keys(GameObject::getAllPropertyKeys());
-        keys.insert(Item::PROPERTY_IMAGENAME);
-        keys.insert(Item::PROPERTY_SIZE);
-        keys.insert(Item::PROPERTY_ITEMTYPE);
-        return keys;
-    }
-
-    void Item::setOwner(GameObject* owner)
-    {
-        mOwner = owner;
-    }
-
-    GameObject* Item::getOwner() const
-    {
-        return mOwner;
-    }
-
-    void Item::setParentSlot(Slot* slot)
-    {
-        mParentSlot = slot;
-    }
-
-    Slot* Item::getParentSlot() const
-    {
-        return mParentSlot;
-    }
-
-    void Item::doCreateActor()
-    {
-        setActor(createActor());
-    }
-
-    void Item::setParentContainer(Container* cont)
-    {
-        mParentContainer = cont;
-    }
-
-    Container* Item::getParentContainer() const
-    {
-        return mParentContainer;
-    }
-
-    const CeGuiString& Item::getSubmeshName() const
-    {
-        return mSubmeshName;
-    }
-
-    void Item::setSubmeshName(const CeGuiString& name)
-    {
-        mSubmeshName = name;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include "Item.h"
+
+#include "Actor.h"
+#include "Container.h"
+#include "Exception.h"
+#include "Slot.h"
+#include "GameObjectManager.h"
+
+using namespace std;
+
+namespace rl
+{
+    const Ogre::String Item::CLASS_NAME = "Item";
+
+    const Ogre::String Item::PROPERTY_ITEMTYPE = "itemtype";
+    const Ogre::String Item::PROPERTY_SIZE = "size";
+    const Ogre::String Item::PROPERTY_SUBMESHNAME = "submeshfile";
+
+    Item::Item(unsigned int id)
+        : GameObject(id),
+		mItemType(ITEMTYPE_OTHER),
+		mSize(pair<int,int>(1,1)),
+        mOwner(NULL),
+        mParentSlot(NULL),
+        mParentContainer(NULL),
+        mSubmeshName("")
+    {
+        mQueryFlags |= QUERYFLAG_ITEM;
+    }
+
+    Item::~Item(void)
+    {
+        removeOldState(); // so the parent-container etc knows this item doesn't exists any more
+    }
+
+	void Item::setItemType(ItemType itemType)
+	{
+		mItemType = itemType;
+	}
+
+	Item::ItemType Item::getItemType() const
+	{
+		return mItemType;
+	}
+
+	bool Item::isContainer() const
+	{
+		return false;
+	}
+
+	pair<int,int> Item::getSize() const
+	{
+		return mSize;
+	}
+
+	void Item::setSize(int widthSize,int heightSize)
+	{
+		mSize = pair<int,int>(widthSize,heightSize);
+	}
+
+    void Item::doLoose()
+    {
+        if (mActor != NULL)
+        {
+            mActor->detachFromParent();
+        }
+        if (mParentContainer != NULL)
+        {
+            mParentContainer->_doRemoveItem(this);
+            mParentContainer = NULL;
+        }
+        if (mParentSlot != NULL)
+        {
+            mParentSlot->setItem(NULL);
+            mParentSlot = NULL;
+        }
+        setOwner(NULL);
+    }
+
+    void Item::removeOldState()
+    {
+        setState(GOS_LOADED);
+    }
+
+// --------------- Warning ------------
+// do not change this function without
+// having a look at the containers and slots
+    void Item::setState(GameObjectState targetState)
+    {
+        if (mState == targetState)
+        {
+            return;
+        }
+
+        // do only things that are possible
+        if( targetState & (GOS_HELD | GOS_READY | GOS_IN_POSSESSION | GOS_IN_SCENE) && mState & (GOS_HELD | GOS_READY | GOS_IN_POSSESSION | GOS_IN_SCENE) )
+        {
+            LOG_ERROR(Logger::RULES,
+                "Item '" + getName() + "' could not change state from '"
+                + Ogre::StringConverter::toString(mState) + "' to state '"
+                + Ogre::StringConverter::toString(targetState) + "'!"
+                + "\nYou need to call 'Item::removeOldState()' first.");
+            
+            // first remove the old state (thats a recursive function call)
+            //removeOldState();
+        }
+
+        // everything else is not handled here, so give it to the parent
+        if ((targetState == GOS_IN_SCENE || targetState == GOS_LOADED)
+            && (mState == GOS_IN_SCENE || mState == GOS_LOADED))
+        {
+            GameObject::setState(targetState);
+            return;
+        }
+
+        GameObjectState oldState = mState;
+        onBeforeStateChange(oldState, targetState);        
+
+        if (targetState == GOS_LOADED 
+            && (mState == GOS_HELD || mState == GOS_READY || GOS_IN_POSSESSION) )
+        {
+            mState = targetState; // this is needed here to prevent an endless recursion
+            // "remove old state"
+            doLoose();
+            destroyActor();
+        }
+        else if (mState == GOS_LOADED &&
+                 (targetState == GOS_HELD || targetState == GOS_READY))
+        {
+            createActor();
+            mState = targetState;
+            // do nothing, the user has to do what he needs himself
+        }
+        else if ((mState == GOS_LOADED && targetState == GOS_IN_POSSESSION)
+            || (mState == GOS_IN_POSSESSION && targetState == GOS_LOADED))
+        {
+            mState = targetState;
+        }
+        else
+        {
+            Throw(rl::IllegalStateException, "Unhandled state change");
+        }
+
+        onAfterStateChange(oldState, targetState);
+        GameObjectManager::getSingleton().gameObjectStateChanged(this, oldState, targetState);
+    }
+
+    void Item::setProperty(const CeGuiString& key, const Property& value)
+    {
+        if (key == Item::PROPERTY_SIZE)
+        {
+            mSize = value.toIntPair();
+        }
+        else if (key == Item::PROPERTY_ITEMTYPE)
+        {
+            mItemType = static_cast<Item::ItemType>(value.toInt());
+        }
+        else if (key == Item::PROPERTY_SUBMESHNAME)
+        {
+            mSubmeshName = value.toString();
+        }
+        else
+        {
+            GameObject::setProperty(key, value);
+        }
+    }
+
+    const Property Item::getProperty(const CeGuiString& key) const
+    {
+        if (key == Item::PROPERTY_SIZE)
+        {
+            return Property(mSize);
+        }
+        else if (key == Item::PROPERTY_ITEMTYPE)
+        {
+            return Property(mItemType);
+        }
+        else if (key == Item::PROPERTY_SUBMESHNAME)
+        {
+            return Property(mSubmeshName);
+        }
+        else
+        {
+            return GameObject::getProperty(key);
+        }
+    }
+
+    PropertyKeys Item::getAllPropertyKeys() const
+    {
+        PropertyKeys keys(GameObject::getAllPropertyKeys());
+        keys.insert(Item::PROPERTY_SUBMESHNAME);
+        keys.insert(Item::PROPERTY_SIZE);
+        keys.insert(Item::PROPERTY_ITEMTYPE);
+        return keys;
+    }
+
+    void Item::setOwner(GameObject* owner)
+    {
+        mOwner = owner;
+    }
+
+    GameObject* Item::getOwner() const
+    {
+        return mOwner;
+    }
+
+    void Item::setParentSlot(Slot* slot)
+    {
+        mParentSlot = slot;
+    }
+
+    Slot* Item::getParentSlot() const
+    {
+        return mParentSlot;
+    }
+
+    void Item::doCreateActor()
+    {
+        setActor(createActor());
+    }
+
+    void Item::setParentContainer(Container* cont)
+    {
+        mParentContainer = cont;
+    }
+
+    Container* Item::getParentContainer() const
+    {
+        return mParentContainer;
+    }
+
+    const CeGuiString& Item::getSubmeshName() const
+    {
+        return mSubmeshName;
+    }
+
+    void Item::setSubmeshName(const CeGuiString& name)
+    {
+        mSubmeshName = name;
+    }
+}



From blakharaz at mail.berlios.de  Mon Nov 24 23:04:56 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 24 Nov 2008 23:04:56 +0100
Subject: [Dsa-hl-svn] r4604 - in rl/trunk/engine: core/src rules/include
	ui/include ui/src
Message-ID: <200811242204.mAOM4uhh007649@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-24 23:04:52 +0100 (Mon, 24 Nov 2008)
New Revision: 4604

Modified:
   rl/trunk/engine/core/src/ConfigurationManager.cpp
   rl/trunk/engine/rules/include/PartyManager.h
   rl/trunk/engine/ui/include/WindowFactory.h
   rl/trunk/engine/ui/src/WindowFactory.cpp
Log:
Added character selection window

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-11-24 22:01:45 UTC (rev 4603)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2008-11-24 22:04:52 UTC (rev 4604)
@@ -111,6 +111,7 @@
         addSetting("Action keys", "showjournalwindow", "J");
         addSetting("Action keys", "showcharactersheet", "C");
         addSetting("Action keys", "togglecharacterstatewindow", "O");
+        addSetting("Action keys", "togglecharacterselectionwindow", "Y");
         addSetting("Action keys", "toggleingameglobalmenu", "F10");
         addSetting("Action keys", "shownextdebugwindowpage", "Ctrl+M");
         addSetting("Action keys", "showobjectactions", "U");

Modified: rl/trunk/engine/rules/include/PartyManager.h
===================================================================
--- rl/trunk/engine/rules/include/PartyManager.h	2008-11-24 22:01:45 UTC (rev 4603)
+++ rl/trunk/engine/rules/include/PartyManager.h	2008-11-24 22:04:52 UTC (rev 4604)
@@ -25,11 +25,11 @@
 {
     class Creature;
 
+    typedef std::vector<Creature*> Party;
+
     class _RlRulesExport PartyManager : public Ogre::Singleton<PartyManager>
     {
     public:
-		typedef std::vector<Creature*> Party;
-
 		PartyManager();
         
         Creature* getActiveCharacter() const;

Modified: rl/trunk/engine/ui/include/WindowFactory.h
===================================================================
--- rl/trunk/engine/ui/include/WindowFactory.h	2008-11-24 22:01:45 UTC (rev 4603)
+++ rl/trunk/engine/ui/include/WindowFactory.h	2008-11-24 22:04:52 UTC (rev 4604)
@@ -1,142 +1,145 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __WindowFactory_H__
-#define __WindowFactory_H__
-
-#include "UiPrerequisites.h"
-
-#include "FixRubyHeaders.h"        // die Makros sind hier vor Ruby schon definiert
-#include <ruby.h>
-#include "FixRubyHeaders.h"
-
-namespace rl {
-
-    class Actor;
-    class AbstractWindow;
-    class CharacterStateWindow;
-    class CharacterSheetWindow;
-    class CloseConfirmationWindow;
-    class CombatWindow;
-    class Console;
-    class Container;
-    class Creature;
-    class DebugWindow;
-    class DialogCharacter;
-    class GameLoggerWindow;
-    class GameObject;
-    class PropertiesWindow;
-    class GameSettings;
-    class InfoPopup;
-    class InGameMenuWindow;
-    class InventoryWindow;
-    class JournalWindow;
-    class LogWindow;
-    class MainMenuWindow;
-    class ObjectDescriptionWindow;
-    class GameSaveLoadWindow;
-    class MainMenuLoadWindow;
-    class WindowUpdater;
-
-    class _RlUiExport WindowFactory : public Ogre::Singleton<WindowFactory>
-    {
-    public:
-        enum PopupIcon
-        {
-            ICON_ERROR = 1,
-            ICON_QUEST
-        };
-
-        WindowFactory();
-        ~WindowFactory();
-
-        void initialize();
-
-        void setActiveCharacter(Creature* character);
-
-        void showActionChoice(GameObject* obj);
-        void showAboutWindow();
-        void showCharacterActionChoice();
-        void showCharacterSheet();
-        void showCharacterSheet(Creature* chara);
-        void showContainerContent(Container* container);
-        void showDescriptionWindow(GameObject* obj);
-        void showPropertiesWindow(GameObject* obj);
-        void showExitConfirmation();
-        void showJournalWindow();
-        void showLogfiles();
-        void showMessageWindow(const CeGuiString& message);
-        void showMainMenu();
-        void showObjectDescription(GameObject* object);
-        void showPlaylist();
-        void showGameSaveLoadWindow();
-        void showMainMenuLoadWindow(MainMenuWindow* win);
-		void hideMainMenuLoadWindow();
-        void showPopupMessage(int popupTypes);
-        void showGameOverWindow();
-        /**
-         * Creates a GameSettings object and displays its layout file on screen
-         */
-        void showGameSettings();
-
-        void toggleConsole();
-        void toggleDebugWindow();
-        void toggleGameLogWindow();
-        void toggleCharacterStateWindow();
-        void toggleInGameGlobalMenu();
-        void toggleInventoryWindow();
-        void notifyInventoryWindowDestroyed();
-		bool isInventoryWindowDestroyed();
-
-        CombatWindow* getCombatWindow();
-
-        void checkForErrors();
-        GameLoggerWindow* getGameLogger();
-
-        void update();
-
-        /// Writes Text into the Console or other output media
-        void writeToConsole(std::string text);
-        static VALUE consoleWrite(VALUE self, VALUE str);
-
-        /// Change shown DebugWindow page
-        void showNextDebugWindowPage();
-
-    private:
-        void logAllWindows();
-
-        GameLoggerWindow* mGameLogger;
-        CharacterStateWindow* mCharacterStateWindow;
-        InGameMenuWindow* mInGameMenuWindow;
-        CharacterSheetWindow* mCharacterSheet;
-        JournalWindow* mJournalWindow;
-        InventoryWindow* mInventoryWindow;
-        LogWindow* mLogWindow;
-        DebugWindow* mDebugWindow;
-        Console* mConsole;
-        InfoPopup* mInfoPopup;
-        Actor* mObjectNameText;
-        GameObject* mShownObject;
-        ObjectDescriptionWindow* mObjectDescriptionWindow;
-        MainMenuWindow* mMainMenuWindow;
-		MainMenuLoadWindow* mMainMenuLoadWindow;
-        CloseConfirmationWindow* mCloseConfirmationWindow;
-        GameSettings* mGameSettings;
-        CombatWindow* mCombatWindow;
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __WindowFactory_H__
+#define __WindowFactory_H__
+
+#include "UiPrerequisites.h"
+
+#include "FixRubyHeaders.h"        // die Makros sind hier vor Ruby schon definiert
+#include <ruby.h>
+#include "FixRubyHeaders.h"
+
+namespace rl {
+
+    class Actor;
+    class AbstractWindow;
+    class CharacterSelectionWindow;
+    class CharacterSheetWindow;
+    class CharacterStateWindow;
+    class CloseConfirmationWindow;
+    class CombatWindow;
+    class Console;
+    class Container;
+    class Creature;
+    class DebugWindow;
+    class DialogCharacter;
+    class GameLoggerWindow;
+    class GameObject;
+    class PropertiesWindow;
+    class GameSettings;
+    class InfoPopup;
+    class InGameMenuWindow;
+    class InventoryWindow;
+    class JournalWindow;
+    class LogWindow;
+    class MainMenuWindow;
+    class ObjectDescriptionWindow;
+    class GameSaveLoadWindow;
+    class MainMenuLoadWindow;
+    class WindowUpdater;
+
+    class _RlUiExport WindowFactory : public Ogre::Singleton<WindowFactory>
+    {
+    public:
+        enum PopupIcon
+        {
+            ICON_ERROR = 1,
+            ICON_QUEST
+        };
+
+        WindowFactory();
+        ~WindowFactory();
+
+        void initialize();
+
+        void setActiveCharacter(Creature* character);
+
+        void showActionChoice(GameObject* obj);
+        void showAboutWindow();
+        void showCharacterActionChoice();
+        void showCharacterSheet();
+        void showCharacterSheet(Creature* chara);
+        void showContainerContent(Container* container);
+        void showDescriptionWindow(GameObject* obj);
+        void showPropertiesWindow(GameObject* obj);
+        void showExitConfirmation();
+        void showJournalWindow();
+        void showLogfiles();
+        void showMessageWindow(const CeGuiString& message);
+        void showMainMenu();
+        void showObjectDescription(GameObject* object);
+        void showPlaylist();
+        void showGameSaveLoadWindow();
+        void showMainMenuLoadWindow(MainMenuWindow* win);
+		void hideMainMenuLoadWindow();
+        void showPopupMessage(int popupTypes);
+        void showGameOverWindow();
+        /**
+         * Creates a GameSettings object and displays its layout file on screen
+         */
+        void showGameSettings();
+
+        void toggleConsole();
+        void toggleDebugWindow();
+        void toggleGameLogWindow();
+        void toggleCharacterStateWindow();
+        void toggleCharacterSelectionWindow();
+        void toggleInGameGlobalMenu();
+        void toggleInventoryWindow();
+        void notifyInventoryWindowDestroyed();
+		bool isInventoryWindowDestroyed();
+
+        CombatWindow* getCombatWindow();
+
+        void checkForErrors();
+        GameLoggerWindow* getGameLogger();
+
+        void update();
+
+        /// Writes Text into the Console or other output media
+        void writeToConsole(std::string text);
+        static VALUE consoleWrite(VALUE self, VALUE str);
+
+        /// Change shown DebugWindow page
+        void showNextDebugWindowPage();
+
+    private:
+        void logAllWindows();
+
+        GameLoggerWindow* mGameLogger;
+        CharacterStateWindow* mCharacterStateWindow;
+        InGameMenuWindow* mInGameMenuWindow;
+        CharacterSheetWindow* mCharacterSheet;
+        JournalWindow* mJournalWindow;
+        InventoryWindow* mInventoryWindow;
+        LogWindow* mLogWindow;
+        DebugWindow* mDebugWindow;
+        Console* mConsole;
+        InfoPopup* mInfoPopup;
+        Actor* mObjectNameText;
+        GameObject* mShownObject;
+        ObjectDescriptionWindow* mObjectDescriptionWindow;
+        MainMenuWindow* mMainMenuWindow;
+		MainMenuLoadWindow* mMainMenuLoadWindow;
+        CloseConfirmationWindow* mCloseConfirmationWindow;
+        GameSettings* mGameSettings;
+        CombatWindow* mCombatWindow;
+        CharacterSelectionWindow* mCharacterSelectionWindow;
+    };
+}
+
+#endif

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2008-11-24 22:01:45 UTC (rev 4603)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2008-11-24 22:04:52 UTC (rev 4604)
@@ -20,6 +20,7 @@
 #include "AboutWindow.h"
 #include "ActionChoiceWindow.h"
 #include "ActorManager.h"
+#include "CharacterSelectionWindow.h"
 #include "CharacterSheetWindow.h"
 #include "CharacterStateWindow.h"
 #include "CloseConfirmationWindow.h"
@@ -85,7 +86,8 @@
         mMainMenuWindow(NULL),
 		mMainMenuLoadWindow(NULL),
         mGameSettings(NULL),
-        mCombatWindow(NULL)
+        mCombatWindow(NULL),
+        mCharacterSelectionWindow(NULL)
     {
     }
 
@@ -111,6 +113,8 @@
         RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mJournalWindow);
         //RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mInfoPopup);
         mMainMenuWindow = new MainMenuWindow( new MainMenuEngineWindow() );
+        
+        mCharacterSelectionWindow = new CharacterSelectionWindow();
 
         logAllWindows();
     }
@@ -292,7 +296,13 @@
     {
         mCharacterStateWindow->setVisible(!mCharacterStateWindow->isVisible());
     }
-
+    
+    void WindowFactory::toggleCharacterSelectionWindow()
+    {
+        mCharacterSelectionWindow->setVisible(!mCharacterSelectionWindow->isVisible());
+        mCharacterSelectionWindow->update();
+    }
+    
     void WindowFactory::toggleInGameGlobalMenu()
     {
         mInGameMenuWindow->setVisible(!mInGameMenuWindow->isVisible());



From blakharaz at mail.berlios.de  Mon Nov 24 23:05:51 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 24 Nov 2008 23:05:51 +0100
Subject: [Dsa-hl-svn] r4605 - in modules: common/gui/windows common/scripts
	regressiontest/scripts regressiontest/scripts/maps
Message-ID: <200811242205.mAOM5pR2007765@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-24 23:05:48 +0100 (Mon, 24 Nov 2008)
New Revision: 4605

Added:
   modules/common/gui/windows/characterselectionwindow.xml
   modules/common/gui/windows/characterselectionwindow_character.xml
   modules/regressiontest/scripts/CharacterSelectionTest.rb
Modified:
   modules/common/scripts/global-actions.rb
   modules/common/scripts/global-settings.rb
   modules/regressiontest/scripts/maps/regressiontest.rb
Log:
Added character selection window tests and action

Added: modules/common/gui/windows/characterselectionwindow.xml
===================================================================
--- modules/common/gui/windows/characterselectionwindow.xml	2008-11-24 22:04:52 UTC (rev 4604)
+++ modules/common/gui/windows/characterselectionwindow.xml	2008-11-24 22:05:48 UTC (rev 4605)
@@ -0,0 +1,10 @@
+<GUILayout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="GUILayout.xsd">
+    <Window Type="DefaultGUISheet" Name="CharacterSelectionWindow/Characters">
+        <Property Name="VerticalAlignment" Value="Bottom" />
+	    <Property Name="HorizontalAlignment" Value="Left" />
+        <Property Name="UnifiedPosition" Value="{{0,10},{0,10}}" />
+        <Property Name="UnifiedSize" Value="{{0,80},{1,-200}}" />
+    </Window>
+</GUILayout>
+
+

Added: modules/common/gui/windows/characterselectionwindow_character.xml
===================================================================
--- modules/common/gui/windows/characterselectionwindow_character.xml	2008-11-24 22:04:52 UTC (rev 4604)
+++ modules/common/gui/windows/characterselectionwindow_character.xml	2008-11-24 22:05:48 UTC (rev 4605)
@@ -0,0 +1,24 @@
+<GUILayout xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="GUILayout.xsd">
+		<Window Type="DefaultWindow" Name="CharacterSelectionWindow/Character">
+	        <Property Name="UnifiedSize" Value="{{0,64},{0,100}}" />
+	        
+			<Window Type="RastullahLook/StaticImage" Name="CharacterSelectionWindow/Character/Picture">
+				<Property Name="UnifiedPosition" Value="{{0,0},{0,14}}" />
+				<Property Name="UnifiedSize" Value="{{1,0},{0,64}}" />
+				<Property Name="FrameEnabled" Value="False"/>
+			</Window>
+
+			<Window Type="RastullahLook/StaticText" Name="CharacterSelectionWindow/Character/Name">
+				<Property Name="UnifiedPosition" Value="{{0,0},{0,80}}" />
+				<Property Name="UnifiedSize" Value="{{1,0},{0,15}}" />
+				<Property Name="FrameEnabled" Value="False"/>
+			</Window>
+	
+			<Window Type="RastullahLook/StatusBar" Name="CharacterSelectionWindow/Character/LP">
+				<Property Name="UnifiedPosition" Value="{{0,0},{0,0}}" />
+				<Property Name="UnifiedSize" Value="{{1,0},{0,13}}" />
+				<Property Name="CurrentProgress" Value="100"/>
+				<Property Name="StatusColour" Value="FFFF0000"/>
+			</Window>
+		</Window>
+</GUILayout>
\ No newline at end of file

Modified: modules/common/scripts/global-actions.rb
===================================================================
--- modules/common/scripts/global-actions.rb	2008-11-24 22:04:52 UTC (rev 4604)
+++ modules/common/scripts/global-actions.rb	2008-11-24 22:05:48 UTC (rev 4605)
@@ -1,276 +1,286 @@
-load 'embed.rb'
-
-class ShowActionMenuAction < Action
-  def initialize
-    super("showactions", "Aktionen anzeigen")
-  end
-
-  def doAction(object, actor, target)
-    $WF.showCharacterActionChoice()
-  end
-end
-
-class QuitGameAction < Action
-  def initialize
-    super("quitgame", "Das Spiel beenden")
-  end
-
-  def doAction(object, actor, target)
-    $WF.showExitConfirmation()
-  end
-end
-
-class SaveLoadGameAction < Action
-  def initialize
-    super("act_saveloadgame", "Das Spiel speichern/laden")
-  end
-
-  def doAction(object, actor, target)
-    $WF.showGameSaveLoadWindow()
-  end
-end
-
-class ForceQuitGameAction < Action
-  def initialize
-    super("forcequitgame", "Das Spiel ohne Nachfrage beenden")
-  end
-
-  def doAction(object, actor, target)
-    GameLoop.getSingleton().quitGame();
-  end
-end
-
-class ToggleConsoleAction < Action
-  def initialize
-    super("toggleconsole", "Konsole zeigen/verstecken")
-  end
-
-  def doAction(object, actor, target)
-    $WF.toggleConsole()
-  end
-end
-
-class ToggleDebugWindowAction < Action
-  def initialize
-    super("toggledebugwindow", "DebugWindow zeigen/verstecken")
-  end
-
-  def doAction(object, actor, target)
-    $WF.toggleDebugWindow()
-  end
-end
-
-class ToggleGameLogWindowAction < Action
-    def initialize
-        super("togglegamelogwindow", "Game Log zeigen/verstecken")
-    end
-
-    def doAction(object, actor, target)
-        $WF.toggleGameLogWindow()
-    end
-end
-
-class ToggleInGameGlobalMenuAction < Action
-  def initialize
-    super("toggleingameglobalmenu", "Spielmen? anzeigen")
-  end
-
-  def doAction(object, actor, target)
-    $WF.toggleInGameGlobalMenu()
-  end
-end
-
-class ToggleInventoryAction < Action
-    def initialize
-        super("toggleinventorywindow", "Das Inventar des aktiven Helden anzeigen")
-    end
-
-    def doAction(object, actor, target)
-        $WF.toggleInventoryWindow()
-    end
-end
-
-class MakeScreenshotAction < Action
-  def initialize
-    super("makescreenshot", "Screenshot erstellen")
-  end
-
-  def doAction(object, actor, target)
-    $CORE.makeScreenshot("rastullah");
-  end
-end
-
-class ToggleCollisionDebugAction < Action
-  def initialize
-    super("togglecollisiondebug", "Kollisionsk?rper anzeigen")
-  end
-
-  def doAction(object, actor, target)
-    $PM.toggleDebugMode();
-  end
-end
-
-class ToggleDebugVisualisationAction < Action
-  def initialize
-    super("toggledebugvisualisation", "Debug-Helfer anzeigen")
-    @isShown = false
-  end
-
-  def doAction(object, actor, target)
-    if @isShown:
-      $DVM.hideAll()
-    else
-      $DVM.showAll()
-    end
-    @isShown = (not @isShown)
-  end
-end
-
-class ToggleCharacterStateWindowAction < Action
-    def initialize
-        super("togglecharacterstatewindow", "Charakterstatus zeigen/verstecken")
-    end
-
-    def doAction(object, actor, target)
-        $WF.toggleCharacterStateWindow()
-    end
-end
-
-class ShowCharacterSheetAction < Action
-  def initialize
-    super("showcharactersheet", "Charakterblatt des aktiven Helden anzeigen")
-  end
-
-  def doAction(object, actor, target)
-    $WF.showCharacterSheet()
-  end
-end
-
-class ShowTargetWindowAction < Action
-  def initialize
-    super("showtargetwindow", "Zielauswahl")
-  end
-
-  def doAction(object, actor, target)
-    $WF.showTargetWindow()
-  end
-end
-
-class ShowJournalWindowAction < Action
-  def initialize
-    super("showjournalwindow", "Tagebuch")
-  end
-
-  def doAction(object, actor, target)
-    $WF.showJournalWindow()
-  end
-end
-
-class ShowObjectDescriptionWindow < Action
-  def initialize
-    super(GameObject.DEFAULT_VIEW_OBJECT_ACTION, "Anschauen")
-  end
-
-  def doAction(object, actor, target)
-    $WF.showDescriptionWindow(object)
-  end
-end
-
-class ShowGameObjectWindowAction < Action
-  def initialize
-    super(GameObject.DEFAULT_VIEW_OBJECT_ACTION_DEBUG, "GameObject Properties (DeveloperMode)")
-  end
-  
-  def doAction(object, actor, target)
-    $WF.showGameObjectPropsWindow(object)
-  end
-  
-  def canDo(object, actor)
-    $CORE.getDeveloperMode()
-  end
-end
-
-class ShowAboutWindowAction < Action
-  def initialize
-    super("showaboutwindow", "?ber")
-  end
-
-  def doAction(object, actor, target)
-    $WF.showAboutWindow()
-  end
-end
-
-class ShowGameSettingsAction < Action
-  def initialize
-    super("showgamesettings", "Spieleinstellungen")
-  end
-
-  def doAction(object, actor, target)
-    $WF.showGameSettings()
-  end
-end
-
-class ShowLogfilesAction < Action
-  def initialize
-    super("showlogfiles", "Logfiles anzeigen")
-  end
-
-  def doAction(object, actor, target)
-    $WF.showLogfiles()
-  end
-end
-
-class ShowNextDebugWindowPageAction < Action
-  def initialize
-    super("shownextdebugwindowpage", "Zur n?chsten Info-Seite wechseln")
-  end
-
-  def doAction(object, actor, target)
-    $WF.showNextDebugWindowPage()
-  end
-end
-
-class CloseCurrentWindowAction < Action
-  def initialize
-    super("closecurrentwindow", "Oberstes Fenster schliessen")
-  end
-
-  def doAction(object, actor, target)
-    WindowManager.getSingleton().closeTopWindow()
-  end
-end
-
-class ShowContainerContentAction < Action
-  def initialize
-    super("showcontainercontent", "Inhalt anzeigen")
-  end
-  
-  def doAction(object, actor, target)
-    $WF.showContainerContent(object)
-  end
-  
-  def canDo(object, actor)
-    return object.isContainer()
-  end
-end
-
-class InventoryShowWorldObjects < Action
-  def initialize
-   super("inventoryshowworldobjects", "Zeige alle greifbaren Objekte")
-  end
-
-  def doAction(object, actor, target)
-  end
-end
-
-act = ShowObjectDescriptionWindow.new()
-ActionManager.getSingleton().registerAction(act)
-
-act2 = ShowGameObjectWindowAction.new()
-ActionManager.getSingleton().registerAction(act2)
-
-act3 = ShowContainerContentAction.new()
-ActionManager.getSingleton().registerAction(act3)
-
-act4 = InventoryShowWorldObjects.new()
-ActionManager.getSingleton().registerAction(act4)
+load 'embed.rb'
+
+class ShowActionMenuAction < Action
+  def initialize
+    super("showactions", "Aktionen anzeigen")
+  end
+
+  def doAction(object, actor, target)
+    $WF.showCharacterActionChoice()
+  end
+end
+
+class QuitGameAction < Action
+  def initialize
+    super("quitgame", "Das Spiel beenden")
+  end
+
+  def doAction(object, actor, target)
+    $WF.showExitConfirmation()
+  end
+end
+
+class SaveLoadGameAction < Action
+  def initialize
+    super("act_saveloadgame", "Das Spiel speichern/laden")
+  end
+
+  def doAction(object, actor, target)
+    $WF.showGameSaveLoadWindow()
+  end
+end
+
+class ForceQuitGameAction < Action
+  def initialize
+    super("forcequitgame", "Das Spiel ohne Nachfrage beenden")
+  end
+
+  def doAction(object, actor, target)
+    GameLoop.getSingleton().quitGame();
+  end
+end
+
+class ToggleConsoleAction < Action
+  def initialize
+    super("toggleconsole", "Konsole zeigen/verstecken")
+  end
+
+  def doAction(object, actor, target)
+    $WF.toggleConsole()
+  end
+end
+
+class ToggleDebugWindowAction < Action
+  def initialize
+    super("toggledebugwindow", "DebugWindow zeigen/verstecken")
+  end
+
+  def doAction(object, actor, target)
+    $WF.toggleDebugWindow()
+  end
+end
+
+class ToggleGameLogWindowAction < Action
+    def initialize
+        super("togglegamelogwindow", "Game Log zeigen/verstecken")
+    end
+
+    def doAction(object, actor, target)
+        $WF.toggleGameLogWindow()
+    end
+end
+
+class ToggleInGameGlobalMenuAction < Action
+  def initialize
+    super("toggleingameglobalmenu", "Spielmen? anzeigen")
+  end
+
+  def doAction(object, actor, target)
+    $WF.toggleInGameGlobalMenu()
+  end
+end
+
+class ToggleInventoryAction < Action
+    def initialize
+        super("toggleinventorywindow", "Das Inventar des aktiven Helden anzeigen")
+    end
+
+    def doAction(object, actor, target)
+        $WF.toggleInventoryWindow()
+    end
+end
+
+class MakeScreenshotAction < Action
+  def initialize
+    super("makescreenshot", "Screenshot erstellen")
+  end
+
+  def doAction(object, actor, target)
+    $CORE.makeScreenshot("rastullah");
+  end
+end
+
+class ToggleCollisionDebugAction < Action
+  def initialize
+    super("togglecollisiondebug", "Kollisionsk?rper anzeigen")
+  end
+
+  def doAction(object, actor, target)
+    $PM.toggleDebugMode();
+  end
+end
+
+class ToggleDebugVisualisationAction < Action
+  def initialize
+    super("toggledebugvisualisation", "Debug-Helfer anzeigen")
+    @isShown = false
+  end
+
+  def doAction(object, actor, target)
+    if @isShown:
+      $DVM.hideAll()
+    else
+      $DVM.showAll()
+    end
+    @isShown = (not @isShown)
+  end
+end
+
+class ToggleCharacterStateWindowAction < Action
+    def initialize
+        super("togglecharacterstatewindow", "Charakterstatus zeigen/verstecken")
+    end
+
+    def doAction(object, actor, target)
+        $WF.toggleCharacterStateWindow()
+    end
+end
+
+class ToggleCharacterSelectionWindowAction < Action
+    def initialize
+        super("togglecharacterselectionwindow", "Partyauswahl zeigen/verstecken")
+    end
+
+    def doAction(object, actor, target)
+        $WF.toggleCharacterSelectionWindow()
+    end
+end
+
+class ShowCharacterSheetAction < Action
+  def initialize
+    super("showcharactersheet", "Charakterblatt des aktiven Helden anzeigen")
+  end
+
+  def doAction(object, actor, target)
+    $WF.showCharacterSheet()
+  end
+end
+
+class ShowTargetWindowAction < Action
+  def initialize
+    super("showtargetwindow", "Zielauswahl")
+  end
+
+  def doAction(object, actor, target)
+    $WF.showTargetWindow()
+  end
+end
+
+class ShowJournalWindowAction < Action
+  def initialize
+    super("showjournalwindow", "Tagebuch")
+  end
+
+  def doAction(object, actor, target)
+    $WF.showJournalWindow()
+  end
+end
+
+class ShowObjectDescriptionWindow < Action
+  def initialize
+    super(GameObject.DEFAULT_VIEW_OBJECT_ACTION, "Anschauen")
+  end
+
+  def doAction(object, actor, target)
+    $WF.showDescriptionWindow(object)
+  end
+end
+
+class ShowGameObjectWindowAction < Action
+  def initialize
+    super(GameObject.DEFAULT_VIEW_OBJECT_ACTION_DEBUG, "GameObject Properties (DeveloperMode)")
+  end
+  
+  def doAction(object, actor, target)
+    $WF.showGameObjectPropsWindow(object)
+  end
+  
+  def canDo(object, actor)
+    $CORE.getDeveloperMode()
+  end
+end
+
+class ShowAboutWindowAction < Action
+  def initialize
+    super("showaboutwindow", "?ber")
+  end
+
+  def doAction(object, actor, target)
+    $WF.showAboutWindow()
+  end
+end
+
+class ShowGameSettingsAction < Action
+  def initialize
+    super("showgamesettings", "Spieleinstellungen")
+  end
+
+  def doAction(object, actor, target)
+    $WF.showGameSettings()
+  end
+end
+
+class ShowLogfilesAction < Action
+  def initialize
+    super("showlogfiles", "Logfiles anzeigen")
+  end
+
+  def doAction(object, actor, target)
+    $WF.showLogfiles()
+  end
+end
+
+class ShowNextDebugWindowPageAction < Action
+  def initialize
+    super("shownextdebugwindowpage", "Zur n?chsten Info-Seite wechseln")
+  end
+
+  def doAction(object, actor, target)
+    $WF.showNextDebugWindowPage()
+  end
+end
+
+class CloseCurrentWindowAction < Action
+  def initialize
+    super("closecurrentwindow", "Oberstes Fenster schliessen")
+  end
+
+  def doAction(object, actor, target)
+    WindowManager.getSingleton().closeTopWindow()
+  end
+end
+
+class ShowContainerContentAction < Action
+  def initialize
+    super("showcontainercontent", "Inhalt anzeigen")
+  end
+  
+  def doAction(object, actor, target)
+    $WF.showContainerContent(object)
+  end
+  
+  def canDo(object, actor)
+    return object.isContainer()
+  end
+end
+
+class InventoryShowWorldObjects < Action
+  def initialize
+   super("inventoryshowworldobjects", "Zeige alle greifbaren Objekte")
+  end
+
+  def doAction(object, actor, target)
+  end
+end
+
+act = ShowObjectDescriptionWindow.new()
+ActionManager.getSingleton().registerAction(act)
+
+act2 = ShowGameObjectWindowAction.new()
+ActionManager.getSingleton().registerAction(act2)
+
+act3 = ShowContainerContentAction.new()
+ActionManager.getSingleton().registerAction(act3)
+
+act4 = InventoryShowWorldObjects.new()
+ActionManager.getSingleton().registerAction(act4)

Modified: modules/common/scripts/global-settings.rb
===================================================================
--- modules/common/scripts/global-settings.rb	2008-11-24 22:04:52 UTC (rev 4604)
+++ modules/common/scripts/global-settings.rb	2008-11-24 22:05:48 UTC (rev 4605)
@@ -15,6 +15,7 @@
       actionManager.registerInGameGlobalAction(ToggleCollisionDebugAction.new(), $grpView)
       actionManager.registerInGameGlobalAction(ShowCharacterSheetAction.new(), $grpView)
       actionManager.registerInGameGlobalAction(ToggleCharacterStateWindowAction.new(), $grpView)
+      actionManager.registerInGameGlobalAction(ToggleCharacterSelectionWindowAction.new(), $grpView)
       actionManager.registerInGameGlobalAction(ShowTargetWindowAction.new(), $grpView)
       actionManager.registerInGameGlobalAction(ToggleInGameGlobalMenuAction.new(), $grpView)
       actionManager.registerInGameGlobalAction(ShowJournalWindowAction.new(), $grpView)

Added: modules/regressiontest/scripts/CharacterSelectionTest.rb
===================================================================
--- modules/regressiontest/scripts/CharacterSelectionTest.rb	2008-11-24 22:04:52 UTC (rev 4604)
+++ modules/regressiontest/scripts/CharacterSelectionTest.rb	2008-11-24 22:05:48 UTC (rev 4605)
@@ -0,0 +1,10 @@
+require "testcase.rb"
+
+class CharacterSelectionTest < TestCase
+    def execute()
+        wolf = $GOM.createGameObject("Wolf");
+        wolf.setPosition(getCenter());
+        wolf.placeIntoScene();
+        PartyManager.getSingleton().addCharacter(wolf);
+    end
+end

Modified: modules/regressiontest/scripts/maps/regressiontest.rb
===================================================================
--- modules/regressiontest/scripts/maps/regressiontest.rb	2008-11-24 22:04:52 UTC (rev 4604)
+++ modules/regressiontest/scripts/maps/regressiontest.rb	2008-11-24 22:05:48 UTC (rev 4605)
@@ -39,6 +39,7 @@
 require 'TimeTest.rb'
 require 'CombatTest.rb'
 require 'WalkJobTest.rb'
+require 'CharacterSelectionTest.rb'
 
 class RegressionTestSuite
 	def initialize
@@ -68,7 +69,7 @@
 		runTest(LightzoneTest, [-10, 0, -5])
 		runTest(MapLoadingTest, [ -5, 0, -10])
 		runTest(MaterialSlotTest, [-15, 0, -5])
-#		runTest(MergeableMeshTest, [ 10, 0, 0])
+		runTest(MergeableMeshTest, [ 10, 0, 0])
 		runTest(MeshAreaTest, [-50, 0,-55])
 		runTest(NpcTest, [ -5, 0, 5])
 		runTest(SelectorTest, [  5, 0, 0])
@@ -76,7 +77,8 @@
 		runTest(TimeTest, [ -5, 0, -5])
 		runTest(WalkJobTest, [  0, 0, -3])
 		runTest(CombatTest, [15, 0, 15])
-   		runTest(FetchItemJobTest, [-15, 0, 15])
+  		runTest(FetchItemJobTest, [-15, 0, 15])
+        runTest(CharacterSelectionTest, [-15, 0, -15])
 
 		if @mErrors > 0
 		  MessageBox.showModal(



From blakharaz at mail.berlios.de  Mon Nov 24 23:06:12 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 24 Nov 2008 23:06:12 +0100
Subject: [Dsa-hl-svn] r4606 - rl/trunk/engine/script/swig
Message-ID: <200811242206.mAOM6Cnh007790@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-24 23:06:11 +0100 (Mon, 24 Nov 2008)
New Revision: 4606

Modified:
   rl/trunk/engine/script/swig/RlUi.swig
Log:
Added character selection window

Modified: rl/trunk/engine/script/swig/RlUi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlUi.swig	2008-11-24 22:05:48 UTC (rev 4605)
+++ rl/trunk/engine/script/swig/RlUi.swig	2008-11-24 22:06:11 UTC (rev 4606)
@@ -103,6 +103,7 @@
     void toggleConsole();
     void toggleDebugWindow();
     void toggleGameLogWindow();
+    void toggleCharacterSelectionWindow();
     void toggleCharacterStateWindow();
     void toggleInGameGlobalMenu();
     void toggleInventoryWindow();



From blakharaz at mail.berlios.de  Mon Nov 24 23:09:25 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Mon, 24 Nov 2008 23:09:25 +0100
Subject: [Dsa-hl-svn] r4607 - rl/trunk/Mac/Rastullah.xcodeproj
Message-ID: <200811242209.mAOM9PRV007975@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-24 23:09:24 +0100 (Mon, 24 Nov 2008)
New Revision: 4607

Modified:
   rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
Log:


Modified: rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-11-24 22:06:11 UTC (rev 4606)
+++ rl/trunk/Mac/Rastullah.xcodeproj/project.pbxproj	2008-11-24 22:09:24 UTC (rev 4607)
@@ -663,6 +663,8 @@
 		48A52CC00E0EF77D008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
 		48A52CC20E0EF77E008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
 		48A52CC30E0EF785008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
+		48B006C50ECAC05F008141C2 /* CharacterSelectionWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B006C40ECAC05F008141C2 /* CharacterSelectionWindow.cpp */; };
+		48B006C80ECAC11D008141C2 /* CharacterSelectionWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B006C70ECAC11D008141C2 /* CharacterSelectionWindow.h */; };
 		48B0B0350E6534690023B198 /* PlaneNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B0B0340E6534690023B198 /* PlaneNodeProcessor.cpp */; };
 		48B0B0370E6534810023B198 /* PlaneNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B0B0360E6534810023B198 /* PlaneNodeProcessor.h */; };
 		48B0B03C0E6535AB0023B198 /* libmeshmagick.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 440785DD0C09D231006E496D /* libmeshmagick.dylib */; };
@@ -1490,6 +1492,8 @@
 		48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libboost_system.dylib; path = /usr/local/lib/libboost_system.dylib; sourceTree = "<absolute>"; };
 		48A52CB50E0EF5BD008DBDD8 /* ApplyDamageJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ApplyDamageJob.h; sourceTree = "<group>"; };
 		48A52CB70E0EF5D0008DBDD8 /* ApplyDamageJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ApplyDamageJob.cpp; sourceTree = "<group>"; };
+		48B006C40ECAC05F008141C2 /* CharacterSelectionWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CharacterSelectionWindow.cpp; sourceTree = "<group>"; };
+		48B006C70ECAC11D008141C2 /* CharacterSelectionWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CharacterSelectionWindow.h; sourceTree = "<group>"; };
 		48B0B0340E6534690023B198 /* PlaneNodeProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PlaneNodeProcessor.cpp; path = ../engine/script/src/PlaneNodeProcessor.cpp; sourceTree = SOURCE_ROOT; };
 		48B0B0360E6534810023B198 /* PlaneNodeProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PlaneNodeProcessor.h; path = ../engine/script/include/PlaneNodeProcessor.h; sourceTree = SOURCE_ROOT; };
 		48B0B0480E65BBB30023B198 /* libfmodex.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libfmodex.dylib; path = "FMOD Programmers API/api/lib/libfmodex.dylib"; sourceTree = SYSTEM_DEVELOPER_DIR; };
@@ -1519,7 +1523,7 @@
 		48D0BE6B0E27401E00863824 /* DialogLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogLoader.cpp; path = ../engine/ai/src/DialogLoader.cpp; sourceTree = SOURCE_ROOT; };
 		48D34A610D90F5D500C89477 /* SaveGameData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameData.h; path = ../engine/core/include/SaveGameData.h; sourceTree = SOURCE_ROOT; };
 		48D34A620D90F5D500C89477 /* SaveGameData.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameData.cpp; path = ../engine/core/src/SaveGameData.cpp; sourceTree = SOURCE_ROOT; };
-		48D401810D9E483200AE5340 /* modules */ = {isa = PBXFileReference; lastKnownFileType = folder; name = modules; path = ../../../modules; sourceTree = SOURCE_ROOT; };
+		48D401810D9E483200AE5340 /* modules */ = {isa = PBXFileReference; explicitFileType = folder; includeInIndex = 1; name = modules; path = ../../../modules; sourceTree = SOURCE_ROOT; };
 		48EFE0A30E8B6AF6007EB7F8 /* FetchItemJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FetchItemJob.h; sourceTree = "<group>"; };
 		48EFE0A50E8B6C39007EB7F8 /* FetchItemJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FetchItemJob.cpp; sourceTree = "<group>"; };
 		48EFE0D70E8B6EB1007EB7F8 /* mkdmg.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; path = mkdmg.sh; sourceTree = "<group>"; };
@@ -2170,6 +2174,97 @@
 			path = src;
 			sourceTree = "<group>";
 		};
+		48B006C30ECABFB0008141C2 /* windows */ = {
+			isa = PBXGroup;
+			children = (
+				444EACAC0BD0E57100C6D4A0 /* ConfigComponent.cpp */,
+				444EACAD0BD0E57100C6D4A0 /* Console.cpp */,
+				444EACB80BD0E57100C6D4A0 /* GameSettings.cpp */,
+				444EACA20BD0E57100C6D4A0 /* AboutWindow.cpp */,
+				444EACA30BD0E57100C6D4A0 /* AbstractWindow.cpp */,
+				444EACA40BD0E57100C6D4A0 /* ActionChoiceWindow.cpp */,
+				487029C80E80DCF900B66388 /* GameOverWindow.cpp */,
+				48389B8F0D86741F00AFAB66 /* GameSaveLoadWindow.cpp */,
+				48389B900D86741F00AFAB66 /* MainMenuLoadWindow.cpp */,
+				446BF4950C4533BD0013C214 /* CombatWindow.cpp */,
+				446BF49C0C4533BD0013C214 /* PropertiesWindow.cpp */,
+				44D814630BF7B5AD00534175 /* ProgressWindow.cpp */,
+				444EACA60BD0E57100C6D4A0 /* CharacterSheetWindow.cpp */,
+				444EACA70BD0E57100C6D4A0 /* CharacterStateWindow.cpp */,
+				444EACA80BD0E57100C6D4A0 /* CloseConfirmationWindow.cpp */,
+				444EACCB0BD0E57100C6D4A0 /* SubtitleWindow.cpp */,
+				444EACC90BD0E57100C6D4A0 /* SoundConfig.cpp */,
+				444EACAE0BD0E57100C6D4A0 /* ContainerContentWindow.cpp */,
+				444EACB10BD0E57100C6D4A0 /* DebugWindow.cpp */,
+				444EACB30BD0E57100C6D4A0 /* DialogWindow.cpp */,
+				444EACB50BD0E57100C6D4A0 /* GameLoggerWindow.cpp */,
+				444EACB60BD0E57100C6D4A0 /* GameObjectInfoWindow.cpp */,
+				444EACB90BD0E57100C6D4A0 /* InfoPopup.cpp */,
+				444EACBA0BD0E57100C6D4A0 /* InGameMenuWindow.cpp */,
+				444EACBC0BD0E57100C6D4A0 /* InventoryWindow.cpp */,
+				444EACBD0BD0E57100C6D4A0 /* ItemDragContainer.cpp */,
+				444EACBE0BD0E57100C6D4A0 /* JournalWindow.cpp */,
+				444EACC00BD0E57100C6D4A0 /* LogWindow.cpp */,
+				446BF4D50C453C1D0013C214 /* ItemDescriptionDragContainer.cpp */,
+				446BF49A0C4533BD0013C214 /* ItemIconDragContainer.cpp */,
+				444EACC10BD0E57100C6D4A0 /* MainMenuEngineWindow.cpp */,
+				444EACBF0BD0E57100C6D4A0 /* ListboxWrappedTextItem.cpp */,
+				444EACC20BD0E57100C6D4A0 /* MainMenuWindow.cpp */,
+				444EACC30BD0E57100C6D4A0 /* MessageWindow.cpp */,
+				444EACC50BD0E57100C6D4A0 /* ObjectDescriptionWindow.cpp */,
+				444EACC60BD0E57100C6D4A0 /* PlaylistWindow.cpp */,
+				444EACC70BD0E57100C6D4A0 /* RenderSystemConfigComponent.cpp */,
+				444EACCA0BD0E57100C6D4A0 /* SoundDriverConfigComponent.cpp */,
+				48B006C40ECAC05F008141C2 /* CharacterSelectionWindow.cpp */,
+			);
+			name = windows;
+			sourceTree = "<group>";
+		};
+		48B006C60ECAC097008141C2 /* windows */ = {
+			isa = PBXGroup;
+			children = (
+				444EACFE0BD0E58C00C6D4A0 /* AboutWindow.h */,
+				444EACFF0BD0E58C00C6D4A0 /* AbstractWindow.h */,
+				444EAD000BD0E58C00C6D4A0 /* ActionChoiceWindow.h */,
+				444EAD030BD0E58C00C6D4A0 /* CharacterSheetWindow.h */,
+				444EAD040BD0E58C00C6D4A0 /* CharacterStateWindow.h */,
+				444EAD050BD0E58C00C6D4A0 /* CloseConfirmationWindow.h */,
+				446BF4D10C453B9E0013C214 /* CombatWindow.h */,
+				444EAD0B0BD0E58C00C6D4A0 /* ContainerContentWindow.h */,
+				48389B970D86743900AFAB66 /* GameSaveLoadWindow.h */,
+				446BF4880C45335A0013C214 /* ItemDescriptionDragContainer.h */,
+				446BF4890C45335A0013C214 /* ItemIconDragContainer.h */,
+				44D8145F0BF7B58A00534175 /* ProgressWindow.h */,
+				444EAD090BD0E58C00C6D4A0 /* ConfigComponent.h */,
+				446BF48B0C45335A0013C214 /* PropertiesWindow.h */,
+				487029C60E80DCEA00B66388 /* GameOverWindow.h */,
+				48389B980D86743900AFAB66 /* MainMenuLoadWindow.h */,
+				444EAD0E0BD0E58C00C6D4A0 /* DebugWindow.h */,
+				444EAD100BD0E58C00C6D4A0 /* DialogWindow.h */,
+				444EAD120BD0E58C00C6D4A0 /* GameLoggerWindow.h */,
+				444EAD130BD0E58C00C6D4A0 /* GameObjectInfoWindow.h */,
+				444EAD150BD0E58C00C6D4A0 /* GameSettings.h */,
+				444EAD170BD0E58C00C6D4A0 /* InGameMenuWindow.h */,
+				444EAD190BD0E58C00C6D4A0 /* InventoryWindow.h */,
+				444EAD1A0BD0E58C00C6D4A0 /* ItemDragContainer.h */,
+				444EAD1C0BD0E58C00C6D4A0 /* ListboxWrappedTextItem.h */,
+				444EAD1E0BD0E58C00C6D4A0 /* MainMenuEngineWindow.h */,
+				444EAD1F0BD0E58C00C6D4A0 /* MainMenuWindow.h */,
+				444EAD200BD0E58C00C6D4A0 /* MessageWindow.h */,
+				444EAD220BD0E58C00C6D4A0 /* ObjectDescriptionWindow.h */,
+				444EAD230BD0E58C00C6D4A0 /* PlaylistWindow.h */,
+				444EAD240BD0E58C00C6D4A0 /* RenderSystemConfigComponent.h */,
+				444EAD260BD0E58C00C6D4A0 /* SoundConfig.h */,
+				444EAD270BD0E58C00C6D4A0 /* SoundDriverConfigComponent.h */,
+				444EAD280BD0E58C00C6D4A0 /* SubtitleWindow.h */,
+				444EAD0A0BD0E58C00C6D4A0 /* Console.h */,
+				444EAD1B0BD0E58C00C6D4A0 /* JournalWindow.h */,
+				444EAD1D0BD0E58C00C6D4A0 /* LogWindow.h */,
+				48B006C70ECAC11D008141C2 /* CharacterSelectionWindow.h */,
+			);
+			name = windows;
+			sourceTree = "<group>";
+		};
 		48B0B0230E6533940023B198 /* Headers */ = {
 			isa = PBXGroup;
 			children = (
@@ -2235,55 +2330,19 @@
 		48EFE0880E8B6822007EB7F8 /* Headers */ = {
 			isa = PBXGroup;
 			children = (
-				44D8145F0BF7B58A00534175 /* ProgressWindow.h */,
-				444EACFE0BD0E58C00C6D4A0 /* AboutWindow.h */,
-				444EACFF0BD0E58C00C6D4A0 /* AbstractWindow.h */,
-				444EAD000BD0E58C00C6D4A0 /* ActionChoiceWindow.h */,
+				48B006C60ECAC097008141C2 /* windows */,
 				444EAD010BD0E58C00C6D4A0 /* CeGuiHelper.h */,
-				444EAD030BD0E58C00C6D4A0 /* CharacterSheetWindow.h */,
 				4404DA850C48D037007B4657 /* stdinc.h */,
 				446BF4D00C453B9E0013C214 /* CombatControlState.h */,
-				446BF4D10C453B9E0013C214 /* CombatWindow.h */,
 				446BF4840C45335A0013C214 /* ControlState.h */,
 				446BF4850C45335A0013C214 /* CutsceneControlState.h */,
 				446BF4860C45335A0013C214 /* DialogControlState.h */,
 				446BF4870C45335A0013C214 /* FreeflightControlState.h */,
-				446BF4880C45335A0013C214 /* ItemDescriptionDragContainer.h */,
-				446BF4890C45335A0013C214 /* ItemIconDragContainer.h */,
 				446BF48A0C45335A0013C214 /* MovementControlState.h */,
-				446BF48B0C45335A0013C214 /* PropertiesWindow.h */,
-				487029C60E80DCEA00B66388 /* GameOverWindow.h */,
 				48389B960D86743900AFAB66 /* CombatGui.h */,
-				48389B970D86743900AFAB66 /* GameSaveLoadWindow.h */,
-				48389B980D86743900AFAB66 /* MainMenuLoadWindow.h */,
-				444EAD040BD0E58C00C6D4A0 /* CharacterStateWindow.h */,
-				444EAD050BD0E58C00C6D4A0 /* CloseConfirmationWindow.h */,
 				444EAD070BD0E58C00C6D4A0 /* CommandMapper.h */,
-				444EAD090BD0E58C00C6D4A0 /* ConfigComponent.h */,
-				444EAD0A0BD0E58C00C6D4A0 /* Console.h */,
-				444EAD0B0BD0E58C00C6D4A0 /* ContainerContentWindow.h */,
-				444EAD0E0BD0E58C00C6D4A0 /* DebugWindow.h */,
-				444EAD100BD0E58C00C6D4A0 /* DialogWindow.h */,
-				444EAD120BD0E58C00C6D4A0 /* GameLoggerWindow.h */,
-				444EAD130BD0E58C00C6D4A0 /* GameObjectInfoWindow.h */,
-				444EAD150BD0E58C00C6D4A0 /* GameSettings.h */,
 				444EAD160BD0E58C00C6D4A0 /* InfoPopup.h */,
-				444EAD170BD0E58C00C6D4A0 /* InGameMenuWindow.h */,
 				444EAD180BD0E58C00C6D4A0 /* InputManager.h */,
-				444EAD190BD0E58C00C6D4A0 /* InventoryWindow.h */,
-				444EAD1A0BD0E58C00C6D4A0 /* ItemDragContainer.h */,
-				444EAD1B0BD0E58C00C6D4A0 /* JournalWindow.h */,
-				444EAD1C0BD0E58C00C6D4A0 /* ListboxWrappedTextItem.h */,
-				444EAD1D0BD0E58C00C6D4A0 /* LogWindow.h */,
-				444EAD1E0BD0E58C00C6D4A0 /* MainMenuEngineWindow.h */,
-				444EAD1F0BD0E58C00C6D4A0 /* MainMenuWindow.h */,
-				444EAD200BD0E58C00C6D4A0 /* MessageWindow.h */,
-				444EAD220BD0E58C00C6D4A0 /* ObjectDescriptionWindow.h */,
-				444EAD230BD0E58C00C6D4A0 /* PlaylistWindow.h */,
-				444EAD240BD0E58C00C6D4A0 /* RenderSystemConfigComponent.h */,
-				444EAD260BD0E58C00C6D4A0 /* SoundConfig.h */,
-				444EAD270BD0E58C00C6D4A0 /* SoundDriverConfigComponent.h */,
-				444EAD280BD0E58C00C6D4A0 /* SubtitleWindow.h */,
 				444EAD290BD0E58C00C6D4A0 /* UiPrerequisites.h */,
 				444EAD2A0BD0E58C00C6D4A0 /* UiSubsystem.h */,
 				444EAD2B0BD0E58C00C6D4A0 /* WindowFactory.h */,
@@ -2298,58 +2357,21 @@
 		48EFE0890E8B6900007EB7F8 /* Source */ = {
 			isa = PBXGroup;
 			children = (
-				444EACC90BD0E57100C6D4A0 /* SoundConfig.cpp */,
-				444EACCA0BD0E57100C6D4A0 /* SoundDriverConfigComponent.cpp */,
-				444EACCB0BD0E57100C6D4A0 /* SubtitleWindow.cpp */,
+				48B006C30ECABFB0008141C2 /* windows */,
 				444EACCC0BD0E57100C6D4A0 /* UiSubsystem.cpp */,
 				444EACCD0BD0E57100C6D4A0 /* WindowFactory.cpp */,
 				444EACCE0BD0E57100C6D4A0 /* WindowFadeJob.cpp */,
 				444EACCF0BD0E57100C6D4A0 /* WindowManager.cpp */,
-				487029C80E80DCF900B66388 /* GameOverWindow.cpp */,
 				48389B8E0D86741F00AFAB66 /* CombatGui.cpp */,
-				48389B8F0D86741F00AFAB66 /* GameSaveLoadWindow.cpp */,
-				48389B900D86741F00AFAB66 /* MainMenuLoadWindow.cpp */,
 				48389B910D86741F00AFAB66 /* stdinc.cpp */,
-				446BF4D50C453C1D0013C214 /* ItemDescriptionDragContainer.cpp */,
 				446BF4940C4533BD0013C214 /* CombatControlState.cpp */,
-				446BF4950C4533BD0013C214 /* CombatWindow.cpp */,
 				446BF4960C4533BD0013C214 /* ControlState.cpp */,
 				446BF4970C4533BD0013C214 /* CutsceneControlState.cpp */,
 				446BF4980C4533BD0013C214 /* DialogControlState.cpp */,
 				446BF4990C4533BD0013C214 /* FreeflightControlState.cpp */,
-				446BF49A0C4533BD0013C214 /* ItemIconDragContainer.cpp */,
 				446BF49B0C4533BD0013C214 /* MovementControlState.cpp */,
-				446BF49C0C4533BD0013C214 /* PropertiesWindow.cpp */,
-				44D814630BF7B5AD00534175 /* ProgressWindow.cpp */,
-				444EACA20BD0E57100C6D4A0 /* AboutWindow.cpp */,
-				444EACA30BD0E57100C6D4A0 /* AbstractWindow.cpp */,
-				444EACA40BD0E57100C6D4A0 /* ActionChoiceWindow.cpp */,
-				444EACA60BD0E57100C6D4A0 /* CharacterSheetWindow.cpp */,
-				444EACA70BD0E57100C6D4A0 /* CharacterStateWindow.cpp */,
-				444EACA80BD0E57100C6D4A0 /* CloseConfirmationWindow.cpp */,
 				444EACAA0BD0E57100C6D4A0 /* CommandMapper.cpp */,
-				444EACAC0BD0E57100C6D4A0 /* ConfigComponent.cpp */,
-				444EACAD0BD0E57100C6D4A0 /* Console.cpp */,
-				444EACAE0BD0E57100C6D4A0 /* ContainerContentWindow.cpp */,
-				444EACB10BD0E57100C6D4A0 /* DebugWindow.cpp */,
-				444EACB30BD0E57100C6D4A0 /* DialogWindow.cpp */,
-				444EACB50BD0E57100C6D4A0 /* GameLoggerWindow.cpp */,
-				444EACB60BD0E57100C6D4A0 /* GameObjectInfoWindow.cpp */,
-				444EACB80BD0E57100C6D4A0 /* GameSettings.cpp */,
-				444EACB90BD0E57100C6D4A0 /* InfoPopup.cpp */,
-				444EACBA0BD0E57100C6D4A0 /* InGameMenuWindow.cpp */,
 				444EACBB0BD0E57100C6D4A0 /* InputManager.cpp */,
-				444EACBC0BD0E57100C6D4A0 /* InventoryWindow.cpp */,
-				444EACBD0BD0E57100C6D4A0 /* ItemDragContainer.cpp */,
-				444EACBE0BD0E57100C6D4A0 /* JournalWindow.cpp */,
-				444EACBF0BD0E57100C6D4A0 /* ListboxWrappedTextItem.cpp */,
-				444EACC00BD0E57100C6D4A0 /* LogWindow.cpp */,
-				444EACC10BD0E57100C6D4A0 /* MainMenuEngineWindow.cpp */,
-				444EACC20BD0E57100C6D4A0 /* MainMenuWindow.cpp */,
-				444EACC30BD0E57100C6D4A0 /* MessageWindow.cpp */,
-				444EACC50BD0E57100C6D4A0 /* ObjectDescriptionWindow.cpp */,
-				444EACC60BD0E57100C6D4A0 /* PlaylistWindow.cpp */,
-				444EACC70BD0E57100C6D4A0 /* RenderSystemConfigComponent.cpp */,
 			);
 			name = Source;
 			path = src;
@@ -2832,6 +2854,7 @@
 				48389B9C0D86743900AFAB66 /* MainMenuLoadWindow.h in Headers */,
 				48389B9D0D86743900AFAB66 /* UiMessages.h in Headers */,
 				487029C70E80DCEA00B66388 /* GameOverWindow.h in Headers */,
+				48B006C80ECAC11D008141C2 /* CharacterSelectionWindow.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3427,6 +3450,7 @@
 				48389B940D86741F00AFAB66 /* MainMenuLoadWindow.cpp in Sources */,
 				48389B950D86741F00AFAB66 /* stdinc.cpp in Sources */,
 				487029C90E80DCF900B66388 /* GameOverWindow.cpp in Sources */,
+				48B006C50ECAC05F008141C2 /* CharacterSelectionWindow.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};



From blakharaz at mail.berlios.de  Tue Nov 25 21:52:03 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 25 Nov 2008 21:52:03 +0100
Subject: [Dsa-hl-svn] r4608 - rl/trunk/engine/ui/src
Message-ID: <200811252052.mAPKq3op008952@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-25 21:52:01 +0100 (Tue, 25 Nov 2008)
New Revision: 4608

Modified:
   rl/trunk/engine/ui/src/CharacterStateWindow.cpp
Log:
Fix character selection window

Modified: rl/trunk/engine/ui/src/CharacterStateWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterStateWindow.cpp	2008-11-24 22:09:24 UTC (rev 4607)
+++ rl/trunk/engine/ui/src/CharacterStateWindow.cpp	2008-11-25 20:52:01 UTC (rev 4608)
@@ -1,118 +1,134 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include <boost/bind.hpp>
-#include "UiPrerequisites.h"
-
-#include "DsaManager.h"
-#include "Creature.h"
-#include "InputManager.h"
-#include "Talent.h"
-
-#include "CharacterStateWindow.h"
-
-using namespace CEGUI;
-using namespace Ogre;
-
-
-namespace rl {
-
-CharacterStateWindow::CharacterStateWindow()
-: AbstractWindow("characterstatewindow.xml", WIT_NONE, false),
-	mCharacter(NULL)
-{
-	mLP = getProgressBar("CharacterStateWindow/LP");
-	mAP = getProgressBar("CharacterStateWindow/AP");
-	mAU = getProgressBar("CharacterStateWindow/AU");
-	mName = getWindow("CharacterStateWindow/Name");
-}
-
-CharacterStateWindow::~CharacterStateWindow()
-{
-    if (mCharacter != NULL)
-		mCharacter->removeObjectStateChangeListener(this);
-}
-
-void CharacterStateWindow::setCharacter(Creature* person)
-{
-	if (mCharacter != NULL)
-		mCharacter->removeObjectStateChangeListener(this);
-
-	mCharacter = person;
-    if(mCharacter)
-        mCharacter->addObjectStateChangeListener(this);
-	update();
-}
-
-void CharacterStateWindow::update()
-{
-	if (!isVisible())
-		return;
-	if (mCharacter == NULL)
-		return;
-
-	mName->setText(mCharacter->getName());
-
-	float lep;
-	if (mCharacter->getLeMax() <= 0)
-		lep = 0.0;
-	else
-		lep = (float)mCharacter->getLe() / (float)mCharacter->getLeMax();
-	mLP->setProgress(lep);
-
-	float au;
-	if (mCharacter->getAuMax() <= 0)
-		au = 0.0;
-	else
-		au = (float)mCharacter->getAu() / (float)mCharacter->getAuMax();
-	mAU->setProgress(au);
-
-	if (!mCharacter->isMagic())
-	{
-		if (mAP->isVisible())
-			mAP->setVisible(false);
-		return;
-	}
-
-	if (!mAP->isVisible())
-		mAP->setVisible(true);
-
-	float asp;
-	if (mCharacter->getAeMax() <= 0)
-		asp = 0.0;
-	else
-		asp = (float)mCharacter->getAe() / (float)mCharacter->getAeMax();
-	mAP->setProgress(asp);
-
-}
-
-void CharacterStateWindow::objectStateChanged(ObjectStateChangeEvent* evt)
-{
-	update();
-}
-
-void CharacterStateWindow::setVisible(bool visible, bool destroyAfterHide)
-{
-	AbstractWindow::setVisible(visible, destroyAfterHide);
-	if (visible)
-	{
-		update();
-	}
-}
-
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include <boost/bind.hpp>
+#include "UiPrerequisites.h"
+
+#include "DsaManager.h"
+#include "Creature.h"
+#include "InputManager.h"
+#include "Talent.h"
+
+#include "CharacterStateWindow.h"
+
+using namespace CEGUI;
+using namespace Ogre;
+
+
+namespace rl {
+
+CharacterStateWindow::CharacterStateWindow()
+: AbstractWindow("characterstatewindow.xml", WIT_NONE, false),
+	mCharacter(NULL)
+{
+	mLP = getProgressBar("CharacterStateWindow/LP");
+	mAP = getProgressBar("CharacterStateWindow/AP");
+	mAU = getProgressBar("CharacterStateWindow/AU");
+	mName = getWindow("CharacterStateWindow/Name");
+}
+
+CharacterStateWindow::~CharacterStateWindow()
+{
+    if (mCharacter != NULL)
+		mCharacter->removeObjectStateChangeListener(this);
+}
+
+void CharacterStateWindow::setCharacter(Creature* person)
+{
+	if (mCharacter != NULL)
+		mCharacter->removeObjectStateChangeListener(this);
+
+	mCharacter = person;
+    if(mCharacter)
+        mCharacter->addObjectStateChangeListener(this);
+	update();
+}
+
+void CharacterStateWindow::update()
+{
+	if (!isVisible() || mCharacter == NULL)
+    {
+		return;
+    }
+        
+	mName->setText(mCharacter->getName());
+
+	float lep;
+	if (mCharacter->getLeMax() <= 0)
+    {
+		lep = 0.0;        
+    }
+	else
+    {
+		lep = (float)mCharacter->getLe() / (float)mCharacter->getLeMax();        
+    }
+	mLP->setProgress(lep);
+
+	float au;
+	if (mCharacter->getAuMax() <= 0)
+    {
+		au = 0.0;        
+    }
+	else
+    {
+		au = (float)mCharacter->getAu() / (float)mCharacter->getAuMax();        
+    }
+	mAU->setProgress(au);
+
+	if (!mCharacter->isMagic())
+	{
+		if (mAP->isVisible()) 
+        {
+			mAP->setVisible(false);            
+        }
+	}
+    else 
+    {
+     	if (!mAP->isVisible()) 
+        {
+            mAP->setVisible(true);            
+        }
+        
+        float asp;
+        if (mCharacter->getAeMax() <= 0)
+        {
+            asp = 0.0;
+        }
+        else
+        {
+            asp = (float)mCharacter->getAe() / (float)mCharacter->getAeMax();
+        }
+        mAP->setProgress(asp);        
+    }
+}
+
+void CharacterStateWindow::objectStateChanged(ObjectStateChangeEvent* evt)
+{
+	update();
+}
+
+void CharacterStateWindow::setVisible(bool visible, bool destroyAfterHide)
+{
+	AbstractWindow::setVisible(visible, destroyAfterHide);
+	if (visible)
+	{
+		update();
+	}
+}
+
+
+}



From blakharaz at mail.berlios.de  Tue Nov 25 21:52:10 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 25 Nov 2008 21:52:10 +0100
Subject: [Dsa-hl-svn] r4609 - modules/common/gui/windows
Message-ID: <200811252052.mAPKqA2v008963@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-25 21:52:09 +0100 (Tue, 25 Nov 2008)
New Revision: 4609

Modified:
   modules/common/gui/windows/characterselectionwindow_character.xml
Log:
Fix character selection window

Modified: modules/common/gui/windows/characterselectionwindow_character.xml
===================================================================
--- modules/common/gui/windows/characterselectionwindow_character.xml	2008-11-25 20:52:01 UTC (rev 4608)
+++ modules/common/gui/windows/characterselectionwindow_character.xml	2008-11-25 20:52:09 UTC (rev 4609)
@@ -3,22 +3,22 @@
 	        <Property Name="UnifiedSize" Value="{{0,64},{0,100}}" />
 	        
 			<Window Type="RastullahLook/StaticImage" Name="CharacterSelectionWindow/Character/Picture">
-				<Property Name="UnifiedPosition" Value="{{0,0},{0,14}}" />
+				<Property Name="UnifiedPosition" Value="{{0,0},{0,16}}" />
 				<Property Name="UnifiedSize" Value="{{1,0},{0,64}}" />
 				<Property Name="FrameEnabled" Value="False"/>
 			</Window>
 
 			<Window Type="RastullahLook/StaticText" Name="CharacterSelectionWindow/Character/Name">
-				<Property Name="UnifiedPosition" Value="{{0,0},{0,80}}" />
+				<Property Name="UnifiedPosition" Value="{{0,0},{0,0}}" />
 				<Property Name="UnifiedSize" Value="{{1,0},{0,15}}" />
 				<Property Name="FrameEnabled" Value="False"/>
 			</Window>
 	
 			<Window Type="RastullahLook/StatusBar" Name="CharacterSelectionWindow/Character/LP">
-				<Property Name="UnifiedPosition" Value="{{0,0},{0,0}}" />
+				<Property Name="UnifiedPosition" Value="{{0,0},{0,80}}" />
 				<Property Name="UnifiedSize" Value="{{1,0},{0,13}}" />
 				<Property Name="CurrentProgress" Value="100"/>
-				<Property Name="StatusColour" Value="FFFF0000"/>
+				<Property Name="StatusColour" Value="FFFF007F"/>
 			</Window>
 		</Window>
 </GUILayout>
\ No newline at end of file



From blakharaz at mail.berlios.de  Tue Nov 25 21:52:44 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Tue, 25 Nov 2008 21:52:44 +0100
Subject: [Dsa-hl-svn] r4610 - modules/regressiontest/scripts
Message-ID: <200811252052.mAPKqicM008990@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-25 21:52:42 +0100 (Tue, 25 Nov 2008)
New Revision: 4610

Modified:
   modules/regressiontest/scripts/MergeableMeshTest.rb
Log:
Fix tes

Modified: modules/regressiontest/scripts/MergeableMeshTest.rb
===================================================================
--- modules/regressiontest/scripts/MergeableMeshTest.rb	2008-11-25 20:52:09 UTC (rev 4609)
+++ modules/regressiontest/scripts/MergeableMeshTest.rb	2008-11-25 20:52:42 UTC (rev 4610)
@@ -55,11 +55,11 @@
         test_obj4.getInventory().dropItem("Armor")
 
         $SCRIPT.log("Give swords to all creatures.");
-        sword2 = $GOM.createGameObject("shortsword");
+        sword2 = $GOM.createGameObject("Kurzschwert");
         test_obj2.getInventory().hold(sword2, "Right Hand");
-        sword3 = $GOM.createGameObject("shortsword");
+        sword3 = $GOM.createGameObject("Kurzschwert");
         test_obj3.getInventory().hold(sword3, "Right Hand");
-        sword4 = $GOM.createGameObject("shortsword");
+        sword4 = $GOM.createGameObject("Kurzschwert");
         test_obj4.getInventory().hold(sword4, "Right Hand");
     end
 



From chrber at mail.berlios.de  Wed Nov 26 14:52:25 2008
From: chrber at mail.berlios.de (chrber at mail.berlios.de)
Date: Wed, 26 Nov 2008 14:52:25 +0100
Subject: [Dsa-hl-svn] r4611 - in rl/trunk: . cmake plugins
	plugins/fmod4driver
Message-ID: <200811261352.mAQDqP4h026776@sheep.berlios.de>

Author: chrber
Date: 2008-11-26 14:52:22 +0100 (Wed, 26 Nov 2008)
New Revision: 4611

Added:
   rl/trunk/CMakeLists.txt
   rl/trunk/cmake/
   rl/trunk/cmake/FindCEGUI.cmake
   rl/trunk/cmake/FindFMODEx.cmake
   rl/trunk/cmake/FindOGRE.cmake
   rl/trunk/plugins/CMakeLists.txt
   rl/trunk/plugins/fmod4driver/CMakeLists.txt
Log:
First incarnation of new cmake based build system


Added: rl/trunk/CMakeLists.txt
===================================================================
--- rl/trunk/CMakeLists.txt	2008-11-25 20:52:42 UTC (rev 4610)
+++ rl/trunk/CMakeLists.txt	2008-11-26 13:52:22 UTC (rev 4611)
@@ -0,0 +1,49 @@
+PROJECT(RL)
+
+CMAKE_MINIMUM_REQUIRED(VERSION 2.6)
+
+# Cmake handles escaping of preprocessor directives
+CMAKE_POLICY(SET CMP0005 NEW)
+
+# Include required cmake macros
+INCLUDE(FeatureSummary)
+
+# Add directory with RL's own macro definitions
+# (checked before ${CMAKE_ROOT}/Modules)
+SET(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake)
+
+# Set convenience variables for Rastullah's own include directories
+SET(RL_AI_INCLUDE_DIR ${CMAKE_SOURCE_DIR}/engine/ai/include INTERNAL)
+SET(RL_COMMON_INCLUDE_DIR ${CMAKE_SOURCE_DIR}/engine/common/include INTERNAL)
+SET(RL_CORE_INCLUDE_DIR ${CMAKE_SOURCE_DIR}/engine/core/include INTERNAL)
+SET(RL_RULES_INCLUDE_DIR ${CMAKE_SOURCE_DIR}/engine/rules/include INTERNAL)
+SET(RL_SCRIPT_INCLUDE_DIR ${CMAKE_SOURCE_DIR}/engine/script/include INTERNAL)
+SET(RL_UI_INCLUDE_DIR ${CMAKE_SOURCE_DIR}/engine/ui/include INTERNAL)
+
+# Check for required components
+FIND_PACKAGE(OGRE 1.6 REQUIRED)
+FIND_PACKAGE(CEGUI REQUIRED)
+FIND_PACKAGE(Boost 1.34 REQUIRED filesystem)
+FIND_PACKAGE(SWIG REQUIRED)
+IF (NOT SWIG_DIR MATCHES -rl$)
+	SET_FEATURE_INFO(SWIG "" "" "You use an unsupported version of SWIG.")
+ENDIF(NOT SWIG_DIR MATCHES -rl$)
+
+# Path options
+SET(BINDIR "bin" CACHE STRING "Where to install binaries")
+SET(DATAROOTDIR "${CMAKE_INSTALL_PREFIX}/share" CACHE STRING "Sets the root of data directories to a non-default location")
+SET(DATADIRNAME "rastullah" CACHE STRING "change the name of the directory for the read-only architecture-independent game data")
+
+# Game options
+SET(ENABLE_FMOD4 "Enable FMOD 4.xx (FMODex) sound support" ON)
+SET(ENABLE_OPENAL "Enable OpenAL sound support (unsupported)" OFF)
+
+# Handle options
+SET(DATADIR ${DATAROOTDIR}/${DATADIRNAME})
+ADD_DEFINITIONS(-DDATADIR=${DATADIR})
+
+# Include subdirectories
+ADD_SUBDIRECTORY(engine)
+ADD_SUBDIRECTORY(plugins)
+
+PRINT_ENABLED_FEATURES()
\ No newline at end of file

Added: rl/trunk/cmake/FindCEGUI.cmake
===================================================================
--- rl/trunk/cmake/FindCEGUI.cmake	2008-11-25 20:52:42 UTC (rev 4610)
+++ rl/trunk/cmake/FindCEGUI.cmake	2008-11-26 13:52:22 UTC (rev 4611)
@@ -0,0 +1,124 @@
+# - Find CEGUI includes and library
+#
+# This module defines
+#  CEGUI_INCLUDE_DIRS
+#  CEGUI_LIBRARIES, the libraries to link against to use CEGUI.
+#  CEGUI_LIBRARY_DIRS, the location of the libraries
+#  CEGUI_FOUND, If false, do not try to use CEGUI
+#
+# Copyright ? 2007-2008, Matt Williams
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+IF (CEGUI_LIBRARIES AND CEGUI_INCLUDE_DIRS)
+	SET(CEGUI_FIND_QUIETLY TRUE)
+ENDIF (CEGUI_LIBRARIES AND CEGUI_INCLUDE_DIRS)
+
+#SET(OGRESDK $ENV{OGRE_HOME})
+#STRING(REGEX REPLACE "[\\]" "/" OGRESDK "${OGRESDK}")
+FILE(TO_CMAKE_PATH "$ENV{OGRE_HOME}" OGRESDK)
+SET(CEGUI_INCLUDE_SEARCH_DIRS
+	${INCLUDE_SEARCH_DIRS}
+	${CMAKE_LIBRARY_PATH}
+	/usr/include
+	/usr/local/include
+	/usr/include/CEGUI
+	/usr/local/include/CEGUI
+	/opt/include/CEGUI
+	/opt/CEGUI/include
+	$ENV{OGRE_HOME}/samples/CEGUI
+	$ENV{OGRE_HOME}/Dependencies/include
+	$ENV{OGRE_HOME}/Dependencies/include/CEGUI
+	CACHE STRING ""
+)
+
+SET(CEGUI_LIBRARY_SEARCH_DIRS
+	${LIBRARY_SEARCH_DIRS}
+	${CMAKE_LIBRARY_PATH}
+	/usr/lib
+	/usr/lib64
+	/usr/local/lib
+	/usr/local/lib64
+	/opt/lib
+	/opt/lib64
+	/opt/CEGUI/lib
+	/opt/CEGUI/lib64
+	$ENV{OGRE_HOME}/lib
+	$ENV{OGRE_HOME}/lib64
+	CACHE STRING ""
+)
+
+IF (WIN32) #Windows
+	MESSAGE(STATUS "Looking for CEGUI")
+	FIND_PATH(CEGUI_INCLUDE_DIRS CEGUI.h ${CEGUI_INCLUDE_SEARCH_DIRS})
+	FIND_LIBRARY(CEGUI_LIBRARIES debug CEGUIBase_d optimized CEGUIBase PATHS ${CEGUI_LIBRARY_SEARCH_DIRS})
+	
+# 	SET(OGRESOURCE $ENV{OGRE_NEW})
+# 	IF (OGRESDK)
+# 		MESSAGE(STATUS "Using CEGUI in OGRE SDK")
+# 		SET(OGRESDK $ENV{OGRE_HOME})
+# 		STRING(REGEX REPLACE "[\\]" "/" OGRESDK "${OGRESDK}" )
+# 		SET(CEGUI_INCLUDE_DIRS ${OGRESDK}/include/CEGUI)
+# 		SET(CEGUI_LIBRARY_DIRS ${OGRESDK}/lib)
+# 		SET(CEGUI_LIBRARIES debug CEGUIBase_d optimized CEGUIBase)
+# 	ELSEIF (OGRESOURCE)
+# 		MESSAGE(STATUS "Using CEGUI in OGRE dependencies")
+# 		SET(CEGUI_INCLUDE_DIRS C:/ogrenew/Dependencies/include C:/ogrenew/Dependencies/include/CEGUI)
+# 		SET(CEGUI_LIBRARY_DIRS C:/ogrenew/Dependencies/lib/Release C:/ogrenew/Dependencies/lib/Debug)
+# 		SET(CEGUI_LIBRARIES debug CEGUIBase_d optimized CEGUIBase)
+# 	ELSE (OGRESDK)
+# 		IF (NOT DEPENDENCIES_PATH)
+# 			MESSAGE(STATUS "Please set DEPENDENCIES_PATH (the directory containing 'common' and 'dependencies')")
+# 		ELSE (NOT DEPENDENCIES_PATH)
+# 			SET(CEGUI_INCLUDE_DIRS ${DEPENDENCIES_PATH}/dependencies/Ogre/CEGUI)
+# 			SET(CEGUI_LIBRARIES optimized CEGUIBase debug CEGUIBase_d)
+# 			SET(CEGUI_LIBRARY_DIRS optimized ${DEPENDENCIES_PATH}/dependencies/lib/release debug ${DEPENDENCIES_PATH}/dependencies/lib/debug)
+# 		ENDIF (NOT DEPENDENCIES_PATH)
+# 	ENDIF (OGRESDK)
+ELSE (WIN32) #Unix
+	SET(CEGUI_INCLUDE_DIRS ${CEGUI_INCLUDE_DIRSS})
+	SET(CEGUI_LIBRARY_DIRS ${CEGUI_LIBDIR})
+	SET(CEGUI_LIBRARIES ${CEGUI_LIBRARIES})
+
+	CMAKE_MINIMUM_REQUIRED(VERSION 2.4.7 FATAL_ERROR)
+	FIND_PACKAGE(PkgConfig)
+	IF(PKG_CONFIG_FOUND)
+		PKG_SEARCH_MODULE(CEGUI CEGUI)
+		SET(CEGUI_INCLUDE_DIRS ${CEGUI_INCLUDE_DIRS})
+		SET(CEGUI_LIBRARY_DIRS ${CEGUI_LIBDIR})
+		SET(CEGUI_LIBRARIES ${CEGUI_LIBRARIES} CACHE STRING "")
+	ENDIF(PKG_CONFIG_FOUND)
+	IF(NOT CEGUI_FOUND) #If PkgConfig couldn't find OGRE...
+		IF (NOT CEGUI_FIND_QUIETLY)
+			MESSAGE(STATUS " Manually searching for CEGUI")
+		ENDIF (NOT CEGUI_FIND_QUIETLY)
+		FIND_PATH(CEGUI_INCLUDE_DIRS Ogre.h ${CEGUI_INCLUDE_SEARCH_DIRS})
+		FIND_LIBRARY(CEGUI_LIBRARIES CEGUIBase PATHS ${CEGUI_LIBRARY_SEARCH_DIRS})
+	ENDIF(NOT CEGUI_FOUND)
+ENDIF (WIN32)
+
+#Do some preparation
+SEPARATE_ARGUMENTS(CEGUI_INCLUDE_DIRS)
+SEPARATE_ARGUMENTS(CEGUI_LIBRARIES)
+
+SET(CEGUI_INCLUDE_DIRS ${CEGUI_INCLUDE_DIRS})
+SET(CEGUI_LIBRARIES ${CEGUI_LIBRARIES})
+SET(CEGUI_LIBRARY_DIRS ${CEGUI_LIBRARY_DIRS})
+
+MARK_AS_ADVANCED(CEGUI_INCLUDE_DIRS CEGUI_LIBRARIES CEGUI_LIBRARY_DIRS)
+
+IF (CEGUI_INCLUDE_DIRS AND CEGUI_LIBRARIES)
+	SET(CEGUI_FOUND TRUE)
+ENDIF (CEGUI_INCLUDE_DIRS AND CEGUI_LIBRARIES)
+
+IF (CEGUI_FOUND)
+	IF (NOT CEGUI_FIND_QUIETLY)
+		MESSAGE(STATUS "  libraries : ${CEGUI_LIBRARIES} from ${CEGUI_LIBRARY_DIRS}")
+		MESSAGE(STATUS "  includes  : ${CEGUI_INCLUDE_DIRS}")
+	ENDIF (NOT CEGUI_FIND_QUIETLY)
+ELSE (CEGUI_FOUND)
+	IF (CEGUI_FIND_REQUIRED)
+		MESSAGE(FATAL_ERROR "Could not find CEGUI. Make sure you have the CEGUI development headers are installed. Otherwise, try setting LIBRARY_SEARCH_DIRS and INCLUDE_SEARCH_DIRS to the place CEGUI was installed with -DLIBRARY_SEARCH_DIRS=<path/to/lib> -DINCLUDE_SEARCH_DIRS=<path/to/include>")
+	ENDIF (CEGUI_FIND_REQUIRED)
+ENDIF (CEGUI_FOUND)

Added: rl/trunk/cmake/FindFMODEx.cmake
===================================================================
--- rl/trunk/cmake/FindFMODEx.cmake	2008-11-25 20:52:42 UTC (rev 4610)
+++ rl/trunk/cmake/FindFMODEx.cmake	2008-11-26 13:52:22 UTC (rev 4611)
@@ -0,0 +1,122 @@
+# Find FMODEx
+#
+# This module defines
+# FMODEX_FOUND
+# FMODEX_INCLUDE_DIR
+# FMODEX_LIBRARY
+#
+# Based on the CMakeLists.txt of zdoom and FindFMOD.cmake of openfrag
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+# On a new cmake run, we do not need to be verbose
+IF(FMODEX_INCLUDE_DIR AND FMODEX_LIBRARY)
+	SET(FMODEX_FIND_QUIETLY TRUE)
+ENDIF(FMODEX_INCLUDE_DIR AND FMODEX_LIBRARY)
+
+# Check for for 32/64 bit architecture
+IF(CMAKE_SIZEOF_VOID_P MATCHES "8")
+	SET(X64 64)
+ENDIF(CMAKE_SIZEOF_VOID_P MATCHES "8")
+
+IF(WIN32)
+	SET(FMODEX_INC_DIR_SUFFIXES PATH_SUFFIXES inc)
+	SET(FMODEX_LIB_DIR_SUFFIXES PATH_SUFFIXES lib)
+ELSE(WIN32)
+	SET(FMODEX_INCLUDE_SEARCH_DIRS
+	    /usr/include
+	    /usr/local/include
+	    /opt/fmodex/fmodex/include
+            /opt/include)
+	SET(FMODEX_LIBRARY_SEARCH_DIRS
+	    /usr/lib
+	    /usr/lib64
+	    /usr/local/lib
+	    /usr/local/lib64
+	    /opt/fmodex/lib
+	    /opt/fmodex/lib64)
+	SET(FMODEX_INC_DIR_SUFFIXES PATH_SUFFIXES fmodex)
+ENDIF(WIN32)
+
+# Decide on the name of the FMODEx library we want to use
+IF(NOT FMODEX_LIBRARY_NAME AND MSVC)
+	SET(FMODEX_LIBRARY_NAME fmodex${X64}_vc)
+ENDIF(NOT FMODEX_LIBRARY_NAME AND MSVC)
+
+IF(NOT FMODEX_LIBRARY_NAME AND BORLAND)
+	SET(FMODEX_LIBRARY_NAME fmodex${X64}_bc)
+ENDIF(NOT FMODEX_LIBRARY_NAME AND BORLAND)
+
+IF(NOT FMODEX_LIBRARY_NAME)
+	SET(FMODEX_LIBRARY_NAME fmodex${X64})
+ENDIF(NOT FMODEX_LIBRARY_NAME)
+
+IF (NOT FMODEX_FIND_QUIETLY)
+	MESSAGE(STATUS "Checking for FMODEx")
+ENDIF(NOT FMODEX_FIND_QUIETLY)
+
+# Search for header files and libraries
+FIND_PATH(FMODEX_INCLUDE_DIR fmod.h
+          PATHS ${FMODEX_INCLUDE_SEARCH_PATHS}
+          PATH_SUFFIXES ${FMODEX_INC_DIR_SUFFIXES})
+IF(FMODEX_INCLUDE_DIR)
+	IF (NOT FMODEX_FIND_QUIETLY)
+		MESSAGE(STATUS "  includes: ${FMODEX_INCLUDE_DIR}")
+	ENDIF(NOT FMODEX_FIND_QUIETLY)
+ELSE(FMODEX_INCLUDE_DIR)
+	MESSAGE(SEND_ERROR "FMODEx include files could not be found.")
+ENDIF(FMODEX_INCLUDE_DIR)
+
+FIND_LIBRARY(FMODEX_LIBRARY ${FMODEX_LIBRARY_NAME}
+             PATHS ${FMODEX_LIBRARY_SEARCH_DIRS}
+             PATH_SUFFIXES ${FMOD_LIB_DIR_SUFFIXES})
+IF(FMODEX_LIBRARY)
+	IF (NOT FMODEX_FIND_QUIETLY)
+		MESSAGE(STATUS "  libraries: ${FMODEX_LIBRARY}")
+	ENDIF(NOT FMODEX_FIND_QUIETLY)
+ELSE(FMODEX_LIBRARY)
+	MESSAGE(SEND_ERROR, "FMODex library could not be found.")
+ENDIF(FMODEX_LIBRARY)
+
+IF(FMODEX_INCLUDE_DIR AND FMODEX_LIBRARY)
+	SET(FMODEX_FOUND TRUE)
+ENDIF(FMODEX_INCLUDE_DIR AND FMODEX_LIBRARY)
+
+# Allow customisation of paths
+SET(FMODEX_INCLUDE_DIR ${FMODEX_INCLUDE_DIR})
+SET(FMODEX_LIBRARY ${FMODEX_LIBRARY})
+
+IF(FMODEX_INCLUDE_DIR)
+	# Extract the library version from the header file
+	SET(FMODEX_VERSION 0)
+	FILE(READ "${FMODEX_INCLUDE_DIR}/fmod.h"
+	     _FMODEX_FMOD_H_CONTENTS)
+	STRING(REGEX REPLACE ".*#define FMOD_VERSION    0x([0-9]+).*" "\\1"
+	       FMODEX_VERSION "${_FMODEX_FMOD_H_CONTENTS}")
+	IF(NOT "${FMODEX_VERSION}" STREQUAL 0)
+		MATH(EXPR FMODEX_MAJOR_VERSION "${FMODEX_VERSION} / 10000")
+		MATH(EXPR FMODEX_MINOR_VERSION "${FMODEX_VERSION} / 100 % 100")
+		MATH(EXPR FMODEX_PATCH_VERSION "${FMODEX_VERSION} % 100")
+		SET(FMODEX_VERSION "${FMODEX_MAJOR_VERSION}.${FMODEX_MINOR_VERSION}.${FMODEX_PATCH_VERSION}")
+	ENDIF(NOT "${FMODEX_VERSION}" STREQUAL 0)
+
+	# Compare installed and required version
+	IF(FMODEx_FIND_VERSION)
+		# Major and minor version are required
+		IF(NOT FMODEx_FIND_VERSION_MINOR)
+			MESSAGE(SEND_ERROR "When requesting a specific version of FMODEx , you must provide at least the major and minor version numbers, e.g., 4.20")
+		ENDIF(NOT FMODEx_FIND_VERSION_MINOR)
+
+		IF ("${FMOD_VERSION}" VERSION_LESS "${FMODEx_FIND_VERSION}")
+			SET(FMODEX_FOUND FALSE)
+			MESSAGE(STATUS "Detected version of FMODEx ${FMODEX_VERSION} is too old. At least version ${FMODEx_FIND_VERSION} is required.")
+		ENDIF("${FMOD_VERSION}" VERSION_LESS "${FMODEx_FIND_VERSION}")
+	ENDIF(FMODEx_FIND_VERSION)
+ENDIF(FMODEX_INCLUDE_DIR)
+
+IF(FMODEX_FOUND)
+	IF(NOT FMODEX_FIND_QUIETLY)
+		MESSAGE(STATUS "  version: ${FMODEX_VERSION}")
+	ENDIF(NOT FMODEX_FIND_QUIETLY)
+ENDIF(FMODEX_FOUND)
\ No newline at end of file

Added: rl/trunk/cmake/FindOGRE.cmake
===================================================================
--- rl/trunk/cmake/FindOGRE.cmake	2008-11-25 20:52:42 UTC (rev 4610)
+++ rl/trunk/cmake/FindOGRE.cmake	2008-11-26 13:52:22 UTC (rev 4611)
@@ -0,0 +1,96 @@
+# Find OGRE includes and library
+#
+# This module defines
+#  OGRE_INCLUDE_DIRS
+#  OGRE_LIBRARIES, the libraries to link against to use OGRE.
+#  OGRE_LIBRARY_DIRS, the location of the libraries
+#  OGRE_FOUND, If false, do not try to use OGRE
+#
+# Copyright ? 2007-2008, Matt Williams
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+IF (OGRE_LIBRARIES AND OGRE_INCLUDE_DIRS)
+	SET(OGRE_FIND_QUIETLY TRUE) # Already in cache, be silent
+ENDIF (OGRE_LIBRARIES AND OGRE_INCLUDE_DIRS)
+
+#Set the library and include search paths
+#SET(OGRESDK $ENV{OGRE_HOME})
+#STRING(REGEX REPLACE "[\\]" "/" OGRESDK "${OGRESDK}")
+FILE(TO_CMAKE_PATH "$ENV{OGRE_HOME}" OGRESDK)
+SET(OGRE_INCLUDE_SEARCH_DIRS #                 this <-
+	${INCLUDE_SEARCH_DIRS} #TODO Cache this, not ^
+	${CMAKE_LIBRARY_PATH}
+	/usr/include/OGRE
+	/usr/local/include/OGRE
+	/opt/include/OGRE
+	/opt/OGRE/include
+	${OGRESDK}/include
+	${OGRESDK}/OgreMain/include
+	CACHE STRING ""
+)
+
+SET(OGRE_LIBRARY_SEARCH_DIRS
+	${LIBRARY_SEARCH_DIRS}
+	${CMAKE_LIBRARY_PATH}
+	/usr/lib
+	/usr/lib64
+	/usr/local/lib
+	/usr/local/lib64
+	/opt/lib
+	/opt/lib64
+	/opt/OGRE/lib
+	/opt/OGRE/lib64
+	${OGRESDK}/lib
+	${OGRESDK}/lib64
+	CACHE STRING ""
+)
+
+#Search for the headers and libraries
+IF (WIN32) #Windows
+	MESSAGE(STATUS "Looking for OGRE")
+	FIND_PATH(OGRE_INCLUDE_DIRS Ogre.h ${OGRE_INCLUDE_SEARCH_DIRS})
+	FIND_LIBRARY(OGRE_LIBRARIES debug OgreMain_d optimized OgreMain PATHS ${OGRE_LIBRARY_SEARCH_DIRS})
+ELSE (WIN32) #Unix/OSX
+	FIND_PACKAGE(PkgConfig)
+	IF(PKG_CONFIG_FOUND)
+		CMAKE_MINIMUM_REQUIRED(VERSION 2.4.7)
+		PKG_SEARCH_MODULE(OGRE OGRE)
+		SET(OGRE_INCLUDE_DIRS ${OGRE_INCLUDE_DIRS})
+		SET(OGRE_LIBRARY_DIRS ${OGRE_LIBDIR})
+		SET(OGRE_LIBRARIES ${OGRE_LIBRARIES} CACHE STRING "")
+	ENDIF(PKG_CONFIG_FOUND)
+	IF(NOT OGRE_FOUND) #If PkgConfig couldn't find OGRE...
+		IF (NOT OGRE_FIND_QUIETLY)
+			MESSAGE(STATUS " Manually searching for OGRE")
+		ENDIF (NOT OGRE_FIND_QUIETLY)
+		FIND_PATH(OGRE_INCLUDE_DIRS Ogre.h ${OGRE_INCLUDE_SEARCH_DIRS})
+		FIND_LIBRARY(OGRE_LIBRARIES OgreMain PATHS ${OGRE_LIBRARY_SEARCH_DIRS})
+	ENDIF(NOT OGRE_FOUND)
+ENDIF (WIN32)
+
+#Do some preparation
+SEPARATE_ARGUMENTS(OGRE_INCLUDE_DIRS)
+SEPARATE_ARGUMENTS(OGRE_LIBRARIES)
+
+SET(OGRE_INCLUDE_DIRS ${OGRE_INCLUDE_DIRS})
+SET(OGRE_LIBRARIES ${OGRE_LIBRARIES})
+SET(OGRE_LIBRARY_DIRS ${OGRE_LIBRARY_DIRS})
+
+MARK_AS_ADVANCED(OGRE_INCLUDE_DIRS OGRE_LIBRARIES OGRE_LIBRARY_DIRS) #So they don't show in the default GUI
+
+IF (OGRE_INCLUDE_DIRS AND OGRE_LIBRARIES)
+	SET(OGRE_FOUND TRUE)
+ENDIF (OGRE_INCLUDE_DIRS AND OGRE_LIBRARIES)
+
+IF (OGRE_FOUND)
+	IF (NOT OGRE_FIND_QUIETLY)
+		MESSAGE(STATUS "  libraries : ${OGRE_LIBRARIES} from ${OGRE_LIBRARY_DIRS}")
+		MESSAGE(STATUS "  includes  : ${OGRE_INCLUDE_DIRS}")
+	ENDIF (NOT OGRE_FIND_QUIETLY)
+ELSE (OGRE_FOUND)
+	IF (OGRE_FIND_REQUIRED)
+		MESSAGE(FATAL_ERROR "Could not find OGRE. Make sure you have the OGRE development headers installed. Otherwise, try setting LIBRARY_SEARCH_DIRS and INCLUDE_SEARCH_DIRS to the place OGRE was installed with -DLIBRARY_SEARCH_DIRS=<path/to/lib> -DINCLUDE_SEARCH_DIRS=<path/to/include>")
+	ENDIF (OGRE_FIND_REQUIRED)
+ENDIF (OGRE_FOUND)

Added: rl/trunk/plugins/CMakeLists.txt
===================================================================
--- rl/trunk/plugins/CMakeLists.txt	2008-11-25 20:52:42 UTC (rev 4610)
+++ rl/trunk/plugins/CMakeLists.txt	2008-11-26 13:52:22 UTC (rev 4611)
@@ -0,0 +1,13 @@
+IF (ENABLE_FMOD4)
+	FIND_PACKAGE(FMODEx 4.20)
+	IF (FMODEX_FOUND)
+		ADD_SUBDIRECTORY(fmod4driver)
+	ENDIF (FMODEX_FOUND)
+ENDIF (ENABLE_FMOD4)
+
+IF (ENABLE_OPENAL)
+	FIND_PACKAGE(OpenAL)
+	IF (OPENAL_FOUND)
+		ADD_SUBDIRECTORY(openaldriver)
+	ENDIF (OPENAL_FOUND)
+ENDIF (ENABLE_OPENAL)
\ No newline at end of file

Added: rl/trunk/plugins/fmod4driver/CMakeLists.txt
===================================================================
--- rl/trunk/plugins/fmod4driver/CMakeLists.txt	2008-11-25 20:52:42 UTC (rev 4610)
+++ rl/trunk/plugins/fmod4driver/CMakeLists.txt	2008-11-26 13:52:22 UTC (rev 4611)
@@ -0,0 +1,17 @@
+INCLUDE_DIRECTORIES(
+${CMAKE_CURRENT_SOURCE_DIR}/include
+${FMODEX_INCLUDE_DIR}
+${OGRE_INCLUDE_DIRS}
+${CEGUI_INCLUDE_DIRS}
+${RL_COMMON_INCLUDE_DIR}
+${RL_CORE_INCLUDE_DIR}
+${RL_UI_INCLUDE_DIR})
+
+SET(RlFmod4Driver_LIB_SRCS
+src/Fmod4ConfigComponent.cpp
+src/Fmod4Driver.cpp
+src/Fmod4DriverDllMain.cpp
+src/Fmod4Listener.cpp
+src/Fmod4Sound.cpp)
+
+ADD_LIBRARY(RlFmod4Driver SHARED ${RlFmod4Driver_LIB_SRCS})
\ No newline at end of file



From blakharaz at mail.berlios.de  Wed Nov 26 20:07:24 2008
From: blakharaz at mail.berlios.de (blakharaz at mail.berlios.de)
Date: Wed, 26 Nov 2008 20:07:24 +0100
Subject: [Dsa-hl-svn] r4612 - in rl/trunk/engine/ui: include src
Message-ID: <200811261907.mAQJ7OQS019323@sheep.berlios.de>

Author: blakharaz
Date: 2008-11-26 20:07:20 +0100 (Wed, 26 Nov 2008)
New Revision: 4612

Added:
   rl/trunk/engine/ui/include/CharacterSelectionWindow.h
   rl/trunk/engine/ui/src/CharacterSelectionWindow.cpp
Modified:
   rl/trunk/engine/ui/include/AbstractWindow.h
   rl/trunk/engine/ui/include/GameSettings.h
   rl/trunk/engine/ui/src/AbstractWindow.cpp
   rl/trunk/engine/ui/src/GameSettings.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
Log:
Forgot the CharacterSelectionWindow files

Modified: rl/trunk/engine/ui/include/AbstractWindow.h
===================================================================
--- rl/trunk/engine/ui/include/AbstractWindow.h	2008-11-26 13:52:22 UTC (rev 4611)
+++ rl/trunk/engine/ui/include/AbstractWindow.h	2008-11-26 19:07:20 UTC (rev 4612)
@@ -1,140 +1,142 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __AbstractWindow_H__
-#define __AbstractWindow_H__
-
-#include "UiPrerequisites.h"
-
-
-#include <CEGUIWindow.h>
-#include <elements/CEGUIEditbox.h>
-#include <elements/CEGUIListbox.h>
-#include <elements/CEGUIMultiColumnList.h>
-#include <elements/CEGUIMultiLineEditbox.h>
-#include <elements/CEGUIProgressBar.h>
-#include <elements/CEGUIMenuBase.h>
-#include <elements/CEGUIMenuItem.h>
-#include <elements/CEGUIPushButton.h>
-#include <elements/CEGUICombobox.h>
-#include <elements/CEGUIComboDropList.h>
-#include <elements/CEGUIScrollablePane.h>
-#include <elements/CEGUISlider.h>
-#include <elements/CEGUITabControl.h>
-
-namespace rl {
-
-	class WindowUpdateTask;
-
-	/**
-	 * This is the base class for all UI windows
-	 */
-	class _RlUiExport AbstractWindow
-	{
-	public:
-
-		enum WindowInputType
-		{
-			WIT_NONE = 0x00,
-			WIT_MOUSE_INPUT = 0x01,
-			WIT_KEYBOARD_INPUT = 0x02
-		};
-
-		virtual ~AbstractWindow();	
-
-		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
-		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile);
-
-		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
-		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix);
-
-		/// gets the CEGUI root
-		static CEGUI::Window* getRoot();
-
-		/// gets the wrapped CEGUI window
-		CEGUI::Window* getWindow();
-
-		CEGUI::Window* getWindow(const char* name, const char* requiredClass = NULL);
-		CEGUI::Editbox* getEditbox(const char* name);
-		CEGUI::Listbox* getListbox(const char* name);
-		CEGUI::MultiColumnList* getMultiColumnList(const char* name);
-		CEGUI::MultiLineEditbox* getMultiLineEditbox(const char* name);
-		CEGUI::ProgressBar* getProgressBar(const char* name);
-		CEGUI::MenuBase* getMenu(const char* name);
-		CEGUI::MenuItem* getMenuItem(const char* name);
-		CEGUI::PushButton* getPushButton(const char* name);
-		CEGUI::Combobox* getCombobox(const char* name);
-		CEGUI::ComboDropList* getComboDropList(const char* name);
-        CEGUI::ScrollablePane* getScrollablePane(const char* name);
-		CEGUI::Slider* getSlider(const char* name);
-		CEGUI::TabControl* getTabControl(const char* name);
-
-		int getWindowInputType();
-
-        virtual bool isVisible();
-        virtual void setVisible(bool visible, bool destroyAfterHide = false);
-
-		bool isModal();
-		bool isClosingOnEscape();
-
-		const CeGuiString& getName() const;
-		const Ogre::Real& getNormalAlpha() const;
-
-		virtual void windowHid();
-
-        // return true, if the specified key should be repeated if pressed down
-        virtual bool wantsKeyToRepeat(const int &key) {return false;}
-
-	protected:
-		AbstractWindow(
-			const CeGuiString& xmlfile, 
-			int inputType, 
-			bool closeOnEscape = true,
-			bool modal = false);
-
-		const CeGuiString& getNamePrefix() const;
-		
-		void centerWindow();
-		bool destroyWindow();		
-		bool hideWindow();
-
-		void bindDestroyWindowToClick(CEGUI::Window* button);
-        void bindHideWindowToClick(CEGUI::Window* button);
-		void bindDestroyWindowToXButton();
-		void bindHideWindowToXButton();
-
-		const CeGuiString& getUserDataType(CEGUI::Window* window) const;
-		void setUserDataType(CEGUI::Window* window, const CeGuiString& typeDescription) const;
-
-		CEGUI::Window* mWindow;
-		bool mVisible;
-
-	private:
-		
-		int mWindowInputType;
-		CeGuiString mNamePrefix;
-		CeGuiString mName;
-		bool mModal;
-		bool mCloseOnEscape;
-		Ogre::Real mNormalAlpha;
-
-		static int sNumAbstractWindows;
-
-	};
-
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __AbstractWindow_H__
+#define __AbstractWindow_H__
+
+#include "UiPrerequisites.h"
+
+
+#include <CEGUIWindow.h>
+#include <elements/CEGUICheckbox.h>
+#include <elements/CEGUIEditbox.h>
+#include <elements/CEGUIListbox.h>
+#include <elements/CEGUIMultiColumnList.h>
+#include <elements/CEGUIMultiLineEditbox.h>
+#include <elements/CEGUIProgressBar.h>
+#include <elements/CEGUIMenuBase.h>
+#include <elements/CEGUIMenuItem.h>
+#include <elements/CEGUIPushButton.h>
+#include <elements/CEGUICombobox.h>
+#include <elements/CEGUIComboDropList.h>
+#include <elements/CEGUIScrollablePane.h>
+#include <elements/CEGUISlider.h>
+#include <elements/CEGUITabControl.h>
+
+namespace rl {
+
+	class WindowUpdateTask;
+
+	/**
+	 * This is the base class for all UI windows
+	 */
+	class _RlUiExport AbstractWindow
+	{
+	public:
+
+		enum WindowInputType
+		{
+			WIT_NONE = 0x00,
+			WIT_MOUSE_INPUT = 0x01,
+			WIT_KEYBOARD_INPUT = 0x02
+		};
+
+		virtual ~AbstractWindow();	
+
+		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
+		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile);
+
+		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
+		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix);
+
+		/// gets the CEGUI root
+		static CEGUI::Window* getRoot();
+
+		/// gets the wrapped CEGUI window
+		CEGUI::Window* getWindow();
+
+		CEGUI::Window* getWindow(const char* name, const char* requiredClass = NULL);
+		CEGUI::Editbox* getEditbox(const char* name);
+		CEGUI::Listbox* getListbox(const char* name);
+		CEGUI::MultiColumnList* getMultiColumnList(const char* name);
+		CEGUI::MultiLineEditbox* getMultiLineEditbox(const char* name);
+		CEGUI::ProgressBar* getProgressBar(const char* name);
+		CEGUI::MenuBase* getMenu(const char* name);
+		CEGUI::MenuItem* getMenuItem(const char* name);
+		CEGUI::PushButton* getPushButton(const char* name);
+		CEGUI::Combobox* getCombobox(const char* name);
+		CEGUI::ComboDropList* getComboDropList(const char* name);
+        CEGUI::ScrollablePane* getScrollablePane(const char* name);
+		CEGUI::Slider* getSlider(const char* name);
+		CEGUI::TabControl* getTabControl(const char* name);
+        CEGUI::Checkbox* getCheckbox(const char* name);
+
+		int getWindowInputType();
+
+        virtual bool isVisible();
+        virtual void setVisible(bool visible, bool destroyAfterHide = false);
+
+		bool isModal();
+		bool isClosingOnEscape();
+
+		const CeGuiString& getName() const;
+		const Ogre::Real& getNormalAlpha() const;
+
+		virtual void windowHid();
+
+        // return true, if the specified key should be repeated if pressed down
+        virtual bool wantsKeyToRepeat(const int &key) {return false;}
+
+	protected:
+		AbstractWindow(
+			const CeGuiString& xmlfile, 
+			int inputType, 
+			bool closeOnEscape = true,
+			bool modal = false);
+
+		const CeGuiString& getNamePrefix() const;
+		
+		void centerWindow();
+		bool destroyWindow();		
+		bool hideWindow();
+
+		void bindDestroyWindowToClick(CEGUI::Window* button);
+        void bindHideWindowToClick(CEGUI::Window* button);
+		void bindDestroyWindowToXButton();
+		void bindHideWindowToXButton();
+
+		const CeGuiString& getUserDataType(CEGUI::Window* window) const;
+		void setUserDataType(CEGUI::Window* window, const CeGuiString& typeDescription) const;
+
+		CEGUI::Window* mWindow;
+		bool mVisible;
+
+	private:
+		
+		int mWindowInputType;
+		CeGuiString mNamePrefix;
+		CeGuiString mName;
+		bool mModal;
+		bool mCloseOnEscape;
+		Ogre::Real mNormalAlpha;
+
+		static int sNumAbstractWindows;
+
+	};
+
+}
+
+#endif

Added: rl/trunk/engine/ui/include/CharacterSelectionWindow.h
===================================================================
--- rl/trunk/engine/ui/include/CharacterSelectionWindow.h	2008-11-26 13:52:22 UTC (rev 4611)
+++ rl/trunk/engine/ui/include/CharacterSelectionWindow.h	2008-11-26 19:07:20 UTC (rev 4612)
@@ -0,0 +1,70 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#ifndef __CharacterSelectionWindow_H__
+#define __CharacterSelectionWindow_H__
+
+#include "UiPrerequisites.h"
+
+#include "AbstractWindow.h"
+#include "MessagePump.h"
+#include "ObjectStateChangeListener.h"
+
+namespace rl
+{
+    class Creature;
+    
+    class CharacterSelectionWindow : public AbstractWindow
+    {
+    public:
+        CharacterSelectionWindow();
+        virtual ~CharacterSelectionWindow();
+        
+        bool update();
+        
+    private:
+        
+        class Element : public AbstractWindow, public ObjectStateChangeListener
+        {
+        public:
+            Element(CharacterSelectionWindow* parent);
+            virtual ~Element();
+            
+            void setCreature(Creature* creature);
+            void objectStateChanged(ObjectStateChangeEvent* evt);
+        
+        private:
+            CharacterSelectionWindow* mParent;
+            Creature* mCreature;
+            CEGUI::Window* mTextName;
+            CEGUI::Window* mPortrait;
+            CEGUI::ProgressBar* mLP;
+            
+            void update();
+        };
+        
+        std::vector<Element*> mCharacterWindows;
+        CEGUI::Window* mCharacterWindow;
+
+        bool handleClickOnCharacter(size_t index);
+        CEGUI::Window* createCharacterWindow();
+        void removeCharacterWindow(CEGUI::Window* window);
+        
+        MessagePump::ScopedConnection mCharacterAddedConnection;
+        MessagePump::ScopedConnection mCharacterRemovedConnection;
+    };
+}
+
+#endif // __CharacterSelectionWindow_H__

Modified: rl/trunk/engine/ui/include/GameSettings.h
===================================================================
--- rl/trunk/engine/ui/include/GameSettings.h	2008-11-26 13:52:22 UTC (rev 4611)
+++ rl/trunk/engine/ui/include/GameSettings.h	2008-11-26 19:07:20 UTC (rev 4612)
@@ -82,11 +82,17 @@
 		 * configuration section.
 		 */
 		bool onRenderSystemChanged();
+        
+        void update();
 
 		std::list<SoundDriverConfigComponent*> mSoundDriverConfigs;   //!< List of registered sounddriver configuration components
 		SoundDriverConfigComponent* mCurrentSoundDriverConfig;        //!< Configuration component of currently selected sound driver
 		std::list<RenderSystemConfigComponent*> mRenderSystemConfigs; //!< List of registered rendersystem configuration components
 		RenderSystemConfigComponent* mCurrentRenderSystemConfig;      //!< Configuration component of currently selected rendersystem
+        
+        CEGUI::Combobox* mVideoRenderer;
+        CEGUI::Combobox* mVideoResolution;
+        CEGUI::Checkbox* mVideoFullscreen;
 	};
 }
 

Modified: rl/trunk/engine/ui/src/AbstractWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/AbstractWindow.cpp	2008-11-26 13:52:22 UTC (rev 4611)
+++ rl/trunk/engine/ui/src/AbstractWindow.cpp	2008-11-26 19:07:20 UTC (rev 4612)
@@ -1,319 +1,325 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include <boost/bind.hpp>
-#include <CEGUIWindowManager.h>
-#include <elements/CEGUIFrameWindow.h>
-
-#include "UiPrerequisites.h"
-#include "Exception.h"
-
-#include "UiSubsystem.h"
-#include "AbstractWindow.h"
-#include "CeGuiHelper.h"
-#include "WindowManager.h"
-#include "WindowFadeJob.h"
-#include "JobScheduler.h"
-
-using namespace std;
-using namespace CEGUI;
-using namespace Ogre;
-
-namespace rl
-{
-
-	int AbstractWindow::sNumAbstractWindows = 0;
-
-	AbstractWindow::AbstractWindow(const CeGuiString& xmlfile, int inputType, bool closeOnEscape, bool modal)
-	: mVisible(false),
-		mModal(modal),
-		mWindowInputType(inputType),
-		mCloseOnEscape(closeOnEscape)
-	{
-        LOG_MESSAGE(Logger::UI,
-		    "Lade Fenster '" + Ogre::String(xmlfile.c_str()) + "'");
-   		mWindow = AbstractWindow::loadWindow(xmlfile, mNamePrefix);
-		if (mWindow == NULL)
-		{
-			Throw(rl::IllegalStateException, Ogre::String("Could not load window '")+xmlfile.c_str()+"'.");
-		}
-
-		getRoot()->addChildWindow(mWindow);
-
-        if (modal)
-		{
-			mWindow->setModalState(true);
-			mWindow->setAlwaysOnTop(true);
-            mWindow->moveToFront();
-            mWindow->show();
-		}
-        else
-        {
-       		mWindow->hide();
-        }
-
-		mNormalAlpha = mWindow->getAlpha();
-		mName = mWindow->getName();
-		WindowManager::getSingleton().registerWindow(this);
-		mWindow->subscribeEvent(Window::EventActivated,
-			boost::bind(
-				&rl::WindowManager::handleMovedToFront,
-				rl::WindowManager::getSingletonPtr(),
-				this));
-	}
-
-	AbstractWindow::~AbstractWindow()
-	{
-		mWindow->hide();
-		mWindow->removeAllEvents();
-		WindowManager::getSingleton().unregisterWindow(this);
-		getRoot()->removeChildWindow(mWindow);
-		CEGUI::WindowManager::getSingleton().destroyWindow(mWindow);
-	}
-
-	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile)
-	{
-		CeGuiString prefix = "";
-		return loadWindow(xmlfile, prefix);
-	}
-
-
-	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix)
-	{
-		CeGuiString namePrefix;
-		if (prefix == "")
-			prefix.assign(StringConverter::toString(sNumAbstractWindows));
-		sNumAbstractWindows++;
-
-		CEGUI::Window* window = NULL;
-		try
-		{
-			window = CEGUI::WindowManager::getSingleton().loadWindowLayout(xmlfile, prefix);
-		}
-		catch(...)
-		{
-		}
-
-		return window;
-	}
-
-	bool AbstractWindow::isVisible()
-	{
-		return mVisible;
-	}
-
-	void AbstractWindow::setVisible(bool visible, bool destroy)
-	{
-		if(mVisible != visible)
-		{
-			if (visible)
-			{
-                JobScheduler::getSingleton().addJob(
-                    new WindowFadeJob(this, WindowFadeJob::FADE_IN, mNormalAlpha));
-			}
-			else
-			{
-                JobScheduler::getSingleton().addJob(
-                    new WindowFadeJob(this,
-                    destroy ? WindowFadeJob::FADE_OUT_AND_DESTROY : WindowFadeJob::FADE_OUT,
-                    0.0f));
-			}
-            WindowManager::getSingleton()._visiblityChanged(this, visible);
-            mVisible = visible;
-		}
-	}
-
-	const Ogre::Real& AbstractWindow::getNormalAlpha() const
-	{
-		return mNormalAlpha;
-	}
-
-	bool AbstractWindow::isModal()
-	{
-		return mModal;
-	}
-
-	bool AbstractWindow::isClosingOnEscape()
-	{
-		return mCloseOnEscape;
-	}
-
-	int AbstractWindow::getWindowInputType()
-	{
-		return mWindowInputType;
-	}
-
-	CEGUI::Window* AbstractWindow::getRoot()
-	{
-		return CEGUI::WindowManager::getSingleton().getWindow(
-			(utf8*)UiSubsystem::CEGUI_ROOT);
-	}
-
-	Window* AbstractWindow::getWindow(const char* name, const char* requiredClass)
-	{
-		CEGUI::Window* wnd =
-			CEGUI::WindowManager::getSingleton().getWindow(
-				mNamePrefix + (utf8*)name);
-
-		if (wnd == NULL)
-			Throw(
-				rl::NullPointerException,
-				"Window "
-				+ Ogre::String(name)
-				+ " is NULL");
-
-		if (requiredClass != NULL && !wnd->testClassName(requiredClass))
-			Throw(
-				rl::NullPointerException,
-				"Window "
-				+ Ogre::String(name)
-				+ " has not the required class "
-				+ Ogre::String(requiredClass));
-
-		return wnd;
-	}
-
-	Editbox* AbstractWindow::getEditbox(const char* name)
-	{
-		return static_cast<Editbox*>(getWindow(name, "Editbox"));
-	}
-
-	Listbox* AbstractWindow::getListbox(const char* name)
-	{
-		return static_cast<Listbox*>(getWindow(name, "Listbox"));
-	}
-
-	MultiColumnList* AbstractWindow::getMultiColumnList(const char* name)
-	{
-		return static_cast<MultiColumnList*>(getWindow(name, "MultiColumnList"));
-	}
-
-	MultiLineEditbox* AbstractWindow::getMultiLineEditbox(const char* name)
-	{
-		return static_cast<MultiLineEditbox*>(getWindow(name, "MultiLineEditbox"));
-	}
-
-	ProgressBar* AbstractWindow::getProgressBar(const char* name)
-	{
-		return static_cast<ProgressBar*>(getWindow(name, "ProgressBar"));
-	}
-
-	MenuBase* AbstractWindow::getMenu(const char* name)
-	{
-		return static_cast<MenuBase*>(getWindow(name, "MenuBase"));
-	}
-
-	MenuItem* AbstractWindow::getMenuItem(const char* name)
-	{
-		return static_cast<MenuItem*>(getWindow(name, "MenuItem"));
-	}
-
-	PushButton* AbstractWindow::getPushButton(const char* name)
-	{
-		return static_cast<PushButton*>(getWindow(name, "PushButton"));
-	}
-
-	Combobox* AbstractWindow::getCombobox(const char* name)
-	{
-		return static_cast<Combobox*>(getWindow(name, "Combobox"));
-	}
-
-	ComboDropList* AbstractWindow::getComboDropList(const char* name)
-	{
-		return static_cast<ComboDropList*>(getWindow(name, "ComboDropList"));
-	}
-
-    ScrollablePane* AbstractWindow::getScrollablePane(const char* name)
-    {
-		return static_cast<ScrollablePane*>(getWindow(name, "ScrollablePane"));
-    }
-
-	Slider* AbstractWindow::getSlider(const char* name)
-	{
-		return static_cast<Slider*>(getWindow(name, "Slider"));
-	}
-
-	TabControl* AbstractWindow::getTabControl(const char* name)
-	{
-		return static_cast<TabControl*>(getWindow(name, "TabControl"));
-	}
-
-	const CeGuiString& AbstractWindow::getName() const
-	{
-		return mName;
-	}
-
-	void AbstractWindow::centerWindow()
-	{
-		CEGUI::Size screenSize = System::getSingleton().getRenderer()->getSize();
-		CEGUI::Size windowSize = mWindow->getPixelSize();
-		float x = 0.5f * (screenSize.d_width - windowSize.d_width);
-		float y = 0.5f * (screenSize.d_height - windowSize.d_height);
-		mWindow->setPosition(CeGuiHelper::asAbsolute(CEGUI::Vector2(x, y)));
-	}
-
-	void AbstractWindow::bindDestroyWindowToClick(CEGUI::Window* button)
-	{
-		button->subscribeEvent(Window::EventMouseClick,
-			boost::bind(&AbstractWindow::destroyWindow, this));
-	}
-
-    void AbstractWindow::bindHideWindowToClick(CEGUI::Window* button)
-	{
-		button->subscribeEvent(Window::EventMouseClick,
-			boost::bind(&AbstractWindow::hideWindow, this));
-	}
-
-	void AbstractWindow::bindDestroyWindowToXButton()
-	{
-		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
-			boost::bind(&AbstractWindow::destroyWindow, this));
-	}
-
-	void AbstractWindow::bindHideWindowToXButton()
-	{
-		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
-			boost::bind(&AbstractWindow::hideWindow, this));
-	}
-
-	bool AbstractWindow::destroyWindow()
-	{
-		setVisible(false, true);
-		return true;
-	}
-
-	bool AbstractWindow::hideWindow()
-	{
-		setVisible(false);
-		return true;
-	}
-
-	CEGUI::Window* AbstractWindow::getWindow()
-	{
-		return mWindow;
-	}
-
-	const CeGuiString& AbstractWindow::getNamePrefix() const
-	{
-		return mNamePrefix;
-	}
-
-	void AbstractWindow::windowHid()
-	{
-	}
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include <boost/bind.hpp>
+#include <CEGUIWindowManager.h>
+#include <elements/CEGUIFrameWindow.h>
+
+#include "UiPrerequisites.h"
+#include "Exception.h"
+
+#include "UiSubsystem.h"
+#include "AbstractWindow.h"
+#include "CeGuiHelper.h"
+#include "WindowManager.h"
+#include "WindowFadeJob.h"
+#include "JobScheduler.h"
+
+using namespace std;
+using namespace CEGUI;
+using namespace Ogre;
+
+namespace rl
+{
+
+	int AbstractWindow::sNumAbstractWindows = 0;
+
+	AbstractWindow::AbstractWindow(const CeGuiString& xmlfile, int inputType, bool closeOnEscape, bool modal)
+	: mVisible(false),
+		mModal(modal),
+		mWindowInputType(inputType),
+		mCloseOnEscape(closeOnEscape)
+	{
+        LOG_MESSAGE(Logger::UI,
+		    "Lade Fenster '" + Ogre::String(xmlfile.c_str()) + "'");
+   		mWindow = AbstractWindow::loadWindow(xmlfile, mNamePrefix);
+		if (mWindow == NULL)
+		{
+			Throw(rl::IllegalStateException, Ogre::String("Could not load window '")+xmlfile.c_str()+"'.");
+		}
+
+		getRoot()->addChildWindow(mWindow);
+
+        if (modal)
+		{
+			mWindow->setModalState(true);
+			mWindow->setAlwaysOnTop(true);
+            mWindow->moveToFront();
+            mWindow->show();
+		}
+        else
+        {
+       		mWindow->hide();
+        }
+
+		mNormalAlpha = mWindow->getAlpha();
+		mName = mWindow->getName();
+		WindowManager::getSingleton().registerWindow(this);
+		mWindow->subscribeEvent(Window::EventActivated,
+			boost::bind(
+				&rl::WindowManager::handleMovedToFront,
+				rl::WindowManager::getSingletonPtr(),
+				this));
+	}
+
+	AbstractWindow::~AbstractWindow()
+	{
+		mWindow->hide();
+		mWindow->removeAllEvents();
+		WindowManager::getSingleton().unregisterWindow(this);
+		getRoot()->removeChildWindow(mWindow);
+		CEGUI::WindowManager::getSingleton().destroyWindow(mWindow);
+	}
+
+	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile)
+	{
+		CeGuiString prefix = "";
+		return loadWindow(xmlfile, prefix);
+	}
+
+
+	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix)
+	{
+		CeGuiString namePrefix;
+		if (prefix == "")
+			prefix.assign(StringConverter::toString(sNumAbstractWindows));
+		sNumAbstractWindows++;
+
+		CEGUI::Window* window = NULL;
+		try
+		{
+			window = CEGUI::WindowManager::getSingleton().loadWindowLayout(xmlfile, prefix);
+		}
+		catch(...)
+		{
+		}
+
+		return window;
+	}
+
+	bool AbstractWindow::isVisible()
+	{
+		return mVisible;
+	}
+
+	void AbstractWindow::setVisible(bool visible, bool destroy)
+	{
+		if(mVisible != visible)
+		{
+			if (visible)
+			{
+                JobScheduler::getSingleton().addJob(
+                    new WindowFadeJob(this, WindowFadeJob::FADE_IN, mNormalAlpha));
+			}
+			else
+			{
+                JobScheduler::getSingleton().addJob(
+                    new WindowFadeJob(this,
+                    destroy ? WindowFadeJob::FADE_OUT_AND_DESTROY : WindowFadeJob::FADE_OUT,
+                    0.0f));
+			}
+            WindowManager::getSingleton()._visiblityChanged(this, visible);
+            mVisible = visible;
+		}
+	}
+
+	const Ogre::Real& AbstractWindow::getNormalAlpha() const
+	{
+		return mNormalAlpha;
+	}
+
+	bool AbstractWindow::isModal()
+	{
+		return mModal;
+	}
+
+	bool AbstractWindow::isClosingOnEscape()
+	{
+		return mCloseOnEscape;
+	}
+
+	int AbstractWindow::getWindowInputType()
+	{
+		return mWindowInputType;
+	}
+
+	CEGUI::Window* AbstractWindow::getRoot()
+	{
+		return CEGUI::WindowManager::getSingleton().getWindow(
+			(utf8*)UiSubsystem::CEGUI_ROOT);
+	}
+
+	Window* AbstractWindow::getWindow(const char* name, const char* requiredClass)
+	{
+		CEGUI::Window* wnd =
+			CEGUI::WindowManager::getSingleton().getWindow(
+				mNamePrefix + (utf8*)name);
+
+		if (wnd == NULL)
+			Throw(
+				rl::NullPointerException,
+				"Window "
+				+ Ogre::String(name)
+				+ " is NULL");
+
+		if (requiredClass != NULL && !wnd->testClassName(requiredClass)) {
+            Throw(
+				rl::NullPointerException,
+				"Window "
+				+ Ogre::String(name)
+				+ " has not the required class "
+				+ Ogre::String(requiredClass));
+        }
+
+		return wnd;
+	}
+
+	Editbox* AbstractWindow::getEditbox(const char* name)
+	{
+		return static_cast<Editbox*>(getWindow(name, "Editbox"));
+	}
+    
+	Checkbox* AbstractWindow::getCheckbox(const char* name)
+	{
+		return static_cast<Checkbox*>(getWindow(name, "Checkbox"));
+	}
+    
+	Listbox* AbstractWindow::getListbox(const char* name)
+	{
+		return static_cast<Listbox*>(getWindow(name, "Listbox"));
+	}
+
+	MultiColumnList* AbstractWindow::getMultiColumnList(const char* name)
+	{
+		return static_cast<MultiColumnList*>(getWindow(name, "MultiColumnList"));
+	}
+
+	MultiLineEditbox* AbstractWindow::getMultiLineEditbox(const char* name)
+	{
+		return static_cast<MultiLineEditbox*>(getWindow(name, "MultiLineEditbox"));
+	}
+
+	ProgressBar* AbstractWindow::getProgressBar(const char* name)
+	{
+		return static_cast<ProgressBar*>(getWindow(name, "ProgressBar"));
+	}
+
+	MenuBase* AbstractWindow::getMenu(const char* name)
+	{
+		return static_cast<MenuBase*>(getWindow(name, "MenuBase"));
+	}
+
+	MenuItem* AbstractWindow::getMenuItem(const char* name)
+	{
+		return static_cast<MenuItem*>(getWindow(name, "MenuItem"));
+	}
+
+	PushButton* AbstractWindow::getPushButton(const char* name)
+	{
+		return static_cast<PushButton*>(getWindow(name, "PushButton"));
+	}
+
+	Combobox* AbstractWindow::getCombobox(const char* name)
+	{
+		return static_cast<Combobox*>(getWindow(name, "Combobox"));
+	}
+
+	ComboDropList* AbstractWindow::getComboDropList(const char* name)
+	{
+		return static_cast<ComboDropList*>(getWindow(name, "ComboDropList"));
+	}
+
+    ScrollablePane* AbstractWindow::getScrollablePane(const char* name)
+    {
+		return static_cast<ScrollablePane*>(getWindow(name, "ScrollablePane"));
+    }
+
+	Slider* AbstractWindow::getSlider(const char* name)
+	{
+		return static_cast<Slider*>(getWindow(name, "Slider"));
+	}
+
+	TabControl* AbstractWindow::getTabControl(const char* name)
+	{
+		return static_cast<TabControl*>(getWindow(name, "TabControl"));
+	}
+
+	const CeGuiString& AbstractWindow::getName() const
+	{
+		return mName;
+	}
+
+	void AbstractWindow::centerWindow()
+	{
+		CEGUI::Size screenSize = System::getSingleton().getRenderer()->getSize();
+		CEGUI::Size windowSize = mWindow->getPixelSize();
+		float x = 0.5f * (screenSize.d_width - windowSize.d_width);
+		float y = 0.5f * (screenSize.d_height - windowSize.d_height);
+		mWindow->setPosition(CeGuiHelper::asAbsolute(CEGUI::Vector2(x, y)));
+	}
+
+	void AbstractWindow::bindDestroyWindowToClick(CEGUI::Window* button)
+	{
+		button->subscribeEvent(Window::EventMouseClick,
+			boost::bind(&AbstractWindow::destroyWindow, this));
+	}
+
+    void AbstractWindow::bindHideWindowToClick(CEGUI::Window* button)
+	{
+		button->subscribeEvent(Window::EventMouseClick,
+			boost::bind(&AbstractWindow::hideWindow, this));
+	}
+
+	void AbstractWindow::bindDestroyWindowToXButton()
+	{
+		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
+			boost::bind(&AbstractWindow::destroyWindow, this));
+	}
+
+	void AbstractWindow::bindHideWindowToXButton()
+	{
+		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
+			boost::bind(&AbstractWindow::hideWindow, this));
+	}
+
+	bool AbstractWindow::destroyWindow()
+	{
+		setVisible(false, true);
+		return true;
+	}
+
+	bool AbstractWindow::hideWindow()
+	{
+		setVisible(false);
+		return true;
+	}
+
+	CEGUI::Window* AbstractWindow::getWindow()
+	{
+		return mWindow;
+	}
+
+	const CeGuiString& AbstractWindow::getNamePrefix() const
+	{
+		return mNamePrefix;
+	}
+
+	void AbstractWindow::windowHid()
+	{
+	}
+
+}

Added: rl/trunk/engine/ui/src/CharacterSelectionWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterSelectionWindow.cpp	2008-11-26 13:52:22 UTC (rev 4611)
+++ rl/trunk/engine/ui/src/CharacterSelectionWindow.cpp	2008-11-26 19:07:20 UTC (rev 4612)
@@ -0,0 +1,149 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h"
+
+#include "CharacterSelectionWindow.h"
+
+#include "Creature.h"
+#include "PartyManager.h"
+#include "RulesMessages.h"
+
+using namespace CEGUI;
+
+namespace rl
+{
+    CharacterSelectionWindow::CharacterSelectionWindow()
+    : AbstractWindow("characterselectionwindow.xml", WIT_MOUSE_INPUT, false)
+    {
+        mCharacterWindow = getWindow("CharacterSelectionWindow/Characters");
+        mCharacterAddedConnection = MessagePump::getSingleton().
+            addMessageHandler<MessageType_PlayerCharAdded>(boost::bind(&CharacterSelectionWindow::update, this));
+        mCharacterRemovedConnection = MessagePump::getSingleton().
+            addMessageHandler<MessageType_PlayerCharRemoved>(boost::bind(&CharacterSelectionWindow::update, this));
+    }
+    
+    CharacterSelectionWindow::~CharacterSelectionWindow()
+    {
+        while (0 > mCharacterWindows.size())
+        {
+            Element* elem = mCharacterWindows.back();
+            mCharacterWindows.pop_back();
+            mCharacterWindow->removeChildWindow(elem->getWindow());
+            delete elem;
+        }        
+    }
+    
+    bool CharacterSelectionWindow::update()
+    {
+        Party party = PartyManager::getSingleton().getCharacters();
+        
+        while (party.size() > mCharacterWindows.size())
+        {
+            Element* elem = new Element(this);
+            mCharacterWindow->addChildWindow(elem->getWindow());
+            CEGUI::Rect size = elem->getWindow()->getPixelRect();
+            size_t windowNum = mCharacterWindows.size();
+            elem->getWindow()->setPosition(UVector2(UDim(0, 0), UDim(0, windowNum * size.getHeight())));
+            elem->setVisible(true);
+            elem->getWindow()->subscribeEvent(
+                 Window::EventMouseClick,
+                 boost::bind(&CharacterSelectionWindow::handleClickOnCharacter, this, windowNum));
+            
+            mCharacterWindows.push_back(elem);
+        }
+        
+        while (party.size() < mCharacterWindows.size())
+        {
+            Element* elem = mCharacterWindows.back();
+            mCharacterWindows.pop_back();
+            mCharacterWindow->removeChildWindow(elem->getWindow());
+            delete elem;
+        }
+        
+        for (int i = 0; i < party.size(); ++i)
+        {
+            mCharacterWindows[i]->setCreature(party[i]);
+        }
+        
+        return true;
+    }
+    
+    bool CharacterSelectionWindow::handleClickOnCharacter(size_t index)
+    {
+        Party party = PartyManager::getSingleton().getCharacters();
+        PartyManager::getSingleton().setActiveCharacter(party[index]);
+        return true;
+    }
+
+    CharacterSelectionWindow::Element::Element(CharacterSelectionWindow* parent)
+    :  AbstractWindow("characterselectionwindow_character.xml", WIT_NONE, false), 
+       mParent(parent),
+       mCreature(NULL),
+       mTextName(NULL)
+    {
+        mTextName = getWindow("CharacterSelectionWindow/Character/Name");
+        mPortrait = getWindow("CharacterSelectionWindow/Character/Picture");
+        mLP = getProgressBar("CharacterSelectionWindow/Character/LP");
+    }
+    
+    CharacterSelectionWindow::Element::~Element()
+    {
+        setCreature(NULL);
+    }
+    
+    void CharacterSelectionWindow::Element::setCreature(Creature* creature)
+    {
+        if (mCreature)
+        {
+            mCreature->removeObjectStateChangeListener(this);
+        }
+
+        
+        if (creature) 
+        {
+            creature->addObjectStateChangeListener(this);
+            mTextName->setText(creature->getName());
+            mPortrait->setProperty("Image", creature->getImageName());
+        }
+        else 
+        {
+            mTextName->setText("");
+        }
+
+        mCreature = creature;
+        update();            
+    }
+    
+    void CharacterSelectionWindow::Element::objectStateChanged(ObjectStateChangeEvent* evt)
+    {
+        update();
+    }
+    
+    
+    void CharacterSelectionWindow::Element::update()
+    {
+        float lep;
+        if (!mCreature || mCreature->getLeMax() <= 0)
+        {
+            lep = 0.0;        
+        }
+        else
+        {
+            lep = (float)mCreature->getLe() / (float)mCreature->getLeMax();        
+        }
+        mLP->setProgress(lep);
+    }
+}

Modified: rl/trunk/engine/ui/src/GameSettings.cpp
===================================================================
--- rl/trunk/engine/ui/src/GameSettings.cpp	2008-11-26 13:52:22 UTC (rev 4611)
+++ rl/trunk/engine/ui/src/GameSettings.cpp	2008-11-26 19:07:20 UTC (rev 4612)
@@ -25,6 +25,8 @@
 #include "SoundManager.h"
 #include "SoundDriver.h"
 
+using namespace Ogre;
+
 namespace rl
 {
     GameSettings::GameSettings()
@@ -46,8 +48,12 @@
         getWindow()->subscribeEvent(CEGUI::FrameWindow::EventCloseClicked,
                                     boost::bind(&GameSettings::onCancel, this));
 
+        mVideoRenderer = getCombobox("GameOptionsWindow/Video/Renderer");
+        mVideoResolution = getCombobox("GameOptionsWindow/Video/Resolution");
+        mVideoFullscreen = getCheckbox("GameOptionsWindow/Video/Fullscreen");
         centerWindow();
         setVisible(false);
+        update();
     }
 
     GameSettings::~GameSettings()
@@ -127,4 +133,54 @@
     {
         return true;
     }
+    
+    void GameSettings::update()
+    {
+        Root* root = Ogre::Root::getSingletonPtr();
+        RenderSystem* renderer = root->getRenderSystem();
+        
+        ConfigOptionMap config = renderer->getConfigOptions();
+        
+		ConfigOptionMap::iterator cfi;
+		
+		cfi = config.find( "Full Screen" );
+		if( cfi != config.end() )
+		{
+			mVideoFullscreen->setSelected(cfi->second.currentValue == "Yes");
+		}
+        
+/*		cfi = config.find( "FSAA" );
+		if( cfi != config.end() )
+		{
+			if( cfi->second.currentValue == "0" )
+			{
+				SetControlValue( iFSAARef, 1 );
+			}
+			else if( cfi->second.currentValue == "2" )
+			{
+				SetControlValue( iFSAARef, 2 );
+			}
+			else if( cfi->second.currentValue == "4" )
+			{
+				SetControlValue( iFSAARef, 3 );
+			}
+			else if( cfi->second.currentValue == "6" )
+			{
+				SetControlValue( iFSAARef, 4 );
+			}
+		}
+        
+		cfi = config.find( "Colour Depth" );
+		if( cfi != config.end() )
+		{
+			if( cfi->second.currentValue == "32" )
+			{
+				SetControlValue( iColorDepthRef, 1 );
+			}
+			else
+			{
+				SetControlValue( iColorDepthRef, 2 );
+			}
+		}*/
+    }
 }

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2008-11-26 13:52:22 UTC (rev 4611)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2008-11-26 19:07:20 UTC (rev 4612)
@@ -174,7 +174,6 @@
     ItemDragContainer* InventoryWindow::getItemDragContainer(const Item* item, bool description)
     {
 		CeGuiString dragContainerName = getDragContainerNameFromItem(item, description);
-		ItemDragContainer* itemhandler = NULL;
 
 		DndContainerMap::iterator iter = mWorldDragContainers.find(dragContainerName);
         if( iter != mWorldDragContainers.end() )



From timm at mail.berlios.de  Wed Nov 26 20:42:17 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Wed, 26 Nov 2008 20:42:17 +0100
Subject: [Dsa-hl-svn] r4613 - in rl/branches/persistence: core/src
	rules/include rules/src script/swig ui ui/include ui/src
Message-ID: <200811261942.mAQJgHlb022232@sheep.berlios.de>

Author: timm
Date: 2008-11-26 20:42:03 +0100 (Wed, 26 Nov 2008)
New Revision: 4613

Added:
   rl/branches/persistence/ui/include/CharacterSelectionWindow.h
   rl/branches/persistence/ui/src/CharacterSelectionWindow.cpp
Modified:
   rl/branches/persistence/core/src/ConfigurationManager.cpp
   rl/branches/persistence/core/src/JobScheduler.cpp
   rl/branches/persistence/rules/include/GameObject.h
   rl/branches/persistence/rules/include/Item.h
   rl/branches/persistence/rules/include/PartyManager.h
   rl/branches/persistence/rules/src/GameObject.cpp
   rl/branches/persistence/rules/src/Item.cpp
   rl/branches/persistence/script/swig/RlUi.swig
   rl/branches/persistence/ui/RlUI2005.vcproj
   rl/branches/persistence/ui/include/AbstractWindow.h
   rl/branches/persistence/ui/include/GameSettings.h
   rl/branches/persistence/ui/include/WindowFactory.h
   rl/branches/persistence/ui/src/AbstractWindow.cpp
   rl/branches/persistence/ui/src/CharacterStateWindow.cpp
   rl/branches/persistence/ui/src/GameSettings.cpp
   rl/branches/persistence/ui/src/InventoryWindow.cpp
   rl/branches/persistence/ui/src/WindowFactory.cpp
Log:
merged with trunk

Modified: rl/branches/persistence/core/src/ConfigurationManager.cpp
===================================================================
--- rl/branches/persistence/core/src/ConfigurationManager.cpp	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/core/src/ConfigurationManager.cpp	2008-11-26 19:42:03 UTC (rev 4613)
@@ -111,6 +111,7 @@
         addSetting("Action keys", "showjournalwindow", "J");
         addSetting("Action keys", "showcharactersheet", "C");
         addSetting("Action keys", "togglecharacterstatewindow", "O");
+        addSetting("Action keys", "togglecharacterselectionwindow", "Y");
         addSetting("Action keys", "toggleingameglobalmenu", "F10");
         addSetting("Action keys", "shownextdebugwindowpage", "Ctrl+M");
         addSetting("Action keys", "showobjectactions", "U");

Modified: rl/branches/persistence/core/src/JobScheduler.cpp
===================================================================
--- rl/branches/persistence/core/src/JobScheduler.cpp	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/core/src/JobScheduler.cpp	2008-11-26 19:42:03 UTC (rev 4613)
@@ -219,13 +219,26 @@
                 writer->setAttributeValueAsInt64(jobNode, "timeLastCall", iter->timeLastCall);
                 writer->setAttributeValueAsBool(jobNode, "called", iter->called);
                 writer->setAttributeValueAsString(jobNode, "classname", iter->job->getClassName());
+                CeGuiString timeSource = "unknown";
+                switch (iter->job->getTimeSource())
+                {
+                    case TimeSource::GAMETIME:
+                        timeSource = "gametime";
+                        break;
+                    case TimeSource::REALTIME_CONTINUOUS:
+                        timeSource = "realtime_continuous";
+                        break;
+                    case TimeSource::REALTIME_INTERRUPTABLE:
+                        timeSource = "realtime_interruptable";
+                        break;
+                }
+                writer->setAttributeValueAsString(jobNode, "time", timeSource);
 
                 PropertyMap map = iter->job->getAllProperties()->toPropertyMap();
                 writer->writeEachPropertyToElem(jobNode, map);
             }
         }
     }*/
-
     //void JobScheduler::readData(SaveGameFileReader* reader)
     //{
     //    // delete and discard old jobs
@@ -285,24 +298,37 @@
     //                        continue;
     //                    }
 
-    //                    AbstractJob* job = it->second();
-    //                    if (job == NULL)
-    //                    {
-    //                        LOG_ERROR(Logger::CORE, "Fehler beim Erstellen eines Objekts der Job-Klasse '" + className + "'!");
-    //                        continue;
-    //                    }
-    //                    PropertyRecordPtr properties = reader->getPropertiesAsRecord(xmlJob);
-    //                    job->setProperties(properties);
-    //                    
-    //                    
-    //                    unsigned long ticket = ++mTicketCounter;
-    //                    TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(job->getTimeSource());
-    //                    JobEntry entry = {job, NULL, ticket, priority, tokens, start, end, timeLastCall, TimeSource::UNKNOWN, called, false};
-    //                    mJobQueue.push_back(entry);
-    //                }
-    //            }
-    //        }
-    //    }
+//                        AbstractJob* job = it->second();
+//                        if (job == NULL)
+//                        {
+//                            LOG_ERROR(Logger::CORE, "Fehler beim Erstellen eines Objekts der Job-Klasse '" + className + "'!");//
+//                            continue;
+//                        }
+//                        PropertyRecordPtr properties = reader->getPropertiesAsRecord(xmlJob);
+//                       job->setProperties(properties);
+//                        
+//                        CeGuiString timeSourceStr = reader->getAttributeValueAsString(xmlJob, "time");
+//                        TimeSource::TimeSourceType ts = TimeSource::UNKNOWN;
+//                        if (timeSourceStr == "gametime") 
+//                        {
+//                            ts = TimeSource::GAMETIME;
+//                        }
+//                        else if (timeSourceStr == "realtime_continuous") 
+//                        {
+//                            ts = TimeSource::REALTIME_CONTINUOUS;
+//                        }
+//                        else if (timeSourceStr == "realtime_interruptable") 
+//                        {
+//                            ts = TimeSource::REALTIME_INTERRUPTABLE;
+//                        }
+//                        
+//                        unsigned long ticket = ++mTicketCounter;
+//                        JobEntry entry = {job, NULL, ticket, priority, tokens, start, end, timeLastCall, ts, called, false};
+//                        mJobQueue.push_back(entry);
+//                    }
+//                }
+//            }
+//        }
 
     //    reader->shutdownXml();
     //}

Modified: rl/branches/persistence/rules/include/GameObject.h
===================================================================
--- rl/branches/persistence/rules/include/GameObject.h	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/rules/include/GameObject.h	2008-11-26 19:42:03 UTC (rev 4613)
@@ -65,6 +65,7 @@
         static const Ogre::String PROPERTY_MASS; 
         static const Ogre::String PROPERTY_ACTIONS; 
         static const Ogre::String PROPERTY_DEFAULT_ACTION;
+        static const Ogre::String PROPERTY_IMAGENAME;
 
         static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
         static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
@@ -81,6 +82,9 @@
         const CeGuiString& getDescription() const;
         void setDescription(const CeGuiString& description);
 
+		const CeGuiString& getImageName() const;
+		void setImageName(const CeGuiString& name);
+        
         const CeGuiString& getMeshfile() const;
         void setMeshfile(const CeGuiString& meshfile);
 
@@ -202,6 +206,7 @@
         
         CeGuiString mName;
         CeGuiString mDescription;
+        CeGuiString mImageName;
         CeGuiString mMeshfile;
 		MeshPartMap mMeshParts;
         CeGuiString mSubmeshPreName;

Modified: rl/branches/persistence/rules/include/Item.h
===================================================================
--- rl/branches/persistence/rules/include/Item.h	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/rules/include/Item.h	2008-11-26 19:42:03 UTC (rev 4613)
@@ -58,7 +58,6 @@
         static const Ogre::String CLASS_NAME;
 
         static const Ogre::String PROPERTY_ITEMTYPE;
-        static const Ogre::String PROPERTY_IMAGENAME;
         static const Ogre::String PROPERTY_SIZE;
         static const Ogre::String PROPERTY_SUBMESHNAME;
 
@@ -68,9 +67,6 @@
 		void setItemType(ItemType itemType);
 		ItemType getItemType() const;
 
-		const CeGuiString& getImageName() const;
-		void setImageName(const CeGuiString& name);
-
         const CeGuiString& getSubmeshName() const;
         void setSubmeshName(const CeGuiString& name);
 
@@ -85,11 +81,11 @@
 
 
         /**
-         * F?gt das Verhalten f?r die GO-States: GOS_READY, GOS_HELD und GOS_IN_POSSESION hinzu.
-         * @warning Bevor einer der drei States gesetzt wird, sollte zun?chst die Funktion removeOldState
-         * aufgerufen werden, dann m?ssen Owner und ParentSlot/ParentContainer gesetzt werden und
+         * F?gt das Verhalten f?r die GO-States: GOS_READY, GOS_HELD und GOS_IN_POSSESION hinzu.
+         * @warning Bevor einer der drei States gesetzt wird, sollte zun?chst die Funktion removeOldState
+         * aufgerufen werden, dann m?ssen Owner und ParentSlot/ParentContainer gesetzt werden und
          * eventuell doCreateActor. Als letztes muss diese Funktion mit dem neuen State aufgerufen werden.
-         * Die Reihenfolge ist wichtig, damit die onStateChange-Funktionen funktionieren k?nnen!
+         * Die Reihenfolge ist wichtig, damit die onStateChange-Funktionen funktionieren k?nnen!
          **/
         virtual void setState(GameObjectState state);
         virtual void removeOldState();
@@ -110,7 +106,6 @@
         void doCreateActor();
     protected:
 		ItemType mItemType;
-		CeGuiString mImageName;
         CeGuiString mSubmeshName;
 		std::pair<int,int> mSize;
         GameObject* mOwner;

Modified: rl/branches/persistence/rules/include/PartyManager.h
===================================================================
--- rl/branches/persistence/rules/include/PartyManager.h	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/rules/include/PartyManager.h	2008-11-26 19:42:03 UTC (rev 4613)
@@ -25,11 +25,11 @@
 {
     class Creature;
 
+    typedef std::vector<Creature*> Party;
+
     class _RlRulesExport PartyManager : public Ogre::Singleton<PartyManager>
     {
     public:
-		typedef std::vector<Creature*> Party;
-
 		PartyManager();
         
         Creature* getActiveCharacter() const;

Modified: rl/branches/persistence/rules/src/GameObject.cpp
===================================================================
--- rl/branches/persistence/rules/src/GameObject.cpp	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/rules/src/GameObject.cpp	2008-11-26 19:42:03 UTC (rev 4613)
@@ -59,10 +59,12 @@
     const Ogre::String GameObject::PROPERTY_MASS = "mass";
     const Ogre::String GameObject::PROPERTY_ACTIONS = "actions";
     const Ogre::String GameObject::PROPERTY_DEFAULT_ACTION = "defaultaction";
-
+    const Ogre::String GameObject::PROPERTY_IMAGENAME = "imagename";
+    
 	GameObject::GameObject(const CeGuiString &id)
         :   mName(""),
             mDescription(""),
+            mImageName(""),
             mMeshfile(""),
 			mMeshParts(),
             mQueryFlags(QUERYFLAG_GAMEOBJECT),
@@ -138,6 +140,16 @@
         mDescription = description;
     }
 
+	void GameObject::setImageName(const CeGuiString& name)
+	{
+		mImageName = name;
+	}
+    
+	const CeGuiString& GameObject::getImageName() const
+	{
+		return mImageName;
+	}
+    
     const CeGuiString& GameObject::getMeshfile() const
     {
         return mMeshfile;
@@ -533,6 +545,10 @@
         {
             prop.setValue(mDescription);
         }
+        else if (key == PROPERTY_IMAGENAME)
+        {
+            prop.setValue(mImageName);
+        }
         else if (key == PROPERTY_MESHFILE)
         {
             prop.setValue(mMeshfile);
@@ -587,6 +603,10 @@
             {
                 setDescription(value.toString());
             }
+            else if (key == PROPERTY_IMAGENAME)
+            {
+                setImageName(value.toString());
+            }
             else if (key == PROPERTY_MESHFILE)
             {
                 setMeshfile(value.toString());
@@ -675,6 +695,7 @@
         keys.insert(PROPERTY_MESHPARTS);
         keys.insert(PROPERTY_GEOMETRY_TYPE);
         keys.insert(PROPERTY_MASS);
+        keys.insert(PROPERTY_IMAGENAME);
         return keys;
     }
 

Modified: rl/branches/persistence/rules/src/Item.cpp
===================================================================
--- rl/branches/persistence/rules/src/Item.cpp	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/rules/src/Item.cpp	2008-11-26 19:42:03 UTC (rev 4613)
@@ -29,7 +29,6 @@
 {
     const Ogre::String Item::CLASS_NAME = "Item";
 
-    const Ogre::String Item::PROPERTY_IMAGENAME = "imagename";
     const Ogre::String Item::PROPERTY_ITEMTYPE = "itemtype";
     const Ogre::String Item::PROPERTY_SIZE = "size";
     const Ogre::String Item::PROPERTY_SUBMESHNAME = "submeshfile";
@@ -37,7 +36,6 @@
 	Item::Item(const CeGuiString &id)
         : GameObject(id),
 		mItemType(ITEMTYPE_OTHER),
-		mImageName(""),
 		mSize(pair<int,int>(1,1)),
         mOwner(NULL),
         mParentSlot(NULL),
@@ -62,16 +60,6 @@
 		return mItemType;
 	}
 
-	void Item::setImageName(const CeGuiString& name)
-	{
-		mImageName = name;
-	}
-
-	const CeGuiString& Item::getImageName() const
-	{
-		return mImageName;
-	}
-
 	bool Item::isContainer() const
 	{
 		return false;
@@ -176,12 +164,8 @@
 
     void Item::setProperty(const CeGuiString& key, const Property& value)
     {
-        if (key == Item::PROPERTY_IMAGENAME)
+        if (key == Item::PROPERTY_SIZE)
         {
-            mImageName = value.toString();
-        }
-        else if (key == Item::PROPERTY_SIZE)
-        {
             mSize = value.toIntPair();
         }
         else if (key == Item::PROPERTY_ITEMTYPE)
@@ -200,12 +184,8 @@
 
     const Property Item::getProperty(const CeGuiString& key) const
     {
-        if (key == Item::PROPERTY_IMAGENAME)
+        if (key == Item::PROPERTY_SIZE)
         {
-            return Property(mImageName);
-        }
-        else if (key == Item::PROPERTY_SIZE)
-        {
             return Property(mSize);
         }
         else if (key == Item::PROPERTY_ITEMTYPE)
@@ -225,7 +205,7 @@
     PropertyKeys Item::getAllPropertyKeys() const
     {
         PropertyKeys keys(GameObject::getAllPropertyKeys());
-        keys.insert(Item::PROPERTY_IMAGENAME);
+        keys.insert(Item::PROPERTY_SUBMESHNAME);
         keys.insert(Item::PROPERTY_SIZE);
         keys.insert(Item::PROPERTY_ITEMTYPE);
         return keys;

Modified: rl/branches/persistence/script/swig/RlUi.swig
===================================================================
--- rl/branches/persistence/script/swig/RlUi.swig	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/script/swig/RlUi.swig	2008-11-26 19:42:03 UTC (rev 4613)
@@ -103,6 +103,7 @@
     void toggleConsole();
     void toggleDebugWindow();
     void toggleGameLogWindow();
+    void toggleCharacterSelectionWindow();
     void toggleCharacterStateWindow();
     void toggleInGameGlobalMenu();
     void toggleInventoryWindow();

Modified: rl/branches/persistence/ui/RlUI2005.vcproj
===================================================================
--- rl/branches/persistence/ui/RlUI2005.vcproj	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/ui/RlUI2005.vcproj	2008-11-26 19:42:03 UTC (rev 4613)
@@ -432,6 +432,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\include\CharacterSelectionWindow.h"
+					>
+				</File>
+				<File
 					RelativePath=".\include\CharacterSheetWindow.h"
 					>
 				</File>
@@ -677,6 +681,10 @@
 					>
 				</File>
 				<File
+					RelativePath=".\src\CharacterSelectionWindow.cpp"
+					>
+				</File>
+				<File
 					RelativePath=".\src\CharacterSheetWindow.cpp"
 					>
 				</File>

Modified: rl/branches/persistence/ui/include/AbstractWindow.h
===================================================================
--- rl/branches/persistence/ui/include/AbstractWindow.h	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/ui/include/AbstractWindow.h	2008-11-26 19:42:03 UTC (rev 4613)
@@ -1,140 +1,142 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __AbstractWindow_H__
-#define __AbstractWindow_H__
-
-#include "UiPrerequisites.h"
-
-
-#include <CEGUIWindow.h>
-#include <elements/CEGUIEditbox.h>
-#include <elements/CEGUIListbox.h>
-#include <elements/CEGUIMultiColumnList.h>
-#include <elements/CEGUIMultiLineEditbox.h>
-#include <elements/CEGUIProgressBar.h>
-#include <elements/CEGUIMenuBase.h>
-#include <elements/CEGUIMenuItem.h>
-#include <elements/CEGUIPushButton.h>
-#include <elements/CEGUICombobox.h>
-#include <elements/CEGUIComboDropList.h>
-#include <elements/CEGUIScrollablePane.h>
-#include <elements/CEGUISlider.h>
-#include <elements/CEGUITabControl.h>
-
-namespace rl {
-
-	class WindowUpdateTask;
-
-	/**
-	 * This is the base class for all UI windows
-	 */
-	class _RlUiExport AbstractWindow
-	{
-	public:
-
-		enum WindowInputType
-		{
-			WIT_NONE = 0x00,
-			WIT_MOUSE_INPUT = 0x01,
-			WIT_KEYBOARD_INPUT = 0x02
-		};
-
-		virtual ~AbstractWindow();	
-
-		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
-		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile);
-
-		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
-		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix);
-
-		/// gets the CEGUI root
-		static CEGUI::Window* getRoot();
-
-		/// gets the wrapped CEGUI window
-		CEGUI::Window* getWindow();
-
-		CEGUI::Window* getWindow(const char* name, const char* requiredClass = NULL);
-		CEGUI::Editbox* getEditbox(const char* name);
-		CEGUI::Listbox* getListbox(const char* name);
-		CEGUI::MultiColumnList* getMultiColumnList(const char* name);
-		CEGUI::MultiLineEditbox* getMultiLineEditbox(const char* name);
-		CEGUI::ProgressBar* getProgressBar(const char* name);
-		CEGUI::MenuBase* getMenu(const char* name);
-		CEGUI::MenuItem* getMenuItem(const char* name);
-		CEGUI::PushButton* getPushButton(const char* name);
-		CEGUI::Combobox* getCombobox(const char* name);
-		CEGUI::ComboDropList* getComboDropList(const char* name);
-        CEGUI::ScrollablePane* getScrollablePane(const char* name);
-		CEGUI::Slider* getSlider(const char* name);
-		CEGUI::TabControl* getTabControl(const char* name);
-
-		int getWindowInputType();
-
-        virtual bool isVisible();
-        virtual void setVisible(bool visible, bool destroyAfterHide = false);
-
-		bool isModal();
-		bool isClosingOnEscape();
-
-		const CeGuiString& getName() const;
-		const Ogre::Real& getNormalAlpha() const;
-
-		virtual void windowHid();
-
-        // return true, if the specified key should be repeated if pressed down
-        virtual bool wantsKeyToRepeat(const int &key) {return false;}
-
-	protected:
-		AbstractWindow(
-			const CeGuiString& xmlfile, 
-			int inputType, 
-			bool closeOnEscape = true,
-			bool modal = false);
-
-		const CeGuiString& getNamePrefix() const;
-		
-		void centerWindow();
-		bool destroyWindow();		
-		bool hideWindow();
-
-		void bindDestroyWindowToClick(CEGUI::Window* button);
-        void bindHideWindowToClick(CEGUI::Window* button);
-		void bindDestroyWindowToXButton();
-		void bindHideWindowToXButton();
-
-		const CeGuiString& getUserDataType(CEGUI::Window* window) const;
-		void setUserDataType(CEGUI::Window* window, const CeGuiString& typeDescription) const;
-
-		CEGUI::Window* mWindow;
-		bool mVisible;
-
-	private:
-		
-		int mWindowInputType;
-		CeGuiString mNamePrefix;
-		CeGuiString mName;
-		bool mModal;
-		bool mCloseOnEscape;
-		Ogre::Real mNormalAlpha;
-
-		static int sNumAbstractWindows;
-
-	};
-
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __AbstractWindow_H__
+#define __AbstractWindow_H__
+
+#include "UiPrerequisites.h"
+
+
+#include <CEGUIWindow.h>
+#include <elements/CEGUICheckbox.h>
+#include <elements/CEGUIEditbox.h>
+#include <elements/CEGUIListbox.h>
+#include <elements/CEGUIMultiColumnList.h>
+#include <elements/CEGUIMultiLineEditbox.h>
+#include <elements/CEGUIProgressBar.h>
+#include <elements/CEGUIMenuBase.h>
+#include <elements/CEGUIMenuItem.h>
+#include <elements/CEGUIPushButton.h>
+#include <elements/CEGUICombobox.h>
+#include <elements/CEGUIComboDropList.h>
+#include <elements/CEGUIScrollablePane.h>
+#include <elements/CEGUISlider.h>
+#include <elements/CEGUITabControl.h>
+
+namespace rl {
+
+	class WindowUpdateTask;
+
+	/**
+	 * This is the base class for all UI windows
+	 */
+	class _RlUiExport AbstractWindow
+	{
+	public:
+
+		enum WindowInputType
+		{
+			WIT_NONE = 0x00,
+			WIT_MOUSE_INPUT = 0x01,
+			WIT_KEYBOARD_INPUT = 0x02
+		};
+
+		virtual ~AbstractWindow();	
+
+		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
+		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile);
+
+		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
+		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix);
+
+		/// gets the CEGUI root
+		static CEGUI::Window* getRoot();
+
+		/// gets the wrapped CEGUI window
+		CEGUI::Window* getWindow();
+
+		CEGUI::Window* getWindow(const char* name, const char* requiredClass = NULL);
+		CEGUI::Editbox* getEditbox(const char* name);
+		CEGUI::Listbox* getListbox(const char* name);
+		CEGUI::MultiColumnList* getMultiColumnList(const char* name);
+		CEGUI::MultiLineEditbox* getMultiLineEditbox(const char* name);
+		CEGUI::ProgressBar* getProgressBar(const char* name);
+		CEGUI::MenuBase* getMenu(const char* name);
+		CEGUI::MenuItem* getMenuItem(const char* name);
+		CEGUI::PushButton* getPushButton(const char* name);
+		CEGUI::Combobox* getCombobox(const char* name);
+		CEGUI::ComboDropList* getComboDropList(const char* name);
+        CEGUI::ScrollablePane* getScrollablePane(const char* name);
+		CEGUI::Slider* getSlider(const char* name);
+		CEGUI::TabControl* getTabControl(const char* name);
+        CEGUI::Checkbox* getCheckbox(const char* name);
+
+		int getWindowInputType();
+
+        virtual bool isVisible();
+        virtual void setVisible(bool visible, bool destroyAfterHide = false);
+
+		bool isModal();
+		bool isClosingOnEscape();
+
+		const CeGuiString& getName() const;
+		const Ogre::Real& getNormalAlpha() const;
+
+		virtual void windowHid();
+
+        // return true, if the specified key should be repeated if pressed down
+        virtual bool wantsKeyToRepeat(const int &key) {return false;}
+
+	protected:
+		AbstractWindow(
+			const CeGuiString& xmlfile, 
+			int inputType, 
+			bool closeOnEscape = true,
+			bool modal = false);
+
+		const CeGuiString& getNamePrefix() const;
+		
+		void centerWindow();
+		bool destroyWindow();		
+		bool hideWindow();
+
+		void bindDestroyWindowToClick(CEGUI::Window* button);
+        void bindHideWindowToClick(CEGUI::Window* button);
+		void bindDestroyWindowToXButton();
+		void bindHideWindowToXButton();
+
+		const CeGuiString& getUserDataType(CEGUI::Window* window) const;
+		void setUserDataType(CEGUI::Window* window, const CeGuiString& typeDescription) const;
+
+		CEGUI::Window* mWindow;
+		bool mVisible;
+
+	private:
+		
+		int mWindowInputType;
+		CeGuiString mNamePrefix;
+		CeGuiString mName;
+		bool mModal;
+		bool mCloseOnEscape;
+		Ogre::Real mNormalAlpha;
+
+		static int sNumAbstractWindows;
+
+	};
+
+}
+
+#endif

Copied: rl/branches/persistence/ui/include/CharacterSelectionWindow.h (from rev 4612, rl/trunk/engine/ui/include/CharacterSelectionWindow.h)

Modified: rl/branches/persistence/ui/include/GameSettings.h
===================================================================
--- rl/branches/persistence/ui/include/GameSettings.h	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/ui/include/GameSettings.h	2008-11-26 19:42:03 UTC (rev 4613)
@@ -82,11 +82,17 @@
 		 * configuration section.
 		 */
 		bool onRenderSystemChanged();
+        
+        void update();
 
 		std::list<SoundDriverConfigComponent*> mSoundDriverConfigs;   //!< List of registered sounddriver configuration components
 		SoundDriverConfigComponent* mCurrentSoundDriverConfig;        //!< Configuration component of currently selected sound driver
 		std::list<RenderSystemConfigComponent*> mRenderSystemConfigs; //!< List of registered rendersystem configuration components
 		RenderSystemConfigComponent* mCurrentRenderSystemConfig;      //!< Configuration component of currently selected rendersystem
+        
+        CEGUI::Combobox* mVideoRenderer;
+        CEGUI::Combobox* mVideoResolution;
+        CEGUI::Checkbox* mVideoFullscreen;
 	};
 }
 

Modified: rl/branches/persistence/ui/include/WindowFactory.h
===================================================================
--- rl/branches/persistence/ui/include/WindowFactory.h	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/ui/include/WindowFactory.h	2008-11-26 19:42:03 UTC (rev 4613)
@@ -1,142 +1,145 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __WindowFactory_H__
-#define __WindowFactory_H__
-
-#include "UiPrerequisites.h"
-
-#include "FixRubyHeaders.h"        // die Makros sind hier vor Ruby schon definiert
-#include <ruby.h>
-#include "FixRubyHeaders.h"
-
-namespace rl {
-
-    class Actor;
-    class AbstractWindow;
-    class CharacterStateWindow;
-    class CharacterSheetWindow;
-    class CloseConfirmationWindow;
-    class CombatWindow;
-    class Console;
-    class Container;
-    class Creature;
-    class DebugWindow;
-    class DialogCharacter;
-    class GameLoggerWindow;
-    class GameObject;
-    class PropertiesWindow;
-    class GameSettings;
-    class InfoPopup;
-    class InGameMenuWindow;
-    class InventoryWindow;
-    class JournalWindow;
-    class LogWindow;
-    class MainMenuWindow;
-    class ObjectDescriptionWindow;
-    class GameSaveLoadWindow;
-    class MainMenuLoadWindow;
-    class WindowUpdater;
-
-    class _RlUiExport WindowFactory : public Ogre::Singleton<WindowFactory>
-    {
-    public:
-        enum PopupIcon
-        {
-            ICON_ERROR = 1,
-            ICON_QUEST
-        };
-
-        WindowFactory();
-        ~WindowFactory();
-
-        void initialize();
-
-        void setActiveCharacter(Creature* character);
-
-        void showActionChoice(GameObject* obj);
-        void showAboutWindow();
-        void showCharacterActionChoice();
-        void showCharacterSheet();
-        void showCharacterSheet(Creature* chara);
-        void showContainerContent(Container* container);
-        void showDescriptionWindow(GameObject* obj);
-        void showPropertiesWindow(GameObject* obj);
-        void showExitConfirmation();
-        void showJournalWindow();
-        void showLogfiles();
-        void showMessageWindow(const CeGuiString& message);
-        void showMainMenu();
-        void showObjectDescription(GameObject* object);
-        void showPlaylist();
-        void showGameSaveLoadWindow();
-        void showMainMenuLoadWindow(MainMenuWindow* win);
-		void hideMainMenuLoadWindow();
-        void showPopupMessage(int popupTypes);
-        void showGameOverWindow();
-        /**
-         * Creates a GameSettings object and displays its layout file on screen
-         */
-        void showGameSettings();
-
-        void toggleConsole();
-        void toggleDebugWindow();
-        void toggleGameLogWindow();
-        void toggleCharacterStateWindow();
-        void toggleInGameGlobalMenu();
-        void toggleInventoryWindow();
-        void notifyInventoryWindowDestroyed();
-		bool isInventoryWindowDestroyed();
-
-        CombatWindow* getCombatWindow();
-
-        void checkForErrors();
-        GameLoggerWindow* getGameLogger();
-
-        void update();
-
-        /// Writes Text into the Console or other output media
-        void writeToConsole(std::string text);
-        static VALUE consoleWrite(VALUE self, VALUE str);
-
-        /// Change shown DebugWindow page
-        void showNextDebugWindowPage();
-
-    private:
-        void logAllWindows();
-
-        GameLoggerWindow* mGameLogger;
-        CharacterStateWindow* mCharacterStateWindow;
-        InGameMenuWindow* mInGameMenuWindow;
-        CharacterSheetWindow* mCharacterSheet;
-        JournalWindow* mJournalWindow;
-        InventoryWindow* mInventoryWindow;
-        LogWindow* mLogWindow;
-        DebugWindow* mDebugWindow;
-        Console* mConsole;
-        InfoPopup* mInfoPopup;
-        Actor* mObjectNameText;
-        GameObject* mShownObject;
-        ObjectDescriptionWindow* mObjectDescriptionWindow;
-        MainMenuWindow* mMainMenuWindow;
-		MainMenuLoadWindow* mMainMenuLoadWindow;
-        CloseConfirmationWindow* mCloseConfirmationWindow;
-        GameSettings* mGameSettings;
-        CombatWindow* mCombatWindow;
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __WindowFactory_H__
+#define __WindowFactory_H__
+
+#include "UiPrerequisites.h"
+
+#include "FixRubyHeaders.h"        // die Makros sind hier vor Ruby schon definiert
+#include <ruby.h>
+#include "FixRubyHeaders.h"
+
+namespace rl {
+
+    class Actor;
+    class AbstractWindow;
+    class CharacterSelectionWindow;
+    class CharacterSheetWindow;
+    class CharacterStateWindow;
+    class CloseConfirmationWindow;
+    class CombatWindow;
+    class Console;
+    class Container;
+    class Creature;
+    class DebugWindow;
+    class DialogCharacter;
+    class GameLoggerWindow;
+    class GameObject;
+    class PropertiesWindow;
+    class GameSettings;
+    class InfoPopup;
+    class InGameMenuWindow;
+    class InventoryWindow;
+    class JournalWindow;
+    class LogWindow;
+    class MainMenuWindow;
+    class ObjectDescriptionWindow;
+    class GameSaveLoadWindow;
+    class MainMenuLoadWindow;
+    class WindowUpdater;
+
+    class _RlUiExport WindowFactory : public Ogre::Singleton<WindowFactory>
+    {
+    public:
+        enum PopupIcon
+        {
+            ICON_ERROR = 1,
+            ICON_QUEST
+        };
+
+        WindowFactory();
+        ~WindowFactory();
+
+        void initialize();
+
+        void setActiveCharacter(Creature* character);
+
+        void showActionChoice(GameObject* obj);
+        void showAboutWindow();
+        void showCharacterActionChoice();
+        void showCharacterSheet();
+        void showCharacterSheet(Creature* chara);
+        void showContainerContent(Container* container);
+        void showDescriptionWindow(GameObject* obj);
+        void showPropertiesWindow(GameObject* obj);
+        void showExitConfirmation();
+        void showJournalWindow();
+        void showLogfiles();
+        void showMessageWindow(const CeGuiString& message);
+        void showMainMenu();
+        void showObjectDescription(GameObject* object);
+        void showPlaylist();
+        void showGameSaveLoadWindow();
+        void showMainMenuLoadWindow(MainMenuWindow* win);
+		void hideMainMenuLoadWindow();
+        void showPopupMessage(int popupTypes);
+        void showGameOverWindow();
+        /**
+         * Creates a GameSettings object and displays its layout file on screen
+         */
+        void showGameSettings();
+
+        void toggleConsole();
+        void toggleDebugWindow();
+        void toggleGameLogWindow();
+        void toggleCharacterStateWindow();
+        void toggleCharacterSelectionWindow();
+        void toggleInGameGlobalMenu();
+        void toggleInventoryWindow();
+        void notifyInventoryWindowDestroyed();
+		bool isInventoryWindowDestroyed();
+
+        CombatWindow* getCombatWindow();
+
+        void checkForErrors();
+        GameLoggerWindow* getGameLogger();
+
+        void update();
+
+        /// Writes Text into the Console or other output media
+        void writeToConsole(std::string text);
+        static VALUE consoleWrite(VALUE self, VALUE str);
+
+        /// Change shown DebugWindow page
+        void showNextDebugWindowPage();
+
+    private:
+        void logAllWindows();
+
+        GameLoggerWindow* mGameLogger;
+        CharacterStateWindow* mCharacterStateWindow;
+        InGameMenuWindow* mInGameMenuWindow;
+        CharacterSheetWindow* mCharacterSheet;
+        JournalWindow* mJournalWindow;
+        InventoryWindow* mInventoryWindow;
+        LogWindow* mLogWindow;
+        DebugWindow* mDebugWindow;
+        Console* mConsole;
+        InfoPopup* mInfoPopup;
+        Actor* mObjectNameText;
+        GameObject* mShownObject;
+        ObjectDescriptionWindow* mObjectDescriptionWindow;
+        MainMenuWindow* mMainMenuWindow;
+		MainMenuLoadWindow* mMainMenuLoadWindow;
+        CloseConfirmationWindow* mCloseConfirmationWindow;
+        GameSettings* mGameSettings;
+        CombatWindow* mCombatWindow;
+        CharacterSelectionWindow* mCharacterSelectionWindow;
+    };
+}
+
+#endif

Modified: rl/branches/persistence/ui/src/AbstractWindow.cpp
===================================================================
--- rl/branches/persistence/ui/src/AbstractWindow.cpp	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/ui/src/AbstractWindow.cpp	2008-11-26 19:42:03 UTC (rev 4613)
@@ -1,319 +1,325 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include <boost/bind.hpp>
-#include <CEGUIWindowManager.h>
-#include <elements/CEGUIFrameWindow.h>
-
-#include "UiPrerequisites.h"
-#include "Exception.h"
-
-#include "UiSubsystem.h"
-#include "AbstractWindow.h"
-#include "CeGuiHelper.h"
-#include "WindowManager.h"
-#include "WindowFadeJob.h"
-#include "JobScheduler.h"
-
-using namespace std;
-using namespace CEGUI;
-using namespace Ogre;
-
-namespace rl
-{
-
-	int AbstractWindow::sNumAbstractWindows = 0;
-
-	AbstractWindow::AbstractWindow(const CeGuiString& xmlfile, int inputType, bool closeOnEscape, bool modal)
-	: mVisible(false),
-		mModal(modal),
-		mWindowInputType(inputType),
-		mCloseOnEscape(closeOnEscape)
-	{
-        LOG_MESSAGE(Logger::UI,
-		    "Lade Fenster '" + Ogre::String(xmlfile.c_str()) + "'");
-   		mWindow = AbstractWindow::loadWindow(xmlfile, mNamePrefix);
-		if (mWindow == NULL)
-		{
-			Throw(rl::IllegalStateException, Ogre::String("Could not load window '")+xmlfile.c_str()+"'.");
-		}
-
-		getRoot()->addChildWindow(mWindow);
-
-        if (modal)
-		{
-			mWindow->setModalState(true);
-			mWindow->setAlwaysOnTop(true);
-            mWindow->moveToFront();
-            mWindow->show();
-		}
-        else
-        {
-       		mWindow->hide();
-        }
-
-		mNormalAlpha = mWindow->getAlpha();
-		mName = mWindow->getName();
-		WindowManager::getSingleton().registerWindow(this);
-		mWindow->subscribeEvent(Window::EventActivated,
-			boost::bind(
-				&rl::WindowManager::handleMovedToFront,
-				rl::WindowManager::getSingletonPtr(),
-				this));
-	}
-
-	AbstractWindow::~AbstractWindow()
-	{
-		mWindow->hide();
-		mWindow->removeAllEvents();
-		WindowManager::getSingleton().unregisterWindow(this);
-		getRoot()->removeChildWindow(mWindow);
-		CEGUI::WindowManager::getSingleton().destroyWindow(mWindow);
-	}
-
-	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile)
-	{
-		CeGuiString prefix = "";
-		return loadWindow(xmlfile, prefix);
-	}
-
-
-	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix)
-	{
-		CeGuiString namePrefix;
-		if (prefix == "")
-			prefix.assign(StringConverter::toString(sNumAbstractWindows));
-		sNumAbstractWindows++;
-
-		CEGUI::Window* window = NULL;
-		try
-		{
-			window = CEGUI::WindowManager::getSingleton().loadWindowLayout(xmlfile, prefix);
-		}
-		catch(...)
-		{
-		}
-
-		return window;
-	}
-
-	bool AbstractWindow::isVisible()
-	{
-		return mVisible;
-	}
-
-	void AbstractWindow::setVisible(bool visible, bool destroy)
-	{
-		if(mVisible != visible)
-		{
-			if (visible)
-			{
-                JobScheduler::getSingleton().addJob(
-                    new WindowFadeJob(this, WindowFadeJob::FADE_IN, mNormalAlpha));
-			}
-			else
-			{
-                JobScheduler::getSingleton().addJob(
-                    new WindowFadeJob(this,
-                    destroy ? WindowFadeJob::FADE_OUT_AND_DESTROY : WindowFadeJob::FADE_OUT,
-                    0.0f));
-			}
-            WindowManager::getSingleton()._visiblityChanged(this, visible);
-            mVisible = visible;
-		}
-	}
-
-	const Ogre::Real& AbstractWindow::getNormalAlpha() const
-	{
-		return mNormalAlpha;
-	}
-
-	bool AbstractWindow::isModal()
-	{
-		return mModal;
-	}
-
-	bool AbstractWindow::isClosingOnEscape()
-	{
-		return mCloseOnEscape;
-	}
-
-	int AbstractWindow::getWindowInputType()
-	{
-		return mWindowInputType;
-	}
-
-	CEGUI::Window* AbstractWindow::getRoot()
-	{
-		return CEGUI::WindowManager::getSingleton().getWindow(
-			(utf8*)UiSubsystem::CEGUI_ROOT);
-	}
-
-	Window* AbstractWindow::getWindow(const char* name, const char* requiredClass)
-	{
-		CEGUI::Window* wnd =
-			CEGUI::WindowManager::getSingleton().getWindow(
-				mNamePrefix + (utf8*)name);
-
-		if (wnd == NULL)
-			Throw(
-				rl::NullPointerException,
-				"Window "
-				+ Ogre::String(name)
-				+ " is NULL");
-
-		if (requiredClass != NULL && !wnd->testClassName(requiredClass))
-			Throw(
-				rl::NullPointerException,
-				"Window "
-				+ Ogre::String(name)
-				+ " has not the required class "
-				+ Ogre::String(requiredClass));
-
-		return wnd;
-	}
-
-	Editbox* AbstractWindow::getEditbox(const char* name)
-	{
-		return static_cast<Editbox*>(getWindow(name, "Editbox"));
-	}
-
-	Listbox* AbstractWindow::getListbox(const char* name)
-	{
-		return static_cast<Listbox*>(getWindow(name, "Listbox"));
-	}
-
-	MultiColumnList* AbstractWindow::getMultiColumnList(const char* name)
-	{
-		return static_cast<MultiColumnList*>(getWindow(name, "MultiColumnList"));
-	}
-
-	MultiLineEditbox* AbstractWindow::getMultiLineEditbox(const char* name)
-	{
-		return static_cast<MultiLineEditbox*>(getWindow(name, "MultiLineEditbox"));
-	}
-
-	ProgressBar* AbstractWindow::getProgressBar(const char* name)
-	{
-		return static_cast<ProgressBar*>(getWindow(name, "ProgressBar"));
-	}
-
-	MenuBase* AbstractWindow::getMenu(const char* name)
-	{
-		return static_cast<MenuBase*>(getWindow(name, "MenuBase"));
-	}
-
-	MenuItem* AbstractWindow::getMenuItem(const char* name)
-	{
-		return static_cast<MenuItem*>(getWindow(name, "MenuItem"));
-	}
-
-	PushButton* AbstractWindow::getPushButton(const char* name)
-	{
-		return static_cast<PushButton*>(getWindow(name, "PushButton"));
-	}
-
-	Combobox* AbstractWindow::getCombobox(const char* name)
-	{
-		return static_cast<Combobox*>(getWindow(name, "Combobox"));
-	}
-
-	ComboDropList* AbstractWindow::getComboDropList(const char* name)
-	{
-		return static_cast<ComboDropList*>(getWindow(name, "ComboDropList"));
-	}
-
-    ScrollablePane* AbstractWindow::getScrollablePane(const char* name)
-    {
-		return static_cast<ScrollablePane*>(getWindow(name, "ScrollablePane"));
-    }
-
-	Slider* AbstractWindow::getSlider(const char* name)
-	{
-		return static_cast<Slider*>(getWindow(name, "Slider"));
-	}
-
-	TabControl* AbstractWindow::getTabControl(const char* name)
-	{
-		return static_cast<TabControl*>(getWindow(name, "TabControl"));
-	}
-
-	const CeGuiString& AbstractWindow::getName() const
-	{
-		return mName;
-	}
-
-	void AbstractWindow::centerWindow()
-	{
-		CEGUI::Size screenSize = System::getSingleton().getRenderer()->getSize();
-		CEGUI::Size windowSize = mWindow->getPixelSize();
-		float x = 0.5f * (screenSize.d_width - windowSize.d_width);
-		float y = 0.5f * (screenSize.d_height - windowSize.d_height);
-		mWindow->setPosition(CeGuiHelper::asAbsolute(CEGUI::Vector2(x, y)));
-	}
-
-	void AbstractWindow::bindDestroyWindowToClick(CEGUI::Window* button)
-	{
-		button->subscribeEvent(Window::EventMouseClick,
-			boost::bind(&AbstractWindow::destroyWindow, this));
-	}
-
-    void AbstractWindow::bindHideWindowToClick(CEGUI::Window* button)
-	{
-		button->subscribeEvent(Window::EventMouseClick,
-			boost::bind(&AbstractWindow::hideWindow, this));
-	}
-
-	void AbstractWindow::bindDestroyWindowToXButton()
-	{
-		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
-			boost::bind(&AbstractWindow::destroyWindow, this));
-	}
-
-	void AbstractWindow::bindHideWindowToXButton()
-	{
-		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
-			boost::bind(&AbstractWindow::hideWindow, this));
-	}
-
-	bool AbstractWindow::destroyWindow()
-	{
-		setVisible(false, true);
-		return true;
-	}
-
-	bool AbstractWindow::hideWindow()
-	{
-		setVisible(false);
-		return true;
-	}
-
-	CEGUI::Window* AbstractWindow::getWindow()
-	{
-		return mWindow;
-	}
-
-	const CeGuiString& AbstractWindow::getNamePrefix() const
-	{
-		return mNamePrefix;
-	}
-
-	void AbstractWindow::windowHid()
-	{
-	}
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include <boost/bind.hpp>
+#include <CEGUIWindowManager.h>
+#include <elements/CEGUIFrameWindow.h>
+
+#include "UiPrerequisites.h"
+#include "Exception.h"
+
+#include "UiSubsystem.h"
+#include "AbstractWindow.h"
+#include "CeGuiHelper.h"
+#include "WindowManager.h"
+#include "WindowFadeJob.h"
+#include "JobScheduler.h"
+
+using namespace std;
+using namespace CEGUI;
+using namespace Ogre;
+
+namespace rl
+{
+
+	int AbstractWindow::sNumAbstractWindows = 0;
+
+	AbstractWindow::AbstractWindow(const CeGuiString& xmlfile, int inputType, bool closeOnEscape, bool modal)
+	: mVisible(false),
+		mModal(modal),
+		mWindowInputType(inputType),
+		mCloseOnEscape(closeOnEscape)
+	{
+        LOG_MESSAGE(Logger::UI,
+		    "Lade Fenster '" + Ogre::String(xmlfile.c_str()) + "'");
+   		mWindow = AbstractWindow::loadWindow(xmlfile, mNamePrefix);
+		if (mWindow == NULL)
+		{
+			Throw(rl::IllegalStateException, Ogre::String("Could not load window '")+xmlfile.c_str()+"'.");
+		}
+
+		getRoot()->addChildWindow(mWindow);
+
+        if (modal)
+		{
+			mWindow->setModalState(true);
+			mWindow->setAlwaysOnTop(true);
+            mWindow->moveToFront();
+            mWindow->show();
+		}
+        else
+        {
+       		mWindow->hide();
+        }
+
+		mNormalAlpha = mWindow->getAlpha();
+		mName = mWindow->getName();
+		WindowManager::getSingleton().registerWindow(this);
+		mWindow->subscribeEvent(Window::EventActivated,
+			boost::bind(
+				&rl::WindowManager::handleMovedToFront,
+				rl::WindowManager::getSingletonPtr(),
+				this));
+	}
+
+	AbstractWindow::~AbstractWindow()
+	{
+		mWindow->hide();
+		mWindow->removeAllEvents();
+		WindowManager::getSingleton().unregisterWindow(this);
+		getRoot()->removeChildWindow(mWindow);
+		CEGUI::WindowManager::getSingleton().destroyWindow(mWindow);
+	}
+
+	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile)
+	{
+		CeGuiString prefix = "";
+		return loadWindow(xmlfile, prefix);
+	}
+
+
+	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix)
+	{
+		CeGuiString namePrefix;
+		if (prefix == "")
+			prefix.assign(StringConverter::toString(sNumAbstractWindows));
+		sNumAbstractWindows++;
+
+		CEGUI::Window* window = NULL;
+		try
+		{
+			window = CEGUI::WindowManager::getSingleton().loadWindowLayout(xmlfile, prefix);
+		}
+		catch(...)
+		{
+		}
+
+		return window;
+	}
+
+	bool AbstractWindow::isVisible()
+	{
+		return mVisible;
+	}
+
+	void AbstractWindow::setVisible(bool visible, bool destroy)
+	{
+		if(mVisible != visible)
+		{
+			if (visible)
+			{
+                JobScheduler::getSingleton().addJob(
+                    new WindowFadeJob(this, WindowFadeJob::FADE_IN, mNormalAlpha));
+			}
+			else
+			{
+                JobScheduler::getSingleton().addJob(
+                    new WindowFadeJob(this,
+                    destroy ? WindowFadeJob::FADE_OUT_AND_DESTROY : WindowFadeJob::FADE_OUT,
+                    0.0f));
+			}
+            WindowManager::getSingleton()._visiblityChanged(this, visible);
+            mVisible = visible;
+		}
+	}
+
+	const Ogre::Real& AbstractWindow::getNormalAlpha() const
+	{
+		return mNormalAlpha;
+	}
+
+	bool AbstractWindow::isModal()
+	{
+		return mModal;
+	}
+
+	bool AbstractWindow::isClosingOnEscape()
+	{
+		return mCloseOnEscape;
+	}
+
+	int AbstractWindow::getWindowInputType()
+	{
+		return mWindowInputType;
+	}
+
+	CEGUI::Window* AbstractWindow::getRoot()
+	{
+		return CEGUI::WindowManager::getSingleton().getWindow(
+			(utf8*)UiSubsystem::CEGUI_ROOT);
+	}
+
+	Window* AbstractWindow::getWindow(const char* name, const char* requiredClass)
+	{
+		CEGUI::Window* wnd =
+			CEGUI::WindowManager::getSingleton().getWindow(
+				mNamePrefix + (utf8*)name);
+
+		if (wnd == NULL)
+			Throw(
+				rl::NullPointerException,
+				"Window "
+				+ Ogre::String(name)
+				+ " is NULL");
+
+		if (requiredClass != NULL && !wnd->testClassName(requiredClass)) {
+            Throw(
+				rl::NullPointerException,
+				"Window "
+				+ Ogre::String(name)
+				+ " has not the required class "
+				+ Ogre::String(requiredClass));
+        }
+
+		return wnd;
+	}
+
+	Editbox* AbstractWindow::getEditbox(const char* name)
+	{
+		return static_cast<Editbox*>(getWindow(name, "Editbox"));
+	}
+    
+	Checkbox* AbstractWindow::getCheckbox(const char* name)
+	{
+		return static_cast<Checkbox*>(getWindow(name, "Checkbox"));
+	}
+    
+	Listbox* AbstractWindow::getListbox(const char* name)
+	{
+		return static_cast<Listbox*>(getWindow(name, "Listbox"));
+	}
+
+	MultiColumnList* AbstractWindow::getMultiColumnList(const char* name)
+	{
+		return static_cast<MultiColumnList*>(getWindow(name, "MultiColumnList"));
+	}
+
+	MultiLineEditbox* AbstractWindow::getMultiLineEditbox(const char* name)
+	{
+		return static_cast<MultiLineEditbox*>(getWindow(name, "MultiLineEditbox"));
+	}
+
+	ProgressBar* AbstractWindow::getProgressBar(const char* name)
+	{
+		return static_cast<ProgressBar*>(getWindow(name, "ProgressBar"));
+	}
+
+	MenuBase* AbstractWindow::getMenu(const char* name)
+	{
+		return static_cast<MenuBase*>(getWindow(name, "MenuBase"));
+	}
+
+	MenuItem* AbstractWindow::getMenuItem(const char* name)
+	{
+		return static_cast<MenuItem*>(getWindow(name, "MenuItem"));
+	}
+
+	PushButton* AbstractWindow::getPushButton(const char* name)
+	{
+		return static_cast<PushButton*>(getWindow(name, "PushButton"));
+	}
+
+	Combobox* AbstractWindow::getCombobox(const char* name)
+	{
+		return static_cast<Combobox*>(getWindow(name, "Combobox"));
+	}
+
+	ComboDropList* AbstractWindow::getComboDropList(const char* name)
+	{
+		return static_cast<ComboDropList*>(getWindow(name, "ComboDropList"));
+	}
+
+    ScrollablePane* AbstractWindow::getScrollablePane(const char* name)
+    {
+		return static_cast<ScrollablePane*>(getWindow(name, "ScrollablePane"));
+    }
+
+	Slider* AbstractWindow::getSlider(const char* name)
+	{
+		return static_cast<Slider*>(getWindow(name, "Slider"));
+	}
+
+	TabControl* AbstractWindow::getTabControl(const char* name)
+	{
+		return static_cast<TabControl*>(getWindow(name, "TabControl"));
+	}
+
+	const CeGuiString& AbstractWindow::getName() const
+	{
+		return mName;
+	}
+
+	void AbstractWindow::centerWindow()
+	{
+		CEGUI::Size screenSize = System::getSingleton().getRenderer()->getSize();
+		CEGUI::Size windowSize = mWindow->getPixelSize();
+		float x = 0.5f * (screenSize.d_width - windowSize.d_width);
+		float y = 0.5f * (screenSize.d_height - windowSize.d_height);
+		mWindow->setPosition(CeGuiHelper::asAbsolute(CEGUI::Vector2(x, y)));
+	}
+
+	void AbstractWindow::bindDestroyWindowToClick(CEGUI::Window* button)
+	{
+		button->subscribeEvent(Window::EventMouseClick,
+			boost::bind(&AbstractWindow::destroyWindow, this));
+	}
+
+    void AbstractWindow::bindHideWindowToClick(CEGUI::Window* button)
+	{
+		button->subscribeEvent(Window::EventMouseClick,
+			boost::bind(&AbstractWindow::hideWindow, this));
+	}
+
+	void AbstractWindow::bindDestroyWindowToXButton()
+	{
+		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
+			boost::bind(&AbstractWindow::destroyWindow, this));
+	}
+
+	void AbstractWindow::bindHideWindowToXButton()
+	{
+		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
+			boost::bind(&AbstractWindow::hideWindow, this));
+	}
+
+	bool AbstractWindow::destroyWindow()
+	{
+		setVisible(false, true);
+		return true;
+	}
+
+	bool AbstractWindow::hideWindow()
+	{
+		setVisible(false);
+		return true;
+	}
+
+	CEGUI::Window* AbstractWindow::getWindow()
+	{
+		return mWindow;
+	}
+
+	const CeGuiString& AbstractWindow::getNamePrefix() const
+	{
+		return mNamePrefix;
+	}
+
+	void AbstractWindow::windowHid()
+	{
+	}
+
+}

Copied: rl/branches/persistence/ui/src/CharacterSelectionWindow.cpp (from rev 4612, rl/trunk/engine/ui/src/CharacterSelectionWindow.cpp)

Modified: rl/branches/persistence/ui/src/CharacterStateWindow.cpp
===================================================================
--- rl/branches/persistence/ui/src/CharacterStateWindow.cpp	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/ui/src/CharacterStateWindow.cpp	2008-11-26 19:42:03 UTC (rev 4613)
@@ -1,118 +1,134 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include <boost/bind.hpp>
-#include "UiPrerequisites.h"
-
-#include "DsaManager.h"
-#include "Creature.h"
-#include "InputManager.h"
-#include "Talent.h"
-
-#include "CharacterStateWindow.h"
-
-using namespace CEGUI;
-using namespace Ogre;
-
-
-namespace rl {
-
-CharacterStateWindow::CharacterStateWindow()
-: AbstractWindow("characterstatewindow.xml", WIT_NONE, false),
-	mCharacter(NULL)
-{
-	mLP = getProgressBar("CharacterStateWindow/LP");
-	mAP = getProgressBar("CharacterStateWindow/AP");
-	mAU = getProgressBar("CharacterStateWindow/AU");
-	mName = getWindow("CharacterStateWindow/Name");
-}
-
-CharacterStateWindow::~CharacterStateWindow()
-{
-    if (mCharacter != NULL)
-		mCharacter->removeObjectStateChangeListener(this);
-}
-
-void CharacterStateWindow::setCharacter(Creature* person)
-{
-	if (mCharacter != NULL)
-		mCharacter->removeObjectStateChangeListener(this);
-
-	mCharacter = person;
-    if(mCharacter)
-        mCharacter->addObjectStateChangeListener(this);
-	update();
-}
-
-void CharacterStateWindow::update()
-{
-	if (!isVisible())
-		return;
-	if (mCharacter == NULL)
-		return;
-
-	mName->setText(mCharacter->getName());
-
-	float lep;
-	if (mCharacter->getLeMax() <= 0)
-		lep = 0.0;
-	else
-		lep = (float)mCharacter->getLe() / (float)mCharacter->getLeMax();
-	mLP->setProgress(lep);
-
-	float au;
-	if (mCharacter->getAuMax() <= 0)
-		au = 0.0;
-	else
-		au = (float)mCharacter->getAu() / (float)mCharacter->getAuMax();
-	mAU->setProgress(au);
-
-	if (!mCharacter->isMagic())
-	{
-		if (mAP->isVisible())
-			mAP->setVisible(false);
-		return;
-	}
-
-	if (!mAP->isVisible())
-		mAP->setVisible(true);
-
-	float asp;
-	if (mCharacter->getAeMax() <= 0)
-		asp = 0.0;
-	else
-		asp = (float)mCharacter->getAe() / (float)mCharacter->getAeMax();
-	mAP->setProgress(asp);
-
-}
-
-void CharacterStateWindow::objectStateChanged(ObjectStateChangeEvent* evt)
-{
-	update();
-}
-
-void CharacterStateWindow::setVisible(bool visible, bool destroyAfterHide)
-{
-	AbstractWindow::setVisible(visible, destroyAfterHide);
-	if (visible)
-	{
-		update();
-	}
-}
-
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include <boost/bind.hpp>
+#include "UiPrerequisites.h"
+
+#include "DsaManager.h"
+#include "Creature.h"
+#include "InputManager.h"
+#include "Talent.h"
+
+#include "CharacterStateWindow.h"
+
+using namespace CEGUI;
+using namespace Ogre;
+
+
+namespace rl {
+
+CharacterStateWindow::CharacterStateWindow()
+: AbstractWindow("characterstatewindow.xml", WIT_NONE, false),
+	mCharacter(NULL)
+{
+	mLP = getProgressBar("CharacterStateWindow/LP");
+	mAP = getProgressBar("CharacterStateWindow/AP");
+	mAU = getProgressBar("CharacterStateWindow/AU");
+	mName = getWindow("CharacterStateWindow/Name");
+}
+
+CharacterStateWindow::~CharacterStateWindow()
+{
+    if (mCharacter != NULL)
+		mCharacter->removeObjectStateChangeListener(this);
+}
+
+void CharacterStateWindow::setCharacter(Creature* person)
+{
+	if (mCharacter != NULL)
+		mCharacter->removeObjectStateChangeListener(this);
+
+	mCharacter = person;
+    if(mCharacter)
+        mCharacter->addObjectStateChangeListener(this);
+	update();
+}
+
+void CharacterStateWindow::update()
+{
+	if (!isVisible() || mCharacter == NULL)
+    {
+		return;
+    }
+        
+	mName->setText(mCharacter->getName());
+
+	float lep;
+	if (mCharacter->getLeMax() <= 0)
+    {
+		lep = 0.0;        
+    }
+	else
+    {
+		lep = (float)mCharacter->getLe() / (float)mCharacter->getLeMax();        
+    }
+	mLP->setProgress(lep);
+
+	float au;
+	if (mCharacter->getAuMax() <= 0)
+    {
+		au = 0.0;        
+    }
+	else
+    {
+		au = (float)mCharacter->getAu() / (float)mCharacter->getAuMax();        
+    }
+	mAU->setProgress(au);
+
+	if (!mCharacter->isMagic())
+	{
+		if (mAP->isVisible()) 
+        {
+			mAP->setVisible(false);            
+        }
+	}
+    else 
+    {
+     	if (!mAP->isVisible()) 
+        {
+            mAP->setVisible(true);            
+        }
+        
+        float asp;
+        if (mCharacter->getAeMax() <= 0)
+        {
+            asp = 0.0;
+        }
+        else
+        {
+            asp = (float)mCharacter->getAe() / (float)mCharacter->getAeMax();
+        }
+        mAP->setProgress(asp);        
+    }
+}
+
+void CharacterStateWindow::objectStateChanged(ObjectStateChangeEvent* evt)
+{
+	update();
+}
+
+void CharacterStateWindow::setVisible(bool visible, bool destroyAfterHide)
+{
+	AbstractWindow::setVisible(visible, destroyAfterHide);
+	if (visible)
+	{
+		update();
+	}
+}
+
+
+}

Modified: rl/branches/persistence/ui/src/GameSettings.cpp
===================================================================
--- rl/branches/persistence/ui/src/GameSettings.cpp	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/ui/src/GameSettings.cpp	2008-11-26 19:42:03 UTC (rev 4613)
@@ -25,6 +25,8 @@
 #include "SoundManager.h"
 #include "SoundDriver.h"
 
+using namespace Ogre;
+
 namespace rl
 {
     GameSettings::GameSettings()
@@ -46,8 +48,12 @@
         getWindow()->subscribeEvent(CEGUI::FrameWindow::EventCloseClicked,
                                     boost::bind(&GameSettings::onCancel, this));
 
+        mVideoRenderer = getCombobox("GameOptionsWindow/Video/Renderer");
+        mVideoResolution = getCombobox("GameOptionsWindow/Video/Resolution");
+        mVideoFullscreen = getCheckbox("GameOptionsWindow/Video/Fullscreen");
         centerWindow();
         setVisible(false);
+        update();
     }
 
     GameSettings::~GameSettings()
@@ -127,4 +133,54 @@
     {
         return true;
     }
+    
+    void GameSettings::update()
+    {
+        Root* root = Ogre::Root::getSingletonPtr();
+        RenderSystem* renderer = root->getRenderSystem();
+        
+        ConfigOptionMap config = renderer->getConfigOptions();
+        
+		ConfigOptionMap::iterator cfi;
+		
+		cfi = config.find( "Full Screen" );
+		if( cfi != config.end() )
+		{
+			mVideoFullscreen->setSelected(cfi->second.currentValue == "Yes");
+		}
+        
+/*		cfi = config.find( "FSAA" );
+		if( cfi != config.end() )
+		{
+			if( cfi->second.currentValue == "0" )
+			{
+				SetControlValue( iFSAARef, 1 );
+			}
+			else if( cfi->second.currentValue == "2" )
+			{
+				SetControlValue( iFSAARef, 2 );
+			}
+			else if( cfi->second.currentValue == "4" )
+			{
+				SetControlValue( iFSAARef, 3 );
+			}
+			else if( cfi->second.currentValue == "6" )
+			{
+				SetControlValue( iFSAARef, 4 );
+			}
+		}
+        
+		cfi = config.find( "Colour Depth" );
+		if( cfi != config.end() )
+		{
+			if( cfi->second.currentValue == "32" )
+			{
+				SetControlValue( iColorDepthRef, 1 );
+			}
+			else
+			{
+				SetControlValue( iColorDepthRef, 2 );
+			}
+		}*/
+    }
 }

Modified: rl/branches/persistence/ui/src/InventoryWindow.cpp
===================================================================
--- rl/branches/persistence/ui/src/InventoryWindow.cpp	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/ui/src/InventoryWindow.cpp	2008-11-26 19:42:03 UTC (rev 4613)
@@ -174,7 +174,6 @@
     ItemDragContainer* InventoryWindow::getItemDragContainer(const Item* item, bool description)
     {
 		CeGuiString dragContainerName = getDragContainerNameFromItem(item, description);
-		ItemDragContainer* itemhandler = NULL;
 
 		DndContainerMap::iterator iter = mWorldDragContainers.find(dragContainerName);
         if( iter != mWorldDragContainers.end() )

Modified: rl/branches/persistence/ui/src/WindowFactory.cpp
===================================================================
--- rl/branches/persistence/ui/src/WindowFactory.cpp	2008-11-26 19:07:20 UTC (rev 4612)
+++ rl/branches/persistence/ui/src/WindowFactory.cpp	2008-11-26 19:42:03 UTC (rev 4613)
@@ -20,6 +20,7 @@
 #include "AboutWindow.h"
 #include "ActionChoiceWindow.h"
 #include "ActorManager.h"
+#include "CharacterSelectionWindow.h"
 #include "CharacterSheetWindow.h"
 #include "CharacterStateWindow.h"
 #include "CloseConfirmationWindow.h"
@@ -85,7 +86,8 @@
         mMainMenuWindow(NULL),
 		mMainMenuLoadWindow(NULL),
         mGameSettings(NULL),
-        mCombatWindow(NULL)
+        mCombatWindow(NULL),
+        mCharacterSelectionWindow(NULL)
     {
     }
 
@@ -111,6 +113,8 @@
         RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mJournalWindow);
         //RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mInfoPopup);
         mMainMenuWindow = new MainMenuWindow( new MainMenuEngineWindow() );
+        
+        mCharacterSelectionWindow = new CharacterSelectionWindow();
 
         logAllWindows();
     }
@@ -292,7 +296,13 @@
     {
         mCharacterStateWindow->setVisible(!mCharacterStateWindow->isVisible());
     }
-
+    
+    void WindowFactory::toggleCharacterSelectionWindow()
+    {
+        mCharacterSelectionWindow->setVisible(!mCharacterSelectionWindow->isVisible());
+        mCharacterSelectionWindow->update();
+    }
+    
     void WindowFactory::toggleInGameGlobalMenu()
     {
         mInGameMenuWindow->setVisible(!mInGameMenuWindow->isVisible());



From melven at mail.berlios.de  Sun Nov 30 22:23:49 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 30 Nov 2008 22:23:49 +0100
Subject: [Dsa-hl-svn] r4614 - in dependencies/OgreNewt_ngt: inc src
Message-ID: <200811302123.mAULNn23000974@sheep.berlios.de>

Author: melven
Date: 2008-11-30 22:23:48 +0100 (Sun, 30 Nov 2008)
New Revision: 4614

Modified:
   dependencies/OgreNewt_ngt/inc/OgreNewt_Tools.h
   dependencies/OgreNewt_ngt/src/OgreNewt_Tools.cpp
Log:
changes for Ogre 1.6


Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_Tools.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_Tools.h	2008-11-26 19:42:03 UTC (rev 4613)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_Tools.h	2008-11-30 21:23:48 UTC (rev 4614)
@@ -269,6 +269,7 @@
                 void    getWorldTransforms(Matrix4 *xform) const;
                 Real    getBoundingRadius(void) const {return mRadius;};
                 Real    getSquaredViewDepth(const Camera *cam) const {return 0;};
+                void visitRenderables(Ogre::Renderable::Visitor* visitor,  bool debugRenderables = false);
                 const   Quaternion        &getWorldOrientation(void) const;
                 const   Vector3           &getWorldPosition(void) const;
                 const   AxisAlignedBox    &getBoundingBox(void) const {return mAABB;};

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_Tools.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_Tools.cpp	2008-11-26 19:42:03 UTC (rev 4613)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_Tools.cpp	2008-11-30 21:23:48 UTC (rev 4614)
@@ -726,6 +726,10 @@
                 }
             }
 
+            void MovableText::visitRenderables(Renderable::Visitor* visitor, bool debugRenderables)
+            {
+                visitor->visit(this, 0, debugRenderables);
+            }
         }
 }
 



From timm at mail.berlios.de  Sun Nov 30 22:28:26 2008
From: timm at mail.berlios.de (timm at mail.berlios.de)
Date: Sun, 30 Nov 2008 22:28:26 +0100
Subject: [Dsa-hl-svn] r4615 - in modules/branch_persistenz: maps scripts/maps
Message-ID: <200811302128.mAULSQ2k001333@sheep.berlios.de>

Author: timm
Date: 2008-11-30 22:28:14 +0100 (Sun, 30 Nov 2008)
New Revision: 4615

Modified:
   modules/branch_persistenz/maps/hero.rlmap.xml
   modules/branch_persistenz/maps/persistenztest01.rlmap.xml
   modules/branch_persistenz/maps/persistenztest02.rlmap.xml
   modules/branch_persistenz/scripts/maps/map01.rb
Log:


Modified: modules/branch_persistenz/maps/hero.rlmap.xml
===================================================================
--- modules/branch_persistenz/maps/hero.rlmap.xml	2008-11-30 21:23:48 UTC (rev 4614)
+++ modules/branch_persistenz/maps/hero.rlmap.xml	2008-11-30 21:28:14 UTC (rev 4615)
@@ -1,4 +1,4 @@
-<scene formatVersion="0.4.0" scenescript="setchar.rb">
+<scene formatVersion="0.4.0" mapscript="setchar.rb">
     <nodes>
         <gameobject class="mckhero" id="hero" state="IN_SCENE">
             <position x="2" y="0.0" z="0"/>

Modified: modules/branch_persistenz/maps/persistenztest01.rlmap.xml
===================================================================
--- modules/branch_persistenz/maps/persistenztest01.rlmap.xml	2008-11-30 21:23:48 UTC (rev 4614)
+++ modules/branch_persistenz/maps/persistenztest01.rlmap.xml	2008-11-30 21:28:14 UTC (rev 4615)
@@ -1,4 +1,4 @@
-<scene formatVersion="0.4.0" scenescript="map01.rb">
+<scene formatVersion="0.4.0" mapscript="map01.rb">
     <nodes>
         <entity meshfile="regressiontest_floorplane.mesh">
             <position x="0.0" y="0.0" z="0.0" />

Modified: modules/branch_persistenz/maps/persistenztest02.rlmap.xml
===================================================================
--- modules/branch_persistenz/maps/persistenztest02.rlmap.xml	2008-11-30 21:23:48 UTC (rev 4614)
+++ modules/branch_persistenz/maps/persistenztest02.rlmap.xml	2008-11-30 21:28:14 UTC (rev 4615)
@@ -1,4 +1,4 @@
-<scene formatVersion="0.4.0" scenescript="map02.rb">
+<scene formatVersion="0.4.0" mapscript="map02.rb">
     <nodes>
         <entity meshfile="regressiontest_floorplane.mesh">
             <position x="0.0" y="0.0" z="0.0" />

Modified: modules/branch_persistenz/scripts/maps/map01.rb
===================================================================
--- modules/branch_persistenz/scripts/maps/map01.rb	2008-11-30 21:23:48 UTC (rev 4614)
+++ modules/branch_persistenz/scripts/maps/map01.rb	2008-11-30 21:28:14 UTC (rev 4615)
@@ -3,7 +3,7 @@
 
 $SCRIPT.log("map 1 von 'persistenztest' wird initialisiert....")
 
-base = $AM.createBoxPrimitiveActor("SelectorTestBase", [-2,0.05,-2], [2,0.3,2], "alpha_blue")
+base = $AM.createBoxPrimitiveActor("SelectorTestBase", [-2,0.05,-2], [2,0.3,2], "nx.cube")
 
 base.placeIntoScene([8,0,8])
 



From melven at mail.berlios.de  Sun Nov 30 23:47:27 2008
From: melven at mail.berlios.de (melven at mail.berlios.de)
Date: Sun, 30 Nov 2008 23:47:27 +0100
Subject: [Dsa-hl-svn] r4616 - in rl/branches/newton20: .
	Mac/Rastullah.xcodeproj cmake editors/Lockenwickler
	editors/Lockenwickler/src editors/Lockenwickler/src/media
	editors/Lockenwickler/src/media/icons engine/ai/include
	engine/ai/src engine/core/include engine/core/src
	engine/rules/include engine/rules/src engine/script/src
	engine/script/swig engine/ui/include engine/ui/src plugins
	plugins/fmod4driver plugins/fmod4driver/include
	plugins/fmod4driver/src
Message-ID: <200811302247.mAUMlROF009065@sheep.berlios.de>

Author: melven
Date: 2008-11-30 23:46:52 +0100 (Sun, 30 Nov 2008)
New Revision: 4616

Added:
   rl/branches/newton20/CMakeLists.txt
   rl/branches/newton20/cmake/
   rl/branches/newton20/cmake/FindCEGUI.cmake
   rl/branches/newton20/cmake/FindFMODEx.cmake
   rl/branches/newton20/cmake/FindOGRE.cmake
   rl/branches/newton20/editors/Lockenwickler/src/CodeDump.py
   rl/branches/newton20/editors/Lockenwickler/src/GOIntEditor.py
   rl/branches/newton20/editors/Lockenwickler/src/NewModuleWizard.py
   rl/branches/newton20/editors/Lockenwickler/src/Ui_GOPropertyEditorDialogINT.py
   rl/branches/newton20/editors/Lockenwickler/src/Ui_NewModuleWizard.py
   rl/branches/newton20/editors/Lockenwickler/src/media/icons/cursor.png
   rl/branches/newton20/editors/Lockenwickler/src/media/lightbulb.blend
   rl/branches/newton20/engine/ui/include/CharacterSelectionWindow.h
   rl/branches/newton20/engine/ui/src/CharacterSelectionWindow.cpp
   rl/branches/newton20/plugins/CMakeLists.txt
   rl/branches/newton20/plugins/fmod4driver/CMakeLists.txt
Removed:
   rl/branches/newton20/cmake/FindCEGUI.cmake
   rl/branches/newton20/cmake/FindFMODEx.cmake
   rl/branches/newton20/cmake/FindOGRE.cmake
   rl/branches/newton20/editors/Lockenwickler/src/ui_pref_dialog.py
Modified:
   rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj
   rl/branches/newton20/bootstrap
   rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p
   rl/branches/newton20/editors/Lockenwickler/src/ConsoleWindow.py
   rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py
   rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassManager.py
   rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py
   rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py
   rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py
   rl/branches/newton20/editors/Lockenwickler/src/PreferencesDialog.py
   rl/branches/newton20/engine/ai/include/AgentCombatState.h
   rl/branches/newton20/engine/ai/src/AgentCombatState.cpp
   rl/branches/newton20/engine/core/include/ListenerMovable.h
   rl/branches/newton20/engine/core/include/MovableText.h
   rl/branches/newton20/engine/core/include/Sound.h
   rl/branches/newton20/engine/core/include/SoundResource.h
   rl/branches/newton20/engine/core/include/SoundStitching.h
   rl/branches/newton20/engine/core/src/Actor.cpp
   rl/branches/newton20/engine/core/src/ConfigurationManager.cpp
   rl/branches/newton20/engine/core/src/DotSceneLoader.cpp
   rl/branches/newton20/engine/core/src/JobScheduler.cpp
   rl/branches/newton20/engine/core/src/ListenerMovable.cpp
   rl/branches/newton20/engine/core/src/MovableText.cpp
   rl/branches/newton20/engine/core/src/PhysicalThing.cpp
   rl/branches/newton20/engine/core/src/PhysicsManager.cpp
   rl/branches/newton20/engine/core/src/Sound.cpp
   rl/branches/newton20/engine/core/src/SoundResource.cpp
   rl/branches/newton20/engine/core/src/SoundStitching.cpp
   rl/branches/newton20/engine/rules/include/Combat.h
   rl/branches/newton20/engine/rules/include/Container.h
   rl/branches/newton20/engine/rules/include/GameObject.h
   rl/branches/newton20/engine/rules/include/Item.h
   rl/branches/newton20/engine/rules/include/PartyManager.h
   rl/branches/newton20/engine/rules/src/Combat.cpp
   rl/branches/newton20/engine/rules/src/Container.cpp
   rl/branches/newton20/engine/rules/src/GameObject.cpp
   rl/branches/newton20/engine/rules/src/Item.cpp
   rl/branches/newton20/engine/script/src/PlaneNodeProcessor.cpp
   rl/branches/newton20/engine/script/swig/RlUi.swig
   rl/branches/newton20/engine/ui/include/AbstractWindow.h
   rl/branches/newton20/engine/ui/include/CombatGui.h
   rl/branches/newton20/engine/ui/include/GameSettings.h
   rl/branches/newton20/engine/ui/include/Makefile.am
   rl/branches/newton20/engine/ui/include/WindowFactory.h
   rl/branches/newton20/engine/ui/src/AbstractWindow.cpp
   rl/branches/newton20/engine/ui/src/CharacterStateWindow.cpp
   rl/branches/newton20/engine/ui/src/CombatControlState.cpp
   rl/branches/newton20/engine/ui/src/CombatGui.cpp
   rl/branches/newton20/engine/ui/src/DebugWindow.cpp
   rl/branches/newton20/engine/ui/src/DialogControlState.cpp
   rl/branches/newton20/engine/ui/src/GameSettings.cpp
   rl/branches/newton20/engine/ui/src/InputManager.cpp
   rl/branches/newton20/engine/ui/src/InventoryWindow.cpp
   rl/branches/newton20/engine/ui/src/Makefile.am
   rl/branches/newton20/engine/ui/src/WindowFactory.cpp
   rl/branches/newton20/plugins/fmod4driver/include/Fmod4Driver.h
   rl/branches/newton20/plugins/fmod4driver/src/Fmod4Driver.cpp
Log:
merged changes from trunk (not working yet)


Copied: rl/branches/newton20/CMakeLists.txt (from rev 4613, rl/trunk/CMakeLists.txt)

Modified: rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj
===================================================================
--- rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/Mac/Rastullah.xcodeproj/project.pbxproj	2008-11-30 22:46:52 UTC (rev 4616)
@@ -663,6 +663,8 @@
 		48A52CC00E0EF77D008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
 		48A52CC20E0EF77E008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
 		48A52CC30E0EF785008DBDD8 /* libboost_system.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */; };
+		48B006C50ECAC05F008141C2 /* CharacterSelectionWindow.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B006C40ECAC05F008141C2 /* CharacterSelectionWindow.cpp */; };
+		48B006C80ECAC11D008141C2 /* CharacterSelectionWindow.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B006C70ECAC11D008141C2 /* CharacterSelectionWindow.h */; };
 		48B0B0350E6534690023B198 /* PlaneNodeProcessor.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 48B0B0340E6534690023B198 /* PlaneNodeProcessor.cpp */; };
 		48B0B0370E6534810023B198 /* PlaneNodeProcessor.h in Headers */ = {isa = PBXBuildFile; fileRef = 48B0B0360E6534810023B198 /* PlaneNodeProcessor.h */; };
 		48B0B03C0E6535AB0023B198 /* libmeshmagick.dylib in Resources */ = {isa = PBXBuildFile; fileRef = 440785DD0C09D231006E496D /* libmeshmagick.dylib */; };
@@ -1490,6 +1492,8 @@
 		48A52CAF0E0EF55C008DBDD8 /* libboost_system.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libboost_system.dylib; path = /usr/local/lib/libboost_system.dylib; sourceTree = "<absolute>"; };
 		48A52CB50E0EF5BD008DBDD8 /* ApplyDamageJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ApplyDamageJob.h; sourceTree = "<group>"; };
 		48A52CB70E0EF5D0008DBDD8 /* ApplyDamageJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = ApplyDamageJob.cpp; sourceTree = "<group>"; };
+		48B006C40ECAC05F008141C2 /* CharacterSelectionWindow.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = CharacterSelectionWindow.cpp; sourceTree = "<group>"; };
+		48B006C70ECAC11D008141C2 /* CharacterSelectionWindow.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = CharacterSelectionWindow.h; sourceTree = "<group>"; };
 		48B0B0340E6534690023B198 /* PlaneNodeProcessor.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = PlaneNodeProcessor.cpp; path = ../engine/script/src/PlaneNodeProcessor.cpp; sourceTree = SOURCE_ROOT; };
 		48B0B0360E6534810023B198 /* PlaneNodeProcessor.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = PlaneNodeProcessor.h; path = ../engine/script/include/PlaneNodeProcessor.h; sourceTree = SOURCE_ROOT; };
 		48B0B0480E65BBB30023B198 /* libfmodex.dylib */ = {isa = PBXFileReference; lastKnownFileType = "compiled.mach-o.dylib"; name = libfmodex.dylib; path = "FMOD Programmers API/api/lib/libfmodex.dylib"; sourceTree = SYSTEM_DEVELOPER_DIR; };
@@ -1519,7 +1523,7 @@
 		48D0BE6B0E27401E00863824 /* DialogLoader.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = DialogLoader.cpp; path = ../engine/ai/src/DialogLoader.cpp; sourceTree = SOURCE_ROOT; };
 		48D34A610D90F5D500C89477 /* SaveGameData.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = SaveGameData.h; path = ../engine/core/include/SaveGameData.h; sourceTree = SOURCE_ROOT; };
 		48D34A620D90F5D500C89477 /* SaveGameData.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = SaveGameData.cpp; path = ../engine/core/src/SaveGameData.cpp; sourceTree = SOURCE_ROOT; };
-		48D401810D9E483200AE5340 /* modules */ = {isa = PBXFileReference; lastKnownFileType = folder; name = modules; path = ../../../modules; sourceTree = SOURCE_ROOT; };
+		48D401810D9E483200AE5340 /* modules */ = {isa = PBXFileReference; explicitFileType = folder; includeInIndex = 1; name = modules; path = ../../../modules; sourceTree = SOURCE_ROOT; };
 		48EFE0A30E8B6AF6007EB7F8 /* FetchItemJob.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = FetchItemJob.h; sourceTree = "<group>"; };
 		48EFE0A50E8B6C39007EB7F8 /* FetchItemJob.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; path = FetchItemJob.cpp; sourceTree = "<group>"; };
 		48EFE0D70E8B6EB1007EB7F8 /* mkdmg.sh */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.script.sh; path = mkdmg.sh; sourceTree = "<group>"; };
@@ -2170,6 +2174,97 @@
 			path = src;
 			sourceTree = "<group>";
 		};
+		48B006C30ECABFB0008141C2 /* windows */ = {
+			isa = PBXGroup;
+			children = (
+				444EACAC0BD0E57100C6D4A0 /* ConfigComponent.cpp */,
+				444EACAD0BD0E57100C6D4A0 /* Console.cpp */,
+				444EACB80BD0E57100C6D4A0 /* GameSettings.cpp */,
+				444EACA20BD0E57100C6D4A0 /* AboutWindow.cpp */,
+				444EACA30BD0E57100C6D4A0 /* AbstractWindow.cpp */,
+				444EACA40BD0E57100C6D4A0 /* ActionChoiceWindow.cpp */,
+				487029C80E80DCF900B66388 /* GameOverWindow.cpp */,
+				48389B8F0D86741F00AFAB66 /* GameSaveLoadWindow.cpp */,
+				48389B900D86741F00AFAB66 /* MainMenuLoadWindow.cpp */,
+				446BF4950C4533BD0013C214 /* CombatWindow.cpp */,
+				446BF49C0C4533BD0013C214 /* PropertiesWindow.cpp */,
+				44D814630BF7B5AD00534175 /* ProgressWindow.cpp */,
+				444EACA60BD0E57100C6D4A0 /* CharacterSheetWindow.cpp */,
+				444EACA70BD0E57100C6D4A0 /* CharacterStateWindow.cpp */,
+				444EACA80BD0E57100C6D4A0 /* CloseConfirmationWindow.cpp */,
+				444EACCB0BD0E57100C6D4A0 /* SubtitleWindow.cpp */,
+				444EACC90BD0E57100C6D4A0 /* SoundConfig.cpp */,
+				444EACAE0BD0E57100C6D4A0 /* ContainerContentWindow.cpp */,
+				444EACB10BD0E57100C6D4A0 /* DebugWindow.cpp */,
+				444EACB30BD0E57100C6D4A0 /* DialogWindow.cpp */,
+				444EACB50BD0E57100C6D4A0 /* GameLoggerWindow.cpp */,
+				444EACB60BD0E57100C6D4A0 /* GameObjectInfoWindow.cpp */,
+				444EACB90BD0E57100C6D4A0 /* InfoPopup.cpp */,
+				444EACBA0BD0E57100C6D4A0 /* InGameMenuWindow.cpp */,
+				444EACBC0BD0E57100C6D4A0 /* InventoryWindow.cpp */,
+				444EACBD0BD0E57100C6D4A0 /* ItemDragContainer.cpp */,
+				444EACBE0BD0E57100C6D4A0 /* JournalWindow.cpp */,
+				444EACC00BD0E57100C6D4A0 /* LogWindow.cpp */,
+				446BF4D50C453C1D0013C214 /* ItemDescriptionDragContainer.cpp */,
+				446BF49A0C4533BD0013C214 /* ItemIconDragContainer.cpp */,
+				444EACC10BD0E57100C6D4A0 /* MainMenuEngineWindow.cpp */,
+				444EACBF0BD0E57100C6D4A0 /* ListboxWrappedTextItem.cpp */,
+				444EACC20BD0E57100C6D4A0 /* MainMenuWindow.cpp */,
+				444EACC30BD0E57100C6D4A0 /* MessageWindow.cpp */,
+				444EACC50BD0E57100C6D4A0 /* ObjectDescriptionWindow.cpp */,
+				444EACC60BD0E57100C6D4A0 /* PlaylistWindow.cpp */,
+				444EACC70BD0E57100C6D4A0 /* RenderSystemConfigComponent.cpp */,
+				444EACCA0BD0E57100C6D4A0 /* SoundDriverConfigComponent.cpp */,
+				48B006C40ECAC05F008141C2 /* CharacterSelectionWindow.cpp */,
+			);
+			name = windows;
+			sourceTree = "<group>";
+		};
+		48B006C60ECAC097008141C2 /* windows */ = {
+			isa = PBXGroup;
+			children = (
+				444EACFE0BD0E58C00C6D4A0 /* AboutWindow.h */,
+				444EACFF0BD0E58C00C6D4A0 /* AbstractWindow.h */,
+				444EAD000BD0E58C00C6D4A0 /* ActionChoiceWindow.h */,
+				444EAD030BD0E58C00C6D4A0 /* CharacterSheetWindow.h */,
+				444EAD040BD0E58C00C6D4A0 /* CharacterStateWindow.h */,
+				444EAD050BD0E58C00C6D4A0 /* CloseConfirmationWindow.h */,
+				446BF4D10C453B9E0013C214 /* CombatWindow.h */,
+				444EAD0B0BD0E58C00C6D4A0 /* ContainerContentWindow.h */,
+				48389B970D86743900AFAB66 /* GameSaveLoadWindow.h */,
+				446BF4880C45335A0013C214 /* ItemDescriptionDragContainer.h */,
+				446BF4890C45335A0013C214 /* ItemIconDragContainer.h */,
+				44D8145F0BF7B58A00534175 /* ProgressWindow.h */,
+				444EAD090BD0E58C00C6D4A0 /* ConfigComponent.h */,
+				446BF48B0C45335A0013C214 /* PropertiesWindow.h */,
+				487029C60E80DCEA00B66388 /* GameOverWindow.h */,
+				48389B980D86743900AFAB66 /* MainMenuLoadWindow.h */,
+				444EAD0E0BD0E58C00C6D4A0 /* DebugWindow.h */,
+				444EAD100BD0E58C00C6D4A0 /* DialogWindow.h */,
+				444EAD120BD0E58C00C6D4A0 /* GameLoggerWindow.h */,
+				444EAD130BD0E58C00C6D4A0 /* GameObjectInfoWindow.h */,
+				444EAD150BD0E58C00C6D4A0 /* GameSettings.h */,
+				444EAD170BD0E58C00C6D4A0 /* InGameMenuWindow.h */,
+				444EAD190BD0E58C00C6D4A0 /* InventoryWindow.h */,
+				444EAD1A0BD0E58C00C6D4A0 /* ItemDragContainer.h */,
+				444EAD1C0BD0E58C00C6D4A0 /* ListboxWrappedTextItem.h */,
+				444EAD1E0BD0E58C00C6D4A0 /* MainMenuEngineWindow.h */,
+				444EAD1F0BD0E58C00C6D4A0 /* MainMenuWindow.h */,
+				444EAD200BD0E58C00C6D4A0 /* MessageWindow.h */,
+				444EAD220BD0E58C00C6D4A0 /* ObjectDescriptionWindow.h */,
+				444EAD230BD0E58C00C6D4A0 /* PlaylistWindow.h */,
+				444EAD240BD0E58C00C6D4A0 /* RenderSystemConfigComponent.h */,
+				444EAD260BD0E58C00C6D4A0 /* SoundConfig.h */,
+				444EAD270BD0E58C00C6D4A0 /* SoundDriverConfigComponent.h */,
+				444EAD280BD0E58C00C6D4A0 /* SubtitleWindow.h */,
+				444EAD0A0BD0E58C00C6D4A0 /* Console.h */,
+				444EAD1B0BD0E58C00C6D4A0 /* JournalWindow.h */,
+				444EAD1D0BD0E58C00C6D4A0 /* LogWindow.h */,
+				48B006C70ECAC11D008141C2 /* CharacterSelectionWindow.h */,
+			);
+			name = windows;
+			sourceTree = "<group>";
+		};
 		48B0B0230E6533940023B198 /* Headers */ = {
 			isa = PBXGroup;
 			children = (
@@ -2235,55 +2330,19 @@
 		48EFE0880E8B6822007EB7F8 /* Headers */ = {
 			isa = PBXGroup;
 			children = (
-				44D8145F0BF7B58A00534175 /* ProgressWindow.h */,
-				444EACFE0BD0E58C00C6D4A0 /* AboutWindow.h */,
-				444EACFF0BD0E58C00C6D4A0 /* AbstractWindow.h */,
-				444EAD000BD0E58C00C6D4A0 /* ActionChoiceWindow.h */,
+				48B006C60ECAC097008141C2 /* windows */,
 				444EAD010BD0E58C00C6D4A0 /* CeGuiHelper.h */,
-				444EAD030BD0E58C00C6D4A0 /* CharacterSheetWindow.h */,
 				4404DA850C48D037007B4657 /* stdinc.h */,
 				446BF4D00C453B9E0013C214 /* CombatControlState.h */,
-				446BF4D10C453B9E0013C214 /* CombatWindow.h */,
 				446BF4840C45335A0013C214 /* ControlState.h */,
 				446BF4850C45335A0013C214 /* CutsceneControlState.h */,
 				446BF4860C45335A0013C214 /* DialogControlState.h */,
 				446BF4870C45335A0013C214 /* FreeflightControlState.h */,
-				446BF4880C45335A0013C214 /* ItemDescriptionDragContainer.h */,
-				446BF4890C45335A0013C214 /* ItemIconDragContainer.h */,
 				446BF48A0C45335A0013C214 /* MovementControlState.h */,
-				446BF48B0C45335A0013C214 /* PropertiesWindow.h */,
-				487029C60E80DCEA00B66388 /* GameOverWindow.h */,
 				48389B960D86743900AFAB66 /* CombatGui.h */,
-				48389B970D86743900AFAB66 /* GameSaveLoadWindow.h */,
-				48389B980D86743900AFAB66 /* MainMenuLoadWindow.h */,
-				444EAD040BD0E58C00C6D4A0 /* CharacterStateWindow.h */,
-				444EAD050BD0E58C00C6D4A0 /* CloseConfirmationWindow.h */,
 				444EAD070BD0E58C00C6D4A0 /* CommandMapper.h */,
-				444EAD090BD0E58C00C6D4A0 /* ConfigComponent.h */,
-				444EAD0A0BD0E58C00C6D4A0 /* Console.h */,
-				444EAD0B0BD0E58C00C6D4A0 /* ContainerContentWindow.h */,
-				444EAD0E0BD0E58C00C6D4A0 /* DebugWindow.h */,
-				444EAD100BD0E58C00C6D4A0 /* DialogWindow.h */,
-				444EAD120BD0E58C00C6D4A0 /* GameLoggerWindow.h */,
-				444EAD130BD0E58C00C6D4A0 /* GameObjectInfoWindow.h */,
-				444EAD150BD0E58C00C6D4A0 /* GameSettings.h */,
 				444EAD160BD0E58C00C6D4A0 /* InfoPopup.h */,
-				444EAD170BD0E58C00C6D4A0 /* InGameMenuWindow.h */,
 				444EAD180BD0E58C00C6D4A0 /* InputManager.h */,
-				444EAD190BD0E58C00C6D4A0 /* InventoryWindow.h */,
-				444EAD1A0BD0E58C00C6D4A0 /* ItemDragContainer.h */,
-				444EAD1B0BD0E58C00C6D4A0 /* JournalWindow.h */,
-				444EAD1C0BD0E58C00C6D4A0 /* ListboxWrappedTextItem.h */,
-				444EAD1D0BD0E58C00C6D4A0 /* LogWindow.h */,
-				444EAD1E0BD0E58C00C6D4A0 /* MainMenuEngineWindow.h */,
-				444EAD1F0BD0E58C00C6D4A0 /* MainMenuWindow.h */,
-				444EAD200BD0E58C00C6D4A0 /* MessageWindow.h */,
-				444EAD220BD0E58C00C6D4A0 /* ObjectDescriptionWindow.h */,
-				444EAD230BD0E58C00C6D4A0 /* PlaylistWindow.h */,
-				444EAD240BD0E58C00C6D4A0 /* RenderSystemConfigComponent.h */,
-				444EAD260BD0E58C00C6D4A0 /* SoundConfig.h */,
-				444EAD270BD0E58C00C6D4A0 /* SoundDriverConfigComponent.h */,
-				444EAD280BD0E58C00C6D4A0 /* SubtitleWindow.h */,
 				444EAD290BD0E58C00C6D4A0 /* UiPrerequisites.h */,
 				444EAD2A0BD0E58C00C6D4A0 /* UiSubsystem.h */,
 				444EAD2B0BD0E58C00C6D4A0 /* WindowFactory.h */,
@@ -2298,58 +2357,21 @@
 		48EFE0890E8B6900007EB7F8 /* Source */ = {
 			isa = PBXGroup;
 			children = (
-				444EACC90BD0E57100C6D4A0 /* SoundConfig.cpp */,
-				444EACCA0BD0E57100C6D4A0 /* SoundDriverConfigComponent.cpp */,
-				444EACCB0BD0E57100C6D4A0 /* SubtitleWindow.cpp */,
+				48B006C30ECABFB0008141C2 /* windows */,
 				444EACCC0BD0E57100C6D4A0 /* UiSubsystem.cpp */,
 				444EACCD0BD0E57100C6D4A0 /* WindowFactory.cpp */,
 				444EACCE0BD0E57100C6D4A0 /* WindowFadeJob.cpp */,
 				444EACCF0BD0E57100C6D4A0 /* WindowManager.cpp */,
-				487029C80E80DCF900B66388 /* GameOverWindow.cpp */,
 				48389B8E0D86741F00AFAB66 /* CombatGui.cpp */,
-				48389B8F0D86741F00AFAB66 /* GameSaveLoadWindow.cpp */,
-				48389B900D86741F00AFAB66 /* MainMenuLoadWindow.cpp */,
 				48389B910D86741F00AFAB66 /* stdinc.cpp */,
-				446BF4D50C453C1D0013C214 /* ItemDescriptionDragContainer.cpp */,
 				446BF4940C4533BD0013C214 /* CombatControlState.cpp */,
-				446BF4950C4533BD0013C214 /* CombatWindow.cpp */,
 				446BF4960C4533BD0013C214 /* ControlState.cpp */,
 				446BF4970C4533BD0013C214 /* CutsceneControlState.cpp */,
 				446BF4980C4533BD0013C214 /* DialogControlState.cpp */,
 				446BF4990C4533BD0013C214 /* FreeflightControlState.cpp */,
-				446BF49A0C4533BD0013C214 /* ItemIconDragContainer.cpp */,
 				446BF49B0C4533BD0013C214 /* MovementControlState.cpp */,
-				446BF49C0C4533BD0013C214 /* PropertiesWindow.cpp */,
-				44D814630BF7B5AD00534175 /* ProgressWindow.cpp */,
-				444EACA20BD0E57100C6D4A0 /* AboutWindow.cpp */,
-				444EACA30BD0E57100C6D4A0 /* AbstractWindow.cpp */,
-				444EACA40BD0E57100C6D4A0 /* ActionChoiceWindow.cpp */,
-				444EACA60BD0E57100C6D4A0 /* CharacterSheetWindow.cpp */,
-				444EACA70BD0E57100C6D4A0 /* CharacterStateWindow.cpp */,
-				444EACA80BD0E57100C6D4A0 /* CloseConfirmationWindow.cpp */,
 				444EACAA0BD0E57100C6D4A0 /* CommandMapper.cpp */,
-				444EACAC0BD0E57100C6D4A0 /* ConfigComponent.cpp */,
-				444EACAD0BD0E57100C6D4A0 /* Console.cpp */,
-				444EACAE0BD0E57100C6D4A0 /* ContainerContentWindow.cpp */,
-				444EACB10BD0E57100C6D4A0 /* DebugWindow.cpp */,
-				444EACB30BD0E57100C6D4A0 /* DialogWindow.cpp */,
-				444EACB50BD0E57100C6D4A0 /* GameLoggerWindow.cpp */,
-				444EACB60BD0E57100C6D4A0 /* GameObjectInfoWindow.cpp */,
-				444EACB80BD0E57100C6D4A0 /* GameSettings.cpp */,
-				444EACB90BD0E57100C6D4A0 /* InfoPopup.cpp */,
-				444EACBA0BD0E57100C6D4A0 /* InGameMenuWindow.cpp */,
 				444EACBB0BD0E57100C6D4A0 /* InputManager.cpp */,
-				444EACBC0BD0E57100C6D4A0 /* InventoryWindow.cpp */,
-				444EACBD0BD0E57100C6D4A0 /* ItemDragContainer.cpp */,
-				444EACBE0BD0E57100C6D4A0 /* JournalWindow.cpp */,
-				444EACBF0BD0E57100C6D4A0 /* ListboxWrappedTextItem.cpp */,
-				444EACC00BD0E57100C6D4A0 /* LogWindow.cpp */,
-				444EACC10BD0E57100C6D4A0 /* MainMenuEngineWindow.cpp */,
-				444EACC20BD0E57100C6D4A0 /* MainMenuWindow.cpp */,
-				444EACC30BD0E57100C6D4A0 /* MessageWindow.cpp */,
-				444EACC50BD0E57100C6D4A0 /* ObjectDescriptionWindow.cpp */,
-				444EACC60BD0E57100C6D4A0 /* PlaylistWindow.cpp */,
-				444EACC70BD0E57100C6D4A0 /* RenderSystemConfigComponent.cpp */,
 			);
 			name = Source;
 			path = src;
@@ -2832,6 +2854,7 @@
 				48389B9C0D86743900AFAB66 /* MainMenuLoadWindow.h in Headers */,
 				48389B9D0D86743900AFAB66 /* UiMessages.h in Headers */,
 				487029C70E80DCEA00B66388 /* GameOverWindow.h in Headers */,
+				48B006C80ECAC11D008141C2 /* CharacterSelectionWindow.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -3427,6 +3450,7 @@
 				48389B940D86741F00AFAB66 /* MainMenuLoadWindow.cpp in Sources */,
 				48389B950D86741F00AFAB66 /* stdinc.cpp in Sources */,
 				487029C90E80DCF900B66388 /* GameOverWindow.cpp in Sources */,
+				48B006C50ECAC05F008141C2 /* CharacterSelectionWindow.cpp in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};

Modified: rl/branches/newton20/bootstrap
===================================================================
--- rl/branches/newton20/bootstrap	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/bootstrap	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,32 +1,4 @@
 #!/bin/sh
-
-# Check for proper versions of autotools
-# We require:
-#  - autoconf 2.50+
-#  - automake 1.6+
-#  - libtool 1.4+
-
-# Deal with some gentoo-specific issues
-export WANT_AUTOMAKE='1.7'
-export WANT_AUTOCONF_2_5=1
-
-## Using prereq in autoconf rather than here, mostly for the debian systems at
-## this point
-if test -z "`autoconf --version 2>&1|head -n 1|egrep '2.[5-9]'`"; then
-	echo "Autoconf 2.50 or above is required. Aborting build...";
-    exit 1;
-fi
-
-if test -z "`automake --version 2>&1|head -n 1|egrep '1.([6-9]|[1-9][0-9])'`"; then
-	echo "Automake 1.6 or above is required. Aborting build...";
-	exit 1;
-fi
-
-if test -z "`libtool --version 2>&1|head -n 1|egrep '1.[4-5]'`"; then
-	echo "Libtool 1.4 or above is required. Aborting build...";
-	exit 1;
-fi
-
 echo "Bootstrap..."
 
 # Fire up autotools

Copied: rl/branches/newton20/cmake (from rev 4613, rl/trunk/cmake)

Deleted: rl/branches/newton20/cmake/FindCEGUI.cmake
===================================================================
--- rl/trunk/cmake/FindCEGUI.cmake	2008-11-26 19:42:03 UTC (rev 4613)
+++ rl/branches/newton20/cmake/FindCEGUI.cmake	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,124 +0,0 @@
-# - Find CEGUI includes and library
-#
-# This module defines
-#  CEGUI_INCLUDE_DIRS
-#  CEGUI_LIBRARIES, the libraries to link against to use CEGUI.
-#  CEGUI_LIBRARY_DIRS, the location of the libraries
-#  CEGUI_FOUND, If false, do not try to use CEGUI
-#
-# Copyright ?? 2007-2008, Matt Williams
-#
-# Redistribution and use is allowed according to the terms of the BSD license.
-# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
-
-IF (CEGUI_LIBRARIES AND CEGUI_INCLUDE_DIRS)
-	SET(CEGUI_FIND_QUIETLY TRUE)
-ENDIF (CEGUI_LIBRARIES AND CEGUI_INCLUDE_DIRS)
-
-#SET(OGRESDK $ENV{OGRE_HOME})
-#STRING(REGEX REPLACE "[\\]" "/" OGRESDK "${OGRESDK}")
-FILE(TO_CMAKE_PATH "$ENV{OGRE_HOME}" OGRESDK)
-SET(CEGUI_INCLUDE_SEARCH_DIRS
-	${INCLUDE_SEARCH_DIRS}
-	${CMAKE_LIBRARY_PATH}
-	/usr/include
-	/usr/local/include
-	/usr/include/CEGUI
-	/usr/local/include/CEGUI
-	/opt/include/CEGUI
-	/opt/CEGUI/include
-	$ENV{OGRE_HOME}/samples/CEGUI
-	$ENV{OGRE_HOME}/Dependencies/include
-	$ENV{OGRE_HOME}/Dependencies/include/CEGUI
-	CACHE STRING ""
-)
-
-SET(CEGUI_LIBRARY_SEARCH_DIRS
-	${LIBRARY_SEARCH_DIRS}
-	${CMAKE_LIBRARY_PATH}
-	/usr/lib
-	/usr/lib64
-	/usr/local/lib
-	/usr/local/lib64
-	/opt/lib
-	/opt/lib64
-	/opt/CEGUI/lib
-	/opt/CEGUI/lib64
-	$ENV{OGRE_HOME}/lib
-	$ENV{OGRE_HOME}/lib64
-	CACHE STRING ""
-)
-
-IF (WIN32) #Windows
-	MESSAGE(STATUS "Looking for CEGUI")
-	FIND_PATH(CEGUI_INCLUDE_DIRS CEGUI.h ${CEGUI_INCLUDE_SEARCH_DIRS})
-	FIND_LIBRARY(CEGUI_LIBRARIES debug CEGUIBase_d optimized CEGUIBase PATHS ${CEGUI_LIBRARY_SEARCH_DIRS})
-	
-# 	SET(OGRESOURCE $ENV{OGRE_NEW})
-# 	IF (OGRESDK)
-# 		MESSAGE(STATUS "Using CEGUI in OGRE SDK")
-# 		SET(OGRESDK $ENV{OGRE_HOME})
-# 		STRING(REGEX REPLACE "[\\]" "/" OGRESDK "${OGRESDK}" )
-# 		SET(CEGUI_INCLUDE_DIRS ${OGRESDK}/include/CEGUI)
-# 		SET(CEGUI_LIBRARY_DIRS ${OGRESDK}/lib)
-# 		SET(CEGUI_LIBRARIES debug CEGUIBase_d optimized CEGUIBase)
-# 	ELSEIF (OGRESOURCE)
-# 		MESSAGE(STATUS "Using CEGUI in OGRE dependencies")
-# 		SET(CEGUI_INCLUDE_DIRS C:/ogrenew/Dependencies/include C:/ogrenew/Dependencies/include/CEGUI)
-# 		SET(CEGUI_LIBRARY_DIRS C:/ogrenew/Dependencies/lib/Release C:/ogrenew/Dependencies/lib/Debug)
-# 		SET(CEGUI_LIBRARIES debug CEGUIBase_d optimized CEGUIBase)
-# 	ELSE (OGRESDK)
-# 		IF (NOT DEPENDENCIES_PATH)
-# 			MESSAGE(STATUS "Please set DEPENDENCIES_PATH (the directory containing 'common' and 'dependencies')")
-# 		ELSE (NOT DEPENDENCIES_PATH)
-# 			SET(CEGUI_INCLUDE_DIRS ${DEPENDENCIES_PATH}/dependencies/Ogre/CEGUI)
-# 			SET(CEGUI_LIBRARIES optimized CEGUIBase debug CEGUIBase_d)
-# 			SET(CEGUI_LIBRARY_DIRS optimized ${DEPENDENCIES_PATH}/dependencies/lib/release debug ${DEPENDENCIES_PATH}/dependencies/lib/debug)
-# 		ENDIF (NOT DEPENDENCIES_PATH)
-# 	ENDIF (OGRESDK)
-ELSE (WIN32) #Unix
-	SET(CEGUI_INCLUDE_DIRS ${CEGUI_INCLUDE_DIRSS})
-	SET(CEGUI_LIBRARY_DIRS ${CEGUI_LIBDIR})
-	SET(CEGUI_LIBRARIES ${CEGUI_LIBRARIES})
-
-	CMAKE_MINIMUM_REQUIRED(VERSION 2.4.7 FATAL_ERROR)
-	FIND_PACKAGE(PkgConfig)
-	IF(PKG_CONFIG_FOUND)
-		PKG_SEARCH_MODULE(CEGUI CEGUI)
-		SET(CEGUI_INCLUDE_DIRS ${CEGUI_INCLUDE_DIRS})
-		SET(CEGUI_LIBRARY_DIRS ${CEGUI_LIBDIR})
-		SET(CEGUI_LIBRARIES ${CEGUI_LIBRARIES} CACHE STRING "")
-	ENDIF(PKG_CONFIG_FOUND)
-	IF(NOT CEGUI_FOUND) #If PkgConfig couldn't find OGRE...
-		IF (NOT CEGUI_FIND_QUIETLY)
-			MESSAGE(STATUS " Manually searching for CEGUI")
-		ENDIF (NOT CEGUI_FIND_QUIETLY)
-		FIND_PATH(CEGUI_INCLUDE_DIRS Ogre.h ${CEGUI_INCLUDE_SEARCH_DIRS})
-		FIND_LIBRARY(CEGUI_LIBRARIES CEGUIBase PATHS ${CEGUI_LIBRARY_SEARCH_DIRS})
-	ENDIF(NOT CEGUI_FOUND)
-ENDIF (WIN32)
-
-#Do some preparation
-SEPARATE_ARGUMENTS(CEGUI_INCLUDE_DIRS)
-SEPARATE_ARGUMENTS(CEGUI_LIBRARIES)
-
-SET(CEGUI_INCLUDE_DIRS ${CEGUI_INCLUDE_DIRS})
-SET(CEGUI_LIBRARIES ${CEGUI_LIBRARIES})
-SET(CEGUI_LIBRARY_DIRS ${CEGUI_LIBRARY_DIRS})
-
-MARK_AS_ADVANCED(CEGUI_INCLUDE_DIRS CEGUI_LIBRARIES CEGUI_LIBRARY_DIRS)
-
-IF (CEGUI_INCLUDE_DIRS AND CEGUI_LIBRARIES)
-	SET(CEGUI_FOUND TRUE)
-ENDIF (CEGUI_INCLUDE_DIRS AND CEGUI_LIBRARIES)
-
-IF (CEGUI_FOUND)
-	IF (NOT CEGUI_FIND_QUIETLY)
-		MESSAGE(STATUS "  libraries : ${CEGUI_LIBRARIES} from ${CEGUI_LIBRARY_DIRS}")
-		MESSAGE(STATUS "  includes  : ${CEGUI_INCLUDE_DIRS}")
-	ENDIF (NOT CEGUI_FIND_QUIETLY)
-ELSE (CEGUI_FOUND)
-	IF (CEGUI_FIND_REQUIRED)
-		MESSAGE(FATAL_ERROR "Could not find CEGUI. Make sure you have the CEGUI development headers are installed. Otherwise, try setting LIBRARY_SEARCH_DIRS and INCLUDE_SEARCH_DIRS to the place CEGUI was installed with -DLIBRARY_SEARCH_DIRS=<path/to/lib> -DINCLUDE_SEARCH_DIRS=<path/to/include>")
-	ENDIF (CEGUI_FIND_REQUIRED)
-ENDIF (CEGUI_FOUND)

Copied: rl/branches/newton20/cmake/FindCEGUI.cmake (from rev 4613, rl/trunk/cmake/FindCEGUI.cmake)

Deleted: rl/branches/newton20/cmake/FindFMODEx.cmake
===================================================================
--- rl/trunk/cmake/FindFMODEx.cmake	2008-11-26 19:42:03 UTC (rev 4613)
+++ rl/branches/newton20/cmake/FindFMODEx.cmake	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,122 +0,0 @@
-# Find FMODEx
-#
-# This module defines
-# FMODEX_FOUND
-# FMODEX_INCLUDE_DIR
-# FMODEX_LIBRARY
-#
-# Based on the CMakeLists.txt of zdoom and FindFMOD.cmake of openfrag
-#
-# Redistribution and use is allowed according to the terms of the BSD license.
-# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
-
-# On a new cmake run, we do not need to be verbose
-IF(FMODEX_INCLUDE_DIR AND FMODEX_LIBRARY)
-	SET(FMODEX_FIND_QUIETLY TRUE)
-ENDIF(FMODEX_INCLUDE_DIR AND FMODEX_LIBRARY)
-
-# Check for for 32/64 bit architecture
-IF(CMAKE_SIZEOF_VOID_P MATCHES "8")
-	SET(X64 64)
-ENDIF(CMAKE_SIZEOF_VOID_P MATCHES "8")
-
-IF(WIN32)
-	SET(FMODEX_INC_DIR_SUFFIXES PATH_SUFFIXES inc)
-	SET(FMODEX_LIB_DIR_SUFFIXES PATH_SUFFIXES lib)
-ELSE(WIN32)
-	SET(FMODEX_INCLUDE_SEARCH_DIRS
-	    /usr/include
-	    /usr/local/include
-	    /opt/fmodex/fmodex/include
-            /opt/include)
-	SET(FMODEX_LIBRARY_SEARCH_DIRS
-	    /usr/lib
-	    /usr/lib64
-	    /usr/local/lib
-	    /usr/local/lib64
-	    /opt/fmodex/lib
-	    /opt/fmodex/lib64)
-	SET(FMODEX_INC_DIR_SUFFIXES PATH_SUFFIXES fmodex)
-ENDIF(WIN32)
-
-# Decide on the name of the FMODEx library we want to use
-IF(NOT FMODEX_LIBRARY_NAME AND MSVC)
-	SET(FMODEX_LIBRARY_NAME fmodex${X64}_vc)
-ENDIF(NOT FMODEX_LIBRARY_NAME AND MSVC)
-
-IF(NOT FMODEX_LIBRARY_NAME AND BORLAND)
-	SET(FMODEX_LIBRARY_NAME fmodex${X64}_bc)
-ENDIF(NOT FMODEX_LIBRARY_NAME AND BORLAND)
-
-IF(NOT FMODEX_LIBRARY_NAME)
-	SET(FMODEX_LIBRARY_NAME fmodex${X64})
-ENDIF(NOT FMODEX_LIBRARY_NAME)
-
-IF (NOT FMODEX_FIND_QUIETLY)
-	MESSAGE(STATUS "Checking for FMODEx")
-ENDIF(NOT FMODEX_FIND_QUIETLY)
-
-# Search for header files and libraries
-FIND_PATH(FMODEX_INCLUDE_DIR fmod.h
-          PATHS ${FMODEX_INCLUDE_SEARCH_PATHS}
-          PATH_SUFFIXES ${FMODEX_INC_DIR_SUFFIXES})
-IF(FMODEX_INCLUDE_DIR)
-	IF (NOT FMODEX_FIND_QUIETLY)
-		MESSAGE(STATUS "  includes: ${FMODEX_INCLUDE_DIR}")
-	ENDIF(NOT FMODEX_FIND_QUIETLY)
-ELSE(FMODEX_INCLUDE_DIR)
-	MESSAGE(SEND_ERROR "FMODEx include files could not be found.")
-ENDIF(FMODEX_INCLUDE_DIR)
-
-FIND_LIBRARY(FMODEX_LIBRARY ${FMODEX_LIBRARY_NAME}
-             PATHS ${FMODEX_LIBRARY_SEARCH_DIRS}
-             PATH_SUFFIXES ${FMOD_LIB_DIR_SUFFIXES})
-IF(FMODEX_LIBRARY)
-	IF (NOT FMODEX_FIND_QUIETLY)
-		MESSAGE(STATUS "  libraries: ${FMODEX_LIBRARY}")
-	ENDIF(NOT FMODEX_FIND_QUIETLY)
-ELSE(FMODEX_LIBRARY)
-	MESSAGE(SEND_ERROR, "FMODex library could not be found.")
-ENDIF(FMODEX_LIBRARY)
-
-IF(FMODEX_INCLUDE_DIR AND FMODEX_LIBRARY)
-	SET(FMODEX_FOUND TRUE)
-ENDIF(FMODEX_INCLUDE_DIR AND FMODEX_LIBRARY)
-
-# Allow customisation of paths
-SET(FMODEX_INCLUDE_DIR ${FMODEX_INCLUDE_DIR})
-SET(FMODEX_LIBRARY ${FMODEX_LIBRARY})
-
-IF(FMODEX_INCLUDE_DIR)
-	# Extract the library version from the header file
-	SET(FMODEX_VERSION 0)
-	FILE(READ "${FMODEX_INCLUDE_DIR}/fmod.h"
-	     _FMODEX_FMOD_H_CONTENTS)
-	STRING(REGEX REPLACE ".*#define FMOD_VERSION    0x([0-9]+).*" "\\1"
-	       FMODEX_VERSION "${_FMODEX_FMOD_H_CONTENTS}")
-	IF(NOT "${FMODEX_VERSION}" STREQUAL 0)
-		MATH(EXPR FMODEX_MAJOR_VERSION "${FMODEX_VERSION} / 10000")
-		MATH(EXPR FMODEX_MINOR_VERSION "${FMODEX_VERSION} / 100 % 100")
-		MATH(EXPR FMODEX_PATCH_VERSION "${FMODEX_VERSION} % 100")
-		SET(FMODEX_VERSION "${FMODEX_MAJOR_VERSION}.${FMODEX_MINOR_VERSION}.${FMODEX_PATCH_VERSION}")
-	ENDIF(NOT "${FMODEX_VERSION}" STREQUAL 0)
-
-	# Compare installed and required version
-	IF(FMODEx_FIND_VERSION)
-		# Major and minor version are required
-		IF(NOT FMODEx_FIND_VERSION_MINOR)
-			MESSAGE(SEND_ERROR "When requesting a specific version of FMODEx , you must provide at least the major and minor version numbers, e.g., 4.20")
-		ENDIF(NOT FMODEx_FIND_VERSION_MINOR)
-
-		IF ("${FMOD_VERSION}" VERSION_LESS "${FMODEx_FIND_VERSION}")
-			SET(FMODEX_FOUND FALSE)
-			MESSAGE(STATUS "Detected version of FMODEx ${FMODEX_VERSION} is too old. At least version ${FMODEx_FIND_VERSION} is required.")
-		ENDIF("${FMOD_VERSION}" VERSION_LESS "${FMODEx_FIND_VERSION}")
-	ENDIF(FMODEx_FIND_VERSION)
-ENDIF(FMODEX_INCLUDE_DIR)
-
-IF(FMODEX_FOUND)
-	IF(NOT FMODEX_FIND_QUIETLY)
-		MESSAGE(STATUS "  version: ${FMODEX_VERSION}")
-	ENDIF(NOT FMODEX_FIND_QUIETLY)
-ENDIF(FMODEX_FOUND)
\ No newline at end of file

Copied: rl/branches/newton20/cmake/FindFMODEx.cmake (from rev 4613, rl/trunk/cmake/FindFMODEx.cmake)

Deleted: rl/branches/newton20/cmake/FindOGRE.cmake
===================================================================
--- rl/trunk/cmake/FindOGRE.cmake	2008-11-26 19:42:03 UTC (rev 4613)
+++ rl/branches/newton20/cmake/FindOGRE.cmake	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,96 +0,0 @@
-# Find OGRE includes and library
-#
-# This module defines
-#  OGRE_INCLUDE_DIRS
-#  OGRE_LIBRARIES, the libraries to link against to use OGRE.
-#  OGRE_LIBRARY_DIRS, the location of the libraries
-#  OGRE_FOUND, If false, do not try to use OGRE
-#
-# Copyright ?? 2007-2008, Matt Williams
-#
-# Redistribution and use is allowed according to the terms of the BSD license.
-# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
-
-IF (OGRE_LIBRARIES AND OGRE_INCLUDE_DIRS)
-	SET(OGRE_FIND_QUIETLY TRUE) # Already in cache, be silent
-ENDIF (OGRE_LIBRARIES AND OGRE_INCLUDE_DIRS)
-
-#Set the library and include search paths
-#SET(OGRESDK $ENV{OGRE_HOME})
-#STRING(REGEX REPLACE "[\\]" "/" OGRESDK "${OGRESDK}")
-FILE(TO_CMAKE_PATH "$ENV{OGRE_HOME}" OGRESDK)
-SET(OGRE_INCLUDE_SEARCH_DIRS #                 this <-
-	${INCLUDE_SEARCH_DIRS} #TODO Cache this, not ^
-	${CMAKE_LIBRARY_PATH}
-	/usr/include/OGRE
-	/usr/local/include/OGRE
-	/opt/include/OGRE
-	/opt/OGRE/include
-	${OGRESDK}/include
-	${OGRESDK}/OgreMain/include
-	CACHE STRING ""
-)
-
-SET(OGRE_LIBRARY_SEARCH_DIRS
-	${LIBRARY_SEARCH_DIRS}
-	${CMAKE_LIBRARY_PATH}
-	/usr/lib
-	/usr/lib64
-	/usr/local/lib
-	/usr/local/lib64
-	/opt/lib
-	/opt/lib64
-	/opt/OGRE/lib
-	/opt/OGRE/lib64
-	${OGRESDK}/lib
-	${OGRESDK}/lib64
-	CACHE STRING ""
-)
-
-#Search for the headers and libraries
-IF (WIN32) #Windows
-	MESSAGE(STATUS "Looking for OGRE")
-	FIND_PATH(OGRE_INCLUDE_DIRS Ogre.h ${OGRE_INCLUDE_SEARCH_DIRS})
-	FIND_LIBRARY(OGRE_LIBRARIES debug OgreMain_d optimized OgreMain PATHS ${OGRE_LIBRARY_SEARCH_DIRS})
-ELSE (WIN32) #Unix/OSX
-	FIND_PACKAGE(PkgConfig)
-	IF(PKG_CONFIG_FOUND)
-		CMAKE_MINIMUM_REQUIRED(VERSION 2.4.7)
-		PKG_SEARCH_MODULE(OGRE OGRE)
-		SET(OGRE_INCLUDE_DIRS ${OGRE_INCLUDE_DIRS})
-		SET(OGRE_LIBRARY_DIRS ${OGRE_LIBDIR})
-		SET(OGRE_LIBRARIES ${OGRE_LIBRARIES} CACHE STRING "")
-	ENDIF(PKG_CONFIG_FOUND)
-	IF(NOT OGRE_FOUND) #If PkgConfig couldn't find OGRE...
-		IF (NOT OGRE_FIND_QUIETLY)
-			MESSAGE(STATUS " Manually searching for OGRE")
-		ENDIF (NOT OGRE_FIND_QUIETLY)
-		FIND_PATH(OGRE_INCLUDE_DIRS Ogre.h ${OGRE_INCLUDE_SEARCH_DIRS})
-		FIND_LIBRARY(OGRE_LIBRARIES OgreMain PATHS ${OGRE_LIBRARY_SEARCH_DIRS})
-	ENDIF(NOT OGRE_FOUND)
-ENDIF (WIN32)
-
-#Do some preparation
-SEPARATE_ARGUMENTS(OGRE_INCLUDE_DIRS)
-SEPARATE_ARGUMENTS(OGRE_LIBRARIES)
-
-SET(OGRE_INCLUDE_DIRS ${OGRE_INCLUDE_DIRS})
-SET(OGRE_LIBRARIES ${OGRE_LIBRARIES})
-SET(OGRE_LIBRARY_DIRS ${OGRE_LIBRARY_DIRS})
-
-MARK_AS_ADVANCED(OGRE_INCLUDE_DIRS OGRE_LIBRARIES OGRE_LIBRARY_DIRS) #So they don't show in the default GUI
-
-IF (OGRE_INCLUDE_DIRS AND OGRE_LIBRARIES)
-	SET(OGRE_FOUND TRUE)
-ENDIF (OGRE_INCLUDE_DIRS AND OGRE_LIBRARIES)
-
-IF (OGRE_FOUND)
-	IF (NOT OGRE_FIND_QUIETLY)
-		MESSAGE(STATUS "  libraries : ${OGRE_LIBRARIES} from ${OGRE_LIBRARY_DIRS}")
-		MESSAGE(STATUS "  includes  : ${OGRE_INCLUDE_DIRS}")
-	ENDIF (NOT OGRE_FIND_QUIETLY)
-ELSE (OGRE_FOUND)
-	IF (OGRE_FIND_REQUIRED)
-		MESSAGE(FATAL_ERROR "Could not find OGRE. Make sure you have the OGRE development headers installed. Otherwise, try setting LIBRARY_SEARCH_DIRS and INCLUDE_SEARCH_DIRS to the place OGRE was installed with -DLIBRARY_SEARCH_DIRS=<path/to/lib> -DINCLUDE_SEARCH_DIRS=<path/to/include>")
-	ENDIF (OGRE_FIND_REQUIRED)
-ENDIF (OGRE_FOUND)

Copied: rl/branches/newton20/cmake/FindOGRE.cmake (from rev 4613, rl/trunk/cmake/FindOGRE.cmake)

Modified: rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/Lockenwickler.e4p	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,7 +1,7 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <!DOCTYPE Project SYSTEM "Project-4.5.dtd">
 <!-- eric4 project file for project Lockenwickler -->
-<!-- Saved: 2008-10-31, 11:20:58 -->
+<!-- Saved: 2008-11-09, 21:48:49 -->
 <!-- Copyright (C) 2008 Stefan Stammberger, sstammberger at web.de -->
 <Project version="4.5">
   <ProgLanguage mixed="0">Python</ProgLanguage>
@@ -22,7 +22,6 @@
     <Source>src/PreferencesDialog.py</Source>
     <Source>src/PythonOgreConfig.py</Source>
     <Source>src/ui_ConsoleWindow.py</Source>
-    <Source>src/ui_pref_dialog.py</Source>
     <Source>src/SceneExplorer.py</Source>
     <Source>src/Property.py</Source>
     <Source>src/ViewportGrid.py</Source>
@@ -33,10 +32,14 @@
     <Source>src/GameObjectClassView.py</Source>
     <Source>src/MyRaySceneQueryListener.py</Source>
     <Source>src/GOStringEditor.py</Source>
+    <Source>src/GOIntEditor.py</Source>
+    <Source>src/CodeDump.py</Source>
+    <Source>src/NewModuleWizard.py</Source>
   </Sources>
   <Forms>
     <Form>ui files/GOPropertyEditorDialogINT.ui</Form>
     <Form>ui files/GOPropertyEditorDialogSTRING.ui</Form>
+    <Form>ui files/NewModuleWizard.ui</Form>
   </Forms>
   <Translations>
   </Translations>

Copied: rl/branches/newton20/editors/Lockenwickler/src/CodeDump.py (from rev 4613, rl/trunk/editors/Lockenwickler/src/CodeDump.py)

Modified: rl/branches/newton20/editors/Lockenwickler/src/ConsoleWindow.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ConsoleWindow.py	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/src/ConsoleWindow.py	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,74 +1,74 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from ui_ConsoleWindow import *
-import ogre.renderer.OGRE as og
-
-
-
-class LockenLog(og.LogListener):
-    def __init__(self, logFunction):
-        og.LogListener.__init__(self)
-        self.logFunction = logFunction
-
-    def messageLogged(self, message, level, debug, logName):
-        self.logFunction(str(message))
-
-class ConsoleWindow(QtGui.QDialog):
-    def __init__(self, filterLog, parent=None):
-        QtGui.QDialog.__init__(self, parent)
-        self.filterLog = filterLog
-
-        self.consoleWindow = Ui_ConsoleWindow()
-        self.consoleWindow.setupUi(self)
-        self.consoleWindow.textEdit.setReadOnly(True)
-        self.lockenLog = LockenLog(self.write)
-
-        sys.stdout = self
-        sys.stderr = self
-
-        clearAction= QAction("Clear Window",  self)
-        self.consoleWindow.textEdit.addAction(clearAction)
-        self.consoleWindow.textEdit.setContextMenuPolicy(Qt.ActionsContextMenu)
-        clearAction.setShortcut("Ctrl + R")
-        self.connect(clearAction, SIGNAL("triggered()"), self.consoleWindow.textEdit.clear)
-
-
-    def write(self, text):
-        if self.filterLog:
-            if text.isspace():
-                return
-            elif text.startswith("Error"):
-                self.consoleWindow.textEdit.append(text)
-                return
-            elif text.startswith("OGRE EXCEPTION"):
-                self.consoleWindow.textEdit.append(text)
-                return
-            elif text.startswith("dbg:"):
-                self.consoleWindow.textEdit.append(text)
-                return
-        else:
-            self.consoleWindow.textEdit.append(text)
-
-    def clear(self):
-        self.consoleWindow.textEdit.clear()
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from ui_ConsoleWindow import *
+import ogre.renderer.OGRE as og
+
+
+
+class LockenLog(og.LogListener):
+    def __init__(self, logFunction):
+        og.LogListener.__init__(self)
+        self.logFunction = logFunction
+
+    def messageLogged(self, message, level, debug, logName):
+        self.logFunction(str(message))
+
+class ConsoleWindow(QtGui.QDialog):
+    def __init__(self, filterLog, parent=None):
+        QtGui.QDialog.__init__(self, parent)
+        self.filterLog = filterLog
+
+        self.consoleWindow = Ui_ConsoleWindow()
+        self.consoleWindow.setupUi(self)
+        self.consoleWindow.textEdit.setReadOnly(True)
+        self.lockenLog = LockenLog(self.write)
+
+        sys.stdout = self
+        sys.stderr = self
+
+        clearAction= QAction("Clear Window",  self)
+        self.consoleWindow.textEdit.addAction(clearAction)
+        self.consoleWindow.textEdit.setContextMenuPolicy(Qt.ActionsContextMenu)
+        clearAction.setShortcut("Ctrl + R")
+        self.connect(clearAction, SIGNAL("triggered()"), self.consoleWindow.textEdit.clear)
+
+
+    def write(self, text):
+        if self.filterLog:
+            if text.isspace():
+                return
+            elif text.startswith("Error"):
+                self.consoleWindow.textEdit.append(text)
+                return
+            elif text.startswith("OGRE EXCEPTION"):
+                self.consoleWindow.textEdit.append(text)
+                return
+            elif text.startswith("dbg:"):
+                self.consoleWindow.textEdit.append(text)
+                return
+        else:
+            self.consoleWindow.textEdit.append(text)
+
+    def clear(self):
+        self.consoleWindow.textEdit.clear()

Copied: rl/branches/newton20/editors/Lockenwickler/src/GOIntEditor.py (from rev 4613, rl/trunk/editors/Lockenwickler/src/GOIntEditor.py)

Modified: rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/src/GameObjectClass.py	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,176 +1,207 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-from elementtree.ElementTree import *
-
-from PyQt4.QtCore import *
-from PyQt4.QtGui import *
-
-from GOStringEditor import *
-
-class GOCStringProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "STRING"
-
-    def openEditor(self, row, parent = None):
-        dlg = GOStringEditor(parent)
-        dlg.nameEdit.setText(self.name)
-        dlg.dataEdit.setText(self.data)
-        result = dlg.exec_()
-        if result:
-            self.name = dlg.nameEdit.text()
-            self.data = dlg.dataEdit.toPlainText()
-
-        return result
-
-class GOCRealProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "REAL"
-
-class GOCBoolProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "BOOL"
-
-class GOCIntProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "INT"
-
-class GOCIntPairProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "INTPAIR"
-
-class GOCIntTripleProperty():
-    def __init__(self, name, data):
-        self.name = name
-        self.data = data
-
-    def getType(self):
-        return "INTTRIPPLE"
-
-class GOCMapProperty():
-    def __init__(self, name):
-        self.name = name
-        self.childProperties = []
-
-    def getType(self):
-        return "MAP"
-
-class GameObjectRepresentation():
-    def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
-        self.inWorldId = inWorldId
-        self.goc = gameObjectClass
-        self.node = node
-        self.meshFile = meshFile
-
-    def setPosition(self, pos):
-        self.node.setPosition(pos)
-
-
-class GameObjectClass():
-    def __init__(self,  parentElement):
-        self.classid = parentElement.get("classid")
-        self.baseclass = parentElement.get("baseclass")
-
-        self.meshFile = None
-
-        self.properties = []
-
-        for property in parentElement:#.getiterator("property"):
-            if property.get("type") == "ARRAY":
-                pass
-            elif property.get("type") == "MAP":
-                self.properties.append(self.createPropertyMap(property))
-            else:
-                self.properties.append(self.createProperty(property))
-
-    def getType(self):
-        return "GAME_OBJECT"
-
-    def createPropertyMap(self, property):
-        propMap = GOCMapProperty(property.get("name"))
-        for subProperty in property:
-            if subProperty.get("type") == "MAP":
-                propMap.childProperties.append(self.createPropertyMap(property))
-            else:
-                for subProperty1 in property:
-                    propMap.childProperties.append(self.createProperty(subProperty1))
-
-        return propMap
-
-    def getMeshFileName(self):
-        if self.meshFile is None:
-            for prop in self.properties:
-                if prop.getType() == "STRING":
-                    if prop.name == "meshfile":
-                        self.meshFile = prop.data
-                        return self.meshFile
-            return None
-        else:
-            return self.meshFile
-
-
-    def createProperty(self, property):
-        if property.get("type") == "STRING":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCStringProperty(name, data)
-        elif property.get("type") == "REAL":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCRealProperty(name, data)
-        elif property.get("type") == "BOOL":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCBoolProperty(name, data)
-        elif property.get("type") == "INT":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCIntProperty(name, data)
-        elif property.get("type") == "INTPAIR":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCIntPairProperty(name, data)
-        elif property.get("type") == "INTTRIPLE":
-            name = property.get("name")
-            data = property.get("data")
-            return GOCIntTripleProperty(name, data)
-        else:
-            print property.get("type")
-
-
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+from elementtree.ElementTree import *
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+import ogre.renderer.OGRE as og
+
+from GOStringEditor import *
+from GOIntEditor import *
+
+class GOCStringProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "STRING"
+
+    def openEditor(self, row, parent = None):
+        dlg = GOStringEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCRealProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "REAL"
+
+    def openEditor(self, row, parent = None):
+        dlg = GOStringEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCBoolProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "BOOL"
+
+class GOCIntProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "INT"
+
+    def openEditor(self, row, parent = None):
+        dlg = GOIntEditor(parent)
+        dlg.nameEdit.setText(self.name)
+        dlg.dataEdit.setText(self.data)
+        result = dlg.exec_()
+        if result:
+            self.name = dlg.nameEdit.text()
+            self.data = dlg.dataEdit.toPlainText()
+
+        return result
+
+class GOCIntPairProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "INTPAIR"
+
+class GOCIntTripleProperty():
+    def __init__(self, name, data):
+        self.name = name
+        self.data = data
+
+    def getType(self):
+        return "INTTRIPPLE"
+
+class GOCMapProperty():
+    def __init__(self, name):
+        self.name = name
+        self.childProperties = []
+
+    def getType(self):
+        return "MAP"
+
+# gameObjectClass is the id of the class itself
+# since a game object can be ingame more than once there is also a id for those
+class GameObjectRepresentation(og.UserDefinedObject):
+    def __init__(self, inWorldId, gameObjectClass, node, meshFile = None):
+        og.UserDefinedObject.__init__(self)
+        self.inWorldId = inWorldId
+        self.gocName = gameObjectClass
+        self.node = node
+        self.meshFile = meshFile
+
+    def getType(self):
+        return "GAME_OBJECT_REPRESENTATION"
+
+    def setPosition(self, pos):
+        self.node.setPosition(pos)
+
+
+class GameObjectClass():
+    def __init__(self,  parentElement):
+        self.classid = parentElement.get("classid")
+        self.baseclass = parentElement.get("baseclass")
+
+        self.meshFile = None
+
+        self.properties = []
+
+        for property in parentElement:#.getiterator("property"):
+            if property.get("type") == "ARRAY":
+                pass
+            elif property.get("type") == "MAP":
+                self.properties.append(self.createPropertyMap(property))
+            else:
+                self.properties.append(self.createProperty(property))
+
+    def getType(self):
+        return "GAME_OBJECT"
+
+    def createPropertyMap(self, property):
+        propMap = GOCMapProperty(property.get("name"))
+        for subProperty in property:
+            if subProperty.get("type") == "MAP":
+                propMap.childProperties.append(self.createPropertyMap(property))
+            else:
+                for subProperty1 in property:
+                    propMap.childProperties.append(self.createProperty(subProperty1))
+
+        return propMap
+
+    def getMeshFileName(self):
+        if self.meshFile is None:
+            for prop in self.properties:
+                if prop.getType() == "STRING":
+                    if prop.name == "meshfile":
+                        self.meshFile = prop.data
+                        return self.meshFile
+            return None
+        else:
+            return self.meshFile
+
+
+    def createProperty(self, property):
+        if property.get("type") == "STRING":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCStringProperty(name, data)
+        elif property.get("type") == "REAL":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCRealProperty(name, data)
+        elif property.get("type") == "BOOL":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCBoolProperty(name, data)
+        elif property.get("type") == "INT":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCIntProperty(name, data)
+        elif property.get("type") == "INTPAIR":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCIntPairProperty(name, data)
+        elif property.get("type") == "INTTRIPLE":
+            name = property.get("name")
+            data = property.get("data")
+            return GOCIntTripleProperty(name, data)
+        else:
+            print property.get("type")
+
+
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassManager.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassManager.py	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/src/GameObjectClassManager.py	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,52 +1,52 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-from elementtree.ElementTree import parse
-
-from GameObjectClass import *
-
-class GameObjectClassManager():
-    def __init__(self):
-        self.fileDict = {}
-        self.callback = None
-
-    def parseGOFFiles(self, filePaths):
-        for filePath in filePaths:
-            tree = parse(filePath)
-            gocList = []
-            for parent in tree.getiterator("gameobjectclass"): # return all allements with the "gameobjectclass" tag
-                go = GameObjectClass(parent)
-                gocList.append(go)
-
-            self.fileDict[filePath] = gocList
-
-        if self.callback is not None:
-            self.callback(self.fileDict)
-
-    def getGameObjectWithClassId(self, id):
-        for key in self.fileDict:
-            for go in self.fileDict[key]:
-                if go.classid == id:
-                    return go
-
-        return None
-
-        # whenever a gameobject changes outside of the view, the view has to update itself wth the new values
-    def setGameObjectsViewUpdateCallback(self, callback):
-        self.callback = callback
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+from elementtree.ElementTree import parse
+
+from GameObjectClass import *
+
+class GameObjectClassManager():
+    def __init__(self):
+        self.fileDict = {}
+        self.callback = None
+
+    def parseGOFFiles(self, filePaths):
+        for filePath in filePaths:
+            tree = parse(filePath)
+            gocList = []
+            for parent in tree.getiterator("gameobjectclass"): # return all allements with the "gameobjectclass" tag
+                go = GameObjectClass(parent)
+                gocList.append(go)
+
+            self.fileDict[filePath] = gocList
+
+        if self.callback is not None:
+            self.callback(self.fileDict)
+
+    def getGameObjectWithClassId(self, id):
+        for key in self.fileDict:
+            for go in self.fileDict[key]:
+                if go.classid == id:
+                    return go
+
+        return None
+
+        # whenever a gameobject changes outside of the view, the view has to update itself wth the new values
+    def setGameObjectsViewUpdateCallback(self, callback):
+        self.callback = callback
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/src/Lockenwickler.py	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,499 +1,440 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import os
-import sys
-import platform
-
-#sys.path.insert(0,'..')
-#import PythonOgreConfig
-
-from random import randint
-from os.path import isfile
-
-from PyQt4 import QtGui, QtCore
-from PreferencesDialog import *
-from ObjectPropertyWin import *
-from ModelSelectionDialog import *
-from GameObjectClassView import *
-from ConsoleWindow import *
-from ModuleManager import *
-from SceneExplorer import *
-
-import OgreMainWindow
-import ogre.renderer.OGRE as og
-
-class Lockenwickler(QtGui.QMainWindow):
-    def __init__(self, parent=None):
-        QtGui.QWidget.__init__(self, parent)
-
-        pixmap = QPixmap("media/icons/lockenwickler_provisorium.png")
-        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
-        splash.setMask(pixmap.mask())
-        splash.showMessage("Starting...")
-        splash.show()
-
-        self.setupUi()
-
-        self.consoleWindow = ConsoleWindow(False,  self)
-
-        self.setupOgre()
-
-        self.prefDialog = PreferencesDialog(self.loadModule, self)
-        self.objectPropertyWin = ObjectPropertyWin(self)
-        self.sceneExplorerWin = SceneExplorer(self)
-        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
-        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
-
-        self.createDockWindows()
-
-        self.mainTimer = QtCore.QTimer(self)
-        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL("timeout()"), self.update)
-        self.mainTimer.start(5)
-
-        settings = QtCore.QSettings()
-        self.restoreGeometry(settings.value("MainWindow/Geometry").toByteArray())
-        self.restoreState(settings.value("MainWindow/DockWindows").toByteArray())
-
-        self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
-        self.setWindowTitle("Rastullahs Lockenwickler")
-#        # Import Psyco if available
-#        try:
-#            import psyco
-#            psyco.full()
-#            #psyco.log()
-#            #psyco.profile()
-#        except ImportError:
-#            pass
-
-        #QtGui.QApplication.setKeyboardInputInterval(5000)
-
-        splash.finish(self)
-
-    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
-        action = QtGui.QAction(text, self)
-        if icon is not None:
-            action.setIcon(QtGui.QIcon("media/icons/%s" % icon))
-        if shortcut is not None:
-            action.setShortcut(shortcut)
-        if tip is not None:
-            action.setToolTip(tip)
-            action.setStatusTip(tip)
-        if slot is not None:
-            self.connect(action, QtCore.SIGNAL(signal), slot)
-
-        action.setCheckable(checkable)
-
-        return action
-
-    def addActions(self, target, actions):
-        for act in actions:
-            if act is None:
-               target.addSeparator()
-            else:
-                target.addAction(act)
-
-    def setupUi(self):
-        self.setObjectName("MainWindow")
-
-        self.centralwidget = QtGui.QWidget(self)
-        self.centralwidget.setObjectName("centralwidget")
-
-        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
-        self.hboxlayout.setObjectName("hboxlayout")
-
-        self.gridlayout = QtGui.QGridLayout()
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.menubar = QtGui.QMenuBar(self)
-        self.menubar.setObjectName("menubar")
-
-        self.menuFile = QtGui.QMenu(self.menubar)
-        self.menuFile.setObjectName("menuFile")
-
-        self.menuEdit = QtGui.QMenu(self.menubar)
-        self.menuEdit.setObjectName("menuEdit")
-
-        self.menuView = QtGui.QMenu(self.menubar)
-        self.menuView.setObjectName("menuView")
-        self.setMenuBar(self.menubar)
-
-
-        self.statusbar = QtGui.QStatusBar(self)
-        self.statusbar.setObjectName("statusbar")
-        self.setStatusBar(self.statusbar)
-
-#####################################
-        self.actionNeu =self.createAction("&New",  self.actionNewSlot,  QKeySequence.New,  "filenew.png",  "New")
-        self.actionNeu.setObjectName("actionNeu")
-
-        self.actionClose = self.createAction("Quit",  self.actionQuitSlot,  "Alt + Q",  "exit.png",  "Quit")
-        self.actionClose.setObjectName("actionQuit")
-#####################################
-
-
-#####################################
-        self.actionDelete = self.createAction("Delete",  self.actionDeleteSlot,  QKeySequence.Delete,  "editdelete.png",  "Delete")
-        self.actionDelete.setObjectName("actionDelete")
-
-        self.actionCopy = self.createAction("Copy",  self.actionCopySlot,  QKeySequence.Copy,  "editcopy.png",  "Copy")
-        self.actionCopy.setObjectName("actionCopy")
-
-        self.actionCut = self.createAction("Cut",  self.actionCutSlot,  QKeySequence.Cut,  "editcut.png",  "Cut")
-        self.actionCut.setObjectName("actionCut")
-
-        self.actionPaste = self.createAction("Paste",  self.actionPasteSlot,  QKeySequence.Paste,  "editpaste.png",  "Paste")
-        self.actionPaste.setObjectName("actionPaste")
-
-        self.actionMove = self.createAction("&Move",  self.actionMoveSlot,  "g",  "move.png",  "Move selected object")
-        self.actionMove.setObjectName("actionMove")
-
-        self.actionRotate = self.createAction("&Rotate",  self.actionRotateSlot,  "r",  "rotate.png",  "Rotate selected object")
-        self.actionRotate.setObjectName("actionRotate")
-
-        self.actionScale = self.createAction("&Scale",  self.actionScaleSlot,  "x",  "resizecol.png",  "Scale selected object")
-        self.actionRotate.setObjectName("actionRotate")
-
-
-#####################################
-#####################################
-        self.actionSceneExplorer = self.createAction("&Scene Exlporer",  self.toggleSceneExplorer,  "Alt + E",  "view_tree.png",  "Scene Explorer",  False)
-        self.actionSceneExplorer.setObjectName("actionSceneExplorer")
-
-        self.actionPreferences = self.createAction("&Preferences",  self.togglePreferencesWindow,  "Alt + P",  "configure.png",  "Lockenwickler Preferences",  False)
-        self.actionPreferences.setObjectName("actionPreferences")
-
-        self.actionProperty_Window = self.createAction("Pr&operty Window",  self.togglePropertyWindow,  "Alt + P",  "unsortedlist1.png",  "Property Window")
-        self.actionProperty_Window.setObjectName("actionProperty_Window")
-
-        self.actionObject_Selection = self.createAction("&Model Preview Window",  self.toggleModelPreviewWindow,  "Alt + O",  "tux.png",  "Model Preview")
-        self.actionObject_Selection.setObjectName("actionObject_Selection")
-
-        self.actionGameObjectClass_Selection = self.createAction("&Game Object Class Preview Window",  self.toggleGameObjectViewWindow,  "Alt + G",  "multirow.png",  "GameObjectClass Preview")
-        self.actionGameObjectClass_Selection.setObjectName("actionObject_Selection")
-
-        self.actionConsole_Window = self.createAction("&Console Window",  self.toggleConsoleWindow,  "Alt + C",  "console.png",  "Console Window")
-        self.actionConsole_Window.setObjectName("actionConsole_Window")
-
-#####################################
-#####################################
-
-
-        self.menuFile.addAction(self.actionNeu)
-        self.menuFile.addAction(self.actionClose)
-
-        self.menuEdit.addAction(self.actionMove)
-        self.menuEdit.addAction(self.actionRotate)
-        self.menuEdit.addAction(self.actionScale)
-        self.menuEdit.addSeparator()
-        self.menuEdit.addAction(self.actionDelete)
-        self.menuEdit.addAction(self.actionCopy)
-        self.menuEdit.addAction(self.actionCut)
-        self.menuEdit.addAction(self.actionPaste)
-
-        self.menuView.addAction(self.actionSceneExplorer)
-        self.menuView.addAction(self.actionPreferences)
-        self.menuView.addAction(self.actionProperty_Window)
-        self.menuView.addAction(self.actionObject_Selection)
-        self.menuView.addAction(self.actionGameObjectClass_Selection)
-        self.menuView.addAction(self.actionConsole_Window)
-        self.menubar.addAction(self.menuFile.menuAction())
-        self.menubar.addAction(self.menuEdit.menuAction())
-        self.menubar.addAction(self.menuView.menuAction())
-
-        self.retranslateUi()
-        QtCore.QMetaObject.connectSlotsByName(self)
-
-    def retranslateUi(self):
-        self.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuEdit.setTitle(QtGui.QApplication.translate("MainWindow", "Edit", None, QtGui.QApplication.UnicodeUTF8))
-        self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "New", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionMove.setText(QtGui.QApplication.translate("MainWindow", "Move", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionRotate.setText(QtGui.QApplication.translate("MainWindow", "Rotate", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionSceneExplorer.setText(QtGui.QApplication.translate("MainWindow", "Scene Explorer", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionClose.setText(QtGui.QApplication.translate("MainWindow", "Quit", None, QtGui.QApplication.UnicodeUTF8))
-        self.actionConsole_Window.setText(QtGui.QApplication.translate("MainWindow", "Console Window", None, QtGui.QApplication.UnicodeUTF8))
-
-    def setupOgre(self, pluginCfgPath="./Plugins.cfg", ogreCfgPath="./ogre.cfg", logPath="./ogre.log"):
-        if platform.system() == "Windows":
-            pluginCfgPath="./Plugins-windows.cfg"
-        else:
-            pluginCfgPath="./Plugins-linux.cfg"
-
-        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
-        self.ogreRoot = root
-
-        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
-            sys.exit('Quit from Config Dialog')
-
-        root.initialise(False)
-
-        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, "OgreMainWinSceneMgr")
-        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
-
-        self.moduleName = ""
-        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
-
-        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
-        self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
-        self.hboxlayout.addLayout(self.gridlayout)
-        self.setCentralWidget(self.centralwidget)
-
-        og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
-        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-        oglog = og.LogManager.getSingleton().getDefaultLog()
-        oglog.addListener(self.consoleWindow.lockenLog)
-
-    def update(self):
-#        try:
-#            self.OgreMainWinSceneMgr.getSceneNode("saeule_076_node").yaw(0.02)
-#        except Exception,  e:
-#            pass
-
-        self.ogreRoot.renderOneFrame()
-
-    def actionNewSlot(self):
-        print "dbg: new"
-        return
-
-    def actionQuitSlot(self):
-        self.close()
-
-    def actionDeleteSlot(self):
-        self.moduleManager.deleteObjects()
-
-    def actionCopySlot(self):
-        self.moduleManager.copyObjects()
-
-    def actionCutSlot(self):
-        self.moduleManager.cutObjects()
-
-    def actionPasteSlot(self):
-        self.moduleManager.pasteObjects(self.ogreRenderWindow.getCameraToViewportRay())
-
-    def actionMoveSlot(self):
-        self.moduleManager.pivot.setMoveMode()
-
-    def actionRotateSlot(self):
-        self.moduleManager.pivot.setRotateMode()
-
-    def actionScaleSlot(self):
-        self.moduleManager.pivot.setScaleMode()
-
-    def togglePreferencesWindow(self):
-        if self.prefDialog.isHidden():
-            self.prefDialog.show()
-        else:
-            self.prefDialog.hide()
-
-    def toggleModelPreviewWindow(self):
-        if self.modelSelectionDock.isHidden():
-            self.modelSelectionDock.show()
-        else:
-            self.modelSelectionDock.hide()
-
-    def toggleGameObjectViewWindow(self):
-        if self.gameObjectClassViewDock.isHidden():
-            self.gameObjectClassViewDock.show()
-        else:
-            self.gameObjectClassViewDock.hide()
-
-    def toggleSceneExplorer(self):
-        if self.sceneExplorerDock.isHidden():
-            self.sceneExplorerDock.show()
-        else:
-            self.sceneExplorerDock.hide()
-
-    def togglePropertyWindow(self):
-        if self.propertyDock.isHidden():
-            self.propertyDock.show()
-        else:
-            self.propertyDock.hide()
-
-    def toggleConsoleWindow(self):
-        if self.consoleDock.isHidden():
-            self.consoleDock.show()
-        else:
-            self.consoleDock.hide()
-
-    # parses the moduleconfig.rb and searches for all loader.loadmap(" statements in the ruby script
-    # and parses them too
-    def loadModule(self, modulePath, moduleName):
-        if self.moduleName == moduleName:
-            return
-
-        self.moduleName = moduleName
-        self.workingDir = modulePath + moduleName # the module path
-        self.workingDirCommon = modulePath + "common" # the module path of the common module
-
-        import codecs
-        import glob
-
-        modConfig = self.workingDir + "/scripts/moduleconfig.rb"
-        if isfile(modConfig): # is the modconfig existing?
-            f = codecs.open(modConfig, 'r', 'utf-8')
-        else:
-            print ("Error: couldn't find module config")
-            pass
-
-        self.mapFiles = [] # a list in case the module has more than one map file
-        self.gofFiles = [] # gof File list
-        for line in f:
-            lStripped = line.strip() #strip the whitespace away, not needed here
-
-            # get the map file(s)
-            if lStripped.startswith("loader.loadMap("): # all loadMap commands begin with loader.loadMap(
-                spl = lStripped.split('"')
-                for a in spl:
-                    if a.endswith(".xml"):
-                        pathToMapFile = self.workingDir + "/maps/" + a
-                        self.mapFiles.append(pathToMapFile)
-
-        self.setWindowTitle(moduleName)
-
-        self.modelSelectionDialog.scanDirForModels(self.workingDir, moduleName)
-        self.modelSelectionDialog.scanDirForModels(self.workingDirCommon, "common")
-
-        self.setResourcePaths(self.workingDir, moduleName)
-        self.setResourcePaths(self.workingDirCommon, "common")
-        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
-
-        command = (os.path.join(self.workingDir,  "maps") + "/*.xml")
-        for mf in glob.glob(command): # search for all xml files in the maps directory and add them
-            self.mapFiles.append(mf)
-
-        command = (os.path.join(self.workingDir,  "maps") + "/*.scene")
-        for mf in glob.glob(command): # search for all .scene files in the maps directory and add them
-            self.mapFiles.append(mf)
-
-        command = (os.path.join(self.workingDir,  "dsa") + "/*.gof")
-        for gf in glob.glob(command): # search for all .gof files in the dsa directory in the module dir
-            self.gofFiles.append(gf)
-
-        command = (os.path.join(self.workingDirCommon,  "dsa") + "/*.gof")
-        for gf in glob.glob(command): # search for all .gof files in the dsa directory in the common module dir
-            self.gofFiles.append(gf)
-
-        self.moduleManager.load(moduleName,  self.mapFiles,  self.gofFiles)
-
-    def setResourcePaths(self, path, moduleName):
-        for file in os.listdir(path):
-            curFile = path + "/" + file
-
-            if file.startswith('.'): #ignore dot files (hidden)
-                continue
-            if isdir(curFile):
-                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", moduleName, False)
-                self.setResourcePaths(curFile, moduleName)
-                continue
-            if isfile(curFile):
-                pass
-
-    def createDockWindows(self):
-        self.propertyDock = QtGui.QDockWidget(self.tr("Properties"), self)
-        self.propertyDock.setObjectName("PropertyDockWindow")
-        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.propertyDock.setWidget(self.objectPropertyWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
-
-        self.modelSelectionDock = QtGui.QDockWidget(self.tr("Models"), self)
-        self.modelSelectionDock.setObjectName("ModelSelectionDockWindow")
-        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
-
-        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr("GameObjectClasses"), self)
-        self.gameObjectClassViewDock.setObjectName("GameObjectClassView")
-        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
-        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
-
-        self.sceneExplorerDock = QtGui.QDockWidget(self.tr("Scene Explorer"), self)
-        self.sceneExplorerDock.setObjectName("SceneExplorerDockWindow")
-        self.sceneExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
-        self.sceneExplorerDock.setWidget(self.sceneExplorerWin)
-        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.sceneExplorerDock)
-
-        self.consoleDock = QtGui.QDockWidget(self.tr("Console"), self)
-        self.consoleDock.setObjectName("ConsoleDockWindow")
-        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
-        self.consoleDock.setWidget(self.consoleWindow)
-        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
-
-        self.fileToolBar = self.addToolBar("File Toolbar")
-        self.fileToolBar.setObjectName("FileToolBar")
-        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.fileToolBar.addAction(self.actionNeu)
-        self.fileToolBar.addAction(self.actionClose)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
-
-        self.moveToolBar = self.addToolBar("Transformation Bar")
-        self.moveToolBar.setObjectName("TransformationBar")
-        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
-        self.moveToolBar.addAction(self.actionMove)
-        self.moveToolBar.addAction(self.actionRotate)
-        self.moveToolBar.addAction(self.actionScale)
-        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
-
-    def keyPressEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreRenderWindow.keyPressEvent(event)
-
-    def keyReleaseEvent(self,  event):
-        if not event.isAutoRepeat():
-            self.ogreRenderWindow.keyReleaseEvent(event)
-        pass
-
-    def connectActionButtons(self):
-        pass
-
-    def saveOnClose(self):
-        reply = QtGui.QMessageBox.question(self,  "Rastullahs Lockenwickler - Unsaved Chages",  "Save unsaved changes?",  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
-        if reply == QtGui.QMessageBox.Cancel:
-            return False
-        if reply == QtGui.QMessageBox.Yes:
-            print""
-            #TODO: implement save here
-        return True
-
-    def closeEvent(self,  event):
-        if self.saveOnClose():
-            settings = QtCore.QSettings()
-            settings.setValue("MainWindow/Geometry",  QtCore.QVariant(self.saveGeometry()))
-            settings.setValue("MainWIndow/DockWindows",  QtCore.QVariant(self.saveState()))
-        else:
-            event.ignore()
-
-if __name__ == "__main__":
-    app = QtGui.QApplication(sys.argv)
-    app.setOrganizationName("Team Pantheon")
-    app.setOrganizationDomain("rastullahs-lockenpracht.de/team")
-    app.setApplicationName("Lockenwickler")
-
-    form = Lockenwickler()
-    form.show()
-
-    sys.exit(app.exec_())
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import os
+import sys
+import platform
+
+#sys.path.insert(0,'..')
+#import PythonOgreConfig
+
+from random import randint
+
+from PyQt4 import QtGui, QtCore
+from PreferencesDialog import *
+from ObjectPropertyWin import *
+from ModelSelectionDialog import *
+from GameObjectClassView import *
+from ConsoleWindow import *
+from ModuleManager import *
+from SceneExplorer import *
+from NewModuleWizard import *
+
+import OgreMainWindow
+import ogre.renderer.OGRE as og
+
+class Lockenwickler(QtGui.QMainWindow):
+    def __init__(self, parent=None):
+        QtGui.QWidget.__init__(self, parent)
+
+        pixmap = QPixmap("media/icons/lockenwickler_provisorium.png")
+        splash = QSplashScreen(pixmap, Qt.WindowStaysOnTopHint)
+        splash.setMask(pixmap.mask())
+        splash.showMessage("Starting...")
+        splash.show()
+
+        self.setupUi()
+
+        self.consoleWindow = ConsoleWindow(False,  self)
+
+        self.setupOgre()
+
+        self.prefDialog = PreferencesDialog(self)
+        self.objectPropertyWin = ObjectPropertyWin(self)
+        self.sceneExplorerWin = SceneExplorer(self)
+        self.modelSelectionDialog = ModelSelectionDialog(self.ogreRoot, self)
+        self.gameObjectClassView = GameObjectClassView(self.moduleManager.gocManager)
+
+        self.createDockWindows()
+
+        self.mainTimer = QtCore.QTimer(self)
+        self.mainTimer.connect(self.mainTimer, QtCore.SIGNAL("timeout()"), self.update)
+        self.mainTimer.start(5)
+
+        settings = QtCore.QSettings()
+        self.restoreGeometry(settings.value("MainWindow/Geometry").toByteArray())
+        self.restoreState(settings.value("MainWindow/DockWindows").toByteArray())
+        if not self.prefDialog.setCfgPath(settings.value("Preferences/moduleCfgPath").toString()):
+            self.prefDialog.show()
+
+        self.setWindowIcon(QIcon("media/icons/lockenwickler_provisorium_small.png"))
+        self.setWindowTitle("Rastullahs Lockenwickler")
+
+
+#        # Import Psyco if available
+#        try:
+#            import psyco
+#            psyco.full()
+#            #psyco.log()
+#            #psyco.profile()
+#        except ImportError:
+#            pass
+
+        splash.finish(self)
+
+    def createAction(self, text, slot=None, shortcut=None, icon=None, tip=None, checkable=False, signal="triggered()"):
+        action = QtGui.QAction(text, self)
+        if icon is not None:
+            action.setIcon(QtGui.QIcon("media/icons/%s" % icon))
+        if shortcut is not None:
+            action.setShortcut(shortcut)
+        if tip is not None:
+            action.setToolTip(tip)
+            action.setStatusTip(tip)
+        if slot is not None:
+            self.connect(action, QtCore.SIGNAL(signal), slot)
+
+        action.setCheckable(checkable)
+
+        return action
+
+    def addActions(self, target, actions):
+        for act in actions:
+            if act is None:
+               target.addSeparator()
+            else:
+                target.addAction(act)
+
+    def setupUi(self):
+        self.setObjectName("MainWindow")
+
+        self.centralwidget = QtGui.QWidget(self)
+        self.centralwidget.setObjectName("centralwidget")
+
+        self.hboxlayout = QtGui.QHBoxLayout(self.centralwidget)
+        self.hboxlayout.setObjectName("hboxlayout")
+
+        self.gridlayout = QtGui.QGridLayout()
+        self.gridlayout.setObjectName("gridlayout")
+
+        self.menubar = QtGui.QMenuBar(self)
+        self.menubar.setObjectName("menubar")
+
+        self.menuFile = QtGui.QMenu(self.menubar)
+        self.menuFile.setObjectName("menuFile")
+
+        self.menuEdit = QtGui.QMenu(self.menubar)
+        self.menuEdit.setObjectName("menuEdit")
+
+        self.menuView = QtGui.QMenu(self.menubar)
+        self.menuView.setObjectName("menuView")
+        self.setMenuBar(self.menubar)
+
+
+        self.statusbar = QtGui.QStatusBar(self)
+        self.statusbar.setObjectName("statusbar")
+        self.setStatusBar(self.statusbar)
+
+#####################################
+        self.actionNeu =self.createAction("&New Module",  self.actionNewSlot,  QKeySequence.New,  "filenew.png",  "New Module")
+        self.actionNeu.setObjectName("actionNeu")
+
+        self.actionOpen = self.createAction("&Open Module",  self.actionOpenSlot,  QKeySequence.Open,  "filenew.png",  "Open Module")
+        self.actionOpen.setObjectName("actionOpen")
+
+        self.actionClose = self.createAction("Quit",  self.actionQuitSlot,  "Alt + Q",  "exit.png",  "Quit")
+        self.actionClose.setObjectName("actionQuit")
+#####################################
+
+
+#####################################
+        self.actionDelete = self.createAction("Delete",  self.actionDeleteSlot,  QKeySequence.Delete,  "editdelete.png",  "Delete")
+        self.actionDelete.setObjectName("actionDelete")
+
+        self.actionCopy = self.createAction("Copy",  self.actionCopySlot,  QKeySequence.Copy,  "editcopy.png",  "Copy")
+        self.actionCopy.setObjectName("actionCopy")
+
+        self.actionCut = self.createAction("Cut",  self.actionCutSlot,  QKeySequence.Cut,  "editcut.png",  "Cut")
+        self.actionCut.setObjectName("actionCut")
+
+        self.actionPaste = self.createAction("Paste",  self.actionPasteSlot,  QKeySequence.Paste,  "editpaste.png",  "Paste")
+        self.actionPaste.setObjectName("actionPaste")
+
+        self.actionSelect = self.createAction("&Select",  self.actionSelectSlot,  "Space",  "cursor.png",  "Move selected object")
+        self.actionSelect.setObjectName("actionSelect")
+
+        self.actionMove = self.createAction("&Move",  self.actionMoveSlot,  "g",  "move.png",  "Move selected object")
+        self.actionMove.setObjectName("actionMove")
+
+        self.actionRotate = self.createAction("&Rotate",  self.actionRotateSlot,  "r",  "rotate.png",  "Rotate selected object")
+        self.actionRotate.setObjectName("actionRotate")
+
+        self.actionScale = self.createAction("&Scale",  self.actionScaleSlot,  "x",  "resizecol.png",  "Scale selected object")
+        self.actionRotate.setObjectName("actionRotate")
+
+
+#####################################
+#####################################
+        self.actionSceneExplorer = self.createAction("&Scene Exlporer",  self.toggleSceneExplorer,  "Alt + E",  "view_tree.png",  "Scene Explorer",  False)
+        self.actionSceneExplorer.setObjectName("actionSceneExplorer")
+
+        self.actionPreferences = self.createAction("&Preferences",  self.togglePreferencesWindow,  "Alt + P",  "configure.png",  "Lockenwickler Preferences",  False)
+        self.actionPreferences.setObjectName("actionPreferences")
+
+        self.actionProperty_Window = self.createAction("Pr&operty Window",  self.togglePropertyWindow,  "Alt + P",  "unsortedlist1.png",  "Property Window")
+        self.actionProperty_Window.setObjectName("actionProperty_Window")
+
+        self.actionObject_Selection = self.createAction("&Model Preview Window",  self.toggleModelPreviewWindow,  "Alt + O",  "tux.png",  "Model Preview")
+        self.actionObject_Selection.setObjectName("actionObject_Selection")
+
+        self.actionGameObjectClass_Selection = self.createAction("&Game Object Class Preview Window",  self.toggleGameObjectViewWindow,  "Alt + G",  "multirow.png",  "GameObjectClass Preview")
+        self.actionGameObjectClass_Selection.setObjectName("actionObject_Selection")
+
+        self.actionConsole_Window = self.createAction("&Console Window",  self.toggleConsoleWindow,  "Alt + C",  "console.png",  "Console Window")
+        self.actionConsole_Window.setObjectName("actionConsole_Window")
+
+#####################################
+#####################################
+
+
+        self.menuFile.addAction(self.actionNeu)
+        self.menuFile.addAction(self.actionOpen)
+        self.menuFile.addAction(self.actionClose)
+
+        self.menuEdit.addAction(self.actionSelect)
+        self.menuEdit.addAction(self.actionMove)
+        self.menuEdit.addAction(self.actionRotate)
+        self.menuEdit.addAction(self.actionScale)
+        self.menuEdit.addSeparator()
+        self.menuEdit.addAction(self.actionDelete)
+        self.menuEdit.addAction(self.actionCopy)
+        self.menuEdit.addAction(self.actionCut)
+        self.menuEdit.addAction(self.actionPaste)
+
+        self.menuView.addAction(self.actionSceneExplorer)
+        self.menuView.addAction(self.actionPreferences)
+        self.menuView.addAction(self.actionProperty_Window)
+        self.menuView.addAction(self.actionObject_Selection)
+        self.menuView.addAction(self.actionGameObjectClass_Selection)
+        self.menuView.addAction(self.actionConsole_Window)
+        self.menubar.addAction(self.menuFile.menuAction())
+        self.menubar.addAction(self.menuEdit.menuAction())
+        self.menubar.addAction(self.menuView.menuAction())
+
+        self.retranslateUi()
+        QtCore.QMetaObject.connectSlotsByName(self)
+
+    def retranslateUi(self):
+        self.setWindowTitle(QtGui.QApplication.translate("MainWindow", "MainWindow", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuFile.setTitle(QtGui.QApplication.translate("MainWindow", "File", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuEdit.setTitle(QtGui.QApplication.translate("MainWindow", "Edit", None, QtGui.QApplication.UnicodeUTF8))
+        self.menuView.setTitle(QtGui.QApplication.translate("MainWindow", "View", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionNeu.setText(QtGui.QApplication.translate("MainWindow", "New Module", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionMove.setText(QtGui.QApplication.translate("MainWindow", "Move", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionRotate.setText(QtGui.QApplication.translate("MainWindow", "Rotate", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionSceneExplorer.setText(QtGui.QApplication.translate("MainWindow", "Scene Explorer", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionPreferences.setText(QtGui.QApplication.translate("MainWindow", "Preferences", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionProperty_Window.setText(QtGui.QApplication.translate("MainWindow", "Property Window", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionObject_Selection.setText(QtGui.QApplication.translate("MainWindow", "Object Selection", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionClose.setText(QtGui.QApplication.translate("MainWindow", "Quit", None, QtGui.QApplication.UnicodeUTF8))
+        self.actionConsole_Window.setText(QtGui.QApplication.translate("MainWindow", "Console Window", None, QtGui.QApplication.UnicodeUTF8))
+
+    def setupOgre(self, pluginCfgPath="./Plugins.cfg", ogreCfgPath="./ogre.cfg", logPath="./ogre.log"):
+        if platform.system() == "Windows":
+            pluginCfgPath="./Plugins-windows.cfg"
+        else:
+            pluginCfgPath="./Plugins-linux.cfg"
+
+        root = og.Root(pluginCfgPath, ogreCfgPath, logPath)
+        self.ogreRoot = root
+
+        if  not self.ogreRoot.restoreConfig() and not self.ogreRoot.showConfigDialog():
+            sys.exit('Quit from Config Dialog')
+
+        root.initialise(False)
+
+        self.OgreMainWinSceneMgr = self.ogreRoot.createSceneManager(og.ST_GENERIC, "OgreMainWinSceneMgr")
+        self.OgreMainWinSceneMgr.ambientLight = og.ColourValue(4, 4, 4)
+
+        self.moduleName = ""
+        self.moduleManager = ModuleManager(self.ogreRoot,  self.OgreMainWinSceneMgr)
+
+        self.ogreRenderWindow = OgreMainWindow.OgreMainWindow(self.moduleManager,  root,  self.OgreMainWinSceneMgr,  self)
+        self.gridlayout.addWidget(self.ogreRenderWindow,0,0,1,1)
+        self.hboxlayout.addLayout(self.gridlayout)
+        self.setCentralWidget(self.centralwidget)
+
+        og.ResourceGroupManager.getSingleton().addResourceLocation("./media", "FileSystem", "General", False)
+        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+        oglog = og.LogManager.getSingleton().getDefaultLog()
+        oglog.addListener(self.consoleWindow.lockenLog)
+
+    def update(self):
+        self.ogreRoot.renderOneFrame()
+
+    def actionOpenSlot(self):
+        self.moduleManager.openLoadModuleDialog(self.prefDialog.lineEdit.text(), self)
+
+    def actionNewSlot(self):
+        newModuleWiz = NewModuleWizard(self)
+        newModuleWiz.exec_()
+        return
+
+    def actionQuitSlot(self):
+        self.close()
+
+    def actionDeleteSlot(self):
+        self.moduleManager.deleteObjects()
+
+    def actionCopySlot(self):
+        self.moduleManager.copyObjects()
+
+    def actionCutSlot(self):
+        self.moduleManager.cutObjects()
+
+    def actionPasteSlot(self):
+        self.moduleManager.pasteObjects(self.ogreRenderWindow.getCameraToViewportRay())
+
+    def actionSelectSlot(self):
+        self.moduleManager.pivot.hide()
+
+    def actionMoveSlot(self):
+        self.moduleManager.pivot.setMoveMode()
+
+    def actionRotateSlot(self):
+        self.moduleManager.pivot.setRotateMode()
+
+    def actionScaleSlot(self):
+        self.moduleManager.pivot.setScaleMode()
+
+    def togglePreferencesWindow(self):
+        if self.prefDialog.isHidden():
+            self.prefDialog.show()
+        else:
+            self.prefDialog.hide()
+
+    def toggleModelPreviewWindow(self):
+        if self.modelSelectionDock.isHidden():
+            self.modelSelectionDock.show()
+        else:
+            self.modelSelectionDock.hide()
+
+    def toggleGameObjectViewWindow(self):
+        if self.gameObjectClassViewDock.isHidden():
+            self.gameObjectClassViewDock.show()
+        else:
+            self.gameObjectClassViewDock.hide()
+
+    def toggleSceneExplorer(self):
+        if self.sceneExplorerDock.isHidden():
+            self.sceneExplorerDock.show()
+        else:
+            self.sceneExplorerDock.hide()
+
+    def togglePropertyWindow(self):
+        if self.propertyDock.isHidden():
+            self.propertyDock.show()
+        else:
+            self.propertyDock.hide()
+
+    def toggleConsoleWindow(self):
+        if self.consoleDock.isHidden():
+            self.consoleDock.show()
+        else:
+            self.consoleDock.hide()
+
+    def createDockWindows(self):
+        self.propertyDock = QtGui.QDockWidget(self.tr("Properties"), self)
+        self.propertyDock.setObjectName("PropertyDockWindow")
+        self.propertyDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.propertyDock.setWidget(self.objectPropertyWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.propertyDock)
+
+        self.modelSelectionDock = QtGui.QDockWidget(self.tr("Models"), self)
+        self.modelSelectionDock.setObjectName("ModelSelectionDockWindow")
+        self.modelSelectionDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.modelSelectionDock.setWidget(self.modelSelectionDialog)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.modelSelectionDock)
+
+        self.gameObjectClassViewDock = QtGui.QDockWidget(self.tr("GameObjectClasses"), self)
+        self.gameObjectClassViewDock.setObjectName("GameObjectClassView")
+        self.gameObjectClassViewDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.gameObjectClassViewDock.setWidget(self.gameObjectClassView)
+        self.addDockWidget(QtCore.Qt.RightDockWidgetArea, self.gameObjectClassViewDock)
+
+        self.sceneExplorerDock = QtGui.QDockWidget(self.tr("Scene Explorer"), self)
+        self.sceneExplorerDock.setObjectName("SceneExplorerDockWindow")
+        self.sceneExplorerDock.setAllowedAreas(QtCore.Qt.LeftDockWidgetArea | QtCore.Qt.RightDockWidgetArea)
+        self.sceneExplorerDock.setWidget(self.sceneExplorerWin)
+        self.addDockWidget(QtCore.Qt.LeftDockWidgetArea, self.sceneExplorerDock)
+
+        self.consoleDock = QtGui.QDockWidget(self.tr("Console"), self)
+        self.consoleDock.setObjectName("ConsoleDockWindow")
+        self.consoleDock.setAllowedAreas(QtCore.Qt.BottomDockWidgetArea | QtCore.Qt.TopDockWidgetArea)
+        self.consoleDock.setWidget(self.consoleWindow)
+        self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, self.consoleDock)
+
+        self.fileToolBar = self.addToolBar("File Toolbar")
+        self.fileToolBar.setObjectName("FileToolBar")
+        self.fileToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.fileToolBar.addAction(self.actionNeu)
+        self.fileToolBar.addAction(self.actionClose)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.fileToolBar)
+
+        self.moveToolBar = self.addToolBar("Transformation Bar")
+        self.moveToolBar.setObjectName("TransformationBar")
+        self.moveToolBar.setAllowedAreas(QtCore.Qt.TopToolBarArea | QtCore.Qt.BottomToolBarArea)
+        self.moveToolBar.addAction(self.actionSelect)
+        self.moveToolBar.addAction(self.actionMove)
+        self.moveToolBar.addAction(self.actionRotate)
+        self.moveToolBar.addAction(self.actionScale)
+        self.addToolBar(QtCore.Qt.TopToolBarArea, self.moveToolBar)
+
+    def keyPressEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreRenderWindow.keyPressEvent(event)
+
+    def keyReleaseEvent(self,  event):
+        if not event.isAutoRepeat():
+            self.ogreRenderWindow.keyReleaseEvent(event)
+        pass
+
+    def connectActionButtons(self):
+        pass
+
+    def saveOnClose(self):
+        reply = QtGui.QMessageBox.question(self,  "Rastullahs Lockenwickler - Unsaved Chages",  "Save unsaved changes?",  QtGui.QMessageBox.Yes|QtGui.QMessageBox.No|QtGui.QMessageBox.Cancel)
+        if reply == QtGui.QMessageBox.Cancel:
+            return False
+        if reply == QtGui.QMessageBox.Yes:
+            print""
+            #TODO: implement save here
+        return True
+
+    def closeEvent(self,  event):
+        if self.saveOnClose():
+            settings = QtCore.QSettings()
+            settings.setValue("Preferences/moduleCfgPath", QtCore.QVariant(self.prefDialog.lineEdit.text()))
+            settings.setValue("MainWindow/Geometry",  QtCore.QVariant(self.saveGeometry()))
+            settings.setValue("MainWIndow/DockWindows",  QtCore.QVariant(self.saveState()))
+        else:
+            event.ignore()
+
+if __name__ == "__main__":
+    app = QtGui.QApplication(sys.argv)
+    app.setOrganizationName("Team Pantheon")
+    app.setOrganizationDomain("rastullahs-lockenpracht.de/team")
+    app.setApplicationName("Lockenwickler")
+
+    form = Lockenwickler()
+    form.show()
+
+    sys.exit(app.exec_())
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/src/ModuleManager.py	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,360 +1,550 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-import sys
-import xml.dom.minidom as xml
-
-import ctypes
-import ogre.renderer.OGRE as og
-
-from MovePivot import *
-from GameObjectClassManager import *
-from MyRaySceneQueryListener import *
-
-class ModuleManager(object):
-    def __init__(self,  ogreRoot,  sceneManager):
-        self.sceneManager = sceneManager
-        self.ogreRoot = ogreRoot
-        self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
-
-        self.gocManager = GameObjectClassManager()
-
-        self.userSelectionList = []
-        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
-        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
-
-        self.listenerDings = MyRaySceneQueryListener()
-
-        self.lastRay = None
-#        self.rayLine = None
-
-        self.pivot = None
-        self.movingPivot = False
-
-        self.leftMouseDown = False
-        self.middleMouseDown = False
-        self.rightMouseDown = False
-
-        self.dropCount = 0
-        self.dropNode = None
-        self.dropEntity = None
-        self.dropCollisionPlane = og.Plane(og.Vector3.UNIT_Y, og.Vector3.ZERO)
-
-        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
-
-    def load(self,  moduleName,  mapFiles,  gofFiles):
-        self.moduleName = moduleName
-        self.mapFiles = mapFiles
-        self.gofFiles = gofFiles
-
-        self.gocManager.parseGOFFiles(self.gofFiles)
-
-        for a in self.mapFiles:
-            doc = xml.parse(a)
-            node = doc.getElementsByTagName("entity")
-            if node != None:
-                self.parseSceneNodes(node)
-
-        self.pivot = Pivot(self.sceneManager)
-        self.pivot.hide()
-
-    def parseSceneNodes(self,  nodeList):
-        for ent in nodeList:
-            entityName = ent.attributes["name"].nodeValue # get the name of the ent
-            meshFile = ent.attributes["meshfile"].nodeValue # meshfile
-            nodePosition = None
-            nodeRotation = None
-            nodeScale = None
-
-            for cn in ent.childNodes:
-                if cn.nodeType == cn.ELEMENT_NODE:
-                    if cn.localName == "position":
-                        px = float(cn.attributes["x"].nodeValue)
-                        py = float(cn.attributes["y"].nodeValue)
-                        pz = float(cn.attributes["z"].nodeValue)
-                        nodePosition = og.Vector3(px, py, pz)
-                        continue
-
-                    if cn.localName == "rotation":
-                        qw = float(cn.attributes["qw"].nodeValue)
-                        qx = float(cn.attributes["qx"].nodeValue)
-                        qy = float(cn.attributes["qy"].nodeValue)
-                        qz = float(cn.attributes["qz"].nodeValue)
-                        nodeRotation = og.Quaternion(qw,  qx, qy, qz)
-                        continue
-
-                    if cn.localName == "scale":
-                        px = float(cn.attributes["x"].nodeValue)
-                        py = float(cn.attributes["y"].nodeValue)
-                        pz = float(cn.attributes["z"].nodeValue)
-                        nodeScale = og.Vector3(px, py, pz)
-                        continue
-
-            try:
-                e = self.sceneManager.createEntity(entityName, meshFile)
-            except:
-                print "Warning: Meshfile " + meshFile + " could not be found."
-                return
-
-            n = self.sceneManager.getRootSceneNode().createChild(entityName + "_node")
-            n.attachObject(e)
-            n.setPosition(nodePosition)
-            #n.setOrientation(nodeRotation)
-            n.setScale(nodeScale)
-
-        pass
-
-    # called when a click into Main Ogre Window occurs
-    def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
-        self.listenerDings.reset()
-        self.lastRay = ray
-        self.listenerDings.currentRay = ray
-        self.raySceneQuery.Ray = ray
-        self.raySceneQuery.execute(self.listenerDings)
-
-        so = self.listenerDings.rayCastToPolygonLevel(ray)
-        if so is not None:
-            if not so.isPivot:
-                if self.pivot is not None:
-                    self.pivot.show()
-                if not controlDown and not shiftDown:
-                    self.resetSelection()
-                    so.setSelected(True)
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-                elif controlDown and not shiftDown:
-                    so.setSelected(True)
-
-                    for soFromList in self.userSelectionList:
-                        if soFromList == so:
-                            return # object already selected
-
-                    self.userSelectionList.append(so)
-                    self.updatePivots()
-
-
-                elif not controlDown and shiftDown:
-                    for selo in self.userSelectionList:
-                        if so == selo:
-                            so.setSelected(False)
-                            self.userSelectionList.remove(selo)
-                    self.updatePivots()
-            else:
-                #so.entity is the pivot direction that was clicked
-                self.pivot.startTransforming(so.entity,  self.userSelectionList)
-        else:
-            self.resetSelection() # click in empty space, deselect everything
-            if self.pivot is not None:
-                self.pivot.hide()
-
-#        if self.rayLine == None:
-#            self.rayLine = self.sceneManager.createManualObject("rayLine")
-#            self.rayLine.setDynamic(True)
-#            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
-#
-#            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-#
-#        else:
-#            self.rayLine.beginUpdate(0)
-#
-#            self.rayLine.position(ray.getOrigin())
-#            self.rayLine.position( ray.getPoint(10000))
-#
-#            self.rayLine.end()
-
-    def deleteObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        self.pivot.hide()
-
-        for so in self.userSelectionList:
-            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
-            del so
-
-        self.userSelectionList = []
-
-    def incrementNameSuffixNumber(self, name):
-        newName = ""
-        split = name.split("_")
-        lastPart = len(split)-1
-        newName = name.rstrip(split[lastPart])
-        newName = newName + str(self.numerOfCopys)
-
-#        if split[lastPart].isdigit() and not split[lastPart].startswith("0"):
-#            num = int(split[lastPart])
-#            num = num + 1
-#            newName = name.rstrip(split[lastPart])
-#            newName = newName + str(num)
-#        else:
-#            newName = name + "_1"
-
-        self.numerOfCopys = self.numerOfCopys + 1
-        return newName
-
-    def copyObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-
-        newSelectionList = []
-        print "dbg: "
-        for so in self.userSelectionList:
-            nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
-            newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
-
-            entityName = self.incrementNameSuffixNumber(so.entity.getName())
-            newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
-
-            newNode.attachObject(newEntity)
-            newNode.setPosition(so.entity.getParentNode().getPosition())
-            newNode.setOrientation(so.entity.getParentNode().getOrientation())
-            newNode.setScale(so.entity.getParentNode().getScale())
-
-            newSO = SelectionObject(newEntity, so.distance)
-            newSO.setSelected(True)
-            newSelectionList.append(newSO)
-
-        self.resetSelection()
-        self.userSelectionList = newSelectionList
-
-    def cutObjects(self):
-        if len(self.userSelectionList) < 1:
-            return
-            return
-
-        self.cutList = []
-        for so in self.userSelectionList:
-            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
-            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
-            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
-            # so we only have to translate them to their new destination when they get pasted
-            # the position of the pivot point is considered as the center of gravity
-            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
-            self.cutList.append(so)
-        self.resetSelection()
-    def pasteObjects(self,  ray):
-        if len(self.cutList) < 1:
-            return
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
-                i = i+1
-        else:
-            i=0
-            while i < len(self.cutList):
-                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
-                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
-                i = i+1
-        self.cutList = []
-
-    def leftMouseUp(self):
-        if self.pivot is not None and self.pivot.isTransforming:
-            self.pivot.stopTransforming()
-
-#    def iterateEntityUnderMouse(self):
-#        self.listenerDings.iterateEntityUnderMouse()
-#
-#        pass
-
-    def resetSelection(self):
-        for so in self.userSelectionList:
-            so.setSelected(False)
-
-        self.userSelectionList = []
-
-        self.listenerDings.reset()
-        pass
-
-
-    def updatePivots(self):
-        newPivotPosition = og.Vector3(0, 0, 0)
-
-        for so in self.userSelectionList:
-            newPivotPosition += so.entity.getParentNode().getPosition()
-        if self.pivot is not None:
-            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
-
-    def unload(self,  saveOnUnload=True):
-        pass
-
-    def save(self):
-        pass
-
-    def startDropGameObjectAction(self, classid, ray):
-        go = self.gocManager.getGameObjectWithClassId(classid)
-        meshFile = go.getMeshFileName()
-
-        if go is not None:
-            dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-            dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
-            dropNode.attachObject(dropEntity)
-
-            result = og.Math.intersects(ray, self.dropCollisionPlane)
-            if result.first == True:
-                dropNode.setPosition(ray.getPoint(result.second))
-            else:
-                dropNode.setPosition(ray.getPoint(50))
-
-            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
-            dropEntity.setUserObject(self.dropGO)
-
-        self.dropCount += 1
-
-    def moveDropGameObjectAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropGO.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropGO.setPosition(ray.getPoint(50))
-
-    def stopDropGameObjectAction(self, ray):
-        print "sd"
-
-    def startDropModelAction(self, meshFile, ray):
-        self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
-        self.dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
-        self.dropNode.attachObject(self.dropEntity)
-
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-        self.dropCount += 1
-
-    def moveDropModelAction(self, ray):
-        result = og.Math.intersects(ray, self.dropCollisionPlane)
-        if result.first == True:
-            self.dropNode.setPosition(ray.getPoint(result.second))
-        else:
-            self.dropNode.setPosition(ray.getPoint(50))
-
-
-    def stopDropModelAction(self, ray):
-        pass
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+import sys
+import codecs
+import glob
+import os
+from os.path import isfile,  join
+
+
+import elementtree.ElementTree as xml
+
+import ctypes
+import ogre.renderer.OGRE as og
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+from MovePivot import *
+from GameObjectClassManager import *
+from MyRaySceneQueryListener import *
+
+class Map():
+    def __init__(self, pathToFile, sceneManager, ogreRoot):
+        self.pathToMapFile = pathToFile
+        self.sceneManager = sceneManager
+        self.mapNode = sceneManager.getRootSceneNode().createChildSceneNode(self.pathToMapFile)
+        self.ogreRoot = ogreRoot
+
+        xmlTree = xml.parse(pathToFile)
+        root = xmlTree.getroot()
+
+        if root.attrib["formatVersion"] == "0.4.0":
+            self.parseMap(root)
+        else:
+            print pathToFile + " has wrong format version. It needs to be 0.4.0"
+            return
+
+    def parseMap(self, rootElement):
+        nodes = rootElement.getiterator("entity")
+        for n in nodes:
+            entityName = n.attrib["name"]
+            meshFile = n.attrib["meshfile"]
+            nodePosition = None
+            nodeRotation = None
+            nodeScale = None
+
+            transformations = n.getiterator()
+            for t in transformations:
+                if t.tag == "position":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodePosition = og.Vector3(x, y, z)
+                elif t.tag == "rotation":
+                    qw = float(t.attrib["qw"])
+                    qx = float(t.attrib["qx"])
+                    qy = float(t.attrib["qy"])
+                    qz = float(t.attrib["qz"])
+                    nodeRotation = og.Quaternion(qw, qx, qy, qz)
+                elif t.tag == "scale":
+                    x = float(t.attrib["x"])
+                    y = float(t.attrib["y"])
+                    z = float(t.attrib["z"])
+                    nodeScale = og.Vector3(x, y, z)
+
+            try:
+                e = self.sceneManager.createEntity(entityName, meshFile)
+            except:
+                print "Warning: Meshfile " + meshFile + " could not be found."
+                return
+
+            n = self.mapNode.createChild(entityName + "_node")
+            n.attachObject(e)
+            n.setPosition(nodePosition)
+            n.setOrientation(nodeRotation)
+            n.setScale(nodeScale)
+
+
+
+
+class Scene():
+    def __init__(self):
+        return
+
+class Module():
+    def __init__(self,name, modulePath, sceneManager, ogreRoot):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+
+        self.name = name
+        self.moduleRoot = join(modulePath, name)
+        self.__isCommon = False
+
+        self.hasDependencies = False
+        self.moduleDependencies = []
+
+        self.mapFiles = [] # a list in case the module has more than one map file
+        self.gofFiles = [] # gof File list
+
+        self.scenes =[]
+
+        self.isLoaded = False
+
+    def isCommon(self):
+        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print ("Error: couldn't find module config")
+            return
+        isDependencieLine = False
+        for i, line in enumerate(f):
+            lStripped = line.strip() #strip the whitespace away, not needed here
+            if lStripped.startswith("super("):
+                split = lStripped.split(",")
+                if split[2].strip() == unicode("true"):
+                    self.__isCommon = True
+                    return True
+
+
+            elif isDependencieLine:
+                if lStripped == "end":
+                    isDependencieLine = False
+                else:
+                    self.hasDependencies = True
+                    self.moduleDependencies.append(lStripped.split('"')[1])
+
+            elif lStripped == "def getDependencies()":
+                isDependencieLine = True
+
+        return False
+
+    def load(self):
+        if self.isLoaded:
+            return
+
+        self.isLoaded = True
+        modConfig = join(self.moduleRoot,  "scripts/moduleconfig.rb")
+        if isfile(modConfig): # is the modconfig existing?
+            f = codecs.open(modConfig, 'r', 'utf-8')
+        else:
+            print ("Error: couldn't find module config")
+            return
+
+        #for i, line in enumerate(f):
+            #lStripped = line.strip() #strip the whitespace away, not needed here
+
+        self.setResourcePaths()
+        og.ResourceGroupManager.getSingleton().initialiseAllResourceGroups()
+
+        if not self.isCommon():
+            cmd = join(self.moduleRoot, "maps/*.rlmap.xml")
+            maps = glob.glob(cmd)
+            for m in maps:
+                self.mapFiles.append(Map(m, self.sceneManager, self.ogreRoot))
+
+            cmd = join(self.moduleRoot, "maps/*.rlscene")
+            sceneFile = glob.glob(cmd)
+            #self.loadScenes(sceneFile)
+
+    def saveMaps(self):
+        return
+
+    def saveScenes(self):
+        return
+
+    def setResourcePaths(self, recurseFolder = ""):
+        if recurseFolder == "":
+            rootFolder = self.moduleRoot
+        else:
+            rootFolder = join(self.moduleRoot, recurseFolder)
+
+        for file in os.listdir(rootFolder):
+            curFile = join(rootFolder, file)
+
+
+            if file.startswith('.'): #ignore dot files (hidden)
+                pass
+            if os.path.isdir(curFile):
+                og.ResourceGroupManager.getSingleton().addResourceLocation(curFile, "FileSystem", self.name, False)
+                self.setResourcePaths(curFile)
+            if os.path.isfile(curFile):
+                pass
+
+class ModuleManager():
+    def __init__(self,  ogreRoot,  sceneManager):
+        self.sceneManager = sceneManager
+        self.ogreRoot = ogreRoot
+        self.raySceneQuery = self.sceneManager.createRayQuery(og.Ray())
+
+        self.gocManager = GameObjectClassManager()
+
+        self.mainModule = []
+        self.mainModuledependencieList =[]
+        self.moduleList = []
+        self.userSelectionList = []
+        self.cutList = [] # selection objects that has been cut out and wait to be pasted again
+        self.cutListPreviousNodes = [] # contains the nodes they where copnnected to before the cut
+
+        # we need to hold a reference to the game object representaions ourself
+        # python does not recognize the a reference to a c++ object (Entity in our case) is passed
+        # and deletes the object
+        self.gameObjectRepresentationDict = []
+
+        self.listenerDings = MyRaySceneQueryListener()
+
+        self.lastRay = None
+#        self.rayLine = None
+
+        self.pivot = None
+        self.movingPivot = False
+
+        self.leftMouseDown = False
+        self.middleMouseDown = False
+        self.rightMouseDown = False
+
+        self.dropCount = 0
+        self.dropNode = None
+        self.dropEntity = None
+        self.dropCollisionPlane = og.Plane(og.Vector3.UNIT_Y, og.Vector3.ZERO)
+
+        self.numerOfCopys = 0 #everytime a copy is made this numer is increased to generate unique node and mesh names
+        self.moduleConfigIsParsed = False
+
+
+    def parseModuleConfig(self):
+        if self.moduleConfigIsParsed:
+            return
+
+        import codecs
+        f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
+
+        for line in f:
+            if line.startswith('#'):
+                continue
+
+            if line.startswith('module='):
+                splines = line.split('=')
+                str = splines[1].rstrip().rstrip()
+                self.moduleList.append(Module(str, self.moduleCfgPath.replace("/modules.cfg",  ""), self.sceneManager, self.ogreRoot))
+
+        self.moduleConfigIsParsed = True
+
+    def openLoadModuleDialog(self, moduleConfigPath, lw):
+        self.moduleCfgPath = str(moduleConfigPath)
+        self.moduleFolder = str(moduleConfigPath.replace("modules.cfg", ""))
+
+        self.parseModuleConfig()
+
+        dlg = QDialog()
+        list = QListWidget()
+        btnBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
+        dlg.connect(btnBox, SIGNAL("accepted()"), dlg.accept)
+        dlg.connect(btnBox, SIGNAL("rejected()"), dlg.reject)
+
+        for m in self.moduleList:
+            if not m.isCommon():
+                list.addItem(m.name)
+
+        layout = QVBoxLayout()
+        layout.addWidget(list)
+        layout.addWidget(btnBox)
+        dlg.setLayout(layout)
+        if dlg.exec_():
+            self.loadModule(str(list.currentItem().text()))
+
+    def loadModule(self, moduleName):
+        for m in self.moduleList:
+            if m.name == moduleName:
+                if m.hasDependencies:
+                    for moduleDependencie in m.moduleDependencies:
+                        for m2 in self.moduleList:
+                            if m2.name == moduleDependencie:
+                                m2.load()
+                                self.mainModuledependencieList.append(m2)
+
+                m.load()
+                self.mainModule = m
+
+
+    # called when a click into Main Ogre Window occurs
+    def selectionClick(self,  ray,  controlDown=False,  shiftDown=False):
+        self.listenerDings.reset()
+        self.lastRay = ray
+        self.listenerDings.currentRay = ray
+        self.raySceneQuery.Ray = ray
+        self.raySceneQuery.execute(self.listenerDings)
+
+        so = self.listenerDings.rayCastToPolygonLevel(ray)
+
+        if so is not None:
+            if not so.isPivot:
+                if not controlDown and not shiftDown:
+                    self.resetSelection()
+                    so.setSelected(True)
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+                elif controlDown and not shiftDown:
+                    so.setSelected(True)
+
+                    for soFromList in self.userSelectionList:
+                        if soFromList == so:
+                            return # object already selected
+
+                    self.userSelectionList.append(so)
+                    self.updatePivots()
+
+
+                elif not controlDown and shiftDown:
+                    for selo in self.userSelectionList:
+                        if so == selo:
+                            so.setSelected(False)
+                            self.userSelectionList.remove(selo)
+                    self.updatePivots()
+            else:
+                #so.entity is the pivot direction that was clicked
+                self.pivot.startTransforming(so.entity,  self.userSelectionList)
+        else:
+            self.resetSelection() # click in empty space, deselect everything
+            if self.pivot is not None:
+                self.pivot.hide()
+
+#        if self.rayLine == None:
+#            self.rayLine = self.sceneManager.createManualObject("rayLine")
+#            self.rayLine.setDynamic(True)
+#            self.sceneManager.getRootSceneNode().createChildSceneNode("raynode").attachObject(self.rayLine)
+#
+#            self.rayLine.begin("BaseWhiteNoLighting", og.RenderOperation.OT_LINE_STRIP)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+#
+#        else:
+#            self.rayLine.beginUpdate(0)
+#
+#            self.rayLine.position(ray.getOrigin())
+#            self.rayLine.position( ray.getPoint(10000))
+#
+#            self.rayLine.end()
+
+    def deleteObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.pivot.hide()
+
+        for so in self.userSelectionList:
+            self.sceneManager.destroySceneNode(so.entity.getParentNode().getName())
+            del so
+
+        self.userSelectionList = []
+
+    def incrementNameSuffixNumber(self, name):
+        newName = ""
+        split = name.split("_")
+        lastPart = len(split)-1
+        newName = name.rstrip(split[lastPart])
+        newName = newName + str(self.numerOfCopys)
+
+#        if split[lastPart].isdigit() and not split[lastPart].startswith("0"):
+#            num = int(split[lastPart])
+#            num = num + 1
+#            newName = name.rstrip(split[lastPart])
+#            newName = newName + str(num)
+#        else:
+#            newName = name + "_1"
+
+        self.numerOfCopys = self.numerOfCopys + 1
+        return newName
+
+    def copyObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        newSelectionList = []
+
+        for so in self.userSelectionList:
+            if so.entity.getUserObject() is not None:
+                if so.entity.getUserObject().getType() == "GAME_OBJECT_REPRESENTATION":
+                    go = self.gocManager.getGameObjectWithClassId(so.entity.getUserObject().gocName)
+                    meshFile = go.getMeshFileName()
+
+                    if go is not None:
+                        newEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+                        newNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
+                        newNode.attachObject(newEntity)
+                        newNode.setPosition(so.entity.getParentNode().getPosition())
+
+                        newGO = GameObjectRepresentation(self.dropCount, so.entity.getUserObject().gocName, newNode, meshFile)
+                        self.gameObjectRepresentationDict.append(newGO)
+                        newEntity.setUserObject(newGO)
+                        newGO.setPosition(og.Vector3(0, 0, 0))
+
+                        newSO = SelectionObject(newEntity, so.distance)
+                        newSO.setSelected(True)
+                        newSelectionList.append(newSO)
+                        self.dropCount += 1
+            else:
+                nodeName = self.incrementNameSuffixNumber(so.entity.getParentNode().getName())
+                newNode = self.sceneManager.getRootSceneNode().createChild(nodeName)
+
+                entityName = self.incrementNameSuffixNumber(so.entity.getName())
+                newEntity = self.sceneManager.createEntity(entityName, so.entity.getMesh().getName())
+
+                newNode.attachObject(newEntity)
+                newNode.setPosition(so.entity.getParentNode().getPosition())
+                newNode.setOrientation(so.entity.getParentNode().getOrientation())
+                newNode.setScale(so.entity.getParentNode().getScale())
+
+                newSO = SelectionObject(newEntity, so.distance)
+                newSO.setSelected(True)
+                newSelectionList.append(newSO)
+
+        self.resetSelection()
+        self.userSelectionList = newSelectionList
+
+    def cutObjects(self):
+        if len(self.userSelectionList) < 1:
+            return
+
+        self.cutList = []
+        for so in self.userSelectionList:
+            self.cutListPreviousNodes.append(so.entity.getParentNode().getParent())
+            so.entity.getParentNode().getParent().removeChild(so.entity.getParentNode())
+            # set the "point of gravity" of all the cutted nodes to world origin at 0,0,0
+            # so we only have to translate them to their new destination when they get pasted
+            # the position of the pivot point is considered as the center of gravity
+            so.entity.getParentNode().setPosition(so.entity.getParentNode().getPosition() - self.pivot.getPosition())
+            self.cutList.append(so)
+        self.resetSelection()
+
+    def pasteObjects(self,  ray):
+        if len(self.cutList) < 1:
+            return
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(result.second))
+                i = i+1
+        else:
+            i=0
+            while i < len(self.cutList):
+                self.cutListPreviousNodes[i].addChild(self.cutList[i].entity.getParentNode())
+                self.cutList[i].entity.getParentNode().translate(ray.getPoint(100.0))
+                i = i+1
+        self.cutList = []
+
+    def leftMouseUp(self):
+        if self.pivot is not None and self.pivot.isTransforming:
+            self.pivot.stopTransforming()
+
+    def resetSelection(self):
+        for so in self.userSelectionList:
+            so.setSelected(False)
+
+        self.userSelectionList = []
+
+        self.listenerDings.reset()
+        pass
+
+
+    def updatePivots(self):
+        newPivotPosition = og.Vector3(0, 0, 0)
+
+        for so in self.userSelectionList:
+            newPivotPosition += so.entity.getParentNode().getPosition()
+        if self.pivot is not None:
+            self.pivot.setPosition(newPivotPosition / len(self.userSelectionList))
+
+    def unload(self,  saveOnUnload=True):
+        pass
+
+    def save(self):
+        pass
+
+    def startDropGameObjectAction(self, classid, ray):
+        go = self.gocManager.getGameObjectWithClassId(classid)
+        meshFile = go.getMeshFileName()
+
+        if go is not None:
+            dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+            dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
+            dropNode.attachObject(dropEntity)
+
+            result = og.Math.intersects(ray, self.dropCollisionPlane)
+            if result.first == True:
+                dropNode.setPosition(ray.getPoint(result.second))
+            else:
+                dropNode.setPosition(ray.getPoint(50))
+
+            self.dropGO = GameObjectRepresentation(self.dropCount, classid, dropNode, meshFile)
+            dropEntity.setUserObject(self.dropGO)
+
+        self.dropCount += 1
+
+    def moveDropGameObjectAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropGO.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropGO.setPosition(ray.getPoint(50))
+
+    def stopDropGameObjectAction(self, ray):
+        print "sd"
+
+    def startDropModelAction(self, meshFile, ray):
+        self.dropEntity = self.sceneManager.createEntity("dropMesh" + str(self.dropCount), str(meshFile))
+        self.dropNode = self.sceneManager.getRootSceneNode().createChild("dropNode" + str(self.dropCount))
+        self.dropNode.attachObject(self.dropEntity)
+
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+        self.dropCount += 1
+
+    def moveDropModelAction(self, ray):
+        result = og.Math.intersects(ray, self.dropCollisionPlane)
+        if result.first == True:
+            self.dropNode.setPosition(ray.getPoint(result.second))
+        else:
+            self.dropNode.setPosition(ray.getPoint(50))
+
+
+    def stopDropModelAction(self, ray):
+        pass
+

Modified: rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/src/MyRaySceneQueryListener.py	2008-11-30 22:46:52 UTC (rev 4616)
@@ -26,6 +26,12 @@
         self.entity = entity #the selected entity
         self.distance = distance # the distance from camera at the time of selection
         self.isPivot = False
+
+#        if self.entity.getUserObject() is not None:
+#            self.isGameObject = True
+#        else:
+#            self.isGameObject = False
+
     #if True this instance will show its bounding box else it will hide it
     def setSelected(self,  selected):
         if selected == True:

Copied: rl/branches/newton20/editors/Lockenwickler/src/NewModuleWizard.py (from rev 4613, rl/trunk/editors/Lockenwickler/src/NewModuleWizard.py)

Modified: rl/branches/newton20/editors/Lockenwickler/src/PreferencesDialog.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/PreferencesDialog.py	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/src/PreferencesDialog.py	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,106 +1,89 @@
-#################################################
- # Copyright (C) 2008  Stefan Stammberger
- #
- # This library is free software; you can redistribute it and/or
- # modify it under the terms of the GNU Lesser General Public
- # License as published by the Free Software Foundation; either
- # version 2.1 of the License, or (at your option) any later version.
- #
- # This library is distributed in the hope that it will be useful,
- # but WITHOUT ANY WARRANTY; without even the implied warranty of
- # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- # Lesser General Public License for more details.
- #
- # You should have received a copy of the GNU Lesser General Public
- # License along with this library; if not, write to the Free Software
- # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- #################################################
-
-
-import sys
-import platform
-import string
-from ui_pref_dialog import *
-
-class PreferencesDialog(QtGui.QDialog):
-    def __init__(self, loadModuleCallback, parent=None):
-        QtGui.QDialog.__init__(self, parent)
-
-        self.loadModuleCallback = loadModuleCallback
-
-        self.prefDialog = Ui_PreferencesDialog()
-        self.prefDialog.setupUi(self)
-
-        QtCore.QObject.connect(self.prefDialog.modulConfigSelector, QtCore.SIGNAL("clicked()"),
-                               self.openModulConfigSelector)
-
-        QtCore.QObject.connect(self.prefDialog.loadModuleBtn, QtCore.SIGNAL("clicked()"),
-                               self.onLoadSelectedModule)
-
-        QtCore.QObject.connect(self.prefDialog.listWidget, QtCore.SIGNAL("itemDoubleClicked(QListWidgetItem *)"),
-                               self.onLoadSelectedModule)
-
-        if platform.system() == "Windows" or platform.system() == "MAC":
-            pass
-            # TODO: delete this when ready
-            self.prefDialog.lineEdit.setText("C:/a11/modules/modules.cfg")
-            self.moduleCfgPath = 'C:/a11/modules/modules.cfg'
-            self.moduleCfgIsSelected = True
-            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
-            self.readInModules()
-            # end delete
-        else:
-            # TODO: delete this when ready
-            self.prefDialog.lineEdit.setText("/home/stefan/blubb/rl_modules/modules/modules.cfg")
-            self.moduleCfgPath = "/home/stefan/blubb/rl_modules/modules/modules.cfg"
-            self.moduleCfgIsSelected = True
-            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
-            self.readInModules()
-            # end delete
-
-        self.moduleCfgIsSelected = False
-
-        self.setModal(True)
-
-    def openModulConfigSelector(self):
-        dialog = QtGui.QFileDialog(self)
-        self.moduleCfgPath = str(dialog.getOpenFileName(self, "Select modules.cfg", "/home/stefan/blubb/rl_modules/modules/", "modules.cfg (*.cfg)"))
-        self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
-
-        from os.path import isfile
-
-        if isfile(self.moduleCfgPath):
-            self.prefDialog.lineEdit.setText(self.moduleCfgPath)
-            self.moduleCfgIsSelected = True
-            self.readInModules()
-
-    def readInModules(self):
-        if self.moduleCfgIsSelected:
-            import codecs
-            f = codecs.open(self.moduleCfgPath, 'r', 'utf-8')
-
-            for line in f:
-                if line.startswith('#'):
-                    continue
-
-                if line.startswith('module='):
-                    splines = line.split('=')
-                    str = splines[1].rstrip().rstrip()
-                    if str != "common":
-                        self.prefDialog.listWidget.addItem(str)
-
-    def onLoadSelectedModule(self):
-        item = self.prefDialog.listWidget.currentItem()
-
-        if item == None:
-            mbox = QtGui.QMessageBox(self)
-            mbox.setModal(True)
-            mbox.setText("Please select a module.")
-            mbox.show()
-        else:
-            tempo = str(item.text())
-            self.loadModuleCallback(self.modulePath, tempo)
-            self.hide()
-
-
-
+#################################################
+ # Copyright (C) 2008  Stefan Stammberger
+ #
+ # This library is free software; you can redistribute it and/or
+ # modify it under the terms of the GNU Lesser General Public
+ # License as published by the Free Software Foundation; either
+ # version 2.1 of the License, or (at your option) any later version.
+ #
+ # This library is distributed in the hope that it will be useful,
+ # but WITHOUT ANY WARRANTY; without even the implied warranty of
+ # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ # Lesser General Public License for more details.
+ #
+ # You should have received a copy of the GNU Lesser General Public
+ # License along with this library; if not, write to the Free Software
+ # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ #################################################
+
+
+import sys
+import platform
+import string
+
+from PyQt4.QtCore import *
+from PyQt4.QtGui import *
+
+class PreferencesDialog(QDialog):
+    def __init__(self, parent=None):
+        QDialog.__init__(self, parent)
+
+        self.label = QLabel()
+        self.label.setText("Please select the modules.cfg file.")
+        self.modulConfigSelector = QPushButton()
+        self.modulConfigSelector.setText("...")
+        self.lineEdit = QLineEdit()
+
+        layout = QGridLayout()
+        layout.addWidget(self.label, 0, 0, 1, 2)
+        layout.addWidget(self.lineEdit, 1, 0)
+        layout.addWidget(self.modulConfigSelector, 1, 1)
+
+        self.setLayout(layout)
+
+        QObject.connect(self.modulConfigSelector, SIGNAL("clicked()"),
+                               self.openModulConfigSelector)
+
+        self.setModal(True)
+
+    def setCfgPath(self, inPath):
+        path = str(inPath)
+
+        from os.path import isfile
+
+        if isfile(path):
+            self.moduleCfgPath = path
+            self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
+            self.lineEdit.setText(self.moduleCfgPath)
+            return True
+        else:
+            return False
+
+    def openModulConfigSelector(self):
+        dialog = QFileDialog(self)
+        self.moduleCfgPath = str(dialog.getOpenFileName(self, "Select modules.cfg", "/home/stefan/blubb/rl_modules/modules/", "modules.cfg (*.cfg)"))
+        self.modulePath = self.moduleCfgPath.replace("modules.cfg", "")
+
+        from os.path import isfile
+
+        if isfile(self.moduleCfgPath):
+            self.lineEdit.setText(self.moduleCfgPath)
+
+
+
+    def onLoadSelectedModule(self):
+        item = self.prefDialog.listWidget.currentItem()
+
+        if item == None:
+            mbox = QMessageBox(self)
+            mbox.setModal(True)
+            mbox.setText("Please select a module.")
+            mbox.show()
+        else:
+            tempo = str(item.text())
+            self.loadModuleCallback(self.modulePath, tempo)
+            self.hide()
+
+    def getModuleConfigPath(self):
+        return self.lineEdit
+

Copied: rl/branches/newton20/editors/Lockenwickler/src/Ui_GOPropertyEditorDialogINT.py (from rev 4613, rl/trunk/editors/Lockenwickler/src/Ui_GOPropertyEditorDialogINT.py)

Copied: rl/branches/newton20/editors/Lockenwickler/src/Ui_NewModuleWizard.py (from rev 4613, rl/trunk/editors/Lockenwickler/src/Ui_NewModuleWizard.py)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/icons/cursor.png (from rev 4613, rl/trunk/editors/Lockenwickler/src/media/icons/cursor.png)

Copied: rl/branches/newton20/editors/Lockenwickler/src/media/lightbulb.blend (from rev 4613, rl/trunk/editors/Lockenwickler/src/media/lightbulb.blend)

Deleted: rl/branches/newton20/editors/Lockenwickler/src/ui_pref_dialog.py
===================================================================
--- rl/branches/newton20/editors/Lockenwickler/src/ui_pref_dialog.py	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/editors/Lockenwickler/src/ui_pref_dialog.py	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,85 +0,0 @@
-# -*- coding: utf-8 -*-
-
-# Form implementation generated from reading ui file 'preferences_dialog.ui'
-#
-# Created: Mon Jun 23 19:28:46 2008
-#      by: PyQt4 UI code generator 4.3.3
-#
-# WARNING! All changes made in this file will be lost!
-
-from PyQt4 import QtCore, QtGui
-
-class Ui_PreferencesDialog(object):
-    def setupUi(self, PreferencesDialog):
-        PreferencesDialog.setObjectName("PreferencesDialog")
-        PreferencesDialog.resize(QtCore.QSize(QtCore.QRect(0,0,528,626).size()).expandedTo(PreferencesDialog.minimumSizeHint()))
-
-        self.gridlayout = QtGui.QGridLayout(PreferencesDialog)
-        self.gridlayout.setObjectName("gridlayout")
-
-        self.toolBox = QtGui.QToolBox(PreferencesDialog)
-        self.toolBox.setObjectName("toolBox")
-
-        self.ResourcePaths = QtGui.QWidget()
-        self.ResourcePaths.setGeometry(QtCore.QRect(0,0,510,505))
-        self.ResourcePaths.setObjectName("ResourcePaths")
-
-        self.gridlayout1 = QtGui.QGridLayout(self.ResourcePaths)
-        self.gridlayout1.setObjectName("gridlayout1")
-
-        self.listWidget = QtGui.QListWidget(self.ResourcePaths)
-        self.listWidget.setObjectName("listWidget")
-        self.gridlayout1.addWidget(self.listWidget,0,0,1,1)
-
-        self.groupBox = QtGui.QGroupBox(self.ResourcePaths)
-        self.groupBox.setMinimumSize(QtCore.QSize(0,95))
-        self.groupBox.setObjectName("groupBox")
-
-        self.layoutWidget = QtGui.QWidget(self.groupBox)
-        self.layoutWidget.setGeometry(QtCore.QRect(10,20,471,67))
-        self.layoutWidget.setObjectName("layoutWidget")
-
-        self.gridlayout2 = QtGui.QGridLayout(self.layoutWidget)
-        self.gridlayout2.setObjectName("gridlayout2")
-
-        self.lineEdit = QtGui.QLineEdit(self.layoutWidget)
-        self.lineEdit.setObjectName("lineEdit")
-        self.gridlayout2.addWidget(self.lineEdit,0,0,1,1)
-
-        self.loadModuleBtn = QtGui.QPushButton(self.layoutWidget)
-        self.loadModuleBtn.setObjectName("loadModuleBtn")
-        self.gridlayout2.addWidget(self.loadModuleBtn,1,0,1,2)
-
-        self.modulConfigSelector = QtGui.QPushButton(self.layoutWidget)
-        self.modulConfigSelector.setObjectName("modulConfigSelector")
-        self.gridlayout2.addWidget(self.modulConfigSelector,0,1,1,1)
-        self.gridlayout1.addWidget(self.groupBox,1,0,1,1)
-        self.toolBox.addItem(self.ResourcePaths,"")
-
-        self.OgreSettings = QtGui.QWidget()
-        self.OgreSettings.setGeometry(QtCore.QRect(0,0,96,26))
-        self.OgreSettings.setObjectName("OgreSettings")
-        self.toolBox.addItem(self.OgreSettings,"")
-        self.gridlayout.addWidget(self.toolBox,0,0,1,1)
-
-        self.buttonBox = QtGui.QDialogButtonBox(PreferencesDialog)
-        self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
-        self.buttonBox.setStandardButtons(QtGui.QDialogButtonBox.Cancel|QtGui.QDialogButtonBox.NoButton|QtGui.QDialogButtonBox.Ok)
-        self.buttonBox.setObjectName("buttonBox")
-        self.gridlayout.addWidget(self.buttonBox,1,0,1,1)
-
-        self.retranslateUi(PreferencesDialog)
-        self.toolBox.setCurrentIndex(0)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("accepted()"),PreferencesDialog.accept)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("rejected()"),PreferencesDialog.reject)
-        QtCore.QObject.connect(self.buttonBox,QtCore.SIGNAL("clicked(QAbstractButton*)"),PreferencesDialog.close)
-        QtCore.QMetaObject.connectSlotsByName(PreferencesDialog)
-
-    def retranslateUi(self, PreferencesDialog):
-        PreferencesDialog.setWindowTitle(QtGui.QApplication.translate("PreferencesDialog", "Dialog", None, QtGui.QApplication.UnicodeUTF8))
-        self.groupBox.setTitle(QtGui.QApplication.translate("PreferencesDialog", "GroupBox", None, QtGui.QApplication.UnicodeUTF8))
-        self.loadModuleBtn.setText(QtGui.QApplication.translate("PreferencesDialog", "Load Selected Module", None, QtGui.QApplication.UnicodeUTF8))
-        self.modulConfigSelector.setText(QtGui.QApplication.translate("PreferencesDialog", "...", None, QtGui.QApplication.UnicodeUTF8))
-        self.toolBox.setItemText(self.toolBox.indexOf(self.ResourcePaths), QtGui.QApplication.translate("PreferencesDialog", "Resource Paths", None, QtGui.QApplication.UnicodeUTF8))
-        self.toolBox.setItemText(self.toolBox.indexOf(self.OgreSettings), QtGui.QApplication.translate("PreferencesDialog", "Ogre Settings", None, QtGui.QApplication.UnicodeUTF8))
-

Modified: rl/branches/newton20/engine/ai/include/AgentCombatState.h
===================================================================
--- rl/branches/newton20/engine/ai/include/AgentCombatState.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ai/include/AgentCombatState.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -18,6 +18,7 @@
 
 #include "AiPrerequisites.h"
 #include "AgentState.h"
+#include "Combat.h"
 #include "Combatant.h"
 
 namespace rl
@@ -46,6 +47,10 @@
     protected:
         typedef enum {} CombatState;
         CombatState mState;
+
+    private:
+        Combatant* findOpponent(const Combat::CombatantSet& opponents) const;
+        Ogre::Vector3 getFleeTarget(const Combat::CombatantSet& opponents) const;
 	};
 }
 #endif

Modified: rl/branches/newton20/engine/ai/src/AgentCombatState.cpp
===================================================================
--- rl/branches/newton20/engine/ai/src/AgentCombatState.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ai/src/AgentCombatState.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -19,6 +19,7 @@
 #include "AgentCombatState.h"
 #include "Combat.h"
 #include "CombatManager.h"
+#include "Creature.h"
 #include "CreatureControllerManager.h"
 
 namespace rl
@@ -45,13 +46,19 @@
     void AgentCombatState::requestCombatantAction()
     {
         // Think!
-		const Combat::CombatantSet& allies = mCombat->getAllAllies();
-		if (!allies.empty())
+        Combat::CombatantSet opponents = mCombat->getAllOpponents(this);
+		if (!opponents.empty())
 		{
-			Combatant* target = *allies.begin();
-			// Are we in weapon range to opponent
-			if (target)
-			{
+			Combatant* target = findOpponent(opponents);
+            
+            mCombat->registerParade(target);
+
+            if (getCreature()->getLe() <= 5)
+            {
+                mCombat->registerBewegen(this, getFleeTarget(opponents));
+            }
+            else if (target)
+            {
 				// Are we in weapon range to opponent
 				if (mCombat->canAttack(this, target))
 				{
@@ -72,4 +79,47 @@
     {
         mAgent->updateVehicle(0, elapsedTime);
     }
+
+    class DistanceComparator
+		: std::binary_function<Combatant*, Combatant*, bool>
+    {
+    private:
+        const Combatant* mActingCombatant;
+
+    public:
+        DistanceComparator(const Combatant* actingCombatant)
+            : mActingCombatant(actingCombatant)
+        {
+        }
+
+        bool operator()(const Combatant* c1, const Combatant* c2) const
+        {
+            Vector3 pos = mActingCombatant->getPosition();
+            return pos.squaredDistance(c1->getPosition())
+                < pos.squaredDistance(c2->getPosition());
+        }
+    };
+
+
+    Combatant* AgentCombatState::findOpponent(const Combat::CombatantSet& opponents) const
+    {
+        ///@todo support different search patterns (search for most dangerous, weakest, ... opponent)
+        Combat::CombatantSet::const_iterator minIt = 
+            std::min_element(opponents.begin(), opponents.end(), DistanceComparator(this));
+        return *minIt;
+    }
+
+    Vector3 AgentCombatState::getFleeTarget(const Combat::CombatantSet& opponents) const
+    {
+        Vector3 oppPosition;
+        for (Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); ++it)
+        {
+            oppPosition += (*it)->getPosition();
+        }
+        oppPosition /= opponents.size();
+
+        Vector3 pos = getPosition();
+        Vector3 oppositeDirection = (pos - oppPosition).normalisedCopy();
+        return pos + 10 * oppositeDirection;
+    }
 }

Modified: rl/branches/newton20/engine/core/include/ListenerMovable.h
===================================================================
--- rl/branches/newton20/engine/core/include/ListenerMovable.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/include/ListenerMovable.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,94 +1,98 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __ListenerMovable_H__
-#define __ListenerMovable_H__
-
-#include "CorePrerequisites.h"
-
-
-namespace rl {
-    
-   /** Diese Klasse dient der Interaktion mit Ogre3d und
-    * kapselt den H?rer.
-    * @author Josch
-    * @date 06-29-2005
-    * @version 1.0
-    * @version 2.0
-    */
-    class _RlCoreExport ListenerMovable : public Ogre::MovableObject
-    {
-    public:
-        /// Konstruktor
-        ListenerMovable(const Ogre::String& name);
-        /// Destruktor
-        virtual ~ListenerMovable() = 0;
-        /// Name zur?ckgeben
-        virtual const Ogre::String& getName() const;
-        /// Moveable-Typ
-        virtual const Ogre::String& getMovableType() const;
-        /// Kamera informieren
-        virtual void _notifyCurrentCamera(Ogre::Camera *cam);
-        /// Unsere Bounding-Box
-        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
-        /// Bound-Radius
-        virtual Ogre::Real getBoundingRadius() const;
-        /// Rendern
-        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
-    
-        /// Gibt die Hauptlautstaerke zurueck
-        virtual const int getGain() const;
-        /// Setzt die Hauptlautstaerke.
-        virtual void setGain(const int direction);
-        /// Gibt die eingestellte Position der Soundquelle zurueck
-        virtual const Ogre::Vector3 getPosition() const;
-        /// Setzt die Position der Soundquelle.
-        virtual void setPosition(const Ogre::Vector3& direction);
-        /// Gibt die Richtung der Soundquelle zurueck.
-        virtual const Ogre::Quaternion getOrientation() const;
-        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
-        virtual const Ogre::Vector3 getVelocity() const;
-        /// Setzt die Richtung der Soundquelle.
-        virtual void setOrientation(const Ogre::Quaternion &orientation);
-        /// Setzt die Geschwindigkeit der Soundquelle.
-        virtual void setVelocity(const Ogre::Vector3&);
-        
-        /// Ist dies der aktuelle Listener
-        bool isActive() const;
-		void setActive(bool active);
-        
-    protected:
-         /// Shared class-level name for Movable type
-        static Ogre::String msMovableType;
-        /// Alignment-Box: gebraucht von MovableObject.
-        static Ogre::AxisAlignedBox msAABox;
-        /// Position
-        Ogre::Vector3 mPosition;
-        /// Geschwindigkeit
-        Ogre::Vector3 mVelocity;
-        /// Orientierung
-        Ogre::Quaternion mOrientation;
-        /// Hauptlautst?rke
-        int mGain;
-
-    private:
-        /// Der Name des ListenerMovable
-        Ogre::String mName;
-		bool mActive;
-    };
-
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __ListenerMovable_H__
+#define __ListenerMovable_H__
+
+#include "CorePrerequisites.h"
+
+
+namespace rl {
+    
+   /** Diese Klasse dient der Interaktion mit Ogre3d und
+    * kapselt den H?rer.
+    * @author Josch
+    * @date 06-29-2005
+    * @version 1.0
+    * @version 2.0
+    */
+    class _RlCoreExport ListenerMovable : public Ogre::MovableObject
+    {
+    public:
+        /// Konstruktor
+        ListenerMovable(const Ogre::String& name);
+        /// Destruktor
+        virtual ~ListenerMovable() = 0;
+        /// Name zur?ckgeben
+        virtual const Ogre::String& getName() const;
+        /// Moveable-Typ
+        virtual const Ogre::String& getMovableType() const;
+        /// Kamera informieren
+        virtual void _notifyCurrentCamera(Ogre::Camera *cam);
+        /// Unsere Bounding-Box
+        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
+        /// Bound-Radius
+        virtual Ogre::Real getBoundingRadius() const;
+        /// Rendern
+        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+    
+        /// Gibt die Hauptlautstaerke zurueck
+        virtual const int getGain() const;
+        /// Setzt die Hauptlautstaerke.
+        virtual void setGain(const int direction);
+        /// Gibt die eingestellte Position der Soundquelle zurueck
+        virtual const Ogre::Vector3 getPosition() const;
+        /// Setzt die Position der Soundquelle.
+        virtual void setPosition(const Ogre::Vector3& direction);
+        /// Gibt die Richtung der Soundquelle zurueck.
+        virtual const Ogre::Quaternion getOrientation() const;
+        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
+        virtual const Ogre::Vector3 getVelocity() const;
+        /// Setzt die Richtung der Soundquelle.
+        virtual void setOrientation(const Ogre::Quaternion &orientation);
+        /// Setzt die Geschwindigkeit der Soundquelle.
+        virtual void setVelocity(const Ogre::Vector3&);
+        
+        /// Ist dies der aktuelle Listener
+        bool isActive() const;
+		void setActive(bool active);
+
+		/// From MovableObject
+		virtual void visitRenderables(Ogre::Renderable::Visitor* visitor, 
+			bool debugRenderables = false);
+        
+    protected:
+         /// Shared class-level name for Movable type
+        static Ogre::String msMovableType;
+        /// Alignment-Box: gebraucht von MovableObject.
+        static Ogre::AxisAlignedBox msAABox;
+        /// Position
+        Ogre::Vector3 mPosition;
+        /// Geschwindigkeit
+        Ogre::Vector3 mVelocity;
+        /// Orientierung
+        Ogre::Quaternion mOrientation;
+        /// Hauptlautst?rke
+        int mGain;
+
+    private:
+        /// Der Name des ListenerMovable
+        Ogre::String mName;
+		bool mActive;
+    };
+
+}
+#endif

Modified: rl/branches/newton20/engine/core/include/MovableText.h
===================================================================
--- rl/branches/newton20/engine/core/include/MovableText.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/include/MovableText.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -63,6 +63,7 @@
         const Ogre::String& getMovableType(void) const { return msType; }
         Ogre::Real getBoundingRadius(void) const {return mRadius;}
         Ogre::Real getSquaredViewDepth(const Ogre::Camera* cam) const { return 0; }
+		void visitRenderables(Ogre::Renderable::Visitor* visitor,  bool debugRenderables = false);
  
         // from renderable
         void getRenderOperation(Ogre::RenderOperation &op);

Modified: rl/branches/newton20/engine/core/include/Sound.h
===================================================================
--- rl/branches/newton20/engine/core/include/Sound.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/include/Sound.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,163 +1,167 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __Sound_H__
-#define __Sound_H__
-
-#include "CorePrerequisites.h"
-#include <set>
-
-#include "Exception.h"
-#include "EventCaster.h"
-#include "SoundEvents.h"
-#include "SoundResource.h"
-
-namespace rl {
-
-    class SoundDriver;
-
-   /** Diese Klasse dient der Interaktion mit dem jeweiligen Soundsystem
-    * ein Objekt stellt eine einzelne Sounddatei oder einen Stream dar
-    * @author Josch
-    * @date 06-29-2005
-    * @version 1.0
-    * @version 2.0
-    */
-    class _RlCoreExport Sound : public Ogre::MovableObject, 
-        public EventCaster<SoundEvent>, public EventSource
-    {
-    public:
-        // Einige Standardwerte f??r Soundpriorit??ten.
-        enum SOUND_PRIORITY {
-            PRIO_SPEECH = 30,
-            PRIO_MUSIC = 75,
-            PRIO_SFX_ENVIRONMENT = 128,
-            PRIO_SFX_OTHER = 175,
-            PRIO_OTHER = 220
-        };
-
-        /// Konstruktor
-        Sound(const SoundResourcePtr& soundres, SoundDriver* creator);
-        /// Destruktor
-        virtual ~Sound();
-          
-        /// Laedt den Sound.
-        virtual void load() throw (RuntimeException) = 0;
-        /// Entlaedt den Sound.
-        virtual void unload() throw (RuntimeException) = 0;
-
-        // SoundResource zurueckgeben.
-        const SoundResourcePtr& getSoundResource() const;
-        // Wollen wir 3D?
-        bool is3d() const;
-        // Setzen des 3D-Flags.
-        void set3d(bool is3d);
-        // Sind wir gueltig
-        virtual bool isValid() const throw (RuntimeException) = 0;
-        
-        // Sollen der Sound wiederholt werden?
-        bool isLooping() const;
-        // Setzen des Loop-Flags.
-        void setLooping(bool looping);
-
-        virtual float getLength() const = 0;
-
-        /// Unsere Bounding-Box
-        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
-        /// Bound-Radius
-        virtual Ogre::Real getBoundingRadius() const;
-        /// Rendern
-        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
-
-
-        /// Gibt die eingestellte Position der Soundquelle zurueck
-        virtual const Ogre::Vector3 getPosition() const = 0;
-        /// Setzt die Position der Soundquelle.
-        virtual void setPosition(const Ogre::Vector3& direction) = 0;
-        /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
-	    virtual const Ogre::Real getVolume() const = 0; 
-        /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
-	    virtual void setVolume(const Ogre::Real gain) = 0;
-        /// Gibt die Richtung der Soundquelle zurueck.
-        virtual const Ogre::Quaternion getDirection() const = 0;
-        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
-        virtual const Ogre::Vector3 getVelocity() const = 0;
-        /// Setzt die Richtung der Soundquelle.
-        virtual void setDirection(const Ogre::Quaternion&) = 0;
-        /// Setzt die Geschwindigkeit der Soundquelle.
-        virtual void setVelocity(const Ogre::Vector3&) = 0;
-	    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
-	    virtual void setRolloffStartDistance(const Ogre::Real&);
-	    virtual const Ogre::Real getRolloffStartDistance() const;
-	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
-	    virtual void setRolloffEndDistance(const Ogre::Real&);
-	    virtual const Ogre::Real getRolloffEndDistance() const;
-        // Sets the priority of this sound
-        virtual void setPriority(const int priority) = 0;
-        // Gets the priority of this sound
-        virtual const int getPriority() const = 0;
-
-        /// Spielt den Sound ab.
-        virtual void play(bool destroyWhenDone=false) = 0;
-        /// Pausiert den Sound.
-        virtual void pause(bool pausing) = 0;
-        /// Ist der Sound pausiert?
-        virtual bool isPaused() = 0;
-        /// Stoppt den Sound.
-        virtual void stop() = 0;
-        /// Zurueck auf Anfang.
-    //        virtual void rewind() throw (RuntimeException) = 0;
-        /// Laeuft der Sound noch
-        virtual const bool isPlaying() const = 0;
-
-    protected:
-        SoundDriver* mCreator;
-
-        /// Die Lautstaerke
-	    Ogre::Real mVolume;
-        /// Die Position
-        Ogre::Vector3 mPosition;
-        /// Die Richtung
-        Ogre::Quaternion mDirection;
-        /// Die Geschwindigkeit
-        Ogre::Vector3 mVelocity;
-        /// The priority of this sound
-        int mPriority;
-
-	    Ogre::Real mRolloffStartDistance;
-	    Ogre::Real mRolloffEndDistance;
-
-    private:
-        /// Shared class-level name for Movable type
-        static Ogre::AxisAlignedBox msAABox;
-
-        /// Der Soundresource, auf den wir verweisen.
-        SoundResourcePtr mSoundResource;
-
-        // Damit die Timings alle 0.5 sek. abgeschickt werden.
-        int mTicks;
-        // Ob dieser Sound 3D sein soll.
-        bool mIs3d;
-        // Ob dieser Sound loopen soll.
-        bool mIsLooping;
-        
-    }; 
-
-
-    typedef std::set<Sound*> SoundSet;
-
-}
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __Sound_H__
+#define __Sound_H__
+
+#include "CorePrerequisites.h"
+#include <set>
+
+#include "Exception.h"
+#include "EventCaster.h"
+#include "SoundEvents.h"
+#include "SoundResource.h"
+
+namespace rl {
+
+    class SoundDriver;
+
+   /** Diese Klasse dient der Interaktion mit dem jeweiligen Soundsystem
+    * ein Objekt stellt eine einzelne Sounddatei oder einen Stream dar
+    * @author Josch
+    * @date 06-29-2005
+    * @version 1.0
+    * @version 2.0
+    */
+    class _RlCoreExport Sound : public Ogre::MovableObject, 
+        public EventCaster<SoundEvent>, public EventSource
+    {
+    public:
+        // Einige Standardwerte f??r Soundpriorit??ten.
+        enum SOUND_PRIORITY {
+            PRIO_SPEECH = 30,
+            PRIO_MUSIC = 75,
+            PRIO_SFX_ENVIRONMENT = 128,
+            PRIO_SFX_OTHER = 175,
+            PRIO_OTHER = 220
+        };
+
+        /// Konstruktor
+        Sound(const SoundResourcePtr& soundres, SoundDriver* creator);
+        /// Destruktor
+        virtual ~Sound();
+          
+        /// Laedt den Sound.
+        virtual void load() throw (RuntimeException) = 0;
+        /// Entlaedt den Sound.
+        virtual void unload() throw (RuntimeException) = 0;
+
+        // SoundResource zurueckgeben.
+        const SoundResourcePtr& getSoundResource() const;
+        // Wollen wir 3D?
+        bool is3d() const;
+        // Setzen des 3D-Flags.
+        void set3d(bool is3d);
+        // Sind wir gueltig
+        virtual bool isValid() const throw (RuntimeException) = 0;
+        
+        // Sollen der Sound wiederholt werden?
+        bool isLooping() const;
+        // Setzen des Loop-Flags.
+        void setLooping(bool looping);
+
+        virtual float getLength() const = 0;
+
+        /// Unsere Bounding-Box
+        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
+        /// Bound-Radius
+        virtual Ogre::Real getBoundingRadius() const;
+        /// Rendern
+        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+
+
+        /// Gibt die eingestellte Position der Soundquelle zurueck
+        virtual const Ogre::Vector3 getPosition() const = 0;
+        /// Setzt die Position der Soundquelle.
+        virtual void setPosition(const Ogre::Vector3& direction) = 0;
+        /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
+	    virtual const Ogre::Real getVolume() const = 0; 
+        /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
+	    virtual void setVolume(const Ogre::Real gain) = 0;
+        /// Gibt die Richtung der Soundquelle zurueck.
+        virtual const Ogre::Quaternion getDirection() const = 0;
+        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
+        virtual const Ogre::Vector3 getVelocity() const = 0;
+        /// Setzt die Richtung der Soundquelle.
+        virtual void setDirection(const Ogre::Quaternion&) = 0;
+        /// Setzt die Geschwindigkeit der Soundquelle.
+        virtual void setVelocity(const Ogre::Vector3&) = 0;
+	    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
+	    virtual void setRolloffStartDistance(const Ogre::Real&);
+	    virtual const Ogre::Real getRolloffStartDistance() const;
+	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
+	    virtual void setRolloffEndDistance(const Ogre::Real&);
+	    virtual const Ogre::Real getRolloffEndDistance() const;
+        // Sets the priority of this sound
+        virtual void setPriority(const int priority) = 0;
+        // Gets the priority of this sound
+        virtual const int getPriority() const = 0;
+
+        /// Spielt den Sound ab.
+        virtual void play(bool destroyWhenDone=false) = 0;
+        /// Pausiert den Sound.
+        virtual void pause(bool pausing) = 0;
+        /// Ist der Sound pausiert?
+        virtual bool isPaused() = 0;
+        /// Stoppt den Sound.
+        virtual void stop() = 0;
+        /// Zurueck auf Anfang.
+    //        virtual void rewind() throw (RuntimeException) = 0;
+        /// Laeuft der Sound noch
+        virtual const bool isPlaying() const = 0;
+
+	/// From MovableObject
+		virtual void visitRenderables(Ogre::Renderable::Visitor* visitor, 
+			bool debugRenderables = false);
+	
+	protected:
+        SoundDriver* mCreator;
+
+        /// Die Lautstaerke
+	    Ogre::Real mVolume;
+        /// Die Position
+        Ogre::Vector3 mPosition;
+        /// Die Richtung
+        Ogre::Quaternion mDirection;
+        /// Die Geschwindigkeit
+        Ogre::Vector3 mVelocity;
+        /// The priority of this sound
+        int mPriority;
+
+	    Ogre::Real mRolloffStartDistance;
+	    Ogre::Real mRolloffEndDistance;
+
+    private:
+        /// Shared class-level name for Movable type
+        static Ogre::AxisAlignedBox msAABox;
+
+        /// Der Soundresource, auf den wir verweisen.
+        SoundResourcePtr mSoundResource;
+
+        // Damit die Timings alle 0.5 sek. abgeschickt werden.
+        int mTicks;
+        // Ob dieser Sound 3D sein soll.
+        bool mIs3d;
+        // Ob dieser Sound loopen soll.
+        bool mIsLooping;
+        
+    }; 
+
+
+    typedef std::set<Sound*> SoundSet;
+
+}
+#endif

Modified: rl/branches/newton20/engine/core/include/SoundResource.h
===================================================================
--- rl/branches/newton20/engine/core/include/SoundResource.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/include/SoundResource.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -33,10 +33,6 @@
  */
 class _RlCoreExport SoundResource: public Ogre::Resource
 {
-    private:
-        /// Unsere Daten von Ogres ResourceManager.
-        Ogre::DataStreamPtr mDataStream;
-                       
     public:
         /// Der Standardkonstruktor
         SoundResource(Ogre::ResourceManager* creator, const Ogre::String& name, 
@@ -44,10 +40,8 @@
             Ogre::ManualResourceLoader* loader);
         /// Der Destruktor
         virtual ~SoundResource();
-        /// Den Datenstrom zur???ckgeben
+        /// Den Datenstrom zurueckgeben
         const Ogre::DataStreamPtr &getDataStream() const;
-        /// Groesse zurueckgeben.
-        int getSize() const;
 
     protected:
 		/// Laedt die Soundquelle.
@@ -57,6 +51,10 @@
 		/// Bestimmt die Groesse im Speicher (wird erst nach dem Laden aufgerufen)
 		virtual size_t calculateSize() const;        
         
+
+	private:
+        /// Unsere Daten von Ogres ResourceManager.
+        Ogre::DataStreamPtr mDataStream;
 };
 
 class _RlCoreExport SoundResourcePtr :

Modified: rl/branches/newton20/engine/core/include/SoundStitching.h
===================================================================
--- rl/branches/newton20/engine/core/include/SoundStitching.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/include/SoundStitching.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,178 +1,182 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-* 
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-
-#ifndef __SoundStitching_H__
-#define __SoundStitching_H__
-
-#include "CorePrerequisites.h"
-#include <set>
-
-#include "Exception.h"
-#include "EventCaster.h"
-#include "SoundEvents.h"
-#include "SoundResource.h"
-
-namespace rl {
-
-    class SoundDriver;
-
-    typedef std::map<CeGuiString, SoundResourcePtr> SoundCache;
-
-   /** Diese Klasse dient der Interaktion mit dem jeweiligen Soundsystem
-    * ein Objekt stellt eine einzelne Sounddatei oder einen Stream dar
-    * @author Josch
-    * @date 06-29-2005
-    * @version 1.0
-    * @version 2.0
-    */
-    class _RlCoreExport SoundStitching : public Ogre::MovableObject, 
-        public EventCaster<SoundEvent>, public EventSource
-    {
-    public:
-        // Einige Standardwerte f??r Soundpriorit??ten.
-        enum SOUND_PRIORITY {
-            PRIO_SPEECH = 30,
-            PRIO_MUSIC = 75,
-            PRIO_SFX_ENVIRONMENT = 128,
-            PRIO_SFX_OTHER = 175,
-            PRIO_OTHER = 220
-        };
-
-        /// Konstruktor
-        SoundStitching(unsigned int numSlots, const CeGuiString& name, SoundDriver* creator);
-        /// Destruktor
-        virtual ~SoundStitching();
-          
-        /// Laedt den Sound.
-        virtual void load() throw (RuntimeException) = 0;
-        /// Entlaedt den Sound.
-        virtual void unload() throw (RuntimeException) = 0;
-
-        virtual float getLength() const;
-
-        // SoundResource zurueckgeben.
-        const SoundResourcePtr& getSoundResource() const;
-        // Wollen wir 3D?
-        bool is3d() const;
-        // Setzen des 3D-Flags.
-        void set3d(bool is3d);
-        // Sind wir gueltig
-        virtual bool isValid() const throw (RuntimeException) = 0;
-        
-        // Sollen der Sound wiederholt werden?
-        bool isLooping() const;
-        // Setzen des Loop-Flags.
-        void setLooping(bool looping);
-
-        /// Unsere Bounding-Box
-        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
-        /// Bound-Radius
-        virtual Ogre::Real getBoundingRadius() const;
-        /// Rendern
-        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
-
-        /// Count of configured slots.
-        unsigned int getNumSlots();
-        /// Add a sound resource to the cache overwritting existing sound resource.
-        virtual void addSoundToCache(CeGuiString label, SoundResourcePtr sound);
-        /// Assign a sound recource to a slot.
-        virtual void putSoundIntoSlot(unsigned int, CeGuiString label) = 0;
-        /// Get the slot of the plaing sound.
-        virtual unsigned int getPlayingSlot() = 0;
-
-        /// Gibt die eingestellte Position der Soundquelle zurueck
-        virtual const Ogre::Vector3 getPosition() const = 0;
-        /// Setzt die Position der Soundquelle.
-        virtual void setPosition(const Ogre::Vector3& direction) = 0;
-        /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
-	    virtual const Ogre::Real getVolume() const = 0; 
-        /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
-	    virtual void setVolume(const Ogre::Real gain) = 0;
-        /// Gibt die Richtung der Soundquelle zurueck.
-        virtual const Ogre::Quaternion getDirection() const = 0;
-        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
-        virtual const Ogre::Vector3 getVelocity() const = 0;
-        /// Setzt die Richtung der Soundquelle.
-        virtual void setDirection(const Ogre::Quaternion&) = 0;
-        /// Setzt die Geschwindigkeit der Soundquelle.
-        virtual void setVelocity(const Ogre::Vector3&) = 0;
-	    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
-	    virtual void setRolloffStartDistance(const Ogre::Real&);
-	    virtual const Ogre::Real getRolloffStartDistance() const;
-	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
-	    virtual void setRolloffEndDistance(const Ogre::Real&);
-	    virtual const Ogre::Real getRolloffEndDistance() const;
-        // Sets the priority of this sound
-        virtual void setPriority(const int priority) = 0;
-        // Gets the priority of this sound
-        virtual const int getPriority() const = 0;
-
-        /// Spielt den Sound ab.
-        virtual void play(bool destroyWhenDone=false) = 0;
-        /// Pausiert den Sound.
-        virtual void pause(bool pausing) = 0;
-        /// Ist der Sound pausiert?
-        virtual bool isPaused() = 0;
-        /// Stoppt den Sound.
-        virtual void stop() = 0;
-        /// Laeuft der Sound noch
-        virtual const bool isPlaying() const = 0;
-
-    protected:
-        SoundDriver* mCreator;
-
-        /// Die Lautstaerke
-	    Ogre::Real mVolume;
-        /// Die Position
-        Ogre::Vector3 mPosition;
-        /// Die Richtung
-        Ogre::Quaternion mDirection;
-        /// Die Geschwindigkeit
-        Ogre::Vector3 mVelocity;
-        /// The priority of this sound
-        int mPriority;
-
-	    Ogre::Real mRolloffStartDistance;
-	    Ogre::Real mRolloffEndDistance;
-
-        // Sound-Cache
-        SoundCache mSoundCache;
-
-    private:
-        /// Shared class-level name for Movable type
-        static Ogre::AxisAlignedBox msAABox;
-
-        /// Der Soundresource, auf den wir verweisen.
-        SoundResourcePtr mSoundResource;
-
-        // Damit die Timings alle 0.5 sek. abgeschickt werden.
-        int mTicks;
-        // Ob dieser Sound 3D sein soll.
-        bool mIs3d;
-        // Ob dieser Sound loopen soll.
-        bool mIsLooping;
-
-        // Anzahl der Soundslots
-        unsigned int mNumSlots;
-
-        // Name
-        CeGuiString mName;
-        
-    }; 
-
-}
-#endif
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+* 
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+
+#ifndef __SoundStitching_H__
+#define __SoundStitching_H__
+
+#include "CorePrerequisites.h"
+#include <set>
+
+#include "Exception.h"
+#include "EventCaster.h"
+#include "SoundEvents.h"
+#include "SoundResource.h"
+
+namespace rl {
+
+    class SoundDriver;
+
+    typedef std::map<CeGuiString, SoundResourcePtr> SoundCache;
+
+   /** Diese Klasse dient der Interaktion mit dem jeweiligen Soundsystem
+    * ein Objekt stellt eine einzelne Sounddatei oder einen Stream dar
+    * @author Josch
+    * @date 06-29-2005
+    * @version 1.0
+    * @version 2.0
+    */
+    class _RlCoreExport SoundStitching : public Ogre::MovableObject, 
+        public EventCaster<SoundEvent>, public EventSource
+    {
+    public:
+        // Einige Standardwerte f??r Soundpriorit??ten.
+        enum SOUND_PRIORITY {
+            PRIO_SPEECH = 30,
+            PRIO_MUSIC = 75,
+            PRIO_SFX_ENVIRONMENT = 128,
+            PRIO_SFX_OTHER = 175,
+            PRIO_OTHER = 220
+        };
+
+        /// Konstruktor
+        SoundStitching(unsigned int numSlots, const CeGuiString& name, SoundDriver* creator);
+        /// Destruktor
+        virtual ~SoundStitching();
+          
+        /// Laedt den Sound.
+        virtual void load() throw (RuntimeException) = 0;
+        /// Entlaedt den Sound.
+        virtual void unload() throw (RuntimeException) = 0;
+
+        virtual float getLength() const;
+
+        // SoundResource zurueckgeben.
+        const SoundResourcePtr& getSoundResource() const;
+        // Wollen wir 3D?
+        bool is3d() const;
+        // Setzen des 3D-Flags.
+        void set3d(bool is3d);
+        // Sind wir gueltig
+        virtual bool isValid() const throw (RuntimeException) = 0;
+        
+        // Sollen der Sound wiederholt werden?
+        bool isLooping() const;
+        // Setzen des Loop-Flags.
+        void setLooping(bool looping);
+
+        /// Unsere Bounding-Box
+        virtual const Ogre::AxisAlignedBox& getBoundingBox(void) const;
+        /// Bound-Radius
+        virtual Ogre::Real getBoundingRadius() const;
+        /// Rendern
+        virtual void _updateRenderQueue(Ogre::RenderQueue *queue);
+
+        /// Count of configured slots.
+        unsigned int getNumSlots();
+        /// Add a sound resource to the cache overwritting existing sound resource.
+        virtual void addSoundToCache(CeGuiString label, SoundResourcePtr sound);
+        /// Assign a sound recource to a slot.
+        virtual void putSoundIntoSlot(unsigned int, CeGuiString label) = 0;
+        /// Get the slot of the plaing sound.
+        virtual unsigned int getPlayingSlot() = 0;
+
+        /// Gibt die eingestellte Position der Soundquelle zurueck
+        virtual const Ogre::Vector3 getPosition() const = 0;
+        /// Setzt die Position der Soundquelle.
+        virtual void setPosition(const Ogre::Vector3& direction) = 0;
+        /// Gibt die eingestellte relative Lautstaerke der Soundquelle zurueck (0.0 ... 1.0)
+	    virtual const Ogre::Real getVolume() const = 0; 
+        /// Setzt die relative Lautstaerke der Soundquelle (0.0 .. 1.0).
+	    virtual void setVolume(const Ogre::Real gain) = 0;
+        /// Gibt die Richtung der Soundquelle zurueck.
+        virtual const Ogre::Quaternion getDirection() const = 0;
+        /// Gibt die Geschwindigkeit der Soundquelle zurueck.
+        virtual const Ogre::Vector3 getVelocity() const = 0;
+        /// Setzt die Richtung der Soundquelle.
+        virtual void setDirection(const Ogre::Quaternion&) = 0;
+        /// Setzt die Geschwindigkeit der Soundquelle.
+        virtual void setVelocity(const Ogre::Vector3&) = 0;
+	    /// Setzt die Entfernung, ab der ein 3D-Sound leiser wird
+	    virtual void setRolloffStartDistance(const Ogre::Real&);
+	    virtual const Ogre::Real getRolloffStartDistance() const;
+	    /// Setzt die Entfernung, ab der ein 3D-Sound nicht mehr leiser wird
+	    virtual void setRolloffEndDistance(const Ogre::Real&);
+	    virtual const Ogre::Real getRolloffEndDistance() const;
+        // Sets the priority of this sound
+        virtual void setPriority(const int priority) = 0;
+        // Gets the priority of this sound
+        virtual const int getPriority() const = 0;
+
+        /// Spielt den Sound ab.
+        virtual void play(bool destroyWhenDone=false) = 0;
+        /// Pausiert den Sound.
+        virtual void pause(bool pausing) = 0;
+        /// Ist der Sound pausiert?
+        virtual bool isPaused() = 0;
+        /// Stoppt den Sound.
+        virtual void stop() = 0;
+        /// Laeuft der Sound noch
+        virtual const bool isPlaying() const = 0;
+
+		/// From MovableObject
+		virtual void visitRenderables(Ogre::Renderable::Visitor* visitor, 
+			bool debugRenderables = false);
+
+    protected:
+        SoundDriver* mCreator;
+
+        /// Die Lautstaerke
+	    Ogre::Real mVolume;
+        /// Die Position
+        Ogre::Vector3 mPosition;
+        /// Die Richtung
+        Ogre::Quaternion mDirection;
+        /// Die Geschwindigkeit
+        Ogre::Vector3 mVelocity;
+        /// The priority of this sound
+        int mPriority;
+
+	    Ogre::Real mRolloffStartDistance;
+	    Ogre::Real mRolloffEndDistance;
+
+        // Sound-Cache
+        SoundCache mSoundCache;
+
+    private:
+        /// Shared class-level name for Movable type
+        static Ogre::AxisAlignedBox msAABox;
+
+        /// Der Soundresource, auf den wir verweisen.
+        SoundResourcePtr mSoundResource;
+
+        // Damit die Timings alle 0.5 sek. abgeschickt werden.
+        int mTicks;
+        // Ob dieser Sound 3D sein soll.
+        bool mIs3d;
+        // Ob dieser Sound loopen soll.
+        bool mIsLooping;
+
+        // Anzahl der Soundslots
+        unsigned int mNumSlots;
+
+        // Name
+        CeGuiString mName;
+        
+    }; 
+
+}
+#endif
+

Modified: rl/branches/newton20/engine/core/src/Actor.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/Actor.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/Actor.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -466,17 +466,17 @@
             node->setScale( vec );
 
             // Falls es sich um ein Mesh handelt ...
-            if( getControlledObject()->isMeshObject() )
+/*            if( getControlledObject()->isMeshObject() )
             {
                 MeshObject* meshObj = dynamic_cast<MeshObject*>( getControlledObject() );
 
                 // ... und gr??er/kleiner als normal skaliert wird ...
                 if( vec != Vector3(1,1,1) )
                     // ... m?ssen die Normalen neu berechnet werden.
-                    meshObj->getEntity()->setNormaliseNormals( true );
+					meshObj->getEntity()->setNormaliseNormals( true );
                 else
                     meshObj->getEntity()->setNormaliseNormals( false );
-            }
+            }*/
         }
     }
 

Modified: rl/branches/newton20/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/ConfigurationManager.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/ConfigurationManager.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -111,6 +111,7 @@
         addSetting("Action keys", "showjournalwindow", "J");
         addSetting("Action keys", "showcharactersheet", "C");
         addSetting("Action keys", "togglecharacterstatewindow", "O");
+        addSetting("Action keys", "togglecharacterselectionwindow", "Y");
         addSetting("Action keys", "toggleingameglobalmenu", "F10");
         addSetting("Action keys", "shownextdebugwindowpage", "Ctrl+M");
         addSetting("Action keys", "showobjectactions", "U");
@@ -388,9 +389,14 @@
 	
 	void ConfigurationManager::setExecutable(const Ogre::String& path)
 	{
+#       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+		return;
+		fs::path exeAbsolute(path);
+#       else
 		fs::path exeAbsolute(path, fs::portable_posix_name);
-		mExecutablePath = exeAbsolute.remove_leaf().string();
-        std::cout << "ConfigurationManager" << "Executable is " << path << " " << mExecutablePath;
+#		endif
+		mExecutablePath = exeAbsolute.branch_path().string();
+        std::cout << "ConfigurationManager " << "Executable is " << path << " " << mExecutablePath;
 	}
 
 	const Ogre::String& ConfigurationManager::getExecutablePath() const
@@ -440,17 +446,14 @@
         try 
         {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-			std::cout << "Checking for " << fs::complete(filename) << std::endl;
-            if (fs::exists(filename))
+			std::cout << "Checking for " << fs::complete(filename).string() << std::endl;
+            return fs::exists(filename);
 #           else
 			std::cout << "Checking for " << 
 				fs::complete(fs::path(filename, fs::portable_posix_name)).string()
                  << std::endl;
-			if (fs::exists(fs::path(filename, fs::portable_posix_name)))
+			return fs::exists(fs::path(filename, fs::portable_posix_name));
 #           endif
-            {
-                return true;
-            }
         }
         catch (fs::filesystem_error&) 
         {

Modified: rl/branches/newton20/engine/core/src/DotSceneLoader.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/DotSceneLoader.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/DotSceneLoader.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -771,8 +771,10 @@
               return;
         }
 
-        if (parentNode->getScale() != Vector3::UNIT_SCALE)
+        /*if (parentNode->getScale() != Vector3::UNIT_SCALE) 
+		{
             newEnt->setNormaliseNormals(true);
+		}*/
 
         parentNode->attachObject(newEnt);
 

Modified: rl/branches/newton20/engine/core/src/JobScheduler.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/JobScheduler.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/JobScheduler.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,323 +1,350 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "JobScheduler.h"
-#include "Job.h"
-#include "JobListener.h"
-#include "GameLoop.h"
-#include "TimeSource.h"
-#include "SaveGameManager.h"
-
-using namespace Ogre;
-
-template<> rl::JobScheduler* Singleton<rl::JobScheduler>::ms_Singleton = 0;
-
-namespace rl
-{
-    JobScheduler::JobScheduler()
-        : GameTask(true),
-        mJobQueue(), 
-        mAddedJobs(),
-        mTokenThreshold(JP_NORMAL), 
-        mTicketCounter(0)
-    {
-        SaveGameManager::getSingleton().registerSaveGameData(this);
-    }
-
-    JobScheduler::~JobScheduler()
-    {
-    }
-
-    unsigned long JobScheduler::addJob(AbstractJob* job, JobPriority priority, Real delay, Real maxRuntime,
-        JobListener* listener)
-    {
-        unsigned long ticket = ++mTicketCounter;
-        TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(
-            job->getTimeSource());
-        unsigned long clock = ts->getClock();
-        unsigned long start = clock + delay*1000;
-        unsigned long end = maxRuntime >= Math::POS_INFINITY ?
-            0xffffffff : static_cast<unsigned long>(start + maxRuntime*1000);
-        JobEntry entry = {job, listener, ticket, priority, priority, start, end, start, job->getTimeSource(), false, false};
-        mAddedJobs.push_back(entry);
-        return ticket;
-    }
-
-    void JobScheduler::run(Ogre::Real time)
-    {
-        ///@todo use different buckets for jobs not yet started, instead of
-        ///      iterating over those each time.
-
-        ///@todo dynamically determine token threshold. Maybe make it work load depending.
-
-
-        // Queue for finished jobs
-        JobQueue notDone;
-
-        for (JobQueue::iterator it = mJobQueue.begin(), end = mJobQueue.end(); it != end; ++it)
-        {
-            JobEntry entry = *it;
-
-            TimeSource::TimeSourceType tst = entry.job->getTimeSource();
-            TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(tst);
-            Time clock = ts->getClock();
-            if (tst != entry.timeSourceLastCall) // time source has changed, e.g. in a job queue
-            {
-                entry.timeLastCall = clock;
-                entry.timeSourceLastCall = tst;
-            }
-
-            if (entry.markedToRemove)
-            {
-                // Notify listener, the job was removed
-                if (entry.listener != NULL)
-                {
-                    entry.listener->jobRemoved(entry.ticket);
-                }
-
-                if (entry.job->destroyWhenDone() )
-                {
-                    delete entry.job;
-                }
-            }
-            else if (entry.start <= clock && clock < entry.end)
-            {
-                // Is the token threshold reached?
-                if (entry.tokens >= mTokenThreshold)
-                {
-                    // Yes, pay run fee and execute.
-                    entry.tokens = 0;
-                    bool runAgain = !entry.job->execute(clock - entry.timeLastCall);
-
-                    if (!entry.called)
-                    {
-                        // Notify listener, the job started for the first time
-                        if (entry.listener != NULL)
-                        {
-                            entry.listener->jobStarted(entry.ticket);
-                        }
-                        entry.called = true;
-                    }
-
-                    if (runAgain)
-                    {
-                        // Job is not done, reset token count and requeue.
-                        entry.tokens = entry.priority;
-                        entry.timeLastCall = clock;
-                        notDone.push_back(entry);
-                    }
-                    else
-                    {
-                        // Notify listener, the job finished regularly.
-                        if (entry.listener != NULL)
-                        {
-                            entry.listener->jobFinished(entry.ticket);
-                        }
-
-                        // If we are supposed to delete the Job, do so now.
-                        if (entry.job->destroyWhenDone())
-                        {
-                            delete entry.job;
-                        }
-                    }
-                }
-                else
-                {
-                    // No, increase token count
-                    entry.tokens += entry.priority;
-                    notDone.push_back(entry);
-                }
-            }
-            else if (clock < entry.end)
-            {
-                // Start time not yet reached. Queue again.
-                notDone.push_back(entry);
-            }
-            else
-            {
-                // Job reached its end time and didn't want to finish itself, so we do it.
-                if (entry.job->isDiscardable())
-                {
-                    entry.job->discard();
-                    if (entry.listener != NULL)
-                    {
-                        entry.listener->jobDiscarded(entry.ticket);
-                    }
-                }
-                if (entry.job->destroyWhenDone() )
-                {
-                    delete entry.job;
-                }
-            }
-        }
-
-        // Copy requeued jobs for next run.
-        mJobQueue = notDone;
-		mJobQueue.insert(mJobQueue.end(), mAddedJobs.begin(), mAddedJobs.end());
-		mAddedJobs.clear();
-    }
-
-    void JobScheduler::removeJob(unsigned long ticket)
-    {
-        JobQueue::iterator it = std::find_if(mJobQueue.begin(), mJobQueue.end(),
-            std::bind2nd(FindJobEntryByTicket(), ticket));
-        if (it != mJobQueue.end())
-        {
-            //mRemovedJobs.push_back(*it);
-            (*it).markedToRemove = true;
-        }
-        else
-        {
-			it = std::find_if(mAddedJobs.begin(), mAddedJobs.end(),
-				std::bind2nd(FindJobEntryByTicket(), ticket));
-			if (it != mAddedJobs.end())
-			{
-				mAddedJobs.erase(it);
-			}
-			else
-			{
-				///@todo Log missing job for the ticket.
-			}
-        }
-    }
-
-    const Ogre::String& JobScheduler::getName() const
-    {
-        static Ogre::String NAME = "JobScheduler";
-
-        return NAME;
-    }
-
-    using namespace XERCES_CPP_NAMESPACE;
-
-    void JobScheduler::writeData(SaveGameFileWriter* writer)
-    {
-        DOMElement* jobSchedulerParentNode = writer->appendChildElement(writer->getDocument(), writer->getDocument()->getDocumentElement(), getXmlNodeIdentifier().c_str());
-
-        for(JobQueue::const_iterator iter = mJobQueue.begin(); iter != mJobQueue.end(); iter++)
-        {
-            if( iter->job->getPersistenceType() == Job::PERSISTENT && !(iter->markedToRemove) )
-            {
-                DOMElement* jobNode = writer->appendChildElement(writer->getDocument(), jobSchedulerParentNode, "job");
-                writer->setAttributeValueAsInteger(jobNode, "priority", iter->priority);
-                writer->setAttributeValueAsInteger(jobNode, "tokens", iter->tokens);
-                writer->setAttributeValueAsInteger(jobNode, "start", iter->start);
-                writer->setAttributeValueAsInteger(jobNode, "end", iter->end);
-                writer->setAttributeValueAsInt64(jobNode, "timeLastCall", iter->timeLastCall);
-                writer->setAttributeValueAsBool(jobNode, "called", iter->called);
-                writer->setAttributeValueAsString(jobNode, "classname", iter->job->getClassName());
-
-                PropertyMap map = iter->job->getAllProperties()->toPropertyMap();
-                writer->writeEachPropertyToElem(jobNode, map);
-            }
-        }
-    }
-
-    void JobScheduler::readData(SaveGameFileReader* reader)
-    {
-        // delete and discard old jobs
-        for( JobQueue::iterator iter = mJobQueue.begin(); iter != mJobQueue.end(); iter++ )
-        {
-            if( iter->job->getPersistenceType() == Job::PERSISTENT )
-            {
-                // delete the job, but do not discard it!
-                iter->markedToRemove = true;
-            }
-            else if( iter->job->getPersistenceType() == Job::FINISH_WHEN_GAME_LOADED )
-            {
-                // discard the job, then delete it
-                if( iter->job->isDiscardable() )
-                    iter->job->discard();
-                iter->markedToRemove = true;
-            }
-        }
-
-        
-        // load jobs from savegamefile
-
-        reader->initializeXml();
-
-
-        DOMNodeList* rootNodeList = reader->getDocument()->getDocumentElement()->getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
-        
-        if(rootNodeList->getLength())
-        {
-            DOMNodeList* xmlJobs = static_cast<DOMElement*>(rootNodeList->item(0))->getElementsByTagName(AutoXMLCh("job").data());
-            if (xmlJobs->getLength())
-            {
-                for (XMLSize_t childIdx1 = 0; childIdx1 < xmlJobs->getLength(); childIdx1++)
-                {
-                    DOMNode* xmlJob_ = xmlJobs->item(childIdx1);
-                    if (xmlJob_->getNodeType() == DOMNode::ELEMENT_NODE)
-                    {
-                        DOMElement* xmlJob = static_cast<DOMElement*>(xmlJob_);
-                        JobPriority priority;
-                        unsigned short tokens;
-                        int start, end;
-                        Time timeLastCall;
-                        bool called;
-                        priority = JobPriority(reader->getAttributeValueAsInteger(xmlJob, "priority"));
-                        tokens = reader->getAttributeValueAsInteger(xmlJob, "tokens");
-                        start = reader->getAttributeValueAsInteger(xmlJob, "start");
-                        end = reader->getAttributeValueAsInteger(xmlJob, "end");
-                        timeLastCall = reader->getAttributeValueAsInt64(xmlJob, "timeLastCall");
-                        called = reader->getAttributeValueAsBool(xmlJob, "called");
-
-                        Ogre::String className = reader->getAttributeValueAsStdString(xmlJob, "classname");
-
-                        JobCreationMap::iterator it = mJobCreationMap.find(className);
-                        if (it == mJobCreationMap.end())
-                        {
-                            LOG_ERROR(Logger::CORE, "Die Job-Klasse '" + className + "' ist nicht beim JobScheduler registriert!");
-                            continue;
-                        }
-
-                        AbstractJob* job = it->second();
-                        if (job == NULL)
-                        {
-                            LOG_ERROR(Logger::CORE, "Fehler beim Erstellen eines Objekts der Job-Klasse '" + className + "'!");
-                            continue;
-                        }
-                        PropertyRecordPtr properties = reader->getPropertiesAsRecord(xmlJob);
-                        job->setProperties(properties);
-                        
-                        
-                        unsigned long ticket = ++mTicketCounter;
-                        TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(job->getTimeSource());
-                        JobEntry entry = {job, NULL, ticket, priority, tokens, start, end, timeLastCall, TimeSource::UNKNOWN, called, false};
-                        mJobQueue.push_back(entry);
-                    }
-                }
-            }
-        }
-
-        reader->shutdownXml();
-    }
-
-    int JobScheduler::getPriority() const
-    {
-        return 0; // must be loaded before triggers!
-    }
-
-    CeGuiString JobScheduler::getXmlNodeIdentifier() const
-    {
-        static const CeGuiString name = "jobscheduler";
-        return name;
-    }
-
-    JobScheduler::JobCreationMap JobScheduler::mJobCreationMap;
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "JobScheduler.h"
+#include "Job.h"
+#include "JobListener.h"
+#include "GameLoop.h"
+#include "TimeSource.h"
+#include "SaveGameManager.h"
+
+using namespace Ogre;
+
+template<> rl::JobScheduler* Singleton<rl::JobScheduler>::ms_Singleton = 0;
+
+namespace rl
+{
+    JobScheduler::JobScheduler()
+        : GameTask(true),
+        mJobQueue(), 
+        mAddedJobs(),
+        mTokenThreshold(JP_NORMAL), 
+        mTicketCounter(0)
+    {
+        SaveGameManager::getSingleton().registerSaveGameData(this);
+    }
+
+    JobScheduler::~JobScheduler()
+    {
+    }
+
+    unsigned long JobScheduler::addJob(AbstractJob* job, JobPriority priority, Real delay, Real maxRuntime,
+        JobListener* listener)
+    {
+        unsigned long ticket = ++mTicketCounter;
+        TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(
+            job->getTimeSource());
+        unsigned long clock = ts->getClock();
+        unsigned long start = clock + delay*1000;
+        unsigned long end = maxRuntime >= Math::POS_INFINITY ?
+            0xffffffff : static_cast<unsigned long>(start + maxRuntime*1000);
+        JobEntry entry = {job, listener, ticket, priority, priority, start, end, start, job->getTimeSource(), false, false};
+        mAddedJobs.push_back(entry);
+        return ticket;
+    }
+
+    void JobScheduler::run(Ogre::Real time)
+    {
+        ///@todo use different buckets for jobs not yet started, instead of
+        ///      iterating over those each time.
+
+        ///@todo dynamically determine token threshold. Maybe make it work load depending.
+
+
+        // Queue for finished jobs
+        JobQueue notDone;
+
+        for (JobQueue::iterator it = mJobQueue.begin(), end = mJobQueue.end(); it != end; ++it)
+        {
+            JobEntry entry = *it;
+
+            TimeSource::TimeSourceType tst = entry.job->getTimeSource();
+            TimeSource* ts = TimeSourceManager::getSingleton().getTimeSource(tst);
+            Time clock = ts->getClock();
+            if (tst != entry.timeSourceLastCall) // time source has changed, e.g. in a job queue
+            {
+                entry.timeLastCall = clock;
+                entry.timeSourceLastCall = tst;
+            }
+
+            if (entry.markedToRemove)
+            {
+                // Notify listener, the job was removed
+                if (entry.listener != NULL)
+                {
+                    entry.listener->jobRemoved(entry.ticket);
+                }
+
+                if (entry.job->destroyWhenDone() )
+                {
+                    delete entry.job;
+                }
+            }
+            else if (entry.start <= clock && clock < entry.end)
+            {
+                // Is the token threshold reached?
+                if (entry.tokens >= mTokenThreshold)
+                {
+                    // Yes, pay run fee and execute.
+                    entry.tokens = 0;
+                    bool runAgain = !entry.job->execute(clock - entry.timeLastCall);
+
+                    if (!entry.called)
+                    {
+                        // Notify listener, the job started for the first time
+                        if (entry.listener != NULL)
+                        {
+                            entry.listener->jobStarted(entry.ticket);
+                        }
+                        entry.called = true;
+                    }
+
+                    if (runAgain)
+                    {
+                        // Job is not done, reset token count and requeue.
+                        entry.tokens = entry.priority;
+                        entry.timeLastCall = clock;
+                        notDone.push_back(entry);
+                    }
+                    else
+                    {
+                        // Notify listener, the job finished regularly.
+                        if (entry.listener != NULL)
+                        {
+                            entry.listener->jobFinished(entry.ticket);
+                        }
+
+                        // If we are supposed to delete the Job, do so now.
+                        if (entry.job->destroyWhenDone())
+                        {
+                            delete entry.job;
+                        }
+                    }
+                }
+                else
+                {
+                    // No, increase token count
+                    entry.tokens += entry.priority;
+                    notDone.push_back(entry);
+                }
+            }
+            else if (clock < entry.end)
+            {
+                // Start time not yet reached. Queue again.
+                notDone.push_back(entry);
+            }
+            else
+            {
+                // Job reached its end time and didn't want to finish itself, so we do it.
+                if (entry.job->isDiscardable())
+                {
+                    entry.job->discard();
+                    if (entry.listener != NULL)
+                    {
+                        entry.listener->jobDiscarded(entry.ticket);
+                    }
+                }
+                if (entry.job->destroyWhenDone() )
+                {
+                    delete entry.job;
+                }
+            }
+        }
+
+        // Copy requeued jobs for next run.
+        mJobQueue = notDone;
+		mJobQueue.insert(mJobQueue.end(), mAddedJobs.begin(), mAddedJobs.end());
+		mAddedJobs.clear();
+    }
+
+    void JobScheduler::removeJob(unsigned long ticket)
+    {
+        JobQueue::iterator it = std::find_if(mJobQueue.begin(), mJobQueue.end(),
+            std::bind2nd(FindJobEntryByTicket(), ticket));
+        if (it != mJobQueue.end())
+        {
+            //mRemovedJobs.push_back(*it);
+            (*it).markedToRemove = true;
+        }
+        else
+        {
+			it = std::find_if(mAddedJobs.begin(), mAddedJobs.end(),
+				std::bind2nd(FindJobEntryByTicket(), ticket));
+			if (it != mAddedJobs.end())
+			{
+				mAddedJobs.erase(it);
+			}
+			else
+			{
+				///@todo Log missing job for the ticket.
+			}
+        }
+    }
+
+    const Ogre::String& JobScheduler::getName() const
+    {
+        static Ogre::String NAME = "JobScheduler";
+
+        return NAME;
+    }
+
+    using namespace XERCES_CPP_NAMESPACE;
+
+    void JobScheduler::writeData(SaveGameFileWriter* writer)
+    {
+        DOMElement* jobSchedulerParentNode = writer->appendChildElement(writer->getDocument(), writer->getDocument()->getDocumentElement(), getXmlNodeIdentifier().c_str());
+
+        for(JobQueue::const_iterator iter = mJobQueue.begin(); iter != mJobQueue.end(); iter++)
+        {
+            if( iter->job->getPersistenceType() == Job::PERSISTENT && !(iter->markedToRemove) )
+            {
+                DOMElement* jobNode = writer->appendChildElement(writer->getDocument(), jobSchedulerParentNode, "job");
+                writer->setAttributeValueAsInteger(jobNode, "priority", iter->priority);
+                writer->setAttributeValueAsInteger(jobNode, "tokens", iter->tokens);
+                writer->setAttributeValueAsInteger(jobNode, "start", iter->start);
+                writer->setAttributeValueAsInteger(jobNode, "end", iter->end);
+                writer->setAttributeValueAsInt64(jobNode, "timeLastCall", iter->timeLastCall);
+                writer->setAttributeValueAsBool(jobNode, "called", iter->called);
+                writer->setAttributeValueAsString(jobNode, "classname", iter->job->getClassName());
+                CeGuiString timeSource = "unknown";
+                switch (iter->job->getTimeSource())
+                {
+                    case TimeSource::GAMETIME:
+                        timeSource = "gametime";
+                        break;
+                    case TimeSource::REALTIME_CONTINUOUS:
+                        timeSource = "realtime_continuous";
+                        break;
+                    case TimeSource::REALTIME_INTERRUPTABLE:
+                        timeSource = "realtime_interruptable";
+                        break;
+                }
+                writer->setAttributeValueAsString(jobNode, "time", timeSource);
+
+                PropertyMap map = iter->job->getAllProperties()->toPropertyMap();
+                writer->writeEachPropertyToElem(jobNode, map);
+            }
+        }
+    }
+
+    void JobScheduler::readData(SaveGameFileReader* reader)
+    {
+        // delete and discard old jobs
+        for( JobQueue::iterator iter = mJobQueue.begin(); iter != mJobQueue.end(); iter++ )
+        {
+            if( iter->job->getPersistenceType() == Job::PERSISTENT )
+            {
+                // delete the job, but do not discard it!
+                iter->markedToRemove = true;
+            }
+            else if( iter->job->getPersistenceType() == Job::FINISH_WHEN_GAME_LOADED )
+            {
+                // discard the job, then delete it
+                if( iter->job->isDiscardable() )
+                    iter->job->discard();
+                iter->markedToRemove = true;
+            }
+        }
+
+        
+        // load jobs from savegamefile
+
+        reader->initializeXml();
+
+
+        DOMNodeList* rootNodeList = reader->getDocument()->getDocumentElement()->getElementsByTagName(AutoXMLCh(getXmlNodeIdentifier().c_str()).data());
+        
+        if(rootNodeList->getLength())
+        {
+            DOMNodeList* xmlJobs = static_cast<DOMElement*>(rootNodeList->item(0))->getElementsByTagName(AutoXMLCh("job").data());
+            if (xmlJobs->getLength())
+            {
+                for (XMLSize_t childIdx1 = 0; childIdx1 < xmlJobs->getLength(); childIdx1++)
+                {
+                    DOMNode* xmlJob_ = xmlJobs->item(childIdx1);
+                    if (xmlJob_->getNodeType() == DOMNode::ELEMENT_NODE)
+                    {
+                        DOMElement* xmlJob = static_cast<DOMElement*>(xmlJob_);
+                        JobPriority priority;
+                        unsigned short tokens;
+                        int start, end;
+                        Time timeLastCall;
+                        bool called;
+                        priority = JobPriority(reader->getAttributeValueAsInteger(xmlJob, "priority"));
+                        tokens = reader->getAttributeValueAsInteger(xmlJob, "tokens");
+                        start = reader->getAttributeValueAsInteger(xmlJob, "start");
+                        end = reader->getAttributeValueAsInteger(xmlJob, "end");
+                        timeLastCall = reader->getAttributeValueAsInt64(xmlJob, "timeLastCall");
+                        called = reader->getAttributeValueAsBool(xmlJob, "called");
+
+                        Ogre::String className = reader->getAttributeValueAsStdString(xmlJob, "classname");
+
+                        JobCreationMap::iterator it = mJobCreationMap.find(className);
+                        if (it == mJobCreationMap.end())
+                        {
+                            LOG_ERROR(Logger::CORE, "Die Job-Klasse '" + className + "' ist nicht beim JobScheduler registriert!");
+                            continue;
+                        }
+
+                        AbstractJob* job = it->second();
+                        if (job == NULL)
+                        {
+                            LOG_ERROR(Logger::CORE, "Fehler beim Erstellen eines Objekts der Job-Klasse '" + className + "'!");
+                            continue;
+                        }
+                        PropertyRecordPtr properties = reader->getPropertiesAsRecord(xmlJob);
+                        job->setProperties(properties);
+                        
+                        CeGuiString timeSourceStr = reader->getAttributeValueAsString(xmlJob, "time");
+                        TimeSource::TimeSourceType ts = TimeSource::UNKNOWN;
+                        if (timeSourceStr == "gametime") 
+                        {
+                            ts = TimeSource::GAMETIME;
+                        }
+                        else if (timeSourceStr == "realtime_continuous") 
+                        {
+                            ts = TimeSource::REALTIME_CONTINUOUS;
+                        }
+                        else if (timeSourceStr == "realtime_interruptable") 
+                        {
+                            ts = TimeSource::REALTIME_INTERRUPTABLE;
+                        }
+                        
+                        unsigned long ticket = ++mTicketCounter;
+                        JobEntry entry = {job, NULL, ticket, priority, tokens, start, end, timeLastCall, ts, called, false};
+                        mJobQueue.push_back(entry);
+                    }
+                }
+            }
+        }
+
+        reader->shutdownXml();
+    }
+
+    int JobScheduler::getPriority() const
+    {
+        return 0; // must be loaded before triggers!
+    }
+
+    CeGuiString JobScheduler::getXmlNodeIdentifier() const
+    {
+        static const CeGuiString name = "jobscheduler";
+        return name;
+    }
+
+    JobScheduler::JobCreationMap JobScheduler::mJobCreationMap;
+}

Modified: rl/branches/newton20/engine/core/src/ListenerMovable.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/ListenerMovable.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/ListenerMovable.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -203,4 +203,9 @@
 	mActive = active;
 }
 
+void ListenerMovable::visitRenderables(Renderable::Visitor* visitor, 
+			bool debugRenderables)
+{
 }
+
+}

Modified: rl/branches/newton20/engine/core/src/MovableText.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/MovableText.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/MovableText.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -554,4 +554,11 @@
     {
         return mAlignment;
     }
+
+    /************************************************************************/
+	void MovableText::visitRenderables(Renderable::Visitor* visitor, 
+			bool debugRenderables)
+	{
+		visitor->visit(this, 0, debugRenderables);
+	}
 }

Modified: rl/branches/newton20/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/PhysicalThing.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/PhysicalThing.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -130,8 +130,8 @@
 		if (mBody && mActor)
 		{
 			mBody->setPositionOrientation(
-				mActor->_getSceneNode()->getWorldPosition(),
-				mActor->_getSceneNode()->getWorldOrientation());
+				mActor->_getSceneNode()->_getDerivedPosition(),
+				mActor->_getSceneNode()->_getDerivedOrientation());
 			mActor->_update(Actor::UF_ALL & ~Actor::UF_PHYSICAL_THING);
 		}
     }

Modified: rl/branches/newton20/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/PhysicsManager.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/PhysicsManager.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -333,8 +333,8 @@
 
 
             body->attachNode(node);
-            body->setPositionOrientation(node->getWorldPosition(),
-                node->getWorldOrientation());
+            body->setPositionOrientation(node->_getDerivedPosition(),
+                node->_getDerivedOrientation());
             body->setMaterialGroupID(getMaterialID("level"));
 
             mLevelBodiesQuadTree.add(body);

Modified: rl/branches/newton20/engine/core/src/Sound.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/Sound.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/Sound.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,148 +1,153 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "Sound.h"
-#include "SoundDriver.h"
-
-using namespace Ogre;
-
-namespace rl
-{
-
-AxisAlignedBox Sound::msAABox = Ogre::AxisAlignedBox(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
-
-Sound::Sound(const SoundResourcePtr &soundres, SoundDriver* creator)
-: MovableObject(soundres->getName()),
-   EventSource(),
-   EventCaster<SoundEvent>(),
-   mCreator(creator),
-   mVolume(1.0),
-   mSoundResource(soundres),
-   mIsLooping(false),
-   mIs3d(false),
-   mTicks(0),
-   mPosition(Vector3::ZERO),
-   mDirection(Quaternion::IDENTITY),
-   mVelocity(Vector3::ZERO),
-   mPriority(128),
-   mRolloffStartDistance(1.0),
-   mRolloffEndDistance(10000.0)
-{
-}
-
-Sound::~Sound()
-{
-}
-
-/**
- * @return Ob der Sound wiederholt werden soll
- * @author JoSch
- * @date 08-08-2005
- */
-bool Sound::isLooping() const
-{
-    return mIsLooping;
-}
-
-/**
- * @param looping Ob der Sound wiederholt werden soll
- * @author JoSch
- * @date 08-08-2005
- */
-void Sound::setLooping(bool looping)
-{
-    mIsLooping = looping;
-}
-
-/**
- * @return Ob der Sound ein 3D-Sound ist.
- * @author JoSch
- * @date 08-08-2005
- */
-bool Sound::is3d() const
-{
-    return mIs3d;
-}
-
-/**
- * @param is3d Ob der Sound ein 3D-Sound ist.
- * @author JoSch
- * @date 08-08-2005
- */
-void Sound::set3d(bool is3d)
-{
-    mIs3d = is3d;
-}
-
-/** SoundResource zur?ckgeben.
- * @return Der Pointer auf die zugeh?rige Soundresource.
- * @author JoSch
- * @date 08-08-2005
- */
-const SoundResourcePtr &Sound::getSoundResource() const
-{
-    return mSoundResource;
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-const AxisAlignedBox& Sound::getBoundingBox() const
-{
-    return msAABox;
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-Real Sound::getBoundingRadius (void) const
-{
-    return 0.0f; // SQRT(3*SQR(0.0)) to fit with AABB
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-void Sound::_updateRenderQueue(RenderQueue *queue)
-{
-    // Brauchen wir nicht
-}
-
-void Sound::setRolloffStartDistance(const Ogre::Real& distance)
-{
-	mRolloffStartDistance = distance;
-}
-
-const Ogre::Real Sound::getRolloffStartDistance() const
-{
-	return mRolloffStartDistance;
-}
-
-void Sound::setRolloffEndDistance(const Ogre::Real& distance)
-{
-	mRolloffEndDistance = distance;
-}
-
-const Ogre::Real Sound::getRolloffEndDistance() const
-{
-	return mRolloffEndDistance;
-}
-
-};
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "Sound.h"
+#include "SoundDriver.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+
+AxisAlignedBox Sound::msAABox = Ogre::AxisAlignedBox(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
+
+Sound::Sound(const SoundResourcePtr &soundres, SoundDriver* creator)
+: MovableObject(soundres->getName()),
+   EventSource(),
+   EventCaster<SoundEvent>(),
+   mCreator(creator),
+   mVolume(1.0),
+   mSoundResource(soundres),
+   mIsLooping(false),
+   mIs3d(false),
+   mTicks(0),
+   mPosition(Vector3::ZERO),
+   mDirection(Quaternion::IDENTITY),
+   mVelocity(Vector3::ZERO),
+   mPriority(128),
+   mRolloffStartDistance(1.0),
+   mRolloffEndDistance(10000.0)
+{
+}
+
+Sound::~Sound()
+{
+}
+
+/**
+ * @return Ob der Sound wiederholt werden soll
+ * @author JoSch
+ * @date 08-08-2005
+ */
+bool Sound::isLooping() const
+{
+    return mIsLooping;
+}
+
+/**
+ * @param looping Ob der Sound wiederholt werden soll
+ * @author JoSch
+ * @date 08-08-2005
+ */
+void Sound::setLooping(bool looping)
+{
+    mIsLooping = looping;
+}
+
+/**
+ * @return Ob der Sound ein 3D-Sound ist.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+bool Sound::is3d() const
+{
+    return mIs3d;
+}
+
+/**
+ * @param is3d Ob der Sound ein 3D-Sound ist.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+void Sound::set3d(bool is3d)
+{
+    mIs3d = is3d;
+}
+
+/** SoundResource zur?ckgeben.
+ * @return Der Pointer auf die zugeh?rige Soundresource.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+const SoundResourcePtr &Sound::getSoundResource() const
+{
+    return mSoundResource;
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+const AxisAlignedBox& Sound::getBoundingBox() const
+{
+    return msAABox;
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+Real Sound::getBoundingRadius (void) const
+{
+    return 0.0f; // SQRT(3*SQR(0.0)) to fit with AABB
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+void Sound::_updateRenderQueue(RenderQueue *queue)
+{
+    // Brauchen wir nicht
+}
+
+void Sound::setRolloffStartDistance(const Ogre::Real& distance)
+{
+	mRolloffStartDistance = distance;
+}
+
+const Ogre::Real Sound::getRolloffStartDistance() const
+{
+	return mRolloffStartDistance;
+}
+
+void Sound::setRolloffEndDistance(const Ogre::Real& distance)
+{
+	mRolloffEndDistance = distance;
+}
+
+const Ogre::Real Sound::getRolloffEndDistance() const
+{
+	return mRolloffEndDistance;
+}
+
+void Sound::visitRenderables(Renderable::Visitor* visitor, 
+			bool debugRenderables)
+{
+}
+
+};

Modified: rl/branches/newton20/engine/core/src/SoundResource.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/SoundResource.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/SoundResource.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -85,15 +85,6 @@
 }
 
 /**
- * @author JoSch
- * @date 03-14-2005
- */
-int SoundResource::getSize() const
-{
-    return calculateSize();
-}
-
-/**
  * @author Blakharaz
  * @date 03-14-2005
  */

Modified: rl/branches/newton20/engine/core/src/SoundStitching.cpp
===================================================================
--- rl/branches/newton20/engine/core/src/SoundStitching.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/core/src/SoundStitching.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,166 +1,171 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
-*/
-#include "stdinc.h" //precompiled header
-
-#include "SoundStitching.h"
-#include "SoundDriver.h"
-
-using namespace Ogre;
-
-namespace rl
-{
-
-AxisAlignedBox SoundStitching::msAABox = Ogre::AxisAlignedBox(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
-
-SoundStitching::SoundStitching(unsigned int numSlots, const CeGuiString& name, SoundDriver* creator)
-:  MovableObject(name.c_str()),
-   EventSource(),
-   EventCaster<SoundEvent>(),
-   mCreator(creator),
-   mVolume(1.0),
-   mName(name),
-   mIsLooping(true),
-   mIs3d(false),
-   mTicks(0),
-   mPosition(Vector3::ZERO),
-   mDirection(Quaternion::IDENTITY),
-   mVelocity(Vector3::ZERO),
-   mPriority(128),
-   mRolloffStartDistance(1.0),
-   mRolloffEndDistance(10000.0),
-   mNumSlots(numSlots)
-{
-}
-
-SoundStitching::~SoundStitching()
-{
-}
-
-/**
- * @return Ob der Sound wiederholt werden soll
- * @author JoSch
- * @date 08-08-2005
- */
-bool SoundStitching::isLooping() const
-{
-    return mIsLooping;
-}
-
-/**
- * @param looping Ob der Sound wiederholt werden soll
- * @author JoSch
- * @date 08-08-2005
- */
-void SoundStitching::setLooping(bool looping)
-{
-    mIsLooping = looping;
-}
-
-/**
- * @return Ob der Sound ein 3D-Sound ist.
- * @author JoSch
- * @date 08-08-2005
- */
-bool SoundStitching::is3d() const
-{
-    return mIs3d;
-}
-
-/**
- * @param is3d Ob der Sound ein 3D-Sound ist.
- * @author JoSch
- * @date 08-08-2005
- */
-void SoundStitching::set3d(bool is3d)
-{
-    mIs3d = is3d;
-}
-
-/** SoundResource zur?ckgeben.
- * @return Der Pointer auf die zugeh?rige Soundresource.
- * @author JoSch
- * @date 08-08-2005
- */
-const SoundResourcePtr &SoundStitching::getSoundResource() const
-{
-    return mSoundResource;
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-const AxisAlignedBox& SoundStitching::getBoundingBox() const
-{
-    return msAABox;
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-Real SoundStitching::getBoundingRadius (void) const
-{
-    return 0.0f; // SQRT(3*SQR(0.0)) to fit with AABB
-}
-
-/**
- * @author JoSch
- * @date 03-11-2005
- */
-void SoundStitching::_updateRenderQueue(RenderQueue *queue)
-{
-    // Brauchen wir nicht
-}
-
-void SoundStitching::setRolloffStartDistance(const Ogre::Real& distance)
-{
-	mRolloffStartDistance = distance;
-}
-
-const Ogre::Real SoundStitching::getRolloffStartDistance() const
-{
-	return mRolloffStartDistance;
-}
-
-void SoundStitching::setRolloffEndDistance(const Ogre::Real& distance)
-{
-	mRolloffEndDistance = distance;
-}
-
-const Ogre::Real SoundStitching::getRolloffEndDistance() const
-{
-	return mRolloffEndDistance;
-}
-
-
-void SoundStitching::addSoundToCache(CeGuiString label, SoundResourcePtr sound)
-{
-    mSoundCache[label] = sound;
-}
-
-unsigned int SoundStitching::getNumSlots()
-{
-    return mNumSlots;
-}
-
-float SoundStitching::getLength() const
-{
-    return 0.0f;
-}
-
-};
-
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+*/
+#include "stdinc.h" //precompiled header
+
+#include "SoundStitching.h"
+#include "SoundDriver.h"
+
+using namespace Ogre;
+
+namespace rl
+{
+
+AxisAlignedBox SoundStitching::msAABox = Ogre::AxisAlignedBox(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
+
+SoundStitching::SoundStitching(unsigned int numSlots, const CeGuiString& name, SoundDriver* creator)
+:  MovableObject(name.c_str()),
+   EventSource(),
+   EventCaster<SoundEvent>(),
+   mCreator(creator),
+   mVolume(1.0),
+   mName(name),
+   mIsLooping(true),
+   mIs3d(false),
+   mTicks(0),
+   mPosition(Vector3::ZERO),
+   mDirection(Quaternion::IDENTITY),
+   mVelocity(Vector3::ZERO),
+   mPriority(128),
+   mRolloffStartDistance(1.0),
+   mRolloffEndDistance(10000.0),
+   mNumSlots(numSlots)
+{
+}
+
+SoundStitching::~SoundStitching()
+{
+}
+
+/**
+ * @return Ob der Sound wiederholt werden soll
+ * @author JoSch
+ * @date 08-08-2005
+ */
+bool SoundStitching::isLooping() const
+{
+    return mIsLooping;
+}
+
+/**
+ * @param looping Ob der Sound wiederholt werden soll
+ * @author JoSch
+ * @date 08-08-2005
+ */
+void SoundStitching::setLooping(bool looping)
+{
+    mIsLooping = looping;
+}
+
+/**
+ * @return Ob der Sound ein 3D-Sound ist.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+bool SoundStitching::is3d() const
+{
+    return mIs3d;
+}
+
+/**
+ * @param is3d Ob der Sound ein 3D-Sound ist.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+void SoundStitching::set3d(bool is3d)
+{
+    mIs3d = is3d;
+}
+
+/** SoundResource zur?ckgeben.
+ * @return Der Pointer auf die zugeh?rige Soundresource.
+ * @author JoSch
+ * @date 08-08-2005
+ */
+const SoundResourcePtr &SoundStitching::getSoundResource() const
+{
+    return mSoundResource;
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+const AxisAlignedBox& SoundStitching::getBoundingBox() const
+{
+    return msAABox;
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+Real SoundStitching::getBoundingRadius (void) const
+{
+    return 0.0f; // SQRT(3*SQR(0.0)) to fit with AABB
+}
+
+/**
+ * @author JoSch
+ * @date 03-11-2005
+ */
+void SoundStitching::_updateRenderQueue(RenderQueue *queue)
+{
+    // Brauchen wir nicht
+}
+
+void SoundStitching::setRolloffStartDistance(const Ogre::Real& distance)
+{
+	mRolloffStartDistance = distance;
+}
+
+const Ogre::Real SoundStitching::getRolloffStartDistance() const
+{
+	return mRolloffStartDistance;
+}
+
+void SoundStitching::setRolloffEndDistance(const Ogre::Real& distance)
+{
+	mRolloffEndDistance = distance;
+}
+
+const Ogre::Real SoundStitching::getRolloffEndDistance() const
+{
+	return mRolloffEndDistance;
+}
+
+
+void SoundStitching::addSoundToCache(CeGuiString label, SoundResourcePtr sound)
+{
+    mSoundCache[label] = sound;
+}
+
+unsigned int SoundStitching::getNumSlots()
+{
+    return mNumSlots;
+}
+
+float SoundStitching::getLength() const
+{
+    return 0.0f;
+}
+
+void SoundStitching::visitRenderables(Renderable::Visitor* visitor, 
+			bool debugRenderables)
+{
+}
+
+};
+

Modified: rl/branches/newton20/engine/rules/include/Combat.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Combat.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/include/Combat.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -41,7 +41,7 @@
     public:
         typedef std::set<Combatant*> CombatantSet;
 
-        Combat();
+        Combat(Ogre::Real maxDistance = 10.0f);
         ~Combat();
 
         void addOpponent(Combatant*);
@@ -54,8 +54,9 @@
 
         void removeAlly(Combatant*);
 
-        const CombatantSet& getAllOpponents() const;
-        const CombatantSet& getAllAllies() const;
+        const CombatantSet getAllOpponents(Combatant* combatant) const;
+        const CombatantSet& getAllPlayerOpponents() const;
+        const CombatantSet& getAllPlayerAllies() const;
 
         void start();
         void pause();
@@ -119,6 +120,10 @@
 
         unsigned short mCurrentRound;
 		unsigned short mNextActionId;
+		
+		/// Maximum distance to enemies, a combatant is  this exceededing distance to its enemies
+		/// he is considered fleeing
+		Ogre::Real mMaxDistance;
 
 		MessagePump::ScopedConnection mLifeStateChangeConnection;
 
@@ -138,8 +143,9 @@
 		/// destroy combatants owned by this combat instance.
 		void clearRemovedCombatantSet();
 
+		bool isOutOfCombatRange(Combatant* combatant, const CombatantSet& enemies) const;
+
         // Message handlers
-
         bool onGameObjectLifeStateChanged(GameObject*, Effect::LifeState, Effect::LifeState);
     };
 }

Modified: rl/branches/newton20/engine/rules/include/Container.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Container.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/include/Container.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -71,8 +71,22 @@
 		 * @return <code>true</code> if adding was successful, <code>false</code> otherwise (e.g. not enough space)
 		 */
         bool addItem(Item* item, IntPair position = IntPair(0,0));
+
+        /**
+         * Remove an item from the container
+         *
+		 * @param item the item
+         */
         void removeItem(Item* item);
 
+        /**
+         * Remove an item from the container
+         * Note: This method must only be called by Item, use removeItem in all other cases
+         *
+		 * @param item the item
+         */
+        void _doRemoveItem(Item* item);
+
         ItemSet getItems() const;
 
 		int getItemCount() const;

Modified: rl/branches/newton20/engine/rules/include/GameObject.h
===================================================================
--- rl/branches/newton20/engine/rules/include/GameObject.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/include/GameObject.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -64,6 +64,7 @@
         static const Ogre::String PROPERTY_MASS; 
         static const Ogre::String PROPERTY_ACTIONS; 
         static const Ogre::String PROPERTY_DEFAULT_ACTION;
+        static const Ogre::String PROPERTY_IMAGENAME;
 
         static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION;
         static const CeGuiString DEFAULT_VIEW_OBJECT_ACTION_DEBUG;
@@ -82,6 +83,9 @@
         const CeGuiString& getDescription() const;
         void setDescription(const CeGuiString& description);
 
+		const CeGuiString& getImageName() const;
+		void setImageName(const CeGuiString& name);
+        
         const CeGuiString& getMeshfile() const;
         void setMeshfile(const CeGuiString& meshfile);
 
@@ -204,6 +208,7 @@
         
         CeGuiString mName;
         CeGuiString mDescription;
+        CeGuiString mImageName;
         CeGuiString mMeshfile;
 		MeshPartMap mMeshParts;
         CeGuiString mSubmeshPreName;

Modified: rl/branches/newton20/engine/rules/include/Item.h
===================================================================
--- rl/branches/newton20/engine/rules/include/Item.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/include/Item.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,124 +1,119 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __ITEM_H__
-#define __ITEM_H__
-
-#include "GameObject.h"
-
-namespace rl
-{
-	class _RlRulesExport Item;
-    class Slot;
-    class Container;
-
-	typedef std::vector<Item*> ContainerColumn;
-	typedef std::vector<ContainerColumn> ContainerLayout;
-
-
-    /// Aufnehmbare Objekte in der Spielwelt.
-    class _RlRulesExport Item : public GameObject
-    {
-    public:
-		enum ItemType{
-			ITEMTYPE_WEAPON     = 1 << 0,
-			ITEMTYPE_SHIELD     = 1 << 1,
-			ITEMTYPE_RING       = 1 << 2,
-			ITEMTYPE_GLOVES     = 1 << 3,
-			ITEMTYPE_BRACELET   = 1 << 4,
-			ITEMTYPE_ARMOR      = 1 << 5,
-			ITEMTYPE_CAPE       = 1 << 6,
-			ITEMTYPE_BRACERS    = 1 << 7,
-			ITEMTYPE_BACKPACK   = 1 << 8,
-			ITEMTYPE_BELT       = 1 << 9,
-			ITEMTYPE_NECKLACE   = 1 << 10,
-			ITEMTYPE_HELMET     = 1 << 11,
-			ITEMTYPE_TROUSERS   = 1 << 12,
-			ITEMTYPE_SHINBONE   = 1 << 13,
-			ITEMTYPE_BOOTS      = 1 << 14,
-            ITEMTYPE_CLOTHES    = 1 << 15,
-			ITEMTYPE_OTHER      = 1 << 16,
-            ITEMTYPE_ALL_ITEMS  = ~(0)
-		};
-
-
-        static const Ogre::String CLASS_NAME;
-
-        static const Ogre::String PROPERTY_ITEMTYPE;
-        static const Ogre::String PROPERTY_IMAGENAME;
-        static const Ogre::String PROPERTY_SIZE;
-        static const Ogre::String PROPERTY_SUBMESHNAME;
-
-		Item(unsigned int id);
-        virtual ~Item(void);
-
-		void setItemType(ItemType itemType);
-		ItemType getItemType() const;
-
-		const CeGuiString& getImageName() const;
-		void setImageName(const CeGuiString& name);
-
-        const CeGuiString& getSubmeshName() const;
-        void setSubmeshName(const CeGuiString& name);
-
-		/**
-		 * @return ob es sich um ein Item handelt,
-		 * in dem andere gespeichert werden koennen
-		 */
-        virtual bool isContainer() const;
-		
-		std::pair<int,int> getSize() const;
-		void setSize(int width, int height);
-
-
-        /**
-         * F?gt das Verhalten f?r die GO-States: GOS_READY, GOS_HELD und GOS_IN_POSSESION hinzu.
-         * @warning Bevor einer der drei States gesetzt wird, sollte zun?chst die Funktion removeOldState
-         * aufgerufen werden, dann m?ssen Owner und ParentSlot/ParentContainer gesetzt werden und
-         * eventuell doCreateActor. Als letztes muss diese Funktion mit dem neuen State aufgerufen werden.
-         * Die Reihenfolge ist wichtig, damit die onStateChange-Funktionen funktionieren k?nnen!
-         **/
-        virtual void setState(GameObjectState state);
-        virtual void removeOldState();
-
-        void setParentSlot(Slot* slot);
-        Slot* getParentSlot() const;
-
-        void setParentContainer(Container* cont);
-        Container* getParentContainer() const;
-
-        virtual void setOwner(GameObject* go);
-        GameObject* getOwner() const;
-
-        virtual const Property getProperty(const CeGuiString& key) const;
-        virtual void setProperty(const CeGuiString& key, const Property& value);
-        virtual PropertyKeys getAllPropertyKeys() const;
-
-        void doCreateActor();
-    protected:
-		ItemType mItemType;
-		CeGuiString mImageName;
-        CeGuiString mSubmeshName;
-		std::pair<int,int> mSize;
-        GameObject* mOwner;
-        Slot* mParentSlot;
-        Container* mParentContainer;
-
-		void doLoose();
-	};
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __ITEM_H__
+#define __ITEM_H__
+
+#include "GameObject.h"
+
+namespace rl
+{
+	class _RlRulesExport Item;
+    class Slot;
+    class Container;
+
+	typedef std::vector<Item*> ContainerColumn;
+	typedef std::vector<ContainerColumn> ContainerLayout;
+
+
+    /// Aufnehmbare Objekte in der Spielwelt.
+    class _RlRulesExport Item : public GameObject
+    {
+    public:
+		enum ItemType{
+			ITEMTYPE_WEAPON     = 1 << 0,
+			ITEMTYPE_SHIELD     = 1 << 1,
+			ITEMTYPE_RING       = 1 << 2,
+			ITEMTYPE_GLOVES     = 1 << 3,
+			ITEMTYPE_BRACELET   = 1 << 4,
+			ITEMTYPE_ARMOR      = 1 << 5,
+			ITEMTYPE_CAPE       = 1 << 6,
+			ITEMTYPE_BRACERS    = 1 << 7,
+			ITEMTYPE_BACKPACK   = 1 << 8,
+			ITEMTYPE_BELT       = 1 << 9,
+			ITEMTYPE_NECKLACE   = 1 << 10,
+			ITEMTYPE_HELMET     = 1 << 11,
+			ITEMTYPE_TROUSERS   = 1 << 12,
+			ITEMTYPE_SHINBONE   = 1 << 13,
+			ITEMTYPE_BOOTS      = 1 << 14,
+            ITEMTYPE_CLOTHES    = 1 << 15,
+			ITEMTYPE_OTHER      = 1 << 16,
+            ITEMTYPE_ALL_ITEMS  = ~(0)
+		};
+
+
+        static const Ogre::String CLASS_NAME;
+
+        static const Ogre::String PROPERTY_ITEMTYPE;
+        static const Ogre::String PROPERTY_SIZE;
+        static const Ogre::String PROPERTY_SUBMESHNAME;
+
+		Item(unsigned int id);
+        virtual ~Item(void);
+
+		void setItemType(ItemType itemType);
+		ItemType getItemType() const;
+
+        const CeGuiString& getSubmeshName() const;
+        void setSubmeshName(const CeGuiString& name);
+
+		/**
+		 * @return ob es sich um ein Item handelt,
+		 * in dem andere gespeichert werden koennen
+		 */
+        virtual bool isContainer() const;
+		
+		std::pair<int,int> getSize() const;
+		void setSize(int width, int height);
+
+
+        /**
+         * F??gt das Verhalten f??r die GO-States: GOS_READY, GOS_HELD und GOS_IN_POSSESION hinzu.
+         * @warning Bevor einer der drei States gesetzt wird, sollte zun???chst die Funktion removeOldState
+         * aufgerufen werden, dann m??ssen Owner und ParentSlot/ParentContainer gesetzt werden und
+         * eventuell doCreateActor. Als letztes muss diese Funktion mit dem neuen State aufgerufen werden.
+         * Die Reihenfolge ist wichtig, damit die onStateChange-Funktionen funktionieren k??nnen!
+         **/
+        virtual void setState(GameObjectState state);
+        virtual void removeOldState();
+
+        void setParentSlot(Slot* slot);
+        Slot* getParentSlot() const;
+
+        void setParentContainer(Container* cont);
+        Container* getParentContainer() const;
+
+        virtual void setOwner(GameObject* go);
+        GameObject* getOwner() const;
+
+        virtual const Property getProperty(const CeGuiString& key) const;
+        virtual void setProperty(const CeGuiString& key, const Property& value);
+        virtual PropertyKeys getAllPropertyKeys() const;
+
+        void doCreateActor();
+    protected:
+		ItemType mItemType;
+        CeGuiString mSubmeshName;
+		std::pair<int,int> mSize;
+        GameObject* mOwner;
+        Slot* mParentSlot;
+        Container* mParentContainer;
+
+		void doLoose();
+	};
+}
+
+#endif

Modified: rl/branches/newton20/engine/rules/include/PartyManager.h
===================================================================
--- rl/branches/newton20/engine/rules/include/PartyManager.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/include/PartyManager.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -25,11 +25,11 @@
 {
     class Creature;
 
+    typedef std::vector<Creature*> Party;
+
     class _RlRulesExport PartyManager : public Ogre::Singleton<PartyManager>
     {
     public:
-		typedef std::vector<Creature*> Party;
-
 		PartyManager();
         
         Creature* getActiveCharacter() const;

Modified: rl/branches/newton20/engine/rules/src/Combat.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Combat.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/src/Combat.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -59,7 +59,7 @@
         }
     };
 
-    Combat::Combat()
+    Combat::Combat(Ogre::Real maxDistance)
         : mOwnedCombatants(),
 		  mOpponents(),
           mAllies(),
@@ -70,7 +70,8 @@
 		  mRemovedCombatants(),
           mCurrentRound(0),
 		  mNextActionId(0),
-		  mAnimationSequenceTicket(0)
+		  mAnimationSequenceTicket(0),
+		  mMaxDistance(maxDistance)
     {
         LOG_MESSAGE("Combat", "Register message handler");
 		mLifeStateChangeConnection =
@@ -165,16 +166,31 @@
 		mRemovedCombatants.clear();
 	}
 
-    const Combat::CombatantSet& Combat::getAllOpponents() const
+    const Combat::CombatantSet& Combat::getAllPlayerOpponents() const
     {
         return mOpponents;
     }
 
-    const Combat::CombatantSet& Combat::getAllAllies() const
+    const Combat::CombatantSet& Combat::getAllPlayerAllies() const
     {
         return mAllies;
     }
 
+    const Combat::CombatantSet Combat::getAllOpponents(Combatant* combatant) const
+    {
+        if (mOpponents.find(combatant) != mOpponents.end())
+        {
+            return mAllies;
+        }
+        
+        if (mAllies.find(combatant) != mAllies.end())
+        {
+            return mOpponents;
+        }
+        
+        return Combat::CombatantSet(); // not in combat -> no opponents
+    }
+
     void Combat::start()
     {
 		GameEventLog::getSingleton().logEvent("Kampf beginnt.", GET_COMBAT);
@@ -384,6 +400,25 @@
     void Combat::endRound()
     {
 		clearRemovedCombatantSet();
+
+        // check for fleeing from combat
+        for (CombatantSet::iterator it = mAllies.begin(); it != mAllies.end(); ++it)
+        {
+            if (isOutOfCombatRange(*it, mOpponents))
+            {
+                removeAlly(*it);
+            }
+        }
+        for (CombatantSet::iterator it = mOpponents.begin(); it != mOpponents.end(); ++it)
+        {
+            if (isOutOfCombatRange(*it, mAllies))
+            {
+                removeOpponent(*it);
+            }
+        }
+
+		clearRemovedCombatantSet();
+
         // All actions executed. Analyze outcome of this round.
         if (mAllies.empty())
         {
@@ -544,4 +579,19 @@
 		}
 		return false;
 	}
+
+	bool Combat::isOutOfCombatRange(Combatant* combatant, const Combat::CombatantSet& enemies) const
+	{
+		Vector3 pos = combatant->getPosition();
+		Ogre::Real sqD = mMaxDistance * mMaxDistance;
+		for (CombatantSet::const_iterator it = enemies.begin(); it != enemies.end(); ++it)
+		{
+			if (pos.squaredDistance((*it)->getPosition()) <= sqD)
+			{
+				return false;
+			}
+		}
+
+		return true;
+	}
 }

Modified: rl/branches/newton20/engine/rules/src/Container.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Container.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/src/Container.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -168,16 +168,25 @@
 		}
     }
 
-    void Container::removeItem(Item* item)
+    void Container::_doRemoveItem(Item* item)
     {
         ItemSet::iterator it = mItems.find(item);
         if (it != mItems.end())
         {
             mItems.erase(it);
             mItemPositions.erase(mItemPositions.find(item));
-            
-            // this is the case, if the item is removed automatically
-            // don't change this without looking at Item::setState
+        }
+        else
+        {
+            Throw(IllegalArgumentException, "Item not in Container.");
+        }
+    }
+
+    void Container::removeItem(Item* item)
+    {
+        ItemSet::iterator it = mItems.find(item);
+        if (it != mItems.end())
+        {
             item->removeOldState();
             item->setScene("");
         }

Modified: rl/branches/newton20/engine/rules/src/GameObject.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/GameObject.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/src/GameObject.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -57,11 +57,13 @@
     const Ogre::String GameObject::PROPERTY_MASS = "mass";
     const Ogre::String GameObject::PROPERTY_ACTIONS = "actions";
     const Ogre::String GameObject::PROPERTY_DEFAULT_ACTION = "defaultaction";
-
+    const Ogre::String GameObject::PROPERTY_IMAGENAME = "imagename";
+    
     GameObject::GameObject(unsigned int id)
         :   mId(id),
             mName(""),
             mDescription(""),
+            mImageName(""),
             mMeshfile(""),
 			mMeshParts(),
             mQueryFlags(QUERYFLAG_GAMEOBJECT),
@@ -141,6 +143,16 @@
         mDescription = description;
     }
 
+	void GameObject::setImageName(const CeGuiString& name)
+	{
+		mImageName = name;
+	}
+    
+	const CeGuiString& GameObject::getImageName() const
+	{
+		return mImageName;
+	}
+    
     const CeGuiString& GameObject::getMeshfile() const
     {
         return mMeshfile;
@@ -540,6 +552,10 @@
         {
             prop.setValue(mDescription);
         }
+        else if (key == PROPERTY_IMAGENAME)
+        {
+            prop.setValue(mImageName);
+        }
         else if (key == PROPERTY_MESHFILE)
         {
             prop.setValue(mMeshfile);
@@ -594,6 +610,10 @@
             {
                 setDescription(value.toString());
             }
+            else if (key == PROPERTY_IMAGENAME)
+            {
+                setImageName(value.toString());
+            }
             else if (key == PROPERTY_MESHFILE)
             {
                 setMeshfile(value.toString());
@@ -682,6 +702,7 @@
         keys.insert(PROPERTY_MESHPARTS);
         keys.insert(PROPERTY_GEOMETRY_TYPE);
         keys.insert(PROPERTY_MASS);
+        keys.insert(PROPERTY_IMAGENAME);
         return keys;
     }
 

Modified: rl/branches/newton20/engine/rules/src/Item.cpp
===================================================================
--- rl/branches/newton20/engine/rules/src/Item.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/rules/src/Item.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,278 +1,258 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include "Item.h"
-
-#include "Actor.h"
-#include "Container.h"
-#include "Exception.h"
-#include "Slot.h"
-#include "GameObjectManager.h"
-
-using namespace std;
-
-namespace rl
-{
-    const Ogre::String Item::CLASS_NAME = "Item";
-
-    const Ogre::String Item::PROPERTY_IMAGENAME = "imagename";
-    const Ogre::String Item::PROPERTY_ITEMTYPE = "itemtype";
-    const Ogre::String Item::PROPERTY_SIZE = "size";
-    const Ogre::String Item::PROPERTY_SUBMESHNAME = "submeshfile";
-
-    Item::Item(unsigned int id)
-        : GameObject(id),
-		mItemType(ITEMTYPE_OTHER),
-		mImageName(""),
-		mSize(pair<int,int>(1,1)),
-        mOwner(NULL),
-        mParentSlot(NULL),
-        mParentContainer(NULL),
-        mSubmeshName("")
-    {
-        mQueryFlags |= QUERYFLAG_ITEM;
-    }
-
-    Item::~Item(void)
-    {
-        removeOldState(); // so the parent-container etc knows this item doesn't exists any more
-    }
-
-	void Item::setItemType(ItemType itemType)
-	{
-		mItemType = itemType;
-	}
-
-	Item::ItemType Item::getItemType() const
-	{
-		return mItemType;
-	}
-
-	void Item::setImageName(const CeGuiString& name)
-	{
-		mImageName = name;
-	}
-
-	const CeGuiString& Item::getImageName() const
-	{
-		return mImageName;
-	}
-
-	bool Item::isContainer() const
-	{
-		return false;
-	}
-
-	pair<int,int> Item::getSize() const
-	{
-		return mSize;
-	}
-
-	void Item::setSize(int widthSize,int heightSize)
-	{
-		mSize = pair<int,int>(widthSize,heightSize);
-	}
-
-    void Item::doLoose()
-    {
-        if (mActor != NULL)
-        {
-            mActor->detachFromParent();
-        }
-        if (mParentContainer != NULL)
-        {
-            mParentContainer->removeItem(this);
-            mParentContainer = NULL;
-        }
-        if (mParentSlot != NULL)
-        {
-            mParentSlot->setItem(NULL);
-            mParentSlot = NULL;
-        }
-        setOwner(NULL);
-    }
-
-    void Item::removeOldState()
-    {
-        setState(GOS_LOADED);
-    }
-
-// --------------- Warning ------------
-// do not change this function without
-// having a look at the containers and slots
-    void Item::setState(GameObjectState targetState)
-    {
-        if (mState == targetState)
-        {
-            return;
-        }
-
-        // do only things that are possible
-        if( targetState & (GOS_HELD | GOS_READY | GOS_IN_POSSESSION | GOS_IN_SCENE) && mState & (GOS_HELD | GOS_READY | GOS_IN_POSSESSION | GOS_IN_SCENE) )
-        {
-            LOG_ERROR(Logger::RULES,
-                "Item '" + getName() + "' could not change state from '"
-                + Ogre::StringConverter::toString(mState) + "' to state '"
-                + Ogre::StringConverter::toString(targetState) + "'!"
-                + "\nYou need to call 'Item::removeOldState()' first.");
-            
-            // first remove the old state (thats a recursive function call)
-            //removeOldState();
-        }
-
-        // everything else is not handled here, so give it to the parent
-        if ((targetState == GOS_IN_SCENE || targetState == GOS_LOADED)
-            && (mState == GOS_IN_SCENE || mState == GOS_LOADED))
-        {
-            GameObject::setState(targetState);
-            return;
-        }
-
-        GameObjectState oldState = mState;
-        onBeforeStateChange(oldState, targetState);        
-
-        if (targetState == GOS_LOADED 
-            && (mState == GOS_HELD || mState == GOS_READY || GOS_IN_POSSESSION) )
-        {
-            mState = targetState; // this is needed here to prevent an endless recursion
-            // "remove old state"
-            doLoose();
-            destroyActor();
-        }
-        else if (mState == GOS_LOADED &&
-                 (targetState == GOS_HELD || targetState == GOS_READY))
-        {
-            createActor();
-            mState = targetState;
-            // do nothing, the user has to do what he needs himself
-        }
-        else if ((mState == GOS_LOADED && targetState == GOS_IN_POSSESSION)
-            || (mState == GOS_IN_POSSESSION && targetState == GOS_LOADED))
-        {
-            mState = targetState;
-        }
-        else
-        {
-            Throw(rl::IllegalStateException, "Unhandled state change");
-        }
-
-        onAfterStateChange(oldState, targetState);
-        GameObjectManager::getSingleton().gameObjectStateChanged(this, oldState, targetState);
-    }
-
-    void Item::setProperty(const CeGuiString& key, const Property& value)
-    {
-        if (key == Item::PROPERTY_IMAGENAME)
-        {
-            mImageName = value.toString();
-        }
-        else if (key == Item::PROPERTY_SIZE)
-        {
-            mSize = value.toIntPair();
-        }
-        else if (key == Item::PROPERTY_ITEMTYPE)
-        {
-            mItemType = static_cast<Item::ItemType>(value.toInt());
-        }
-        else if (key == Item::PROPERTY_SUBMESHNAME)
-        {
-            mSubmeshName = value.toString();
-        }
-        else
-        {
-            GameObject::setProperty(key, value);
-        }
-    }
-
-    const Property Item::getProperty(const CeGuiString& key) const
-    {
-        if (key == Item::PROPERTY_IMAGENAME)
-        {
-            return Property(mImageName);
-        }
-        else if (key == Item::PROPERTY_SIZE)
-        {
-            return Property(mSize);
-        }
-        else if (key == Item::PROPERTY_ITEMTYPE)
-        {
-            return Property(mItemType);
-        }
-        else if (key == Item::PROPERTY_SUBMESHNAME)
-        {
-            return Property(mSubmeshName);
-        }
-        else
-        {
-            return GameObject::getProperty(key);
-        }
-    }
-
-    PropertyKeys Item::getAllPropertyKeys() const
-    {
-        PropertyKeys keys(GameObject::getAllPropertyKeys());
-        keys.insert(Item::PROPERTY_IMAGENAME);
-        keys.insert(Item::PROPERTY_SIZE);
-        keys.insert(Item::PROPERTY_ITEMTYPE);
-        return keys;
-    }
-
-    void Item::setOwner(GameObject* owner)
-    {
-        mOwner = owner;
-    }
-
-    GameObject* Item::getOwner() const
-    {
-        return mOwner;
-    }
-
-    void Item::setParentSlot(Slot* slot)
-    {
-        mParentSlot = slot;
-    }
-
-    Slot* Item::getParentSlot() const
-    {
-        return mParentSlot;
-    }
-
-    void Item::doCreateActor()
-    {
-        setActor(createActor());
-    }
-
-    void Item::setParentContainer(Container* cont)
-    {
-        mParentContainer = cont;
-    }
-
-    Container* Item::getParentContainer() const
-    {
-        return mParentContainer;
-    }
-
-    const CeGuiString& Item::getSubmeshName() const
-    {
-        return mSubmeshName;
-    }
-
-    void Item::setSubmeshName(const CeGuiString& name)
-    {
-        mSubmeshName = name;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include "Item.h"
+
+#include "Actor.h"
+#include "Container.h"
+#include "Exception.h"
+#include "Slot.h"
+#include "GameObjectManager.h"
+
+using namespace std;
+
+namespace rl
+{
+    const Ogre::String Item::CLASS_NAME = "Item";
+
+    const Ogre::String Item::PROPERTY_ITEMTYPE = "itemtype";
+    const Ogre::String Item::PROPERTY_SIZE = "size";
+    const Ogre::String Item::PROPERTY_SUBMESHNAME = "submeshfile";
+
+    Item::Item(unsigned int id)
+        : GameObject(id),
+		mItemType(ITEMTYPE_OTHER),
+		mSize(pair<int,int>(1,1)),
+        mOwner(NULL),
+        mParentSlot(NULL),
+        mParentContainer(NULL),
+        mSubmeshName("")
+    {
+        mQueryFlags |= QUERYFLAG_ITEM;
+    }
+
+    Item::~Item(void)
+    {
+        removeOldState(); // so the parent-container etc knows this item doesn't exists any more
+    }
+
+	void Item::setItemType(ItemType itemType)
+	{
+		mItemType = itemType;
+	}
+
+	Item::ItemType Item::getItemType() const
+	{
+		return mItemType;
+	}
+
+	bool Item::isContainer() const
+	{
+		return false;
+	}
+
+	pair<int,int> Item::getSize() const
+	{
+		return mSize;
+	}
+
+	void Item::setSize(int widthSize,int heightSize)
+	{
+		mSize = pair<int,int>(widthSize,heightSize);
+	}
+
+    void Item::doLoose()
+    {
+        if (mActor != NULL)
+        {
+            mActor->detachFromParent();
+        }
+        if (mParentContainer != NULL)
+        {
+            mParentContainer->_doRemoveItem(this);
+            mParentContainer = NULL;
+        }
+        if (mParentSlot != NULL)
+        {
+            mParentSlot->setItem(NULL);
+            mParentSlot = NULL;
+        }
+        setOwner(NULL);
+    }
+
+    void Item::removeOldState()
+    {
+        setState(GOS_LOADED);
+    }
+
+// --------------- Warning ------------
+// do not change this function without
+// having a look at the containers and slots
+    void Item::setState(GameObjectState targetState)
+    {
+        if (mState == targetState)
+        {
+            return;
+        }
+
+        // do only things that are possible
+        if( targetState & (GOS_HELD | GOS_READY | GOS_IN_POSSESSION | GOS_IN_SCENE) && mState & (GOS_HELD | GOS_READY | GOS_IN_POSSESSION | GOS_IN_SCENE) )
+        {
+            LOG_ERROR(Logger::RULES,
+                "Item '" + getName() + "' could not change state from '"
+                + Ogre::StringConverter::toString(mState) + "' to state '"
+                + Ogre::StringConverter::toString(targetState) + "'!"
+                + "\nYou need to call 'Item::removeOldState()' first.");
+            
+            // first remove the old state (thats a recursive function call)
+            //removeOldState();
+        }
+
+        // everything else is not handled here, so give it to the parent
+        if ((targetState == GOS_IN_SCENE || targetState == GOS_LOADED)
+            && (mState == GOS_IN_SCENE || mState == GOS_LOADED))
+        {
+            GameObject::setState(targetState);
+            return;
+        }
+
+        GameObjectState oldState = mState;
+        onBeforeStateChange(oldState, targetState);        
+
+        if (targetState == GOS_LOADED 
+            && (mState == GOS_HELD || mState == GOS_READY || GOS_IN_POSSESSION) )
+        {
+            mState = targetState; // this is needed here to prevent an endless recursion
+            // "remove old state"
+            doLoose();
+            destroyActor();
+        }
+        else if (mState == GOS_LOADED &&
+                 (targetState == GOS_HELD || targetState == GOS_READY))
+        {
+            createActor();
+            mState = targetState;
+            // do nothing, the user has to do what he needs himself
+        }
+        else if ((mState == GOS_LOADED && targetState == GOS_IN_POSSESSION)
+            || (mState == GOS_IN_POSSESSION && targetState == GOS_LOADED))
+        {
+            mState = targetState;
+        }
+        else
+        {
+            Throw(rl::IllegalStateException, "Unhandled state change");
+        }
+
+        onAfterStateChange(oldState, targetState);
+        GameObjectManager::getSingleton().gameObjectStateChanged(this, oldState, targetState);
+    }
+
+    void Item::setProperty(const CeGuiString& key, const Property& value)
+    {
+        if (key == Item::PROPERTY_SIZE)
+        {
+            mSize = value.toIntPair();
+        }
+        else if (key == Item::PROPERTY_ITEMTYPE)
+        {
+            mItemType = static_cast<Item::ItemType>(value.toInt());
+        }
+        else if (key == Item::PROPERTY_SUBMESHNAME)
+        {
+            mSubmeshName = value.toString();
+        }
+        else
+        {
+            GameObject::setProperty(key, value);
+        }
+    }
+
+    const Property Item::getProperty(const CeGuiString& key) const
+    {
+        if (key == Item::PROPERTY_SIZE)
+        {
+            return Property(mSize);
+        }
+        else if (key == Item::PROPERTY_ITEMTYPE)
+        {
+            return Property(mItemType);
+        }
+        else if (key == Item::PROPERTY_SUBMESHNAME)
+        {
+            return Property(mSubmeshName);
+        }
+        else
+        {
+            return GameObject::getProperty(key);
+        }
+    }
+
+    PropertyKeys Item::getAllPropertyKeys() const
+    {
+        PropertyKeys keys(GameObject::getAllPropertyKeys());
+        keys.insert(Item::PROPERTY_SUBMESHNAME);
+        keys.insert(Item::PROPERTY_SIZE);
+        keys.insert(Item::PROPERTY_ITEMTYPE);
+        return keys;
+    }
+
+    void Item::setOwner(GameObject* owner)
+    {
+        mOwner = owner;
+    }
+
+    GameObject* Item::getOwner() const
+    {
+        return mOwner;
+    }
+
+    void Item::setParentSlot(Slot* slot)
+    {
+        mParentSlot = slot;
+    }
+
+    Slot* Item::getParentSlot() const
+    {
+        return mParentSlot;
+    }
+
+    void Item::doCreateActor()
+    {
+        setActor(createActor());
+    }
+
+    void Item::setParentContainer(Container* cont)
+    {
+        mParentContainer = cont;
+    }
+
+    Container* Item::getParentContainer() const
+    {
+        return mParentContainer;
+    }
+
+    const CeGuiString& Item::getSubmeshName() const
+    {
+        return mSubmeshName;
+    }
+
+    void Item::setSubmeshName(const CeGuiString& name)
+    {
+        mSubmeshName = name;
+    }
+}

Modified: rl/branches/newton20/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/branches/newton20/engine/script/src/PlaneNodeProcessor.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/script/src/PlaneNodeProcessor.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -222,8 +222,8 @@
 
 	void PlaneReflectionTextureListener::preRenderTargetUpdate(const RenderTargetEvent &evt)
 	{
-		mCamera->setPosition(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getWorldPosition());
-		mCamera->setOrientation(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getWorldOrientation());
+		mCamera->setPosition(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getDerivedPosition());
+		mCamera->setOrientation(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getDerivedOrientation());
 		mEntity->setVisible(false);
 		mCamera->enableReflection((MovablePlane*)mPlane);
 	}
@@ -242,8 +242,8 @@
 
 	void PlaneRefractionTextureListener::preRenderTargetUpdate(const Ogre::RenderTargetEvent& evt)
 	{
-		mCamera->setPosition(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getWorldPosition());
-		mCamera->setOrientation(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getWorldOrientation());
+		mCamera->setPosition(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getDerivedPosition());
+		mCamera->setOrientation(CoreSubsystem::getSingleton().getWorld()->getActiveCamera()->getDerivedOrientation());
 		mEntity->setVisible(false);
 	}
 

Modified: rl/branches/newton20/engine/script/swig/RlUi.swig
===================================================================
--- rl/branches/newton20/engine/script/swig/RlUi.swig	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/script/swig/RlUi.swig	2008-11-30 22:46:52 UTC (rev 4616)
@@ -103,6 +103,7 @@
     void toggleConsole();
     void toggleDebugWindow();
     void toggleGameLogWindow();
+    void toggleCharacterSelectionWindow();
     void toggleCharacterStateWindow();
     void toggleInGameGlobalMenu();
     void toggleInventoryWindow();

Modified: rl/branches/newton20/engine/ui/include/AbstractWindow.h
===================================================================
--- rl/branches/newton20/engine/ui/include/AbstractWindow.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/include/AbstractWindow.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,140 +1,142 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- * 
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __AbstractWindow_H__
-#define __AbstractWindow_H__
-
-#include "UiPrerequisites.h"
-
-
-#include <CEGUIWindow.h>
-#include <elements/CEGUIEditbox.h>
-#include <elements/CEGUIListbox.h>
-#include <elements/CEGUIMultiColumnList.h>
-#include <elements/CEGUIMultiLineEditbox.h>
-#include <elements/CEGUIProgressBar.h>
-#include <elements/CEGUIMenuBase.h>
-#include <elements/CEGUIMenuItem.h>
-#include <elements/CEGUIPushButton.h>
-#include <elements/CEGUICombobox.h>
-#include <elements/CEGUIComboDropList.h>
-#include <elements/CEGUIScrollablePane.h>
-#include <elements/CEGUISlider.h>
-#include <elements/CEGUITabControl.h>
-
-namespace rl {
-
-	class WindowUpdateTask;
-
-	/**
-	 * This is the base class for all UI windows
-	 */
-	class _RlUiExport AbstractWindow
-	{
-	public:
-
-		enum WindowInputType
-		{
-			WIT_NONE = 0x00,
-			WIT_MOUSE_INPUT = 0x01,
-			WIT_KEYBOARD_INPUT = 0x02
-		};
-
-		virtual ~AbstractWindow();	
-
-		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
-		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile);
-
-		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
-		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix);
-
-		/// gets the CEGUI root
-		static CEGUI::Window* getRoot();
-
-		/// gets the wrapped CEGUI window
-		CEGUI::Window* getWindow();
-
-		CEGUI::Window* getWindow(const char* name, const char* requiredClass = NULL);
-		CEGUI::Editbox* getEditbox(const char* name);
-		CEGUI::Listbox* getListbox(const char* name);
-		CEGUI::MultiColumnList* getMultiColumnList(const char* name);
-		CEGUI::MultiLineEditbox* getMultiLineEditbox(const char* name);
-		CEGUI::ProgressBar* getProgressBar(const char* name);
-		CEGUI::MenuBase* getMenu(const char* name);
-		CEGUI::MenuItem* getMenuItem(const char* name);
-		CEGUI::PushButton* getPushButton(const char* name);
-		CEGUI::Combobox* getCombobox(const char* name);
-		CEGUI::ComboDropList* getComboDropList(const char* name);
-        CEGUI::ScrollablePane* getScrollablePane(const char* name);
-		CEGUI::Slider* getSlider(const char* name);
-		CEGUI::TabControl* getTabControl(const char* name);
-
-		int getWindowInputType();
-
-        virtual bool isVisible();
-        virtual void setVisible(bool visible, bool destroyAfterHide = false);
-
-		bool isModal();
-		bool isClosingOnEscape();
-
-		const CeGuiString& getName() const;
-		const Ogre::Real& getNormalAlpha() const;
-
-		virtual void windowHid();
-
-        // return true, if the specified key should be repeated if pressed down
-        virtual bool wantsKeyToRepeat(const int &key) {return false;}
-
-	protected:
-		AbstractWindow(
-			const CeGuiString& xmlfile, 
-			int inputType, 
-			bool closeOnEscape = true,
-			bool modal = false);
-
-		const CeGuiString& getNamePrefix() const;
-		
-		void centerWindow();
-		bool destroyWindow();		
-		bool hideWindow();
-
-		void bindDestroyWindowToClick(CEGUI::Window* button);
-        void bindHideWindowToClick(CEGUI::Window* button);
-		void bindDestroyWindowToXButton();
-		void bindHideWindowToXButton();
-
-		const CeGuiString& getUserDataType(CEGUI::Window* window) const;
-		void setUserDataType(CEGUI::Window* window, const CeGuiString& typeDescription) const;
-
-		CEGUI::Window* mWindow;
-		bool mVisible;
-
-	private:
-		
-		int mWindowInputType;
-		CeGuiString mNamePrefix;
-		CeGuiString mName;
-		bool mModal;
-		bool mCloseOnEscape;
-		Ogre::Real mNormalAlpha;
-
-		static int sNumAbstractWindows;
-
-	};
-
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __AbstractWindow_H__
+#define __AbstractWindow_H__
+
+#include "UiPrerequisites.h"
+
+
+#include <CEGUIWindow.h>
+#include <elements/CEGUICheckbox.h>
+#include <elements/CEGUIEditbox.h>
+#include <elements/CEGUIListbox.h>
+#include <elements/CEGUIMultiColumnList.h>
+#include <elements/CEGUIMultiLineEditbox.h>
+#include <elements/CEGUIProgressBar.h>
+#include <elements/CEGUIMenuBase.h>
+#include <elements/CEGUIMenuItem.h>
+#include <elements/CEGUIPushButton.h>
+#include <elements/CEGUICombobox.h>
+#include <elements/CEGUIComboDropList.h>
+#include <elements/CEGUIScrollablePane.h>
+#include <elements/CEGUISlider.h>
+#include <elements/CEGUITabControl.h>
+
+namespace rl {
+
+	class WindowUpdateTask;
+
+	/**
+	 * This is the base class for all UI windows
+	 */
+	class _RlUiExport AbstractWindow
+	{
+	public:
+
+		enum WindowInputType
+		{
+			WIT_NONE = 0x00,
+			WIT_MOUSE_INPUT = 0x01,
+			WIT_KEYBOARD_INPUT = 0x02
+		};
+
+		virtual ~AbstractWindow();	
+
+		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
+		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile);
+
+		/// creates a CEGUI window from an XML file, should only be used to load window parts (e.g. buttons)
+		static CEGUI::Window* loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix);
+
+		/// gets the CEGUI root
+		static CEGUI::Window* getRoot();
+
+		/// gets the wrapped CEGUI window
+		CEGUI::Window* getWindow();
+
+		CEGUI::Window* getWindow(const char* name, const char* requiredClass = NULL);
+		CEGUI::Editbox* getEditbox(const char* name);
+		CEGUI::Listbox* getListbox(const char* name);
+		CEGUI::MultiColumnList* getMultiColumnList(const char* name);
+		CEGUI::MultiLineEditbox* getMultiLineEditbox(const char* name);
+		CEGUI::ProgressBar* getProgressBar(const char* name);
+		CEGUI::MenuBase* getMenu(const char* name);
+		CEGUI::MenuItem* getMenuItem(const char* name);
+		CEGUI::PushButton* getPushButton(const char* name);
+		CEGUI::Combobox* getCombobox(const char* name);
+		CEGUI::ComboDropList* getComboDropList(const char* name);
+        CEGUI::ScrollablePane* getScrollablePane(const char* name);
+		CEGUI::Slider* getSlider(const char* name);
+		CEGUI::TabControl* getTabControl(const char* name);
+        CEGUI::Checkbox* getCheckbox(const char* name);
+
+		int getWindowInputType();
+
+        virtual bool isVisible();
+        virtual void setVisible(bool visible, bool destroyAfterHide = false);
+
+		bool isModal();
+		bool isClosingOnEscape();
+
+		const CeGuiString& getName() const;
+		const Ogre::Real& getNormalAlpha() const;
+
+		virtual void windowHid();
+
+        // return true, if the specified key should be repeated if pressed down
+        virtual bool wantsKeyToRepeat(const int &key) {return false;}
+
+	protected:
+		AbstractWindow(
+			const CeGuiString& xmlfile, 
+			int inputType, 
+			bool closeOnEscape = true,
+			bool modal = false);
+
+		const CeGuiString& getNamePrefix() const;
+		
+		void centerWindow();
+		bool destroyWindow();		
+		bool hideWindow();
+
+		void bindDestroyWindowToClick(CEGUI::Window* button);
+        void bindHideWindowToClick(CEGUI::Window* button);
+		void bindDestroyWindowToXButton();
+		void bindHideWindowToXButton();
+
+		const CeGuiString& getUserDataType(CEGUI::Window* window) const;
+		void setUserDataType(CEGUI::Window* window, const CeGuiString& typeDescription) const;
+
+		CEGUI::Window* mWindow;
+		bool mVisible;
+
+	private:
+		
+		int mWindowInputType;
+		CeGuiString mNamePrefix;
+		CeGuiString mName;
+		bool mModal;
+		bool mCloseOnEscape;
+		Ogre::Real mNormalAlpha;
+
+		static int sNumAbstractWindows;
+
+	};
+
+}
+
+#endif

Copied: rl/branches/newton20/engine/ui/include/CharacterSelectionWindow.h (from rev 4613, rl/trunk/engine/ui/include/CharacterSelectionWindow.h)

Modified: rl/branches/newton20/engine/ui/include/CombatGui.h
===================================================================
--- rl/branches/newton20/engine/ui/include/CombatGui.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/include/CombatGui.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -73,6 +73,8 @@
 		/// Needed to only close it after combat if it was not shown before.
 		bool mGameLoggerWindowOpened;
 
+        bool mVisible;
+
         Ogre::FloatRect getScreenRectFromWorldAabb(const Ogre::AxisAlignedBox& aabb) const;
 	};
 }

Modified: rl/branches/newton20/engine/ui/include/GameSettings.h
===================================================================
--- rl/branches/newton20/engine/ui/include/GameSettings.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/include/GameSettings.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -82,11 +82,17 @@
 		 * configuration section.
 		 */
 		bool onRenderSystemChanged();
+        
+        void update();
 
 		std::list<SoundDriverConfigComponent*> mSoundDriverConfigs;   //!< List of registered sounddriver configuration components
 		SoundDriverConfigComponent* mCurrentSoundDriverConfig;        //!< Configuration component of currently selected sound driver
 		std::list<RenderSystemConfigComponent*> mRenderSystemConfigs; //!< List of registered rendersystem configuration components
 		RenderSystemConfigComponent* mCurrentRenderSystemConfig;      //!< Configuration component of currently selected rendersystem
+        
+        CEGUI::Combobox* mVideoRenderer;
+        CEGUI::Combobox* mVideoResolution;
+        CEGUI::Checkbox* mVideoFullscreen;
 	};
 }
 

Modified: rl/branches/newton20/engine/ui/include/Makefile.am
===================================================================
--- rl/branches/newton20/engine/ui/include/Makefile.am	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/include/Makefile.am	2008-11-30 22:46:52 UTC (rev 4616)
@@ -5,6 +5,7 @@
     CeGuiHelper.h \
     CharacterSheetWindow.h \
     CharacterStateWindow.h \
+	CharacterSelectionWindow.h \
     CloseConfirmationWindow.h \
     CombatControlState.h \
     CombatGui.h \

Modified: rl/branches/newton20/engine/ui/include/WindowFactory.h
===================================================================
--- rl/branches/newton20/engine/ui/include/WindowFactory.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/include/WindowFactory.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,142 +1,145 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-
-#ifndef __WindowFactory_H__
-#define __WindowFactory_H__
-
-#include "UiPrerequisites.h"
-
-#include "FixRubyHeaders.h"        // die Makros sind hier vor Ruby schon definiert
-#include <ruby.h>
-#include "FixRubyHeaders.h"
-
-namespace rl {
-
-    class Actor;
-    class AbstractWindow;
-    class CharacterStateWindow;
-    class CharacterSheetWindow;
-    class CloseConfirmationWindow;
-    class CombatWindow;
-    class Console;
-    class Container;
-    class Creature;
-    class DebugWindow;
-    class DialogCharacter;
-    class GameLoggerWindow;
-    class GameObject;
-    class PropertiesWindow;
-    class GameSettings;
-    class InfoPopup;
-    class InGameMenuWindow;
-    class InventoryWindow;
-    class JournalWindow;
-    class LogWindow;
-    class MainMenuWindow;
-    class ObjectDescriptionWindow;
-    class GameSaveLoadWindow;
-    class MainMenuLoadWindow;
-    class WindowUpdater;
-
-    class _RlUiExport WindowFactory : public Ogre::Singleton<WindowFactory>
-    {
-    public:
-        enum PopupIcon
-        {
-            ICON_ERROR = 1,
-            ICON_QUEST
-        };
-
-        WindowFactory();
-        ~WindowFactory();
-
-        void initialize();
-
-        void setActiveCharacter(Creature* character);
-
-        void showActionChoice(GameObject* obj);
-        void showAboutWindow();
-        void showCharacterActionChoice();
-        void showCharacterSheet();
-        void showCharacterSheet(Creature* chara);
-        void showContainerContent(Container* container);
-        void showDescriptionWindow(GameObject* obj);
-        void showPropertiesWindow(GameObject* obj);
-        void showExitConfirmation();
-        void showJournalWindow();
-        void showLogfiles();
-        void showMessageWindow(const CeGuiString& message);
-        void showMainMenu();
-        void showObjectDescription(GameObject* object);
-        void showPlaylist();
-        void showGameSaveLoadWindow();
-        void showMainMenuLoadWindow(MainMenuWindow* win);
-		void hideMainMenuLoadWindow();
-        void showPopupMessage(int popupTypes);
-        void showGameOverWindow();
-        /**
-         * Creates a GameSettings object and displays its layout file on screen
-         */
-        void showGameSettings();
-
-        void toggleConsole();
-        void toggleDebugWindow();
-        void toggleGameLogWindow();
-        void toggleCharacterStateWindow();
-        void toggleInGameGlobalMenu();
-        void toggleInventoryWindow();
-        void notifyInventoryWindowDestroyed();
-		bool isInventoryWindowDestroyed();
-
-        CombatWindow* getCombatWindow();
-
-        void checkForErrors();
-        GameLoggerWindow* getGameLogger();
-
-        void update();
-
-        /// Writes Text into the Console or other output media
-        void writeToConsole(std::string text);
-        static VALUE consoleWrite(VALUE self, VALUE str);
-
-        /// Change shown DebugWindow page
-        void showNextDebugWindowPage();
-
-    private:
-        void logAllWindows();
-
-        GameLoggerWindow* mGameLogger;
-        CharacterStateWindow* mCharacterStateWindow;
-        InGameMenuWindow* mInGameMenuWindow;
-        CharacterSheetWindow* mCharacterSheet;
-        JournalWindow* mJournalWindow;
-        InventoryWindow* mInventoryWindow;
-        LogWindow* mLogWindow;
-        DebugWindow* mDebugWindow;
-        Console* mConsole;
-        InfoPopup* mInfoPopup;
-        Actor* mObjectNameText;
-        GameObject* mShownObject;
-        ObjectDescriptionWindow* mObjectDescriptionWindow;
-        MainMenuWindow* mMainMenuWindow;
-		MainMenuLoadWindow* mMainMenuLoadWindow;
-        CloseConfirmationWindow* mCloseConfirmationWindow;
-        GameSettings* mGameSettings;
-        CombatWindow* mCombatWindow;
-    };
-}
-
-#endif
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+
+#ifndef __WindowFactory_H__
+#define __WindowFactory_H__
+
+#include "UiPrerequisites.h"
+
+#include "FixRubyHeaders.h"        // die Makros sind hier vor Ruby schon definiert
+#include <ruby.h>
+#include "FixRubyHeaders.h"
+
+namespace rl {
+
+    class Actor;
+    class AbstractWindow;
+    class CharacterSelectionWindow;
+    class CharacterSheetWindow;
+    class CharacterStateWindow;
+    class CloseConfirmationWindow;
+    class CombatWindow;
+    class Console;
+    class Container;
+    class Creature;
+    class DebugWindow;
+    class DialogCharacter;
+    class GameLoggerWindow;
+    class GameObject;
+    class PropertiesWindow;
+    class GameSettings;
+    class InfoPopup;
+    class InGameMenuWindow;
+    class InventoryWindow;
+    class JournalWindow;
+    class LogWindow;
+    class MainMenuWindow;
+    class ObjectDescriptionWindow;
+    class GameSaveLoadWindow;
+    class MainMenuLoadWindow;
+    class WindowUpdater;
+
+    class _RlUiExport WindowFactory : public Ogre::Singleton<WindowFactory>
+    {
+    public:
+        enum PopupIcon
+        {
+            ICON_ERROR = 1,
+            ICON_QUEST
+        };
+
+        WindowFactory();
+        ~WindowFactory();
+
+        void initialize();
+
+        void setActiveCharacter(Creature* character);
+
+        void showActionChoice(GameObject* obj);
+        void showAboutWindow();
+        void showCharacterActionChoice();
+        void showCharacterSheet();
+        void showCharacterSheet(Creature* chara);
+        void showContainerContent(Container* container);
+        void showDescriptionWindow(GameObject* obj);
+        void showPropertiesWindow(GameObject* obj);
+        void showExitConfirmation();
+        void showJournalWindow();
+        void showLogfiles();
+        void showMessageWindow(const CeGuiString& message);
+        void showMainMenu();
+        void showObjectDescription(GameObject* object);
+        void showPlaylist();
+        void showGameSaveLoadWindow();
+        void showMainMenuLoadWindow(MainMenuWindow* win);
+		void hideMainMenuLoadWindow();
+        void showPopupMessage(int popupTypes);
+        void showGameOverWindow();
+        /**
+         * Creates a GameSettings object and displays its layout file on screen
+         */
+        void showGameSettings();
+
+        void toggleConsole();
+        void toggleDebugWindow();
+        void toggleGameLogWindow();
+        void toggleCharacterStateWindow();
+        void toggleCharacterSelectionWindow();
+        void toggleInGameGlobalMenu();
+        void toggleInventoryWindow();
+        void notifyInventoryWindowDestroyed();
+		bool isInventoryWindowDestroyed();
+
+        CombatWindow* getCombatWindow();
+
+        void checkForErrors();
+        GameLoggerWindow* getGameLogger();
+
+        void update();
+
+        /// Writes Text into the Console or other output media
+        void writeToConsole(std::string text);
+        static VALUE consoleWrite(VALUE self, VALUE str);
+
+        /// Change shown DebugWindow page
+        void showNextDebugWindowPage();
+
+    private:
+        void logAllWindows();
+
+        GameLoggerWindow* mGameLogger;
+        CharacterStateWindow* mCharacterStateWindow;
+        InGameMenuWindow* mInGameMenuWindow;
+        CharacterSheetWindow* mCharacterSheet;
+        JournalWindow* mJournalWindow;
+        InventoryWindow* mInventoryWindow;
+        LogWindow* mLogWindow;
+        DebugWindow* mDebugWindow;
+        Console* mConsole;
+        InfoPopup* mInfoPopup;
+        Actor* mObjectNameText;
+        GameObject* mShownObject;
+        ObjectDescriptionWindow* mObjectDescriptionWindow;
+        MainMenuWindow* mMainMenuWindow;
+		MainMenuLoadWindow* mMainMenuLoadWindow;
+        CloseConfirmationWindow* mCloseConfirmationWindow;
+        GameSettings* mGameSettings;
+        CombatWindow* mCombatWindow;
+        CharacterSelectionWindow* mCharacterSelectionWindow;
+    };
+}
+
+#endif

Modified: rl/branches/newton20/engine/ui/src/AbstractWindow.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/AbstractWindow.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/AbstractWindow.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,319 +1,325 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include <boost/bind.hpp>
-#include <CEGUIWindowManager.h>
-#include <elements/CEGUIFrameWindow.h>
-
-#include "UiPrerequisites.h"
-#include "Exception.h"
-
-#include "UiSubsystem.h"
-#include "AbstractWindow.h"
-#include "CeGuiHelper.h"
-#include "WindowManager.h"
-#include "WindowFadeJob.h"
-#include "JobScheduler.h"
-
-using namespace std;
-using namespace CEGUI;
-using namespace Ogre;
-
-namespace rl
-{
-
-	int AbstractWindow::sNumAbstractWindows = 0;
-
-	AbstractWindow::AbstractWindow(const CeGuiString& xmlfile, int inputType, bool closeOnEscape, bool modal)
-	: mVisible(false),
-		mModal(modal),
-		mWindowInputType(inputType),
-		mCloseOnEscape(closeOnEscape)
-	{
-        LOG_MESSAGE(Logger::UI,
-		    "Lade Fenster '" + Ogre::String(xmlfile.c_str()) + "'");
-   		mWindow = AbstractWindow::loadWindow(xmlfile, mNamePrefix);
-		if (mWindow == NULL)
-		{
-			Throw(rl::IllegalStateException, Ogre::String("Could not load window '")+xmlfile.c_str()+"'.");
-		}
-
-		getRoot()->addChildWindow(mWindow);
-
-        if (modal)
-		{
-			mWindow->setModalState(true);
-			mWindow->setAlwaysOnTop(true);
-            mWindow->moveToFront();
-            mWindow->show();
-		}
-        else
-        {
-       		mWindow->hide();
-        }
-
-		mNormalAlpha = mWindow->getAlpha();
-		mName = mWindow->getName();
-		WindowManager::getSingleton().registerWindow(this);
-		mWindow->subscribeEvent(Window::EventActivated,
-			boost::bind(
-				&rl::WindowManager::handleMovedToFront,
-				rl::WindowManager::getSingletonPtr(),
-				this));
-	}
-
-	AbstractWindow::~AbstractWindow()
-	{
-		mWindow->hide();
-		mWindow->removeAllEvents();
-		WindowManager::getSingleton().unregisterWindow(this);
-		getRoot()->removeChildWindow(mWindow);
-		CEGUI::WindowManager::getSingleton().destroyWindow(mWindow);
-	}
-
-	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile)
-	{
-		CeGuiString prefix = "";
-		return loadWindow(xmlfile, prefix);
-	}
-
-
-	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix)
-	{
-		CeGuiString namePrefix;
-		if (prefix == "")
-			prefix.assign(StringConverter::toString(sNumAbstractWindows));
-		sNumAbstractWindows++;
-
-		CEGUI::Window* window = NULL;
-		try
-		{
-			window = CEGUI::WindowManager::getSingleton().loadWindowLayout(xmlfile, prefix);
-		}
-		catch(...)
-		{
-		}
-
-		return window;
-	}
-
-	bool AbstractWindow::isVisible()
-	{
-		return mVisible;
-	}
-
-	void AbstractWindow::setVisible(bool visible, bool destroy)
-	{
-		if(mVisible != visible)
-		{
-			if (visible)
-			{
-                JobScheduler::getSingleton().addJob(
-                    new WindowFadeJob(this, WindowFadeJob::FADE_IN, mNormalAlpha));
-			}
-			else
-			{
-                JobScheduler::getSingleton().addJob(
-                    new WindowFadeJob(this,
-                    destroy ? WindowFadeJob::FADE_OUT_AND_DESTROY : WindowFadeJob::FADE_OUT,
-                    0.0f));
-			}
-            WindowManager::getSingleton()._visiblityChanged(this, visible);
-            mVisible = visible;
-		}
-	}
-
-	const Ogre::Real& AbstractWindow::getNormalAlpha() const
-	{
-		return mNormalAlpha;
-	}
-
-	bool AbstractWindow::isModal()
-	{
-		return mModal;
-	}
-
-	bool AbstractWindow::isClosingOnEscape()
-	{
-		return mCloseOnEscape;
-	}
-
-	int AbstractWindow::getWindowInputType()
-	{
-		return mWindowInputType;
-	}
-
-	CEGUI::Window* AbstractWindow::getRoot()
-	{
-		return CEGUI::WindowManager::getSingleton().getWindow(
-			(utf8*)UiSubsystem::CEGUI_ROOT);
-	}
-
-	Window* AbstractWindow::getWindow(const char* name, const char* requiredClass)
-	{
-		CEGUI::Window* wnd =
-			CEGUI::WindowManager::getSingleton().getWindow(
-				mNamePrefix + (utf8*)name);
-
-		if (wnd == NULL)
-			Throw(
-				rl::NullPointerException,
-				"Window "
-				+ Ogre::String(name)
-				+ " is NULL");
-
-		if (requiredClass != NULL && !wnd->testClassName(requiredClass))
-			Throw(
-				rl::NullPointerException,
-				"Window "
-				+ Ogre::String(name)
-				+ " has not the required class "
-				+ Ogre::String(requiredClass));
-
-		return wnd;
-	}
-
-	Editbox* AbstractWindow::getEditbox(const char* name)
-	{
-		return static_cast<Editbox*>(getWindow(name, "Editbox"));
-	}
-
-	Listbox* AbstractWindow::getListbox(const char* name)
-	{
-		return static_cast<Listbox*>(getWindow(name, "Listbox"));
-	}
-
-	MultiColumnList* AbstractWindow::getMultiColumnList(const char* name)
-	{
-		return static_cast<MultiColumnList*>(getWindow(name, "MultiColumnList"));
-	}
-
-	MultiLineEditbox* AbstractWindow::getMultiLineEditbox(const char* name)
-	{
-		return static_cast<MultiLineEditbox*>(getWindow(name, "MultiLineEditbox"));
-	}
-
-	ProgressBar* AbstractWindow::getProgressBar(const char* name)
-	{
-		return static_cast<ProgressBar*>(getWindow(name, "ProgressBar"));
-	}
-
-	MenuBase* AbstractWindow::getMenu(const char* name)
-	{
-		return static_cast<MenuBase*>(getWindow(name, "MenuBase"));
-	}
-
-	MenuItem* AbstractWindow::getMenuItem(const char* name)
-	{
-		return static_cast<MenuItem*>(getWindow(name, "MenuItem"));
-	}
-
-	PushButton* AbstractWindow::getPushButton(const char* name)
-	{
-		return static_cast<PushButton*>(getWindow(name, "PushButton"));
-	}
-
-	Combobox* AbstractWindow::getCombobox(const char* name)
-	{
-		return static_cast<Combobox*>(getWindow(name, "Combobox"));
-	}
-
-	ComboDropList* AbstractWindow::getComboDropList(const char* name)
-	{
-		return static_cast<ComboDropList*>(getWindow(name, "ComboDropList"));
-	}
-
-    ScrollablePane* AbstractWindow::getScrollablePane(const char* name)
-    {
-		return static_cast<ScrollablePane*>(getWindow(name, "ScrollablePane"));
-    }
-
-	Slider* AbstractWindow::getSlider(const char* name)
-	{
-		return static_cast<Slider*>(getWindow(name, "Slider"));
-	}
-
-	TabControl* AbstractWindow::getTabControl(const char* name)
-	{
-		return static_cast<TabControl*>(getWindow(name, "TabControl"));
-	}
-
-	const CeGuiString& AbstractWindow::getName() const
-	{
-		return mName;
-	}
-
-	void AbstractWindow::centerWindow()
-	{
-		CEGUI::Size screenSize = System::getSingleton().getRenderer()->getSize();
-		CEGUI::Size windowSize = mWindow->getPixelSize();
-		float x = 0.5f * (screenSize.d_width - windowSize.d_width);
-		float y = 0.5f * (screenSize.d_height - windowSize.d_height);
-		mWindow->setPosition(CeGuiHelper::asAbsolute(CEGUI::Vector2(x, y)));
-	}
-
-	void AbstractWindow::bindDestroyWindowToClick(CEGUI::Window* button)
-	{
-		button->subscribeEvent(Window::EventMouseClick,
-			boost::bind(&AbstractWindow::destroyWindow, this));
-	}
-
-    void AbstractWindow::bindHideWindowToClick(CEGUI::Window* button)
-	{
-		button->subscribeEvent(Window::EventMouseClick,
-			boost::bind(&AbstractWindow::hideWindow, this));
-	}
-
-	void AbstractWindow::bindDestroyWindowToXButton()
-	{
-		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
-			boost::bind(&AbstractWindow::destroyWindow, this));
-	}
-
-	void AbstractWindow::bindHideWindowToXButton()
-	{
-		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
-			boost::bind(&AbstractWindow::hideWindow, this));
-	}
-
-	bool AbstractWindow::destroyWindow()
-	{
-		setVisible(false, true);
-		return true;
-	}
-
-	bool AbstractWindow::hideWindow()
-	{
-		setVisible(false);
-		return true;
-	}
-
-	CEGUI::Window* AbstractWindow::getWindow()
-	{
-		return mWindow;
-	}
-
-	const CeGuiString& AbstractWindow::getNamePrefix() const
-	{
-		return mNamePrefix;
-	}
-
-	void AbstractWindow::windowHid()
-	{
-	}
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include <boost/bind.hpp>
+#include <CEGUIWindowManager.h>
+#include <elements/CEGUIFrameWindow.h>
+
+#include "UiPrerequisites.h"
+#include "Exception.h"
+
+#include "UiSubsystem.h"
+#include "AbstractWindow.h"
+#include "CeGuiHelper.h"
+#include "WindowManager.h"
+#include "WindowFadeJob.h"
+#include "JobScheduler.h"
+
+using namespace std;
+using namespace CEGUI;
+using namespace Ogre;
+
+namespace rl
+{
+
+	int AbstractWindow::sNumAbstractWindows = 0;
+
+	AbstractWindow::AbstractWindow(const CeGuiString& xmlfile, int inputType, bool closeOnEscape, bool modal)
+	: mVisible(false),
+		mModal(modal),
+		mWindowInputType(inputType),
+		mCloseOnEscape(closeOnEscape)
+	{
+        LOG_MESSAGE(Logger::UI,
+		    "Lade Fenster '" + Ogre::String(xmlfile.c_str()) + "'");
+   		mWindow = AbstractWindow::loadWindow(xmlfile, mNamePrefix);
+		if (mWindow == NULL)
+		{
+			Throw(rl::IllegalStateException, Ogre::String("Could not load window '")+xmlfile.c_str()+"'.");
+		}
+
+		getRoot()->addChildWindow(mWindow);
+
+        if (modal)
+		{
+			mWindow->setModalState(true);
+			mWindow->setAlwaysOnTop(true);
+            mWindow->moveToFront();
+            mWindow->show();
+		}
+        else
+        {
+       		mWindow->hide();
+        }
+
+		mNormalAlpha = mWindow->getAlpha();
+		mName = mWindow->getName();
+		WindowManager::getSingleton().registerWindow(this);
+		mWindow->subscribeEvent(Window::EventActivated,
+			boost::bind(
+				&rl::WindowManager::handleMovedToFront,
+				rl::WindowManager::getSingletonPtr(),
+				this));
+	}
+
+	AbstractWindow::~AbstractWindow()
+	{
+		mWindow->hide();
+		mWindow->removeAllEvents();
+		WindowManager::getSingleton().unregisterWindow(this);
+		getRoot()->removeChildWindow(mWindow);
+		CEGUI::WindowManager::getSingleton().destroyWindow(mWindow);
+	}
+
+	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile)
+	{
+		CeGuiString prefix = "";
+		return loadWindow(xmlfile, prefix);
+	}
+
+
+	CEGUI::Window* AbstractWindow::loadWindow(const CeGuiString& xmlfile, CeGuiString& prefix)
+	{
+		CeGuiString namePrefix;
+		if (prefix == "")
+			prefix.assign(StringConverter::toString(sNumAbstractWindows));
+		sNumAbstractWindows++;
+
+		CEGUI::Window* window = NULL;
+		try
+		{
+			window = CEGUI::WindowManager::getSingleton().loadWindowLayout(xmlfile, prefix);
+		}
+		catch(...)
+		{
+		}
+
+		return window;
+	}
+
+	bool AbstractWindow::isVisible()
+	{
+		return mVisible;
+	}
+
+	void AbstractWindow::setVisible(bool visible, bool destroy)
+	{
+		if(mVisible != visible)
+		{
+			if (visible)
+			{
+                JobScheduler::getSingleton().addJob(
+                    new WindowFadeJob(this, WindowFadeJob::FADE_IN, mNormalAlpha));
+			}
+			else
+			{
+                JobScheduler::getSingleton().addJob(
+                    new WindowFadeJob(this,
+                    destroy ? WindowFadeJob::FADE_OUT_AND_DESTROY : WindowFadeJob::FADE_OUT,
+                    0.0f));
+			}
+            WindowManager::getSingleton()._visiblityChanged(this, visible);
+            mVisible = visible;
+		}
+	}
+
+	const Ogre::Real& AbstractWindow::getNormalAlpha() const
+	{
+		return mNormalAlpha;
+	}
+
+	bool AbstractWindow::isModal()
+	{
+		return mModal;
+	}
+
+	bool AbstractWindow::isClosingOnEscape()
+	{
+		return mCloseOnEscape;
+	}
+
+	int AbstractWindow::getWindowInputType()
+	{
+		return mWindowInputType;
+	}
+
+	CEGUI::Window* AbstractWindow::getRoot()
+	{
+		return CEGUI::WindowManager::getSingleton().getWindow(
+			(utf8*)UiSubsystem::CEGUI_ROOT);
+	}
+
+	Window* AbstractWindow::getWindow(const char* name, const char* requiredClass)
+	{
+		CEGUI::Window* wnd =
+			CEGUI::WindowManager::getSingleton().getWindow(
+				mNamePrefix + (utf8*)name);
+
+		if (wnd == NULL)
+			Throw(
+				rl::NullPointerException,
+				"Window "
+				+ Ogre::String(name)
+				+ " is NULL");
+
+		if (requiredClass != NULL && !wnd->testClassName(requiredClass)) {
+            Throw(
+				rl::NullPointerException,
+				"Window "
+				+ Ogre::String(name)
+				+ " has not the required class "
+				+ Ogre::String(requiredClass));
+        }
+
+		return wnd;
+	}
+
+	Editbox* AbstractWindow::getEditbox(const char* name)
+	{
+		return static_cast<Editbox*>(getWindow(name, "Editbox"));
+	}
+    
+	Checkbox* AbstractWindow::getCheckbox(const char* name)
+	{
+		return static_cast<Checkbox*>(getWindow(name, "Checkbox"));
+	}
+    
+	Listbox* AbstractWindow::getListbox(const char* name)
+	{
+		return static_cast<Listbox*>(getWindow(name, "Listbox"));
+	}
+
+	MultiColumnList* AbstractWindow::getMultiColumnList(const char* name)
+	{
+		return static_cast<MultiColumnList*>(getWindow(name, "MultiColumnList"));
+	}
+
+	MultiLineEditbox* AbstractWindow::getMultiLineEditbox(const char* name)
+	{
+		return static_cast<MultiLineEditbox*>(getWindow(name, "MultiLineEditbox"));
+	}
+
+	ProgressBar* AbstractWindow::getProgressBar(const char* name)
+	{
+		return static_cast<ProgressBar*>(getWindow(name, "ProgressBar"));
+	}
+
+	MenuBase* AbstractWindow::getMenu(const char* name)
+	{
+		return static_cast<MenuBase*>(getWindow(name, "MenuBase"));
+	}
+
+	MenuItem* AbstractWindow::getMenuItem(const char* name)
+	{
+		return static_cast<MenuItem*>(getWindow(name, "MenuItem"));
+	}
+
+	PushButton* AbstractWindow::getPushButton(const char* name)
+	{
+		return static_cast<PushButton*>(getWindow(name, "PushButton"));
+	}
+
+	Combobox* AbstractWindow::getCombobox(const char* name)
+	{
+		return static_cast<Combobox*>(getWindow(name, "Combobox"));
+	}
+
+	ComboDropList* AbstractWindow::getComboDropList(const char* name)
+	{
+		return static_cast<ComboDropList*>(getWindow(name, "ComboDropList"));
+	}
+
+    ScrollablePane* AbstractWindow::getScrollablePane(const char* name)
+    {
+		return static_cast<ScrollablePane*>(getWindow(name, "ScrollablePane"));
+    }
+
+	Slider* AbstractWindow::getSlider(const char* name)
+	{
+		return static_cast<Slider*>(getWindow(name, "Slider"));
+	}
+
+	TabControl* AbstractWindow::getTabControl(const char* name)
+	{
+		return static_cast<TabControl*>(getWindow(name, "TabControl"));
+	}
+
+	const CeGuiString& AbstractWindow::getName() const
+	{
+		return mName;
+	}
+
+	void AbstractWindow::centerWindow()
+	{
+		CEGUI::Size screenSize = System::getSingleton().getRenderer()->getSize();
+		CEGUI::Size windowSize = mWindow->getPixelSize();
+		float x = 0.5f * (screenSize.d_width - windowSize.d_width);
+		float y = 0.5f * (screenSize.d_height - windowSize.d_height);
+		mWindow->setPosition(CeGuiHelper::asAbsolute(CEGUI::Vector2(x, y)));
+	}
+
+	void AbstractWindow::bindDestroyWindowToClick(CEGUI::Window* button)
+	{
+		button->subscribeEvent(Window::EventMouseClick,
+			boost::bind(&AbstractWindow::destroyWindow, this));
+	}
+
+    void AbstractWindow::bindHideWindowToClick(CEGUI::Window* button)
+	{
+		button->subscribeEvent(Window::EventMouseClick,
+			boost::bind(&AbstractWindow::hideWindow, this));
+	}
+
+	void AbstractWindow::bindDestroyWindowToXButton()
+	{
+		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
+			boost::bind(&AbstractWindow::destroyWindow, this));
+	}
+
+	void AbstractWindow::bindHideWindowToXButton()
+	{
+		mWindow->subscribeEvent(FrameWindow::EventCloseClicked,
+			boost::bind(&AbstractWindow::hideWindow, this));
+	}
+
+	bool AbstractWindow::destroyWindow()
+	{
+		setVisible(false, true);
+		return true;
+	}
+
+	bool AbstractWindow::hideWindow()
+	{
+		setVisible(false);
+		return true;
+	}
+
+	CEGUI::Window* AbstractWindow::getWindow()
+	{
+		return mWindow;
+	}
+
+	const CeGuiString& AbstractWindow::getNamePrefix() const
+	{
+		return mNamePrefix;
+	}
+
+	void AbstractWindow::windowHid()
+	{
+	}
+
+}

Copied: rl/branches/newton20/engine/ui/src/CharacterSelectionWindow.cpp (from rev 4613, rl/trunk/engine/ui/src/CharacterSelectionWindow.cpp)

Modified: rl/branches/newton20/engine/ui/src/CharacterStateWindow.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/CharacterStateWindow.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/CharacterStateWindow.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -1,118 +1,134 @@
-/* This source file is part of Rastullahs Lockenpracht.
- * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the Clarified Artistic License.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  Clarified Artistic License for more details.
- *
- *  You should have received a copy of the Clarified Artistic License
- *  along with this program; if not you can get it here
- *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
- */
-#include "stdinc.h" //precompiled header
-
-#include <boost/bind.hpp>
-#include "UiPrerequisites.h"
-
-#include "DsaManager.h"
-#include "Creature.h"
-#include "InputManager.h"
-#include "Talent.h"
-
-#include "CharacterStateWindow.h"
-
-using namespace CEGUI;
-using namespace Ogre;
-
-
-namespace rl {
-
-CharacterStateWindow::CharacterStateWindow()
-: AbstractWindow("characterstatewindow.xml", WIT_NONE, false),
-	mCharacter(NULL)
-{
-	mLP = getProgressBar("CharacterStateWindow/LP");
-	mAP = getProgressBar("CharacterStateWindow/AP");
-	mAU = getProgressBar("CharacterStateWindow/AU");
-	mName = getWindow("CharacterStateWindow/Name");
-}
-
-CharacterStateWindow::~CharacterStateWindow()
-{
-    if (mCharacter != NULL)
-		mCharacter->removeObjectStateChangeListener(this);
-}
-
-void CharacterStateWindow::setCharacter(Creature* person)
-{
-	if (mCharacter != NULL)
-		mCharacter->removeObjectStateChangeListener(this);
-
-	mCharacter = person;
-    if(mCharacter)
-        mCharacter->addObjectStateChangeListener(this);
-	update();
-}
-
-void CharacterStateWindow::update()
-{
-	if (!isVisible())
-		return;
-	if (mCharacter == NULL)
-		return;
-
-	mName->setText(mCharacter->getName());
-
-	float lep;
-	if (mCharacter->getLeMax() <= 0)
-		lep = 0.0;
-	else
-		lep = (float)mCharacter->getLe() / (float)mCharacter->getLeMax();
-	mLP->setProgress(lep);
-
-	float au;
-	if (mCharacter->getAuMax() <= 0)
-		au = 0.0;
-	else
-		au = (float)mCharacter->getAu() / (float)mCharacter->getAuMax();
-	mAU->setProgress(au);
-
-	if (!mCharacter->isMagic())
-	{
-		if (mAP->isVisible())
-			mAP->setVisible(false);
-		return;
-	}
-
-	if (!mAP->isVisible())
-		mAP->setVisible(true);
-
-	float asp;
-	if (mCharacter->getAeMax() <= 0)
-		asp = 0.0;
-	else
-		asp = (float)mCharacter->getAe() / (float)mCharacter->getAeMax();
-	mAP->setProgress(asp);
-
-}
-
-void CharacterStateWindow::objectStateChanged(ObjectStateChangeEvent* evt)
-{
-	update();
-}
-
-void CharacterStateWindow::setVisible(bool visible, bool destroyAfterHide)
-{
-	AbstractWindow::setVisible(visible, destroyAfterHide);
-	if (visible)
-	{
-		update();
-	}
-}
-
-
-}
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2008 Team Pantheon. http://www.team-pantheon.de
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  http://www.jpaulmorrison.com/fbp/artistic2.htm.
+ */
+#include "stdinc.h" //precompiled header
+
+#include <boost/bind.hpp>
+#include "UiPrerequisites.h"
+
+#include "DsaManager.h"
+#include "Creature.h"
+#include "InputManager.h"
+#include "Talent.h"
+
+#include "CharacterStateWindow.h"
+
+using namespace CEGUI;
+using namespace Ogre;
+
+
+namespace rl {
+
+CharacterStateWindow::CharacterStateWindow()
+: AbstractWindow("characterstatewindow.xml", WIT_NONE, false),
+	mCharacter(NULL)
+{
+	mLP = getProgressBar("CharacterStateWindow/LP");
+	mAP = getProgressBar("CharacterStateWindow/AP");
+	mAU = getProgressBar("CharacterStateWindow/AU");
+	mName = getWindow("CharacterStateWindow/Name");
+}
+
+CharacterStateWindow::~CharacterStateWindow()
+{
+    if (mCharacter != NULL)
+		mCharacter->removeObjectStateChangeListener(this);
+}
+
+void CharacterStateWindow::setCharacter(Creature* person)
+{
+	if (mCharacter != NULL)
+		mCharacter->removeObjectStateChangeListener(this);
+
+	mCharacter = person;
+    if(mCharacter)
+        mCharacter->addObjectStateChangeListener(this);
+	update();
+}
+
+void CharacterStateWindow::update()
+{
+	if (!isVisible() || mCharacter == NULL)
+    {
+		return;
+    }
+        
+	mName->setText(mCharacter->getName());
+
+	float lep;
+	if (mCharacter->getLeMax() <= 0)
+    {
+		lep = 0.0;        
+    }
+	else
+    {
+		lep = (float)mCharacter->getLe() / (float)mCharacter->getLeMax();        
+    }
+	mLP->setProgress(lep);
+
+	float au;
+	if (mCharacter->getAuMax() <= 0)
+    {
+		au = 0.0;        
+    }
+	else
+    {
+		au = (float)mCharacter->getAu() / (float)mCharacter->getAuMax();        
+    }
+	mAU->setProgress(au);
+
+	if (!mCharacter->isMagic())
+	{
+		if (mAP->isVisible()) 
+        {
+			mAP->setVisible(false);            
+        }
+	}
+    else 
+    {
+     	if (!mAP->isVisible()) 
+        {
+            mAP->setVisible(true);            
+        }
+        
+        float asp;
+        if (mCharacter->getAeMax() <= 0)
+        {
+            asp = 0.0;
+        }
+        else
+        {
+            asp = (float)mCharacter->getAe() / (float)mCharacter->getAeMax();
+        }
+        mAP->setProgress(asp);        
+    }
+}
+
+void CharacterStateWindow::objectStateChanged(ObjectStateChangeEvent* evt)
+{
+	update();
+}
+
+void CharacterStateWindow::setVisible(bool visible, bool destroyAfterHide)
+{
+	AbstractWindow::setVisible(visible, destroyAfterHide);
+	if (visible)
+	{
+		update();
+	}
+}
+
+
+}

Modified: rl/branches/newton20/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/CombatControlState.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/CombatControlState.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -318,14 +318,14 @@
         int n = 0;
         Vector3 pos = Vector3::ZERO;
 
-        const Combat::CombatantSet &allies (mCombat->getAllAllies() );
+        const Combat::CombatantSet &allies (mCombat->getAllPlayerAllies() );
         for(Combat::CombatantSet::iterator it = allies.begin(); it != allies.end(); it++)
         {
             pos += (*it)->getCreature()->getPosition();
             n++;
         }
 
-        const Combat::CombatantSet &opponents (mCombat->getAllOpponents());
+        const Combat::CombatantSet &opponents (mCombat->getAllPlayerOpponents());
         for(Combat::CombatantSet::iterator it = opponents.begin(); it != opponents.end(); it++)
         {
             pos += (*it)->getCreature()->getPosition();
@@ -346,12 +346,12 @@
     {
         // get the greatest distance from center from all persons
         Real distance = 0;
-        const Combat::CombatantSet &allies (mCombat->getAllAllies() );
+        const Combat::CombatantSet &allies (mCombat->getAllPlayerAllies() );
         for(Combat::CombatantSet::iterator it = allies.begin(); it != allies.end(); it++)
         {
             distance = std::max( ( (*it)->getCreature()->getPosition() - center ).length(), distance );
         }
-        const Combat::CombatantSet &opponents = mCombat->getAllOpponents();
+        const Combat::CombatantSet &opponents = mCombat->getAllPlayerOpponents();
         for(Combat::CombatantSet::iterator it = opponents.begin(); it != opponents.end(); it++)
         {
             distance = std::max( ( (*it)->getCreature()->getPosition() - center ).length(), distance );

Modified: rl/branches/newton20/engine/ui/src/CombatGui.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/CombatGui.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/CombatGui.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -37,7 +37,8 @@
 		  mCombat(combat),
 		  mCamera(camera),
 		  mUserInputEnabled(false),
-		  mGameLoggerWindowOpened(false)
+		  mGameLoggerWindowOpened(false),
+          mVisible(false)
     {
         mCombatWindow = WindowFactory::getSingleton().getCombatWindow();
 		mGameLoggerWindow = WindowFactory::getSingleton().getGameLogger();
@@ -68,7 +69,7 @@
         sceneMgr->getRootSceneNode()->createChildSceneNode()->attachObject(mHud);
 
 		// Create an attack/parry/(goto) button set for all opponents present at the beginning.
-        const Combat::CombatantSet& opponents = mCombat->getAllOpponents();
+        const Combat::CombatantSet& opponents = mCombat->getAllPlayerOpponents();
         for (Combat::CombatantSet::const_iterator it = opponents.begin(), end = opponents.end();
             it != end; ++it)
         {
@@ -82,6 +83,7 @@
 	CombatGui::~CombatGui()
 	{
 		hide();
+        mHud->getParentSceneNode()->detachObject(mHud);
         SceneManager* sceneMgr = CoreSubsystem::getSingleton().getWorld()->getSceneManager();
 		sceneMgr->destroyManualObject(mHud);
 	}
@@ -96,7 +98,7 @@
         mHud->clear();
 
         mHud->begin("alpha_red", RenderOperation::OT_LINE_LIST);
-        const Combat::CombatantSet& opponents = mCombat->getAllOpponents();
+        const Combat::CombatantSet& opponents = mCombat->getAllPlayerOpponents();
         for (Combat::CombatantSet::const_iterator it = opponents.begin(), end = opponents.end();
             it != end; ++it)
         {
@@ -161,16 +163,25 @@
 
 	void CombatGui::show()
 	{
-		mGameLoggerWindowOpened = !mGameLoggerWindow->isVisible();
-        mCombatWindow->setVisible(true);
-		mGameLoggerWindow->setVisible(true);
+        if (!mVisible)
+        {
+		    mGameLoggerWindowOpened = !mGameLoggerWindow->isVisible();
+            mCombatWindow->setVisible(true);
+		    mGameLoggerWindow->setVisible(true);
+            mHud->setVisible(true);
+            mVisible = true;
+        }
 	}
 
 	void CombatGui::hide()
 	{
-        mCombatWindow->setVisible(false);
-		mGameLoggerWindow->setVisible(!mGameLoggerWindowOpened);
-		mHud->clear();
+        if (mVisible)
+        {
+            mCombatWindow->setVisible(false);
+		    mGameLoggerWindow->setVisible(!mGameLoggerWindowOpened);
+            mHud->setVisible(false);
+            mVisible = false;
+        }
 	}
 
 	bool CombatGui::enemyButtonClicked(int handle, int buttonIndex)

Modified: rl/branches/newton20/engine/ui/src/DebugWindow.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/DebugWindow.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/DebugWindow.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -186,8 +186,8 @@
 
             if( charObj != NULL )
             {
-                Ogre::Vector3 pos = charObj->getMovableObject()->getParentNode()->getWorldPosition();
-                Ogre::Quaternion ori = charObj->getMovableObject()->getParentNode()->getWorldOrientation();
+                Ogre::Vector3 pos = charObj->getMovableObject()->getParentNode()->_getDerivedPosition();
+                Ogre::Quaternion ori = charObj->getMovableObject()->getParentNode()->_getDerivedOrientation();
 
                 textSt += "\nPlayer Position [ "
                     + StringConverter::toString(pos.x,2,0,32,std::ios_base::fixed)+", "

Modified: rl/branches/newton20/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/DialogControlState.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/DialogControlState.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -220,8 +220,8 @@
 
         // Weltkoordinaten in lokale umwandeln
         mTargetCameraPosition =
-            -1*(mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldOrientation().Inverse()*
-            (mCameraActor->_getSceneNode()->getParentSceneNode()->getWorldPosition() - globalCameraPosition));
+            -1*(mCameraActor->_getSceneNode()->getParentSceneNode()->_getDerivedOrientation().Inverse()*
+            (mCameraActor->_getSceneNode()->getParentSceneNode()->_getDerivedPosition() - globalCameraPosition));
 
         mTargetCameraDirection = (listenerEyes - mTargetCameraPosition).normalisedCopy();
     }

Modified: rl/branches/newton20/engine/ui/src/GameSettings.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/GameSettings.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/GameSettings.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -25,6 +25,8 @@
 #include "SoundManager.h"
 #include "SoundDriver.h"
 
+using namespace Ogre;
+
 namespace rl
 {
     GameSettings::GameSettings()
@@ -46,8 +48,12 @@
         getWindow()->subscribeEvent(CEGUI::FrameWindow::EventCloseClicked,
                                     boost::bind(&GameSettings::onCancel, this));
 
+        mVideoRenderer = getCombobox("GameOptionsWindow/Video/Renderer");
+        mVideoResolution = getCombobox("GameOptionsWindow/Video/Resolution");
+        mVideoFullscreen = getCheckbox("GameOptionsWindow/Video/Fullscreen");
         centerWindow();
         setVisible(false);
+        update();
     }
 
     GameSettings::~GameSettings()
@@ -127,4 +133,54 @@
     {
         return true;
     }
+    
+    void GameSettings::update()
+    {
+        Root* root = Ogre::Root::getSingletonPtr();
+        RenderSystem* renderer = root->getRenderSystem();
+        
+        ConfigOptionMap config = renderer->getConfigOptions();
+        
+		ConfigOptionMap::iterator cfi;
+		
+		cfi = config.find( "Full Screen" );
+		if( cfi != config.end() )
+		{
+			mVideoFullscreen->setSelected(cfi->second.currentValue == "Yes");
+		}
+        
+/*		cfi = config.find( "FSAA" );
+		if( cfi != config.end() )
+		{
+			if( cfi->second.currentValue == "0" )
+			{
+				SetControlValue( iFSAARef, 1 );
+			}
+			else if( cfi->second.currentValue == "2" )
+			{
+				SetControlValue( iFSAARef, 2 );
+			}
+			else if( cfi->second.currentValue == "4" )
+			{
+				SetControlValue( iFSAARef, 3 );
+			}
+			else if( cfi->second.currentValue == "6" )
+			{
+				SetControlValue( iFSAARef, 4 );
+			}
+		}
+        
+		cfi = config.find( "Colour Depth" );
+		if( cfi != config.end() )
+		{
+			if( cfi->second.currentValue == "32" )
+			{
+				SetControlValue( iColorDepthRef, 1 );
+			}
+			else
+			{
+				SetControlValue( iColorDepthRef, 2 );
+			}
+		}*/
+    }
 }

Modified: rl/branches/newton20/engine/ui/src/InputManager.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/InputManager.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/InputManager.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -446,7 +446,10 @@
     {
         while (!mControlStates.empty())
         {
-            popControlState();
+            ControlState* controller = mControlStates.top();
+            mControlStates.pop();
+            controller->pause();
+            mFinishedControlStates.push_back(controller);
         }
     }
 

Modified: rl/branches/newton20/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/InventoryWindow.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/InventoryWindow.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -175,7 +175,6 @@
     ItemDragContainer* InventoryWindow::getItemDragContainer(const Item* item, bool description)
     {
 		CeGuiString dragContainerName = getDragContainerNameFromItem(item, description);
-		ItemDragContainer* itemhandler = NULL;
 
 		DndContainerMap::iterator iter = mWorldDragContainers.find(dragContainerName);
         if( iter != mWorldDragContainers.end() )
@@ -453,7 +452,7 @@
 		mousePos.d_y /= getRoot()->getPixelSize().d_height;
 		Ogre::Ray camToWorld = camera->getCameraToViewportRay(
 			mousePos.d_x, mousePos.d_y);
-		Ogre::Vector3 rayStart = camera->getCamera()->getWorldPosition();
+		Ogre::Vector3 rayStart = camera->getCamera()->getDerivedPosition();
 		Ogre::Vector3 rayDir = camera->getDirectionFromScreenPosition(
 			mousePos.d_x, mousePos.d_y);
 

Modified: rl/branches/newton20/engine/ui/src/Makefile.am
===================================================================
--- rl/branches/newton20/engine/ui/src/Makefile.am	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/Makefile.am	2008-11-30 22:46:52 UTC (rev 4616)
@@ -13,6 +13,7 @@
     AbstractWindow.cpp \
     CharacterSheetWindow.cpp \
     CharacterStateWindow.cpp \
+	CharacterSelectionWindow.cpp \
     CloseConfirmationWindow.cpp \
     CombatControlState.cpp \
     CombatGui.cpp \

Modified: rl/branches/newton20/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/branches/newton20/engine/ui/src/WindowFactory.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/engine/ui/src/WindowFactory.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -20,6 +20,7 @@
 #include "AboutWindow.h"
 #include "ActionChoiceWindow.h"
 #include "ActorManager.h"
+#include "CharacterSelectionWindow.h"
 #include "CharacterSheetWindow.h"
 #include "CharacterStateWindow.h"
 #include "CloseConfirmationWindow.h"
@@ -85,7 +86,8 @@
         mMainMenuWindow(NULL),
 		mMainMenuLoadWindow(NULL),
         mGameSettings(NULL),
-        mCombatWindow(NULL)
+        mCombatWindow(NULL),
+        mCharacterSelectionWindow(NULL)
     {
     }
 
@@ -111,6 +113,8 @@
         RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mJournalWindow);
         //RulesSubsystem::getSingleton().getQuestBook()->addQuestListener(mInfoPopup);
         mMainMenuWindow = new MainMenuWindow( new MainMenuEngineWindow() );
+        
+        mCharacterSelectionWindow = new CharacterSelectionWindow();
 
         logAllWindows();
     }
@@ -294,7 +298,13 @@
     {
         mCharacterStateWindow->setVisible(!mCharacterStateWindow->isVisible());
     }
-
+    
+    void WindowFactory::toggleCharacterSelectionWindow()
+    {
+        mCharacterSelectionWindow->setVisible(!mCharacterSelectionWindow->isVisible());
+        mCharacterSelectionWindow->update();
+    }
+    
     void WindowFactory::toggleInGameGlobalMenu()
     {
         mInGameMenuWindow->setVisible(!mInGameMenuWindow->isVisible());

Copied: rl/branches/newton20/plugins/CMakeLists.txt (from rev 4613, rl/trunk/plugins/CMakeLists.txt)

Copied: rl/branches/newton20/plugins/fmod4driver/CMakeLists.txt (from rev 4613, rl/trunk/plugins/fmod4driver/CMakeLists.txt)

Modified: rl/branches/newton20/plugins/fmod4driver/include/Fmod4Driver.h
===================================================================
--- rl/branches/newton20/plugins/fmod4driver/include/Fmod4Driver.h	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/plugins/fmod4driver/include/Fmod4Driver.h	2008-11-30 22:46:52 UTC (rev 4616)
@@ -137,9 +137,8 @@
         static FMOD_RESULT F_CALLBACK channelCallback(
             FMOD_CHANNEL* channel,
             FMOD_CHANNEL_CALLBACKTYPE type,
-            int command,
-            unsigned int commanddata1,
-            unsigned int commanddata2
+            void* commanddata1,
+            void* commanddata2
         );
 
         typedef std::map<const Ogre::String, FMOD_REVERB_PROPERTIES> EaxPresetMap;

Modified: rl/branches/newton20/plugins/fmod4driver/src/Fmod4Driver.cpp
===================================================================
--- rl/branches/newton20/plugins/fmod4driver/src/Fmod4Driver.cpp	2008-11-30 21:28:14 UTC (rev 4615)
+++ rl/branches/newton20/plugins/fmod4driver/src/Fmod4Driver.cpp	2008-11-30 22:46:52 UTC (rev 4616)
@@ -209,17 +209,22 @@
 
         int numPlugins;
         mFmod4System->getNumPlugins(FMOD_PLUGINTYPE_CODEC, &numPlugins);
-        for (int i = 0; i < numDrivers; i++)
+        for (int i = 0; i < numPlugins; i++)
         {
             char pluginName[128];
             unsigned int version;
+			FMOD_PLUGINTYPE type = FMOD_PLUGINTYPE_CODEC;
+			unsigned int handle;
+			FMOD_RESULT result = mFmod4System->getPluginHandle(FMOD_PLUGINTYPE_CODEC, i, &handle);
+			CHECK_FMOD4_ERRORS(result);
 
-            mFmod4System->getPluginInfo(
-                FMOD_PLUGINTYPE_CODEC,
-                i,
-                pluginName,
+            result = mFmod4System->getPluginInfo(
+                handle,
+                &type,
+				pluginName,
                 127,
                 &version);
+			CHECK_FMOD4_ERRORS(result);
             LOG_MESSAGE(Logger::MULTIMEDIA,
                 String("Fmod4Driver Plugin '")
                 + pluginName
@@ -407,9 +412,8 @@
 FMOD_RESULT F_CALLBACK Fmod4Driver::channelCallback(
     FMOD_CHANNEL *_channel,
     FMOD_CHANNEL_CALLBACKTYPE type,
-    int command,
-    unsigned int commanddata1, 
-    unsigned int commanddata2)
+    void* commanddata1, 
+    void* commanddata2)
 {
     /// Extract the Fmod channel and then our Sound object.
     FMOD::Channel* channel = (FMOD::Channel*)_channel;
@@ -444,7 +448,7 @@
         
                     // We get the time point of the sync point and put it in a timing event.
                     sound->getFmodChannel()->getCurrentSound(&fmodsound);
-                    fmodsound->getSyncPoint(commanddata1, &syncpoint);
+                    fmodsound->getSyncPoint(*static_cast<int*>(commanddata1), &syncpoint);
                     fmodsound->getSyncPointInfo(syncpoint, NULL, 0, &event.mTime, FMOD_TIMEUNIT_MS);
                     sound->dispatchEvent(&event);
                 }
@@ -480,12 +484,8 @@
 
     void Fmod4Driver::_registerChannel(FMOD::Channel* channel, Fmod4Sound* sound)
     {
-        FMOD_RESULT res = channel->setCallback(FMOD_CHANNEL_CALLBACKTYPE_END, channelCallback, 0);
+        FMOD_RESULT res = channel->setCallback(channelCallback);
         CHECK_FMOD4_ERRORS(res);
-        res = channel->setCallback(FMOD_CHANNEL_CALLBACKTYPE_SYNCPOINT, channelCallback, 0);
-        CHECK_FMOD4_ERRORS(res);
-        res = channel->setCallback(FMOD_CHANNEL_CALLBACKTYPE_VIRTUALVOICE, channelCallback, 0);
-        CHECK_FMOD4_ERRORS(res);
         mChannelSoundMap.insert(std::make_pair(channel, sound));
     }
 



