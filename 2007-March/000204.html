<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r3133 - in rl/trunk: . engine/ai engine/ai/include	engine/ai/src engine/script/swig
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-March/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3133%20-%20in%20rl/trunk%3A%20.%20engine/ai%20engine/ai/include%0A%09engine/ai/src%20engine/script/swig&In-Reply-To=%3C200703062107.l26L7NSV004861%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000203.html">
   <LINK REL="Next"  HREF="000205.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r3133 - in rl/trunk: . engine/ai engine/ai/include	engine/ai/src engine/script/swig</H1>
    <B>natoka at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3133%20-%20in%20rl/trunk%3A%20.%20engine/ai%20engine/ai/include%0A%09engine/ai/src%20engine/script/swig&In-Reply-To=%3C200703062107.l26L7NSV004861%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r3133 - in rl/trunk: . engine/ai engine/ai/include	engine/ai/src engine/script/swig">natoka at mail.berlios.de
       </A><BR>
    <I>Tue Mar  6 22:07:23 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000203.html">[Dsa-hl-svn] r3132 - rl/trunk/engine/ui/src
</A></li>
        <LI>Next message: <A HREF="000205.html">[Dsa-hl-svn] r3134 - in rl/trunk/engine: ai/include ai/src	script/swig
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#204">[ date ]</a>
              <a href="thread.html#204">[ thread ]</a>
              <a href="subject.html#204">[ subject ]</a>
              <a href="author.html#204">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: natoka
Date: 2007-03-06 22:07:05 +0100 (Tue, 06 Mar 2007)
New Revision: 3133

Added:
   rl/trunk/engine/ai/include/AStar.h
   rl/trunk/engine/ai/include/AStarCosts.h
   rl/trunk/engine/ai/include/AStarHeuristic.h
   rl/trunk/engine/ai/include/AStarNodePool.h
   rl/trunk/engine/ai/include/AStarWayPointNode.h
   rl/trunk/engine/ai/src/AStar.cpp
   rl/trunk/engine/ai/src/AStarCosts.cpp
   rl/trunk/engine/ai/src/AStarHeuristic.cpp
   rl/trunk/engine/ai/src/AStarNodePool.cpp
   rl/trunk/engine/ai/src/AStarWayPointNode.cpp
Modified:
   rl/trunk/Rastullah2005.sln
   rl/trunk/engine/ai/RlAI2005.vcproj
   rl/trunk/engine/ai/include/WayPointGraph.h
   rl/trunk/engine/ai/src/WayPointGraph.cpp
   rl/trunk/engine/script/swig/RlAi.head.swig
   rl/trunk/engine/script/swig/RlAi.swig
Log:
adding AStar algorithm to rlai
fixed the slow down bug of WayPointGraph by introducing a flag that prevents recreation of the lines when nothing has changed.



Modified: rl/trunk/Rastullah2005.sln
===================================================================
--- rl/trunk/Rastullah2005.sln	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/Rastullah2005.sln	2007-03-06 21:07:05 UTC (rev 3133)
@@ -9,70 +9,71 @@
 EndProject
 Project(&quot;{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}&quot;) = &quot;RlDialog&quot;, &quot;engine\dialog\RlDialog2005.vcproj&quot;, &quot;{6361481B-A6D5-4BC2-826C-C26A49C631A8}&quot;
 	ProjectSection(ProjectDependencies) = postProject
+		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
+		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
-		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 	EndProjectSection
 EndProject
 Project(&quot;{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}&quot;) = &quot;RlRules&quot;, &quot;engine\rules\RlRules2005.vcproj&quot;, &quot;{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}&quot;
 	ProjectSection(ProjectDependencies) = postProject
+		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 	EndProjectSection
 EndProject
 Project(&quot;{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}&quot;) = &quot;RlScript&quot;, &quot;engine\script\RlScript2005.vcproj&quot;, &quot;{9A41EAE4-302A-4823-8F20-FA1AD58189A1}&quot;
 	ProjectSection(ProjectDependencies) = postProject
+		{53FE20F3-E726-44FE-BBEC-D29CAE210D25} = {53FE20F3-E726-44FE-BBEC-D29CAE210D25}
+		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
+		{ED15F1B3-8B3B-40D1-8F56-5399B2E5E851} = {ED15F1B3-8B3B-40D1-8F56-5399B2E5E851}
+		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
+		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
+		{C3E78B89-587B-499A-BE7D-4FE8564F0CD7} = {C3E78B89-587B-499A-BE7D-4FE8564F0CD7}
 		{6361481B-A6D5-4BC2-826C-C26A49C631A8} = {6361481B-A6D5-4BC2-826C-C26A49C631A8}
-		{C3E78B89-587B-499A-BE7D-4FE8564F0CD7} = {C3E78B89-587B-499A-BE7D-4FE8564F0CD7}
-		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
-		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
-		{ED15F1B3-8B3B-40D1-8F56-5399B2E5E851} = {ED15F1B3-8B3B-40D1-8F56-5399B2E5E851}
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
-		{53FE20F3-E726-44FE-BBEC-D29CAE210D25} = {53FE20F3-E726-44FE-BBEC-D29CAE210D25}
 	EndProjectSection
 EndProject
 Project(&quot;{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}&quot;) = &quot;RlStartup&quot;, &quot;engine\startup\RlStartup2005.vcproj&quot;, &quot;{B78AEF70-E618-4E9D-BD67-E17995ECF714}&quot;
 	ProjectSection(ProjectDependencies) = postProject
+		{53FE20F3-E726-44FE-BBEC-D29CAE210D25} = {53FE20F3-E726-44FE-BBEC-D29CAE210D25}
+		{9A41EAE4-302A-4823-8F20-FA1AD58189A1} = {9A41EAE4-302A-4823-8F20-FA1AD58189A1}
+		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
+		{ED15F1B3-8B3B-40D1-8F56-5399B2E5E851} = {ED15F1B3-8B3B-40D1-8F56-5399B2E5E851}
+		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
+		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
+		{C3E78B89-587B-499A-BE7D-4FE8564F0CD7} = {C3E78B89-587B-499A-BE7D-4FE8564F0CD7}
 		{6361481B-A6D5-4BC2-826C-C26A49C631A8} = {6361481B-A6D5-4BC2-826C-C26A49C631A8}
-		{C3E78B89-587B-499A-BE7D-4FE8564F0CD7} = {C3E78B89-587B-499A-BE7D-4FE8564F0CD7}
-		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
-		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
-		{ED15F1B3-8B3B-40D1-8F56-5399B2E5E851} = {ED15F1B3-8B3B-40D1-8F56-5399B2E5E851}
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
-		{9A41EAE4-302A-4823-8F20-FA1AD58189A1} = {9A41EAE4-302A-4823-8F20-FA1AD58189A1}
-		{53FE20F3-E726-44FE-BBEC-D29CAE210D25} = {53FE20F3-E726-44FE-BBEC-D29CAE210D25}
 	EndProjectSection
 EndProject
 Project(&quot;{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}&quot;) = &quot;RlUI&quot;, &quot;engine\ui\RlUI2005.vcproj&quot;, &quot;{53FE20F3-E726-44FE-BBEC-D29CAE210D25}&quot;
 	ProjectSection(ProjectDependencies) = postProject
+		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
+		{ED15F1B3-8B3B-40D1-8F56-5399B2E5E851} = {ED15F1B3-8B3B-40D1-8F56-5399B2E5E851}
+		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
+		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
 		{6361481B-A6D5-4BC2-826C-C26A49C631A8} = {6361481B-A6D5-4BC2-826C-C26A49C631A8}
-		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
-		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
-		{ED15F1B3-8B3B-40D1-8F56-5399B2E5E851} = {ED15F1B3-8B3B-40D1-8F56-5399B2E5E851}
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 	EndProjectSection
 EndProject
 Project(&quot;{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}&quot;) = &quot;RlUIComponents&quot;, &quot;engine\uicomponents\RlUIComponents2005.vcproj&quot;, &quot;{ED15F1B3-8B3B-40D1-8F56-5399B2E5E851}&quot;
 EndProject
 Project(&quot;{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}&quot;) = &quot;RlAI&quot;, &quot;engine\ai\RlAI2005.vcproj&quot;, &quot;{C3E78B89-587B-499A-BE7D-4FE8564F0CD7}&quot;
 	ProjectSection(ProjectDependencies) = postProject
+		{6361481B-A6D5-4BC2-826C-C26A49C631A8} = {6361481B-A6D5-4BC2-826C-C26A49C631A8}
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
+		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 		{1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070} = {1D1D45B2-A9C3-4D10-93EC-22AE4AA5C070}
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 	EndProjectSection
 EndProject
 Project(&quot;{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}&quot;) = &quot;RlFmod4Driver&quot;, &quot;plugins\fmod4driver\RlFmod4Driver.vcproj&quot;, &quot;{A2DD1E40-4D80-44C5-B04E-1B1C4B07131C}&quot;
 	ProjectSection(ProjectDependencies) = postProject
+		{53FE20F3-E726-44FE-BBEC-D29CAE210D25} = {53FE20F3-E726-44FE-BBEC-D29CAE210D25}
+		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
-		{53FE20F3-E726-44FE-BBEC-D29CAE210D25} = {53FE20F3-E726-44FE-BBEC-D29CAE210D25}
 	EndProjectSection
 EndProject
 Project(&quot;{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}&quot;) = &quot;RlOpenALDriver&quot;, &quot;plugins\openaldriver\RlOpenALDriver.vcproj&quot;, &quot;{173A345C-D7B1-46F9-974F-53661D7C8AF6}&quot;
 	ProjectSection(ProjectDependencies) = postProject
+		{53FE20F3-E726-44FE-BBEC-D29CAE210D25} = {53FE20F3-E726-44FE-BBEC-D29CAE210D25}
+		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
 		{0935F495-4540-40E3-AC8F-AA54C85DC5B2} = {0935F495-4540-40E3-AC8F-AA54C85DC5B2}
-		{D3185FC6-9384-431A-A237-80284F859B21} = {D3185FC6-9384-431A-A237-80284F859B21}
-		{53FE20F3-E726-44FE-BBEC-D29CAE210D25} = {53FE20F3-E726-44FE-BBEC-D29CAE210D25}
 	EndProjectSection
 EndProject
 Global

Modified: rl/trunk/engine/ai/RlAI2005.vcproj
===================================================================
--- rl/trunk/engine/ai/RlAI2005.vcproj	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/RlAI2005.vcproj	2007-03-06 21:07:05 UTC (rev 3133)
@@ -305,6 +305,26 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\src\AStar.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\src\AStarCosts.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\src\AStarHeuristic.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\src\AStarNodePool.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\src\AStarWayPointNode.cpp&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\src\PhysicalObstacle.cpp&quot;
 				&gt;
 			&lt;/File&gt;
@@ -355,6 +375,26 @@
 				&gt;
 			&lt;/File&gt;
 			&lt;File
+				RelativePath=&quot;.\include\AStar.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\include\AStarCosts.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\include\AStarHeuristic.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\include\AStarNodePool.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
+				RelativePath=&quot;.\include\AStarWayPointNode.h&quot;
+				&gt;
+			&lt;/File&gt;
+			&lt;File
 				RelativePath=&quot;.\include\FuzzyState.h&quot;
 				&gt;
 			&lt;/File&gt;

Added: rl/trunk/engine/ai/include/AStar.h
===================================================================
--- rl/trunk/engine/ai/include/AStar.h	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/include/AStar.h	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,145 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
+ */
+#ifndef __RlAI_AStar_H__
+#define __RlAI_AStar_H__
+
+#include &quot;AiPrerequisites.h&quot;
+#include &quot;AStarWayPointNode.h&quot;
+#include &quot;DebugVisualisable.h&quot;
+#include &quot;OgreVector3.h&quot;
+
+namespace rl
+{
+
+	class WayPointGraph;
+	class AStarCosts;
+
+	/* Just some short notes to the ideas of amit:
+	 * we're using heaps here for the open/close sets
+	 * once we get beyond 800 waypoints, we can have a look at HOT buckets ...
+	 */
+
+	/** A class to get some statistical output about the AStar search.
+	 */
+	class AStarStatistics
+	{
+	public:
+	};
+
+	/** Stores a waypointgraph and is capable of loading and saving it.
+	 */
+	class _RlAiExport AStar 
+		: public DebugVisualisable	
+	{
+	public:
+		//! defines the type of the open/closed sets
+		typedef std::vector&lt; AStarWayPointNode* &gt; AStarSet;
+		//! defines the resultpath as a list of points in world space
+		typedef std::vector&lt; Ogre::Vector3 &gt; AStarPath;
+
+		/** The constructor of AStar
+		 * AStar needs several things to find a path: 
+		 * a heuristic to calculate the cost for the still not travelled part of the path.
+		 * some sort of map to travel in.
+		 * A start and and end point.
+		 * @param Costs encapsulates cost and heuristic for distance calculations.
+		 * @param WPGraph contains the map of WayPoints to examine for a path.
+		 * @param StartPos is the start point in world space.
+		 * @param StartPos is the end point in world space.
+		 */
+		AStar( const AStarCosts* Costs, const WayPointGraph* WPGraph,
+			const Ogre::Vector3&amp; StartPos, const Ogre::Vector3&amp; EndPos );
+		/** explicit virtual destructor
+		 */
+		~AStar();
+
+		/** starts the search.
+		 */
+		void search(AStarPath&amp; resultPath);
+
+		/** starts the search for the given start and end positions
+		 * @param StartPos gives the startpoint for the search
+		 * @param EndPos gives the endposition for the search
+		 */
+		void searchFromTo(AStarPath&amp; resultPath, const Ogre::Vector3&amp; StartPos,
+			const Ogre::Vector3&amp; EndPos );
+
+		/* retrieve a list of WayPoints (=the solution)
+		 * This generates a path from the solution created by search
+		 */
+		//const AStarPath&amp; getResultPointList() const;
+
+		/** Resets the AStar to do an other search.
+		 * Before searching can be done again all temporary data has to be
+		 * deallocated.
+		 */
+		void reset();
+
+		// Overrides from DebugVisualisable
+		/** Provides the flag of the kind of visualisation done in the class.
+		 * \see DebugVisualisable::DebugVisualisableFlag for further information
+		 */
+		virtual DebugVisualisableFlag getFlag() const;
+		/** Called to update the debug primitive. Redrawing is done in here.
+		 */
+        virtual void updatePrimitive();
+
+	protected:
+		// Overrides from DebugVisualisable
+		/** actualy creates the debug primitive.
+		 * \see DebugVisualisable for further information
+		 */
+        virtual void doCreatePrimitive();
+
+		// End of Overrides from DebugVisualisable
+
+		/** sets up everyting needed for the search.
+		 */
+		void initialise();
+
+		/** search for a AStarWayPointNode in the specified set
+		 * @param Set to search through
+		 * @param Node to search for
+		 */
+		AStarSet::iterator AStar::searchSet(AStarSet&amp; Set, AStarWayPointNode* Node);
+
+		// static data
+		//! heuristic function
+		const AStarCosts* mCosts;
+		//! map (which is a waypoint graph)
+		const WayPointGraph* mWPGraph;
+		//! start position
+		Ogre::Vector3 mStartPos;
+		//! end position (to reach)
+		Ogre::Vector3 mEndPos;
+		//! the nearest waypoint to the start position
+		AStarWayPointNode* mANStart;
+		//! the nearest waypoint ot the end position
+		AStarWayPointNode* mANEnd;
+
+		typedef std::greater&lt;AStarWayPointNode* &gt; AStarNodeComp;
+
+		// dynamic data (changed while searching)
+		//! contains the OPEN set
+		AStarSet mOpen;
+		//! contains the CLOSED set
+		AStarSet mClosed;
+
+	};
+	
+}; // namespace
+
+#endif
\ No newline at end of file

Added: rl/trunk/engine/ai/include/AStarCosts.h
===================================================================
--- rl/trunk/engine/ai/include/AStarCosts.h	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/include/AStarCosts.h	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,96 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
+ */
+#ifndef __RlAI_AStarCosts_H__
+#define __RlAI_AStarCosts_H__
+
+#include &quot;AiPrerequisites.h&quot;
+#include &quot;AStarHeuristic.h&quot;
+
+namespace rl {
+
+	class WayPointGraph;
+	class AStarWayPointNode;
+
+	/** Abstract cost class definining an interface for AStar to access.
+	 * Contains the heuristic to calculate the distance cost to the goal and
+	 * the calculation of the real costs from one node to an other.
+	 */
+	class _RlAiExport AStarCosts
+	{
+	public:
+		/** default constructor
+		 * @param Heuristic to use for calculating heuritic values
+		 */
+		AStarCosts(const AStarHeuristic* Heuristic);
+		/** explicit virtual destructor
+		 */
+		virtual ~AStarCosts();
+
+		/** calculates the (remaining) distance between wp1 and wp2.
+		 * @param WPGraph contains a WayPointGraph that knows the Waypoints to the given nodes
+		 * @param wp1 start AStarWayPoint
+		 * @param wp2 goal AStarWayPoint
+		 * @returns a float giving the result of the heuristic distance calculation
+		 */
+		virtual float calcHeuristic(const WayPointGraph* WPGraph, const AStarWayPointNode* wp1,
+			const AStarWayPointNode* wp2) const;
+
+		/** calculates the real cost between wp1 and wp2.
+		 * @param WPGraph contains a WayPointGraph that knows the Waypoints to the given nodes
+		 * @param wp1 start AStarWayPoint
+		 * @param wp2 goal AStarWayPoint
+		 * @returns a float giving the result of the real cost calculation
+		 */
+		virtual float calcCost(const WayPointGraph* WPGraph, const AStarWayPointNode* wp1,
+			const AStarWayPointNode* wp2) const = 0;
+
+	protected:
+		const AStarHeuristic* mHeuristic;
+	};
+	
+	/* An implementation of the abstract interface of AStarCosts.
+	 * currently utilises euklidean distance as a method for calculating
+	 * the real costs.
+	 * Of course there is a lot of tuning that can be done here.
+	 */
+	class _RlAiExport AStarCostsDefault
+		: public AStarCosts
+	{
+		/** default constructor
+		 * @param Heuristic to use for calculating heuritic values
+		 */
+		AStarCostsDefault(const AStarHeuristic* Heuristic);
+		/** explicit virtual destructor
+		 */
+		virtual ~AStarCostsDefault();
+		/** calculates the real cost between wp1 and wp2.
+		 * The calculation in place is planely reporting the euclidean
+		 * distance.
+		 * @param WPGraph contains a WayPointGraph that knows the Waypoints to the given nodes
+		 * @param wp1 start AStarWayPoint
+		 * @param wp2 goal AStarWayPoint
+		 * @returns a float giving the result of the real cost calculation
+		 */
+		virtual float calcCost(const WayPointGraph* WPGraph, const AStarWayPointNode* wp1,
+			const AStarWayPointNode* wp2) const;
+
+	protected:
+		EuclideanDistance mEuclid;
+	};
+
+};  //namespace
+
+#endif
\ No newline at end of file

Added: rl/trunk/engine/ai/include/AStarHeuristic.h
===================================================================
--- rl/trunk/engine/ai/include/AStarHeuristic.h	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/include/AStarHeuristic.h	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,122 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
+ */
+#ifndef __RlAI_AStarHeuristic_H__
+#define __RlAI_AStarHeuristic_H__
+
+#include &quot;AiPrerequisites.h&quot;
+
+namespace rl {
+
+	
+
+	/** Abstract heuristic class definining an interface for AStar to access.
+	 * Contains the heuristic to calculate the distance cost to the goal
+	 */
+	class _RlAiExport AStarHeuristic
+	{
+	public:
+		/** default constructor
+		 */
+		AStarHeuristic();
+		/** explicit virtual destructor
+		 */
+		virtual ~AStarHeuristic();
+
+		/** calculates the (remaining) distance between wp1 and wp2.
+		 * @param vec1 start position in world space
+		 * @param vec2 goal position in world space
+		 * @returns a float giving the result of the heuristic distance calculation
+		 */
+		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const = 0;
+	};
+
+	// a set of sample heuristics that can be used
+
+	//! Manhatten distance heuristic
+	class _RlAiExport ManhattenDistance
+		: public AStarHeuristic
+	{
+	public:
+		//! default constructor
+		ManhattenDistance();
+		//! explicit virtual destructor
+		virtual ~ManhattenDistance();
+
+		/** calculates the Manhatten distance of the given 2 points.
+		 * @param vec1 start point in world space
+		 * @param vec2 end point in world space
+		 * @returns a float containing the Manhatten distance of the 2 points.
+		 */
+		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const;
+	};
+
+	//! diagonal distance heuristic
+	class _RlAiExport DiagonalDistance
+		: public AStarHeuristic
+	{
+	public:
+		//! default constructor
+		DiagonalDistance();
+		//! explicit virtual destructor
+		virtual ~DiagonalDistance();
+
+		/** calculates the of diagonal distance the given 2 points.
+		 * @param vec1 start point in world space
+		 * @param vec2 end point in world space
+		 * @returns a float containing the diagonal distance of the 2 points.
+		 */
+		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const;
+	};
+
+	//! euclidean distance heuristic
+	class _RlAiExport EuclideanDistance
+		: public AStarHeuristic
+	{
+	public:
+		//! default constructor
+		EuclideanDistance();
+		//! explicit virtual destructor
+		virtual ~EuclideanDistance();
+
+		/** calculates the of the given 2 points.
+		 * @param vec1 start point in world space
+		 * @param vec2 end point in world space
+		 * @returns a float containing the of the 2 points.
+		 */
+		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const;
+	};
+
+	//! euclidian distance square heuristic
+	class _RlAiExport EuclideanDistanceSquared
+		: public AStarHeuristic
+	{
+	public:
+		//! default constructor
+		EuclideanDistanceSquared();
+		//! explicit virtual destructor
+		virtual ~EuclideanDistanceSquared();
+
+		/** calculates the of the given 2 points.
+		 * @param vec1 start point in world space
+		 * @param vec2 end point in world space
+		 * @returns a float containing the of the 2 points.
+		 */
+		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const;
+	};
+
+}; // namespace
+
+#endif
\ No newline at end of file

Added: rl/trunk/engine/ai/include/AStarNodePool.h
===================================================================
--- rl/trunk/engine/ai/include/AStarNodePool.h	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/include/AStarNodePool.h	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,89 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
+ */
+#ifndef __RlAI_AStarNodeManager_H__
+#define __RlAI_AStarNodeManager_H__
+
+#include &quot;AiPrerequisites.h&quot;
+#include &quot;AStarWayPointNode.h&quot;
+
+namespace rl {
+
+	/** A class for the memory management of Nodes for the A Star.
+	 * Internally it keeps a list of nodes and just remembers which
+	 * are used externally and which are not. So alloc/dealloc doesn't
+	 * happen that often when throwing away nodes.
+	 */
+	class _RlAiExport AStarNodePool
+	{
+		//! typedefinition for a list of AStar nodes
+		typedef std::vector&lt;AStarWayPointNode *&gt; AStarNodeList;
+
+		/** default constructor
+		 */
+		AStarNodePool();
+		/** explicit destructor
+		 */
+		~AStarNodePool();
+
+		/** fetches a AStarWayPointNode for use
+		 * @param WP WayPointNode to save in the AStarWayPointNode
+		 */
+		AStarWayPointNode* createAStarWayPointNode( const WayPointNode* WP );
+
+		/** releases a AStarWayPointNode from use
+		 * @param Node the node to release
+		 */
+		void release( AStarWayPointNode* Node );
+
+		/** releases all AStarWayPointNodes from use
+		 */
+		void releaseAll();
+
+		/** removes a single AStarWayPointNode (delete)
+		 */
+		void remove( AStarWayPointNode* Node );
+
+		/** removes all AStarWayPointNodes (delete)
+		 */
+		void removeAll( );
+
+		/** retrieves the AStarWayPointNode at the specified Index.
+		 * Retrieval is conducted on the list of nodes in use. (mUsed)
+		 * @param Index to retrieve AStarWayPointNode at.
+		 */
+		AStarWayPointNode* getAt(unsigned int Index);
+
+		/** retrieves the number of AStarWayPointNodes available for retrieval.
+		 * Is necessary to avoid throwing of an error
+		 * @returns unsigned int giving the number of elements stored in mUsed.
+		 */
+		unsigned int getSize();
+
+	protected:
+		/** helper function to remove all contents of a AStarNodeList
+		 */
+		void removeListContents(AStarNodeList&amp; List);
+
+		//! list of nodes in use
+		AStarNodeList mUsed;
+		//! list of nodes not yet in use
+		AStarNodeList mFree;
+
+	};
+
+};
+
+#endif
\ No newline at end of file

Added: rl/trunk/engine/ai/include/AStarWayPointNode.h
===================================================================
--- rl/trunk/engine/ai/include/AStarWayPointNode.h	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/include/AStarWayPointNode.h	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,135 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
+ */
+#ifndef __RlAI_AStarWayPointNode_H__
+#define __RlAI_AStarWayPointNode_H__
+
+#include &quot;AiPrerequisites.h&quot;
+
+namespace rl
+{
+	
+	class WayPointNode;
+
+	/** This class used as a node for creating the a* search graph.
+	 * It is tightly linked with the real map representation of waypoints which
+	 * is done with WayPointNode - hence its name is AStarWayPointNode to express
+	 * that tight link.
+	 */
+	class _RlAiExport AStarWayPointNode
+	{
+	public:
+
+		/** Constructor for an AStar Node
+		 * AStarWayPointNode is not derived from WayPointNode, because doubling
+		 * information that present at some other place is not necessary and 
+		 * just makes it difficult to the if it's accurate at the moment.
+		 * Therefore only a pointer to the waypoint, this Astar node is linked
+		 * to, is stored.
+		 * @param WP is a WayPointNode object storing, position and neigbours.
+		 */
+		AStarWayPointNode(const WayPointNode* WP);
+
+		/** explicit virtual destructor
+		 */
+		virtual ~AStarWayPointNode();
+
+		/** 2 nodes are compared by comparing their f value.
+		 * The f value of a node is the sum of g and h value. (really needed?)
+		 */
+		inline bool operator &lt; ( const AStarWayPointNode&amp; wp2 ) //, const AStarWayPointNode&amp; wp2 )
+		{
+			return (mG+mH) &lt; (wp2.mG+wp2.mH);
+		    //return (wp1-&gt;mG+wp1-&gt;mH) &lt; (wp2-&gt;mG+wp2-&gt;mH);
+		}
+		/** 2 nodes compared for equilibrium by comparing their values.
+		 * (really needed?)
+		 */
+		inline bool operator == ( const AStarWayPointNode&amp; wp2 ) //, const AStarWayPointNode* wp2 )
+		{
+			return (mWP == wp2.mWP) &amp;&amp; (mG == wp2.mG) &amp;&amp; (mH == wp2.mH);
+			//return (wp1-&gt;mWP == wp2-&gt;mWP) &amp;&amp; (wp1-&gt;mG == wp2-&gt;mG) &amp;&amp; (wp1-&gt;mH == wp2-&gt;mH);
+		}
+		/** 2 nodes compared for equilibrium by comparing their values.
+		 * (really needed?)
+		 */
+		inline bool operator == (const AStarWayPointNode* wp2 )
+		{
+			return (mWP == wp2-&gt;mWP) &amp;&amp; (mG == wp2-&gt;mG) &amp;&amp; (mH == wp2-&gt;mH);
+		}
+		/** 2 nodes compared for equilibrium by comparing their values.
+		 * (really needed?) 
+		 */
+		static inline bool Equal ( const AStarWayPointNode* wp1 , const AStarWayPointNode* wp2 )
+		{
+			
+			return (wp1-&gt;mWP == wp2-&gt;mWP) &amp;&amp; (wp1-&gt;mG == wp2-&gt;mG) &amp;&amp; (wp1-&gt;mH == wp2-&gt;mH);
+		}
+
+		/** 2 nodes compared by comparing their f value.
+		 * The f value of a node is the sum of g and h value.
+		 * This function is used when sorting a stl::vector.
+		 */
+		static bool SortMethod(const AStarWayPointNode* wp1, const AStarWayPointNode* wp2)
+		{
+			return (wp1-&gt;mG+wp1-&gt;mH) &lt; (wp2-&gt;mG+wp2-&gt;mH);
+		}
+
+		/** fetches the G value (cost til now)
+		 * @returns the cost value up to this waypoint
+		 */
+		inline float getG() const {return mG;}
+		/** fetches the H value (cost heuristic from now to goal)
+		 * @returns the cost value from this waypoint to the goal
+		 */
+		inline float getH() const {return mH;}
+		/** fetches the Parent of this node
+		 * @returns the parent of this node in the search path
+		 */
+		inline AStarWayPointNode* getParent() const {return mParent;}
+		/** returns the attached Waypoint node
+		 * Is necessary to generate the connection to the graph of nodepoints
+		 */
+		inline const WayPointNode* getWP() const {return mWP;}
+
+		/** fetches the G value (cost til now)
+		 * @returns the cost value up to this waypoint
+		 */
+		inline void setG(float G) {mG=G;}
+		/** fetches the H value (cost heuristic from now to goal)
+		 * @returns the cost value from this waypoint to the goal
+		 */
+		inline void setH(float H) {mH=H;}
+		/** fetches the Parent of this node
+		 * @returns the parent of this node in the search path
+		 */
+		inline void setParent(AStarWayPointNode* Parent) {mParent=Parent;}
+
+	protected:
+		//! the positional WayPoint
+		const WayPointNode* mWP;
+		//! the real costs up to this node
+		float mG;
+		//! the estimated costs to the goal
+		float mH;
+		//! the parent of this node in the search
+		AStarWayPointNode* mParent;
+	};
+
+
+
+}; // namespace
+
+#endif

Modified: rl/trunk/engine/ai/include/WayPointGraph.h
===================================================================
--- rl/trunk/engine/ai/include/WayPointGraph.h	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/include/WayPointGraph.h	2007-03-06 21:07:05 UTC (rev 3133)
@@ -150,6 +150,9 @@
 
 		//! to ease handling of the WayPointTree we also store a list of nodes
 		WayPointNodeList mNodeList;
+
+		//! remembers changes
+		bool mChanged;
 	};
 
 };

Added: rl/trunk/engine/ai/src/AStar.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStar.cpp	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/src/AStar.cpp	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,243 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
+ */
+#include &quot;AStar.h&quot;
+#include &quot;AStarWayPointNode.h&quot;
+#include &quot;AStarHeuristic.h&quot;
+#include &quot;AStarCosts.h&quot;
+#include &quot;AStarNodePool.h&quot;
+#include &quot;WayPointGraph.h&quot;
+#include &quot;WayPointNode.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;World.h&quot;
+#include &quot;LineSetPrimitive.h&quot;
+#include &lt;algorithm&gt;
+
+using namespace std;
+
+namespace rl {
+
+AStar::AStar( const AStarCosts* Costs, const WayPointGraph* WPGraph,
+			const Ogre::Vector3&amp; StartPos, const Ogre::Vector3&amp; EndPos )
+	: mCosts(Costs),
+	mWPGraph(WPGraph),
+	mStartPos(StartPos),
+	mEndPos(EndPos),
+	mANStart(NULL),
+	mANEnd(NULL)
+{
+}
+
+AStar::~AStar()
+{
+	reset();
+}
+
+void AStar::reset()
+{
+	//mAStarNodePool.clearall();
+	mANStart = NULL;
+	mANEnd = NULL;
+
+	AStarSet::iterator it;
+	for (it = mOpen.begin(); it != mOpen.end(); it++)
+	{
+		delete (*it);
+	}
+	for (it = mClosed.begin(); it != mClosed.end(); it++)
+	{
+		delete (*it);
+	}
+}
+
+void AStar::initialise()
+{
+	// drop everything already allocated
+	// perhaps it's wise to first have a look where we're going to head ?
+	// and decide it then depending on the destionation ?
+	reset();
+
+	// first find 'real' start and end positions by searching for the corresponding waypoints
+	mANStart = new AStarWayPointNode( mWPGraph-&gt;getNearestWayPoint(mStartPos) );
+	mANEnd = new AStarWayPointNode( mWPGraph-&gt;getNearestWayPoint(mEndPos) );
+}
+
+void AStar::searchFromTo(AStarPath&amp; resultPath, const Ogre::Vector3&amp; StartPos,
+						 const Ogre::Vector3&amp; EndPos )
+{
+	mStartPos = StartPos;
+	mEndPos = EndPos;
+	search(resultPath);
+}
+
+/*
+The A* algorithm, stripped of all the code, is fairly simple. 
+There are two sets, OPEN and CLOSED. The OPEN set contains those nodes that are candidates for examining.
+Initially, the OPEN set contains just one element: the starting position.
+The CLOSED set contains those nodes that have already been examined.
+Initially, the CLOSED set is empty. Graphically, the OPEN set is the &quot;frontier&quot;
+and the CLOSED set is the &quot;interior&quot; of the visited areas. Each node also keeps
+a pointer to its parent node so that we can determine how it was found.
+
+There is a main loop that repeatedly pulls out the best node n in OPEN
+(the node with the lowest f value) and examines it. If n is the goal, then we're done.
+Otherwise, node n is removed from OPEN and added to CLOSED. 
+Then, its neighbors n' are examined. A neighbor that is in CLOSED has already
+been seen, so we don't need to look at it (*). A neighbor that is in OPEN is
+scheduled to be looked at, so we don't need to look at it now (*). Otherwise,
+we add it to OPEN, with its parent set to n. The path cost to n', g(n'), will
+be set to g(n) + movementcost(n, n').
+
+(*) I'm skipping a small detail here. You do need to check to see if the
+node's g value can be lowered, and if so, you re-open it.
+*/
+
+void AStar::search(AStarPath&amp; resultPath)
+{
+	initialise();
+	mOpen.push_back(mANStart);
+	mANStart-&gt;setH(mCosts-&gt;calcHeuristic(mWPGraph,mANStart,mANEnd));
+
+	AStarWayPointNode* Node;
+
+	// While there are still unvisited nodes
+    while( !mOpen.empty() )
+	{
+		Node = mOpen.front();
+		pop_heap(mOpen.begin(), mOpen.end(), AStarWayPointNode::SortMethod);
+		mOpen.pop_back();
+		mClosed.push_back(Node);
+
+		// check if goal reached
+		if ( (*Node) == (*mANEnd) ) {
+			// create result
+			for (; Node-&gt;getParent(); Node = Node-&gt;getParent())
+			{
+				resultPath.push_back(Node-&gt;getWP()-&gt;getPosition());
+			}
+			// terminate search
+			break;
+		}
+
+		// now look through the neighbours
+		WayPointNode::WayPointWeightNodeList WPList = Node-&gt;getWP()-&gt;getNeighbours();
+		WayPointNode::WayPointWeightNodeList::iterator it;
+
+		for (it = WPList.begin(); it != WPList.end(); it++)
+		{
+			AStarWayPointNode* ASubNode = new AStarWayPointNode((*it).second);
+			float cost = mCosts-&gt;calcCost(mWPGraph,mANStart,mANEnd);
+
+			ASubNode-&gt;setG( Node-&gt;getG() + cost );
+			ASubNode-&gt;setH( mCosts-&gt;calcHeuristic(mWPGraph,ASubNode,mANEnd) );
+
+			AStarSet::iterator ASit;
+			// now check if the node is already in Open
+			
+			if ( (ASit = searchSet(mOpen, ASubNode)) != mOpen.end() ) 
+			{
+				AStarWayPointNode* ASfound = (*ASit);
+				// check if current g is better
+				if (ASfound-&gt;getG() &gt; ASubNode-&gt;getG()) {
+					ASfound-&gt;setG(ASubNode-&gt;getG());
+					ASfound-&gt;setH(ASubNode-&gt;getH());
+					ASfound-&gt;setParent(Node);
+					// dark magic ... for resorting the heap from the top
+					// down to the changed element
+					push_heap( mOpen.begin(), ASit+1, AStarWayPointNode::SortMethod );
+				}
+				// anyway the newly created node isn't needed
+				delete ASubNode;
+			
+			}  // now check if the node is already in Closed
+			else if ( (ASit = searchSet(mClosed, ASubNode)) != mClosed.end()) 
+			{
+				AStarWayPointNode* ASfound = (*ASit);
+				// (check if current g is better, then reopen)
+				if (ASfound-&gt;getG() &gt; ASubNode-&gt;getG()) {
+					ASfound-&gt;setG(ASubNode-&gt;getG());
+					ASfound-&gt;setH(ASubNode-&gt;getH());
+					ASfound-&gt;setParent(Node);
+					// remove the node from the closed list
+					mClosed.erase(ASit);
+
+					// dark magic ... for resorting the heap from the top
+					// down to the changed element
+					push_heap( mOpen.begin(), mOpen.end(), AStarWayPointNode::SortMethod );
+				}
+				// anyway the newly created node isn't needed
+				delete ASubNode;
+			} 
+			else 
+			{
+				// neither in Open nor Closed, so add it to Open
+				mOpen.push_back( ASubNode );
+                push_heap( mOpen.begin(), mOpen.end(), AStarWayPointNode::SortMethod );
+				ASubNode-&gt;setParent(Node);
+			}
+		}
+	}
+
+}
+
+AStar::AStarSet::iterator AStar::searchSet(AStarSet&amp; Set, AStarWayPointNode* Node)
+{
+	AStarSet::iterator it;
+
+	it = find(Set.begin(), Set.end(), Node);
+	AStarWayPointNode* help = (*it);
+	for (it = Set.begin(); it != Set.end(); it++) 
+	{
+		if ( (*it) == Node )
+			return it;
+	}
+
+	return it;
+}
+
+/*		
+const AStarSet&amp; AStar::getWayPointList()
+{
+	// search must be finished ? or just invoke it here then ?
+}
+*/
+
+DebugVisualisableFlag AStar::getFlag() const
+{
+	return DVF_WAYPOINT;
+}
+
+void AStar::updatePrimitive()
+{
+	if (mSceneNode-&gt;getParent() == NULL)
+    {
+		//mActor = ActorManager::createEmptyActor(&quot;__Astar_Debugger__&quot;);
+		CoreSubsystem::getSingletonPtr()-&gt;getWorld()-&gt;getSceneManager()-&gt;
+			getRootSceneNode()-&gt;addChild(mSceneNode);
+    }
+
+	LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
+
+	lineSet-&gt;clear();
+
+	//lineSet-&gt;addLine(wp1Vec, (*nit).second-&gt;getPosition(), Ogre::ColourValue::Blue);
+}
+
+void AStar::doCreatePrimitive()
+{
+	mPrimitive = new LineSetPrimitive();
+}
+
+};
\ No newline at end of file

Added: rl/trunk/engine/ai/src/AStarCosts.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarCosts.cpp	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/src/AStarCosts.cpp	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,53 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
+ */
+#include &quot;AStarCosts.h&quot;
+#include &quot;AStarWayPointNode.h&quot;
+#include &quot;WayPointNode.h&quot;
+
+namespace rl {
+
+AStarCosts::AStarCosts(const AStarHeuristic* Heuristic)
+: mHeuristic(Heuristic)
+{
+}
+
+AStarCosts::~AStarCosts()
+{
+}
+
+float AStarCosts::calcHeuristic(const WayPointGraph* WPGraph, const AStarWayPointNode* wp1,
+			const AStarWayPointNode* wp2) const
+{
+	return mHeuristic-&gt;calcDistance(wp1-&gt;getWP()-&gt;getPosition(), wp2-&gt;getWP()-&gt;getPosition());
+}
+
+AStarCostsDefault::AStarCostsDefault(const AStarHeuristic* Heuristic)
+: AStarCosts(Heuristic)
+{
+}
+
+AStarCostsDefault::~AStarCostsDefault()
+{
+}
+
+float AStarCostsDefault::calcCost(const WayPointGraph* WPGraph,
+										  const AStarWayPointNode* wp1,
+										  const AStarWayPointNode* wp2) const
+{
+	return mEuclid.calcDistance(wp1-&gt;getWP()-&gt;getPosition(), wp2-&gt;getWP()-&gt;getPosition());
+}
+
+};

Added: rl/trunk/engine/ai/src/AStarHeuristic.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarHeuristic.cpp	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/src/AStarHeuristic.cpp	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,71 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
+ */
+#include &quot;AStarHeuristic.h&quot;
+#include &quot;AStarWayPointNode.h&quot;
+#include &quot;WayPointNode.h&quot;
+
+namespace rl {
+
+AStarHeuristic::AStarHeuristic()
+{
+}
+
+AStarHeuristic::~AStarHeuristic()
+{
+}
+
+ManhattenDistance::ManhattenDistance()
+{
+}
+ManhattenDistance::~ManhattenDistance()
+{
+}
+float ManhattenDistance::calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const
+{
+	return (abs(vec1.x - vec2.x) + abs(vec1.y - vec2.y) + abs(vec1.z - vec2.z));
+}
+DiagonalDistance::DiagonalDistance()
+{
+}
+DiagonalDistance::~DiagonalDistance()
+{
+}
+float DiagonalDistance::calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const
+{
+	return std::max( std::max( abs(vec1.x - vec2.x), abs(vec1.y - vec2.y) ), abs(vec1.z - vec2.z) );
+}
+EuclideanDistance::EuclideanDistance()
+{
+}
+EuclideanDistance::~EuclideanDistance()
+{
+}
+float EuclideanDistance::calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const
+{
+	return vec1.distance( vec2);
+}
+EuclideanDistanceSquared::EuclideanDistanceSquared()
+{
+}
+EuclideanDistanceSquared::~EuclideanDistanceSquared()
+{
+}
+float EuclideanDistanceSquared::calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const
+{
+	return vec1.squaredDistance( vec2);
+}
+
+};

Added: rl/trunk/engine/ai/src/AStarNodePool.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarNodePool.cpp	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/src/AStarNodePool.cpp	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,110 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
+ */
+#include &quot;AStarNodePool.h&quot;
+#include &quot;AStarWayPointNode.h&quot;
+
+namespace rl {
+
+AStarNodePool::AStarNodePool()
+{
+}
+
+AStarNodePool::~AStarNodePool()
+{
+	removeAll();
+}
+
+void AStarNodePool::removeAll()
+{
+	removeListContents(mUsed);
+	removeListContents(mFree);
+}
+
+void AStarNodePool::releaseAll()
+{
+	AStarNodeList::iterator it;
+	for (it = mUsed.begin(); it != mUsed.end(); it++)
+	{
+		mFree.push_back( (*it) );
+	}
+	mUsed.clear();
+}
+
+void AStarNodePool::release(AStarWayPointNode* Node)
+{
+	AStarNodeList::iterator it;
+	for (it = mUsed.begin(); it != mUsed.end(); it++)
+	{
+		if ( (*it) == Node ) 
+		{
+			mUsed.erase(it);
+			mFree.push_back(Node);
+		}
+	}
+}
+
+void AStarNodePool::remove( AStarWayPointNode* Node )
+{
+	AStarNodeList::iterator it;
+	for (it = mUsed.begin(); it != mUsed.end(); it++)
+	{
+		if ( (*it) == Node ) 
+		{
+			mUsed.erase(it);
+			delete Node;
+		}
+	}
+}
+
+AStarWayPointNode* AStarNodePool::createAStarWayPointNode(const WayPointNode* WP)
+{
+	AStarWayPointNode* Node;
+	
+	if ( mFree.empty())
+		Node = new AStarWayPointNode(WP);
+	else
+	{
+		Node = mFree.back();
+		mFree.pop_back();
+	}
+
+	mUsed.push_back(Node);
+
+	return Node;
+}
+
+void AStarNodePool::removeListContents(AStarNodeList&amp; List)
+{
+	AStarNodeList::iterator it;
+	for (it = List.begin(); it != List.end(); it++)
+	{
+		delete (*it);
+	}
+	List.clear();
+}
+
+AStarWayPointNode* AStarNodePool::getAt(unsigned int Index)
+{
+	return mUsed[Index];
+}
+
+
+unsigned int AStarNodePool::getSize()
+{
+	return mUsed.size();
+}
+
+};

Added: rl/trunk/engine/ai/src/AStarWayPointNode.cpp
===================================================================
--- rl/trunk/engine/ai/src/AStarWayPointNode.cpp	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/src/AStarWayPointNode.cpp	2007-03-06 21:07:05 UTC (rev 3133)
@@ -0,0 +1,29 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2006 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Perl Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Perl Artistic License for more details.
+ *
+ *  You should have received a copy of the Perl Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.perldoc.com/perl5.6/Artistic.html.">http://www.perldoc.com/perl5.6/Artistic.html.</A>
+ */
+#include &quot;AStarWayPointNode.h&quot;
+
+namespace rl {
+
+AStarWayPointNode::AStarWayPointNode(const WayPointNode* WP)
+: mWP(WP), mG(-1), mH(-1), mParent(NULL)
+{
+}
+
+AStarWayPointNode::~AStarWayPointNode()
+{
+}
+
+};

Modified: rl/trunk/engine/ai/src/WayPointGraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/ai/src/WayPointGraph.cpp	2007-03-06 21:07:05 UTC (rev 3133)
@@ -28,7 +28,8 @@
 namespace rl {
 
 WayPointGraph::WayPointGraph()
-: mRoot(NULL)
+: mRoot(NULL),
+  mChanged(false)
 {
 }
 
@@ -70,6 +71,7 @@
 {
 	WayPointNode* newWayPoint = new WayPointNode(position, type);
 	mNodeList.push_back(newWayPoint);
+	mChanged = true;
 
 	return newWayPoint;
 }
@@ -78,11 +80,13 @@
 {
 	wp1-&gt;addNeighbour(wp2);
 	wp2-&gt;addNeighbour(wp1);
+	mChanged = true;
 }
 
 void WayPointGraph::addDirectedConnection(WayPointNode* wp1, const WayPointNode* wp2)
 {
 	wp1-&gt;addNeighbour(wp2);
+	mChanged = true;
 }
 
 void WayPointGraph::load (const Ogre::String&amp; filename)
@@ -168,6 +172,7 @@
 		Throw(Error, filename+&quot;: couldn't read expeced number of connections&quot;);
 
 	input.close();
+	mChanged = true;
 }
 
 void WayPointGraph::save (const Ogre::String&amp; filename) const
@@ -298,6 +303,10 @@
 		//mCharacterActor-&gt;_getSceneNode()-&gt;addChild(mSceneNode);
     }
 
+	// avoid building graph again and again
+	if (! mChanged)
+		return;
+
 	LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
 
 	lineSet-&gt;clear();
@@ -336,6 +345,8 @@
 		}
 	}
 	edgeList.clear();
+
+	mChanged = false;
 }
 
 void WayPointGraph::doCreatePrimitive()

Modified: rl/trunk/engine/script/swig/RlAi.head.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.head.swig	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/script/swig/RlAi.head.swig	2007-03-06 21:07:05 UTC (rev 3133)
@@ -23,6 +23,9 @@
 #include &quot;AiSubsystem.h&quot;
 #include &quot;AgentManager.h&quot;
 #include &quot;Agent.h&quot;
+#include &quot;AStar.h&quot;
+#include &quot;AStarHeuristic.h&quot;
+#include &quot;AStarCosts.h&quot;
 #include &quot;PhysicalObstacle.h&quot;
 #include &quot;WayPointNode.h&quot;
 #include &quot;WayPointGraph.h&quot;

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2007-03-06 18:03:15 UTC (rev 3132)
+++ rl/trunk/engine/script/swig/RlAi.swig	2007-03-06 21:07:05 UTC (rev 3133)
@@ -16,6 +16,10 @@
 
 namespace rl 
 {
+	// Before first use of GameObject or subclasses!
+	%apply SWIGTYPE *DYNAMIC { rl::AStarHeuristic * };
+	%apply SWIGTYPE *DYNAMIC { rl::AStarCosts * };
+
 	class SteeringVehicle
 	{
 	public:
@@ -114,6 +118,69 @@
         virtual void setBehaviourFactory(BehaviourFactory* factory);
 	};
 	
+	class AStarHeuristic
+	{
+		AStarHeuristic();
+		virtual ~AStarHeuristic();
+		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const = 0;
+	};
+	
+	class ManhattenDistance
+		: public AStarHeuristic
+	{
+	public:
+		ManhattenDistance();
+		virtual ~ManhattenDistance();
+	};
+
+	class DiagonalDistance
+		: public AStarHeuristic
+	{
+	public:
+		DiagonalDistance();
+		virtual ~DiagonalDistance();
+	};
+
+	class EuclideanDistance
+		: public AStarHeuristic
+	{
+	public:
+		EuclideanDistance();
+		virtual ~EuclideanDistance();
+	};
+
+	class EuclideanDistanceSquared
+		: public AStarHeuristic
+	{
+	public:
+		EuclideanDistanceSquared();
+		virtual ~EuclideanDistanceSquared();
+	}; 
+	
+	class AStarCosts
+	{
+		AStarCosts(const AStarHeuristic* Heuristic);	
+		virtual ~AStarCosts();
+	};
+	
+	class AStarCostsDefault
+	{
+		AStarCostsDefault(const AStarHeuristic* Heuristic);	
+		~AStarCostsDefault();
+	};
+	
+	class AStar
+	{
+		AStar( const AStarCosts* Costs, const WayPointGraph* WPGraph,
+			const Ogre::Vector3&amp; StartPos, const Ogre::Vector3&amp; EndPos );
+		virtual ~AStar();
+		
+		void search(std::vector&lt;Ogre::Vector3&gt;&amp; resultPath);
+		void searchFromTo(std::vector&lt;Ogre::Vector3&gt;&amp; resultPath,
+			const Ogre::Vector3&amp; StartPos, const Ogre::Vector3&amp; EndPos );
+		void reset();
+	};
+	
     class PhysicalObstacle {
         
         public:
@@ -161,4 +228,57 @@
 	
 } // Namespace
 
+%{
+static swig_type_info *AStarHeuristic_dynamic_cast(void **ptr)
+{
+    rl::AStarHeuristic **ppAStarHeuristic = reinterpret_cast&lt;rl::AStarHeuristic**&gt;(ptr);
 
+    rl::ManhattenDistance *pManhattenDistance=dynamic_cast&lt;rl::ManhattenDistance*&gt;(*ppAStarHeuristic);
+    if( pManhattenDistance )
+    {
+        *ptr=reinterpret_cast&lt;void*&gt;(pManhattenDistance);
+        return SWIGTYPE_p_rl__ManhattenDistance;
+    }
+    rl::DiagonalDistance *pDiagonalDistance=dynamic_cast&lt;rl::DiagonalDistance*&gt;(*ppAStarHeuristic);
+    if( pDiagonalDistance )
+    {
+        *ptr=reinterpret_cast&lt;void*&gt;(pDiagonalDistance);
+        return SWIGTYPE_p_rl__DiagonalDistance;
+    }
+    rl::EuclideanDistance *pEuclideanDistance=dynamic_cast&lt;rl::EuclideanDistance*&gt;(*ppAStarHeuristic);
+    if( pEuclideanDistance )
+    {
+        *ptr=reinterpret_cast&lt;void*&gt;(pEuclideanDistance);
+        return SWIGTYPE_p_rl__EuclideanDistance;
+    }
+    rl::EuclideanDistanceSquared *pEuclideanDistanceSquared=dynamic_cast&lt;rl::EuclideanDistanceSquared*&gt;(*ppAStarHeuristic);
+    if( pEuclideanDistanceSquared )
+    {
+        *ptr=reinterpret_cast&lt;void*&gt;(pEuclideanDistanceSquared);
+        return SWIGTYPE_p_rl__EuclideanDistanceSquared;
+    }
+   
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__AStarHeuristic, AStarHeuristic_dynamic_cast);
+
+
+%{
+static swig_type_info *AStarCosts_dynamic_cast(void **ptr)
+{
+    rl::AStarCosts **ppAStarCosts = reinterpret_cast&lt;rl::AStarCosts**&gt;(ptr);
+
+    rl::AStarCostsDefault *pAStarCostsDefault=dynamic_cast&lt;rl::AStarCostsDefault*&gt;(*ppAStarCosts);
+    if( pAStarCostsDefault )
+    {
+        *ptr=reinterpret_cast&lt;void*&gt;(pAStarCostsDefault);
+        return SWIGTYPE_p_rl__AStarCostsDefault;
+    }
+   
+    return 0;
+}
+%}
+DYNAMIC_CAST(SWIGTYPE_p_rl__AStarCosts, AStarCosts_dynamic_cast);
+
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000203.html">[Dsa-hl-svn] r3132 - rl/trunk/engine/ui/src
</A></li>
	<LI>Next message: <A HREF="000205.html">[Dsa-hl-svn] r3134 - in rl/trunk/engine: ai/include ai/src	script/swig
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#204">[ date ]</a>
              <a href="thread.html#204">[ thread ]</a>
              <a href="subject.html#204">[ subject ]</a>
              <a href="author.html#204">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
