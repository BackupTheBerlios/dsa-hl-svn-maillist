<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r3109 - in rl/trunk/engine: ai/include ai/src	common/include core/src rules/include rules/src script/swig	ui/include ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-March/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3109%20-%20in%20rl/trunk/engine%3A%20ai/include%20ai/src%0A%09common/include%20core/src%20rules/include%20rules/src%20script/swig%0A%09ui/include%20ui/src&In-Reply-To=%3C200703021359.l22Dxdwt016136%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000179.html">
   <LINK REL="Next"  HREF="000181.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r3109 - in rl/trunk/engine: ai/include ai/src	common/include core/src rules/include rules/src script/swig	ui/include ui/src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3109%20-%20in%20rl/trunk/engine%3A%20ai/include%20ai/src%0A%09common/include%20core/src%20rules/include%20rules/src%20script/swig%0A%09ui/include%20ui/src&In-Reply-To=%3C200703021359.l22Dxdwt016136%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r3109 - in rl/trunk/engine: ai/include ai/src	common/include core/src rules/include rules/src script/swig	ui/include ui/src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Fri Mar  2 14:59:39 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000179.html">[Dsa-hl-svn] r3108 - rl/trunk/engine/common/src
</A></li>
        <LI>Next message: <A HREF="000181.html">[Dsa-hl-svn] r3110 - rl/trunk/engine/core/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#180">[ date ]</a>
              <a href="thread.html#180">[ thread ]</a>
              <a href="subject.html#180">[ subject ]</a>
              <a href="author.html#180">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2007-03-02 14:59:13 +0100 (Fri, 02 Mar 2007)
New Revision: 3109

Removed:
   rl/trunk/engine/ui/include/CommandExecutor.h
   rl/trunk/engine/ui/src/CommandExecutor.cpp
Modified:
   rl/trunk/engine/ai/include/SteeringVehicle.h
   rl/trunk/engine/ai/src/Agent.cpp
   rl/trunk/engine/ai/src/AiWorld.cpp
   rl/trunk/engine/ai/src/PlayerVehicle.cpp
   rl/trunk/engine/ai/src/SteeringVehicle.cpp
   rl/trunk/engine/common/include/CommonPrerequisites.h
   rl/trunk/engine/common/include/EventCaster.h
   rl/trunk/engine/core/src/BaseAnimation.cpp
   rl/trunk/engine/core/src/BoxPrimitive.cpp
   rl/trunk/engine/core/src/ConfigurationManager.cpp
   rl/trunk/engine/core/src/GameAreaEventSource.cpp
   rl/trunk/engine/rules/include/Container.h
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/Inventory.h
   rl/trunk/engine/rules/include/Item.h
   rl/trunk/engine/rules/include/Weapon.h
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/DsaDataLoader.cpp
   rl/trunk/engine/rules/src/GameObjectManager.cpp
   rl/trunk/engine/rules/src/QuestBook.cpp
   rl/trunk/engine/script/swig/RlExports.i
   rl/trunk/engine/script/swig/RlRules.swig
   rl/trunk/engine/script/swig/TypeOgreQuaternion.swig
   rl/trunk/engine/script/swig/TypeRlProperty.swig
   rl/trunk/engine/ui/include/DialogWindow.h
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/include/Makefile.am
   rl/trunk/engine/ui/src/CharacterSheetWindow.cpp
   rl/trunk/engine/ui/src/DialogWindow.cpp
   rl/trunk/engine/ui/src/InputManager.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/Makefile.am
   rl/trunk/engine/ui/src/MovementCharacterController.cpp
Log:
A small cleanup operation
- removed some #using namespace from header files (causing a lot of 
changes in other files)
- removed unused CommandExecutor class
- removed some unneccessary #include from Creature.h



Modified: rl/trunk/engine/ai/include/SteeringVehicle.h
===================================================================
--- rl/trunk/engine/ai/include/SteeringVehicle.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ai/include/SteeringVehicle.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -22,13 +22,10 @@
 #include &quot;OpenSteer/SteerLibrary.h&quot;
 
 
-using namespace Ogre;
-using namespace OpenSteer;
-
 namespace rl
 {
 //	SimpleVehicle_1 adds concrete LocalSpace methods to AbstractVehicle
-	typedef OpenSteer::LocalSpaceMixin&lt;AbstractVehicle&gt; SimpleVehicle_1;
+	typedef OpenSteer::LocalSpaceMixin&lt;OpenSteer::AbstractVehicle&gt; SimpleVehicle_1;
 //	SimpleVehicle_2 adds concrete steering methods to SimpleVehicle_1
 	typedef OpenSteer::SteerLibraryMixin&lt;SimpleVehicle_1&gt; SimpleVehicle_2;
 	
@@ -63,7 +60,7 @@
 		 * @param  elapsedTime The time step value allows wander rate to be consistent when frame times vary
 		 * @return a steering force for wandering behavior. 
 		 */
-		Vector3 calcWander(const float elapsedTime);
+		Ogre::Vector3 calcWander(const float elapsedTime);
 
 		/**
 		 * Causes the vehicle to turn toward a target and move to it. 
@@ -73,23 +70,23 @@
 		 * @param  target target position to seek for
 		 * @return a steering force to seek the given target location. 
 		 */
-		Vector3 calcSeek(const Vector3&amp; target);
+		Ogre::Vector3 calcSeek(const Ogre::Vector3&amp; target);
 
 		/**
 		 * Causes the vehicle to turn away from a target and move away from it.
 		 * @param  target target position to flee for
 		 * @return a steering force to flee from the given target location. 
 		 */
-		Vector3 calcFlee(const Vector3&amp; target);
+		Ogre::Vector3 calcFlee(const Ogre::Vector3&amp; target);
 
-		Vector3 calcPursuit(Agent* agent);
+		Ogre::Vector3 calcPursuit(Agent* agent);
 		/**
 		 * Causes the vehicle to turn away from obstacles in space. 
 		 * The vehicle will consider all close-by obstacles automatically
 		 * @param  minTimeToCollision distance to the obstacle in time at the vehicle's current velocity
 		 * @return a steering force to avoid obstacles. 
 		 */
-		Vector3 calcAvoidObstacles(const float minTimeToCollision);
+		Ogre::Vector3 calcAvoidObstacles(const float minTimeToCollision);
 
 		/**
 		 * Causes the vehicle to turn away from neighbor vehicles.
@@ -97,12 +94,12 @@
 		 * @param  minTimeToCollision distance to the neighbour in time at the vehicle's current velocity
 		 * @return a steering force to avoid neighbours. 
 		 */
-		Vector3 calcAvoidNeighbors(const float minTimeToCollision);
+		Ogre::Vector3 calcAvoidNeighbors(const float minTimeToCollision);
 			
 		/**
 		 * @returns a steering force to maintain a given target speed. 
 		 */
-		Vector3 calcSteerTargetSpeed(const float targetSpeed);
+		Ogre::Vector3 calcSteerTargetSpeed(const float targetSpeed);
 
 		bool isAhead(Agent* agent, const float threshold);
 		bool needAvoidance(const float minTimeToCollision);
@@ -123,9 +120,9 @@
 
 		bool isDialogActive();
 
-		float calcDistance(const Vector3&amp; vec1, const Vector3&amp; vec2);
+		float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2);
 
-		Vector3 getPosition();
+		Ogre::Vector3 getPosition();
 
 		// inherited from AbstractVehicle
 
@@ -137,7 +134,7 @@
 		 * predict position of this vehicle at some time in the future
 		 * (assumes velocity remains constant)
 		 */
-		Vec3 predictFuturePosition (const float predictionTime) const;
+		OpenSteer::Vec3 predictFuturePosition (const float predictionTime) const;
 
 		void resetLocalSpace();
 		// get/set mass
@@ -145,7 +142,7 @@
 		float setMass (float m) {return 1;} // don't set mass here TODO: throw exception
 
 		// get velocity of vehicle
-		Vec3 velocity (void) const {return Vec3(mCurrentVelocity.x, mCurrentVelocity.y, mCurrentVelocity.z);}
+		OpenSteer::Vec3 velocity (void) const {return OpenSteer::Vec3(mCurrentVelocity.x, mCurrentVelocity.y, mCurrentVelocity.z);}
 
 		// get/set speed of vehicle  (may be faster than taking mag of velocity)
 		float speed (void) const {return mSpeed;}
@@ -173,14 +170,14 @@
          * allows a specific vehicle class to redefine this adjustment.
          * default is to disallow backward-facing steering at low speed.
 		 */
-		virtual Vec3 adjustRawSteeringForce (const Vec3&amp; force);
+		virtual OpenSteer::Vec3 adjustRawSteeringForce (const OpenSteer::Vec3&amp; force);
                                             // const float elapsedTime);
 
 		/**
 		 * apply a given steering force to our momentum,
 		 * adjusting our orientation to maintain velocity-alignment.
 		 */
-	//	void applySteeringForce(const Vec3&amp; force, const float elapsedTime);
+	//	void applySteeringForce(const OpenSteer::Vec3&amp; force, const float elapsedTime);
 	//	void applySteeringForce(const Ogre::Vector3&amp; force, const float elapsedTime);
 		
 		
@@ -189,7 +186,7 @@
 		 * the default version: keep FORWARD parallel to velocity, change
          * UP as little as possible.
 		 */
-  /*      virtual void regenerateLocalSpace (const Vec3&amp; newVelocity,
+  /*      virtual void regenerateLocalSpace (const OpenSteer::Vec3&amp; newVelocity,
                                            const float elapsedTime);
 		*/
 		
@@ -201,21 +198,21 @@
 		
 		float resetSmoothedCurvature (float value = 0)
 		{
-			_lastForward = Vec3::zero;
-			_lastPosition = Vec3::zero;
+			_lastForward = OpenSteer::Vec3::zero;
+			_lastPosition = OpenSteer::Vec3::zero;
 			return _smoothedCurvature = _curvature = value;
 		}
 		
-		Vec3 smoothedAcceleration (void) {return _smoothedAcceleration;}
+		OpenSteer::Vec3 smoothedAcceleration (void) {return _smoothedAcceleration;}
 		
-		Vec3 resetSmoothedAcceleration (const Vec3&amp; value = Vec3::zero)
+		OpenSteer::Vec3 resetSmoothedAcceleration (const OpenSteer::Vec3&amp; value = OpenSteer::Vec3::zero)
 		{
 			return _smoothedAcceleration = value;
 		}
 		
-		Vec3 smoothedPosition (void) {return _smoothedPosition;}
+		OpenSteer::Vec3 smoothedPosition (void) {return _smoothedPosition;}
 		
-		Vec3 resetSmoothedPosition (const Vec3&amp; value = Vec3::zero)
+		OpenSteer::Vec3 resetSmoothedPosition (const OpenSteer::Vec3&amp; value = OpenSteer::Vec3::zero)
 		{
 			return _smoothedPosition = value;
 		}
@@ -224,7 +221,7 @@
 		// rotate about it by a random angle (pick random forward, derive side).
 		void randomizeHeadingOnXZPlane (void)
 		{
-			setUp (Vec3::up);
+			setUp (OpenSteer::Vec3::up);
 			setForward (RandomUnitVectorOnXZPlane ());
 			setSide (localRotateForwardToSide (forward()));
 		}
@@ -234,8 +231,8 @@
         const Actor* getActor(void) const  { return mActor; }
 	protected:
 		void initialize();
-		AVGroup getNeighbors();
-		ObstacleGroup getObstacles();
+		OpenSteer::AVGroup getNeighbors();
+		OpenSteer::ObstacleGroup getObstacles();
 	//    float _mass;       // mass (defaults to unity so acceleration=force)
     //   float _radius;     // size of bounding sphere, for obstacle avoidance, etc.
     //    float _speed;      // speed along Forward direction.  Because local space

Modified: rl/trunk/engine/ai/src/Agent.cpp
===================================================================
--- rl/trunk/engine/ai/src/Agent.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ai/src/Agent.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -24,6 +24,8 @@
 #include &quot;SteeringMachine.h&quot;
 //#include &quot;PerceptionPool.h&quot;
 
+using namespace Ogre;
+using namespace OpenSteer;
 using namespace rl;
 
 Agent::Agent(Creature* character)

Modified: rl/trunk/engine/ai/src/AiWorld.cpp
===================================================================
--- rl/trunk/engine/ai/src/AiWorld.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ai/src/AiWorld.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -24,6 +24,7 @@
 
 using namespace rl;
 using namespace OpenSteer;
+using namespace Ogre;
 
 AiWorld::AiWorld(void) : mObstacles()
 {

Modified: rl/trunk/engine/ai/src/PlayerVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/PlayerVehicle.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ai/src/PlayerVehicle.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -19,6 +19,8 @@
 #include &quot;PhysicalThing.h&quot;
 
 using namespace rl;
+using namespace OpenSteer;
+using namespace Ogre;
 
 PlayerVehicle::PlayerVehicle(Actor* character)
 	: SteeringVehicle(NULL, character)

Modified: rl/trunk/engine/ai/src/SteeringVehicle.cpp
===================================================================
--- rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ai/src/SteeringVehicle.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -22,6 +22,8 @@
 #include &quot;PhysicalThing.h&quot;
 
 using namespace rl;
+using namespace Ogre;
+using namespace OpenSteer;
 
 SteeringVehicle::SteeringVehicle(Agent* parent, Actor* character)
 	: _maxForce(1.0f),

Modified: rl/trunk/engine/common/include/CommonPrerequisites.h
===================================================================
--- rl/trunk/engine/common/include/CommonPrerequisites.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/common/include/CommonPrerequisites.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -33,6 +33,7 @@
 
 #undef _assert
 
+#undef max
 #undef min
 #pragma warning( disable : 4267 ) // Konvertierungswarnung in CEGUIString
 #include &lt;CEGUIString.h&gt;

Modified: rl/trunk/engine/common/include/EventCaster.h
===================================================================
--- rl/trunk/engine/common/include/EventCaster.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/common/include/EventCaster.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -20,8 +20,6 @@
 #include &lt;set&gt;
 #include &quot;EventListener.h&quot;
 
-using namespace std;
-
 namespace rl {
 /**
  * Diese Klasse ist die Basisklasse fuer Objekte, die Ereignisse verschicken.
@@ -34,7 +32,7 @@
 class EventCaster {
 public:
     typedef EventListener&lt;Event&gt; ListenerToEvent;
-    typedef set&lt;ListenerToEvent*&gt; EventSet;
+    typedef std::set&lt;ListenerToEvent*&gt; EventSet;
     typedef typename EventSet::iterator EventSetIterator;
 
     /// Der Konstruktor
@@ -168,7 +166,7 @@
 }
     
 template &lt;typename Event&gt;
-set&lt; EventListener&lt;Event&gt;* &gt; EventCaster&lt;Event&gt;::getEventSet() const
+std::set&lt; EventListener&lt;Event&gt;* &gt; EventCaster&lt;Event&gt;::getEventSet() const
 {
     return mListeners;
 }

Modified: rl/trunk/engine/core/src/BaseAnimation.cpp
===================================================================
--- rl/trunk/engine/core/src/BaseAnimation.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/core/src/BaseAnimation.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -176,7 +176,7 @@
     }
 }
 
-// @todo - Existenz &#252;berpr&#252;fen
+// @todo - Existenz berprfen
 void BaseAnimation::addAnimationFrameListener( 
 	AnimationFrameListener *listener, Ogre::Real frameNumber)
 {
@@ -185,7 +185,7 @@
     ScriptWrapper::getSingleton().owned( listener );
 }
 
-// @todo - Existenz &#252;berpr&#252;fen
+// @todo - Existenz berprfen
 void BaseAnimation::removeAnimationFrameListener( AnimationFrameListener *listener )
 {
     AnimationFrameListenerMap::iterator iter = mAnimationFrameListener.begin();
@@ -252,7 +252,7 @@
     mAnimationCaster.removeEventListeners();
 }
 
-// Zeit hinzuf&#252;gen // wird vom AnimationManager aufgerufen
+// Zeit hinzufgen // wird vom AnimationManager aufgerufen
 void BaseAnimation::addTime( Ogre::Real timePassed )
 {
 	if( !mPaused )
@@ -304,8 +304,8 @@
 
 	Erfolgt in drei Schritten 
 	 * Aktueller Durchlauf
-	 * Wenn &#220;berlauf, dann wird die Anzahl weiterer Durchl&#228;ufe bestimmt
-	 * F&#252;r den Rest im letzten Durchlauf wird erneut gepr&#252;ft
+	 * Wenn &#239;&#191;&#189;erlauf, dann wird die Anzahl weiterer Durchl&#239;&#191;&#189;fe bestimmt
+	 * Fr den Rest im letzten Durchlauf wird erneut geprft
 */
 void BaseAnimation::checkAnimationFrameListeners( Ogre::Real timePassed )
 {
@@ -329,25 +329,25 @@
 
     Ogre::Real elapsedTime = (mTimePlayed/mLength)*mLength;
 
-	// Vorw&#228;rts laufen
+	// Vorw&#239;&#191;&#189;ts laufen
 	if( mSpeed &gt; 0 )		
 	{
-        lower = max(elapsedTime, 0.0f);
-		upper = min(elapsedTime, mLength );
+        lower = std::max(elapsedTime, 0.0f);
+		upper = std::min(elapsedTime, mLength );
 	}
-	// Das ganze r&#252;ckw&#228;rts
+	// Das ganze rckw&#239;&#191;&#189;ts
 	else
 	{
-		// FIXME f&#252;r die erste Runde beim R&#252;ckw&#228;rtsspielen, beginnt leider bei 0, nicht Length
+		// FIXME fr die erste Runde beim Rckw&#239;&#191;&#189;tsspielen, beginnt leider bei 0, nicht Length
 		Ogre::Real timePos = elapsedTime;
 		if( timePos == 0.0f )
 			timePos = mLength;
 
-		lower = max(timePos-timePassed, 0.0f);
-		upper = min(timePos, mLength );
+		lower = std::max(timePos-timePassed, 0.0f);
+		upper = std::min(timePos, mLength );
 	}
 
-	// Iteratoren f&#252;r die Grenzen holen
+	// Iteratoren fr die Grenzen holen
 	lowerBorder = mAnimationFrameListener.lower_bound(
 		lower);
 	upperBorder = mAnimationFrameListener.upper_bound(
@@ -362,21 +362,21 @@
 
 	// Einmal abspielen abziehen
 	timePassed -= mLength;
-	// Ums Wrapping k&#252;mmern - wenn Looping - und AbspielZeit
+	// Ums Wrapping kmmern - wenn Looping - und AbspielZeit
 	if( timePassed &gt; 0 &amp;&amp; isLoop() &amp;&amp; 
-		// Falls begrenzte Wiederholungen, m&#252;ssen mindestens 2(1+die oben abgearbeitete) fehlen
+		// Falls begrenzte Wiederholungen, mssen mindestens 2(1+die oben abgearbeitete) fehlen
 		( ( mTimesToPlay &gt; 0 &amp;&amp; getTimesToPlayLeft() &gt; 1 ) || ( mTimesToPlay == 0 ) )
 	   )
 	{
-		// Wie oft passt die L&#228;nge in die gesamte fortgeschrittene Zeit		
+		// Wie oft passt die L&#239;&#191;&#189;ge in die gesamte fortgeschrittene Zeit		
 		unsigned int timesSkipped = floor( timePassed/mLength );
 		Ogre::Real timeLeft = timePassed - timesSkipped*mLength;
 
-		// Falls die Abspielanzahlbegrenzt ist, nicht h&#228;ufiger als verbliebene Anzahl abspielen
+		// Falls die Abspielanzahlbegrenzt ist, nicht h&#239;&#191;&#189;figer als verbliebene Anzahl abspielen
 		if( mTimesToPlay &gt; 0 &amp;&amp; timesSkipped &gt;= getTimesToPlayLeft()-1)
 		{
 			timesSkipped = getTimesToPlayLeft()-1;
-			// Restzeit unwichtig, letzen Abspielvorg&#228;nge waren komplette
+			// Restzeit unwichtig, letzen Abspielvorg&#239;&#191;&#189;ge waren komplette
 			timeLeft = 0;
 		}
 
@@ -393,7 +393,7 @@
 			}
 		}		
 
-		// F&#252;r letzten Event pr&#252;fen, wenn noch Restzeit vorhanden ist
+		// Fr letzten Event prfen, wenn noch Restzeit vorhanden ist
 		if( timeLeft &gt; 0 )
 		{
 			// Wrapping nach oben

Modified: rl/trunk/engine/core/src/BoxPrimitive.cpp
===================================================================
--- rl/trunk/engine/core/src/BoxPrimitive.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/core/src/BoxPrimitive.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -19,6 +19,7 @@
 #include &quot;CoreSubsystem.h&quot;
 
 using namespace Ogre;
+using namespace std;
 
 namespace rl {
 

Modified: rl/trunk/engine/core/src/ConfigurationManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/core/src/ConfigurationManager.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -25,6 +25,8 @@
 
 template&lt;&gt; rl::ConfigurationManager* Ogre::Singleton&lt;rl::ConfigurationManager&gt;::ms_Singleton = 0;
 
+using namespace std;
+
 namespace rl
 {
     ConfigurationManager* ConfigurationManager::getSingletonPtr()
@@ -173,7 +175,7 @@
     {
         // On Linux, we create the .rastullah directory
 #       if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-        fs::path rastullahCfgDirectory(string(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah&quot;,
+        fs::path rastullahCfgDirectory(Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah&quot;,
             fs::portable_posix_name);
 
         if (!fs::exists(rastullahCfgDirectory))
@@ -300,7 +302,7 @@
         if (mRastullahLogDirectory.empty())
         {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_LINUX
-            mRastullahLogDirectory = string(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/logs&quot;;
+            mRastullahLogDirectory = Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/logs&quot;;
 #           else
             mRastullahLogDirectory = &quot;./logs&quot;;
 #           endif
@@ -375,7 +377,7 @@
         cfgfile-&gt;addSection(&quot;Input&quot;, mInputSettings);
 
 #       if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-        cfgfile-&gt;save(fs::path(&quot;./modules/config/&quot; + mRastullahCfgFile).native_file_string());
+        cfgfile-&gt;save(fs::path(&quot;./modules/config/&quot; + mRastullahCfgFile).native_file_Ogre::String());
 #       else
         cfgfile-&gt;save(Ogre::String(::getenv(&quot;HOME&quot;)) + &quot;/.rastullah/&quot; + mRastullahCfgFile);
 #       endif
@@ -518,7 +520,7 @@
 #       endif
     }
 
-    void ConfigurationManager::addToCfgPath(const std::string&amp; path)
+    void ConfigurationManager::addToCfgPath(const Ogre::String&amp; path)
     {
         std::cout &lt;&lt; &quot;Checking for &quot; &lt;&lt; mRastullahCfgFile &lt;&lt; &quot; in &quot; &lt;&lt; path &lt;&lt; std::endl;
 
@@ -538,7 +540,7 @@
         }
     }
 
-    bool ConfigurationManager::checkForFile(const std::string&amp; filename)
+    bool ConfigurationManager::checkForFile(const Ogre::String&amp; filename)
     {
         try {
 #           if OGRE_PLATFORM == OGRE_PLATFORM_WIN32

Modified: rl/trunk/engine/core/src/GameAreaEventSource.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaEventSource.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/core/src/GameAreaEventSource.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -17,7 +17,7 @@
 #include &quot;GameAreaEventSource.h&quot;
 #include &quot;ScriptWrapper.h&quot;
 
-// F&#252;r Intersection und so :)
+// Fr Intersection und so :)
 #include &lt;algorithm&gt;
 
 namespace rl {
@@ -44,27 +44,27 @@
 		if( !mAreaEventCaster.hasEventListeners() )
 			return;
 
-        // Position &#252;bertragen
+        // Position bertragen
         mAreaType-&gt;setQueryPosition( mActor-&gt;getWorldPosition() );       
         ActorMap currInside = mAreaType-&gt;performQuery();
         // Der Actor um den herum die Quelle ist, wird vermutlich auch gefunden :)
-        // Also rausl&#246;schen
+        // Also rausl&#239;&#191;&#189;chen
         currInside.erase( mActor-&gt;getName() );
 
         ActorMap enteredMap, leftMap;
         // EinfuegeIteratoren erstellen        
-        insert_iterator&lt;ActorMap&gt; enteredInsert(enteredMap, enteredMap.begin());
-        insert_iterator&lt;ActorMap&gt; leftInsert(leftMap, leftMap.begin());
+        std::insert_iterator&lt;ActorMap&gt; enteredInsert(enteredMap, enteredMap.begin());
+        std::insert_iterator&lt;ActorMap&gt; leftInsert(leftMap, leftMap.begin());
 
         // Alle feststellen die rausgefallen sind
-        set_difference( mInsideAreaList.begin(), mInsideAreaList.end(),
+        std::set_difference( mInsideAreaList.begin(), mInsideAreaList.end(),
                         currInside.begin(), currInside.end(), leftInsert );
         
         // Alle feststellen die neu hinzugekommen sind
-        set_difference( currInside.begin(), currInside.end(),
+        std::set_difference( currInside.begin(), currInside.end(),
             mInsideAreaList.begin(), mInsideAreaList.end(), enteredInsert );
 
-        // Die &#220;briggebliebenen in mInsideAreaList speichern
+        // Die &#239;&#191;&#189;riggebliebenen in mInsideAreaList speichern
         mInsideAreaList = currInside;
 
         // Die Neuen und die Rausgefallenen an die Listener dispatchen
@@ -78,7 +78,7 @@
         Actor* actor;
 
         GameAreaEvent* event = new GameAreaEvent( this, GameAreaEvent::AREA_LEFT );
-        // Erst werden alle Listener f&#252;r jedes verlassende Object einmal benachrichtigt
+        // Erst werden alle Listener fr jedes verlassende Object einmal benachrichtigt
         for( it = leavingActors.begin(); it != leavingActors.end();++it) 
         {
             actor = it-&gt;second;
@@ -87,7 +87,7 @@
         }
 
         event-&gt;setReason( GameAreaEvent::AREA_ENTERED );
-        // Dann werden alle Listener f&#252;r jedes betretende Object einmal benachrichtigt
+        // Dann werden alle Listener fr jedes betretende Object einmal benachrichtigt
         for( it = enteringActors.begin(); it != enteringActors.end();++it) 
         {
             actor = it-&gt;second;

Modified: rl/trunk/engine/rules/include/Container.h
===================================================================
--- rl/trunk/engine/rules/include/Container.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/include/Container.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -23,9 +23,9 @@
 
 namespace rl
 {
-    typedef set&lt;Item*&gt; ItemSet;
+    typedef std::set&lt;Item*&gt; ItemSet;
 
-    /// Behaelter f&#252;r Items.
+    /// Behaelter fr Items.
     class _RlRulesExport Container : public Item
     {
     public:
@@ -44,9 +44,9 @@
         /// Fassungsvermoegen in Unzen
         void setCapacity(Ogre::Real capacity);
 
-		// Volumen in x (breite) * y (hoehe)
-		void setVolume(unsigned int x, unsigned int y);
-        pair&lt;unsigned int, unsigned int&gt; getVolume() const;
+	// Volumen in x (breite) * y (hoehe)
+	void setVolume(unsigned int x, unsigned int y);
+        std::pair&lt;unsigned int, unsigned int&gt; getVolume() const;
 
         /// ist dieser Gegenstand ein Container
         virtual bool isContainer() const;
@@ -60,7 +60,7 @@
 
         ItemSet getItems() const;
 
-		int getItemCount() const;
+	int getItemCount() const;
 
         bool isFree(unsigned int x, unsigned int y) const;
         Item* getItemAt(unsigned int x, unsigned int y) const;
@@ -74,11 +74,11 @@
 
     private:
         Ogre::Real mCapacity;
-		pair&lt;unsigned int,unsigned int&gt; mVolume;
+	std::pair&lt;unsigned int,unsigned int&gt; mVolume;
 		
 		// Speichert, wo die Items sich im Container befinden.
 		// Speichert also die IDs der Objekte in die einzelnen Volumenfelder
-		int objIDMap [1][1];
+	int objIDMap [1][1];
 
         ItemSet mItems;
 

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/include/Creature.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -20,9 +20,6 @@
 
 #include &quot;GameObject.h&quot;
 #include &quot;Eigenschaft.h&quot;
-#include &quot;Inventory.h&quot;
-#include &quot;Container.h&quot;
-#include &quot;Weapon.h&quot;
 #include &quot;EigenschaftenStateSet.h&quot;
 #include &quot;TalentStateSet.h&quot;
 #include &quot;ZauberStateSet.h&quot;
@@ -31,12 +28,13 @@
 
 //#include &quot;CompositeEffect.h&quot;
 
-using namespace std;
-
 namespace rl
 {
-	class Effect;
+    class Container;
+    class Effect;
+    class Inventory;
     class Item;
+    class Weapon;
 
 ///////////////////////////////////////////////////////////////////////////////
 // Konstanten
@@ -109,7 +107,7 @@
 		 *  Liste der Talente. Besteht aus den Namen der Talente (z.B. Athletik)
          *  als Schluessel und ihrem Wert.
 		 **/
-		typedef map&lt;const CeGuiString, TalentStateSet*&gt; TalentMap;
+		typedef std::map&lt;const CeGuiString, TalentStateSet*&gt; TalentMap;
 
         static const Ogre::String CLASS_NAME;
 
@@ -272,7 +270,7 @@
          **/
         int getAp();
         /**
-         *  Ver&#228;ndert die verbrauchten @ref abbdea &quot;AP&quot;, wird beim Steigern
+         *  Ver&#239;&#191;&#189;dert die verbrauchten @ref abbdea &quot;AP&quot;, wird beim Steigern
          *  aufgerufen.
          *  @param modifier Kann auch negativ sein (z.B. Borbarad-Moskitos).
          **/
@@ -402,16 +400,16 @@
 		 *  @throws InvalidArgumentExeption Die Kampftechnik ist unbekannt.
          *  @ingroup CreatureRubyExports
 		 **/
-		void addKampftechnik(const CeGuiString kampftechnikName, const pair&lt;int,int&gt;&amp; value = make_pair(0,0));
+		void addKampftechnik(const CeGuiString kampftechnikName, const std::pair&lt;int,int&gt;&amp; value = std::make_pair(0,0));
 		/** 
          *  Liefert die @ref abbdea &quot;AT&quot; und @ref abbdep &quot;PA&quot; Werte in einer 
          *  bestimmten Kampftechnik zurueck.
 		 *  @param kampftechnikName Beszeichnet die Kampftechnik.
-		 *  @return Ein pair&lt;AT, PA&gt;.
+		 *  @return Ein std::pair&lt;AT, PA&gt;.
 		 *  @throws InvalidArgumentException \a kampftechnikId konnte nicht in 
 		 *   \c mKampftechniken gefunden werden.
 		 **/
-        virtual pair&lt;int, int&gt; getKampftechnik(const CeGuiString kampftechnikName) const;
+        virtual std::pair&lt;int, int&gt; getKampftechnik(const CeGuiString kampftechnikName) const;
 		/** 
          *  Setzt die @ref abbdea &quot;AT&quot; und @ref abbdep &quot;PA&quot; Werte in einer bestimmten 
          *  Kampftechnik.
@@ -420,7 +418,7 @@
 		 *  @throws InvalidArgumentException Die Kampftechnik \a kampftechnikId
 		 *    konnte nicht in \c mKampftechniken gefunden werden.
 		 **/
-        virtual void setKampftechnik(const CeGuiString kampftechnikName, const pair&lt;int, int&gt;&amp; value);
+        virtual void setKampftechnik(const CeGuiString kampftechnikName, const std::pair&lt;int, int&gt;&amp; value);
 
 ///////////////////////////////////////////////////////////////////////////////
 // Vorteile
@@ -844,13 +842,13 @@
          *  Liste der Werte.
          *  @see Wert
          **/
-		typedef map&lt;const Wert, StateSet*&gt; WertMap;
+		typedef std::map&lt;const Wert, StateSet*&gt; WertMap;
 		/** 
          *  Liste der guten Eigenschaften. Besteht aus dem Abkuerzung der 
          *  Eigenschaft (z.B. @ref abbdem &quot;MU&quot;, @ref abbdek &quot;KL&quot;) als Schluessel 
          *  und einem Zeiger auf ihr StateSet.
 		 **/
-		typedef map&lt;const CeGuiString, EigenschaftenStateSet*&gt; EigenschaftMap;
+		typedef std::map&lt;const CeGuiString, EigenschaftenStateSet*&gt; EigenschaftMap;
 		/**
 		 *  Liste der Kampftechniken und ihrer @ref abbdea &quot;AT&quot;/@ref abbdep &quot;PA2 Werte.
 		 *  Eine Kampftechnik in diesem Sinne ist so was wie Hiebwaffen
@@ -860,22 +858,22 @@
 		 *  AT/PA Werte ergeben. Die Summe des pairs muss also dem TaW in dem
 		 *  Kampftalent entsprechen.
 		 **/
-        typedef map&lt;const CeGuiString, pair&lt;int, int&gt; &gt; KampftechnikMap;
+        typedef std::map&lt;const CeGuiString, std::pair&lt;int, int&gt; &gt; KampftechnikMap;
         /**
          *  Eine Liste der Vorteile der Kreatur. Gaben gehoeren ebenfalls zu 
          *  den Vorteilen, verhalten sich aber wie Talente.
          **/
-        typedef map&lt;const CeGuiString, TalentStateSet*&gt; VorteilMap;
+        typedef std::map&lt;const CeGuiString, TalentStateSet*&gt; VorteilMap;
         /**
          *  Eine Liste der Nachteile der Kreatur. Schlechte Eigenschaften gehoeren 
          *  ebenfalls zu den Nachteilen, verhalten sich aber wie Eigenschaften.
          **/
-        typedef map&lt;const CeGuiString, EigenschaftenStateSet*&gt; NachteilMap;
+        typedef std::map&lt;const CeGuiString, EigenschaftenStateSet*&gt; NachteilMap;
 		/** 
          *  Die Sonderfertigkeiten der Kreatur. Besteht aus dem Namen der 
          *  Sonderfertigkeit als Schluessel und ihrem Status.
 		 */
-		typedef map&lt;const CeGuiString ,SonderfertigkeitenStateSet*&gt; SonderfertigkeitMap;
+		typedef std::map&lt;const CeGuiString ,SonderfertigkeitenStateSet*&gt; SonderfertigkeitMap;
 
         struct Ap
         {

Modified: rl/trunk/engine/rules/include/Inventory.h
===================================================================
--- rl/trunk/engine/rules/include/Inventory.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/include/Inventory.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -50,7 +50,7 @@
 	/**
 	* Liefert alle Items im Inventar inm einer Liste
 	* Wichtig:
-	* NUR die erste Hierarchieebene der Items wird zur&#252;ckgegeben
+	* NUR die erste Hierarchieebene der Items wird zurckgegeben
 	* Was in den Items drinnen ist, ist vernachlaessigt
 	*/
 	ItemList getAllItems();
@@ -64,10 +64,10 @@
 	/**
 	 * @return Die errechnete Behinderung
 	 **/
-	pair&lt;int,int&gt; getOverallBe();
+	std::pair&lt;int,int&gt; getOverallBe();
 
 	/**
-	* @return die gesamte R&#252;stung des Chars
+	* @return die gesamte Rstung des Chars
 	*/
 	int getOverallRs();
 
@@ -94,12 +94,12 @@
 	Creature* mOwner;
 
 	/**
-	* Setzt Flag, dass die Werte neu berechnet werden m&#252;ssen
+	* Setzt Flag, dass die Werte neu berechnet werden mssen
 	*/
 	void markDirty();
 
 	/**
-	* Update der Werte f&#252;r Gewicht, Rs und Behinderung
+	* Update der Werte fr Gewicht, Rs und Behinderung
 	*/
 	void updateStats();
 

Modified: rl/trunk/engine/rules/include/Item.h
===================================================================
--- rl/trunk/engine/rules/include/Item.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/include/Item.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -23,8 +23,8 @@
 {
 	class _RlRulesExport Item;
 
-	typedef vector&lt;Item*&gt; ContainerColumn;
-	typedef vector&lt;ContainerColumn&gt; ContainerLayout;
+	typedef std::vector&lt;Item*&gt; ContainerColumn;
+	typedef std::vector&lt;ContainerColumn&gt; ContainerLayout;
 
 
     /// Aufnehmbare Objekte in der Spielwelt.
@@ -79,7 +79,7 @@
 
 		/**
 		 * @return ob es sich um ein Item handelt,
-		 * in dem andere gespeichert werden k&#246;nnen
+		 * in dem andere gespeichert werden k&#239;&#191;&#189;nen
 		 */
         virtual bool isContainer() const;
 		
@@ -107,9 +107,9 @@
 
 
 		/**
-		* Generiert einen Text mit Zeilenumbr&#252;chen, aus dem String.
+		* Generiert einen Text mit Zeilenumbrchen, aus dem String.
 		* @param unformattedText Der zu formatierende Text
-		* @return CeGuiString der Text mit eingef&#252;gten Enter-symbolen
+		* @return CeGuiString der Text mit eingefgten Enter-symbolen
 		*/
 		static CeGuiString getFormattedText(const CeGuiString &amp;unformattedText);
     };

Modified: rl/trunk/engine/rules/include/Weapon.h
===================================================================
--- rl/trunk/engine/rules/include/Weapon.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/include/Weapon.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -44,13 +44,13 @@
 		void setTp(int d6, int d20, int mod);
 		const Tripel&lt;int&gt;&amp; getTp() const;
 		void setTpKk(int base, int step);
-		const pair&lt;int, int&gt;&amp; getTpKk() const;
+		const std::pair&lt;int, int&gt;&amp; getTpKk() const;
 		void setBf(int newBf);
 		int getBf();
 		void setIni(int newIni);
 		int getIni();
-		void setWm(pair&lt;int, int&gt;&amp; newWm);
-		const pair&lt;int,int&gt;&amp; getWm() const;
+		void setWm(std::pair&lt;int, int&gt;&amp; newWm);
+		const std::pair&lt;int,int&gt;&amp; getWm() const;
 		void setDk(Distanzklasse newDk);
 		Distanzklasse getDk();
 		void setKampftechnik(const CeGuiString newKampftechnik);
@@ -62,10 +62,10 @@
 
 	private:
 		Tripel&lt;int&gt; mTp;
-		pair&lt;int, int&gt; mTpKk;
+		std::pair&lt;int, int&gt; mTpKk;
 		int mBf;
 		int mIni;
-		pair&lt;int, int&gt; mWm;
+		std::pair&lt;int, int&gt; mWm;
 		Distanzklasse mDk;
 		CeGuiString mKampftechnik;
 	};

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -16,17 +16,23 @@
 #include &quot;Creature.h&quot;
 
 #include &quot;Actor.h&quot;
+#include &quot;Container.h&quot;
 #include &quot;DsaManager.h&quot;
 #include &quot;Eigenschaft.h&quot;
 #include &quot;Exception.h&quot;
+#include &quot;Inventory.h&quot;
 #include &quot;Kampftechnik.h&quot;
 #include &quot;MeshObject.h&quot;
 #include &quot;StateSet.h&quot;
 #include &quot;Talent.h&quot;
-#include &quot;Inventory.h&quot;
+#include &quot;Weapon.h&quot;
+
+///@todo Just for debugging, remove when not needed anymore
 #include &quot;CoreSubsystem.h&quot;
 #include &quot;RubyInterpreter.h&quot;
 
+using namespace std;
+
 namespace rl
 {
     const Ogre::String Creature::CLASS_NAME = &quot;Creature&quot;;
@@ -36,7 +42,7 @@
 		mCurrentLe(0),
         mCurrentAu(0),
         mCurrentAe(0),
-		mActiveWeapon(NULL),
+	mActiveWeapon(NULL),
 		mInventory(NULL),
 		mEigenschaften(),
 		mWerte(),

Modified: rl/trunk/engine/rules/src/DsaDataLoader.cpp
===================================================================
--- rl/trunk/engine/rules/src/DsaDataLoader.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/src/DsaDataLoader.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -136,7 +136,7 @@
         return t;
     }
 
-	int XdimlLoader::getEBeFromString(const string&amp; eBeString)
+	int XdimlLoader::getEBeFromString(const Ogre::String&amp; eBeString)
 	{
 		if (eBeString.length() == 0)
 			return EBE_KEINE_BE;
@@ -144,7 +144,7 @@
 		if (!(eBeString.substr(0, 2).compare(&quot;BE&quot;)) == 0)
 			Throw(IllegalArgumentException, &quot;Ungueltige EBE-Angabe.&quot;);
 
-		string ebe = eBeString.substr(2);
+		Ogre::String ebe = eBeString.substr(2);
 		if (ebe.compare(&quot;x2&quot;) == 0)
 			return EBE_BEx2;
 		if (ebe.compare(&quot;&quot;) == 0)
@@ -234,7 +234,7 @@
 		DOMNodeList* eigensch = 
 			XmlHelper::getChildNamed(personXml, &quot;Eigenschaften&quot;)-&gt;
 				getElementsByTagName(EIGENSCHAFT.data());
-		// Die Eigenschaftsnamen m&#252;ssen durch ihre Abk&#252;rzung ersetzt werden.
+		// Die Eigenschaftsnamen mssen durch ihre Abkrzung ersetzt werden.
 		for (unsigned int idx = 0; idx &lt; eigensch-&gt;getLength(); idx++)
 		{
 			DOMElement* eigenschXml = static_cast&lt;DOMElement*&gt;(eigensch-&gt;item(idx));

Modified: rl/trunk/engine/rules/src/GameObjectManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/src/GameObjectManager.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -17,6 +17,7 @@
 
 #include &quot;Armor.h&quot;
 #include &quot;CoreSubsystem.h&quot;
+#include &quot;Container.h&quot;
 #include &quot;Creature.h&quot;
 #include &quot;Exception.h&quot;
 #include &quot;GameObject.h&quot;

Modified: rl/trunk/engine/rules/src/QuestBook.cpp
===================================================================
--- rl/trunk/engine/rules/src/QuestBook.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/rules/src/QuestBook.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -19,6 +19,8 @@
 #include &quot;Exception.h&quot;
 #include &quot;ScriptWrapper.h&quot;
 
+using namespace std;
+
 namespace rl {
 
 QuestBook::QuestBook()

Modified: rl/trunk/engine/script/swig/RlExports.i
===================================================================
--- rl/trunk/engine/script/swig/RlExports.i	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/script/swig/RlExports.i	2007-03-02 13:59:13 UTC (rev 3109)
@@ -89,14 +89,14 @@
 // Error Handling for Ruby
 void RL_handleRubyError( VALUE error )
 {
-	stringstream stream;	
+	std::stringstream stream;	
 	// get error class
     VALUE klass = rb_class_path(CLASS_OF(error));
     stream &lt;&lt; RSTRING(klass)-&gt;ptr &lt;&lt; &quot; (&quot;; 
 
     // get error message
     VALUE message = rb_obj_as_string(error);
-    stream &lt;&lt; RSTRING(message)-&gt;ptr &lt;&lt; &quot;) &quot; &lt;&lt; endl;
+    stream &lt;&lt; RSTRING(message)-&gt;ptr &lt;&lt; &quot;) &quot; &lt;&lt; std::endl;
 
     // get backtrace
     if(!NIL_P(ruby_errinfo)) 
@@ -207,7 +207,7 @@
 		$result = val;
 } 
 
-// Animation* getActor oder andere OUTPUT Parameter f&#252;r DYNAMICs
+// Animation* getActor oder andere OUTPUT Parameter fr DYNAMICs
 %typemap(out) SWIGTYPE* DYNAMIC, SWIGTYPE&amp; DYNAMIC
 {
 	VALUE val = SWIG_RubyInstanceFor( $1 );
@@ -215,7 +215,7 @@
 	// Es gab das SkriptObjekt noch nicht
 	if (NIL_P(val))
 	{
-		// Dynamic Cast ausf&#252;hren
+		// Dynamic Cast ausfhren
 		swig_type_info *ty = SWIG_TypeDynamicCast($1_descriptor, (void **) &amp;$1);
 		$result = SWIG_NewPointerObj((void *) $1, ty, 0);		
 	}
@@ -223,7 +223,7 @@
 		$result = val;
 } 
 
-// doWithAnimation( Animation* ) oder andere Director-Methoden Parameter f&#252;r DYNAMICs
+// doWithAnimation( Animation* ) oder andere Director-Methoden Parameter fr DYNAMICs
 %typemap(directorin) SWIGTYPE* DYNAMIC, SWIGTYPE&amp; DYNAMIC
 {
 	// Auf Director testen
@@ -238,7 +238,7 @@
 		
 		// Es gab das SkriptObjekt noch nicht
 		if (NIL_P(val)) {
-			// Dynamic Cast ausf&#252;hren
+			// Dynamic Cast ausfhren
 			swig_type_info *ty = SWIG_TypeDynamicCast($1_descriptor, (void **) &amp;$1);
 			$input = SWIG_NewPointerObj((void *) $1, ty, 0);		
 		}

Modified: rl/trunk/engine/script/swig/RlRules.swig
===================================================================
--- rl/trunk/engine/script/swig/RlRules.swig	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/script/swig/RlRules.swig	2007-03-02 13:59:13 UTC (rev 3109)
@@ -430,13 +430,13 @@
 		void setTp(int d6, int d20, int mod);
 		const Tripel&lt;int&gt;&amp; getTp() const;
 		void setTpKk(int base, int step);
-		const pair&lt;int, int&gt;&amp; getTpKk() const;
+		const std::pair&lt;int, int&gt;&amp; getTpKk() const;
 		void setBf(int newBf);
 		int getBf();
 		void setIni(int newIni);
 		int getIni();
-		void setWm(pair&lt;int, int&gt;&amp; newWm);
-		const pair&lt;int,int&gt;&amp; getWm() const;
+		void setWm(std::pair&lt;int, int&gt;&amp; newWm);
+		const std::pair&lt;int,int&gt;&amp; getWm() const;
 		void setDk(Weapon::Distanzklasse newDk);
 		Weapon::Distanzklasse getDk();
 		void setKampftechnik(const rl::CeGuiString newKampftechnik);

Modified: rl/trunk/engine/script/swig/TypeOgreQuaternion.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeOgreQuaternion.swig	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/script/swig/TypeOgreQuaternion.swig	2007-03-02 13:59:13 UTC (rev 3109)
@@ -16,7 +16,7 @@
 
 /* Typemaps fuer Quaternion.
  * Ein Quaternion wird auf ein Array aus einem 3-elementigen Array 
- * f&#252;r die Rotationsachse und einem Wert f&#252;r den Winkel abgebildet
+ * fr die Rotationsachse und einem Wert fr den Winkel abgebildet
  * 
  */
 
@@ -82,7 +82,7 @@
    }
    else if (RARRAY($input)-&gt;len == 3)
    {
-	   Quaternion rotX, rotY, rotZ;
+	   Ogre::Quaternion rotX, rotY, rotZ;
         rotX.FromAngleAxis(
 			Ogre::Degree(NUM2DBL(rb_ary_entry($input, 0))), 
 			Ogre::Vector3::UNIT_X);
@@ -124,7 +124,7 @@
    }
    else if (RARRAY($input)-&gt;len == 3)
    {
-	   Quaternion rotX, rotY, rotZ;
+	   Ogre::Quaternion rotX, rotY, rotZ;
         rotX.FromAngleAxis(
 			Ogre::Degree(NUM2DBL(rb_ary_entry($input, 0))), 
 			Ogre::Vector3::UNIT_X);
@@ -155,8 +155,8 @@
 
 
 %typemap(out) Ogre::Quaternion, const Ogre::Quaternion {
-   Degree angle;
-   Vector3 axis;
+   Ogre::Degree angle;
+   Ogre::Vector3 axis;
    
    $1.ToAngleAxis(angle, axis);
    
@@ -172,8 +172,8 @@
 }
 
 %typemap(out) Ogre::Quaternion*, const Ogre::Quaternion*, const Ogre::Quaternion&amp;, Ogre::Quaternion&amp; {
-   Degree angle;
-   Vector3 axis;
+   Ogre::Degree angle;
+   Ogre::Vector3 axis;
    
    $1-&gt;ToAngleAxis(angle, axis);
    

Modified: rl/trunk/engine/script/swig/TypeRlProperty.swig
===================================================================
--- rl/trunk/engine/script/swig/TypeRlProperty.swig	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/script/swig/TypeRlProperty.swig	2007-03-02 13:59:13 UTC (rev 3109)
@@ -17,9 +17,9 @@
 %{
 namespace rl {
 
-Property convertValueToProperty(VALUE input)
+rl::Property convertValueToProperty(VALUE input)
 {
-	Property rval;
+	rl::Property rval;
 	if (TYPE(input) == T_FLOAT)
     {
 	    rval.setValue(Ogre::Real(NUM2DBL(input)));
@@ -71,7 +71,7 @@
 			}
 			else // Array of Properties
 			{
-				std::vector&lt;Property&gt; vec;
+				std::vector&lt;rl::Property&gt; vec;
 				for (int idx = 0; idx &lt; length; idx++)
 				{
 					vec.push_back(rl::convertValueToProperty(rb_ary_entry(input, 0)));
@@ -84,7 +84,7 @@
     return rval;
 }
 
-VALUE convertPropertyToValue(Property input)
+VALUE convertPropertyToValue(rl::Property input)
 {
 	if (input.isString())
     {
@@ -131,9 +131,9 @@
     }
     else if (input.isArray())
     {
-		std::vector&lt;Property&gt; vec = input.toArray();
+		std::vector&lt;rl::Property&gt; vec = input.toArray();
 		VALUE rval = rb_ary_new();
-		for (std::vector&lt;Property&gt;::const_iterator it = vec.begin();
+		for (std::vector&lt;rl::Property&gt;::const_iterator it = vec.begin();
 			it != vec.end(); it++)
 		{
 			rb_ary_push(rval, rl::convertPropertyToValue(*it));

Deleted: rl/trunk/engine/ui/include/CommandExecutor.h
===================================================================
--- rl/trunk/engine/ui/include/CommandExecutor.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/include/CommandExecutor.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -1,27 +0,0 @@
-#ifndef __CommandExecutor_h__
-#define __CommandExecutor_h__
-
-#include &quot;UiPrerequisites.h&quot;
-#include &lt;vector&gt;
-
-namespace rl {
-
-	/**
-	* Diese Klasse enth&#228;lt die ausf&#252;hrbaren Spieleraktionen, welche mit einer Taste verbunden werden
-	* k&#246;nnen
-	* 
-	* pure virtual - von dieser Klasse muss in Ruby geerbt werden, hier ist nur das Interface definiert
-	*/
-	class _RlUiExport CommandExecutor
-	{
-	public:
-		virtual ~CommandExecutor();
-
-		virtual CeGuiStringVector getCommandsInBattle();
-		virtual CeGuiStringVector getCommandsOffBattle();
-		virtual void executeCommand(CeGuiString command);
-	};
-
-}
-
-#endif

Modified: rl/trunk/engine/ui/include/DialogWindow.h
===================================================================
--- rl/trunk/engine/ui/include/DialogWindow.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/include/DialogWindow.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -41,9 +41,9 @@
 
 		void getResponse(const CeGuiString&amp; msg);
 		unsigned int count();
-		void setCallback(std::string function);
-		void setName(std::string name);
-		void setImage(std::string imageset, std::string image);
+		void setCallback(Ogre::String function);
+		void setName(Ogre::String name);
+		void setImage(Ogre::String imageset, Ogre::String image);
 		int getSelectedOption();
 
 		void textFinished();

Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-03-02 13:59:13 UTC (rev 3109)
@@ -44,7 +44,7 @@
 		InventoryWindow();
 		~InventoryWindow();
 
-		// Flag f&#252;r den ArrangeTask - FIXME nach private umziehen, wenn 
+		// Flag fr den ArrangeTask - FIXME nach private umziehen, wenn 
 		CEGUI::DragContainer* mDroppedItem;
 
 		/**
@@ -53,17 +53,17 @@
 		void setInventory(Inventory* inventory);
 
 		/**
-		* Methode f&#252;r das OnMouseOver Event
+		* Methode fr das OnMouseOver Event
 		*/
 		bool handleMouseEnters(const CEGUI::EventArgs &amp;args);
 		
 		/**
-		* Methode f&#252;r das OnMouseLeaves Event
+		* Methode fr das OnMouseLeaves Event
 		*/
 		bool handleMouseLeaves(const CEGUI::EventArgs &amp;args);
 
 		/**
-		* Methode f&#252;r das OnMouseClick Event
+		* Methode fr das OnMouseClick Event
 		*/
 		bool handleMouseClicked(const CEGUI::EventArgs &amp;args);
 
@@ -73,13 +73,13 @@
 		void update();
 
 		/**
-		* &#220;bergibt &#228;nderungen ans Inventar
+		* &#239;&#191;&#189;ergibt &#239;&#191;&#189;derungen ans Inventar
 		*/
 		void updateInventory();
 
 		/**
 		* Passt die Position eines gedroppten Items an, da CEGUI Bug, braucht man 
-		* daf&#252;r ne externe Methode
+		* dafr ne externe Methode
 		*/
 		void updateItemPosition();
 
@@ -88,7 +88,7 @@
 		/**
 		* Schaut nach, ob das Item an der Position gedroppt werden kann.
 		*/
-		bool isFreeInContainer(Item* item, pair&lt;int,int&gt; kaestechenPos, Container* container);
+		bool isFreeInContainer(Item* item, std::pair&lt;int,int&gt; kaestechenPos, Container* container);
 
 
 		Item* getGroundItem();
@@ -96,7 +96,7 @@
 	private:
 		Inventory* mInventory;
 
-		// Farbschema f&#252;r die Fenster und Itemhintergr&#252;nde
+		// Farbschema fr die Fenster und Itemhintergrnde
 		const CeGuiString mColorAccept;
 		const CeGuiString mColorReject;
 		const CeGuiString mColorNormal;
@@ -110,7 +110,7 @@
 		Ogre::SceneNode* mInventoryItemNode;
 		// Entity des jeweils zu rendernden Items
 		Ogre::Entity* mRenderItemEntity;
-		// 128*128 Textur f&#252;r das Item-view Fenster
+		// 128*128 Textur fr das Item-view Fenster
 		Ogre::RenderTexture* mRenderTexture;
 		// Viewport des RenderToTexture Features
 		Ogre::Viewport* mRenderViewport;
@@ -126,7 +126,7 @@
 		CEGUI::Window* mItemRenderImage;
 
 
-		// Das R&#252;stungs- und Behinderungswert Fenster
+		// Das Rstungs- und Behinderungswert Fenster
 		CEGUI::Window* mArmorValueWindow;
 		CEGUI::Window* mArmorValue;
 		CEGUI::Window* mHandicapValue;
@@ -139,7 +139,7 @@
 		// Das Item-Beschreibungsfenster
 		CEGUI::ScrollablePane* mDescription;
 
-		// Das jeweils aktive Fenster, das im Beschreibungsfenster angew&#228;hlt ist
+		// Das jeweils aktive Fenster, das im Beschreibungsfenster angew&#239;&#191;&#189;lt ist
 		CEGUI::Window* mActiveItemWindow;
 
 		// Das Fenster, in das der Rucksackcontainer soll
@@ -188,7 +188,7 @@
 		void initRenderToTexture();
 
 		/**
-		* L&#228;dt die Rtt-Camera
+		* L&#239;&#191;&#189;t die Rtt-Camera
 		*/
 		void loadCamera();
 		void unloadCamera();
@@ -204,12 +204,12 @@
 		void initSlots();
 
 		/**
-		* F&#252;llt die Slots im InventarFenster mit den Items aus dem Inventar
+		* Fllt die Slots im InventarFenster mit den Items aus dem Inventar
 		*/
 		void fillSlots();
 
 		/**
-		* Erzeugt ein Tab f&#252;r den Container, und befuellt ihn nach Inhalt des container - Items
+		* Erzeugt ein Tab fr den Container, und befuellt ihn nach Inhalt des container - Items
 		*/
 		void createAndFillContainer(Container* container);
 
@@ -227,7 +227,7 @@
 		void refreshTabs();
 
 		/**
-		* Sucht unter den Containern dasjenige, das zum gesuchten Container geh&#246;rt
+		* Sucht unter den Containern dasjenige, das zum gesuchten Container geh&#239;&#191;&#189;t
 		*/
 		CEGUI::Window* findContainer(Container* container);
 
@@ -237,25 +237,25 @@
 		*/
 		void emptySlot(CEGUI::Window* slot);
 		/** 
-		* Gibt dem Slot die F&#228;higkeit Dragcontainer zu akzeptieren
+		* Gibt dem Slot die F&#239;&#191;&#189;igkeit Dragcontainer zu akzeptieren
 		*/
 		void addDropListener(CEGUI::Window* slot);
 
 		/*!
-		* f&#252;gt dem Inventar den Container f&#252;r den Rucksack zu,
-		* gibt ihm die n&#246;tige Funktionalit&#228;t f&#252;r drag&amp;drop
+		* fgt dem Inventar den Container fr den Rucksack zu,
+		* gibt ihm die n&#239;&#191;&#189;ige Funktionalit&#239;&#191;&#189; fr drag&amp;drop
 		*/
 		void initBackpack(std::pair&lt;int,int&gt; dim);
 
 
 		/**
-		* erzeugt f&#252;r alle Items im Inventar, die Containerfunktionaltiaet haben, ein Containertab
+		* erzeugt fr alle Items im Inventar, die Containerfunktionaltiaet haben, ein Containertab
 		* im Inventar
 		*/
 		void createContainerWindows();
 
 		/**
-		* &#220;berpr&#252;ft, ob das gedroppte Item vom Slot akzeptiert wird oder nicht
+		* &#239;&#191;&#189;erprft, ob das gedroppte Item vom Slot akzeptiert wird oder nicht
 		* @return true: Item wird akzeptiert
 		*         false: Item wird nicht akzeptiert
 		*/ 
@@ -263,7 +263,7 @@
 
 
 		/**
-		* Errechnet die K&#228;stchenposition, an der das Item im Container gedroppt wurde
+		* Errechnet die K&#239;&#191;&#189;tchenposition, an der das Item im Container gedroppt wurde
 		*/
 		std::pair&lt;int,int&gt; calculateNewPosition(const CEGUI::DragDropEventArgs&amp; ddea);
 

Modified: rl/trunk/engine/ui/include/Makefile.am
===================================================================
--- rl/trunk/engine/ui/include/Makefile.am	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/include/Makefile.am	2007-03-02 13:59:13 UTC (rev 3109)
@@ -6,7 +6,6 @@
 	CharacterSheetWindow.h \
 	CharacterStateWindow.h \
 	CloseConfirmationWindow.h \
-	CommandExecutor.h \
 	CommandMapper.h \
 	CommandMapperWindow.h \
 	ConfigComponent.h \

Modified: rl/trunk/engine/ui/src/CharacterSheetWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/CharacterSheetWindow.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/src/CharacterSheetWindow.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -84,7 +84,7 @@
 
 void CharacterSheetWindow::update()
 {
-	    //TODO: Daten updaten
+	///@TODO: Daten updaten
 	updateTalents();
 	/*if (mCharacter-&gt;isMagic())
 		updateMagic();*/
@@ -94,8 +94,8 @@
 void CharacterSheetWindow::updateValues()
 {
 	mName-&gt;setText(&quot;Name: &quot;+mCharacter-&gt;getName());
-	mRasse-&gt;setText(string(&quot;Rasse: &quot;));
-	mProfession-&gt;setText(string(&quot;Profession: &quot;));
+	mRasse-&gt;setText(&quot;Rasse: &quot;);
+	mProfession-&gt;setText(&quot;Profession: &quot;);
 
 	mLE-&gt;setText(&quot;LeP: &quot;+
 		StringConverter::toString(mCharacter-&gt;getLe())+&quot;/&quot;+
@@ -161,18 +161,18 @@
 		mTalentTable-&gt;setItem(new ListboxTextItem(probe), 1, talentNum);
 		CeGuiString eBe;
 		if (talent-&gt;getEbe() == EBE_KEINE_BE)
-			eBe = (utf8*)&quot;-&quot;;
+			eBe = &quot;-&quot;;
 		else if (talent-&gt;getEbe() == EBE_BEx2)
-			eBe = (utf8*)&quot;BEx2&quot;;
+			eBe = &quot;BEx2&quot;;
 		else if (talent-&gt;getEbe() == 0)
-			eBe = (utf8*)&quot;BE&quot;;
+			eBe = &quot;BE&quot;;
 		else if (talent-&gt;getEbe() &gt; 0)
-			eBe = (utf8*)&quot;BE+&quot; + CeGuiString(StringConverter::toString(talent-&gt;getEbe()));
+			eBe = &quot;BE+&quot; + CEGUI::PropertyHelper::intToString(talent-&gt;getEbe());
 		else
-			eBe = (utf8*)&quot;BE&quot; + CeGuiString(StringConverter::toString(talent-&gt;getEbe()));
+			eBe = &quot;BE&quot; + CEGUI::PropertyHelper::intToString(talent-&gt;getEbe());
 
 		mTalentTable-&gt;setItem(new ListboxTextItem(eBe), 2, talentNum);
-		mTalentTable-&gt;setItem(new ListboxTextItem((utf8*)&quot;&quot;), 3, talentNum);
+		mTalentTable-&gt;setItem(new ListboxTextItem(&quot;&quot;), 3, talentNum);
 
 		talentNum++;
 	}

Deleted: rl/trunk/engine/ui/src/CommandExecutor.cpp
===================================================================
--- rl/trunk/engine/ui/src/CommandExecutor.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/src/CommandExecutor.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -1,24 +0,0 @@
-#include &quot;CommandExecutor.h&quot;
-
-namespace rl {
-
-	CommandExecutor::~CommandExecutor()
-	{
-	}
-
-	CeGuiStringVector CommandExecutor::getCommandsInBattle()
-	{
-		static CeGuiStringVector emptyvec;
-		return emptyvec;
-	}
-	
-	CeGuiStringVector CommandExecutor::getCommandsOffBattle()
-	{
-		static CeGuiStringVector emptyvec;
-		return emptyvec;
-	}
-	
-	void CommandExecutor::executeCommand(CeGuiString command)
-	{
-	}
-}

Modified: rl/trunk/engine/ui/src/DialogWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogWindow.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/src/DialogWindow.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -256,7 +256,7 @@
 	return mDialogOptions-&gt;getItemCount();
 }
 
-void DialogWindow::setCallback(string function)
+void DialogWindow::setCallback(Ogre::String function)
 {
 	// TO DO: DialogWindow::setCallback(string function)
 }
@@ -314,12 +314,12 @@
 	return true;
 }
 
-void DialogWindow::setImage(string imageset, string image)
+void DialogWindow::setImage(Ogre::String imageset, Ogre::String image)
 {
     mImage-&gt;setProperty(&quot;Image&quot;, &quot;set:&quot; + imageset + &quot; image:&quot; + image);
 }
 
-void DialogWindow::setName(string name)
+void DialogWindow::setName(Ogre::String name)
 {
 	mName-&gt;setProperty(&quot;Text&quot;, name);
 }

Modified: rl/trunk/engine/ui/src/InputManager.cpp
===================================================================
--- rl/trunk/engine/ui/src/InputManager.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/src/InputManager.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -46,11 +46,12 @@
 #include &quot;WindowFactory.h&quot;
 
 using namespace Ogre;
-
-template&lt;&gt; rl::InputManager* Singleton&lt;rl::InputManager&gt;::ms_Singleton = 0;
 using namespace OIS;
 using CEGUI::System;
+using namespace std;
 
+template&lt;&gt; rl::InputManager* Singleton&lt;rl::InputManager&gt;::ms_Singleton = 0;
+
 namespace rl {
 
     InputManager::InputManager(Ogre::RenderWindow* win) :

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -40,6 +40,7 @@
 
 using namespace CEGUI;
 using namespace Ogre;
+using namespace std;
 
 namespace rl {
 
@@ -172,7 +173,7 @@
 	{
 		// Aktualisiere Werte
 
-		// R&#252;stung
+		// Rstung
 		mArmorValue-&gt;setText(Ogre::StringConverter::toString(mInventory-&gt;getOverallRs()));
 
 		// Behinderung
@@ -180,11 +181,11 @@
 		mHandicapValue-&gt;setText(Ogre::StringConverter::toString(behinderung.first+behinderung.second));
 		if (behinderung.second &gt; 0)
 		{
-			mArmorValueWindow-&gt;setTooltipText(&quot;R&#252;stung / Behinderung\r\n           / +&quot;+Ogre::StringConverter::toString(behinderung.second)+&quot; &#252;berladen&quot;);
+			mArmorValueWindow-&gt;setTooltipText(&quot;Rstung / Behinderung\r\n           / +&quot;+Ogre::StringConverter::toString(behinderung.second)+&quot; berladen&quot;);
 		} 
 		else
 		{
-			mArmorValueWindow-&gt;setTooltipText(&quot;R&#252;stung / Behinderung&quot;);
+			mArmorValueWindow-&gt;setTooltipText(&quot;Rstung / Behinderung&quot;);
 		}
 
 		// Gewicht in Unzen
@@ -220,7 +221,7 @@
 		// Gegenstand vom Boden entfernen
 		//mInventory-&gt;removeItemFromContainer(item, mGroundItem);
 
-		// Welchem Item wird das Item hinzugef&#252;gt? -&gt; speichere das in die Variable container
+		// Welchem Item wird das Item hinzugefgt? -&gt; speichere das in die Variable container
 		Item* container = static_cast&lt;Item*&gt;(mContainerDraggedTo-&gt;getUserData());
 
 		// Extra Behandlung, falls Item auf den Boden gelegt wird
@@ -232,7 +233,7 @@
 			//	(int)(mPosDraggedTo.d_y/30),
 			//	container);
 
-			// Zus&#228;tzlich wenn Item Container war, muss Tab entfernt werden (einfach Inventar neu aufbauen)
+			// Zus&#239;&#191;&#189;zlich wenn Item Container war, muss Tab entfernt werden (einfach Inventar neu aufbauen)
 			if (item-&gt;isContainer())
 			{
 				removeContainerAndContent(dynamic_cast&lt;Container*&gt;(item));
@@ -259,7 +260,7 @@
 
 		if (item-&gt;isContainer())
 		{
-			// ContainerTab hinzuf&#252;gen, wenn nicht schon vorhanden
+			// ContainerTab hinzufgen, wenn nicht schon vorhanden
 			createAndFillContainer(dynamic_cast&lt;Container*&gt;(item));
 			refreshTabs();
 
@@ -267,10 +268,10 @@
 		
 
 		bool itemSwitched = false;
-		// Gegenstand in Slot setzen / Schon dagewesenen Gegenstand zur&#252;ck in den Rucksack setzen
+		// Gegenstand in Slot setzen / Schon dagewesenen Gegenstand zurck in den Rucksack setzen
 		//if (mContainerDraggedTo == mArmor){
 		//	if (mInventory-&gt;getArmor() != NULL){
-		//		//Pack die alte R&#252;stung ins Inventar
+		//		//Pack die alte Rstung ins Inventar
 		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeArmor(), mInventory-&gt;getBackpack());
 		//		itemSwitched = true;
 		//	}
@@ -278,7 +279,7 @@
 		//}
 		//if (mContainerDraggedTo == mCape){
 		//	if (mInventory-&gt;getCape() != NULL){
-		//		//Pack die alte R&#252;stung ins Inventar
+		//		//Pack die alte Rstung ins Inventar
 		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeCape(), mInventory-&gt;getBackpack());
 		//		itemSwitched = true;
 		//	}
@@ -294,7 +295,7 @@
 		//}
 		//if (mContainerDraggedTo == mBelt) {
 		//	if (mInventory-&gt;getBelt() != NULL){
-		//		//Pack den alten G&#252;rtel ins Inventar
+		//		//Pack den alten Grtel ins Inventar
 		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeBelt(), mInventory-&gt;getBackpack());
 		//		itemSwitched = true;
 		//	}
@@ -412,7 +413,7 @@
 
 				//// Container Fenster suchen
 				//CEGUI::Window* win = findContainer(posInContainer.second);
-				//// Dem Fenster hinzuf&#252;gen
+				//// Dem Fenster hinzufgen
 				//win-&gt;addChildWindow(mOldItemInSlot);
 				//// Positionieren		
 				//mOldItemInSlot-&gt;setPosition( CEGUI::Absolute,
@@ -426,7 +427,7 @@
 		}
 
 
-		// Update am Inventar durchgef&#252;hrt, jetzt sollen noch die Werte aktualisiert werden
+		// Update am Inventar durchgefhrt, jetzt sollen noch die Werte aktualisiert werden
 		update();
 	}
 
@@ -441,7 +442,7 @@
 			mContainerTabs-&gt;removeTab(mContainerTabs-&gt;getTabContents(0)-&gt;getName());
 		}
 
-		// f&#252;ge sie in richtiger Reihenfolge wieder hinzu
+		// fge sie in richtiger Reihenfolge wieder hinzu
 		while (it != mContainers.end())
 		{
 			mContainerTabs-&gt;addTab(*it++);
@@ -465,8 +466,8 @@
 	{
 		mArmorValueWindow = getWindow(&quot;InventoryWindow/ArmorValueWindow&quot;);
         mArmorValueWindow-&gt;setProperty(&quot;Image&quot;, &quot;set:InventorySymbols image:Shield&quot;);
-		mArmorValueWindow-&gt;setTooltipText(&quot;R&#252;stung / Behinderung&quot;);
-		//TODO: An Tooltip anh&#228;ngen: woraus setzt sich die R&#252;stung zusammen?
+		mArmorValueWindow-&gt;setTooltipText(&quot;Rstung / Behinderung&quot;);
+		//TODO: An Tooltip anh&#239;&#191;&#189;gen: woraus setzt sich die Rstung zusammen?
 		mArmorValue = getWindow(&quot;InventoryWindow/ArmorValue&quot;);
 		mArmorValue-&gt;setText(&quot; 3&quot;);
 		//mArmorValue-&gt;setTextColours(CEGUI::colour(0.0,0.4,0.0)); //TODO port to cegui0.5
@@ -482,7 +483,7 @@
 
 		mTotalWeight = getWindow(&quot;InventoryWindow/TotalWeight&quot;);
 		mTotalWeight-&gt;setText(&quot;&quot;);
-		// Schwarzer Text (wird rot, wenn &#252;berladen)
+		// Schwarzer Text (wird rot, wenn berladen)
 		//mTotalWeight-&gt;setTextColours(CEGUI::colour(0.0,0.0,0.0));  //TODO port to cegui0.5
 		mTotalWeight-&gt;disable();
 				
@@ -491,7 +492,7 @@
 		mDescription = getScrollablePane(&quot;InventoryWindow/Description&quot;);
 
 		// Das &quot;BodenItem&quot; initiieren
-		mGroundItem = new Item(1/*&quot;Boden&quot;, &quot;Dieses Item repr&#228;sentiert den Boden&quot;*/);
+		mGroundItem = new Item(1/*&quot;Boden&quot;, &quot;Dieses Item repr&#239;&#191;&#189;entiert den Boden&quot;*/);
 		mGroundItem-&gt;setImageName(&quot;Trank&quot;);
 		mGroundItem-&gt;setItemType(Item::ITEMTYPE_OTHER);
 		mGroundItem-&gt;setSize(1,1);
@@ -552,7 +553,7 @@
 		mBoots = getWindow(&quot;InventoryWindow/Boots&quot;);
 		mBoots-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_BOOTS));
 
-		// gib ihnen die Funktionalit&#228;t Items aufzunehmen
+		// gib ihnen die Funktionalit&#239;&#191;&#189; Items aufzunehmen
 		addDropListener(mHelmet);
 		addDropListener(mRingLeft);
 		addDropListener(mRingRight);
@@ -593,7 +594,7 @@
 		//createItem(mInventory-&gt;getBoots(), mBoots);
 
 
-		// Fenster f&#252;r ContainerItems erstellen
+		// Fenster fr ContainerItems erstellen
 		createContainerWindows();
 	}
 
@@ -609,7 +610,7 @@
 			Item* currentItem = *itemIterator++;
 
 			if (currentItem-&gt;isContainer()){
-				// Tab f&#252;r Item erzeugen, da es als Container funktioniert
+				// Tab fr Item erzeugen, da es als Container funktioniert
 				createAndFillContainer(dynamic_cast&lt;Container*&gt;(currentItem));
 			}
 		}
@@ -622,7 +623,7 @@
 
 		std::list&lt;CEGUI::Window*&gt;::iterator it = mContainerContents.begin();
 		bool found = false;
-		// &#252;berpr&#252;fe, ob schon vorhanden
+		// berprfe, ob schon vorhanden
 		while (it != mContainerContents.end())
 		{
 			if (container == static_cast&lt;Item*&gt;((*it)-&gt;getUserData()))
@@ -637,9 +638,9 @@
 		if (!found)
 		{
 
-			// Erzeuge Tab im Inventar f&#252;r den Container
+			// Erzeuge Tab im Inventar fr den Container
 			CEGUI::Window* containerWindow = CEGUI::WindowManager::getSingleton().createWindow(&quot;DefaultGUISheet&quot;, &quot;InventoryWindow/Tabs/&quot;+container-&gt;getName());
-			// Name f&#252;r das Tab
+			// Name fr das Tab
 			containerWindow-&gt;setText(container-&gt;getName());
 
 
@@ -655,8 +656,8 @@
 			containerWindow-&gt;addChildWindow(containerSpace);
 
 
-			// Inhalt in die Liste Einf&#252;gen
-						// Boden an das Ende der Liste einf&#252;gen
+			// Inhalt in die Liste Einfgen
+						// Boden an das Ende der Liste einfgen
 			if (container == mGroundItem)
 			{
 				mContainers.push_back(containerWindow);
@@ -762,7 +763,7 @@
 		emptySlot(mShinbone);
 		emptySlot(mBoots);
 
-		// Zus&#228;tzlich alle Container durchgehen und entleeren
+		// Zus&#239;&#191;&#189;zlich alle Container durchgehen und entleeren
 		
 		std::list&lt;CEGUI::Window*&gt;::iterator it = mContainerContents.begin();
 		
@@ -817,10 +818,10 @@
 
 	DragContainer* InventoryWindow::createItem(Item* item, Window* parent, UVector2 position)
 	{
-		// Pr&#252;fe, ob ein Item da ist
+		// Prfe, ob ein Item da ist
 		if (item != NULL) {
 
-			// TODO: Ausnahmen sind Waffe und Schild (wenn parent mHand* ist, soll Hintergrund gef&#252;llt werden)
+			// TODO: Ausnahmen sind Waffe und Schild (wenn parent mHand* ist, soll Hintergrund gefllt werden)
 			// Waffe:
 			if (parent == mHandRight || parent == mHandLeft) 
 			{
@@ -830,7 +831,7 @@
 			static int itemCnt = 0;
 			itemCnt++;
 
-			// Erzeuge einen Handler f&#252;r Drag and Drop
+			// Erzeuge einen Handler fr Drag and Drop
 			DragContainer* itemhandler = static_cast&lt;DragContainer*&gt;(
 				CEGUI::WindowManager::getSingletonPtr()-&gt;createWindow(&quot;DragContainer&quot;, Ogre::StringConverter::toString(itemCnt) + item-&gt;getName()));
 			itemhandler-&gt;setPosition(position);
@@ -886,7 +887,7 @@
 
 	bool InventoryWindow::handleMouseClicked(const EventArgs &amp;args) 
 	{
-		// Hole das ausgew&#228;hlte Item
+		// Hole das ausgew&#239;&#191;&#189;lte Item
 		const CEGUI::MouseEventArgs&amp; mea = static_cast&lt;const MouseEventArgs&amp;&gt;(args);
 
 		// Nur, wenn es sich uim einen Itemhandler handelt, soll was geschehen...
@@ -903,7 +904,7 @@
 			
 			assert(mea.window-&gt;getChildCount() &gt; 0);
 			
-			// aktiviere das angew&#228;hlte Item...
+			// aktiviere das angew&#239;&#191;&#189;lte Item...
 			mActiveItemWindow = mea.window-&gt;getChildAtIdx(0);
 			mActiveItemWindow-&gt;setProperty(&quot;BackgroundColour&quot;, mColorItemSelected);
 			mActiveItemWindow-&gt;setProperty(&quot;FrameEnabled&quot;, &quot;True&quot;);
@@ -984,7 +985,7 @@
 		SceneManager* tempManager = CoreSubsystem::getSingleton().
 					getWorld()-&gt;getSceneManager();
 
-		// F&#252;r einen Aufh&#228;ngeknoten Sorgen
+		// Fr einen Aufh&#239;&#191;&#189;geknoten Sorgen
 		if (mInventoryItemNode == NULL){
 			mInventoryItemNode = tempManager-&gt;getRootSceneNode()-&gt;createChildSceneNode(Ogre::Vector3(0,-999999.6,-0.2));
 			//mInventoryItemNode-&gt;setPosition(0,-100,-0.2);
@@ -999,7 +1000,7 @@
 		}
 		if (item-&gt;getActor())
 		{
-			// Camera update erforderlich, da Mapchange da was kaputt gemacht haben k&#246;nnte
+			// Camera update erforderlich, da Mapchange da was kaputt gemacht haben k&#239;&#191;&#189;nte
 			unloadCamera();
 			loadCamera();
 
@@ -1056,7 +1057,7 @@
 
 	void InventoryWindow::unloadCamera()
 	{
-		// wenn loadCamera schon mal geladen wurde, soll die Camera zerst&#246;rt werden
+		// wenn loadCamera schon mal geladen wurde, soll die Camera zerst&#239;&#191;&#189;t werden
 		if (mRenderViewport)
 		{
 			mRenderTexture-&gt;removeViewport(0);
@@ -1065,7 +1066,7 @@
 	}
 
 	/*!
-	*		&#220;berpr&#252;ft, ob das Item von dem Slot akzeptiert wird
+	*		&#239;&#191;&#189;erprft, ob das Item von dem Slot akzeptiert wird
 	*/
 	bool InventoryWindow::checkTypeAccepted(CEGUI::Window* window, CEGUI::DragContainer* draggedItem)
 	{
@@ -1084,7 +1085,7 @@
 	*/
 	std::pair&lt;int,int&gt; InventoryWindow::calculateNewPosition(const DragDropEventArgs&amp; ddea)
 	{
-		// Errechnung der Koordinaten, in welchem K&#228;stchen denn nun gedroppt wird
+		// Errechnung der Koordinaten, in welchem K&#239;&#191;&#189;tchen denn nun gedroppt wird
 		Point absMouse = MouseCursor::getSingleton().getPosition();
         Point scrnPt = ddea.window-&gt;getPixelRect().getPosition();
 		Point relMouse = absMouse - ddea.dragDropItem-&gt;getPixelRect().getPosition();
@@ -1104,7 +1105,7 @@
 		Point pointInBackpack = absMouse-scrnPt;
 		pointInBackpack -= relMouse;
 
-		// Position des n&#228;chsten K&#228;stchens bestimmen		
+		// Position des n&#239;&#191;&#189;hsten K&#239;&#191;&#189;tchens bestimmen		
 		if (pointInBackpack.d_x &lt; 0)
         {
 			pointInBackpack.d_x = 0;
@@ -1143,8 +1144,8 @@
 
 
 	/*!
-	* Behandlung f&#252;r Mouse-over mit Item in der Maus
-	* &#220;berpr&#252;ft, ob das Item passt, und f&#228;rbt dementsprechend den Beh&#228;lter ein
+	* Behandlung fr Mouse-over mit Item in der Maus
+	* &#239;&#191;&#189;erprft, ob das Item passt, und f&#239;&#191;&#189;bt dementsprechend den Beh&#239;&#191;&#189;ter ein
 	*/
 	bool InventoryWindow::handleDragEnter(const CEGUI::EventArgs&amp; args)
 	{
@@ -1175,8 +1176,8 @@
 				}
 			}
 			else {
-				// Beliebiger anderer Container am K&#246;rper
-				// TODO: Beschr&#228;nkung auf Itemtypen... 
+				// Beliebiger anderer Container am K&#239;&#191;&#189;per
+				// TODO: Beschr&#239;&#191;&#189;kung auf Itemtypen... 
 
 				ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorAccept);
 				return true;
@@ -1206,7 +1207,7 @@
 	{
 		// Event zu einem DragDropEvent machen
 		const DragDropEventArgs&amp; ddea = static_cast&lt;const DragDropEventArgs&amp;&gt;(args);
-		// Farbe zur&#252;cksetzen
+		// Farbe zurcksetzen
 		ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorNormal);
 
 
@@ -1219,15 +1220,15 @@
 			} 
 			else if (container-&gt;getItemType() == Item::ITEMTYPE_BACKPACK)
 			{
-				// Rucksack (nimmt alles au&#223;er dem Rucksack selbst)
+				// Rucksack (nimmt alles au&#239;&#191;&#189;r dem Rucksack selbst)
 				if (!(ddea.dragDropItem-&gt;getUserString(&quot;ItemType&quot;).compare(Item::getItemTypeString(Item::ITEMTYPE_BACKPACK))))
 				{
 					return false;
 				}
 			}
 			else {
-				// Beliebiger anderer Container am K&#246;rper
-				// TODO: Beschr&#228;nkung auf Itemtypen... 
+				// Beliebiger anderer Container am K&#239;&#191;&#189;per
+				// TODO: Beschr&#239;&#191;&#189;kung auf Itemtypen... 
 			}
 
 			std::pair&lt;int,int&gt; newPos = calculateNewPosition(ddea);
@@ -1252,9 +1253,9 @@
 
 
 		} else {
-			// Es handelt sich um einen Slot am K&#246;rper
+			// Es handelt sich um einen Slot am K&#239;&#191;&#189;per
 			if (checkTypeAccepted(ddea.window, ddea.dragDropItem)){
-				// Nur wenn das Item in den Slot passt, soll es auch dort gedroppt werden k&#246;nnen
+				// Nur wenn das Item in den Slot passt, soll es auch dort gedroppt werden k&#239;&#191;&#189;nen
 
 				if (ddea.window-&gt;getChildCount() &gt; 0)
 				{
@@ -1277,7 +1278,7 @@
 					Item* item = static_cast&lt;Item*&gt;(ddea.dragDropItem-&gt;getUserData());
 					mPosDraggedTo= CEGUI::Point(30-(item-&gt;getSize().first * 15),75-(item-&gt;getSize().second *15));
 				}
-				// Rest kommt in die linke obere Ecke (weil ausf&#252;llend)
+				// Rest kommt in die linke obere Ecke (weil ausfllend)
 				else {
 					mPosDraggedTo=CEGUI::Point(0.0,0.0);
 				}

Modified: rl/trunk/engine/ui/src/Makefile.am
===================================================================
--- rl/trunk/engine/ui/src/Makefile.am	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/src/Makefile.am	2007-03-02 13:59:13 UTC (rev 3109)
@@ -16,7 +16,6 @@
 	CharacterSheetWindow.cpp \
 	CharacterStateWindow.cpp \
 	CloseConfirmationWindow.cpp \
-	CommandExecutor.cpp \
 	CommandMapper.cpp \
 	CommandMapperWindow.cpp \
 	ConfigComponent.cpp \

Modified: rl/trunk/engine/ui/src/MovementCharacterController.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-03-02 09:27:15 UTC (rev 3108)
+++ rl/trunk/engine/ui/src/MovementCharacterController.cpp	2007-03-02 13:59:13 UTC (rev 3109)
@@ -121,7 +121,7 @@
             mCharacterActor-&gt;getControlledObject());
         AxisAlignedBox aabb = charMesh-&gt;getDefaultSize();
 
-        // wird sp&#228;ter neu berechnet in calculateOptimalCameraPosition
+        // wird sp&#239;&#191;&#189;er neu berechnet in calculateOptimalCameraPosition
         mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
 
         // The actor should be controlled manually,
@@ -262,12 +262,12 @@
 
         if (mCharacterState.mPose == CharacterState::Stand)
         {
-            // Spr&#252;nge werden von updateAnimationStat geregelt
+            // Sprnge werden von updateAnimationStat geregelt
 
-            // R&#252;ckw&#228;rts gehen oder laufen
+            // Rckw&#239;&#191;&#189;ts gehen oder laufen
             if ( movement &amp; MOVE_BACKWARD &amp;&amp; !(movement &amp; MOVE_FORWARD) )
             {
-                if( movement &amp; MOVE_RUN_LOCK ) // R&#252;ckw&#228;rts joggen
+                if( movement &amp; MOVE_RUN_LOCK ) // Rckw&#239;&#191;&#189;ts joggen
                 {
                     mCharacterState.mDesiredVel = Vector3(0,0,1) * 0.6 * gs / 2.0;
                 }
@@ -276,7 +276,7 @@
                     mCharacterState.mDesiredVel = Vector3(0,0,1) * 0.6 * gs / 3.6;
                 }
             }
-            else if ( movement &amp; MOVE_FORWARD ) // Vorw&#228;rtsbewegung
+            else if ( movement &amp; MOVE_FORWARD ) // Vorw&#239;&#191;&#189;tsbewegung
             {
                 if( movement &amp; MOVE_RUN &amp;&amp; movement &amp; MOVE_RUN_LOCK ) // sprinten
                 {
@@ -321,8 +321,8 @@
         }
 
 /*
-// soll daf&#252;r sorgen, dass er auf dem
-// Boden bleibt und &#252;ber kleine Hindernisse kommt
+// soll dafr sorgen, dass er auf dem
+// Boden bleibt und ber kleine Hindernisse kommt
 
 Quaternion orientation = mCharacterActor-&gt;getWorldOrientation();
 Vector3 position = mCharacterActor-&gt;getWorldPosition();
@@ -352,7 +352,7 @@
 }
 while( dirVector.y &gt; -stepHeight );
 
-// kann das Hindernis &#252;berwunden werden:
+// kann das Hindernis berwunden werden:
 dirVector = relCollPos;
 while( dirVector.y &lt;= stepHeight )
 {
@@ -461,7 +461,7 @@
         }
         else if( mViewMode == VM_THIRD_PERSON )
         {
-            // Kamera-Gr&#246;&#223;e beziehen
+            // Kamera-Gr&#239;&#191;&#189;e beziehen
             CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
                 mCameraActor-&gt;getControlledObject());
             AxisAlignedBox aabb = ogreCam-&gt;getDefaultSize();
@@ -541,7 +541,7 @@
             getContactPositionAndNormal(point, normal);
 
             // determine if this contact is with the floor.
-            // Meaning the contact normal has an angle to UNIT_Y of 20&#176; or less.
+            // Meaning the contact normal has an angle to UNIT_Y of 20 or less.
             Degree angle = Math::ACos(normal.dotProduct(Vector3::UNIT_Y));
 
             Vector3 charPos;
@@ -575,10 +575,10 @@
             }
 
 
-            // beinflusst die Sprungh&#246;he!
-            // der erste Sprung bleibt normal, jeder weitere Sprung ist ungef&#228;hr um
-            // die angegebene Zahl h&#246;her (eher 2*die angegebene Zahl oder so,
-            // vermutlich wieder framedauer abh&#228;ngig!)
+            // beinflusst die Sprungh&#239;&#191;&#189;e!
+            // der erste Sprung bleibt normal, jeder weitere Sprung ist ungef&#239;&#191;&#189;r um
+            // die angegebene Zahl h&#239;&#191;&#189;er (eher 2*die angegebene Zahl oder so,
+            // vermutlich wieder framedauer abh&#239;&#191;&#189;gig!)
             setContactElasticity(0.3f); // was 0.3f
             setContactSoftness(0.01f);
 
@@ -609,7 +609,7 @@
         else
         {
             mCharacterState.mJumpTimer += timestep;
-            static Real timeSinceLastFloorContact(0.0f); // damit kleine Bodenunebenheiten nicht gleich zum &quot;Sprung f&#252;hren&quot;
+            static Real timeSinceLastFloorContact(0.0f); // damit kleine Bodenunebenheiten nicht gleich zum &quot;Sprung fhren&quot;
             if( !mCharacterState.mHasFloorContact )
                 timeSinceLastFloorContact += timestep;
             else
@@ -654,7 +654,7 @@
                 {
                     mCharacterState.mJumpTimer = 0.0f;
                     mCharacterState.mIsAirBorne = true;
-                    Real height = 0.75f; // beim zweiten gehts seltsamerweise was h&#246;her /doppelsprung physik?)
+                    Real height = 0.75f; // beim zweiten gehts seltsamerweise was h&#239;&#191;&#189;er /doppelsprung physik?)
                     Real gravity = 9.81f;
                     Real jumpForce = 0.5f*gravity*mass * (Math::Sqrt(1 + 8*height/(gravity * timestep * timestep)) - 1);
                     force += Vector3(0,
@@ -662,7 +662,7 @@
                         0);
                 }
 
-                Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep(); // so ist die Beschleunigung unabh&#228;ngig von der framerate!
+                Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep(); // so ist die Beschleunigung unabh&#239;&#191;&#189;gig von der framerate!
                 force += mass*(orientation*mCharacterState.mDesiredVel - currentVel) / delay;
             }
             mCharacterState.mStartJump = false;
@@ -715,18 +715,18 @@
         if( playpos.y &gt; maxHeight )
             maxHeight = playpos.y;
         ss
-            &lt;&lt; &quot;scene node : &quot; &lt;&lt; playpos &lt;&lt; endl
+            &lt;&lt; &quot;scene node : &quot; &lt;&lt; playpos &lt;&lt; std::endl
 //            &lt;&lt; &quot;player max Height : &quot; &lt;&lt; maxHeight &lt;&lt; endl
             &lt;&lt; &quot;camera posder : &quot; &lt;&lt; static_cast&lt;Camera*&gt;(
-                mCameraActor-&gt;_getMovableObject())-&gt;getDerivedPosition() &lt;&lt; endl
+                mCameraActor-&gt;_getMovableObject())-&gt;getDerivedPosition() &lt;&lt; std::endl
 //                &lt;&lt; &quot;camera pos : &quot; &lt;&lt; static_cast&lt;Camera*&gt;(
-//                    mCameraActor-&gt;_getMovableObject())-&gt;getPosition() &lt;&lt; endl
-            &lt;&lt; &quot;camera actor orientation : &quot; &lt;&lt; mCameraActor-&gt;getWorldOrientation() &lt;&lt; endl
-            &lt;&lt; &quot;camera actor : &quot; &lt;&lt; mCameraActor-&gt;getWorldPosition() &lt;&lt; endl
-            &lt;&lt; &quot;camera body pos : &quot; &lt;&lt; bodpos &lt;&lt; endl
-            &lt;&lt; &quot;is airborne: &quot; &lt;&lt; (mCharacterState.mIsAirBorne ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl
-            &lt;&lt; &quot;start jump : &quot; &lt;&lt; (mCharacterState.mStartJump ? &quot;true&quot; : &quot;false&quot;)  &lt;&lt; endl
-            &lt;&lt; &quot;jump timer : &quot; &lt;&lt; mCharacterState.mJumpTimer &lt;&lt; endl;
+//                    mCameraActor-&gt;_getMovableObject())-&gt;getPosition() &lt;&lt; std::endl
+            &lt;&lt; &quot;camera actor orientation : &quot; &lt;&lt; mCameraActor-&gt;getWorldOrientation() &lt;&lt; std::endl
+            &lt;&lt; &quot;camera actor : &quot; &lt;&lt; mCameraActor-&gt;getWorldPosition() &lt;&lt; std::endl
+            &lt;&lt; &quot;camera body pos : &quot; &lt;&lt; bodpos &lt;&lt; std::endl
+            &lt;&lt; &quot;is airborne: &quot; &lt;&lt; (mCharacterState.mIsAirBorne ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl
+            &lt;&lt; &quot;start jump : &quot; &lt;&lt; (mCharacterState.mStartJump ? &quot;true&quot; : &quot;false&quot;)  &lt;&lt; std::endl
+            &lt;&lt; &quot;jump timer : &quot; &lt;&lt; mCharacterState.mJumpTimer &lt;&lt; std::endl;
 
         LOG_DEBUG(Logger::UI, ss.str());
         DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
@@ -775,7 +775,7 @@
 
 
 
-        // Kamera-Gr&#246;&#223;e beziehen
+        // Kamera-Gr&#239;&#191;&#189;e beziehen
         CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
             mCameraActor-&gt;getControlledObject());
         AxisAlignedBox camAabb = ogreCam-&gt;getDefaultSize();
@@ -804,9 +804,9 @@
             RaycastInfo infoCastOptPos = mRaycast-&gt;execute(
                 world,
                 materialId,
-                camPos + camRadius * normToOptCamPos, // Gr&#246;&#223;e der Kamera einbeziehen
+                camPos + camRadius * normToOptCamPos, // Gr&#239;&#191;&#189;e der Kamera einbeziehen
                 optimalCamPos + camRadius * normToOptCamPos,
-                true); // Gr&#246;&#223;e der Kamera einbeziehen
+                true); // Gr&#239;&#191;&#189;e der Kamera einbeziehen
 
             RaycastInfo infoCastChar = mRaycast-&gt;execute(
                 world,
@@ -843,17 +843,17 @@
                     RaycastInfo infoCastNewPos;
                     Real delta = lenToOptCamPos/2.0f;
                     Vector3 temp = charPos + delta * normToOptCamPos;
-                    // Ann&#228;herung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
+                    // Ann&#239;&#191;&#189;erung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
                     while( delta &gt; 0.05 ) // genauigkeit des gefundenen Punktes
                     {
                         infoCastNewPos = mRaycast-&gt;execute(
                             world,
                             materialId,
-                            camPos + camRadius * normToOptCamPos, // Gr&#246;&#223;e der Kamera!
+                            camPos + camRadius * normToOptCamPos, // Gr&#239;&#191;&#189;e der Kamera!
                             temp,
                             true);
                         delta = delta/2.0f;
-                        if( infoCastNewPos.mBody ) // Hindernis gefunden, n&#228;her an Char ran
+                        if( infoCastNewPos.mBody ) // Hindernis gefunden, n&#239;&#191;&#189;er an Char ran
                         {
                             temp = temp - delta * normToOptCamPos;
                         }
@@ -863,9 +863,9 @@
                         }
                     }
 
-                    // Jetzt k&#246;nnen wir sicher sein, dass diese Stelle erreichbar ist:
+                    // Jetzt k&#239;&#191;&#189;nen wir sicher sein, dass diese Stelle erreichbar ist:
                     temp = temp - 0.05 * normToOptCamPos;
-                    // Gr&#246;&#223;e der Kamera einbeziehen
+                    // Gr&#239;&#191;&#189;e der Kamera einbeziehen
                     optimalCamPos = temp - camRadius * normToOptCamPos;
                     // so ab hier kann ganz normal weiter gerechnet werden!
                 }
@@ -874,7 +874,7 @@
 
             static bool isPathfinding (false);
             static unsigned int lastReachableBufPos;
-            // gibt an, ob schon gebufferte Daten f&#252;r den
+            // gibt an, ob schon gebufferte Daten fr den
             // neuen Weg existieren und dort weitergemacht werden kann,
             // oder ob neu nach einem Weg gesucht werden muss!
             if( infoCastChar.mBody &amp;&amp; infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
@@ -882,8 +882,8 @@
                 // anderen Weg finden
                 // hier werden erstmal nur alte Player-Positionen betrachtet
                 // es wird davon ausgegangen, dass diese &quot;nah&quot; genug aneinanderliegen
-                // und durch &quot;Geraden&quot; miteinander verbunden werden k&#246;nnen
-                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem fl&#252;ssig
+                // und durch &quot;Geraden&quot; miteinander verbunden werden k&#239;&#191;&#189;nen
+                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
                 // und weich (keine scharfen Kurven) erscheinen
 
                 size_t buffSize = charPositionsBuffer.size();
@@ -924,12 +924,12 @@
                 }
                 else
                 {
-                    LOG_DEBUG(Logger::UI, &quot; Pathfinding der Kamera sollte weitergef&#252;hrt werden!&quot;);
+                    LOG_DEBUG(Logger::UI, &quot; Pathfinding der Kamera sollte weitergefhrt werden!&quot;);
 
 
                     // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
                     unsigned int delta = lastReachableBufPos; // das ist die von der letzten Frame!
-                    while ( delta &gt; 0 ) // delta = 0 braucht nicht &#252;berpr&#252;ft zu werden, wurde oben schon ausgeschlossen!
+                    while ( delta &gt; 0 ) // delta = 0 braucht nicht berprft zu werden, wurde oben schon ausgeschlossen!
                     {
                         RaycastInfo info = mRaycast-&gt;execute(
                             world,
@@ -947,7 +947,7 @@
                     // auf zu der ermittelten Position!
                     optimalCamPos = charPositionsBuffer[ (charPositionsBufferIdx - lastReachableBufPos) % buffSize ];
                 }
-                isPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Pr&#252;fung gleicher sachen)
+                isPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
             }
             else
             {
@@ -1012,7 +1012,7 @@
             }
 
 
-            // Kamera-Gr&#246;&#223;e beziehen
+            // Kamera-Gr&#239;&#191;&#189;e beziehen
             CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
                 mCameraActor-&gt;getControlledObject());
             AxisAlignedBox aabb = ogreCam-&gt;getDefaultSize();
@@ -1033,7 +1033,7 @@
             endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
                                       // dadurch kann aber sichergestellt
                                       // werden, dass kein Objekt direkt
-                                      // hinter dem Helden &#252;bersehen wird
+                                      // hinter dem Helden bersehen wird
             startRay[1] = charPos + radiusOffset;
             endRay[1] = targetCamPos + radiusOffset;
             radiusOffset = charOri * Vector3(radius, sinPitchRad, cosPitchRad);
@@ -1432,7 +1432,7 @@
 
         if (newAnimation != &quot;&quot;)
         {
-            // nur schneller nicht langsamer ausf&#252;hren!
+            // nur schneller nicht langsamer ausfhren!
             if (animSpeed &lt; 1) animSpeed = 1;
 
             if (lastAnimation != newAnimation)
@@ -1449,7 +1449,7 @@
             }
             else
             {
-                if ( lastSpeed != animSpeed ) // Geschwindigkeits&#228;nderung
+                if ( lastSpeed != animSpeed ) // Geschwindigkeits&#239;&#191;&#189;derung
                 {
                     MeshAnimation *meshAnim = mesh-&gt;getAnimation(newAnimation);
                     meshAnim-&gt;setSpeed(animSpeed);
@@ -1516,7 +1516,7 @@
         Vector3 interpolatedSize;
 
 
-        // Die Gr&#246;&#223;e der beiden Animationen abfragen
+        // Die Gr&#239;&#191;&#189;e der beiden Animationen abfragen
         MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
         aab = mesh-&gt;getPoseSize(actAnim);
         size[0] = aab.getMaximum() - aab.getMinimum();
@@ -1524,7 +1524,7 @@
         aab = mesh-&gt;getPoseSize(newAnim);
         size[1] = aab.getMaximum() - aab.getMinimum();
 
-        // interpolierte Gr&#246;&#223;e (linear) berechnen
+        // interpolierte Gr&#239;&#191;&#189;e (linear) berechnen
         interpolatedSize = size[0] + factor*(size[1] - size[0]);
 
         // LookAtOffset berechnen!


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000179.html">[Dsa-hl-svn] r3108 - rl/trunk/engine/common/src
</A></li>
	<LI>Next message: <A HREF="000181.html">[Dsa-hl-svn] r3110 - rl/trunk/engine/core/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#180">[ date ]</a>
              <a href="thread.html#180">[ thread ]</a>
              <a href="subject.html#180">[ subject ]</a>
              <a href="author.html#180">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
