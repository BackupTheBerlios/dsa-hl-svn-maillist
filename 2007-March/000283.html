<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r3212 - modules/common/dsa	modules/common/gui/imagesets modules/common/gui/windows	modules/regressiontest/dsa rl/branches	rl/branches/old_inventory_window	rl/branches/old_inventory_window/engine	rl/branches/old_inventory_window/engine/ui	rl/branches/old_inventory_window/engine/ui/include	rl/branches/old_inventory_window/engine/ui/src	rl/trunk/engine/rules/include rl/trunk/engine/rules/src	rl/trunk/engine/ui/include rl/trunk/engine/ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2007-March/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3212%20-%20modules/common/dsa%0A%09modules/common/gui/imagesets%20modules/common/gui/windows%0A%09modules/regressiontest/dsa%20rl/branches%0A%09rl/branches/old_inventory_window%0A%09rl/branches/old_inventory_window/engine%0A%09rl/branches/old_inventory_window/engine/ui%0A%09rl/branches/old_inventory_window/engine/ui/include%0A%09rl/branches/old_inventory_window/engine/ui/src%0A%09rl/trunk/engine/rules/include%20rl/trunk/engine/rules/src%0A%09rl/trunk/engine/ui/include%20rl/trunk/engine/ui/src&In-Reply-To=%3C200703301920.l2UJKTZ0002885%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000282.html">
   <LINK REL="Next"  HREF="000284.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r3212 - modules/common/dsa	modules/common/gui/imagesets modules/common/gui/windows	modules/regressiontest/dsa rl/branches	rl/branches/old_inventory_window	rl/branches/old_inventory_window/engine	rl/branches/old_inventory_window/engine/ui	rl/branches/old_inventory_window/engine/ui/include	rl/branches/old_inventory_window/engine/ui/src	rl/trunk/engine/rules/include rl/trunk/engine/rules/src	rl/trunk/engine/ui/include rl/trunk/engine/ui/src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r3212%20-%20modules/common/dsa%0A%09modules/common/gui/imagesets%20modules/common/gui/windows%0A%09modules/regressiontest/dsa%20rl/branches%0A%09rl/branches/old_inventory_window%0A%09rl/branches/old_inventory_window/engine%0A%09rl/branches/old_inventory_window/engine/ui%0A%09rl/branches/old_inventory_window/engine/ui/include%0A%09rl/branches/old_inventory_window/engine/ui/src%0A%09rl/trunk/engine/rules/include%20rl/trunk/engine/rules/src%0A%09rl/trunk/engine/ui/include%20rl/trunk/engine/ui/src&In-Reply-To=%3C200703301920.l2UJKTZ0002885%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r3212 - modules/common/dsa	modules/common/gui/imagesets modules/common/gui/windows	modules/regressiontest/dsa rl/branches	rl/branches/old_inventory_window	rl/branches/old_inventory_window/engine	rl/branches/old_inventory_window/engine/ui	rl/branches/old_inventory_window/engine/ui/include	rl/branches/old_inventory_window/engine/ui/src	rl/trunk/engine/rules/include rl/trunk/engine/rules/src	rl/trunk/engine/ui/include rl/trunk/engine/ui/src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Fri Mar 30 21:20:29 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000282.html">[Dsa-hl-svn] r3211 - rl/trunk/engine/rules/src
</A></li>
        <LI>Next message: <A HREF="000284.html">[Dsa-hl-svn] r3213 - in tools/mesh_combiner: include src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#283">[ date ]</a>
              <a href="thread.html#283">[ thread ]</a>
              <a href="subject.html#283">[ subject ]</a>
              <a href="author.html#283">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2007-03-30 21:20:10 +0200 (Fri, 30 Mar 2007)
New Revision: 3212

Added:
   modules/common/gui/windows/inventory_human.xml
   rl/branches/old_inventory_window/
   rl/branches/old_inventory_window/engine/
   rl/branches/old_inventory_window/engine/ui/
   rl/branches/old_inventory_window/engine/ui/include/
   rl/branches/old_inventory_window/engine/ui/include/InventoryWindow.h
   rl/branches/old_inventory_window/engine/ui/src/
   rl/branches/old_inventory_window/engine/ui/src/InventoryWindow.cpp
Modified:
   modules/common/dsa/gameobjectdefinitions.gof
   modules/common/gui/imagesets/ModelThumbnails.imageset
   modules/regressiontest/dsa/gameobjectdefinitions.gof
   rl/trunk/engine/rules/include/Creature.h
   rl/trunk/engine/rules/include/Inventory.h
   rl/trunk/engine/rules/include/Item.h
   rl/trunk/engine/rules/src/Container.cpp
   rl/trunk/engine/rules/src/Creature.cpp
   rl/trunk/engine/rules/src/Inventory.cpp
   rl/trunk/engine/rules/src/Item.cpp
   rl/trunk/engine/ui/include/InventoryWindow.h
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/WindowFactory.cpp
Log:
Started work on new inventory window

Modified: modules/common/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/common/dsa/gameobjectdefinitions.gof	2007-03-30 19:13:11 UTC (rev 3211)
+++ modules/common/dsa/gameobjectdefinitions.gof	2007-03-30 19:20:10 UTC (rev 3212)
@@ -17,6 +17,7 @@
 		&lt;property name=&quot;baseclass&quot; type=&quot;STRING&quot; data=&quot;Hero&quot; /&gt;
 		&lt;property name=&quot;geometrytype&quot; type=&quot;STRING&quot; data=&quot;ellipsoid&quot; /&gt;
 		&lt;property name=&quot;mass&quot; type=&quot;REAL&quot; data=&quot;75&quot;/&gt;
+		&lt;property name=&quot;inventorywindowtype&quot; type=&quot;STRING&quot; data=&quot;inventory_human.xml&quot;/&gt;
 	&lt;/gameobjectclass&gt;
 
 &lt;/GameObjectDefinitions&gt;

Modified: modules/common/gui/imagesets/ModelThumbnails.imageset
===================================================================
--- modules/common/gui/imagesets/ModelThumbnails.imageset	2007-03-30 19:13:11 UTC (rev 3211)
+++ modules/common/gui/imagesets/ModelThumbnails.imageset	2007-03-30 19:20:10 UTC (rev 3212)
@@ -8,6 +8,7 @@
 	&lt;Image Name=&quot;Stiefel&quot; XPos=&quot;30&quot; YPos=&quot;62&quot; Width=&quot;60&quot; Height=&quot;60&quot; /&gt;
 	&lt;Image Name=&quot;Fellumhang&quot; XPos=&quot;154&quot; YPos=&quot;1&quot; Width=&quot;60&quot; Height=&quot;120&quot; /&gt;
 	&lt;Image Name=&quot;Rubinring&quot; XPos=&quot;217&quot; YPos=&quot;1&quot; Width=&quot;30&quot; Height=&quot;30&quot; /&gt;
+	&lt;Image Name=&quot;waf_kurzschwert_01&quot; XPos=&quot;170&quot; YPos=&quot;130&quot; Width=&quot;30&quot; Height=&quot;120&quot; /&gt;
 	&lt;Image Name=&quot;Kurzschwert&quot; XPos=&quot;170&quot; YPos=&quot;130&quot; Width=&quot;30&quot; Height=&quot;120&quot; /&gt;
     &lt;Image Name=&quot;Fackel&quot; XPos=&quot;218&quot; YPos=&quot;31&quot; Width=&quot;30&quot; Height=&quot;90&quot; /&gt;
 	&lt;Image Name=&quot;Amboss&quot; XPos=&quot;0&quot; YPos=&quot;256&quot; Width=&quot;120&quot; Height=&quot;60&quot; /&gt;

Added: modules/common/gui/windows/inventory_human.xml
===================================================================
--- modules/common/gui/windows/inventory_human.xml	2007-03-30 19:13:11 UTC (rev 3211)
+++ modules/common/gui/windows/inventory_human.xml	2007-03-30 19:20:10 UTC (rev 3212)
@@ -0,0 +1,163 @@
+&lt;GUILayout xmlns:xsi=&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>&quot; xsi:noNamespaceSchemaLocation=&quot;GUILayout.xsd&quot;&gt;
+    &lt;Window Type=&quot;RastullahLook/FrameWindow&quot; Name=&quot;InventoryWindow&quot;&gt;
+		&lt;Property Name=&quot;VerticalAlignment&quot; Value=&quot;Centre&quot; /&gt;
+		&lt;Property Name=&quot;HorizontalAlignment&quot; Value=&quot;Centre&quot; /&gt;
+		&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,830},{0,560}}&quot; /&gt;
+		&lt;Property Name=&quot;Text&quot; Value=&quot;Inventar&quot; /&gt;
+		
+		&lt;Window Type=&quot;RastullahLook/InventoryBackground&quot; Name=&quot;InventoryWindow/Slots&quot;&gt;
+			&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,5},{0,5}}&quot; /&gt;
+			&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,820},{0,540}}&quot; /&gt;
+			
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/Head&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0.0,150},{0,40}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,60},{0,60}}&quot; /&gt;
+			&lt;/Window&gt;
+
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/Back&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,270},{0,450}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,60},{0,60}}&quot; /&gt;
+			&lt;/Window&gt;
+
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/Right Ring&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,30},{0,240}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,30},{0,30}}&quot; /&gt;
+			&lt;/Window&gt;
+
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/Left Ring&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,300},{0,240}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,30},{0,30}}&quot; /&gt;
+			&lt;/Window&gt;				
+
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/Right Hand&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,30},{0,80}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,60},{0,150}}&quot; /&gt;
+			&lt;/Window&gt;
+			
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/Left Hand&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,270},{0,80}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,60},{0,150}}&quot; /&gt;
+			&lt;/Window&gt;
+			
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/Armor&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,135},{0,110}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,90},{0,120}}&quot; /&gt;
+			&lt;/Window&gt;
+			
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/Belt&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,135},{0,240}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,90},{0,30}}&quot; /&gt;
+			&lt;/Window&gt;
+			
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/Trousers&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,150},{0,280}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,60},{0,90}}&quot; /&gt;
+			&lt;/Window&gt;
+			
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/Boots&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,150},{0,450}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,60},{0,60}}&quot; /&gt;
+			&lt;/Window&gt;
+			
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/Shinbone&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,150},{0,380}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,60},{0,60}}&quot; /&gt;
+			&lt;/Window&gt;
+			
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/Necklace&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,225},{0,70}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,30},{0,30}}&quot; /&gt;
+			&lt;/Window&gt;
+			
+			
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/BraceletRight&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,70},{0,240}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,30},{0,30}}&quot; /&gt;
+			&lt;/Window&gt;
+		
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/BraceletLeft&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,260},{0,240}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,30},{0,30}}&quot; /&gt;
+			&lt;/Window&gt;
+			
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/Gloves&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,30},{0,350}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,60},{0,60}}&quot; /&gt;
+			&lt;/Window&gt;
+			
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/Bracers&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,30},{0,280}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,60},{0,60}}&quot; /&gt;
+			&lt;/Window&gt;
+			
+			&lt;Window Type=&quot;RastullahLook/Container&quot; Name=&quot;InventoryWindow/Slots/Cape&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,270},{0,280}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,60},{0,120}}&quot; /&gt;
+			&lt;/Window&gt;
+			
+						
+			
+			&lt;!--
+			*** Helden wechsel ***
+			
+			&lt;Window Type=&quot;RastullahLook/Listbox&quot; Name=&quot;InventoryWindow/Heroes&quot;&gt;
+				&lt;Property Name=&quot;Text&quot; Value=&quot;Heroes&quot;/&gt;
+				&lt;Property Name=&quot;UnifiedAreaRect&quot; Value=&quot;{{0,30},{0,475},{0,330},{0,525}}&quot; /&gt;
+			&lt;/Window&gt;
+			--&gt;
+			&lt;!-- Rechte Seite --&gt; 
+			
+			&lt;!-- Itembild --&gt;
+			&lt;Window Type=&quot;RastullahLook/StaticImage&quot; Name=&quot;InventoryWindow/ItemPicture&quot;&gt;
+				&lt;Property Name=&quot;Text&quot; Value=&quot;Itempicture&quot;/&gt;
+				&lt;Property Name=&quot;UnifiedAreaRect&quot; Value=&quot;{{0,370},{0,20},{0,498},{0,148}}&quot; /&gt;
+			&lt;/Window&gt;
+			
+			&lt;Window Type=&quot;RastullahLook/ScrollablePane&quot; Name=&quot;InventoryWindow/Description&quot;&gt;
+				&lt;Property Name=&quot;Text&quot; Value=&quot;&quot;/&gt;
+				&lt;Property Name=&quot;UnifiedAreaRect&quot; Value=&quot;{{0,508},{0,20},{1,-25},{0,148}}&quot; /&gt;
+			&lt;/Window&gt;
+	
+			&lt;Window Type=&quot;RastullahLook/MultiLineEditbox&quot; Name=&quot;InventoryWindow/Infos&quot;&gt;
+				&lt;Property Name=&quot;Font&quot; Value=&quot;Vera Serif-10&quot; /&gt;
+                &lt;!--&lt;Property Name=&quot;FrameEnabled&quot; Value=&quot;false&quot; /&gt;--&gt;
+				&lt;Property Name=&quot;Text&quot; Value=&quot;BE: 0, AT: 5, Traglast: 0 Stein, Max: 50 Stein, Guthaben: 5 Dukaten, Ausdauer: 25&quot;/&gt;
+				
+				&lt;Property Name=&quot;UnifiedAreaRect&quot; Value=&quot;{{0,370},{0,158},{1,-25},{0,210}}&quot; /&gt;
+			&lt;/Window&gt;
+				
+			&lt;Window Type=&quot;RastullahLook/TabControl&quot; Name=&quot;InventoryWindow/Tabs&quot;&gt;
+				&lt;Property Name=&quot;UnifiedAreaRect&quot; Value=&quot;{{0,370},{0,220},{1,-25},{0.9,-20}}&quot; /&gt;
+			&lt;/Window&gt;
+			
+			&lt;!-- Das Ruestungsfenster --&gt;
+			&lt;Window Type=&quot;RastullahLook/TransparentStaticImage&quot; Name=&quot;InventoryWindow/ArmorValueWindow&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,370},{0,475}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,50},{0,50}}&quot; /&gt;
+				
+				&lt;Window Type=&quot;RastullahLook/TransparentStaticText&quot; Name=&quot;InventoryWindow/ArmorValue&quot;&gt;
+					&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,6},{0,0}}&quot; /&gt;
+					&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{1,0},{0.67,0}}&quot; /&gt;
+				&lt;/Window&gt;
+				
+				&lt;Window Type=&quot;RastullahLook/TransparentStaticText&quot; Name=&quot;InventoryWindow/HandicapValue&quot;&gt;
+					&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,24},{0,0}}&quot; /&gt;
+					&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{1,0},{0.67,0}}&quot; /&gt;
+				&lt;/Window&gt;
+			&lt;/Window&gt;
+			&lt;!-- Das Gewichtsfenster --&gt;
+			&lt;Window Type=&quot;RastullahLook/TransparentStaticImage&quot; Name=&quot;InventoryWindow/WeightWindow&quot;&gt;
+				&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,430},{0,475}}&quot; /&gt;
+				&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{0,45},{0,50}}&quot; /&gt;
+
+				&lt;Window Type=&quot;RastullahLook/TransparentStaticText&quot; Name=&quot;InventoryWindow/TotalWeight&quot;&gt;
+					&lt;Property Name=&quot;UnifiedPosition&quot; Value=&quot;{{0,6},{0,4}}&quot; /&gt;
+					&lt;Property Name=&quot;UnifiedSize&quot; Value=&quot;{{1,0},{1,-4}}&quot; /&gt;
+				&lt;/Window&gt;
+			&lt;/Window&gt;
+			
+		&lt;/Window&gt;
+	&lt;/Window&gt;
+&lt;/GUILayout&gt;
+
+

Modified: modules/regressiontest/dsa/gameobjectdefinitions.gof
===================================================================
--- modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-03-30 19:13:11 UTC (rev 3211)
+++ modules/regressiontest/dsa/gameobjectdefinitions.gof	2007-03-30 19:20:10 UTC (rev 3212)
@@ -60,6 +60,7 @@
         &lt;property name=&quot;baseclass&quot; type=&quot;STRING&quot; data=&quot;Weapon&quot; /&gt;
         &lt;property name=&quot;description&quot; type=&quot;STRING&quot; data=&quot;Ein ordin&#228;res Kurzschwert - scharf, aber langweilig&quot;/&gt;
         &lt;property name=&quot;meshfile&quot; type=&quot;STRING&quot; data=&quot;waf_kurzschwert_01.mesh&quot;/&gt;
+		&lt;property name=&quot;imagename&quot; type=&quot;STRING&quot; data=&quot;set:ModelThumbnails image:waf_kurzschwert_01&quot;/&gt;
     &lt;/gameobjectclass&gt;
 
     &lt;gameobjectclass&gt;

Added: rl/branches/old_inventory_window/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/branches/old_inventory_window/engine/ui/include/InventoryWindow.h	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/branches/old_inventory_window/engine/ui/include/InventoryWindow.h	2007-03-30 19:20:10 UTC (rev 3212)
@@ -0,0 +1,275 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+#ifndef __InventoryWindow_H__
+#define __InventoryWindow_H__
+
+#include &quot;UiPrerequisites.h&quot;
+#include &quot;CeGuiWindow.h&quot;
+#include &quot;Inventory.h&quot;
+#include &quot;GameTask.h&quot;
+
+namespace rl {
+
+	class Creature;
+    class Item;
+
+	class _RlUiExport InventoryArrangeTask : public GameTask
+	{
+	public:
+		InventoryArrangeTask();
+		~InventoryArrangeTask();
+		
+		void run(Ogre::Real elapsedTime);
+
+        virtual const Ogre::String&amp; getName() const;
+	};
+
+	class _RlUiExport InventoryWindow : public CeGuiWindow
+	{
+	public:
+		InventoryWindow();
+		~InventoryWindow();
+
+		// Flag fr den ArrangeTask - FIXME nach private umziehen, wenn 
+		CEGUI::DragContainer* mDroppedItem;
+
+		/**
+		* Gibt dem Fenster das anzuzeigende Inventar
+		*/
+		void setInventory(Inventory* inventory);
+
+		/**
+		* Methode fr das OnMouseOver Event
+		*/
+		bool handleMouseEnters(const CEGUI::EventArgs &amp;args);
+		
+		/**
+		* Methode fr das OnMouseLeaves Event
+		*/
+		bool handleMouseLeaves(const CEGUI::EventArgs &amp;args);
+
+		/**
+		* Methode fr das OnMouseClick Event
+		*/
+		bool handleMouseClicked(const CEGUI::EventArgs &amp;args);
+
+		/**
+		* 
+		*/
+		void update();
+
+		/**
+		* &#65533;ergibt &#65533;derungen ans Inventar
+		*/
+		void updateInventory();
+
+		/**
+		* Passt die Position eines gedroppten Items an, da CEGUI Bug, braucht man 
+		* dafr ne externe Methode
+		*/
+		void updateItemPosition();
+
+		// FIXME, wenn BUG im CEGUI behoben ist: entfernen
+
+		/**
+		* Schaut nach, ob das Item an der Position gedroppt werden kann.
+		*/
+		bool isFreeInContainer(Item* item, std::pair&lt;int,int&gt; kaestechenPos, Container* container);
+
+
+		Item* getGroundItem();
+
+	private:
+		Inventory* mInventory;
+
+		// Farbschema fr die Fenster und Itemhintergrnde
+		const CeGuiString mColorAccept;
+		const CeGuiString mColorReject;
+		const CeGuiString mColorNormal;
+		const CeGuiString mColorItemNormal;
+		const CeGuiString mColorItemSelected;
+
+		// TODO : Ersetze durch etwas dynamisches
+		Item* mGroundItem;
+
+		// Der Knoten an dem das zu redernde Item angebracht wird;
+		Ogre::SceneNode* mInventoryItemNode;
+		// Entity des jeweils zu rendernden Items
+		Ogre::Entity* mRenderItemEntity;
+		// 128*128 Textur fr das Item-view Fenster
+		Ogre::RenderTexture* mRenderTexture;
+		// Viewport des RenderToTexture Features
+		Ogre::Viewport* mRenderViewport;
+		// Die Camera, die das Item filmt
+		Actor* mCameraActor;
+
+		CEGUI::Texture* mTexture;
+		CEGUI::Imageset* mImageSet;
+
+        InventoryArrangeTask* mInventoryArrangeTask;
+
+		// Das Item-Renderfenster
+		CEGUI::Window* mItemRenderImage;
+
+
+		// Das Rstungs- und Behinderungswert Fenster
+		CEGUI::Window* mArmorValueWindow;
+		CEGUI::Window* mArmorValue;
+		CEGUI::Window* mHandicapValue;
+
+		// Das Gewichtsfenster
+		CEGUI::Window* mWeightWindow;
+		CEGUI::Window* mTotalWeight;
+		
+
+		// Das Item-Beschreibungsfenster
+		CEGUI::ScrollablePane* mDescription;
+
+		// Das jeweils aktive Fenster, das im Beschreibungsfenster angew&#65533;lt ist
+		CEGUI::Window* mActiveItemWindow;
+
+		// Das Fenster, in das der Rucksackcontainer soll
+		CEGUI::TabControl* mContainerTabs;
+
+		// Die Containerslots (besonders, da alle Arten von Items akzeptiert)
+		std::list&lt;CEGUI::Window*&gt; mContainerContents;
+
+		std::list&lt;CEGUI::Window*&gt; mContainers;
+
+		CEGUI::Window* mGroundTab;
+		CEGUI::Window* mGroundContainer;
+
+		const std::pair&lt;int,int&gt; mGroundDimension;
+
+		// Alle verschiedenen Inventoryslots
+		CEGUI::Window* mRingLeft;
+		CEGUI::Window* mRingRight;
+		CEGUI::Window* mHandLeft;
+		CEGUI::Window* mHandRight;
+		CEGUI::Window* mGloves;
+		CEGUI::Window* mBraceletLeft;
+		CEGUI::Window* mBraceletRight;
+		CEGUI::Window* mArmor;
+		CEGUI::Window* mCape;
+		CEGUI::Window* mBracers;
+		CEGUI::Window* mBackpack;
+		CEGUI::Window* mBelt;
+		CEGUI::Window* mNecklace;
+		CEGUI::Window* mHelmet;
+		CEGUI::Window* mTrousers;
+		CEGUI::Window* mShinbone;
+		CEGUI::Window* mBoots;
+
+		CEGUI::Point mPosDraggedTo;
+		CEGUI::Window* mContainerDraggedTo;
+		CEGUI::DragContainer* mOldItemInSlot;
+        
+        CEGUI::DragContainer* createItem(Item* item, CEGUI::Window* parent, CEGUI::UVector2 position = CEGUI::UVector2(cegui_reldim(0.0f), cegui_reldim(0.0f)));
+
+		/**
+		* Schliesst das Fenster bei Klick auf X
+		*/
+		bool handleClose();
+
+		void initRenderToTexture();
+
+		/**
+		* L&#65533;t die Rtt-Camera
+		*/
+		void loadCamera();
+		void unloadCamera();
+
+		/**
+		* Rendert das Item in das Vorschaufenster im Inventar
+		*/
+		void renderItem(Item* item);
+
+		/**
+		* Initiiert die Slots des Inventars
+		*/
+		void initSlots();
+
+		/**
+		* Fllt die Slots im InventarFenster mit den Items aus dem Inventar
+		*/
+		void fillSlots();
+
+		/**
+		* Erzeugt ein Tab fr den Container, und befuellt ihn nach Inhalt des container - Items
+		*/
+		void createAndFillContainer(Container* container);
+
+		/**
+		* entfernt ein ContainerTab mitsamt Inhalt aus dem Inventar
+		*/
+		void removeContainerAndContent(Container* container);
+
+		/**
+		* Entleert die Slots im InventarFenster wieder
+		*/
+		void emptySlots();
+
+
+		void refreshTabs();
+
+		/**
+		* Sucht unter den Containern dasjenige, das zum gesuchten Container geh&#65533;t
+		*/
+		CEGUI::Window* findContainer(Container* container);
+
+		/**
+		*
+		* Entfernt alle Unterfenster
+		*/
+		void emptySlot(CEGUI::Window* slot);
+		/** 
+		* Gibt dem Slot die F&#65533;igkeit Dragcontainer zu akzeptieren
+		*/
+		void addDropListener(CEGUI::Window* slot);
+
+		/*!
+		* fgt dem Inventar den Container fr den Rucksack zu,
+		* gibt ihm die n&#65533;ige Funktionalit&#65533; fr drag&amp;drop
+		*/
+		void initBackpack(std::pair&lt;int,int&gt; dim);
+
+
+		/**
+		* erzeugt fr alle Items im Inventar, die Containerfunktionaltiaet haben, ein Containertab
+		* im Inventar
+		*/
+		void createContainerWindows();
+
+		/**
+		* &#65533;erprft, ob das gedroppte Item vom Slot akzeptiert wird oder nicht
+		* @return true: Item wird akzeptiert
+		*         false: Item wird nicht akzeptiert
+		*/ 
+		bool checkTypeAccepted(CEGUI::Window* window, CEGUI::DragContainer* draggedItem);
+
+
+		/**
+		* Errechnet die K&#65533;tchenposition, an der das Item im Container gedroppt wurde
+		*/
+		std::pair&lt;int,int&gt; calculateNewPosition(const CEGUI::DragDropEventArgs&amp; ddea);
+
+		bool handleDragEnter(const CEGUI::EventArgs&amp; args);
+		bool handleDragLeave(const CEGUI::EventArgs&amp; args);
+		bool handleDragDropped(const CEGUI::EventArgs&amp; args);
+	};
+}
+#endif

Added: rl/branches/old_inventory_window/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/branches/old_inventory_window/engine/ui/src/InventoryWindow.cpp	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/branches/old_inventory_window/engine/ui/src/InventoryWindow.cpp	2007-03-30 19:20:10 UTC (rev 3212)
@@ -0,0 +1,1295 @@
+/* This source file is part of Rastullahs Lockenpracht.
+ * Copyright (C) 2003-2007 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+ * 
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the Clarified Artistic License.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  Clarified Artistic License for more details.
+ *
+ *  You should have received a copy of the Clarified Artistic License
+ *  along with this program; if not you can get it here
+ *  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+ */
+
+
+#include &lt;boost/bind.hpp&gt;
+
+#include &quot;InventoryWindow.h&quot;
+
+#include &quot;Actor.h&quot;
+#include &quot;ActorManager.h&quot;
+#include &quot;CameraObject.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;GameLoop.h&quot;
+#include &quot;Inventory.h&quot;
+#include &quot;MeshObject.h&quot;
+#include &quot;PhysicalThing.h&quot;
+#include &quot;RulesSubsystem.h&quot;
+#include &quot;UiSubsystem.h&quot;
+#include &quot;WindowFactory.h&quot;
+#include &quot;World.h&quot;
+#include &quot;CeGuiHelper.h&quot;
+
+#include &lt;CEGUIPropertyHelper.h&gt;
+#include &lt;OgreCEGUIRenderer.h&gt;
+
+using namespace CEGUI;
+using namespace Ogre;
+using namespace std;
+
+namespace rl {
+
+	// @FIXME Wenn CeGUI Bug beseitigt hat:
+	InventoryArrangeTask::InventoryArrangeTask() : GameTask()
+	{
+	}
+
+	InventoryArrangeTask::~InventoryArrangeTask()
+	{
+	}
+
+	void InventoryArrangeTask::run(Ogre::Real elapsedTime)
+	{
+		static InventoryWindow* invWin = WindowFactory::getSingletonPtr()-&gt;getInventoryWindow();
+		if (invWin-&gt;mDroppedItem)
+		{
+			LOG_MESSAGE(&quot;InventoryWindow&quot;, &quot;Item placed&quot;);
+			invWin-&gt;updateItemPosition();
+		}
+	}
+
+    const Ogre::String&amp; InventoryArrangeTask::getName() const
+    {
+        static Ogre::String NAME = &quot;InventoryArrangeTask&quot;;
+
+        return NAME;
+    }
+
+
+	// ***************************************************************
+	// ***************** Konstruktor *********************************
+	// ***************************************************************
+	InventoryWindow::InventoryWindow()
+		: CeGuiWindow(&quot;inventorywindow.xml&quot;, WND_MOUSE_INPUT),
+		mDescription(NULL),
+		mRenderItemEntity(NULL),
+		mRenderTexture(NULL),
+		mRenderViewport(NULL),
+		mItemRenderImage(NULL),
+		mCameraActor(NULL),
+		mInventoryItemNode(NULL),
+		mTexture(NULL),
+		mImageSet(NULL),
+		mActiveItemWindow(NULL),
+		mArmorValueWindow(NULL),
+		mArmorValue(NULL),
+		mHandicapValue(NULL),
+		mWeightWindow(NULL),
+		mTotalWeight(NULL),
+		mPosDraggedTo(),
+		mContainerDraggedTo(NULL),
+		mDroppedItem(NULL),
+		mOldItemInSlot(NULL),
+		mContainerTabs(NULL),
+		mContainerContents(NULL),
+		mGroundTab(NULL),
+		mGroundItem(NULL),
+		mGroundContainer(NULL),
+		mColorAccept(&quot;FF22FF22&quot;),
+		mColorReject(&quot;FFFF2222&quot;),
+		mColorNormal(&quot;FFFFFFFF&quot;),
+		mColorItemNormal(&quot;FF999955&quot;),
+		mColorItemSelected(&quot;FFDDDD99&quot;),
+		mRingLeft(NULL),
+		mRingRight(NULL),
+		mHandLeft(NULL),
+		mHandRight(NULL),
+		mGloves(NULL),
+		mBraceletLeft(NULL),
+		mBraceletRight(NULL),
+		mArmor(NULL),
+		mCape(NULL),
+		mBracers(NULL),
+		mBackpack(NULL),
+		mBelt(NULL),
+		mNecklace(NULL),
+		mHelmet(NULL),
+		mTrousers(NULL),
+		mShinbone(NULL),
+		mBoots(NULL),
+        mInventoryArrangeTask(),
+		mGroundDimension(make_pair&lt;int,int&gt;(12,15))
+	{
+		initSlots();
+		initRenderToTexture();
+
+		mWindow-&gt;subscribeEvent(FrameWindow::EventCloseClicked,
+			boost::bind(&amp;InventoryWindow::handleClose, this));
+
+        mInventoryArrangeTask = new InventoryArrangeTask();
+        GameLoop::getSingletonPtr()-&gt;addTask(mInventoryArrangeTask, GameLoop::TG_GRAPHICS);
+	}
+	
+	InventoryWindow::~InventoryWindow()
+	{
+		/*if(mBackpackContent){
+			mBackpackContent-&gt;destroy();
+		}*/
+        delete mInventoryArrangeTask;
+//        delete mGroundItem;
+	}
+
+
+	/** Methoden */
+
+	void InventoryWindow::setInventory(Inventory* inventory)
+	{
+		if (inventory != NULL &amp;&amp; mInventory != inventory){
+			// Entleere Slots zur Sicherheit (falls anderes Inventar zuvor gezeigt wurde)
+			emptySlots();
+			// Speichere das neue Inventar
+			mInventory = inventory;
+			// Fuelle das Fenster entsprechend dem neuen Inventar, das angezeigt werden soll
+			fillSlots();
+			update();
+		}
+	}
+
+	bool InventoryWindow::handleClose()
+	{
+		if (isVisible())
+		{
+			setVisible(false);
+		}
+		return true;
+	}
+
+	void InventoryWindow::update()
+	{
+		// Aktualisiere Werte
+
+		// Rstung
+		mArmorValue-&gt;setText(Ogre::StringConverter::toString(mInventory-&gt;getOverallRs()));
+
+		// Behinderung
+		pair&lt;int,int&gt; behinderung = mInventory-&gt;getOverallBe();
+		mHandicapValue-&gt;setText(Ogre::StringConverter::toString(behinderung.first+behinderung.second));
+		if (behinderung.second &gt; 0)
+		{
+			mArmorValueWindow-&gt;setTooltipText(&quot;Rstung / Behinderung\r\n           / +&quot;+Ogre::StringConverter::toString(behinderung.second)+&quot; berladen&quot;);
+		} 
+		else
+		{
+			mArmorValueWindow-&gt;setTooltipText(&quot;Rstung / Behinderung&quot;);
+		}
+
+		// Gewicht in Unzen
+		int weight = mInventory-&gt;getOverallWeight() / 40;
+		// TODO: runden
+		mTotalWeight-&gt;setText(Ogre::StringConverter::toString(weight));
+	}
+
+	void InventoryWindow::updateItemPosition(){
+		
+		// Positionieren
+        mDroppedItem-&gt;setPosition(CeGuiHelper::asAbsolute(mPosDraggedTo));
+		mDroppedItem = NULL;
+
+		// Loggen
+		LOG_MESSAGE(
+			&quot;InventoryWindow&quot;,
+			Ogre::String(&quot;Position set to: Point x:&quot;)
+			+ StringConverter::toString(mPosDraggedTo.d_x)
+			+ &quot;, Point y:&quot;
+			+ StringConverter::toString(mPosDraggedTo.d_y));
+
+		LOG_MESSAGE(&quot;InventoryWindow&quot;, &quot;updateItemPosition finished&quot;);
+	}
+
+	void InventoryWindow::updateInventory(){
+		// Nach Drop
+		Item* item = static_cast&lt;Item*&gt;(mDroppedItem-&gt;getUserData());
+
+		// Gegenstand von alter Position entfernen
+		//mInventory-&gt;removeItem(item);
+
+		// Gegenstand vom Boden entfernen
+		//mInventory-&gt;removeItemFromContainer(item, mGroundItem);
+
+		// Welchem Item wird das Item hinzugefgt? -&gt; speichere das in die Variable container
+		Item* container = static_cast&lt;Item*&gt;(mContainerDraggedTo-&gt;getUserData());
+
+		// Extra Behandlung, falls Item auf den Boden gelegt wird
+		if (container == mGroundItem)
+		{
+			//mInventory-&gt;setItemContainerPosition(
+			//	item,
+			//	(int)(mPosDraggedTo.d_x/30), 
+			//	(int)(mPosDraggedTo.d_y/30),
+			//	container);
+
+			// Zusaetzlich wenn Item Container war, muss Tab entfernt werden (einfach Inventar neu aufbauen)
+			if (item-&gt;isContainer())
+			{
+				removeContainerAndContent(dynamic_cast&lt;Container*&gt;(item));
+				refreshTabs();
+			}
+			update();
+			return;
+		} 
+				
+		// Item im Container platzieren
+		std::list&lt;CEGUI::Window*&gt;::iterator it = mContainerContents.begin();
+
+		while (it != mContainerContents.end())
+		{
+			if (mContainerDraggedTo == *it++){
+				//mInventory-&gt;setItemContainerPosition(
+				//	item,
+				//	(int)(mPosDraggedTo.d_x/30), 
+				//	(int)(mPosDraggedTo.d_y/30),
+				//	container);
+				break;
+			}
+		}
+
+		if (item-&gt;isContainer())
+		{
+			// ContainerTab hinzufgen, wenn nicht schon vorhanden
+			createAndFillContainer(dynamic_cast&lt;Container*&gt;(item));
+			refreshTabs();
+
+		}
+		
+
+		bool itemSwitched = false;
+		// Gegenstand in Slot setzen / Schon dagewesenen Gegenstand zurck in den Rucksack setzen
+		//if (mContainerDraggedTo == mArmor){
+		//	if (mInventory-&gt;getArmor() != NULL){
+		//		//Pack die alte Rstung ins Inventar
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeArmor(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setArmor(item);
+		//}
+		//if (mContainerDraggedTo == mCape){
+		//	if (mInventory-&gt;getCape() != NULL){
+		//		//Pack die alte Rstung ins Inventar
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeCape(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setCape(item);
+		//}
+		//if (mContainerDraggedTo == mBackpack) {
+		//	if (mInventory-&gt;getBackpack() != NULL){
+		//		//Pack den alten Rucksack auf den Boden
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeBackpack(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setBackpack(item);
+		//}
+		//if (mContainerDraggedTo == mBelt) {
+		//	if (mInventory-&gt;getBelt() != NULL){
+		//		//Pack den alten Grtel ins Inventar
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeBelt(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setBelt(item);
+		//}
+		//if (mContainerDraggedTo == mBoots) {
+		//	if (mInventory-&gt;getBoots() != NULL){
+		//		//pack die alten Stiefel ins Inventar
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeBoots(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setBoots(item);
+		//}
+		//if (mContainerDraggedTo == mBraceletLeft) {
+		//	if (mInventory-&gt;getBraceletLeft() != NULL){
+		//		//pack den alten Armreif ins Inventar
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeBraceletLeft(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setBraceletLeft(item);
+		//}
+		//if (mContainerDraggedTo == mBraceletRight) {
+		//	if (mInventory-&gt;getBraceletRight() != NULL){
+		//		//pack den alten Armreif ins Inventar
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeBraceletRight(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setBraceletRight(item);
+		//}
+		//if (mContainerDraggedTo == mRingLeft) {
+		//	if (mInventory-&gt;getRingLeft() != NULL){
+		//		//pack den alten Ring ins Inventar
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeRingLeft(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setRingLeft(item);
+		//}
+		//if (mContainerDraggedTo == mRingRight) {
+		//	if (mInventory-&gt;getRingRight() != NULL){
+		//		//pack den alten Ring ins Inventar
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeRingRight(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setRingRight(item);
+		//}
+		//if (mContainerDraggedTo == mHelmet) {
+		//	if (mInventory-&gt;getHelmet() != NULL){
+		//		//pack den alten Helm ins Inventar
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeHelmet(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setHelmet(item);
+		//}
+		//if (mContainerDraggedTo == mBracers) {
+		//	if (mInventory-&gt;getBracers() != NULL){
+		//		//pack die alte Armschienen ins Inventar
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeBracers(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setBracers(item);
+		//}
+		//if (mContainerDraggedTo == mNecklace) {
+		//	if (mInventory-&gt;getNecklace() != NULL){
+		//		//pack das alte Amulett ins Inventar
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeNecklace(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setNecklace(item);
+		//}
+		//if (mContainerDraggedTo == mGloves) {
+		//	if (mInventory-&gt;getGloves() != NULL){
+		//		//pack die alten Handschuhe ins Inventar
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeGloves(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setGloves(item);
+		//}
+		//if (mContainerDraggedTo == mTrousers) {
+		//	if (mInventory-&gt;getTrousers() != NULL){
+		//		//pack die alte Hose ins Inventar
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeTrousers(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setTrousers(item);
+		//}
+		//if (mContainerDraggedTo == mShinbone) {
+		//	if (mInventory-&gt;getShinbone() != NULL){
+		//		//pack die alte Hose ins Inventar
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeShinbone(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setShinbone(item);
+		//}
+		//if (mContainerDraggedTo == mHandLeft) {
+		//	if (mInventory-&gt;getHandLeft() != NULL){
+		//		//pack das alte Schild ins Inventar
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeHandLeft(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setHandLeft(item);
+		//}
+		//if (mContainerDraggedTo == mHandRight) {
+		//	if (mInventory-&gt;getHandRight() != NULL){
+		//		//pack die alte Waffe ins Inventar
+		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeHandRight(), mInventory-&gt;getBackpack());
+		//		itemSwitched = true;
+		//	}
+		//	mInventory-&gt;setHandRight(item);
+		//}
+		if (itemSwitched)
+		{
+			try {
+				//Bild muss im Inventarfenster an die neue Position gelegt werden
+				//pair&lt;pair&lt;int,int&gt;,Item*&gt; posInContainer = mInventory-&gt;getItemPositionInContainer(static_cast&lt;Item*&gt;(mOldItemInSlot-&gt;getUserData()));
+
+				//// Container Fenster suchen
+				//CEGUI::Window* win = findContainer(posInContainer.second);
+				//// Dem Fenster hinzufgen
+				//win-&gt;addChildWindow(mOldItemInSlot);
+				//// Positionieren		
+				//mOldItemInSlot-&gt;setPosition( CEGUI::Absolute,
+				//	CEGUI::Point(posInContainer.first.first * 30, posInContainer.first.second * 30));
+
+			}
+			catch (IllegalArgumentException iae)
+			{
+				// TODO: Item am Boden suchen
+			}
+		}
+
+
+		// Update am Inventar durchgefhrt, jetzt sollen noch die Werte aktualisiert werden
+		update();
+	}
+
+
+	void InventoryWindow::refreshTabs()
+	{
+		std::list&lt;CEGUI::Window*&gt;::iterator it = mContainers.begin();
+
+		// entferne alle Unterfenster
+		while(mContainerTabs-&gt;getTabCount() &gt; 0)
+		{
+			mContainerTabs-&gt;removeTab(mContainerTabs-&gt;getTabContents(0)-&gt;getName());
+		}
+
+		// fge sie in richtiger Reihenfolge wieder hinzu
+		while (it != mContainers.end())
+		{
+			mContainerTabs-&gt;addTab(*it++);
+		}
+	}
+
+	bool InventoryWindow::isFreeInContainer(Item* item, pair&lt;int,int&gt; kaestchenPos, Container* container)
+	{
+        return container-&gt;canPlaceAt(item, kaestchenPos.first, kaestchenPos.second);
+		//return mInventory-&gt;isFreeInContainer(item, kaestchenPos, container);
+        //return true;
+	}
+
+
+	Item* InventoryWindow::getGroundItem()
+	{
+		return mGroundItem;
+	}
+
+	void InventoryWindow::initSlots()
+	{
+		mArmorValueWindow = getWindow(&quot;InventoryWindow/ArmorValueWindow&quot;);
+        mArmorValueWindow-&gt;setProperty(&quot;Image&quot;, &quot;set:InventorySymbols image:Shield&quot;);
+		mArmorValueWindow-&gt;setTooltipText(&quot;Rstung / Behinderung&quot;);
+		//TODO: An Tooltip anhaengen: woraus setzt sich die Rstung zusammen?
+		mArmorValue = getWindow(&quot;InventoryWindow/ArmorValue&quot;);
+		mArmorValue-&gt;setText(&quot; 3&quot;);
+		//mArmorValue-&gt;setTextColours(CEGUI::colour(0.0,0.4,0.0)); //TODO port to cegui0.5
+		mArmorValue-&gt;disable();
+		mHandicapValue = getWindow(&quot;InventoryWindow/HandicapValue&quot;);
+		mHandicapValue-&gt;setText(&quot;2&quot;);
+		//mHandicapValue-&gt;setTextColours(CEGUI::colour(0.4,0.0,0.0)); //TODO port to cegui0.5
+		mHandicapValue-&gt;disable();
+
+		mWeightWindow = getWindow(&quot;InventoryWindow/WeightWindow&quot;);
+        mWeightWindow-&gt;setProperty(&quot;Image&quot;, &quot;set:InventorySymbols image:Weight&quot;);
+		mWeightWindow-&gt;setTooltipText(&quot;Getragenes Gewicht\r\nin Stein&quot;);
+
+		mTotalWeight = getWindow(&quot;InventoryWindow/TotalWeight&quot;);
+		mTotalWeight-&gt;setText(&quot;&quot;);
+		// Schwarzer Text (wird rot, wenn berladen)
+		//mTotalWeight-&gt;setTextColours(CEGUI::colour(0.0,0.0,0.0));  //TODO port to cegui0.5
+		mTotalWeight-&gt;disable();
+				
+
+		// Das Item-Beschreibungsfeld holen
+		mDescription = getScrollablePane(&quot;InventoryWindow/Description&quot;);
+
+		// Das &quot;BodenItem&quot; initiieren
+		mGroundItem = new Item(1/*&quot;Boden&quot;, &quot;Dieses Item repr&#65533;entiert den Boden&quot;*/);
+		mGroundItem-&gt;setImageName(&quot;Trank&quot;);
+		mGroundItem-&gt;setItemType(Item::ITEMTYPE_OTHER);
+		mGroundItem-&gt;setSize(1,1);
+		//mGroundItem-&gt;setContainer(true, std::make_pair&lt;int,int&gt;(mGroundDimension.first,mGroundDimension.second));
+
+
+		mContainerTabs = getTabControl(&quot;InventoryWindow/Tabs&quot;);
+		
+		// Hole die einzelnen Slots aus dem XML-File
+		mHelmet = getWindow(&quot;InventoryWindow/Helmet&quot;);
+		mHelmet-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_HELMET));
+		
+		mRingLeft = getWindow(&quot;InventoryWindow/RingLeft&quot;);
+		mRingLeft-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_RING));
+		
+		mRingRight = getWindow(&quot;InventoryWindow/RingRight&quot;);
+		mRingRight-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_RING));
+		
+		mHandLeft = getWindow(&quot;InventoryWindow/HandLeft&quot;);
+		mHandLeft-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_SHIELD));
+
+		mHandRight = getWindow(&quot;InventoryWindow/HandRight&quot;);
+		mHandRight-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_WEAPON));
+
+		mGloves = getWindow(&quot;InventoryWindow/Gloves&quot;);
+		mGloves-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_GLOVES));
+
+		mBraceletLeft = getWindow(&quot;InventoryWindow/BraceletLeft&quot;);
+		mBraceletLeft-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_BRACELET));
+
+		mBraceletRight = getWindow(&quot;InventoryWindow/BraceletRight&quot;);
+		mBraceletRight-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_BRACELET));
+
+		mArmor = getWindow(&quot;InventoryWindow/Armor&quot;);
+		mArmor-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_ARMOR));
+
+		mCape = getWindow(&quot;InventoryWindow/Cape&quot;);
+		mCape-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_CAPE));
+
+		mBracers = getWindow(&quot;InventoryWindow/Bracers&quot;);
+		mBracers-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_BRACERS));
+
+		mBackpack = getWindow(&quot;InventoryWindow/Backpack&quot;);
+		mBackpack-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_BACKPACK));
+
+		mBelt = getWindow(&quot;InventoryWindow/Belt&quot;);
+		mBelt-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_BELT));
+
+		mNecklace = getWindow(&quot;InventoryWindow/Necklace&quot;);
+		mNecklace-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_NECKLACE));
+
+		mTrousers = getWindow(&quot;InventoryWindow/Trousers&quot;);
+		mTrousers-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_TROUSERS));
+
+		mShinbone = getWindow(&quot;InventoryWindow/Shinbone&quot;);
+		mShinbone-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_SHINBONE));
+
+		mBoots = getWindow(&quot;InventoryWindow/Boots&quot;);
+		mBoots-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_BOOTS));
+
+		// gib ihnen die Funktionalitaet Items aufzunehmen
+		addDropListener(mHelmet);
+		addDropListener(mRingLeft);
+		addDropListener(mRingRight);
+		addDropListener(mHandLeft);
+		addDropListener(mHandRight);
+		addDropListener(mGloves);
+		addDropListener(mBraceletLeft);
+		addDropListener(mBraceletRight);
+		addDropListener(mArmor);
+		addDropListener(mCape);
+		addDropListener(mBracers);
+		addDropListener(mBackpack);
+		addDropListener(mBelt);
+		addDropListener(mNecklace);
+		addDropListener(mTrousers);
+		addDropListener(mShinbone);
+		addDropListener(mBoots);
+	}
+
+	void InventoryWindow::fillSlots()
+	{
+		//createItem(mInventory-&gt;getRingLeft(), mRingLeft);
+		//createItem(mInventory-&gt;getRingRight(), mRingRight);
+		createItem(mInventory-&gt;getItem(&quot;Left Hand&quot;), mHandLeft);
+		//createItem(mInventory-&gt;getHandRight(), mHandRight);
+		//createItem(mInventory-&gt;getGloves(), mGloves);
+		//createItem(mInventory-&gt;getBraceletLeft(), mBraceletLeft);
+		//createItem(mInventory-&gt;getBraceletRight(), mBraceletRight);
+		//createItem(mInventory-&gt;getArmor(), mArmor);
+		//createItem(mInventory-&gt;getCape(), mCape);
+		//createItem(mInventory-&gt;getBracers(), mBracers);
+		//createItem(mInventory-&gt;getBackpack(), mBackpack);
+		//createItem(mInventory-&gt;getBelt(), mBelt);
+		//createItem(mInventory-&gt;getNecklace(), mNecklace);
+		//createItem(mInventory-&gt;getHelmet(), mHelmet);
+		//createItem(mInventory-&gt;getTrousers(), mTrousers);
+		//createItem(mInventory-&gt;getShinbone(), mShinbone);
+		//createItem(mInventory-&gt;getBoots(), mBoots);
+
+
+		// Fenster fr ContainerItems erstellen
+		createContainerWindows();
+	}
+
+
+	void InventoryWindow::createContainerWindows() {
+		
+
+		std::list&lt;Item*&gt; allItems = mInventory-&gt;getAllItems();
+
+		std::list&lt;Item*&gt;::iterator itemIterator = allItems.begin();
+		
+		while (itemIterator != allItems.end()){
+			Item* currentItem = *itemIterator++;
+
+			if (currentItem-&gt;isContainer()){
+				// Tab fr Item erzeugen, da es als Container funktioniert
+				createAndFillContainer(dynamic_cast&lt;Container*&gt;(currentItem));
+			}
+		}
+		// Den Boden hinzufuegen
+		//createAndFillContainer(mGroundItem);
+	}
+
+	void InventoryWindow::createAndFillContainer(Container* container){
+		assert(mContainerContents.size() == mContainers.size());
+
+		std::list&lt;CEGUI::Window*&gt;::iterator it = mContainerContents.begin();
+		bool found = false;
+		// berprfe, ob schon vorhanden
+		while (it != mContainerContents.end())
+		{
+			if (container == static_cast&lt;Item*&gt;((*it)-&gt;getUserData()))
+			{
+				found = true;
+				break;
+			}
+			it++;
+		}
+		
+		// Nur wenn noch nicht vorhanden, soll Containertab erzeugt werden
+		if (!found)
+		{
+
+			// Erzeuge Tab im Inventar fr den Container
+			CEGUI::Window* containerWindow = CEGUI::WindowManager::getSingleton().createWindow(&quot;DefaultGUISheet&quot;, &quot;InventoryWindow/Tabs/&quot;+container-&gt;getName());
+			// Name fr das Tab
+			containerWindow-&gt;setText(container-&gt;getName());
+
+
+			mContainerTabs-&gt;addTab(containerWindow);
+
+			CEGUI::Window* containerSpace = static_cast&lt;CEGUI::Window*&gt;(CEGUI::WindowManager::getSingletonPtr()-&gt;createWindow(&quot;RastullahLook/Container&quot;, &quot;InventoryWindow/Tabs/&quot;+container-&gt;getName()+&quot;/Content&quot;));
+			
+			containerSpace-&gt;setVerticalAlignment(CEGUI::VA_CENTRE);
+			containerSpace-&gt;setHorizontalAlignment(CEGUI::HA_CENTRE);
+            containerSpace-&gt;setSize(UVector2(cegui_absdim(container-&gt;getVolume().first*30),
+                cegui_absdim(container-&gt;getVolume().second*30)));
+			containerSpace-&gt;setUserData(container);
+			containerWindow-&gt;addChildWindow(containerSpace);
+
+
+			// Inhalt in die Liste Einfgen
+						// Boden an das Ende der Liste einfgen
+			if (container == mGroundItem)
+			{
+				mContainers.push_back(containerWindow);
+				mContainerContents.push_back(containerSpace);
+			}
+			// Rucksack vorne in die Liste einfuegen
+			else if (container-&gt;getItemType() == Item::ITEMTYPE_BACKPACK)
+			{
+				mContainers.push_front(containerWindow);
+				mContainerContents.push_front(containerSpace);
+			}
+			// den Rest dazwischen
+			else 
+			{
+				if (mContainers.size() &gt; 1)
+				{
+					mContainers.insert(++(mContainers.begin()),containerWindow);
+					mContainerContents.insert(++(mContainerContents.begin()),containerSpace);
+				} else {
+					mContainers.push_front(containerWindow);
+					mContainerContents.push_front(containerSpace);
+				}
+			}
+			
+
+			addDropListener(containerSpace);
+
+			// Items im Container erstellen
+			std::set&lt;Item*&gt; itemsInContainer;
+
+			//ContainerLayout temp = container-&gt;getContainerLayout();
+			//for (unsigned x = 0; x &lt; temp.size(); x++){
+			//	for (unsigned y = 0; y &lt; temp[0].size(); y++) {
+			//		if (temp[x][y] != NULL &amp;&amp; (itemsInContainer.find(temp[x][y]) == itemsInContainer.end())){
+			//			DragContainer* itemhandler = createItem(temp[x][y],containerSpace);
+			//			itemhandler-&gt;setPosition(CEGUI::Absolute,CEGUI::Point(x*30,y*30));
+			//			itemsInContainer.insert(temp[x][y]);
+			//			LOG_MESSAGE(
+			//				&quot;InventoryWindow&quot;,
+			//				Ogre::String(&quot;erzeuge Bild im Container: &quot;) + temp[x][y]-&gt;getName());
+			//		}
+			//	}
+			//}
+		}
+	}
+
+
+	void InventoryWindow::removeContainerAndContent(Container* container)
+	{
+		assert(mContainerContents.size() == mContainers.size());
+		std::list&lt;CEGUI::Window*&gt;::iterator it = mContainerContents.begin();
+		std::list&lt;CEGUI::Window*&gt;::iterator itParent = mContainers.begin();
+		CEGUI::Window* windowToEmpty = NULL;
+		CEGUI::Window* parentTabWindow = NULL;
+
+		bool found = false;
+		while (it != mContainerContents.end())
+		{
+			if (container == static_cast&lt;Item*&gt;((*it)-&gt;getUserData()))
+			{
+				// Aus Liste entfernen
+				windowToEmpty = *it;
+				parentTabWindow = *itParent;
+				found = true;
+				break;
+			}
+			it++;
+			itParent++;
+		}
+		if (found)
+		{
+			// Entferne die Elemente aus den Listen
+			mContainerContents.erase(it);
+			mContainers.erase(itParent);
+
+
+			emptySlot(windowToEmpty);
+			emptySlot(parentTabWindow);
+
+			mContainerTabs-&gt;removeTab(parentTabWindow-&gt;getName());
+
+			CEGUI::WindowManager::getSingletonPtr()-&gt;destroyWindow(parentTabWindow);
+		}
+	}
+
+	void InventoryWindow::emptySlots()
+	{
+		emptySlot(mHelmet);
+		emptySlot(mRingLeft);
+		emptySlot(mRingRight);
+		emptySlot(mHandLeft);
+		emptySlot(mHandRight);
+		emptySlot(mGloves);
+		emptySlot(mBraceletLeft);
+		emptySlot(mBraceletRight);
+		emptySlot(mArmor);
+		emptySlot(mCape);
+		emptySlot(mBracers);
+		emptySlot(mBackpack);
+		emptySlot(mBelt);
+		emptySlot(mNecklace);
+		emptySlot(mTrousers);
+		emptySlot(mShinbone);
+		emptySlot(mBoots);
+
+		// Zus&#65533;zlich alle Container durchgehen und entleeren
+		
+		std::list&lt;CEGUI::Window*&gt;::iterator it = mContainerContents.begin();
+		
+		while (it != mContainerContents.end())
+		{
+			emptySlot(*it);
+			CEGUI::WindowManager::getSingletonPtr()-&gt;destroyWindow(*it);
+			it++;
+		} // alle Container wurden entleert
+
+		it = mContainers.begin();
+		while (it != mContainers.end())
+		{
+			emptySlot(*it);
+			mContainerTabs-&gt;removeTab((*it)-&gt;getName());
+			CEGUI::WindowManager::getSingletonPtr()-&gt;destroyWindow(*it);
+			it++;
+		} // alle ContainerTabs wurden entleert
+		mContainerContents.clear();
+		mContainers.clear();
+	}
+
+	void InventoryWindow::emptySlot(CEGUI::Window* slot)
+	{
+		while(slot-&gt;getChildCount() &gt; 0){
+			CEGUI::Window* windowToDestroy = slot-&gt;getChildAtIdx(0);
+			CEGUI::WindowManager::getSingletonPtr()-&gt;destroyWindow(windowToDestroy);
+			slot-&gt;removeChildWindow(windowToDestroy);
+		}
+	}
+
+	void InventoryWindow::addDropListener(CEGUI::Window* slot){
+		// onMouseOver (beim Drag)
+		slot-&gt;subscribeEvent(Window::EventDragDropItemEnters, boost::bind(&amp;InventoryWindow::handleDragEnter,this,_1));
+		// onMouseOut (beim Drag)
+		slot-&gt;subscribeEvent(Window::EventDragDropItemLeaves, boost::bind(&amp;InventoryWindow::handleDragLeave,this,_1));
+		// onItemDropped
+		slot-&gt;subscribeEvent(Window::EventDragDropItemDropped, boost::bind(&amp;InventoryWindow::handleDragDropped,this,_1)); 
+	}
+
+	CEGUI::Window* InventoryWindow::findContainer(Container* container)
+	{
+		std::list&lt;CEGUI::Window*&gt;::iterator it = mContainerContents.begin();
+		while (it != mContainerContents.end())
+		{
+			if (static_cast&lt;Item*&gt;((*it)-&gt;getUserData()) == container)
+				return (*it);
+			it++;
+		}
+		Throw(IllegalArgumentException, &quot;Es gibt kein Containerfenster zu dem gesuchten Item&quot;);
+	}
+
+	DragContainer* InventoryWindow::createItem(Item* item, Window* parent, UVector2 position)
+	{
+		// Prfe, ob ein Item da ist
+		if (item != NULL) {
+
+			// TODO: Ausnahmen sind Waffe und Schild (wenn parent mHand* ist, soll Hintergrund gefllt werden)
+			// Waffe:
+			if (parent == mHandRight || parent == mHandLeft) 
+			{
+				position = UVector2(cegui_absdim(30-(item-&gt;getSize().first * 15)), cegui_absdim(75-(item-&gt;getSize().second *15)));
+			}
+
+			static int itemCnt = 0;
+			itemCnt++;
+
+			// Erzeuge einen Handler fr Drag and Drop
+			DragContainer* itemhandler = static_cast&lt;DragContainer*&gt;(
+				CEGUI::WindowManager::getSingletonPtr()-&gt;createWindow(&quot;DragContainer&quot;, Ogre::StringConverter::toString(itemCnt) + item-&gt;getName()));
+			itemhandler-&gt;setPosition(position);
+			itemhandler-&gt;setSize(UVector2(cegui_absdim(item-&gt;getSize().first*30),
+                cegui_absdim(item-&gt;getSize().second*30))); 
+			itemhandler-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(item-&gt;getItemType()));
+			itemhandler-&gt;setUserData(item);
+			itemhandler-&gt;setTooltipText(item-&gt;getName());
+			itemhandler-&gt;subscribeEvent(CEGUI::Window::EventMouseClick,
+				Event::Subscriber(&amp;InventoryWindow::handleMouseClicked,this));
+			
+			parent-&gt;addChildWindow(itemhandler);
+
+			CeGuiString tempName = item-&gt;getName();
+
+			// Erzeuge das Hintergrundfenster des Items
+			Window* itemWindow = 
+				CEGUI::WindowManager::getSingletonPtr()-&gt;createWindow(
+					&quot;RastullahLook/StaticImage&quot;, 
+					tempName + &quot;Item&quot;);
+
+			itemWindow-&gt;setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
+			itemWindow-&gt;setSize(UVector2(cegui_absdim(item-&gt;getSize().first*30),
+                cegui_absdim(item-&gt;getSize().second*30)));
+			itemWindow-&gt;setProperty(&quot;FrameEnabled&quot;, &quot;false&quot;);
+			//itemWindow-&gt;setProperty(&quot;BackgroundColour&quot;, mColorItemNormal);
+			// Gib dem Item noch ein Bild...
+			itemWindow-&gt;setProperty(&quot;Image&quot;, item-&gt;getImageName());
+            itemWindow-&gt;disable(); 
+
+			itemhandler-&gt;addChildWindow(itemWindow);
+
+			return itemhandler;
+		}
+		else
+		{
+			// Kein Item da...
+			return NULL;
+		}
+	}
+
+	bool InventoryWindow::handleMouseEnters(const EventArgs &amp;args) 
+	{
+		return true;
+	}
+
+	bool InventoryWindow::handleMouseLeaves(const EventArgs &amp;args) 
+	{
+		return true;
+	}
+
+
+	bool InventoryWindow::handleMouseClicked(const EventArgs &amp;args) 
+	{
+		// Hole das ausgew&#65533;lte Item
+		const CEGUI::MouseEventArgs&amp; mea = static_cast&lt;const MouseEventArgs&amp;&gt;(args);
+
+		// Nur, wenn es sich uim einen Itemhandler handelt, soll was geschehen...
+		if (mea.window-&gt;getUserData() != NULL)
+		{
+			Item* item = NULL;
+			item = static_cast&lt;Item*&gt;(mea.window-&gt;getUserData());
+	
+			// deaktiviere das letzte aktive Item, falls es eins gab
+			if (mActiveItemWindow){
+				mActiveItemWindow-&gt;setProperty(&quot;BackgroundColour&quot;, mColorItemNormal);
+				mActiveItemWindow-&gt;setProperty(&quot;FrameEnabled&quot;, &quot;False&quot;);
+			}
+			
+			assert(mea.window-&gt;getChildCount() &gt; 0);
+			
+			// aktiviere das angew&#65533;lte Item...
+			mActiveItemWindow = mea.window-&gt;getChildAtIdx(0);
+			mActiveItemWindow-&gt;setProperty(&quot;BackgroundColour&quot;, mColorItemSelected);
+			mActiveItemWindow-&gt;setProperty(&quot;FrameEnabled&quot;, &quot;True&quot;);
+			
+			// Schreibe Iteminfos in Description Fenster
+			if (item) 
+			{
+				mDescription-&gt;setText(item-&gt;getDescription());
+				if (item-&gt;getDescription().length() &gt; 200)
+				{
+					// Scrollbalken aktivieren
+                    mDescription-&gt;setShowVertScrollbar(true);
+				}
+				else 
+				{
+
+				}
+				renderItem(item);
+			}
+			else
+			{
+				mDescription-&gt;setText(&quot;&quot;);
+			}
+		}
+		return true;
+	}
+
+	void InventoryWindow::initRenderToTexture()
+	{
+		// Das Feld, in das gerendert werden soll (TransparentStaticImage)
+		mItemRenderImage = getWindow(&quot;InventoryWindow/ItemPicture&quot;);
+
+		SceneManager* tempManager = CoreSubsystem::getSingleton().
+				getWorld()-&gt;getSceneManager();
+	
+
+		// Setup Render To Texture for preview window
+		mRenderTexture = Root::getSingleton().getRenderSystem()-&gt;createRenderTexture( &quot;InventoryItemRttTex&quot;, 128, 128, TEX_TYPE_2D, PF_R8G8B8 );
+        {
+			
+			/*Ogre::Camera* itemRenderCam = tempManager-&gt;createCamera(&quot;InventoryItemRenderCamera&quot;);
+			
+            SceneNode* itemCamNode = 
+				tempManager-&gt;getRootSceneNode()-&gt;createChildSceneNode(Ogre::Vector3(0,-1000,0));
+			
+			itemCamNode-&gt;attachObject(itemRenderCam);
+			itemRenderCam-&gt;pitch(Ogre::Radian(90));
+
+            mRenderViewport = mRenderTexture-&gt;addViewport( itemRenderCam );
+            mRenderTexture-&gt;setAutoUpdated(false);
+			mRenderViewport-&gt;setOverlaysEnabled(false);
+            mRenderViewport-&gt;setClearEveryFrame( true );
+			//mRenderViewport-&gt;setClearEveryFrame(false);
+            mRenderViewport-&gt;setBackgroundColour( ColourValue::Black );
+			*/
+			
+			//loadCamera();
+
+            
+			
+			
+        }
+
+        // Retrieve CEGUI texture for the RTT
+		mTexture = UiSubsystem::getSingleton().getGUIRenderer()-&gt;createTexture((CEGUI::utf8*)&quot;InventoryItemRttTex&quot;);
+
+        mImageSet = CEGUI::ImagesetManager::getSingleton().createImageset(
+                    (CEGUI::utf8*)&quot;InventoryItemRttImageset&quot;, mTexture);
+
+        mImageSet-&gt;defineImage((CEGUI::utf8*)&quot;InventoryItemRttImage&quot;, 
+                CEGUI::Point(0.0f, 0.0f),
+                CEGUI::Size(mTexture-&gt;getWidth(), mTexture-&gt;getHeight()),
+                CEGUI::Point(0.0f,0.0f));
+	}
+
+	void InventoryWindow::renderItem(Item* item)
+	{
+		SceneManager* tempManager = CoreSubsystem::getSingleton().
+					getWorld()-&gt;getSceneManager();
+
+		// Fr einen Aufh&#65533;geknoten Sorgen
+		if (mInventoryItemNode == NULL){
+			mInventoryItemNode = tempManager-&gt;getRootSceneNode()-&gt;createChildSceneNode(Ogre::Vector3(0,-999999.6,-0.2));
+			//mInventoryItemNode-&gt;setPosition(0,-100,-0.2);
+		}
+		
+		if (mRenderItemEntity) {
+			// Vom Knoten entfernen
+			mInventoryItemNode-&gt;detachAllObjects();
+			// alte Entity entfernen
+			tempManager-&gt;destroyEntity(mRenderItemEntity);
+			mRenderItemEntity = NULL;
+		}
+		if (item-&gt;getActor())
+		{
+			// Camera update erforderlich, da Mapchange da was kaputt gemacht haben k&#65533;nte
+			unloadCamera();
+			loadCamera();
+
+			// Item setzen und Schnappschuss machen
+			mRenderItemEntity = tempManager-&gt;createEntity(&quot;inventoryRenderedItem&quot;,
+                (static_cast&lt;MeshObject*&gt;(item-&gt;getActor()-&gt;getControlledObject()))-&gt;getMeshName());
+			mInventoryItemNode-&gt;attachObject(mRenderItemEntity);
+		
+			// Das Item hat einen Actor
+			//mItemActor = ActorManager::getSingleton().createMeshActor(&quot;inventoryRenderedItem&quot;,
+            //  (static_cast&lt;MeshObject*&gt;(item-&gt;getActor()-&gt;getControlledObject()))-&gt;getMeshName());
+			//mItemActor-&gt;placeIntoScene(Ogre::Vector3(0,-101055.3,-0.2));
+            mItemRenderImage-&gt;setSize(CeGuiHelper::asAbsolute(CEGUI::Vector2(128, 128)));
+			mItemRenderImage-&gt;setProperty(&quot;Image&quot;,
+                &quot;set:&quot; + mImageSet-&gt;getName() + &quot; image:InventoryItemRttImage&quot;);
+			mRenderTexture-&gt;update();
+
+		}
+        else if (item-&gt;getImageName() != &quot;&quot;)
+        {
+            mItemRenderImage-&gt;setProperty(&quot;Image&quot;,
+                &quot;set:ModelThumbnails image:&quot; + item-&gt;getImageName());
+
+			float div = item-&gt;getSize().first / float(item-&gt;getSize().second);
+
+			if (div &lt; 1)
+			{
+				//schmales Item
+                mItemRenderImage-&gt;setSize(CeGuiHelper::asAbsolute(CEGUI::Vector2(128*div, 128)));
+			}
+			else
+			{
+				// breites oder quadratisches Item
+                mItemRenderImage-&gt;setSize(CeGuiHelper::asAbsolute(CEGUI::Vector2(128, 128/div)));
+			}
+		}
+	}
+
+
+	void InventoryWindow::loadCamera()
+	{
+		mCameraActor = ActorManager::getSingleton().createCameraActor(&quot;InventoryItemRttCam&quot;);
+		mCameraActor-&gt;placeIntoScene(Ogre::Vector3(0,-999999,0));
+		mCameraActor-&gt;pitch(-90);
+		mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
+
+		mRenderTexture-&gt;setAutoUpdated(false);
+        mRenderViewport = mRenderTexture-&gt;addViewport(
+            (static_cast&lt;CameraObject*&gt;(mCameraActor-&gt;getControlledObject()))-&gt;getCamera());
+        mRenderViewport-&gt;setOverlaysEnabled(false);
+        mRenderViewport-&gt;setClearEveryFrame(true);
+        mRenderViewport-&gt;setBackgroundColour( ColourValue::Black );
+	}
+
+	void InventoryWindow::unloadCamera()
+	{
+		// wenn loadCamera schon mal geladen wurde, soll die Camera zerst&#65533;t werden
+		if (mRenderViewport)
+		{
+			mRenderTexture-&gt;removeViewport(0);
+			ActorManager::getSingleton().destroyActor(mCameraActor);
+		}
+	}
+
+	/*!
+	*		&#65533;erprft, ob das Item von dem Slot akzeptiert wird
+	*/
+	bool InventoryWindow::checkTypeAccepted(CEGUI::Window* window, CEGUI::DragContainer* draggedItem)
+	{
+		if (window-&gt;getUserString(&quot;ItemType&quot;).compare(draggedItem-&gt;getUserString(&quot;ItemType&quot;)) == 0)
+		{
+			return true;
+		} 
+		else 
+		{
+			return false;
+		}
+	}
+
+	/**
+	* Berechnet aus relativen und Absoluten Mousekoordinaten die neue Position im Container
+	*/
+	std::pair&lt;int,int&gt; InventoryWindow::calculateNewPosition(const DragDropEventArgs&amp; ddea)
+	{
+		// Errechnung der Koordinaten, in welchem K&#65533;tchen denn nun gedroppt wird
+		Point absMouse = MouseCursor::getSingleton().getPosition();
+        Point scrnPt = ddea.window-&gt;getPixelRect().getPosition();
+		Point relMouse = absMouse - ddea.dragDropItem-&gt;getPixelRect().getPosition();
+
+		//Bug in CeGUI (1. rel Mouse koordinate spinnt
+		if (relMouse.d_x &lt; 0) {
+			relMouse.d_x = 15;
+		}
+
+		LOG_MESSAGE(
+			&quot;InventoryWindow&quot;,
+			Ogre::String(&quot;relMouse: Point x:&quot;)
+			+ StringConverter::toString(relMouse.d_x)
+			+ &quot;, Point y:&quot;
+			+ StringConverter::toString(relMouse.d_y));
+
+		Point pointInBackpack = absMouse-scrnPt;
+		pointInBackpack -= relMouse;
+
+		// Position des n&#65533;hsten K&#65533;tchens bestimmen		
+		if (pointInBackpack.d_x &lt; 0)
+        {
+			pointInBackpack.d_x = 0;
+		}
+		if (pointInBackpack.d_y &lt; 0)
+        {
+			pointInBackpack.d_y = 0;
+		}
+
+		if (pointInBackpack.d_x &gt; 16)
+        {
+			pointInBackpack.d_x = (int(pointInBackpack.d_x) + 14) -
+                ((int(pointInBackpack.d_x) + 14) % 30);
+		}
+        else
+        {
+			pointInBackpack.d_x = 0;
+		}
+
+		if (pointInBackpack.d_y &gt; 16)
+        {
+			pointInBackpack.d_y = (int(pointInBackpack.d_y) + 14 ) -
+                ((int(pointInBackpack.d_y) + 14) % 30);
+		}
+        else
+        {
+			pointInBackpack.d_y = 0;
+		}
+
+		int xKaestchen = (int) (pointInBackpack.d_x / 30);
+		int yKaestchen = (int) (pointInBackpack.d_y / 30);
+
+		std::pair&lt;int,int&gt; result = std::make_pair&lt;int,int&gt;(xKaestchen, yKaestchen);
+		return result;
+	}
+
+
+	/*!
+	* Behandlung fr Mouse-over mit Item in der Maus
+	* &#65533;erprft, ob das Item passt, und f&#65533;bt dementsprechend den Beh&#65533;ter ein
+	*/
+	bool InventoryWindow::handleDragEnter(const CEGUI::EventArgs&amp; args)
+	{
+		// Event zu einem DragDropEvent machen
+		const DragDropEventArgs&amp; ddea = static_cast&lt;const DragDropEventArgs&amp;&gt;(args);
+		
+		if (ddea.window-&gt;getUserData()){
+			// Es handelt sich um einen Container
+			Item* container = static_cast&lt;Item*&gt;(ddea.window-&gt;getUserData());
+			if (container == getGroundItem())
+			{
+				// Boden (nimmt alles)
+				ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorAccept);
+				return true;
+			} 
+			else if (container &amp;&amp; container-&gt;getItemType() == Item::ITEMTYPE_BACKPACK)
+			{
+				// Ein Container kann keinen Rucksack aufnehmen
+				if (!(ddea.dragDropItem-&gt;getUserString(&quot;ItemType&quot;).compare(Item::getItemTypeString(Item::ITEMTYPE_BACKPACK))))
+				{
+					ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorReject);
+					return false;
+				}
+				else 
+				{
+					ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorAccept);
+					return true;
+				}
+			}
+			else {
+				// Beliebiger anderer Container am K&#65533;per
+				// TODO: Beschr&#65533;kung auf Itemtypen... 
+
+				ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorAccept);
+				return true;
+			}
+		}
+		else if (checkTypeAccepted(ddea.window, ddea.dragDropItem))
+		{
+			ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorAccept);
+			return true;
+		}
+		else
+		{
+			ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorReject);
+			return false;
+		}
+	}
+
+	bool InventoryWindow::handleDragLeave(const CEGUI::EventArgs&amp; args)
+	{
+		// Event zu einem DragDropEvent machen
+		const DragDropEventArgs&amp; ddea = static_cast&lt;const DragDropEventArgs&amp;&gt;(args);
+		ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorNormal);
+		return true;
+	}
+
+	bool InventoryWindow::handleDragDropped(const CEGUI::EventArgs&amp; args)
+	{
+		// Event zu einem DragDropEvent machen
+		const DragDropEventArgs&amp; ddea = static_cast&lt;const DragDropEventArgs&amp;&gt;(args);
+		// Farbe zurcksetzen
+		ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorNormal);
+
+
+		if (ddea.window-&gt;getUserData()){
+			// Es handelt sich um einen Container
+			Item* container = static_cast&lt;Item*&gt;(ddea.window-&gt;getUserData());
+			if (container == mGroundItem)
+			{
+				// Boden (nimmt alles)
+			} 
+			else if (container-&gt;getItemType() == Item::ITEMTYPE_BACKPACK)
+			{
+				// Rucksack (nimmt alles au&#65533;r dem Rucksack selbst)
+				if (!(ddea.dragDropItem-&gt;getUserString(&quot;ItemType&quot;).compare(Item::getItemTypeString(Item::ITEMTYPE_BACKPACK))))
+				{
+					return false;
+				}
+			}
+			else {
+				// Beliebiger anderer Container am K&#65533;per
+				// TODO: Beschr&#65533;kung auf Itemtypen... 
+			}
+
+			std::pair&lt;int,int&gt; newPos = calculateNewPosition(ddea);
+
+			if (isFreeInContainer(
+				static_cast&lt;Item*&gt;(ddea.dragDropItem-&gt;getUserData()),
+				newPos, static_cast&lt;Container*&gt;(ddea.window-&gt;getUserData())))
+			{
+				ddea.window-&gt;addChildWindow(ddea.dragDropItem);
+
+				mPosDraggedTo=CEGUI::Point(newPos.first*30,newPos.second*30);
+				mDroppedItem = ddea.dragDropItem;
+				mContainerDraggedTo = ddea.window;
+
+				updateInventory();
+				return true;
+			}
+			else 
+			{
+				return false;
+			}
+
+
+		} else {
+			// Es handelt sich um einen Slot am K&#65533;per
+			if (checkTypeAccepted(ddea.window, ddea.dragDropItem)){
+				// Nur wenn das Item in den Slot passt, soll es auch dort gedroppt werden k&#65533;nen
+
+				if (ddea.window-&gt;getChildCount() &gt; 0)
+				{
+					// Slot hat schon einen anderen Gegenstand getragen
+					mOldItemInSlot = static_cast&lt;CEGUI::DragContainer*&gt;(ddea.window-&gt;getChildAtIdx(0));
+					ddea.window-&gt;removeChildWindow(mOldItemInSlot);
+				}
+				else
+				{
+					mOldItemInSlot = NULL;
+				}
+
+				ddea.window-&gt;addChildWindow(ddea.dragDropItem);
+
+				// Waffe und Schild sollen mittig positioniert werden
+				if ((!ddea.window-&gt;getUserString(&quot;ItemType&quot;).compare(Item::getItemTypeString(Item::ITEMTYPE_WEAPON)) ||
+					(!ddea.window-&gt;getUserString(&quot;ItemType&quot;).compare(Item::getItemTypeString(Item::ITEMTYPE_SHIELD)))) &amp;&amp;
+					(ddea.dragDropItem-&gt;getUserData()))
+				{
+					Item* item = static_cast&lt;Item*&gt;(ddea.dragDropItem-&gt;getUserData());
+					mPosDraggedTo= CEGUI::Point(30-(item-&gt;getSize().first * 15),75-(item-&gt;getSize().second *15));
+				}
+				// Rest kommt in die linke obere Ecke (weil ausfllend)
+				else {
+					mPosDraggedTo=CEGUI::Point(0.0,0.0);
+				}
+				mDroppedItem = ddea.dragDropItem;
+				mContainerDraggedTo = ddea.window;
+
+				updateInventory();
+				return true;
+			} else {
+				// Item passt nicht zum Slot
+				return false;
+			}
+		}
+	}
+}

Modified: rl/trunk/engine/rules/include/Creature.h
===================================================================
--- rl/trunk/engine/rules/include/Creature.h	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/rules/include/Creature.h	2007-03-30 19:20:10 UTC (rev 3212)
@@ -18,9 +18,11 @@
 
 #include &quot;RulesPrerequisites.h&quot;
 
-#include &quot;GameObject.h&quot;
+#include &quot;Date.h&quot;
 #include &quot;Effect.h&quot;
+#include &quot;Effect.h&quot;
 #include &quot;Eigenschaft.h&quot;
+#include &quot;GameObject.h&quot;
 #include &quot;ZauberStateSet.h&quot;
 #include &quot;SonderfertigkeitenStateSet.h&quot;
 
@@ -107,7 +109,8 @@
 
             static const Ogre::String CLASS_NAME;
             static const Ogre::String PROPERTY_BEHAVIOURS;
-
+        static const Ogre::String PROPERTY_INVENTORY_WINDOW_TYPE;
+        
             Creature(unsigned int id);
 
             /// Der Standarddestruktor.
@@ -501,8 +504,8 @@
              **/
             Inventory* getInventory() const;
 
+        const Ogre::String&amp; getInventoryWindowType() const;
 
-
 ///////////////////////////////////////////////////////////////////////////////
 // Aktionen
             /**
@@ -857,9 +860,9 @@
             SonderfertigkeitMap mSonderfertigkeiten;
             WertMap mWerte;
             Ap mAp;
-
             /// Zeigt auf das Inventar der Kreatur.
             Inventory* mInventory;
+        Ogre::String mInventoryWindowType;
 
             Property mBehaviours;
 

Modified: rl/trunk/engine/rules/include/Inventory.h
===================================================================
--- rl/trunk/engine/rules/include/Inventory.h	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/rules/include/Inventory.h	2007-03-30 19:20:10 UTC (rev 3212)
@@ -41,6 +41,11 @@
 	**/
 	typedef std::list&lt;Item*&gt; ItemList;
 
+    /**
+     * @brief A map of slot names to slots
+     */
+    typedef std::map&lt;CeGuiString, Slot*&gt; SlotMap;
+
 	Inventory(Creature* owner);
 	virtual ~Inventory();
 
@@ -79,10 +84,9 @@
 
     Item* getItem(const CeGuiString&amp; slotName) const;
     void addSlot(const CeGuiString&amp; name, const Ogre::String&amp; bone, int itemMask);
+    const SlotMap&amp; getAllSlots() const;
 
 private:
-    typedef std::map&lt;CeGuiString, Slot*&gt; SlotMap;
-
 	bool mValuesUpToDate;
 	int mCurrentWeight;
 	int mCurrentBeByWeight;

Modified: rl/trunk/engine/rules/include/Item.h
===================================================================
--- rl/trunk/engine/rules/include/Item.h	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/rules/include/Item.h	2007-03-30 19:20:10 UTC (rev 3212)
@@ -61,9 +61,7 @@
 		Item(unsigned int id);
         virtual ~Item(void);
 
-		const CeGuiString getDescription() const;
-
-        void setWeight(Ogre::Real weight);
+	    void setWeight(Ogre::Real weight);
         Ogre::Real getWeight() const;
 
 		void setItemType(ItemType itemType);
@@ -79,7 +77,7 @@
 
 		/**
 		 * @return ob es sich um ein Item handelt,
-		 * in dem andere gespeichert werden k&#65533;nen
+		 * in dem andere gespeichert werden koennen
 		 */
         virtual bool isContainer() const;
 		

Modified: rl/trunk/engine/rules/src/Container.cpp
===================================================================
--- rl/trunk/engine/rules/src/Container.cpp	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/rules/src/Container.cpp	2007-03-30 19:20:10 UTC (rev 3212)
@@ -255,7 +255,7 @@
         }
         else if (key == Container::PROPERTY_VOLUME)
         {
-            return Property(mVolume);
+            return Property(make_pair((int)mVolume.first, (int)mVolume.second));
         }
         else
         {
@@ -267,7 +267,7 @@
     {
         PropertySet* ps = Item::getAllProperties();
         ps-&gt;setProperty(Container::PROPERTY_CAPACITY, Property(mCapacity));
-        ps-&gt;setProperty(Container::PROPERTY_VOLUME, Property(mVolume));
+        ps-&gt;setProperty(Container::PROPERTY_VOLUME, Property(make_pair((int)mVolume.first, (int)mVolume.second)));
 
         return ps;
     }

Modified: rl/trunk/engine/rules/src/Creature.cpp
===================================================================
--- rl/trunk/engine/rules/src/Creature.cpp	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/rules/src/Creature.cpp	2007-03-30 19:20:10 UTC (rev 3212)
@@ -39,6 +39,8 @@
     const Ogre::String Creature::CLASS_NAME = &quot;Creature&quot;;
     const Ogre::String Creature::PROPERTY_BEHAVIOURS = &quot;behaviours&quot;;
 
+    const Ogre::String Creature::PROPERTY_INVENTORY_WINDOW_TYPE = &quot;inventorywindowtype&quot;; 
+
     Creature::Creature(unsigned int id)
         : GameObject(id), 
 		mCurrentLe(0),
@@ -82,6 +84,8 @@
 		mEigenschaften[E_KONSTITUTION] = 0;
 		mEigenschaften[E_KOERPERKRAFT] = 0;
 
+        mEffectManager = new EffectManager();
+
 		mInventory = new Inventory(this);
     }
 
@@ -704,6 +708,11 @@
 	{
 		return mInventory;
 	}
+
+    const Ogre::String&amp; Creature::getInventoryWindowType() const
+    {
+        return mInventoryWindowType;
+    }
 	
 	int Creature::doAttacke(const CeGuiString kampftechnikName, int modifier)
 	{
@@ -952,6 +961,10 @@
         {
             mBehaviours = value;
         }
+        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
+        {
+            mInventoryWindowType = value.toString().c_str();
+        }
         else
         {
             GameObject::setProperty(key, value);
@@ -964,10 +977,10 @@
         {
             return mBehaviours;
         }
-        //else if (key == Item::PROPERTY_SIZE)
-        //{
-        //    return Property(mSize);
-        //}
+        else if (key == Creature::PROPERTY_INVENTORY_WINDOW_TYPE)
+        {
+            return Property(mInventoryWindowType);
+        }
         else
         {
             return GameObject::getProperty(key);
@@ -978,6 +991,7 @@
     {
         PropertySet* ps = GameObject::getAllProperties();
         ps-&gt;setProperty(Creature::PROPERTY_BEHAVIOURS, mBehaviours);
+        ps-&gt;setProperty(Creature::PROPERTY_INVENTORY_WINDOW_TYPE, Property(mInventoryWindowType));
 
         return ps;
     }
@@ -1489,4 +1503,5 @@
     }
 
 
+
 }

Modified: rl/trunk/engine/rules/src/Inventory.cpp
===================================================================
--- rl/trunk/engine/rules/src/Inventory.cpp	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/rules/src/Inventory.cpp	2007-03-30 19:20:10 UTC (rev 3212)
@@ -196,4 +196,8 @@
         mSlots[name] = new Slot(mOwner, name, bone, itemMask);
     }
 
+    const Inventory::SlotMap&amp; Inventory::getAllSlots() const
+    {
+        return mSlots;
+    }
 }

Modified: rl/trunk/engine/rules/src/Item.cpp
===================================================================
--- rl/trunk/engine/rules/src/Item.cpp	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/rules/src/Item.cpp	2007-03-30 19:20:10 UTC (rev 3212)
@@ -124,24 +124,23 @@
 		return CeGuiString(&quot;undefined&quot;);
 	}
 
-	const CeGuiString Item::getDescription() const
-	{
-		CeGuiString desc = mName + &quot;\r\n\r\n&quot; + 
-			getFormattedText(mDescription)+
-			&quot;\r\n\r\n&quot;+
-			&quot;Gewicht: &quot;;
-		if (mWeight &gt;= 40)
-		{
-			desc += Ogre::StringConverter::toString(mWeight / 40)+ &quot; Stein&quot;;
-		}
-		else
-		{
-			desc += Ogre::StringConverter::toString(mWeight)+ &quot; Unzen&quot;;
-		}
-		return desc;
+	//const CeGuiString Item::getDescription() const
+	//{
+	//	CeGuiString desc = mName + &quot;\r\n\r\n&quot; + 
+	//		getFormattedText(mDescription)+
+	//		&quot;\r\n\r\n&quot;+
+	//		&quot;Gewicht: &quot;;
+	//	if (mWeight &gt;= 40)
+	//	{
+	//		desc += Ogre::StringConverter::toString(mWeight / 40)+ &quot; Stein&quot;;
+	//	}
+	//	else
+	//	{
+	//		desc += Ogre::StringConverter::toString(mWeight)+ &quot; Unzen&quot;;
+	//	}
+	//	return desc;
+	//}
 
-	}
-
     void Item::setWeight(Ogre::Real weight)
     {
         mWeight = weight;

Modified: rl/trunk/engine/ui/include/InventoryWindow.h
===================================================================
--- rl/trunk/engine/ui/include/InventoryWindow.h	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/ui/include/InventoryWindow.h	2007-03-30 19:20:10 UTC (rev 3212)
@@ -24,252 +24,34 @@
 
 namespace rl {
 
-	class Creature;
-    class Item;
+    class Inventory;
 
-	class _RlUiExport InventoryArrangeTask : public GameTask
-	{
-	public:
-		InventoryArrangeTask();
-		~InventoryArrangeTask();
-		
-		void run(Ogre::Real elapsedTime);
+	//class _RlUiExport InventoryArrangeTask : public GameTask
+	//{
+	//public:
+	//	InventoryArrangeTask();
+	//	~InventoryArrangeTask();
+	//	
+	//	void run(Ogre::Real elapsedTime);
 
-        virtual const Ogre::String&amp; getName() const;
-	};
+ //       virtual const Ogre::String&amp; getName() const;
+	//};
 
 	class _RlUiExport InventoryWindow : public AbstractWindow
 	{
 	public:
-		InventoryWindow();
+		InventoryWindow(const Ogre::String&amp; inventoryWindow, Inventory* inventory);
 		~InventoryWindow();
 
-		// Flag fr den ArrangeTask - FIXME nach private umziehen, wenn 
-		CEGUI::DragContainer* mDroppedItem;
+    private:
+        Inventory* mInventory;
+        std::map&lt;CeGuiString, CEGUI::Window*&gt; mSlotWindows;
 
-		/**
-		* Gibt dem Fenster das anzuzeigende Inventar
-		*/
-		void setInventory(Inventory* inventory);
+        CEGUI::Window* mContainerTabs;
 
-		/**
-		* Methode fr das OnMouseOver Event
-		*/
-		bool handleMouseEnters(const CEGUI::EventArgs &amp;args);
-		
-		/**
-		* Methode fr das OnMouseLeaves Event
-		*/
-		bool handleMouseLeaves(const CEGUI::EventArgs &amp;args);
-
-		/**
-		* Methode fr das OnMouseClick Event
-		*/
-		bool handleMouseClicked(const CEGUI::EventArgs &amp;args);
-
-		/**
-		* 
-		*/
-		void update();
-
-		/**
-		* &#65533;ergibt &#65533;derungen ans Inventar
-		*/
-		void updateInventory();
-
-		/**
-		* Passt die Position eines gedroppten Items an, da CEGUI Bug, braucht man 
-		* dafr ne externe Methode
-		*/
-		void updateItemPosition();
-
-		// FIXME, wenn BUG im CEGUI behoben ist: entfernen
-
-		/**
-		* Schaut nach, ob das Item an der Position gedroppt werden kann.
-		*/
-		bool isFreeInContainer(Item* item, std::pair&lt;int,int&gt; kaestechenPos, Container* container);
-
-
-		Item* getGroundItem();
-
-	private:
-		Inventory* mInventory;
-
-		// Farbschema fr die Fenster und Itemhintergrnde
-		const CeGuiString mColorAccept;
-		const CeGuiString mColorReject;
-		const CeGuiString mColorNormal;
-		const CeGuiString mColorItemNormal;
-		const CeGuiString mColorItemSelected;
-
-		// TODO : Ersetze durch etwas dynamisches
-		Item* mGroundItem;
-
-		// Der Knoten an dem das zu redernde Item angebracht wird;
-		Ogre::SceneNode* mInventoryItemNode;
-		// Entity des jeweils zu rendernden Items
-		Ogre::Entity* mRenderItemEntity;
-		// 128*128 Textur fr das Item-view Fenster
-		Ogre::RenderTexture* mRenderTexture;
-		// Viewport des RenderToTexture Features
-		Ogre::Viewport* mRenderViewport;
-		// Die Camera, die das Item filmt
-		Actor* mCameraActor;
-
-		CEGUI::Texture* mTexture;
-		CEGUI::Imageset* mImageSet;
-
-        InventoryArrangeTask* mInventoryArrangeTask;
-
-		// Das Item-Renderfenster
-		CEGUI::Window* mItemRenderImage;
-
-
-		// Das Rstungs- und Behinderungswert Fenster
-		CEGUI::Window* mArmorValueWindow;
-		CEGUI::Window* mArmorValue;
-		CEGUI::Window* mHandicapValue;
-
-		// Das Gewichtsfenster
-		CEGUI::Window* mWeightWindow;
-		CEGUI::Window* mTotalWeight;
-		
-
-		// Das Item-Beschreibungsfenster
-		CEGUI::ScrollablePane* mDescription;
-
-		// Das jeweils aktive Fenster, das im Beschreibungsfenster angew&#65533;lt ist
-		CEGUI::Window* mActiveItemWindow;
-
-		// Das Fenster, in das der Rucksackcontainer soll
-		CEGUI::TabControl* mContainerTabs;
-
-		// Die Containerslots (besonders, da alle Arten von Items akzeptiert)
-		std::list&lt;CEGUI::Window*&gt; mContainerContents;
-
-		std::list&lt;CEGUI::Window*&gt; mContainers;
-
-		CEGUI::Window* mGroundTab;
-		CEGUI::Window* mGroundContainer;
-
-		const std::pair&lt;int,int&gt; mGroundDimension;
-
-		// Alle verschiedenen Inventoryslots
-		CEGUI::Window* mRingLeft;
-		CEGUI::Window* mRingRight;
-		CEGUI::Window* mHandLeft;
-		CEGUI::Window* mHandRight;
-		CEGUI::Window* mGloves;
-		CEGUI::Window* mBraceletLeft;
-		CEGUI::Window* mBraceletRight;
-		CEGUI::Window* mArmor;
-		CEGUI::Window* mCape;
-		CEGUI::Window* mBracers;
-		CEGUI::Window* mBackpack;
-		CEGUI::Window* mBelt;
-		CEGUI::Window* mNecklace;
-		CEGUI::Window* mHelmet;
-		CEGUI::Window* mTrousers;
-		CEGUI::Window* mShinbone;
-		CEGUI::Window* mBoots;
-
-		CEGUI::Point mPosDraggedTo;
-		CEGUI::Window* mContainerDraggedTo;
-		CEGUI::DragContainer* mOldItemInSlot;
-        
-        CEGUI::DragContainer* createItem(Item* item, CEGUI::Window* parent, CEGUI::UVector2 position = CEGUI::UVector2(cegui_reldim(0.0f), cegui_reldim(0.0f)));
-
-		/**
-		* Schliesst das Fenster bei Klick auf X
-		*/
-		bool handleClose();
-
-		void initRenderToTexture();
-
-		/**
-		* L&#65533;t die Rtt-Camera
-		*/
-		void loadCamera();
-		void unloadCamera();
-
-		/**
-		* Rendert das Item in das Vorschaufenster im Inventar
-		*/
-		void renderItem(Item* item);
-
-		/**
-		* Initiiert die Slots des Inventars
-		*/
-		void initSlots();
-
-		/**
-		* Fllt die Slots im InventarFenster mit den Items aus dem Inventar
-		*/
-		void fillSlots();
-
-		/**
-		* Erzeugt ein Tab fr den Container, und befuellt ihn nach Inhalt des container - Items
-		*/
-		void createAndFillContainer(Container* container);
-
-		/**
-		* entfernt ein ContainerTab mitsamt Inhalt aus dem Inventar
-		*/
-		void removeContainerAndContent(Container* container);
-
-		/**
-		* Entleert die Slots im InventarFenster wieder
-		*/
-		void emptySlots();
-
-
-		void refreshTabs();
-
-		/**
-		* Sucht unter den Containern dasjenige, das zum gesuchten Container geh&#65533;t
-		*/
-		CEGUI::Window* findContainer(Container* container);
-
-		/**
-		*
-		* Entfernt alle Unterfenster
-		*/
-		void emptySlot(CEGUI::Window* slot);
-		/** 
-		* Gibt dem Slot die F&#65533;igkeit Dragcontainer zu akzeptieren
-		*/
-		void addDropListener(CEGUI::Window* slot);
-
-		/*!
-		* fgt dem Inventar den Container fr den Rucksack zu,
-		* gibt ihm die n&#65533;ige Funktionalit&#65533; fr drag&amp;drop
-		*/
-		void initBackpack(std::pair&lt;int,int&gt; dim);
-
-
-		/**
-		* erzeugt fr alle Items im Inventar, die Containerfunktionaltiaet haben, ein Containertab
-		* im Inventar
-		*/
-		void createContainerWindows();
-
-		/**
-		* &#65533;erprft, ob das gedroppte Item vom Slot akzeptiert wird oder nicht
-		* @return true: Item wird akzeptiert
-		*         false: Item wird nicht akzeptiert
-		*/ 
-		bool checkTypeAccepted(CEGUI::Window* window, CEGUI::DragContainer* draggedItem);
-
-
-		/**
-		* Errechnet die K&#65533;tchenposition, an der das Item im Container gedroppt wurde
-		*/
-		std::pair&lt;int,int&gt; calculateNewPosition(const CEGUI::DragDropEventArgs&amp; ddea);
-
-		bool handleDragEnter(const CEGUI::EventArgs&amp; args);
-		bool handleDragLeave(const CEGUI::EventArgs&amp; args);
-		bool handleDragDropped(const CEGUI::EventArgs&amp; args);
-	};
+        void createSlotWindows(Inventory* inventory);
+        void initInventoryWindow(Inventory* inventory);
+    };
 }
-#endif
+
+#endif //__InventoryWindow_H__

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2007-03-30 19:20:10 UTC (rev 3212)
@@ -24,1278 +24,99 @@
 #include &lt;elements/CEGUIFrameWindow.h&gt;
 
 
-#include &quot;Actor.h&quot;
-#include &quot;ActorManager.h&quot;
-#include &quot;CameraObject.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;GameLoop.h&quot;
-#include &quot;Inventory.h&quot;
-#include &quot;MeshObject.h&quot;
-#include &quot;PhysicalThing.h&quot;
-#include &quot;RulesSubsystem.h&quot;
-#include &quot;UiSubsystem.h&quot;
-#include &quot;WindowFactory.h&quot;
-#include &quot;World.h&quot;
-#include &quot;CeGuiHelper.h&quot;
-
-#include &lt;CEGUIPropertyHelper.h&gt;
-#include &lt;OgreCEGUIRenderer.h&gt;
-
 using namespace CEGUI;
-using namespace Ogre;
 using namespace std;
 
 namespace rl {
 
-	// @FIXME Wenn CeGUI Bug beseitigt hat:
-	InventoryArrangeTask::InventoryArrangeTask() : GameTask()
-	{
-	}
+    InventoryWindow::InventoryWindow(const Ogre::String&amp; inventoryWindow, Inventory* inventory)
+        : AbstractWindow(inventoryWindow, AbstractWindow::WND_MOUSE_INPUT)
+    {
+        mInventory = inventory;
 
-	InventoryArrangeTask::~InventoryArrangeTask()
-	{
-	}
+        mContainerTabs = getTabControl(&quot;InventoryWindow/Tabs&quot;);
+        //mSquareSize = ...;
 
-	void InventoryArrangeTask::run(Ogre::Real elapsedTime)
-	{
-		static InventoryWindow* invWin = WindowFactory::getSingletonPtr()-&gt;getInventoryWindow();
-		if (invWin-&gt;mDroppedItem)
-		{
-			LOG_MESSAGE(&quot;InventoryWindow&quot;, &quot;Item placed&quot;);
-			invWin-&gt;updateItemPosition();
-		}
-	}
+        createSlotWindows(inventory);
+        initInventoryWindow(inventory);
+    }
 
-    const Ogre::String&amp; InventoryArrangeTask::getName() const
+    InventoryWindow::~InventoryWindow()
     {
-        static Ogre::String NAME = &quot;InventoryArrangeTask&quot;;
-
-        return NAME;
     }
 
+    void InventoryWindow::createSlotWindows(Inventory* inventory)
+    {
+        std::map&lt;CeGuiString, Window*&gt; slotsInWindowDefinition;
 
-	// ***************************************************************
-	// ***************** Konstruktor *********************************
-	// ***************************************************************
-	InventoryWindow::InventoryWindow()
-		: AbstractWindow(&quot;inventorywindow.xml&quot;, WND_MOUSE_INPUT),
-		mDescription(NULL),
-		mRenderItemEntity(NULL),
-		mRenderTexture(NULL),
-		mRenderViewport(NULL),
-		mItemRenderImage(NULL),
-		mCameraActor(NULL),
-		mInventoryItemNode(NULL),
-		mTexture(NULL),
-		mImageSet(NULL),
-		mActiveItemWindow(NULL),
-		mArmorValueWindow(NULL),
-		mArmorValue(NULL),
-		mHandicapValue(NULL),
-		mWeightWindow(NULL),
-		mTotalWeight(NULL),
-		mPosDraggedTo(),
-		mContainerDraggedTo(NULL),
-		mDroppedItem(NULL),
-		mOldItemInSlot(NULL),
-		mContainerTabs(NULL),
-		mContainerContents(NULL),
-		mGroundTab(NULL),
-		mGroundItem(NULL),
-		mGroundContainer(NULL),
-		mColorAccept(&quot;FF22FF22&quot;),
-		mColorReject(&quot;FFFF2222&quot;),
-		mColorNormal(&quot;FFFFFFFF&quot;),
-		mColorItemNormal(&quot;FF999955&quot;),
-		mColorItemSelected(&quot;FFDDDD99&quot;),
-		mRingLeft(NULL),
-		mRingRight(NULL),
-		mHandLeft(NULL),
-		mHandRight(NULL),
-		mGloves(NULL),
-		mBraceletLeft(NULL),
-		mBraceletRight(NULL),
-		mArmor(NULL),
-		mCape(NULL),
-		mBracers(NULL),
-		mBackpack(NULL),
-		mBelt(NULL),
-		mNecklace(NULL),
-		mHelmet(NULL),
-		mTrousers(NULL),
-		mShinbone(NULL),
-		mBoots(NULL),
-        mInventoryArrangeTask(),
-		mGroundDimension(make_pair&lt;int,int&gt;(12,15))
-	{
-		initSlots();
-		initRenderToTexture();
+        Window* containers = getWindow(&quot;InventoryWindow/Slots&quot;);
 
-		mWindow-&gt;subscribeEvent(FrameWindow::EventCloseClicked,
-			boost::bind(&amp;InventoryWindow::handleClose, this));
-
-        mInventoryArrangeTask = new InventoryArrangeTask();
-        GameLoop::getSingletonPtr()-&gt;addTask(mInventoryArrangeTask, GameLoop::TG_GRAPHICS);
-	}
-	
-	InventoryWindow::~InventoryWindow()
-	{
-		/*if(mBackpackContent){
-			mBackpackContent-&gt;destroy();
-		}*/
-        delete mInventoryArrangeTask;
-//        delete mGroundItem;
-	}
-
-
-	/** Methoden */
-
-	void InventoryWindow::setInventory(Inventory* inventory)
-	{
-		if (inventory != NULL &amp;&amp; mInventory != inventory){
-			// Entleere Slots zur Sicherheit (falls anderes Inventar zuvor gezeigt wurde)
-			emptySlots();
-			// Speichere das neue Inventar
-			mInventory = inventory;
-			// Fuelle das Fenster entsprechend dem neuen Inventar, das angezeigt werden soll
-			fillSlots();
-			update();
-		}
-	}
-
-	bool InventoryWindow::handleClose()
-	{
-		if (isVisible())
-		{
-			setVisible(false);
-		}
-		return true;
-	}
-
-	void InventoryWindow::update()
-	{
-		// Aktualisiere Werte
-
-		// Rstung
-		mArmorValue-&gt;setText(Ogre::StringConverter::toString(mInventory-&gt;getOverallRs()));
-
-		// Behinderung
-		pair&lt;int,int&gt; behinderung = mInventory-&gt;getOverallBe();
-		mHandicapValue-&gt;setText(Ogre::StringConverter::toString(behinderung.first+behinderung.second));
-		if (behinderung.second &gt; 0)
-		{
-			mArmorValueWindow-&gt;setTooltipText(&quot;Rstung / Behinderung\r\n           / +&quot;+Ogre::StringConverter::toString(behinderung.second)+&quot; berladen&quot;);
-		} 
-		else
-		{
-			mArmorValueWindow-&gt;setTooltipText(&quot;Rstung / Behinderung&quot;);
-		}
-
-		// Gewicht in Unzen
-		int weight = mInventory-&gt;getOverallWeight() / 40;
-		// TODO: runden
-		mTotalWeight-&gt;setText(Ogre::StringConverter::toString(weight));
-	}
-
-	void InventoryWindow::updateItemPosition(){
-		
-		// Positionieren
-        mDroppedItem-&gt;setPosition(CeGuiHelper::asAbsolute(mPosDraggedTo));
-		mDroppedItem = NULL;
-
-		// Loggen
-		LOG_MESSAGE(
-			&quot;InventoryWindow&quot;,
-			Ogre::String(&quot;Position set to: Point x:&quot;)
-			+ StringConverter::toString(mPosDraggedTo.d_x)
-			+ &quot;, Point y:&quot;
-			+ StringConverter::toString(mPosDraggedTo.d_y));
-
-		LOG_MESSAGE(&quot;InventoryWindow&quot;, &quot;updateItemPosition finished&quot;);
-	}
-
-	void InventoryWindow::updateInventory(){
-		// Nach Drop
-		Item* item = static_cast&lt;Item*&gt;(mDroppedItem-&gt;getUserData());
-
-		// Gegenstand von alter Position entfernen
-		//mInventory-&gt;removeItem(item);
-
-		// Gegenstand vom Boden entfernen
-		//mInventory-&gt;removeItemFromContainer(item, mGroundItem);
-
-		// Welchem Item wird das Item hinzugefgt? -&gt; speichere das in die Variable container
-		Item* container = static_cast&lt;Item*&gt;(mContainerDraggedTo-&gt;getUserData());
-
-		// Extra Behandlung, falls Item auf den Boden gelegt wird
-		if (container == mGroundItem)
-		{
-			//mInventory-&gt;setItemContainerPosition(
-			//	item,
-			//	(int)(mPosDraggedTo.d_x/30), 
-			//	(int)(mPosDraggedTo.d_y/30),
-			//	container);
-
-			// Zus&#65533;zlich wenn Item Container war, muss Tab entfernt werden (einfach Inventar neu aufbauen)
-			if (item-&gt;isContainer())
-			{
-				removeContainerAndContent(dynamic_cast&lt;Container*&gt;(item));
-				refreshTabs();
-			}
-			update();
-			return;
-		} 
-				
-		// Item im Container platzieren
-		std::list&lt;CEGUI::Window*&gt;::iterator it = mContainerContents.begin();
-
-		while (it != mContainerContents.end())
-		{
-			if (mContainerDraggedTo == *it++){
-				//mInventory-&gt;setItemContainerPosition(
-				//	item,
-				//	(int)(mPosDraggedTo.d_x/30), 
-				//	(int)(mPosDraggedTo.d_y/30),
-				//	container);
-				break;
-			}
-		}
-
-		if (item-&gt;isContainer())
-		{
-			// ContainerTab hinzufgen, wenn nicht schon vorhanden
-			createAndFillContainer(dynamic_cast&lt;Container*&gt;(item));
-			refreshTabs();
-
-		}
-		
-
-		bool itemSwitched = false;
-		// Gegenstand in Slot setzen / Schon dagewesenen Gegenstand zurck in den Rucksack setzen
-		//if (mContainerDraggedTo == mArmor){
-		//	if (mInventory-&gt;getArmor() != NULL){
-		//		//Pack die alte Rstung ins Inventar
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeArmor(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setArmor(item);
-		//}
-		//if (mContainerDraggedTo == mCape){
-		//	if (mInventory-&gt;getCape() != NULL){
-		//		//Pack die alte Rstung ins Inventar
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeCape(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setCape(item);
-		//}
-		//if (mContainerDraggedTo == mBackpack) {
-		//	if (mInventory-&gt;getBackpack() != NULL){
-		//		//Pack den alten Rucksack auf den Boden
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeBackpack(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setBackpack(item);
-		//}
-		//if (mContainerDraggedTo == mBelt) {
-		//	if (mInventory-&gt;getBelt() != NULL){
-		//		//Pack den alten Grtel ins Inventar
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeBelt(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setBelt(item);
-		//}
-		//if (mContainerDraggedTo == mBoots) {
-		//	if (mInventory-&gt;getBoots() != NULL){
-		//		//pack die alten Stiefel ins Inventar
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeBoots(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setBoots(item);
-		//}
-		//if (mContainerDraggedTo == mBraceletLeft) {
-		//	if (mInventory-&gt;getBraceletLeft() != NULL){
-		//		//pack den alten Armreif ins Inventar
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeBraceletLeft(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setBraceletLeft(item);
-		//}
-		//if (mContainerDraggedTo == mBraceletRight) {
-		//	if (mInventory-&gt;getBraceletRight() != NULL){
-		//		//pack den alten Armreif ins Inventar
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeBraceletRight(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setBraceletRight(item);
-		//}
-		//if (mContainerDraggedTo == mRingLeft) {
-		//	if (mInventory-&gt;getRingLeft() != NULL){
-		//		//pack den alten Ring ins Inventar
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeRingLeft(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setRingLeft(item);
-		//}
-		//if (mContainerDraggedTo == mRingRight) {
-		//	if (mInventory-&gt;getRingRight() != NULL){
-		//		//pack den alten Ring ins Inventar
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeRingRight(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setRingRight(item);
-		//}
-		//if (mContainerDraggedTo == mHelmet) {
-		//	if (mInventory-&gt;getHelmet() != NULL){
-		//		//pack den alten Helm ins Inventar
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeHelmet(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setHelmet(item);
-		//}
-		//if (mContainerDraggedTo == mBracers) {
-		//	if (mInventory-&gt;getBracers() != NULL){
-		//		//pack die alte Armschienen ins Inventar
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeBracers(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setBracers(item);
-		//}
-		//if (mContainerDraggedTo == mNecklace) {
-		//	if (mInventory-&gt;getNecklace() != NULL){
-		//		//pack das alte Amulett ins Inventar
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeNecklace(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setNecklace(item);
-		//}
-		//if (mContainerDraggedTo == mGloves) {
-		//	if (mInventory-&gt;getGloves() != NULL){
-		//		//pack die alten Handschuhe ins Inventar
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeGloves(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setGloves(item);
-		//}
-		//if (mContainerDraggedTo == mTrousers) {
-		//	if (mInventory-&gt;getTrousers() != NULL){
-		//		//pack die alte Hose ins Inventar
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeTrousers(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setTrousers(item);
-		//}
-		//if (mContainerDraggedTo == mShinbone) {
-		//	if (mInventory-&gt;getShinbone() != NULL){
-		//		//pack die alte Hose ins Inventar
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeShinbone(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setShinbone(item);
-		//}
-		//if (mContainerDraggedTo == mHandLeft) {
-		//	if (mInventory-&gt;getHandLeft() != NULL){
-		//		//pack das alte Schild ins Inventar
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeHandLeft(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setHandLeft(item);
-		//}
-		//if (mContainerDraggedTo == mHandRight) {
-		//	if (mInventory-&gt;getHandRight() != NULL){
-		//		//pack die alte Waffe ins Inventar
-		//		mInventory-&gt;addItemToContainer(mInventory-&gt;removeHandRight(), mInventory-&gt;getBackpack());
-		//		itemSwitched = true;
-		//	}
-		//	mInventory-&gt;setHandRight(item);
-		//}
-		if (itemSwitched)
-		{
-			try {
-				//Bild muss im Inventarfenster an die neue Position gelegt werden
-				//pair&lt;pair&lt;int,int&gt;,Item*&gt; posInContainer = mInventory-&gt;getItemPositionInContainer(static_cast&lt;Item*&gt;(mOldItemInSlot-&gt;getUserData()));
-
-				//// Container Fenster suchen
-				//CEGUI::Window* win = findContainer(posInContainer.second);
-				//// Dem Fenster hinzufgen
-				//win-&gt;addChildWindow(mOldItemInSlot);
-				//// Positionieren		
-				//mOldItemInSlot-&gt;setPosition( CEGUI::Absolute,
-				//	CEGUI::Point(posInContainer.first.first * 30, posInContainer.first.second * 30));
-
-			}
-			catch (IllegalArgumentException iae)
-			{
-				// TODO: Item am Boden suchen
-			}
-		}
-
-
-		// Update am Inventar durchgefhrt, jetzt sollen noch die Werte aktualisiert werden
-		update();
-	}
-
-
-	void InventoryWindow::refreshTabs()
-	{
-		std::list&lt;CEGUI::Window*&gt;::iterator it = mContainers.begin();
-
-		// entferne alle Unterfenster
-		while(mContainerTabs-&gt;getTabCount() &gt; 0)
-		{
-			mContainerTabs-&gt;removeTab(mContainerTabs-&gt;getTabContents(0)-&gt;getName());
-		}
-
-		// fge sie in richtiger Reihenfolge wieder hinzu
-		while (it != mContainers.end())
-		{
-			mContainerTabs-&gt;addTab(*it++);
-		}
-	}
-
-	bool InventoryWindow::isFreeInContainer(Item* item, pair&lt;int,int&gt; kaestchenPos, Container* container)
-	{
-        return container-&gt;canPlaceAt(item, kaestchenPos.first, kaestchenPos.second);
-		//return mInventory-&gt;isFreeInContainer(item, kaestchenPos, container);
-        //return true;
-	}
-
-
-	Item* InventoryWindow::getGroundItem()
-	{
-		return mGroundItem;
-	}
-
-	void InventoryWindow::initSlots()
-	{
-		mArmorValueWindow = getWindow(&quot;InventoryWindow/ArmorValueWindow&quot;);
-        mArmorValueWindow-&gt;setProperty(&quot;Image&quot;, &quot;set:InventorySymbols image:Shield&quot;);
-		mArmorValueWindow-&gt;setTooltipText(&quot;Rstung / Behinderung&quot;);
-		//TODO: An Tooltip anh&#65533;gen: woraus setzt sich die Rstung zusammen?
-		mArmorValue = getWindow(&quot;InventoryWindow/ArmorValue&quot;);
-		mArmorValue-&gt;setText(&quot; 3&quot;);
-		//mArmorValue-&gt;setTextColours(CEGUI::colour(0.0,0.4,0.0)); //TODO port to cegui0.5
-		mArmorValue-&gt;disable();
-		mHandicapValue = getWindow(&quot;InventoryWindow/HandicapValue&quot;);
-		mHandicapValue-&gt;setText(&quot;2&quot;);
-		//mHandicapValue-&gt;setTextColours(CEGUI::colour(0.4,0.0,0.0)); //TODO port to cegui0.5
-		mHandicapValue-&gt;disable();
-
-		mWeightWindow = getWindow(&quot;InventoryWindow/WeightWindow&quot;);
-        mWeightWindow-&gt;setProperty(&quot;Image&quot;, &quot;set:InventorySymbols image:Weight&quot;);
-		mWeightWindow-&gt;setTooltipText(&quot;Getragenes Gewicht\r\nin Stein&quot;);
-
-		mTotalWeight = getWindow(&quot;InventoryWindow/TotalWeight&quot;);
-		mTotalWeight-&gt;setText(&quot;&quot;);
-		// Schwarzer Text (wird rot, wenn berladen)
-		//mTotalWeight-&gt;setTextColours(CEGUI::colour(0.0,0.0,0.0));  //TODO port to cegui0.5
-		mTotalWeight-&gt;disable();
-				
-
-		// Das Item-Beschreibungsfeld holen
-		mDescription = getScrollablePane(&quot;InventoryWindow/Description&quot;);
-
-		// Das &quot;BodenItem&quot; initiieren
-		mGroundItem = new Item(1/*&quot;Boden&quot;, &quot;Dieses Item repr&#65533;entiert den Boden&quot;*/);
-		mGroundItem-&gt;setImageName(&quot;Trank&quot;);
-		mGroundItem-&gt;setItemType(Item::ITEMTYPE_OTHER);
-		mGroundItem-&gt;setSize(1,1);
-		//mGroundItem-&gt;setContainer(true, std::make_pair&lt;int,int&gt;(mGroundDimension.first,mGroundDimension.second));
-
-
-		mContainerTabs = getTabControl(&quot;InventoryWindow/Tabs&quot;);
-		
-		// Hole die einzelnen Slots aus dem XML-File
-		mHelmet = getWindow(&quot;InventoryWindow/Helmet&quot;);
-		mHelmet-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_HELMET));
-		
-		mRingLeft = getWindow(&quot;InventoryWindow/RingLeft&quot;);
-		mRingLeft-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_RING));
-		
-		mRingRight = getWindow(&quot;InventoryWindow/RingRight&quot;);
-		mRingRight-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_RING));
-		
-		mHandLeft = getWindow(&quot;InventoryWindow/HandLeft&quot;);
-		mHandLeft-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_SHIELD));
-
-		mHandRight = getWindow(&quot;InventoryWindow/HandRight&quot;);
-		mHandRight-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_WEAPON));
-
-		mGloves = getWindow(&quot;InventoryWindow/Gloves&quot;);
-		mGloves-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_GLOVES));
-
-		mBraceletLeft = getWindow(&quot;InventoryWindow/BraceletLeft&quot;);
-		mBraceletLeft-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_BRACELET));
-
-		mBraceletRight = getWindow(&quot;InventoryWindow/BraceletRight&quot;);
-		mBraceletRight-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_BRACELET));
-
-		mArmor = getWindow(&quot;InventoryWindow/Armor&quot;);
-		mArmor-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_ARMOR));
-
-		mCape = getWindow(&quot;InventoryWindow/Cape&quot;);
-		mCape-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_CAPE));
-
-		mBracers = getWindow(&quot;InventoryWindow/Bracers&quot;);
-		mBracers-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_BRACERS));
-
-		mBackpack = getWindow(&quot;InventoryWindow/Backpack&quot;);
-		mBackpack-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_BACKPACK));
-
-		mBelt = getWindow(&quot;InventoryWindow/Belt&quot;);
-		mBelt-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_BELT));
-
-		mNecklace = getWindow(&quot;InventoryWindow/Necklace&quot;);
-		mNecklace-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_NECKLACE));
-
-		mTrousers = getWindow(&quot;InventoryWindow/Trousers&quot;);
-		mTrousers-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_TROUSERS));
-
-		mShinbone = getWindow(&quot;InventoryWindow/Shinbone&quot;);
-		mShinbone-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_SHINBONE));
-
-		mBoots = getWindow(&quot;InventoryWindow/Boots&quot;);
-		mBoots-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(Item::ITEMTYPE_BOOTS));
-
-		// gib ihnen die Funktionalit&#65533; Items aufzunehmen
-		addDropListener(mHelmet);
-		addDropListener(mRingLeft);
-		addDropListener(mRingRight);
-		addDropListener(mHandLeft);
-		addDropListener(mHandRight);
-		addDropListener(mGloves);
-		addDropListener(mBraceletLeft);
-		addDropListener(mBraceletRight);
-		addDropListener(mArmor);
-		addDropListener(mCape);
-		addDropListener(mBracers);
-		addDropListener(mBackpack);
-		addDropListener(mBelt);
-		addDropListener(mNecklace);
-		addDropListener(mTrousers);
-		addDropListener(mShinbone);
-		addDropListener(mBoots);
-	}
-
-	void InventoryWindow::fillSlots()
-	{
-		//createItem(mInventory-&gt;getRingLeft(), mRingLeft);
-		//createItem(mInventory-&gt;getRingRight(), mRingRight);
-		//createItem(mInventory-&gt;getHandLeft(), mHandLeft);
-		//createItem(mInventory-&gt;getHandRight(), mHandRight);
-		//createItem(mInventory-&gt;getGloves(), mGloves);
-		//createItem(mInventory-&gt;getBraceletLeft(), mBraceletLeft);
-		//createItem(mInventory-&gt;getBraceletRight(), mBraceletRight);
-		//createItem(mInventory-&gt;getArmor(), mArmor);
-		//createItem(mInventory-&gt;getCape(), mCape);
-		//createItem(mInventory-&gt;getBracers(), mBracers);
-		//createItem(mInventory-&gt;getBackpack(), mBackpack);
-		//createItem(mInventory-&gt;getBelt(), mBelt);
-		//createItem(mInventory-&gt;getNecklace(), mNecklace);
-		//createItem(mInventory-&gt;getHelmet(), mHelmet);
-		//createItem(mInventory-&gt;getTrousers(), mTrousers);
-		//createItem(mInventory-&gt;getShinbone(), mShinbone);
-		//createItem(mInventory-&gt;getBoots(), mBoots);
-
-
-		// Fenster fr ContainerItems erstellen
-		createContainerWindows();
-	}
-
-
-	void InventoryWindow::createContainerWindows() {
-		
-
-		std::list&lt;Item*&gt; allItems = mInventory-&gt;getAllItems();
-
-		std::list&lt;Item*&gt;::iterator itemIterator = allItems.begin();
-		
-		while (itemIterator != allItems.end()){
-			Item* currentItem = *itemIterator++;
-
-			if (currentItem-&gt;isContainer()){
-				// Tab fr Item erzeugen, da es als Container funktioniert
-				createAndFillContainer(dynamic_cast&lt;Container*&gt;(currentItem));
-			}
-		}
-		// Den Boden hinzufuegen
-		//createAndFillContainer(mGroundItem);
-	}
-
-	void InventoryWindow::createAndFillContainer(Container* container){
-		assert(mContainerContents.size() == mContainers.size());
-
-		std::list&lt;CEGUI::Window*&gt;::iterator it = mContainerContents.begin();
-		bool found = false;
-		// berprfe, ob schon vorhanden
-		while (it != mContainerContents.end())
-		{
-			if (container == static_cast&lt;Item*&gt;((*it)-&gt;getUserData()))
-			{
-				found = true;
-				break;
-			}
-			it++;
-		}
-		
-		// Nur wenn noch nicht vorhanden, soll Containertab erzeugt werden
-		if (!found)
-		{
-
-			// Erzeuge Tab im Inventar fr den Container
-			CEGUI::Window* containerWindow = CEGUI::WindowManager::getSingleton().createWindow(&quot;DefaultGUISheet&quot;, &quot;InventoryWindow/Tabs/&quot;+container-&gt;getName());
-			// Name fr das Tab
-			containerWindow-&gt;setText(container-&gt;getName());
-
-
-			mContainerTabs-&gt;addTab(containerWindow);
-
-			CEGUI::Window* containerSpace = static_cast&lt;CEGUI::Window*&gt;(CEGUI::WindowManager::getSingletonPtr()-&gt;createWindow(&quot;RastullahLook/Container&quot;, &quot;InventoryWindow/Tabs/&quot;+container-&gt;getName()+&quot;/Content&quot;));
-			
-			containerSpace-&gt;setVerticalAlignment(CEGUI::VA_CENTRE);
-			containerSpace-&gt;setHorizontalAlignment(CEGUI::HA_CENTRE);
-            containerSpace-&gt;setSize(UVector2(cegui_absdim(container-&gt;getVolume().first*30),
-                cegui_absdim(container-&gt;getVolume().second*30)));
-			containerSpace-&gt;setUserData(container);
-			containerWindow-&gt;addChildWindow(containerSpace);
-
-
-			// Inhalt in die Liste Einfgen
-						// Boden an das Ende der Liste einfgen
-			if (container == mGroundItem)
-			{
-				mContainers.push_back(containerWindow);
-				mContainerContents.push_back(containerSpace);
-			}
-			// Rucksack vorne in die Liste einfuegen
-			else if (container-&gt;getItemType() == Item::ITEMTYPE_BACKPACK)
-			{
-				mContainers.push_front(containerWindow);
-				mContainerContents.push_front(containerSpace);
-			}
-			// den Rest dazwischen
-			else 
-			{
-				if (mContainers.size() &gt; 1)
-				{
-					mContainers.insert(++(mContainers.begin()),containerWindow);
-					mContainerContents.insert(++(mContainerContents.begin()),containerSpace);
-				} else {
-					mContainers.push_front(containerWindow);
-					mContainerContents.push_front(containerSpace);
-				}
-			}
-			
-
-			addDropListener(containerSpace);
-
-			// Items im Container erstellen
-			std::set&lt;Item*&gt; itemsInContainer;
-
-			//ContainerLayout temp = container-&gt;getContainerLayout();
-			//for (unsigned x = 0; x &lt; temp.size(); x++){
-			//	for (unsigned y = 0; y &lt; temp[0].size(); y++) {
-			//		if (temp[x][y] != NULL &amp;&amp; (itemsInContainer.find(temp[x][y]) == itemsInContainer.end())){
-			//			DragContainer* itemhandler = createItem(temp[x][y],containerSpace);
-			//			itemhandler-&gt;setPosition(CEGUI::Absolute,CEGUI::Point(x*30,y*30));
-			//			itemsInContainer.insert(temp[x][y]);
-			//			LOG_MESSAGE(
-			//				&quot;InventoryWindow&quot;,
-			//				Ogre::String(&quot;erzeuge Bild im Container: &quot;) + temp[x][y]-&gt;getName());
-			//		}
-			//	}
-			//}
-		}
-	}
-
-
-	void InventoryWindow::removeContainerAndContent(Container* container)
-	{
-		assert(mContainerContents.size() == mContainers.size());
-		std::list&lt;CEGUI::Window*&gt;::iterator it = mContainerContents.begin();
-		std::list&lt;CEGUI::Window*&gt;::iterator itParent = mContainers.begin();
-		CEGUI::Window* windowToEmpty = NULL;
-		CEGUI::Window* parentTabWindow = NULL;
-
-		bool found = false;
-		while (it != mContainerContents.end())
-		{
-			if (container == static_cast&lt;Item*&gt;((*it)-&gt;getUserData()))
-			{
-				// Aus Liste entfernen
-				windowToEmpty = *it;
-				parentTabWindow = *itParent;
-				found = true;
-				break;
-			}
-			it++;
-			itParent++;
-		}
-		if (found)
-		{
-			// Entferne die Elemente aus den Listen
-			mContainerContents.erase(it);
-			mContainers.erase(itParent);
-
-
-			emptySlot(windowToEmpty);
-			emptySlot(parentTabWindow);
-
-			mContainerTabs-&gt;removeTab(parentTabWindow-&gt;getName());
-
-			CEGUI::WindowManager::getSingletonPtr()-&gt;destroyWindow(parentTabWindow);
-		}
-	}
-
-	void InventoryWindow::emptySlots()
-	{
-		emptySlot(mHelmet);
-		emptySlot(mRingLeft);
-		emptySlot(mRingRight);
-		emptySlot(mHandLeft);
-		emptySlot(mHandRight);
-		emptySlot(mGloves);
-		emptySlot(mBraceletLeft);
-		emptySlot(mBraceletRight);
-		emptySlot(mArmor);
-		emptySlot(mCape);
-		emptySlot(mBracers);
-		emptySlot(mBackpack);
-		emptySlot(mBelt);
-		emptySlot(mNecklace);
-		emptySlot(mTrousers);
-		emptySlot(mShinbone);
-		emptySlot(mBoots);
-
-		// Zus&#65533;zlich alle Container durchgehen und entleeren
-		
-		std::list&lt;CEGUI::Window*&gt;::iterator it = mContainerContents.begin();
-		
-		while (it != mContainerContents.end())
-		{
-			emptySlot(*it);
-			CEGUI::WindowManager::getSingletonPtr()-&gt;destroyWindow(*it);
-			it++;
-		} // alle Container wurden entleert
-
-		it = mContainers.begin();
-		while (it != mContainers.end())
-		{
-			emptySlot(*it);
-			mContainerTabs-&gt;removeTab((*it)-&gt;getName());
-			CEGUI::WindowManager::getSingletonPtr()-&gt;destroyWindow(*it);
-			it++;
-		} // alle ContainerTabs wurden entleert
-		mContainerContents.clear();
-		mContainers.clear();
-	}
-
-	void InventoryWindow::emptySlot(CEGUI::Window* slot)
-	{
-		while(slot-&gt;getChildCount() &gt; 0){
-			CEGUI::Window* windowToDestroy = slot-&gt;getChildAtIdx(0);
-			CEGUI::WindowManager::getSingletonPtr()-&gt;destroyWindow(windowToDestroy);
-			slot-&gt;removeChildWindow(windowToDestroy);
-		}
-	}
-
-	void InventoryWindow::addDropListener(CEGUI::Window* slot){
-		// onMouseOver (beim Drag)
-		slot-&gt;subscribeEvent(Window::EventDragDropItemEnters, boost::bind(&amp;InventoryWindow::handleDragEnter,this,_1));
-		// onMouseOut (beim Drag)
-		slot-&gt;subscribeEvent(Window::EventDragDropItemLeaves, boost::bind(&amp;InventoryWindow::handleDragLeave,this,_1));
-		// onItemDropped
-		slot-&gt;subscribeEvent(Window::EventDragDropItemDropped, boost::bind(&amp;InventoryWindow::handleDragDropped,this,_1)); 
-	}
-
-	CEGUI::Window* InventoryWindow::findContainer(Container* container)
-	{
-		std::list&lt;CEGUI::Window*&gt;::iterator it = mContainerContents.begin();
-		while (it != mContainerContents.end())
-		{
-			if (static_cast&lt;Item*&gt;((*it)-&gt;getUserData()) == container)
-				return (*it);
-			it++;
-		}
-		Throw(IllegalArgumentException, &quot;Es gibt kein Containerfenster zu dem gesuchten Item&quot;);
-	}
-
-	DragContainer* InventoryWindow::createItem(Item* item, Window* parent, UVector2 position)
-	{
-		// Prfe, ob ein Item da ist
-		if (item != NULL) {
-
-			// TODO: Ausnahmen sind Waffe und Schild (wenn parent mHand* ist, soll Hintergrund gefllt werden)
-			// Waffe:
-			if (parent == mHandRight || parent == mHandLeft) 
-			{
-				position = UVector2(cegui_absdim(30-(item-&gt;getSize().first * 15)), cegui_absdim(75-(item-&gt;getSize().second *15)));
-			}
-
-			static int itemCnt = 0;
-			itemCnt++;
-
-			// Erzeuge einen Handler fr Drag and Drop
-			DragContainer* itemhandler = static_cast&lt;DragContainer*&gt;(
-				CEGUI::WindowManager::getSingletonPtr()-&gt;createWindow(&quot;DragContainer&quot;, Ogre::StringConverter::toString(itemCnt) + item-&gt;getName()));
-			itemhandler-&gt;setPosition(position);
-			itemhandler-&gt;setSize(UVector2(cegui_absdim(item-&gt;getSize().first*30),
-                cegui_absdim(item-&gt;getSize().second*30))); 
-			itemhandler-&gt;setUserString(&quot;ItemType&quot;,Item::getItemTypeString(item-&gt;getItemType()));
-			itemhandler-&gt;setUserData(item);
-			itemhandler-&gt;setTooltipText(item-&gt;getName());
-			itemhandler-&gt;subscribeEvent(CEGUI::Window::EventMouseClick,
-				Event::Subscriber(&amp;InventoryWindow::handleMouseClicked,this));
-			
-			parent-&gt;addChildWindow(itemhandler);
-
-			CeGuiString tempName = item-&gt;getName();
-
-			// Erzeuge das Hintergrundfenster des Items
-			Window* itemWindow = 
-				CEGUI::WindowManager::getSingletonPtr()-&gt;createWindow(
-					&quot;RastullahLook/Item&quot;, 
-					tempName + &quot;Item&quot;);
-
-			itemWindow-&gt;setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
-			itemWindow-&gt;setSize(UVector2(cegui_absdim(item-&gt;getSize().first*30),
-                cegui_absdim(item-&gt;getSize().second*30)));
-			itemWindow-&gt;setProperty(&quot;FrameEnabled&quot;, &quot;false&quot;);
-			itemWindow-&gt;setProperty(&quot;BackgroundColour&quot;, mColorItemNormal);
-			// Gib dem Item noch ein Bild...
-			itemWindow-&gt;setProperty(&quot;Image&quot;,
-                CeGuiString(&quot;set:ModelThumbnails image:&quot;) + item-&gt;getImageName());
-			itemWindow-&gt;disable(); 
-
-			itemhandler-&gt;addChildWindow(itemWindow);
-
-			return itemhandler;
-		}
-		else
-		{
-			// Kein Item da...
-			return NULL;
-		}
-	}
-
-	bool InventoryWindow::handleMouseEnters(const EventArgs &amp;args) 
-	{
-		return true;
-	}
-
-	bool InventoryWindow::handleMouseLeaves(const EventArgs &amp;args) 
-	{
-		return true;
-	}
-
-
-	bool InventoryWindow::handleMouseClicked(const EventArgs &amp;args) 
-	{
-		// Hole das ausgew&#65533;lte Item
-		const CEGUI::MouseEventArgs&amp; mea = static_cast&lt;const MouseEventArgs&amp;&gt;(args);
-
-		// Nur, wenn es sich uim einen Itemhandler handelt, soll was geschehen...
-		if (mea.window-&gt;getUserData() != NULL)
-		{
-			Item* item = NULL;
-			item = static_cast&lt;Item*&gt;(mea.window-&gt;getUserData());
-	
-			// deaktiviere das letzte aktive Item, falls es eins gab
-			if (mActiveItemWindow){
-				mActiveItemWindow-&gt;setProperty(&quot;BackgroundColour&quot;, mColorItemNormal);
-				mActiveItemWindow-&gt;setProperty(&quot;FrameEnabled&quot;, &quot;False&quot;);
-			}
-			
-			assert(mea.window-&gt;getChildCount() &gt; 0);
-			
-			// aktiviere das angew&#65533;lte Item...
-			mActiveItemWindow = mea.window-&gt;getChildAtIdx(0);
-			mActiveItemWindow-&gt;setProperty(&quot;BackgroundColour&quot;, mColorItemSelected);
-			mActiveItemWindow-&gt;setProperty(&quot;FrameEnabled&quot;, &quot;True&quot;);
-			
-			// Schreibe Iteminfos in Description Fenster
-			if (item) 
-			{
-				mDescription-&gt;setText(item-&gt;getDescription());
-				if (item-&gt;getDescription().length() &gt; 200)
-				{
-					// Scrollbalken aktivieren
-                    mDescription-&gt;setShowVertScrollbar(true);
-				}
-				else 
-				{
-
-				}
-				renderItem(item);
-			}
-			else
-			{
-				mDescription-&gt;setText(&quot;&quot;);
-			}
-		}
-		return true;
-	}
-
-	void InventoryWindow::initRenderToTexture()
-	{
-		// Das Feld, in das gerendert werden soll (TransparentStaticImage)
-		mItemRenderImage = getWindow(&quot;InventoryWindow/ItemPicture&quot;);
-
-		SceneManager* tempManager = CoreSubsystem::getSingleton().
-				getWorld()-&gt;getSceneManager();
-	
-
-		// Setup Render To Texture for preview window
-		mRenderTexture = Root::getSingleton().getRenderSystem()-&gt;createRenderTexture( &quot;InventoryItemRttTex&quot;, 128, 128, TEX_TYPE_2D, PF_R8G8B8 );
+        for (size_t idx = 0; idx &lt; containers-&gt;getChildCount(); idx++)
         {
-			
-			/*Ogre::Camera* itemRenderCam = tempManager-&gt;createCamera(&quot;InventoryItemRenderCamera&quot;);
-			
-            SceneNode* itemCamNode = 
-				tempManager-&gt;getRootSceneNode()-&gt;createChildSceneNode(Ogre::Vector3(0,-1000,0));
-			
-			itemCamNode-&gt;attachObject(itemRenderCam);
-			itemRenderCam-&gt;pitch(Ogre::Radian(90));
-
-            mRenderViewport = mRenderTexture-&gt;addViewport( itemRenderCam );
-            mRenderTexture-&gt;setAutoUpdated(false);
-			mRenderViewport-&gt;setOverlaysEnabled(false);
-            mRenderViewport-&gt;setClearEveryFrame( true );
-			//mRenderViewport-&gt;setClearEveryFrame(false);
-            mRenderViewport-&gt;setBackgroundColour( ColourValue::Black );
-			*/
-			
-			//loadCamera();
-
-            
-			
-			
+            Window* curWnd = containers-&gt;getChildAtIdx(idx);
+            CeGuiString curWndName = curWnd-&gt;getName();
+            if (curWndName.find(&quot;InventoryWindow/Slots/&quot;) != CeGuiString::npos)
+            {
+                CeGuiString slotname = 
+                    curWndName.substr(
+                        curWndName.find(&quot;InventoryWindow/Slots/&quot;) + 22);
+                slotsInWindowDefinition[slotname] = curWnd;
+            }
+            else
+            {
+                LOG_DEBUG(Logger::UI, &quot;Not a slot: &quot;+curWndName);
+            }
         }
 
-        // Retrieve CEGUI texture for the RTT
-		mTexture = UiSubsystem::getSingleton().getGUIRenderer()-&gt;createTexture((CEGUI::utf8*)&quot;InventoryItemRttTex&quot;);
-
-        mImageSet = CEGUI::ImagesetManager::getSingleton().createImageset(
-                    (CEGUI::utf8*)&quot;InventoryItemRttImageset&quot;, mTexture);
-
-        mImageSet-&gt;defineImage((CEGUI::utf8*)&quot;InventoryItemRttImage&quot;, 
-                CEGUI::Point(0.0f, 0.0f),
-                CEGUI::Size(mTexture-&gt;getWidth(), mTexture-&gt;getHeight()),
-                CEGUI::Point(0.0f,0.0f));
-	}
-
-	void InventoryWindow::renderItem(Item* item)
-	{
-		SceneManager* tempManager = CoreSubsystem::getSingleton().
-					getWorld()-&gt;getSceneManager();
-
-		// Fr einen Aufh&#65533;geknoten Sorgen
-		if (mInventoryItemNode == NULL){
-			mInventoryItemNode = tempManager-&gt;getRootSceneNode()-&gt;createChildSceneNode(Ogre::Vector3(0,-999999.6,-0.2));
-			//mInventoryItemNode-&gt;setPosition(0,-100,-0.2);
-		}
-		
-		if (mRenderItemEntity) {
-			// Vom Knoten entfernen
-			mInventoryItemNode-&gt;detachAllObjects();
-			// alte Entity entfernen
-			tempManager-&gt;destroyEntity(mRenderItemEntity);
-			mRenderItemEntity = NULL;
-		}
-		if (item-&gt;getActor())
-		{
-			// Camera update erforderlich, da Mapchange da was kaputt gemacht haben k&#65533;nte
-			unloadCamera();
-			loadCamera();
-
-			// Item setzen und Schnappschuss machen
-			mRenderItemEntity = tempManager-&gt;createEntity(&quot;inventoryRenderedItem&quot;,
-                (static_cast&lt;MeshObject*&gt;(item-&gt;getActor()-&gt;getControlledObject()))-&gt;getMeshName());
-			mInventoryItemNode-&gt;attachObject(mRenderItemEntity);
-		
-			// Das Item hat einen Actor
-			//mItemActor = ActorManager::getSingleton().createMeshActor(&quot;inventoryRenderedItem&quot;,
-            //  (static_cast&lt;MeshObject*&gt;(item-&gt;getActor()-&gt;getControlledObject()))-&gt;getMeshName());
-			//mItemActor-&gt;placeIntoScene(Ogre::Vector3(0,-101055.3,-0.2));
-            mItemRenderImage-&gt;setSize(CeGuiHelper::asAbsolute(CEGUI::Vector2(128, 128)));
-			mItemRenderImage-&gt;setProperty(&quot;Image&quot;,
-                &quot;set:&quot; + mImageSet-&gt;getName() + &quot; image:InventoryItemRttImage&quot;);
-			mRenderTexture-&gt;update();
-
-		}
-        else if (item-&gt;getImageName() != &quot;&quot;)
+        Inventory::SlotMap slots = inventory-&gt;getAllSlots();
+        for (Inventory::SlotMap::const_iterator it = slots.begin(); it != slots.end(); it++)
         {
-            mItemRenderImage-&gt;setProperty(&quot;Image&quot;,
-                &quot;set:ModelThumbnails image:&quot; + item-&gt;getImageName());
+            CeGuiString slotName = (*it).first;
+            std::map&lt;CeGuiString, Window*&gt;::iterator 
+                slotInWindowFile = slotsInWindowDefinition.find(slotName);
 
-			float div = item-&gt;getSize().first / float(item-&gt;getSize().second);
+            if (slotInWindowFile != slotsInWindowDefinition.end())
+            {
+                mSlotWindows[slotName] = (*slotInWindowFile).second; 
+                slotsInWindowDefinition.erase(slotInWindowFile);
+                LOG_DEBUG(Logger::UI, &quot;Found slot &quot;+slotName);
+            }
+            else
+            {
+                LOG_DEBUG(Logger::UI, &quot;Not found slot &quot;+slotName);
+                ///@todo Create tab
+                // mSlotWindows.push_back();
+            }
+        }
 
-			if (div &lt; 1)
-			{
-				//schmales Item
-                mItemRenderImage-&gt;setSize(CeGuiHelper::asAbsolute(CEGUI::Vector2(128*div, 128)));
-			}
-			else
-			{
-				// breites oder quadratisches Item
-                mItemRenderImage-&gt;setSize(CeGuiHelper::asAbsolute(CEGUI::Vector2(128, 128/div)));
-			}
-		}
-	}
+        ///@todo deactivate all remaining elements of slotsInWindowDefinition
+    }
 
-
-	void InventoryWindow::loadCamera()
-	{
-		mCameraActor = ActorManager::getSingleton().createCameraActor(&quot;InventoryItemRttCam&quot;);
-		mCameraActor-&gt;placeIntoScene(Ogre::Vector3(0,-999999,0));
-		mCameraActor-&gt;pitch(-90);
-		mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
-
-		mRenderTexture-&gt;setAutoUpdated(false);
-        mRenderViewport = mRenderTexture-&gt;addViewport(
-            (static_cast&lt;CameraObject*&gt;(mCameraActor-&gt;getControlledObject()))-&gt;getCamera());
-        mRenderViewport-&gt;setOverlaysEnabled(false);
-        mRenderViewport-&gt;setClearEveryFrame(true);
-        mRenderViewport-&gt;setBackgroundColour( ColourValue::Black );
-	}
-
-	void InventoryWindow::unloadCamera()
-	{
-		// wenn loadCamera schon mal geladen wurde, soll die Camera zerst&#65533;t werden
-		if (mRenderViewport)
-		{
-			mRenderTexture-&gt;removeViewport(0);
-			ActorManager::getSingleton().destroyActor(mCameraActor);
-		}
-	}
-
-	/*!
-	*		&#65533;erprft, ob das Item von dem Slot akzeptiert wird
-	*/
-	bool InventoryWindow::checkTypeAccepted(CEGUI::Window* window, CEGUI::DragContainer* draggedItem)
-	{
-		if (window-&gt;getUserString(&quot;ItemType&quot;).compare(draggedItem-&gt;getUserString(&quot;ItemType&quot;)) == 0)
-		{
-			return true;
-		} 
-		else 
-		{
-			return false;
-		}
-	}
-
-	/**
-	* Berechnet aus relativen und Absoluten Mousekoordinaten die neue Position im Container
-	*/
-	std::pair&lt;int,int&gt; InventoryWindow::calculateNewPosition(const DragDropEventArgs&amp; ddea)
-	{
-		// Errechnung der Koordinaten, in welchem K&#65533;tchen denn nun gedroppt wird
-		Point absMouse = MouseCursor::getSingleton().getPosition();
-        Point scrnPt = ddea.window-&gt;getPixelRect().getPosition();
-		Point relMouse = absMouse - ddea.dragDropItem-&gt;getPixelRect().getPosition();
-
-		//Bug in CeGUI (1. rel Mouse koordinate spinnt
-		if (relMouse.d_x &lt; 0) {
-			relMouse.d_x = 15;
-		}
-
-		LOG_MESSAGE(
-			&quot;InventoryWindow&quot;,
-			Ogre::String(&quot;relMouse: Point x:&quot;)
-			+ StringConverter::toString(relMouse.d_x)
-			+ &quot;, Point y:&quot;
-			+ StringConverter::toString(relMouse.d_y));
-
-		Point pointInBackpack = absMouse-scrnPt;
-		pointInBackpack -= relMouse;
-
-		// Position des n&#65533;hsten K&#65533;tchens bestimmen		
-		if (pointInBackpack.d_x &lt; 0)
+    void InventoryWindow::initInventoryWindow(Inventory* inventory)
+    {
+        for (std::map&lt;CeGuiString, Window*&gt;::iterator it = mSlotWindows.begin(); it != mSlotWindows.end(); it++)
         {
-			pointInBackpack.d_x = 0;
-		}
-		if (pointInBackpack.d_y &lt; 0)
-        {
-			pointInBackpack.d_y = 0;
-		}
-
-		if (pointInBackpack.d_x &gt; 16)
-        {
-			pointInBackpack.d_x = (int(pointInBackpack.d_x) + 14) -
-                ((int(pointInBackpack.d_x) + 14) % 30);
-		}
-        else
-        {
-			pointInBackpack.d_x = 0;
-		}
-
-		if (pointInBackpack.d_y &gt; 16)
-        {
-			pointInBackpack.d_y = (int(pointInBackpack.d_y) + 14 ) -
-                ((int(pointInBackpack.d_y) + 14) % 30);
-		}
-        else
-        {
-			pointInBackpack.d_y = 0;
-		}
-
-		int xKaestchen = (int) (pointInBackpack.d_x / 30);
-		int yKaestchen = (int) (pointInBackpack.d_y / 30);
-
-		std::pair&lt;int,int&gt; result = std::make_pair&lt;int,int&gt;(xKaestchen, yKaestchen);
-		return result;
-	}
-
-
-	/*!
-	* Behandlung fr Mouse-over mit Item in der Maus
-	* &#65533;erprft, ob das Item passt, und f&#65533;bt dementsprechend den Beh&#65533;ter ein
-	*/
-	bool InventoryWindow::handleDragEnter(const CEGUI::EventArgs&amp; args)
-	{
-		// Event zu einem DragDropEvent machen
-		const DragDropEventArgs&amp; ddea = static_cast&lt;const DragDropEventArgs&amp;&gt;(args);
-		
-		if (ddea.window-&gt;getUserData()){
-			// Es handelt sich um einen Container
-			Item* container = static_cast&lt;Item*&gt;(ddea.window-&gt;getUserData());
-			if (container == getGroundItem())
-			{
-				// Boden (nimmt alles)
-				ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorAccept);
-				return true;
-			} 
-			else if (container &amp;&amp; container-&gt;getItemType() == Item::ITEMTYPE_BACKPACK)
-			{
-				// Ein Container kann keinen Rucksack aufnehmen
-				if (!(ddea.dragDropItem-&gt;getUserString(&quot;ItemType&quot;).compare(Item::getItemTypeString(Item::ITEMTYPE_BACKPACK))))
-				{
-					ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorReject);
-					return false;
-				}
-				else 
-				{
-					ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorAccept);
-					return true;
-				}
-			}
-			else {
-				// Beliebiger anderer Container am K&#65533;per
-				// TODO: Beschr&#65533;kung auf Itemtypen... 
-
-				ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorAccept);
-				return true;
-			}
-		}
-		else if (checkTypeAccepted(ddea.window, ddea.dragDropItem))
-		{
-			ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorAccept);
-			return true;
-		}
-		else
-		{
-			ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorReject);
-			return false;
-		}
-	}
-
-	bool InventoryWindow::handleDragLeave(const CEGUI::EventArgs&amp; args)
-	{
-		// Event zu einem DragDropEvent machen
-		const DragDropEventArgs&amp; ddea = static_cast&lt;const DragDropEventArgs&amp;&gt;(args);
-		ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorNormal);
-		return true;
-	}
-
-	bool InventoryWindow::handleDragDropped(const CEGUI::EventArgs&amp; args)
-	{
-		// Event zu einem DragDropEvent machen
-		const DragDropEventArgs&amp; ddea = static_cast&lt;const DragDropEventArgs&amp;&gt;(args);
-		// Farbe zurcksetzen
-		ddea.window-&gt;setProperty(&quot;ContainerColour&quot;, mColorNormal);
-
-
-		if (ddea.window-&gt;getUserData()){
-			// Es handelt sich um einen Container
-			Item* container = static_cast&lt;Item*&gt;(ddea.window-&gt;getUserData());
-			if (container == mGroundItem)
-			{
-				// Boden (nimmt alles)
-			} 
-			else if (container-&gt;getItemType() == Item::ITEMTYPE_BACKPACK)
-			{
-				// Rucksack (nimmt alles au&#65533;r dem Rucksack selbst)
-				if (!(ddea.dragDropItem-&gt;getUserString(&quot;ItemType&quot;).compare(Item::getItemTypeString(Item::ITEMTYPE_BACKPACK))))
-				{
-					return false;
-				}
-			}
-			else {
-				// Beliebiger anderer Container am K&#65533;per
-				// TODO: Beschr&#65533;kung auf Itemtypen... 
-			}
-
-			std::pair&lt;int,int&gt; newPos = calculateNewPosition(ddea);
-
-			if (isFreeInContainer(
-				static_cast&lt;Item*&gt;(ddea.dragDropItem-&gt;getUserData()),
-				newPos, static_cast&lt;Container*&gt;(ddea.window-&gt;getUserData())))
-			{
-				ddea.window-&gt;addChildWindow(ddea.dragDropItem);
-
-				mPosDraggedTo=CEGUI::Point(newPos.first*30,newPos.second*30);
-				mDroppedItem = ddea.dragDropItem;
-				mContainerDraggedTo = ddea.window;
-
-				updateInventory();
-				return true;
-			}
-			else 
-			{
-				return false;
-			}
-
-
-		} else {
-			// Es handelt sich um einen Slot am K&#65533;per
-			if (checkTypeAccepted(ddea.window, ddea.dragDropItem)){
-				// Nur wenn das Item in den Slot passt, soll es auch dort gedroppt werden k&#65533;nen
-
-				if (ddea.window-&gt;getChildCount() &gt; 0)
-				{
-					// Slot hat schon einen anderen Gegenstand getragen
-					mOldItemInSlot = static_cast&lt;CEGUI::DragContainer*&gt;(ddea.window-&gt;getChildAtIdx(0));
-					ddea.window-&gt;removeChildWindow(mOldItemInSlot);
-				}
-				else
-				{
-					mOldItemInSlot = NULL;
-				}
-
-				ddea.window-&gt;addChildWindow(ddea.dragDropItem);
-
-				// Waffe und Schild sollen mittig positioniert werden
-				if ((!ddea.window-&gt;getUserString(&quot;ItemType&quot;).compare(Item::getItemTypeString(Item::ITEMTYPE_WEAPON)) ||
-					(!ddea.window-&gt;getUserString(&quot;ItemType&quot;).compare(Item::getItemTypeString(Item::ITEMTYPE_SHIELD)))) &amp;&amp;
-					(ddea.dragDropItem-&gt;getUserData()))
-				{
-					Item* item = static_cast&lt;Item*&gt;(ddea.dragDropItem-&gt;getUserData());
-					mPosDraggedTo= CEGUI::Point(30-(item-&gt;getSize().first * 15),75-(item-&gt;getSize().second *15));
-				}
-				// Rest kommt in die linke obere Ecke (weil ausfllend)
-				else {
-					mPosDraggedTo=CEGUI::Point(0.0,0.0);
-				}
-				mDroppedItem = ddea.dragDropItem;
-				mContainerDraggedTo = ddea.window;
-
-				updateInventory();
-				return true;
-			} else {
-				// Item passt nicht zum Slot
-				return false;
-			}
-		}
-	}
+            CeGuiString slotName = (*it).first;
+            Item* item = inventory-&gt;getItem(slotName);
+            if (item != NULL)
+            {
+                LOG_MESSAGE(Logger::UI, (*it).first + &quot; - &quot; + item-&gt;getDescription());
+                CeGuiString icon = item-&gt;getImageName();
+                if (icon != &quot;&quot; /*&amp;&amp; icon.find(&quot;/&quot;) != CeGuiString::npos*/)
+                {
+                    LOG_MESSAGE(&quot;IW&quot;, icon);
+                    Window* itemWindow = 
+				        CEGUI::WindowManager::getSingletonPtr()-&gt;createWindow(
+					    &quot;RastullahLook/StaticImage&quot;, 
+                        mWindow-&gt;getName() + &quot;/&quot; + slotName + &quot;/&quot; + icon);
+                    itemWindow-&gt;setProperty(&quot;Image&quot;, icon);
+                    (*it).second-&gt;addChildWindow(itemWindow);
+                    itemWindow-&gt;setPosition(UVector2(cegui_reldim(0), cegui_reldim(0)));
+                    itemWindow-&gt;setSize(
+                        UVector2(cegui_absdim(item-&gt;getSize().first*30),
+                                 cegui_absdim(item-&gt;getSize().second*30)));
+                }
+            }
+        }
+    }
 }

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2007-03-30 19:13:11 UTC (rev 3211)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2007-03-30 19:20:10 UTC (rev 3212)
@@ -66,7 +66,8 @@
 	WindowFactory::WindowFactory()
 		: mShownObject(NULL),
 		  mObjectNameText(NULL),
-          mMainMenuWindow(NULL)
+          mMainMenuWindow(NULL),
+          mInventoryWindow(NULL)
     {
     }
 
@@ -83,7 +84,6 @@
 		mGameLogger = new GameLoggerWindow();
 		mCharacterStateWindow = new CharacterStateWindow();
 		mInGameMenuWindow = new InGameMenuWindow();
-		mInventoryWindow = new InventoryWindow();
 		mCharacterSheet = new CharacterSheetWindow();
 		mJournalWindow = new JournalWindow();
 		mInfoPopup = new InfoPopup();
@@ -189,19 +189,32 @@
 
 	void WindowFactory::toggleInventoryWindow()
 	{
-		if (mInventoryWindow-&gt;isVisible())
-		{
-			mInventoryWindow-&gt;setVisible(false);
-		}
-		else if (UiSubsystem::getSingleton().getActiveCharacter() != NULL)
+        if (mInventoryWindow != NULL &amp;&amp; mInventoryWindow-&gt;isVisible())
         {
-			mInventoryWindow-&gt;setInventory(UiSubsystem::getSingleton().getActiveCharacter()-&gt;getInventory());
-			mInventoryWindow-&gt;setVisible(true);
-		}
-	}
+            mInventoryWindow-&gt;setVisible(false, true);
+            mInventoryWindow = NULL;
+        }
+        else
+        {
+            if (mInventoryWindow != NULL)
+            {
+                WindowManager::getSingleton().destroyWindow(mInventoryWindow);
+                mInventoryWindow = NULL;
+            }
 
-	InventoryWindow* WindowFactory::getInventoryWindow(){
-		return mInventoryWindow;
+		    if (UiSubsystem::getSingleton().getActiveCharacter() != NULL)
+            {
+                Creature* creat = UiSubsystem::getSingleton().getActiveCharacter();
+
+                Ogre::String inventoryWindowType = creat-&gt;getInventoryWindowType();
+                if (inventoryWindowType == &quot;&quot;)
+                {
+                    inventoryWindowType = &quot;inventory_default.xml&quot;; ///TODO: Extract
+                }
+                mInventoryWindow = new InventoryWindow(inventoryWindowType, creat-&gt;getInventory());
+			    mInventoryWindow-&gt;setVisible(true);
+		    }
+        }
 	}
 
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000282.html">[Dsa-hl-svn] r3211 - rl/trunk/engine/rules/src
</A></li>
	<LI>Next message: <A HREF="000284.html">[Dsa-hl-svn] r3213 - in tools/mesh_combiner: include src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#283">[ date ]</a>
              <a href="thread.html#283">[ thread ]</a>
              <a href="subject.html#283">[ subject ]</a>
              <a href="author.html#283">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
