<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4772 - modules/common/scripts	rl/trunk/engine/ai/include rl/trunk/engine/ai/src	rl/trunk/engine/script/swig rl/trunk/engine/ui	rl/trunk/engine/ui/include rl/trunk/engine/ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4772%20-%20modules/common/scripts%0A%09rl/trunk/engine/ai/include%20rl/trunk/engine/ai/src%0A%09rl/trunk/engine/script/swig%20rl/trunk/engine/ui%0A%09rl/trunk/engine/ui/include%20rl/trunk/engine/ui/src&In-Reply-To=%3C200902221146.n1MBkCls030876%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001828.html">
   <LINK REL="Next"  HREF="001830.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4772 - modules/common/scripts	rl/trunk/engine/ai/include rl/trunk/engine/ai/src	rl/trunk/engine/script/swig rl/trunk/engine/ui	rl/trunk/engine/ui/include rl/trunk/engine/ui/src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4772%20-%20modules/common/scripts%0A%09rl/trunk/engine/ai/include%20rl/trunk/engine/ai/src%0A%09rl/trunk/engine/script/swig%20rl/trunk/engine/ui%0A%09rl/trunk/engine/ui/include%20rl/trunk/engine/ui/src&In-Reply-To=%3C200902221146.n1MBkCls030876%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4772 - modules/common/scripts	rl/trunk/engine/ai/include rl/trunk/engine/ai/src	rl/trunk/engine/script/swig rl/trunk/engine/ui	rl/trunk/engine/ui/include rl/trunk/engine/ui/src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Sun Feb 22 12:46:12 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001828.html">[Dsa-hl-svn] r4771 - rl/trunk/engine/script
</A></li>
        <LI>Next message: <A HREF="001830.html">[Dsa-hl-svn] r4773 - content/textures
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1829">[ date ]</a>
              <a href="thread.html#1829">[ thread ]</a>
              <a href="subject.html#1829">[ subject ]</a>
              <a href="author.html#1829">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2009-02-22 12:45:48 +0100 (Sun, 22 Feb 2009)
New Revision: 4772

Added:
   rl/trunk/engine/ui/include/DialogController.h
   rl/trunk/engine/ui/src/DialogController.cpp
Modified:
   modules/common/scripts/npc.rb
   rl/trunk/engine/ai/include/Dialog.h
   rl/trunk/engine/ai/include/DialogElement.h
   rl/trunk/engine/ai/include/DialogLoader.h
   rl/trunk/engine/ai/include/DialogLoaderImpl.h
   rl/trunk/engine/ai/include/DialogManager.h
   rl/trunk/engine/ai/include/DialogOption.h
   rl/trunk/engine/ai/include/DialogParagraph.h
   rl/trunk/engine/ai/include/DialogResponse.h
   rl/trunk/engine/ai/src/Dialog.cpp
   rl/trunk/engine/ai/src/DialogElement.cpp
   rl/trunk/engine/ai/src/DialogImplication.cpp
   rl/trunk/engine/ai/src/DialogLoader.cpp
   rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
   rl/trunk/engine/ai/src/DialogManager.cpp
   rl/trunk/engine/ai/src/DialogOption.cpp
   rl/trunk/engine/ai/src/DialogParagraph.cpp
   rl/trunk/engine/ai/src/DialogResponse.cpp
   rl/trunk/engine/ai/src/DialogVariable.cpp
   rl/trunk/engine/script/swig/RlAi.swig
   rl/trunk/engine/ui/CMakeLists.txt
   rl/trunk/engine/ui/include/CutsceneControlState.h
   rl/trunk/engine/ui/include/DialogControlState.h
   rl/trunk/engine/ui/src/CutsceneControlState.cpp
   rl/trunk/engine/ui/src/DialogControlState.cpp
Log:
Added functions to have more than 2 persons in a dialog
Refactored DialogControlState to allow some reuse in CutsceneControlState


Modified: modules/common/scripts/npc.rb
===================================================================
--- modules/common/scripts/npc.rb	2009-02-22 00:15:32 UTC (rev 4771)
+++ modules/common/scripts/npc.rb	2009-02-22 11:45:48 UTC (rev 4772)
@@ -6,7 +6,7 @@
   end
 
   def doAction(object, actor, target)
-    dialog = DialogManager::getSingleton().createDialog(object.getDialog(), object, actor)  
+    dialog = DialogManager::getSingleton().createDialog(object.getDialog(), object)  
 	  agent = AgentManager::getSingleton().createAgent(object)
 	  agent.pushState(RlScript::AST_DIALOG);
 	  agent.getCurrentState().setDialogPartner(

Modified: rl/trunk/engine/ai/include/Dialog.h
===================================================================
--- rl/trunk/engine/ai/include/Dialog.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/include/Dialog.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -22,27 +22,23 @@
 
 namespace rl
 {
+    class Creature;
     class DialogOption;
     class DialogResponse;
     class DialogVariable;
-    class Creature;
 
     class _RlAiExport Dialog : public PropertyHolder
     {
     public:
 		static const Ogre::String PROP_EXIT_REQUESTED;
 
-        Dialog(const std::vector&lt;Creature*&gt;&amp; pc, const std::vector&lt;Creature*&gt;&amp; npc);
+        Dialog();
         ~Dialog();
 
         DialogResponse* getDialogStart() const;
         void setStartResponse(DialogResponse* start);
         void addVariable(DialogVariable* variable);
         void initialize();
-        Creature* getNpc(int id) const;
-        Creature* getPc(int id) const;
-        std::vector&lt;Creature*&gt; getNonPlayerCharacters() const;
-        std::vector&lt;Creature*&gt; getPlayerCharacters() const;
 		bool isExitRequested() const;
         CeGuiString getVariableValue(const Ogre::String&amp; variableName) const;
 
@@ -50,10 +46,14 @@
         virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
         virtual PropertyKeys getAllPropertyKeys() const;
 
+        void addParticipant(const CeGuiString&amp; personId, Creature* person);
+        std::list&lt;Creature*&gt; getParticipants() const;
+        Creature* getParticipant(const CeGuiString&amp; id) const;
+
     private:
         DialogResponse* mDialogStart;
-        std::vector&lt;Creature*&gt; mNonPlayerCharacters;
-        std::vector&lt;Creature*&gt; mPlayerCharacters;
+        std::list&lt;Creature*&gt; mAllParticipants;
+        std::map&lt;CeGuiString, Creature*&gt; mParticipantMap;
         std::map&lt;Ogre::String, DialogVariable*&gt; mVariables;
         PropertyRecord mPropertyVariables;
 		bool mExitRequested;

Modified: rl/trunk/engine/ai/include/DialogElement.h
===================================================================
--- rl/trunk/engine/ai/include/DialogElement.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/include/DialogElement.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -33,13 +33,17 @@
         void addParagraph(DialogParagraph* paragraph);
         virtual std::list&lt;DialogParagraph*&gt; getParagraphs(Dialog* dialog);
 		virtual bool isSelection() const;
+		const CeGuiString&amp; getPerson() const;
 
     protected:
-        DialogElement(const CeGuiString&amp; id);
+        DialogElement(const CeGuiString&amp; id, const CeGuiString&amp; person = &quot;&quot;);
         virtual ~DialogElement();
 
+        virtual const CeGuiString&amp; getDefaultPerson() const = 0;
+
     private:
         CeGuiString mId;
+        CeGuiString mPerson;
         std::list&lt;DialogParagraph*&gt; mParagraphs;
     };
 
@@ -66,10 +70,10 @@
         {
             return (mVariable != NULL);
         }
-            
+
         virtual const CeGuiString&amp; getConditionVariableType()
         {
-            RlAssert(mVariable, CeGuiString(&quot;No variable found for option with id: &quot; + DialogElementType::getId()).c_str()); 
+            RlAssert(mVariable, CeGuiString(&quot;No variable found for option with id: &quot; + DialogElementType::getId()).c_str());
             return mVariable-&gt;getType();
         }
 

Modified: rl/trunk/engine/ai/include/DialogLoader.h
===================================================================
--- rl/trunk/engine/ai/include/DialogLoader.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/include/DialogLoader.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -18,7 +18,9 @@
 
 #include &quot;AiPrerequisites.h&quot;
 
-namespace rl 
+#include &lt;list&gt;
+
+namespace rl
 {
 	class Creature;
     class Dialog;
@@ -29,14 +31,14 @@
 	public:
 		DialogLoader();
 		~DialogLoader();
-	
+
 		virtual const Ogre::StringVector&amp; getScriptPatterns() const;
         virtual void parseScript(Ogre::DataStreamPtr&amp; stream, const Ogre::String&amp; groupName);
 		virtual Ogre::Real getLoadingOrder() const;
-		
-		Dialog* createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs) const;
 
-	private: 
+		Dialog* createDialog(const Ogre::String&amp; name, const std::list&lt;Creature*&gt;&amp; participants) const;
+
+	private:
         Ogre::StringVector mScriptPatterns;
         DialogLoaderImpl* mLoaderImplementation;
     };

Modified: rl/trunk/engine/ai/include/DialogLoaderImpl.h
===================================================================
--- rl/trunk/engine/ai/include/DialogLoaderImpl.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/include/DialogLoaderImpl.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -9,6 +9,8 @@
 
 #include &quot;AiPrerequisites.h&quot;
 
+#include &lt;list&gt;
+
 #include &quot;Properties.h&quot;
 #include &quot;XmlProcessor.h&quot;
 
@@ -24,17 +26,33 @@
     class DialogResponse;
     class DialogVariable;
 	class Property;
-    
+
     class DialogLoaderImpl : private XmlProcessor
     {
     public:
         DialogLoaderImpl();
         ~DialogLoaderImpl();
-        
-        Dialog* createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs) const;
+
+        Dialog* createDialog(const Ogre::String&amp; name, const std::list&lt;Creature*&gt;&amp; participants) const;
         void parseDialog(Ogre::DataStreamPtr&amp; stream, const Ogre::String&amp; groupName);
 
     private:
+        class DialogParticipant
+        {
+        public:
+            DialogParticipant(const CeGuiString&amp; personId,
+                    int goId, const CeGuiString&amp; goClass, const CeGuiString&amp; name);
+
+            bool isMatching(Creature* go) const;
+            const CeGuiString&amp; getPersonId() const;
+
+        private:
+            const CeGuiString&amp; mPersonId;
+            int mGoId;
+            const CeGuiString&amp; mGoClass;
+            const CeGuiString&amp; mName;
+        };
+
         class DialogPrototype
         {
         public:
@@ -44,14 +62,17 @@
             DialogOption* getOption(const CeGuiString&amp; id) const;
             void addResponse(DialogResponse* option);
             DialogResponse* getResponse(const CeGuiString&amp; id) const;
-            
+
             void setStartResponse(DialogResponse* response);
-            Dialog* createDialog(const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs);
+            Dialog* createDialog(const std::list&lt;Creature*&gt;&amp; participants);
             void setProperty(const CeGuiString&amp; key, const Property&amp; value);
-            
+
+            void addParticipant(DialogParticipant* participant);
+
         private:
             std::map&lt;CeGuiString, DialogOption*&gt; mOptionCache;
             std::map&lt;CeGuiString, DialogResponse*&gt; mResponseCache;
+            std::list&lt;DialogParticipant*&gt; mParticipantFilter;
             DialogResponse* mDialogStart;
             PropertyRecord mPropertyVariables;
         };
@@ -69,6 +90,7 @@
         DialogCondition* processConditionClasses(XERCES_CPP_NAMESPACE::DOMElement* conditionXml);
         DialogParagraph* processParagraph(XERCES_CPP_NAMESPACE::DOMElement* paragraphXml);
         DialogImplication* processImplicationClasses(XERCES_CPP_NAMESPACE::DOMNode* implicationXml);
+        DialogParticipant* processPerson(XERCES_CPP_NAMESPACE::DOMElement* personXml);
         void processTranslation(DialogElement* element, XERCES_CPP_NAMESPACE::DOMNode* translationXml);
         void createDialogVariable(XERCES_CPP_NAMESPACE::DOMElement* variableXml, DialogPrototype* dialogPrototype);
         void processElementNodes(XERCES_CPP_NAMESPACE::DOMElement* dialogXml, const Ogre::String&amp; nodeName, DialogPrototype* dialogPrototype);
@@ -77,4 +99,3 @@
 
     };
 }
-

Modified: rl/trunk/engine/ai/include/DialogManager.h
===================================================================
--- rl/trunk/engine/ai/include/DialogManager.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/include/DialogManager.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -18,6 +18,8 @@
 
 #include &quot;AiPrerequisites.h&quot;
 
+#include &lt;list&gt;
+
 #include &quot;Properties.h&quot;
 #include &quot;SaveGameData.h&quot;
 #include &quot;XmlProcessor.h&quot;
@@ -28,8 +30,8 @@
 	class Dialog;
 	class DialogLoader;
 
-    class _RlAiExport DialogManager 
-        : public Ogre::Singleton&lt;DialogManager&gt;, 
+    class _RlAiExport DialogManager
+        : public Ogre::Singleton&lt;DialogManager&gt;,
         public PropertyHolder,
         public SaveGameData
     {
@@ -42,8 +44,8 @@
         DialogManager();
         ~DialogManager();
 
-        Dialog* createDialog(const Ogre::String&amp; name, rl::Creature* npc, rl::Creature* pc);
-        Dialog* createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs);
+        Dialog* createDialog(const Ogre::String&amp; name, Creature* npc);
+        Dialog* createDialog(const Ogre::String&amp; name, const std::list&lt;Creature*&gt;&amp; npcs);
 
         virtual const Property getProperty(const CeGuiString&amp; key) const;
         virtual void setProperty(const CeGuiString&amp; key, const Property&amp; value);
@@ -54,20 +56,20 @@
         virtual int getPriority() const;
 
     private:
- 
+
         class DialogConfiguration
         {
         public:
-            DialogConfiguration(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; npcs);
+            DialogConfiguration(const Ogre::String&amp; name, const std::list&lt;Creature*&gt;&amp; participants);
 
             const Ogre::String&amp; getName() const;
-            const std::vector&lt;Creature*&gt;&amp; getNpcs() const;
-            
+            const std::list&lt;Creature*&gt;&amp; getParticipants() const;
+
             bool operator==(const DialogConfiguration&amp;) const;
             bool operator&lt;(const DialogConfiguration&amp;) const;
         private:
             Ogre::String mDialogName;
-            std::vector&lt;Creature*&gt; mNpcs;
+            std::list&lt;Creature*&gt; mParticipants;
         };
 
 

Modified: rl/trunk/engine/ai/include/DialogOption.h
===================================================================
--- rl/trunk/engine/ai/include/DialogOption.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/include/DialogOption.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -36,14 +36,12 @@
         DialogOption(const CeGuiString&amp; id, bool isAutoSelected);
         ~DialogOption();
 
-
         const CeGuiString&amp; getLabel() const;
         void setLabel(const CeGuiString&amp; label);
 
+        DialogResponse* getResponse() const;
         void setResponse(DialogResponse* response);
-        DialogResponse* getResponse() const;
 
-
         void setPrecondition(DialogCondition* precondition);
         virtual const CeGuiString&amp; getConditionVariableType();
         virtual bool isConditional();
@@ -51,13 +49,16 @@
         bool isAutoSelected() const;
         bool isAvailable(Dialog* dialog) const;
 
+    protected:
+        virtual const CeGuiString&amp; getDefaultPerson() const;
+
     private:
         DialogResponse* mResponse;
         DialogCondition* mPrecondition;
         CeGuiString mLabel;
         bool mIsAutoSelected;
     };
-    
+
     typedef DialogSelection&lt;DialogOption&gt; DialogOptionSelection;
 }
 

Modified: rl/trunk/engine/ai/include/DialogParagraph.h
===================================================================
--- rl/trunk/engine/ai/include/DialogParagraph.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/include/DialogParagraph.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -21,21 +21,31 @@
 
 namespace rl
 {
+    class Creature;
+    class Dialog;
+    class DialogElement;
     class DialogResponse;
 
     class _RlAiExport DialogParagraph
     {
     public:
-        DialogParagraph(const CeGuiString&amp; text, const Ogre::String&amp; voicefile = &quot;&quot;);
+        DialogParagraph(const CeGuiString&amp; text, const CeGuiString&amp; person = &quot;&quot;, const Ogre::String&amp; voicefile = &quot;&quot;);
         virtual ~DialogParagraph();
 
         const CeGuiString&amp; getText() const;
+        const CeGuiString&amp; getPerson() const;
         const Ogre::String&amp; getVoiceFile() const;
+        DialogElement* getParent() const;
+        void _setParent(DialogElement* parent);
         virtual DialogResponse* getResponse() const;
+        Creature* getSpeaker(Dialog* dialog) const;
+        std::list&lt;Creature*&gt; getListeners(Dialog* dialog) const;
 
     private:
         CeGuiString mText;
+        CeGuiString mPerson;
         Ogre::String mVoiceFile;
+        DialogElement* mParent;
     };
 
     class _RlAiExport DialogGotoResponse : public DialogParagraph

Modified: rl/trunk/engine/ai/include/DialogResponse.h
===================================================================
--- rl/trunk/engine/ai/include/DialogResponse.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/include/DialogResponse.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -24,11 +24,11 @@
 {
     class Dialog;
     class DialogImplication;
-	class DialogOption;   
+	class DialogOption;
     class Creature;
 
     /**
-     * The reponse a DialogCharacter can give in a Dialog
+     * The response a DialogCharacter can give in a Dialog
      */
     class _RlAiExport DialogResponse : public DialogElement
     {
@@ -39,7 +39,6 @@
         DialogResponse(const CeGuiString&amp; id, int npcId = 0);
         virtual ~DialogResponse();
 
-
         void addOption(DialogOption* option);
         void addImplication(DialogImplication* effect);
         virtual const Options&amp; getOptions(Dialog* dialog) const;
@@ -47,14 +46,15 @@
 
         void applyImplications(Dialog* dialog);
 
-        Creature* getNpc(Dialog* dialog) const;
+    protected:
+        virtual const CeGuiString&amp; getDefaultPerson() const;
 
     private:
         Options mOptions;
         Implications mEffects;
         int mNpcId;
     };
-    
+
     class DialogResponseSelection : public DialogSelection&lt;DialogResponse&gt;
     {
     public:

Modified: rl/trunk/engine/ai/src/Dialog.cpp
===================================================================
--- rl/trunk/engine/ai/src/Dialog.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/Dialog.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -18,14 +18,14 @@
 #include &quot;Dialog.h&quot;
 #include &quot;DialogResponse.h&quot;
 
+using namespace std;
+
 namespace rl
 {
 	const Ogre::String Dialog::PROP_EXIT_REQUESTED = &quot;exit_requested&quot;;
 
-    Dialog::Dialog(const std::vector&lt;Creature*&gt;&amp; npc, const std::vector&lt;Creature*&gt;&amp; pc)
+    Dialog::Dialog()
     {
-        mNonPlayerCharacters = npc;
-        mPlayerCharacters = pc;
     }
 
     Dialog::~Dialog()
@@ -52,16 +52,6 @@
         //mVariables[vkey] = variable;
     }
 
-    Creature* Dialog::getNpc(int id) const
-    {
-        return mNonPlayerCharacters[id];
-    }
-
-    Creature* Dialog::getPc(int id) const
-    {
-        return mPlayerCharacters[id];
-    }
-
     const Property Dialog::getProperty(const CeGuiString&amp; key) const
     {
         ///@todo dialog's state
@@ -104,14 +94,27 @@
         return getProperty(key).getAsString();
     }
 
-    std::vector&lt;Creature*&gt; Dialog::getNonPlayerCharacters() const
+    void Dialog::addParticipant(const CeGuiString&amp; personId, Creature* person)
     {
-        return mNonPlayerCharacters;
+        mParticipantMap[personId] = person;
+        mAllParticipants.push_back(person);
     }
 
-    std::vector&lt;Creature*&gt; Dialog::getPlayerCharacters() const
+    list&lt;Creature*&gt; Dialog::getParticipants() const
     {
-        return mPlayerCharacters;
+        return mAllParticipants;
     }
 
+    Creature* Dialog::getParticipant(const CeGuiString&amp; personId) const
+    {
+        map&lt;CeGuiString, Creature*&gt;::const_iterator it = mParticipantMap.find(personId);
+
+        if (it == mParticipantMap.end())
+        {
+            LOG_ERROR(&quot;Dialog&quot;, &quot;Could not find participant with ID '&quot; + personId + &quot;'&quot;);
+            return NULL;
+        }
+
+        return it-&gt;second;
+    }
 }

Modified: rl/trunk/engine/ai/src/DialogElement.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogElement.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogElement.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -22,8 +22,8 @@
 
 namespace rl
 {
-    DialogElement::DialogElement(const CeGuiString&amp; id)
-        : mId(id)
+    DialogElement::DialogElement(const CeGuiString&amp; id, const CeGuiString&amp; person)
+        : mId(id), mPerson(person)
     {
     }
 
@@ -41,9 +41,20 @@
         return mId;
     }
 
+    const CeGuiString&amp; DialogElement::getPerson() const
+    {
+        if (mPerson.empty())
+        {
+            return getDefaultPerson();
+        }
+
+        return mPerson;
+    }
+
     void DialogElement::addParagraph(DialogParagraph* paragraph)
     {
         mParagraphs.push_back(paragraph);
+        paragraph-&gt;_setParent(this);
     }
 
     std::list&lt;DialogParagraph*&gt; DialogElement::getParagraphs(Dialog* dialog)
@@ -55,5 +66,4 @@
 	{
 		return false;
 	}
-
 }

Modified: rl/trunk/engine/ai/src/DialogImplication.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogImplication.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogImplication.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -37,7 +37,7 @@
     {
     }
 
-    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String&amp; variableName, 
+    DialogVariableAssignment::DialogVariableAssignment(const Ogre::String&amp; variableName,
                                                        const CeGuiString&amp; value)
         : mVariableName(variableName), mValue(value)
     {
@@ -50,7 +50,7 @@
         dialog-&gt;setProperty(mVariableName, prop);
     }
 
-	DialogVariableIncrease::DialogVariableIncrease(const Ogre::String&amp; variableName, 
+	DialogVariableIncrease::DialogVariableIncrease(const Ogre::String&amp; variableName,
                                                    const CeGuiString&amp; value)
         : DialogVariableAssignment(variableName, value)
     {
@@ -69,13 +69,13 @@
         }
         else
         {
-            LOG_ERROR(Logger::DIALOG, &quot;You can not increase the variable '&quot; 
+            LOG_ERROR(Logger::DIALOG, &quot;You can not increase the variable '&quot;
                                       + mVariableName
                                       + &quot;'. The variable's type is not a number&quot;);
         }
     }
 
-    DialogVariableDecrease::DialogVariableDecrease(const Ogre::String&amp; variableName, 
+    DialogVariableDecrease::DialogVariableDecrease(const Ogre::String&amp; variableName,
                                                    const CeGuiString&amp; value)
         : DialogVariableAssignment(variableName, value)
     {
@@ -94,13 +94,13 @@
         }
         else
         {
-            LOG_ERROR(Logger::DIALOG, &quot;You can not decrease the variable '&quot; 
+            LOG_ERROR(Logger::DIALOG, &quot;You can not decrease the variable '&quot;
                                       + mVariableName
                                       + &quot;'. The variable's type is not a number&quot;);
         }
     }
 
-    DialogElementActivation::DialogElementActivation(const CeGuiString&amp; id, 
+    DialogElementActivation::DialogElementActivation(const CeGuiString&amp; id,
                                                      bool value,
                                                      bool isOption)
         : mElementId(id), mValue(value), mIsOption(isOption)
@@ -135,24 +135,25 @@
         Quest* quest = RulesSubsystem::getSingleton().getQuestBook()-&gt;getQuest(mQuestId);
         quest-&gt;setPropertyAsString(mProperty, mNewValue);
     }
-    
+
     CombatStart::CombatStart()
     {
     }
-    
+
     void CombatStart::apply(Dialog* dialog)
     {
         Combat* combat = CombatManager::getSingleton().startCombat();
-        std::vector&lt;Creature*&gt; allies = dialog-&gt;getPlayerCharacters();
+        ///@FIXME: fix starting combat from dialog
+/*        std::vector&lt;Creature*&gt; allies = dialog-&gt;getPlayerCharacters();
         for (std::vector&lt;Creature*&gt;::iterator it = allies.begin(); it != allies.end(); ++it)
         {
-            combat-&gt;addAlly(*it);            
+            combat-&gt;addAlly(*it);
         }
         std::vector&lt;Creature*&gt; enemies = dialog-&gt;getNonPlayerCharacters();
         for (std::vector&lt;Creature*&gt;::iterator it = enemies.begin(); it != enemies.end(); ++it)
         {
             combat-&gt;addOpponent(*it);
-        }
+        }*/
         combat-&gt;start();
     }
 

Modified: rl/trunk/engine/ai/src/DialogLoader.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoader.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogLoader.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
 * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-* 
+*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the Clarified Artistic License.
 *
@@ -29,30 +29,30 @@
         mLoaderImplementation = new DialogLoaderImpl();
         mScriptPatterns.push_back(&quot;*.dialog&quot;);
   	}
-	
+
     DialogLoader::~DialogLoader()
     {
         delete mLoaderImplementation;
 	}
- 
+
     const StringVector&amp; DialogLoader::getScriptPatterns() const
     {
         return mScriptPatterns;
     }
-    
+
 	Ogre::Real DialogLoader::getLoadingOrder() const
     {
         return 1000;
     }
-    
+
     void DialogLoader::parseScript(Ogre::DataStreamPtr&amp; stream, const Ogre::String&amp; groupName)
     {
         mLoaderImplementation-&gt;parseDialog(stream, groupName);
     }
-    
-    Dialog* DialogLoader::createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs) const
+
+    Dialog* DialogLoader::createDialog(const Ogre::String&amp; name, const std::list&lt;Creature*&gt;&amp; participants) const
     {
-        return mLoaderImplementation-&gt;createDialog(name, pcs, npcs);
+        return mLoaderImplementation-&gt;createDialog(name, participants);
     }
 
 }

Modified: rl/trunk/engine/ai/src/DialogLoaderImpl.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogLoaderImpl.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -13,6 +13,7 @@
 #include &quot;DialogLoaderImpl.h&quot;
 
 #include &quot;ConfigurationManager.h&quot;
+#include &quot;Creature.h&quot;
 #include &quot;Dialog.h&quot;
 #include &quot;DialogCondition.h&quot;
 #include &quot;DialogElement.h&quot;
@@ -21,9 +22,11 @@
 #include &quot;DialogParagraph.h&quot;
 #include &quot;DialogResponse.h&quot;
 #include &quot;DialogVariable.h&quot;
+#include &quot;PartyManager.h&quot;
 #include &quot;XmlPropertyReader.h&quot;
 
 using namespace Ogre;
+using namespace std;
 using namespace XERCES_CPP_NAMESPACE;
 
 namespace rl
@@ -32,51 +35,50 @@
     : XmlProcessor()
     {
     }
-    
+
     DialogLoaderImpl::~DialogLoaderImpl()
     {
 		std::map&lt;Ogre::String, DialogPrototype*&gt;::iterator itr = mDialogs.begin();
         std::map&lt;Ogre::String, DialogPrototype*&gt;::iterator end = mDialogs.end();
-        for(; itr != end; ++itr)
+        for (; itr != end; ++itr)
         {
 			DialogPrototype* p = itr-&gt;second;
 			delete p;
 		}
         mDialogs.clear();
 	}
-    
 
+
     void DialogLoaderImpl::parseDialog(DataStreamPtr&amp; stream, const Ogre::String&amp; groupName)
     {
         initializeXml();
-        
+
         DOMDocument* doc = loadDocument(stream);
         if (doc)
         {
             DOMNodeList* dialogNodes = doc-&gt;getElementsByTagName(AutoXMLCh(&quot;dialog&quot;).data());
-            
+
             for (XMLSize_t i = 0; i &lt; dialogNodes-&gt;getLength(); ++i)
             {
                 DOMNode* cur = dialogNodes-&gt;item(i);
                 processDialog(static_cast&lt;DOMElement*&gt;(cur));
             }
         }
-        
+
         shutdownXml();
     }
 
-    Dialog* DialogLoaderImpl::createDialog(const String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, 
-                                       const std::vector&lt;Creature*&gt;&amp; npcs) const
+    Dialog* DialogLoaderImpl::createDialog(const String&amp; name, const std::list&lt;Creature*&gt;&amp; participants) const
     {
         std::map&lt;Ogre::String, DialogPrototype*&gt;::const_iterator it =
         mDialogs.find(name);
-        
+
         if (it == mDialogs.end())
         {
             return NULL;
         }
-        
-        return it-&gt;second-&gt;createDialog(pcs, npcs);
+
+        return it-&gt;second-&gt;createDialog(participants);
     }
 
     void DialogLoaderImpl::processDialog(DOMElement* dialogElem)
@@ -84,13 +86,13 @@
         DialogPrototype* dialogPrototype = new DialogPrototype();
         Ogre::String name = getAttributeValueAsStdString(dialogElem, &quot;name&quot;);
         mDialogs[name] = dialogPrototype;
-        
+
         // first step: process all possible references
         processElementNodes(dialogElem, &quot;option&quot;, dialogPrototype);
         processElementNodes(dialogElem, &quot;switchoption&quot;, dialogPrototype);
         processElementNodes(dialogElem, &quot;response&quot;, dialogPrototype);
         processElementNodes(dialogElem, &quot;switchresponse&quot;, dialogPrototype);
-        
+
         for (DOMNode* curChild = dialogElem-&gt;getFirstChild(); curChild != NULL; curChild = curChild-&gt;getNextSibling())
         {
             if (hasNodeName(curChild, &quot;variable&quot;))
@@ -115,16 +117,27 @@
             }
             else if (hasNodeName(curChild, &quot;start&quot;))
             {
-                for (DOMNode* curChildChild = curChild-&gt;getFirstChild(); curChildChild != NULL; 
+                for (DOMNode* curChildChild = curChild-&gt;getFirstChild(); curChildChild != NULL;
                      curChildChild = curChildChild-&gt;getNextSibling())
                 {
-                    DialogResponse *response = processResponseClasses(curChildChild, dialogPrototype);
+                    DialogResponse* response = processResponseClasses(curChildChild, dialogPrototype);
                     if (response)
                     {
                         dialogPrototype-&gt;setStartResponse(response);
                     }
                 }
             }
+            else if (hasNodeName(curChild, &quot;persons&quot;))
+            {
+                for (DOMNode* curChildChild = curChild-&gt;getFirstChild(); curChildChild != NULL;
+                                     curChildChild = curChildChild-&gt;getNextSibling())
+                {
+                    if (hasNodeName(curChildChild, &quot;person&quot;))
+                    {
+                        dialogPrototype-&gt;addParticipant(processPerson(static_cast&lt;DOMElement*&gt;(curChildChild)));
+                    }
+                }
+            }
         }
         LOG_MESSAGE(Logger::AI, &quot;Processed Dialog &quot;+ name);
     }
@@ -141,7 +154,7 @@
             }
             CeGuiString id = getAttributeValueAsString(dialogElemXml, &quot;id&quot;);
             CeGuiString text = getValueAsString(dialogElemXml);
-            
+
             if (hasNodeName(dialogElemXml, &quot;switchoption&quot;))
             {
                 DialogOption* option = new DialogSelection&lt;DialogOption&gt;(id);
@@ -171,7 +184,7 @@
                 dialogPrototype-&gt;addResponse(new DialogResponseSelection(id));
             }
         }
-        
+
     }
 
     DialogResponse* DialogLoaderImpl::processResponseClasses(DOMNode *node, DialogPrototype *dialogPrototype)
@@ -195,17 +208,17 @@
     DialogResponse* DialogLoaderImpl::processResponse(DOMElement *responseXml, DialogLoaderImpl::DialogPrototype *dialogPrototype, bool subelements)
     {
         CeGuiString id = getAttributeValueAsString(responseXml, &quot;id&quot;);
-        
+
         DialogResponse* response = dialogPrototype-&gt;getResponse(id);
-        
+
         if (!response)  Throw(IllegalArgumentException, CeGuiString(&quot;No response with ID &quot;+ id).c_str());
-        
+
         bool languageDefined = false;
         DOMElement* defaultLanguage = NULL;
         if (subelements)
         {
             bool paragraphsDefined = false;
-            
+
             for (DOMNode* cur = responseXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
             {
                 DialogOption* option = processOptionClasses(cur, dialogPrototype);
@@ -214,14 +227,14 @@
                     response-&gt;addOption(option);
                     continue;
                 }
-                
+
                 DialogImplication* implication = processImplicationClasses(cur);
                 if (implication)
                 {
                     response-&gt;addImplication(implication);
                     continue;
                 }
-                
+
                 if (hasNodeName(cur, &quot;p&quot;))
                 {
                     response-&gt;addParagraph(processParagraph(static_cast&lt;DOMElement*&gt;(cur)));
@@ -232,14 +245,14 @@
                 {
                     DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
                     // check loca
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) 
+                    if (getAttributeValueAsStdString(translation, &quot;language&quot;)
                        == ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
                     {
                         processTranslation(response, translation);
                         languageDefined = true;
                     }
                     // set german as default language
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) == &quot;de&quot;)
+                    if (getAttributeValueAsStdString(translation, &quot;language&quot;) == &quot;de&quot;)
                     {
                         defaultLanguage = translation;
                     }
@@ -251,22 +264,22 @@
                     response-&gt;addParagraph(new DialogGotoResponse(dialogPrototype-&gt;getResponse(id)));
                 }
             }
-            
+
             if (!paragraphsDefined)
             {
                 CeGuiString responseXmlText = getValueAsString(responseXml);
                 response-&gt;addParagraph(new DialogParagraph(responseXmlText));
             }
-        }            
+        }
         // use german as the default language if german is not set as
         // default language but no other language was found!
-        if(!languageDefined &amp;&amp; defaultLanguage != NULL 
+        if (!languageDefined &amp;&amp; defaultLanguage != NULL
            &amp;&amp; ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;) != &quot;de&quot;)
         {
             processTranslation(response, defaultLanguage);
             languageDefined = true;
         }
-        
+
         return response;
     }
 
@@ -274,9 +287,9 @@
     {
         CeGuiString id = getAttributeValueAsString(switchRespXml, &quot;id&quot;);
         DialogSelection&lt;DialogResponse&gt;* response = dynamic_cast&lt;DialogSelection&lt;DialogResponse&gt;*&gt;(dialogPrototype-&gt;getResponse(id));
-        
+
         if (!response)  Throw(IllegalArgumentException, CeGuiString(&quot;No switchresponse with ID &quot;+ id).c_str());
-        
+
         for (DOMNode* cur = switchRespXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
         {
             DialogVariable* variable = processVariableClasses(static_cast&lt;DOMElement*&gt;(cur));
@@ -295,11 +308,11 @@
                         response-&gt;addElement(condition, responseCase);
                         break;
                     }
-                }               
+                }
             }
         }
-        
-        
+
+
         return response;
     }
 
@@ -324,18 +337,18 @@
     DialogOption* DialogLoaderImpl::processOption(DOMElement *optionXml, DialogLoaderImpl::DialogPrototype *dialogPrototype, bool subelements)
     {
         CeGuiString id = getAttributeValueAsString(optionXml, &quot;id&quot;);
-        
+
         DialogOption* option = dialogPrototype-&gt;getOption(id);
-        
+
         if (!option)    Throw(IllegalArgumentException, CeGuiString(&quot;No option with ID &quot;+ id).c_str());
-        
+
         bool languageDefined = false;
         DOMElement* defaultLanguage = NULL;
-        
+
         if (subelements)
         {
             bool paragraphsDefined = false;
-            
+
             for (DOMNode* cur = optionXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
             {
                 DialogResponse* response = processResponseClasses(cur, dialogPrototype);
@@ -356,28 +369,28 @@
                 else if (hasNodeName(cur, &quot;t&quot;))
                 {
                     DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
-                    // check loca
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) 
+                    // check locale
+                    if (getAttributeValueAsStdString(translation, &quot;language&quot;)
                        == ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
                     {
                         defaultLanguage = translation;
                         processTranslation(option, translation);
                         std::string label = getAttributeValueAsStdString(translation, &quot;label&quot;);
-                        if(!label.empty())
+                        if (!label.empty())
                         {
                             option-&gt;setLabel(label);
                         }
                         languageDefined = true;
                     }
                     // set german as default language
-                    if(getAttributeValueAsStdString(translation, &quot;language&quot;) == &quot;de&quot;)
+                    if (getAttributeValueAsStdString(translation, &quot;language&quot;) == &quot;de&quot;)
                     {
                         defaultLanguage = translation;
                     }
                     paragraphsDefined = true;
                 }
             }
-            
+
             if (!paragraphsDefined)
             {
                 CeGuiString optionXmlText = getValueAsString(optionXml);
@@ -386,18 +399,18 @@
         }
         // use german as the default language if german is not set as
         // default language but no other language was found!
-        if(!languageDefined &amp;&amp; defaultLanguage != NULL 
+        if (!languageDefined &amp;&amp; defaultLanguage != NULL
            &amp;&amp; ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;) != &quot;de&quot;)
         {
             processTranslation(option, defaultLanguage);
             std::string label = getAttributeValueAsStdString(defaultLanguage, &quot;label&quot;);
-            if(!label.empty())
+            if (!label.empty())
             {
                 option-&gt;setLabel(label);
             }
             languageDefined = true;
         }
-        
+
         return option;
     }
 
@@ -405,9 +418,9 @@
     {
         CeGuiString id = getAttributeValueAsString(switchOptXml, &quot;id&quot;);
         DialogOptionSelection* option = dynamic_cast&lt;DialogOptionSelection*&gt;(dialogPrototype-&gt;getOption(id));
-        
+
         if (!option) Throw(IllegalArgumentException, CeGuiString(&quot;No switchoption with ID &quot;+ id).c_str());
-        
+
         for (DOMNode* cur = switchOptXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
         {
             DialogVariable* variable = processVariableClasses(static_cast&lt;DOMElement*&gt;(cur));
@@ -426,25 +439,25 @@
                         option-&gt;addElement(condition, optionCase);
                         break;
                     }
-                }               
+                }
             }
             // process translations
             else if (hasNodeName(cur, &quot;t&quot;))
             {
                 DOMElement* translation = static_cast&lt;DOMElement*&gt;(cur);
                 // check loca
-                if(getAttributeValueAsStdString(translation, &quot;language&quot;) == 
+                if (getAttributeValueAsStdString(translation, &quot;language&quot;) ==
                    ConfigurationManager::getSingleton().getStringSetting(&quot;Localization&quot;, &quot;language&quot;))
                 {
                     std::string label = getAttributeValueAsStdString(translation, &quot;label&quot;);
-                    if(!label.empty())
+                    if (!label.empty())
                     {
                         option-&gt;setLabel(label);
                     }
-                } 
+                }
             }
         }
-        
+
         return option;
     }
 
@@ -459,19 +472,19 @@
     {
         DialogCondition* cond = NULL;
         DialogVariable* var = NULL;
-        
+
         for (DOMNode* cur = ifXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
         {
             if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
             {
                 DOMElement* curElem = static_cast&lt;DOMElement*&gt;(cur);
-                
+
                 DialogCondition* curCond = processConditionClasses(curElem);
                 if (curCond)
                 {
                     cond = curCond;
                 }
-                
+
                 DialogVariable* curVar = processVariableClasses(curElem);
                 if (curVar)
                 {
@@ -479,7 +492,7 @@
                 }
             }
         }
-        
+
         cond-&gt;setVariable(var);
         return cond;
     }
@@ -497,7 +510,7 @@
     DialogCondition* DialogLoaderImpl::processCase(DOMElement *caseXml)
     {
         DialogCondition* cond = NULL;
-        
+
         for (DOMNode* cur = caseXml-&gt;getFirstChild(); cur != NULL; cur = cur-&gt;getNextSibling())
         {
             if (cur-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
@@ -509,7 +522,7 @@
                 }
             }
         }
-        
+
         return cond;
     }
 
@@ -520,13 +533,13 @@
     DialogLoaderImpl::DialogPrototype::~DialogPrototype()
     {
         std::map&lt;CeGuiString, DialogOption*&gt;::iterator it;
-        for( it = mOptionCache.begin(); it != mOptionCache.end(); it++ )
-            if( it-&gt;second != NULL )
+        for (it = mOptionCache.begin(); it != mOptionCache.end(); it++)
+            if (it-&gt;second != NULL)
                 delete it-&gt;second;
-        
+
         std::map&lt;CeGuiString, DialogResponse*&gt;::iterator it1;
-        for( it1 = mResponseCache.begin(); it1 != mResponseCache.end(); it1++ )
-            if( it1-&gt;second != NULL )
+        for (it1 = mResponseCache.begin(); it1 != mResponseCache.end(); it1++)
+            if (it1-&gt;second != NULL)
                 delete it1-&gt;second;
     }
 
@@ -534,7 +547,7 @@
     {
         if (mOptionCache.find(option-&gt;getId()) != mOptionCache.end())
         {
-            Throw(IllegalArgumentException, 
+            Throw(IllegalArgumentException,
                   CeGuiString(&quot;Duplicate option/switchoption ID &quot;+ option-&gt;getId()).c_str());
         }
         mOptionCache[option-&gt;getId()] = option;
@@ -554,7 +567,7 @@
     {
         if (mResponseCache.find(response-&gt;getId()) != mResponseCache.end())
         {
-            Throw(IllegalArgumentException, 
+            Throw(IllegalArgumentException,
                   CeGuiString(&quot;Duplicate Response/switchResponse ID &quot;+ response-&gt;getId()).c_str());
         }
         mResponseCache[response-&gt;getId()] = response;
@@ -570,17 +583,58 @@
         return it-&gt;second;
     }
 
-    Dialog* DialogLoaderImpl::DialogPrototype::createDialog(const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs)
+    Dialog* DialogLoaderImpl::DialogPrototype::createDialog(const list&lt;Creature*&gt;&amp; participants)
     {
-        Dialog* dialog = new Dialog(pcs, npcs);
+        Dialog* dialog = new Dialog();
+
+        // for easy 1pc-1nsc dialogs (active player is &quot;player&quot;, one NSC is &quot;nsc&quot;)
+        Creature* player = PartyManager::getSingleton().getActiveCharacter();
+        dialog-&gt;addParticipant(&quot;player&quot;, player);
+
+        bool found1stNpc = false;
+        Party playerChars = PartyManager::getSingleton().getCharacters();
+
+        for (list&lt;Creature*&gt;::const_iterator itPart = participants.begin(); itPart != participants.end(); ++itPart)
+        {
+            Creature* curCr = *itPart;
+
+            if (!found1stNpc)
+            {
+                bool isInParty = false;
+                for (Party::iterator itParty = playerChars.begin(); itParty != playerChars.end(); ++itParty)
+                {
+                    if (*itParty == curCr)
+                    {
+                        isInParty = true;
+                        break;
+                    }
+                }
+
+                if (!isInParty)
+                {
+                    dialog-&gt;addParticipant(&quot;nsc&quot;, curCr);
+                    found1stNpc = true;
+                }
+            }
+
+
+            for (list&lt;DialogLoaderImpl::DialogParticipant*&gt;::iterator it = mParticipantFilter.begin();
+                    it != mParticipantFilter.end(); ++it)
+            {
+                if ((*it)-&gt;isMatching(curCr))
+                {
+                    dialog-&gt;addParticipant((*it)-&gt;getPersonId(), curCr);
+                }
+            }
+        }
         dialog-&gt;setStartResponse(mDialogStart);
-        
-        for (PropertyRecord::PropertyRecordMap::const_iterator it = mPropertyVariables.begin(); 
+
+        for (PropertyRecord::PropertyRecordMap::const_iterator it = mPropertyVariables.begin();
              it != mPropertyVariables.end(); ++it)
         {
             dialog-&gt;setProperty(it-&gt;first, it-&gt;second);
         }
-        
+
         return dialog;
     }
 
@@ -594,7 +648,29 @@
         mDialogStart = start;
     }
 
+    void DialogLoaderImpl::DialogPrototype::addParticipant(DialogLoaderImpl::DialogParticipant* participant)
+    {
+        mParticipantFilter.push_back(participant);
+    }
 
+    DialogLoaderImpl::DialogParticipant::DialogParticipant(const CeGuiString&amp; personId, int goId,
+            const CeGuiString&amp; goClass, const CeGuiString&amp; name)
+        : mPersonId(personId), mGoId(goId), mGoClass(goClass), mName(name)
+    {
+    }
+
+    const CeGuiString&amp; DialogLoaderImpl::DialogParticipant::getPersonId() const
+    {
+        return mPersonId;
+    }
+
+    bool DialogLoaderImpl::DialogParticipant::isMatching(Creature* creature) const
+    {
+        return (mGoId == -1 || creature-&gt;getId() == mGoId)
+            &amp;&amp; (mGoClass.empty() || creature-&gt;getClassId() == mGoClass)
+            &amp;&amp; (mName.empty() || creature-&gt;getName() == mName);
+    }
+
     DialogCondition* DialogLoaderImpl::processConditionClasses(DOMElement* conditionXml)
     {
         if (hasNodeName(conditionXml, &quot;equals&quot;))
@@ -628,7 +704,7 @@
             return new DialogConditionGreaterOrEquals(
                                                       getAttributeValueAsReal(conditionXml, &quot;value&quot;));
         }
-        
+
         return NULL;
     }
 
@@ -671,7 +747,7 @@
             int maximum = getAttributeValueAsInteger(variableXml, &quot;maximum&quot;);
             return new RandomVariable(maximum);
         }
-        
+
         return NULL;
     }
 
@@ -681,7 +757,7 @@
         if (implicationXml-&gt;getNodeType() == DOMNode::ELEMENT_NODE)
         {
             DOMElement* implicationElem = static_cast&lt;DOMElement*&gt;(implicationXml);
-            
+
             if (hasNodeName(implicationElem, &quot;setvariable&quot;))
             {
                 Ogre::String variableName = getAttributeValueAsStdString(implicationElem, &quot;name&quot;);
@@ -722,7 +798,7 @@
                 return new CombatStart();
             }
         }
-        
+
         return NULL;
     }
 
@@ -736,6 +812,36 @@
             }
         }
     }
-    
+
+    DialogLoaderImpl::DialogParticipant* DialogLoaderImpl::processPerson(DOMElement* personXml)
+    {
+        CeGuiString personId(&quot;&quot;), goClass(&quot;&quot;), name(&quot;&quot;);
+        int goId = -1;
+
+        if (hasAttribute(personXml, &quot;id&quot;))
+        {
+            personId = getAttributeValueAsString(personXml, &quot;id&quot;);
+        }
+        else
+        {
+            LOG_ERROR(&quot;DialogLoader&quot;, &quot;person node without id found&quot;);
+        }
+
+        if (hasAttribute(personXml, &quot;goId&quot;))
+        {
+            goId = getAttributeValueAsInteger(personXml, &quot;goId&quot;);
+        }
+        if (hasAttribute(personXml, &quot;goClass&quot;))
+        {
+            goClass = getAttributeValueAsString(personXml, &quot;goClass&quot;);
+        }
+        if (hasAttribute(personXml, &quot;name&quot;))
+        {
+            name = getAttributeValueAsString(personXml, &quot;name&quot;);
+        }
+
+        return new DialogParticipant(personId, goId, goClass, name);
+    }
+
 }
 

Modified: rl/trunk/engine/ai/src/DialogManager.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogManager.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogManager.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -22,9 +22,11 @@
 #include &quot;Dialog.h&quot;
 #include &quot;DialogLoader.h&quot;
 #include &quot;GameObjectManager.h&quot;
+#include &quot;PartyManager.h&quot;
 #include &quot;SaveGameManager.h&quot;
 
 using namespace Ogre;
+using namespace std;
 using namespace XERCES_CPP_NAMESPACE;
 
 template&lt;&gt;
@@ -51,8 +53,8 @@
 			mDialogLoader);
 		delete mDialogLoader;
         SaveGameManager::getSingleton().unregisterSaveGameData(this);
-		std::map&lt;DialogConfiguration, Dialog*&gt;::iterator itr = mDialogStates.begin();
-		std::map&lt;DialogConfiguration, Dialog*&gt;::iterator end = mDialogStates.end();
+		map&lt;DialogConfiguration, Dialog*&gt;::iterator itr = mDialogStates.begin();
+		map&lt;DialogConfiguration, Dialog*&gt;::iterator end = mDialogStates.end();
 		for(; itr != end; ++itr)
 		{
 			delete itr-&gt;second;
@@ -66,7 +68,7 @@
         if (key == DialogManager::PROPERTY_DIALOGS)
         {
             PropertyArray vec;
-            for (std::map&lt;DialogConfiguration, Dialog*&gt;::const_iterator it
+            for (map&lt;DialogConfiguration, Dialog*&gt;::const_iterator it
                 = mDialogStates.begin(); it != mDialogStates.end(); ++it)
             {
                 PropertyMap curDialogProp;
@@ -76,8 +78,8 @@
 
                 PropertyArray npcs;
 
-                for (std::vector&lt;Creature*&gt;::const_iterator itNpc = it-&gt;first.getNpcs().begin();
-                    itNpc != it-&gt;first.getNpcs().end(); ++itNpc)
+                for (list&lt;Creature*&gt;::const_iterator itNpc = it-&gt;first.getParticipants().begin();
+                    itNpc != it-&gt;first.getParticipants().end(); ++itNpc)
                 {
                     npcs.push_back(GameObjectManager::getSingleton().toProperty(*itNpc));
                 }
@@ -90,7 +92,7 @@
 
         Throw(IllegalArgumentException, key + &quot; is not a property of DialogManager&quot;);
     }
-	
+
 	int DialogManager::getPriority() const
 	{
 		return 50;
@@ -129,43 +131,55 @@
         return &quot;dialogs&quot;;
     }
 
-    Dialog* DialogManager::createDialog(const Ogre::String&amp; name, Creature* npc, Creature* pc)
+    Dialog* DialogManager::createDialog(const Ogre::String&amp; name, Creature* npc)
     {
-        std::vector&lt;Creature*&gt; npcs;
+        list&lt;Creature*&gt; npcs;
         npcs.push_back(npc);
-        std::vector&lt;Creature*&gt; pcs;
-        pcs.push_back(pc);
 
-        return createDialog(name, npcs, pcs);
+        return createDialog(name, npcs);
     }
 
-    Dialog* DialogManager::createDialog(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; pcs, const std::vector&lt;Creature*&gt;&amp; npcs)
+    Dialog* DialogManager::createDialog(const Ogre::String&amp; name, const list&lt;Creature*&gt;&amp; npcs)
     {
-        std::map&lt;DialogConfiguration, Dialog*&gt;::iterator it 
-            = mDialogStates.find(DialogConfiguration(name, npcs));
+        list&lt;Creature*&gt; participants;
 
+        Party party = PartyManager::getSingleton().getCharacters();
+        for (Party::const_iterator it = party.begin(); it != party.end(); ++it)
+        {
+            participants.push_back(*it);
+        }
+
+        for (list&lt;Creature*&gt;::const_iterator it = npcs.begin(); it != npcs.end(); ++it)
+        {
+            participants.push_back(*it);
+        }
+
+        map&lt;DialogConfiguration, Dialog*&gt;::iterator it
+            = mDialogStates.find(DialogConfiguration(name, participants));
+
         Dialog* dialog;
         if (it != mDialogStates.end())
         {
             dialog = (*it).second;
         }
-        else 
+        else
         {
-			dialog = mDialogLoader-&gt;createDialog(name, pcs, npcs); ///@todo save dialogs
-			
-			if (!dialog) 
+			dialog = mDialogLoader-&gt;createDialog(name, participants); ///@todo save dialogs
+
+			if (!dialog)
 			{
 				return NULL;
 			}
-			
+
             dialog-&gt;initialize();
-            mDialogStates[DialogConfiguration(name, npcs)] = dialog;
+            mDialogStates[DialogConfiguration(name, participants)] = dialog;
         }
 		return dialog;
     }
-	
-    DialogManager::DialogConfiguration::DialogConfiguration(const Ogre::String&amp; name, const std::vector&lt;Creature*&gt;&amp; npcs)
-        : mDialogName(name), mNpcs(npcs)
+
+    DialogManager::DialogConfiguration::DialogConfiguration(const Ogre::String&amp; name,
+            const list&lt;Creature*&gt;&amp; participants)
+        : mDialogName(name), mParticipants(participants)
     {
     }
 
@@ -174,9 +188,9 @@
         return mDialogName;
     }
 
-    const std::vector&lt;Creature*&gt;&amp; DialogManager::DialogConfiguration::getNpcs() const
+    const list&lt;Creature*&gt;&amp; DialogManager::DialogConfiguration::getParticipants() const
     {
-        return mNpcs;
+        return mParticipants;
     }
 
     bool DialogManager::DialogConfiguration::operator &lt;(const rl::DialogManager::DialogConfiguration &amp; other) const
@@ -186,8 +200,8 @@
 
     bool DialogManager::DialogConfiguration::operator ==(const rl::DialogManager::DialogConfiguration &amp; other) const
     {
-        return (mDialogName == other.mDialogName) 
-            &amp;&amp; (mNpcs == other.mNpcs);
+        return (mDialogName == other.mDialogName)
+            &amp;&amp; (mParticipants == other.mParticipants);
     }
 
 

Modified: rl/trunk/engine/ai/src/DialogOption.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogOption.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogOption.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -48,7 +48,7 @@
 
     const CeGuiString&amp; DialogOption::getConditionVariableType()
     {
-        RlAssert(mPrecondition, CeGuiString(&quot;No precondition found for option with id: &quot; 
+        RlAssert(mPrecondition, CeGuiString(&quot;No precondition found for option with id: &quot;
                                 + getId()
                                 + &quot;\nA precondition must be set to get its variable type&quot;).c_str());
         return mPrecondition-&gt;getVariableType();
@@ -67,7 +67,7 @@
     bool DialogOption::isAvailable(Dialog* dialog) const
     {
         bool isActive = true;
-        
+
         if(dialog-&gt;getAllProperties()-&gt;hasProperty(&quot;option&quot; + getId() + &quot;isActive&quot;))
         {
             isActive = dialog-&gt;getProperty(&quot;option&quot; + getId() + &quot;isActive&quot;);
@@ -97,4 +97,9 @@
         return mLabel;
     }
 
+    const CeGuiString&amp; DialogOption::getDefaultPerson() const
+    {
+        static CeGuiString PLAYER = &quot;player&quot;;
+        return PLAYER;
+    }
 }

Modified: rl/trunk/engine/ai/src/DialogParagraph.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogParagraph.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogParagraph.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -17,12 +17,17 @@
 
 #include &quot;DialogParagraph.h&quot;
 
+#include &quot;Dialog.h&quot;
+#include &quot;DialogElement.h&quot;
+
+using namespace std;
+
 namespace rl
 {
 
     DialogParagraph::DialogParagraph(
-        const CeGuiString&amp; text, const Ogre::String&amp; voicefile)
-    : mText(text), mVoiceFile(voicefile)
+        const CeGuiString&amp; text, const CeGuiString&amp; person, const Ogre::String&amp; voicefile)
+    : mText(text), mPerson(person), mVoiceFile(voicefile), mParent(NULL)
     {
         // for debug information
         mText.c_str();
@@ -37,6 +42,15 @@
         return mText;
     }
 
+    const CeGuiString&amp; DialogParagraph::getPerson() const
+    {
+        if (mPerson.empty())
+        {
+            return mParent-&gt;getPerson();
+        }
+        return mPerson;
+    }
+
     const Ogre::String&amp; DialogParagraph::getVoiceFile() const
     {
         return mVoiceFile;
@@ -47,8 +61,41 @@
         return NULL;
     }
 
+    DialogElement* DialogParagraph::getParent() const
+    {
+        return mParent;
+    }
+
+    void DialogParagraph::_setParent(DialogElement* parent)
+    {
+        mParent = parent;
+    }
+
+    Creature* DialogParagraph::getSpeaker(Dialog* dialog) const
+    {
+        return dialog-&gt;getParticipant(getPerson());
+    }
+
+    list&lt;Creature*&gt; DialogParagraph::getListeners(Dialog* dialog) const
+    {
+        Creature* speaker = getSpeaker(dialog);
+
+        list&lt;Creature*&gt; listeners;
+
+        list&lt;Creature*&gt; participants = dialog-&gt;getParticipants();
+        for (list&lt;Creature*&gt;::iterator it = participants.begin(), end = participants.end(); it != end; ++it)
+        {
+            if (*it != speaker)
+            {
+                listeners.push_back(*it);
+            }
+        }
+
+        return listeners;
+    }
+
     DialogGotoResponse::DialogGotoResponse(rl::DialogResponse *response)
-        : DialogParagraph(&quot;&quot;, &quot;&quot;), mResponse(response)
+        : DialogParagraph(&quot;&quot;, &quot;&quot;, &quot;&quot;), mResponse(response)
     {
     }
 
@@ -57,4 +104,3 @@
         return mResponse;
     }
 }
-

Modified: rl/trunk/engine/ai/src/DialogResponse.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogResponse.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogResponse.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -31,8 +31,8 @@
     DialogResponse::~DialogResponse()
     {
     }
-    
 
+
     void DialogResponse::addOption(rl::DialogOption *option)
     {
         mOptions.push_back(option);
@@ -77,9 +77,10 @@
         }
     }
 
-    Creature* DialogResponse::getNpc(rl::Dialog *dialog) const
+    const CeGuiString&amp; DialogResponse::getDefaultPerson() const
     {
-        return dialog-&gt;getNpc(mNpcId);
+        static CeGuiString PERSON = &quot;npc&quot;;
+        return PERSON;
     }
 
     DialogResponseSelection::DialogResponseSelection(const CeGuiString&amp; id)

Modified: rl/trunk/engine/ai/src/DialogVariable.cpp
===================================================================
--- rl/trunk/engine/ai/src/DialogVariable.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ai/src/DialogVariable.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -81,19 +81,16 @@
 
     Property TalentProbeVariable::calculateValue(Dialog* dialog)
     {
-        Creature* cr = NULL;
-        if(mTarget == &quot;pc&quot;)
+        Creature* cr = dialog-&gt;getParticipant(mTarget);
+        if (cr == NULL)
         {
-            cr = dialog-&gt;getPc(0); ///@todo allow multiple PCs
+            LOG_ERROR(&quot;Dialog&quot;, &quot;No or wrong target for talent check ' &quot; + mTalent + &quot;'&quot;);
+            return Property(-1);
         }
-        else if (mTarget == &quot;npc&quot;)
+        else
         {
-            cr = dialog-&gt;getNpc(0);
+            return Property(cr-&gt;doTalentprobe(mTalent, mModifier));
         }
-        // if no target was given, use the player character. 
-        // @todo: remove this, target should be required!
-        if(cr == NULL) { cr = dialog-&gt;getPc(0);}
-        return Property(cr-&gt;doTalentprobe(mTalent, mModifier));
     }
 
     EigenschaftsProbeVariable::EigenschaftsProbeVariable(const rl::CeGuiString &amp;eigenschaft, int modifier, const rl::CeGuiString&amp; target)
@@ -103,26 +100,25 @@
 
     Property EigenschaftsProbeVariable::calculateValue(Dialog* dialog)
     {
-        Creature* cr = NULL;
-        if(mTarget == &quot;pc&quot;)
+        Creature* cr = dialog-&gt;getParticipant(mTarget);
+        // if no target was given, use the player character.
+        // @todo: remove this, target should be required!
+        if (cr == NULL)
         {
-            cr = dialog-&gt;getPc(0); ///@todo allow multiple PCs
+            LOG_ERROR(&quot;Dialog&quot;, &quot;No or wrong target for attribute check ' &quot; + mEigenschaft + &quot;'&quot;);
+            return Property(-1);
         }
-        else if (mTarget == &quot;npc&quot;)
+        else
         {
-            cr = dialog-&gt;getNpc(0);
+            return Property(cr-&gt;doEigenschaftsprobe(mEigenschaft, mModifier));
         }
-        // if no target was given, use the player character. 
-        // @todo: remove this, target should be required!
-        if(cr == NULL) { cr = dialog-&gt;getPc(0);}
-        return Property(cr-&gt;doEigenschaftsprobe(mEigenschaft, mModifier));
     }
-	
+
 	RandomVariable::RandomVariable(int maximum)
 		: DialogVariable(&quot;random&quot;), mMaximum(maximum)
 	{
 	}
-	
+
 	Property RandomVariable::calculateValue(Dialog* dialog)
 	{
 		double d = std::rand();

Modified: rl/trunk/engine/script/swig/RlAi.swig
===================================================================
--- rl/trunk/engine/script/swig/RlAi.swig	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/script/swig/RlAi.swig	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -20,7 +20,7 @@
 	%template(Ogrevec3Vector) vector&lt;Ogre::Vector3 &gt;;
 };
 
-namespace rl 
+namespace rl
 {
 	// Before first use
 	%apply SWIGTYPE *DYNAMIC { rl::AStarHeuristic * };
@@ -44,7 +44,7 @@
 		bool isAhead(rl::Agent* agent, const float threshold);
 		bool needAvoidance(const float minTimeToCollision);
 	};
-	
+
 	%feature(&quot;director&quot;) SteeringBehaviour;
 	class SteeringBehaviour
 	{
@@ -58,28 +58,28 @@
 		virtual void update(const float elapsedTime)=0;
 
 		virtual float calculateActivation()=0;
-		
+
 		float getActivationLevel();
 		void setActivationLevel(float activationLevel);
 
 		rl::SteeringBehaviour* getParent();
 		rl::SteeringVehicle* getController();
 	};
-	
+
 	%feature(&quot;director&quot;) AgentState;
     class AgentState
     {
     private:
         AgentState(rl::Agent* agent);
     };
-    
-    
+
+
     class AgentSteeringState : public rl::AgentState
     {
     public:
         void addSteeringBehaviour(SteeringBehaviour* behaviour);
     };
-   
+
     class AgentDialogState : public rl::AgentState
     {
     public:
@@ -90,7 +90,7 @@
     };
 
     typedef enum {AST_STEERING, AST_COMBAT, AST_DIALOG} AgentStateType;
-	
+
 	class Agent
 	{
 	public:
@@ -101,12 +101,12 @@
         void pushState(rl::AgentStateType type);
 	};
 
-	class AiSubsystem 
+	class AiSubsystem
 	{
 	public:
 		static AiSubsystem&amp; getSingleton(void);
 	};
-	
+
 	%feature(&quot;director&quot;) BehaviourFactory;
     class BehaviourFactory
     {
@@ -116,16 +116,16 @@
 
         virtual rl::SteeringBehaviour* createBehaviour(const Ogre::String&amp; classname) = 0;
     };
-    
+
 	class AgentManager
 	{
-	public:		
+	public:
 		static AgentManager&amp; getSingleton(void);
 		rl::Agent* createAgent(rl::Creature* character);
-		
+
         virtual void setBehaviourFactory(BehaviourFactory* factory);
 	};
-	
+
 	class AStarHeuristic
 	{
 	public:
@@ -133,7 +133,7 @@
 		virtual ~AStarHeuristic();
 		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const = 0;
 	};
-	
+
 	class ManhattanDistance
 		: public rl::AStarHeuristic
 	{
@@ -168,26 +168,26 @@
 		EuclideanDistanceSquared();
 		virtual ~EuclideanDistanceSquared();
 		virtual float calcDistance(const Ogre::Vector3&amp; vec1, const Ogre::Vector3&amp; vec2) const;
-	}; 
-	
+	};
+
 	class AStarCosts
 	{
 	public:
-		AStarCosts(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);	
+		AStarCosts(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);
 		virtual ~AStarCosts();
 		virtual float calcCost(const rl::WayPointGraph* WPGraph, const rl::AStarWayPointNode* wp1,
 			const rl::AStarWayPointNode* wp2) const = 0;
 	};
-	
+
 	class AStarCostsDefault : public AStarCosts
 	{
 	public:
-		AStarCostsDefault(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);	
+		AStarCostsDefault(const rl::AStarHeuristic* Heuristic, float TieBreakFactor);
 		~AStarCostsDefault();
 		virtual float calcCost(const rl::WayPointGraph* WPGraph, const rl::AStarWayPointNode* wp1,
 			const rl::AStarWayPointNode* wp2) const;
 	};
-	
+
 	class AStar
 	{
 	public:
@@ -195,40 +195,40 @@
 		//AStar( const rl::AStarCosts* Costs, const rl::WayPointGraph* WPGraph,
 		//	const Ogre::Vector3&amp; StartPos, const Ogre::Vector3&amp; EndPos );
 		virtual ~AStar();
-		
+
 		void search(std::vector&lt;Ogre::Vector3&gt;&amp; resultPath);
 		void searchFromTo(std::vector&lt;Ogre::Vector3&gt;&amp; resultPath,
 			const Ogre::Vector3&amp; StartPos, const Ogre::Vector3&amp; EndPos );
 		void reset();
 	};
-	
+
     class PhysicalObstacle {
-        
+
         public:
             PhysicalObstacle(rl::PhysicalThing *thing);
             virtual ~PhysicalObstacle();
-            
+
             OpenSteer::Obstacle *getObstacle() const;
-            
+
             rl::PhysicalThing *getPhysicalThing() const;
             void setPhysicalThing(rl::PhysicalThing *thing);
     };
-    
+
     class WayPointNode
 	{
 	public:
-		enum WayPointNodeType 
+		enum WayPointNodeType
 		{
 			WP_UNKNOWN = 0,
 			WP_EXTERIOR = 1,
 			WP_INTERIOR = 2
 		};
-		
+
 		WayPointNode(const Ogre::Vector3&amp; pos, const rl::WayPointNode::WayPointNodeType type);
 		Ogre::Vector3 getPosition() const;
 	};
-	
-	class WayPointGraph 
+
+	class WayPointGraph
 	{
 	public:
 		WayPointNode* addWayPoint(const Ogre::Vector3&amp; position, const WayPointNode::WayPointNodeType type);
@@ -238,14 +238,14 @@
 		const rl::WayPointNode* getNearestWayPoint(const Ogre::Vector3&amp; position) const;
 		const rl::WayPointNode* getWayPointAt(unsigned int index) const;
 	};
-	
-	class WayPointGraphManager 
+
+	class WayPointGraphManager
 	{
 	public:
 		static WayPointGraphManager&amp; getSingleton(void);
 		rl::WayPointGraph* createWayPointGraph();
 	};
-	
+
 	class Landmark
 	{
 	public:
@@ -253,7 +253,7 @@
 		const Ogre::String&amp; getName() const;
 		const Ogre::Vector3&amp; getPosition() const;
 	};
-	
+
 	class LandmarkPath
 	{
 	public:
@@ -264,7 +264,7 @@
 		void addPoint(rl::Landmark* lm);
         rl::LandmarkPath::LandmarkList getPoints();
 	};
-	
+
     class WalkPathBehaviour : public rl::SteeringBehaviour
 	{
 	public:
@@ -280,7 +280,7 @@
 
 		virtual float calculateActivation();
 	};
-	
+
 	class CreatureWalkPathJob : public Job
     {
     public:
@@ -301,8 +301,8 @@
     {
     public:
         static rl::DialogManager&amp; getSingleton();
-        rl::Dialog* createDialog(const Ogre::String&amp; name, rl::Creature* npc, rl::Creature* pc);
-        rl::Dialog* createDialog(const Ogre::String&amp; name, const std::vector&lt;rl::Creature*&gt;&amp; npcs, const std::vector&lt;rl::Creature*&gt;&amp; pcs);
+        rl::Dialog* createDialog(const Ogre::String&amp; name, rl::Creature* npc);
+        rl::Dialog* createDialog(const Ogre::String&amp; name, const std::list&lt;rl::Creature*&gt;&amp; npcs);
     private:
         DialogManager();
     };
@@ -337,7 +337,7 @@
         *ptr=pEuclideanDistanceSquared;
         return SWIGTYPE_p_rl__EuclideanDistanceSquared;
     }
-   
+
     return 0;
 }
 %}
@@ -355,7 +355,7 @@
         *ptr=pAStarCostsDefault;
         return SWIGTYPE_p_rl__AStarCostsDefault;
     }
-   
+
     return 0;
 }
 %}
@@ -373,14 +373,14 @@
         *ptr=pAgentDialogState;
         return SWIGTYPE_p_rl__AgentDialogState;
     }
-    
+
     rl::AgentSteeringState *pAgentSteeringState = dynamic_cast&lt;rl::AgentSteeringState*&gt;(pAgentState);
     if (pAgentSteeringState)
     {
         *ptr=pAgentSteeringState;
         return SWIGTYPE_p_rl__AgentSteeringState;
     }
-   
+
     return 0;
 }
 %}

Modified: rl/trunk/engine/ui/CMakeLists.txt
===================================================================
--- rl/trunk/engine/ui/CMakeLists.txt	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ui/CMakeLists.txt	2009-02-22 11:45:48 UTC (rev 4772)
@@ -29,6 +29,7 @@
 src/Console.cpp
 src/CutsceneControlState.cpp
 src/DebugWindow.cpp
+src/DialogController.cpp
 src/DialogControlState.cpp
 src/DialogWindow.cpp
 src/FreeflightControlState.cpp

Modified: rl/trunk/engine/ui/include/CutsceneControlState.h
===================================================================
--- rl/trunk/engine/ui/include/CutsceneControlState.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ui/include/CutsceneControlState.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -61,6 +61,7 @@
         void addCamera(const Ogre::Vector3&amp; position, const Ogre::Quaternion&amp; orientation);
         void addCamera(const Ogre::Vector3&amp; position, const Ogre::Quaternion&amp; orientation1,
                        const Ogre::Quaternion&amp; orientation2);
+        void clearCameras();
 
 	private:
 	    std::vector&lt;CameraPosition&gt; mPositions;

Modified: rl/trunk/engine/ui/include/DialogControlState.h
===================================================================
--- rl/trunk/engine/ui/include/DialogControlState.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ui/include/DialogControlState.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -1,6 +1,6 @@
 /* This source file is part of Rastullahs Lockenpracht.
  * Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
- * 
+ *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the Clarified Artistic License.
  *
@@ -18,33 +18,29 @@
 #define __DialogCharacterController_H__
 
 #include &quot;UiPrerequisites.h&quot;
-#include &quot;ControlState.h&quot;
+#include &quot;DialogController.h&quot;
 
-
 namespace rl {
 
 	class Actor;
+    class Creature;
 	class Dialog;
     class DialogElement;
-	class DialogOption;
-	class DialogParagraph;
-	class DialogResponse;
 	class DialogWindow;
 	class GameLoggerWindow;
-    class GameObject;
 	class MeshAnimation;
 	class SoundObject;
 	class SubtitleWindow;
 
-	/** Diese Klasse 
-	  *  
+	/** Diese Klasse
+	  *
 	  */
-	class _RlUiExport DialogControlState : public ControlState
+	class _RlUiExport DialogControlState : public DialogController
 	{
 	public:
         enum DialogMode
-		{ 
-            // Frontperspektive auf Augenh&#246;he, ausgehend von der Mitte zwischen den Redenden
+		{
+            // Frontperspektive auf Augenh&#239;&#191;&#189;he, ausgehend von der Mitte zwischen den Redenden
 			DM_FRONT = 1,
 		};
 
@@ -54,7 +50,7 @@
 		*  @throw InvalidArgumentException if character is not placed in the scene.
 		*/
 		DialogControlState(CommandMapper* cmdMapper, Actor* camera, Creature* character);
-		/// Dtor 
+		/// Dtor
 		virtual ~DialogControlState();
 
         virtual void pause();
@@ -65,71 +61,40 @@
 
 		void start(Dialog* dialog);
 
-		/// Antwort eines der Dialogf&#252;hrenden
+		/// Antwort eines der Dialogf&#239;&#191;&#189;hrenden
 		void response(Actor* actor, const CeGuiString&amp; text, const Ogre::String&amp; soundFile = &quot;&quot;);
 
-        virtual bool mouseReleased(const OIS::MouseEvent&amp; evt, OIS::MouseButtonID id, bool handled);
-
-		bool handleDialogSelectOption(DialogOption* option);	
-		bool handleDialogClose();
+		bool handleDialogSelectOption(DialogOption* option);
+		virtual void handleDialogEnd();
 		bool requestDialogClose();
+	    virtual bool textFinished();
 
 	private:
+        enum DialogState
+        {
+            CHOOSING_OPTION = 1,
+            TALKING_PARTNER_CHARACTER,
+            TALKING_PLAYER_CHARACTER,
+            CLOSING_DIALOG
+        };
+
 		/// Die Zielkameraposition in lokalen Koordinaten
 		Ogre::Vector3 mTargetCameraPosition;
-		/// Die ben&#246;tigte lokale Drehung der Kamera
+		/// Die ben&#239;&#191;&#189;tigte lokale Drehung der Kamera
 		Ogre::Vector3 mTargetCameraDirection;
 
-		/// Die aktuelle Zeit f&#252;r die Textanzeige
-		Ogre::Real mCurrFadeTextTime;
-        /// Die Zeit bis der Text ausgeblendet wird
-        Ogre::Real mTotalFadeTextTime;
 
-        Ogre::Real mSubtitleSpeed;
-
-		/// Der Untertitel-Text
-		CeGuiString mText;
-		/// Es wird gerade Text angezeigt
-		bool mTextShown;
-
-		GameObject* mCurrentSpeaker;
-		GameObject* mCurrentListener;
-        DialogResponse* mCurrentResponse;
-        DialogOption* mCurrentOption;
-        std::list&lt;DialogParagraph*&gt; mCurrentParagraphs;
-
-        /// Die Art der Kamerapositinierung
+        /// Die Art der Kamerapositionierung
         DialogMode mDialogMode;
 
-		MeshAnimation* mTalkAnimation;
+        DialogState mDialogState;
 
+
 		DialogWindow* mDialogWindow;
-		SubtitleWindow* mSubtitleWindow;
-		SoundObject* mSoundObject;
-	
-		float getShowTextLength(const CeGuiString&amp; text) const;
-        void recalculateCamera(GameObject* speaker, GameObject* listener);
-        void processTextVariables(CeGuiString&amp; text);
 
-		enum DialogState
-		{
-			CHOOSING_OPTION = 1,
-			TALKING_PARTNER_CHARACTER,
-			TALKING_PLAYER_CHARACTER,
-			CLOSING_DIALOG
-		};
+        virtual void recalculateDialogCamera(Creature* speaker, std::list&lt;Creature*&gt; listeners);
 
-		Dialog* mDialog;
-		GameLoggerWindow* mGameLogger;
-		DialogState mState;
-		CeGuiString mCurrentResponseText;
-				
-        void showResponse(DialogResponse* response);
         void showOptions(const std::list&lt;DialogOption*&gt;&amp; options);
-        void doTalk(DialogParagraph* paragraph);
-        Ogre::Vector3 getParticipantPosition(GameObject* participant);
-
-		void textFinished();
 	};
 }
 #endif

Added: rl/trunk/engine/ui/include/DialogController.h
===================================================================
--- rl/trunk/engine/ui/include/DialogController.h	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ui/include/DialogController.h	2009-02-22 11:45:48 UTC (rev 4772)
@@ -0,0 +1,81 @@
+/*
+ * DialogController.h
+ *
+ *  Created on: 15.02.2009
+ *      Author: blakharaz
+ */
+
+#ifndef DIALOGCONTROLLER_H_
+#define DIALOGCONTROLLER_H_
+
+#include &quot;AiPrerequisites.h&quot;
+
+#include &lt;list&gt;
+
+#include &quot;ControlState.h&quot;
+
+namespace rl
+{
+    class Actor;
+    class Creature;
+    class Dialog;
+    class DialogOption;
+    class DialogParagraph;
+    class DialogResponse;
+    class DialogWindow;
+    class GameLoggerWindow;
+    class MeshAnimation;
+    class SoundObject;
+    class SubtitleWindow;
+
+    class DialogController : public ControlState
+    {
+    public:
+        virtual bool mouseReleased(const OIS::MouseEvent&amp; evt, OIS::MouseButtonID id, bool handled);
+
+    protected:
+        DialogController(CommandMapper* commandMapper, Actor* camera, Creature* character,
+                ControlStateType type);
+        virtual ~DialogController();
+
+        void showResponse(DialogResponse* response, DialogWindow* window = NULL);
+        void doTalk(DialogParagraph* paragraph, DialogWindow* window = NULL);
+        Ogre::Vector3 getParticipantPosition(Creature* participant);
+        virtual bool textFinished();
+        virtual void recalculateDialogCamera(Creature* speaker, std::list&lt;Creature*&gt; listeners) = 0;
+        virtual void handleDialogEnd() = 0;
+        void setDialogWindow(DialogWindow* window);
+        void setSubtitleWindow(SubtitleWindow* window);
+        virtual void pause();
+
+         SubtitleWindow* mSubtitleWindow;
+        DialogWindow* mDialogWindow;
+        SoundObject* mSoundObject;
+        MeshAnimation* mTalkAnimation;
+        /// Die aktuelle Zeit f&#239;&#191;&#189;r die Textanzeige
+        Ogre::Real mCurrFadeTextTime;
+        /// Die Zeit bis der Text ausgeblendet wird
+        Ogre::Real mTotalFadeTextTime;
+        Ogre::Real mSubtitleSpeed;
+        Creature* mCurrentSpeaker;
+        std::list&lt;Creature*&gt; mCurrentListeners;
+        /// Der Untertitel-Text
+        CeGuiString mText;
+        /// Es wird gerade Text angezeigt
+        bool mTextShown;
+
+        DialogResponse* mCurrentResponse;
+        DialogOption* mCurrentOption;
+        std::list&lt;DialogParagraph*&gt; mCurrentParagraphs;
+
+        Dialog* mDialog;
+        GameLoggerWindow* mGameLogger;
+        CeGuiString mCurrentResponseText;
+
+        float getShowTextLength(const CeGuiString&amp; text) const;
+        void processTextVariables(CeGuiString&amp; text);
+    };
+}
+
+
+#endif /* DIALOGCONTROLLER_H_ */

Modified: rl/trunk/engine/ui/src/CutsceneControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/CutsceneControlState.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ui/src/CutsceneControlState.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -110,4 +110,9 @@
         CameraPosition cpos = {CPT_ROTATING, position, orientation1, orientation2};
         mPositions.push_back(cpos);
     }
+
+    void CutsceneControlState::clearCameras()
+    {
+        mPositions.clear();
+    }
 }

Modified: rl/trunk/engine/ui/src/DialogControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogControlState.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ui/src/DialogControlState.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -53,40 +53,26 @@
 #endif
 
 using namespace Ogre;
+using namespace std;
 
 namespace rl {
 
     DialogControlState::DialogControlState(CommandMapper* cmdMapper,
         Actor* camera, Creature* character)
-        : ControlState(cmdMapper, camera, character, CST_DIALOG),
+        : DialogController(cmdMapper, camera, character, CST_DIALOG),
         mTargetCameraPosition(Vector3::ZERO),
         mTargetCameraDirection(Vector3::UNIT_Z),
-        mCurrFadeTextTime(0),
-        mTotalFadeTextTime(0),
-        mText(),
-        mDialogMode(DM_FRONT),
-        mTextShown(false),
-        mDialogWindow(NULL),
-        mSubtitleWindow(NULL),
-        mSoundObject(NULL),
-        mTalkAnimation(NULL),
-        mSubtitleSpeed(1.0f),
-		mCurrentResponseText(&quot;&quot;),
-		mGameLogger(NULL),
-        mCurrentSpeaker(NULL),
-        mCurrentListener(NULL)
+        mDialogMode(DM_FRONT)
     {
-        mSubtitleSpeed = ConfigurationManager::getSingleton().getRealSetting(
-            &quot;General&quot;, &quot;Subtitle Speed&quot;);
     }
 
     DialogControlState::~DialogControlState()
     {
-        delete mSoundObject;
     }
 
     void DialogControlState::pause()
     {
+        DialogController::pause();
         /*
         if (mDialogPartner)
         {
@@ -95,7 +81,7 @@
             {
                 mesh-&gt;stopAllAnimations();
                 if (mesh-&gt;hasAnimation(&quot;idle&quot;))
-                { 
+                {
                     mTalkAnimation = mesh-&gt;startAnimation(&quot;idle&quot;);
                 }
             }
@@ -103,8 +89,6 @@
         */
         //mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
         //mCharacterActor-&gt;getPhysicalThing()-&gt;unfreeze();
-        mDialogWindow-&gt;setVisible(false, false);
-        mSubtitleWindow-&gt;setVisible(false, false);
     }
 
     void DialogControlState::resume()
@@ -127,6 +111,8 @@
         {
             mSubtitleWindow = new SubtitleWindow();
         }
+
+
         mDialogWindow-&gt;setVisible(true);
         mSubtitleWindow-&gt;setVisible(true);
 
@@ -155,12 +141,10 @@
 		if (!mDialog || !mDialogWindow)
 		{
             LOG_ERROR(Logger::UI, &quot;DialogControlState not properly initialized.&quot;);
-            handleDialogClose();
+            handleDialogEnd();
             return;
 		}
         mDialog-&gt;setProperty(Dialog::PROP_EXIT_REQUESTED, false);
-        mCurrentSpeaker = mDialog-&gt;getNpc(0);
-        mCurrentListener = mDialog-&gt;getPc(0);
         showResponse(mDialog-&gt;getDialogStart());
 	}
 
@@ -211,11 +195,11 @@
                 + StringConverter::toString(mCurrFadeTextTime));
     }
 
-    void DialogControlState::recalculateCamera(GameObject* speaker, GameObject* listener)
+    void DialogControlState::recalculateDialogCamera(Creature* speaker, std::list&lt;Creature*&gt; listeners)
     {
         // Position camera at position between char and dialog partner
         Vector3 speakerEyes = getParticipantPosition(speaker);
-        Vector3 listenerEyes = getParticipantPosition(listener);
+        Vector3 listenerEyes = getParticipantPosition(listeners.front()); ///@FIXME, this is just using the 1st listener
         Vector3 globalCameraPosition = (speakerEyes + listenerEyes) / 2.0f;
 
         // Weltkoordinaten in lokale umwandeln
@@ -226,335 +210,95 @@
         mTargetCameraDirection = (listenerEyes - mTargetCameraPosition).normalisedCopy();
     }
 
-    Vector3 DialogControlState::getParticipantPosition(GameObject* participant)
-    {
-        Vector3 eyesPosition = participant-&gt;getPosition();
 
-        // Modify by MeshBounds
-        if (participant-&gt;getActor() &amp;&amp; participant-&gt;getActor()-&gt;getControlledObject()-&gt;isMeshObject())
+	void DialogControlState::handleDialogEnd()
+	{
+		InputManager::getSingleton().popControlState();
+		mDialogWindow-&gt;setVisible(false, true);
+		mSubtitleWindow-&gt;setVisible(false, true);
+        mDialogWindow = NULL;
+        mSubtitleWindow = NULL;
+        if (mDialog != NULL)
         {
-            MeshObject* mo = static_cast&lt;MeshObject*&gt;(participant-&gt;getActor()-&gt;getControlledObject());
-            Ogre::AxisAlignedBox aab = mo-&gt;getDefaultSize();
-            Vector3 offset(
-                aab.getCenter().x,
-                aab.getMaximum().y * 0.933,
-                aab.getCenter().z);
-            eyesPosition += participant-&gt;getOrientation() * offset;
-        }
-
-        return eyesPosition;
-    }
-
-    float DialogControlState::getShowTextLength(const CeGuiString&amp; text) const
-    {
-        return 0.019f * text.length() + // Zeit f&#195;&#188;rs Text lesen
-               0.25f;                   // Fade in
-    }
-
-    void DialogControlState::processTextVariables(CeGuiString&amp; text)
-    {
-        CeGuiString newText = text;
-        CeGuiString::size_type pos = CeGuiString::npos;
-        do
-        {
-            pos = newText.find(&quot;{$&quot;);
-            if (pos != CeGuiString::npos)
+            const list&lt;Creature*&gt; list = mDialog-&gt;getParticipants();
+            for (std::list&lt;Creature*&gt;::const_iterator it = list.begin(); it != list.end(); ++it)
             {
-                CeGuiString::size_type endpos = newText.find(&quot;}&quot;, pos);
-                if (endpos != CeGuiString::npos)
+                Actor* actor = (*it)-&gt;getActor();
+                if (actor != NULL)
                 {
-                    CeGuiString varName = newText.substr(pos+2, endpos - pos - 2);
-                    CeGuiString varValue = mDialog-&gt;getVariableValue(varName.c_str());
-                    newText = newText.replace(pos, endpos - pos + 1, varValue);
+                    MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(actor-&gt;getControlledObject());
+                    if (mesh != NULL &amp;&amp; mesh-&gt;hasAnimation(&quot;reden&quot;))
+                    {
+                        mesh-&gt;stopAnimation(&quot;reden&quot;);
+                    }
                 }
             }
         }
-        while (pos != CeGuiString::npos);
-        text.assign(newText);
-    }
-
-    void DialogControlState::doTalk(DialogParagraph* paragraph)
-    {
-        mDialogWindow-&gt;setVisible(false);
-        Ogre::String soundFile = paragraph-&gt;getVoiceFile();
-        CeGuiString text = paragraph-&gt;getText();
-        // if there is no text in the paragraph, go directly to the next entry!
-        if(text.empty())
-        {
-            textFinished();
-            return;
-        }
-        processTextVariables(text);
-
-        recalculateCamera(mCurrentListener, mCurrentSpeaker);
-
-        Actor* actor = mCurrentSpeaker-&gt;getActor();
-        // @todo: find out why we don't here anything if the sound is attached to the player
-        // atm, we attach it everytime to the npc to here at least anything
-        actor = mDialog-&gt;getNpc(0)-&gt;getActor();
-        // Ungef&#195;&#164;hre Lesedauer bestimmen
-        float fadeTime = getShowTextLength(text);
-        if (soundFile.length() == 0)
-        {
-            float speed = mSubtitleSpeed;
-
-            if (mSubtitleSpeed == 0.0)
-                speed = 1.0;
-
-            mCurrFadeTextTime = fadeTime*speed;
-            mTotalFadeTextTime = fadeTime*speed;
-        }
         else
         {
-            if (mSoundObject != NULL)
-            {
-                mSoundObject-&gt;getMovableObject()-&gt;getParentSceneNode()-&gt;detachObject(
-                    mSoundObject-&gt;getMovableObject());
-                delete mSoundObject;
-            }
-
-            mSoundObject = new SoundObject(SoundManager::getSingleton().getActiveDriver()-&gt;
-                    createSound(soundFile, ST_SAMPLE), soundFile);
-
-            // An Sprecher h&#195;&#164;ngen
-            actor-&gt;_getSceneNode()-&gt;attachObject(mSoundObject-&gt;getMovableObject());
-            actor-&gt;_getSceneNode()-&gt;_update(true, false);
-            mSoundObject-&gt;_setActor(actor);
-            mSoundObject-&gt;set3d(true);
-            mSoundObject-&gt;play();
-            mSoundObject-&gt;_update();
-
-
-            mCurrFadeTextTime = std::max(fadeTime*mSubtitleSpeed,mSoundObject-&gt;getLength());
-            mTotalFadeTextTime = mCurrFadeTextTime;
+            LOG_ERROR(Logger::UI, &quot;There is no Dialog to be closed!&quot;);
         }
+	}
 
-        MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(actor-&gt;getControlledObject());
-        if (mesh != NULL)
-        {
-            if (mesh-&gt;hasAnimation(&quot;reden&quot;))
-            {
-                mesh-&gt;stopAllAnimations();
-                mTalkAnimation = mesh-&gt;startAnimation(&quot;reden&quot;);
-            }
-        }
-
-        LOG_DEBUG(Logger::UI,
-            &quot;Response: &quot;
-                + actor-&gt;getName()
-                + &quot; File: '&quot;
-                + soundFile
-                + &quot;', Text: '&quot; + text + &quot;', Time: &quot;
-                + StringConverter::toString(mCurrFadeTextTime));
-
-
-        mTextShown = true;
-
-        if (mSubtitleWindow != NULL &amp;&amp; !text.empty())
-        {
-            mSubtitleWindow-&gt;show(text);
-        }
-    }
-
-    bool DialogControlState::mouseReleased(const OIS::MouseEvent&amp; evt,
-        OIS::MouseButtonID id, bool handled)
-    {
-        bool retval = false;
-        if (ControlState::mouseReleased(evt, id, handled))
-            retval = true;
-
-        if (!handled &amp;&amp; !retval)
-        {
-            if (mTextShown &amp;&amp; 
-                (mCurrFadeTextTime + 0.25 &lt; mTotalFadeTextTime))
-            {
-                mCurrFadeTextTime = -1;
-                retval = true;
-            }
-        }
-
-        return retval;
-    }
-
-    void DialogControlState::showResponse(DialogResponse* response)
+	bool DialogControlState::requestDialogClose()
 	{
-        if (!response)
-		{
-            LOG_MESSAGE(Logger::UI, &quot;No response found! Close Dialog!&quot;);
-			mDialogWindow-&gt;setDialogEnd();
-			mState = CLOSING_DIALOG;
-			handleDialogClose();
-			return;
-		}
-
-		if (response-&gt;isSelection())
-		{
-			DialogResponseSelection* sel = static_cast&lt;DialogResponseSelection*&gt;(response);
-			mCurrentResponse = sel-&gt;getSelectedElement(mDialog);
-		}
-		else
-		{
-			mCurrentResponse = response;
-		}
-	
-        mState = TALKING_PARTNER_CHARACTER;
-        mCurrentOption = NULL;
-
-		mDialogWindow-&gt;setVisible(false);
-
-        mCurrentListener = mDialog-&gt;getPc(0);
-        mCurrentSpeaker = mCurrentResponse-&gt;getNpc(mDialog);
-        mCurrentParagraphs = mCurrentResponse-&gt;getParagraphs(mDialog);
-        if(!mCurrentParagraphs.empty())
-        {
-            DialogParagraph* firstParagraph = mCurrentParagraphs.front();
-            mCurrentResponse-&gt;applyImplications(mDialog);
-            // does this paragraph contain a response?
-            if (!firstParagraph-&gt;getResponse())
-            {
-                // no, so directly start with the first paragraph
-                doTalk(firstParagraph);
-            }
-            else if(mCurrentParagraphs.size() &gt; 1)
-            {
-                // yes, but there are other paragraphs in the list.
-                // the response should be executed at last, so we put it back to the end
-                mCurrentParagraphs.pop_front();
-                mCurrentParagraphs.push_back(firstParagraph);
-                firstParagraph = mCurrentParagraphs.front();
-                // we don't allow more than one goto per response
-                if(firstParagraph-&gt;getResponse())
-                {
-                    LOG_ERROR(Logger::UI, &quot;To many gotoresponses in response with id: &quot; 
-                        + mCurrentResponse-&gt;getId()); 
-                    handleDialogClose();
-                }
-                else
-                {
-                    doTalk(firstParagraph);
-                }
-            }
-            else
-            {
-                // we only have a response as paragraph, execute it!
-                showResponse(firstParagraph-&gt;getResponse());
-            }
-        }
-        else
-        {
-            handleDialogClose();
-        }
+	//	handleClose is called automatically
+        handleDialogEnd();
+		//@todo
+		return true;
 	}
 
-	void DialogControlState::textFinished()
+
+	bool DialogControlState::textFinished()
 	{
-		if (mDialog-&gt;isExitRequested())
-		{
-			handleDialogClose();
-			return;
-		}
 
-        mCurrentParagraphs.pop_front();
-        if (!mCurrentParagraphs.empty())
+        if (!DialogController::textFinished())
         {
-            DialogParagraph* curParagraph = mCurrentParagraphs.front();
-            if (curParagraph-&gt;getResponse() == NULL)
+            if (mDialogState == TALKING_PARTNER_CHARACTER)
             {
-                doTalk(curParagraph);
-            }
-            else
-            {
-                showResponse(curParagraph-&gt;getResponse());
-            }
-        }
-        else
-        {
-		    if (mState == TALKING_PARTNER_CHARACTER)
-		    {
-                mCurrentListener = mCurrentResponse-&gt;getNpc(mDialog);
-                mCurrentSpeaker = mDialog-&gt;getPc(0);
 
                 DialogResponse::Options options = mCurrentResponse-&gt;getAvailableOptions(mDialog);
                 // if there is just one option and it is an auto selected one,
                 // display it.
-                if(options.size() == 1 &amp;&amp;  options.front()-&gt;isAutoSelected())
+                if (options.size() == 1 &amp;&amp;  options.front()-&gt;isAutoSelected())
                 {
                     handleDialogSelectOption(options.front());
-                    return;
+                    return true;
                 }
                 mDialogWindow-&gt;setAvailableOptions(options);
-		        mDialogWindow-&gt;setVisible(true);
-		        mState = CHOOSING_OPTION;
-		    }
-            else if (mState == TALKING_PLAYER_CHARACTER)
+                mDialogWindow-&gt;setVisible(true);
+                mDialogState = CHOOSING_OPTION;
+            }
+            else if (mDialogState == TALKING_PLAYER_CHARACTER)
             {
                 showResponse(mCurrentOption-&gt;getResponse());
             }
         }
 
-		LOG_DEBUG(Logger::UI,
-					StringConverter::toString(mState)
-					+ &quot; bei textFinished&quot;);
-	}
+        LOG_DEBUG(Logger::UI,
+                    StringConverter::toString(mDialogState)
+                    + &quot; bei textFinished&quot;);
 
-	bool DialogControlState::handleDialogSelectOption(DialogOption* option)
-	{
-		if (option-&gt;isSelection())
-		{
-			DialogOptionSelection* sel = static_cast&lt;DialogOptionSelection*&gt;(option);
-			mCurrentOption = sel-&gt;getSelectedElement(mDialog);
-		}
-		else
-		{
-			mCurrentOption = option;
-		}
-        mState = TALKING_PLAYER_CHARACTER;
-        mCurrentListener = mDialog-&gt;getNpc(0);
-        mCurrentSpeaker = mDialog-&gt;getPc(0); ///@todo allow char switch 
-        mCurrentParagraphs = mCurrentOption-&gt;getParagraphs(mDialog);
-        doTalk(mCurrentParagraphs.front());
-
-		return true;
+        return true;
 	}
 
-	bool DialogControlState::handleDialogClose()
-	{
-		InputManager::getSingleton().popControlState();
-		mDialogWindow-&gt;setVisible(false, true);
-		mSubtitleWindow-&gt;setVisible(false, true);
-        mDialogWindow = NULL;
-        mSubtitleWindow = NULL;
-        if (mDialog != NULL)
+    bool DialogControlState::handleDialogSelectOption(DialogOption* option)
+    {
+        if (option-&gt;isSelection())
         {
-            const std::vector&lt;Creature*&gt; list = mDialog-&gt;getPlayerCharacters();
-            for (std::vector&lt;Creature*&gt;::const_iterator it = list.begin(); it != list.end(); ++it)
-            {
-                Actor* actor = (*it)-&gt;getActor();
-                if (actor != NULL)
-                {
-                    MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(actor-&gt;getControlledObject());
-                    if (mesh != NULL &amp;&amp; mesh-&gt;hasAnimation(&quot;reden&quot;))
-                    {
-                        mesh-&gt;stopAnimation(&quot;reden&quot;);
-                    }
-                }        
-            }
-            return true;
+            DialogOptionSelection* sel = static_cast&lt;DialogOptionSelection*&gt;(option);
+            mCurrentOption = sel-&gt;getSelectedElement(mDialog);
         }
         else
         {
-            LOG_ERROR(Logger::UI, &quot;There is no Dialog to be closed!&quot;);
-            return false;
+            mCurrentOption = option;
         }
-	}
 
-	bool DialogControlState::requestDialogClose()
-	{
-	//	handleClose is called automatically
-        handleDialogClose();
-		//@todo
-		return true;
-	}
+        mDialogState = TALKING_PLAYER_CHARACTER;
+        mCurrentParagraphs = mCurrentOption-&gt;getParagraphs(mDialog);
+        doTalk(mCurrentParagraphs.front());
 
+        return true;
+    }
 
 }

Added: rl/trunk/engine/ui/src/DialogController.cpp
===================================================================
--- rl/trunk/engine/ui/src/DialogController.cpp	2009-02-22 00:15:32 UTC (rev 4771)
+++ rl/trunk/engine/ui/src/DialogController.cpp	2009-02-22 11:45:48 UTC (rev 4772)
@@ -0,0 +1,324 @@
+/*
+ * DialogController.cpp
+ *
+ *  Created on: 15.02.2009
+ *      Author: blakharaz
+ */
+
+#include &quot;stdinc.h&quot;
+
+#include &quot;DialogController.h&quot;
+
+#include &quot;Actor.h&quot;
+#include &quot;ConfigurationManager.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;Dialog.h&quot;
+#include &quot;DialogOption.h&quot;
+#include &quot;DialogParagraph.h&quot;
+#include &quot;DialogResponse.h&quot;
+#include &quot;DialogWindow.h&quot;
+#include &quot;GameObject.h&quot;
+#include &quot;MeshObject.h&quot;
+#include &quot;SoundDriver.h&quot;
+#include &quot;SoundManager.h&quot;
+#include &quot;SoundObject.h&quot;
+#include &quot;SubtitleWindow.h&quot;
+
+using namespace Ogre;
+
+namespace rl
+{
+    DialogController::DialogController(CommandMapper* commandMapper, Actor* camera, Creature* character,
+            ControlStateType type)
+        : ControlState(commandMapper, camera, character, type),
+        mSubtitleWindow(NULL),
+        mSoundObject(NULL),
+        mTalkAnimation(NULL),
+        mSubtitleSpeed(1.0f),
+        mTextShown(false),
+        mCurrFadeTextTime(0),
+        mTotalFadeTextTime(0),
+        mText(),
+        mDialogWindow(NULL),
+        mCurrentResponseText(&quot;&quot;),
+        mGameLogger(NULL),
+        mCurrentSpeaker(NULL)
+    {
+        mSubtitleSpeed = ConfigurationManager::getSingleton().getRealSetting(
+            &quot;General&quot;, &quot;Subtitle Speed&quot;);
+    }
+
+    DialogController::~DialogController()
+    {
+        delete mSoundObject;
+    }
+
+    void DialogController::doTalk(DialogParagraph* paragraph, DialogWindow* window)
+    {
+        if (window)
+        {
+            window-&gt;setVisible(false);
+        }
+        Ogre::String soundFile = paragraph-&gt;getVoiceFile();
+        CeGuiString text = paragraph-&gt;getText();
+        // if there is no text in the paragraph, go directly to the next entry!
+        if(text.empty())
+        {
+            textFinished();
+            return;
+        }
+        processTextVariables(text);
+
+        mCurrentSpeaker = paragraph-&gt;getSpeaker(mDialog);
+        mCurrentListeners = paragraph-&gt;getListeners(mDialog);
+
+        recalculateDialogCamera(mCurrentSpeaker, mCurrentListeners);
+        Actor* actor = mCurrentSpeaker-&gt;getActor();
+
+        // Ungef&#195;&#164;hre Lesedauer bestimmen
+        float fadeTime = getShowTextLength(text);
+        if (soundFile.length() == 0)
+        {
+            float speed = mSubtitleSpeed;
+
+            if (mSubtitleSpeed == 0.0)
+            {
+                speed = 1.0;
+            }
+
+            mCurrFadeTextTime = fadeTime*speed;
+            mTotalFadeTextTime = fadeTime*speed;
+        }
+        else
+        {
+            if (mSoundObject != NULL)
+            {
+                mSoundObject-&gt;getMovableObject()-&gt;getParentSceneNode()-&gt;detachObject(
+                    mSoundObject-&gt;getMovableObject());
+                delete mSoundObject;
+            }
+
+            mSoundObject = new SoundObject(SoundManager::getSingleton().getActiveDriver()-&gt;
+                    createSound(soundFile, ST_SAMPLE), soundFile);
+
+            // An Sprecher h&#195;&#164;ngen
+            actor-&gt;_getSceneNode()-&gt;attachObject(mSoundObject-&gt;getMovableObject());
+            actor-&gt;_getSceneNode()-&gt;_update(true, false);
+            mSoundObject-&gt;_setActor(actor);
+            mSoundObject-&gt;set3d(true);
+            mSoundObject-&gt;play();
+            mSoundObject-&gt;_update();
+
+
+            mCurrFadeTextTime = std::max(fadeTime*mSubtitleSpeed,mSoundObject-&gt;getLength());
+            mTotalFadeTextTime = mCurrFadeTextTime;
+        }
+
+        MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(actor-&gt;getControlledObject());
+        if (mesh != NULL)
+        {
+            if (mesh-&gt;hasAnimation(&quot;reden&quot;))
+            {
+                mesh-&gt;stopAllAnimations();
+                mTalkAnimation = mesh-&gt;startAnimation(&quot;reden&quot;);
+            }
+        }
+
+        LOG_DEBUG(Logger::UI,
+            &quot;Response: &quot;
+                + actor-&gt;getName()
+                + &quot; File: '&quot;
+                + soundFile
+                + &quot;', Text: '&quot; + text + &quot;', Time: &quot;
+                + StringConverter::toString(mCurrFadeTextTime));
+
+
+        mTextShown = true;
+
+        if (mSubtitleWindow != NULL &amp;&amp; !text.empty())
+        {
+            mSubtitleWindow-&gt;show(text);
+        }
+    }
+
+    void DialogController::showResponse(DialogResponse* response, DialogWindow* window)
+    {
+        if (!response)
+        {
+            LOG_MESSAGE(Logger::UI, &quot;No response found! Close Dialog!&quot;);
+            if (window)
+            {
+                window-&gt;setDialogEnd();
+            }
+            handleDialogEnd();
+            return;
+        }
+
+        if (response-&gt;isSelection())
+        {
+            DialogResponseSelection* sel = static_cast&lt;DialogResponseSelection*&gt;(response);
+            mCurrentResponse = sel-&gt;getSelectedElement(mDialog);
+        }
+        else
+        {
+            mCurrentResponse = response;
+        }
+
+
+        if (window)
+        {
+            window-&gt;setVisible(false);
+        }
+
+        mCurrentParagraphs = mCurrentResponse-&gt;getParagraphs(mDialog);
+        if(!mCurrentParagraphs.empty())
+        {
+            DialogParagraph* firstParagraph = mCurrentParagraphs.front();
+            mCurrentResponse-&gt;applyImplications(mDialog);
+            // does this paragraph contain a response?
+            if (!firstParagraph-&gt;getResponse())
+            {
+                // no, so directly start with the first paragraph
+                doTalk(firstParagraph, window);
+            }
+            else if(mCurrentParagraphs.size() &gt; 1)
+            {
+                // yes, but there are other paragraphs in the list.
+                // the response should be executed at last, so we put it back to the end
+                mCurrentParagraphs.pop_front();
+                mCurrentParagraphs.push_back(firstParagraph);
+                firstParagraph = mCurrentParagraphs.front();
+                // we don't allow more than one goto per response
+                if(firstParagraph-&gt;getResponse())
+                {
+                    LOG_ERROR(Logger::UI, &quot;To many gotoresponses in response with id: &quot;
+                        + mCurrentResponse-&gt;getId());
+                    handleDialogEnd();
+                }
+                else
+                {
+                    doTalk(firstParagraph, window);
+                }
+            }
+            else
+            {
+                // we only have a response as paragraph, execute it!
+                showResponse(firstParagraph-&gt;getResponse());
+            }
+        }
+        else
+        {
+            handleDialogEnd();
+        }
+    }
+
+    float DialogController::getShowTextLength(const CeGuiString&amp; text) const
+    {
+        return 0.019f * text.length() + // Zeit f&#195;&#188;rs Text lesen
+               0.25f;                   // Fade in
+    }
+
+    void DialogController::processTextVariables(CeGuiString&amp; text)
+    {
+        CeGuiString newText = text;
+        CeGuiString::size_type pos = CeGuiString::npos;
+        do
+        {
+            pos = newText.find(&quot;{$&quot;);
+            if (pos != CeGuiString::npos)
+            {
+                CeGuiString::size_type endpos = newText.find(&quot;}&quot;, pos);
+                if (endpos != CeGuiString::npos)
+                {
+                    CeGuiString varName = newText.substr(pos+2, endpos - pos - 2);
+                    CeGuiString varValue = mDialog-&gt;getVariableValue(varName.c_str());
+                    newText = newText.replace(pos, endpos - pos + 1, varValue);
+                }
+            }
+        }
+        while (pos != CeGuiString::npos);
+        text.assign(newText);
+    }
+
+    void DialogController::pause()
+    {
+        if (mDialogWindow) {
+            mDialogWindow-&gt;setVisible(false, false);
+        }
+        if (mSubtitleWindow) {
+            mSubtitleWindow-&gt;setVisible(false, false);
+        }
+    }
+
+    bool DialogController::mouseReleased(const OIS::MouseEvent&amp; evt,
+        OIS::MouseButtonID id, bool handled)
+    {
+        bool retval = ControlState::mouseReleased(evt, id, handled);
+
+        if (!handled &amp;&amp; !retval)
+        {
+            if (mTextShown &amp;&amp;
+                (mCurrFadeTextTime + 0.25 &lt; mTotalFadeTextTime))
+            {
+                mCurrFadeTextTime = -1;
+                retval = true;
+            }
+        }
+
+        return retval;
+    }
+
+    void DialogController::setDialogWindow(DialogWindow* window)
+    {
+        mDialogWindow = window;
+    }
+
+    void DialogController::setSubtitleWindow(SubtitleWindow* window)
+    {
+        mSubtitleWindow = window;
+    }
+
+    Vector3 DialogController::getParticipantPosition(Creature* participant)
+    {
+        Vector3 eyesPosition = participant-&gt;getPosition();
+
+        // Modify by MeshBounds
+        if (participant-&gt;getActor() &amp;&amp; participant-&gt;getActor()-&gt;getControlledObject()-&gt;isMeshObject())
+        {
+            MeshObject* mo = static_cast&lt;MeshObject*&gt;(participant-&gt;getActor()-&gt;getControlledObject());
+            Ogre::AxisAlignedBox aab = mo-&gt;getDefaultSize();
+            Vector3 offset(
+                aab.getCenter().x,
+                aab.getMaximum().y * 0.933,
+                aab.getCenter().z);
+            eyesPosition += participant-&gt;getOrientation() * offset;
+        }
+
+        return eyesPosition;
+    }
+
+    bool DialogController::textFinished()
+    {
+        if (mDialog-&gt;isExitRequested())
+        {
+            handleDialogEnd();
+            return true;
+        }
+
+        mCurrentParagraphs.pop_front();
+        if (!mCurrentParagraphs.empty())
+        {
+            DialogParagraph* curParagraph = mCurrentParagraphs.front();
+            if (curParagraph-&gt;getResponse() == NULL)
+            {
+                doTalk(curParagraph, mDialogWindow);
+            }
+            else
+            {
+                showResponse(curParagraph-&gt;getResponse());
+            }
+
+            return true;
+        }
+    }
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001828.html">[Dsa-hl-svn] r4771 - rl/trunk/engine/script
</A></li>
	<LI>Next message: <A HREF="001830.html">[Dsa-hl-svn] r4773 - content/textures
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1829">[ date ]</a>
              <a href="thread.html#1829">[ thread ]</a>
              <a href="subject.html#1829">[ subject ]</a>
              <a href="author.html#1829">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
