<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4755 - in rl/trunk: . engine/ai/src	engine/core/include engine/core/src engine/rules/include	engine/rules/src engine/script/src engine/ui/include engine/ui/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4755%20-%20in%20rl/trunk%3A%20.%20engine/ai/src%0A%09engine/core/include%20engine/core/src%20engine/rules/include%0A%09engine/rules/src%20engine/script/src%20engine/ui/include%20engine/ui/src&In-Reply-To=%3C200902092057.n19Kv8Zm021425%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001811.html">
   <LINK REL="Next"  HREF="001813.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4755 - in rl/trunk: . engine/ai/src	engine/core/include engine/core/src engine/rules/include	engine/rules/src engine/script/src engine/ui/include engine/ui/src</H1>
    <B>melven at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4755%20-%20in%20rl/trunk%3A%20.%20engine/ai/src%0A%09engine/core/include%20engine/core/src%20engine/rules/include%0A%09engine/rules/src%20engine/script/src%20engine/ui/include%20engine/ui/src&In-Reply-To=%3C200902092057.n19Kv8Zm021425%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4755 - in rl/trunk: . engine/ai/src	engine/core/include engine/core/src engine/rules/include	engine/rules/src engine/script/src engine/ui/include engine/ui/src">melven at mail.berlios.de
       </A><BR>
    <I>Mon Feb  9 21:57:08 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001811.html">[Dsa-hl-svn] r4754 - in rl/branches/newton20/engine: core/include	ui/include
</A></li>
        <LI>Next message: <A HREF="001813.html">[Dsa-hl-svn] r4756 - modules/common/gui/windows
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1812">[ date ]</a>
              <a href="thread.html#1812">[ thread ]</a>
              <a href="subject.html#1812">[ subject ]</a>
              <a href="author.html#1812">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: melven
Date: 2009-02-09 21:56:41 +0100 (Mon, 09 Feb 2009)
New Revision: 4755

Modified:
   rl/trunk/CMakeLists.txt
   rl/trunk/engine/ai/src/PhysicalObstacle.cpp
   rl/trunk/engine/core/include/Actor.h
   rl/trunk/engine/core/include/GameEventManager.h
   rl/trunk/engine/core/include/GameLoop.h
   rl/trunk/engine/core/include/PhysicalThing.h
   rl/trunk/engine/core/include/PhysicsController.h
   rl/trunk/engine/core/include/PhysicsGenericContactCallback.h
   rl/trunk/engine/core/include/PhysicsManager.h
   rl/trunk/engine/core/include/PhysicsMaterialRaycast.h
   rl/trunk/engine/core/include/SaveAbleFactory.h
   rl/trunk/engine/core/include/SoundManager.h
   rl/trunk/engine/core/src/Actor.cpp
   rl/trunk/engine/core/src/ActorManager.cpp
   rl/trunk/engine/core/src/CoreSubsystem.cpp
   rl/trunk/engine/core/src/DotSceneLoader.cpp
   rl/trunk/engine/core/src/GameAreaTypes.cpp
   rl/trunk/engine/core/src/GameEventManager.cpp
   rl/trunk/engine/core/src/GameLoop.cpp
   rl/trunk/engine/core/src/ListenerObject.cpp
   rl/trunk/engine/core/src/PhysicalThing.cpp
   rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp
   rl/trunk/engine/core/src/PhysicsManager.cpp
   rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp
   rl/trunk/engine/core/src/SoundObject.cpp
   rl/trunk/engine/rules/include/AbstractMovement.h
   rl/trunk/engine/rules/include/CreatureController.h
   rl/trunk/engine/rules/include/CreatureControllerManager.h
   rl/trunk/engine/rules/src/CreatureController.cpp
   rl/trunk/engine/rules/src/CreatureControllerManager.cpp
   rl/trunk/engine/rules/src/JumpHighMovement.cpp
   rl/trunk/engine/rules/src/JumpLongMovement.cpp
   rl/trunk/engine/rules/src/StepRecognitionMovement.cpp
   rl/trunk/engine/script/src/EntityNodeProcessor.cpp
   rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
   rl/trunk/engine/ui/include/CombatControlState.h
   rl/trunk/engine/ui/include/Console.h
   rl/trunk/engine/ui/include/FreeflightControlState.h
   rl/trunk/engine/ui/include/ItemDescriptionDragContainer.h
   rl/trunk/engine/ui/include/ItemDragContainer.h
   rl/trunk/engine/ui/include/ItemIconDragContainer.h
   rl/trunk/engine/ui/include/MovementControlState.h
   rl/trunk/engine/ui/include/WindowFadeJob.h
   rl/trunk/engine/ui/src/CombatControlState.cpp
   rl/trunk/engine/ui/src/CombatGui.cpp
   rl/trunk/engine/ui/src/Console.cpp
   rl/trunk/engine/ui/src/ContainerContentWindow.cpp
   rl/trunk/engine/ui/src/FreeflightControlState.cpp
   rl/trunk/engine/ui/src/InventoryWindow.cpp
   rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp
   rl/trunk/engine/ui/src/ItemDragContainer.cpp
   rl/trunk/engine/ui/src/ItemIconDragContainer.cpp
   rl/trunk/engine/ui/src/MovementControlState.cpp
   rl/trunk/engine/ui/src/UiSubsystem.cpp
   rl/trunk/engine/ui/src/WindowFactory.cpp
   rl/trunk/engine/ui/src/WindowFadeJob.cpp
Log:
MOVED TO NEWTON20
(merged newton20 branch)


Modified: rl/trunk/CMakeLists.txt
===================================================================
--- rl/trunk/CMakeLists.txt	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/CMakeLists.txt	2009-02-09 20:56:41 UTC (rev 4755)
@@ -29,7 +29,7 @@
 FIND_PACKAGE(OIS REQUIRED)
 FIND_PACKAGE(CEGUI REQUIRED)
 FIND_PACKAGE(CEGUIOGRE 1.6 REQUIRED)
-FIND_PACKAGE(OgreNewt 1.53 REQUIRED)
+FIND_PACKAGE(OgreNewt 2.0 REQUIRED)
 FIND_PACKAGE(OpenSteer REQUIRED)
 FIND_PACKAGE(MeshMagick 0.5 REQUIRED)
 FIND_PACKAGE(Ruby REQUIRED)
@@ -39,6 +39,10 @@
 	SET_FEATURE_INFO(SWIG &quot;&quot; &quot;&quot; &quot;You use an unsupported version of SWIG.&quot;)
 ENDIF(NOT SWIG_DIR MATCHES -rl$)
 
+# Compile settings for build types
+SET(CMAKE_CXX_FLAGS_DEBUG &quot;-O0 -g -DDEBUG&quot;)
+SET(CMAKE_CXX_FLAGS_RELWITHDEBINFO &quot;-O2 -g -DDEBUG&quot;)
+
 # Path options
 SET(BINDIR &quot;bin&quot; CACHE STRING &quot;Where to install binaries&quot;)
 SET(DATAROOTDIR &quot;${CMAKE_INSTALL_PREFIX}/share&quot; CACHE STRING &quot;Sets the root of data directories to a non-default location&quot;)

Modified: rl/trunk/engine/ai/src/PhysicalObstacle.cpp
===================================================================
--- rl/trunk/engine/ai/src/PhysicalObstacle.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ai/src/PhysicalObstacle.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -70,8 +70,8 @@
         Quaternion orientation;
         body-&gt;getPositionOrientation(position, orientation);
 
-    	OgreNewt::CollisionPtr collision = body-&gt;getCollision();
-    	RlAssert(collision.getPointer(), &quot;Body has no collision!&quot;);
+    	const OgreNewt::Collision* collision = body-&gt;getCollision();
+    	RlAssert(collision, &quot;Body has no collision!&quot;);
     	AxisAlignedBox box = collision-&gt;getAABB();
     	Ogre::Vector3 dims = box.getMaximum() - box.getMinimum();
     	OpenSteer::BoxObstacle *obstacle = new OpenSteer::BoxObstacle(dims[0], dims[1], dims[2]);

Modified: rl/trunk/engine/core/include/Actor.h
===================================================================
--- rl/trunk/engine/core/include/Actor.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/Actor.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -144,6 +144,9 @@
         /// Gibt die aktuelle Position des Aktors relativ zur Welt zur&#252;ck
         const Ogre::Vector3&amp; getWorldPosition(void) const;
 
+        /// Ermittelt die aktuelle Geschwindigkeit des Actors, falls moeglich
+        const Ogre::Vector3 getVelocity() const;
+
         /// Setzt die Position des Aktors relativ zu seinem Parent
         void setPosition(const Ogre::Vector3&amp; vec);
         /// Setzt die Position des Aktors relativ zu seinem Parent

Modified: rl/trunk/engine/core/include/GameEventManager.h
===================================================================
--- rl/trunk/engine/core/include/GameEventManager.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/GameEventManager.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -130,8 +130,8 @@
 	void removeQueuedDeletionSources();
 
 
-    /// newton collision callback function
-    int userProcess();
+    /// newton collision callback functions
+    void userProcess(OgreNewt::ContactJoint &amp;contactJoint, Ogre::Real timestep, int threadid);
 
     /// notify about newton world update
     void notifyNewtonWorldUpdate();

Modified: rl/trunk/engine/core/include/GameLoop.h
===================================================================
--- rl/trunk/engine/core/include/GameLoop.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/GameLoop.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -116,6 +116,7 @@
     unsigned long mSmoothedFrames;
     /// Time cap for frame time, to prevent interpolation problems during spikes.
     Ogre::Real mMaxFrameTime;
+    Ogre::Real mMinFrameTime;
     bool mQuitRequested;
     bool mPaused;
 

Modified: rl/trunk/engine/core/include/PhysicalThing.h
===================================================================
--- rl/trunk/engine/core/include/PhysicalThing.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/PhysicalThing.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -120,7 +120,7 @@
         void _detachFromSceneNode(Ogre::SceneNode* node);
 
 		/** ForceCallback for mBody (OgreNewt::Body). */
-        void onApplyForceAndTorque();
+        void onApplyForceAndTorque(float timeStep);
         void addForce(const Ogre::Vector3&amp; force);
 
         void freeze();

Modified: rl/trunk/engine/core/include/PhysicsController.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsController.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/PhysicsController.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -39,7 +39,7 @@
 		 * to be applied to the associated PhysicalThing object.
 		 * @param thing PhysicalThing to apply force and torque to.
 		 */
-        virtual void OnApplyForceAndTorque(PhysicalThing* thing) = 0;
+        virtual void OnApplyForceAndTorque(PhysicalThing* thing, float timestep) = 0;
     };
 }
 

Modified: rl/trunk/engine/core/include/PhysicsGenericContactCallback.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsGenericContactCallback.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/PhysicsGenericContactCallback.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -31,12 +31,20 @@
     class _RlCoreExport PhysicsGenericContactCallback : public OgreNewt::ContactCallback
     {
     public:
-        int userBegin();
-        int userProcess();
-        /// This function calls the contact listeners. So any specialised listener overriding
-        /// this one, has to call it explicitly.
-        void userEnd();
-    private:
+        /*!
+         * this function is called, when the aabbs of two bodies overlap, return 0 to indicate, that no contact calculation
+         * should be initiated.
+         * ATTENTION: if 0 is returned, the contact-listeners cannot be called!
+        */
+        virtual int onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1,  int threadindex) { return 1; }
+
+        /*!
+         * process user defined contact forces (etc) here
+        */
+        virtual void userProcess( OgreNewt::ContactJoint &amp;contactJoint, Ogre::Real timeStep, int threadid) {}
+
+        //! this function must not be overwritten!
+        void contactsProcess( OgreNewt::ContactJoint &amp;contactJoint, Ogre::Real timeStep, int threadid );
     };
 }
 

Modified: rl/trunk/engine/core/include/PhysicsManager.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsManager.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/PhysicsManager.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -30,7 +30,6 @@
 
 namespace OgreNewt {
     class Body;
-    class Debugger;
     class MaterialID;
     class MaterialPair;
     class World;
@@ -137,17 +136,17 @@
 		/// Komplette Levelgeometrie aufl&#246;sen
 		void clearLevelGeometry();
 		
-		void toggleDebugMode();
-        bool isDebugMode() const;
+	void toggleDebugMode();
+        int isDebugMode() const;
 
         // Newton callbacks ...
         /// generic force callback. Gravity is applied and the force,
         /// applied via PhysicalThing interface.
-        static void genericForceCallback(OgreNewt::Body* body);
+        static void genericForceCallback(OgreNewt::Body* body, float timeStep, int threadIndex);
 
         /// special force callback for controlled characters (or monsters even)
         /// those bodies have up vector and are controlled using inverse dynamics
-        static void controlledForceCallback(OgreNewt::Body* body);
+        static void controlledForceCallback(OgreNewt::Body* body, float timeStep, int threadIndex);
 
         OgreNewt::World* _getNewtonWorld() const;
 
@@ -277,7 +276,7 @@
         static Ogre::String convertGeometryTypeToString(const GeometryType&amp; geomType);
 
         /// returns newton debugger
-        OgreNewt::Debugger* getNewtonDebugger() {return mNewtonDebugger;}
+        OgreNewt::Debugger* getNewtonDebugger() {return &amp;mWorld-&gt;getDebugger();}
 
     private:
 
@@ -288,6 +287,7 @@
         struct CollisionInUse
         {
         public:
+            CollisionInUse() : colPtr(NULL), geomType(GT_NONE) {}
             GeometryType geomType;  //! primitive type
             OgreNewt::CollisionPtr colPtr;          //! the collision primitve
         };
@@ -302,9 +302,8 @@
         bool mEnabled;
         //! the globally used physical representation of the world by Newton
         OgreNewt::World* mWorld;
-        //! the visualisation for physical behaviour (actually not the best)
-        OgreNewt::Debugger* mNewtonDebugger;
-        bool mDebugMode;
+        //! debug mode: 0 no debugging, 1 show debug lines (freezed state), 2 show debug lines (update every frame), 3 show raycasts from one frame, 4 upda raycasts every frame
+        int mDebugMode;
 
         //! factory for creating new collision primitives
         PhysicsCollisionFactory* mPhysicsCollisionFactory;

Modified: rl/trunk/engine/core/include/PhysicsMaterialRaycast.h
===================================================================
--- rl/trunk/engine/core/include/PhysicsMaterialRaycast.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/PhysicsMaterialRaycast.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -33,11 +33,12 @@
     {
         RaycastInfo() : mDistance(), mBody(), mNormal() {}
         /// dist from point1 of the raycast, in range [0,1].
-        Ogre::Real mDistance;	
+        Ogre::Real mDistance;
         /// pointer to body intersected with
         OgreNewt::Body* mBody;
         /// normal of intersection.
         Ogre::Vector3 mNormal;
+        // the collisionID for compound collisions could be added here, but we didn't need them yet
     };
 
     class _RlCoreExport PhysicsMaterialRaycast : OgreNewt::Raycast
@@ -64,18 +65,76 @@
         * If this param is NULL, every material will be found
         * @param startpt start-point of the cast
         * @param endpt end-point of the cast
+        * @param invertmat if &quot;true&quot;, the ray finds all collisions, which do NOT have the material-id &quot;material&quot;
         */
         RaycastInfo execute(OgreNewt::World* world, const MaterialVector* materials,
             const Ogre::Vector3&amp; startpt, const Ogre::Vector3&amp; endpt, bool invertmat = false);
 
         bool userCallback(OgreNewt::Body* body, Ogre::Real distance, const Ogre::Vector3&amp; normal, int collisionID);
+
+
+        bool userPreFilterCallback( OgreNewt::Body *body );  // filtering is now done here!
     private:
         RaycastInfo mInfo;
         const MaterialVector *mMaterialVector;
         const OgreNewt::MaterialID* mMaterial;
-        bool mGetNearest;
         bool mInvertMat;
     };
+
+
+
+// --------------------------------------------------------------------------------------
+
+    // we can use the info-class from OgreNewt
+    class _RlCoreExport ConvexcastInfo : public OgreNewt::BasicConvexcast::ConvexcastContactInfo
+    {
+        public:
+            ConvexcastInfo(const OgreNewt::BasicConvexcast::ConvexcastContactInfo&amp; info);
+            Ogre::Real mDistance;
+    };
+
+    class _RlCoreExport PhysicsMaterialConvexcast : public OgreNewt::BasicConvexcast
+    {
+    public:
+        typedef std::vector&lt;const OgreNewt::MaterialID*&gt; MaterialVector;
+
+        PhysicsMaterialConvexcast();
+
+        /** executes the Convexcast
+        * @param world OgreNewt-World
+        * @param material The material, which will be found by the raycast.
+        * If this param is NULL, every material will be found
+        * @param col the collisions representing a convex shape used for the cast
+        * @param startpt start-point of the cast
+        * @param ori the orientation of the collision in global space
+        * @param endpt end-point of the cast
+        * @param invertmat if &quot;true&quot;, the ray finds all collisions, which do NOT have the material-id &quot;material&quot;
+        */
+        ConvexcastInfo execute(OgreNewt::World* world, const OgreNewt::MaterialID* material,
+            const OgreNewt::Collision *col, const Ogre::Vector3&amp; startpt, const Ogre::Quaternion &amp;ori,
+            const Ogre::Vector3&amp; endpt, bool invertmat = false);
+        
+        /** executes the Convexcast
+        * @param world OgreNewt-World
+        * @param materials a vector with pairs of a material and a boolean value, that describes if this material should be matched or not
+        * If this param is NULL, every material will be found
+        * @param col the collisions representing a convex shape used for the cast
+        * @param startpt start-point of the cast
+        * @param ori the orientation of the collision in global space
+        * @param endpt end-point of the cast
+        * @param invertmat if &quot;true&quot;, the ray finds all collisions, which do NOT have the material-id &quot;material&quot;
+        */
+        ConvexcastInfo execute(OgreNewt::World* world, const MaterialVector* materials,
+            const OgreNewt::Collision *col, const Ogre::Vector3&amp; startpt, const Ogre::Quaternion &amp;ori,
+            const Ogre::Vector3&amp; endpt, bool invertmat = false);
+
+
+        bool userPreFilterCallback( OgreNewt::Body *body );
+    private:
+        const MaterialVector *mMaterialVector;
+        const OgreNewt::MaterialID* mMaterial;
+        bool mInvertMat;
+    };
 }
 
 #endif

Modified: rl/trunk/engine/core/include/SaveAbleFactory.h
===================================================================
--- rl/trunk/engine/core/include/SaveAbleFactory.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/SaveAbleFactory.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -41,3 +41,4 @@
 }
 
 #endif
+

Modified: rl/trunk/engine/core/include/SoundManager.h
===================================================================
--- rl/trunk/engine/core/include/SoundManager.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/include/SoundManager.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -83,7 +83,7 @@
         Ogre::NameValuePairList getSettings() const;
 
         /// 3D-Sound aktualisieren.
-        void update();
+        //void update(); // there is no implementation of this function and it is never used!
         /// Den aktiven Treiber zurckgeben.
         SoundDriver* getActiveDriver() const;
         /// Den aktiven Treiber setzen.

Modified: rl/trunk/engine/core/src/Actor.cpp
===================================================================
--- rl/trunk/engine/core/src/Actor.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/Actor.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -317,6 +317,10 @@
         {
             return mBone-&gt;getPosition();
         }
+        else if (mParent)
+        {
+            return mParent-&gt;getPosition();
+        }
         else
         {
             return Vector3::ZERO;
@@ -326,6 +330,22 @@
         }
     }
 
+    const Vector3 Actor::getVelocity() const
+    {
+        if (mPhysicalThing)
+        {
+            return mPhysicalThing-&gt;getVelocity();
+        }
+        else if ( mParent )
+        {
+            return mParent-&gt;getVelocity();
+        }
+        else
+        {
+            return Vector3::ZERO;
+        }
+    }
+
     const Quaternion&amp; Actor::getOrientation(void) const
     {
         if (mSceneNode)
@@ -336,6 +356,10 @@
         {
             return mBone-&gt;getOrientation();
         }
+        else if (mParent)
+        {
+            return mParent-&gt;getOrientation();
+        }
         else
         {
             return Quaternion::IDENTITY;
@@ -355,6 +379,10 @@
         {
             return mBone-&gt;_getDerivedPosition();
         }
+        else if (mParent)
+        {
+            return mParent-&gt;getWorldPosition();
+        }
         else
         {
             return Vector3::ZERO;
@@ -417,6 +445,10 @@
         {
             return mBone-&gt;_getDerivedOrientation();
         }
+        else if (mParent)
+        {
+            return mParent-&gt;getWorldOrientation();
+        }
         else
         {
             Throw(IllegalStateException,
@@ -533,6 +565,7 @@
         // Erst danach Parent/Child wirklich zuweisen, falls es eine Exception gibt.
         actor-&gt;mParent = this;
         mChildren.insert(actor);
+        actor-&gt;_update();
     }
 
     void Actor::attachToSlotAxisRot(

Modified: rl/trunk/engine/core/src/ActorManager.cpp
===================================================================
--- rl/trunk/engine/core/src/ActorManager.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/ActorManager.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -291,9 +291,11 @@
         try
         {
             CameraObject* co = new CameraObject(uniquename);
+            // the mass should be as small as possible, so the camera doesn't interact with other bodies,
+            // but setting the mass to 0 means, that the body is static!
             PhysicalThing* pt = PhysicsManager::getSingleton()
                 .createPhysicalThing(GT_SPHERE, co,
-                100.0f, true);
+                0.001f, true);
             PhysicsManager::getSingleton().createPhysicsProxy(pt, NULL);
             pt-&gt;_getBody()-&gt;setMaterialGroupID(
                 PhysicsManager::getSingleton().createMaterialID(&quot;camera&quot;));

Modified: rl/trunk/engine/core/src/CoreSubsystem.cpp
===================================================================
--- rl/trunk/engine/core/src/CoreSubsystem.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/CoreSubsystem.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -283,7 +283,7 @@
         mWorld = new DotSceneOctreeWorld();
         mActorManager-&gt;setWorld(mWorld);
 
-        mPhysicsManager = new PhysicsManager();
+        mPhysicsManager = new PhysicsManager();  // the World needs to be initialized before!
         GameLoop::getSingleton().addTask(mPhysicsManager, GameLoop::TG_PHYSICS);
         LOG_MESSAGE(Logger::CORE,&quot;PhysicsManager erzeugt&quot;);
 

Modified: rl/trunk/engine/core/src/DotSceneLoader.cpp
===================================================================
--- rl/trunk/engine/core/src/DotSceneLoader.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/DotSceneLoader.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -492,7 +492,7 @@
                 child = child-&gt;getNextSibling();
                 continue;
             }
-            collision.setNull();
+            collision = NULL;
             // am Anfang steht ein Node mit dem Typ
             std::string typeAsString = transcodeToStdString(child-&gt;getNodeName());
 
@@ -701,21 +701,21 @@
                 {
                     LOG_MESSAGE(Logger::CORE,
                         &quot; Mesh-Collisions in &lt;collisions&gt; werden momentan noch nicht unterst&#252;tzt (Eintrag wird ignoriert).&quot;);
-                    collision.setNull();
+                    collision = NULL;
                 }
 /*
                 else if (typeAsString.compare(&quot;meshhull&quot;) == 0)  // automatische convexhull mit daten aus mesh
                 {
                     LOG_MESSAGE(Logger::CORE,
                         &quot; Entityhull-Collisions werden momentan noch nicht unterst&#252;tzt (Eintrag wird ignoriert).&quot;);
-                    collision.setNull();
+                    collision = NULL;
                 }
 */
                 else
                 {
                     LOG_MESSAGE(Logger::CORE,
                         &quot; &gt; Parse Error beim Erstellen einer Collision; ung&#252;ltiger typ: '&quot;+typeAsString+&quot;' !&quot;);
-                    collision.setNull();
+                    collision = NULL;
                     //return OgreNewt::CollisionPtr(NULL);
                 }
 
@@ -723,7 +723,7 @@
 
 
             // Collision dem vektor hinzuf&#252;gen
-            if (!collision.isNull())
+            if (collision != NULL)
                 mCollisions.push_back(collision);
 
             child = child-&gt;getNextSibling();
@@ -870,15 +870,13 @@
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
                                     thisWorld,
-                                    newEnt,
-                                    false));
-                    //orientation, pos));
+                                    newEnt));
                     LOG_DEBUG(Logger::CORE, &quot; physical_body 'convexhull' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
                 }
                 else if (physical_body.compare(&quot;mesh&quot;) == 0 || physical_body.compare(&quot;auto&quot;))
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
-                                    thisWorld, newEnt, false));
+                                    thisWorld, newEnt, true));
                     LOG_DEBUG(Logger::CORE, &quot; physical_body 'mesh' f&#252;r Entity '&quot;+entName+&quot;' erstellt. &quot;);
                 }
                 else
@@ -893,7 +891,7 @@
         }
 
         // zur liste hinzuf&#252;gen
-        if (!collision.isNull())
+        if (collision != NULL)
         {
             mCollisions.push_back(collision);
         }
@@ -908,7 +906,7 @@
 
 
         // wieder aus der liste entfernen, falls mehrere entities hier definiert werden
-        if (!collision.isNull())
+        if (collision != NULL)
         {
             mCollisions.pop_back();
         }

Modified: rl/trunk/engine/core/src/GameAreaTypes.cpp
===================================================================
--- rl/trunk/engine/core/src/GameAreaTypes.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/GameAreaTypes.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -207,7 +207,7 @@
                 mBody-&gt;getCollision(), orientationA, positionA,
                 actor-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getCollision(),
                 actor-&gt;getOrientation(), actor-&gt;getPosition(),
-                retA, retB, retNorm);
+                retA, retB, retNorm, 0); // set threadindex to 0, I hope this is ok!
 
         if( intRet == 0 )
             return 0;
@@ -245,6 +245,7 @@
         mBody-&gt;setMaterialGroupID(
             PhysicsManager::getSingleton().getMaterialID(&quot;gamearea&quot;));
         mBody-&gt;setUserData(NULL);
+        ((OgreNewt::ConvexCollision*)col)-&gt;setAsTriggerVolume(true);
     }
 
     GameSimpleCollisionAreaType::GameSimpleCollisionAreaType(
@@ -262,6 +263,7 @@
         mBody-&gt;setMaterialGroupID(
             PhysicsManager::getSingleton().getMaterialID(&quot;gamearea&quot;));
         mBody-&gt;setUserData(NULL);
+        ((OgreNewt::ConvexCollision*)col)-&gt;setAsTriggerVolume(true);
     }
 
 }

Modified: rl/trunk/engine/core/src/GameEventManager.cpp
===================================================================
--- rl/trunk/engine/core/src/GameEventManager.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/GameEventManager.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -275,24 +275,28 @@
         return NAME;
     }
 
-    int GameEventManager::userProcess()
+    void GameEventManager::userProcess(OgreNewt::ContactJoint &amp;contactJoint, Real timestep, int)
     {
-        NewtonBodyGameAreaMap::iterator it = mBodyGameAreaMap.find(m_body0);
+        OgreNewt::Body* body0 = contactJoint.getBody0();
+        OgreNewt::Body* body1 = contactJoint.getBody1();
+
+        NewtonBodyGameAreaMap::iterator it = mBodyGameAreaMap.find(body0);
         if( it != mBodyGameAreaMap.end() )
         {
-            it-&gt;second-&gt;foundCollision(bodyToActor(m_body1));
-            return false;
+            it-&gt;second-&gt;foundCollision(bodyToActor(body1));
+            return;
         }
 
-        it = mBodyGameAreaMap.find(m_body1);
+        it = mBodyGameAreaMap.find(body1);
         if( it != mBodyGameAreaMap.end() )
         {
-            it-&gt;second-&gt;foundCollision(bodyToActor(m_body0));
-            return 0;
+            it-&gt;second-&gt;foundCollision(bodyToActor(body0));
+            return;
         }
 
         LOG_WARNING(Logger::CORE, &quot;Der Kollisionsk&#246;rper konnte keiner GameArea zugeordnet werden!&quot;);
-        return 0;
+
+        // there should be no contacts (trigger-volume!), so we don't need to do anything here!
     }
 
     void GameEventManager::notifyNewtonWorldUpdate()

Modified: rl/trunk/engine/core/src/GameLoop.cpp
===================================================================
--- rl/trunk/engine/core/src/GameLoop.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/GameLoop.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -40,6 +40,7 @@
           mLastTimes(),
           mSmoothedFrames(3),
           mMaxFrameTime(0.1f),
+          mMinFrameTime(1.0/60),
           mQuitRequested(false),
           mPaused(false)
     {
@@ -138,6 +139,16 @@
         if( elapsedTime &lt; mGameTime )
             unsmoothedFrameTime = 1;
 
+        if( unsmoothedFrameTime &lt; mMinFrameTime*1000 )
+        {
+            usleep(floor(1000*(mMinFrameTime*1000 - unsmoothedFrameTime)));
+            elapsedTime = mTimer-&gt;getMilliseconds();
+            unsmoothedFrameTime = elapsedTime - mGameTime;
+            if( elapsedTime &lt; mGameTime )
+                unsmoothedFrameTime = 1;
+        }
+
+
         if( unsmoothedFrameTime &gt; mMaxFrameTime*1000 )
         {
             LOG_DEBUG(Logger::CORE, &quot;The current frame time was truncated at maximum.&quot;);

Modified: rl/trunk/engine/core/src/ListenerObject.cpp
===================================================================
--- rl/trunk/engine/core/src/ListenerObject.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/ListenerObject.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -71,7 +71,8 @@
         return;
     }
     listener-&gt;setPosition(actor-&gt;getWorldPosition());
-	listener-&gt;setOrientation(actor-&gt;getWorldOrientation());
+    listener-&gt;setOrientation(actor-&gt;getWorldOrientation());
+    listener-&gt;setVelocity(actor-&gt;getVelocity());
     LOG_DEBUG(Logger::CORE, &quot;Pos Listener: &quot;
         + StringConverter::toString(actor-&gt;getWorldPosition().x) + &quot; &quot;
         + StringConverter::toString(actor-&gt;getWorldPosition().y) + &quot; &quot;
@@ -81,8 +82,6 @@
         + StringConverter::toString(actor-&gt;getWorldOrientation().x) + &quot; &quot;
         + StringConverter::toString(actor-&gt;getWorldOrientation().y) + &quot;, &quot;
         + StringConverter::toString(actor-&gt;getWorldOrientation().z));
-//    listener-&gt;setOrientation(*temp1, *temp1);
-    // TODO Orientation korrigieren
 }
 
 /**

Modified: rl/trunk/engine/core/src/PhysicalThing.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicalThing.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/PhysicalThing.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -145,7 +145,7 @@
 
     void PhysicalThing::_attachToSceneNode(Ogre::SceneNode* node)
     {
-        mBody-&gt;attachToNode(node);
+        mBody-&gt;attachNode(node);
     }
 
     void PhysicalThing::_attachToBone(MeshObject* object, const std::string&amp; boneName )
@@ -189,7 +189,7 @@
         mUpVectorJoint = NULL;
     }
 
-    void PhysicalThing::onApplyForceAndTorque()
+    void PhysicalThing::onApplyForceAndTorque(float timestep)
     {
         Vector3 gravity = mOverrideGravity ?
             mGravity : PhysicsManager::getSingleton().getGravity();
@@ -210,8 +210,10 @@
 
     void PhysicalThing::setMass(Ogre::Real mass)
     {
+        Vector3 inertia;
+        mBody-&gt;getMassMatrix(mMass, inertia);
         mMass = mass;
-        mBody-&gt;setMass(mass);
+        mBody-&gt;setMassMatrix(mass, inertia);
     }
 
     void PhysicalThing::setGravityOverride(bool override, const Vector3&amp; gravity)
@@ -297,7 +299,7 @@
 		else if (mGeometryType == GT_MESH)
 		{
 	        CollisionPtr collision(new TreeCollision(
-				PhysicsManager::getSingleton()._getNewtonWorld(), entity, false));
+				PhysicsManager::getSingleton()._getNewtonWorld(), entity, true));
 		    mBody-&gt;setCollision(collision);
 		}
 
@@ -482,7 +484,7 @@
         {
             // prepare for control
             mPhysicsController = controller;
-            mBody-&gt;setAutoFreeze(0);
+            //mBody-&gt;setAutoFreeze(0);
             mBody-&gt;unFreeze();
             mBody-&gt;setLinearDamping(0.0f);
             mBody-&gt;setAngularDamping(Vector3::ZERO);

Modified: rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/PhysicsGenericContactCallback.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -20,22 +20,17 @@
 #include &quot;Actor.h&quot;
 #include &quot;PhysicalThing.h&quot;
 
+
+using namespace Ogre;
+
 namespace rl
 {
-    int PhysicsGenericContactCallback::userBegin()
+    void PhysicsGenericContactCallback::contactsProcess(OgreNewt::ContactJoint &amp;contactJoint, Real timestep, int threadid)
     {
-        return 1;
-    }
+        userProcess(contactJoint, timestep, threadid);
 
-    int PhysicsGenericContactCallback::userProcess()
-    {
-        return 1;
-    }
-
-    void PhysicsGenericContactCallback::userEnd()
-    {
-        Actor* a1 = static_cast&lt;Actor*&gt;(m_body0-&gt;getUserData());
-        Actor* a2 = static_cast&lt;Actor*&gt;(m_body1-&gt;getUserData());
+        Actor* a1 = static_cast&lt;Actor*&gt;(contactJoint.getBody0()-&gt;getUserData());
+        Actor* a2 = static_cast&lt;Actor*&gt;(contactJoint.getBody1()-&gt;getUserData());
         if (a1 &amp;&amp; a1-&gt;getPhysicalThing()-&gt;getContactListener())
         {
             a1-&gt;getPhysicalThing()-&gt;getContactListener()-&gt;

Modified: rl/trunk/engine/core/src/PhysicsManager.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsManager.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/PhysicsManager.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -70,9 +70,8 @@
 
     PhysicsManager::PhysicsManager( )
         : mEnabled(false),
-        mNewtonDebugger(&amp;OgreNewt::Debugger::getSingleton()),
         mPhysicalThings(),
-        mDebugMode(false),
+        mDebugMode(0),
         mGravity(0, -9.81, 0),
         mTimeFactor(1.0f),
         mWorldAABB(Vector3(-100, -100, -100), Vector3(100, 100, 100)),
@@ -99,8 +98,9 @@
         // setup level material
         createMaterialID(&quot;level&quot;);
 
-        mNewtonDebugger-&gt;setMaterialColor(getMaterialID(&quot;level&quot;), Ogre::ColourValue::Blue);
+        mWorld-&gt;getDebugger().setMaterialColor(getMaterialID(&quot;level&quot;), Ogre::ColourValue::Blue);
 
+
         // below here starts 'old' stale fix code that should be removed
 
         // setup level quadtree extents
@@ -132,6 +132,8 @@
         }
         mMaterials.clear();
 
+        mWorld-&gt;getDebugger().deInit();
+
         delete mPhysicsCollisionFactory;
         delete mGenericCallback;
         delete mWorld;
@@ -148,6 +150,12 @@
         //NewtonSetMinimumFrameRate(mWorld-&gt;getNewtonWorld(), 1./mMaxTimestep);
 
 
+        if( mDebugMode == 4 )
+        {
+            mWorld-&gt;getDebugger().clearRaycastsRecorded();
+        }
+
+
         // Newton kann timesteps zwischen 1/20 und 1/600!
         mElapsed += elapsedTime * mTimeFactor;
         while( mElapsed &gt;= mMaxTimestep)
@@ -156,6 +164,7 @@
             // know if it's really neccessary
             GameEventManager::getSingleton().notifyNewtonWorldUpdate();
 
+
             mWorld-&gt;update(mMaxTimestep);
             mElapsed-=mMaxTimestep;
 #ifdef _DEBUG
@@ -165,7 +174,10 @@
                     &quot;Omega  Force  Torque  NewtonBodyGetSleepingState  NewtonBodyGetAutoFreeze  &quot;\
                     &quot;NewtonBodyGetContinuousCollisionMode  ( invMass  invIxx  invIyy  invIzz )&quot;);
                 if( Logger::getSingleton().getLogDetail() &lt;= Logger::LL_DEBUG )
-                    NewtonWorldForEachBodyDo(mWorld-&gt;getNewtonWorld(), newtonPerBodyLogProperties);
+                for( const NewtonBody* body = NewtonWorldGetFirstBody(mWorld-&gt;getNewtonWorld());
+                     body != NULL;
+                     body = NewtonWorldGetNextBody(mWorld-&gt;getNewtonWorld(), body)  )
+                    newtonPerBodyLogProperties(body);
             }
 #endif
         }
@@ -183,10 +195,23 @@
                 LOG_DEBUG(Logger::CORE, &quot;\tNewtonBodyLog: &amp;Body  Position  Orientation  Velocity  &quot;\
                     &quot;Omega  Force  Torque  NewtonBodyGetSleepingState  NewtonBodyGetAutoFreeze  &quot;\
                     &quot;NewtonBodyGetContinuousCollisionMode  ( invMass  invIxx  invIyy  invIzz )&quot;);
-                if( Logger::getSingleton().getLogDetail() &lt;= Logger::LL_DEBUG )
-                    NewtonWorldForEachBodyDo(mWorld-&gt;getNewtonWorld(), newtonPerBodyLogProperties);            }
+                for( const NewtonBody* body = NewtonWorldGetFirstBody(mWorld-&gt;getNewtonWorld());
+                     body != NULL;
+                     body = NewtonWorldGetNextBody(mWorld-&gt;getNewtonWorld(), body)  )
+                    newtonPerBodyLogProperties(body);
+            }
 #endif
         }
+
+
+        if( mDebugMode == 2 )
+        {
+            mWorld-&gt;getDebugger().showDebugInformation();
+        }
+        else if( mDebugMode == 3 )
+        {
+            mWorld-&gt;getDebugger().stopRaycastRecording();
+        }
     }
 
 #ifdef _DEBUG
@@ -269,31 +294,38 @@
         mEnabled = enabled;
     }
 
-    bool PhysicsManager::isDebugMode() const
+    int PhysicsManager::isDebugMode() const
     {
         return mDebugMode;
     }
 
     void PhysicsManager::toggleDebugMode()
     {
-        if (mDebugMode)
-		{
-            mNewtonDebugger-&gt;hideLines();
-		}
-        else
+        mWorld-&gt;getDebugger().init(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager());
+        mDebugMode = (mDebugMode+1)%5;
+        switch(mDebugMode)
         {
-            mNewtonDebugger = &amp;OgreNewt::Debugger::getSingleton();
-
-			try
-			{
-				mNewtonDebugger-&gt;init(
-					CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager());
-			}
-			catch(Ogre::Exception) {}
-
-            mNewtonDebugger-&gt;showLines(mWorld);
+            case 0:
+                mWorld-&gt;getDebugger().stopRaycastRecording();
+                mWorld-&gt;getDebugger().clearRaycastsRecorded();
+                mWorld-&gt;getDebugger().hideDebugInformation();
+                break;
+            case 1:
+                mWorld-&gt;getDebugger().showDebugInformation();
+                break;
+            case 2:
+                break;
+            case 3:
+                mWorld-&gt;getDebugger().startRaycastRecording(true);
+                mWorld-&gt;getDebugger().hideDebugInformation();
+                break;
+            case 4:
+                mWorld-&gt;getDebugger().startRaycastRecording(true);
+                mWorld-&gt;getDebugger().hideDebugInformation();
+                break;
+            default:
+                break;
         }
-        mDebugMode = !mDebugMode;
     }
 
     void PhysicsManager::addLevelGeometry( Ogre::Entity* levelEntity, const std::vector&lt;OgreNewt::CollisionPtr&gt; &amp;collisions)
@@ -303,23 +335,33 @@
 
         SceneNode* node = levelEntity-&gt;getParentSceneNode();
         //Level entity has to be attached to a scene node.
+        
 
-        for( size_t i = 0; i &lt; collisions.size(); i++)
+        // try one compound collision for the entity if there are several collisions
+        OgreNewt::CollisionPtr collision(NULL);
+        switch( collisions.size() )
         {
-		    if( collisions[i].isNull() )
-                continue;
+            case 0:
+                break;
+            case 1:
+                collision = collisions[0];
+                break;
+            default:
+                collision = new OgreNewt::CollisionPrimitives::CompoundCollision(mWorld, collisions);
+                break;
+        }
 
-            OgreNewt::CollisionPtr collision = collisions[i];
+        if( collision )
+        {
+            OgreNewt::Body* body = new OgreNewt::Body(mWorld, collision );
 
-		    OgreNewt::Body* body = new OgreNewt::Body(mWorld, collision );
 
-
-            body-&gt;attachToNode(node);
+            body-&gt;attachNode(node);
             body-&gt;setPositionOrientation(node-&gt;_getDerivedPosition(),
                 node-&gt;_getDerivedOrientation());
             body-&gt;setMaterialGroupID(getMaterialID(&quot;level&quot;));
 
-			mLevelBodiesQuadTree.add(body);
+            mLevelBodiesQuadTree.add(body);
             //mLevelBodies.push_back(body);
         }
 
@@ -364,26 +406,23 @@
 		*/
     }
 
-    // adopted from the chararcter demo in the newton sdk
-    // copyright 2000-2004
-    // By Julio Jerez
-    void PhysicsManager::genericForceCallback(OgreNewt::Body* body)
+    void PhysicsManager::genericForceCallback(OgreNewt::Body* body, float timestep, int)
     {
         // apply saved forces in the PhysicalThing
         PhysicalThing* thing =
             static_cast&lt;Actor*&gt;(body-&gt;getUserData())-&gt;getPhysicalThing();
 
-        thing-&gt;onApplyForceAndTorque();
+        thing-&gt;onApplyForceAndTorque(timestep);
     }
 
-    void PhysicsManager::controlledForceCallback(OgreNewt::Body* body)
+    void PhysicsManager::controlledForceCallback(OgreNewt::Body* body, float timestep, int)
     {
         PhysicalThing* thing =
             static_cast&lt;Actor*&gt;(body-&gt;getUserData())-&gt;getPhysicalThing();
 
         if (thing-&gt;getPhysicsController())
         {
-            thing-&gt;getPhysicsController()-&gt;OnApplyForceAndTorque(thing);
+            thing-&gt;getPhysicsController()-&gt;OnApplyForceAndTorque(thing, timestep);
         }
         else
         {
@@ -460,7 +499,15 @@
     void PhysicsManager::resetMaterialPair(const OgreNewt::MaterialID* M1,
             const OgreNewt::MaterialID* M2)
     {
-        getMaterialPair(M1,M2)-&gt;setContactCallback(mGenericCallback);
+        OgreNewt::MaterialPair *mat_pair = getMaterialPair(M1,M2);
+        mat_pair-&gt;setContactCallback(mGenericCallback);
+        mat_pair-&gt;setContinuousCollisionMode(0);
+        mat_pair-&gt;setDefaultCollidable(1);
+        mat_pair-&gt;setDefaultElasticity(0.4f);
+        mat_pair-&gt;setDefaultSoftness(0.1f);
+        mat_pair-&gt;setDefaultFriction(0.9f, 0.5f);
+        //! TODO find a good value here, until now I hope nobody is changing the default from newton :-P
+        //mat_pair-&gt;setDefaultSurfaceThickness(); 
     }
 
     OgreNewt::CollisionPtr PhysicsManager::createCollision(
@@ -480,7 +527,8 @@
         CollisionInUse &amp;usedcol (mCollisionPrimitives[collisionName]);
         // log some performance warning if collisionname is equal, but geomtype different ?
 
-        if (! usedcol.colPtr.isNull() )
+        if( false )
+//        if ( usedcol.colPtr != NULL )
         {
             if ( usedcol.geomType != geomType )
             {   // when geometry types mismatch, issue performance warning
@@ -495,7 +543,28 @@
 
                 if( inertia )
                 {
+
                     // we must set inertia here, the calling function doesn't know we are not creating a new collision
+                    switch(usedcol.geomType)
+                    {
+                    case GT_BOX: // from createBox
+                    case GT_CAPSULE: // from createCapsule
+                    case GT_CONVEXHULL: // from createCollisionFromEntity
+                    case GT_ELLIPSOID: // from createEllipsoid
+                    case GT_PYRAMID: // createPyramid
+                    case GT_SPHERE:
+                        {
+                            Vector3 inert_offs=Vector3::ZERO;
+                            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
+                            *inertia *= mass;
+                        }
+                        break;
+                    case GT_MESH:
+                    case GT_NONE:
+                        *inertia = Ogre::Vector3::ZERO;
+                        break;
+                    }
+/*
                     Ogre::AxisAlignedBox aabb(entity-&gt;getBoundingBox());
                     Vector3 size( aabb.getSize() );
                     switch(usedcol.geomType)
@@ -539,11 +608,12 @@
                         }
                         break;
                     }
+*/
                 }
             }
         }
 
-        if (rval.isNull())
+//        if ( rval == NULL )
         {
             // if there is none, then create a new collision object
             rval = mPhysicsCollisionFactory-&gt;createCollisionFromEntity(
@@ -568,7 +638,8 @@
         CollisionInUse &amp;usedcol (mCollisionPrimitives[name]);
         // log some performance warning if collisionname is equal, but geomtype different ?
 
-        if (! usedcol.colPtr.isNull() )
+        if( false )
+//        if ( usedcol.colPtr != NULL )
         {
             if ( usedcol.geomType != geomType )
             {   // when geometry types mismatch, issue performance warning
@@ -582,7 +653,7 @@
             }
         }
 
-        if (rval.isNull())
+//        if ( rval == NULL )
         {
             // if there is none, then create a new collision object
             rval = mPhysicsCollisionFactory-&gt;createCollisionFromAABB(
@@ -804,14 +875,13 @@
 			// calculate the convex hull of the animated mesh
 			rval = CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
                 PhysicsManager::getSingleton()._getNewtonWorld(),
-				entity, entity-&gt;hasSkeleton(), *orientation, *offset));
+				entity, /*entity-&gt;hasSkeleton(),*/ *orientation, *offset));
 
 			if (inertia != NULL)
 			{
-				*inertia = Vector3(
-				size.x*size.x/6.0f,
-				size.y*size.y/6.0f,
-				size.z*size.z/6.0f) * Mass;
+                            Vector3 inert_offs=Vector3::ZERO;
+                            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
+                            *inertia *= Mass;
 			}
         }
         else if (geomType == GT_MESH)
@@ -821,14 +891,14 @@
 
             rval = CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
                 PhysicsManager::getSingleton()._getNewtonWorld(),
-                entity, false, true));
+                entity, true ));
         }
         else
         {
             Throw(IllegalArgumentException, &quot;unknown geometry type.&quot;);
         }
 
-        if (rval.isNull())
+        if ( rval == NULL )
         {
             LOG_DEBUG(Logger::CORE, &quot; creating collision primitiv '&quot;+
                 PhysicsManager::convertGeometryTypeToString(geomType)+&quot;' for Entity '&quot;+
@@ -860,13 +930,19 @@
 			offset = &amp;object_offset;
 		if (! orientation)
 			orientation = &amp;object_orientation;
-        if (inertia)
-            *inertia = OgreNewt::MomentOfInertia::CalcBoxSolid(mass, aabb.getSize());
 
-		// a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
-		return CollisionPtr(new OgreNewt::CollisionPrimitives::Box(
+        // a box collision primitiv has got it's coordinate system at it's center, so we need to shift it
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Box(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             aabb.getSize(), *orientation, *offset));
+        if (inertia)
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
+            *inertia *= mass;
+        }
+
+        return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createPyramid(const Ogre::AxisAlignedBox&amp; aabb,
@@ -886,12 +962,18 @@
 			offset = &amp;object_offset;
 		if (! orientation)
 			orientation = &amp;object_orientation;
-        if (inertia)
-            *inertia = Ogre::Vector3(size.x,size.y/2.0f, size.z) * mass;
 
-        return CollisionPtr(new OgreNewt::CollisionPrimitives::Pyramid(
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Pyramid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             size, *orientation, *offset));
+        if (inertia)
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
+            *inertia *= mass;
+        }
+
+        return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createSphere(const Ogre::AxisAlignedBox&amp; aabb,
@@ -914,14 +996,18 @@
 			offset = &amp;object_offset;
 		if (! orientation)
 			orientation = &amp;object_orientation;
+ 
+        // a sphere primitiv has got its coordinate system at its center, so shift it with radius
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
+            PhysicsManager::getSingleton()._getNewtonWorld(),
+            Vector3(radius, radius, radius), *orientation, *offset));
         if (inertia)
-            //*inertia = OgreNewt::MomentOfInertia::CalcSphereSolid(Mass,radius);
-            *inertia = mass * Vector3(radius*radius, radius*radius, radius*radius);
-
-		// a sphere primitiv has got its coordinate system at its center, so shift it with radius
-        return CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
-    		PhysicsManager::getSingleton()._getNewtonWorld(),
-            Vector3(radius, radius, radius), *orientation, *offset));
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
+            *inertia *= mass;
+        }
+        return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createEllipsoid(const Ogre::AxisAlignedBox&amp; aabb,
@@ -945,13 +1031,20 @@
 			offset = &amp;object_offset;
 		if (! orientation)
 			orientation = &amp;object_orientation;
-        if (inertia)
-            *inertia = Vector3(s.x*s.x, s.y*s.y, s.z*s.z) * mass;
 
         // an ellipsoid primitiv has got its coordinate system at its center, so shift it with radius
-        return CollisionPtr(new OgreNewt::CollisionPrimitives::Ellipsoid(
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Ellipsoid(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             s, *orientation, *offset));
+
+        if (inertia)
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
+            *inertia *= mass;
+        }
+
+        return rval;
     }
 
     OgreNewt::CollisionPtr PhysicsCollisionFactory::createCapsule(const Ogre::AxisAlignedBox&amp; aabb,
@@ -975,16 +1068,21 @@
     		offset = &amp;object_offset;
 		if (! orientation)
 			orientation = &amp;object_orientation;
-        if (inertia) {
-            double sradius = radius*radius;
-			*inertia = Vector3(sradius, size.y*size.y, sradius) * mass;
-        }
 
-		// an capsule primitiv has got its coordinate system at its center, so shift it with radius
-		// additionally it is x axis aligned, so rotate it 90 degrees around z axis
-		return CollisionPtr(new OgreNewt::CollisionPrimitives::Capsule(
+
+        // an capsule primitiv has got its coordinate system at its center, so shift it with radius
+        // additionally it is x axis aligned, so rotate it 90 degrees around z axis
+        OgreNewt::CollisionPtr rval(new OgreNewt::CollisionPrimitives::Capsule(
             PhysicsManager::getSingleton()._getNewtonWorld(),
             radius, height, *orientation, *offset));
+
+        if (inertia)
+        {
+            Vector3 inert_offs=Vector3::ZERO;
+            static_cast&lt;OgreNewt::ConvexCollision*&gt;(rval)-&gt;calculateInertialMatrix(*inertia, inert_offs);
+            *inertia *= mass;
+        }
+        return rval;
     }
+}
 
-}

Modified: rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp
===================================================================
--- rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/PhysicsMaterialRaycast.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -23,7 +23,7 @@
 
 namespace rl {
     PhysicsMaterialRaycast::PhysicsMaterialRaycast()
-        : Raycast(), mInfo(), mMaterial(0), mGetNearest(false)
+        : Raycast(), mInfo(), mMaterial(0)
     {
     }
 
@@ -38,7 +38,6 @@
         mInfo.mDistance = 1.1;
         mInfo.mNormal = Vector3::ZERO;
 
-        mGetNearest = false;
         go(world, start, end);
 
         return mInfo;
@@ -55,14 +54,66 @@
         mInfo.mDistance = 1.1;
         mInfo.mNormal = Vector3::ZERO;
 
-        mGetNearest = false;
         go(world, start, end);
 
         return mInfo;
     }
 
+    bool PhysicsMaterialRaycast::userPreFilterCallback( OgreNewt::Body *body )
+    {
+        if( body-&gt;getMaterialGroupID() == NULL )
+        {
+            LOG_MESSAGE(Logger::CORE, &quot;Warning PhysicsMaterialRaycast found body without material (getMaterialGroupId() == NULL)!&quot;);
+            return true;
+        }
+        else if( body-&gt;getMaterialGroupID() == PhysicsManager::getSingleton().createMaterialID(&quot;gamearea&quot;) ) // don't trigger gameareas
+        {
+            return false;
+        }
+        else
+        {
+            if( mMaterial == NULL &amp;&amp; mMaterialVector == NULL)
+            {
+                return true;
+            }
+            else if( mMaterial != NULL )
+            {
+                if (body-&gt;getMaterialGroupID()-&gt;getID() == mMaterial-&gt;getID() &amp;&amp; !mInvertMat ||
+                    body-&gt;getMaterialGroupID()-&gt;getID() != mMaterial-&gt;getID() &amp;&amp; mInvertMat)
+                {
+                    return true;
+                }
+            }
+            else // mMaterialVector != NULL
+            {
+                bool found = false;
+
+                MaterialVector::const_iterator iter;
+                for(iter = mMaterialVector-&gt;begin(); iter != mMaterialVector-&gt;end(); iter++)
+                {
+                    if (body-&gt;getMaterialGroupID()-&gt;getID() == (*iter)-&gt;getID())
+                    {
+                        found = true;
+                        break;
+                    }
+                }
+
+                if( found &amp;&amp; !mInvertMat || !found &amp;&amp; mInvertMat )
+                {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
     bool PhysicsMaterialRaycast::userCallback(Body* body, Ogre::Real distance, const Ogre::Vector3&amp; normal, int collisionID)
     {
+        mInfo.mBody = body;
+        mInfo.mDistance = distance;
+        mInfo.mNormal = normal;
+        return true;
+        /*
         if( body-&gt;getMaterialGroupID() == NULL )
         {
             mInfo.mBody = body;
@@ -110,14 +161,107 @@
 
                 if( found &amp;&amp; !mInvertMat || !found &amp;&amp; mInvertMat )
                 {
-                    mInfo.mBody = body;
-                    mInfo.mDistance = distance;
-                    mInfo.mNormal = normal;
                     mGetNearest = true;
                 }
             }
         }
         return mGetNearest;
+        */
     }
 
+
+// -------------------------------------------------------------------------------------------------
+
+    ConvexcastInfo::ConvexcastInfo(const OgreNewt::BasicConvexcast::ConvexcastContactInfo &amp;info) :
+        ConvexcastContactInfo(info),
+        mDistance(0)
+    {
+    }
+
+    PhysicsMaterialConvexcast::PhysicsMaterialConvexcast() :
+        mMaterialVector(NULL),
+        mMaterial(NULL),
+        mInvertMat(false)
+    {
+    }
+
+    ConvexcastInfo PhysicsMaterialConvexcast::execute(OgreNewt::World* world, const OgreNewt::MaterialID* material,
+                        const OgreNewt::Collision *col, const Vector3&amp; startpt, const Quaternion &amp;ori,
+                        const Vector3&amp; endpt, bool invertmat)
+    {
+        mMaterialVector = NULL;
+        mMaterial = material;
+        mInvertMat = invertmat;
+
+        BasicConvexcast::go(world, col, startpt, ori, endpt, 1, 0); // set threadindex to 0, I hope this is ok
+
+        ConvexcastInfo info(BasicConvexcast::getInfoAt(0));
+        info.mDistance = getDistanceToFirstHit();
+        return info;
+    }
+
+    ConvexcastInfo PhysicsMaterialConvexcast::execute(OgreNewt::World* world, const MaterialVector* materials,
+                        const OgreNewt::Collision *col, const Vector3&amp; startpt, const Quaternion &amp;ori,
+                        const Vector3&amp; endpt, bool invertmat)
+    {
+        mMaterialVector = materials;
+        mMaterial = NULL;
+        mInvertMat = invertmat;
+
+        BasicConvexcast::go(world, col, startpt, ori, endpt, 1, 0); // set threadindex to 0, I hope this is ok
+
+        ConvexcastInfo info(BasicConvexcast::getInfoAt(0));
+        info.mDistance = getDistanceToFirstHit();
+        return info;
+    }
+
+    bool PhysicsMaterialConvexcast::userPreFilterCallback( OgreNewt::Body *body )
+    {
+        if( body-&gt;getMaterialGroupID() == NULL )
+        {
+            LOG_MESSAGE(Logger::CORE, &quot;Warning PhysicsMaterialRaycast found body without material (getMaterialGroupId() == NULL)!&quot;);
+            return true;
+        }
+        else if( body-&gt;getMaterialGroupID() == PhysicsManager::getSingleton().createMaterialID(&quot;gamearea&quot;) ) // don't trigger gameareas
+        {
+            return false;
+        }
+        else
+        {
+            if( mMaterial == NULL &amp;&amp; mMaterialVector == NULL)
+            {
+                return true;
+            }
+            else if( mMaterial != NULL )
+            {
+                if (body-&gt;getMaterialGroupID()-&gt;getID() == mMaterial-&gt;getID() &amp;&amp; !mInvertMat ||
+                    body-&gt;getMaterialGroupID()-&gt;getID() != mMaterial-&gt;getID() &amp;&amp; mInvertMat)
+                {
+                    return true;
+                }
+            }
+            else // mMaterialVector != NULL
+            {
+                bool found = false;
+
+                MaterialVector::const_iterator iter;
+                for(iter = mMaterialVector-&gt;begin(); iter != mMaterialVector-&gt;end(); iter++)
+                {
+                    if (body-&gt;getMaterialGroupID()-&gt;getID() == (*iter)-&gt;getID())
+                    {
+                        found = true;
+                        break;
+                    }
+                }
+
+                if( found &amp;&amp; !mInvertMat || !found &amp;&amp; mInvertMat )
+                {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
 }
+

Modified: rl/trunk/engine/core/src/SoundObject.cpp
===================================================================
--- rl/trunk/engine/core/src/SoundObject.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/core/src/SoundObject.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -144,6 +144,7 @@
 void SoundObject::set3d( bool is3d )
 {
 	getSound()-&gt;set3d(is3d);
+        _update(); // do we need this here?
 }
 
 void SoundObject::load()

Modified: rl/trunk/engine/rules/include/AbstractMovement.h
===================================================================
--- rl/trunk/engine/rules/include/AbstractMovement.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/rules/include/AbstractMovement.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -26,8 +26,7 @@
 namespace rl
 {
     /// this is the base class of all movements and provides a general interface for movements
-    class AbstractMovement : 
-        public OgreNewt::ContactCallback
+    class AbstractMovement // : public PhysicsGenericContactCallback
     {
     public:
         AbstractMovement(CreatureController *movingCreature) : mMovingCreature(movingCreature), mActive(false) {}
@@ -55,7 +54,7 @@
          * this method is called, when this movement is currently used to enable 
          * an individual procession of collisions contacts for each movement
          */
-        virtual int userProcess(OgreNewt::Body *body0, OgreNewt::Body *body1) {return 1;}
+        virtual void userProcess(OgreNewt::ContactJoint &amp;contactJoint, Ogre::Real timestep, int threadid) {}
 
         /**
          * this method is called by OnApplyTorqueAndForceCallback of the CreatureController

Modified: rl/trunk/engine/rules/include/CreatureController.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureController.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/rules/include/CreatureController.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -20,7 +20,6 @@
 
 #include &quot;RulesPrerequisites.h&quot;
 #include &quot;PhysicsController.h&quot;
-#include &quot;PhysicsGenericContactCallback.h&quot;
 #include &quot;PhysicsMaterialRaycast.h&quot;
 #include &quot;Creature.h&quot;
 #include &quot;Actor.h&quot;
@@ -40,8 +39,7 @@
      * It handles all nessessary things like animations and calculates the movement speed.
      */
     class _RlRulesExport CreatureController :
-        public PhysicsController,
-        public PhysicsGenericContactCallback
+        public PhysicsController
     {
     public:
         static const Ogre::String PROPERTY_CREATUREID;
@@ -52,10 +50,10 @@
         bool run(Ogre::Real elapsedTime);
 
         /// Newton force and torque callback
-        void OnApplyForceAndTorque(PhysicalThing* thing);
+        void OnApplyForceAndTorque(PhysicalThing* thing, float timestep);
 
         /// Newton contact callback called by the movingCreatureManager
-        int userProcess();
+        void userProcess(OgreNewt::ContactJoint &amp;contactJoint, Ogre::Real timestep, int threadid);
 
         Creature* getCreature() {return mCreature;}
         bool refetchCreature();
@@ -114,7 +112,7 @@
          * @param direction This is the movement direction in local space.
 		 *                  If the direction isn't possible (see AbstractMovement::isDirectionPossible),
 		 *                  only a &quot;part&quot; of the direction is applied.
-         * @param rotation like above
+         * @param rotation like above (in radians)
          * @retval false signifies that the change to this movement was not possible (possibly because the present movement forbade it)
          */
         bool setMovement(MovementType type, Ogre::Vector3 direction, Ogre::Vector3 rotation);

Modified: rl/trunk/engine/rules/include/CreatureControllerManager.h
===================================================================
--- rl/trunk/engine/rules/include/CreatureControllerManager.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/rules/include/CreatureControllerManager.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -60,7 +60,7 @@
         const Ogre::String&amp; getName() const;
 
         // Newton Contact Callback
-        int userProcess();
+        void userProcess(OgreNewt::ContactJoint &amp;contactJoint, Ogre::Real timestep, int threadid);
     protected:
         typedef std::map&lt;Creature*, CreatureController*&gt; ControllerMap;
         ControllerMap mControllers;

Modified: rl/trunk/engine/rules/src/CreatureController.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureController.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/rules/src/CreatureController.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -80,7 +80,10 @@
 
         mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;setPhysicsController(this);
 
+//        mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;setAngularDamping(0*Vector3::UNIT_SCALE);
+        mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;setContinuousCollisionMode(1);
 
+
         std::pair&lt;MovementType, AbstractMovement*&gt; movementPair;
         movementPair.first = MT_NONE;
         movementPair.second = NULL;
@@ -154,6 +157,8 @@
                 mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
 
                 mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;setMaterialID(mOldMaterialId);
+        
+//                mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;setAngularDamping(0.1*Vector3::UNIT_SCALE);
             }
         }
     }
@@ -170,7 +175,7 @@
     {
         int act_gs = mCreature-&gt;getWert(Creature::WERT_GS);
         ///@todo wy does this not work
-        //act_gs -= mCreature-&gt;getWert(Creature::WERT_BE);
+        act_gs -= mCreature-&gt;getWert(Creature::WERT_BE);
         return max(act_gs,1);
     }
 
@@ -297,7 +302,7 @@
         {
             // find a reason why we now are AL_FLOOR
             if( timeSinceLastFloorContact &lt; Time(Date::ONE_SECOND)*0.19 &amp;&amp;
-                -speed.y &lt; 0.6 )
+                abs(speed.y) &lt; 0.6 )
             {
                 setAbstractLocation(AL_FLOOR);
             }
@@ -306,7 +311,7 @@
         {
             // find a reason why we now are AL_AIRBORNE
             if( timeSinceLastFloorContact &gt;= Time(Date::ONE_SECOND)*0.2 &amp;&amp; // 2 seconds?
-                -speed.y &gt; 0.6 )
+                abs(speed.y) &gt; 0.6 )
             {
                 //std::ostringstream oss;
                 //oss &lt;&lt; &quot;Raycast for floor: speed.y: &quot; &lt;&lt; speed.y &lt;&lt; &quot;      timeSinceLastFloorContact: &quot; &lt;&lt; timeSinceLastFloorContact;
@@ -316,8 +321,8 @@
 		// find the distance to the floor:
                 // raycasts
                 PhysicsMaterialRaycast::MaterialVector materialVector;
-                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;)); // should we perhaps only use level here?
-                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
+                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;)); // should we perhaps only use level here?
+                materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
 
                 Vector3 start = getCreature()-&gt;getPosition();
                 Vector3 end = start + Vector3::NEGATIVE_UNIT_Y*0.4;
@@ -325,7 +330,7 @@
                 RaycastInfo info = mRaycast.execute(
                             PhysicsManager::getSingleton()._getNewtonWorld(),
                             &amp;materialVector,
-                            start, end);
+                            start, end, false);
 
 		if( info.mBody == NULL )
 		{
@@ -359,14 +364,13 @@
         return false;
     }
 
-    void CreatureController::OnApplyForceAndTorque(PhysicalThing* thing)
+    void CreatureController::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
     {
         Vector3 force, torque;
         OgreNewt::Body *body = thing-&gt;_getBody();
         force = Vector3::ZERO;
         torque = Vector3::ZERO;
         OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-        Real timestep = world-&gt;getTimeStep();
         Real mass;
         Vector3 inertia;
         body-&gt;getMassMatrix(mass, inertia);
@@ -387,12 +391,15 @@
         body-&gt;setTorque(torque);
     }
 
-    int CreatureController::userProcess()
+    void CreatureController::userProcess(OgreNewt::ContactJoint &amp;contactJoint, Real timestep, int threadid)
     {
+for(OgreNewt::Contact contact = contactJoint.getFirstContact(); contact; contact = contact.getNext() )
+{
+
         // own collision handling (floor, in order to get information for mAbstractLocation)
         Vector3 point;
         Vector3 normal;
-        getContactPositionAndNormal(point, normal);
+        contact.getPositionAndNormal(point, normal);
 
         // determine if this contact is with the floor.
         // Meaning the contact normal has an angle to UNIT_Y of 20 or less.
@@ -419,7 +426,32 @@
                 mLastFloorContact = time;
             }
         }
+/*
+//        setContactNormalDirection(((Vector3::UNIT_Y.dotProduct(point-charPos)*Vector3::UNIT_Y + charPos) - point).normalisedCopy());
+        setContactNormalDirection(point - (charPos + charHeight/2));
+        setContactNormalAcceleration(0);
+        setContactFrictionState(0,0);
+        setContactFrictionState(0,1);
+        setContactTangentAcceleration(0, 0);
+        setContactTangentAcceleration(0, 1);
 
+*/
+//std::ostringstream oss;
+//Vector3 vec1, vec2;
+//oss &lt;&lt; &quot; Collision: Point: &quot; &lt;&lt; point-charPos;
+//    &lt;&lt; &quot;  \t Normal: &quot; &lt;&lt; normal
+//    &lt;&lt; &quot;  \t Force: &quot; &lt;&lt; getContactForce()
+//    &lt;&lt; &quot;  \t Normal-Speed: &quot; &lt;&lt; getContactNormalSpeed()
+//    &lt;&lt; &quot;  \t Contact-Speed: &quot; &lt;&lt; point
+//    &lt;&lt; &quot;  \t Contact-Normal: &quot; &lt;&lt; normal;
+//getContactTangentDirections(vec1, vec2);
+//oss &lt;&lt; &quot;  \t Tangent-Directions: &quot; &lt;&lt; vec1 &lt;&lt; &quot; &quot; &lt;&lt; vec2;
+//LOG_MESSAGE(Logger::RULES, oss.str());
+
+        contact.rotateTangentDirections(/*charOri*mDirection + */Vector3::UNIT_Y);
+        contact.setFrictionState(1,0);
+        contact.setFrictionState(0,1);
+
         if( stepHeight &lt; 0.4 )
         {
             if(stepHeight &gt; 0.01f) // experimantal value, 
@@ -427,17 +459,15 @@
                                    // too high means the creature stops if moving slowly onto a step because of the friction
             {
                 //setContactNormalAcceleration(5);
-                rotateTangentDirections(charOri*mDirection + Vector3::UNIT_Y);
-                setContactTangentAcceleration(5,0);
-                setContactFrictionState(1,0);
-                setContactFrictionState(1,1);
+                contact.setTangentAcceleration(5,0);
+                //setContactFrictionState(1,0);
+                //setContactFrictionState(1,1);
             }
             else
             {
-                setContactFrictionState(1,0);
-                setContactFrictionState(1,1);
+                //setContactFrictionState(1,0);
+                //setContactFrictionState(1,1);
             }
-            //setContactTangentAcceleration(5);
             //setContactElasticity(0.0f);
         }
         else
@@ -446,29 +476,22 @@
             vel = mCreature-&gt;getActor()-&gt;getPhysicalThing()-&gt;getVelocity();
             if( vel.y &gt;= 0 )
             {
-                setContactFrictionState(1,0);
-                setContactFrictionState(1,1);    
+                //setContactFrictionState(1,0);
+                //setContactFrictionState(1,1);    
             }
             else
             {
-                setContactFrictionState(0,0);
-                setContactFrictionState(0,1);
+                //setContactFrictionState(0,0);
+                //setContactFrictionState(0,1);
             }
         }
+}
 
         if(mMovement != NULL)
         {
-            // @XXX Evil code!
-            // Protected members from type OgreNewt::ContactCallback have to be overridden in order
-            // for the movements to work. This is because these members are used by OgreNewt functions
-            // for processing this contact. Should probably be solved in OgreNewt directly.
-            OgreNewt::ContactCallback *movement = mMovement;
-            *movement = (OgreNewt::ContactCallback)(*this);
-            return movement-&gt;userProcess();
+            // give the movement a chance to modify the contact
+            mMovement-&gt;userProcess(contactJoint, timestep, threadid);
         }
-
-        // return one to tell Newton we want to accept this contact
-        return 1;
     }
 
     AbstractMovement *CreatureController::getMovementFromId(CreatureController::MovementType id)

Modified: rl/trunk/engine/rules/src/CreatureControllerManager.cpp
===================================================================
--- rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/rules/src/CreatureControllerManager.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -44,14 +44,32 @@
 
         physicsManager-&gt;createMaterialPair(char_mat, def_mat)-&gt;setContactCallback(this);
         physicsManager-&gt;createMaterialPair(char_mat, level_mat)-&gt;setContactCallback(this);
-        
+        physicsManager-&gt;createMaterialPair(char_mat, char_mat); //-&gt;setContactCallback(this);
+
+        physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultFriction(0.0f,0.0f);
+        physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultFriction(0.0f,0.0f);
+        physicsManager-&gt;getMaterialPair(char_mat, char_mat)-&gt;setDefaultFriction(0.0f,0.0f);
+        physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultElasticity(0.1f);
+        physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultElasticity(0.1f);
+        physicsManager-&gt;getMaterialPair(char_mat, char_mat)-&gt;setDefaultElasticity(0.1f);
+        physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultSoftness(0.1f);
+        physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultSoftness(0.1f);
+        physicsManager-&gt;getMaterialPair(char_mat, char_mat)-&gt;setDefaultSoftness(0.1f);
+        physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultSurfaceThickness(0.0f);
+        physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultSurfaceThickness(0.0f);
+        physicsManager-&gt;getMaterialPair(char_mat, char_mat)-&gt;setDefaultSurfaceThickness(0.0f);
+
+/*        
         physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultFriction(0.8f,0.4f);
         physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultFriction(0.8f,0.4f);
-        physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultElasticity(0.0f);
-        physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultElasticity(0.0f);
-        physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultSoftness(1.0f);
-        physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultSoftness(1.0f);
-
+        physicsManager-&gt;getMaterialPair(char_mat, char_mat)-&gt;setDefaultFriction(0.8f,0.4f);
+        physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultElasticity(0.01f);
+        physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultElasticity(0.01f);
+        physicsManager-&gt;getMaterialPair(char_mat, char_mat)-&gt;setDefaultElasticity(0.01);
+        physicsManager-&gt;getMaterialPair(char_mat, def_mat)-&gt;setDefaultSoftness(0.8f);
+        physicsManager-&gt;getMaterialPair(char_mat, level_mat)-&gt;setDefaultSoftness(0.8f);
+        physicsManager-&gt;getMaterialPair(char_mat, char_mat)-&gt;setDefaultSoftness(0.8f);
+*/
         physicsManager-&gt;getNewtonDebugger()-&gt;setMaterialColor(char_mat, Ogre::ColourValue::Red);
     }
 
@@ -146,27 +164,34 @@
         }
     }
 
-    int CreatureControllerManager::userProcess()
+    void CreatureControllerManager::userProcess(OgreNewt::ContactJoint &amp;contactJoint, Real timestep, int threadid)
     {
-        Actor *actor = static_cast&lt;Actor*&gt;(m_body0-&gt;getUserData());
+        Actor *actor = static_cast&lt;Actor*&gt;(contactJoint.getBody0()-&gt;getUserData());
         if( actor != NULL )
         {
             ControllerMap::const_iterator it = mControllers.find(static_cast&lt;Creature*&gt;(actor-&gt;getGameObject()));
             if (it != mControllers.end())
             {
-                // @XXX Evil code!
-                // Protected members from type OgreNewt::ContactCallback have to be overridden in order
-                // for the controllers to work. This is because these members are used by OgreNewt functions
-                // for processing this contact. Should probably be solved in OgreNewt directly.
-                OgreNewt::ContactCallback* controller = it-&gt;second;
-                *controller = (OgreNewt::ContactCallback)(*this);
-                return controller-&gt;userProcess();
+                it-&gt;second-&gt;userProcess(contactJoint, timestep, threadid);
+                return;
             }
         }
 
+        // if the controlled body is the second body...
+        actor = static_cast&lt;Actor*&gt;(contactJoint.getBody1()-&gt;getUserData());
+        if( actor != NULL )
+        {
+            ControllerMap::const_iterator it = mControllers.find(static_cast&lt;Creature*&gt;(actor-&gt;getGameObject()));
+            if (it != mControllers.end())
+            {
+                it-&gt;second-&gt;userProcess(contactJoint, timestep, threadid);
+                return;
+            }
+        }
+
+
         LOG_ERROR(Logger::RULES,
             &quot;Der Kollisionsk&#246;rper konnte keinem CreatureController zugeordnet werden.&quot;);
-        return 1;
     }
 
     const Ogre::String&amp; CreatureControllerManager::getName() const

Modified: rl/trunk/engine/rules/src/JumpHighMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/JumpHighMovement.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/rules/src/JumpHighMovement.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -147,7 +147,7 @@
         }
 
         Vector3 omega = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getOmega();
-        torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
+        torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * inertia;
     }
 
     bool JumpHighMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)

Modified: rl/trunk/engine/rules/src/JumpLongMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/JumpLongMovement.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/rules/src/JumpLongMovement.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -186,7 +186,7 @@
         }
 
         Vector3 omega = mMovingCreature-&gt;getCreature()-&gt;getActor()-&gt;getPhysicalThing()-&gt;_getBody()-&gt;getOmega();
-        torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * mass;
+        torque = -omega / PhysicsManager::getSingleton().getMaxTimestep() * 2 * inertia;
     }
 
     bool JumpLongMovement::run(Ogre::Real elapsedTime,  Ogre::Vector3 direction, Ogre::Vector3 rotation)

Modified: rl/trunk/engine/rules/src/StepRecognitionMovement.cpp
===================================================================
--- rl/trunk/engine/rules/src/StepRecognitionMovement.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/rules/src/StepRecognitionMovement.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -21,6 +21,8 @@
 using namespace Ogre;
 
 
+/// @todo: use TriggerVolumes
+// void NewtonCollisionSetAsTriggerVolume(const NewtonCollision* convexCollision, int trigger);
 
 
 namespace rl
@@ -98,8 +100,8 @@
 
         // the materials that are triggered here
         PhysicsMaterialRaycast::MaterialVector materialVector;
-        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;)); // should we perhaps only use level here?
-        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
+        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;)); // should we perhaps only use level here?
+        materialVector.push_back(PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;));
 
 
 
@@ -113,7 +115,8 @@
                 PhysicsManager::getSingleton()._getNewtonWorld(),
                 &amp;materialVector,
                 start,
-                end);
+                end,
+                true);
         if(info.mBody)
         {
             mMoveToNextTarget = false;
@@ -149,7 +152,7 @@
                     mRaycast.execute(
                             PhysicsManager::getSingleton()._getNewtonWorld(),
                             &amp;materialVector,
-                            start, end);
+                            start, end, true);
 
                 // do we need to check bodies left and right of this ray? (step width?)
 

Modified: rl/trunk/engine/script/src/EntityNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/script/src/EntityNodeProcessor.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -250,15 +250,13 @@
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::ConvexHull(
                                     thisWorld,
-                                    entity,
-                                    false));
-                    //orientation, pos));
+                                    entity));
                     LOG_DEBUG(Logger::RULES, &quot;Created physics proxy type 'convexhull' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
                 }
                 else if (physicsProxyType == &quot;mesh&quot; || physicsProxyType == &quot;auto&quot;)
                 {
                     collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::TreeCollision(
-                                    thisWorld, entity, false));
+                                    thisWorld, entity, true));
                     LOG_DEBUG(Logger::RULES, &quot;Created physics proxy type 'mesh' for entity '&quot;+entity-&gt;getName()+&quot;'.&quot;);
                 }
                 else
@@ -274,7 +272,7 @@
             }
         }
 
-        if (!collision.isNull())
+        if ( collision != NULL )
         {
             collisions.push_back(collision);
         }

Modified: rl/trunk/engine/script/src/PlaneNodeProcessor.cpp
===================================================================
--- rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/script/src/PlaneNodeProcessor.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -150,7 +150,7 @@
 
 			collision = OgreNewt::CollisionPtr(new OgreNewt::CollisionPrimitives::Box(world, size, orientation, pos));
 
-			if (!collision.isNull())
+			if ( collision != NULL )
 			{
 				collisions.push_back(collision);
 			}

Modified: rl/trunk/engine/ui/include/CombatControlState.h
===================================================================
--- rl/trunk/engine/ui/include/CombatControlState.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/include/CombatControlState.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -22,6 +22,8 @@
 #include &quot;ControlState.h&quot;
 #include &quot;Combatant.h&quot;
 #include &quot;MessagePump.h&quot;
+#include &quot;PhysicsController.h&quot;
+#include &quot;PhysicsGenericContactCallback.h&quot;
 #include &quot;Selector.h&quot;
 
 
@@ -32,9 +34,21 @@
     class CombatGui;
     class CombatManager;
 
-	class _RlUiExport CombatControlState : public ControlState, public Combatant
+	class _RlUiExport CombatControlState :
+            public ControlState,
+            public Combatant,
+            public PhysicsController,
+            public PhysicsGenericContactCallback
 	{
 	public:
+        /** 
+         * Different view-modes:
+         * @VM_COMBAT_CENTERED: &quot;cameraLookAt&quot; to center of combat (middle of all combatant positions)
+         * @VM_THIRD_PERSON: zooms to one combatant (not only hero!)
+        */
+        typedef enum {VM_COMBAT_CENTERED, VM_THIRD_PERSON} ViewMode;
+
+
 		/**
 		*  @throw NullPointerException if camera is NULL.
 		*  @warning Ownership of combat is taken by the CombatControlState.
@@ -46,6 +60,8 @@
 
         virtual void pause();
         virtual void resume();
+        virtual bool keyPressed(const OIS::KeyEvent&amp; evt, bool handled);
+        virtual bool keyReleased(const OIS::KeyEvent&amp; evt, bool handled);
 
 		void run(Ogre::Real elapsedTime);
 
@@ -54,6 +70,21 @@
         virtual Ogre::String getCombatantTypeName() const;
         virtual void requestCombatantAction();
 
+
+        // camera collision: OgreNewt::ContactCallback overides
+        int onAABBOverlap(OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex);
+        void userProcess(OgreNewt::ContactJoint &amp;contactJoint, Ogre::Real timestep, int threadIndex);
+
+        // camera movement: Newton force and torque callback
+        void OnApplyForceAndTorque(PhysicalThing *pt, float timstep);
+
+        // Change ViewMode
+        void setViewMode(ViewMode mode);
+        ViewMode getViewMode();
+        void toggleViewMode();
+        // set the combatant (must be part of this combat), the camera should focus on (VM_THIRD_PERSON) (only used internally?)
+        void setCameraFocusedCombatant(Combatant* combatant);
+
     private:
 		enum State {REQUEST_USER_INPUT, ROUND_EXECUTION};
 
@@ -74,6 +105,36 @@
         CameraObject* mCamera;
 
 		State mState;
+
+        // Camera:
+        Ogre::Degree mCameraYaw, mCameraPitch;
+        Ogre::Real mCameraMaxDistance, mCameraCombatCenteredMinDistance, mCameraThirdPersonMinDistance;
+        int mMovementState; // keyboard input
+        Ogre::Real mCameraLinearDampingK, mCameraLinearSpringK;
+        ViewMode mViewMode;
+        Ogre::Vector3 mCameraLookAt; // set by calculateOptimalCameraPositionAndLookAt
+        Ogre::Vector3 mCameraOptPos; // set by calculateOptimalCameraPositionAndLookAt
+        Ogre::Real mCameraDistance; // only used in third-person, changed by calculateOptimalCameraAndPosition
+        Ogre::Real mCameraSwitchDist; // set by calculateOptimalCameraPositionAndLookAt, dist at which switches to third-person
+        Ogre::Real mCameraSwitchTransitionDist; // relative value (0-1) of mCameraSwitchDist
+        Combatant* mCameraFocusedCombatant;  // the combatant currently focused by camera (VM_THIRD_PERSON)
+        // when switching from one view-mode to another or when changing focused combatant, these variables are used
+        // to provide smooth camera movement
+        bool mCameraTransitionLookAtActive;
+        bool mCameraTransitionPositionActive;
+        Ogre::Vector3 mCameraTransitionPosition;
+        Ogre::Vector3 mCameraTransitionLookAt;
+        // buffered values needed fo camera-movement, calculated once per frame:
+        Ogre::Vector3 mCombatCenter; // result of calculateCombatCenterPosition
+        Ogre::Real mCombatRadius; // result of calculateCombatRadius
+
+        // Camera helper functions
+        void resetCamera();
+        void updateCameraLookAt(Ogre::Real timestep);
+        Ogre::Vector3 calculateCombatCenterPosition();
+        Ogre::Real calculateCombatRadius(Ogre::Vector3 center);
+        // sets the variables mCameraLookAt, mCameraOptPos, mCameraDistance, usually called in OnApplyForceAndTorque
+        void calculateOptimalCameraPositionAndLookAt();
         
         // Event handlers
 		bool userRequestAttackOpponent(Combatant*);

Modified: rl/trunk/engine/ui/include/Console.h
===================================================================
--- rl/trunk/engine/ui/include/Console.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/include/Console.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -53,6 +53,7 @@
 
 			bool handleKeyDown(const CEGUI::EventArgs&amp; e);
             bool handleKeyUp(const CEGUI::EventArgs&amp; e);
+            bool handleActivated(const CEGUI::EventArgs&amp; e);
 			void appendTextRow(const CeGuiString&amp; text, const CEGUI::colour color);
 
 			std::vector&lt;CeGuiString&gt; mHistory;

Modified: rl/trunk/engine/ui/include/FreeflightControlState.h
===================================================================
--- rl/trunk/engine/ui/include/FreeflightControlState.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/include/FreeflightControlState.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -26,6 +26,7 @@
 #   include &lt;OgreNewt/OgreNewt.h&gt;
 #else
 #   include &lt;OgreNewt.h&gt;
+#   include &lt;OgreNewt_PlayerController.h&gt;
 #endif
 
 namespace rl {
@@ -57,12 +58,10 @@
 	    void toggleCameraCollision();
 	    void resetCamera();
 
-        /// This is the OgreNewt contact process callback for the combination
-        /// Character &lt;-&gt; Level
-        int userProcess();
-
+        /// Newton contacts callback
+        int onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex );
         /// Newton force and torque callback
-        void OnApplyForceAndTorque(PhysicalThing* thing);
+        void OnApplyForceAndTorque(PhysicalThing* thing, float timestep);
 
 	private:		
 		int mCurrentMovementState;
@@ -78,6 +77,8 @@
         Ogre::Real mMouseSensitivity;
         bool mInvertedMouse;
         std::pair&lt;Ogre::Degree, Ogre::Degree&gt; mPitchRange;
+
+        OgreNewt::PlayerController *mOgreNewtPlayerController;
 	};
 }
 #endif

Modified: rl/trunk/engine/ui/include/ItemDescriptionDragContainer.h
===================================================================
--- rl/trunk/engine/ui/include/ItemDescriptionDragContainer.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/include/ItemDescriptionDragContainer.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -25,9 +25,17 @@
 	class ItemDescriptionDragContainer : public ItemDragContainer
 	{
 	public:
-		ItemDescriptionDragContainer(Item* item, const CeGuiString&amp; name);
+		ItemDescriptionDragContainer(const CeGuiString &amp;type, const CeGuiString&amp; name);
+                void setItem(Item*);
+                static const CeGuiString WidgetTypeName; // for CEGUI
 	};
 
 } // namespace rl
+namespace CEGUI{
 
+    using rl::ItemDescriptionDragContainer;
+
+    CEGUI_DECLARE_WINDOW_FACTORY(ItemDescriptionDragContainer)
+}
+
 #endif //__ItemDescriptionDragContainer_H__

Modified: rl/trunk/engine/ui/include/ItemDragContainer.h
===================================================================
--- rl/trunk/engine/ui/include/ItemDragContainer.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/include/ItemDragContainer.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -18,6 +18,7 @@
 
 #include &quot;UiPrerequisites.h&quot;
 
+#include &lt;CEGUI.h&gt;
 #include &lt;elements/CEGUIDragContainer.h&gt;
 
 namespace rl 
@@ -41,6 +42,7 @@
 		const CeGuiString&amp; getItemParentSlot() const;
 		Inventory* getItemParentInventory() const;
 		Item* getItem() const;
+                virtual void setItem(Item*); // can only be used once to initialize the Container
 		CEGUI::Window* getContentWindow() const;
 	
 		bool _handleItemMouseClick(const CEGUI::EventArgs&amp; evt, Item* item);
@@ -49,13 +51,15 @@
         bool fadeOutAndHide(Ogre::Real delay);
         bool stopFadeOut();
 
-        void destroyWindow(); // this is internally done with a windowfadejob to prevent problems
+        virtual void destroy(void); // inherited from CEGUI::WINDOW
 
-        void setDestroyListener(ItemDragContainerDestroyListener *listener) {mDestroyListener = listener;}
+        //void destroyWindow(); // this is internally done with a windowfadejob to prevent problems
+
+        void setDestroyListener(ItemDragContainerDestroyListener *listener);
 	protected:
 		CEGUI::Window* mContentWindow;
 		
-		ItemDragContainer(Item* item, const CeGuiString&amp; name);
+		ItemDragContainer(const CeGuiString &amp;type, const CeGuiString&amp; name);
 		virtual bool testClassName_impl(const CEGUI::String&amp; class_name) const;
 
 	private:
@@ -71,7 +75,17 @@
     class ItemDragContainerDestroyListener
     {
     public:
+        ItemDragContainerDestroyListener();
+        virtual ~ItemDragContainerDestroyListener();
         virtual void notifyItemDragContainerDestroyed(ItemDragContainer* cont) = 0;
+    protected:
+        void addDragContainer(ItemDragContainer* dragcont);
+        void removeDragContainer(ItemDragContainer* dragcont);
+        friend class ItemDragContainer;
+    private:
+        typedef std::map&lt;CeGuiString, ItemDragContainer*&gt; DndContainerMap;
+        DndContainerMap mContainers;
+        bool mIsDestroying;
     };
 
 } // namespace rl

Modified: rl/trunk/engine/ui/include/ItemIconDragContainer.h
===================================================================
--- rl/trunk/engine/ui/include/ItemIconDragContainer.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/include/ItemIconDragContainer.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -27,9 +27,19 @@
 	class ItemIconDragContainer : public ItemDragContainer
 	{
 	public:
-		ItemIconDragContainer(Item* item, const CeGuiString&amp; name);
+		ItemIconDragContainer(const CeGuiString &amp;type, const CeGuiString&amp; name);
+                void setItem(Item* item);
+                static const CeGuiString WidgetTypeName; // for CEGUI
 	};
 
 } // namespace rl
 
+namespace CEGUI{
+
+    using rl::ItemIconDragContainer;
+
+    CEGUI_DECLARE_WINDOW_FACTORY(ItemIconDragContainer)
+
+}
+
 #endif //__ItemIconDragContainer_H__

Modified: rl/trunk/engine/ui/include/MovementControlState.h
===================================================================
--- rl/trunk/engine/ui/include/MovementControlState.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/include/MovementControlState.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -60,10 +60,11 @@
 
         /// This is the OgreNewt contact process callback for the combination
         /// Character &lt;-&gt; Level
-        int userProcess();
+        int onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex );
+        void userProcess(OgreNewt::ContactJoint &amp;contactJoint, Ogre::Real timestep, int threadid);
 
         /// Newton force and torque callback
-        void OnApplyForceAndTorque(PhysicalThing* thing);
+        void OnApplyForceAndTorque(PhysicalThing* thing, float timestep);
 
         /// First oder Third person view.
         void setViewMode(ViewMode mode);
@@ -123,12 +124,9 @@
 
         ViewMode mViewMode;
 
-        int mObstractedFrameCount;
-        Ogre::Real mObstractedTime;
-        int mCameraJammedFrameCount;
-        Ogre::Real mCameraJammedTime;
-
         PhysicsMaterialRaycast* mRaycast;
+        PhysicsMaterialConvexcast * mConvexcast;
+        OgreNewt::Collision *mCameraCastCollision;
         HalfSphereSelector mSelector;
         HalfSphereSelector mCombatSelector;
 

Modified: rl/trunk/engine/ui/include/WindowFadeJob.h
===================================================================
--- rl/trunk/engine/ui/include/WindowFadeJob.h	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/include/WindowFadeJob.h	2009-02-09 20:56:41 UTC (rev 4755)
@@ -40,8 +40,8 @@
             Ogre::Real targetAlpha = 1.0f, Ogre::Real changeRate = 4.0f);
         WindowFadeJob(CEGUI::Window* window, Mode mode, 
             Ogre::Real targetAlpha = 1.0f, Ogre::Real changeRate = 4.0f);
-        WindowFadeJob(ItemDragContainer* window, Mode mode, 
-            Ogre::Real targetAlpha = 1.0f, Ogre::Real changeRate = 4.0f);
+        //WindowFadeJob(ItemDragContainer* window, Mode mode, 
+        //    Ogre::Real targetAlpha = 1.0f, Ogre::Real changeRate = 4.0f);
 
         virtual bool execute(Ogre::Real time);
         virtual void discard();
@@ -49,7 +49,7 @@
     protected:
         AbstractWindow* mAbstractWindow;
         CEGUI::Window* mCEGUIWindow;
-        ItemDragContainer* mItemDragContainer;
+        //ItemDragContainer* mItemDragContainer;
         Mode mMode;
         Ogre::Real mChangeRate;
         Ogre::Real mCurrentAlpha;

Modified: rl/trunk/engine/ui/src/CombatControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatControlState.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/CombatControlState.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -22,6 +22,7 @@
 #include &quot;Combat.h&quot;
 #include &quot;CombatGui.h&quot;
 #include &quot;CombatManager.h&quot;
+#include &quot;CommandMapper.h&quot;
 #include &quot;CoreSubsystem.h&quot;
 #include &quot;Creature.h&quot;
 #include &quot;CreatureController.h&quot;
@@ -49,7 +50,21 @@
           mEnemySelector(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager(),
             QUERYFLAG_CREATURE),
           mCamera(NULL),
-		  mState(ROUND_EXECUTION)
+		  mState(ROUND_EXECUTION),
+          mCameraYaw(0),
+          mCameraPitch(60), // the same value as in resetCamera
+          mMovementState(0),
+          mCameraLinearSpringK(100.0f),
+          mCameraLinearDampingK(Math::NEG_INFINITY),
+          mViewMode(VM_COMBAT_CENTERED),
+          mCameraFocusedCombatant(NULL),
+          mCameraTransitionLookAtActive(false),
+          mCameraTransitionPositionActive(false),
+          mCameraMaxDistance(30.0f),
+          mCameraCombatCenteredMinDistance(5.0f),
+          mCameraThirdPersonMinDistance(1.0f),
+          mCameraSwitchDist(30.0f),
+          mCameraSwitchTransitionDist(0.8f)
     {
         CreatureSelectionFilter* filter = new CreatureSelectionFilter();
         filter-&gt;setAlignmentMask(Creature::ALIGNMENT_ENEMY);
@@ -74,6 +89,11 @@
 
         mCamera = static_cast&lt;CameraObject*&gt;(mCameraActor-&gt;getControlledObject());
 		mCombatGui = new CombatGui(mCombat, mCamera);
+
+
+        // calculate camera spring-damping system coefficients
+        Real relationCoefficient = 0.8f;
+        mCameraLinearDampingK = relationCoefficient * 2.0 * Math::Sqrt(mCameraLinearSpringK);
     }
 
 	CombatControlState::~CombatControlState()
@@ -85,9 +105,40 @@
 
     void CombatControlState::resume()
     {
-        mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
-        mCharacterActor-&gt;getPhysicalThing()-&gt;freeze();
+        // control camera
+        mCameraActor-&gt;getPhysicalThing()-&gt;setMaterialID(
+        PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;));
+        mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
+        mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(this);
+        mCameraActor-&gt;getPhysicalThing()-&gt;setUpConstraint(Vector3::ZERO);
+        
+        // We also handle cam&lt;-&gt;level, cam&lt;-&gt;default cam&lt;-&gt;char collision from now on
+        OgreNewt::MaterialPair* mat_pair = NULL;
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;));
+        mat_pair-&gt;setContactCallback(this);
+        mat_pair-&gt;setDefaultCollidable(1);
+        mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair-&gt;setDefaultFriction(0,1);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
+        mat_pair-&gt;setContactCallback(this);
+        mat_pair-&gt;setDefaultCollidable(1);
+        mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair-&gt;setDefaultFriction(0,1);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
+        mat_pair-&gt;setContactCallback(this);
+        mat_pair-&gt;setDefaultCollidable(1);
+        mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair-&gt;setDefaultFriction(0,1);
 
+       
+
+
         ///\todo Richtig machen, nur tempor&#228;r Ani hier setzen.
         static_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject())
             -&gt;startAnimation(&quot;kampf_schwerter_idle&quot;);
@@ -119,24 +170,361 @@
         mCombat-&gt;addAlly(this);
 
         mCombat-&gt;start();
+
+        // reset camera
+        //resetCamera(); // if you don't call this here, the camera should smoothly move to the new position -&gt; looks nicer
+        // perhaps this should be handled differently!
+        mMovementState = 0;
+        // calculate some buffered values, so they are initialized:
+        mCameraTransitionPositionActive = false;
+        mCameraTransitionLookAtActive = false;
+        mCameraFocusedCombatant = this;
+        mCameraYaw = Degree(0);
+        mCameraPitch = Degree(50);
+        mCameraDistance = 30.0f; // only used for third-person
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+        calculateOptimalCameraPositionAndLookAt();
+ 
+        // update CombatGui
+        mCombatGui-&gt;update();
     }
 
     void CombatControlState::pause()
     {
-		mCombatGui-&gt;hide();
+        mCombatGui-&gt;hide();
 
-        mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
-        mCharacterActor-&gt;getPhysicalThing()-&gt;unfreeze();
+
+        // stop controlling camera actor
+        mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
+        mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
+        // cam&lt;-&gt;Level collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;));
+        // cam&lt;-&gt;Default collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
+
         static_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject())-&gt;stopAllAnimations();
 
         mCombat-&gt;pause();
     }
 
-	void CombatControlState::run(Ogre::Real elapsedTime)
+    bool CombatControlState::keyPressed(const OIS::KeyEvent&amp; evt, bool handled)
     {
-		mCombatGui-&gt;update();
+        bool retval = false;
+        if( !handled )
+        {
+            int movement = mCommandMapper-&gt;getMovement(evt.key);
+            mMovementState |= movement;
+            
+            if( movement != MOVE_NONE )
+                retval = true;
+        }
+
+        if( ControlState::keyPressed(evt, handled || retval) )
+            retval = true;
+
+        return retval;
     }
+     
+    bool CombatControlState::keyReleased(const OIS::KeyEvent&amp; evt, bool handled)
+    {
+        bool retval = false;
+        int movement = mCommandMapper-&gt;getMovement(evt.key);
+        if( movement != MOVE_NONE )
+        {
+            mMovementState &amp;= (~movement);
+            retval = true;
+        }
 
+        if( ControlState::keyReleased(evt, handled || retval) )
+            retval = true;
+        return retval;
+    }
+
+    void CombatControlState::run(Ogre::Real elapsedTime)
+    {
+        // updateCameraLookAt should be called before mCombatGui-&gt;update()!
+
+        // update camera look-at position
+        updateCameraLookAt(elapsedTime);
+
+
+        // update CombatGui
+        mCombatGui-&gt;update();
+
+
+        // slow down rotational movement, when radius grows
+        if( mMovementState &amp; MOVE_RIGHT )
+            mCameraYaw += Degree( 360.0/2.0 * elapsedTime / Math::Sqrt(mCameraDistance) );
+        if( mMovementState &amp; MOVE_LEFT )
+            mCameraYaw -= Degree( 360.0/2.0 * elapsedTime / Math::Sqrt(mCameraDistance) );
+        if( mMovementState &amp; MOVE_FORWARD )
+            mCameraDistance -= 5 * elapsedTime;
+        if( mMovementState &amp; MOVE_BACKWARD )
+            mCameraDistance += 5 * elapsedTime;
+
+        mCameraDistance = std::max( mCameraDistance, mCameraThirdPersonMinDistance);
+        mCameraDistance = std::min( mCameraDistance, mCameraMaxDistance);
+
+        // switch view mode smoothly if nearer:
+        if( mViewMode == VM_COMBAT_CENTERED )
+        {
+            if( mMovementState &amp; MOVE_FORWARD )
+            {
+                mViewMode = VM_THIRD_PERSON;
+            }
+        }
+        else // VM_THIRD_PERSON
+        {
+            if( mCameraDistance &gt;= mCameraSwitchDist - 0.05f &amp;&amp; mMovementState &amp; MOVE_BACKWARD )
+            {
+                mViewMode = VM_COMBAT_CENTERED;
+            }
+        }
+    }
+
+    void CombatControlState::resetCamera(void)
+    {
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+        mCameraTransitionPositionActive = false;
+        mCameraTransitionLookAtActive = false;
+        mCameraYaw = Degree(0);
+        mCameraPitch = Degree(50);
+        if( mViewMode == VM_THIRD_PERSON )
+            mCameraDistance = 2.0f; // only used for third-person
+        calculateOptimalCameraPositionAndLookAt();
+        mCameraActor-&gt;setPosition(mCameraOptPos);
+        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
+        cameraNode-&gt;lookAt(mCameraLookAt, Node::TS_WORLD);
+    }
+
+    void CombatControlState::updateCameraLookAt(Real elapsedTime)
+    {
+        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
+        cameraNode-&gt;lookAt(mCameraLookAt, Node::TS_WORLD);
+    }
+
+    Vector3 CombatControlState::calculateCombatCenterPosition()
+    {
+        // get the center of all persons (allies and opponents)
+        int n = 0;
+        Vector3 pos = Vector3::ZERO;
+
+        const Combat::CombatantSet &amp;allies (mCombat-&gt;getAllPlayerAllies() );
+        for(Combat::CombatantSet::const_iterator it = allies.begin(); it != allies.end(); it++)
+        {
+            pos += (*it)-&gt;getCreature()-&gt;getPosition();
+            n++;
+        }
+
+        const Combat::CombatantSet &amp;opponents (mCombat-&gt;getAllPlayerOpponents());
+        for(Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); it++)
+        {
+            pos += (*it)-&gt;getCreature()-&gt;getPosition();
+            n++;
+        }
+
+        if( n &gt; 0 )
+            pos /= n;
+        else
+        {
+            pos = mCharacter-&gt;getPosition();
+        }
+
+        return pos;
+    }
+
+    Real CombatControlState::calculateCombatRadius(Vector3 center)
+    {
+        // get the greatest distance from center from all persons
+        Real distance = 0;
+        const Combat::CombatantSet &amp;allies (mCombat-&gt;getAllPlayerAllies() );
+        for(Combat::CombatantSet::const_iterator it = allies.begin(); it != allies.end(); it++)
+        {
+            distance = std::max( ( (*it)-&gt;getCreature()-&gt;getPosition() - center ).length(), distance );
+        }
+        const Combat::CombatantSet &amp;opponents = mCombat-&gt;getAllPlayerOpponents();
+        for(Combat::CombatantSet::const_iterator it = opponents.begin(); it != opponents.end(); it++)
+        {
+            distance = std::max( ( (*it)-&gt;getCreature()-&gt;getPosition() - center ).length(), distance );
+        }
+        return distance;
+    }
+    
+    void CombatControlState::calculateOptimalCameraPositionAndLookAt()
+    {
+        // some variables:
+        Vector3 playerPos = mCharacter-&gt;getPosition();
+        mCombatCenter = calculateCombatCenterPosition();
+        mCombatRadius = calculateCombatRadius(mCombatCenter);
+
+
+
+        // calculate camera-distance for VM_COMBAT_CENTERED (needed for third-person view, too)
+        Real combatCenteredDistance = mCombatRadius + 2; // this is camera-distance from center projected to the plane!
+            
+        // put camera on the line player-center far enough to see all persons
+        // if player is &quot;exactly&quot; in the center, use player orientation as fallback orientation
+        // + rotation from mCameraYaw
+        Vector3 diff = playerPos - mCombatCenter;
+        diff.y = 0;
+        Quaternion combatCenteredCamYaw;
+        combatCenteredCamYaw.FromAngleAxis(mCameraYaw, Vector3::UNIT_Y);
+        if( diff.squaredLength() &lt; 0.01 )
+        {
+            diff = mCharacterActor-&gt;getOrientation()*Vector3::UNIT_Z;
+        }
+        diff.y = 0;
+        diff.normalise();
+        diff = combatCenteredCamYaw*diff;
+        diff.y = Math::Tan(mCameraPitch.valueRadians());
+
+        Real cosPitch = Math::Cos(mCameraPitch.valueRadians());
+        combatCenteredDistance = std::max( combatCenteredDistance,  mCameraCombatCenteredMinDistance*cosPitch );
+        combatCenteredDistance = std::min( combatCenteredDistance,  mCameraMaxDistance*cosPitch );
+ 
+
+
+
+
+        // TODO
+        // Bewegung wirkt zu eckig... evt hilft es lookat und position separat zu berechnen
+        // und dabei das lookat schneller auf den anvisierten combatant zu setzen...
+        // ideal scheint mir eine &quot;runde&quot; bewegung, a la kamerafahrt!
+
+
+        Vector3 center;
+        Vector3 dist;
+        if( mViewMode == VM_THIRD_PERSON &amp;&amp; mCameraFocusedCombatant )
+        {
+            center = mCameraFocusedCombatant-&gt;getPosition();
+            // if mCameraDistance is near the one needed for combatCentered,
+            // interpolate the center (between center of third-person-view
+            // and center of combat-centered-view)
+            Real interpolateDist = std::max(0.0f, combatCenteredDistance - mCameraDistance*cosPitch) / cosPitch;
+            if( interpolateDist &lt;  mCameraSwitchTransitionDist*mCameraSwitchDist )
+            {
+                center += (mCombatCenter - center)*(1 - interpolateDist/(mCameraSwitchTransitionDist*mCameraSwitchDist));
+            }
+            dist = mCameraDistance*cosPitch;
+        }
+        else // assume VM_COMBAT_CENTERED
+        {
+            center = mCombatCenter;
+            // update camera-distance variable
+            mCameraDistance = (combatCenteredDistance*diff).length();
+            dist = combatCenteredDistance;
+        }
+
+        mCameraSwitchDist = (combatCenteredDistance*diff).length();
+        mCameraOptPos = center + dist*diff;
+        mCameraLookAt = center + 1.4*Vector3::UNIT_Y;
+    }
+
+    void CombatControlState::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
+    {
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody-&gt;getPositionOrientation(camPos, camOri);
+
+        calculateOptimalCameraPositionAndLookAt();
+
+        // handle transition
+        if( mCameraTransitionPositionActive )
+        {
+            Vector3 diff = mCameraOptPos - mCameraTransitionPosition;
+            Real dist = diff.length();
+            Vector3 dir = diff/dist;
+            mCameraTransitionPosition += dir*std::min(dist, 0.5f*timestep);
+            if( (mCameraTransitionPosition - mCameraOptPos).squaredLength() &lt; 0.02 )
+                mCameraTransitionPositionActive = false;
+            mCameraOptPos = mCameraTransitionPosition;
+        }
+        if( mCameraTransitionLookAtActive )
+        {
+            Vector3 diff = mCameraLookAt - mCameraTransitionLookAt;
+            Real dist = diff.length();
+            Vector3 dir = diff/dist;
+            mCameraTransitionLookAt += dir * std::min(dist,0.5f*timestep);
+            if( (mCameraLookAt-mCameraTransitionLookAt).squaredLength() &lt; 0.02 )
+                mCameraTransitionLookAtActive = false;
+            mCameraLookAt = mCameraTransitionLookAt;
+        }
+
+
+        Vector3 diff = camPos - mCameraOptPos;
+        Vector3 cameraVelocity;
+        cameraVelocity = mCamBody-&gt;getVelocity();
+        // spring velocity
+        Vector3 springAcc = -mCameraLinearSpringK*diff - mCameraLinearDampingK * cameraVelocity;
+                                            
+        // get the camera mass
+        Real mass;
+        Vector3 inertia;
+        mCamBody-&gt;getMassMatrix(mass, inertia);
+                                                
+        mCamBody-&gt;setForce(springAcc * mass);
+    }
+
+    void CombatControlState::setViewMode(ViewMode mode)
+    {
+        if(mode != mViewMode)
+        {
+            mViewMode = mode;
+            mCameraTransitionPosition = mCameraActor-&gt;getPosition();
+            mCameraTransitionLookAt = mCameraLookAt;
+            mCameraTransitionLookAtActive = true;
+            mCameraTransitionPositionActive = true;
+        }
+    }
+
+    void CombatControlState::toggleViewMode()
+    {
+        if( mViewMode == VM_COMBAT_CENTERED )
+            setViewMode(VM_THIRD_PERSON);
+        else
+            setViewMode(VM_COMBAT_CENTERED);
+    }
+
+    CombatControlState::ViewMode CombatControlState::getViewMode()
+    {
+        return mViewMode;
+    }
+
+    void CombatControlState::setCameraFocusedCombatant(Combatant* combatant)
+    {
+        if( combatant != mCameraFocusedCombatant )
+        {
+            if( mViewMode == VM_THIRD_PERSON )
+            {
+                mCameraTransitionPosition = mCameraActor-&gt;getPosition();
+                mCameraTransitionLookAt = mCameraLookAt;
+                mCameraTransitionLookAtActive = true;
+                mCameraTransitionPositionActive = true;
+            }
+        }
+        mCameraFocusedCombatant = combatant;
+    }
+
+    int CombatControlState::onAABBOverlap(OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex)
+    {
+        // TODO handle camera collisions here
+        return 0;
+    }
+   
+    void CombatControlState::userProcess(OgreNewt::ContactJoint &amp;contactJoint, Ogre::Real timestep, int threadIndex)
+    {
+        // TODO handle camera collisions here
+    }
+
     Ogre::String CombatControlState::getCombatantTypeName() const
     {
         return &quot;CombatControlState&quot;;

Modified: rl/trunk/engine/ui/src/CombatGui.cpp
===================================================================
--- rl/trunk/engine/ui/src/CombatGui.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/CombatGui.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -106,14 +106,15 @@
                 (*it)-&gt;getCreatureController()-&gt;getCreature()-&gt;getActor()
                     -&gt;_getSceneNode()-&gt;_getWorldAABB());
 
-			// Place buttons, if needed by current state
-			if (mUserInputEnabled)
-			{
-				Ogre::Rect screenRect = mCamera-&gt;getPixelRectOnScreen(rec);
-				// Place button set above opponent, horizontally centered.
-				int xpos = screenRect.left + ((screenRect.right - screenRect.left) - setSize.first) / 2;
-				mCombatWindow-&gt;placeEnemyButtonSet(mOpponentButtons[*it], xpos, screenRect.top - setSize.second);
-			}
+			// Place buttons, update every frame (camera movement requires this)
+                        // TODO: is there any better possibility (attach button-windows to ogre node?!?)
+			//if (mUserInputEnabled)
+			//{
+			Ogre::Rect screenRect = mCamera-&gt;getPixelRectOnScreen(rec);
+			// Place button set above opponent, horizontally centered.
+			int xpos = screenRect.left + ((screenRect.right - screenRect.left) - setSize.first) / 2;
+			mCombatWindow-&gt;placeEnemyButtonSet(mOpponentButtons[*it], xpos, screenRect.top - setSize.second);
+			//}
 
 			// draw Hud
 

Modified: rl/trunk/engine/ui/src/Console.cpp
===================================================================
--- rl/trunk/engine/ui/src/Console.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/Console.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -57,9 +57,15 @@
 		mCommandLine-&gt;subscribeEvent(
 			Editbox::EventKeyUp,
 			boost::bind(&amp;Console::handleKeyUp, this, _1));
-		mWindow-&gt;subscribeEvent(FrameWindow::EventCloseClicked,
-            boost::bind(&amp;Console::hideWindow, this));
+		mWindow-&gt;subscribeEvent(
+                        FrameWindow::EventCloseClicked,
+                        boost::bind(&amp;Console::hideWindow, this));
+                mWindow-&gt;subscribeEvent(
+                        FrameWindow::EventActivated,
+                        boost::bind(&amp;Console::handleActivated, this, _1));
 
+                mWindow-&gt;setAlwaysOnTop(true);
+
 		// load history from file
         if( ConfigurationManager::getSingleton().getIntSetting(&quot;General&quot;, &quot;Save Console History&quot;) &gt; 0 )
         {
@@ -282,5 +288,11 @@
 		else
 			mCommandLine-&gt;setText(mHistory[mHistoryMarker]);
 	}
+
+        bool Console::handleActivated(const CEGUI::EventArgs&amp;)
+        {
+            mCommandLine-&gt;activate();
+            return false;
+        }
 }
 

Modified: rl/trunk/engine/ui/src/ContainerContentWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/ContainerContentWindow.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -72,7 +72,7 @@
 
 		if (evtArgs.dragDropItem-&gt;testClassName(&quot;ItemDragContainer&quot;))
 		{
-			ItemDragContainer* dragcont = static_cast&lt;ItemDragContainer*&gt;(
+			ItemDragContainer* dragcont = dynamic_cast&lt;ItemDragContainer*&gt;(
 				evtArgs.dragDropItem);
 			Item* item = dragcont-&gt;getItem();
 
@@ -158,7 +158,7 @@
 
 		if (evtArgs.dragDropItem-&gt;testClassName(&quot;ItemDragContainer&quot;))
 		{
-			ItemDragContainer* dragcont = static_cast&lt;ItemDragContainer*&gt;(
+			ItemDragContainer* dragcont = dynamic_cast&lt;ItemDragContainer*&gt;(
 				evtArgs.dragDropItem);
 			Item* item = dragcont-&gt;getItem();
 
@@ -179,7 +179,8 @@
             {
                 if( dragcont != getItemWindow(item) )
                 {
-                    dragcont-&gt;destroyWindow();
+                    CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
+                    //dragcont-&gt;destroyWindow();
                     dragcont = createItemWindow(item);
                     mContentWindow-&gt;addChildWindow(dragcont);
                 }
@@ -211,8 +212,11 @@
 			mWindow-&gt;getName() +  &quot;/item/&quot;
 			+ Ogre::StringConverter::toString(item-&gt;getId())+&quot;_DragContainer&quot;;
 
-		itemhandler = new ItemIconDragContainer(item,
-			dragContainerName);
+                itemhandler = dynamic_cast&lt;ItemIconDragContainer*&gt;(
+                    AbstractWindow::loadWindow(&quot;itemicondragcontainer.xml&quot;, dragContainerName));
+                    //CEGUI::WindowManager::getSingleton().createWindow(&quot;ItemIconDragContainer&quot;, dragContainerName));
+                itemhandler-&gt;setItem(item);
+		//itemhandler = new ItemIconDragContainer(item, dragContainerName);
         itemhandler-&gt;setDestroyListener(this);
         mItemDragContainerMap.insert(std::make_pair(item, itemhandler));
 		itemhandler-&gt;setItemParent(mContainer);

Modified: rl/trunk/engine/ui/src/FreeflightControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/FreeflightControlState.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/FreeflightControlState.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -46,7 +46,8 @@
         mCollisionsEnabled(false),
         mPitchRange(Degree(-89), Degree(89)),
         mYaw(Degree(0)),
-        mPitch(Degree(0))
+        mPitch(Degree(0)),
+        mOgreNewtPlayerController(NULL)
 	{
         mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting(&quot;Input&quot;, &quot;Mouse Sensitivity&quot;);
         mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting(&quot;Input&quot;, &quot;Mouse Invert&quot;);
@@ -59,7 +60,10 @@
     void FreeflightControlState::pause()
     {
 		mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
-		mCharacterActor-&gt;getPhysicalThing()-&gt;unfreeze();
+		//mCharacterActor-&gt;getPhysicalThing()-&gt;unfreeze();
+        delete mOgreNewtPlayerController;
+        mOgreNewtPlayerController = NULL;
+        mCharacterActor-&gt;getPhysicalThing()-&gt;setUpConstraint();
         mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
 
         // Char&lt;-&gt;Level collision back to default
@@ -78,7 +82,9 @@
     void FreeflightControlState::resume()
     {
         mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
-		mCharacterActor-&gt;getPhysicalThing()-&gt;freeze();
+		//mCharacterActor-&gt;getPhysicalThing()-&gt;freeze();
+        mCharacterActor-&gt;getPhysicalThing()-&gt;clearUpConstraint();
+        mOgreNewtPlayerController = new OgreNewt::PlayerController(mCharBody);
 
         resetCamera();
 
@@ -92,21 +98,30 @@
         mat_pair = PhysicsManager::getSingleton().createMaterialPair(
                     PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
                     PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;));
-        mat_pair-&gt;setContactCallback(this);
+        mat_pair-&gt;setContactCallback(NULL);
         mat_pair-&gt;setContinuousCollisionMode(1);
+        mat_pair-&gt;setDefaultSoftness(1.0f);
         mat_pair-&gt;setDefaultCollidable(1);
+        mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair-&gt;setContactCallback(this);
         mat_pair = PhysicsManager::getSingleton().createMaterialPair(
                     PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
                     PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
-        mat_pair-&gt;setContactCallback(this);
+        mat_pair-&gt;setContactCallback(NULL);
         mat_pair-&gt;setContinuousCollisionMode(1);
+        mat_pair-&gt;setDefaultSoftness(1.0f);
         mat_pair-&gt;setDefaultCollidable(1);
+        mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair-&gt;setContactCallback(this);
         mat_pair = PhysicsManager::getSingleton().createMaterialPair(
                     PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
                     PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
-        mat_pair-&gt;setContactCallback(this);
+        mat_pair-&gt;setContactCallback(NULL);
         mat_pair-&gt;setContinuousCollisionMode(1);
+        mat_pair-&gt;setDefaultSoftness(1.0f);
         mat_pair-&gt;setDefaultCollidable(1);
+        mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair-&gt;setContactCallback(this);
     }
 
 	void FreeflightControlState::run(Real elapsedTime)
@@ -198,11 +213,20 @@
         if (mPitch &lt; mPitchRange.first) mPitch = mPitchRange.first;
         if (mPitch &gt; mPitchRange.second) mPitch = mPitchRange.second;
 
+if( mCollisionsEnabled )
+    mOgreNewtPlayerController-&gt;setVelocity(mDesiredVelocity.z, mDesiredVelocity.x, mYaw);
+
         mCameraActor-&gt;setOrientation(Quaternion::IDENTITY);
         mCameraActor-&gt;yaw(mYaw.valueDegrees());
         mCameraActor-&gt;pitch(mPitch.valueDegrees());
     }
 
+    
+    int FreeflightControlState::onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex )
+    {
+        return mCollisionsEnabled;
+    }
+
 	void FreeflightControlState::toggleCameraCollision()
 	{
 		// with or without collision?
@@ -286,35 +310,12 @@
         return retval;
 	}
 
-    int FreeflightControlState::userProcess()
-    {
-        if (m_body0 == mCamBody || m_body1 == mCamBody)
-        {
-            // this is camera collision
 
-            if( !mCollisionsEnabled )
-                return 0;
-
-            setContactSoftness(1.0f);  // &quot;weiche&quot; Collision
-            setContactElasticity(0.0f);
-
-            return 1;
-        }
-
-        // return one to tell Newton we want to accept this contact
-        return 1;
-    }
-
-
-
-    void FreeflightControlState::OnApplyForceAndTorque(PhysicalThing* thing)
+    void FreeflightControlState::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
     {
         OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
         OgreNewt::Body* body = thing-&gt;_getBody();
 
-        // Get the current world timestep
-        Real timestep = world-&gt;getTimeStep();
-
         if (body == mCamBody)
         {
             // apply camera force
@@ -332,7 +333,8 @@
             Vector3 currentVel = body-&gt;getVelocity();
             Real delay = 2 * PhysicsManager::getSingleton().getMaxTimestep();
             Vector3 force = mass*(orientation * mDesiredVelocity - currentVel) / delay;
-
+if( mCollisionsEnabled )
+    force = mass*(- currentVel) / delay;
             body-&gt;setForce(force);
         }
     }

Modified: rl/trunk/engine/ui/src/InventoryWindow.cpp
===================================================================
--- rl/trunk/engine/ui/src/InventoryWindow.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/InventoryWindow.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -23,6 +23,7 @@
 #include &lt;CEGUIWindowManager.h&gt;
 #include &lt;elements/CEGUIFrameWindow.h&gt;
 
+#include &quot;AbstractWindow.h&quot;
 #include &quot;Actor.h&quot;
 #include &quot;ActorManager.h&quot;
 #include &quot;CameraObject.h&quot;
@@ -213,10 +214,19 @@
 		else
 		{
 			if (showdescription)
-				itemhandler = new ItemDescriptionDragContainer(item, dragContainerName);
+                        {
+				itemhandler = dynamic_cast&lt;ItemDescriptionDragContainer*&gt; (
+                                        AbstractWindow::loadWindow(&quot;itemdescriptiondragcontainer.xml&quot;, dragContainerName));
+                                //new ItemDescriptionDragContainer(item, dragContainerName);
+                                itemhandler-&gt;setItem(item);
+                        }
 			else
             {
-				itemhandler = new ItemIconDragContainer(item, dragContainerName);
+				itemhandler = dynamic_cast&lt;ItemIconDragContainer*&gt; (
+                                        AbstractWindow::loadWindow(&quot;itemicondragcontainer.xml&quot;, dragContainerName));
+                                    //CEGUI::WindowManager::getSingleton().createWindow(&quot;ItemIconDragContainer&quot;, dragContainerName));
+                                itemhandler-&gt;setItem(item);
+				//itemhandler = new ItemIconDragContainer(item, dragContainerName);
                 itemhandler-&gt;setTooltipText(item-&gt;getName());
             }
 
@@ -286,20 +296,14 @@
 
 			if (mInventory-&gt;canHold(item, targetSlot))
 			{
-				if (dragcont-&gt;getItemParentContainer() != NULL)
-				{
-					dragcont-&gt;getParent()-&gt;removeChildWindow(dragcont);
-				}
-				else if (dragcont-&gt;getItemParentSlot() != &quot;&quot;)
-				{
-					dragcont-&gt;getParent()-&gt;removeChildWindow(dragcont);
-				}
+				dragcont-&gt;getParent()-&gt;removeChildWindow(dragcont);
 
 				ItemDragContainer* newCont = createItemDragContainer(item, false, targetSlot);
 
 				if (newCont)
 				{
-                    dragcont-&gt;destroyWindow();
+                                    CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
+//                    dragcont-&gt;destroyWindow();
 				}
 				else
 				{
@@ -412,7 +416,8 @@
 				-1);
 
 
-            dragcont-&gt;destroyWindow();
+                        CEGUI::WindowManager::getSingleton().destroyWindow(dragcont);
+//            dragcont-&gt;destroyWindow();
 
 			Ogre::Vector3 targetPosWorldSpace =
 				mInventory-&gt;getOwner()-&gt;getPosition()

Modified: rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/ItemDescriptionDragContainer.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -22,10 +22,34 @@
 #include &quot;AbstractWindow.h&quot;
 #include &quot;Item.h&quot;
 
+
+
+namespace CEGUI
+{
+    CEGUI_DEFINE_WINDOW_FACTORY(ItemDescriptionDragContainer)
+}
+
 namespace rl {
-	ItemDescriptionDragContainer::ItemDescriptionDragContainer(Item* item, const CeGuiString&amp; name)
-		: ItemDragContainer(item, name)
+
+    const CeGuiString ItemDescriptionDragContainer::WidgetTypeName(&quot;ItemDescriptionDragContainer&quot;);
+
+
+
+
+	ItemDescriptionDragContainer::ItemDescriptionDragContainer(const CeGuiString &amp;type, const CeGuiString&amp; name)
+		: ItemDragContainer(type, name)
 	{
+		CeGuiString prefix = name;
+
+		mContentWindow = this; //AbstractWindow::loadWindow(&quot;itemdescriptiondragcontainer.xml&quot;, prefix);
+		addChildWindow(mContentWindow);
+                mContentWindow-&gt;setDestroyedByParent(true);
+	}
+
+        void ItemDescriptionDragContainer::setItem(Item* item)
+        {
+            ItemDragContainer::setItem(item);
+
 		CeGuiString icon = item-&gt;getImageName();
 
 		if (icon == &quot;&quot;)
@@ -33,19 +57,20 @@
 			icon = ICON_UNKNOWN_ITEM;
 		}
 
-		CeGuiString prefix = name;
-		mContentWindow = AbstractWindow::loadWindow(&quot;itemdescriptiondragcontainer.xml&quot;, prefix);
+                const CeGuiString &amp;name = getName();
 
+
 		mContentWindow-&gt;getChild(
-			name+&quot;ItemDescriptionDragContainer/Icon&quot;)
+			name+&quot;/Icon&quot;)
 			-&gt;setProperty(&quot;Image&quot;, icon);
 		mContentWindow-&gt;getChild(
-			name+&quot;ItemDescriptionDragContainer/Name&quot;)
+			name+&quot;/Name&quot;)
 			-&gt;setText(item-&gt;getName());
 		mContentWindow-&gt;getChild(
-			name+&quot;ItemDescriptionDragContainer/Description&quot;)
+			name+&quot;/Description&quot;)
 			-&gt;setText(item-&gt;getDescription());
 
+
 		mContentWindow-&gt;subscribeEvent(
 			Window::EventMouseClick,
 			boost::bind(&amp;ItemDragContainer::_handleItemMouseClick, this, _1, item));
@@ -54,7 +79,8 @@
 			Window::EventMouseDoubleClick,
 			boost::bind(&amp;ItemDragContainer::_handleItemDoubleClick, this, _1, item));
 
-		setSize(mContentWindow-&gt;getSize());
-		addChildWindow(mContentWindow);
-	}
+
+
+	    setSize(mContentWindow-&gt;getSize());
+        }
 }

Modified: rl/trunk/engine/ui/src/ItemDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemDragContainer.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/ItemDragContainer.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -31,9 +31,9 @@
 namespace rl {
 	const Ogre::String ItemDragContainer::ICON_UNKNOWN_ITEM = &quot;set:ModelThumbnails image:item_unknown&quot;;
 
-	ItemDragContainer::ItemDragContainer(Item* item, const CeGuiString&amp; name)
-		: CEGUI::DragContainer(&quot;DragContainer&quot;, name),
-		mItem(item),
+	ItemDragContainer::ItemDragContainer(const CeGuiString &amp;type, const CeGuiString&amp; name)
+		: CEGUI::DragContainer(type, name),
+		mItem(NULL),
 		mParentContainer(NULL),
 		mParentSlot(&quot;&quot;),
 		mContentWindow(NULL),
@@ -43,10 +43,28 @@
 	{
 	}
 
-	ItemDragContainer::~ItemDragContainer()
+        void ItemDragContainer::setItem(Item* item)
+        {
+            if( mItem != NULL )
+                Throw(IllegalArgumentException,&quot;The item of an ItemDragContainer can only be set once!&quot;);
+            mItem = item;
+        }
+
+        ItemDragContainer::~ItemDragContainer()
+        {
+            if(mDestroyListener)
+                mDestroyListener-&gt;notifyItemDragContainerDestroyed(this);
+            setDestroyListener(NULL);
+        }
+
+	void ItemDragContainer::destroy()
 	{
-        if(mDestroyListener)
-            mDestroyListener-&gt;notifyItemDragContainerDestroyed(this);
+            if(mDestroyListener)
+                mDestroyListener-&gt;notifyItemDragContainerDestroyed(this);
+            setDestroyListener(NULL);
+
+            CEGUI::DragContainer::destroy();
+/*        
         stopFadeOut();
 
         hide();
@@ -59,8 +77,9 @@
 		removeChildWindow(mContentWindow);
 		CEGUI::WindowManager::getSingleton().destroyWindow(mContentWindow);
         CEGUI::WindowManager::getSingleton().destroyWindow(this);
+*/
 	}
-
+/*
     void ItemDragContainer::destroyWindow()
     {
         if(mDestroyListener)
@@ -80,7 +99,7 @@
             JobScheduler::JP_NORMAL,
             0.0f);
     }
-
+*/
 	void ItemDragContainer::setItemParent(Container* container)
 	{
 		mParentContainer = container;
@@ -179,4 +198,65 @@
 
         return true;
     }
+
+    void ItemDragContainer::setDestroyListener(ItemDragContainerDestroyListener *listener)
+    {
+        if( listener == mDestroyListener )
+            return ;
+
+        if( mDestroyListener )
+            mDestroyListener-&gt;removeDragContainer(this);
+
+        mDestroyListener = listener;
+
+        if( listener )
+            mDestroyListener-&gt;addDragContainer(this);
+    }
+
+
+    ItemDragContainerDestroyListener::ItemDragContainerDestroyListener() : mIsDestroying(false)
+    {
+    }
+
+    ItemDragContainerDestroyListener::~ItemDragContainerDestroyListener()
+    {
+        // remove all dragContainers from list
+        mIsDestroying = true;
+        for( DndContainerMap::iterator it = mContainers.begin(); it != mContainers.end(); it++ )
+            it-&gt;second-&gt;setDestroyListener(NULL);
+    }
+
+    void ItemDragContainerDestroyListener::addDragContainer(ItemDragContainer *dragcont)
+    {
+        if( dragcont == NULL )
+            Throw(NullPointerException, &quot;Parameter dragcont in ItemDragContainerDestroyListener::addDragContainer should not be NULL!&quot;);
+
+        DndContainerMap::iterator it = mContainers.find(dragcont-&gt;getName());
+        if( it != mContainers.end() )
+        {
+            Throw(IllegalArgumentException, &quot;ItemDragContainerDestroyListener::addDragContainer: ItemDragContainer with name '&quot;+
+                    dragcont-&gt;getName()+&quot;' already added!&quot;);
+        }
+
+        mContainers.insert(std::make_pair(dragcont-&gt;getName(), dragcont));
+    }
+
+    void ItemDragContainerDestroyListener::removeDragContainer(ItemDragContainer *dragcont)
+    {
+        if( mIsDestroying )  // if this Listener is destroyed, we don't need to care about the list
+            return ;
+
+        if( dragcont == NULL )
+            Throw(NullPointerException, &quot;Parameter dragcont in ItemDragContainerDestroyListener::removeDragContainer should not be NULL!&quot;);
+
+        DndContainerMap::iterator it = mContainers.find(dragcont-&gt;getName());
+        if( it == mContainers.end() )
+        {
+            Throw(IllegalArgumentException, &quot;ItemDragContainerDestroyListener::removeDragContainer: ItemDragContainer with name '&quot;+
+                    dragcont-&gt;getName()+&quot;' was not added before!&quot;);
+        }
+
+        mContainers.erase(it);
+   }
+
 }

Modified: rl/trunk/engine/ui/src/ItemIconDragContainer.cpp
===================================================================
--- rl/trunk/engine/ui/src/ItemIconDragContainer.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/ItemIconDragContainer.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -22,26 +22,49 @@
 #include &quot;AbstractWindow.h&quot;
 #include &quot;Item.h&quot;
 
+namespace CEGUI{
+    CEGUI_DEFINE_WINDOW_FACTORY(ItemIconDragContainer)
+}
 namespace rl {
-	ItemIconDragContainer::ItemIconDragContainer(Item* item, const CeGuiString&amp; name)
-		: ItemDragContainer(item, name)
+
+    const CeGuiString ItemIconDragContainer::WidgetTypeName(&quot;ItemIconDragContainer&quot;);
+
+
+
+	ItemIconDragContainer::ItemIconDragContainer(const CeGuiString &amp;type, const CeGuiString&amp; name)
+		: ItemDragContainer(type, name)
 	{
+		CeGuiString prefix = name;
+		mContentWindow = this; //AbstractWindow::loadWindow(&quot;itemicondragcontainer.xml&quot;, prefix);
+
+
+		for (size_t idx = 0; idx &lt; mContentWindow-&gt;getChildCount(); ++idx)
+		{
+			LOG_MESSAGE(Logger::UI, mContentWindow-&gt;getChildAtIdx(idx)-&gt;getName());
+		}
+
+		addChildWindow(mContentWindow);
+                mContentWindow-&gt;setDestroyedByParent(true);
+	}
+
+        void ItemIconDragContainer::setItem(Item* item)
+        {
+            ItemDragContainer::setItem(item);
+
+
+
+
 		CeGuiString icon = item-&gt;getImageName();
 
 		if (icon == &quot;&quot;)
 		{
 			icon = ICON_UNKNOWN_ITEM;
 		}
+                const CeGuiString &amp;name = getName();
 
-		CeGuiString prefix = name;
-		mContentWindow = AbstractWindow::loadWindow(&quot;itemicondragcontainer.xml&quot;, prefix);
 
-		for (size_t idx = 0; idx &lt; mContentWindow-&gt;getChildCount(); ++idx)
-		{
-			LOG_MESSAGE(Logger::UI, mContentWindow-&gt;getChildAtIdx(idx)-&gt;getName());
-		}
 
-		mContentWindow-&gt;getChild(name+&quot;ItemIconDragContainer/Icon&quot;)
+		mContentWindow-&gt;getChild(name+&quot;/Icon&quot;)
 			-&gt;setProperty(&quot;Image&quot;, icon);
 
 		mContentWindow-&gt;subscribeEvent(
@@ -59,6 +82,6 @@
 			cegui_absdim(item-&gt;getSize().first*30),
 			cegui_absdim(item-&gt;getSize().second*30)));
 
-		addChildWindow(mContentWindow);
-	}
+
+        }
 }

Modified: rl/trunk/engine/ui/src/MovementControlState.cpp
===================================================================
--- rl/trunk/engine/ui/src/MovementControlState.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/MovementControlState.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -1,1535 +1,1498 @@
-/* This source file is part of Rastullahs Lockenpracht.
-* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the Clarified Artistic License.
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  Clarified Artistic License for more details.
-*
-*  You should have received a copy of the Clarified Artistic License
-*  along with this program; if not you can get it here
-*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
-*/
-
-#include &quot;stdinc.h&quot;
-
-#include &quot;MovementControlState.h&quot;
-
-#include &lt;utility&gt;
-
-#include &quot;AbstractMovement.h&quot;
-#include &quot;Actor.h&quot;
-#include &quot;ActorManager.h&quot;
-#include &quot;CameraObject.h&quot;
-#include &quot;CommandMapper.h&quot;
-#include &quot;ConfigurationManager.h&quot;
-#include &quot;CoreSubsystem.h&quot;
-#include &quot;Creature.h&quot;
-#include &quot;CreatureControllerManager.h&quot;
-#include &quot;DebugWindow.h&quot;
-#include &quot;Exception.h&quot;
-#include &quot;GameObjectManager.h&quot;
-#include &quot;InputManager.h&quot;
-#include &quot;Logger.h&quot;
-#include &quot;MeshObject.h&quot;
-#include &quot;MeshAnimation.h&quot;
-#include &quot;MovementControlState.h&quot;
-#include &quot;PhysicsManager.h&quot;
-#include &quot;PhysicsMaterialRaycast.h&quot;
-#include &quot;PhysicalThing.h&quot;
-#include &quot;RulesMessages.h&quot;
-#include &quot;World.h&quot;
-#include &quot;LineSetPrimitive.h&quot;
-#include &quot;WindowFactory.h&quot;
-#include &quot;AnimationManager.h&quot;
-#include &quot;UiSubsystem.h&quot;
-#include &quot;WindowManager.h&quot;
-
-#include &lt;numeric&gt;
-
-using namespace Ogre;
-
-namespace rl {
-
-    Ogre::String MovementControlState::msDebugWindowPageName = &quot;MovementControlState&quot;;
-
-    MovementControlState::CharacterState::CharacterState()
-        :
-        mCurrentMovementState(MOVE_NONE),
-        mLastMovementState(MOVE_NONE)
-    {
-    }
-
-    MovementControlState::MovementControlState(CommandMapper* cmdMapper,
-        Actor* camera, Creature* character)
-        : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
-        mController(NULL),
-        mCharacterState(),
-        mDesiredDistance(2.00),
-        mDistanceRange(0.60, 7.00),
-        mCamYaw(0),
-        mCamVirtualYaw(0),
-        mNewCamVirtualYaw(0),
-        mPitch(20),
-        mRoll(0),
-        mPitchRange(Degree(-75), Degree(85)),
-        mLinearSpringK(400.0f),
-        mLinearDampingK(Math::NEG_INFINITY),
-        mCamMoveAwayVelocity(4.0f),
-        mCamMoveAwayStartTime(0.25f),
-        mCamMoveAwayRange(8.0f),
-        mLookAtOffset(),
-        mRotationSpeed(Degree(120.0f)),
-        mMouseSensitivity(4.0f),
-        mViewMode(VM_THIRD_PERSON),
-        mObstractedFrameCount(0),
-        mObstractedTime(0.0f),
-        mCameraJammedFrameCount(0),
-        mCameraJammedTime(0.0f),
-        mRaycast(new PhysicsMaterialRaycast()),
-        mSelector(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager()),
-        mCombatSelector(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager(),
-            QUERYFLAG_CREATURE),
-        mCharPositionsBuffer(20),
-        mCharPositionsBufferIdx(-1),
-        mCharacterOccludedTime(0),
-        mCharacterOccludedFrameCount(0),
-        mLastDistance(0.0f),
-        mTimeOfLastCollision(0.0f),
-        mIsPathfinding (false),
-        mLastReachableBufPos(1),
-        mLastCameraCollision(0)
-    {
-        DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
-
-
-        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting(&quot;Input&quot;, &quot;Mouse Sensitivity&quot;);
-        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting(&quot;Input&quot;, &quot;Mouse Invert&quot;);
-
-        // The relationCoefficient determines the relation between spring accel in target direction
-        // and damping in velocity direction. 1.0 means equilibrium is reached in optimal time
-        // smaller 1.0 means spring accel is stronger and thus cam shoots over the target, resulting
-        // in a damped ozillation before reaching equilibrium.
-        // Values greater than 1.0 mean damping is stronger and thus camera takes a detour.
-        Real relationCoefficient = 0.8f;
-        mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
-
-        // Offset for the look at point,
-        // so the cam does look at the characters head instead of the feet.
-        MeshObject* charMesh = dynamic_cast&lt;MeshObject*&gt;(
-            mCharacterActor-&gt;getControlledObject());
-        AxisAlignedBox aabb = charMesh-&gt;getDefaultSize();
-
-        // this will be recalculated in calculateOptimalCameraPosition
-        mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
-
-        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
-        filter-&gt;setAlignmentMask(Creature::ALIGNMENT_ENEMY);
-        mCombatSelector.setFilter(filter);
-
-        mSelector.setFilter(new InSceneSelectionFilter());
-
-        mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler&lt;MessageType_GameObjectsLoaded&gt;(
-            boost::bind(&amp;MovementControlState::updateAfterGameObjectLoading, this));
-
-        mMessageType_SaveGameLoading_Handler = MessagePump::getSingleton().addMessageHandler&lt;MessageType_SaveGameLoading&gt;(
-            boost::bind(&amp;MovementControlState::beforeLoadingSaveGame, this));
-    }
-
-    //------------------------------------------------------------------------
-    MovementControlState::~MovementControlState()
-    {
-        delete mCombatSelector.getFilter();
-        mCombatSelector.setFilter(NULL);
-        delete mSelector.getFilter();
-        mSelector.setFilter(NULL);
-        delete mRaycast;
-
-        if (DebugWindow::getSingletonPtr())
-        {
-            DebugWindow::getSingletonPtr()-&gt;unregisterPage(msDebugWindowPageName);
-        }
-
-        // Remove debug scene node from character node, if debugview was used.
-        if (mSceneNode != NULL &amp;&amp; mSceneNode-&gt;getParent() != NULL)
-        {
-            mCharacterActor-&gt;_getSceneNode()-&gt;removeChild(mSceneNode);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::pause()
-    {
-        mController = NULL;
-
-        // actors aren't controlled anymore
-        mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
-        mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
-        // cam&lt;-&gt;Level collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;));
-        // cam&lt;-&gt;Default collision back to default
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
-        PhysicsManager::getSingleton().resetMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
-
-
-        // Unhighlight selected object, if any.
-        GameObject* go = mSelector.getFirstSelectedObject();
-        if (go != NULL &amp;&amp; go-&gt;isHighlighted())
-        {
-            go-&gt;setHighlighted(false);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::resume()
-    {
-        if (mController == NULL )
-        {
-            mController =
-                CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
-        }
-
-        // We want to check for visibility from char's POV.
-        mSelector.setCheckVisibility(true, mCharacter);
-        mSelector.track(mCharacter);
-        mSelector.setRadius(3.0);
-
-        // Same for combat selector
-        mCombatSelector.setCheckVisibility(true, mCharacter);
-        mCombatSelector.track(mCharacter);
-        mCombatSelector.setRadius(10.0);
-
-
-        // control camera
-        mCameraActor-&gt;getPhysicalThing()-&gt;setMaterialID(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;));
-        mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
-        mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(this);
-        mCameraActor-&gt;getPhysicalThing()-&gt;setUpConstraint(Vector3::ZERO);
-
-        // We also handle cam&lt;-&gt;level, cam&lt;-&gt;default cam&lt;-&gt;char collision from now on
-        OgreNewt::MaterialPair* mat_pair = NULL;
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;));
-        mat_pair-&gt;setContactCallback(this);
-        mat_pair-&gt;setDefaultCollidable(1);
-        mat_pair-&gt;setDefaultFriction(0,0);
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
-        mat_pair-&gt;setContactCallback(this);
-        mat_pair-&gt;setDefaultCollidable(1);
-        mat_pair-&gt;setDefaultFriction(0,0);
-        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
-            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
-            PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
-        mat_pair-&gt;setContactCallback(this);
-        mat_pair-&gt;setDefaultCollidable(1);
-        mat_pair-&gt;setDefaultFriction(0,0);
-
-        mCharacterState.mCurrentMovementState = MOVE_NONE;
-
-        setViewMode(VM_THIRD_PERSON);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::run(Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        updateCharacter(elapsedTime);
-        updateCameraLookAt(elapsedTime);
-        updateSelection();
-
-
-
-        // camera pitch
-        if (!isMouseUsedByCegui() )
-        {
-            if (mInvertedMouse)
-                mPitch -= 0.5 * mMouseSensitivity * Degree(im-&gt;getMouseRelativeY() / 10);
-            else
-                mPitch += 0.5 * mMouseSensitivity * Degree(im-&gt;getMouseRelativeY() / 10);
-            if (mPitch &lt; mPitchRange.first) mPitch = mPitchRange.first;
-            if (mPitch &gt; mPitchRange.second) mPitch = mPitchRange.second;
-        }
-
-
-
-
-        // Do we need to reset the Camera?
-        Vector3 charPos = mCharacterActor-&gt;getWorldPosition();
-        Quaternion charOri = mCharacterActor-&gt;getWorldOrientation();
-        //mCharBody-&gt;getPositionOrientation(charPos, charOri);
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody-&gt;getPositionOrientation(camPos, camOri);
-
-        float maxdistance;
-        if (mViewMode == VM_FIRST_PERSON)
-            maxdistance = 0.25;
-        else
-            maxdistance = 1.3f * mDesiredDistance + 1.4f;
-
-        // if we have more than 250ms and at least five frames with camera distance higher
-        // than desired distance, reset camera
-        if ((camPos - (charPos + charOri*mLookAtOffset)).length() &gt; maxdistance)
-        {
-            mCameraJammedTime += elapsedTime;
-            ++mCameraJammedFrameCount;
-        }
-        else
-        {
-            mCameraJammedTime = 0.0f;
-            mCameraJammedFrameCount = 0;
-        }
-
-        if (mCameraJammedTime &gt; 0.250f &amp;&amp; mCameraJammedFrameCount &gt; 5)
-        {
-            mCameraJammedFrameCount = 0;
-            resetCamera();
-        }
-
-        mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
-
-        if (isEnemyNear() &amp;&amp; !(mCharacter-&gt;getLifeState() &amp; Effect::LS_NO_COMBAT))
-        {
-            InputManager::getSingleton().pushControlState(CST_COMBAT);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-        if( mController != NULL )
-        {
-            int movement = mCharacterState.mCurrentMovementState;
-            Degree rotation(0);
-
-            AbstractMovement *drehen = mController-&gt;getMovementFromId(CreatureController::MT_DREHEN);
-            Real baseVelocity = 0;
-            if( drehen-&gt;calculateBaseVelocity(baseVelocity) )
-            {
-                if( !(movement &amp; MOVE_RIGHT || movement &amp; MOVE_LEFT) )
-                {
-                    Degree baseVel(baseVelocity*360);
-                    if( mViewMode != VM_PNYX_MODE )
-                    {
-                        if (movement &amp; TURN_LEFT)
-                            rotation = elapsedTime * baseVel;
-                        if (movement &amp; TURN_RIGHT)
-                            rotation = -elapsedTime * baseVel;
-                    }
-
-                    // mouse
-                    if( !isMouseUsedByCegui() )
-                    {
-                        if (mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
-                        {
-                            if( !(movement &amp; TURN_LEFT || movement &amp; TURN_RIGHT) )
-                            {
-                                rotation = -mMouseSensitivity/3.0f * Degree(im-&gt;getMouseRelativeX())/200.0 * baseVel;
-                            }
-                        }
-                    }
-                }
-
-
-                if( mViewMode != VM_PNYX_MODE  &amp;&amp; mViewMode != VM_FIRST_PERSON )
-                {
-                    // virtual yaw
-                    if( mCamVirtualYaw != mNewCamVirtualYaw )
-                    {
-                        mCamVirtualYaw = mNewCamVirtualYaw;
-                    }
-                    if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) ||
-                        ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) )
-                    {
-                        mNewCamVirtualYaw = Degree(45);
-                    }
-                    else if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) ||
-                        ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) )
-                    {
-                        mNewCamVirtualYaw = Degree(-45);
-                    }
-                    else
-                    {
-                        mNewCamVirtualYaw =Degree(0);
-                    }
-                    if( mCamVirtualYaw != mNewCamVirtualYaw )
-                    {
-                        rotation += mCamVirtualYaw - mNewCamVirtualYaw;
-                    }
-                }
-
-                if( mViewMode == VM_FIRST_PERSON )
-                {
-                    if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) ||
-                        ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) )
-                    {
-                        mCamVirtualYaw -= Degree(270)*elapsedTime;
-                        if( mCamVirtualYaw &lt;= Degree(-90) )
-                            mCamVirtualYaw = Degree(-90);
-                    }
-                    else if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) ||
-                             ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) )
-                    {
-                        mCamVirtualYaw += Degree(270)*elapsedTime;
-                        if( mCamVirtualYaw &gt;= Degree(90) )
-                            mCamVirtualYaw = Degree(90);
-                    }
-                    else
-                    {
-                        if( mCamVirtualYaw &gt; Degree(0) )
-                        {
-                            mCamVirtualYaw -= Degree(270)*elapsedTime;
-                            if( mCamVirtualYaw &lt;= Degree(0) )
-                                mCamVirtualYaw = Degree(0);
-                        }
-                        else if( mCamVirtualYaw &lt; Degree(0) )
-                        {
-                            mCamVirtualYaw += Degree(270)*elapsedTime;
-                            if( mCamVirtualYaw &gt;= Degree(0) )
-                                mCamVirtualYaw = Degree(0);
-                        }
-                    }
-                }
-            }
-
-
-
-            if( mViewMode != VM_PNYX_MODE )
-            {
-                if( mController-&gt;getMovementId() == CreatureController::MT_HOCHSPRUNG )
-                {
-                    // move forward or backward if wanted
-                    Vector3 direction = Vector3::UNIT_Y;
-                    if( movement &amp; MOVE_FORWARD )
-                        direction += Vector3::NEGATIVE_UNIT_Z;
-                    else if( movement &amp; MOVE_BACKWARD )
-                        direction += Vector3::UNIT_Z;
-
-                    mController-&gt;setMovement(
-                        CreatureController::MT_HOCHSPRUNG,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement &amp; MOVE_SNEAK )
-                {
-                    Vector3 direction(Vector3::ZERO);
-                    if (movement &amp; MOVE_FORWARD)
-                        direction.z = -1;
-                    else if( movement &amp; MOVE_BACKWARD)
-                        direction.z = 1;
-                    mController-&gt;setMovement(
-                        CreatureController::MT_SCHLEICHEN,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement &amp; MOVE_JUMP &amp;&amp; 
-                    mController-&gt;getMovementFromId(CreatureController::MT_HOCHSPRUNG)-&gt;isPossible() )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
-                    Vector3 direction = Vector3::UNIT_Y;
-                    if( movement &amp; MOVE_FORWARD )
-                    {
-                        type = CreatureController::MT_WEITSPRUNG;
-                        direction += Vector3::NEGATIVE_UNIT_Z;
-                    }
-                    mController-&gt;setMovement(
-                        type,
-                        direction,
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if( movement &amp; MOVE_FORWARD )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_GEHEN;
-                    if( movement &amp; MOVE_RUN_LOCK )
-                    {
-                        if( movement &amp; MOVE_RUN )
-                            type = CreatureController::MT_RENNEN;
-                        else
-                            type = CreatureController::MT_LAUFEN;
-                    }
-                    else
-                    {
-                        if( movement &amp; MOVE_RUN )
-                            type = CreatureController::MT_GEHEN;
-                        else
-                            type = CreatureController::MT_JOGGEN;
-                    }
-                    mController-&gt;setMovement(
-                        type,
-                        Vector3(0,0,-1), 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if (movement &amp; MOVE_BACKWARD )
-                {
-                    CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
-                    if( !(movement &amp; MOVE_RUN) )
-                        type = CreatureController::MT_RUECKWAERTS_JOGGEN;
-                    mController-&gt;setMovement(
-                        type,
-                        Vector3(0,0,1), 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else if (movement &amp; MOVE_LEFT || movement &amp; MOVE_RIGHT)
-                {
-                    Vector3 direction = Vector3::UNIT_X;
-                    if( movement &amp; MOVE_LEFT )
-                        direction = Vector3::NEGATIVE_UNIT_X;
-                    mController-&gt;setMovement(
-                        CreatureController::MT_SEITWAERTS_GEHEN,
-                        direction, 
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-                else
-                {
-                    mController-&gt;setMovement(
-                        CreatureController::MT_STEHEN, 
-                        Vector3(0,0,0),
-                        Vector3(0, rotation.valueRadians(), 0) );
-                }
-            }
-            else // VM_PNYX_MODE
-            {
-                // turn to the direction entered
-                if( movement &amp; MOVE_FORWARD || movement &amp; MOVE_BACKWARD || movement &amp; MOVE_LEFT || movement &amp; MOVE_RIGHT )
-                {
-                    // direction to turn to
-                    int direction = movement &amp; (MOVE_FORWARD | MOVE_BACKWARD | MOVE_RIGHT | MOVE_LEFT);
-                    Degree yaw(0);
-                    switch(direction)
-                    {
-                    case MOVE_FORWARD:
-                        yaw = Degree(0);
-                        break;
-                    case MOVE_FORWARD | MOVE_LEFT:
-                        yaw = Degree(45);
-                        break;
-                    case MOVE_FORWARD | MOVE_RIGHT:
-                        yaw = Degree(-45);
-                        break;
-                    case MOVE_RIGHT:
-                        yaw = Degree(-90);
-                        break;
-                    case MOVE_LEFT:
-                        yaw = Degree(90);
-                        break;
-                    case MOVE_BACKWARD:
-                        yaw = Degree(180);
-                        break;
-                    case MOVE_BACKWARD | MOVE_LEFT:
-                        yaw = Degree(-225);
-                        break;
-                    case MOVE_BACKWARD | MOVE_RIGHT:
-                        yaw = Degree(225);
-                        break;
-                    default:
-                        break;
-                    }
-                    yaw+=mCamYaw;
-
-                    CreatureController::MovementType type = CreatureController::MT_JOGGEN;
-                    if( movement &amp; MOVE_SNEAK )
-                        type = CreatureController::MT_SCHLEICHEN;
-                    else
-                    {
-                        if( movement &amp; MOVE_JUMP )
-                            type = CreatureController::MT_WEITSPRUNG;
-                        else
-                        {
-                            switch( movement &amp; (MOVE_RUN | MOVE_RUN_LOCK) )
-                            {
-                            case MOVE_RUN:
-                                type = CreatureController::MT_GEHEN;
-                                break;
-                            case MOVE_RUN_LOCK:
-                                type = CreatureController::MT_LAUFEN;
-                                break;
-                            case MOVE_RUN | MOVE_RUN_LOCK:
-                                type = CreatureController::MT_RENNEN;
-                                break;
-                            default:
-                                break;
-                            }
-                        }
-                    }
-
-
-                    mController-&gt;setMovement(
-                        type,
-                        Vector3::NEGATIVE_UNIT_Z,
-                        Vector3::UNIT_Y * (yaw-mController-&gt;getYaw()).valueRadians());
-                }
-                else
-                {
-                    // don't move
-                    CreatureController::MovementType type = CreatureController::MT_STEHEN;
-                    if( movement &amp; MOVE_SNEAK )
-                        type = CreatureController::MT_SCHLEICHEN;
-                    else if( movement &amp; MOVE_JUMP )
-                        type = CreatureController::MT_HOCHSPRUNG;
-                    mController-&gt;setMovement(
-                        type,
-                        Vector3::ZERO,
-                        Vector3::ZERO);
-                }
-            }
-        }
-    }
-
-    // ------------------------------------------------------------------------
-    void MovementControlState::updateCameraLookAt(Ogre::Real elapsedTime)
-    {
-        InputManager* im = InputManager::getSingletonPtr();
-
-        // camera position (distance)
-        if ( !isMouseUsedByCegui() )
-        {
-            mDesiredDistance -= im-&gt;getMouseRelativeZ() * 0.002;
-            if (mDesiredDistance &lt; mDistanceRange.first)
-            {
-                mDesiredDistance = mDistanceRange.first;
-            }
-            if (mDesiredDistance &gt; mDistanceRange.second)
-            {
-                mDesiredDistance = mDistanceRange.second;
-            }
-
-            if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
-            {
-                mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im-&gt;getMouseRelativeX() / 15);
-
-                while (mCamYaw.valueDegrees() &gt; 360.0f) mCamYaw -= Degree(360.0f);
-                while (mCamYaw.valueDegrees() &lt; -360.0f) mCamYaw += Degree(360.0f);
-            }
-        }
-
-        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
-
-        Vector3 charPos;
-        charPos = mCharacter-&gt;getActor()-&gt;getWorldPosition();
-        Quaternion charOri = mCharacter-&gt;getActor()-&gt;getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-        // Kamera-Gr&#239;&#191;&#189;e beziehen
-        CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
-                mCameraActor-&gt;getControlledObject());
-        AxisAlignedBox aabb = ogreCam-&gt;getDefaultSize();
-        // Radius berechnen
-        Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
- 
-
-        if( mViewMode == VM_FIRST_PERSON)
-        {
-            Quaternion camOri;
-            camOri.FromAngleAxis(mPitch, Vector3::NEGATIVE_UNIT_X);
-            cameraNode-&gt;lookAt(
-                charPos
-                + charOri * virtualCamOri * mLookAtOffset
-                + charOri * camOri * virtualCamOri * (-Vector3::UNIT_Z),
-                Node::TS_WORLD);
-        }
-        else if( mViewMode == VM_THIRD_PERSON )
-        {
-           cameraNode-&gt;lookAt(
-                charPos
-                + charOri * /* virtualCamOri * */  mLookAtOffset
-                + charOri * /* virtualCamOri * */ (-Vector3::UNIT_Z*radius),   // doesn't work smoothly with strafe+forward
-                Node::TS_WORLD);
-
-        }
-        else if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
-        {
-            Quaternion camOri;
-            camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-            Real dist = (mCameraActor-&gt;getPosition() - charPos).length();
-            cameraNode-&gt;lookAt(
-                charPos
-                + camOri * virtualCamOri * mLookAtOffset
-                + camOri * (-Vector3::UNIT_Z*radius),
-                Node::TS_WORLD);
-        }
-
-
-        // Character ausblenden, wenn Kamera zu nah.
-        if( mViewMode != VM_FIRST_PERSON )
-        {
-            // here the real charOri of the object is needed
-            Vector3 charPos;
-            Quaternion charOri;
-            mCharBody-&gt;getPositionOrientation(charPos, charOri);
-            Vector3 camPos;
-            Quaternion camOri;
-            mCamBody-&gt;getPositionOrientation(camPos, camOri);
-            Vector3 camPoint, charPoint, normal;
-            int collisionPoints =
-                OgreNewt::CollisionTools::CollisionClosestPoint(
-                    PhysicsManager::getSingleton()._getNewtonWorld(),
-                    mCamBody-&gt;getCollision(), camOri, camPos,
-                    mCharBody-&gt;getCollision(), charOri, charPos,
-                    camPoint, charPoint, normal
-                    );
-            if( collisionPoints == 0 )
-                mCharacterActor-&gt;setVisible(false);
-            else
-            {
-                // eigentlich muss hier transparent gemacht werden!
-                mCharacterActor-&gt;setVisible(true);
-            }
-        }
-        mCameraActor-&gt;setOrientation(cameraNode-&gt;getOrientation());
-    }
-
-    // -------------------------------------------------------------
-    // character collision moved to CreatureController(Manager)
-    int MovementControlState::userProcess()
-    {
-        if( mViewMode == VM_FIRST_PERSON )
-            return 0;
-
-        // test if this is cam-player-collide
-        if( ( m_body0 == mCamBody &amp;&amp; m_body1 == mCharacterActor-&gt;getPhysicalThing()-&gt;_getBody() ) ||
-            ( m_body1 == mCamBody &amp;&amp; m_body0 == mCharacterActor-&gt;getPhysicalThing()-&gt;_getBody() ) )
-        {
-            return 0;
-        }
-
-        setContactSoftness(0.8f);
-        setContactElasticity(0.0f);
-        mLastCameraCollision = 0;
-
-        return 1;
-    }
-
-    //------------------------------------------------------------------------
-    // character callback moved to CreatureController
-    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing)
-    {
-        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
-        Real timestep = world-&gt;getTimeStep();
-
-        calculateCamera(timestep);
-
-
-
-
-        ///@todo move to CreatureController?
-        SceneNode* node = mCharacterActor-&gt;_getSceneNode();
-        std::ostringstream ss;
-        Vector3 bodpos, playpos = node-&gt;getPosition();
-        Quaternion egal;
-        mCamBody-&gt;getPositionOrientation(bodpos,egal);
-        ss
-            &lt;&lt; &quot;scene node : &quot; &lt;&lt; playpos &lt;&lt; std::endl
-            &lt;&lt; &quot;player velocity : &quot; &lt;&lt; -mController-&gt;getVelocity().z &lt;&lt; std::endl
-            &lt;&lt; &quot;player orientation : &quot; &lt;&lt; mController-&gt;getCreature()-&gt;getActor()-&gt;getOrientation() &lt;&lt; std::endl
-            &lt;&lt; &quot;camera posder : &quot; &lt;&lt; static_cast&lt;Camera*&gt;(
-                mCameraActor-&gt;_getMovableObject())-&gt;getDerivedPosition() &lt;&lt; std::endl
-            &lt;&lt; &quot;camera orientation : &quot; &lt;&lt; mCameraActor-&gt;getWorldOrientation() &lt;&lt; std::endl
-            &lt;&lt; &quot;camera pos : &quot; &lt;&lt; bodpos &lt;&lt; std::endl
-            &lt;&lt; &quot;camera distance : &quot; &lt;&lt; mLastDistance &lt;&lt; &quot; ( &quot; &lt;&lt; mDesiredDistance &lt;&lt; &quot; ) &quot; &lt;&lt; std::endl
-            &lt;&lt; &quot;is airborne: &quot; &lt;&lt; (mController-&gt;getAbstractLocation() == CreatureController::AL_AIRBORNE ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
-
-        LOG_DEBUG(Logger::UI, ss.str());
-        DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::calculateCamera(const Ogre::Real&amp; timestep)
-    {
-        mLastCameraCollision += timestep;
-        Vector3 charPos = mCharacter-&gt;getActor()-&gt;getWorldPosition();
-        Quaternion charOri = mCharacter-&gt;getActor()-&gt;getWorldOrientation();
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody-&gt;getPositionOrientation(camPos, camOri);
-        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
-
-
-        Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
-        charPos = charPos + charOri * virtualCamOri * mLookAtOffset;
-
-        // Ringbuffer mit Positionen des Characters
-        mCharPositionsBufferIdx = (mCharPositionsBufferIdx + 1) % mCharPositionsBuffer.size();
-        mCharPositionsBuffer[mCharPositionsBufferIdx] = charPos;
-
-
-        // Kamera-Gr&#239;&#191;&#189;e beziehen
-        CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
-            mCameraActor-&gt;getControlledObject());
-        AxisAlignedBox camAabb = ogreCam-&gt;getDefaultSize();
-        // Radius berechnen
-        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
-
-
-
-
-
-        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
-        {
-
-            // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
-            // so zur optimalen kommen
-            const OgreNewt::MaterialID *charMaterialId = mCharBody-&gt;getMaterialGroupID();
-            const OgreNewt::MaterialID *camMaterialId = mCamBody-&gt;getMaterialGroupID();
-            PhysicsMaterialRaycast::MaterialVector materialVector;
-            materialVector.push_back(charMaterialId);
-            materialVector.push_back(camMaterialId);
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
-            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-
-            Vector3 normToOptCamPos = (optimalCamPos - charPos);
-            normToOptCamPos.normalise();
-
-
-
-            RaycastInfo infoCastOptPos = mRaycast-&gt;execute(
-                world,
-                &amp;materialVector,
-                camPos + camRadius * normToOptCamPos, // Gr&#239;&#191;&#189;e der Kamera einbeziehen
-                optimalCamPos + camRadius * normToOptCamPos,
-                true); // Gr&#239;&#191;&#189;e der Kamera einbeziehen
-
-            RaycastInfo infoCastChar = mRaycast-&gt;execute(
-                world,
-                &amp;materialVector,
-                camPos,
-                charPos,
-                true);
-
-            Real maxdistance = Math::Pow(1.5f * mDesiredDistance + 1.4f, 2);
-            if( infoCastChar.mBody || (camPos - charPos).squaredLength() &gt; maxdistance)
-            {
-                mCharacterOccludedTime += timestep;
-                mCharacterOccludedFrameCount++;
-
-                // falls zu lange, Kamera resetten:
-                if( mCharacterOccludedTime &gt; 0.500f &amp;&amp; mCharacterOccludedFrameCount &gt; 10 )
-                {
-                    resetCamera();
-                    return;
-                }
-
-            }
-            else
-                mCharacterOccludedTime = 0;
-
-            if( infoCastOptPos.mBody )
-            {
-                if( !infoCastChar.mBody ) // Character noch im Blickfeld
-                {
-                    // andere Position ermitteln, die ziwschen optimaler und Character liegt
-                    // und erreichbar ist
-                    Real lenToOptCamPos = (optimalCamPos - charPos).length();
-
-                    RaycastInfo infoCastNewPos;
-                    Real delta = lenToOptCamPos/2.0f;
-                    Vector3 temp = charPos + delta * normToOptCamPos;
-                    // Annaeherung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
-                    while( delta &gt; 0.05 ) // genauigkeit des gefundenen Punktes
-                    {
-                        infoCastNewPos = mRaycast-&gt;execute(
-                            world,
-                            &amp;materialVector,
-                            camPos + camRadius * normToOptCamPos, // Groesse der Kamera!
-                            temp,
-                            true);
-                        delta = delta/2.0f;
-                        if( infoCastNewPos.mBody ) // Hindernis gefunden, naeher an Char ran
-                        {
-                            temp = temp - delta * normToOptCamPos;
-                        }
-                        else // kein Hindernis gefunden, weiter von Char weg
-                        {
-                            temp = temp + delta * normToOptCamPos;
-                        }
-                    }
-
-                    // Jetzt koennen wir sicher sein, dass diese Stelle erreichbar ist:
-                    temp = temp - 0.05 * normToOptCamPos;
-                    // Groesse der Kamera einbeziehen
-                    optimalCamPos = temp - camRadius * normToOptCamPos;
-                    // so ab hier kann ganz normal weiter gerechnet werden!
-                }
-            }
-
-
-            // gibt an, ob schon gebufferte Daten fuer den
-            // neuen Weg existieren und dort weitergemacht werden kann,
-            // oder ob neu nach einem Weg gesucht werden muss!
-            if( infoCastChar.mBody &amp;&amp; infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
-            {
-                // anderen Weg finden
-                // hier werden erstmal nur alte Player-Positionen betrachtet
-                // es wird davon ausgegangen, dass diese &quot;nah&quot; genug aneinanderliegen
-                // und durch &quot;Geraden&quot; miteinander verbunden werden koennen
-                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem flssig
-                // und weich (keine scharfen Kurven) erscheinen
-
-                size_t buffSize = mCharPositionsBuffer.size();
-
-                if( !mIsPathfinding )
-                {
-                    LOG_DEBUG(Logger::UI, &quot; Pathfinding der Kamera sollte jetzt anfangen!&quot;);
-
-
-                    // letzte Character - Position suchen, die erreichbar ist...
-                    // Ist vermutlicherweise ja die letzte, davor war ja noch alles ok!
-                    unsigned int delta = 1;
-                    while ( delta &lt; buffSize )
-                    {
-                        RaycastInfo info = mRaycast-&gt;execute(
-                            world,
-                            &amp;materialVector,
-                            camPos,
-                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
-                            true);
-
-                        if( !info.mBody )
-                            break;
-                        delta++;
-                    }
-                    if( delta &gt;= buffSize )
-                    {
-                        // is wohl irgendwas schiefgegangen!
-                        LOG_MESSAGE(Logger::UI, &quot; Der Ringbuffer mit den Player-Positionen scheint zu klein zu sein; Pathfinding der Kamera fehlgeschlagen! &quot;);
-                        mIsPathfinding = false;
-                        resetCamera();
-                        return;
-                    }
-                    mLastReachableBufPos = delta;
-
-                    // auf zu der ermittelten Position!
-                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
-                }
-                else
-                {
-                    LOG_DEBUG(Logger::UI, &quot; Pathfinding der Kamera sollte weitergefhrt werden!&quot;);
-
-
-                    // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
-                    unsigned int delta = mLastReachableBufPos; // das ist die von der letzten Frame!
-                    while ( delta &gt; 0 ) // delta = 0 braucht nicht ueberprft zu werden, wurde oben schon ausgeschlossen!
-                    {
-                        RaycastInfo info = mRaycast-&gt;execute(
-                            world,
-                            &amp;materialVector,
-                            camPos,
-                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
-                            true);
-
-                        if( info.mBody )
-                            break;
-                        delta--;
-                    }
-                    mLastReachableBufPos = delta + 1;
-
-                    // auf zu der ermittelten Position!
-                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
-                }
-                mIsPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
-            }
-            else
-            {
-                mIsPathfinding = false;
-            }
-
-            Vector3 diff = camPos - optimalCamPos;
-
-            Vector3 cameraVelocity;
-            cameraVelocity = mCamBody-&gt;getVelocity();
-            // spring velocity
-            Vector3 springAcc = -mLinearSpringK*diff - mLinearDampingK * cameraVelocity;
-
-            // get the camera mass
-            Real mass;
-            Vector3 inertia;
-            mCamBody-&gt;getMassMatrix(mass, inertia);
-
-            //mCamBody-&gt;setPositionOrientation(newCamPos, camOri);
-            mCamBody-&gt;setForce(springAcc * mass);
-        }
-        else if( mViewMode == VM_FIRST_PERSON )
-        {
-            mCamBody-&gt;setPositionOrientation(optimalCamPos, camOri);
-        }
-    }
-
-    //------------------------------------------------------------------------
-    Ogre::Vector3 MovementControlState::calculateOptimalCameraPosition(bool slowlyMoveBackward, const Real &amp;timestep)
-    {
-        Vector3 targetCamPos;
-
-        Vector3 charPos = mCharacter-&gt;getActor()-&gt;getWorldPosition();
-        //Quaternion charOri = mCharacter-&gt;getActor()-&gt;getWorldOrientation();
-        Quaternion charOri (mController-&gt;getYaw(), Vector3::UNIT_Y);
-        Quaternion virtualCamOri;
-        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
-
-
-
-        if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
-        {
-            charPos = charPos + charOri * mLookAtOffset;
-            if(mViewMode == VM_PNYX_MODE)
-            {
-                Quaternion camOri;
-                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-                targetCamPos =
-                    charPos
-                    + camOri * virtualCamOri * Vector3(
-                                                0,
-                                                Math::Sin(mPitch) * mDesiredDistance,
-                                                Math::Cos(mPitch) * mDesiredDistance);
-            }
-            else if(mViewMode == VM_THIRD_PERSON)
-            {
-                targetCamPos =
-                    charPos
-                    + charOri * virtualCamOri * Vector3(
-                                    0,
-                                    Math::Sin(mPitch) * mDesiredDistance,
-                                    Math::Cos(mPitch) * mDesiredDistance);
-            }
-            else
-            {
-                Quaternion camOri;
-                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
-                targetCamPos =
-                    charPos
-                    + charOri * camOri * virtualCamOri * Vector3(
-                                                0,
-                                                Math::Sin(mPitch) * mDesiredDistance,
-                                                Math::Cos(mPitch) * mDesiredDistance);
-            }
-
-
-            // Kamera-Gr&#239;&#191;&#189;e beziehen
-            CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
-                mCameraActor-&gt;getControlledObject());
-            AxisAlignedBox aabb = ogreCam-&gt;getDefaultSize();
-            // Radius berechnen
-            Real radius = (aabb.getMaximum().z - aabb.getMinimum().z) / 2.0f;
-            radius *= 1.1f; // bissle was dazu tun schadet nich, da ja nur wenige raycasts gemacht werden
-            // unds eigentlich ne kugel ist!
-
-
-
-            Vector3 startRay[6], endRay[6];
-
-            Real sinPitchRad = Math::Sin(mPitch) * radius;
-            Real cosPitchRad = Math::Cos(mPitch) * radius;
-            Vector3 radiusOffset = charOri * Vector3(0, sinPitchRad, cosPitchRad);
-
-            startRay[0] = charPos;
-            endRay[0] = targetCamPos; // hier ist nun leider was doppelt,
-                                      // dadurch kann aber sichergestellt
-                                      // werden, dass kein Objekt direkt
-                                      // hinter dem Helden bersehen wird
-            startRay[1] = charPos + radiusOffset;
-            endRay[1] = targetCamPos + radiusOffset;
-            radiusOffset = charOri * Vector3(radius, sinPitchRad, cosPitchRad);
-            startRay[2] = charPos + radiusOffset;
-            endRay[2] = targetCamPos + radiusOffset;
-            startRay[3] = charPos - radiusOffset;
-            endRay[3] = targetCamPos - radiusOffset;
-            radiusOffset = charOri * Vector3(0, radius-cosPitchRad, -sinPitchRad);
-            startRay[4] = charPos + radiusOffset;
-            endRay[4] = targetCamPos + radiusOffset;
-            startRay[5] = charPos - radiusOffset;
-            endRay[5] = targetCamPos - radiusOffset;
-
-            const OgreNewt::MaterialID* materialId =
-                mCharBody-&gt;getMaterialGroupID();
-//                PhysicsManager::getSingleton()._getLevelMaterialID();
-            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
-
-            Vector3 diff = targetCamPos - charPos;
-            bool CollisionFound = false;
-            for( int i = 0; i &lt; 6; i++ )
-            {
-                RaycastInfo info = mRaycast-&gt;execute(
-                    world,
-                    materialId,
-                    startRay[i],
-                    endRay[i],
-                    true);
-
-                if( info.mBody &amp;&amp; info.mBody != mCamBody )
-                {
-                    CollisionFound = true;
-                    Vector3 newdiff = (info.mDistance) * (endRay[i] - startRay[i]);
-                    if( newdiff.squaredLength() &lt; diff.squaredLength() )
-                        diff = newdiff;
-                    if( i == 0 ) // beim ersten schon nahes hindernis gefunden?
-                    {
-                        if( diff.squaredLength() &lt; radius*radius )
-                        {
-                            diff -= charOri * Vector3(0, sinPitchRad, cosPitchRad);
-                            break;
-                        }
-                    }
-                }
-            }
-
-            // Langsames Entfernen vom Char:
-            if( CollisionFound )
-                mTimeOfLastCollision = 0.0f;
-            else
-                mTimeOfLastCollision += timestep;
-
-
-            Real desiredDistance = diff.length();
-            Vector3 camPos;
-            Quaternion camOri;
-            mCamBody-&gt;getPositionOrientation(camPos, camOri);
-
-            if( slowlyMoveBackward &amp;&amp;
-                desiredDistance &gt; mLastDistance )
-            {
-
-                diff.normalise();
-                Real newDistance;
-                Vector3 actDiff = camPos - charPos;
-                actDiff.normalise();
-
-                if( mLastCameraCollision &lt;= 0.5 ) // there was a cam collision 0.5 seconds ago
-                {
-                    newDistance = mLastDistance;
-                }
-                else if( mTimeOfLastCollision &gt; mCamMoveAwayStartTime ||
-                    diff.directionEquals(actDiff, mCamMoveAwayRange*timestep) )
-                    newDistance = mLastDistance + mCamMoveAwayVelocity*timestep;
-                else
-                    newDistance = mLastDistance;
-
-                if( newDistance &gt; desiredDistance )
-                    newDistance = desiredDistance;
-
-                diff = diff*newDistance;
-
-                mLastDistance = newDistance;
-            }
-            else
-                mLastDistance = desiredDistance;
-
-
-            targetCamPos = charPos + diff;
-        }
-        else  // FIRST_PERSON
-        {
-            // determine the optimal target position of the camera
-            targetCamPos =
-                charPos
-                + charOri * virtualCamOri * mLookAtOffset
-                + charOri * virtualCamOri * Vector3(
-                                0,
-                                Math::Sin(mPitch) * mDesiredDistance,
-                                Math::Cos(mPitch) * mDesiredDistance);
-        }
-
-
-        return targetCamPos;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::isEnemyNear()
-    {
-        mCombatSelector.updateSelection();
-
-        const Selector::GameObjectVector&amp; gov = mCombatSelector.getAllSelectedObjects();
-        for (size_t i = 0, end = gov.size(); i &lt; end; ++i)
-        {
-            Creature* creature = dynamic_cast&lt;Creature*&gt;(gov.at(i));
-            if (creature &amp;&amp;
-				creature-&gt;getAlignment() == Creature::ALIGNMENT_ENEMY &amp;&amp;
-				(creature-&gt;getLifeState() &amp; Effect::LS_NO_COMBAT) == 0)
-            {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updateSelection()
-    {
-        if ( isMouseUsedByCegui() )
-            return;
-
-        //InputManager* im = InputManager::getSingletonPtr();
-
-        GameObject* oldGo = mSelector.getFirstSelectedObject();
-
-        mSelector.updateSelection();
-
-        GameObject* newGo = mSelector.getFirstSelectedObject();
-
-        if (oldGo != NULL &amp;&amp; oldGo != newGo)
-        {
-            oldGo-&gt;setHighlighted(false);
-        }
-
-        if (newGo != NULL &amp;&amp; newGo != oldGo)
-        {
-            newGo-&gt;setHighlighted(true);
-        }
-/*
-        // Optionen anzeigen
-        if (im-&gt;isMouseButtonDown(OIS::MB_Right) &amp;&amp; newGo != NULL)
-        {
-            WindowFactory::getSingleton().showActionChoice(newGo);
-        }
-        else if (im-&gt;isMouseButtonDown(OIS::MB_Left) &amp;&amp; newGo != NULL)
-        {
-            newGo-&gt;doDefaultAction(mCharacter, NULL);
-        }
-*/
-    }
-
-
-    void MovementControlState::setViewMode(ViewMode mode)
-    {
-        mViewMode = mode;
-
-        MeshObject* charMesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
-        AxisAlignedBox aabb;
-        try
-        {
-			aabb = charMesh-&gt;getPoseSize(mCharacter-&gt;getAnimation(&quot;stehen&quot;).first);
-        }
-        catch(...)
-        {
-            aabb = charMesh-&gt;getDefaultSize();
-        }
-        if (mode == VM_FIRST_PERSON)
-        {
-            mLookAtOffset = Vector3(
-                    0,
-                    (aabb.getMaximum().y - aabb.getMinimum().y) * 0.90f,
-                    (aabb.getMaximum().z - aabb.getMinimum().z) * (-0.3f) );
-            mDistanceRange.first = 0.0;
-            mDistanceRange.second = 0.0;
-            mDesiredDistance = 0.0;
-            mPitchRange.first = Degree(-85);
-            mPitchRange.second = Degree(85);
-            mPitch = 0;
-            LOG_MESSAGE(Logger::UI, &quot;Switch to 1st person view&quot;);
-            resetCamera();
-        }
-        else if(mode == VM_THIRD_PERSON)
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.90f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.0;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            LOG_MESSAGE(Logger::UI, &quot;Switch to 3rd person view&quot;);
-            resetCamera();
-        }
-        else if(mode == VM_FREE_CAMERA)
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.0;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            mCamYaw = mCharacter-&gt;getActor()-&gt;getWorldOrientation().getYaw();
-            LOG_MESSAGE(Logger::UI, &quot;Switch to free camera view&quot;);
-            resetCamera();
-        }
-        else // mode == VM_PNYX_MODE
-        {
-            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
-            mDistanceRange.first = 0.60;
-            mDistanceRange.second = 7.00;
-            mDesiredDistance = 2.5;
-            mPitchRange.first = Degree(-75);
-            mPitchRange.second = Degree(85);
-            mPitch = Degree(30);
-            mCamYaw = mCharacter-&gt;getActor()-&gt;getWorldOrientation().getYaw();
-            LOG_MESSAGE(Logger::UI, &quot;Switch to pnyx mode movementcontroller&quot;);
-            resetCamera();
-        }
-    }
-
-    //------------------------------------------------------------------------
-/*
-    // not used at the moment!
-    void MovementControlState::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
-    {
-        AxisAlignedBox aab;
-        Vector3 size[2];
-        Vector3 interpolatedSize;
-
-
-        // Die Gr&#239;&#191;&#189;e der beiden Animationen abfragen
-        MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
-        aab = mesh-&gt;getPoseSize(actAnim);
-        size[0] = aab.getMaximum() - aab.getMinimum();
-
-        aab = mesh-&gt;getPoseSize(newAnim);
-        size[1] = aab.getMaximum() - aab.getMinimum();
-
-        // interpolierte Gr&#239;&#191;&#189;e (linear) berechnen
-        interpolatedSize = size[0] + factor*(size[1] - size[0]);
-
-        // LookAtOffset berechnen!
-        switch(mViewMode)
-        {
-        case VM_FIRST_PERSON:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, interpolatedSize.z * (-0.3f) );
-            break;
-        case VM_THIRD_PERSON:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, 0);
-            break;
-        case VM_FREE_CAMERA:
-        default:
-            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.80f, 0);
-        }
-    }
-*/
-
-    //------------------------------------------------------------------------
-    MovementControlState::ViewMode MovementControlState::getViewMode()
-    {
-        return mViewMode;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::toggleViewMode()
-    {
-        if (getViewMode() == VM_THIRD_PERSON)
-            setViewMode(VM_FIRST_PERSON);
-        else if(getViewMode() == VM_FIRST_PERSON)
-            setViewMode(VM_FREE_CAMERA);
-        else if(getViewMode() == VM_FREE_CAMERA)
-            setViewMode(VM_PNYX_MODE);
-        else
-            setViewMode(VM_THIRD_PERSON);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::resetCamera()
-    {
-        Vector3 camPos;
-        Quaternion camOri;
-        mCamBody-&gt;getPositionOrientation(camPos, camOri);
-        mCamBody-&gt;setPositionOrientation(calculateOptimalCameraPosition(false, 0.0f), camOri);
-        mCamVirtualYaw = Degree(0);
-        mNewCamVirtualYaw = Degree(0);
-        mLastCameraCollision = 0;
-        if(mViewMode == VM_FIRST_PERSON)
-            mCharacterActor-&gt;setVisible(false);
-        else
-            mCharacterActor-&gt;setVisible(true);
-        
-        LOG_MESSAGE(Logger::UI, &quot;Camera resetted.&quot;);
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::keyPressed(const OIS::KeyEvent&amp; evt, bool handled)
-    {
-        bool retval = false;
-        if( !handled )
-        {
-            int code = CommandMapper::encodeKey(evt.key, InputManager::getSingleton().getModifierCode());
-            // First see, if a control state action is defined
-	        CeGuiString command = mCommandMapper-&gt;getControlStateAction(code, mType);
-            if (command == &quot;&quot;)
-            {
-                // No. So try global actions.
-                command = mCommandMapper-&gt;getGlobalAction(code);
-            }
-            else if (command == &quot;freeflight_mode&quot;)
-            {
-                InputManager::getSingleton().pushControlState(CST_FREEFLIGHT);
-                retval = true;
-            }
-            else if (command == &quot;reset_camera&quot;)
-            {
-                resetCamera();
-                retval = true;
-            }
-            else if (command == &quot;toggle_view_mode&quot;)
-            {
-                toggleViewMode();
-                retval = true;
-            }
-            else if( startAction(command, mCharacter) )
-                retval = true;
-
-
-
-            if( !retval )
-            {
-                int movement = mCommandMapper-&gt;getMovement(evt.key);
-
-                if (movement &amp; MOVE_RUN_LOCK) // dieses einrasten lassen
-                {
-                    mCharacterState.mCurrentMovementState ^= MOVE_RUN_LOCK;
-                    movement &amp;= ~MOVE_RUN_LOCK;
-                    retval = true;
-                }
-
-                if (movement != MOVE_NONE)
-                {
-                    mCharacterState.mCurrentMovementState |= movement;
-                    retval = true;
-                }
-            }
-        }
-
-
-        if( ControlState::keyPressed(evt, handled || retval ) )
-            retval = true;
-        return retval;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::keyReleased(const OIS::KeyEvent&amp; evt, bool handled)
-    {
-        bool retval = false;
-        int movement = mCommandMapper-&gt;getMovement(evt.key);
-        if (movement != MOVE_NONE)
-        {
-            mCharacterState.mCurrentMovementState &amp;= (~movement | MOVE_RUN_LOCK);
-            retval = true;
-        }
-
-        if( ControlState::keyReleased(evt, retval) )
-            retval = true;
-        return retval;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::mouseReleased(const OIS::MouseEvent&amp; evt,
-        OIS::MouseButtonID id, bool handled)
-    {
-        handled = handled || ControlState::mouseReleased(evt, id, handled);
-
-/*
-        if( !handled )
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int mouseButtonMask = CommandMapper::encodeKey(id, im-&gt;getModifierCode());
-            return startAction(mCommandMapper-&gt;getControlStateAction(mouseButtonMask,
-                CST_MOVEMENT), mCharacter);
-        }
-*/
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    bool MovementControlState::mousePressed(const OIS::MouseEvent&amp; evt,
-        OIS::MouseButtonID id, bool handled)
-    {
-        handled = handled || ControlState::mouseReleased(evt, id, handled);
-
-        // default action und action-selektor, falls object selected
-        GameObject* newGo = mSelector.getFirstSelectedObject();
-        if( newGo != NULL &amp;&amp; !isMouseUsedByCegui() )
-        {
-            if( id == OIS::MB_Left )
-            {
-                if( newGo-&gt;getDefaultAction(mCharacter) != NULL )
-                {
-                    newGo-&gt;doDefaultAction(mCharacter, NULL);
-                    handled = true;
-                }
-            }
-            else if( id == OIS::MB_Right )
-            {
-                WindowFactory::getSingleton().showActionChoice(newGo);
-                handled = true;
-            }
-        }
-
-        if( !handled )
-        {
-            InputManager* im = InputManager::getSingletonPtr();
-            int mouseButtonMask = CommandMapper::encodeKey(id, im-&gt;getModifierCode());
-            return startAction(mCommandMapper-&gt;getControlStateAction(mouseButtonMask,
-                CST_MOVEMENT), mCharacter);
-        }
-        return false;
-    }
-
-    //------------------------------------------------------------------------
-    DebugVisualisableFlag MovementControlState::getFlag() const
-    {
-        return DVF_CONTROL;
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::updatePrimitive()
-    {
-        if (mSceneNode-&gt;getParent() == NULL)
-        {
-            mCharacterActor-&gt;_getSceneNode()-&gt;addChild(mSceneNode);
-        }
-
-        LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
-        lineSet-&gt;clear();
-        lineSet-&gt;addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
-    }
-
-    //------------------------------------------------------------------------
-    void MovementControlState::doCreatePrimitive()
-    {
-        mPrimitive = new LineSetPrimitive();
-    }
-
-    bool MovementControlState::updateAfterGameObjectLoading()
-    {
-        resume(); //saving/loading only possible in movement state
-        //// We want to check for visibility from char's POV.
-        //mSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
-        //mSelector.track(mCharacter);
-        //mSelector.setRadius(3.0);
-
-        //// Same for combat selector
-        //mCombatSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
-        //mCombatSelector.track(mCharacter);
-        //mCombatSelector.setRadius(10.0);
-
-        return false;
-    }
-
-    bool MovementControlState::beforeLoadingSaveGame()  //unhighlight selected go
-    {
-        if(mSelector.getFirstSelectedObject())
-        {
-            mSelector.getFirstSelectedObject()-&gt;setHighlighted(false);
-        }
-
-        pause(); //saving/loading only possible in movement state
-
-        return false;
-    }
-}
+/* This source file is part of Rastullahs Lockenpracht.
+* Copyright (C) 2003-2008 Team Pantheon. <A HREF="http://www.team-pantheon.de">http://www.team-pantheon.de</A>
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the Clarified Artistic License.
+*
+*  This program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*  Clarified Artistic License for more details.
+*
+*  You should have received a copy of the Clarified Artistic License
+*  along with this program; if not you can get it here
+*  <A HREF="http://www.jpaulmorrison.com/fbp/artistic2.htm.">http://www.jpaulmorrison.com/fbp/artistic2.htm.</A>
+*/
+
+#include &quot;stdinc.h&quot;
+
+#include &quot;MovementControlState.h&quot;
+
+#include &lt;utility&gt;
+
+#include &quot;AbstractMovement.h&quot;
+#include &quot;Actor.h&quot;
+#include &quot;ActorManager.h&quot;
+#include &quot;CameraObject.h&quot;
+#include &quot;CommandMapper.h&quot;
+#include &quot;ConfigurationManager.h&quot;
+#include &quot;CoreSubsystem.h&quot;
+#include &quot;Creature.h&quot;
+#include &quot;CreatureControllerManager.h&quot;
+#include &quot;DebugWindow.h&quot;
+#include &quot;Exception.h&quot;
+#include &quot;GameObjectManager.h&quot;
+#include &quot;InputManager.h&quot;
+#include &quot;Logger.h&quot;
+#include &quot;MeshObject.h&quot;
+#include &quot;MeshAnimation.h&quot;
+#include &quot;MovementControlState.h&quot;
+#include &quot;PhysicsManager.h&quot;
+#include &quot;PhysicsMaterialRaycast.h&quot;
+#include &quot;PhysicalThing.h&quot;
+#include &quot;RulesMessages.h&quot;
+#include &quot;World.h&quot;
+#include &quot;LineSetPrimitive.h&quot;
+#include &quot;WindowFactory.h&quot;
+#include &quot;AnimationManager.h&quot;
+#include &quot;UiSubsystem.h&quot;
+#include &quot;WindowManager.h&quot;
+
+#include &lt;numeric&gt;
+
+using namespace Ogre;
+
+namespace rl {
+
+    Ogre::String MovementControlState::msDebugWindowPageName = &quot;MovementControlState&quot;;
+
+    MovementControlState::CharacterState::CharacterState()
+        :
+        mCurrentMovementState(MOVE_NONE),
+        mLastMovementState(MOVE_NONE)
+    {
+    }
+
+    MovementControlState::MovementControlState(CommandMapper* cmdMapper,
+        Actor* camera, Creature* character)
+        : ControlState(cmdMapper, camera, character, CST_MOVEMENT),
+        mController(NULL),
+        mCharacterState(),
+        mDesiredDistance(2.00),
+        mDistanceRange(0.60, 7.00),
+        mCamYaw(0),
+        mCamVirtualYaw(0),
+        mNewCamVirtualYaw(0),
+        mPitch(20),
+        mRoll(0),
+        mPitchRange(Degree(-75), Degree(85)),
+        mLinearSpringK(400.0f),
+        mLinearDampingK(Math::NEG_INFINITY),
+        mCamMoveAwayVelocity(4.0f),
+        mCamMoveAwayStartTime(0.25f),
+        mCamMoveAwayRange(8.0f),
+        mLookAtOffset(),
+        mRotationSpeed(Degree(120.0f)),
+        mMouseSensitivity(4.0f),
+        mViewMode(VM_THIRD_PERSON),
+        mRaycast(new PhysicsMaterialRaycast()),
+        mConvexcast(new PhysicsMaterialConvexcast()),
+        mCameraCastCollision(NULL),
+        mSelector(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager()),
+        mCombatSelector(CoreSubsystem::getSingleton().getWorld()-&gt;getSceneManager(),
+            QUERYFLAG_CREATURE),
+        mCharPositionsBuffer(100),
+        mCharPositionsBufferIdx(-1),
+        mCharacterOccludedTime(0),
+        mCharacterOccludedFrameCount(0),
+        mLastDistance(0.0f),
+        mTimeOfLastCollision(0.0f),
+        mIsPathfinding (false),
+        mLastReachableBufPos(1),
+        mLastCameraCollision(0)
+    {
+        DebugWindow::getSingleton().registerPage(msDebugWindowPageName);
+
+
+        mMouseSensitivity = ConfigurationManager::getSingleton().getIntSetting(&quot;Input&quot;, &quot;Mouse Sensitivity&quot;);
+        mInvertedMouse = ConfigurationManager::getSingleton().getBoolSetting(&quot;Input&quot;, &quot;Mouse Invert&quot;);
+
+        // The relationCoefficient determines the relation between spring accel in target direction
+        // and damping in velocity direction. 1.0 means equilibrium is reached in optimal time
+        // smaller 1.0 means spring accel is stronger and thus cam shoots over the target, resulting
+        // in a damped ozillation before reaching equilibrium.
+        // Values greater than 1.0 mean damping is stronger and thus camera takes a detour.
+        Real relationCoefficient = 0.8f;
+        mLinearDampingK = relationCoefficient * 2.0f * Math::Sqrt(mLinearSpringK);
+
+        // Offset for the look at point,
+        // so the cam does look at the characters head instead of the feet.
+        MeshObject* charMesh = dynamic_cast&lt;MeshObject*&gt;(
+            mCharacterActor-&gt;getControlledObject());
+        AxisAlignedBox aabb = charMesh-&gt;getDefaultSize();
+
+        // this will be recalculated in calculateOptimalCameraPosition
+        mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.45f, 0);
+
+        CreatureSelectionFilter* filter = new CreatureSelectionFilter();
+        filter-&gt;setAlignmentMask(Creature::ALIGNMENT_ENEMY);
+        mCombatSelector.setFilter(filter);
+
+        mSelector.setFilter(new InSceneSelectionFilter());
+
+        mMessageType_GameObjectsLoaded_Handler = MessagePump::getSingleton().addMessageHandler&lt;MessageType_GameObjectsLoaded&gt;(
+            boost::bind(&amp;MovementControlState::updateAfterGameObjectLoading, this));
+
+        mMessageType_SaveGameLoading_Handler = MessagePump::getSingleton().addMessageHandler&lt;MessageType_SaveGameLoading&gt;(
+            boost::bind(&amp;MovementControlState::beforeLoadingSaveGame, this));
+
+        // Kamera-Groesse beziehen
+        CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
+            mCameraActor-&gt;getControlledObject());
+        AxisAlignedBox camAabb = ogreCam-&gt;getDefaultSize();
+        // Radius berechnen
+        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
+        camRadius *= 1.1f;
+        Vector3 verts[80];
+        int k = 0;
+        for(int i = 0; i &lt; 16; i++)
+        {
+            int n;
+            n = abs(abs(i-8)-8)+1;
+            for(int j = 0; j &lt; n; j++)
+            {
+                Real h = (i-7.5f)/7.5f;
+                Degree angle(360.0f/(n+1)*j);
+                Real rad = Math::Sqrt(1-h*h);
+                verts[k++] = camRadius*Vector3(rad*Math::Cos(angle),rad*Math::Sin(angle),h);
+            }
+        }
+        //! TODO: remove this workaround (newton-bug: &quot;spheres don't cast&quot;!)
+        mCameraCastCollision = new OgreNewt::CollisionPrimitives::ConvexHull(mCamBody-&gt;getWorld(), verts, 80);
+        //mCameraCastCollision = new OgreNewt::CollisionPrimitives::Ellipsoid(mCamBody-&gt;getWorld(), Vector3::UNIT_SCALE * camRadius);
+    }
+
+    //------------------------------------------------------------------------
+    MovementControlState::~MovementControlState()
+    {
+        delete mCombatSelector.getFilter();
+        mCombatSelector.setFilter(NULL);
+        delete mSelector.getFilter();
+        mSelector.setFilter(NULL);
+        delete mRaycast;
+        delete mConvexcast;
+        delete mCameraCastCollision;
+
+        if (DebugWindow::getSingletonPtr())
+        {
+            DebugWindow::getSingletonPtr()-&gt;unregisterPage(msDebugWindowPageName);
+        }
+
+        // Remove debug scene node from character node, if debugview was used.
+        if (mSceneNode != NULL &amp;&amp; mSceneNode-&gt;getParent() != NULL)
+        {
+            mCharacterActor-&gt;_getSceneNode()-&gt;removeChild(mSceneNode);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::pause()
+    {
+        mController = NULL;
+
+        // actors aren't controlled anymore
+        mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(NULL);
+        mCameraActor-&gt;getPhysicalThing()-&gt;freeze();
+        // cam&lt;-&gt;Level collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;));
+        // cam&lt;-&gt;Default collision back to default
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
+        PhysicsManager::getSingleton().resetMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
+
+
+        // Unhighlight selected object, if any.
+        GameObject* go = mSelector.getFirstSelectedObject();
+        if (go != NULL &amp;&amp; go-&gt;isHighlighted())
+        {
+            go-&gt;setHighlighted(false);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::resume()
+    {
+        if (mController == NULL )
+        {
+            mController =
+                CreatureControllerManager::getSingleton().getCreatureController(mCharacter);
+        }
+
+        // We want to check for visibility from char's POV.
+        mSelector.setCheckVisibility(true, mCharacter);
+        mSelector.track(mCharacter);
+        mSelector.setRadius(3.0);
+
+        // Same for combat selector
+        mCombatSelector.setCheckVisibility(true, mCharacter);
+        mCombatSelector.track(mCharacter);
+        mCombatSelector.setRadius(10.0);
+
+
+        // control camera
+        mCameraActor-&gt;getPhysicalThing()-&gt;setMaterialID(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;));
+        mCameraActor-&gt;getPhysicalThing()-&gt;unfreeze();
+        mCameraActor-&gt;getPhysicalThing()-&gt;setPhysicsController(this);
+        mCameraActor-&gt;getPhysicalThing()-&gt;setUpConstraint(Vector3::ZERO);
+
+        // We also handle cam&lt;-&gt;level, cam&lt;-&gt;default cam&lt;-&gt;char collision from now on
+        OgreNewt::MaterialPair* mat_pair = NULL;
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;default&quot;));
+        mat_pair-&gt;setContactCallback(this);
+        mat_pair-&gt;setDefaultCollidable(1);
+        mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair-&gt;setDefaultSoftness(0.8f);
+        mat_pair-&gt;setDefaultElasticity(0.4f);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;level&quot;));
+        mat_pair-&gt;setContactCallback(this);
+        mat_pair-&gt;setDefaultCollidable(1);
+        mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair-&gt;setDefaultSoftness(0.8f);
+        mat_pair-&gt;setDefaultElasticity(0.4f);
+        mat_pair = PhysicsManager::getSingleton().createMaterialPair(
+            PhysicsManager::getSingleton().getMaterialID(&quot;camera&quot;),
+            PhysicsManager::getSingleton().getMaterialID(&quot;character&quot;));
+        mat_pair-&gt;setContactCallback(this);
+        mat_pair-&gt;setDefaultCollidable(1);
+        mat_pair-&gt;setDefaultFriction(0,0);
+        mat_pair-&gt;setDefaultSoftness(0.8f);
+        mat_pair-&gt;setDefaultElasticity(0.4f);
+
+        mCharacterState.mCurrentMovementState = MOVE_NONE;
+
+        setViewMode(VM_THIRD_PERSON);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::run(Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+
+        updateCharacter(elapsedTime);
+        updateCameraLookAt(elapsedTime);
+        updateSelection();
+
+
+
+        // camera pitch
+        if (!isMouseUsedByCegui() )
+        {
+            if (mInvertedMouse)
+                mPitch -= 0.5 * mMouseSensitivity * Degree(im-&gt;getMouseRelativeY() / 10);
+            else
+                mPitch += 0.5 * mMouseSensitivity * Degree(im-&gt;getMouseRelativeY() / 10);
+            if (mPitch &lt; mPitchRange.first) mPitch = mPitchRange.first;
+            if (mPitch &gt; mPitchRange.second) mPitch = mPitchRange.second;
+        }
+
+
+        mCharacterState.mLastMovementState = mCharacterState.mCurrentMovementState;
+
+        if (isEnemyNear() &amp;&amp; !(mCharacter-&gt;getLifeState() &amp; Effect::LS_NO_COMBAT))
+        {
+            InputManager::getSingleton().pushControlState(CST_COMBAT);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updateCharacter(Ogre::Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+        if( mController != NULL )
+        {
+            int movement = mCharacterState.mCurrentMovementState;
+            Degree rotation(0);
+
+            AbstractMovement *drehen = mController-&gt;getMovementFromId(CreatureController::MT_DREHEN);
+            Real baseVelocity = 0;
+            if( drehen-&gt;calculateBaseVelocity(baseVelocity) )
+            {
+                if( !(movement &amp; MOVE_RIGHT || movement &amp; MOVE_LEFT) )
+                {
+                    Degree baseVel(baseVelocity*360);
+                    if( mViewMode != VM_PNYX_MODE )
+                    {
+                        if (movement &amp; TURN_LEFT)
+                            rotation = elapsedTime * baseVel;
+                        if (movement &amp; TURN_RIGHT)
+                            rotation = -elapsedTime * baseVel;
+                    }
+
+                    // mouse
+                    if( !isMouseUsedByCegui() )
+                    {
+                        if (mViewMode == VM_FIRST_PERSON || mViewMode == VM_THIRD_PERSON )
+                        {
+                            if( !(movement &amp; TURN_LEFT || movement &amp; TURN_RIGHT) )
+                            {
+                                rotation = -mMouseSensitivity/3.0f * Degree(im-&gt;getMouseRelativeX())/200.0 * baseVel;
+                            }
+                        }
+                    }
+                }
+
+
+                if( mViewMode != VM_PNYX_MODE  &amp;&amp; mViewMode != VM_FIRST_PERSON )
+                {
+                    // virtual yaw
+                    if( mCamVirtualYaw != mNewCamVirtualYaw )
+                    {
+                        mCamVirtualYaw = mNewCamVirtualYaw;
+                    }
+                    if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) ||
+                        ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) )
+                    {
+                        mNewCamVirtualYaw = Degree(45);
+                    }
+                    else if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) ||
+                        ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) )
+                    {
+                        mNewCamVirtualYaw = Degree(-45);
+                    }
+                    else
+                    {
+                        mNewCamVirtualYaw =Degree(0);
+                    }
+                    if( mCamVirtualYaw != mNewCamVirtualYaw )
+                    {
+                        rotation += mCamVirtualYaw - mNewCamVirtualYaw;
+                    }
+                }
+
+                if( mViewMode == VM_FIRST_PERSON )
+                {
+                    if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) ||
+                        ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_RIGHT) &amp;&amp; !(movement &amp; MOVE_LEFT)) )
+                    {
+                        mCamVirtualYaw -= Degree(270)*elapsedTime;
+                        if( mCamVirtualYaw &lt;= Degree(-90) )
+                            mCamVirtualYaw = Degree(-90);
+                    }
+                    else if( ((movement &amp; MOVE_FORWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) ||
+                             ((movement &amp; MOVE_BACKWARD) &amp;&amp; (movement &amp; MOVE_LEFT) &amp;&amp; !(movement &amp; MOVE_RIGHT)) )
+                    {
+                        mCamVirtualYaw += Degree(270)*elapsedTime;
+                        if( mCamVirtualYaw &gt;= Degree(90) )
+                            mCamVirtualYaw = Degree(90);
+                    }
+                    else
+                    {
+                        if( mCamVirtualYaw &gt; Degree(0) )
+                        {
+                            mCamVirtualYaw -= Degree(270)*elapsedTime;
+                            if( mCamVirtualYaw &lt;= Degree(0) )
+                                mCamVirtualYaw = Degree(0);
+                        }
+                        else if( mCamVirtualYaw &lt; Degree(0) )
+                        {
+                            mCamVirtualYaw += Degree(270)*elapsedTime;
+                            if( mCamVirtualYaw &gt;= Degree(0) )
+                                mCamVirtualYaw = Degree(0);
+                        }
+                    }
+                }
+            }
+
+
+
+            if( mViewMode != VM_PNYX_MODE )
+            {
+                if( mController-&gt;getMovementId() == CreatureController::MT_HOCHSPRUNG )
+                {
+                    // move forward or backward if wanted
+                    Vector3 direction = Vector3::UNIT_Y;
+                    if( movement &amp; MOVE_FORWARD )
+                        direction += Vector3::NEGATIVE_UNIT_Z;
+                    else if( movement &amp; MOVE_BACKWARD )
+                        direction += Vector3::UNIT_Z;
+
+                    mController-&gt;setMovement(
+                        CreatureController::MT_HOCHSPRUNG,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement &amp; MOVE_SNEAK )
+                {
+                    Vector3 direction(Vector3::ZERO);
+                    if (movement &amp; MOVE_FORWARD)
+                        direction.z = -1;
+                    else if( movement &amp; MOVE_BACKWARD)
+                        direction.z = 1;
+                    mController-&gt;setMovement(
+                        CreatureController::MT_SCHLEICHEN,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement &amp; MOVE_JUMP &amp;&amp; 
+                    mController-&gt;getMovementFromId(CreatureController::MT_HOCHSPRUNG)-&gt;isPossible() )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_HOCHSPRUNG;
+                    Vector3 direction = Vector3::UNIT_Y;
+                    if( movement &amp; MOVE_FORWARD )
+                    {
+                        type = CreatureController::MT_WEITSPRUNG;
+                        direction += Vector3::NEGATIVE_UNIT_Z;
+                    }
+                    mController-&gt;setMovement(
+                        type,
+                        direction,
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if( movement &amp; MOVE_FORWARD )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_GEHEN;
+                    if( movement &amp; MOVE_RUN_LOCK )
+                    {
+                        if( movement &amp; MOVE_RUN )
+                            type = CreatureController::MT_RENNEN;
+                        else
+                            type = CreatureController::MT_LAUFEN;
+                    }
+                    else
+                    {
+                        if( movement &amp; MOVE_RUN )
+                            type = CreatureController::MT_GEHEN;
+                        else
+                            type = CreatureController::MT_JOGGEN;
+                    }
+                    mController-&gt;setMovement(
+                        type,
+                        Vector3(0,0,-1), 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if (movement &amp; MOVE_BACKWARD )
+                {
+                    CreatureController::MovementType type = CreatureController::MT_RUECKWAERTS_GEHEN;
+                    if( !(movement &amp; MOVE_RUN) )
+                        type = CreatureController::MT_RUECKWAERTS_JOGGEN;
+                    mController-&gt;setMovement(
+                        type,
+                        Vector3(0,0,1), 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else if (movement &amp; MOVE_LEFT || movement &amp; MOVE_RIGHT)
+                {
+                    Vector3 direction = Vector3::UNIT_X;
+                    if( movement &amp; MOVE_LEFT )
+                        direction = Vector3::NEGATIVE_UNIT_X;
+                    mController-&gt;setMovement(
+                        CreatureController::MT_SEITWAERTS_GEHEN,
+                        direction, 
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+                else
+                {
+                    mController-&gt;setMovement(
+                        CreatureController::MT_STEHEN, 
+                        Vector3(0,0,0),
+                        Vector3(0, rotation.valueRadians(), 0) );
+                }
+            }
+            else // VM_PNYX_MODE
+            {
+                // turn to the direction entered
+                if( movement &amp; MOVE_FORWARD || movement &amp; MOVE_BACKWARD || movement &amp; MOVE_LEFT || movement &amp; MOVE_RIGHT )
+                {
+                    // direction to turn to
+                    int direction = movement &amp; (MOVE_FORWARD | MOVE_BACKWARD | MOVE_RIGHT | MOVE_LEFT);
+                    Degree yaw(0);
+                    switch(direction)
+                    {
+                    case MOVE_FORWARD:
+                        yaw = Degree(0);
+                        break;
+                    case MOVE_FORWARD | MOVE_LEFT:
+                        yaw = Degree(45);
+                        break;
+                    case MOVE_FORWARD | MOVE_RIGHT:
+                        yaw = Degree(-45);
+                        break;
+                    case MOVE_RIGHT:
+                        yaw = Degree(-90);
+                        break;
+                    case MOVE_LEFT:
+                        yaw = Degree(90);
+                        break;
+                    case MOVE_BACKWARD:
+                        yaw = Degree(180);
+                        break;
+                    case MOVE_BACKWARD | MOVE_LEFT:
+                        yaw = Degree(-225);
+                        break;
+                    case MOVE_BACKWARD | MOVE_RIGHT:
+                        yaw = Degree(225);
+                        break;
+                    default:
+                        break;
+                    }
+                    yaw+=mCamYaw;
+
+                    CreatureController::MovementType type = CreatureController::MT_JOGGEN;
+                    if( movement &amp; MOVE_SNEAK )
+                        type = CreatureController::MT_SCHLEICHEN;
+                    else
+                    {
+                        if( movement &amp; MOVE_JUMP )
+                            type = CreatureController::MT_WEITSPRUNG;
+                        else
+                        {
+                            switch( movement &amp; (MOVE_RUN | MOVE_RUN_LOCK) )
+                            {
+                            case MOVE_RUN:
+                                type = CreatureController::MT_GEHEN;
+                                break;
+                            case MOVE_RUN_LOCK:
+                                type = CreatureController::MT_LAUFEN;
+                                break;
+                            case MOVE_RUN | MOVE_RUN_LOCK:
+                                type = CreatureController::MT_RENNEN;
+                                break;
+                            default:
+                                break;
+                            }
+                        }
+                    }
+
+
+                    mController-&gt;setMovement(
+                        type,
+                        Vector3::NEGATIVE_UNIT_Z,
+                        Vector3::UNIT_Y * (yaw-mController-&gt;getYaw()).valueRadians());
+                }
+                else
+                {
+                    // don't move
+                    CreatureController::MovementType type = CreatureController::MT_STEHEN;
+                    if( movement &amp; MOVE_SNEAK )
+                        type = CreatureController::MT_SCHLEICHEN;
+                    else if( movement &amp; MOVE_JUMP )
+                        type = CreatureController::MT_HOCHSPRUNG;
+                    mController-&gt;setMovement(
+                        type,
+                        Vector3::ZERO,
+                        Vector3::ZERO);
+                }
+            }
+        }
+    }
+
+    // ------------------------------------------------------------------------
+    void MovementControlState::updateCameraLookAt(Ogre::Real elapsedTime)
+    {
+        InputManager* im = InputManager::getSingletonPtr();
+
+        // camera position (distance)
+        if ( !isMouseUsedByCegui() )
+        {
+            mDesiredDistance -= im-&gt;getMouseRelativeZ() * 0.002;
+            if (mDesiredDistance &lt; mDistanceRange.first)
+            {
+                mDesiredDistance = mDistanceRange.first;
+            }
+            if (mDesiredDistance &gt; mDistanceRange.second)
+            {
+                mDesiredDistance = mDistanceRange.second;
+            }
+
+            if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
+            {
+                mCamYaw -= 2 * mMouseSensitivity / 4.0 * mRotationSpeed * Degree(im-&gt;getMouseRelativeX() / 15);
+
+                while (mCamYaw.valueDegrees() &gt; 360.0f) mCamYaw -= Degree(360.0f);
+                while (mCamYaw.valueDegrees() &lt; -360.0f) mCamYaw += Degree(360.0f);
+            }
+        }
+
+        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
+
+        Vector3 charPos;
+        charPos = mCharacter-&gt;getActor()-&gt;getWorldPosition();
+        Quaternion charOri = mCharacter-&gt;getActor()-&gt;getWorldOrientation();
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+
+
+        // Kamera-Gr&#239;&#191;&#189;e beziehen
+        CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
+                mCameraActor-&gt;getControlledObject());
+        AxisAlignedBox aabb = ogreCam-&gt;getDefaultSize();
+        // Radius berechnen
+        Real radius = (aabb.getMaximum()-aabb.getMinimum()).length() / 2.0f;
+ 
+
+        if( mViewMode == VM_FIRST_PERSON)
+        {
+            Quaternion camOri;
+            camOri.FromAngleAxis(mPitch, Vector3::NEGATIVE_UNIT_X);
+            cameraNode-&gt;lookAt(
+                charPos
+                + charOri * virtualCamOri * mLookAtOffset
+                + charOri * camOri * virtualCamOri * (-Vector3::UNIT_Z),
+                Node::TS_WORLD);
+        }
+        else if( mViewMode == VM_THIRD_PERSON )
+        {
+           cameraNode-&gt;lookAt(
+                charPos
+                + charOri * /* virtualCamOri * */  mLookAtOffset
+                + charOri * /* virtualCamOri * */ (-Vector3::UNIT_Z*radius),   // doesn't work smoothly with strafe+forward
+                Node::TS_WORLD);
+
+        }
+        else if( mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE )
+        {
+            Quaternion camOri;
+            camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+            Real dist = (mCameraActor-&gt;getPosition() - charPos).length();
+            cameraNode-&gt;lookAt(
+                charPos
+                + camOri * virtualCamOri * mLookAtOffset
+                + camOri * (-Vector3::UNIT_Z*radius),
+                Node::TS_WORLD);
+        }
+
+
+        // Character ausblenden, wenn Kamera zu nah.
+        if( mViewMode != VM_FIRST_PERSON )
+        {
+            // here the real charOri of the object is needed
+            Vector3 charPos;
+            Quaternion charOri;
+            mCharBody-&gt;getPositionOrientation(charPos, charOri);
+            Vector3 camPos;
+            Quaternion camOri;
+            mCamBody-&gt;getPositionOrientation(camPos, camOri);
+            Vector3 camPoint, charPoint, normal;
+            int collisionPoints =
+                OgreNewt::CollisionTools::CollisionClosestPoint(
+                    PhysicsManager::getSingleton()._getNewtonWorld(),
+                    mCamBody-&gt;getCollision(), camOri, camPos,
+                    mCharBody-&gt;getCollision(), charOri, charPos,
+                    camPoint, charPoint, normal, 0 // set threadindex to 0, I hope this is ok!
+                    );
+            if( collisionPoints == 0 )
+                mCharacterActor-&gt;setVisible(false);
+            else
+            {
+                // eigentlich muss hier transparent gemacht werden!
+                mCharacterActor-&gt;setVisible(true);
+            }
+        }
+        mCameraActor-&gt;setOrientation(cameraNode-&gt;getOrientation());
+    }
+
+
+    int MovementControlState::onAABBOverlap( OgreNewt::Body* body0, OgreNewt::Body* body1, int threadIndex )
+    {
+        if( mViewMode == VM_FIRST_PERSON )
+            return 0;
+
+        // test if this is cam-player-collide
+        if( ( body0 == mCamBody &amp;&amp; body1 == mCharacterActor-&gt;getPhysicalThing()-&gt;_getBody() ) ||
+            ( body1 == mCamBody &amp;&amp; body0 == mCharacterActor-&gt;getPhysicalThing()-&gt;_getBody() ) )
+        {
+            return 0;
+        }
+
+        return 1;
+    }
+
+    void MovementControlState::userProcess(OgreNewt::ContactJoint &amp;contactJoint, Real timestep, int)
+    {
+        mLastCameraCollision = 0;
+    }
+
+    //------------------------------------------------------------------------
+    // character callback moved to CreatureController
+    void MovementControlState::OnApplyForceAndTorque(PhysicalThing* thing, float timestep)
+    {
+        OgreNewt::World* world = PhysicsManager::getSingleton()._getNewtonWorld();
+
+        calculateCamera(timestep);
+
+
+
+
+        ///@todo move to CreatureController?
+        SceneNode* node = mCharacterActor-&gt;_getSceneNode();
+        std::ostringstream ss;
+        Vector3 bodpos, playpos = node-&gt;getPosition();
+        Quaternion egal;
+        mCamBody-&gt;getPositionOrientation(bodpos,egal);
+        ss
+            &lt;&lt; &quot;scene node : &quot; &lt;&lt; playpos &lt;&lt; std::endl
+            &lt;&lt; &quot;player velocity : &quot; &lt;&lt; -mController-&gt;getVelocity().z &lt;&lt; std::endl
+            &lt;&lt; &quot;player orientation : &quot; &lt;&lt; mController-&gt;getCreature()-&gt;getActor()-&gt;getOrientation() &lt;&lt; std::endl
+            &lt;&lt; &quot;camera posder : &quot; &lt;&lt; static_cast&lt;Camera*&gt;(
+                mCameraActor-&gt;_getMovableObject())-&gt;getDerivedPosition() &lt;&lt; std::endl
+            &lt;&lt; &quot;camera orientation : &quot; &lt;&lt; mCameraActor-&gt;getWorldOrientation() &lt;&lt; std::endl
+            &lt;&lt; &quot;camera pos : &quot; &lt;&lt; bodpos &lt;&lt; std::endl
+            &lt;&lt; &quot;camera distance : &quot; &lt;&lt; mLastDistance &lt;&lt; &quot; ( &quot; &lt;&lt; mDesiredDistance &lt;&lt; &quot; ) &quot; &lt;&lt; std::endl
+            &lt;&lt; &quot;is airborne: &quot; &lt;&lt; (mController-&gt;getAbstractLocation() == CreatureController::AL_AIRBORNE ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; std::endl;
+
+        LOG_DEBUG(Logger::UI, ss.str());
+        DebugWindow::getSingleton().setPageText(msDebugWindowPageName, ss.str());
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::calculateCamera(const Ogre::Real&amp; timestep)
+    {
+        mLastCameraCollision += timestep;
+        Vector3 charPos = mCharacter-&gt;getActor()-&gt;getWorldPosition();
+        Quaternion charOri = mCharacter-&gt;getActor()-&gt;getWorldOrientation();
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+
+
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody-&gt;getPositionOrientation(camPos, camOri);
+        SceneNode* cameraNode = mCameraActor-&gt;_getSceneNode();
+
+
+        Vector3 optimalCamPos = calculateOptimalCameraPosition(true, timestep);
+        charPos = charPos + charOri * virtualCamOri * mLookAtOffset;
+
+        // Ringbuffer mit Positionen des Characters
+        mCharPositionsBufferIdx = (mCharPositionsBufferIdx + 1) % mCharPositionsBuffer.size();
+        mCharPositionsBuffer[mCharPositionsBufferIdx] = charPos;
+
+
+        // Kamera-Gr&#239;&#191;&#189;e beziehen
+        CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
+            mCameraActor-&gt;getControlledObject());
+        AxisAlignedBox camAabb = ogreCam-&gt;getDefaultSize();
+        // Radius berechnen
+        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
+
+
+
+
+
+        if (mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
+        {
+
+            // wir machen ein paar Raycasts um herauszufinden, ob wir von der jetzigen Position
+            // so zur optimalen kommen
+            const OgreNewt::MaterialID *charMaterialId = mCharBody-&gt;getMaterialGroupID();
+            const OgreNewt::MaterialID *camMaterialId = mCamBody-&gt;getMaterialGroupID();
+            PhysicsMaterialRaycast::MaterialVector materialVector;
+            materialVector.push_back(charMaterialId);
+            materialVector.push_back(camMaterialId);
+//                PhysicsManager::getSingleton()._getLevelMaterialID();
+            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
+
+            Vector3 normToOptCamPos = (optimalCamPos - charPos);
+            normToOptCamPos.normalise();
+
+
+
+            RaycastInfo infoCastOptPos = mRaycast-&gt;execute(
+                world,
+                &amp;materialVector,
+                camPos + camRadius * normToOptCamPos, // Gr&#239;&#191;&#189;e der Kamera einbeziehen
+                optimalCamPos + camRadius * normToOptCamPos,
+                true); // Gr&#239;&#191;&#189;e der Kamera einbeziehen
+
+            RaycastInfo infoCastChar = mRaycast-&gt;execute(
+                world,
+                &amp;materialVector,
+                camPos,
+                charPos,
+                true);
+
+
+            // reset the camera if the character is to far away or cannot be seen any more (Raycast)
+            Real maxdistance = Math::Pow(1.5f * mDesiredDistance + 1.4f, 2);
+            if( infoCastChar.mBody || (camPos - charPos).squaredLength() &gt; maxdistance)
+            {
+                mCharacterOccludedTime += timestep;
+                mCharacterOccludedFrameCount++;
+
+                // falls zu lange, Kamera resetten:
+                if( mCharacterOccludedTime &gt; 0.250f &amp;&amp; mCharacterOccludedFrameCount &gt; 5 )
+                {
+                    resetCamera();
+                    return;
+                }
+
+            }
+            else
+            {
+                mCharacterOccludedTime = 0;
+                mCharacterOccludedFrameCount = 0;
+            }
+
+            if( infoCastOptPos.mBody &amp;&amp; !infoCastChar.mBody )
+            {
+                // andere Position ermitteln, die ziwschen optimaler und Character liegt
+                // und erreichbar ist
+                Real lenToOptCamPos = (optimalCamPos - charPos).length();
+
+                RaycastInfo infoCastNewPos;
+                Real delta = lenToOptCamPos/2.0f;
+                Vector3 temp = charPos + delta * normToOptCamPos;
+                // Annaeherung in Schritten, an den Punkt, der von der aktuellen Position aus erreicht werden kann!
+                while( delta &gt; 0.05 ) // genauigkeit des gefundenen Punktes
+                {
+                    infoCastNewPos = mRaycast-&gt;execute(
+                        world,
+                        &amp;materialVector,
+                        camPos + camRadius * normToOptCamPos, // Groesse der Kamera!
+                        temp,
+                        true);
+                    delta = delta/2.0f;
+                    if( infoCastNewPos.mBody ) // Hindernis gefunden, naeher an Char ran
+                    {
+                        temp = temp - delta * normToOptCamPos;
+                    }
+                    else // kein Hindernis gefunden, weiter von Char weg
+                    {
+                        temp = temp + delta * normToOptCamPos;
+                    }
+                }
+
+                // Jetzt koennen wir sicher sein, dass diese Stelle erreichbar ist:
+                temp = temp - 0.05 * normToOptCamPos;
+                // Groesse der Kamera einbeziehen
+                optimalCamPos = temp - camRadius * normToOptCamPos;
+                // so ab hier kann ganz normal weiter gerechnet werden!
+            }
+
+
+            // gibt an, ob schon gebufferte Daten fuer den
+            // neuen Weg existieren und dort weitergemacht werden kann,
+            // oder ob neu nach einem Weg gesucht werden muss!
+            if( infoCastChar.mBody &amp;&amp; infoCastOptPos.mBody ) // neue Position und Character nicht erreichbar
+            {
+                // anderen Weg finden
+                // hier werden erstmal nur alte Player-Positionen betrachtet
+                // es wird davon ausgegangen, dass diese &quot;nah&quot; genug aneinanderliegen
+                // und durch &quot;Geraden&quot; miteinander verbunden werden koennen
+                // durch das spring-Acc-Damping System sollten die Bewegungen trotzdem fluessig
+                // und weich (keine scharfen Kurven) erscheinen
+
+                size_t buffSize = mCharPositionsBuffer.size();
+
+                if( !mIsPathfinding )
+                {
+                    LOG_DEBUG(Logger::UI, &quot; Pathfinding der Kamera sollte jetzt anfangen!&quot;);
+
+
+                    // letzte Character - Position suchen, die erreichbar ist...
+                    // Ist vermutlicherweise ja die letzte, davor war ja noch alles ok!
+                    unsigned int delta = 1;
+                    while ( delta &lt; buffSize )
+                    {
+                        RaycastInfo info = mRaycast-&gt;execute(
+                            world,
+                            &amp;materialVector,
+                            camPos,
+                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
+                            true);
+
+                        if( !info.mBody )
+                            break;
+                        delta++;
+                    }
+                    if( delta &gt;= buffSize )
+                    {
+                        // is wohl irgendwas schiefgegangen!
+                        LOG_MESSAGE(Logger::UI, &quot; Der Ringbuffer mit den Player-Positionen scheint zu klein zu sein; Pathfinding der Kamera fehlgeschlagen! &quot;);
+                        mIsPathfinding = false;
+                        resetCamera();
+                        return;
+                    }
+                    mLastReachableBufPos = delta;
+
+                    // auf zu der ermittelten Position!
+                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
+                }
+                else
+                {
+                    LOG_DEBUG(Logger::UI, &quot; Pathfinding der Kamera sollte weitergefhrt werden!&quot;);
+
+
+                    // suche von lastReachableBufPos aus der letzten Frame nach neuen erreichbaren Buffer-Positionen
+                    unsigned int delta = mLastReachableBufPos; // das ist die von der letzten Frame!
+                    while ( delta &gt; 0 ) // delta = 0 braucht nicht ueberprft zu werden, wurde oben schon ausgeschlossen!
+                    {
+                        RaycastInfo info = mRaycast-&gt;execute(
+                            world,
+                            &amp;materialVector,
+                            camPos,
+                            mCharPositionsBuffer[ (mCharPositionsBufferIdx - delta) % buffSize ],
+                            true);
+
+                        if( info.mBody )
+                            break;
+                        delta--;
+                    }
+                    mLastReachableBufPos = delta + 1;
+
+                    // auf zu der ermittelten Position!
+                    optimalCamPos = mCharPositionsBuffer[ (mCharPositionsBufferIdx - mLastReachableBufPos) % buffSize ];
+                }
+                mIsPathfinding = true; // so zum Testen noch keine Optimierung (doppelte Prfung gleicher sachen)
+            }
+            else
+            {
+                mIsPathfinding = false;
+            }
+
+            Vector3 diff = camPos - optimalCamPos;
+
+            Vector3 cameraVelocity;
+            cameraVelocity = mCamBody-&gt;getVelocity();
+            // spring velocity
+            Vector3 springAcc = -mLinearSpringK*diff - mLinearDampingK * cameraVelocity;
+
+            // get the camera mass
+            Real mass;
+            Vector3 inertia;
+            mCamBody-&gt;getMassMatrix(mass, inertia);
+
+            //mCamBody-&gt;setPositionOrientation(newCamPos, camOri);
+            mCamBody-&gt;setForce(springAcc * mass);
+        }
+        else if( mViewMode == VM_FIRST_PERSON )
+        {
+            mCamBody-&gt;setPositionOrientation(optimalCamPos, camOri);
+        }
+    }
+
+    //------------------------------------------------------------------------
+    Ogre::Vector3 MovementControlState::calculateOptimalCameraPosition(bool slowlyMoveBackward, const Real &amp;timestep)
+    {
+        Vector3 targetCamPos;
+
+        Vector3 charPos = mCharacter-&gt;getActor()-&gt;getWorldPosition();
+        //Quaternion charOri = mCharacter-&gt;getActor()-&gt;getWorldOrientation();
+        Quaternion charOri (mController-&gt;getYaw(), Vector3::UNIT_Y);
+        Quaternion virtualCamOri;
+        virtualCamOri.FromAngleAxis(mCamVirtualYaw, Vector3::UNIT_Y);
+        // get camera size
+        CameraObject* ogreCam = static_cast&lt;CameraObject*&gt;(
+                mCameraActor-&gt;getControlledObject());
+        AxisAlignedBox camAabb = ogreCam-&gt;getDefaultSize();
+        Real camRadius = (camAabb.getMaximum().z - camAabb.getMinimum().z) / 2.0f;
+
+
+
+
+        if( mViewMode == VM_THIRD_PERSON || mViewMode == VM_FREE_CAMERA || mViewMode == VM_PNYX_MODE)
+        {
+            charPos = charPos + charOri * mLookAtOffset;
+            if(mViewMode == VM_PNYX_MODE)
+            {
+                Quaternion camOri;
+                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+                targetCamPos =
+                    charPos
+                    + camOri * virtualCamOri * Vector3(
+                                                0,
+                                                Math::Sin(mPitch) * mDesiredDistance,
+                                                Math::Cos(mPitch) * mDesiredDistance);
+            }
+            else if(mViewMode == VM_THIRD_PERSON)
+            {
+                targetCamPos =
+                    charPos
+                    + charOri * virtualCamOri * Vector3(
+                                    0,
+                                    Math::Sin(mPitch) * mDesiredDistance,
+                                    Math::Cos(mPitch) * mDesiredDistance);
+            }
+            else
+            {
+                Quaternion camOri;
+                camOri.FromAngleAxis(mCamYaw, Vector3::UNIT_Y);
+                targetCamPos =
+                    charPos
+                    + charOri * camOri * virtualCamOri * Vector3(
+                                                0,
+                                                Math::Sin(mPitch) * mDesiredDistance,
+                                                Math::Cos(mPitch) * mDesiredDistance);
+            }
+
+            Vector3 diff = targetCamPos - charPos;
+
+            // Convexcast
+            PhysicsMaterialConvexcast::MaterialVector materialVector;
+            materialVector.push_back( mCharBody-&gt;getMaterialGroupID() );
+            materialVector.push_back( mCamBody-&gt;getMaterialGroupID() );
+            OgreNewt::World *world = PhysicsManager::getSingleton()._getNewtonWorld();
+
+            ConvexcastInfo info = mConvexcast-&gt;execute(
+                    world,
+                    &amp;materialVector,
+                    mCameraCastCollision,
+                    charPos,
+                    Quaternion::IDENTITY,
+                    targetCamPos,
+                    true);
+
+            bool CollisionFound = false;
+            if( info.mBody )
+            {
+                CollisionFound = true;
+                Real hitBodyVel = info.mBody-&gt;getVelocity().dotProduct(diff.normalisedCopy());
+                hitBodyVel = std::min(0.0f, hitBodyVel); // if the body moves, try to avoid it
+                Real dist = std::max(info.mDistance  + (hitBodyVel*timestep - 0.01)/diff.length(), 0.0);
+                diff *= dist;
+
+                mLastCameraCollision = 0;
+            }
+
+
+            // Langsames Entfernen vom Char:
+            if( CollisionFound )
+                mTimeOfLastCollision = 0.0f;
+            else
+                mTimeOfLastCollision += timestep;
+
+
+            Real desiredDistance = diff.length();
+            Vector3 camPos;
+            Quaternion camOri;
+            mCamBody-&gt;getPositionOrientation(camPos, camOri);
+
+            if( slowlyMoveBackward &amp;&amp;
+                desiredDistance &gt; mLastDistance )
+            {
+
+                diff.normalise();
+                Real newDistance;
+                Vector3 actDiff = camPos - charPos;
+                actDiff.normalise();
+
+                if( mLastCameraCollision &lt;= 0.5 ) // there was a cam collision 0.5 seconds ago
+                {
+                    newDistance = mLastDistance;
+                }
+                else if( mTimeOfLastCollision &gt; mCamMoveAwayStartTime ||
+                    diff.directionEquals(actDiff, mCamMoveAwayRange*timestep) )
+                    newDistance = mLastDistance + mCamMoveAwayVelocity*timestep;
+                else
+                    newDistance = mLastDistance;
+
+                if( newDistance &gt; desiredDistance )
+                    newDistance = desiredDistance;
+
+                diff = diff*newDistance;
+
+                mLastDistance = newDistance;
+            }
+            else
+                mLastDistance = desiredDistance;
+
+
+            targetCamPos = charPos + diff;
+        }
+        else  // FIRST_PERSON
+        {
+            // determine the optimal target position of the camera
+            targetCamPos =
+                charPos
+                + charOri * virtualCamOri * mLookAtOffset
+                + charOri * virtualCamOri * Vector3(
+                                0,
+                                Math::Sin(mPitch) * mDesiredDistance,
+                                Math::Cos(mPitch) * mDesiredDistance);
+        }
+
+
+        return targetCamPos;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::isEnemyNear()
+    {
+        mCombatSelector.updateSelection();
+
+        const Selector::GameObjectVector&amp; gov = mCombatSelector.getAllSelectedObjects();
+        for (size_t i = 0, end = gov.size(); i &lt; end; ++i)
+        {
+            Creature* creature = dynamic_cast&lt;Creature*&gt;(gov.at(i));
+            if (creature &amp;&amp;
+				creature-&gt;getAlignment() == Creature::ALIGNMENT_ENEMY &amp;&amp;
+				(creature-&gt;getLifeState() &amp; Effect::LS_NO_COMBAT) == 0)
+            {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updateSelection()
+    {
+        if ( isMouseUsedByCegui() )
+            return;
+
+        InputManager* im = InputManager::getSingletonPtr();
+
+        GameObject* oldGo = mSelector.getFirstSelectedObject();
+
+        mSelector.updateSelection();
+
+        GameObject* newGo = mSelector.getFirstSelectedObject();
+
+        if (oldGo != NULL &amp;&amp; oldGo != newGo)
+        {
+            oldGo-&gt;setHighlighted(false);
+        }
+
+        if (newGo != NULL &amp;&amp; newGo != oldGo)
+        {
+            newGo-&gt;setHighlighted(true);
+        }
+/*
+        // Optionen anzeigen
+        if (im-&gt;isMouseButtonDown(OIS::MB_Right) &amp;&amp; newGo != NULL)
+        {
+            WindowFactory::getSingleton().showActionChoice(newGo);
+        }
+        else if (im-&gt;isMouseButtonDown(OIS::MB_Left) &amp;&amp; newGo != NULL)
+        {
+            newGo-&gt;doDefaultAction(mCharacter, NULL);
+        }
+*/
+    }
+
+
+    void MovementControlState::setViewMode(ViewMode mode)
+    {
+        mViewMode = mode;
+
+        MeshObject* charMesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
+        AxisAlignedBox aabb;
+        try
+        {
+			aabb = charMesh-&gt;getPoseSize(mCharacter-&gt;getAnimation(&quot;stehen&quot;).first);
+        }
+        catch(...)
+        {
+            aabb = charMesh-&gt;getDefaultSize();
+        }
+        if (mode == VM_FIRST_PERSON)
+        {
+            mLookAtOffset = Vector3(
+                    0,
+                    (aabb.getMaximum().y - aabb.getMinimum().y) * 0.90f,
+                    (aabb.getMaximum().z - aabb.getMinimum().z) * (-0.3f) );
+            mDistanceRange.first = 0.0;
+            mDistanceRange.second = 0.0;
+            mDesiredDistance = 0.0;
+            mPitchRange.first = Degree(-85);
+            mPitchRange.second = Degree(85);
+            mPitch = 0;
+            LOG_MESSAGE(Logger::UI, &quot;Switch to 1st person view&quot;);
+            resetCamera();
+        }
+        else if(mode == VM_THIRD_PERSON)
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.90f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.0;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            LOG_MESSAGE(Logger::UI, &quot;Switch to 3rd person view&quot;);
+            resetCamera();
+        }
+        else if(mode == VM_FREE_CAMERA)
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.0;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            mCamYaw = mCharacter-&gt;getActor()-&gt;getWorldOrientation().getYaw();
+            LOG_MESSAGE(Logger::UI, &quot;Switch to free camera view&quot;);
+            resetCamera();
+        }
+        else // mode == VM_PNYX_MODE
+        {
+            mLookAtOffset = Vector3(0, (aabb.getMaximum() - aabb.getMinimum()).y * 0.80f, 0);
+            mDistanceRange.first = 0.60;
+            mDistanceRange.second = 7.00;
+            mDesiredDistance = 2.5;
+            mPitchRange.first = Degree(-75);
+            mPitchRange.second = Degree(85);
+            mPitch = Degree(30);
+            mCamYaw = mCharacter-&gt;getActor()-&gt;getWorldOrientation().getYaw();
+            LOG_MESSAGE(Logger::UI, &quot;Switch to pnyx mode movementcontroller&quot;);
+            resetCamera();
+        }
+    }
+
+    //------------------------------------------------------------------------
+/*
+    // not used at the moment!
+    void MovementControlState::interpolateAnimationLookAtOffset(std::string actAnim, std::string newAnim, Ogre::Real factor)
+    {
+        AxisAlignedBox aab;
+        Vector3 size[2];
+        Vector3 interpolatedSize;
+
+
+        // Die Gr&#239;&#191;&#189;e der beiden Animationen abfragen
+        MeshObject* mesh = dynamic_cast&lt;MeshObject*&gt;(mCharacterActor-&gt;getControlledObject());
+        aab = mesh-&gt;getPoseSize(actAnim);
+        size[0] = aab.getMaximum() - aab.getMinimum();
+
+        aab = mesh-&gt;getPoseSize(newAnim);
+        size[1] = aab.getMaximum() - aab.getMinimum();
+
+        // interpolierte Gr&#239;&#191;&#189;e (linear) berechnen
+        interpolatedSize = size[0] + factor*(size[1] - size[0]);
+
+        // LookAtOffset berechnen!
+        switch(mViewMode)
+        {
+        case VM_FIRST_PERSON:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, interpolatedSize.z * (-0.3f) );
+            break;
+        case VM_THIRD_PERSON:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.90f, 0);
+            break;
+        case VM_FREE_CAMERA:
+        default:
+            mLookAtOffset = Vector3(0, interpolatedSize.y * 0.80f, 0);
+        }
+    }
+*/
+
+    //------------------------------------------------------------------------
+    MovementControlState::ViewMode MovementControlState::getViewMode()
+    {
+        return mViewMode;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::toggleViewMode()
+    {
+        if (getViewMode() == VM_THIRD_PERSON)
+            setViewMode(VM_FIRST_PERSON);
+        else if(getViewMode() == VM_FIRST_PERSON)
+            setViewMode(VM_FREE_CAMERA);
+        else if(getViewMode() == VM_FREE_CAMERA)
+            setViewMode(VM_PNYX_MODE);
+        else
+            setViewMode(VM_THIRD_PERSON);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::resetCamera()
+    {
+        Vector3 camPos;
+        Quaternion camOri;
+        mCamBody-&gt;getPositionOrientation(camPos, camOri);
+        mCamBody-&gt;setPositionOrientation(calculateOptimalCameraPosition(false, 0.0f), camOri);
+        mCamVirtualYaw = Degree(0);
+        mNewCamVirtualYaw = Degree(0);
+        mLastCameraCollision = 0;
+        if(mViewMode == VM_FIRST_PERSON)
+            mCharacterActor-&gt;setVisible(false);
+        else
+            mCharacterActor-&gt;setVisible(true);
+        
+        LOG_MESSAGE(Logger::UI, &quot;Camera resetted.&quot;);
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::keyPressed(const OIS::KeyEvent&amp; evt, bool handled)
+    {
+        bool retval = false;
+        if( !handled )
+        {
+            int code = CommandMapper::encodeKey(evt.key, InputManager::getSingleton().getModifierCode());
+            // First see, if a control state action is defined
+	        CeGuiString command = mCommandMapper-&gt;getControlStateAction(code, mType);
+            if (command == &quot;&quot;)
+            {
+                // No. So try global actions.
+                command = mCommandMapper-&gt;getGlobalAction(code);
+            }
+            else if (command == &quot;freeflight_mode&quot;)
+            {
+                InputManager::getSingleton().pushControlState(CST_FREEFLIGHT);
+                retval = true;
+            }
+            else if (command == &quot;reset_camera&quot;)
+            {
+                resetCamera();
+                retval = true;
+            }
+            else if (command == &quot;toggle_view_mode&quot;)
+            {
+                toggleViewMode();
+                retval = true;
+            }
+            else if( startAction(command, mCharacter) )
+                retval = true;
+
+
+
+            if( !retval )
+            {
+                int movement = mCommandMapper-&gt;getMovement(evt.key);
+
+                if (movement &amp; MOVE_RUN_LOCK) // dieses einrasten lassen
+                {
+                    mCharacterState.mCurrentMovementState ^= MOVE_RUN_LOCK;
+                    movement &amp;= ~MOVE_RUN_LOCK;
+                    retval = true;
+                }
+
+                if (movement != MOVE_NONE)
+                {
+                    mCharacterState.mCurrentMovementState |= movement;
+                    retval = true;
+                }
+            }
+        }
+
+
+        if( ControlState::keyPressed(evt, handled || retval ) )
+            retval = true;
+        return retval;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::keyReleased(const OIS::KeyEvent&amp; evt, bool handled)
+    {
+        bool retval = false;
+        int movement = mCommandMapper-&gt;getMovement(evt.key);
+        if (movement != MOVE_NONE)
+        {
+            mCharacterState.mCurrentMovementState &amp;= (~movement | MOVE_RUN_LOCK);
+            retval = true;
+        }
+
+        if( ControlState::keyReleased(evt, retval) )
+            retval = true;
+        return retval;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::mouseReleased(const OIS::MouseEvent&amp; evt,
+        OIS::MouseButtonID id, bool handled)
+    {
+        handled = handled || ControlState::mouseReleased(evt, id, handled);
+
+/*
+        if( !handled )
+        {
+            InputManager* im = InputManager::getSingletonPtr();
+            int mouseButtonMask = CommandMapper::encodeKey(id, im-&gt;getModifierCode());
+            return startAction(mCommandMapper-&gt;getControlStateAction(mouseButtonMask,
+                CST_MOVEMENT), mCharacter);
+        }
+*/
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    bool MovementControlState::mousePressed(const OIS::MouseEvent&amp; evt,
+        OIS::MouseButtonID id, bool handled)
+    {
+        handled = handled || ControlState::mouseReleased(evt, id, handled);
+
+        // default action und action-selektor, falls object selected
+        GameObject* newGo = mSelector.getFirstSelectedObject();
+        if( newGo != NULL &amp;&amp; !isMouseUsedByCegui() )
+        {
+            if( id == OIS::MB_Left )
+            {
+                if( newGo-&gt;getDefaultAction(mCharacter) != NULL )
+                {
+                    newGo-&gt;doDefaultAction(mCharacter, NULL);
+                    handled = true;
+                }
+            }
+            else if( id == OIS::MB_Right )
+            {
+                WindowFactory::getSingleton().showActionChoice(newGo);
+                handled = true;
+            }
+        }
+
+        if( !handled )
+        {
+            InputManager* im = InputManager::getSingletonPtr();
+            int mouseButtonMask = CommandMapper::encodeKey(id, im-&gt;getModifierCode());
+            return startAction(mCommandMapper-&gt;getControlStateAction(mouseButtonMask,
+                CST_MOVEMENT), mCharacter);
+        }
+        return false;
+    }
+
+    //------------------------------------------------------------------------
+    DebugVisualisableFlag MovementControlState::getFlag() const
+    {
+        return DVF_CONTROL;
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::updatePrimitive()
+    {
+        if (mSceneNode-&gt;getParent() == NULL)
+        {
+            mCharacterActor-&gt;_getSceneNode()-&gt;addChild(mSceneNode);
+        }
+
+        LineSetPrimitive* lineSet = static_cast&lt;LineSetPrimitive*&gt;(mPrimitive);
+        lineSet-&gt;clear();
+        lineSet-&gt;addLine(mLookAtOffset, mLookAtOffset + Vector3(0, 1.2, 0), ColourValue::Red);
+    }
+
+    //------------------------------------------------------------------------
+    void MovementControlState::doCreatePrimitive()
+    {
+        mPrimitive = new LineSetPrimitive();
+    }
+
+    bool MovementControlState::updateAfterGameObjectLoading()
+    {
+        resume(); //saving/loading only possible in movement state
+        //// We want to check for visibility from char's POV.
+        //mSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
+        //mSelector.track(mCharacter);
+        //mSelector.setRadius(3.0);
+
+        //// Same for combat selector
+        //mCombatSelector.setCheckVisibility(true, GameObjectManager::getSingleton().getGameObject(mCharacterId));
+        //mCombatSelector.track(mCharacter);
+        //mCombatSelector.setRadius(10.0);
+
+        return false;
+    }
+
+    bool MovementControlState::beforeLoadingSaveGame()  //unhighlight selected go
+    {
+        if(mSelector.getFirstSelectedObject())
+        {
+            mSelector.getFirstSelectedObject()-&gt;setHighlighted(false);
+        }
+
+        pause(); //saving/loading only possible in movement state
+
+        return false;
+    }
+}

Modified: rl/trunk/engine/ui/src/UiSubsystem.cpp
===================================================================
--- rl/trunk/engine/ui/src/UiSubsystem.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/UiSubsystem.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -17,9 +17,7 @@
 
 #include &quot;UiSubsystem.h&quot;
 
-#include &lt;CEGUISystem.h&gt;
-#include &lt;CEGUIWindow.h&gt;
-#include &lt;CEGUIWindowManager.h&gt;
+#include &lt;CEGUI.h&gt;
 
 #ifdef __APPLE__
 #   include &lt;OgreCEGUIRenderer/OgreCEGUIRenderer.h&gt;
@@ -39,6 +37,8 @@
 #include &quot;GameLoop.h&quot;
 #include &quot;GameObjectManager.h&quot;
 #include &quot;InputManager.h&quot;
+#include &quot;ItemDescriptionDragContainer.h&quot;
+#include &quot;ItemIconDragContainer.h&quot;
 #include &quot;Logger.h&quot;
 #include &quot;RulesMessages.h&quot;
 #include &quot;ScriptWrapper.h&quot;
@@ -50,6 +50,18 @@
 using namespace Ogre;
 template&lt;&gt; rl::UiSubsystem* Singleton&lt;rl::UiSubsystem&gt;::ms_Singleton = 0;
 
+// this function needs to be in the CEGUI-namespace
+namespace CEGUI{
+    void initializeOwnCeguiWindowFactories()
+    {
+            CEGUI::WindowFactoryManager&amp; wfMgr = CEGUI::WindowFactoryManager::getSingleton();
+            wfMgr.addFactory(&amp;CEGUI_WINDOW_FACTORY(ItemDescriptionDragContainer)); // ohne rl:: davor hier!
+            //wfMgr.addFalagardWindowMapping(&quot;ItemDescriptionDragContainer&quot;, &quot;CEGUI/ItemDescriptionDragContainer&quot;, &quot;&quot;, &quot;Falagard/Default&quot;);
+            wfMgr.addFactory(&amp;CEGUI_WINDOW_FACTORY(ItemIconDragContainer)); // ohne rl:: davor hier!
+            //wfMgr.addFalagardWindowMapping(&quot;ItemIconDragContainer&quot;, &quot;CEGUI/ItemIconDragContainer&quot;, &quot;&quot;, &quot;Falagard/Default&quot;);
+    }
+}
+
 namespace rl {
     const char* UiSubsystem::CEGUI_ROOT = &quot;RootWindow&quot;;
 
@@ -138,9 +150,14 @@
         sheet-&gt;setZOrderingEnabled(true);
         sheet-&gt;moveToBack();
         System::getSingleton().setDefaultTooltip(&quot;RastullahLook/Tooltip&quot;);
+
+        CEGUI::initializeOwnCeguiWindowFactories();
+
         LOG_MESSAGE2(Logger::UI, &quot;CEGUI initialized.&quot;,
             &quot;UiSubsystem::initializeUiSubsystem&quot;);
 
+
+
         mWindowManager = new WindowManager();
 
         //Initializing InputManager
@@ -149,6 +166,7 @@
             &quot;UiSubsystem::initializeUiSubsystem&quot;);
 
         mWindowFactory-&gt;initialize();
+        LOG_MESSAGE2(Logger::UI, &quot;WindowFactory initialized.&quot;, &quot;UiSubsystem::initializeUiSubsystem&quot;);
     }
 
     CEGUI::OgreCEGUIRenderer* UiSubsystem::getGUIRenderer()

Modified: rl/trunk/engine/ui/src/WindowFactory.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFactory.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/WindowFactory.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -164,6 +164,8 @@
     void WindowFactory::toggleConsole()
     {
         mConsole-&gt;setVisible(!mConsole-&gt;isVisible());
+        if( mConsole-&gt;isVisible() )
+            mConsole-&gt;getWindow()-&gt;activate();
     }
 
     void WindowFactory::toggleDebugWindow()

Modified: rl/trunk/engine/ui/src/WindowFadeJob.cpp
===================================================================
--- rl/trunk/engine/ui/src/WindowFadeJob.cpp	2009-02-09 20:10:01 UTC (rev 4754)
+++ rl/trunk/engine/ui/src/WindowFadeJob.cpp	2009-02-09 20:56:41 UTC (rev 4755)
@@ -32,7 +32,7 @@
         : Job(true, true),
         mAbstractWindow(window),
         mCEGUIWindow(window-&gt;getWindow()),
-        mItemDragContainer(NULL),
+//        mItemDragContainer(NULL),
         mMode(mode),
         mChangeRate(changeRate),
         mCurrentAlpha(mode == FADE_IN ? 0.0f : 1.0f),
@@ -47,7 +47,7 @@
         : Job(true, true),
         mAbstractWindow(NULL),
         mCEGUIWindow(window),
-        mItemDragContainer(NULL),
+//        mItemDragContainer(NULL),
         mMode(mode),
         mChangeRate(changeRate),
         mCurrentAlpha(mode == FADE_IN ? 0.0f : 1.0f),
@@ -57,7 +57,7 @@
         mCEGUIWindow-&gt;setVisible(true);
         mCEGUIWindow-&gt;setAlpha(mCurrentAlpha);
     }
-
+/*
     WindowFadeJob::WindowFadeJob(ItemDragContainer* window, Mode mode, Real targetAlpha, Real changeRate)
         : Job(true, true),
         mAbstractWindow(NULL),
@@ -72,7 +72,7 @@
         mCEGUIWindow-&gt;setVisible(true);
         mCEGUIWindow-&gt;setAlpha(mCurrentAlpha);
     }
-
+*/
     bool WindowFadeJob::execute(Real time)
     {
         mCurrentAlpha += time * mChangeRate * Math::Sign(mTargetAlpha - mCurrentAlpha);
@@ -97,8 +97,8 @@
         {
             if( mAbstractWindow )
                 WindowManager::getSingleton().destroyWindow(mAbstractWindow);
-            else if(mItemDragContainer)
-                delete mItemDragContainer;
+//            else if(mItemDragContainer)
+//                delete mItemDragContainer;
             else
                 CEGUI::WindowManager::getSingleton().destroyWindow(mCEGUIWindow);
         }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001811.html">[Dsa-hl-svn] r4754 - in rl/branches/newton20/engine: core/include	ui/include
</A></li>
	<LI>Next message: <A HREF="001813.html">[Dsa-hl-svn] r4756 - modules/common/gui/windows
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1812">[ date ]</a>
              <a href="thread.html#1812">[ thread ]</a>
              <a href="subject.html#1812">[ subject ]</a>
              <a href="author.html#1812">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
