<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Dsa-hl-svn] r4768 - in dependencies/OgreNewt_ngt: . Mac	Mac/English.lproj Mac/OgreNewt.xcodeproj inc src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dsa-hl-svn/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4768%20-%20in%20dependencies/OgreNewt_ngt%3A%20.%20Mac%0A%09Mac/English.lproj%20Mac/OgreNewt.xcodeproj%20inc%20src&In-Reply-To=%3C200902142136.n1ELaT1P005439%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001824.html">
   <LINK REL="Next"  HREF="001826.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Dsa-hl-svn] r4768 - in dependencies/OgreNewt_ngt: . Mac	Mac/English.lproj Mac/OgreNewt.xcodeproj inc src</H1>
    <B>blakharaz at mail.berlios.de</B> 
    <A HREF="mailto:dsa-hl-svn%40lists.berlios.de?Subject=Re%3A%20%5BDsa-hl-svn%5D%20r4768%20-%20in%20dependencies/OgreNewt_ngt%3A%20.%20Mac%0A%09Mac/English.lproj%20Mac/OgreNewt.xcodeproj%20inc%20src&In-Reply-To=%3C200902142136.n1ELaT1P005439%40sheep.berlios.de%3E"
       TITLE="[Dsa-hl-svn] r4768 - in dependencies/OgreNewt_ngt: . Mac	Mac/English.lproj Mac/OgreNewt.xcodeproj inc src">blakharaz at mail.berlios.de
       </A><BR>
    <I>Sat Feb 14 22:36:29 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001824.html">[Dsa-hl-svn] r4767 - rl/trunk/engine/core/src
</A></li>
        <LI>Next message: <A HREF="001826.html">[Dsa-hl-svn] r4769 - in rl/trunk/editors/Lockenwickler: . src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1825">[ date ]</a>
              <a href="thread.html#1825">[ thread ]</a>
              <a href="subject.html#1825">[ subject ]</a>
              <a href="author.html#1825">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: blakharaz
Date: 2009-02-14 22:36:25 +0100 (Sat, 14 Feb 2009)
New Revision: 4768

Added:
   dependencies/OgreNewt_ngt/Mac/
   dependencies/OgreNewt_ngt/Mac/English.lproj/
   dependencies/OgreNewt_ngt/Mac/English.lproj/InfoPlist.strings
   dependencies/OgreNewt_ngt/Mac/Info.plist
   dependencies/OgreNewt_ngt/Mac/OgreNewt.xcodeproj/
   dependencies/OgreNewt_ngt/Mac/OgreNewt.xcodeproj/project.pbxproj
Modified:
   dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionSerializer.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_Prerequisites.h
   dependencies/OgreNewt_ngt/inc/OgreNewt_Tools.h
   dependencies/OgreNewt_ngt/src/OgreNewt_BasicFrameListener.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_CollisionPrimitives.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_CollisionSerializer.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp
   dependencies/OgreNewt_ngt/src/OgreNewt_Tools.cpp
Log:
Make OgreNewt_ngt compile on Mac OS X (with some nasty #ifdefs, and on 10.5 only)

Added: dependencies/OgreNewt_ngt/Mac/English.lproj/InfoPlist.strings
===================================================================
(Binary files differ)


Property changes on: dependencies/OgreNewt_ngt/Mac/English.lproj/InfoPlist.strings
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: dependencies/OgreNewt_ngt/Mac/Info.plist
===================================================================
--- dependencies/OgreNewt_ngt/Mac/Info.plist	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/Mac/Info.plist	2009-02-14 21:36:25 UTC (rev 4768)
@@ -0,0 +1,26 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+&lt;!DOCTYPE plist PUBLIC &quot;-//Apple Computer//DTD PLIST 1.0//EN&quot; &quot;<A HREF="http://www.apple.com/DTDs/PropertyList-1.0.dtd">http://www.apple.com/DTDs/PropertyList-1.0.dtd</A>&quot;&gt;
+&lt;plist version=&quot;1.0&quot;&gt;
+&lt;dict&gt;
+	&lt;key&gt;CFBundleDevelopmentRegion&lt;/key&gt;
+	&lt;string&gt;English&lt;/string&gt;
+	&lt;key&gt;CFBundleExecutable&lt;/key&gt;
+	&lt;string&gt;OgreNewt&lt;/string&gt;
+	&lt;key&gt;CFBundleIconFile&lt;/key&gt;
+	&lt;string&gt;&lt;/string&gt;
+	&lt;key&gt;CFBundleIdentifier&lt;/key&gt;
+	&lt;string&gt;com.apple.carbonframeworktemplate&lt;/string&gt;
+	&lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;
+	&lt;string&gt;6.0&lt;/string&gt;
+	&lt;key&gt;CFBundlePackageType&lt;/key&gt;
+	&lt;string&gt;FMWK&lt;/string&gt;
+	&lt;key&gt;CFBundleSignature&lt;/key&gt;
+	&lt;string&gt;????&lt;/string&gt;
+	&lt;key&gt;CFBundleVersion&lt;/key&gt;
+	&lt;string&gt;1.0&lt;/string&gt;
+        &lt;key&gt;CFBundleShortVersionString&lt;/key&gt;
+        &lt;string&gt;1.0&lt;/string&gt;
+	&lt;key&gt;CSResourcesFileMapped&lt;/key&gt;
+	&lt;true/&gt;
+&lt;/dict&gt;
+&lt;/plist&gt;

Added: dependencies/OgreNewt_ngt/Mac/OgreNewt.xcodeproj/project.pbxproj
===================================================================
--- dependencies/OgreNewt_ngt/Mac/OgreNewt.xcodeproj/project.pbxproj	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/Mac/OgreNewt.xcodeproj/project.pbxproj	2009-02-14 21:36:25 UTC (rev 4768)
@@ -0,0 +1,446 @@
+// !$*UTF8*$!
+{
+	archiveVersion = 1;
+	classes = {
+	};
+	objectVersion = 42;
+	objects = {
+
+/* Begin PBXBuildFile section */
+		444EA9A30BD0D33B00C6D4A0 /* Ogre.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EA9A20BD0D33B00C6D4A0 /* Ogre.framework */; };
+		444EA9A70BD0D35800C6D4A0 /* libnewton32.a in Frameworks */ = {isa = PBXBuildFile; fileRef = 444EA9A60BD0D35800C6D4A0 /* libnewton32.a */; };
+		487D45C30F47388600D1D69F /* OgreNewt.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45AF0F47388600D1D69F /* OgreNewt.h */; };
+		487D45C50F47388600D1D69F /* OgreNewt_BasicJoints.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B10F47388600D1D69F /* OgreNewt_BasicJoints.h */; };
+		487D45C60F47388600D1D69F /* OgreNewt_Body.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B20F47388600D1D69F /* OgreNewt_Body.h */; };
+		487D45C70F47388600D1D69F /* OgreNewt_BodyInAABBIterator.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B30F47388600D1D69F /* OgreNewt_BodyInAABBIterator.h */; };
+		487D45C80F47388600D1D69F /* OgreNewt_Collision.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B40F47388600D1D69F /* OgreNewt_Collision.h */; };
+		487D45C90F47388600D1D69F /* OgreNewt_CollisionPrimitives.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B50F47388600D1D69F /* OgreNewt_CollisionPrimitives.h */; };
+		487D45CA0F47388600D1D69F /* OgreNewt_CollisionSerializer.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B60F47388600D1D69F /* OgreNewt_CollisionSerializer.h */; };
+		487D45CB0F47388600D1D69F /* OgreNewt_ContactCallback.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B70F47388600D1D69F /* OgreNewt_ContactCallback.h */; };
+		487D45CC0F47388600D1D69F /* OgreNewt_ContactJoint.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B80F47388600D1D69F /* OgreNewt_ContactJoint.h */; };
+		487D45CD0F47388600D1D69F /* OgreNewt_Debugger.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45B90F47388600D1D69F /* OgreNewt_Debugger.h */; };
+		487D45CE0F47388600D1D69F /* OgreNewt_Joint.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45BA0F47388600D1D69F /* OgreNewt_Joint.h */; };
+		487D45CF0F47388600D1D69F /* OgreNewt_MaterialID.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45BB0F47388600D1D69F /* OgreNewt_MaterialID.h */; };
+		487D45D00F47388600D1D69F /* OgreNewt_MaterialPair.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45BC0F47388600D1D69F /* OgreNewt_MaterialPair.h */; };
+		487D45D10F47388600D1D69F /* OgreNewt_PlayerController.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45BD0F47388600D1D69F /* OgreNewt_PlayerController.h */; };
+		487D45D20F47388600D1D69F /* OgreNewt_Prerequisites.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45BE0F47388600D1D69F /* OgreNewt_Prerequisites.h */; };
+		487D45D30F47388600D1D69F /* OgreNewt_RayCast.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45BF0F47388600D1D69F /* OgreNewt_RayCast.h */; };
+		487D45D40F47388600D1D69F /* OgreNewt_Tools.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45C00F47388600D1D69F /* OgreNewt_Tools.h */; };
+		487D45D50F47388600D1D69F /* OgreNewt_Vehicle.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45C10F47388600D1D69F /* OgreNewt_Vehicle.h */; };
+		487D45D60F47388600D1D69F /* OgreNewt_World.h in Headers */ = {isa = PBXBuildFile; fileRef = 487D45C20F47388600D1D69F /* OgreNewt_World.h */; };
+		487D45EA0F47389A00D1D69F /* OgreNewt_BasicJoints.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45D80F47389A00D1D69F /* OgreNewt_BasicJoints.cpp */; };
+		487D45EB0F47389A00D1D69F /* OgreNewt_Body.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45D90F47389A00D1D69F /* OgreNewt_Body.cpp */; };
+		487D45EC0F47389A00D1D69F /* OgreNewt_BodyInAABBIterator.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45DA0F47389A00D1D69F /* OgreNewt_BodyInAABBIterator.cpp */; };
+		487D45ED0F47389A00D1D69F /* OgreNewt_Collision.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45DB0F47389A00D1D69F /* OgreNewt_Collision.cpp */; };
+		487D45EE0F47389A00D1D69F /* OgreNewt_CollisionPrimitives.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45DC0F47389A00D1D69F /* OgreNewt_CollisionPrimitives.cpp */; };
+		487D45EF0F47389A00D1D69F /* OgreNewt_CollisionSerializer.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45DD0F47389A00D1D69F /* OgreNewt_CollisionSerializer.cpp */; };
+		487D45F00F47389A00D1D69F /* OgreNewt_ContactCallback.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45DE0F47389A00D1D69F /* OgreNewt_ContactCallback.cpp */; };
+		487D45F10F47389A00D1D69F /* OgreNewt_ContactJoint.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45DF0F47389A00D1D69F /* OgreNewt_ContactJoint.cpp */; };
+		487D45F20F47389A00D1D69F /* OgreNewt_Debugger.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E00F47389A00D1D69F /* OgreNewt_Debugger.cpp */; };
+		487D45F30F47389A00D1D69F /* OgreNewt_Joint.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E10F47389A00D1D69F /* OgreNewt_Joint.cpp */; };
+		487D45F40F47389A00D1D69F /* OgreNewt_MaterialID.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E20F47389A00D1D69F /* OgreNewt_MaterialID.cpp */; };
+		487D45F50F47389A00D1D69F /* OgreNewt_MaterialPair.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E30F47389A00D1D69F /* OgreNewt_MaterialPair.cpp */; };
+		487D45F60F47389A00D1D69F /* OgreNewt_PlayerController.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E40F47389A00D1D69F /* OgreNewt_PlayerController.cpp */; };
+		487D45F70F47389A00D1D69F /* OgreNewt_RayCast.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E50F47389A00D1D69F /* OgreNewt_RayCast.cpp */; };
+		487D45F80F47389A00D1D69F /* OgreNewt_Tools.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E60F47389A00D1D69F /* OgreNewt_Tools.cpp */; };
+		487D45F90F47389A00D1D69F /* OgreNewt_Vehicle.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E70F47389A00D1D69F /* OgreNewt_Vehicle.cpp */; };
+		487D45FA0F47389A00D1D69F /* OgreNewt_World.cpp in Sources */ = {isa = PBXBuildFile; fileRef = 487D45E80F47389A00D1D69F /* OgreNewt_World.cpp */; };
+		48A94EC50F476C1700252666 /* libc.dylib in Frameworks */ = {isa = PBXBuildFile; fileRef = 48A94EC10F476B1400252666 /* libc.dylib */; };
+		8D07F2C00486CC7A007CD1D0 /* InfoPlist.strings in Resources */ = {isa = PBXBuildFile; fileRef = 089C1666FE841158C02AAC07 /* InfoPlist.strings */; };
+/* End PBXBuildFile section */
+
+/* Begin PBXFileReference section */
+		089C1667FE841158C02AAC07 /* English */ = {isa = PBXFileReference; fileEncoding = 10; lastKnownFileType = text.plist.strings; name = English; path = English.lproj/InfoPlist.strings; sourceTree = &quot;&lt;group&gt;&quot;; };
+		444EA9A20BD0D33B00C6D4A0 /* Ogre.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Ogre.framework; path = /Library/Frameworks/Ogre.framework; sourceTree = &quot;&lt;absolute&gt;&quot;; };
+		444EA9A60BD0D35800C6D4A0 /* libnewton32.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; name = libnewton32.a; path = /usr/local/lib/libnewton32.a; sourceTree = &quot;&lt;absolute&gt;&quot;; };
+		487D45AF0F47388600D1D69F /* OgreNewt.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt.h; path = ../inc/OgreNewt.h; sourceTree = SOURCE_ROOT; };
+		487D45B10F47388600D1D69F /* OgreNewt_BasicJoints.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_BasicJoints.h; path = ../inc/OgreNewt_BasicJoints.h; sourceTree = SOURCE_ROOT; };
+		487D45B20F47388600D1D69F /* OgreNewt_Body.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_Body.h; path = ../inc/OgreNewt_Body.h; sourceTree = SOURCE_ROOT; };
+		487D45B30F47388600D1D69F /* OgreNewt_BodyInAABBIterator.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_BodyInAABBIterator.h; path = ../inc/OgreNewt_BodyInAABBIterator.h; sourceTree = SOURCE_ROOT; };
+		487D45B40F47388600D1D69F /* OgreNewt_Collision.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_Collision.h; path = ../inc/OgreNewt_Collision.h; sourceTree = SOURCE_ROOT; };
+		487D45B50F47388600D1D69F /* OgreNewt_CollisionPrimitives.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_CollisionPrimitives.h; path = ../inc/OgreNewt_CollisionPrimitives.h; sourceTree = SOURCE_ROOT; };
+		487D45B60F47388600D1D69F /* OgreNewt_CollisionSerializer.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_CollisionSerializer.h; path = ../inc/OgreNewt_CollisionSerializer.h; sourceTree = SOURCE_ROOT; };
+		487D45B70F47388600D1D69F /* OgreNewt_ContactCallback.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_ContactCallback.h; path = ../inc/OgreNewt_ContactCallback.h; sourceTree = SOURCE_ROOT; };
+		487D45B80F47388600D1D69F /* OgreNewt_ContactJoint.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_ContactJoint.h; path = ../inc/OgreNewt_ContactJoint.h; sourceTree = SOURCE_ROOT; };
+		487D45B90F47388600D1D69F /* OgreNewt_Debugger.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_Debugger.h; path = ../inc/OgreNewt_Debugger.h; sourceTree = SOURCE_ROOT; };
+		487D45BA0F47388600D1D69F /* OgreNewt_Joint.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_Joint.h; path = ../inc/OgreNewt_Joint.h; sourceTree = SOURCE_ROOT; };
+		487D45BB0F47388600D1D69F /* OgreNewt_MaterialID.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_MaterialID.h; path = ../inc/OgreNewt_MaterialID.h; sourceTree = SOURCE_ROOT; };
+		487D45BC0F47388600D1D69F /* OgreNewt_MaterialPair.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_MaterialPair.h; path = ../inc/OgreNewt_MaterialPair.h; sourceTree = SOURCE_ROOT; };
+		487D45BD0F47388600D1D69F /* OgreNewt_PlayerController.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_PlayerController.h; path = ../inc/OgreNewt_PlayerController.h; sourceTree = SOURCE_ROOT; };
+		487D45BE0F47388600D1D69F /* OgreNewt_Prerequisites.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_Prerequisites.h; path = ../inc/OgreNewt_Prerequisites.h; sourceTree = SOURCE_ROOT; };
+		487D45BF0F47388600D1D69F /* OgreNewt_RayCast.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_RayCast.h; path = ../inc/OgreNewt_RayCast.h; sourceTree = SOURCE_ROOT; };
+		487D45C00F47388600D1D69F /* OgreNewt_Tools.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_Tools.h; path = ../inc/OgreNewt_Tools.h; sourceTree = SOURCE_ROOT; };
+		487D45C10F47388600D1D69F /* OgreNewt_Vehicle.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_Vehicle.h; path = ../inc/OgreNewt_Vehicle.h; sourceTree = SOURCE_ROOT; };
+		487D45C20F47388600D1D69F /* OgreNewt_World.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; name = OgreNewt_World.h; path = ../inc/OgreNewt_World.h; sourceTree = SOURCE_ROOT; };
+		487D45D80F47389A00D1D69F /* OgreNewt_BasicJoints.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_BasicJoints.cpp; path = ../src/OgreNewt_BasicJoints.cpp; sourceTree = SOURCE_ROOT; };
+		487D45D90F47389A00D1D69F /* OgreNewt_Body.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_Body.cpp; path = ../src/OgreNewt_Body.cpp; sourceTree = SOURCE_ROOT; };
+		487D45DA0F47389A00D1D69F /* OgreNewt_BodyInAABBIterator.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_BodyInAABBIterator.cpp; path = ../src/OgreNewt_BodyInAABBIterator.cpp; sourceTree = SOURCE_ROOT; };
+		487D45DB0F47389A00D1D69F /* OgreNewt_Collision.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_Collision.cpp; path = ../src/OgreNewt_Collision.cpp; sourceTree = SOURCE_ROOT; };
+		487D45DC0F47389A00D1D69F /* OgreNewt_CollisionPrimitives.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_CollisionPrimitives.cpp; path = ../src/OgreNewt_CollisionPrimitives.cpp; sourceTree = SOURCE_ROOT; };
+		487D45DD0F47389A00D1D69F /* OgreNewt_CollisionSerializer.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_CollisionSerializer.cpp; path = ../src/OgreNewt_CollisionSerializer.cpp; sourceTree = SOURCE_ROOT; };
+		487D45DE0F47389A00D1D69F /* OgreNewt_ContactCallback.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_ContactCallback.cpp; path = ../src/OgreNewt_ContactCallback.cpp; sourceTree = SOURCE_ROOT; };
+		487D45DF0F47389A00D1D69F /* OgreNewt_ContactJoint.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_ContactJoint.cpp; path = ../src/OgreNewt_ContactJoint.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E00F47389A00D1D69F /* OgreNewt_Debugger.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_Debugger.cpp; path = ../src/OgreNewt_Debugger.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E10F47389A00D1D69F /* OgreNewt_Joint.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_Joint.cpp; path = ../src/OgreNewt_Joint.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E20F47389A00D1D69F /* OgreNewt_MaterialID.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_MaterialID.cpp; path = ../src/OgreNewt_MaterialID.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E30F47389A00D1D69F /* OgreNewt_MaterialPair.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_MaterialPair.cpp; path = ../src/OgreNewt_MaterialPair.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E40F47389A00D1D69F /* OgreNewt_PlayerController.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_PlayerController.cpp; path = ../src/OgreNewt_PlayerController.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E50F47389A00D1D69F /* OgreNewt_RayCast.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_RayCast.cpp; path = ../src/OgreNewt_RayCast.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E60F47389A00D1D69F /* OgreNewt_Tools.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_Tools.cpp; path = ../src/OgreNewt_Tools.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E70F47389A00D1D69F /* OgreNewt_Vehicle.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_Vehicle.cpp; path = ../src/OgreNewt_Vehicle.cpp; sourceTree = SOURCE_ROOT; };
+		487D45E80F47389A00D1D69F /* OgreNewt_World.cpp */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.cpp.cpp; name = OgreNewt_World.cpp; path = ../src/OgreNewt_World.cpp; sourceTree = SOURCE_ROOT; };
+		48A94EBE0F476A8700252666 /* libstdc++.dylib */ = {isa = PBXFileReference; lastKnownFileType = &quot;compiled.mach-o.dylib&quot;; name = &quot;libstdc++.dylib&quot;; path = &quot;usr/lib/i686-apple-darwin9/4.0.1/libstdc++.dylib&quot;; sourceTree = SDKROOT; };
+		48A94EC10F476B1400252666 /* libc.dylib */ = {isa = PBXFileReference; lastKnownFileType = &quot;compiled.mach-o.dylib&quot;; name = libc.dylib; path = usr/lib/libc.dylib; sourceTree = SDKROOT; };
+		8D07F2C70486CC7A007CD1D0 /* Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist; path = Info.plist; sourceTree = &quot;&lt;group&gt;&quot;; };
+		8D07F2C80486CC7A007CD1D0 /* OgreNewt.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = OgreNewt.framework; sourceTree = BUILT_PRODUCTS_DIR; };
+/* End PBXFileReference section */
+
+/* Begin PBXFrameworksBuildPhase section */
+		8D07F2C30486CC7A007CD1D0 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				444EA9A30BD0D33B00C6D4A0 /* Ogre.framework in Frameworks */,
+				444EA9A70BD0D35800C6D4A0 /* libnewton32.a in Frameworks */,
+				48A94EC50F476C1700252666 /* libc.dylib in Frameworks */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXFrameworksBuildPhase section */
+
+/* Begin PBXGroup section */
+		034768DDFF38A45A11DB9C8B /* Products */ = {
+			isa = PBXGroup;
+			children = (
+				8D07F2C80486CC7A007CD1D0 /* OgreNewt.framework */,
+			);
+			name = Products;
+			sourceTree = &quot;&lt;group&gt;&quot;;
+		};
+		0867D691FE84028FC02AAC07 /* OgreNewt */ = {
+			isa = PBXGroup;
+			children = (
+				08FB77ACFE841707C02AAC07 /* Source */,
+				089C1665FE841158C02AAC07 /* Resources */,
+				0867D69AFE84028FC02AAC07 /* External Frameworks and Libraries */,
+				034768DDFF38A45A11DB9C8B /* Products */,
+				48A94EBE0F476A8700252666 /* libstdc++.dylib */,
+				48A94EC10F476B1400252666 /* libc.dylib */,
+			);
+			name = OgreNewt;
+			sourceTree = &quot;&lt;group&gt;&quot;;
+		};
+		0867D69AFE84028FC02AAC07 /* External Frameworks and Libraries */ = {
+			isa = PBXGroup;
+			children = (
+				444EA9A60BD0D35800C6D4A0 /* libnewton32.a */,
+				444EA9A20BD0D33B00C6D4A0 /* Ogre.framework */,
+			);
+			name = &quot;External Frameworks and Libraries&quot;;
+			sourceTree = &quot;&lt;group&gt;&quot;;
+		};
+		089C1665FE841158C02AAC07 /* Resources */ = {
+			isa = PBXGroup;
+			children = (
+				8D07F2C70486CC7A007CD1D0 /* Info.plist */,
+				089C1666FE841158C02AAC07 /* InfoPlist.strings */,
+			);
+			name = Resources;
+			sourceTree = &quot;&lt;group&gt;&quot;;
+		};
+		08FB77ACFE841707C02AAC07 /* Source */ = {
+			isa = PBXGroup;
+			children = (
+				487D45D80F47389A00D1D69F /* OgreNewt_BasicJoints.cpp */,
+				487D45D90F47389A00D1D69F /* OgreNewt_Body.cpp */,
+				487D45DA0F47389A00D1D69F /* OgreNewt_BodyInAABBIterator.cpp */,
+				487D45DB0F47389A00D1D69F /* OgreNewt_Collision.cpp */,
+				487D45DC0F47389A00D1D69F /* OgreNewt_CollisionPrimitives.cpp */,
+				487D45DD0F47389A00D1D69F /* OgreNewt_CollisionSerializer.cpp */,
+				487D45DE0F47389A00D1D69F /* OgreNewt_ContactCallback.cpp */,
+				487D45DF0F47389A00D1D69F /* OgreNewt_ContactJoint.cpp */,
+				487D45E00F47389A00D1D69F /* OgreNewt_Debugger.cpp */,
+				487D45E10F47389A00D1D69F /* OgreNewt_Joint.cpp */,
+				487D45E20F47389A00D1D69F /* OgreNewt_MaterialID.cpp */,
+				487D45E30F47389A00D1D69F /* OgreNewt_MaterialPair.cpp */,
+				487D45E40F47389A00D1D69F /* OgreNewt_PlayerController.cpp */,
+				487D45E50F47389A00D1D69F /* OgreNewt_RayCast.cpp */,
+				487D45E60F47389A00D1D69F /* OgreNewt_Tools.cpp */,
+				487D45E70F47389A00D1D69F /* OgreNewt_Vehicle.cpp */,
+				487D45E80F47389A00D1D69F /* OgreNewt_World.cpp */,
+				487D45AF0F47388600D1D69F /* OgreNewt.h */,
+				487D45B10F47388600D1D69F /* OgreNewt_BasicJoints.h */,
+				487D45B20F47388600D1D69F /* OgreNewt_Body.h */,
+				487D45B30F47388600D1D69F /* OgreNewt_BodyInAABBIterator.h */,
+				487D45B40F47388600D1D69F /* OgreNewt_Collision.h */,
+				487D45B50F47388600D1D69F /* OgreNewt_CollisionPrimitives.h */,
+				487D45B60F47388600D1D69F /* OgreNewt_CollisionSerializer.h */,
+				487D45B70F47388600D1D69F /* OgreNewt_ContactCallback.h */,
+				487D45B80F47388600D1D69F /* OgreNewt_ContactJoint.h */,
+				487D45B90F47388600D1D69F /* OgreNewt_Debugger.h */,
+				487D45BA0F47388600D1D69F /* OgreNewt_Joint.h */,
+				487D45BB0F47388600D1D69F /* OgreNewt_MaterialID.h */,
+				487D45BC0F47388600D1D69F /* OgreNewt_MaterialPair.h */,
+				487D45BD0F47388600D1D69F /* OgreNewt_PlayerController.h */,
+				487D45BE0F47388600D1D69F /* OgreNewt_Prerequisites.h */,
+				487D45BF0F47388600D1D69F /* OgreNewt_RayCast.h */,
+				487D45C00F47388600D1D69F /* OgreNewt_Tools.h */,
+				487D45C10F47388600D1D69F /* OgreNewt_Vehicle.h */,
+				487D45C20F47388600D1D69F /* OgreNewt_World.h */,
+			);
+			name = Source;
+			sourceTree = &quot;&lt;group&gt;&quot;;
+		};
+/* End PBXGroup section */
+
+/* Begin PBXHeadersBuildPhase section */
+		8D07F2BD0486CC7A007CD1D0 /* Headers */ = {
+			isa = PBXHeadersBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				487D45C30F47388600D1D69F /* OgreNewt.h in Headers */,
+				487D45C50F47388600D1D69F /* OgreNewt_BasicJoints.h in Headers */,
+				487D45C60F47388600D1D69F /* OgreNewt_Body.h in Headers */,
+				487D45C70F47388600D1D69F /* OgreNewt_BodyInAABBIterator.h in Headers */,
+				487D45C80F47388600D1D69F /* OgreNewt_Collision.h in Headers */,
+				487D45C90F47388600D1D69F /* OgreNewt_CollisionPrimitives.h in Headers */,
+				487D45CA0F47388600D1D69F /* OgreNewt_CollisionSerializer.h in Headers */,
+				487D45CB0F47388600D1D69F /* OgreNewt_ContactCallback.h in Headers */,
+				487D45CC0F47388600D1D69F /* OgreNewt_ContactJoint.h in Headers */,
+				487D45CD0F47388600D1D69F /* OgreNewt_Debugger.h in Headers */,
+				487D45CE0F47388600D1D69F /* OgreNewt_Joint.h in Headers */,
+				487D45CF0F47388600D1D69F /* OgreNewt_MaterialID.h in Headers */,
+				487D45D00F47388600D1D69F /* OgreNewt_MaterialPair.h in Headers */,
+				487D45D10F47388600D1D69F /* OgreNewt_PlayerController.h in Headers */,
+				487D45D20F47388600D1D69F /* OgreNewt_Prerequisites.h in Headers */,
+				487D45D30F47388600D1D69F /* OgreNewt_RayCast.h in Headers */,
+				487D45D40F47388600D1D69F /* OgreNewt_Tools.h in Headers */,
+				487D45D50F47388600D1D69F /* OgreNewt_Vehicle.h in Headers */,
+				487D45D60F47388600D1D69F /* OgreNewt_World.h in Headers */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXHeadersBuildPhase section */
+
+/* Begin PBXNativeTarget section */
+		8D07F2BC0486CC7A007CD1D0 /* OgreNewt */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = 4FADC24208B4156D00ABE55E /* Build configuration list for PBXNativeTarget &quot;OgreNewt&quot; */;
+			buildPhases = (
+				8D07F2BD0486CC7A007CD1D0 /* Headers */,
+				8D07F2BF0486CC7A007CD1D0 /* Resources */,
+				8D07F2C10486CC7A007CD1D0 /* Sources */,
+				8D07F2C30486CC7A007CD1D0 /* Frameworks */,
+				8D07F2C50486CC7A007CD1D0 /* Rez */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = OgreNewt;
+			productInstallPath = &quot;$(HOME)/Library/Frameworks&quot;;
+			productName = OgreNewt;
+			productReference = 8D07F2C80486CC7A007CD1D0 /* OgreNewt.framework */;
+			productType = &quot;com.apple.product-type.framework&quot;;
+		};
+/* End PBXNativeTarget section */
+
+/* Begin PBXProject section */
+		0867D690FE84028FC02AAC07 /* Project object */ = {
+			isa = PBXProject;
+			buildConfigurationList = 4FADC24608B4156D00ABE55E /* Build configuration list for PBXProject &quot;OgreNewt&quot; */;
+			compatibilityVersion = &quot;Xcode 2.4&quot;;
+			hasScannedForEncodings = 1;
+			mainGroup = 0867D691FE84028FC02AAC07 /* OgreNewt */;
+			productRefGroup = 034768DDFF38A45A11DB9C8B /* Products */;
+			projectDirPath = &quot;&quot;;
+			projectRoot = &quot;&quot;;
+			targets = (
+				8D07F2BC0486CC7A007CD1D0 /* OgreNewt */,
+			);
+		};
+/* End PBXProject section */
+
+/* Begin PBXResourcesBuildPhase section */
+		8D07F2BF0486CC7A007CD1D0 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				8D07F2C00486CC7A007CD1D0 /* InfoPlist.strings in Resources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXResourcesBuildPhase section */
+
+/* Begin PBXRezBuildPhase section */
+		8D07F2C50486CC7A007CD1D0 /* Rez */ = {
+			isa = PBXRezBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXRezBuildPhase section */
+
+/* Begin PBXSourcesBuildPhase section */
+		8D07F2C10486CC7A007CD1D0 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				487D45EA0F47389A00D1D69F /* OgreNewt_BasicJoints.cpp in Sources */,
+				487D45EB0F47389A00D1D69F /* OgreNewt_Body.cpp in Sources */,
+				487D45EC0F47389A00D1D69F /* OgreNewt_BodyInAABBIterator.cpp in Sources */,
+				487D45ED0F47389A00D1D69F /* OgreNewt_Collision.cpp in Sources */,
+				487D45EE0F47389A00D1D69F /* OgreNewt_CollisionPrimitives.cpp in Sources */,
+				487D45EF0F47389A00D1D69F /* OgreNewt_CollisionSerializer.cpp in Sources */,
+				487D45F00F47389A00D1D69F /* OgreNewt_ContactCallback.cpp in Sources */,
+				487D45F10F47389A00D1D69F /* OgreNewt_ContactJoint.cpp in Sources */,
+				487D45F20F47389A00D1D69F /* OgreNewt_Debugger.cpp in Sources */,
+				487D45F30F47389A00D1D69F /* OgreNewt_Joint.cpp in Sources */,
+				487D45F40F47389A00D1D69F /* OgreNewt_MaterialID.cpp in Sources */,
+				487D45F50F47389A00D1D69F /* OgreNewt_MaterialPair.cpp in Sources */,
+				487D45F60F47389A00D1D69F /* OgreNewt_PlayerController.cpp in Sources */,
+				487D45F70F47389A00D1D69F /* OgreNewt_RayCast.cpp in Sources */,
+				487D45F80F47389A00D1D69F /* OgreNewt_Tools.cpp in Sources */,
+				487D45F90F47389A00D1D69F /* OgreNewt_Vehicle.cpp in Sources */,
+				487D45FA0F47389A00D1D69F /* OgreNewt_World.cpp in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXSourcesBuildPhase section */
+
+/* Begin PBXVariantGroup section */
+		089C1666FE841158C02AAC07 /* InfoPlist.strings */ = {
+			isa = PBXVariantGroup;
+			children = (
+				089C1667FE841158C02AAC07 /* English */,
+			);
+			name = InfoPlist.strings;
+			sourceTree = &quot;&lt;group&gt;&quot;;
+		};
+/* End PBXVariantGroup section */
+
+/* Begin XCBuildConfiguration section */
+		4FADC24308B4156D00ABE55E /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = (
+					i386,
+					ppc,
+				);
+				COPY_PHASE_STRIP = NO;
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_VERSION = A;
+				GCC_DYNAMIC_NO_PIC = NO;
+				GCC_ENABLE_FIX_AND_CONTINUE = YES;
+				GCC_MODEL_TUNING = G5;
+				GCC_OPTIMIZATION_LEVEL = 0;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = &quot;&quot;;
+				HEADER_SEARCH_PATHS = (
+					/Library/Frameworks/Ogre.framework/Headers,
+					/usr/local/include,
+				);
+				INFOPLIST_FILE = Info.plist;
+				INSTALL_PATH = &quot;$(HOME)/Library/Frameworks&quot;;
+				LIBRARY_SEARCH_PATHS = (
+					/usr/local/lib,
+					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1)&quot;,
+				);
+				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = &quot;\&quot;$(SDKROOT)/usr/lib/i686-apple-darwin9/4.0.1\&quot;&quot;;
+				LIBRARY_STYLE = DYNAMIC;
+				MACH_O_TYPE = mh_dylib;
+				PRODUCT_NAME = OgreNewt;
+				SDKROOT = /Developer/SDKs/MacOSX10.5.sdk;
+				WRAPPER_EXTENSION = framework;
+				ZERO_LINK = YES;
+			};
+			name = Debug;
+		};
+		4FADC24408B4156D00ABE55E /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ARCHS = (
+					i386,
+					ppc,
+				);
+				DYLIB_COMPATIBILITY_VERSION = 1;
+				DYLIB_CURRENT_VERSION = 1;
+				FRAMEWORK_SEARCH_PATHS = &quot;/Library/Frameworks/Ogre.framework/**&quot;;
+				FRAMEWORK_VERSION = A;
+				GCC_GENERATE_DEBUGGING_SYMBOLS = NO;
+				GCC_MODEL_TUNING = G5;
+				GCC_PRECOMPILE_PREFIX_HEADER = YES;
+				GCC_PREFIX_HEADER = &quot;&quot;;
+				HEADER_SEARCH_PATHS = /usr/local/include;
+				INFOPLIST_FILE = Info.plist;
+				INSTALL_PATH = &quot;$(HOME)/Library/Frameworks&quot;;
+				LIBRARY_SEARCH_PATHS = (
+					/usr/local/lib,
+					&quot;$(LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1)&quot;,
+				);
+				LIBRARY_SEARCH_PATHS_QUOTED_FOR_TARGET_1 = &quot;\&quot;$(SDKROOT)/usr/lib/i686-apple-darwin9/4.0.1\&quot;&quot;;
+				LIBRARY_STYLE = DYNAMIC;
+				MACH_O_TYPE = mh_dylib;
+				OTHER_LDFLAGS = (
+					&quot;-framework&quot;,
+					Ogre,
+				);
+				PRODUCT_NAME = OgreNewt;
+				SDKROOT = /Developer/SDKs/MacOSX10.5.sdk;
+				WRAPPER_EXTENSION = framework;
+			};
+			name = Release;
+		};
+		4FADC24708B4156D00ABE55E /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = /Library/Frameworks/Ogre.framework/Headers;
+				PREBINDING = NO;
+				SDKROOT = /Developer/SDKs/MacOSX10.4u.sdk;
+			};
+			name = Debug;
+		};
+		4FADC24808B4156D00ABE55E /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				GCC_WARN_ABOUT_RETURN_TYPE = YES;
+				GCC_WARN_UNUSED_VARIABLE = YES;
+				HEADER_SEARCH_PATHS = (
+					/usr/local/include,
+					/Library/Frameworks/Ogre.framework/Headers,
+				);
+				PREBINDING = NO;
+				SCAN_ALL_SOURCE_FILES_FOR_INCLUDES = YES;
+				SDKROOT = /Developer/SDKs/MacOSX10.4u.sdk;
+			};
+			name = Release;
+		};
+/* End XCBuildConfiguration section */
+
+/* Begin XCConfigurationList section */
+		4FADC24208B4156D00ABE55E /* Build configuration list for PBXNativeTarget &quot;OgreNewt&quot; */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				4FADC24308B4156D00ABE55E /* Debug */,
+				4FADC24408B4156D00ABE55E /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		4FADC24608B4156D00ABE55E /* Build configuration list for PBXProject &quot;OgreNewt&quot; */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				4FADC24708B4156D00ABE55E /* Debug */,
+				4FADC24808B4156D00ABE55E /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+/* End XCConfigurationList section */
+	};
+	rootObject = 0867D690FE84028FC02AAC07 /* Project object */;
+}

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionSerializer.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionSerializer.h	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_CollisionSerializer.h	2009-02-14 21:36:25 UTC (rev 4768)
@@ -13,8 +13,6 @@
 
 
 #include &quot;OgreNewt_Prerequisites.h&quot;
-#include &quot;OgreSerializer.h&quot;
-#include &quot;OgreString.h&quot;
 
 // OgreNewt namespace.  all functions and classes use this namespace.
 namespace OgreNewt

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_Prerequisites.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_Prerequisites.h	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_Prerequisites.h	2009-02-14 21:36:25 UTC (rev 4768)
@@ -1,34 +1,40 @@
-/* 
-	OgreNewt Library
-
-	Ogre implementation of Newton Game Dynamics SDK
-
-	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
-
-		by Walaber
-
-*/
-
-
-#ifndef __INCLUDE_OGRENEWT_PREREQ__
-#define __INCLUDE_OGRENEWT_PREREQ__
-
-#include &lt;Ogre.h&gt;
-#include &lt;Newton.h&gt;
-
-#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
-#   define _CDECL _cdecl
-#   if defined( _OGRENEWT_EXPORTS ) &amp;&amp; defined( _OGRENEWT_DYNAMIC )
-#       define _OgreNewtExport __declspec( dllexport )
-#   elif defined( _OGRENEWT_DYNAMIC )
-#       define _OgreNewtExport __declspec( dllimport )
-#   else
-#       define _OgreNewtExport
-#   endif
-#else // Linux / Mac OSX etc
-#   define _OgreNewtExport
-#   define _CDECL
-#endif
-
-#endif 
-
+/* 
+	OgreNewt Library
+
+	Ogre implementation of Newton Game Dynamics SDK
+
+	OgreNewt basically has no license, you may use any or all of the library however you desire... I hope it can help you in any way.
+
+		by Walaber
+
+*/
+
+
+#ifndef __INCLUDE_OGRENEWT_PREREQ__
+#define __INCLUDE_OGRENEWT_PREREQ__
+
+#ifdef __APPLE__
+#    include &lt;Carbon/Carbon.h&gt;
+#    include &lt;Ogre/Ogre.h&gt;
+#else
+#    include &lt;Ogre.h&gt;
+#endif
+
+#include &lt;Newton.h&gt;
+
+#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
+#   define _CDECL _cdecl
+#   if defined( _OGRENEWT_EXPORTS ) &amp;&amp; defined( _OGRENEWT_DYNAMIC )
+#       define _OgreNewtExport __declspec( dllexport )
+#   elif defined( _OGRENEWT_DYNAMIC )
+#       define _OgreNewtExport __declspec( dllimport )
+#   else
+#       define _OgreNewtExport
+#   endif
+#else // Linux / Mac OSX etc
+#   define _OgreNewtExport
+#   define _CDECL
+#endif
+
+#endif 
+

Modified: dependencies/OgreNewt_ngt/inc/OgreNewt_Tools.h
===================================================================
--- dependencies/OgreNewt_ngt/inc/OgreNewt_Tools.h	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/inc/OgreNewt_Tools.h	2009-02-14 21:36:25 UTC (rev 4768)
@@ -13,8 +13,6 @@
 
 
 #include &quot;OgreNewt_Prerequisites.h&quot;
-#include &lt;OgreMovableObject.h&gt;
-#include &lt;OgreRenderable.h&gt;
 
 namespace OgreNewt
 {

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_BasicFrameListener.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_BasicFrameListener.cpp	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_BasicFrameListener.cpp	2009-02-14 21:36:25 UTC (rev 4768)
@@ -1,5 +1,6 @@
 #include &quot;OgreNewt_BasicFrameListener.h&quot;
 #include &quot;OgreNewt_Debugger.h&quot;
+#include &quot;OgreNewt_World.h&quot;
 
 namespace OgreNewt
 {

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_CollisionPrimitives.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_CollisionPrimitives.cpp	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_CollisionPrimitives.cpp	2009-02-14 21:36:25 UTC (rev 4768)
@@ -2,8 +2,6 @@
 #include &quot;OgreNewt_Tools.h&quot;
 #include &quot;OgreNewt_RayCast.h&quot;
 
-#include &quot;Ogre.h&quot;
-
 namespace OgreNewt
 {
 

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_CollisionSerializer.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_CollisionSerializer.cpp	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_CollisionSerializer.cpp	2009-02-14 21:36:25 UTC (rev 4768)
@@ -1,8 +1,6 @@
 #include &quot;OgreNewt_CollisionSerializer.h&quot;
 #include &quot;OgreNewt_Collision.h&quot;
 
-#include &quot;Ogre.h&quot;
-
 namespace OgreNewt
 {
   CollisionSerializer::CollisionSerializer()

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_RayCast.cpp	2009-02-14 21:36:25 UTC (rev 4768)
@@ -213,11 +213,18 @@
                 float matrix[16];
                 OgreNewt::Converters::QuatPosToMatrix(colori, startpt, &amp;matrix[0] );
                 mFirstContactDistance = -1;
+#ifdef __APPLE__
                 mReturnInfoListLength = 
-                        NewtonWorldConvexCast( world-&gt;getNewtonWorld(), &amp;matrix[0], (float*)&amp;endpt, col-&gt;getNewtonCollision(),
+                    NewtonWorldConvexCast( world-&gt;getNewtonWorld(), &amp;matrix[0], (float*)&amp;endpt, col-&gt;getNewtonCollision(),
                                                &amp;mFirstContactDistance, this, OgreNewt::Convexcast::newtonConvexcastPreFilter,
-                                               mReturnInfoList, mReturnInfoListSize, threadIndex);
-
+                                               mReturnInfoList, mReturnInfoListSize);
+#else
+                mReturnInfoListLength = 
+                    NewtonWorldConvexCast( world-&gt;getNewtonWorld(), &amp;matrix[0], (float*)&amp;endpt, col-&gt;getNewtonCollision(),
+                              &amp;mFirstContactDistance, this, OgreNewt::Convexcast::newtonConvexcastPreFilter,
+                              mReturnInfoList, mReturnInfoListSize, threadIndex);
+#endif
+        
                 //! TODO: that's a hack here!!
                 if( mReturnInfoListLength &gt; 0 )
                 {

Modified: dependencies/OgreNewt_ngt/src/OgreNewt_Tools.cpp
===================================================================
--- dependencies/OgreNewt_ngt/src/OgreNewt_Tools.cpp	2009-02-13 23:30:16 UTC (rev 4767)
+++ dependencies/OgreNewt_ngt/src/OgreNewt_Tools.cpp	2009-02-14 21:36:25 UTC (rev 4768)
@@ -1,738 +1,763 @@
-#include &quot;OgreNewt_Tools.h&quot;
-#include &quot;OgreNewt_World.h&quot;
-#include &quot;OgreNewt_Body.h&quot;
-#include &quot;OgreNewt_Collision.h&quot;
-#include &lt;iostream&gt;
-#include &lt;OgreFontManager.h&gt;
-
-namespace OgreNewt
-{
-
-	namespace Converters
-	{
-		
-		//! Take a Newton matrix and create a Quaternion + Position_vector
-		void MatrixToQuatPos( const float* matrix, Ogre::Quaternion&amp; quat, Ogre::Vector3 &amp;pos )
-		{
-			// this takes a matrix returned by Newton, and creates a Quaternion
-			// and position Vector3, which is more meaningful for Ogre.
-			using namespace Ogre;
-			quat = Quaternion( Matrix3(	matrix[0], matrix[4], matrix[8],
-							matrix[1], matrix[5], matrix[9],
-							matrix[2], matrix[6], matrix[10] ) );
-		
-			pos = Vector3( matrix[12], matrix[13], matrix[14] );
-		}
-
-		//! Take a Quaternion and Position Matrix and create a Newton-happy float matrix!
-		void QuatPosToMatrix( const Ogre::Quaternion&amp; quat, const Ogre::Vector3 &amp;pos, float* matrix )
-		{
-			// this takes a Quaternion and a Vector3 and creates a float array
-			// which is more meaningful to Newton.
-			using namespace Ogre;
-			Matrix3 rot;
-			Vector3 xcol, ycol, zcol;
-			
-			quat.ToRotationMatrix( rot );	// creates a 3x3 rotation matrix from the Quaternion.
-
-			xcol = rot.GetColumn(0);
-			ycol = rot.GetColumn(1);
-			zcol = rot.GetColumn(2);
-		
-			// now fill the final matrix with the appropriate data:
-			matrix[0] = xcol.x;
-			matrix[1] = xcol.y;
-			matrix[2] = xcol.z;
-			matrix[3] = 0.0f;
-		
-			matrix[4] = ycol.x;
-			matrix[5] = ycol.y;
-			matrix[6] = ycol.z;
-			matrix[7] = 0.0f;
-		
-			matrix[8] = zcol.x;
-			matrix[9] = zcol.y;
-			matrix[10] = zcol.z;
-			matrix[11] = 0.0f;
-		
-			matrix[12] = pos.x;
-			matrix[13] = pos.y;
-			matrix[14] = pos.z;
-			matrix[15] = 1.0;
-		}
-
-		void MatrixToMatrix4( const float* matrix_in, Ogre::Matrix4&amp; matrix_out )
-		{
-			// from Newton to Ogre::Matrix4
-			matrix_out = Ogre::Matrix4( matrix_in[0], matrix_in[4], matrix_in[8], matrix_in[12],
-				matrix_in[1], matrix_in[5], matrix_in[9], matrix_in[13],
-				matrix_in[2], matrix_in[6], matrix_in[10], matrix_in[14],
-				matrix_in[3], matrix_in[7], matrix_in[11], matrix_in[15] );
-		}
-
-		void Matrix4ToMatrix( const Ogre::Matrix4&amp; matrix_in, float* matrix_out )
-		{
-			// from Ogre to Newton.
-			matrix_out[0] = matrix_in[0][0];
-			matrix_out[1] = matrix_in[1][0];
-			matrix_out[2] = matrix_in[2][0];
-			matrix_out[3] = matrix_in[3][0];
-
-			matrix_out[4] = matrix_in[0][1];
-			matrix_out[5] = matrix_in[1][1];
-			matrix_out[6] = matrix_in[2][1];
-			matrix_out[7] = matrix_in[3][1];
-
-			matrix_out[8] = matrix_in[0][2];
-			matrix_out[9] = matrix_in[1][2];
-			matrix_out[10] = matrix_in[2][2];
-			matrix_out[11] = matrix_in[3][2];
-
-			matrix_out[12] = matrix_in[0][3];
-			matrix_out[13] = matrix_in[1][3];
-			matrix_out[14] = matrix_in[2][3];
-			matrix_out[15] = matrix_in[3][3];
-		}
-
-
-	} // end namespace &quot;converters&quot;
-
-	
-	namespace CollisionTools
-	{
-		//! find the point on a collision primitive closest to a global point.
-		
-		int CollisionPointDistance( const OgreNewt::World* world, const Ogre::Vector3&amp; globalpt, 
-									const OgreNewt::Collision* col, const Ogre::Quaternion&amp; colorient, const Ogre::Vector3&amp; colpos, 
-									Ogre::Vector3&amp; retpt, Ogre::Vector3&amp; retnormal, int threadIndex )
-		{
-			float matrix[16];
-			Converters::QuatPosToMatrix( colorient, colpos, matrix );
-
-			return NewtonCollisionPointDistance( world-&gt;getNewtonWorld(), &amp;globalpt.x, col-&gt;getNewtonCollision(), matrix, &amp;retpt.x, &amp;retnormal.x, threadIndex);
-		}
-		
-
-
-		
-		int CollisionClosestPoint( const OgreNewt::World* world, const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA,
-															const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB,
-															Ogre::Vector3&amp; retPosA, Ogre::Vector3&amp; retPosB, Ogre::Vector3&amp; retNorm, int threadIndex )
-		{
-			float matrixA[16];
-			float matrixB[16];
-
-			Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
-			Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
-
-			return NewtonCollisionClosestPoint( world-&gt;getNewtonWorld(), colA-&gt;getNewtonCollision(), matrixA, colB-&gt;getNewtonCollision(), matrixB,
-												&amp;retPosA.x, &amp;retPosB.x, &amp;retNorm.x, threadIndex );
-		}
-
-
-		int CollisionCollide(  const OgreNewt::World* world, int maxSize, 
-			const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA,
-			const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB,
-			Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex )
-		{
-			float matrixA[16];
-			float matrixB[16];
-
-			Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
-			Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
-
-			return NewtonCollisionCollide( world-&gt;getNewtonWorld(), maxSize, colA-&gt;getNewtonCollision(), matrixA,
-				colB-&gt;getNewtonCollision(), matrixB, &amp;retContactPts[0].x, &amp;retNormals[0].x, retPenetrations, threadIndex );
-		}
-
-
-		int CollisionCollideContinue( const OgreNewt::World* world, int maxSize, Ogre::Real timeStep,
-			const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA, const Ogre::Vector3&amp; colVelA, const Ogre::Vector3&amp; colOmegaA,
-			const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB, const Ogre::Vector3&amp; colVelB, const Ogre::Vector3&amp; colOmegaB,
-			Ogre::Real&amp; retTimeOfImpact, Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex )
-		{
-			float matrixA[16];
-			float matrixB[16];
-
-			Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
-			Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
-
-			return NewtonCollisionCollideContinue( world-&gt;getNewtonWorld(), maxSize, timeStep,
-				colA-&gt;getNewtonCollision(), matrixA, &amp;colVelA.x, &amp;colOmegaA.x, 
-				colB-&gt;getNewtonCollision(), matrixB, &amp;colVelB.x, &amp;colOmegaB.x,
-				&amp;retTimeOfImpact, &amp;retContactPts[0].x, &amp;retNormals[0].x, retPenetrations, threadIndex );
-		}
-
-
-		Ogre::Real CollisionRayCast( const OgreNewt::Collision* col, const Ogre::Vector3&amp; startPt, const Ogre::Vector3&amp; endPt, 
-			Ogre::Vector3&amp; retNorm, int&amp; retColID )
-		{
-			return NewtonCollisionRayCast( col-&gt;getNewtonCollision(), &amp;startPt.x, &amp;endPt.x, &amp;retNorm.x, &amp;retColID );
-		}
-
-		Ogre::AxisAlignedBox CollisionCalculateAABB( const OgreNewt::Collision* col, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos )
-		{
-			float matrix[16];
-			Converters::QuatPosToMatrix( orient, pos, matrix );
-			Ogre::Vector3 min, max;
-
-			NewtonCollisionCalculateAABB( col-&gt;getNewtonCollision(), matrix, &amp;min.x, &amp;max.x );
-
-			return Ogre::AxisAlignedBox( min, max );
-		}
-
-	}	// end namespace &quot;CollisionTools&quot;
-
-	namespace Springs
-	{
-
-		Ogre::Real calculateSpringDamperAcceleration(Ogre::Real deltaTime, Ogre::Real springK,
-						Ogre::Real stretchDistance, Ogre::Real springDamping, Ogre::Real dampVelocity )
-		{
-			return NewtonCalculateSpringDamperAcceleration( deltaTime, springK, stretchDistance, springDamping, dampVelocity );
-		}
-	}
-
-
-        namespace OgreAddons
-        {
-            /**
-             * File: MovableText.cpp
-             *
-             * description: This create create a billboarding object that display a text.
-             * 
-             * @author  2003 by cTh see <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">gavocanov at rambler.ru</A>
-             * @update  2006 by barraq see <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">nospam at barraquand.com</A>
-            */
-
-
-            using namespace Ogre;
-
-            const unsigned short POS_TEX_BINDING = 0;
-            const unsigned short COLOUR_BINDING = 1;
-
-            MovableText::MovableText(const String &amp;name, const String &amp;caption, const String &amp;fontName, Real charHeight, const ColourValue &amp;color)
-                : mpCam(NULL)
-                  , mpWin(NULL)
-                  , mpFont(NULL)
-                  , mName(name)
-                  , mCaption(caption)
-                  , mFontName(fontName)
-                  , mCharHeight(charHeight)
-                  , mColor(color)
-                  , mType(&quot;MovableText&quot;)
-                  , mTimeUntilNextToggle(0)
-                  , mSpaceWidth(0)
-                  , mUpdateColors(true)
-                  , mOnTop(false)
-                  , mHorizontalAlignment(H_LEFT)
-                  , mVerticalAlignment(V_BELOW)
-                  , mGlobalTranslation(0.0)
-                  , mLocalTranslation(0.0)
-            {
-                if (name == &quot;&quot;)
-                    throw Exception(Exception::ERR_INVALIDPARAMS, &quot;Trying to create MovableText without name&quot;, &quot;MovableText::MovableText&quot;);
-
-                if (caption == &quot;&quot;)
-                    throw Exception(Exception::ERR_INVALIDPARAMS, &quot;Trying to create MovableText without caption&quot;, &quot;MovableText::MovableText&quot;);
-
-                mRenderOp.vertexData = NULL;
-                this-&gt;setFontName(mFontName);
-                this-&gt;_setupGeometry();
-            }
-
-            MovableText::~MovableText()
-            {
-                if (mRenderOp.vertexData)
-                    delete mRenderOp.vertexData;
-                // May cause crashing... check this and comment if it does
-                if (!mpMaterial.isNull())
-                    MaterialManager::getSingletonPtr()-&gt;remove(mpMaterial-&gt;getName());
-            }
-
-            void MovableText::setFontName(const String &amp;fontName)
-            {
-                if((Ogre::MaterialManager::getSingletonPtr()-&gt;resourceExists(mName + &quot;Material&quot;))) 
-                { 
-                    Ogre::MaterialManager::getSingleton().remove(mName + &quot;Material&quot;); 
-                }
-
-                if (mFontName != fontName || mpMaterial.isNull() || !mpFont)
-                {
-                    mFontName = fontName;
-                    mpFont = (Font *)FontManager::getSingleton().getByName(mFontName).getPointer();
-                    if (!mpFont)
-                        throw Exception(Exception::ERR_ITEM_NOT_FOUND, &quot;Could not find font &quot; + fontName, &quot;MovableText::setFontName&quot;);
-
-                    mpFont-&gt;load();
-                    if (!mpMaterial.isNull())
-                    {
-                        MaterialManager::getSingletonPtr()-&gt;remove(mpMaterial-&gt;getName());
-                        mpMaterial.setNull();
-                    }
-
-                    mpMaterial = mpFont-&gt;getMaterial()-&gt;clone(mName + &quot;Material&quot;);
-                    if (!mpMaterial-&gt;isLoaded())
-                        mpMaterial-&gt;load();
-
-                    mpMaterial-&gt;setDepthCheckEnabled(!mOnTop);
-                    mpMaterial-&gt;setDepthBias(1.0,1.0);
-                    mpMaterial-&gt;setDepthWriteEnabled(mOnTop);
-                    mpMaterial-&gt;setLightingEnabled(false);
-                    mNeedUpdate = true;
-                }
-            }
-
-            void MovableText::setCaption(const String &amp;caption)
-            {
-                if (caption != mCaption)
-                {
-                    mCaption = caption;
-                    mNeedUpdate = true;
-                }
-            }
-
-            void MovableText::setColor(const ColourValue &amp;color)
-            {
-                if (color != mColor)
-                {
-                    mColor = color;
-                    mUpdateColors = true;
-                }
-            }
-
-            void MovableText::setCharacterHeight(Real height)
-            {
-                if (height != mCharHeight)
-                {
-                    mCharHeight = height;
-                    mNeedUpdate = true;
-                }
-            }
-
-            void MovableText::setSpaceWidth(Real width)
-            {
-                if (width != mSpaceWidth)
-                {
-                    mSpaceWidth = width;
-                    mNeedUpdate = true;
-                }
-            }
-
-            void MovableText::setTextAlignment(const HorizontalAlignment&amp; horizontalAlignment, const VerticalAlignment&amp; verticalAlignment)
-            {
-                if(mHorizontalAlignment != horizontalAlignment)
-                {
-                    mHorizontalAlignment = horizontalAlignment;
-                    mNeedUpdate = true;
-                }
-                if(mVerticalAlignment != verticalAlignment)
-                {
-                    mVerticalAlignment = verticalAlignment;
-                    mNeedUpdate = true;
-                }
-            }
-
-            void MovableText::setGlobalTranslation( Vector3 trans )
-            {
-                mGlobalTranslation = trans;
-            }
-
-            void MovableText::setLocalTranslation( Vector3 trans )
-            {
-                mLocalTranslation = trans;
-            }
-
-            void MovableText::showOnTop(bool show)
-            {
-                if( mOnTop != show &amp;&amp; !mpMaterial.isNull() )
-                {
-                    mOnTop = show;
-                    mpMaterial-&gt;setDepthBias(1.0,1.0);
-                    mpMaterial-&gt;setDepthCheckEnabled(!mOnTop);
-                    mpMaterial-&gt;setDepthWriteEnabled(mOnTop);
-                }
-            }
-
-            void MovableText::_setupGeometry()
-            {
-                assert(mpFont);
-                assert(!mpMaterial.isNull());
-
-                unsigned int vertexCount = static_cast&lt;unsigned int&gt;(mCaption.size() * 6);
-
-                if (mRenderOp.vertexData)
-                {
-                    // Removed this test as it causes problems when replacing a caption
-                    // of the same size: replacing &quot;Hello&quot; with &quot;hello&quot;
-                    // as well as when changing the text alignment
-                    //if (mRenderOp.vertexData-&gt;vertexCount != vertexCount)
-                    {
-                        delete mRenderOp.vertexData;
-                        mRenderOp.vertexData = NULL;
-                        mUpdateColors = true;
-                    }
-                }
-
-                if (!mRenderOp.vertexData)
-                    mRenderOp.vertexData = new VertexData();
-
-                mRenderOp.indexData = 0;
-                mRenderOp.vertexData-&gt;vertexStart = 0;
-                mRenderOp.vertexData-&gt;vertexCount = vertexCount;
-                mRenderOp.operationType = RenderOperation::OT_TRIANGLE_LIST; 
-                mRenderOp.useIndexes = false; 
-
-                VertexDeclaration  *decl = mRenderOp.vertexData-&gt;vertexDeclaration;
-                VertexBufferBinding   *bind = mRenderOp.vertexData-&gt;vertexBufferBinding;
-                size_t offset = 0;
-
-                // create/bind positions/tex.ccord. buffer
-                if (!decl-&gt;findElementBySemantic(VES_POSITION))
-                    decl-&gt;addElement(POS_TEX_BINDING, offset, VET_FLOAT3, VES_POSITION);
-
-                offset += VertexElement::getTypeSize(VET_FLOAT3);
-
-                if (!decl-&gt;findElementBySemantic(VES_TEXTURE_COORDINATES))
-                    decl-&gt;addElement(POS_TEX_BINDING, offset, Ogre::VET_FLOAT2, Ogre::VES_TEXTURE_COORDINATES, 0);
-
-                HardwareVertexBufferSharedPtr ptbuf = HardwareBufferManager::getSingleton().createVertexBuffer(decl-&gt;getVertexSize(POS_TEX_BINDING),
-                        mRenderOp.vertexData-&gt;vertexCount,
-                        HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY);
-                bind-&gt;setBinding(POS_TEX_BINDING, ptbuf);
-
-                // Colours - store these in a separate buffer because they change less often
-                if (!decl-&gt;findElementBySemantic(VES_DIFFUSE))
-                    decl-&gt;addElement(COLOUR_BINDING, 0, VET_COLOUR, VES_DIFFUSE);
-
-                HardwareVertexBufferSharedPtr cbuf = HardwareBufferManager::getSingleton().createVertexBuffer(decl-&gt;getVertexSize(COLOUR_BINDING),
-                        mRenderOp.vertexData-&gt;vertexCount,
-                        HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY);
-                bind-&gt;setBinding(COLOUR_BINDING, cbuf);
-
-                size_t charlen = mCaption.size();
-                float *pPCBuff = static_cast&lt;float*&gt;(ptbuf-&gt;lock(HardwareBuffer::HBL_DISCARD));
-
-                float largestWidth = 0;
-                float left = 0 * 2.0 - 1.0;
-                float top = -((0 * 2.0) - 1.0);
-
-                Real spaceWidth = mSpaceWidth;
-                // Derive space width from a capital A
-                if (spaceWidth == 0)
-                    spaceWidth = mpFont-&gt;getGlyphAspectRatio('A') * mCharHeight * 2.0;
-
-                // for calculation of AABB
-                Ogre::Vector3 min, max, currPos;
-                Ogre::Real maxSquaredRadius;
-                bool first = true;
-
-                // Use iterator
-                String::iterator i, iend;
-                iend = mCaption.end();
-                bool newLine = true;
-                Real len = 0.0f;
-
-                Real verticalOffset = 0;
-                switch (mVerticalAlignment)
-                {
-                    case MovableText::V_ABOVE:
-                        verticalOffset = mCharHeight;
-                        break;
-                    case MovableText::V_CENTER:
-                        verticalOffset = 0.5*mCharHeight;
-                        break;
-                    case MovableText::V_BELOW:
-                        verticalOffset = 0;
-                        break;
-                }
-                // Raise the first line of the caption
-                top += verticalOffset;
-                for (i = mCaption.begin(); i != iend; ++i)
-                {
-                    if (*i == '\n')
-                        top += verticalOffset * 2.0;
-                }
-
-                for (i = mCaption.begin(); i != iend; ++i)
-                {
-                    if (newLine)
-                    {
-                        len = 0.0f;
-                        for (String::iterator j = i; j != iend &amp;&amp; *j != '\n'; j++)
-                        {
-                            if (*j == ' ')
-                                len += spaceWidth;
-                            else 
-                                len += mpFont-&gt;getGlyphAspectRatio(*j) * mCharHeight * 2.0;
-                        }
-                        newLine = false;
-                    }
-
-                    if (*i == '\n')
-                    {
-                        left = 0 * 2.0 - 1.0;
-                        top -= mCharHeight * 2.0;
-                        newLine = true;
-                        continue;
-                    }
-
-                    if (*i == ' ')
-                    {
-                        // Just leave a gap, no tris
-                        left += spaceWidth;
-                        // Also reduce tri count
-                        mRenderOp.vertexData-&gt;vertexCount -= 6;
-                        continue;
-                    }
-
-                    Real horiz_height = mpFont-&gt;getGlyphAspectRatio(*i);
-                    Real u1, u2, v1, v2; 
-                    Ogre::Font::UVRect utmp;
-                    utmp = mpFont-&gt;getGlyphTexCoords(*i);
-                    u1 = utmp.left;
-                    u2 = utmp.right;
-                    v1 = utmp.top;
-                    v2 = utmp.bottom;
-
-                    // each vert is (x, y, z, u, v)
-                    //-------------------------------------------------------------------------------------
-                    // First tri
-                    //
-                    // Upper left
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        *pPCBuff++ = left;
-                    else
-                        *pPCBuff++ = left - (len / 2);
-                    *pPCBuff++ = top;
-                    *pPCBuff++ = -1.0;
-                    *pPCBuff++ = u1;
-                    *pPCBuff++ = v1;
-
-                    // Deal with bounds
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        currPos = Ogre::Vector3(left, top, -1.0);
-                    else
-                        currPos = Ogre::Vector3(left - (len / 2), top, -1.0);
-                    if (first)
-                    {
-                        min = max = currPos;
-                        maxSquaredRadius = currPos.squaredLength();
-                        first = false;
-                    }
-                    else
-                    {
-                        min.makeFloor(currPos);
-                        max.makeCeil(currPos);
-                        maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
-                    }
-
-                    top -= mCharHeight * 2.0;
-
-                    // Bottom left
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        *pPCBuff++ = left;
-                    else
-                        *pPCBuff++ = left - (len / 2);
-                    *pPCBuff++ = top;
-                    *pPCBuff++ = -1.0;
-                    *pPCBuff++ = u1;
-                    *pPCBuff++ = v2;
-
-                    // Deal with bounds
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        currPos = Ogre::Vector3(left, top, -1.0);
-                    else
-                        currPos = Ogre::Vector3(left - (len / 2), top, -1.0);
-                    min.makeFloor(currPos);
-                    max.makeCeil(currPos);
-                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
-
-                    top += mCharHeight * 2.0;
-                    left += horiz_height * mCharHeight * 2.0;
-
-                    // Top right
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        *pPCBuff++ = left;
-                    else
-                        *pPCBuff++ = left - (len / 2);
-                    *pPCBuff++ = top;
-                    *pPCBuff++ = -1.0;
-                    *pPCBuff++ = u2;
-                    *pPCBuff++ = v1;
-                    //-------------------------------------------------------------------------------------
-
-                    // Deal with bounds
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        currPos = Ogre::Vector3(left, top, -1.0);
-                    else
-                        currPos = Ogre::Vector3(left - (len / 2), top, -1.0);
-                    min.makeFloor(currPos);
-                    max.makeCeil(currPos);
-                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
-
-                    //-------------------------------------------------------------------------------------
-                    // Second tri
-                    //
-                    // Top right (again)
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        *pPCBuff++ = left;
-                    else
-                        *pPCBuff++ = left - (len / 2);
-                    *pPCBuff++ = top;
-                    *pPCBuff++ = -1.0;
-                    *pPCBuff++ = u2;
-                    *pPCBuff++ = v1;
-
-                    currPos = Ogre::Vector3(left, top, -1.0);
-                    min.makeFloor(currPos);
-                    max.makeCeil(currPos);
-                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
-
-                    top -= mCharHeight * 2.0;
-                    left -= horiz_height  * mCharHeight * 2.0;
-
-                    // Bottom left (again)
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        *pPCBuff++ = left;
-                    else
-                        *pPCBuff++ = left - (len / 2);
-                    *pPCBuff++ = top;
-                    *pPCBuff++ = -1.0;
-                    *pPCBuff++ = u1;
-                    *pPCBuff++ = v2;
-
-                    currPos = Ogre::Vector3(left, top, -1.0);
-                    min.makeFloor(currPos);
-                    max.makeCeil(currPos);
-                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
-
-                    left += horiz_height  * mCharHeight * 2.0;
-
-                    // Bottom right
-                    if(mHorizontalAlignment == MovableText::H_LEFT)
-                        *pPCBuff++ = left;
-                    else
-                        *pPCBuff++ = left - (len / 2);
-                    *pPCBuff++ = top;
-                    *pPCBuff++ = -1.0;
-                    *pPCBuff++ = u2;
-                    *pPCBuff++ = v2;
-                    //-------------------------------------------------------------------------------------
-
-                    currPos = Ogre::Vector3(left, top, -1.0);
-                    min.makeFloor(currPos);
-                    max.makeCeil(currPos);
-                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
-
-                    // Go back up with top
-                    top += mCharHeight * 2.0;
-
-                    float currentWidth = (left + 1)/2 - 0;
-                    if (currentWidth &gt; largestWidth)
-                        largestWidth = currentWidth;
-                }
-
-                // Unlock vertex buffer
-                ptbuf-&gt;unlock();
-
-                // update AABB/Sphere radius
-                mAABB = Ogre::AxisAlignedBox(min, max);
-                mRadius = Ogre::Math::Sqrt(maxSquaredRadius);
-
-                if (mUpdateColors)
-                    this-&gt;_updateColors();
-
-                mNeedUpdate = false;
-            }
-
-            void MovableText::_updateColors(void)
-            {
-                assert(mpFont);
-                assert(!mpMaterial.isNull());
-
-                // Convert to system-specific
-                RGBA color;
-                Root::getSingleton().convertColourValue(mColor, &amp;color);
-                HardwareVertexBufferSharedPtr vbuf = mRenderOp.vertexData-&gt;vertexBufferBinding-&gt;getBuffer(COLOUR_BINDING);
-                RGBA *pDest = static_cast&lt;RGBA*&gt;(vbuf-&gt;lock(HardwareBuffer::HBL_DISCARD));
-                for (int i = 0; i &lt; (int)mRenderOp.vertexData-&gt;vertexCount; ++i)
-                    *pDest++ = color;
-                vbuf-&gt;unlock();
-                mUpdateColors = false;
-            }
-
-            const Quaternion&amp; MovableText::getWorldOrientation(void) const
-            {
-                assert(mpCam);
-                return const_cast&lt;Quaternion&amp;&gt;(mpCam-&gt;getDerivedOrientation());
-            }
-
-            const Vector3&amp; MovableText::getWorldPosition(void) const
-            {
-                assert(mParentNode);
-                return mParentNode-&gt;_getDerivedPosition();
-            }
-
-            void MovableText::getWorldTransforms(Matrix4 *xform) const 
-            {
-                if (this-&gt;isVisible() &amp;&amp; mpCam)
-                {
-                    Matrix3 rot3x3, scale3x3 = Matrix3::IDENTITY;
-
-                    // store rotation in a matrix
-                    mpCam-&gt;getDerivedOrientation().ToRotationMatrix(rot3x3);
-
-                    // parent node position
-                    Vector3 ppos = mParentNode-&gt;_getDerivedPosition() + Vector3::UNIT_Y*mGlobalTranslation;
-                    ppos += rot3x3*mLocalTranslation;
-
-                    // apply scale
-                    scale3x3[0][0] = mParentNode-&gt;_getDerivedScale().x / 2;
-                    scale3x3[1][1] = mParentNode-&gt;_getDerivedScale().y / 2;
-                    scale3x3[2][2] = mParentNode-&gt;_getDerivedScale().z / 2;
-
-                    // apply all transforms to xform       
-                    *xform = (rot3x3 * scale3x3);
-                    xform-&gt;setTrans(ppos);
-                }
-            }
-
-            void MovableText::getRenderOperation(RenderOperation &amp;op)
-            {
-                if (this-&gt;isVisible())
-                {
-                    if (mNeedUpdate)
-                        this-&gt;_setupGeometry();
-                    if (mUpdateColors)
-                        this-&gt;_updateColors();
-                    op = mRenderOp;
-                }
-            }
-
-            void MovableText::_notifyCurrentCamera(Camera *cam)
-            {
-                mpCam = cam;
-            }
-
-            void MovableText::_updateRenderQueue(RenderQueue* queue)
-            {
-                if (this-&gt;isVisible())
-                {
-                    if (mNeedUpdate)
-                        this-&gt;_setupGeometry();
-                    if (mUpdateColors)
-                        this-&gt;_updateColors();
-
-                    queue-&gt;addRenderable(this, mRenderQueueID, OGRE_RENDERABLE_DEFAULT_PRIORITY);
-                    //queue-&gt;addRenderable(this, mRenderQueueID, RENDER_QUEUE_SKIES_LATE);
-                }
-            }
-
-            void MovableText::visitRenderables(Renderable::Visitor* visitor, bool debugRenderables)
-            {
-                visitor-&gt;visit(this, 0, debugRenderables);
-            }
-        }
-}
-
+#include &quot;OgreNewt_Tools.h&quot;
+#include &quot;OgreNewt_World.h&quot;
+#include &quot;OgreNewt_Body.h&quot;
+#include &quot;OgreNewt_Collision.h&quot;
+#include &lt;iostream&gt;
+
+#ifdef __APPLE__
+#    include &lt;Ogre/OgreFontManager.h&gt;
+#else
+#    include &lt;OgreFontManager.h&gt;
+#endif
+
+namespace OgreNewt
+{
+
+	namespace Converters
+	{
+		
+		//! Take a Newton matrix and create a Quaternion + Position_vector
+		void MatrixToQuatPos( const float* matrix, Ogre::Quaternion&amp; quat, Ogre::Vector3 &amp;pos )
+		{
+			// this takes a matrix returned by Newton, and creates a Quaternion
+			// and position Vector3, which is more meaningful for Ogre.
+			using namespace Ogre;
+			quat = Quaternion( Matrix3(	matrix[0], matrix[4], matrix[8],
+							matrix[1], matrix[5], matrix[9],
+							matrix[2], matrix[6], matrix[10] ) );
+		
+			pos = Vector3( matrix[12], matrix[13], matrix[14] );
+		}
+
+		//! Take a Quaternion and Position Matrix and create a Newton-happy float matrix!
+		void QuatPosToMatrix( const Ogre::Quaternion&amp; quat, const Ogre::Vector3 &amp;pos, float* matrix )
+		{
+			// this takes a Quaternion and a Vector3 and creates a float array
+			// which is more meaningful to Newton.
+			using namespace Ogre;
+			Matrix3 rot;
+			Vector3 xcol, ycol, zcol;
+			
+			quat.ToRotationMatrix( rot );	// creates a 3x3 rotation matrix from the Quaternion.
+
+			xcol = rot.GetColumn(0);
+			ycol = rot.GetColumn(1);
+			zcol = rot.GetColumn(2);
+		
+			// now fill the final matrix with the appropriate data:
+			matrix[0] = xcol.x;
+			matrix[1] = xcol.y;
+			matrix[2] = xcol.z;
+			matrix[3] = 0.0f;
+		
+			matrix[4] = ycol.x;
+			matrix[5] = ycol.y;
+			matrix[6] = ycol.z;
+			matrix[7] = 0.0f;
+		
+			matrix[8] = zcol.x;
+			matrix[9] = zcol.y;
+			matrix[10] = zcol.z;
+			matrix[11] = 0.0f;
+		
+			matrix[12] = pos.x;
+			matrix[13] = pos.y;
+			matrix[14] = pos.z;
+			matrix[15] = 1.0;
+		}
+
+		void MatrixToMatrix4( const float* matrix_in, Ogre::Matrix4&amp; matrix_out )
+		{
+			// from Newton to Ogre::Matrix4
+			matrix_out = Ogre::Matrix4( matrix_in[0], matrix_in[4], matrix_in[8], matrix_in[12],
+				matrix_in[1], matrix_in[5], matrix_in[9], matrix_in[13],
+				matrix_in[2], matrix_in[6], matrix_in[10], matrix_in[14],
+				matrix_in[3], matrix_in[7], matrix_in[11], matrix_in[15] );
+		}
+
+		void Matrix4ToMatrix( const Ogre::Matrix4&amp; matrix_in, float* matrix_out )
+		{
+			// from Ogre to Newton.
+			matrix_out[0] = matrix_in[0][0];
+			matrix_out[1] = matrix_in[1][0];
+			matrix_out[2] = matrix_in[2][0];
+			matrix_out[3] = matrix_in[3][0];
+
+			matrix_out[4] = matrix_in[0][1];
+			matrix_out[5] = matrix_in[1][1];
+			matrix_out[6] = matrix_in[2][1];
+			matrix_out[7] = matrix_in[3][1];
+
+			matrix_out[8] = matrix_in[0][2];
+			matrix_out[9] = matrix_in[1][2];
+			matrix_out[10] = matrix_in[2][2];
+			matrix_out[11] = matrix_in[3][2];
+
+			matrix_out[12] = matrix_in[0][3];
+			matrix_out[13] = matrix_in[1][3];
+			matrix_out[14] = matrix_in[2][3];
+			matrix_out[15] = matrix_in[3][3];
+		}
+
+
+	} // end namespace &quot;converters&quot;
+
+	
+	namespace CollisionTools
+	{
+		//! find the point on a collision primitive closest to a global point.
+		
+		int CollisionPointDistance( const OgreNewt::World* world, const Ogre::Vector3&amp; globalpt, 
+									const OgreNewt::Collision* col, const Ogre::Quaternion&amp; colorient, const Ogre::Vector3&amp; colpos, 
+									Ogre::Vector3&amp; retpt, Ogre::Vector3&amp; retnormal, int threadIndex )
+		{
+			float matrix[16];
+			Converters::QuatPosToMatrix( colorient, colpos, matrix );
+#ifdef __APPLE__
+			return NewtonCollisionPointDistance( world-&gt;getNewtonWorld(), &amp;globalpt.x, col-&gt;getNewtonCollision(), matrix, &amp;retpt.x, &amp;retnormal.x);
+#else
+			return NewtonCollisionPointDistance( world-&gt;getNewtonWorld(), &amp;globalpt.x, col-&gt;getNewtonCollision(), matrix, &amp;retpt.x, &amp;retnormal.x, threadIndex);
+#endif
+		}
+		
+
+
+		
+		int CollisionClosestPoint( const OgreNewt::World* world, const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA,
+															const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB,
+															Ogre::Vector3&amp; retPosA, Ogre::Vector3&amp; retPosB, Ogre::Vector3&amp; retNorm, int threadIndex )
+		{
+			float matrixA[16];
+			float matrixB[16];
+
+			Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
+			Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
+
+#ifdef __APPLE__
+			return NewtonCollisionClosestPoint( world-&gt;getNewtonWorld(), colA-&gt;getNewtonCollision(), matrixA, colB-&gt;getNewtonCollision(), matrixB,
+												&amp;retPosA.x, &amp;retPosB.x, &amp;retNorm.x);
+#else
+			return NewtonCollisionClosestPoint( world-&gt;getNewtonWorld(), colA-&gt;getNewtonCollision(), matrixA, colB-&gt;getNewtonCollision(), matrixB,
+                                               &amp;retPosA.x, &amp;retPosB.x, &amp;retNorm.x, threadIndex );
+#endif
+		}
+
+
+		int CollisionCollide(  const OgreNewt::World* world, int maxSize, 
+			const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA,
+			const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB,
+			Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex )
+		{
+			float matrixA[16];
+			float matrixB[16];
+
+			Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
+			Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
+
+#ifdef __APPLE__
+			return NewtonCollisionCollide( world-&gt;getNewtonWorld(), maxSize, colA-&gt;getNewtonCollision(), matrixA,
+				colB-&gt;getNewtonCollision(), matrixB, &amp;retContactPts[0].x, &amp;retNormals[0].x, retPenetrations);
+#else
+			return NewtonCollisionCollide( world-&gt;getNewtonWorld(), maxSize, colA-&gt;getNewtonCollision(), matrixA,
+                                          colB-&gt;getNewtonCollision(), matrixB, &amp;retContactPts[0].x, &amp;retNormals[0].x, retPenetrations, threadIndex );
+#endif
+		}
+
+
+		int CollisionCollideContinue( const OgreNewt::World* world, int maxSize, Ogre::Real timeStep,
+			const OgreNewt::Collision* colA, const Ogre::Quaternion&amp; colOrientA, const Ogre::Vector3&amp; colPosA, const Ogre::Vector3&amp; colVelA, const Ogre::Vector3&amp; colOmegaA,
+			const OgreNewt::Collision* colB, const Ogre::Quaternion&amp; colOrientB, const Ogre::Vector3&amp; colPosB, const Ogre::Vector3&amp; colVelB, const Ogre::Vector3&amp; colOmegaB,
+			Ogre::Real&amp; retTimeOfImpact, Ogre::Vector3* retContactPts, Ogre::Vector3* retNormals, Ogre::Real* retPenetrations, int threadIndex )
+		{
+			float matrixA[16];
+			float matrixB[16];
+
+			Converters::QuatPosToMatrix( colOrientA, colPosA, matrixA );
+			Converters::QuatPosToMatrix( colOrientB, colPosB, matrixB );
+
+#ifdef __APPLE__
+			return NewtonCollisionCollideContinue( world-&gt;getNewtonWorld(), maxSize, timeStep,
+                                                  colA-&gt;getNewtonCollision(), matrixA, &amp;colVelA.x, &amp;colOmegaA.x, 
+                                                  colB-&gt;getNewtonCollision(), matrixB, &amp;colVelB.x, &amp;colOmegaB.x,
+                                                  &amp;retTimeOfImpact, &amp;retContactPts[0].x, &amp;retNormals[0].x, retPenetrations);
+#else
+			return NewtonCollisionCollideContinue( world-&gt;getNewtonWorld(), maxSize, timeStep,
+                                                  colA-&gt;getNewtonCollision(), matrixA, &amp;colVelA.x, &amp;colOmegaA.x, 
+                                                  colB-&gt;getNewtonCollision(), matrixB, &amp;colVelB.x, &amp;colOmegaB.x,
+                                                  &amp;retTimeOfImpact, &amp;retContactPts[0].x, &amp;retNormals[0].x, retPenetrations, threadIndex );
+#endif
+		}
+
+
+		Ogre::Real CollisionRayCast( const OgreNewt::Collision* col, const Ogre::Vector3&amp; startPt, const Ogre::Vector3&amp; endPt, 
+			Ogre::Vector3&amp; retNorm, int&amp; retColID )
+		{
+			return NewtonCollisionRayCast( col-&gt;getNewtonCollision(), &amp;startPt.x, &amp;endPt.x, &amp;retNorm.x, &amp;retColID );
+		}
+
+		Ogre::AxisAlignedBox CollisionCalculateAABB( const OgreNewt::Collision* col, const Ogre::Quaternion&amp; orient, const Ogre::Vector3&amp; pos )
+		{
+			float matrix[16];
+			Converters::QuatPosToMatrix( orient, pos, matrix );
+			Ogre::Vector3 min, max;
+
+			NewtonCollisionCalculateAABB( col-&gt;getNewtonCollision(), matrix, &amp;min.x, &amp;max.x );
+
+			return Ogre::AxisAlignedBox( min, max );
+		}
+
+	}	// end namespace &quot;CollisionTools&quot;
+
+	namespace Springs
+	{
+
+		Ogre::Real calculateSpringDamperAcceleration(Ogre::Real deltaTime, Ogre::Real springK,
+						Ogre::Real stretchDistance, Ogre::Real springDamping, Ogre::Real dampVelocity )
+		{
+			return NewtonCalculateSpringDamperAcceleration( deltaTime, springK, stretchDistance, springDamping, dampVelocity );
+		}
+	}
+
+
+        namespace OgreAddons
+        {
+            /**
+             * File: MovableText.cpp
+             *
+             * description: This create create a billboarding object that display a text.
+             * 
+             * @author  2003 by cTh see <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">gavocanov at rambler.ru</A>
+             * @update  2006 by barraq see <A HREF="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">nospam at barraquand.com</A>
+            */
+
+
+            using namespace Ogre;
+
+            const unsigned short POS_TEX_BINDING = 0;
+            const unsigned short COLOUR_BINDING = 1;
+
+            MovableText::MovableText(const String &amp;name, const String &amp;caption, const String &amp;fontName, Real charHeight, const ColourValue &amp;color)
+                : mpCam(NULL)
+                  , mpWin(NULL)
+                  , mpFont(NULL)
+                  , mName(name)
+                  , mCaption(caption)
+                  , mFontName(fontName)
+                  , mCharHeight(charHeight)
+                  , mColor(color)
+                  , mType(&quot;MovableText&quot;)
+                  , mTimeUntilNextToggle(0)
+                  , mSpaceWidth(0)
+                  , mUpdateColors(true)
+                  , mOnTop(false)
+                  , mHorizontalAlignment(H_LEFT)
+                  , mVerticalAlignment(V_BELOW)
+                  , mGlobalTranslation(0.0)
+                  , mLocalTranslation(0.0)
+            {
+                if (name == &quot;&quot;)
+                    throw Exception(Exception::ERR_INVALIDPARAMS, &quot;Trying to create MovableText without name&quot;, &quot;MovableText::MovableText&quot;);
+
+                if (caption == &quot;&quot;)
+                    throw Exception(Exception::ERR_INVALIDPARAMS, &quot;Trying to create MovableText without caption&quot;, &quot;MovableText::MovableText&quot;);
+
+                mRenderOp.vertexData = NULL;
+                this-&gt;setFontName(mFontName);
+                this-&gt;_setupGeometry();
+            }
+
+            MovableText::~MovableText()
+            {
+                if (mRenderOp.vertexData)
+                    delete mRenderOp.vertexData;
+                // May cause crashing... check this and comment if it does
+                if (!mpMaterial.isNull())
+                    MaterialManager::getSingletonPtr()-&gt;remove(mpMaterial-&gt;getName());
+            }
+
+            void MovableText::setFontName(const String &amp;fontName)
+            {
+                if((Ogre::MaterialManager::getSingletonPtr()-&gt;resourceExists(mName + &quot;Material&quot;))) 
+                { 
+                    Ogre::MaterialManager::getSingleton().remove(mName + &quot;Material&quot;); 
+                }
+
+                if (mFontName != fontName || mpMaterial.isNull() || !mpFont)
+                {
+                    mFontName = fontName;
+                    mpFont = (Font *)FontManager::getSingleton().getByName(mFontName).getPointer();
+                    if (!mpFont)
+                        throw Exception(Exception::ERR_ITEM_NOT_FOUND, &quot;Could not find font &quot; + fontName, &quot;MovableText::setFontName&quot;);
+
+                    mpFont-&gt;load();
+                    if (!mpMaterial.isNull())
+                    {
+                        MaterialManager::getSingletonPtr()-&gt;remove(mpMaterial-&gt;getName());
+                        mpMaterial.setNull();
+                    }
+
+                    mpMaterial = mpFont-&gt;getMaterial()-&gt;clone(mName + &quot;Material&quot;);
+                    if (!mpMaterial-&gt;isLoaded())
+                        mpMaterial-&gt;load();
+
+                    mpMaterial-&gt;setDepthCheckEnabled(!mOnTop);
+                    mpMaterial-&gt;setDepthBias(1.0,1.0);
+                    mpMaterial-&gt;setDepthWriteEnabled(mOnTop);
+                    mpMaterial-&gt;setLightingEnabled(false);
+                    mNeedUpdate = true;
+                }
+            }
+
+            void MovableText::setCaption(const String &amp;caption)
+            {
+                if (caption != mCaption)
+                {
+                    mCaption = caption;
+                    mNeedUpdate = true;
+                }
+            }
+
+            void MovableText::setColor(const ColourValue &amp;color)
+            {
+                if (color != mColor)
+                {
+                    mColor = color;
+                    mUpdateColors = true;
+                }
+            }
+
+            void MovableText::setCharacterHeight(Real height)
+            {
+                if (height != mCharHeight)
+                {
+                    mCharHeight = height;
+                    mNeedUpdate = true;
+                }
+            }
+
+            void MovableText::setSpaceWidth(Real width)
+            {
+                if (width != mSpaceWidth)
+                {
+                    mSpaceWidth = width;
+                    mNeedUpdate = true;
+                }
+            }
+
+            void MovableText::setTextAlignment(const HorizontalAlignment&amp; horizontalAlignment, const VerticalAlignment&amp; verticalAlignment)
+            {
+                if(mHorizontalAlignment != horizontalAlignment)
+                {
+                    mHorizontalAlignment = horizontalAlignment;
+                    mNeedUpdate = true;
+                }
+                if(mVerticalAlignment != verticalAlignment)
+                {
+                    mVerticalAlignment = verticalAlignment;
+                    mNeedUpdate = true;
+                }
+            }
+
+            void MovableText::setGlobalTranslation( Vector3 trans )
+            {
+                mGlobalTranslation = trans;
+            }
+
+            void MovableText::setLocalTranslation( Vector3 trans )
+            {
+                mLocalTranslation = trans;
+            }
+
+            void MovableText::showOnTop(bool show)
+            {
+                if( mOnTop != show &amp;&amp; !mpMaterial.isNull() )
+                {
+                    mOnTop = show;
+                    mpMaterial-&gt;setDepthBias(1.0,1.0);
+                    mpMaterial-&gt;setDepthCheckEnabled(!mOnTop);
+                    mpMaterial-&gt;setDepthWriteEnabled(mOnTop);
+                }
+            }
+
+            void MovableText::_setupGeometry()
+            {
+                assert(mpFont);
+                assert(!mpMaterial.isNull());
+
+                unsigned int vertexCount = static_cast&lt;unsigned int&gt;(mCaption.size() * 6);
+
+                if (mRenderOp.vertexData)
+                {
+                    // Removed this test as it causes problems when replacing a caption
+                    // of the same size: replacing &quot;Hello&quot; with &quot;hello&quot;
+                    // as well as when changing the text alignment
+                    //if (mRenderOp.vertexData-&gt;vertexCount != vertexCount)
+                    {
+                        delete mRenderOp.vertexData;
+                        mRenderOp.vertexData = NULL;
+                        mUpdateColors = true;
+                    }
+                }
+
+                if (!mRenderOp.vertexData)
+                    mRenderOp.vertexData = new VertexData();
+
+                mRenderOp.indexData = 0;
+                mRenderOp.vertexData-&gt;vertexStart = 0;
+                mRenderOp.vertexData-&gt;vertexCount = vertexCount;
+                mRenderOp.operationType = RenderOperation::OT_TRIANGLE_LIST; 
+                mRenderOp.useIndexes = false; 
+
+                VertexDeclaration  *decl = mRenderOp.vertexData-&gt;vertexDeclaration;
+                VertexBufferBinding   *bind = mRenderOp.vertexData-&gt;vertexBufferBinding;
+                size_t offset = 0;
+
+                // create/bind positions/tex.ccord. buffer
+                if (!decl-&gt;findElementBySemantic(VES_POSITION))
+                    decl-&gt;addElement(POS_TEX_BINDING, offset, VET_FLOAT3, VES_POSITION);
+
+                offset += VertexElement::getTypeSize(VET_FLOAT3);
+
+                if (!decl-&gt;findElementBySemantic(VES_TEXTURE_COORDINATES))
+                    decl-&gt;addElement(POS_TEX_BINDING, offset, Ogre::VET_FLOAT2, Ogre::VES_TEXTURE_COORDINATES, 0);
+
+                HardwareVertexBufferSharedPtr ptbuf = HardwareBufferManager::getSingleton().createVertexBuffer(decl-&gt;getVertexSize(POS_TEX_BINDING),
+                        mRenderOp.vertexData-&gt;vertexCount,
+                        HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY);
+                bind-&gt;setBinding(POS_TEX_BINDING, ptbuf);
+
+                // Colours - store these in a separate buffer because they change less often
+                if (!decl-&gt;findElementBySemantic(VES_DIFFUSE))
+                    decl-&gt;addElement(COLOUR_BINDING, 0, VET_COLOUR, VES_DIFFUSE);
+
+                HardwareVertexBufferSharedPtr cbuf = HardwareBufferManager::getSingleton().createVertexBuffer(decl-&gt;getVertexSize(COLOUR_BINDING),
+                        mRenderOp.vertexData-&gt;vertexCount,
+                        HardwareBuffer::HBU_DYNAMIC_WRITE_ONLY);
+                bind-&gt;setBinding(COLOUR_BINDING, cbuf);
+
+                size_t charlen = mCaption.size();
+                float *pPCBuff = static_cast&lt;float*&gt;(ptbuf-&gt;lock(HardwareBuffer::HBL_DISCARD));
+
+                float largestWidth = 0;
+                float left = 0 * 2.0 - 1.0;
+                float top = -((0 * 2.0) - 1.0);
+
+                Real spaceWidth = mSpaceWidth;
+                // Derive space width from a capital A
+                if (spaceWidth == 0)
+                    spaceWidth = mpFont-&gt;getGlyphAspectRatio('A') * mCharHeight * 2.0;
+
+                // for calculation of AABB
+                Ogre::Vector3 min, max, currPos;
+                Ogre::Real maxSquaredRadius;
+                bool first = true;
+
+                // Use iterator
+                String::iterator i, iend;
+                iend = mCaption.end();
+                bool newLine = true;
+                Real len = 0.0f;
+
+                Real verticalOffset = 0;
+                switch (mVerticalAlignment)
+                {
+                    case MovableText::V_ABOVE:
+                        verticalOffset = mCharHeight;
+                        break;
+                    case MovableText::V_CENTER:
+                        verticalOffset = 0.5*mCharHeight;
+                        break;
+                    case MovableText::V_BELOW:
+                        verticalOffset = 0;
+                        break;
+                }
+                // Raise the first line of the caption
+                top += verticalOffset;
+                for (i = mCaption.begin(); i != iend; ++i)
+                {
+                    if (*i == '\n')
+                        top += verticalOffset * 2.0;
+                }
+
+                for (i = mCaption.begin(); i != iend; ++i)
+                {
+                    if (newLine)
+                    {
+                        len = 0.0f;
+                        for (String::iterator j = i; j != iend &amp;&amp; *j != '\n'; j++)
+                        {
+                            if (*j == ' ')
+                                len += spaceWidth;
+                            else 
+                                len += mpFont-&gt;getGlyphAspectRatio(*j) * mCharHeight * 2.0;
+                        }
+                        newLine = false;
+                    }
+
+                    if (*i == '\n')
+                    {
+                        left = 0 * 2.0 - 1.0;
+                        top -= mCharHeight * 2.0;
+                        newLine = true;
+                        continue;
+                    }
+
+                    if (*i == ' ')
+                    {
+                        // Just leave a gap, no tris
+                        left += spaceWidth;
+                        // Also reduce tri count
+                        mRenderOp.vertexData-&gt;vertexCount -= 6;
+                        continue;
+                    }
+
+                    Real horiz_height = mpFont-&gt;getGlyphAspectRatio(*i);
+                    Real u1, u2, v1, v2; 
+                    Ogre::Font::UVRect utmp;
+                    utmp = mpFont-&gt;getGlyphTexCoords(*i);
+                    u1 = utmp.left;
+                    u2 = utmp.right;
+                    v1 = utmp.top;
+                    v2 = utmp.bottom;
+
+                    // each vert is (x, y, z, u, v)
+                    //-------------------------------------------------------------------------------------
+                    // First tri
+                    //
+                    // Upper left
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        *pPCBuff++ = left;
+                    else
+                        *pPCBuff++ = left - (len / 2);
+                    *pPCBuff++ = top;
+                    *pPCBuff++ = -1.0;
+                    *pPCBuff++ = u1;
+                    *pPCBuff++ = v1;
+
+                    // Deal with bounds
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        currPos = Ogre::Vector3(left, top, -1.0);
+                    else
+                        currPos = Ogre::Vector3(left - (len / 2), top, -1.0);
+                    if (first)
+                    {
+                        min = max = currPos;
+                        maxSquaredRadius = currPos.squaredLength();
+                        first = false;
+                    }
+                    else
+                    {
+                        min.makeFloor(currPos);
+                        max.makeCeil(currPos);
+                        maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
+                    }
+
+                    top -= mCharHeight * 2.0;
+
+                    // Bottom left
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        *pPCBuff++ = left;
+                    else
+                        *pPCBuff++ = left - (len / 2);
+                    *pPCBuff++ = top;
+                    *pPCBuff++ = -1.0;
+                    *pPCBuff++ = u1;
+                    *pPCBuff++ = v2;
+
+                    // Deal with bounds
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        currPos = Ogre::Vector3(left, top, -1.0);
+                    else
+                        currPos = Ogre::Vector3(left - (len / 2), top, -1.0);
+                    min.makeFloor(currPos);
+                    max.makeCeil(currPos);
+                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
+
+                    top += mCharHeight * 2.0;
+                    left += horiz_height * mCharHeight * 2.0;
+
+                    // Top right
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        *pPCBuff++ = left;
+                    else
+                        *pPCBuff++ = left - (len / 2);
+                    *pPCBuff++ = top;
+                    *pPCBuff++ = -1.0;
+                    *pPCBuff++ = u2;
+                    *pPCBuff++ = v1;
+                    //-------------------------------------------------------------------------------------
+
+                    // Deal with bounds
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        currPos = Ogre::Vector3(left, top, -1.0);
+                    else
+                        currPos = Ogre::Vector3(left - (len / 2), top, -1.0);
+                    min.makeFloor(currPos);
+                    max.makeCeil(currPos);
+                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
+
+                    //-------------------------------------------------------------------------------------
+                    // Second tri
+                    //
+                    // Top right (again)
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        *pPCBuff++ = left;
+                    else
+                        *pPCBuff++ = left - (len / 2);
+                    *pPCBuff++ = top;
+                    *pPCBuff++ = -1.0;
+                    *pPCBuff++ = u2;
+                    *pPCBuff++ = v1;
+
+                    currPos = Ogre::Vector3(left, top, -1.0);
+                    min.makeFloor(currPos);
+                    max.makeCeil(currPos);
+                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
+
+                    top -= mCharHeight * 2.0;
+                    left -= horiz_height  * mCharHeight * 2.0;
+
+                    // Bottom left (again)
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        *pPCBuff++ = left;
+                    else
+                        *pPCBuff++ = left - (len / 2);
+                    *pPCBuff++ = top;
+                    *pPCBuff++ = -1.0;
+                    *pPCBuff++ = u1;
+                    *pPCBuff++ = v2;
+
+                    currPos = Ogre::Vector3(left, top, -1.0);
+                    min.makeFloor(currPos);
+                    max.makeCeil(currPos);
+                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
+
+                    left += horiz_height  * mCharHeight * 2.0;
+
+                    // Bottom right
+                    if(mHorizontalAlignment == MovableText::H_LEFT)
+                        *pPCBuff++ = left;
+                    else
+                        *pPCBuff++ = left - (len / 2);
+                    *pPCBuff++ = top;
+                    *pPCBuff++ = -1.0;
+                    *pPCBuff++ = u2;
+                    *pPCBuff++ = v2;
+                    //-------------------------------------------------------------------------------------
+
+                    currPos = Ogre::Vector3(left, top, -1.0);
+                    min.makeFloor(currPos);
+                    max.makeCeil(currPos);
+                    maxSquaredRadius = std::max(maxSquaredRadius, currPos.squaredLength());
+
+                    // Go back up with top
+                    top += mCharHeight * 2.0;
+
+                    float currentWidth = (left + 1)/2 - 0;
+                    if (currentWidth &gt; largestWidth)
+                        largestWidth = currentWidth;
+                }
+
+                // Unlock vertex buffer
+                ptbuf-&gt;unlock();
+
+                // update AABB/Sphere radius
+                mAABB = Ogre::AxisAlignedBox(min, max);
+                mRadius = Ogre::Math::Sqrt(maxSquaredRadius);
+
+                if (mUpdateColors)
+                    this-&gt;_updateColors();
+
+                mNeedUpdate = false;
+            }
+
+            void MovableText::_updateColors(void)
+            {
+                assert(mpFont);
+                assert(!mpMaterial.isNull());
+
+                // Convert to system-specific
+                RGBA color;
+                Root::getSingleton().convertColourValue(mColor, &amp;color);
+                HardwareVertexBufferSharedPtr vbuf = mRenderOp.vertexData-&gt;vertexBufferBinding-&gt;getBuffer(COLOUR_BINDING);
+                RGBA *pDest = static_cast&lt;RGBA*&gt;(vbuf-&gt;lock(HardwareBuffer::HBL_DISCARD));
+                for (int i = 0; i &lt; (int)mRenderOp.vertexData-&gt;vertexCount; ++i)
+                    *pDest++ = color;
+                vbuf-&gt;unlock();
+                mUpdateColors = false;
+            }
+
+            const Quaternion&amp; MovableText::getWorldOrientation(void) const
+            {
+                assert(mpCam);
+                return const_cast&lt;Quaternion&amp;&gt;(mpCam-&gt;getDerivedOrientation());
+            }
+
+            const Vector3&amp; MovableText::getWorldPosition(void) const
+            {
+                assert(mParentNode);
+                return mParentNode-&gt;_getDerivedPosition();
+            }
+
+            void MovableText::getWorldTransforms(Matrix4 *xform) const 
+            {
+                if (this-&gt;isVisible() &amp;&amp; mpCam)
+                {
+                    Matrix3 rot3x3, scale3x3 = Matrix3::IDENTITY;
+
+                    // store rotation in a matrix
+                    mpCam-&gt;getDerivedOrientation().ToRotationMatrix(rot3x3);
+
+                    // parent node position
+                    Vector3 ppos = mParentNode-&gt;_getDerivedPosition() + Vector3::UNIT_Y*mGlobalTranslation;
+                    ppos += rot3x3*mLocalTranslation;
+
+                    // apply scale
+                    scale3x3[0][0] = mParentNode-&gt;_getDerivedScale().x / 2;
+                    scale3x3[1][1] = mParentNode-&gt;_getDerivedScale().y / 2;
+                    scale3x3[2][2] = mParentNode-&gt;_getDerivedScale().z / 2;
+
+                    // apply all transforms to xform       
+                    *xform = (rot3x3 * scale3x3);
+                    xform-&gt;setTrans(ppos);
+                }
+            }
+
+            void MovableText::getRenderOperation(RenderOperation &amp;op)
+            {
+                if (this-&gt;isVisible())
+                {
+                    if (mNeedUpdate)
+                        this-&gt;_setupGeometry();
+                    if (mUpdateColors)
+                        this-&gt;_updateColors();
+                    op = mRenderOp;
+                }
+            }
+
+            void MovableText::_notifyCurrentCamera(Camera *cam)
+            {
+                mpCam = cam;
+            }
+
+            void MovableText::_updateRenderQueue(RenderQueue* queue)
+            {
+                if (this-&gt;isVisible())
+                {
+                    if (mNeedUpdate)
+                        this-&gt;_setupGeometry();
+                    if (mUpdateColors)
+                        this-&gt;_updateColors();
+
+                    queue-&gt;addRenderable(this, mRenderQueueID, OGRE_RENDERABLE_DEFAULT_PRIORITY);
+                    //queue-&gt;addRenderable(this, mRenderQueueID, RENDER_QUEUE_SKIES_LATE);
+                }
+            }
+
+            void MovableText::visitRenderables(Renderable::Visitor* visitor, bool debugRenderables)
+            {
+                visitor-&gt;visit(this, 0, debugRenderables);
+            }
+        }
+}
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001824.html">[Dsa-hl-svn] r4767 - rl/trunk/engine/core/src
</A></li>
	<LI>Next message: <A HREF="001826.html">[Dsa-hl-svn] r4769 - in rl/trunk/editors/Lockenwickler: . src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1825">[ date ]</a>
              <a href="thread.html#1825">[ thread ]</a>
              <a href="subject.html#1825">[ subject ]</a>
              <a href="author.html#1825">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dsa-hl-svn">More information about the Dsa-hl-svn
mailing list</a><br>
</body></html>
